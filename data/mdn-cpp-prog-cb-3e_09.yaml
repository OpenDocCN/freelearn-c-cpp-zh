- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Robustness and Performance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健壮性和性能
- en: C++ is often the first choice when it comes to selecting an object-oriented
    programming language with performance and flexibility as key goals. Modern C++
    provides language and library features, such as rvalue references, move semantics,
    and smart pointers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择以性能和灵活性为主要目标的面向对象编程语言时，C++ 常常是首选。现代 C++ 提供了语言和库功能，例如右值引用、移动语义和智能指针。
- en: When combined with good practices for exception handling, constant correctness,
    type-safe conversions, resource allocation, and releasing, C++ enables developers
    to write better, more robust, and performant code. This chapter’s recipes address
    all of these essential topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当与良好的异常处理实践、常量正确性、类型安全转换、资源分配和释放相结合时，C++ 使开发者能够编写更好、更健壮、更高效的代码。本章的食谱涵盖了所有这些基本主题。
- en: 'This chapter includes the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下食谱：
- en: Using exceptions for error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常进行错误处理
- en: Using `noexcept` for functions that do not throw exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不抛出异常的函数使用 `noexcept`
- en: Ensuring constant correctness for a program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保程序常量正确性
- en: Creating compile-time constant expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建编译时常量表达式
- en: Creating immediate functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建即时函数
- en: Optimizing code in constant-evaluated contexts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常量评估上下文中优化代码
- en: Using virtual function calls in constant expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常量表达式中使用虚函数调用
- en: Performing correct type casts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行正确的类型转换
- en: Implementing move semantics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现移动语义
- en: Using `unique_ptr` to uniquely own a memory resource
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `unique_ptr` 独特拥有内存资源
- en: Using `shared_ptr` to share a memory resource
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `shared_ptr` 共享内存资源
- en: Consistent comparison with the operator `<=>`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `<=>` 运算符进行一致比较
- en: Comparing signed and unsigned integers safely
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地比较有符号和无符号整数
- en: We will start this chapter with a couple of recipes that deal with exceptions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，介绍一些处理异常的食谱。
- en: Using exceptions for error handling
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常进行错误处理
- en: Exceptions are responses to exceptional circumstances that can appear when a
    program is running. They enable the transfer of the control flow to another part
    of the program. Exceptions are a mechanism for simpler and more robust error handling,
    as opposed to returning error codes, which could greatly complicate and clutter
    the code. In this recipe, we will look at some key aspects related to throwing
    and handling exceptions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是程序运行时可能出现的异常情况的一种响应。它们使控制流转移到程序的另一部分。与返回错误代码相比，异常是一种更简单、更健壮的错误处理机制，后者可能会极大地复杂化和杂乱代码。在本食谱中，我们将探讨与抛出和处理异常相关的关键方面。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires you to have basic knowledge of the mechanisms of throwing
    exceptions (using the `throw` statement) and catching exceptions (using `try...catch`
    blocks). This recipe is focused on good practices around exceptions and not on
    the details of the exception mechanism in the C++ language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱要求您具备抛出异常（使用 `throw` 语句）和捕获异常（使用 `try...catch` 块）的机制的基本知识。本食谱侧重于异常周围的良好实践，而不是
    C++ 语言中异常机制的细节。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following practices to deal with exceptions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下实践来处理异常：
- en: 'Throw exceptions by value:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值抛出异常：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Catch exceptions by reference, or in most cases, by constant reference:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用捕获异常，或者在大多数情况下，通过常量引用捕获：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Order `catch` statements from the most derived class to the base class of the
    hierarchy when catching multiple exceptions from a class hierarchy:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在捕获类层次结构中的多个异常时，从最派生类到层次结构的基类按顺序排列 `catch` 语句：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use `catch(...)` to catch all exceptions, regardless of their type:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `catch(...)` 捕获所有异常，无论它们的类型如何：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use `throw;` to rethrow the current exception. This can be used to create a
    single exception-handling function for multiple exceptions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `throw;` 重新抛出当前异常。这可以用于为多个异常创建单个异常处理函数。
- en: 'Throw the exception object (for example, `throw e;`) when you want to hide
    the original location of the exception:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想隐藏异常的原始位置时，抛出异常对象（例如，`throw e;`）：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Most functions have to indicate the success or failure of their execution.
    This can be achieved in different ways. Here are several possibilities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数必须指示其执行的成败。这可以通过不同的方式实现。以下是一些可能性：
- en: 'Return an error code (with a special value for success) to indicate the specific
    reason for failure:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个错误代码（对于成功有一个特殊值）以指示失败的具体原因：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A variation of this is to return a Boolean value to only indicate success or
    failure:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种变体是只返回布尔值来仅指示成功或失败：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another alternative is to return invalid objects, null pointers, or empty `std::optional<T>`
    objects:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个替代方案是返回无效对象、空指针或空的`std::optional<T>`对象：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In any case, the return value from the functions should be checked. This can
    lead to complex, cluttered, and hard-to-read and maintain real-world code. Moreover,
    the process of checking the return value of a function is always executed, regardless
    of whether the function was successful or failed. On the other hand, exceptions
    are thrown and handled only when a function fails, which should happen more rarely
    than successful executions. This can actually lead to faster code than code that
    returns and tests error codes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，都应该检查函数的返回值。这可能导致复杂、杂乱、难以阅读和维护的现实代码。此外，检查函数返回值的过程始终执行，无论函数是成功还是失败。另一方面，只有当函数失败时才会抛出并处理异常，这应该比成功的执行更少发生。这实际上可能导致比返回并测试错误代码的代码更快。
- en: Exceptions and error codes are not mutually exclusive. Exceptions should be
    used only for transferring the control flow in exceptional situations, not for
    controlling the data flow in a program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 异常和错误代码不是互斥的。异常应该仅用于在异常情况下转移控制流，而不是用于控制程序中的数据流。
- en: Class constructors are special functions that do not return any value. They
    are supposed to construct an object, but in the case of failure, they will not
    be able to indicate this with a return value. Exceptions should be a mechanism
    that constructors use to indicate failure. Together with the **Resource Acquisition
    Is Initialization** (**RAII**) idiom, this ensures the safe acquisition and release
    of resources in all situations. On the other hand, exceptions are not allowed
    to leave a destructor. When this happens, the program abnormally terminates with
    a call to `std::terminate()`. This is the case for destructors called during stack
    unwinding, due to the occurrence of another exception. When an exception occurs,
    the stack is unwound from the point where the exception was thrown to the block
    where the exception is handled. This process involves the destruction of all local
    objects in all those stack frames.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数是特殊的函数，它们不返回任何值。它们应该构建一个对象，但在失败的情况下，它们将无法通过返回值来指示这一点。异常应该是一个构造函数用来指示失败机制的机制。与**资源获取即初始化（RAII**）惯用法一起，这确保了在所有情况下资源的安全获取和释放。另一方面，异常不允许离开析构函数。当这种情况发生时，程序会通过调用`std::terminate()`异常终止。这是在发生另一个异常时调用析构函数进行栈回溯的情况。当发生异常时，栈从抛出异常的点回溯到处理异常的块。这个过程涉及到所有这些栈帧中所有局部对象的销毁。
- en: If the destructor of an object that is being destroyed during this process throws
    an exception, another stack unwinding process should begin, which conflicts with
    the one already under way. Because of this, the program terminates abnormally.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此过程中正在销毁的对象的析构函数抛出异常，则应开始另一个栈回溯过程，这将与已经进行的过程冲突。因此，程序会异常终止。
- en: 'The rule of thumb for dealing with exceptions in constructors and destructors
    is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 处理构造函数和析构函数中的异常的规则如下：
- en: Use exceptions to indicate the errors that occur in constructors.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常来指示构造函数中发生的错误。
- en: Do not throw or let exceptions leave destructors.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在析构函数中抛出或让异常离开。
- en: 'It is possible to throw any type of exception. However, in most cases, you
    should throw temporaries and catch exceptions by constant reference. The reason
    for catching (constant) references is to avoid slicing the exception types. Let’s
    consider the following snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以抛出任何类型的异常。然而，在大多数情况下，你应该抛出临时对象，并通过常量引用捕获异常。捕获（常量）引用的原因是避免异常类型的切片。让我们考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are throwing a `simple_error` object but catch a `std::exception` object
    by value. This is the base type of `simple_error`. The *slicing* process occurs,
    the derived type information is lost, and only the `std::exception` part of the
    object is kept. Therefore, the printed message is *Unknown exception* and not
    *simple exception* as one would expect. Using a reference avoids the object slicing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抛出一个`simple_error`对象，但通过值捕获一个`std::exception`对象。这是`simple_error`的基类型。发生**切片**过程，派生类型信息丢失，只保留对象的`std::exception`部分。因此，打印的消息是*未知异常*，而不是预期的*简单异常*。使用引用可以避免对象切片。
- en: 'The following are some guidelines for exception throwing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于抛出异常的指南：
- en: Prefer throwing either standard exceptions or your own exceptions derived from
    `std::exception` or another standard exception. The reason for this is that the
    standard library provides exception classes that are intended to be the first
    choice for representing exceptions. You should use the ones that are available
    already and when these are not good enough, build your own based on the standard
    ones. The main benefits of this are consistency and helping users catch exceptions
    via the base `std::exception` class.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议抛出标准异常或从 `std::exception` 或其他标准异常派生的自定义异常。这样做的原因是标准库提供了旨在作为表示异常首选方案的异常类。你应该使用已经可用的那些，当这些不够用时，基于标准异常构建自己的异常。这样做的主要好处是一致性，并帮助用户通过基类
    `std::exception` 捕获异常。
- en: Avoid throwing exceptions of built-in types, such as integers. The reason for
    this is that numbers carry little information to the user, who must know what
    it represents, while an object can provide contextual information. For instance,
    the statement `throw 13;` tells nothing to the user, but `throw access_denied_exception{};`
    carries much more implicit information from the class name alone, and with the
    help of data members, it carries anything useful or necessary about the exceptional
    situation.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免抛出内置类型的异常，如整数。这样做的原因是数字对用户来说信息量很小，用户必须知道它代表什么，而一个对象可以提供上下文信息。例如，`throw 13;`
    对用户来说没有任何说明，但 `throw access_denied_exception{};` 仅从类名本身就携带了大量的隐含信息，借助数据成员，它还可以携带关于异常情况的有用或必要信息。
- en: When using a library or framework that provides its own exception hierarchy,
    prefer throwing exceptions from this hierarchy or your own exceptions derived
    from it, at least in the parts of the code that are tightly related to it. The
    main reason for this is to keep the code that utilizes the library APIs consistent.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用提供自己异常层次结构的库或框架时，优先抛出该层次结构中的异常或从它派生的自定义异常，至少在代码中与它紧密相关的部分。这样做的主要原因是为了保持利用库API的代码的一致性。
- en: There’s more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As mentioned in the preceding section, when you need to create your own exception
    types, derive them from one of the standard exceptions that are available, unless
    you are using a library or framework with its own exception hierarchy. The C++
    standard defines several categories of exceptions that need to be considered for
    this purpose:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你需要创建自己的异常类型时，应从可用的标准异常之一派生，除非你正在使用具有自己异常层次结构的库或框架。C++标准定义了几个需要考虑此类目的的异常类别：
- en: The `std::logic_error` represents an exception that indicates an error in the
    program logic, such as an invalid argument and an index beyond the bounds of a
    range. There are various standard-derived classes, such as `std::invalid_argument`,
    `std::out_of_range`, and `std::length_error`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::logic_error` 表示指示程序逻辑错误的异常，例如无效的参数和范围之外的索引。有各种从标准派生的类，如 `std::invalid_argument`、`std::out_of_range`
    和 `std::length_error`。'
- en: The `std::runtime_error` represents an exception that indicates an error beyond
    the scope of the program or that cannot be predicted due to various factors, including
    external ones, such as overflows and underflows or operating system errors. The
    C++ standard also provides several derived classes from `std::runtime_error`,
    including `std::overflow_error`, `std::underflow_error`, `std::system_error`,
    and `std::format_error` in C++20.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::runtime_error` 表示指示超出程序范围或由于各种因素（包括外部因素）无法预测的错误。C++标准还提供了从 `std::runtime_error`
    派生的几个类，包括 `std::overflow_error`、`std::underflow_error`、`std::system_error` 和 C++20中的
    `std::format_error`。'
- en: Exceptions prefixed with `bad_`, such as `std::bad_alloc`, `std::bad_cast`,
    and `std::bad_function_call`, represent various errors in a program, such as failure
    to allocate memory and failure to dynamically cast or make a function call.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `bad_` 为前缀的异常，例如 `std::bad_alloc`、`std::bad_cast` 和 `std::bad_function_call`，表示程序中的各种错误，如内存分配失败、动态类型转换失败或函数调用失败。
- en: The base class for all these exceptions is `std::exception`. It has a non-throwing
    virtual method called `what()` that returns a pointer to an array of characters
    representing the description of the error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些异常的基类是 `std::exception`。它有一个非抛出（non-throwing）的虚方法 `what()`，该方法返回一个指向字符数组的指针，该数组表示错误的描述。
- en: 'When you need to derive custom exceptions from a standard exception, use the
    appropriate category, such as logical or runtime error. If none of these categories
    is suitable, then you can derive directly from `std::exception`. The following
    is a list of possible solutions you can use to derive from a standard exception:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要从标准异常派生自定义异常时，使用适当的类别，例如逻辑错误或运行时错误。如果这些类别都不合适，则可以直接从`std::exception`派生。以下是从标准异常派生时可以使用的可能解决方案列表：
- en: 'If you need to derive from `std::exception`, then override the virtual method
    `what()` to provide a description of the error:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要从`std::exception`派生，则重写虚拟方法`what()`以提供错误描述：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you derive from `std::logic_error` or `std::runtime_error` and you only
    need to provide a static description that does not depend on runtime data, then
    pass the description text to the base class constructor:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您从`std::logic_error`或`std::runtime_error`派生，并且只需要提供一个不依赖于运行时数据的静态描述，则将描述文本传递给基类构造函数：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you derive from `std::logic_error` or `std::runtime_error` but the description
    message depends on runtime data, provide a constructor with parameters and use
    them to build the description message. You can either pass the description message
    to the base class constructor or return it from the overridden `what()` method:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您从`std::logic_error`或`std::runtime_error`派生，但描述消息依赖于运行时数据，则提供一个带有参数的构造函数并使用它们来构建描述消息。您可以将描述消息传递给基类构造函数或从重写的`what()`方法返回它：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For a complete list of the standard exception classes, you can visit the [https://en.cppreference.com/w/cpp/error/exception](https://en.cppreference.com/w/cpp/error/exception)
    page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看标准异常类的完整列表，您可以访问[https://en.cppreference.com/w/cpp/error/exception](https://en.cppreference.com/w/cpp/error/exception)页面。
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Chapter 8*, *Handling exceptions from thread functions*, to understand how
    to handle exceptions thrown in a worker thread from the main thread or the thread
    where it was joined'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第8章*，*处理线程函数抛出的异常*，了解如何处理从主线程或它所加入的线程抛出的工作线程中的异常'
- en: '*Using noexcept for functions that do not throw exceptions*, to see how to
    inform the compiler that a function should not throw exceptions'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`noexcept`指定不抛出异常的函数*，以了解如何通知编译器一个函数不应该抛出异常'
- en: Using noexcept for functions that do not throw exceptions
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`noexcept`指定不抛出异常的函数
- en: Exception specification is a language feature that can enable performance improvements,
    but on the other hand, when done incorrectly, it can abnormally terminate the
    program. The exception specification from C++03, which allowed you to indicate
    what types of exceptions a function could throw, was deprecated in C++11 and removed
    in C++17\. It was replaced with the C++11 `noexcept` specifier. Moreover, the
    use of the `throw()` specifier to indicate that a function throws, without indicating
    what exception types have also been deprecated in C++17 and completely removed
    in C++20\. The `noexcept` specifier only allows you to indicate that a function
    does not throw exceptions (as opposed to the old `throw` specifier, which could
    indicate the list of types a function could throw). This recipe provides information
    about the modern exception specifications in C++, as well as guidelines on when
    to use them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 异常规范是一种语言特性，可以启用性能改进，但另一方面，如果使用不当，可能会导致程序异常终止。C++03中的异常规范，允许您指示函数可以抛出哪些类型的异常，已在C++11中弃用，并在C++17中删除。它被C++11的`noexcept`指定符所取代。此外，使用`throw()`指定符来指示函数抛出，而不指示可以抛出的异常类型，已在C++17中弃用，并在C++20中完全删除。`noexcept`指定符仅允许您指示函数不抛出异常（与旧的`throw`指定符相反，旧的`throw`指定符可以指示函数可以抛出的类型列表）。本食谱提供了有关C++中现代异常规范的信息，以及何时使用它们的指南。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following constructs to specify or query exception specifications:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下构造来指定或查询异常规范：
- en: 'Use `noexcept` in a function declaration to indicate that the function is not
    throwing any exception:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数声明中使用`noexcept`来指示该函数不会抛出任何异常：
- en: '[PRE12]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use `noexcept(expr)` in a function declaration, such as template metaprogramming,
    to indicate that the function may or may not throw an exception based on a condition
    that evaluates to `bool`:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数声明中使用`noexcept(expr)`，例如模板元编程，来指示函数可能抛出或可能不抛出异常，这取决于评估为`bool`的条件：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `noexcept` operator at compile time to check whether an expression
    is declared to not throw any exception:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时使用`noexcept`运算符来检查表达式是否声明为不抛出任何异常：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As of C++17, exception specification is part of the function type, but not part
    of the function signature; it may appear as part of any function declarator. Because
    exception specification is not part of the function signature, two function signatures
    cannot differ only in the exception specification.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C++17，异常指定是函数类型的一部分，但不是函数签名的一部分；它可以作为任何函数声明的部分出现。因为异常指定不是函数签名的一部分，所以两个函数签名不能仅在异常指定上有所不同。
- en: Prior to C++17, exception specification was not part of the function type and
    could only appear as part of lambda declarators or top-level function declarators;
    they could not appear even in `typedef` or type alias declarations. Further discussions
    on exception specification refer solely to the C++17 standard.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 之前，异常指定不是函数类型的一部分，只能作为 lambda 声明或顶层函数声明的部分出现；它们甚至不能出现在 `typedef` 或类型别名声明中。关于异常指定的进一步讨论仅限于
    C++17 标准。
- en: 'There are several ways in which the process of throwing an exception can be
    specified:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常的过程可以通过几种方式来指定：
- en: If no exception specification is present, then the function could potentially
    throw exceptions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有异常指定，则函数可能抛出异常。
- en: '`noexcept(false)` is equivalent to no exception specification.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noexcept(false)` 等同于没有异常指定。'
- en: '`noexcept(true)` and `noexcept` indicate that a function does not throw any
    exception.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noexcept(true)` 和 `noexcept` 表示一个函数不会抛出任何异常。'
- en: '`throw()` was equivalent to `noexcept(true)` but was deprecated in C++17 and
    removed altogether in C++20.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`throw()` 等同于 `noexcept(true)`，但在 C++17 中被弃用，并在 C++20 中完全删除。'
- en: Using exception specifications must be done with care because if an exception
    (either thrown directly or from another function that is called) leaves a function
    marked as non-throwing, the program is terminated immediately and abnormally with
    a call to `std::terminate()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常指定必须谨慎进行，因为如果一个异常（无论是直接抛出还是从被调用的另一个函数中抛出）使一个标记为非抛出的函数结束，程序将立即以调用 `std::terminate()`
    的方式异常终止。
- en: Pointers to the functions that do not throw exceptions can be implicitly converted
    to pointers to functions that may throw exceptions, but not vice versa. On the
    other hand, if a virtual function has a non-throwing exception specification,
    this indicates that all the declarations of all the overrides must preserve this
    specification unless an overridden function is declared as deleted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不抛出异常的函数指针可以隐式转换为可能抛出异常的函数指针，但反之则不行。另一方面，如果一个虚函数具有非抛出异常指定，这表明所有重写声明的所有重写都必须保留此指定，除非重写的函数被声明为已删除。
- en: At compile time, it is possible to check whether a function is declared to be
    non-throwing or not using the operator `noexcept`. This operator takes an expression
    and returns `true` if the expression is declared as either non-throwing or `false`.
    It does not evaluate the expression it checks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，可以使用操作符 `noexcept` 来检查一个函数是否声明为非抛出。此操作符接受一个表达式，如果表达式被声明为非抛出或 `false`，则返回
    `true`。它不会评估它检查的表达式。
- en: The `noexcept` operator, along with the `noexcept` specifier, is particularly
    useful in template metaprogramming to indicate whether a function may throw exceptions
    for some types. It is also used with `static_assert` declarations to check whether
    an expression breaks the non-throwing guarantee of a function, as seen in the
    examples in the *How to do it...* section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept` 操作符，连同 `noexcept` 指定符一起，在模板元编程中特别有用，用于指示一个函数对于某些类型是否可能抛出异常。它还与 `static_assert`
    声明一起使用，以检查表达式是否违反了函数的非抛出保证，如 *如何做...* 部分的示例所示。'
- en: 'The following code provides more examples of how the `noexcept` operator works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了更多关于 `noexcept` 操作符如何工作的示例：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to note that the `noexcept` specifier does not provide compile-time
    checking for exceptions. It only represents a way for users to inform the compiler
    that a function is not expected to throw exceptions. The compiler can use this
    to enable certain optimizations. An example is the `std::vector`, which moves
    elements if their move constructor is `noexcept` and copies them otherwise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`noexcept` 指定符不提供编译时对异常的检查。它只代表用户通知编译器一个函数不期望抛出异常的一种方式。编译器可以使用这一点来启用某些优化。例如，`std::vector`
    如果其移动构造函数是 `noexcept`，则会移动元素，否则会复制它们。
- en: There’s more...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: As mentioned earlier, a function declared with the `noexcept` specifier that
    exits due to an exception causes the program to terminate abnormally. Therefore,
    the `noexcept` specifier should be used with caution. Its presence can enable
    code optimizations, which help increase performance while preserving the *strong
    exception guarantee*. An example of this is library containers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用 `noexcept` 指示符声明的函数由于异常而退出会导致程序异常终止。因此，应谨慎使用 `noexcept` 指示符。它的存在可以启用代码优化，这有助于提高性能同时保持*强异常保证*。一个例子是库容器。
- en: 'The C++ language provides several levels of exception guarantees:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言提供了几个异常保证级别：
- en: The first level, *no exception guarantees*, does not provide any guarantees.
    If an exception occurs, there is nothing to indicate whether the program is left
    in a valid state. Resources could be leaked, memory can be corrupted, and object
    invariants may be broken.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一级，*无异常保证*，不提供任何保证。如果发生异常，没有任何指示表明程序是否处于有效状态。资源可能会泄漏，内存可能会损坏，对象的不变性可能会被破坏。
- en: The *basic exception guarantee* is the simplest level of guarantee, which ensures
    that after an exception is thrown, objects are left in a consistent and usable
    state, no resource leaks occur, and invariants are preserved.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本异常保证*是保证的最简单级别，它确保在抛出异常后，对象处于一致和可用的状态，没有资源泄漏发生，且不变性得到保留。'
- en: The *strong exception guarantee* specifies that either an operation is completed
    successfully, or that it is completed with an exception that leaves the program
    in the same state it was in before the operation started. This ensures commit-or-rollback
    semantics.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*强异常保证*指定操作要么成功完成，要么以抛出异常的方式完成，该异常使程序处于操作开始之前的状态。这确保了提交或回滚语义。'
- en: The *no-throw exception guarantee* is actually the strongest of them all and
    specifies that an operation is guaranteed to not throw any exception and to complete
    successfully.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无抛出异常保证*实际上是其中最强烈的，它指定操作保证不会抛出任何异常并成功完成。'
- en: Many standard containers provide some of their operations with a strong exception
    guarantee. An example is vector’s `push_back()` method. This method could be optimized
    by using the move constructor or move assignment operator instead of the copy
    constructor or copy assignment operator of the vector’s element type. However,
    in order to preserve its strong exception guarantee, this can only be done if
    the move constructor or assignment operator does not throw exceptions. If either
    does, then the copy constructor or the assignment operator must be used instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准容器为其一些操作提供了强异常保证。例如，vector 的 `push_back()` 方法。可以通过使用移动构造函数或移动赋值运算符而不是向量元素类型的复制构造函数或复制赋值运算符来优化此方法。然而，为了保持其强异常保证，这只能在移动构造函数或赋值运算符不抛出异常的情况下进行。如果任一抛出异常，则必须使用复制构造函数或赋值运算符。
- en: The `std::move_if_noexcept()` utility function does this if the move constructor
    of its type argument is marked with `noexcept`. The ability to indicate that move
    constructors or move assignment operators do not throw exceptions is probably
    the most important scenario where `noexcept` is used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其类型参数的移动构造函数带有 `noexcept` 标记，`std::move_if_noexcept()` 实用函数会这样做。能够表明移动构造函数或移动赋值运算符不会抛出异常可能是使用
    `noexcept` 的最重要的场景之一。
- en: 'Consider the following rules for the exception specification:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下异常指定规则：
- en: If a function could potentially throw an exception, then do not use any exception
    specifier.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数可能抛出异常，则不要使用任何异常指定符。
- en: Mark only those functions with `noexcept` that are guaranteed not to throw an
    exception.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅标记那些保证不会抛出异常的函数。
- en: Mark only those functions with `noexcept(expression)` that could potentially
    throw exceptions based on a condition.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅标记那些可能基于条件抛出异常的带有 `noexcept(expression)` 的函数。
- en: These rules are important because, as already noted previously, throwing an
    exception from a `noexcept` function will immediately terminate the program with
    a call to `std::terminate()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则很重要，因为，如前所述，从 `noexcept` 函数抛出异常将立即通过调用 `std::terminate()` 终止程序。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using exceptions for error handling*, to explore the best practices for using
    exceptions in the C++ language'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用异常进行错误处理*，以探索在 C++ 语言中使用异常的最佳实践'
- en: Ensuring constant correctness for a program
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保程序的正确性保持恒定。
- en: Although there is no formal definition, constant correctness means objects that
    are not supposed to be modified (are immutable) remain unmodified. As a developer,
    you can enforce this by using the `const` keyword for declaring parameters, variables,
    and member functions. In this recipe, we will explore the benefits of constant
    correctness and how to achieve it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有正式的定义，但常量正确性意味着不应该被修改的对象（是不可变的）保持不变。作为开发者，您可以通过使用 `const` 关键字来声明参数、变量和成员函数来强制执行这一点。在本食谱中，我们将探讨常量正确性的好处以及如何实现它。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To ensure constant correctness for a program, you should always declare the
    following as constants:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保程序具有常量正确性，您应该始终将以下内容声明为常量：
- en: 'Parameters to functions that are not supposed to be modified within the function:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数不应该在函数内部被修改：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Class data members that do not change:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变的类数据成员：
- en: '[PRE17]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Class member functions that do not modify the object state, as seen from the
    outside:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部看，不修改对象状态的类成员函数：
- en: '[PRE18]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Function locals whose values do not change throughout their lifetime:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其整个生命周期中值不改变的函数局部变量：
- en: '[PRE19]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'References that should be bound to a temporary (an rvalue) in order to extend
    the lifetime of the temporary to the lifetime of the (constant) reference:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该绑定到临时（一个右值）以扩展临时寿命到（常量）引用寿命的引用：
- en: '[PRE20]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Declaring objects and member functions as constant has several important benefits:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象和成员函数声明为常量具有几个重要的好处：
- en: You prevent both accidental and intentional changes of the object, which, in
    some cases, can result in incorrect program behavior.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您防止了对象意外和故意的更改，这在某些情况下可能导致程序行为不正确。
- en: You enable the compiler to perform better optimizations.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您使编译器能够执行更好的优化。
- en: You document the semantics of the code for other users.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您为其他用户记录代码的语义。
- en: Constant correctness is not a matter of personal style but a core principle
    that should guide C++ development.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 常量正确性不是一个个人风格的问题，而是一个应该指导C++开发的核心理念。
- en: Unfortunately, the importance of constant correctness has not been, and is still
    not, stressed enough in books, C++ communities, and working environments. But
    the rule of thumb is that everything that is not supposed to change should be
    declared as constant. This should be done all the time and not only at later stages
    of development, when you might need to clean up and refactor the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，常量正确性的重要性在书籍、C++ 社区和工作环境中尚未得到，并且仍然没有得到足够的强调。但经验法则是，所有不应该改变的内容都应该声明为常量。这应该始终如此，而不仅仅是在开发的后期阶段，当您可能需要清理和重构代码时。
- en: 'When you declare a parameter or variable as constant, you can either put the
    `const` keyword before the type (`const T c`) or after the type (`T const c`).
    These two are equivalent, but regardless of which of the two styles you use, the
    reading of the declaration must be done from the right-hand side. `const T c`
    is read as *c is a T that is constant* and `T const c` as *c is a constant T*.
    This gets a little bit more complicated with pointers. The following table presents
    various pointer declarations and their meanings:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将参数或变量声明为常量时，您可以将 `const` 关键字放在类型之前（`const T c`）或之后（`T const c`）。这两种方式是等效的，但无论您使用哪种风格，对声明的读取必须从右侧开始。`const
    T c` 读取为 *c 是一个常量的 T*，而 `T const c` 读取为 *c 是一个常量 T*。当涉及到指针时，这会变得稍微复杂一些。以下表格展示了各种指针声明及其含义：
- en: '| **Expression** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **描述** |'
- en: '| `T* p` | `p` is a non-constant pointer to a non-constant `T`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `T* p` | `p` 是一个指向非常量 `T` 的非常量指针。 |'
- en: '| `const T* p` | `p` is a non-constant pointer to a `T` that is constant. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `const T* p` | `p` 是一个指向常量 `T` 的非常量指针。 |'
- en: '| `T const * p` | `p` is a non-constant pointer to a constant `T` (same as
    the prior point). |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `T const * p` | `p` 是一个指向常量 `T` 的非常量指针（与前面的点相同）。 |'
- en: '| `const T * const p` | `p` is a constant pointer to a `T` that is constant.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `const T * const p` | `p` 是一个指向常量 `T` 的常量指针。 |'
- en: '| `T const * const p` | `p` is a constant pointer to a constant `T` (same as
    the prior point). |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `T const * const p` | `p` 是一个指向常量 `T` 的常量指针（与前面的点相同）。 |'
- en: '| `T** p` | `p` is a non-constant pointer to a non-constant pointer to a non-constant
    `T`. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `T** p` | `p` 是一个指向非常量指针的非常量指针，该指针指向非常量 `T`。 |'
- en: '| `const T** p` | `p` is a non-constant pointer to a non-constant pointer to
    a constant `T`. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `const T** p` | `p` 是一个指向非常量指针的非常量指针，该指针指向常量 `T`。 |'
- en: '| `T const ** p` | Same as `const T** p`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `T const ** p` | 与 `const T** p` 相同。 |'
- en: '| `const T* const * p` | `p` is a non-constant pointer to a constant pointer,
    which is a constant `T`. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `const T* const * p` | `p` 是一个指向常量指针的非常量指针，该指针是一个常量 `T`。|'
- en: '| `T const * const * p` | Same as `const T* const * p`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `T const * const * p` | 与 `const T* const * p` 相同。|'
- en: 'Table 9.1: Example of pointer declarations and their meaning'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1：指针声明及其含义示例
- en: Placing the `const` keyword after the type is more natural because it is consistent
    with the direction the syntax is interpreted, from right to left. For this reason,
    all the examples in this book use this style.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `const` 关键字放在类型之后更自然，因为它与语法解释的方向一致，即从右到左。因此，本书中的所有示例都使用这种风格。
- en: 'When it comes to references, the situation is similar: `const T & c` and `T
    const & c` are equivalent, which means *c is a reference to a constant T*. However,
    `T const & const c`, which would mean that *c is a constant reference to a constant
    T*, does not make sense because references—aliases of a variable—are implicitly
    constant in the sense that they cannot be modified to represent an alias to another
    variable.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到引用时，情况类似：`const T & c` 和 `T const & c` 是等价的，这意味着 *c 是指向常量 T 的引用*。然而，`T const
    & const c`，这意味着 *c 是指向常量 T 的常量引用*，是没有意义的，因为引用——变量的别名——在隐式上是常量的，它们不能被修改来表示指向另一个变量的别名。
- en: 'A non-constant pointer to a non-constant object, that is, `T*`, can be implicitly
    converted to a non-constant pointer to a constant object, `T const *`. However,
    `T**` cannot be implicitly converted to `T const **` (which is the same with `const
    T**`). This is because this could lead to constant objects being modified through
    a pointer to a non-constant object, as shown in the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指向非常量对象的非常量指针，即 `T*`，可以隐式转换为指向常量对象的非常量指针，`T const *`。然而，`T**` 不能隐式转换为 `T const
    **`（这与 `const T**` 相同）。这是因为这可能导致通过指向非常量对象的指针修改常量对象，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If an object is constant, only the constant functions of its class can be invoked.
    However, declaring a member function as constant does not mean that the function
    can only be called on constant objects; it could also mean that the function does
    not modify the state of the object, as seen from the outside. This is a key aspect,
    but it is usually misunderstood. A class has an internal state that it can expose
    to its clients through its public interface.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象是常量，则只能调用其类的常量函数。然而，将成员函数声明为常量并不意味着该函数只能对常量对象进行调用；它也可能意味着该函数不会修改对象的状态，从外部看。这是一个关键方面，但通常被误解。一个类有一个内部状态，它可以通过其公共接口向其客户端公开。
- en: However, not all the internal states might be exposed, and what is visible from
    the public interface might not have a direct representation in the internal state.
    (If you model order lines and have the item quantity and item selling price fields
    in the internal representation, then you might have a public method that exposes
    the order line amount by multiplying the quantity by the price.) Therefore, the
    state of an object, as visible from its public interface, is a logical state.
    Defining a method as constant is a statement that ensures the function does not
    alter the logical state. However, the compiler prevents you from modifying data
    members using such methods. To avoid this problem, data members that are supposed
    to be modified from constant methods should be declared `mutable`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有内部状态都可能被公开，从公共接口可见的内容可能没有在内部状态中的直接表示。（如果你对订单行进行建模，并在内部表示中具有项目数量和项目销售价格字段，那么你可能有一个公开的方法，通过乘以数量和价格来公开订单行金额。）因此，从其公共接口可见的对象状态是一个逻辑状态。将方法定义为常量是一个确保函数不改变逻辑状态的声明。然而，编译器阻止你使用此类方法修改数据成员。为了避免这个问题，应该从常量方法中修改的数据成员应声明为
    `mutable`。
- en: 'In the following example, `computation` is a class with the `compute()` method,
    which performs a long-running computation operation. Because it does not affect
    the logical state of the object, this function is declared constant. However,
    to avoid computing the result of the same input again, the computed values are
    stored in a cache. To be able to modify the cache from the constant function,
    it is declared `mutable`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`computation` 是一个具有 `compute()` 方法的类，它执行长时间运行的计算操作。因为它不影响对象的逻辑状态，所以这个函数被声明为常量。然而，为了避免对相同输入再次计算结果，计算出的值被存储在缓存中。为了能够在常量函数中修改缓存，它被声明为
    `mutable`：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A similar situation is represented by the following class, which implements
    a thread-safe container. Access to shared internal data is protected with `mutex`.
    The class provides methods such as adding and removing values, and also methods
    such as `contains()`, which indicate whether an item exists in the container.
    Because this member function is not intended to modify the logical state of the
    object, it is declared constant. However, access to the shared internal state
    must be protected with the mutex. In order to lock and unlock the mutex, both
    mutable operations (that modify the state of the object) and the mutex must be
    declared `mutable`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类表示了类似的情况，它实现了一个线程安全的容器。对共享内部数据的访问通过`mutex`进行保护。该类提供了添加和删除值的方法，以及如`contains()`这样的方法，指示项目是否存在于容器中。因为这个成员函数不打算修改对象的逻辑状态，所以它被声明为常量。但是，访问共享内部状态必须通过互斥锁进行保护。为了锁定和解锁互斥锁，必须将修改对象状态的
    mutable 操作和互斥锁都声明为`mutable`：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `mutable` specifier allows us to modify the class member on which it was
    used, even if the containing object is declared `const`. This is the case of the
    `mt` member of the `std::mutex` type, which is modified even within the `contains()`
    method, which is declared `const`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable`指定符允许我们修改使用它的类成员，即使包含的对象被声明为`const`。这是`std::mutex`类型的`mt`成员的情况，即使在声明为`const`的`contains()`方法中也会被修改。'
- en: 'Sometimes, a method or an operator is overloaded to have both constant and
    non-constant versions. This is often the case with the subscript operator or methods
    that provide direct access to the internal state. The reason for this is that
    the method is supposed to be available for both constant and non-constant objects.
    The behavior should be different, though: for non-constant objects, the method
    should allow the client to modify the data it provides access to, but for constant
    objects, it should not. Therefore, the non-constant subscript operator returns
    a reference to a non-constant object, and the constant subscript operator returns
    a reference to a constant object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个方法或运算符会被重载以同时具有常量和非常量版本。这种情况通常出现在下标运算符或提供直接访问内部状态的方法中。这样做的原因是，该方法应该对常量和非常量对象都可用。尽管行为应该不同：对于非常量对象，该方法应允许客户端修改它提供访问的数据，但对于常量对象，则不应修改。因此，非常量下标运算符返回对非常量对象的引用，而常量下标运算符返回对常量对象的引用：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It should be noted that, if a member function is constant, even if an object
    is constant, the data that’s returned by this member function may not be constant.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，如果成员函数是常量，即使对象是常量，该成员函数返回的数据可能不是常量。
- en: An important use case for the use of `const` is to define references to temporary
    objects, as shown in the last bullet in the *How to do it…* section. A temporary
    is an rvalue and a non-`const` lvalue reference cannot be bound to an rvalue.
    However, it is possible by making the lvalue reference `const`. This has the effect
    of extending the lifetime of the temporary object to the lifetime of the constant
    reference. However, this only works for stack-based references but not for references
    that are members of objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`的一个重要用途是定义对临时对象的引用，如*如何做…*部分最后一条所述。临时对象是一个右值，非`const`左值引用不能绑定到右值。然而，通过将左值引用变为`const`，这是可能的。这会使临时对象的生存期延长到常量引用的生存期。但是，这仅适用于基于堆栈的引用，不适用于对象成员的引用。'
- en: There’s more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `const` qualifier of an object can be removed with a `const_cast` conversion,
    but this should only be used when you know that the object was not declared constant.
    You can read more about this in the *Performing correct type casts* recipe.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`const_cast`转换来移除对象的`const`限定符，但只有在你知道该对象没有被声明为常量时才应使用它。你可以在*执行正确的类型转换*菜谱中了解更多关于此内容。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建编译时常量表达式*，了解`constexpr`指定符以及如何定义可以在编译时评估的变量和函数'
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建即时函数*，了解C++20的`consteval`指定符，它用于定义保证在编译时评估的函数'
- en: '*Performing correct type casts*, to learn about the best practices for performing
    correct casts in the C++ language'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行正确的类型转换*，了解在 C++ 语言中执行正确转换的最佳实践'
- en: Creating compile-time constant expressions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建编译时常量表达式
- en: The possibility to evaluate expressions at compile time improves runtime execution
    because there is less code to run and the compiler can perform additional optimizations.
    Compile-time constants can be not only literals (such as a number or string),
    but also the result of a function’s execution. If all the input values of a function
    (regardless of whether they are arguments, locals, or global variables) are known
    at compile time, the compiler can execute the function and have the result available
    at compile time. This is what generalized the constant expressions that were introduced
    in C++11, which were relaxed in C++14 and even further in C++20\. The keyword
    `constexpr` (short for *constant expression*) can be used to declare compile-time
    constant objects and functions. We have seen this in several examples in the previous
    chapters. Now, it’s time to learn how it actually works.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时评估表达式的可能性提高了运行时执行效率，因为要运行的代码更少，编译器可以执行额外的优化。编译时常量不仅可以是文本（如数字或字符串），还可以是函数执行的结果。如果函数的所有输入值（无论它们是参数、局部变量还是全局变量）在编译时都是已知的，编译器可以执行该函数，并在编译时提供结果。这就是
    C++11 中引入的泛型常量表达式所实现的功能，它在 C++14 中得到了放宽，甚至在 C++20 中进一步放宽。关键字 `constexpr`（代表 *常量表达式*）可以用来声明编译时常量对象和函数。我们已经在前面章节的几个例子中看到了这一点。现在，是时候学习它实际上是如何工作的了。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The way generalized constant expressions work has been relaxed in C++14 and
    C++20, but this introduced some breaking changes to C++11\. For instance, in C++11,
    a `constexpr` function was implicitly `const`, but this is no longer the case
    in C++14\. In this recipe, we will discuss generalized constant expressions, as
    defined in C++20.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: C++14 和 C++20 中对泛型常量表达式的处理方式已经放宽，但这给 C++11 引入了一些破坏性变化。例如，在 C++11 中，`constexpr`
    函数隐式地是 `const` 的，但在 C++14 中就不再是这种情况了。在本食谱中，我们将讨论 C++20 中定义的泛型常量表达式。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `constexpr` keyword when you want to:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用 `constexpr` 关键字时：
- en: 'Define non-member functions that can be evaluated at compile time:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可以在编译时评估的非成员函数：
- en: '[PRE25]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define constructors that can be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked during this period:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可以在编译时执行以初始化 `constexpr` 对象和在此期间调用的成员函数的构造函数：
- en: '[PRE26]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define variables that can have their values evaluated at compile time:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可以在编译时评估其值的变量：
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `const` keyword is used for declaring variables as constant at runtime;
    this means that, once initialized, they cannot be changed. However, evaluating
    the constant expression may still imply runtime computation. The `constexpr` keyword
    is used for declaring variables that are constant at compile time or functions
    that can be executed at compile time. `constexpr` functions and objects can replace
    macros and hardcoded literals without any performance penalties.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字用于在运行时声明变量为常量；这意味着一旦初始化，它们就不能更改。然而，评估常量表达式可能仍然意味着运行时计算。`constexpr`
    关键字用于声明在编译时为常量的变量或可以在编译时执行的功能。`constexpr` 函数和对象可以替代宏和硬编码的文本，而不会产生任何性能损失。'
- en: 'Declaring a function as `constexpr` does not mean that it is always evaluated
    at compile time. It only enables the use of the function in expressions that are
    evaluated during compile time. This only happens if all the input values of the
    function can be evaluated at compile time. However, the function may also be invoked
    at runtime. The following code shows two invocations of the same function, first
    at compile time, and then at runtime:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数声明为 `constexpr` 并不意味着它总是会在编译时评估。它仅允许在编译时评估的表达式中使用该函数。这仅发生在函数的所有输入值都可以在编译时评估的情况下。然而，该函数也可能在运行时被调用。以下代码显示了同一函数的两个调用，首先是编译时，然后是运行时：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There are some restrictions in regard to where `constexpr` can be used. These
    restrictions have evolved over time, with changes in C++14 and C++20\. To keep
    the list in a reasonable form, only the requirements that need to be satisfied
    in C++20 are shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `constexpr` 可以使用的地方有一些限制。这些限制随着时间的推移而演变，C++14 和 C++20 中有所变化。为了保持列表的合理性，这里只显示了在
    C++20 中需要满足的要求：
- en: 'A variable that is `constexpr` must satisfy the following requirements:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`constexpr`变量必须满足以下要求：
- en: Its type is a literal type.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的类型是一个字面量类型。
- en: It is initialized upon declaration.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在声明时初始化。
- en: The expression used for initializing the variable is a constant expression.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于初始化变量的表达式是一个常量表达式。
- en: It must have constant destruction. This means that it must not be of a class
    type or an array of a class type; otherwise, the class type must have a `constexpr`
    destructor.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有常量析构。这意味着它不能是类类型或类类型的数组；否则，类类型必须有一个`constexpr`析构函数。
- en: 'A function that is `constexpr` must satisfy the following requirements:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`constexpr`函数必须满足以下要求：
- en: It is not a coroutine.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是一个协程。
- en: The return type and the type of all its parameters are all literal types.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型以及所有参数的类型都是字面量类型。
- en: There is at least one set of arguments for which the invocation of the function
    would produce a constant expression.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一组参数，对于该函数的调用会产生一个常量表达式。
- en: The function body must not contain `goto` statements, labels (other than `case`
    and `default` in a switch), and local variables that are either of non-literal
    types or of static or thread storage duration. The restrictions mentioned in this
    bullet point were removed in C++23.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体不得包含`goto`语句、标签（除了在`switch`中的`case`和`default`之外），以及非字面量类型或具有静态或线程存储持续时间的局部变量。这个列表点中提到的限制在C++23中被移除。
- en: 'A constructor that is `constexpr` must satisfy the following requirements,
    in addition to the preceding ones required for functions:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`constexpr`构造函数必须满足以下要求，除了之前对函数的要求之外：
- en: There is no virtual base class for the class.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类没有虚拟基类。
- en: All the constructors that initialize non-static data members, including base
    classes, must also be `constexpr`.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有初始化非静态数据成员的构造函数，包括基类，也必须是`constexpr`。
- en: 'A destructor that is `constexpr`, available only since C++20, must satisfy
    the following requirements, in addition to the preceding ones required for functions:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自C++20起，一个`constexpr`析构函数必须满足以下要求，除了之前对函数的要求之外：
- en: There is no virtual base class for the class.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类没有虚拟基类。
- en: All the destructors that destroy non-static data members, including base classes,
    must also be `constexpr`.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有销毁非静态数据成员的析构函数，包括基类，也必须是`constexpr`。
- en: All the restrictions for `constexpr` constructors and destructors mentioned
    here were removed in C++23.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提到的所有`constexpr`构造函数和析构函数的限制在C++23中都被移除了。
- en: For a complete list of requirements in different versions of the standard, you
    should read the online documentation available at [https://en.cppreference.com/w/cpp/language/constexpr](https://en.cppreference.com/w/cpp/language/constexpr).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准不同版本的要求的完整列表，你应该阅读在[https://en.cppreference.com/w/cpp/language/constexpr](https://en.cppreference.com/w/cpp/language/constexpr)可用的在线文档。
- en: 'A function that is `constexpr` is not implicitly `const` (as of C++14), so
    you need to explicitly use the `const` specifier if the function does not alter
    the logical state of the object. However, a function that is `constexpr` is implicitly
    `inline`. On the other hand, an object that is declared `constexpr` is implicitly
    `const`. The following two declarations are equivalent:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`constexpr`函数不是隐式`const`（截至C++14），所以如果你希望函数不改变对象的逻辑状态，你需要显式使用`const`说明符。然而，一个`constexpr`函数是隐式`inline`的。另一方面，一个声明为`constexpr`的对象是隐式`const`的。以下两个声明是等价的：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are situations when you may need to use both `constexpr` and `const`
    in a declaration, as they would refer to different parts of the declaration. In
    the following example, `p` is a `constexpr` pointer to a constant integer:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要在声明中使用`constexpr`和`const`，因为它们会引用声明中的不同部分。在以下示例中，`p`是一个指向常量整数的`constexpr`指针：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Reference variables can also be `constexpr` if, and only if, they alias an
    object with static storage duration or a function. The following snippet provides
    an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果且仅如果一个引用变量别名一个具有静态存储持续时间或函数的对象，那么引用变量也可以是`constexpr`。以下是一个示例：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `r` is a `constexpr` reference that defines an alias for the
    compile-time constant variable `c`, defined in the previous snippet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`r`是一个`constexpr`引用，它定义了一个对在前面代码片段中定义的编译时常量变量`c`的别名。
- en: 'Although you can define static `constexpr` variables, doing so in a `constexpr`
    function was not possible until C++23\. The following snippet shows such an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以定义静态的`constexpr`变量，但在`constexpr`函数中这样做直到C++23之前是不可能的。以下是一个这样的示例：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The declaration of the `symbols` variable would generate a compiler error,
    prior to C++23\. A possible workaround for this problem was to define the variable
    outside of the `constexpr` function, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`symbols`变量将生成编译器错误，在C++23之前。解决这个问题的一个可能方法是定义变量在`constexpr`函数之外，如下所示：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This problem has been solved in C++23, which relaxed several `constexpr` restrictions,
    making a workaround unnecessary.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23中，这个问题得到了解决，它放宽了几个`constexpr`限制，使得解决方案变得不再必要。
- en: 'One more aspect that should be mentioned on constexpr functions is related
    to exceptions. Since C++20, try-catch blocks are allowed in constexpr functions
    (their use was not possible prior to this version). However, throwing exceptions
    from constant expressions is not allowed. Although you can have a throw statement
    in a constexpr function, the behavior is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`constexpr`函数中还应提及的一个方面与异常有关。自C++20以来，允许在`constexpr`函数中使用try-catch块（在此版本之前无法使用）。然而，不允许从常量表达式中抛出异常。尽管你可以在`constexpr`函数中有一个抛出语句，但其行为如下：
- en: When executed at runtime, it would behave as if it wasn’t declared constexpr.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在运行时执行时，它将表现得好像没有被声明为`constexpr`。
- en: When executed at compile time, if the execution path encounters a throw statement,
    a compiler error is emitted.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在编译时执行时，如果执行路径遇到抛出语句，则编译器会发出错误。
- en: 'This is exemplified in the following snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码片段中得到了体现：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this snippet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中：
- en: The first two calls to `factorial2()` are executed at runtime. The first executes
    successfully and returns `60`. The second throws a `std::invalid_argument` exception
    because the argument is negative.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`factorial2()`的前两次调用是在运行时执行的。第一次调用成功并返回`60`。第二次调用由于参数为负而抛出`std::invalid_argument`异常。
- en: The third call is evaluated at compile time because variable `c` is declared
    `constexpr` and all the function’s inputs are also known at compile time. The
    invocation is successful and the function evaluates to `60`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次调用是在编译时评估的，因为变量`c`被声明为`constexpr`，并且所有函数的输入在编译时也是已知的。调用成功，函数评估结果为`60`。
- en: The fourth call is also evaluated at compile time, but since the argument is
    negative the path that throws an exception should execute. However, this is not
    allowed in constant expressions, and, therefore, the compiler issues an error.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四次调用也是在编译时评估的，但由于参数为负，应该执行抛出异常的路径。然而，在常量表达式中不允许这样做，因此编译器会发出错误。
- en: There’s more…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In C++20, a new specifier was added to the language. This specifier is called
    `constinit` and is used to ensure that variables with static or thread storage
    duration have static initialization. In C++, the initialization of variables can
    be either static or dynamic. Static initialization can be either zero initialization
    (when the initial value of an object is set to zero) or constant initialization
    (when the initial value is set to a compile-time expression). The following snippet
    shows examples of zero and constant initialization:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，语言中添加了一个新的指定符。这个指定符被称为`constinit`，用于确保具有静态或线程存储持续时间的变量具有静态初始化。在C++中，变量的初始化可以是静态的或动态的。静态初始化可以是零初始化（当对象的初始值设置为零时）或常量初始化（当初始值设置为编译时表达式时）。以下代码片段显示了零和常量初始化的示例：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A variable that has static storage could have either static or dynamic initialization.
    In the latter case, hard-to-find bugs may appear. Imagine two static objects that
    are initialized in different translation units.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 具有静态存储的变量可以具有静态或动态初始化。在后一种情况下，可能出现难以发现的错误。想象两个在不同的翻译单元中初始化的静态对象。
- en: When the initialization of one of the two objects depends on the other object,
    then the order they are initialized in is important. This is because the object
    that depends on the object must be initialized first. However, the order of the
    initialization of the translation units is not deterministic, so there is no guarantee
    of the order of these objects’ initialization. However, variables with static
    storage duration that have static initialization are initialized at compile time.
    This implies that these objects can be safely used when performing dynamic initialization
    of translation units.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象的初始化依赖于另一个对象时，它们的初始化顺序很重要。这是因为依赖于对象的那个对象必须首先初始化。然而，翻译单元初始化的顺序是不确定的，因此无法保证这些对象的初始化顺序。然而，具有静态存储持续时间的变量如果具有静态初始化，则是在编译时初始化的。这意味着当执行翻译单元的动态初始化时，可以安全地使用这些对象。
- en: 'This is what the new specifier, `constinit`, is intended for. It ensures that
    a variable with static or thread-local storage has static initialization, and,
    therefore, its initialization is performed at compile time:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是新指定符`constinit`的目的。它确保具有静态或线程局部存储的变量具有静态初始化，因此其初始化是在编译时执行的：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It can also be used in a non-initializing declaration to indicate that a variable
    with thread storage duration is already initialized, as shown in the following
    example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以用于非初始化声明中，以指示具有线程存储持续时间的变量已经初始化，如下面的示例所示：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You cannot use more than one of the `constexpr`, `constinit`, and `consteval`
    specifiers in the same declaration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在同一个声明中使用超过一个的`constexpr`、`constinit`和`consteval`指定符。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating immediate functions*, to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建立即函数*，了解C++20的`consteval`指定符，该指定符用于定义保证在编译时评估的函数'
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确保程序恒定正确性*，以探索恒定正确性的好处以及如何实现它'
- en: Creating immediate functions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建立即函数
- en: '`constexpr` functions enable the evaluation of functions at compile time, provided
    that all their inputs, if any, are also available at compile time. However, this
    is not a guarantee, and constexpr functions may also execute at runtime, as we
    have seen in the previous recipe, *Creating compile-time constant expressions*.
    In C++20, a new category of functions has been introduced: *immediate functions*.
    These are functions that are guaranteed to always be evaluated at compile time;
    otherwise, they produce errors. Immediate functions are useful as replacements
    for macros and may be important in the possible future development of the language
    with reflection and meta-classes.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数允许在编译时评估函数，前提是它们的所有输入（如果有的话）也必须在编译时可用。然而，这并不保证，`constexpr`函数也可能在运行时执行，正如我们在之前的配方中看到的，*创建编译时常量表达式*。在C++20中，引入了函数的新类别：*立即函数*。这些函数保证始终在编译时进行评估；否则，它们会产生错误。立即函数可以作为宏的替代品，并且可能在语言未来的反射和元类开发中很重要。'
- en: How to do it…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Use the `consteval` keyword when you want to:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想使用`consteval`关键字时：
- en: 'Define non-member functions or function templates that must be evaluated at
    compile time:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义必须在编译时评估的非成员函数或函数模板：
- en: '[PRE38]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Define constructors that must be executed at compile time to initialize `constexpr`
    objects and member functions to be invoked only at compile time:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义必须在编译时执行的构造函数，以初始化`constexpr`对象和仅应在编译时调用的成员函数：
- en: '[PRE39]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `consteval` specifier was introduced in C++20\. It can only be applied to
    functions and function templates and defines them as immediate functions. This
    means that any function invocation must be evaluated at compile time and therefore
    produce a compile-time constant expression. If the function cannot be evaluated
    at compile time, the program is ill-formed and the compiler issues an error.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`consteval`指定符是在C++20中引入的。它只能应用于函数和函数模板，并将它们定义为立即函数。这意味着任何函数调用都必须在编译时进行评估，因此产生一个编译时常量表达式。如果函数不能在编译时进行评估，则程序是不良形式，编译器会发出错误。'
- en: 'The following rules apply to immediate functions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则适用于立即函数：
- en: Destructors, allocation, and deallocation functions cannot be immediate functions.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数、分配和释放函数不能是立即函数。
- en: If any declaration of a function contains the `consteval` specifier, then all
    the declarations of that function must also include it.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数的任何声明包含`consteval`指定符，则该函数的所有声明也必须包含它。
- en: The `consteval` specifier cannot be used together with `constexpr` or `constinit`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consteval`指定符不能与`constexpr`或`constinit`一起使用。'
- en: An immediate function is an inline `constexpr` function. Therefore, immediate
    functions and function templates must satisfy the requirements applicable to `constexpr`
    functions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数是一个内联的`constexpr`函数。因此，立即函数和函数模板必须满足适用于`constexpr`函数的要求。
- en: 'Here is how we can use the `factorial()` function and the `point3d` class defined
    in the previous section:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用上一节中定义的`factorial()`函数和`point3d`类的示例：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, the following sample produces compiler errors because the immediate
    function `factorial()` and the constructor of `point3d` cannot be evaluated at
    compile time:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下示例会产生编译器错误，因为即时函数`factorial()`和`point3d`的构造函数无法在编译时评估：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It is not possible to take the address on an immediate function unless it is
    also in a constant expression:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果即时函数不是在常量表达式中，则无法获取其地址：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Because immediate functions are not visible at runtime, their symbols are not
    emitted for them and debuggers will not be able to show them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因为即时函数在运行时不可见，所以不会为它们生成符号，调试器也无法显示它们。
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确保程序常量正确性*，探索常量正确性的好处以及如何实现它'
- en: '*Creating compile-time constant expressions*, to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建编译时常量表达式*，了解`constexpr`指定符以及如何定义可以在编译时评估的变量和函数'
- en: Optimizing code in constant-evaluated contexts
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在常量评估上下文中优化代码
- en: In the previous two recipes, we learned about *constexpr functions*, which allow
    functions to be evaluated at compile time if all their inputs are available at
    compile time, and *immediate functions* (in C++20), which are guaranteed to always
    be evaluated at compile time (or otherwise, produce an error). An important aspect
    of `constexpr` functions is constant-evaluated contexts; these are code paths
    where all expressions and functions are evaluated at compile time. A constant-evaluated
    context is useful for optimizing code more effectively. On the other hand, the
    invocation of immediate functions from `constexpr` functions is only possible
    in C++23\. In this recipe, we will learn about utilizing constant-evaluated contexts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个菜谱中，我们学习了关于*常量表达式函数*，它允许函数在所有输入在编译时都可用的情况下在编译时进行评估，以及*C++20中的即时函数*，它们保证始终在编译时评估（否则将产生错误）。`constexpr`函数的一个重要方面是常量评估上下文；这些是在编译时评估所有表达式和函数的代码路径。常量评估上下文对于更有效地优化代码非常有用。另一方面，从`constexpr`函数中调用即时函数仅在C++23中可行。在本菜谱中，我们将学习如何利用常量评估上下文。
- en: How to do it…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'To determine whether a function context is constant-evaluated in order to provide
    compile-time implementations use the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定函数上下文是否为常量评估，以便提供编译时实现，请使用以下方法：
- en: 'In C++20, the `std::is_constant_evaluated()` library function, available in
    the `<type_traits>` header, with a regular `if` statement:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++20中，`std::is_constant_evaluated()`库函数，在`<type_traits>`头文件中可用，使用常规的`if`语句：
- en: '[PRE43]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In C++23, the `if consteval` statement, which is a simplification (with additional
    benefits) of the `if(std::is_constant_evaluated())` statement:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++23中，`if consteval`语句，它是`if(std::is_constant_evaluated())`语句的简化（具有额外的优点）：
- en: '[PRE44]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The C++20 standard provides a library function (in the `<type_traits>` header)
    called `std::is_constant_evaluated()`, which detects whether its call occurs within
    a constant-evaluated context in a `constexpr` function. In this case, it returns
    `true`; otherwise, it returns `false`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准提供了一个名为`std::is_constant_evaluated()`的库函数（在`<type_traits>`头文件中），它可以检测其调用是否发生在`constexpr`函数中的常量评估上下文中。在这种情况下，它返回`true`；否则，返回`false`。
- en: 'This function is used with a regular `if` statement, as in the example provided
    in the previous section, where we computed the power of a number. The key takeaways
    from this implementation are the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用常规的`if`语句，如前一小节中提供的示例，其中我们计算了数字的幂。从这个实现中可以得出的关键要点如下：
- en: In a constant-evaluated context, we used an algorithm that can be executed by
    the compiler at compile time, to optimize the code.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常量评估上下文中，我们使用了一个可以在编译时由编译器执行的算法来优化代码。
- en: In a non-constant evaluated context (i.e., at runtime) we invoke the `std::pow()`
    function to compute the power.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非常量评估上下文（即运行时）中，我们调用`std::pow()`函数来计算幂。
- en: 'However, there are some “gotchas” with this function and the constant-evaluated
    contexts that you must be aware of:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个函数和常量评估上下文有一些“陷阱”，你必须注意：
- en: 'Just because the arguments of a function are known at compile time, it does
    not mean that a context is constant-evaluated. In the following snippet, the first
    invocation of the `constexpr` function `power()` is in a constant-evaluated context,
    but the second is not, even though all its arguments are known at compile time
    and the function is declared `constexpr`:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的参数在编译时已知，并不意味着上下文是常量评估的。在以下代码片段中，`constexpr` 函数 `power()` 的第一次调用是在常量评估上下文中，但第二次调用不是，尽管所有参数在编译时已知，并且函数被声明为
    `constexpr`：
- en: '[PRE45]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If used with a `constexpr` if statement, the `std::is_constant_evaluated()`
    function always evaluates to `true` (compilers such as GCC and Clang provide a
    warning for this subtle error):'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果与 `constexpr` if 语句一起使用，`std::is_constant_evaluated()` 函数始终评估为 `true`（例如 GCC
    和 Clang 编译器会为此细微的错误提供警告）：
- en: '[PRE46]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is an example of the reported error:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个报告错误的示例：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The C++23 standard provides a better alternative to the `std::is_constant_evaluated()`
    function, the `consteval if` statement. This has several benefits:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: C++23 标准提供了对 `std::is_constant_evaluated()` 函数的更好替代方案，即 `consteval if` 语句。这有几个优点：
- en: Does not require the inclusion of a header
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要包含头文件
- en: Avoids confusion about the correct form of the `if` statement to use
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免对使用正确形式的 `if` 语句产生混淆
- en: Allows the invocation of immediate functions in a constant-evaluated context
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在常量评估上下文中调用立即函数
- en: 'The implementation of the power function changes to the following in C++23:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，幂函数的实现变为以下形式：
- en: '[PRE48]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `consteval` `if` statement always requires braces. The negated form is
    also possible, either with `!` or the `not` keyword. In the following snippet,
    each of the two pairs of statements are equivalent:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`consteval` `if` 语句始终需要花括号。否定形式也是可能的，无论是使用 `!` 还是 `not` 关键字。在以下代码片段中，每一对语句都是等价的：'
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `consteval` if statement is also important for allowing an immediate function
    to be invoked from a constant-evaluated context in a `constexpr` function. Let’s
    take the following C++20 example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`consteval` if 语句对于允许在 `constexpr` 函数中从常量评估上下文中立即调用函数也很重要。以下是一个 C++20 的示例：'
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the function `plus_one()` is an immediate function and can be invoked
    from the `plus_two()` function, which is also an immediate function. However,
    invoking it from the `plus_two_alt()` function is not possible because it is not
    a constant expression, even though this is a `constexpr` function and the context
    where the `plus_one()` function is invoked is constant-evaluated.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数 `plus_one()` 是一个立即函数，可以从 `plus_two()` 函数（也是一个立即函数）中调用。然而，从 `plus_two_alt()`
    函数中调用它是不可能的，因为它不是一个常量表达式，尽管这是一个 `constexpr` 函数，并且调用 `plus_one()` 函数的上下文是常量评估的。
- en: 'This problem is solved by the C++23 `consteval if` statement. This makes it
    possible for immediate functions to be invoked from a constant-evaluated context,
    as shown in the following example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通过 C++23 的 `consteval if` 语句得到解决。这使得从常量评估上下文中调用立即函数成为可能，如下面的示例所示：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'With the availability of the `consteval if` statement, the `std::is_constant_evaluated()`
    function becomes obsolete. In fact, it can be implemented with a `consteval if`
    statement as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `consteval if` 语句的可用性，`std::is_constant_evaluated()` 函数变得过时。实际上，它可以使用 `consteval
    if` 语句如下实现：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When using a C++23 compiler, you should always prefer the `consteval if` statement
    over the obsolete `std::is_constant_evaluated()` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 C++23 编译器时，你应该始终优先选择 `consteval if` 语句，而不是过时的 `std::is_constant_evaluated()`
    函数。
- en: See also
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating compile-time constant expressions,* to learn about the `constexpr`
    specifier and how to define variables and functions that can be evaluated at compile
    time'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建编译时常量表达式*，了解 `constexpr` 指示符以及如何定义可以在编译时评估的变量和函数'
- en: '*Creating immediate functions,* to learn about the C++20 `consteval` specifier,
    which is used to define functions that are guaranteed to be evaluated at compile
    time'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建立即函数*，了解 C++20 的 `consteval` 指示符，它用于定义保证在编译时评估的函数'
- en: Using virtual function calls in constant expressions
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在常量表达式中使用虚函数调用
- en: 'As a multi-paradigm programming language, C++ includes support for object-oriented
    programming. Polymorphism, one of the core principles of object-oriented programming,
    has two forms in C++: compile-time polymorphism, with function and operator overloading,
    and runtime-polymorphism, with virtual functions. Virtual functions allow a derived
    class to override the implementation (of a function) in the base class. In C++20,
    however, virtual functions are allowed in constant expressions, meaning they can
    be invoked at compile time. In this recipe, you will learn how that works.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种多范式编程语言，C++ 包括对面向对象编程的支持。多态性是面向对象编程的核心原则之一，在 C++ 中有两种形式：编译时多态性，通过函数和运算符重载实现，以及运行时多态性，通过虚函数实现。虚函数允许派生类覆盖基类中的函数实现。然而，在
    C++20 中，虚函数被允许在常量表达式中使用，这意味着它们可以在编译时调用。在本食谱中，你将了解这是如何工作的。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the following structure to represent the dimension
    of a document and, respectively, an envelope, in the ensuing examples:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用以下结构来表示文档的维度以及随后的示例中的信封维度：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How to do it…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'You can move runtime polymorphism to the compile time by doing the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式将运行时多态性移动到编译时：
- en: Declare the virtual functions whose invocation you want to move to compile time
    as `constexpr`.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你想要移动到编译时调用的虚函数声明为 `constexpr`。
- en: Declare the destructor of the base class of the hierarchy as `constexpr`.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将层次结构的基类的析构函数声明为 `constexpr`。
- en: Declare the overridden virtual function as `constexpr`.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将重写的虚函数声明为 `constexpr`。
- en: Invoke the `constexpr` virtual function in a constant expression.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常量表达式中调用 `constexpr` 虚函数。
- en: 'An example is shown in the following snippet:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例片段：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Prior to C++20, virtual functions could not be `constexpr`. However, the dynamic
    type of an object used in a constant expression must be known at compile time.
    As a result, the restriction of making virtual functions `constexpr` has been
    lifted in C++20.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 之前，虚函数不能是 `constexpr`。然而，用于常量表达式的对象的动态类型必须在编译时已知。因此，将虚函数设置为 `constexpr`
    的限制在 C++20 中已被取消。
- en: The advantage of having `constexpr` virtual functions is that some computations
    can be moved from runtime to compile time. Although this will not impact many
    use cases in practice, an example was given in the previous section. Let’s elaborate
    on it for a better understanding.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有 `constexpr` 虚函数的优势在于可以将一些计算从运行时移动到编译时。尽管这不会影响实践中许多用例，但在上一节中已经给出一个示例。让我们进一步阐述，以便更好地理解。
- en: We have a set of various paper sizes for documents. Examples include *A3*, *A4*,
    *A5*, *legal*, *letter*, and *half-letter*. These have different sizes. For instance,
    A5 is 148.5 mm x 210 mm, while letter is 215.9 mm x 279.4 mm.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一系列各种文档纸张大小。例如，包括 *A3*、*A4*、*A5*、*legal*、*letter* 和 *half-letter*。它们有不同的尺寸。例如，A5
    是 148.5 毫米 x 210 毫米，而 letter 是 215.9 毫米 x 279.4 毫米。
- en: On the other hand, we have envelopes of different types and sizes. For instance,
    we have an envelope that is 92 mm x 219 mm with a maximum enclosure size of 86
    mm x 213 mm. We want to write a function that determines whether a folded paper
    of a certain type can be placed inside an envelope. Since the sizes are standard,
    they are known at compile time. This means we can perform this check at compile
    time instead of runtime.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有不同类型和大小的信封。例如，我们有一个 92 毫米 x 219 毫米的信封，最大封装尺寸为 86 毫米 x 213 毫米。我们想要编写一个函数，以确定某种类型的折叠纸张是否可以放入信封中。由于尺寸是标准的，它们在编译时是已知的。这意味着我们可以在编译时而不是运行时执行此检查。
- en: 'For this purpose, in the *How to do it…* section, we have seen:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，在 *如何实现...* 部分中，我们已经看到：
- en: 'A hierarchy of documents, with the base class called `document_type`. This
    has two members: a virtual destructor and a virtual function called `size()` that
    returns the size of the paper. Both of these functions are also `constexpr`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文档的层次结构，基类称为 `document_type`。它有两个成员：一个虚析构函数和一个名为 `size()` 的虚函数，该函数返回纸张的大小。这两个函数也都是
    `constexpr`。
- en: 'A hierarchy of envelopes, with the base class called `envelope_type`. This
    has three members: a virtual destructor, a virtual function called `size()`, which
    returns the size of the envelope, and a virtual function called `max_enclosure_size()`,
    which returns the maximum size of a (folded) paper that can be placed in the envelope.
    All these are `constexpr`.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个信封的层次结构，基类称为`envelope_type`。它有三个成员：一个虚析构函数，一个名为`size()`的虚函数，它返回信封的大小，以及一个名为`max_enclosure_size()`的虚函数，它返回可以放入信封中的（折叠）纸张的最大尺寸。所有这些都是`constexpr`。
- en: A free function called `document_fits_envelope()` determines whether a given
    document type fits a particular envelope type, by comparing the size of the width
    of the two. This is also a `constexpr` function.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`document_fits_envelope()`的免费函数通过比较两个宽度的尺寸来确定给定的文档类型是否适合特定的信封类型。这也是一个`constexpr`函数。
- en: Because all these functions mentioned are `constexpr`, the `document_fits_envelope()`
    function can be invoked in a constant expression, such as a `static_assert`, given
    that the objects for which they are invoked are also `constexpr`. In the code
    files that accompany the book you will find an elaborate example with various
    paper and envelope sizes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有提到的函数都是`constexpr`，所以如果被调用的对象也是`constexpr`，则可以在常量表达式中调用`document_fits_envelope()`函数，例如在`static_assert`中。在本书附带的代码文件中，你可以找到一个关于各种纸张和信封尺寸的详细示例。
- en: 'You should keep in mind that:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住：
- en: You can make an overridden virtual function `constexpr`, even though the function
    it overrides in the base class is not defined as `constexpr`.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至可以将一个重写的虚拟函数声明为`constexpr`，即使它在基类中被重写的函数没有被定义为`constexpr`。
- en: The opposite is also possible, the overridden virtual function in the derived
    class can be non-`constexpr`, although the function was defined as `constexpr`
    in the base class.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反过来也是可能的，派生类中重写的虚拟函数可以不是`constexpr`，尽管在基类中该函数被定义为`constexpr`。
- en: If there is a hierarchy on multiple levels and a virtual function has some overrides
    defined as `constexpr` and some not, then the final overrider appropriate for
    the object on which the function is invoked is considered to determine whether
    the virtual function is `constexpr` or not.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在多级层次结构，并且一个虚拟函数定义了一些`constexpr`重写和一些非`constexpr`重写，那么用于确定虚拟函数是否为`constexpr`的最终重写器是针对被调用的对象。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 1*, *Using override and final for virtual methods,* to learn how to
    use the override and final specifiers on virtual methods and classes, respectively'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用override和final对虚拟方法和类进行操作*，学习如何在虚拟方法和类上使用override和final说明符'
- en: Performing correct type casts
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确执行类型转换
- en: It is often the case that data has to be converted from one type into another
    type. Some conversions are necessary at compile time (such as `double` to `int`);
    others are necessary at runtime (such as upcasting and downcasting pointers to
    the classes in a hierarchy). The language supports compatibility with the C casting
    style in either the `(type)expression` or `type(expression)` form. However, this
    type of casting breaks the type safety of C++.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，数据必须从一种类型转换为另一种类型。一些转换在编译时是必要的（例如`double`到`int`）；其他转换在运行时是必要的（例如向上转换和向下转换层次结构中的类指针）。该语言支持与C转换风格的兼容性，无论是`(type)expression`还是`type(expression)`形式。然而，这种类型的转换破坏了C++的类型安全性。
- en: 'Therefore, the language also provides several conversions: `static_cast`, `dynamic_cast`,
    `const_cast`, and `reinterpret_cast`. They are used to better indicate intent
    and write safer code. In this recipe, we’ll look at how these casts can be used.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该语言也提供了几种转换：`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`。它们用于更好地指示意图并编写更安全的代码。在本菜谱中，我们将探讨如何使用这些转换。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following casts to perform type conversions:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下转换来执行类型转换：
- en: 'Use `static_cast` to perform type casting of non-polymorphic types, including
    the casting of integers to enumerations, from floating-point to integral values,
    or from a pointer type to another pointer type, such as from a base class to a
    derived class (downcasting) or from a derived class to a base class (upcasting),
    but without any runtime checks:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`static_cast`来执行非多态类型的类型转换，包括将整数转换为枚举、从浮点数转换为整数值，或从指针类型转换为另一个指针类型，例如从基类到派生类（向下转换）或从派生类到基类（向上转换），但没有任何运行时检查：
- en: '[PRE55]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use `dynamic_cast` to perform type casting of pointers or references of polymorphic
    types from a base class to a derived class or the other way around. These checks
    are performed at runtime and may require that **run-time type information** (**RTTI**)
    is enabled:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dynamic_cast` 来执行从基类到派生类或相反的指针或引用的多态类型的类型转换。这些检查在运行时执行，可能需要启用 **运行时类型信息**（**RTTI**）：
- en: '[PRE56]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use `const_cast` to perform conversion between types with different `const`
    and `volatile` specifiers, such as removing `const` from an object that was not
    declared as `const`:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `const_cast` 来执行具有不同 `const` 和 `volatile` 说明符的类型之间的转换，例如从未声明为 `const` 的对象中移除
    `const`：
- en: '[PRE57]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use `reinterpret_cast` to perform bit reinterpretation, such as conversion
    between integers and pointer types, from pointer types to integers, or from a
    pointer type to any other pointer type, without involving any runtime checks:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reinterpret_cast` 来执行位重新解释，例如在整数和指针类型之间、从指针类型到整数或从指针类型到任何其他指针类型的转换，而不涉及任何运行时检查：
- en: '[PRE58]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The explicit type conversion, sometimes referred to as *C-style casting* or
    *static casting*, is a legacy of the compatibility of C++ with the C language
    and enables you to perform various conversions including the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型转换，有时被称为 *C 风格转换* 或 *静态转换*，是 C++ 与 C 语言兼容性的遗产，并允许你执行各种转换，包括以下内容：
- en: Between arithmetical types
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在算术类型之间
- en: Between pointer types
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在指针类型之间
- en: Between integral and pointer types
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整型和指针类型之间
- en: Between const or volatile qualified and unqualified types
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在具有不同 `const` 或 `volatile` 修饰符的已修饰和未修饰类型之间
- en: 'This type of casting does not work well with polymorphic types or in templates.
    Because of this, C++ provides the four casts we saw in the examples earlier. Using
    these casts leads to several important benefits:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的转换在处理多态类型或在模板中使用时效果不佳。正因为如此，C++ 提供了我们在前面的示例中看到的四种转换。使用这些转换可以带来几个重要的好处：
- en: They express user intent better, both to the compiler and others that read the
    code.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更好地表达了用户的意图，无论是对于编译器还是阅读代码的其他人。
- en: They enable safer conversion between various types (except for `reinterpret_cast`).
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使得在不同类型之间的转换更加安全（除了 `reinterpret_cast`）。
- en: They can be easily searched in the source code.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在源代码中轻松搜索。
- en: '`static_cast` is not a direct equivalent of explicit type conversion, or static
    casting, even though the name might suggest that. This cast is performed at compile
    time and can be used to perform implicit conversions, the reverse of implicit
    conversions, and conversion from pointers to types from a hierarchy of classes.
    It cannot be used to trigger a conversion between unrelated pointer types, though.
    For this reason, in the following example, converting from `int*` to `double*`
    using `static_cast` produces a compiler error:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_cast` 并不是显式类型转换或静态转换的直接等价物，尽管名称可能暗示这一点。这种转换在编译时执行，可以用来执行隐式转换、隐式转换的反向转换以及从类层次结构中的指针到类型的转换。它不能用来触发不相关指针类型之间的转换。因此，在以下示例中，使用
    `static_cast` 从 `int*` 转换到 `double*` 会产生编译器错误：'
- en: '[PRE59]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'However, converting from `base*` to `derived*` (where `base` and `derived`
    are the classes shown in the *How to do it...* section) does not produce a compiler
    error but a runtime error when trying to use the newly obtained pointer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从 `base*` 转换到 `derived*`（其中 `base` 和 `derived` 是在 *如何做...* 部分中显示的类）不会产生编译器错误，但在尝试使用新获得的指针时会产生运行时错误：
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the other hand, `static_cast` cannot be used to remove `const` and `volatile`
    qualifiers. The following snippet exemplifies this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`static_cast` 不能用来移除 `const` 和 `volatile` 修饰符。以下代码片段说明了这一点：
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Safely typecasting expressions up, down, or sideways along an inheritance hierarchy
    can be performed with `dynamic_cast`. This cast is performed at runtime and requires
    that RTTI is enabled. Because of this, it incurs a runtime overhead. Dynamic casting
    can only be used for pointers and references.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dynamic_cast` 可以在继承层次结构中安全地进行向上、向下或侧向的类型转换。这种转换在运行时执行，并要求启用 RTTI。正因为如此，它会产生运行时开销。动态转换只能用于指针和引用。
- en: When `dynamic_cast` is used to convert an expression into a pointer type and
    the operation fails, the result is a null pointer. When it is used to convert
    an expression into a reference type and the operation fails, a `std::bad_cast`
    exception is thrown. Therefore, always put a `dynamic_cast` conversion to a reference
    type within a `try...catch` block.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `dynamic_cast` 将表达式转换为指针类型且操作失败时，结果是一个空指针。当它用于将表达式转换为引用类型且操作失败时，会抛出 `std::bad_cast`
    异常。因此，总是将 `dynamic_cast` 转换到引用类型的操作放在 `try...catch` 块中。
- en: RTTI is a mechanism that exposes information about object data types at runtime.
    This is available only for polymorphic types (types that have at least one virtual
    method, including a virtual destructor, which all base classes should have). RTTI
    is usually an optional compiler feature (or might not be supported at all), which
    means using this functionality may require using a compiler switch.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: RTTI 是一种在运行时暴露对象数据类型信息的机制。这仅适用于多态类型（至少有一个虚方法，包括虚析构函数，所有基类都应该有）。RTTI 通常是一个可选的编译器功能（或者可能根本不支持），这意味着使用此功能可能需要使用编译器开关。
- en: 'Though dynamic casting is performed at runtime, if you attempt to convert it
    between non-polymorphic types, you’ll get a compiler error:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然动态转换是在运行时执行的，但如果尝试在非多态类型之间进行转换，将会得到编译器错误：
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`reinterpret_cast` is more like a compiler directive. It does not translate
    into any CPU instructions; it only instructs the compiler to interpret the binary
    representation of an expression as it was of another, specified type. This is
    a type-unsafe conversion and should be used with care. It can be used to convert
    expressions between integral types and pointers, pointer types, and function pointer
    types. Because no checks are done, `reinterpret_cast` can be successfully used
    to convert expressions between unrelated types, such as from `int*` to `double*`,
    which produces undefined behavior:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast` 更像是一个编译器指令。它不会转换为任何 CPU 指令；它只是指示编译器将表达式的二进制表示解释为另一种指定的类型。这是一种类型不安全的转换，应该谨慎使用。它可以用于在整数类型和指针、指针类型和函数指针类型之间转换表达式。因为没有任何检查，`reinterpret_cast`
    可以成功用于在无关类型之间转换表达式，例如从 `int*` 转换到 `double*`，这将产生未定义的行为：'
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A typical use of `reinterpret_cast` is to convert expressions between types
    in code that uses operating system or vendor-specific APIs. Many APIs store user
    data in the form of a pointer or an integral type. Therefore, if you need to pass
    the address of a user-defined type to such APIs, you need to convert values of
    unrelated pointer types or a pointer type value into an integral type value. A
    similar example was provided in the previous section, where `widget` was a class
    that stored user-defined data in a data member and provided methods for accessing
    it: `set_data()` and `get_data()`. If you need to store a pointer to an object
    in `widget`, then use `reinterpret_cast`, as shown in this example.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast` 的典型用途是在使用操作系统或供应商特定 API 的代码中在类型之间转换表达式。许多 API 以指针或整数类型的形式存储用户数据。因此，如果您需要将用户定义类型的地址传递给此类
    API，则需要将无关指针类型或指针类型值转换为整数类型值。在上一节中提供了一个类似的例子，其中 `widget` 是一个类，它在数据成员中存储用户定义的数据，并提供了访问它的方法：`set_data()`
    和 `get_data()`。如果您需要在 `widget` 中存储对象的指针，那么请使用 `reinterpret_cast`，如下面的例子所示。'
- en: '`const_cast` is similar to `reinterpret_cast` in the sense that it is a compiler
    directive and does not translate into CPU instructions. It is used to cast away
    `const` or `volatile` qualifiers, an operation that none of the other three conversions
    discussed here can do.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 在某种程度上与 `reinterpret_cast` 相似，因为它是一个编译器指令，并不转换为 CPU 指令。它用于去除 `const`
    或 `volatile` 修饰符，这是其他三种转换所不能做的操作。'
- en: '`const_cast` should only be used to remove `const` or `volatile` qualifiers
    when the object is not declared `const` or `volatile`. Anything else incurs undefined
    behavior, as shown in the following example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`const_cast` 应仅用于在对象未声明为 `const` 或 `volatile` 时去除 `const` 或 `volatile` 修饰符。否则，将会引入未定义的行为，如下面的例子所示：'
- en: '[PRE64]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, the variable `p` points to an object (the variable `a`) that
    was declared constant. By re­moving the `const` qualifier, the attempt to modify
    the pointed object introduces undefined behavior.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，变量 `p` 指向一个对象（变量 `a`），该对象被声明为常量。通过移除 `const` 修饰符，尝试修改指向的对象会引入未定义的行为。
- en: There’s more...
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When using explicit type conversion in the form `(type)expression`, be aware
    that it will select the first choice from the following list that satisfies specific
    cast requirements:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用形式为`(type)expression`的显式类型转换时，请注意它将选择以下列表中满足特定转换要求的第一个选择：
- en: '`const_cast<type>(expression)`'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`const_cast<type>(expression)`'
- en: '`static_cast<type>(expression)`'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static_cast<type>(expression)`'
- en: '`static_cast<type>(expression) + const_cast<type>(expression)`'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`static_cast<type>(expression) + const_cast<type>(expression)`'
- en: '`reinterpret_cast<type>(expression)`'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast<type>(expression)`'
- en: '`reinterpret_cast<type>(expression) + const_cast<type>(expression)`'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast<type>(expression) + const_cast<type>(expression)`'
- en: Moreover, unlike the specific C++ casts, static cast can be used to convert
    between incomplete class types. If both `type` and `expression` are pointers to
    incomplete types, then it is not specified whether `static_cast` or `reinterpret_cast`
    is selected.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与特定的C++转换不同，静态转换可以用于在未完整类类型之间进行转换。如果`type`和`expression`都是指向未完整类型的指针，则未指定是选择`static_cast`还是`reinterpret_cast`。
- en: See also
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确保程序常量正确性*，以探索常量正确性的好处以及如何实现它'
- en: Implementing move semantics
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现移动语义
- en: Move semantics is a key feature that drives the performance improvements of
    modern C++. They enable moving, rather than copying, resources, or, in general,
    objects that are expensive to copy. However, it requires that classes implement
    a move constructor and move assignment operator. These are provided by the compiler
    in some circumstances, but in practice, it is often the case that you have to
    explicitly write them. In this recipe, we will see how to implement the move constructor
    and the move assignment operator.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义是推动现代C++性能提升的关键特性。它们允许移动资源，而不是复制，或者更一般地说，复制代价高昂的对象。然而，它要求类实现移动构造函数和移动赋值运算符。在某些情况下，编译器提供了这些，但在实践中，通常您必须显式地编写它们。在本配方中，我们将看到如何实现移动构造函数和移动赋值运算符。
- en: Getting ready
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You are expected to have basic knowledge of rvalue references and the special
    class functions (constructors, assignment operators, and destructors). We will
    demonstrate how to implement a move constructor and assignment operator using
    the following `Buffer` class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 预期您具备关于右值引用和特殊类函数（构造函数、赋值运算符和析构函数）的基本知识。我们将演示如何使用以下`Buffer`类来实现移动构造函数和赋值运算符：
- en: '[PRE65]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let’s move on to the next section, where you’ll learn how to modify this class
    in order to benefit from move semantics.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一节，在那里您将学习如何修改这个类以利用移动语义。
- en: How to do it...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement the move constructor for a class, do the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要为类实现移动构造函数，请执行以下操作：
- en: 'Write a constructor that takes an rvalue reference to the class type:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个接受类类型右值引用的构造函数：
- en: '[PRE66]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Assign all the data members from the rvalue reference to the current object.
    This can be done either in the body of the constructor, as follows, or in the
    initialization list, which is the preferred way:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有数据成员从右值引用赋值到当前对象。这可以在构造函数体中完成，如下所示，或者在初始化列表中完成，这是首选方式：
- en: '[PRE67]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Optionally, assign the data members from the rvalue reference to default values
    (to ensure the object that was moved is in a destructible state):'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，将数据成员从右值引用赋值为默认值（以确保被移动的对象处于可析构状态）：
- en: '[PRE68]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Put all together, the move constructor for the `Buffer` class looks like this:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Buffer`类的移动构造函数整合如下：
- en: '[PRE69]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To implement the move assignment operator for a class, do the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 要为类实现移动赋值运算符，请执行以下操作：
- en: 'Write an assignment operator that takes an rvalue reference to the class type
    and returns a reference to it:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个接受类类型右值引用并返回其引用的赋值运算符：
- en: '[PRE70]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Check that the rvalue reference does not refer to the same object as `this`,
    and if they are different, perform *steps 3* to *5*:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查右值引用是否指向与`this`相同的对象，如果它们不同，则执行步骤3到步骤5：
- en: '[PRE71]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Dispose of all the resources (such as memory, handles, and so on) from the
    current object:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理当前对象的所有资源（如内存、句柄等）：
- en: '[PRE72]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Assign all the data members from the rvalue reference to the current object:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有数据成员从右值引用赋值到当前对象：
- en: '[PRE73]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Assign the data members from the rvalue reference to the default values:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右值引用的数据成员赋值为默认值：
- en: '[PRE74]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Return a reference to the current object, regardless of whether *steps 3* to
    *5* were executed or not:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不论是否执行了步骤3到步骤5，都返回当前对象的引用：
- en: '[PRE75]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Put all together, the move assignment operator for the `Buffer` class looks
    like this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，`Buffer`类的移动赋值运算符看起来像这样：
- en: '[PRE76]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: How it works...
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The move constructor and move assignment operator are provided by default by
    the compiler unless a user-defined copy constructor, move constructor, copy assignment
    operator, move assignment operator, or destructor exists already. When provided
    by the compiler, they perform a movement in a member-wise manner. The move constructor
    invokes the move constructors of the class data members recursively; similarly,
    the move assignment operator invokes the move assignment operators of the class
    data members recursively.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数和移动赋值运算符由编译器默认提供，除非已经存在用户定义的复制构造函数、移动构造函数、复制赋值运算符、移动赋值运算符或析构函数。当由编译器提供时，它们以成员方式执行移动。移动构造函数递归地调用类数据成员的移动构造函数；同样，移动赋值运算符递归地调用类数据成员的移动赋值运算符。
- en: Move, in this case, represents a performance benefit for objects that are too
    large to copy (such as a string or container) or for objects that are not supposed
    to be copied (such as the `unique_ptr` smart pointer). Not all classes are supposed
    to implement both copy and move semantics. Some classes should only be movable,
    while others should be both copyable and movable. On the other hand, it does not
    make much sense for a class to be copyable but not moveable, though this can be
    technically achieved.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，移动代表了对太大而无法复制（如字符串或容器）或不应被复制（如`unique_ptr`智能指针）的对象的性能优势。并非所有类都应该实现复制和移动语义。一些类应该只可移动，而另一些类则应该可复制和可移动。另一方面，一个类可复制但不移动并没有太多意义，尽管技术上可以实现。
- en: 'Not all types benefit from move semantics. In the case of built-in types (such
    as `bool`, `int`, or `double`), arrays, or PODs, the move is actually a copy operation.
    On the other hand, move semantics provide a performance benefit in the context
    of rvalues, that is, temporary objects. An rvalue is an object that does not have
    a name; it lives temporarily during the evaluation of an expression and is destroyed
    at the next semicolon:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型都从移动语义中受益。对于内置类型（如`bool`、`int`或`double`）、数组或PODs，移动实际上是一个复制操作。另一方面，移动语义在rvalue的上下文中提供了性能优势，即临时对象。rvalue是一个没有名字的对象；它在表达式的评估期间临时存在，并在下一个分号处被销毁：
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding example, `a`, `b`, and `c` are lvalues; they are objects that
    have a name that can be used to refer to the object at any point throughout its
    lifetime. On the other hand, when you evaluate the expression `a+b`, the compiler
    creates a temporary object (which, in this case, is assigned to `c`), which is
    then destroyed when a semicolon is encountered. These temporary objects are called
    rvalues because they usually appear on the right-hand side of an assignment expression.
    In C++11, we can refer to these objects through rvalue references, expressed with
    `&&`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`a`、`b`和`c`是lvalue；它们是有名字的对象，可以在其生命周期的任何时刻通过这个名字来引用该对象。另一方面，当你评估表达式`a+b`时，编译器创建了一个临时对象（在这种情况下，被分配给`c`），然后在遇到分号时被销毁。这些临时对象被称为rvalue，因为它们通常出现在赋值表达式的右侧。在C++11中，我们可以通过`&&`这样的rvalue引用来引用这些对象。
- en: Move semantics are important in the context of rvalues. This is because they
    allow you to take ownership of the resources from the temporary object that is
    destroyed, without the client being able to use it after the move operation is
    completed. On the other hand, lvalues cannot be moved; they can only be copied.
    This is because they can be accessed after the move operation, and the client
    expects the object to be in the same state. For instance, in the preceding example,
    the expression `b = a` assigns `a` to `b`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义在rvalue的上下文中非常重要。这是因为它们允许你在临时对象被销毁后获取其资源所有权，而客户端在移动操作完成后无法再使用它。另一方面，lvalue不能被移动；它们只能被复制。这是因为它们可以在移动操作之后被访问，客户端期望对象处于相同的状态。例如，在前面的例子中，表达式`b
    = a`将`a`赋值给`b`。
- en: After this operation is complete, the object `a`, which is an lvalue, can still
    be used by the client and should be in the same state as it was before. On the
    other hand, the result of `a+b` is temporary, and its data can be safely moved
    to `c`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作完成后，lvalue类型的对象`a`仍然可以被客户端使用，并且应该处于与之前相同的状态。另一方面，`a+b`的结果是临时的，其数据可以安全地移动到`c`。
- en: The move constructor is different from a copy constructor because it takes an
    rvalue reference to the class type `T(T&&)`, as opposed to an lvalue reference
    in the case of the copy constructor `T(T const&)`. Similarly, the move assignment
    takes an rvalue reference, namely `T& operator=(T&&)`, as opposed to an lvalue
    reference for the copy assignment operator, namely `T& operator=(T const &)`.
    This is true even though both return a reference to the `T&` class. The compiler
    selects the appropriate constructor or assignment operator based on the type of
    argument, rvalue, or lvalue.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数与复制构造函数不同，因为它接受对类类型`T`的右值引用`T(T&&)`，而复制构造函数接受左值引用`T(T const&)`。同样，移动赋值也接受右值引用，即`T&
    operator=(T&&)`，而复制赋值运算符接受左值引用，即`T& operator=(T const &)`。即使两者都返回对`T&`类的引用，这也是正确的。编译器根据参数的类型（右值或左值）选择合适的构造函数或赋值运算符。
- en: 'When a move constructor/assignment operator exists, an rvalue is moved automatically.
    lvalues can also be moved, but this requires an explicit casting to an rvalue
    reference. This can be done using the `std::move()` function, which basically
    performs a `static_cast<T&&>`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在移动构造函数/赋值运算符时，右值会被自动移动。左值也可以被移动，但这需要显式地将其转换为右值引用。这可以通过使用`std::move()`函数来完成，它基本上执行了一个`static_cast<T&&>`操作：
- en: '[PRE78]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: After an object is moved, it must remain in a valid state. However, there is
    no requirement regarding what this state should be. For consistency, you should
    set all member fields to their default value (numerical types to `0`, pointers
    to `nullptr`, Booleans to `false`, and so on).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对象移动后，它必须保持在一个有效状态。然而，没有关于这个状态应该是什么的要求。为了保持一致性，你应该将所有成员字段设置为它们的默认值（数值类型为`0`，指针为`nullptr`，布尔值为`false`等）。
- en: 'The following example shows the different ways in which `Buffer` objects can
    be constructed and assigned:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`Buffer`对象可以以不同的方式被构造和赋值：
- en: '[PRE79]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The constructor or assignment operator involved in the creation or assignment
    of the objects `b1`, `b2`, `b3`, and `b4` is mentioned in the comments on each
    line.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行注释中提到的构造函数或赋值运算符都涉及到了对象`b1`、`b2`、`b3`和`b4`的创建或赋值。
- en: There’s more...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As seen with the `Buffer` example, implementing both the move constructor and
    move assignment operator involves writing similar code (the entire code of the
    move constructor was also present in the move assignment operator). This can actually
    be avoided by calling the move assignment operator in the move constructor (or,
    alternatively, factor the assignment code into a private function that is invoked
    from both the move constructor and move assignment operator):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如`Buffer`示例所示，实现移动构造函数和移动赋值运算符都涉及到编写类似的代码（移动构造函数的整个代码也存在于移动赋值运算符中）。实际上，可以通过在移动构造函数中调用移动赋值运算符（或者，作为替代方案，将赋值代码分解成一个私有函数，该函数由移动构造函数和移动赋值运算符共同调用）来避免这种情况：
- en: '[PRE80]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'There are two points that must be noticed in this example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中有两个需要注意的点：
- en: Member initialization in the constructor’s initialization list is necessary
    because these members could potentially be used in the move assignment operator
    later on (such as the `ptr` member in this example).
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造函数的初始化列表中进行成员初始化是必要的，因为这些成员可能会在以后的移动赋值运算符中使用（例如，本例中的`ptr`成员）。
- en: Static casting of `other` to an rvalue reference. Without this explicit conversion,
    the copy assignment operator would be called. This is because even if an rvalue
    is passed to this constructor as an argument, when it is assigned a name, it is
    bound to an lvalue. Therefore, `other` is actually an lvalue, and it must be converted
    to an rvalue reference in order to invoke the move assignment operator.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`other`显式地转换为右值引用。如果没有这个显式转换，将会调用复制赋值运算符。这是因为即使将右值作为参数传递给这个构造函数，当它被赋予一个名称时，它绑定到一个左值上。因此，`other`实际上是一个左值，必须转换为右值引用才能调用移动赋值运算符。
- en: See also
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 3*, *Defaulted and deleted functions*, to learn about the use of the
    `default` specifier on special member functions and how to define functions as
    deleted with the `delete` specifier'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*默认和删除函数*，了解在特殊成员函数上使用`default`指定符以及如何使用`delete`指定符定义已删除的函数'
- en: Using unique_ptr to uniquely own a memory resource
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`unique_ptr`来唯一拥有内存资源
- en: Manual handling of heap memory allocation and releasing it (with `new` and `delete`)
    is one of the most controversial features of C++. All allocations must be properly
    paired with a corresponding delete operation in the correct scope. If the memory
    allocation is done in a function and needs to be released before the function
    returns, for instance, then this has to happen on all the return paths, including
    the abnormal situation where a function returns because of an exception. C++11
    features, such as rvalues and move semantics, have enabled the development of
    better smart pointers (since some, such as `auto_ptr`, existed prior to C++11);
    these pointers can manage a memory resource and automatically release it when
    the smart pointer is destroyed. In this recipe, we will look at `std::unique_ptr`,
    a smart pointer that owns and manages another object or an array of objects allocated
    on the heap, and performs the disposal operation when the smart pointer goes out
    of scope.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 手动处理堆内存分配和释放（使用 `new` 和 `delete`）是 C++ 中最具争议的特性之一。所有分配都必须与正确的范围内的相应删除操作正确配对。如果内存分配在函数中完成，并且需要在函数返回之前释放，例如，那么这必须在所有返回路径上发生，包括函数由于异常而返回的不正常情况。C++11
    特性，如右值和移动语义，使得更好的智能指针（因为一些，如 `auto_ptr`，在 C++11 之前就已存在）的开发成为可能；这些指针可以管理内存资源，并在智能指针被销毁时自动释放。在这个菜谱中，我们将查看
    `std::unique_ptr`，这是一个拥有并管理在堆上分配的另一个对象或对象数组的智能指针，并在智能指针超出作用域时执行销毁操作。
- en: Getting ready
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the following examples, we will use the ensuing class:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用以下类：
- en: '[PRE81]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: For this recipe, you need to be familiar with move semantics and the `std::move()`
    conversion function. The `unique_ptr` class is available in the `std` namespace
    in the `<memory>` header.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要熟悉移动语义和 `std::move()` 转换函数。`unique_ptr` 类在 `<memory>` 头文件中的 `std`
    命名空间中可用。
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following is a list of typical operations you need to be aware of when
    working with `std::unique_ptr`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用 `std::unique_ptr` 时需要了解的一些典型操作列表：
- en: 'Use the available overloaded constructors to create a `std::unique_ptr` that
    manages objects or an array of objects through a pointer. The default constructor
    creates a pointer that does not manage any object:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可用的重载构造函数创建一个通过指针管理对象或对象数组的 `std::unique_ptr`。默认构造函数创建一个不管理任何对象的指针：
- en: '[PRE82]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Alternatively, use the `std::make_unique()` function template, available in
    C++14, to create `std::unique_ptr` objects:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，使用 C++14 中可用的 `std::make_unique()` 函数模板创建 `std::unique_ptr` 对象：
- en: '[PRE83]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Use the `std::make_unique_for_overwrite()` function template, available in
    C++20, to create a `std::unique_ptr` to objects or an array of objects that are
    default initialized. These objects should later be overwritten with a determined
    value:'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++20 中可用的 `std::make_unique_for_overwrite()` 函数模板，创建指向默认初始化的对象或对象数组的 `std::unique_ptr`。这些对象应稍后用确定的值覆盖：
- en: '[PRE84]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    `delete` operator is not appropriate for destroying the managed object or array:'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果默认的 `delete` 操作符不适用于销毁托管对象或数组，请使用重载构造函数，该构造函数接受自定义删除器：
- en: '[PRE85]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use `std::move()` to transfer the ownership of an object from one `std::unique_ptr`
    to another:'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::move()` 将对象的所有权从一个 `std::unique_ptr` 转移到另一个：
- en: '[PRE86]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To access the raw pointer to the managed object, use `get()` if you want to
    retain ownership of the object or `release()` if you want to release the ownership
    as well:'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问托管对象的原始指针，如果你想保留对象的所有权，请使用 `get()`；如果你想释放所有权，请使用 `release()`：
- en: '[PRE87]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `operator*` 和 `operator->` 解引用托管对象的指针：
- en: '[PRE88]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If `std::unique_ptr` manages an array of objects, `operator[]` can be used
    to access individual elements of the array:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `std::unique_ptr` 管理一个对象数组，可以使用 `operator[]` 访问数组的单个元素：
- en: '[PRE89]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To check whether `std::unique_ptr` can manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查 `std::unique_ptr` 是否可以管理一个对象，请使用显式操作符 `bool` 或检查 `get() != nullptr`（这是操作符
    `bool` 所做的）：
- en: '[PRE90]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`std::unique_ptr` objects can be stored in a container. Objects returned by
    `make_unique()` can be stored directly. An lvalue object could be statically converted
    to an rvalue object with `std::move()` if you want to give up the ownership of
    the managed object to the `std::unique_ptr` object in the container:'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`对象可以存储在容器中。由`make_unique()`返回的对象可以直接存储。如果想要将管理对象的所有权放弃给容器中的`std::unique_ptr`对象，可以将一个左值对象通过`std::move()`静态转换为右值对象：'
- en: '[PRE91]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How it works...
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::unique_ptr` is a smart pointer that manages an object or an array allocated
    on the heap through a raw pointer. It performs an appropriate disposal when the
    smart pointer goes out of scope, is assigned a new pointer with `operator=`, or
    gives up ownership using the `release()` method. By default, the operator `delete`
    is used to dispose of the managed object. However, the user may supply a custom
    deleter when constructing the smart pointer. This deleter must be a function object,
    either an lvalue reference to a function object or a function, and this callable
    object must take a single argument of the type `unique_ptr<T, Deleter>::pointer`.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`是一个智能指针，它通过原始指针管理在堆上分配的对象或数组。当智能指针超出作用域、被赋予新的指针使用`operator=`或使用`release()`方法放弃所有权时，它会执行适当的销毁操作。默认情况下，使用`delete`运算符来销毁管理对象。然而，用户在构造智能指针时可以提供自定义的销毁器。这个销毁器必须是一个函数对象，要么是一个函数对象的左值引用，要么是一个函数，并且这个可调用对象必须接受一个类型为`unique_ptr<T,
    Deleter>::pointer`的单个参数。'
- en: 'C++14 has added the `std::make_unique()` utility function template to create
    a `std::unique_ptr`. It avoids memory leaks in some particular contexts, but it
    has some limitations:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: C++14添加了`std::make_unique()`实用函数模板来创建`std::unique_ptr`。它在某些特定情况下避免了内存泄漏，但也有一些限制：
- en: It can only be used to allocate arrays; you cannot use it to initialize them,
    which is possible with a `std::unique_ptr` constructor.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能用来分配数组；你不能用它来初始化它们，这是`std::unique_ptr`构造函数所能做到的。
- en: 'The following two pieces of sample code are equivalent:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下两段示例代码是等价的：
- en: '[PRE92]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It cannot be used to create a `std::unique_ptr` object with a user-defined deleter.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能用来创建具有用户定义销毁器的`std::unique_ptr`对象。
- en: 'As we just mentioned, the great advantage of `make_unique()` is that it helps
    us avoid memory leaks in some contexts where exceptions are being thrown. `make_unique()`
    itself can throw `std::bad_alloc` if the allocation fails or any exception is
    thrown by the constructor of the object it creates. Let’s consider the following
    example:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，`make_unique()`的巨大优势是它帮助我们避免在某些抛出异常的上下文中发生内存泄漏。如果分配失败或它创建的对象的构造函数抛出任何异常，`make_unique()`本身可能会抛出`std::bad_alloc`。让我们考虑以下示例：
- en: '[PRE93]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Regardless of what happens with the allocation and construction of `foo`, there
    will be no memory leaks, irrespective of whether you use `make_unique()` or the
    constructor of `std::unique_ptr`. However, this situation changes in a slightly
    different version of the code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`foo`的分配和构造过程中发生什么，都不会有内存泄漏，无论你使用`make_unique()`还是`std::unique_ptr`的构造函数。然而，代码的略微不同版本会导致这种情况发生变化：
- en: '[PRE94]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In this example, `some_other_function()` has an extra parameter: an integer
    value. The integer argument that’s passed to this function is the returned value
    of another function. If this function call throws an exception, using the constructor
    of `std::unique_ptr` to create the smart pointer can produce a memory leak. The
    reason for this is that, upon calling `some_other_function()`, the compiler might
    first call `foo`, then `function_that_throws()`, and then the constructor of `std::unique_ptr`.
    If `function_that_throws()` throws an error, then the allocated `foo` will leak.
    If the calling order is `function_that_throws()` and then `new foo()` and the
    constructor of `unique_ptr`, a memory leak will not happen; this is because the
    stack starts unwinding before the `foo` object is allocated. However, by using
    the `make_unique()` function, this situation is avoided. This is because the only
    calls made are to `make_unique()` and `function_that_throws()`. If `function_that_throws()`
    is called first, then the `foo` object will not be allocated at all. If `make_unique()`
    is called first, the `foo` object is constructed and its ownership is passed to
    `std::unique_ptr`. If a later call to `function_that_throws()` does throw, then
    `std::unique_ptr` will be destroyed when the stack is unwound and the `foo` object
    will be destroyed from the smart pointer’s destructor. C++17 fixed this problem
    by requiring any parameter to be fully evaluated before the next one is started.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`some_other_function()` 有一个额外的参数：一个整数值。传递给这个函数的整数参数是另一个函数的返回值。如果这个函数调用抛出异常，使用
    `std::unique_ptr` 构造函数创建智能指针可能会导致内存泄漏。这是因为，在调用 `some_other_function()` 时，编译器可能会首先调用
    `foo`，然后是 `function_that_throws()`，最后是 `std::unique_ptr` 的构造函数。如果 `function_that_throws()`
    抛出错误，那么分配的 `foo` 将会泄漏。如果调用顺序是 `function_that_throws()` 然后是 `new foo()` 和 `unique_ptr`
    的构造函数，则不会发生内存泄漏；这是因为栈在 `foo` 对象分配之前就开始回溯。然而，通过使用 `make_unique()` 函数，可以避免这种情况。这是因为，唯一调用的函数是
    `make_unique()` 和 `function_that_throws()`。如果首先调用 `function_that_throws()`，则 `foo`
    对象根本不会分配。如果首先调用 `make_unique()`，则 `foo` 对象将被构造，并且其所有权将传递给 `std::unique_ptr`。如果稍后调用
    `function_that_throws()` 抛出异常，那么当栈回溯时，`std::unique_ptr` 将被销毁，并且 `foo` 对象将从智能指针的析构函数中销毁。C++17
    通过要求在开始下一个参数之前必须完全评估任何参数来解决这个问题。
- en: In C++20, a new function, called `std::make_unique_for_overwrite()`, has been
    added. This is similar to `make_unique()` except that its default initializes
    the object or the array of objects. This function can be used in generic code
    where it’s unknown whether the type template parameter is trivially copyable or
    not. This function expresses the intent to create a pointer to an object that
    may not be initialized so that it should be overwritten later.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，添加了一个名为 `std::make_unique_for_overwrite()` 的新函数。这与 `make_unique()`
    类似，但它的默认值初始化对象或对象数组。此函数可用于泛型代码，其中不知道类型模板参数是否是平凡的复制的。此函数表达了创建指向可能未初始化的对象的指针的意图，以便稍后可以覆盖它。
- en: Constant `std::unique_ptr` objects cannot transfer the ownership of a managed
    object or array to another `std::unique_ptr` object. On the other hand, access
    to the raw pointer to the managed object can be obtained with either `get()` or
    `release()`. The first method only returns the underlying pointer, but the latter
    also releases the ownership of the managed object, hence the name. After a call
    to `release()`, the `std::unique_ptr` object will be empty and a call to `get()`
    will return `nullptr`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 常量 `std::unique_ptr` 对象不能将管理对象或数组的所有权转移到另一个 `std::unique_ptr` 对象。另一方面，可以通过 `get()`
    或 `release()` 获取管理对象的原始指针。第一种方法仅返回底层指针，但后者也释放了管理对象的所有权，因此得名。在调用 `release()` 之后，`std::unique_ptr`
    对象将变为空，调用 `get()` 将返回 `nullptr`。
- en: 'A `std::unique_ptr` that manages the object of a `Derived` class can be implicitly
    converted to a `std::unique_ptr` that manages an object of the class `Base` if
    `Derived` is derived from `Base`. This implicit conversion is safe only if `Base`
    has a virtual destructor (as all base classes should have); otherwise, undefined
    behavior is employed:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 `Derived` 类对象的 `std::unique_ptr` 可以隐式转换为管理 `Base` 类对象的 `std::unique_ptr`，如果
    `Derived` 从 `Base` 继承。这种隐式转换只有在 `Base` 有虚拟析构函数（所有基类都应该有）的情况下才是安全的；否则，将执行未定义的行为：
- en: '[PRE95]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output from running this snippet is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段的输出如下：
- en: '[PRE96]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '`std::unique_ptr` can be stored in containers, such as `std::vector`. Because
    only one `std::unique_ptr` object can own the managed object at any point, the
    smart pointer cannot be copied to the container; it has to be moved. This is possible
    with `std::move()`, which performs a `static_cast` to an rvalue reference type.
    This allows the ownership of the managed object to be transferred to the `std::unique_ptr`
    object that is created in the container.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 可以存储在容器中，例如 `std::vector`。因为任何时刻只有一个 `std::unique_ptr` 对象可以拥有被管理的对象，所以智能指针不能被复制到容器中；它必须被移动。这可以通过
    `std::move()` 实现，它执行了一个 `static_cast` 到右值引用类型。这允许将管理对象的所有权转移到容器中创建的 `std::unique_ptr`
    对象。'
- en: See also
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using shared_ptr to share a memory resource*, to learn about the `std::shared_ptr`
    class, which represents a smart pointer that shares ownership of an object or
    array of objects allocated on the heap'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `shared_ptr` 共享内存资源*，了解 `std::shared_ptr` 类，它表示一个智能指针，它共享堆上分配的对象或对象数组的所有权'
- en: Using shared_ptr to share a memory resource
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `shared_ptr` 共享内存资源
- en: Managing dynamically allocated objects or arrays with `std::unique_ptr` is not
    possible when the object or array has to be shared. This is because a `std::unique_ptr`
    retains its sole ownership. The C++ standard provides another smart pointer, called
    `std::shared_ptr`; it is similar to `std::unique_ptr` in many ways, but the difference
    is that it can share the ownership of an object or array with other `std::shared_ptr`
    objects. In this recipe, we will see how `std::shared_ptr` works and how it differs
    from `std::uniqueu_ptr`. We will also look at `std::weak_ptr`, which is a non-resource-owning
    smart pointer that holds a reference to an object managed by a `std::shared_ptr`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象或数组需要共享时，无法使用 `std::unique_ptr` 来管理动态分配的对象或数组。这是因为 `std::unique_ptr` 保留其唯一所有权。C++
    标准提供了一个名为 `std::shared_ptr` 的另一个智能指针；它在许多方面与 `std::unique_ptr` 类似，但不同之处在于它可以与其他
    `std::shared_ptr` 对象共享对象或数组的所有权。在本配方中，我们将了解 `std::shared_ptr` 的工作原理以及它与 `std::unique_ptr`
    的区别。我们还将查看 `std::weak_ptr`，它是一个非资源拥有智能指针，它持有由 `std::shared_ptr` 管理的对象的引用。
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you read the previous recipe, *Using unique_ptr to uniquely own a
    memory resource*, to become familiar with how `unique_ptr` and `make_unique()`
    work. We will use the `foo`, `foo_deleter`, `Base`, and `Derived` classes defined
    in this recipe, and also make several references to it.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经阅读了之前的配方，*使用 `unique_ptr` 唯一拥有内存资源*，以熟悉 `unique_ptr` 和 `make_unique()`
    的工作方式。我们将使用本配方中定义的 `foo`、`foo_deleter`、`Base` 和 `Derived` 类，并对其进行多次引用。
- en: Both the `shared_ptr` and `weak_ptr` classes, as well as the `make_shared()`
    function template, are available in the `std` namespace in the `<memory>` header.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr` 和 `weak_ptr` 类以及 `make_shared()` 函数模板都包含在 `<memory>` 头文件中的 `std`
    命名空间中。'
- en: For simplicity and readability, we will not use the fully qualified names `std::unique_ptr`,
    `std::shared_ptr`, and `std::weak_ptr` in this recipe, but `unique_ptr`, `shared_ptr`,
    and `weak_ptr`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和可读性，我们不会在本配方中使用完全限定的名称 `std::unique_ptr`、`std::shared_ptr` 和 `std::weak_ptr`，而是使用
    `unique_ptr`、`shared_ptr` 和 `weak_ptr`。
- en: How to do it...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of the typical operations you need to be aware of when
    working with `shared_ptr` and `weak_ptr`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用 `shared_ptr` 和 `weak_ptr` 时需要了解的典型操作的列表：
- en: 'Use one of the available overloaded constructors to create a `shared_ptr` that
    manages an object through a pointer. The default constructor creates an empty
    `shared_ptr`, which does not manage any object:'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可用的重载构造函数之一来创建一个通过指针管理对象的 `shared_ptr`。默认构造函数创建一个空的 `shared_ptr`，它不管理任何对象：
- en: '[PRE97]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternatively, use the `std::make_shared()` function template, available since
    C++11, to create `shared_ptr` objects:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，使用自 C++11 起可用的 `std::make_shared()` 函数模板来创建 `shared_ptr` 对象：
- en: '[PRE98]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Use the `std::make_shared_for_overwrite()` function template, available in
    C++20, to create `shared_ptr`s to objects or arrays of objects that are default
    initialized. These objects should later be overwritten with a determined value:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++20 中可用的 `std::make_shared_for_overwrite()` 函数模板来创建指向默认初始化的对象或对象数组的 `shared_ptr`。这些对象应稍后用确定的值覆盖：
- en: '[PRE99]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Use the overloaded constructor, which takes a custom deleter if the default
    delete operation is not appropriate for destroying the managed object:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果默认的删除操作不适用于销毁被管理的对象，请使用重载的构造函数，它接受一个自定义删除器：
- en: '[PRE100]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Always specify a deleter when managing an array of objects. The deleter can
    either be a partial specialization of `std::default_delete` for arrays or any
    function that takes a pointer to the template type:'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管理对象的数组时，始终指定一个删除器。删除器可以是 `std::default_delete` 的数组部分特化，或者任何接受模板类型指针的函数：
- en: '[PRE101]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To access the raw pointer to the managed object, use the `get()` function:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要访问管理对象的原始指针，请使用 `get()` 函数：
- en: '[PRE102]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Dereference the pointer to the managed object using `operator*` and `operator->`:'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `operator*` 和 `operator->` 解引用管理对象的指针：
- en: '[PRE103]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If a `shared_ptr` manages an array of objects, `operator[]` can be used to
    access the individual elements of the array. This is only available in C++17:'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `shared_ptr` 管理对象的数组，可以使用 `operator[]` 访问数组的各个元素。这仅在 C++17 中可用：
- en: '[PRE104]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To check whether a `shared_ptr` could manage an object or not, use the explicit
    operator `bool` or check whether `get() != nullptr` (which is what the operator
    `bool` does):'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要检查 `shared_ptr` 是否可以管理一个对象，请使用显式操作符 `bool` 或检查 `get() != nullptr`（这是操作符 `bool`
    所做的）：
- en: '[PRE105]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`shared_ptr` objects can be stored in containers, such as `std::vector`:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr` 对象可以存储在容器中，例如 `std::vector`：'
- en: '[PRE106]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use `weak_ptr` to maintain a non-owning reference to a shared object, which
    can be later accessed through a `shared_ptr` constructed from the `weak_ptr` object:'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `weak_ptr` 维护对共享对象的非拥有引用，稍后可以通过从 `weak_ptr` 对象构造的 `shared_ptr` 访问：
- en: '[PRE107]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Use the `std::enable_shared_from_this` class template as the base class for
    a type when you need to create `shared_ptr` objects for instances that are already
    managed by another `shared_ptr` object:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要为已由另一个 `shared_ptr` 对象管理的实例创建 `shared_ptr` 对象时，请将 `std::enable_shared_from_this`
    类模板用作类型的基类：
- en: '[PRE108]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works...
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`shared_ptr` is very similar to `unique_ptr` in many aspects; however, it serves
    a different purpose: sharing the ownership of an object or array. Two or more
    `shared_ptr` smart pointers can manage the same dynamically allocated object or
    array, which is automatically destroyed when the last smart pointer goes out of
    scope, is assigned a new pointer with `operator=`, or is reset with the method
    `reset()`. By default, the object is destroyed with `operator delete`; however,
    the user could supply a custom deleter to the constructor, something that is not
    possible using `std::make_shared()`. If `shared_ptr` is used to manage an array
    of objects, a custom deleter must be supplied. In this case, you can use `std::default_delete<T[]>`,
    which is a partial specialization of the `std::default_delete` class template
    that uses `operator delete[]` to delete the dynamically allocated array.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，`shared_ptr` 与 `unique_ptr` 非常相似；然而，它服务于不同的目的：共享对象或数组的所有权。两个或多个 `shared_ptr`
    智能指针可以管理同一个动态分配的对象或数组，当最后一个智能指针超出作用域、使用 `operator=` 分配新指针或使用 `reset()` 方法重置时，该对象或数组将被自动销毁。默认情况下，对象使用
    `operator delete` 销毁；然而，用户可以向构造函数提供一个自定义删除器，这是使用 `std::make_shared()` 所不可能做到的。如果
    `shared_ptr` 用于管理对象的数组，必须提供一个自定义删除器。在这种情况下，你可以使用 `std::default_delete<T[]>`，它是
    `std::default_delete` 类模板的部分特化，使用 `operator delete[]` 来删除动态分配的数组。
- en: 'The utility function `std::make_shared()` (available since C++11), unlike `std::make_unique()`,
    which has only been available since C++14, should be used to create smart pointers
    unless you need to provide a custom deleter. The primary reason for this is the
    same as for `make_unique()`: avoiding potential memory leaks in some contexts
    when an exception is thrown. For more information on this, read the explanation
    provided on `std::make_unique()` in the previous recipe.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 与自 C++14 才可用的 `std::make_unique()` 不同，`std::make_shared()`（自 C++11 起可用）应用于创建智能指针，除非你需要提供一个自定义删除器。主要原因与
    `make_unique()` 相同：避免在某些上下文中抛出异常时潜在的内存泄漏。有关更多信息，请阅读前一道菜谱中提供的 `std::make_unique()`
    的解释。
- en: In C++20, a new function, called `std::make_shared_for_overwrite()`, has been
    added. This is similar to `make_shared()` except that it default initializes the
    object or the array of objects. This function can be used in generic code where
    it’s unknown whether the type template parameter is trivially copyable or not.
    This function expresses the intent to create a pointer to an object that may not
    be initialized so that it should be overwritten later.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++20 中，添加了一个新的函数，称为 `std::make_shared_for_overwrite()`。这个函数与 `make_shared()`
    类似，但默认初始化对象或对象数组。这个函数可以在未知类型模板参数是否是平凡可复制的泛型代码中使用。这个函数表达了创建一个可能未初始化的对象的指针的意图，以便稍后可以覆盖它。
- en: 'Also, as in the case of `unique_ptr`, a `shared_ptr` that manages an object
    of a `Derived` class can be implicitly converted to a `shared_ptr` that manages
    an object of the `Base` class. This is possible if the `Derived` class is derived
    from `Base`. This implicit conversion is safe only if `Base` has a virtual destructor
    (as all the base classes should have when objects are supposed to be deleted polymorphically
    through a pointer or reference to the base class); otherwise, undefined behavior
    is employed. In C++17, several new non-member functions have been added: `std::static_pointer_cast()`,
    `std::dynamic_pointer_cast()`, `std::const_pointer_cast()`, and `std::reinterpret_pointer_cast()`.
    These apply `static_cast`, `dynamic_cast`, `const_cast`, and `reinterpret_cast`
    to the stored pointer, returning a new `shared_ptr` to the designated type.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与 `unique_ptr` 的情况类似，一个管理 `Derived` 类对象的 `shared_ptr` 可以隐式转换为管理 `Base` 类对象的
    `shared_ptr`。这只有在 `Derived` 类从 `Base` 类派生时才可能。这种隐式转换只有在 `Base` 类有一个虚析构函数（正如所有基类在应该通过基类的指针或引用多态删除对象时应该有的那样）时才是安全的；否则，将执行未定义的行为。在
    C++17 中，添加了几个新的非成员函数：`std::static_pointer_cast()`、`std::dynamic_pointer_cast()`、`std::const_pointer_cast()`
    和 `std::reinterpret_pointer_cast()`。这些函数将 `static_cast`、`dynamic_cast`、`const_cast`
    和 `reinterpret_cast` 应用于存储的指针，并返回一个新的指向指定类型的 `shared_ptr`。
- en: 'In the following example, `Base` and `Derived` are the same classes we used
    in the previous recipe:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Base` 和 `Derived` 是我们在上一个示例中使用的相同类：
- en: '[PRE109]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: There are situations when you need a smart pointer for a shared object but without
    it contributing to the shared ownership. Suppose you model a tree structure where
    a node has references to its children and they are represented by `shared_ptr`
    objects. On the other hand, say a node needs to keep a reference to its parent.
    If this reference were also `shared_ptr`, then it would create circular references
    and no object would ever be automatically destroyed.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要一个智能指针来管理共享对象，但又不希望它对共享所有权做出贡献。假设你模拟一个树结构，其中节点对其子节点有引用，并且它们由 `shared_ptr`
    对象表示。另一方面，假设一个节点需要保持对其父节点的引用。如果这个引用也是 `shared_ptr`，那么它将创建循环引用，并且没有任何对象会被自动销毁。
- en: '`weak_ptr` is a smart pointer that’s used to break such circular dependencies.
    It holds a non-owning reference to an object or array managed by a `shared_ptr`.
    `weak_ptr` can be created from a `shared_ptr` object. In order to access the managed
    object, you need to get a temporary `shared_ptr` object. To do so, we need to
    use the `lock()` method. This method atomically checks whether the referred object
    still exists and returns either an empty `shared_ptr`, if the object no longer
    exists, or a `shared_ptr` that owns the object, if it still exists. Because `weak_ptr`
    is a non-owning smart pointer, the referred object can be destroyed before `weak_ptr`
    goes out of scope or when all the owning `shared_ptr` objects have been destroyed,
    reset, or assigned to other pointers. The method `expired()` can be used to check
    whether the referenced object has been destroyed or is still available.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr` 是一种智能指针，用于打破这种循环依赖。它持有对由 `shared_ptr` 管理的对象或数组的非拥有引用。可以从 `shared_ptr`
    对象创建 `weak_ptr`。为了访问管理的对象，你需要获取一个临时的 `shared_ptr` 对象。为此，我们需要使用 `lock()` 方法。此方法原子性地检查所引用的对象是否仍然存在，如果对象不再存在，则返回一个空的
    `shared_ptr`，如果对象仍然存在，则返回一个拥有该对象的 `shared_ptr`。由于 `weak_ptr` 是一个非拥有智能指针，因此所引用的对象可以在
    `weak_ptr` 超出作用域之前或当所有拥有 `shared_ptr` 对象被销毁、重置或分配给其他指针时被销毁。可以使用 `expired()` 方法来检查所引用的对象是否已被销毁或仍然可用。'
- en: In the *How to do it...* section, the preceding example models a master-apprentice
    relationship. There is a `Master` class and an `Apprentice` class. The `Master`
    class has a reference to an `Apprentice` class and a method called `take_apprentice()`
    to set the `Apprentice` object. The `Apprentice` class has a reference to a `Master`
    class and the method `take_master()` to set the `Master` object. In order to avoid
    circular dependencies, one of these references must be represented by a `weak_ptr`.
    In the proposed example, the `Master` class had a `shared_ptr` to own the `Apprentice`
    object, and the `Apprentice` class had a `weak_ptr` to track a reference to the
    `Master` object. This example, however, is a bit more complex because here, the
    `Apprentice::take_master()` method is called from `Master::take_apprentice()`
    and needs a `weak_ptr<Master>`. In order to call it from within the `Master` class,
    we must be able to create a `shared_ptr<Master>` in the `Master` class, using
    the `this` pointer. The only way to do this in a safe manner is to use `std::enable_shared_from_this`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分，前面的示例模拟了一个师徒关系。有一个`Master`类和一个`Apprentice`类。`Master`类有一个对`Apprentice`类的引用和一个名为`take_apprentice()`的方法来设置`Apprentice`对象。`Apprentice`类有一个对`Master`类的引用和一个名为`take_master()`的方法来设置`Master`对象。为了避免循环依赖，这些引用中的一个必须由一个`weak_ptr`表示。在提出的示例中，`Master`类有一个`shared_ptr`来拥有`Apprentice`对象，而`Apprentice`类有一个`weak_ptr`来跟踪对`Master`对象的引用。然而，这个示例稍微复杂一些，因为在这里，`Apprentice::take_master()`方法是从`Master::take_apprentice()`中调用的，并且需要一个`weak_ptr<Master>`。为了在`Master`类内部调用它，我们必须能够在`Master`类中使用`this`指针创建一个`shared_ptr<Master>`。在安全的方式中做到这一点的唯一方法是使用`std::enable_shared_from_this`。
- en: '`std::enable_shared_from_this` is a class template that must be used as a base
    class for all the classes where you need to create a `shared_ptr` for the current
    object (the `this` pointer) when this object is already managed by another `shared_ptr`.
    Its type template parameter must be the class that derives from it, as in the
    curiously recurring template pattern. It has two methods: `shared_from_this()`,
    which returns a `shared_ptr`, which shares the ownership of the `this` object,
    and `weak_from_this()`, which returns a `weak_ptr`, which shares a non-owning
    reference to the `this` object. The latter method is only available in C++17\.
    These methods can be called only on an object that is managed by an existing `shared_ptr`;
    otherwise, they throw a `std::bad_weak_ptr` exception, as of C++17\. Prior to
    C++17, the behavior was undefined.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::enable_shared_from_this`是一个类模板，必须用作所有需要为当前对象（`this`指针）创建`shared_ptr`的类的基类，当此对象已被另一个`shared_ptr`管理时。它的类型模板参数必须是派生自它的类，就像在好奇的递归模板模式中一样。它有两个方法：`shared_from_this()`，它返回一个`shared_ptr`，共享`this`对象的拥有权，和`weak_from_this()`，它返回一个`weak_ptr`，共享对`this`对象的非拥有引用。后者方法仅在C++17中可用。这些方法只能在由现有`shared_ptr`管理的对象上调用；否则，它们会抛出`std::bad_weak_ptr`异常，自C++17起。在C++17之前，行为是未定义的。'
- en: Not using `std::enable_shared_from_this` and creating a `shared_ptr<T>(this)`
    directly would lead to having multiple `shared_ptr` objects managing the same
    object independently, without knowing each other. When this happens, the object
    ends up being destroyed multiple times by different `shared_ptr` objects.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用`std::enable_shared_from_this`并直接创建`shared_ptr<T>(this)`会导致有多个`shared_ptr`对象独立管理同一个对象，彼此之间不知道。当这种情况发生时，对象最终会被不同的`shared_ptr`对象多次销毁。
- en: See also
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using unique_ptr to uniquely own a memory resource*, to learn about the `std::unique_ptr`
    class, which represents a smart pointer that owns and manages another object or
    array of objects allocated on the heap'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`unique_ptr`来唯一拥有内存资源*，学习`std::unique_ptr`类，它代表一个智能指针，它拥有并管理在堆上分配的另一个对象或对象数组'
- en: Consistent comparison with the operator <=>
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与操作符`<=>`的一致比较
- en: 'The C++ language defines six relational operators that perform comparison:
    `==`, `!=`, `<`, `<=`, `>`, and `>=`. Although `!=` can be implemented in terms
    of `==`, and `<=`, `>=`, and `>` in terms of `<`, you still have to implement
    both `==` and `!=` if you want your user-defined type to support equality comparison,
    and `<`, `<=`, `>`, and `>=` if you want it to support ordering.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言定义了六个关系运算符来执行比较：`==`、`!=`、`<`、`<=`、`>`和`>=`。尽管`!=`可以用`==`来实现，而`<=`、`>=`和`>`可以用`<`来实现，但如果你想让用户定义的类型支持相等比较，你仍然必须实现`==`和`!=`；如果你想让它支持排序，你必须实现`<`、`<=`、`>`和`>=`。
- en: That means 6 functions if you want objects of your type—let’s call it `T`—to
    be comparable, 12 if you want them to be comparable with another type, `U`, 18
    if you also want values of a `U` type to be comparable with your `T` type, and
    so on. The new C++20 standard reduces this number to either one or two, or multiple
    of these (depending on the comparison with other types) by introducing a new comparison
    operator, called *the three-way comparison*, which is designated with the symbol
    `<=>`, for which reason it is popularly known as the *spaceship operator*. This
    new operator helps us write less code, better describe the strength of relations,
    and avoid possible performance issues that come from manually implementing comparison
    operators in terms of others.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你的类型——让我们称它为 `T`——的对象要可比较，那么需要 6 个函数；如果它们要与另一个类型 `U` 可比较，则需要 12 个函数；如果还要使
    `U` 类型的值与你的 `T` 类型可比较，则需要 18 个函数，依此类推。新的 C++20 标准通过引入一个新的比较操作符，称为三向比较，将这个数字减少到
    1 或 2，或者这些数字的倍数（取决于与其他类型的比较），这个新的比较操作符用符号 `<=>` 表示，因此它通常被称为 *飞船操作符*。这个新操作符帮助我们编写更少的代码，更好地描述关系的强度，并避免手动实现比较操作符时可能出现的性能问题。
- en: Getting ready
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is necessary to include the header `<compare>` when defining or implementing
    the three-way comparison operator. This new C++20 header is part of the standard
    general utility library and provides classes, functions, and concepts for implementing
    comparison.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义或实现三向比较操作符时，必须包含头文件 `<compare>`。这个新的 C++20 头文件是标准通用工具库的一部分，它提供了用于实现比较的类、函数和概念。
- en: How to do it…
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To optimally implement comparison in C++20, do the following:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C++20 中最优地实现比较，请执行以下操作：
- en: 'If you only want your type to support equality comparison (both `==` and `!=`),
    implement only the `==` operator and return a `bool`. You can default the implementation
    so that the compiler performs a member-wise comparison:'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想让你的类型支持相等比较（包括 `==` 和 `!=`），则只需实现 `==` 操作符并返回一个 `bool`。你可以默认实现，以便编译器执行逐成员比较：
- en: '[PRE110]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If you want your type to support both equality and ordering and the default
    member-wise comparison will do, then only define the `<=>` operator, returning
    `auto`, and default its implementation:'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望你的类型同时支持相等和排序，并且默认的成员比较就足够了，那么只需定义 `<=>` 操作符，返回 `auto`，并默认其实现：
- en: '[PRE111]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'If you want your type to support both equality and ordering and you need to
    perform custom comparison, then implement both the `==` operator (for equality)
    and the `<=>` operator (for ordering):'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望你的类型同时支持相等和排序，并且需要执行自定义比较，那么实现 `==` 操作符（用于相等）和 `<=>` 操作符（用于排序）：
- en: '[PRE112]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'When implementing the three-way comparison operator, follow these guidelines:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现三向比较操作符时，请遵循以下指南：
- en: Only implement the three-way comparison operator but always use the two-way
    comparison operators `<`, `<=`, `>`, and `>=` when comparing values.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅实现三向比较操作符，但在比较值时始终使用双向比较操作符 `<`、`<=`、`>` 和 `>=`。
- en: Implement the three-way comparison operator as a member function, even if you
    want the first operand of a comparison to be of a type other than your class.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你想要比较操作符的第一个操作数是除你的类之外的其他类型，也要将三向比较操作符实现为成员函数。
- en: Implement the three-way comparison operator as non-member functions only if
    you want implicit conversion on both arguments (that means comparing two objects,
    neither of which is of your class).
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当你在两个参数上想要隐式转换时，才将三向比较操作符实现为非成员函数（这意味着比较两个对象，它们都不是你的类）。
- en: How it works…
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The new three-way comparison operator is similar to the `memcmp()`/`strcmp()`
    C functions and the `std::string::compare()` method. These functions take two
    arguments and return an integer value that is smaller than zero if the first is
    less than the second, zero if they are equal, or greater than zero if the first
    argument is greater than the second. The three-way comparison operator does not
    return an integer but a value of a comparison category type.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 新的三向比较操作符类似于 `memcmp()`/`strcmp()` C 函数和 `std::string::compare()` 方法。这些函数接受两个参数，并返回一个整数值，如果第一个小于第二个，则返回小于零的值；如果它们相等，则返回零；如果第一个参数大于第二个参数，则返回大于零的值。三向比较操作符不返回整数，而是返回比较类别类型的值。
- en: 'This can be one of the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是以下之一：
- en: '`std::strong_ordering` represents the result of a three-way comparison that
    supports all six relational operators, does not allow incomparable values (which
    means that at least one of `a < b`, `a == b`, and `a > b` must be true), and implies
    substitutability. This is a property such that if `a == b` and `f` is a function
    that reads only comparison-salient state (accessible via the argument’s public
    constant members), then `f(a) == f(b)`.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::strong_ordering` 表示支持所有六个关系运算符的三向比较的结果，不允许不可比较的值（这意味着 `a < b`、`a == b`
    和 `a > b` 至少有一个必须为真），并且意味着可替换性。这是一个属性，如果 `a == b` 并且 `f` 是一个只读取比较显著状态（通过参数的公共常量成员访问）的函数，那么
    `f(a) == f(b)`。'
- en: '`std::weak_ordering` supports all the six relational operators, does not support
    incomparable values (which means that none of `a < b`, `a == b`, and `a > b` could
    be true), but also does not imply substitutability. A typical example of a type
    that defines weak ordering is a case-insensitive string type.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::weak_ordering` 支持所有六个关系运算符，不支持不可比较的值（这意味着 `a < b`、`a == b` 和 `a > b`
    都可能不为真），但也不意味着可替换性。一个典型的定义弱排序的类型是无大小写敏感的字符串类型。'
- en: '`std::partial_ordering` supports all six relational operators but does not
    imply substitutability and has a value that might not be comparable (for instance,
    a floating-point `NaN` cannot be compared to any other value).'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_ordering` 支持所有六个关系运算符，但不意味着可替换性，并且其值可能不可比较（例如，浮点数 `NaN` 不能与任何其他值进行比较）。'
- en: 'The `std::strong_ordering` type is the strongest of all these category types.
    It is not implicitly convertible from any other category, but it implicitly converts
    to both `std::weak_ordering` and `std::partial_ordering`. `std::weak_ordering`
    is also implicitly convertible to `std::partial_ordering`. We’ve summarized all
    these properties in the following table:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::strong_ordering` 类型是所有这些类别类型中最强的。它不能隐式转换为任何其他类别，但它可以隐式转换为 `std::weak_ordering`
    和 `std::partial_ordering`。`std::weak_ordering` 也可以隐式转换为 `std::partial_ordering`。我们已在以下表格中总结了所有这些属性：'
- en: '| **Category** | **Operators** | **Substitutability** | **Comparable values**
    | **Implicit conversion** |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **运算符** | **可替换性** | **可比较值** | **隐式转换** |'
- en: '| `std::strong_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | Yes | Yes | ![](img/B21549_09_001.png)
    |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `std::strong_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | 是 | 是 | ![](img/B21549_09_001.png)
    |'
- en: '| `std::weak_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | Yes | ![](img/B21549_09_001.png)
    |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `std::weak_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | 否 | 是 | ![](img/B21549_09_001.png)
    |'
- en: '| `std::partial_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | No | No |  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `std::partial_ordering` | `==`, `!=`, `<`, `<=`, `>`, `>=` | 否 | 否 |  |'
- en: 'Table 9.2: Properties of the category types'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.2：类别类型属性
- en: 'These comparison categories have values that are implicitly comparable with
    literal zero (but not with an integer variable that is zero). Their values are
    listed in the following table:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较类别具有隐式可比较于文字零（但不能与零的整数变量）的值。它们的值列在以下表格中：
- en: '| **Category** | **Numeric values** | **Non-numeric values** |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **数值** | **非数值** |'
- en: '| -1 | 0 | 1 |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 0 | 1 |'
- en: '| `strong_ordering` | less | equalequivalent | greater |  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| `strong_ordering` | 小于 | 等价 | 大于 |  |'
- en: '| `weak_ordering` | less | equivalent | greater |  |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `weak_ordering` | 小于 | 等价 | 大于 |  |'
- en: '| `partial_ordering` | less | equivalent | greater | unordered |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `partial_ordering` | 小于 | 等价 | 大于 | 无序 |'
- en: 'Table 9.3: The values of the comparison categories that are implicitly comparable
    to literal zero'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.3：隐式可比较于文字零的比较类别值
- en: 'To better understand how this works, let’s look at the following example:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解其工作原理，让我们看看以下示例：
- en: '[PRE113]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Here, `cost_unit_t` is a base class that contains some (unspecified) data members
    and defines the `<=>` operator, although it is default-implemented by the compiler.
    This means that the compiler will also provide the `==` and `!=` operators, not
    just `<`, `<=`, `>`, and `>=`. This class is derived by `project_t`, which contains
    several data fields: an identifier for the project, a type, and a name. However,
    for this type, we cannot default the implementation of the operators, because
    we do not want to compare the fields member-wise, but in a custom order: first
    the name, then the type, and lastly the identifier. In this case, we implement
    both the `==` operator, which returns a `bool` and tests the member fields for
    equality, and the `<=>` operator, which returns `std::strong_ordering` and uses
    the `<=>` operator itself to compare the values of its two arguments.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cost_unit_t`是一个基类，它包含一些（未指定的）数据成员并定义了`<=>`运算符，尽管它是由编译器默认实现的。这意味着编译器还将提供`==`和`!=`运算符，而不仅仅是`<`、`<=`、`>`和`>=`。这个类通过`project_t`派生，它包含几个数据字段：项目的标识符、类型和名称。然而，对于这种类型，我们不能默认实现运算符的实现，因为我们不想逐字段比较成员，而是按照自定义的顺序：首先是名称，然后是类型，最后是标识符。在这种情况下，我们实现了`==`运算符，它返回`bool`并测试成员字段是否相等，以及`<=>`运算符，它返回`std::strong_ordering`并使用其自身的`<=>`运算符来比较两个参数的值。
- en: '[PRE114]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The methods `is_same()`, `is_manager_of()`, and `is_managed_by()` return the
    relationship of two employees. However, it is possible there are employees with
    no relationship; for instance, employees in different teams, or a team without
    a manager-subordinate structure. Here, we can implement equality and ordering.
    However, since we cannot compare all employees with each other, the `<=>` operator
    must return a `std::partial_ordering` value. The return value is `partial_ordering::equivalent`
    if the values represent the same employee, `partial_ordering::less` if the current
    employee is managed by the supplied one, `partial_ordering::greater` if the current
    employee is the manager of the supplied one, and `partial_ordering::unorder` in
    all other cases.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_same()`、`is_manager_of()`和`is_managed_by()`方法返回两个员工之间的关系。然而，可能存在没有关系的员工；例如，来自不同团队的员工，或者没有经理-下属结构的团队。在这里，我们可以实现相等和排序。然而，由于我们不能比较所有员工，`<=>`运算符必须返回`std::partial_ordering`值。如果值代表相同的员工，则返回值是`partial_ordering::equivalent`；如果当前员工由提供的员工管理，则返回`partial_ordering::less`；如果当前员工是提供的员工的管理者，则返回`partial_ordering::greater`；在其他所有情况下返回`partial_ordering::unorder`。'
- en: 'Let’s see one more example to understand how the three-way comparison operator
    works. In the following sample, the `ipv4` class models an IP version 4 address.
    It supports comparison with both other objects of the `ipv4` type but also `unsigned
    long` values (because there is a `to_unlong()` method that converts the IP address
    into a 32-bit unsigned integral value):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子来理解三向比较运算符是如何工作的。在以下示例中，`ipv4`类模拟了一个IP版本4地址。它支持与其他`ipv4`类型的对象以及`unsigned
    long`值的比较（因为有一个`to_unlong()`方法，它将IP地址转换为32位无符号整数值）：
- en: '[PRE116]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In this example, we overloaded the `<=>` operator and allowed it to be default
    implemented. But we also explicitly implemented overloads for `operator==` and
    `operator<=>`, which compare an `ipv4` object with an `unsigned long` value. Because
    of these operators, we can write any of the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们重载了`<=>`运算符并允许它默认实现。但我们还明确实现了`operator==`和`operator<=>`的重载，这些运算符用于比较`ipv4`对象与`unsigned
    long`值。因为这些运算符，我们可以写出以下任何一种形式：
- en: '[PRE117]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'There are two things to notice here: the first is that although we only overloaded
    the `==` operator, we can also use the `!=` operator, and second, although we
    overloaded the `==` operator and the `<=>` operator to compare `ipv4` values to
    `unsigned long` values, we can also compare `unsigned long` values to `ipv4` values.
    This is because the compiler performs symmetrical overload resolution. That means
    that for an expression `a@b` where `@` is a two-way relational operator, it performs
    name lookup for `a@b`, `a<=>b`, and `b<=>a`. The following table shows the list
    of all possible transformations of the relational operators:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方：第一个是，尽管我们只重载了`==`运算符，我们也可以使用`!=`运算符；第二个是，尽管我们重载了`==`运算符和`<=>`运算符来比较`ipv4`值与`unsigned
    long`值，我们也可以比较`unsigned long`值与`ipv4`值。这是因为编译器执行对称重载解析。这意味着对于表达式`a@b`（其中`@`是一个双向关系运算符），它执行`a@b`、`a<=>b`和`b<=>a`的名称查找。以下表格显示了所有可能的关系运算符转换：
- en: '| `a == b` | `b == a` |  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| `a == b` | `b == a` |  |'
- en: '| `a != b` | `!(a == b)` | `!(b == a)` |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| `a != b` | `!(a == b)` | `!(b == a)` |'
- en: '| `a <=> b` | `0 <=> (b <=> a)` |  |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| `a <=> b` | `0 <=> (b <=> a)` |  |'
- en: '| `a < b` | `(a <=> b) < 0` | `0 > (b <=> a)` |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| `a < b` | `(a <=> b) < 0` | `0 > (b <=> a)` |'
- en: '| `a <= b` | `(a <=> b) <= 0` | `0 >= (b <=> a)` |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| `a <= b` | `(a <=> b) <= 0` | `0 >= (b <=> a)` |'
- en: '| `a > b` | `(a <=> b) > 0` | `0 < (b <=> a)` |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| `a > b` | `(a <=> b) > 0` | `0 < (b <=> a)` |'
- en: '| `a >= b` | `(a <=> b) >= 0` | `0 <= (b <=> a)` |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| `a >= b` | `(a <=> b) >= 0` | `0 <= (b <=> a)` |'
- en: 'Table 9.4: The possible transformations of the relational operators'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.4：关系运算符的可能转换
- en: This greatly reduces the number of overloads you must explicitly provide for
    supporting comparison in different forms. The three-way comparison operator can
    be implemented either as a member or as a non-member function. In general, you
    should prefer the member implementation.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大减少了你必须显式提供的重载数量，以支持不同形式的比较。三向比较运算符可以实施为成员函数或非成员函数。通常，你应该优先选择成员实现。
- en: 'The non-member form should be used only when you want implicit conversion on
    both arguments. The following shows an example:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你想要两个参数都进行隐式转换时才应使用非成员形式。以下是一个示例：
- en: '[PRE118]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Although the `<=>` operator is defined for the type `B`, because it is a non-member
    and because `A` can be implicitly converted to `B`, we can perform a comparison
    on objects of the `A` type.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`<=>`运算符为类型`B`定义，因为它是一个非成员运算符，并且由于`A`可以隐式转换为`B`，我们可以对`A`类型的对象执行比较操作。
- en: See also
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 1*, *Simplifying code with class template argument deduction*, to
    learn how to use class templates without explicitly specifying template arguments'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用类模板参数推导简化代码*，学习如何在不显式指定模板参数的情况下使用类模板'
- en: '*Ensuring constant correctness for a program*, to explore the benefits of constant
    correctness and how to achieve it'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确保程序常量正确性*，以探索常量正确性的好处以及如何实现它'
- en: Comparing signed and unsigned integers safely
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地比较有符号和无符号整数
- en: 'The C++ language features a variety of integral types: `short`, `int`, `long`,
    and `long long`, as well as their unsigned counterparts `unsigned short`, `unsigned
    int`, `unsigned long`, and `unsigned long long`. In C++11, fixed-width integer
    types were introduced, such as `int32_t` and `uint32_t`, and many similar others.
    Apart from these, there are also the types `char`, `signed char`, `unsigned char`,
    `wchar_t`, `char8_t`, `char16_t`, and `char32_t`, although these are not supposed
    to store numbers but characters. Moreover, the type `bool` used for storing the
    values `true` or `false` is also an integral type. The comparison of values of
    these types is a common operation but comparing signed and unsigned values is
    error-prone. Without some compiler-specific switches to flag these as warnings
    or errors, you can perform these operations and get unexpected results. For instance,
    the comparison `-1 < 42u` (comparing signed -1 with unsigned 42) would yield `false`.
    The C++20 standard provides a set of functions for performing a safe comparison
    of signed and unsigned values, which we will learn about in this recipe.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言具有多种整型：`short`、`int`、`long`和`long long`，以及它们的无符号对应类型`unsigned short`、`unsigned
    int`、`unsigned long`和`unsigned long long`。在C++11中，引入了固定宽度的整型，例如`int32_t`和`uint32_t`，以及许多类似的类型。除此之外，还有`char`、`signed
    char`、`unsigned char`、`wchar_t`、`char8_t`、`char16_t`和`char32_t`这些类型，尽管它们不是为了存储数字而是为了存储字符。此外，用于存储`true`或`false`值的`bool`类型也是一个整型。这些类型值的比较是一个常见的操作，但比较有符号和无符号值是容易出错的。如果没有一些特定的编译器开关来将这些操作标记为警告或错误，你就可以执行这些操作并得到意外的结果。例如，比较`-1
    < 42u`（比较有符号的-1和无符号的42）将返回`false`。C++20标准提供了一套用于执行有符号和无符号值安全比较的函数，我们将在本食谱中学习这些函数。
- en: How to do it…
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To perform a safe comparison of signed and unsigned integer values that ensures
    negative signed integers always compare less than unsigned values, use one of
    the following comparison functions from the `<utility>` header:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行确保负有符号整数始终比较小于无符号整数的无符号和有符号整数的安全比较，请使用`<utility>`头文件中的以下比较函数之一：
- en: '| **Function** | **Corresponding comparison operator** |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **对应的比较运算符** |'
- en: '| `std::cmp_equal` | `==` |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_equal` | `==` |'
- en: '| `std::cmp_not_equal` | `!=` |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_not_equal` | `!=` |'
- en: '| `std::cmp_less` | `<` |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_less` | `<` |'
- en: '| `std::cmp_less_equal` | `<=` |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_less_equal` | `<=` |'
- en: '| `std::cmp_greater` | `>` |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_greater` | `>` |'
- en: '| `std::cmp_greater_equal` | `>=` |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| `std::cmp_greater_equal` | `>=` |'
- en: 'Table 9.5: New C++20 comparison functions and their corresponding comparison
    operator'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.5：新的C++20比较函数及其对应的比较运算符
- en: 'The following snippet shows an example:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE119]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: How it works…
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Comparing two signed or two unsigned values is straightforward but comparing
    a signed and unsigned integer is error prone. When such a comparison occurs, the
    signed value is converted to unsigned. For instance, integer -1 becomes 4294967295\.
    The reason for this is that signed numbers are stored in memory as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个有符号或两个无符号值很简单，但比较一个有符号和一个无符号整数则容易出错。当发生此类比较时，有符号值会被转换为无符号。例如，整数-1变为4294967295。这是因为有符号数在内存中的存储方式如下：
- en: 'The most significant bit indicates the sign: 0 for positive numbers and 1 for
    negative ones.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高有效位表示符号：正数为0，负数为1。
- en: Negative values are stored by inverting the bits of the positive number and
    adding 1.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负值通过取正数的位反并加1来存储。
- en: This representation is known as the **two’s complement**. For instance, assuming
    an 8-bit signed representation, value 1 is stored as `0000001`, but the value
    -1 is stored as `11111111`. This is because the 7 least significant bits of the
    positive number are `0000001`, which inverted are `1111110`. By adding 1, we get
    `1111111`. Together with the sign bit this makes `11111111`. For 32-bit signed
    integers, the value -1 is stored as `11111111'11111111'11111111'11111111`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法被称为**二进制补码**。例如，假设是一个8位有符号表示，值1存储为`0000001`，但值-1存储为`11111111`。这是因为正数的7个最低有效位是`0000001`，取反后是`1111110`。通过加1，我们得到`1111111`。与符号位一起，这构成了`11111111`。对于32位有符号整数，值-1存储为`11111111'11111111'11111111'11111111`。
- en: '[PRE120]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'This is true for all the six equality (`==`, `!=`) and inequality (`<`, `<=`,
    `>`, `>=`) operators. To get the correct result, we need to check whether the
    signed values are negative. The correct condition for the `if` statement shown
    previously is the following:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有六个相等（`==`，`!=`）和不相等（`<`，`<=`，`>`，`>=`）运算符。为了得到正确的结果，我们需要检查有符号值是否为负。之前显示的`if`语句的正确条件如下：
- en: '[PRE122]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: To ease the writing of such expressions, the C++20 standard has introduced the
    six functions listed in *Table 9.5* that should be used as replacements for the
    corresponding operator when comparing signed and unsigned integers.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化此类表达式的编写，C++20标准引入了表9.5中列出的六个函数，应在比较有符号和无符号整数时用作相应运算符的替代。
- en: '[PRE123]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'A possible implementation for the `std::cmp_less()` function is shown in the
    next snippet:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了`std::cmp_less()`函数的一个可能的实现：
- en: '[PRE124]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'What this does is the following:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的是以下内容：
- en: If both arguments are signed, it uses the built-in `<` comparison operator to
    compare them.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个参数都是有符号的，它使用内置的`<`比较运算符来比较它们。
- en: If the first argument is signed and the second is unsigned, then it checks whether
    the first is native (a negative value is always less than a positive one) or compares
    the first argument cast to unsigned with the second argument using the built-in
    operator `<`.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数是有符号的，第二个是无符号的，那么它检查第一个是否是本地的（负值总是小于正值）或者使用内置运算符`<`将第一个参数转换为无符号并与第二个参数进行比较。
- en: If the first argument is unsigned, the second can be either signed or unsigned.
    The first argument can only be less than the second if the second is positive
    and the first is less than the second cast as unsigned.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个参数是无符号的，第二个可以是有符号或无符号的。第一个参数只能小于第二个，如果第二个是正数，并且第一个参数小于将其转换为无符号的第二个参数。
- en: 'When you use these functions, keep in mind that they only work for:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这些函数时，请记住它们只适用于：
- en: '`short`, `int`, `long`, `long long`, and their unsigned counterparts'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`，`int`，`long`，`long long`及其无符号对应类型'
- en: Fixed-width integer types such as `int32_t`, `int_least32_t`, `int_fast32_t`
    and their unsigned counterparts
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定宽度整数类型，如`int32_t`，`int_least32_t`，`int_fast32_t`及其无符号对应类型
- en: Extended integer types (which are compiler-specific types such as `__int64`
    or `__int128` and their unsigned counterparts that most compilers support)
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展整数类型（这些是编译器特定的类型，如`__int64`或`__int128`及其大多数编译器支持的无符号对应类型）
- en: The next snippet provides an example for using extended types (in this case
    Microsoft specific) and standard fixed with integer types, respectively.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段提供了一个使用扩展类型（在这种情况下是Microsoft特定的）和标准固定宽度整数类型的示例。
- en: '[PRE125]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, you cannot use them to compare enums, `std::byte`, `char`, `char8_t`,
    `char16_t`, `char32_t`, `wchar_t`, and `bool`. In this case, you would get a compiler
    error:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能用它们来比较枚举，`std::byte`，`char`，`char8_t`，`char16_t`，`char32_t`，`wchar_t`和`bool`。在这种情况下，你会得到编译器错误：
- en: '[PRE126]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: See also
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 2*, *Understanding the various numeric types*, to learn about the
    available integral and floating-point types'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*理解各种数值类型*，了解可用的整数和浮点类型'
- en: '*Performing correct type casts*, to learn the proper way of performing type
    casts in C++'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行正确的类型转换*，了解在 C++ 中执行类型转换的正确方法'
- en: Learn more on Discord
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_09.xhtml)'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_09.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
