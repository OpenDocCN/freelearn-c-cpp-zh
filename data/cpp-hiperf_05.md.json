["```cpp\n#include <algorithm>\n#include <vector>\nauto values = std::vector{9, 2, 5, 3, 4};\n// Sort using the std algorithms\nstd::sort(values.begin(), values.end());\n// Sort using the constrained algorithms under std::ranges\nstd::ranges::sort(values); \nstd::ranges::sort(values.begin(), values.end()); \n```", "```cpp\nvoid print(auto&& r) {\n  std::ranges::for_each(r, [](auto&& i) { std::cout << i << ' '; });\n} \n```", "```cpp\nauto in = std::vector{1, 2, 3, 4};\nauto out = std::vector<int>(in.size());\nauto lambda = [](auto&& i) { return i * i; };\nstd::ranges::transform(in, out.begin(), lambda);\nprint(out); \n// Prints: \"1 4 9 16\" \nprint() function defined earlier. The transform() algorithm will call our lambda once for each element in the input range. To specify where the output will be stored, we provide transform() with an output iterator, out.begin(). We will talk a lot more about iterators later on in this chapter.\n```", "```cpp\nauto v = std::vector<int>(4);\nstd::ranges::fill(v, -1);\nprint(v); \n// Prints \"-1 -1 -1 -1 \" \n```", "```cpp\nauto v = std::vector<int>(4);\nstd::ranges::generate(v, std::rand);\nprint(v);\n// Possible output: \"1804289383 846930886 1681692777 1714636915 \" \n```", "```cpp\n auto v = std::vector<int>(6);\n  std::iota(v.begin(), v.end(), 0);\n  print(v); // Prints: \"0 1 2 3 4 5 \" \n```", "```cpp\nauto v = std::vector{4, 3, 2, 3, 6};\nstd::ranges::sort(v);\nprint(v);       // Prints: \"2 3 3 4 6 \" \n```", "```cpp\nauto col = std::list{2, 4, 3, 2, 3, 1};\nauto it = std::ranges::find(col, 2);\nif (it != col.end()) {\n  std::cout << *it << '\\n';\n} \n```", "```cpp\nauto v = std::vector{2, 2, 3, 3, 3, 4, 5};    // Sorted!\nbool found = std::ranges::binary_search(v, 3);\nstd::cout << std::boolalpha << found << '\\n'; //   Output: true \n```", "```cpp\nassert(std::ranges::is_sorted(v)); \n```", "```cpp\nauto v = std::vector{2, 2, 3, 3, 3, 4, 5};\nauto it = std::ranges::lower_bound(v, 3);\nif (it != v.end()) {\n  auto index = std::distance(v.begin(), it);\n  std::cout << index << '\\n'; // Output: 2\n} \n```", "```cpp\nconst auto v = std::vector{2, 2, 3, 3, 3, 4, 5};\nauto it = std::ranges::upper_bound(v, 3);\nif (it != v.end()) {\n  auto index = std::distance(v.begin(), it);\n  std::cout << index << '\\n'; // Output: 5\n} \n```", "```cpp\nconst auto v = std::vector{2, 2, 3, 3, 3, 4, 5};\nauto subrange = std::ranges::equal_range(v, 3);\nif (subrange.begin() != subrange.end()) {\n  auto pos1 = std::distance(v.begin(), subrange.begin());\n  auto pos2 = std::distance(v.begin(), subrange.end());\n  std::cout << pos1 << \" \" << pos2 << '\\n';\n} // Output: \"2 5\" \n```", "```cpp\nconst auto v = std::vector{3, 2, 2, 1, 0, 2, 1};\nconst auto is_negative = [](int i) { return i < 0; }; \n```", "```cpp\nif (std::ranges::none_of(v, is_negative)) {\n  std::cout << \"Contains only natural numbers\\n\";\n} \n```", "```cpp\nif (std::ranges::all_of(v, is_negative)) {\n  std::cout << \"Contains only negative numbers\\n\";\n} \n```", "```cpp\nif (std::ranges::any_of(v, is_negative)) {\n  std::cout << \"Contains at least one negative number\\n\";\n} \n```", "```cpp\nconst auto numbers = std::list{3, 3, 2, 1, 3, 1, 3};\nint n = std::ranges::count(numbers, 3);\nstd::cout << n;                    // Prints: 4 \n```", "```cpp\nconst auto v = std::vector{0, 2, 2, 3, 3, 4, 5};\nassert(std::ranges::is_sorted(v)); // O(n), but not called in release\nauto r = std::ranges::equal_range(v, 3);\nint n = std::ranges::size(r);\nstd::cout << n;                    // Prints: 2 \n```", "```cpp\nconst auto y_max = 100;\nauto y = some_func();\nif (y > y_max) {\n  y = y_max;\n} \n```", "```cpp\nconst auto y = std::min(some_func(), y_max); \n```", "```cpp\nconst auto y = std::max(std::min(some_func(), y_max), y_min); \n```", "```cpp\nconst auto y = std::clamp(some_func(), y_min, y_max); \n```", "```cpp\nconst auto v = std::vector{4, 2, 1, 7, 3, 1, 5};\nconst auto [min, max] = std::ranges::minmax(v);\nstd::cout << min << \" \" << max;      // Prints: \"1 7\" \n```", "```cpp\nconst auto v = std::vector{4, 2, 7, 1, 1, 3};\nconst auto it = std::ranges::min_element(v);\nstd::cout << std::distance(v.begin(), it); // Output: 3 \n3, which is the index of the first minimum value that was found.\n```", "```cpp\nbool operator=!(sentinel s, iterator i) {\n  // ...\n} \n```", "```cpp\nauto vec = std::vector {\n  'a','b','c','d'\n};\nauto first = vec.begin();\nauto last = vec.end(); \n```", "```cpp\nfor (; first != last; ++first) {\n  char value = *first; // Dereference iterator\n  // ... \n```", "```cpp\nchar arr[] = {'a', 'b', 'c', 'd'};\nchar* end = arr + sizeof(arr);\nfor (char* it = arr; it != end; ++it) { // Stop at end\n   std::cout << *it << ' ';} \n// Output: a b c d \n```", "```cpp\ntemplate<class T>\nconcept range = requires(T& t) {\n  ranges::begin(t);\n  ranges::end(t);\n}; \n```", "```cpp\nauto vec = std::vector{1, 1, 0, 1, 1, 0, 0, 1};\nstd::cout << std::ranges::count(vec, 0); // Prints 3 \n```", "```cpp\n// Example with std::remove()\nauto v = std::vector{1,1,2,2,3,3};\nauto new_end = std::remove(\n  v.begin(), v.end(), 2);\nv.erase(new_end, v.end()); \n```", "```cpp\n// Example with std::unique()\nauto v = std::vector{1,1,2,2,3,3};\nauto new_end = std::unique(\n  v.begin(), v.end());\nv.erase(new_end, v.end()); \n```", "```cpp\nconst auto square_func = [](int x) { return x * x; };\nconst auto v = std::vector{1, 2, 3, 4};\nauto squared = std::vector<int>{};\nstd::ranges::transform(v, squared.begin(), square_func); \n```", "```cpp\nconst auto square_func = [](int x) { return x * x; };\nconst auto v = std::vector{1, 2, 3, 4};\nauto squared = std::vector<int>{};\nsquared.resize(v.size());\nstd::ranges::transform(v, squared.begin(), square_func); \nstd::back_inserter() and std::inserter() to insert values into a container that is not preallocated:\n```", "```cpp\nconst auto square_func = [](int x) { return x * x; };\nconst auto v = std::vector{1, 2, 3, 4};\n// Insert into back of vector using std::back_inserter\nauto squared_vec = std::vector<int>{};\nauto dst_vec = std::back_inserter(squared_vec);\nstd::ranges::transform(v, dst_vec, square_func);\n// Insert into a std::set using std::inserter\nauto squared_set = std::set<int>{};\nauto dst_set = std::inserter(squared_set, squared_set.end());\nstd::ranges::transform(v, dst_set, square_func); \n```", "```cpp\nstruct Flower {\n    auto operator<=>(const Flower& f) const = default; \n    bool operator==(const Flower&) const = default;\n    int height_{};\n};\nauto garden = std::vector<Flower>{{67}, {28}, {14}};\n// std::max_element() uses operator<()\nauto tallest = std::max_element(garden.begin(), garden.end());\n// std::find() uses operator==()\nauto perfect = *std::find(garden.begin(), garden.end(), Flower{28}); \n```", "```cpp\nauto names = std::vector<std::string> {\n  \"Ralph\", \"Lisa\", \"Homer\", \"Maggie\", \"Apu\", \"Bart\"\n};\nstd::sort(names.begin(), names.end(), \n          [](const std::string& a,const std::string& b) {\n            return a.size() < b.size(); });\n// names is now \"Apu\", \"Lisa\", \"Bart\", \"Ralph\", \"Homer\", \"Maggie\"\n// Find names with length 3\nauto x = std::find_if(names.begin(), names.end(), \n  [](const auto& v) { return v.size() == 3; });\n// x points to \"Apu\" \n```", "```cpp\nauto names = std::vector<std::string>{\n  \"Ralph\", \"Lisa\", \"Homer\", \"Maggie\", \"Apu\", \"Bart\"\n};\nstd::ranges::sort(names, std::less<>{}, &std::string::size);\n// names is now \"Apu\", \"Lisa\", \"Bart\", \"Ralph\", \"Homer\", \"Maggie\"\n\n// Find names with length 3\nauto x = std::ranges::find(names, 3, &std::string::size);\n// x points to \"Apu\" \n```", "```cpp\nstruct Player {\n  std::string name_{};\n  int level_{};\n  float health_{};\n  // ...\n};\nauto players = std::vector<Player>{\n  {\"Aki\", 1, 9.f}, \n  {\"Nao\", 2, 7.f}, \n  {\"Rei\", 2, 3.f}};\nauto level_and_health = [](const Player& p) {\n  return std::tie(p.level_, p.health_);\n}; \n// Order players by level, then health\nstd::ranges::sort(players, std::greater<>{}, level_and_health); \n```", "```cpp\ntemplate <typename Iterator>\nauto contains_duplicates(Iterator first, Iterator last) {\n  for (auto it = first; it != last; ++it)\n    if (std::find(std::next(it), last, *it) != last)\n      return true;\n  return false;\n} \n```", "```cpp\ntemplate <typename Iterator>\nauto contains_duplicates(Iterator first, Iterator last) {\n  // As (*first) returns a reference, we have to get \n  // the base type using std::decay_t\n  using ValueType = std::decay_t<decltype(*first)>;\n  auto c = std::vector<ValueType>(first, last);\n  std::sort(c.begin(), c.end());\n  return std::adjacent_find(c.begin(),c.end()) != c.end();\n} \n```", "```cpp\nauto contains(const std::vector<int>& arr, int v) {\n  for (int i = 0; i < arr.size(); ++i) {\t\n    if (arr[i] == v) { return true; }\n  }\n  return false;\n} \n```", "```cpp\ntemplate <typename Iterator, typename T>\nauto contains(Iterator begin, Iterator end, const T& v) {\n  for (auto it = begin; it != end; ++it) {\n    if (*it == v) {\u00a0return true;\u00a0}\n  }\n  return false;\n} \n```", "```cpp\nauto v = std::vector{3, 4, 2, 4};\nif (contains(v.begin(), v.end(), 3)) {\n // Found the value...\n} \n```", "```cpp\nauto contains(const auto& r, const auto& x) {\n  auto it = std::begin(r);\n  auto sentinel = std::end(r);\n  return contains(it, sentinel, x);\n} \n```", "```cpp\nauto contains(const std::ranges::range auto& r, const auto& x) {\n  auto it = std::begin(r);\n  auto sentinel = std::end(r);\n  return contains(it, sentinel, x);\n} \n```", "```cpp\nstruct Grid {\n  Grid(std::size_t w, std::size_t h) : w_{w}, h_{h} {    data_.resize(w * h); \n  }\n  auto get_row(std::size_t y); // Returns iterators or a range\n\n  std::vector<int> data_{};\n  std::size_t w_{};\n  std::size_t h_{};\n}; \n```", "```cpp\nauto Grid::get_row(std::size_t y) {\n  auto left = data_.begin() + w_ * y;\n  auto right = left + w_;\n  return std::make_pair(left, right);\n} \n```", "```cpp\nauto grid = Grid{10, 10};\nauto y = 3;\nauto row = grid.get_row(y);\nstd::generate(row.first, row.second, std::rand);\nauto num_fives = std::count(row.first, row.second, 5); \n```", "```cpp\nauto Grid::get_row(std::size_t y) {\n  auto first = data_.begin() + w_ * y;\n  auto sentinel = first + w_;\n  return std::ranges::subrange{first, sentinel};\n} \n```", "```cpp\nauto Grid::get_row(std::size_t y) {\n  auto first = data_.begin() + w_ * y;\n  return std::views::counted(first, w_);\n} \n```", "```cpp\nauto row = grid.get_row(y);\nstd::ranges::generate(row, std::rand);\nauto num_fives = std::ranges::count(row, 5); \n```", "```cpp\nauto v = std::vector{6, 3, 2, 7,\n                     4, 1, 5};\nauto it = v.begin() + v.size()/2; \n```", "```cpp\nstd::ranges::sort(v); \n```", "```cpp\nstd::nth_element(v.begin(), it,\n                 v.end()); \n```", "```cpp\nstd::partial_sort(v.begin(), it,\n                  v.end()); \n```", "```cpp\nauto v = std::vector{6, 3, 2, 7,\n                     4, 1, 5};\nauto it = v.begin() + v.size()/2; \n```", "```cpp\nauto left = it - 1;\nauto right = it + 2;\nstd::nth_element(v.begin(),\n                 left, v.end());\nstd::partial_sort(left, right,\n                  v.end()); \n```", "```cpp\nstd::nth_element(v.begin(), it,\n                 v.end());\nstd::sort(it, v.end()); \n```", "```cpp\nauto left = it - 1;\nauto right = it + 2;\nstd::nth_element(v.begin(),\n                 right, v.end());\nstd::partial_sort(v.begin(),\n                  left, right);\nstd::sort(right, v.end()); \n```", "```cpp\nstd::sort(r.begin(), r.end()); \n```", "```cpp\nauto it = r.begin() + r.size() / 2;\nstd::nth_element(r.begin(), it, r.end()); \n```", "```cpp\nauto it = r.begin() + r.size() / 10;\nstd::partial_sort(r.begin(), it, r.end()); \n```", "```cpp\n// Original version using a for-loop\nauto conflicting = false;\nfor (const auto& info : infos) {\n  if (info.params() == output.params()) {\n    if (varies(info.flags())) {\n      conflicting = true;\n      break;\n    }\n  }\n  else {\n    conflicting = true;\n    break;\n  }\n} \n```", "```cpp\n// Version using standard algorithms\nconst auto in_conflict = [&](const auto& info) {\n  return info.params() != output.params() || varies(info.flags());\n};\nconst auto conflicting = std::ranges::any_of(infos, in_conflict); \n```", "```cpp\ntemplate <typename Container>\nauto move_n_elements_to_back(Container& c, std::size_t n) {\n  // Copy the first n elements to the end of the container\n  for (auto it = c.begin(); it != std::next(c.begin(), n); ++it) {\n    c.emplace_back(std::move(*it));\n  }\n  // Erase the copied elements from front of container\n  c.erase(c.begin(), std::next(c.begin(), n));\n} \n```", "```cpp\ntemplate <typename Container>\nauto move_n_elements_to_back(Container& c, std::size_t n) {\n  for (size_t i = 0; i < n; ++i) {\n    auto value = *std::next(c.begin(), i);\n    c.emplace_back(std::move(value));\n  }\n  c.erase(c.begin(), std::next(c.begin(), n));\n} \n```", "```cpp\ntemplate <typename Container>\nauto move_n_elements_to_back(Container& c, std::size_t n) {\n  auto new_begin = std::next(c.begin(), n);\n  std::rotate(c.begin(), new_begin, c.end());\n} \n```", "```cpp\ntemplate <typename It, typename Value>\nauto find_slow(It first, It last, const Value& value) {\n  for (auto it = first; it != last; ++it)\n    if (*it == value)\n      return it;\n  return last;\n} \n```", "```cpp\ntemplate <typename It, typename Value>\nauto find_fast(It first, It last, const Value& value) {\n  // Main loop unrolled into chunks of four\n  auto num_trips = (last - first) / 4;\n  for (auto trip_count = num_trips; trip_count > 0; --trip_count) {\n    if (*first == value) {return first;} ++first;\n    if (*first == value) {return first;} ++first;\n    if (*first == value) {return first;} ++first;\n    if (*first == value) {return first;} ++first;\n  }\n  // Handle the remaining elements\n  switch (last - first) {\n    case 3: if (*first == value) {return first;} ++first;\n    case 2: if (*first == value) {return first;} ++first;\n    case 1: if (*first == value) {return first;} ++first;\n    case 0:\n    default: return last;\n  }\n} \n```", "```cpp\nauto cmp_zero(size_t val) {\n  return val > 0;\n} \n```", "```cpp\ntest edi, edi\nsetne al\nret \n```", "```cpp\nauto cmp_val(size_t val) {\n  return val > 42;\n} \n```", "```cpp\ncmp edi, 42\nsetba al\nret \n```", "```cpp\nstruct Student {\n  int year_{};\n  int score_{};\n  std::string name_{};\n  // ...\n}; \n```", "```cpp\nauto get_max_score(const std::vector<Student>& students, int year) {\n  auto by_year = [=](const auto& s) { return s.year_ == year; }; \n  // The student list needs to be copied in\n  // order to filter on the year\n  auto v = std::vector<Student>{};\n  std::ranges::copy_if(students, std::back_inserter(v), by_year);\n  auto it = std::ranges::max_element(v, std::less{}, &Student::score_);\n  return it != v.end() ? it->score_ : 0; \n} \n```"]