- en: Chapter 14. Building Playable Levels and Collision Detection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。构建可玩级别和碰撞检测
- en: This chapter will probably be one of the most satisfying of this project. The
    reason for this is that by the end of it, we will have a playable game. Although
    there will still be features to implement (sound, particle effects, HUD, and shader
    effects), Bob and Thomas will be able to run, jump, and explore the world. Furthermore,
    you will be able to create your very own level designs of almost any size or complexity
    by simply making platforms and obstacles in a text file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章可能是这个项目中最令人满意的。原因是到最后，我们将有一个可玩的游戏。虽然还有一些功能要实现（声音，粒子效果，HUD和着色器效果），但鲍勃和托马斯将能够奔跑，跳跃和探索世界。此外，你将能够通过简单地在文本文件中制作平台和障碍物来创建几乎任何大小或复杂度的级别设计。
- en: 'We will achieve all this by covering following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过以下主题来实现所有这些内容：
- en: Exploring how to design levels in a text file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索如何在文本文件中设计级别
- en: Building a `LevelManager` class that will load levels from a text file, convert
    them into data our game can use, and keep track of the level details, such as
    spawn position, current level, and allowed time limit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个`LevelManager`类，它将从文本文件加载级别，将它们转换为我们的游戏可以使用的数据，并跟踪级别细节，如生成位置，当前级别和允许的时间限制
- en: Updating the game engine to use `LevelManager`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新游戏引擎以使用`LevelManager`
- en: Coding a polymorphic function to handle the collision detection for both Bob
    and Thomas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个多态函数来处理Bob和Thomas的碰撞检测
- en: Designing some levels
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一些级别
- en: 'Remember our sprite sheet that we introduced in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP.* Here it is again, annotated with numbers that represent
    each tile that we will build our levels from:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第12章](ch12.html "第12章。抽象和代码管理-更好地利用OOP")中介绍的精灵表吗，*抽象和代码管理-更好地利用OOP*。这里再次显示，用数字注释表示我们将构建级别的每个瓦片：
- en: '![Designing some levels](img/image_14_001.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些级别](img/image_14_001.jpg)'
- en: 'I placed the screenshot on a gray background so you could see clearly the different
    details of the sprite sheet. The checkered background represents the level of
    transparency. So, all of the tiles except for number 1 will reveal at least a
    little of the background behind them:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将屏幕截图放在灰色背景上，这样你可以清楚地看到精灵表的不同细节。方格背景表示透明度级别。因此，除了数字1之外的所有瓦片都会至少显示一点背后的背景：
- en: Tile 0 is completely transparent and will be used to fill in the gaps where
    there aren't any other tiles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓦片0是完全透明的，将用于填补没有其他瓦片的空隙
- en: Tile 1 is for the platforms that Thomas and Bob will walk on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓷砖1是为了托马斯和鲍勃将走的平台
- en: Tile 2 is for fire tiles and tile 3 is for water tiles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瓷砖2是用于火瓦片，瓦片3是用于水瓦片
- en: Tile 4 you might need to look quite closely to see. It has a white, square outline.
    This is the goal of the level where Thomas and Bob must get to together.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要仔细查看瓦片4。它有一个白色的方形轮廓。这是托马斯和鲍勃必须一起到达的级别目标。
- en: Keep this screenshot in mind as we discuss designing the levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论设计级别时，请记住这个屏幕截图。
- en: 'We will enter combinations of these tile numbers into text files to design
    the layouts. An example will help:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些瓦片号码的组合输入到文本文件中来设计布局。举个例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous code translates to the following level layout:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码转换为以下级别布局：
- en: '![Designing some levels](img/image_14_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些级别](img/image_14_002.jpg)'
- en: 'Note that to get the view shown in the previous screenshot, I had to zoom out
    the `View`. Also, the screenshot is cropped. The actual start of the level would
    look like the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了获得前面屏幕截图中显示的视图，我必须缩小`View`。此外，屏幕截图被裁剪了。级别的实际开始看起来像下面的屏幕截图：
- en: '![Designing some levels](img/image_14_003.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些级别](img/image_14_003.jpg)'
- en: The point of showing you these screenshots is two fold. Firstly, you can see
    how you can quickly construct level designs using a simple and free text editor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 向你展示这些屏幕截图的目的有两个。首先，你可以看到如何使用简单和免费的文本编辑器快速构建级别设计。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just make sure you use a monospace font so that all the numbers are the same
    size. This makes designing the levels much easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保使用等宽字体，这样所有数字都是相同大小。这样设计级别就会更容易。
- en: 'Secondly, the screenshots demonstrate the gameplay aspects of the design. From
    left to right in the level, Thomas and Bob first need to jump a small hole or
    they will fall to their deaths (re-spawn). Then they have a large expanse of fire
    to traverse. It is actually impossible for Bob to jump that many tiles. The players
    will need to work together for the solution. The only way that Bob will clear
    the fire tiles is by standing on Thomas''s head and jumping from there, as shown
    in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这些屏幕截图展示了设计的游戏方面。在级别的左侧，托马斯和鲍勃首先需要跳过一个小洞，否则他们将掉入死亡（重生）。然后他们需要穿过大片火焰。鲍勃不可能跳过那么多瓦片。玩家需要共同解决问题。鲍勃清除火瓦片的唯一方法是站在托马斯的头上，然后从那里跳，如下面的屏幕截图所示：
- en: '![Designing some levels](img/image_14_004.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些级别](img/image_14_004.jpg)'
- en: It is then quite simple to get to the goal and move on to the next level.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后很容易到达目标并进入下一个级别。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I strongly encourage you to complete this chapter and then spend some time designing
    your own levels.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈鼓励你完成本章，然后花一些时间设计你自己的级别。
- en: I have included a few level designs to get you started. They are in the `levels`
    folder that we added to the project back in [Chapter 12](ch12.html "Chapter 12. Abstraction
    and Code Management – Making Better Use of OOP"), *Abstraction and Code Management
    - Making Better Use of OOP*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了一些级别设计，让你开始。它们在我们在[第12章](ch12.html "第12章。抽象和代码管理-更好地利用OOP")中添加到项目中的`levels`文件夹中，*抽象和代码管理-更好地利用OOP*。
- en: What follows are some zoomed out views of the game, along with a screenshot
    of the code of the level design. The screenshot of the code is probably more useful
    than reproducing the actual textual content. If you do want to see the code, just
    open up the files in the `levels` folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是游戏的一些缩小视图，以及关卡设计代码的截图。代码的截图可能比重现实际的文本内容更有用。如果您确实想看到代码，只需打开`levels`文件夹中的文件。
- en: 'This is what the code looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '![Designing some levels](img/image_14_005.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: 代码声明`Vector2i` `m_LevelSize`来保存当前地图包含的水平和垂直瓦片数的两个整数值。`Vector2f` `m_StartPosition`包含Bob和Thomas应该生成的世界坐标。请注意，这不是与`m_LevelSize`单位相关的瓦片位置，而是关卡中水平和垂直像素位置。
- en: 'This is level layout that the previous code will produce:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面的代码将产生的关卡布局：
- en: '![Designing some levels](img/image_14_006.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些关卡](img/image_14_006.jpg)'
- en: 'This level is the "leap of faith" level I referred to in [Chapter 12](ch12.html
    "Chapter 12. Abstraction and Code Management – Making Better Use of OOP"), *Abstraction
    and Code Management - Making Better Use of OOP*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡是我在[第12章](ch12.html "第12章。抽象和代码管理-更好地利用OOP")中提到的“信任之跃”关卡，*抽象和代码管理-更好地利用OOP*：
- en: '![Designing some levels](img/image_14_007.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些关卡](img/image_14_007.jpg)'
- en: 'I have highlighted the platforms, as they are not very clear in the zoomed-out
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了平台，因为它们在缩小的截图中不太清晰：
- en: '![Designing some levels](img/image_14_008.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![设计一些关卡](img/image_14_008.jpg)'
- en: The provided designs are simple. The game engine will be able to handle very
    large designs, however. You have the freedom to use your imagination and build
    some really big and hard-to-complete levels.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的设计很简单。游戏引擎将能够处理非常大的设计。您可以自由发挥想象力，构建一些非常大且难以完成的关卡。
- en: Of course, these designs won't actually do anything until we learn how to load
    them and convert the text into a playable level. Additionally, it won't be possible
    to stand on any platforms until we have implemented the collision detection.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些设计在我们学会如何加载它们并将文本转换为可玩的关卡之前实际上不会做任何事情。此外，在实现碰撞检测之前，将无法站在任何平台上。
- en: First, let's handle loading the level designs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理加载关卡设计。
- en: Building the LevelManager class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建LevelManager类
- en: It will take several phases of coding to make our level designs work. The first
    thing we will do is code the `LevelManager` header file. This will allow us to
    look at and discuss the member variables and functions that will be in the `LevelManger`
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要经过多个阶段的编码才能使我们的关卡设计生效。我们将首先编写`LevelManager`头文件。这将使我们能够查看和讨论`LevelManger`类中的成员变量和函数。
- en: Next, we will code the `LevelManager.cpp` file, which will have all the function
    definitions in it. As this is a long file, we will break it up into several sections,
    to code and discuss them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`LevelManager.cpp`文件，其中将包含所有的函数定义。由于这是一个很长的文件，我们将把它分成几个部分，以便编写和讨论它们。
- en: Once the `LevelManager` class is complete, we will add an instance of it to
    the game engine (`Engine` class). We will also add a new function to the `Engine`
    class, `loadLevel`, which we can call from the `update` function whenever a new
    level is required. The `loadLevel` function will not only use the `LevelManager`
    instance to load the appropriate level but it will also take care of aspects such
    as spawning the player characters and preparing the clock.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`LevelManager`类完成，我们将在游戏引擎（`Engine`类）中添加一个实例。我们还将在`Engine`类中添加一个新函数`loadLevel`，我们可以在需要新关卡时从`update`函数中调用。`loadLevel`函数不仅将使用`LevelManager`实例来加载适当的关卡，还将处理诸如生成玩家角色和准备时钟等方面。
- en: As already mentioned, let's get an overview of `LevelManager` by coding the
    `LevelManager.h` file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，让我们通过编写`LevelManager.h`文件来概述`LevelManager`。
- en: Coding LevelManager.h
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写LevelManager.h
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `LevelManager.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `LevelManager` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件（**
    `.h` **）**，然后在**名称**字段中键入`LevelManager.h`。最后，单击**添加**按钮。现在我们准备好为`LevelManager`类编写头文件了。
- en: 'Add the following include directives and private variables, and then we will
    discuss them:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下包含指令和私有变量，然后我们将讨论它们：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code declares `Vector2i` `m_LevelSize` to hold two integer values that will
    hold the horizontal and vertical number of tiles that the current map contains. `Vector2f`, `m_StartPosition`
    contains the coordinates in the world where Bob and Thomas should be spawned.
    Note that this is not a tile position relatable to `m_LevelSize` units, but a
    horizontal and vertical pixel position in the level.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![设计一些关卡](img/image_14_005.jpg)'
- en: The `m_TimeModifier` member variable is a float that will be used to multiply
    the time available in the current level. The reason we want to do this is so that
    by changing (decreasing) this value, we will shorten the time available each time
    the player attempts the same level. As an example, if the player gets 60 seconds
    for the first time they attempt level one then 60 multiplied by 1 is, of course,
    60\. When the player completes all the levels and comes back to level 1 for the
    second time, `m_TimeModifier` will have been reduced by 10 percent. Then, when
    the time available is multiplied by 0.9, the amount of time available to the player
    will be 54 seconds. This is 10 percent less than 60\. The game will get steadily
    harder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_TimeModifier`成员变量是一个浮点数，将用于乘以当前关卡中可用的时间。我们之所以要这样做，是因为通过改变（减少）这个值，我们将在玩家尝试同一关卡时缩短可用时间。例如，如果玩家第一次尝试第一关卡时获得60秒，那么60乘以1当然是60。当玩家完成所有关卡并再次回到第一关卡时，`m_TimeModifier`将减少10％。然后，当可用时间乘以0.9时，玩家可用的时间将是54秒。这比60少10％。游戏将逐渐变得更加困难。'
- en: The float variable, `m_BaseTimeLimit`, holds the original, unmodified time limit
    we have just been discussing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点变量`m_BaseTimeLimit`保存了我们刚刚讨论的原始未修改的时间限制。
- en: You can probably guess that `m_CurrentLevel` will hold the current level number
    that is being played.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到`m_CurrentLevel`将保存当前正在播放的关卡编号。
- en: The `int` `NUM_LEVELS` constant will be used to flag when it is appropriate
    to go back to level one again and reduce the value of `m_TimeModifier`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` `NUM_LEVELS`常量将用于标记何时适合再次返回到第一关，并减少`m_TimeModifier`的值。'
- en: 'Now add the following public variables and function declarations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下公共变量和函数声明：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, there are two constant `int` members. `TILE_SIZE` is a
    useful constant to remind us that each tile in the sprite sheet is fifty pixels
    wide and fifty pixels high. `VERTS_IN_QUAD` is a useful constant to make our manipulation
    of a `VertexArray` less error-prone. There are, in fact, four vertices in a quad.
    Now we can't forget it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有两个常量`int`成员。`TILE_SIZE`是一个有用的常量，提醒我们精灵表中的每个瓦片都是五十像素宽和五十像素高。`VERTS_IN_QUAD`是一个有用的常量，使我们对`VertexArray`的操作不那么容易出错。实际上，一个四边形中有四个顶点。现在我们不能忘记它。
- en: The `getTimeLimit`, `getStartPosition`, `getLevelSize`, and `getCurrentLevel` functions
    are simple getter functions, that return the current value of the private member
    variables we declared in the previous block of code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTimeLimit`、`getStartPosition`、`getLevelSize`和`getCurrentLevel`函数是简单的getter函数，返回我们在前面的代码块中声明的私有成员变量的当前值。'
- en: A function that deserves a closer look is `nextLevel`. This function receives
    a `VertexArray` reference, just like we used in the Zombie Arena game. The function
    can then work on the `VertexArray`, and all the changes will be present in the
    `VertexArray` from the calling code. The `nextLevel` function returns a pointer
    to a pointer, which means we can return an address that is the first element of
    a two-dimensional array of `int` values. We will be building a two-dimensional
    array of `int` values that will represent the layout of each level. Of course,
    these int values will be read from the level design text files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 值得仔细研究的一个函数是`nextLevel`。这个函数接收一个`VertexArray`的引用，就像我们在Zombie Arena游戏中使用的那样。该函数可以在`VertexArray`上工作，所有的更改都将出现在调用代码中的`VertexArray`中。`nextLevel`函数返回一个指向指针的指针，这意味着我们可以返回一个地址，该地址是`int`值的二维数组的第一个元素。我们将构建一个`int`值的二维数组，该数组将表示每个关卡的布局。当然，这些int值将从关卡设计文本文件中读取。
- en: Coding the LevelManager.cpp file
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写LevelManager.cpp文件
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `LevelManager.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `LevelManager` class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**
    `.cpp` **）**，然后在**名称**字段中键入`LevelManager.cpp`。最后，单击**添加**按钮。我们现在准备为`LevelManager`类编写`.cpp`文件。
- en: As this is quite a long class, we will break it up to discuss it in six chunks.
    The first five will cover the `nextLevel` function, and the sixth, all the rest.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当长的类，我们将把它分成六个部分来讨论。前五个将涵盖`nextLevel`函数，第六个将涵盖所有其他内容。
- en: 'Add the following include directives and the first (of five) part of the `nextLevel`
    function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下包含指令和`nextLevel`函数的第一部分（共五部分）：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the include directives, the code initializes `m_LevelSize.x` and `m_LevelSize.y`
    to zero.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含指令之后，代码将`m_LevelSize.x`和`m_LevelSize.y`初始化为零。
- en: Next, `m_CurrentLevel` is incremented. The `if` statement that follows checks
    whether `m_CurrentLevel` is greater than `NUM_LEVELS`. If it is, `m_CurrentLevel`
    is set back to `1` and `m_TimeModifier` is reduced by `.1f` in order to shorten
    the time allowed for all levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`m_CurrentLevel`增加。随后的`if`语句检查`m_CurrentLevel`是否大于`NUM_LEVELS`。如果是，`m_CurrentLevel`被设置回`1`，并且`m_TimeModifier`减少了`.1f`，以缩短所有关卡允许的时间。
- en: The code then switches based on the value held by `m_CurrentLevel`. Each `case`
    statement initializes the name of the text file, which holds the level design
    and the starting position for Thomas and Bob, as well as `m_BaseTimeLimit`, which
    is the unmodified time limit for the level in question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码然后根据`m_CurrentLevel`的值进行切换。每个`case`语句都初始化文本文件的名称，该文件包含了关卡设计和Thomas和Bob的起始位置，以及`m_BaseTimeLimit`，这是问题关卡的未修改时间限制。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you design your own levels, add a `case` statement and the appropriate values
    for it here. Also edit the `NUM_LEVELS` constant in the `LevelManager.h` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设计自己的关卡，请在此处添加`case`语句和相应的值。还要编辑`LevelManager.h`文件中的`NUM_LEVELS`常量。
- en: 'Now add the second part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加`nextLevel`函数的第二部分，如所示。在上一段代码之后立即添加代码。在添加代码时，仔细研究代码，以便我们可以讨论它：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous (second part) we have just coded, we declare an `ifstream` object
    called `inputFile`, which opens a stream to the filename contained in `levelToLoad`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面（第二部分）我们刚刚编写的代码中，我们声明了一个名为`inputFile`的`ifstream`对象，它打开了一个流到`levelToLoad`中包含的文件名。
- en: The code loops through each line of the file using `getline`, but doesn't record
    any of its content. All it does is count the number of lines by incrementing `m_LevelSize.y`.
    After the `for` loop, the width of the level is saved in `m_LevelSize.x` using
    `s.length`. This implies that the length of all the lines must be the same or
    we would run in to trouble.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`getline`循环遍历文件的每一行，但不记录任何内容。它只是通过递增`m_LevelSize.y`来计算行数。在`for`循环之后，使用`s.length`将关卡的宽度保存在`m_LevelSize.x`中。这意味着所有行的长度必须相同，否则我们会遇到麻烦。
- en: At this point, we know and have saved the length and width of the current level
    in `m_LevelSize`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道并已保存了`m_LevelSize`中当前关卡的长度和宽度。
- en: 'Now add the third part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加`nextLevel`函数的第三部分，如所示。在上一段代码之后立即添加代码。在添加代码时，请仔细研究代码，以便我们讨论它：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we clear `inputFile` using its `clear` function. The `seekg` function
    called with the `0, ios::beg` parameters resets the stream back to before the
    first character.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用其`clear`函数清除`inputFile`。使用`0, ios::beg`参数调用的`seekg`函数将流重置到第一个字符之前。
- en: Next, we declare a pointer to a pointer called `arrayLevel`. Note that this
    is done on the free store/heap using the `new` keyword. Once we have initialized
    this two-dimensional array, we will be able to return its address to the calling
    code and it will persist until we either delete it or the game is closed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个指向指针的`arrayLevel`。请注意，这是使用`new`关键字在自由存储/堆上完成的。一旦我们初始化了这个二维数组，我们就能够将其地址返回给调用代码，并且它将持续存在，直到我们删除它或游戏关闭。
- en: '`for` loops from 0 to `m_LevelSize.y -1`. In each pass, it adds a new array
    of `int` values to the heap to match the value of `m_LevelSize.x`. We now have
    a perfectly configured (for the current level) two-dimensional array. The only
    problem is that there is nothing in it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环从0到`m_LevelSize.y -1`。在每次循环中，它向堆中添加一个新的`int`值数组，以匹配`m_LevelSize.x`的值。现在，我们有一个完全配置好的（对于当前关卡）二维数组。唯一的问题是里面什么都没有。'
- en: 'Now add the fourth part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加`nextLevel`函数的第四部分，如所示。在上一段代码之后立即添加代码。在添加代码时，请仔细研究代码，以便我们讨论它：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, the code initializes a `string`, called `row`, which will hold one row
    of the level design at a time. We also declare and initialize an `int` called
    `y` that will help us count the rows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码初始化一个名为`row`的`string`，它将一次保存一个关卡设计的行。我们还声明并初始化一个名为`y`的`int`，它将帮助我们计算行数。
- en: The `while` loop executes repeatedly until `inputFile` gets past the last row.
    Inside the `while` loop there is a `for` loop, which goes through each character
    of the current row and stores it in the two-dimensional array, `arrayLevel`. Notice
    that we access exactly the right element of the two-dimensional array with `arrayLevel[y][x]
    =`. The `atoi` function converts `char val` to `int`. This is what is required,
    because we have a two-dimensional array for `int`, not `char`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环重复执行，直到`inputFile`超过最后一行。在`while`循环内部有一个`for`循环，它遍历当前行的每个字符，并将其存储在二维数组`arrayLevel`中。请注意，我们使用`arrayLevel[y][x]
    =`准确访问二维数组的正确元素。`atoi`函数将`char val`转换为`int`。这是必需的，因为我们有一个用于`int`而不是`char`的二维数组。'
- en: 'Now add the fifth part of the `nextLevel` function, as shown. Add the code
    immediately after the previous code. Study the code as you add it so we can discuss
    it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加`nextLevel`函数的第五部分，如所示。在上一段代码之后立即添加代码。在添加代码时，请仔细研究代码，以便我们讨论它：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although this is the longest section of code from the five sections we divided
    `nextLevel` into, it is also the most straightforward. This is because we have
    seen very similar code in the Zombie Arena project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是我们将`nextLevel`分成五个部分中最长的代码部分，但它也是最直接的。这是因为我们在Zombie Arena项目中看到了非常相似的代码。
- en: What happens is that the nested `for` loop loops from zero through to the width
    and height of the level. For each position in the array, four vertices are put
    into `VertexArray` and four texture coordinates are assigned from the sprite sheet.
    The positions of the vertices and texture coordinates are calculated using the
    `currentVertex` variable, the `TILE SIZE`, and `VERTS_IN_QUAD` constants. At the
    end of each loop of the inner `for` loop, `currentVertex` is increased by `VERTS_IN_QUAD`,
    moving nicely on to the next tile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`for`循环循环从零到关卡的宽度和高度。对于数组中的每个位置，将四个顶点放入`VertexArray`，并从精灵表中分配四个纹理坐标。顶点和纹理坐标的位置是使用`currentVertex`变量、`TILE
    SIZE`和`VERTS_IN_QUAD`常量计算的。在内部`for`循环的每次循环结束时，`currentVertex`增加`VERTS_IN_QUAD`，很好地移动到下一个瓷砖上。
- en: The important thing to remember about this `VertexArray` is that it was passed
    into `nextLevel` by reference. Therefore, the `VertexArray` will be available
    in the calling code. We will call `nextLevel` from the code in the `Engine` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个`VertexArray`的重要事情是，它是通过引用传递给`nextLevel`的。因此，`VertexArray`将在调用代码中可用。我们将从`Engine`类中的代码中调用`nextLevel`。
- en: Once this function has been called, the `Engine` class will have a `VertexArray`
    to represent the level graphically, and a two-dimensional array of `int` values
    as a numerical representation of all the platforms and obstacles in the level.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用了这个函数，`Engine`类将拥有一个`VertexArray`来图形化表示关卡，并且拥有一个`int`值的二维数组，作为关卡中所有平台和障碍物的数值表示。
- en: 'The rest of the `LevelManager` functions are all simple getter functions, but
    do take the time to familiarize yourself with what private value is returned by
    which function. Add the remaining functions from the `LevelManager` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager`的其余函数都是简单的getter函数，但请花时间熟悉每个函数返回的私有值。添加`LevelManager`类的其余函数：'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that the `LevelManager` class is complete, we can move on to using it. We
    will code another function in the Engine class to do so.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`LevelManager`类已经完成，我们可以继续使用它。我们将在`Engine`类中编写另一个函数来实现。
- en: Coding the loadLevel function
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写loadLevel函数
- en: To be clear, this function is part of the `Engine` class, although it will delegate
    much of its work to other functions, including those of the `LevelManager` class
    that we just built.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要清楚，这个函数是`Engine`类的一部分，尽管它将把大部分工作委托给其他函数，包括我们刚刚构建的`LevelManager`类的函数。
- en: 'First, let''s add the declaration for the new function, along with some other
    new code, to the `Engine.h` file. Open the `Engine.h` file and add the highlighted
    lines of code shown in the following abbreviated snapshot of the `Engine.h` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`Engine.h`文件中添加新函数的声明，以及一些其他新代码。打开`Engine.h`文件，并添加以下`Engine.h`文件的摘要快照中显示的突出显示的代码行：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see the following in the previous code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在先前的代码中看到以下内容：
- en: We included the `LevelManager.h` file
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们包括了`LevelManager.h`文件
- en: We added an instance of `LevelManager` called `m_LM`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`m_LM`的`LevelManager`实例
- en: We added a `VertexArray` called `m_VALevel`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`m_VALevel`的`VertexArray`
- en: We added a pointer to a pointer to an `int` that will hold the two-dimensional
    array that is returned from `nextLevel`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个指向`int`的指针，该指针将保存从`nextLevel`返回的二维数组
- en: We added a new `Texture` object for the sprite sheet
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为精灵表添加了一个新的`Texture`对象
- en: We added the declaration for the `loadLevel` function that we will write now
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了`loadLevel`函数的声明，现在我们将编写该函数
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `LoadLevel.cpp`.
    Finally, click the **Add** button. We are now ready to code the `loadLevel` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Solution Explorer**中右键单击**Source Files**，然后选择**Add** | **New Item...**。在**Add
    New Item**窗口中，通过左键单击突出显示（` .cpp`）**C++ File**，然后在**Name**字段中键入`LoadLevel.cpp`。最后，单击**Add**按钮。现在我们准备编写`loadLevel`函数。
- en: 'Add the code for the `loadLevel` function to the `LoadLevel.cpp` file, and
    then we can discuss it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将`loadLevel`函数的代码添加到`LoadLevel.cpp`文件中，然后我们可以讨论它：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we set `m_Playing` to false to stop parts of the update function from
    executing. Next, we loop through all the horizontal arrays within `m_ArrayLevel`
    and delete them. After the `for` loop, we delete `m_ArrayLevel`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`m_Playing`设置为false，以阻止更新函数的部分执行。接下来，我们循环遍历`m_ArrayLevel`中的所有水平数组，并将它们删除。在`for`循环之后，我们删除`m_ArrayLevel`。
- en: The code, `m_ArrayLevel = m_LM.nextLevel(m_VALevel)`, calls `nextLevel` and
    prepares both the `VertexArray` and `m_VALevel`, as well as the two-dimensional `m_ArrayLevel` array.
    The level is set up and ready to go.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`m_ArrayLevel = m_LM.nextLevel(m_VALevel)`，调用了`nextLevel`并准备了`VertexArray`和`m_VALevel`，以及二维`m_ArrayLevel`数组。关卡已经设置好，准备就绪。
- en: '`m_TimeRemaining` is initialized by calling `getTimeLimit`, and Thomas and
    Bob are spawned using the `spawn` function along with the value returned from
    `getStartPosition`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`getTimeLimit`初始化了`m_TimeRemaining`，并使用`spawn`函数生成了Thomas和Bob，以及从`getStartPosition`返回的值。
- en: Finally, `m_NewLevelRequired` is set to `false`. As we will see in a few page's
    time, `m_NewLevelRequired` being set to `true` is what causes `loadLevel` to be
    called. We only want to run this function once.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`m_NewLevelRequired`被设置为`false`。正如我们将在几页后看到的那样，`m_NewLevelRequired`被设置为`true`会导致调用`loadLevel`。我们只想运行这个函数一次。
- en: Updating the engine
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新引擎
- en: 'Open the `Engine.cpp` file and add the highlighted code to load the sprite
    sheet texture at the end of the `Engine` constructor:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.cpp`文件，并在`Engine`构造函数的末尾添加突出显示的代码，以加载精灵表纹理：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All we do in the previous code is load the sprite sheet into `m_TextureTiles`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们只是将精灵表加载到`m_TextureTiles`中。
- en: 'Open the `Update.cpp` file and make the following highlighted changes and additions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Update.cpp`文件，并进行以下突出显示的更改和添加：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Actually, you should delete, rather than comment out, the lines we are no longer
    using. I have just shown it to you this way so that the changes are clear. All
    there should be in the previous `if` statement is the call to `loadLevel`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你应该删除而不是注释掉我们不再使用的行。我只是以这种方式向你展示，以便更清楚地看到更改。在先前的`if`语句中，应该只有对`loadLevel`的调用。
- en: 'Finally, before we can see the results of the work so far this chapter, open
    the `Draw.cpp` file and make the following highlighted additions to draw the vertex
    array that represents a level:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们能够看到本章工作成果之前，打开`Draw.cpp`文件，并进行以下突出显示的添加，以绘制表示关卡的顶点数组：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice we need to draw the `VertexArray` for all screen options (full, left,
    and right.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要为所有屏幕选项（全屏、左侧和右侧）绘制`VertexArray`。
- en: Now you can run the game. Unfortunately, however, Thomas and Bob fall straight
    through all our lovingly-designed platforms. For this reason, we can't try and
    progress through the levels and beat the clock.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行游戏了。不幸的是，Thomas和Bob直接穿过了我们精心设计的所有平台。因此，我们无法尝试通过关卡并打败时间。
- en: Collision detection
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We will handle collision detection using rectangle intersection and the SFML
    intersects function. What will be different in this project is that we will abstract
    the collision detection code into its own function and Thomas and Bob, as we have
    already seen, have multiple rectangles (`m_Head`, `m_Feet`, `m_Left`, `m_Right`)
    that we need to check for collisions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用矩形相交和SFML相交函数来处理碰撞检测。在这个项目中的不同之处在于，我们将把碰撞检测代码抽象成自己的函数，并且正如我们已经看到的，Thomas和Bob有多个矩形（`m_Head`、`m_Feet`、`m_Left`、`m_Right`），我们需要检查碰撞。
- en: Coding the detectCollisions function
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`detectCollisions`函数
- en: 'To be clear, this function is part of the Engine class. Open up the `Engine.h`
    file and add a declaration for a function called `detectCollisions`. This is shown
    highlighted in the following code snippet:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确，这个函数是Engine类的一部分。打开`Engine.h`文件，并添加一个名为`detectCollisions`的函数声明。在下面的代码片段中突出显示了这一点：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice from the signature that the `detectCollision` function takes a polymorphic
    argument, a `PlayerCharacter` object. As we know, `PlayerCharacter` is abstract
    and can never be instantiated. We do, however, inherit from it with the `Thomas`
    and `Bob` classes. We will be able to pass either `m_Thomas` or `m_Bob` to `detectCollisions`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从签名中可以看出，`detectCollision`函数接受一个多态参数，即`PlayerCharacter`对象。正如我们所知，`PlayerCharacter`是抽象的，永远不能被实例化。然而，我们可以用`Thomas`和`Bob`类继承它。我们将能够将`m_Thomas`或`m_Bob`传递给`detectCollisions`。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `DetectCollisions.cpp`.
    Finally, click the **Add** button. We are now ready to code the `detectCollisions`
    function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**
    `.cpp` **）**，然后在**名称**字段中键入`DetectCollisions.cpp`。最后，单击**添加**按钮。现在我们准备编写`detectCollisions`函数。
- en: 'Add the following code to `DetectCollisions.cpp`. Note that this is just the
    first part of this function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`DetectCollisions.cpp`。请注意，这只是该函数的第一部分：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing that happens is that we declare a Boolean called `reachedGoal`.
    This is the value that the `detectCollisions` function returns to the calling
    code. It is initialized to `false`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们声明一个名为`reachedGoal`的布尔值。这是`detectCollisions`函数返回给调用代码的值。它被初始化为`false`。
- en: Next we declare a `FloatRect` called `detectionZone` and initialize it with
    the same rectangle that represents the entire rectangle of the character sprite.
    Note that we will not actually do intersection tests with this rectangle. After
    that, we declare another `FloatRect` called `block`. We initialize `block` as
    a 50 by 50 rectangle. We will see `block` in use shortly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们声明一个名为`detectionZone`的`FloatRect`，并用表示角色精灵整个矩形的相同矩形进行初始化。请注意，我们实际上不会使用这个矩形进行交集测试。之后，我们声明另一个名为`block`的`FloatRect`。我们将`block`初始化为一个50x50的矩形。我们很快就会看到`block`的使用。
- en: Next we see how we will use `detectionZone`. We initialize four `int` variables,
    `startX`, `startY`, `endX`, and `endY` by expanding the area around `detectionZone`
    a few blocks. In the four `if` statements that follow, we check that it is not
    possible to try and do collision detection on a tile that does not exist. We achieve
    this by making sure we never check positions less than zero or greater than the
    value returned by `getLevelSize().x` or `.y`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看看如何使用`detectionZone`。我们通过扩展`detectionZone`周围的区域几个块来初始化四个`int`变量`startX`、`startY`、`endX`和`endY`。在接下来的四个`if`语句中，我们检查不可能尝试在不存在的瓦片上进行碰撞检测。我们通过确保永远不检查小于零或大于`getLevelSize().x`或`.y`返回的值来实现这一点。
- en: What all this previous code has done is to create an area with which to do collision
    detection. There is no point doing collision detection on a block that is hundreds
    or thousands of pixels away from the character. In addition, if we try and do
    collision detection where an array position doesn't exist (less than zero or greater
    than `getLevelSize()...`), the game will crash.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有代码所做的是创建一个用于碰撞检测的区域。在角色数百或数千像素远的方块上进行碰撞检测是没有意义的。此外，如果我们尝试在数组位置不存在的地方进行碰撞检测（小于零或大于`getLevelSize()...`），游戏将崩溃。
- en: 'Next, add this code, which handles the player falling out of the level:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下处理玩家掉出地图的代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For a character to stop falling, it must collide with a platform. Therefore,
    if the player moves out of the map (where there are no platforms) it will continuously
    fall. The previous code checks whether the character *does not* intersect with
    the `FloatRect`, `level`. If it does not, then it has fallen out of the level
    and the `spawn` function sends it back to the start.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 角色要停止下落，必须与平台发生碰撞。因此，如果玩家移出地图（没有平台的地方），它将不断下落。前面的代码检查角色是否*不*与`FloatRect`、`level`相交。如果不相交，那么它已经掉出地图，`spawn`函数会将其发送回起点。
- en: 'Add the following, quite large code, and then we will go through what it does:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下相当大的代码，然后我们将逐步讲解它的功能：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous code does three things using the same techniques. It loops through
    all the values contained between startX, endX and startY, endY. For each pass,
    it checks and does the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用相同的技术做了三件事。它循环遍历了startX、endX和startY、endY之间包含的所有值。对于每次循环，它都会检查并执行以下操作：
- en: Has the character burned or drowned? The code `if (m_ArrayLevel[y][x] == 2 ||
    m_ArrayLevel[y][x] == 3)` determines if the current position being checked is
    a fire or a water tile. If the character's head intersects with one of these tiles,
    the player is re-spawned. We also code an empty `if…else` block in preparation
    for adding sound in the following chapter.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否被烧伤或淹死？代码`if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)`确定当前被检查的位置是否是火瓦或水瓦。如果角色的头与这些瓦片之一相交，玩家将重新生成。我们还编写了一个空的`if…else`块，为下一章添加声音做准备。
- en: Has the character touched a regular tile? The code `if (m_ArrayLevel[y][x] ==
    1)` determines if the current position being checked holds a regular tile. If
    it intersects with any of the rectangles that represent the various body parts
    of the character, the related function is called (`stopRight`, `stopLeft`, `stopFalling`,
    and `stopJump`). The value that is passed to each of these functions and how the
    function uses the value to reposition the character is quite nuanced. While it
    is not necessary to closely examine these values to understand the code, you might
    like to look at the values passed in and then refer back to the appropriate function
    of the `PlayableCharacter` class in the previous chapter. This will help you appreciate
    exactly what is going on.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否触碰了普通瓦片？代码`if (m_ArrayLevel[y][x] == 1)`确定当前被检查的位置是否持有普通瓦片。如果它与表示角色各个身体部位的矩形之一相交，相关的函数就会被调用（`stopRight`、`stopLeft`、`stopFalling`和`stopJump`）。传递给这些函数的值以及函数如何使用这些值重新定位角色是相当微妙的。虽然不必仔细检查这些值来理解代码，但您可能会喜欢查看传递的值，然后参考上一章`PlayableCharacter`类的适当函数。这将帮助您准确理解发生了什么。
- en: Has the character touched the goal tile? This is determined with the code `if
    (m_ArrayLevel[y][x] == 4)`. All we need to do is set `reachedGoal` to `true`.
    The `update` function of the `Engine` class will keep track of whether both characters
    (Thomas and Bob) have reached the goal simultaneously. We will write this code
    in `update` in just a minute.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否触碰到了目标瓦片？这是通过代码`if (m_ArrayLevel[y][x] == 4)`来确定的。我们只需要将`reachedGoal`设置为`true`。`Engine`类的`update`函数将跟踪托马斯和鲍勃是否同时到达了目标。我们将在`update`中编写这段代码，马上就会。
- en: 'Add the last line of code to the `detectCollisions` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`detectCollisions`函数中添加最后一行代码：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous line of code returns `reachedGoal` so that the calling code can
    keep track and respond appropriately if both characters reach the goal simultaneously.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码返回`reachedGoal`，以便调用代码可以跟踪并适当地响应如果两个角色同时到达目标。
- en: 'All we need to do now is call the `detectCollision` function once per character
    per frame. Add the following highlighted code in the `Update.cpp` file within
    the `if(m_Playing)` block of code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要每帧调用一次`detectCollision`函数。在`Update.cpp`文件的`if(m_Playing)`代码块中添加以下突出显示的代码：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code calls the `detectCollision` function and checks if both Bob
    and Thomas have simultaneously reached the goal. If they have, the next level
    is prepared by setting `m_NewLevelRequired` to `true`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码调用了`detectCollision`函数，并检查鲍勃和托马斯是否同时到达了目标。如果是，下一个关卡将通过将`m_NewLevelRequired`设置为`true`来准备好。
- en: You can run the game and walk on the platforms. You can reach the goal and start
    a new level. Also, for the first time, the jump buttons (*W* or Arrow Up) will
    work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行游戏并走在平台上。您可以到达目标并开始新的关卡。此外，首次，跳跃按钮（*W*或箭头上）将起作用。
- en: If you reach the goal, the next level will load. If you reach the goal of the
    last level, then the first level will load with a 10% reduced time limit. Of course,
    there is no visual feedback for the time or the current level because we haven't
    built a HUD yet. We will do so in the following chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您达到目标，下一个关卡将加载。如果您达到最后一关的目标，则第一关将以减少10%的时间限制加载。当然，由于我们还没有构建HUD，所以时间或当前关卡没有视觉反馈。我们将在下一章中完成。
- en: Many of the levels, however, require Thomas and Bob to work as a team. More
    specifically, Thomas and Bob need to be able to climb on each other's heads.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多关卡需要托马斯和鲍勃一起合作。更具体地说，托马斯和鲍勃需要能够爬到彼此的头上。
- en: More collision detection
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多碰撞检测
- en: 'Add this code just after the previous code you added in the `Update.cpp` file,
    within the `if (m_Playing)` section:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update.cpp`文件中添加前面添加的代码后面，即在`if (m_Playing)`部分内：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can run the game again and stand on the heads of Thomas and Bob to get
    to the hard-to-reach places that were previously not attainable:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以再次运行游戏，并站在托马斯和鲍勃的头上，以到达以前无法到达的难以到达的地方：
- en: '![More collision detection](img/image_14_009.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![更多碰撞检测](img/image_14_009.jpg)'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There was quite a lot of code in this chapter. We learned how to read from a
    file and convert strings of text into char and then `int`. Once we had a two-dimensional
    array of `int`, we were able to populate a `VertexArray` to actually show the
    level on the screen. We then used exactly the same two-dimensional array of int
    to implement collision detection. We used rectangle intersection, just as we did
    in the Zombie Arena project, although this time, for more precision, we gave each
    character four collision zones, one each to represent their head, feet, and their
    left and right sides.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有相当多的代码。我们学会了如何从文件中读取并将文本字符串转换为char，然后转换为`int`。一旦我们有了一个二维数组的`int`，我们就能够填充一个`VertexArray`来在屏幕上显示关卡。然后，我们使用完全相同的二维数组int来实现碰撞检测。我们使用了矩形相交，就像我们在僵尸竞技场项目中所做的那样，尽管这次，为了更精确，我们给了每个角色四个碰撞区域，分别代表他们的头部、脚部和左右两侧。
- en: Now that the game is totally playable, we need to represent the state of the
    game (score and time) on the screen. In the following chapter, we will implement
    the HUD, along with some much more advanced sound effects than we have used so
    far.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏完全可玩，我们需要在屏幕上表示游戏的状态（得分和时间）。在下一章中，我们将实现HUD，以及比目前使用的更高级的音效。
