["```cpp\n/*\n * Converted to C code taken from:\n * https://github.com/timhutton/sdl-canvas-wasm\n * Some of the variable names and comments were also\n * slightly updated.\n */\n#include <SDL2/SDL.h>\n#include <emscripten.h>\n#include <stdlib.h>\n\n// This enables us to have a single point of reference\n// for the current iteration and renderer, rather than\n// have to refer to them separately.\ntypedef struct Context {\n  SDL_Renderer *renderer;\n  int iteration;\n} Context;\n\n/*\n * Looping function that draws a blue square on a red\n * background and moves it across the <canvas>.\n */\nvoid mainloop(void *arg) {\n    Context *ctx = (Context *)arg;\n    SDL_Renderer *renderer = ctx->renderer;\n    int iteration = ctx->iteration;\n\n    // This sets the background color to red:\n    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);\n    SDL_RenderClear(renderer);\n\n    // This creates the moving blue square, the rect.x\n    // and rect.y values update with each iteration to move\n    // 1px at a time, so the square will move down and\n    // to the right infinitely:\n    SDL_Rect rect;\n    rect.x = iteration;\n    rect.y = iteration;\n    rect.w = 50;\n    rect.h = 50;\n    SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);\n    SDL_RenderFillRect(renderer, &rect);\n\n    SDL_RenderPresent(renderer);\n\n    // This resets the counter to 0 as soon as the iteration\n    // hits the maximum canvas dimension (otherwise you'd\n    // never see the blue square after it travelled across\n    // the canvas once).\n    if (iteration == 255) {\n        ctx->iteration = 0;\n    } else {\n        ctx->iteration++;\n    }\n}\n\nint main() {\n    SDL_Init(SDL_INIT_VIDEO);\n    SDL_Window *window;\n    SDL_Renderer *renderer;\n\n    // The first two 255 values represent the size of the <canvas>\n    // element in pixels.\n    SDL_CreateWindowAndRenderer(255, 255, 0, &window, &renderer);\n\n    Context ctx;\n    ctx.renderer = renderer;\n    ctx.iteration = 0;\n\n    // Call the function repeatedly:\n    int infinite_loop = 1;\n\n    // Call the function as fast as the browser wants to render\n    // (typically 60fps):\n    int fps = -1;\n\n    // This is a function from emscripten.h, it sets a C function\n    // as the main event loop for the calling thread:\n    emscripten_set_main_loop_arg(mainloop, &ctx, fps, infinite_loop);\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n\n    return EXIT_SUCCESS;\n}\n```", "```cpp\nemcc with-glue.c -O3 -s WASM=1 -s USE_SDL=2 -o with-glue.html\n```", "```cpp\nserve -l 8080\n```", "```cpp\nvar statusElement = document.getElementById('status');\nvar progressElement = document.getElementById('progress');\nvar spinnerElement = document.getElementById('spinner');\n\nvar Module = {\n  preRun: [],\n  postRun: [],\n  print: (function() {...})(),\n  printErr: function(text) {...},\n  canvas: (function() {...})(),\n  setStatus: function(text) {...},\n  totalDependencies: 0,\n  monitorRunDependencies: function(left) {...}\n};\n\nModule.setStatus('Downloading...');\n\nwindow.onerror = function(event) {\n  Module.setStatus('Exception thrown, see JavaScript console');\n  spinnerElement.style.display = 'none';\n  Module.setStatus = function(text) {\n    if (text) Module.printErr('[post-exception status] ' + text);\n  };\n};\n```", "```cpp\ncanvas: (function() {\n  var canvas = document.getElementById('canvas');\n  canvas.addEventListener(\n    'webglcontextlost',\n    function(e) {\n      alert('WebGL context lost. You will need to reload the page.');\n      e.preventDefault();\n    },\n    false\n  );\n\n  return canvas;\n})(),\n```", "```cpp\nemcc with-glue.c -O3 -s WASM=1 -s USE_SDL=2 -s MODULARIZE=1 -o custom-loading.js\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>Custom Loading Code</title>\n</head>\n<body>\n  <h1>Using Custom Loading Code</h1>\n  <canvas id=\"canvas\"></canvas>\n  <script type=\"application/javascript\" src=\"img/custom-loading.js\"></script>\n  <script type=\"application/javascript\">\n    Module({\n      canvas: (() => document.getElementById('canvas'))(),\n    })\n      .then(() => {\n        console.log('Loaded!');\n      });\n  </script>\n</body>\n</html>\n```", "```cpp\nserve -l 8080\n```", "```cpp\nemcc with-glue.c -Os -s WASM=1 -s USE_SDL=2 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o try-with-glue.wasm\n```", "```cpp\n(module\n  (type $t0 (func (param i32)))\n  (type $t1 (func (param i32 i32 i32 i32 i32) (result i32)))\n  (type $t2 (func (param i32) (result i32)))\n  (type $t3 (func))\n  (type $t4 (func (param i32 i32) (result i32)))\n  (type $t5 (func (param i32 i32 i32 i32)))\n  (type $t6 (func (result i32)))\n  (type $t7 (func (result f64)))\n  (import \"env\" \"memory\" (memory $env.memory 256))\n  (import \"env\" \"table\" (table $env.table 4 anyfunc))\n  (import \"env\" \"memoryBase\" (global $env.memoryBase i32))\n  (import \"env\" \"tableBase\" (global $env.tableBase i32))\n  (import \"env\" \"abort\" (func $env.abort (type $t0)))\n  (import \"env\" \"_SDL_CreateWindowAndRenderer\" (func $env._SDL_CreateWindowAndRenderer (type $t1)))\n  (import \"env\" \"_SDL_DestroyRenderer\" (func $env._SDL_DestroyRenderer (type $t0)))\n  (import \"env\" \"_SDL_DestroyWindow\" (func $env._SDL_DestroyWindow (type $t0)))\n  (import \"env\" \"_SDL_Init\" (func $env._SDL_Init (type $t2)))\n  (import \"env\" \"_SDL_Quit\" (func $env._SDL_Quit (type $t3)))\n  (import \"env\" \"_SDL_RenderClear\" (func $env._SDL_RenderClear (type $t2)))\n  (import \"env\" \"_SDL_RenderFillRect\" (func $env._SDL_RenderFillRect (type $t4)))\n  (import \"env\" \"_SDL_RenderPresent\" (func $env._SDL_RenderPresent (type $t0)))\n  (import \"env\" \"_SDL_SetRenderDrawColor\" (func $env._SDL_SetRenderDrawColor (type $t1)))\n  (import \"env\" \"_emscripten_set_main_loop_arg\" (func $env._emscripten_set_main_loop_arg (type $t5)))\n  ...\n```", "```cpp\n/*\n * This file interacts with the canvas through imported functions.\n * It moves a blue rectangle diagonally across the canvas\n * (mimics the SDL example).\n */\n#include <stdbool.h>\n\n#define BOUNDS 255\n#define RECT_SIDE 50\n#define BOUNCE_POINT (BOUNDS - RECT_SIDE)\n\n// These functions are passed in through the importObj.env object\n// and update the rectangle on the <canvas>:\nextern int jsClearRect();\nextern int jsFillRect(int x, int y, int width, int height);\n\nbool isRunning = true;\n\ntypedef struct Rect {\n  int x;\n  int y;\n  char direction;\n} Rect;\n\nstruct Rect rect;\n\n/*\n * Updates the rectangle location by 1px in the x and y in a\n * direction based on its current position.\n */\nvoid updateRectLocation() {\n    // Since we want the rectangle to \"bump\" into the edge of the\n    // canvas, we need to determine when the right edge of the\n    // rectangle encounters the bounds of the canvas, which is why\n    // we're using the canvas width - rectangle width:\n    if (rect.x == BOUNCE_POINT) rect.direction = 'L';\n\n    // As soon as the rectangle \"bumps\" into the left side of the\n    // canvas, it should change direction again.\n    if (rect.x == 0) rect.direction = 'R';\n\n    // If the direction has changed based on the x and y\n    // coordinates, ensure the x and y points update\n    // accordingly:\n    int incrementer = 1;\n    if (rect.direction == 'L') incrementer = -1;\n    rect.x = rect.x + incrementer;\n    rect.y = rect.y + incrementer;\n}\n\n/*\n * Clear the existing rectangle element from the canvas and draw a\n * new one in the updated location.\n */\nvoid moveRect() {\n    jsClearRect();\n    updateRectLocation();\n    jsFillRect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);\n}\n\nbool getIsRunning() {\n    return isRunning;\n}\n\nvoid setIsRunning(bool newIsRunning) {\n    isRunning = newIsRunning;\n}\n\nvoid init() {\n    rect.x = 0;\n    rect.y = 0;\n    rect.direction = 'R';\n    setIsRunning(true);\n}\n```", "```cpp\nemcc without-glue.c -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o without-glue.wasm\n```", "```cpp\n(module\n  (type $t0 (func (param i32)))\n  (type $t1 (func (result i32)))\n  (type $t2 (func (param i32 i32 i32 i32) (result i32)))\n  (type $t3 (func))\n  (type $t4 (func (result f64)))\n  (import \"env\" \"memory\" (memory $env.memory 256))\n  (import \"env\" \"table\" (table $env.table 8 anyfunc))\n  (import \"env\" \"memoryBase\" (global $env.memoryBase i32))\n  (import \"env\" \"tableBase\" (global $env.tableBase i32))\n  (import \"env\" \"abort\" (func $env.abort (type $t0)))\n  (import \"env\" \"_jsClearRect\" (func $env._jsClearRect (type $t1)))\n  (import \"env\" \"_jsFillRect\" (func $env._jsFillRect (type $t2)))\n  ...\n```", "```cpp\n{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"Build\",\n      \"type\": \"shell\",\n      \"command\": \"emcc\",\n      \"args\": [\n        \"${file}\",\n        \"-Os\",\n        \"-s\", \"WASM=1\",\n        \"-s\", \"SIDE_MODULE=1\",\n        \"-s\", \"BINARYEN_ASYNC_COMPILATION=0\",\n        \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.wasm\"\n       ],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n       },\n       \"presentation\": {\n         \"panel\": \"new\"\n       }\n     }\n  ]\n}\n```", "```cpp\n/**\n * Returns a valid importObj.env object with default values to pass\n * into the WebAssembly.Instance constructor for Emscripten's\n * Wasm module.\n */\nconst getDefaultEnv = () => ({\n  memoryBase: 0,\n  tableBase: 0,\n  memory: new WebAssembly.Memory({ initial: 256 }),\n  table: new WebAssembly.Table({ initial: 2, element: 'anyfunc' }),\n  abort: console.log\n});\n\n/**\n * Returns a WebAssembly.Instance instance compiled from the specified\n * .wasm file.\n */\nfunction loadWasm(fileName, importObj = { env: {} }) {\n  // Override any default env values with the passed in importObj.env\n  // values:\n  const allEnv = Object.assign({}, getDefaultEnv(), importObj.env);\n\n  // Ensure the importObj object includes the valid env value:\n  const allImports = Object.assign({}, importObj, { env: allEnv });\n\n  // Return the result of instantiating the module (instance and module):\n  return fetch(fileName)\n    .then(response => {\n      if (response.ok) return response.arrayBuffer();\n      throw new Error(`Unable to fetch WebAssembly file ${fileName}`);\n    })\n    .then(bytes => WebAssembly.instantiate(bytes, allImports));\n}\n```", "```cpp\n(import \"env\" \"memory\" (memory $env.memory 256))\n(import \"env\" \"table\" (table $env.table 8 anyfunc))\n(import \"env\" \"memoryBase\" (global $env.memoryBase i32))\n(import \"env\" \"tableBase\" (global $env.tableBase i32))\n(import \"env\" \"abort\" (func $env.abort (type $t0)))\n```", "```cpp\n<!doctype html>\n<html lang=\"en-us\">\n<head>\n  <title>No Glue Code</title>\n  <script type=\"application/javascript\" src=\"img/load-wasm.js\"></script>\n</head>\n<body>\n  <h1>No Glue Code</h1>\n  <canvas id=\"myCanvas\" width=\"255\" height=\"255\"></canvas>\n  <div style=\"margin-top: 16px;\">\n    <button id=\"actionButton\" style=\"width: 100px; height: 24px;\">\n      Pause\n    </button>\n  </div>\n  <script type=\"application/javascript\">\n    const canvas = document.querySelector('#myCanvas');\n    const ctx = canvas.getContext('2d');\n\n    const env = {\n      table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),\n      _jsFillRect: function (x, y, w, h) {\n        ctx.fillStyle = '#0000ff';\n        ctx.fillRect(x, y, w, h);\n      },\n      _jsClearRect: function() {\n        ctx.fillStyle = '#ff0000';\n        ctx.fillRect(0, 0, 255, 255);\n      },\n    };\n\n    loadWasm('without-glue.wasm', { env }).then(({ instance }) => {\n      const m = instance.exports;\n      m._init();\n\n      // Move the rectangle by 1px in the x and y every 20 milliseconds:\n      const loopRectMotion = () => {\n        setTimeout(() => {\n          m._moveRect();\n          if (m._getIsRunning()) loopRectMotion();\n        }, 20)\n      };\n\n      // Enable you to pause and resume the rectangle movement:\n      document.querySelector('#actionButton')\n        .addEventListener('click', event => {\n          const newIsRunning = !m._getIsRunning();\n          m._setIsRunning(newIsRunning);\n          event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';\n          if (newIsRunning) loopRectMotion();\n        });\n\n      loopRectMotion();\n    });\n  </script>\n</body>\n</html>\n```", "```cpp\nserve -l 8080\n```"]