- en: Working with Memory, Arrays, and Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理内存、数组和指针
- en: C++ allows you to have direct access to memory through pointers. This gives
    you a lot of flexibility, and potentially it allows you to improve the performance
    of your code by eliminating some unnecessary copying of data. However, it also
    provides an extra source of errors; some can be fatal for your application or
    worse (yes, worse than fatal!) because poor use of memory buffers can open security
    holes in your code that can allow malware to take over the machine. Clearly pointers
    are an important aspect of C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您通过指针直接访问内存。这为您提供了很大的灵活性，潜在地可以通过消除一些不必要的数据复制来提高代码的性能。然而，它也提供了额外的错误来源；一些错误对您的应用程序可能是致命的，甚至更糟（是的，比致命更糟！），因为对内存缓冲区的不良使用可能会在您的代码中打开安全漏洞，从而允许恶意软件接管机器。显然，指针是C++的一个重要方面。
- en: In this chapter, you'll see how to declare pointers and initialize them to memory
    locations, how to allocate memory on the stack and, C++ free store, and how to
    use C++ arrays.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何声明指针并将其初始化为内存位置，如何在堆栈上分配内存和C++自由存储器，并如何使用C++数组。
- en: Using memory in C++
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中使用内存
- en: C++ uses the same syntax as C to declare pointer variables and assign them to
    memory addresses, and it has C-like pointer arithmetic. Like C, C++ also allows
    you to allocate memory on the stack, so there is automatic memory cleanup when
    the stack frame is destroyed, and dynamic allocation (on the C++ free store) where
    the programmer has the responsibility to release memory. This section will cover
    these concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用与C相同的语法来声明指针变量并将它们分配给内存地址，并且具有类似C的指针算术。与C一样，C++还允许您在堆栈上分配内存，因此在堆栈帧被销毁时会自动清理内存，并且动态分配（在C++自由存储器上），程序员有责任释放内存。本节将涵盖这些概念。
- en: Using C++ pointer syntax
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++指针语法
- en: 'The syntax to access memory in C++ is straightforward. The `&` operator returns
    the address of an object. That *object* can be a variable, a built-in type or
    the instance of a custom type, or even a function (function pointers will be covered
    in the next chapter). The address is assigned a typed pointer variable or a `void*`
    pointer. A `void*` pointer should be treated as merely storage for the memory
    address because you cannot access data and you cannot perform pointer arithmetic
    (that is, manipulate the pointer value using arithmetic operators) on a `void*`
    pointer. Pointer variables are usually declared using a type and the `*` symbol.
    For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C++中访问内存的语法很简单。`&`运算符返回一个对象的地址。这个*对象*可以是一个变量，一个内置类型或自定义类型的实例，甚至是一个函数（函数指针将在下一章中介绍）。地址被分配给一个类型化的指针变量或一个`void*`指针。`void*`指针应该被视为内存地址的存储，因为你不能访问数据，也不能对`void*`指针进行指针算术（即使用算术运算符操作指针值）。指针变量通常使用类型和`*`符号声明。例如：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code, the variable `i` is an integer, and the compiler and linker will
    determine where this variable will be allocated. Usually, a variable in a function
    will be on a stack frame, as described in a later section. At runtime, the stack
    will be created (essentially a chunk of memory will be allocated) and space will
    be reserved in the stack memory for the variable `i`. The program then puts a
    value (42) in that memory. Next, the address of the memory allocated for the variable
    `i` is placed in the variable `pi`. The memory usage of the previous code is illustrated
    in the following diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，变量`i`是一个整数，编译器和链接器将确定分配这个变量的位置。通常，函数中的变量将在堆栈帧上，如后面的部分所述。在运行时，堆栈将被创建（基本上将分配一块内存），并且在堆栈内存中为变量`i`保留空间。然后，程序将一个值（42）放入该内存中。接下来，为变量`i`分配的内存的地址放入变量`pi`中。上述代码的内存使用情况如下图所示：
- en: '![](img/89bf3c10-6e3f-4ac5-8ef7-9e801286fa70.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89bf3c10-6e3f-4ac5-8ef7-9e801286fa70.png)'
- en: The pointer holds a value of `0x007ef8c` (notice that the lowest byte is stored
    in the lowest byte in memory; this is for an x86 machine). The memory location
    `0x007ef8c` has a value of `0x0000002a`, that is, a value of 42, the value of
    the variable `i`. Since `pi` is also a variable, it also occupies space in memory,
    and in this case the compiler has put the pointer *lower* in memory than the data
    it points to and, in this case, the two variables are not contiguous.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指针保存了一个值为`0x007ef8c`（注意最低字节存储在内存中的最低字节；这是针对x86机器的）。内存位置`0x007ef8c`的值为`0x0000002a`，即42的值，即变量`i`的值。由于`pi`也是一个变量，它也占用内存空间，在这种情况下，编译器将指针放在内存中的*较低*位置，在这种情况下，这两个变量不是连续的。
- en: With variables allocated on the stack like this, you should make no assumptions
    about where in memory the variables are allocated, nor their location in relation
    to other variables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样在堆栈上分配的变量，您不应该假设变量分配在内存中的位置，也不应该假设它们与其他变量的位置有关。
- en: This code assumes a 32-bit operating system, and so the pointer `pi` occupies
    32 bits and contains a 32-bit address. If the operating system is 64 bits then
    the pointer will be 64 bits wide (but the integer may still be 32 bits). In this
    book, we will use 32-bit pointers for the simple convenience that 32-bit addresses
    take less typing than 64-bit addresses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码假设是32位操作系统，因此指针`pi`占用32位并包含32位地址。如果操作系统是64位，则指针将是64位宽（但整数可能仍然是32位）。在本书中，我们将使用32位指针，因为32位地址比64位地址少打字。
- en: 'The typed pointer is declared with a `*` symbol and we will refer to this as
    an `int*` pointer because the pointer points to memory that holds an `int`. When
    declaring a pointer, the convention is to put the `*` next to the variable name
    rather than next to the type. This syntax emphasizes that the *type pointed* to
    is an `int`. However, it is important to use this syntax if you declare more than
    one variable in a single statement:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化指针使用`*`符号声明，我们将其称为`int*`指针，因为指针指向保存`int`的内存。在声明指针时，约定是将`*`放在变量名旁边，而不是放在类型旁边。这种语法强调了指向的*类型*是`int`。但是，如果您在单个语句中声明多个变量，则重要使用此语法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is clear that the first variable is an `int*` pointer and the second is
    an `int`. The following is not so clear:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，第一个变量是`int*`指针，第二个是`int`。以下则不太清楚：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You might interpret this to mean that the type of both variables is `int*`, *but
    this is not the case*, as this declares a pointer and an `int`. If you want to
    declare two pointers, then apply `*` to each variable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会理解这意味着两个变量的类型都是`int*`，*但事实并非如此*，因为这声明了一个指针和一个`int`。如果你想声明两个指针，那么对每个变量应用`*`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is probably better just to declare the two pointers on separate lines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是将这两个指针分开声明。
- en: When you apply the `sizeof` operator to a pointer, you will get the size of
    the pointer, not what it points to. Thus, on an x86 machine, `sizeof(int*)` will
    return 4; and on an x64 machine, it will return 8\. This is an important observation,
    especially when we discuss C++ built-in arrays in a later section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对指针应用`sizeof`运算符时，你将得到指针的大小，而不是它指向的内容。因此，在x86机器上，`sizeof(int*)`将返回4；在x64机器上，它将返回8。这是一个重要的观察，特别是当我们在后面的部分讨论C++内置数组时。
- en: 'To access the data pointed to by a pointer, you must **dereference** it using
    the `*` operator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问指针指向的数据，你必须使用`*`运算符对其进行**解引用**：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Used like this on the right-hand side of an assignment, the dereferenced pointer
    gives access to the value pointed to by the pointer, so `j` is initialized to
    42\. Compare this to the declaration of a pointer, where the `*` symbol is also
    used, but has a different meaning.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值的右侧使用解引用指针可以访问指针指向的值，所以`j`被初始化为42。与指针的声明相比，`*`符号也被使用，但意义不同。
- en: 'The dereference operator does more than give read access to the data at the
    memory location. As long as the pointer does not restrict it (using the `const`
    keyword; see later), you can dereference the pointer to write to a memory location
    too:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用运算符不仅可以读取内存位置的数据。只要指针没有限制（使用`const`关键字；见后文），你也可以解引用指针来写入内存位置：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, the pointer `pi` points to the location in memory of the variable
    `i` (in this case, using the brace syntax). Assigning the dereferenced pointer
    assigns the value to the location that the pointer points to. The result is that
    on the last line, the variable `i` will have a value of 99 and not 42.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，指针`pi`指向变量`i`在内存中的位置（在这种情况下，使用大括号语法）。对解引用指针进行赋值将值分配给指针指向的位置。结果是在最后一行，变量`i`的值将是99而不是42。
- en: Using null pointers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空指针
- en: A pointer could point to anywhere in the memory installed in your computer,
    and assignment through a dereferenced pointer means that you could potentially
    write over sensitive memory used by your operating system, or (through direct
    memory access) write to memory used by hardware on your machine. However, operating
    systems will usually give an executable a specific memory range that it can access,
    and attempts to access memory out of this range will cause an operating system
    memory access violation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以指向计算机中安装的内存的任何位置，通过解引用指针进行赋值意味着你可能会覆盖操作系统使用的敏感内存，或者（通过直接内存访问）写入计算机硬件使用的内存。然而，操作系统通常会给可执行文件分配一个特定的内存范围，它可以访问，尝试访问超出此范围的内存将导致操作系统内存访问违规。
- en: 'For this reason, you should almost always obtain pointer values using the `&`
    operator or from a call to an operating system function. You should not give a
    pointer an absolute address. The only exception to this is the C++ constant for
    an invalid memory address, `nullptr`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你几乎总是应该使用`&`运算符或从操作系统函数调用中获取指针值。你不应该给指针一个绝对地址。唯一的例外是C++对于无效内存地址的常量`nullptr`：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code initializes the pointer `pi` to `nullptr`. Later in the code, the
    pointer is initialized to the address of an integer variable. Still later in the
    code, the pointer is used, but rather than calling it immediately, the pointer
    is first checked to ensure that it has been initialized to a non-null value. The
    compiler will check to see if you are about to use a variable that has not been
    initialized, but if you are writing library code, the compiler will not know whether
    the callers of your code will use pointers correctly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将指针`pi`初始化为`nullptr`。稍后在代码中，指针被初始化为整数变量的地址。代码中稍后使用了指针，但是不是立即调用它，而是首先检查指针以确保它已经被初始化为非空值。编译器将检查你是否即将使用一个未初始化的变量，但如果你正在编写库代码，编译器将不知道你的代码的调用者是否正确使用指针。
- en: The type of constant `nullptr` is not an integer, it is `std::nullptr_t`. All
    pointer types can be implicitly converted to this type, so `nullptr` can be used
    to initialize variables of all pointer types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`nullptr`的类型不是整数，而是`std::nullptr_t`。所有指针类型都可以隐式转换为此类型，因此`nullptr`可以用于初始化所有指针类型的变量。
- en: Types of memory
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存类型
- en: 'In general, you can regard memory as being one of four types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以将内存视为四种类型之一：
- en: Static or global
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态或全局
- en: String pool
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串池
- en: Automatic or stack
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动或堆栈
- en: Free store
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由存储
- en: When you declare a variable at the global level, or if you have a variable declared
    in a function as `static`, then the compiler will ensure that the variable is
    allocated from memory that has the same lifetime as the application--the variable
    is created when the application starts and deleted when the application ends.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在全局级别声明一个变量，或者在函数中将变量声明为`static`时，编译器将确保变量分配的内存具有与应用程序相同的生命周期--变量在应用程序启动时创建，在应用程序结束时删除。
- en: 'When you use a string literal, the data will also, effectively, be a global
    variable, but stored in a different part of the executable. For a Windows executable,
    string literals are stored in the `.rdata` PE/COFF section of the executable.
    The `.rdata` section of the file is for read-only initialized data, and hence
    you cannot change the data. Visual C++ allows you to go a step further and gives
    you an option of **string pooling**. Consider this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用字符串常量时，数据实际上也是全局变量，但存储在可执行文件的不同部分。对于Windows可执行文件，字符串常量存储在可执行文件的`.rdata`
    PE/COFF部分中。文件的`.rdata`部分用于只读初始化数据，因此您无法更改数据。Visual C++允许您更进一步，并为您提供了**字符串池**的选项。考虑这个：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, two pointers are initialized with the address of the string literal
    `hello`. In the following two lines, the address of each pointer is printed on
    the console. Since the `<<` operator for `char*` treats the variable as a pointer
    to a string, it will print the string rather than the address of the pointer.
    To get around this, we call the `reinterpret_cast` operator to convert the pointer
    to an integer and print the value of the integer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，两个指针被初始化为字符串常量`hello`的地址。在接下来的两行中，每个指针的地址都打印在控制台上。由于`<<`运算符对于`char*`将变量视为指向字符串的指针，它将打印字符串而不是指针的地址。为了解决这个问题，我们调用`reinterpret_cast`运算符将指针转换为整数并打印整数的值。
- en: If you compile the code at the command line using the Visual C++ compiler, you
    will see two different addresses printed. These two addresses are in the `.rdata`
    section and are both read-only. If you compile this code with the `/GF` switch
    to enable string pooling (which is default for Visual C++ projects), the compiler
    will see that the two string literals are the same and will only store one copy
    in the `.rdata` section, so the result of this code will be that a single address
    will be printed on the console twice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在命令行使用Visual C++编译器编译代码，您将看到打印出两个不同的地址。这两个地址都在`.rdata`部分，并且都是只读的。如果您使用`/GF`开关编译此代码以启用字符串池（这是Visual
    C++项目的默认设置），编译器将看到两个字符串常量是相同的，并且只会在`.rdata`部分存储一个副本，因此此代码的结果将是在控制台上打印两次相同的地址。
- en: In this code, the two variables `p1` and `p2` are automatic variables, that
    is, they are created on the stack created for the current function. When a function
    is called, a chunk of memory is allocated for the function and this contains space
    for the parameters passed to the function and the return address of the code that
    called the function, as well as space for the automatic variables declared in
    the function. When the function finishes, the stack frame is destroyed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，两个变量`p1`和`p2`是自动变量，也就是说，它们是在当前函数的堆栈上创建的。当调用函数时，为函数分配一块内存，其中包含为函数传递的参数和调用函数的代码的返回地址，以及在函数中声明的自动变量的空间。当函数结束时，堆栈帧被销毁。
- en: The **calling convention** of the function determines whether the calling function
    or the called function has the responsibility to do this. In Visual C++, the default
    is the `__cdecl` calling convention, which means the calling function cleans up
    the stack. The `__stdcall` calling convention is used by Windows operating system
    functions and the stack clean up is carried out by the called function. More details
    will be given in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的**调用约定**决定了是调用函数还是被调用函数负责这样做。在Visual C++中，默认的是`__cdecl`调用约定，这意味着调用函数清理堆栈。`__stdcall`调用约定被Windows操作系统函数使用，并且堆栈清理由被调用函数执行。更多细节将在下一章中给出。
- en: Automatic variables only last as long as the function and the address of such
    variables only make any sense within the function. Later in this chapter, you
    will see how to create arrays of data. Arrays allocated as automatic variables
    are allocated on the stack to a fixed size determined at compile time. It is possible
    with large arrays that you could exceed the size of the stack, particularly with
    functions that are called recursively. On Windows, the default stack size is 1
    MB, and on x86 Linux, it is 2 MB. Visual C++ allows you to specify a bigger stack
    with the `/F` compiler switch (or the `/STACK` linker switch). The gcc compiler
    allows you to change the default stack size with the `--stack` switch.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自动变量只在函数执行期间存在，这样变量的地址只在函数内部有意义。在本章的后面，您将看到如何创建数据数组。作为自动变量分配的数组是在编译时确定的固定大小的堆栈上分配的。对于大数组，可能会超出堆栈的大小，特别是在递归调用的函数中。在Windows上，默认堆栈大小为1
    MB，在x86 Linux上为2 MB。Visual C++允许您使用`/F`编译器开关（或`/STACK`链接器开关）指定更大的堆栈。gcc编译器允许您使用`--stack`开关更改默认堆栈大小。
- en: The final type of memory is **dynamic memory** created on the **free store**
    or sometimes known as the **heap**. This is the most flexible way of using memory.
    As the name suggests, you allocate memory at runtime of a size determined at runtime.
    The implementation of the free store depends on the C++ implementation but you
    should regard the free store as having the same lifetime as your application,
    so memory allocated from the free store should last at least as long as your application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型的内存是在**自由存储器**或有时称为**堆**上创建的**动态内存**。这是使用内存的最灵活的方式。顾名思义，您在运行时分配大小确定的内存。自由存储器的实现取决于C++的实现，但您应该将自由存储器视为具有与应用程序相同的生命周期，因此从自由存储器分配的内存应该至少持续与应用程序一样长的时间。
- en: However, there are potential dangers here, particularly for long-lived applications.
    All memory allocated from the free store should be returned back to the free store
    when you have finished with it so that the free store manager can reuse the memory.
    If you do not return memory appropriately, then potentially the free store manager
    could run out of memory, which will prompt it to ask the operating system for
    more memory, and consequently, the memory usage of your application will grow
    over time, causing performance issues due to memory paging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里存在潜在的危险，特别是对于长期运行的应用程序。从自由存储器分配的所有内存都应在使用完毕后返回到自由存储器，以便自由存储器管理器可以重用内存。如果不适当地返回内存，那么自由存储管理器可能会耗尽内存，这将促使它向操作系统请求更多内存，因此，应用程序的内存使用量将随时间增长，导致由于内存分页而引起性能问题。
- en: Pointer arithmetic
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针算术
- en: A pointer points to memory, and the type of the pointer determines the type
    of the data that can be accessed through the pointer. So, an `int*` pointer will
    point to an integer in memory, and you dereference the pointer (`*`) to get the
    integer. If the pointer allows it (it is not marked as `const`), you can change
    its value through pointer arithmetic. For example, you can increment or decrement
    a pointer. What happens to the value of the memory address depends on the type
    of the pointer. Since a typed pointer points to a type, any pointer arithmetic
    will change the pointer in units of the *size* of that type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 指针指向内存，指针的类型决定了可以通过指针访问的数据的类型。因此，`int*`指针将指向内存中的整数，并且您可以通过解引用指针(`*`)来获取整数。如果指针允许（未标记为`const`），则可以通过指针算术更改其值。例如，您可以增加或减少指针。内存地址的值取决于指针的类型。由于类型化指针指向类型，任何指针算术都将以该类型的*size*为单位更改指针。
- en: 'If you increment an `int*` pointer, it will point to the *next* integer in
    memory and the change in the memory address depends on the size of the integer.
    This is equivalent to array indexing, where an expression such as `v[1]` means
    you should start at the memory location of the first item in `v` and then move
    one item further in memory and return the item there:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您增加一个`int*`指针，它将指向内存中的*下一个*整数，内存地址的变化取决于整数的大小。这相当于数组索引，其中诸如`v[1]`的表达式意味着您应该从`v`中的第一项的内存位置开始，然后在内存中移动一个项，并返回那里的项：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line allocates an array of five integers on the stack and initializes
    the values to the numbers 1 to 5\. In this example, because an initialization
    list is used, the compiler will create space for the required number of items,
    hence the size of the array is not given. If you give the size of the array between
    the brackets, then the initialization list must not have more items than the array
    size. If the list has fewer items, then the rest of the items in the array are
    initialized to the default value (usually zero).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在堆栈上分配了一个包含五个整数的数组，并将值初始化为1到5。在这个例子中，因为使用了初始化列表，编译器将为所需数量的项创建空间，因此数组的大小没有给出。如果在括号之间给出数组的大小，那么初始化列表中的项数不能超过数组大小。如果列表中的项数较少，则数组中的其余项将被初始化为默认值（通常为零）。
- en: 'The next line in this code obtains a pointer to the first item in the array.
    This line is significant: an array name is treated as a pointer to the first item
    in the array. The following lines alter array items in various ways. The first
    of these (`*pv`) changes the first item in the array by dereferencing the pointer
    and assigning it a value. The second (`v[1]`) uses array indexing to assign a
    value to the second item in the array. The third (`pv[2]`) uses indexing, but
    this time with a pointer, and assigns a value to the third value in the array.
    And the final example (`*(pv + 3)`) uses pointer arithmetic to determine the address
    of the fourth item in the array (remember the first item has an index of 0) and
    then dereferences the pointer to assign the item a value. After these, the array
    contains the values `{ 11, 12, 13, 14, 5 }` and the memory layout is illustrated
    here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中的下一行获取数组中第一项的指针。这一行很重要：数组名称被视为指向数组中第一项的指针。接下来的几行以各种方式更改数组项。其中第一行(`*pv`)通过解引用指针并赋值来更改数组中的第一项。第二行(`v[1]`)使用数组索引为数组中的第二项赋值。第三行(`pv[2]`)使用索引，但这次使用指针，并为数组中的第三个值赋值。最后一个例子(`*(pv
    + 3)`)使用指针算术来确定数组中第四项的地址（请记住，第一项的索引为0），然后解引用指针来为该项赋值。在这些操作之后，数组包含值`{ 11, 12, 13,
    14, 5 }`，内存布局如下所示：
- en: '![](img/5daa49f6-aa94-46a5-b9e8-1e3f60e607a0.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5daa49f6-aa94-46a5-b9e8-1e3f60e607a0.png)'
- en: 'If you have a memory buffer containing values (in this example, allocated via
    an array) and you want to multiply each value by 3, you can do this using pointer
    arithmetic:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个包含值的内存缓冲区（在本例中，通过数组分配），并且想要将每个值乘以3，可以使用指针算术来实现：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The loop statement is complicated, and you will need to refer back to the operator
    precedence given in [Chapter 2](92dda5f2-3cee-40d5-8797-cdbbd6b8f59a.xhtml), *Understanding
    Language Features*. The postfix increment operator has the highest precedence,
    the next highest precedence is the dereference operator (`*`), and finally, the
    `*=` operator has the lowest of the three operators, so the operators are run
    in this order: `++`, `*`, `*=`. The postfix operator returns the value *before*
    the increment, so although the pointer is incremented to the next item in memory,
    the expression uses the address before the increment. This address is then dereferenced
    which is assigned by the assignment operator that replaces the item with the value
    multiplied by 3\. This illustrates an important difference between pointers and
    array names; you can increment a pointer but you cannot increment an array:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句很复杂，您需要参考[第2章](92dda5f2-3cee-40d5-8797-cdbbd6b8f59a.xhtml)中给出的运算符优先级，*理解语言特性*。后缀递增运算符具有最高的优先级，其次是解引用运算符（`*`），最后是`*=`运算符的优先级最低，因此这些运算符按照这个顺序运行：`++`，`*`，`*=`。后缀运算符返回递增*之前*的值，因此尽管指针被递增到内存中的下一个项目，表达式使用的是递增之前的地址。然后对这个地址进行解引用，由赋值运算符赋予值乘以3的值。这说明了指针和数组名称之间的一个重要区别；您可以递增指针，但不能递增数组：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can, of course use indexing (with `[]`) on both array names and pointers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在数组名称和指针上都使用索引（使用`[]`）。
- en: Using arrays
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组
- en: 'As the name suggests, a C++ built-in array is zero or more items of data of
    the same type. In C++, square brackets are used to declare arrays and to access
    array elements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，C++内置数组是零个或多个相同类型的数据项。在C++中，使用方括号声明数组和访问数组元素：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `squares` variable is an array of integers. The first line allocates enough
    memory for *four* integers and then the `for` loop initializes the memory with
    the first four squares. The memory allocated by the compiler from the stack is
    contiguous and the items in the array are sequential, so the memory location of
    `squares[3]` is `sizeof(int)` following on from `squares[2]`. Since the array
    is created on the stack, the size of the array is an instruction to the compiler;
    this is not dynamic allocation, so the size has to be a constant.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`squares`变量是一个整数数组。第一行为*四个*整数分配了足够的内存，然后`for`循环初始化了前四个平方的内存。编译器从堆栈中分配的内存是连续的，数组中的项目是顺序的，因此`squares[3]`的内存位置是从`squares[2]`的`sizeof(int)`开始的。由于数组是在堆栈上创建的，数组的大小是对编译器的一条指令；这不是动态分配，因此大小必须是一个常量。'
- en: 'There is a potential problem here: the size of the array is mentioned twice,
    once in the declaration and then again in the `for` loop. If you use two different
    values, then you may initialize too few items, or you could potentially access
    memory outside the array. The ranged `for` syntax allows you to get access to
    each item in the array; the compiler can determine the size of the array and will
    use this in the ranged `for` loop. In the following code, there is a deliberate
    mistake that shows an issue with array sizes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在潜在的问题：数组的大小被提到两次，一次在声明中，然后在`for`循环中再次提到。如果使用两个不同的值，那么您可能会初始化太少的项目，或者可能会访问数组之外的内存。范围`for`语法允许您访问数组中的每个项目；编译器可以确定数组的大小，并将在范围`for`循环中使用它。在下面的代码中，有一个故意的错误，显示了数组大小的问题：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The size of the array and the range of the first `for` loop do not agree and
    consequently the last item will not be initialized. The ranged `for` loop, however,
    will loop through all five items and so will print out some random value for the
    value of the last value. What if the same code is used but the `squares` array
    is declared to have three items? It depends on the compiler you are using and
    whether you are compiling a debug build, but clearly you will be writing to memory
    *outside* of that allocated to the array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小和第一个`for`循环的范围不一致，因此最后一个项目将不会被初始化。然而，范围`for`循环将循环遍历所有五个项目，因此将打印出最后一个值的一些随机值。如果使用相同的代码，但将`squares`数组声明为三个项目呢？这取决于您使用的编译器以及您是否正在编译调试版本，但显然您将写入*数组分配之外*的内存。
- en: 'There are some ways to mitigate these issues. The first one has been mentioned
    in an earlier chapter: declare a constant for the size of the array and use that
    whenever your code needs to know the array size:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法可以缓解这些问题。第一个方法在早期的章节中已经提到过：声明一个数组大小的常量，并在代码需要知道数组大小时使用它：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The array declaration must have a constant for the size, and that is managed
    by using the `sq_size` constant variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数组声明必须有一个常量作为大小，并且通过使用`sq_size`常量变量来管理。
- en: 'You may also want to calculate the size of an already allocated array. The
    `sizeof` operator, when applied to an array, returns the size in bytes of the
    *entire* array, so you can determine the size of the array by dividing this value
    by the size of a single item:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想计算已分配数组的大小。`sizeof`运算符，当应用于数组时，返回*整个*数组的字节大小，因此您可以通过将这个值除以单个项目的大小来确定数组的大小：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is safer code, but clearly it is verbose. The C runtime library contains
    a macro called `_countof` that performs this calculation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更安全的代码，但显然很冗长。C运行时库包含一个名为`_countof`的宏，用于执行这个计算。
- en: Function parameters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: As illustrated, there is an automatic conversion of an array to the appropriate
    pointer type and this occurs if you pass an array to a function, or return it
    from a function. This decay to a dumb pointer means that other code can make no
    assumption about an array size. A pointer could point to memory allocated on the
    stack where the memory lifetime is determined by the function, or a global variable
    where the memory lifetime is that of the program, or it could be to memory that
    is dynamically allocated and the memory is determined by the programmer. There
    is nothing in a pointer declaration that indicates the type of memory or who is
    responsible for the deallocation of the memory. Nor is there any information in
    a dumb pointer of how much memory the pointer points to. When you write code using
    pointers, you have to be disciplined about how you use them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，数组会自动转换为适当的指针类型，如果你将数组传递给一个函数，或者从一个函数返回它。这种衰变为愚蠢的指针意味着其他代码不能假设数组的大小。指针可能指向在函数确定内存生命周期的堆栈上分配的内存，或者指向程序的内存生命周期的全局变量，或者可能指向由程序员确定内存的动态分配的内存。在指针声明中没有任何信息表明内存的类型或谁负责释放内存。在愚蠢的指针中也没有任何关于指针指向多少内存的信息。当你使用指针编写代码时，你必须严格遵守它们的使用方式。
- en: 'A function can have an array parameter, but this means a lot less than it appear
    to indicate:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有一个数组参数，但这意味着的远不及它表面所示的那么多：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function will check that each member of the array has a value between
    the minimum and maximum values allowed. There are four tires in use at any one
    time on a car, so the function *should* be called with an array of four values.
    The problem is that although it appears that the compiler *should* check that
    the array passed to the function is the appropriate size, it doesn''t. You can
    call this function like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将检查数组的每个成员是否具有在允许的最小和最大值之间的值。汽车上一次使用四个轮胎，所以这个函数*应该*被调用以传递一个包含四个值的数组。问题在于，尽管看起来编译器*应该*检查传递给函数的数组是否是适当的大小，但它并没有。你可以这样调用这个函数：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Of course, it should have been obvious to the developer that a truck is not
    a car, and so this developer should not have written this code, but the usual
    advantage of a compiled language is that the compiler will perform some *sanity
    checks* for you. In the case of array parameters, it won't.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发人员应该明显地意识到卡车不是汽车，因此这个开发人员不应该编写这段代码，但编译语言的通常优势是编译器会为你执行一些*合理性检查*。在数组参数的情况下，它不会。
- en: The reason is that the array is passed as a pointer, so although the parameter
    appears to be a built-in array, you cannot use facilities you are used to using
    with arrays like ranged `for`. In fact, if the `safe_car` function calls `sizeof(tire_pressures)`,
    it will get the size of a double pointer and not 16, the size in bytes of a four
    `int` array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是数组被传递为指针，因此尽管参数看起来是一个内置数组，但你不能使用你习惯使用的数组功能，比如范围`for`。事实上，如果`safe_car`函数调用`sizeof(tire_pressures)`，它将得到一个双指针的大小，而不是16，即四个`int`数组的字节大小。
- en: 'This *decay to a pointer* feature of array parameters means that functions
    will only ever know the size of an array parameter if you explicitly tell it the
    size. You can use an empty pair of square brackets to indicate that the item should
    be passed an array, but it really is just the same as a pointer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 数组参数的*衰变为指针*特性意味着函数只有在你明确告诉它大小时才会知道数组参数的大小。你可以使用一对空的方括号来表示应该传递一个数组，但实际上它只是一个指针：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here the function has a parameter that indicates the size of the array. The
    preceding function is exactly the same as declaring the first parameter to be
    a pointer. The following is not an overload of the function; it is the *same*
    function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数有一个指示数组大小的参数。前面的函数与声明第一个参数为指针完全相同。以下不是函数的重载；它是*相同*的函数：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The important point is that when you pass an array to a function, the *first
    dimension* of the array is treated as a pointer. So far arrays have been single
    dimensional, but they may have more than one dimension.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，当你把一个数组传递给一个函数时，数组的*第一个维度*会被视为一个指针。到目前为止，数组一直是单维的，但它们可能有多个维度。
- en: Multidimensional arrays
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'Arrays can be multidimensional and to add another dimension you add another
    set of square brackets:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以是多维的，要添加另一个维度，需要添加另一组方括号：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first example creates an array of two integers, the second creates a two-dimensional
    array with 12 integers arranged so that there are four rows of three columns.
    Of course, *row* and *column* are arbitrary and treat the two-dimensional array
    like a conventional spreadsheet table, but it helps to visualize how the data
    is arranged in memory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子创建了一个包含两个整数的数组，第二个例子创建了一个包含12个整数的二维数组，排列成四行三列。当然，*行*和*列*是任意的，并且将二维数组视为传统的电子表格表格，但这有助于可视化数据在内存中的排列方式。
- en: Note that there are square brackets around every dimension. C++ is different
    to other languages in this respect, so a declaration of `int x[10,10]` will be
    reported as an error by the C++ compiler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个维度周围都有方括号。在这方面，C++与其他语言不同，所以`int x[10,10]`的声明将被C++编译器报告为错误。
- en: 'Initializing multidimensional arrays involves a pair of braces and the data
    in the order that it will be used to initialize the dimensions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化多维数组涉及一对大括号和按照将用于初始化维度的顺序排列的数据：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, the values having the highest digit reflect the left-most
    index and the lower digit reflect, the right-most index (in both cases, one more
    than the actual index). Clearly, you can split this over several lines and use
    whitespace to group values together to make this more readable. You can also use
    nested braces. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，具有最高数字的值反映了最左边的索引，较低的数字反映了右边的索引（在这两种情况下，比实际索引多一个）。显然，你可以将这个分成几行，并使用空格来将值分组在一起，以使其更易读。你也可以使用嵌套的大括号。例如：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you read the dimensions going left to right, you can read the initialization
    going into deeper levels of nesting. There are four rows, so within the outer
    braces there are four sets of nested braces. There are three columns, and so within
    the nested braces there are three initialization values.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从左到右读取维度，你可以读取初始化值进入更深层次的嵌套。有四行，所以在外部大括号内有四组嵌套的大括号。有三列，所以在嵌套的大括号内有三个初始化值。
- en: 'Nested braces are not just a convenience for formatting your C++ code, because
    if you provide an empty pair of braces the compiler will use the default value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的大括号不仅仅是为了格式化你的C++代码的方便，因为如果你提供了一对空的大括号，编译器将使用默认值：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the second-row items are initialized to 0.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第二行的项目被初始化为0。
- en: 'When you increase the dimensions, the principle applies: increase the nesting
    for the right most dimension:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你增加维度时，原则仍然适用：增加最右边维度的嵌套：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is four rows of three columns of pairs (as you can see, when the dimensions
    increase it becomes apparent that the terms **rows** and **columns** are largely
    arbitrary).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是四行三列的成对数组（当维度增加时，可以看出术语**行**和**列**在很大程度上是任意的）。
- en: 'You access items using the same syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的语法访问项目：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In terms of the memory layout, the compiler interprets the syntax in the following
    way. The first index determines the offset from the beginning of the array in
    chunks of six integers (3 * 2), the second index indicates the offset within one
    of these six integer *chunks* itself in chunks of two integers, and the third
    index is the offset in terms of individual integers. Thus `[3][2][0]` is *(3 *
    6) + (2 * 2) + 0 = 22* integers from the beginning, treating the first integer
    as index zero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就内存布局而言，编译器以以下方式解释语法。第一个索引确定了从数组开始处的偏移量，每次偏移六个整数（3 * 2），第二个索引指示了在这六个整数“块”内的偏移量，每次偏移两个整数，第三个索引是以单个整数为单位的偏移量。因此`[3][2][0]`是从开始处*(3
    * 6) + (2 * 2) + 0 = 22*个整数的偏移量，将第一个整数视为索引零。
- en: A multidimensional array is treated as arrays of arrays, so the type of each
    "row" is `int[3][2]` and we know from the declaration that there are four of them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组被视为数组的数组，因此每个“行”的类型是`int[3][2]`，我们从声明中知道有四个这样的行。
- en: Passing multidimensional arrays to functions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多维数组传递给函数
- en: 'You can pass a multidimensional array to a function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多维数组传递给一个函数：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This compiles and you can access the parameter as a 4x5 array, assuming that
    this vehicle has four wheels with five nuts on each one.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样编译后，你可以将参数作为一个4x5的数组访问，假设这辆车有四个轮子，每个轮子上有五个螺母。
- en: 'As stated earlier, when you pass an array, the first dimension will be treated
    as a pointer, so while you can pass a 4x5 array to this function, you can also
    pass a 2x5 array and the compiler will not complain. However, if you pass a 4x3
    array (that is, the second dimension is not the same as declared in the function),
    the compiler will issue an error that the array is incompatible. The parameter
    may be more accurately described as being `double row[][5]`. Since the size of
    the first dimension is not available, the function should be declared with the
    size of that dimension:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当你传递一个数组时，第一个维度将被视为指针，所以虽然你可以将一个4x5的数组传递给这个函数，你也可以传递一个2x5的数组，编译器不会抱怨。然而，如果你传递一个4x3的数组（也就是说，第二个维度与函数中声明的不同），编译器将发出一个数组不兼容的错误。参数可能更准确地描述为`double
    row[][5]`。由于第一个维度的大小不可用，函数应该声明该维度的大小：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This says that `nut_torques` is one or more "rows", each of which has five
    items. Since the array does not provide information about the number of rows it
    has, you should provide it. Another way to declare this is:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明`nut_torques`是一个或多个“行”，每个行有五个项目。由于数组没有提供有关它有多少行的信息，你应该提供它。另一种声明方式是：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The brackets are important here, if you omit them and use `double *nut_torques[5]`,
    then it means the `*` will refer to the type in the array, that is, the compiler
    will treat `nut_torques` as a five-element array of `double*` pointers. We have
    seen an example of such an array before:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里括号很重要，如果你省略它们并使用`double *nut_torques[5]`，那么`*`将指的是数组中的类型，也就是说，编译器将把`nut_torques`视为一个`double*`指针的五个元素数组。我们之前已经看到了这样一个数组的例子：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `argv` parameter is an array of `char*` pointers. You can also declare the
    `argv` parameter as `char**` which has the same meaning.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv`参数是一个`char*`指针数组。你也可以将`argv`参数声明为`char**`，它具有相同的含义。'
- en: In general, if you intend to pass arrays to a function it is best to use custom
    types, or use the C++ array types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你打算将数组传递给一个函数，最好使用自定义类型，或者使用C++数组类型。
- en: Using ranged `for` with multidimensional arrays is a bit more complicated than
    appears on first sight, and requires the use of a reference as explained in the
    section later in this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多维数组的范围`for`循环比第一眼看上去更复杂，并且需要在本章后面的部分中解释的引用的使用。
- en: Using arrays of characters
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符数组
- en: Strings will be covered in more detail in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*, but it is worth pointing out here that C strings are arrays of
    characters and are accessed through pointer variables. This means that if you
    want to manipulate strings, you must manipulate the memory that the pointer points
    to, and not manipulate the pointer itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串将在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml) *使用字符串*中更详细地介绍，但值得指出的是，C字符串是字符数组，并且通过指针变量访问。这意味着如果你想操作字符串，你必须操作指针指向的内存，而不是操作指针本身。
- en: Comparing strings
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'The following allocates two string buffers and it calls the `strcpy_s` function
    to initialize each with the same string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下分配了两个字符串缓冲区，并调用`strcpy_s`函数来用相同的字符串初始化每个缓冲区：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `strcpy_c` function will copy characters from the pointer given in the last
    parameter (until the terminating `NUL`), into the buffer given in the first parameter,
    whose maximum size is given in the second parameter. These two pointers are compared
    in the final line, and this will return a value of `false`. The problem is that
    the compare function is comparing the values of the pointers, not what the pointers
    point to. The two buffers have the same string, but the pointers are different,
    so `b` will be `false`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcpy_c`函数将从最后一个参数中给定的指针（直到终止的`NUL`）复制字符，到第一个参数中给定的缓冲区中，该缓冲区的最大大小在第二个参数中给出。这两个指针在最后一行进行比较，这将返回一个`false`值。问题在于比较函数比较的是指针的值，而不是指针指向的内容。这两个缓冲区具有相同的字符串，但指针不同，因此`b`将是`false`。'
- en: 'The correct way to compare strings is to compare the data character by character
    to see if they are equal. The C runtime provides `strcmp` that compares two string
    buffers character by character, and the `std::string` class defines a function
    called `compare` that will also perform such a comparison; however, be wary of
    the value returned from these functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符串的正确方法是逐个字符比较数据以查看它们是否相等。C运行时提供了`strcmp`，它逐个字符比较两个字符串缓冲区，并且`std::string`类定义了一个名为`compare`的函数，也将执行这样的比较；但是，要注意这些函数返回的值：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The return value is not a `bool` type indicating if the two strings are the
    same; it is an `int`. These compare functions carry out a lexicographical compare
    and return a negative value if the parameter (`s2` in this code) is greater than
    the operand (`s1`) lexicographically, and a positive number if the operand is
    greater than the parameter. If the two strings are the same, the function returns
    0\. Remember that a `bool` is `false` for a value of 0 and `true` for non-zero
    values. The standard library provides an overload for the `==` operator for `std::string`,
    so it is safe to write code like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值不是`bool`类型，表示两个字符串是否相同；它是一个`int`。这些比较函数进行词典比较，如果参数（在这个代码中是`s2`）在词典上大于操作数（`s1`），则返回一个负值，如果操作数大于参数，则返回一个正数。如果两个字符串相同，函数返回0。记住，`bool`对于值为0是`false`，对于非零值是`true`。标准库为`std::string`提供了`==`运算符的重载，因此可以安全地编写这样的代码：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The operator will compare the strings contained in the two variables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员将比较两个变量中包含的字符串。
- en: Preventing buffer overruns
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止缓冲区溢出
- en: 'The C runtime library for manipulating strings is notorious for allowing buffer
    overruns. For example, the `strcpy` function copies one string to another, and
    you get access to this through the `<cstring>` header, which is included by the
    `<iostream>` header. You may be tempted to write something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于操作字符串的C运行时库以允许缓冲区溢出而臭名昭著。例如，`strcpy`函数将一个字符串复制到另一个字符串，并且您可以通过`<cstring>`头文件访问它，该头文件由`<iostream>`头文件包含。您可能会尝试编写类似这样的代码：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The problem is that `strcpy` will copy all the character up to, and including
    the terminating `NULL` character and so you will be copying six characters into
    an array with space for only *five*. You could be taking a string from the user
    input (say, from a text box on a web page) and think that the array you have allocated
    is big enough, but a malicious user could provide an excessively long string deliberately
    bigger than the buffer so that it overwrites other parts of your program. Such
    *buffer overruns* have caused a lot of programs to be subjected to hackers taking
    control of servers, so much so that the C string functions have all been replaced
    by safer versions. Indeed, if you are tempted to type the preceding code, you''ll
    find that `strcpy` is available, but the Visual C++ compiler will issue an error:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`strcpy`将复制所有字符直到包括终止的`NULL`字符，因此您将把六个字符复制到只有*五*个空间的数组中。您可能会从用户输入中获取一个字符串（比如，从网页上的文本框），并认为您分配的数组足够大，但是恶意用户可能会提供一个故意大于缓冲区的过长字符串，以便覆盖程序的其他部分。这种*缓冲区溢出*导致许多程序遭受黑客控制服务器的攻击，以至于C字符串函数都已被更安全的版本所取代。实际上，如果您尝试键入上述代码，您会发现`strcpy`是可用的，但是Visual
    C++编译器会发出错误：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you have existing code that uses `strcpy`, and you need to make that code
    compile, you can define the symbol before `<cstring>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有使用`strcpy`的现有代码，并且需要使该代码编译，可以在`<cstring>`之前定义该符号：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An initial attempt to prevent this issue is to call `strncpy`, which will copy
    a specific number of characters:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 防止这个问题的一个初始尝试是调用`strncpy`，它将复制特定数量的字符：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The function will copy up to five characters and then stop. The problem is
    that the string to copy has five characters and so the result will be no `NULL`
    termination. The safer version of this function has a parameter that you can use
    to say how big the destination buffer is:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将复制最多五个字符，然后停止。问题在于要复制的字符串有五个字符，因此结果将没有`NULL`终止。此函数的更安全版本具有一个参数，您可以使用该参数指定目标缓冲区的大小：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At runtime this will still cause a problem. You have told the function that
    the buffer is five characters in size and it will determine that this is not big
    enough to hold the six characters that you have asked it to copy. Rather than
    allowing the program to silently continue and the buffer overrun to cause problems,
    the safer string functions will call a function called the **constraint handler**
    and the default version will shut down the program on the rationale that a buffer
    overrun means that the program is compromised.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，这仍然会导致问题。您告诉函数缓冲区大小为五个字符，它将确定这不足以容纳您要求它复制的六个字符。与其允许程序悄悄继续并且缓冲区溢出导致问题，更安全的字符串函数将调用一个名为**约束处理程序**的函数，其默认版本将关闭程序，理由是缓冲区溢出意味着程序已受到威胁。
- en: 'The C runtime library strings functions were originally written to return the
    result of the function, the safer versions now return an error value. The `strncpy_s`
    function can also be told to truncate the copy rather than call the constraint
    handler:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C运行时库字符串函数最初是为了返回函数的结果，现在更安全的版本返回一个错误值。`strncpy_s`函数也可以被告知截断复制而不是调用约束处理程序：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The C++ `string` class protects you from such issues.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++的`string`类可以保护你免受这些问题的困扰。
- en: Using pointers in C++
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中使用指针
- en: Pointers are clearly very important in C++, but as with any powerful feature,
    there are issues and dangers, so it is worth pointing out some of the major issues.
    A pointer points to a single location in memory, and the type of the pointer indicates
    how the memory location should be interpreted. The very most you can assume is
    the number of bytes at that position in memory is the size of the type of the
    pointer. That's it. This means that pointers are inherently unsafe. However, in
    C++ they are the quickest way to enable code within your process to access large
    amounts of data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，指针显然非常重要，但与任何强大的功能一样，都存在问题和危险，因此值得指出一些主要问题。指针指向内存中的单个位置，指针的类型表示应该如何解释内存位置。你最多可以假设的是在内存中该位置的字节数是指针类型的大小。就是这样。这意味着指针本质上是不安全的。然而，在C++中，它们是使你的进程内的代码快速访问大量数据的最快方式。
- en: Accessing out of bounds
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问超出边界
- en: 'When you allocate a buffer, whether on the stack or on the free store, and
    you get a pointer, there is little to stop you from accessing memory you have
    not allocated--either before or after the position of the buffer. This means that
    when you use pointer arithmetic, or indexed access on arrays, that you check carefully
    that you are not going to access data out of bounds. Sometimes the error may not
    be immediately obvious:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分配一个缓冲区，无论是在堆栈上还是在自由存储器上，并且你得到一个指针时，很少有东西能阻止你访问你没有分配的内存--无论是在缓冲区的位置之前还是之后。这意味着当你使用指针算术或数组的索引访问时，你要仔细检查你是否将要访问超出边界的数据。有时错误可能并不立即显而易见：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you use indexing, you have to keep reminding yourself that arrays are indexed
    from zero so the highest index is the size of the array minus 1.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用索引时，你必须不断提醒自己数组是从零开始索引的，所以最高的索引是数组大小减1。
- en: Pointers to deallocated memory
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指向释放内存的指针
- en: 'This applies to memory allocated on the stack and to memory dynamically allocated.
    The following is a poorly written function that returns a string allocated on
    the stack in a function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于在堆栈上分配的内存和动态分配的内存。以下是一个糟糕编写的函数，它在函数中返回了一个在堆栈上分配的字符串：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code allocates a buffer of six characters and then initializes
    it with the five characters of the string literal `hello`, and the `NULL` termination
    character. The problem is that once the function finishes the stack frame is torn
    down so that the memory can be re-used, and the pointer will point to memory that
    could be used by something else. This error is caused by poor programming, but
    it may not be as obvious as in this example. If the function uses several pointers
    and performs a pointer assignment, you may not immediately notice that you have
    returned a pointer to a stack-allocated object. The best course of action is simply
    not to return raw pointers from functions, but if you do want to use this style
    of programming, make sure that the memory buffer is passed in through a parameter
    (so the function does not own the buffer) or is dynamically allocated and you
    are passing ownership to the caller.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码分配了一个六个字符的缓冲区，然后用字符串字面量`hello`的五个字符和`NULL`终止字符对其进行初始化。问题在于一旦函数完成，堆栈帧就会被拆除，以便内存可以被重新使用，指针将指向可能被其他东西使用的内存。这个错误是由糟糕的编程引起的，但在这个例子中可能并不像这么明显。如果函数使用了几个指针并执行了指针赋值，你可能不会立即注意到你已经返回了一个指向堆栈分配对象的指针。最好的做法就是简单地不要从函数中返回原始指针，但如果你确实想使用这种编程风格，确保内存缓冲区是通过参数传递的（所以函数不拥有缓冲区），或者是动态分配的，并且你正在将所有权传递给调用者。
- en: This leads on to another issue. If you call `delete` on a pointer and then later
    in your code, try to access the pointer, you will be accessing memory that is
    potentially being used by other variables. To alleviate this problem, you can
    get into the habit of assigning a pointer to `null_ptr` when you delete it and
    check for `null_ptr` before using a pointer. Alternatively, you can use a smart
    pointer object which will do this for you. Smart pointers will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个问题。如果你在指针上调用`delete`，然后在你的代码中稍后尝试访问指针，你将访问可能被其他变量使用的内存。为了缓解这个问题，你可以养成在删除指针时将指针赋值为`null_ptr`并在使用指针之前检查`null_ptr`的习惯。或者，你可以使用智能指针对象来代替。智能指针将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中介绍，*类*。
- en: Converting pointers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换指针
- en: You can either have typed pointers, or the `void*` pointer. Typed pointers will
    access the memory as if it is the specified type (this has interesting consequences
    when you have inheritance with classes, but that will be left for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes* and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction
    to Object-Oriented Programming*). Thus, if you cast a pointer to a different type
    and dereference it, the memory will be treated as containing the cast type. It
    rarely makes sense to do this. The `void*` pointer cannot be dereferenced, so
    you can never access data through a `void*` pointer, to access the data you have
    to cast the pointer. The whole reason for the `void*` pointer type is that it
    can point to anything. In general, `void*` pointers should only be used when the
    type does not matter to that function. For example, the C `malloc` function returns
    a `void*` pointer because the function merely allocates memory; it does not care
    what that memory will be used for.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类型化指针，也可以使用`void*`指针。类型化指针将访问内存，就好像它是指定的类型（当你在类中使用继承时，这会产生有趣的后果，但这将留到第6章，*类*和第7章，*面向对象编程简介*）。因此，如果你将指针转换为不同的类型并对其进行解引用，内存将被视为包含转换类型。这很少有意义。`void*`指针不能被解引用，因此你永远无法通过`void*`指针访问数据，要访问数据，你必须转换指针。`void*`指针类型的整个原因是它可以指向任何东西。通常情况下，只有当类型对该函数无关紧要时，才应该使用`void*`指针。例如，C中的`malloc`函数返回一个`void*`指针，因为该函数仅分配内存；它不关心该内存将用于什么目的。
- en: Constant pointers
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量指针
- en: 'Pointers can be declared as `const` which, depending on where you apply it,
    means that the memory the pointer points to is read-only through the pointer,
    or the value of the pointer is read-only:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以声明为`const`，这取决于你在哪里应用它，这意味着指针指向的内存是只读的，或者指针的值是只读的：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, `ptc` is a pointer to constant `char`, that is, although you can change
    what `ptc` points to, and you can read what it points to, you cannot use it to
    change the memory. On the other hand, `cp` is a constant pointer, which means
    you can both read and write the memory which the pointer points to, but you cannot
    change where it points to. It is typical to pass the `const char*` pointers to
    functions because the functions do not know where the string has been allocated
    or the size of the buffer (the caller may pass a literal which cannot be changed).
    Note that there is no `const*` operator so `char const*` is treated as `const
    char*`, a pointer to a constant buffer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ptc`是一个指向常量`char`的指针，也就是说，尽管你可以更改`ptc`指向的内容，并且可以读取它指向的内容，但你不能使用它来更改内存。另一方面，`cp`是一个常量指针，这意味着你既可以读取也可以写入指针指向的内存，但你不能更改它指向的位置。通常将`const
    char*`指针传递给函数，因为函数不知道字符串在哪里分配，或者缓冲区的大小（调用者可能传递一个无法更改的文字）。请注意，没有`const*`运算符，因此`char
    const*`被视为`const char*`，即指向常量缓冲区的指针。
- en: 'You can make a pointer constant, change it, or remove it using casts. The following
    does some fairly pointless changing around of the `const` keyword to prove the
    point:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用转换使指针变为常量，更改它，或者移除它。以下是对`const`关键字进行了一些相当无意义的更改，以证明这一点：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The pointers `cp1` and `cp2` can be used to change the memory they point to,
    but once assigned neither can point to other memory. The first `const_cast` casts
    away the `const`-ness to a pointer that can be changed to point to other memory,
    but cannot be used to alter that memory, `ptc`. The second `const_cast` casts
    away the `const`-ness of `ptc` so that the memory can be changed through the pointer,
    `cp2`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指针`cp1`和`cp2`可以用于更改它们指向的内存，但一旦分配，它们都不能指向其他内存。第一个`const_cast`去除了指向其他内存的`const`属性，但不能用于更改内存，`ptc`。第二个`const_cast`去除了`ptc`的`const`属性，以便可以通过指针更改内存，`cp2`。
- en: Changing the type pointed to
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改指向的类型
- en: 'The `static_cast` operator is used to convert with a compile time check, but
    not a runtime check, so this means that the pointers must be related. The `void*`
    pointer can be converted to any pointer, so the following compiles and makes sense:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_cast`运算符用于进行编译时检查的转换，而不是运行时检查，这意味着指针必须是相关的。`void*`指针可以转换为任何指针，因此以下内容可以编译并且是有意义的：'
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The C `malloc` function returns a `void*` pointer so you have to convert it
    to be able to use the memory. (Of course, the C++ `new` operator removes the need
    for such casting.) The built-in types are not "related" enough for `static_cast`
    to convert between pointer types, so you cannot use `static_cast` to convert an
    `int*` pointer to a `char*` pointer, even though `int` and `char` are both integer
    types. For custom types that are related through inheritance, you can cast pointers
    using `static_cast`, but there is no runtime check that the cast is correct. To
    cast with runtime checks you should use `dynamic_cast`, and more details will
    be given in [Chapters 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C中的`malloc`函数返回一个`void*`指针，因此你必须转换它才能使用内存。（当然，C++的`new`运算符消除了这种转换的需要。）内置类型不足够“相关”，无法使用`static_cast`在指针类型之间进行转换，因此你不能使用`static_cast`将`int*`指针转换为`char*`指针，即使`int`和`char`都是整数类型。对于通过继承相关的自定义类型，你可以使用`static_cast`进行指针转换，但没有运行时检查来验证转换是否正确。要进行带有运行时检查的转换，应该使用`dynamic_cast`，更多细节将在第6章，*类*和第7章，*面向对象编程简介*中给出。
- en: 'The `reinterpret_cast` operator is the most flexible, and dangerous, of the
    cast operators because it will convert between any pointer types without any type
    checks. It is inherently unsafe. For example, the following code initializes a
    wide character array with a literal. The array `wc` will have six characters,
    `hello` followed by `NULL`. The `wcout` object interprets a `wchar_t*` pointer
    as a pointer to the first character in a `wchar_t` string, so inserting `wc` will
    print the string (every character until the `NUL`). To get the actual memory location,
    you have to convert the pointer to an integer:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast`运算符是转换运算符中最灵活、最危险的，因为它将在没有任何类型检查的情况下在任何指针类型之间进行转换。这是不安全的。例如，以下代码使用文字初始化宽字符数组。数组`wc`将有六个字符，`hello`后跟`NULL`。`wcout`对象将`wchar_t*`指针解释为`wchar_t`字符串中第一个字符的指针，因此插入`wc`将打印字符串（直到`NUL`为止）。要获取实际的内存位置，您必须将指针转换为整数：'
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, if you insert a `wchar_t` into the `wcout` object, it will print
    the character, not the numeric value. So, to print out the codes for the individual
    characters, we need to cast the pointer to a suitable integer pointer. This code
    assumes that a `short` is the same size as a `wchar_t`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果将`wchar_t`插入`wcout`对象中，它将打印字符，而不是数值。因此，要打印出各个字符的代码，我们需要将指针转换为合适的整数指针。此代码假定`short`与`wchar_t`大小相同：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Allocating memory in code
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中分配内存
- en: C++ defines two operators, `new` and `delete`, that allocate memory from the
    free store and release memory back into the free store.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C++定义了两个运算符`new`和`delete`，它们从自由存储区分配内存并将内存释放回自由存储区。
- en: Allocating individual objects
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配单个对象
- en: 'The `new` operator is used with the type to allocate memory, and it will return
    a typed pointer to that memory:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符与类型一起用于分配内存，并将返回指向该内存的类型化指针：'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `new` operator will call the *default constructor* for custom types for
    every object it creates (as explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*). Built-in types do not have constructors, so instead a type initialization
    will occur and this will usually initialize the object to zero (in this example,
    a zero integer).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符将为创建的每个对象调用自定义类型的*默认构造函数*（如[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中所述，*类*）。内置类型没有构造函数，因此将发生类型初始化，这通常会将对象初始化为零（在此示例中为零整数）。'
- en: In general, you should not use memory allocated for built-in types without explicitly
    initializing it. In fact, in Visual C++ the debug version of the `new` operator
    will initialize memory to a value of `0xcd` for every byte, as a visual reminder
    in the debugger that you have not initialized the memory. For custom types, it
    is left to the author of the type to initialize allocated memory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您不应该在没有明确初始化的情况下使用为内置类型分配的内存。实际上，在Visual C++中，`new`运算符的调试版本将将内存初始化为每个字节的值`0xcd`，作为调试器中的视觉提醒，表明您尚未初始化内存。对于自定义类型，将分配的内存初始化留给类型的作者。
- en: 'It is important that when you have finished with memory that you return it
    back to the free store so that the allocator can reuse it. You do this by calling
    the `delete` operator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当您使用完内存后，将其返回到自由存储区，以便分配器可以重用它。您可以通过调用`delete`运算符来执行此操作：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you delete a pointer, the **destructor** for the object is called. For
    built-in types, this does nothing. It is good practice to initialize a pointer
    to `nullptr`, after you have deleted it, and if you use the convention of checking
    the value of a pointer before using it, this will protect you from using a deleted
    pointer. The C++ standard says that the `delete` operator will have no effect
    if you delete a pointer that has a value of `nullptr`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您删除指针时，将调用对象的**析构函数**。对于内置类型，这不会有任何作用。在删除指针后，将指针初始化为`nullptr`是一个良好的做法，如果您使用在使用指针之前检查指针的值的约定，这将保护您免受使用已删除指针的伤害。C++标准规定，如果删除具有`nullptr`值的指针，`delete`运算符将不起作用。
- en: 'C++ allows you to initialize a value at the time you call the `new` operator,
    in two ways:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许您以两种方式在调用`new`运算符时初始化值：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For a custom type, the `new` operator will call a constructor on the type; for
    a built in type, the end result is the same, and is carried out by initializing
    the item to the value provided. You can also use initialized list syntax, as shown
    in the second line in the preceding code. It is important to note that the initialization
    is the memory pointed to, not the pointer variable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义类型，`new`运算符将调用类型的构造函数；对于内置类型，最终结果是相同的，并且通过将项目初始化为提供的值来执行。您还可以使用初始化列表语法，如前面代码中的第二行所示。重要的是要注意，初始化是指向的内存，而不是指针变量。
- en: Allocating arrays of objects
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配对象数组
- en: 'You can also create arrays of objects in dynamic memory using the `new` operator.
    You do this by providing the number of items you want created in a pair of square
    brackets. The following code allocates memory for two integers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`new`运算符在动态内存中创建对象数组。您可以通过提供要创建的项目数的一对方括号来执行此操作。以下代码为两个整数分配内存：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The operator returns a pointer to the type allocated, and you can use pointer
    arithmetic or array indexing to access the memory. You cannot initialize the memory
    in the `new` statement; you have to do that after creating the buffer. When you
    use `new` to create a buffer for more than one object, you must use the appropriate
    version of the `delete` operator: the `[]` is used to indicate that more than
    one item is deleted and the destructor for each object will be called. It is important
    that you always use the right version of `delete` appropriate to the version of
    `new` used to create the pointer.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符返回分配的类型的指针，您可以使用指针算术或数组索引来访问内存。您不能在`new`语句中初始化内存；您必须在创建缓冲区后执行此操作。当您使用`new`为多个对象创建缓冲区时，必须使用适当版本的`delete`运算符：`[]`用于指示删除多个项目，并将调用每个对象的析构函数。重要的是，您始终要使用与用于创建指针的`new`版本相适应的正确版本的`delete`。
- en: Custom types can define their own operator `new` and operator `delete` for individual
    objects, as well as operator `new[]` and operator `delete[]` for arrays of objects.
    The custom type author can use these to use custom memory allocation schemes for
    their objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型可以为单个对象定义自己的运算符`new`和运算符`delete`，以及为对象数组定义运算符`new[]`和运算符`delete[]`。自定义类型的作者可以使用这些来为其对象使用自定义内存分配方案。
- en: Handling failed allocations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理失败的分配
- en: 'If the `new` operator cannot allocate the memory for an object, it will throw
    the `std::bad_alloc` exception and the pointer returned will be `nullptr`. Exceptions
    are covered in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics
    and Debugging*, so only a brief outline of the syntax will be given here. It is
    important that you check for failure to allocate memory in production code. The
    following code shows how to guard the allocation so that you can catch the `std::bad_alloc`
    exception and handle it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`new`运算符无法为对象分配内存，它将引发`std::bad_alloc`异常，并且返回的指针将为`nullptr`。异常在[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)中有所涵盖，*诊断和调试*，因此此处仅给出语法的简要概述。在生产代码中，重要的是检查内存分配失败。以下代码显示了如何保护分配，以便捕获`std::bad_alloc`异常并处理它：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If any code in the `try` block throws an exception control it is passed to the
    `catch` clause, ignoring any other code that has not been executed yet. The `catch`
    clause checks the type of the exception object and if it is the correct type (in
    this case an allocation fault), it creates a reference to that object and passes
    control to the `catch` block, and the scope of the exception reference is this
    block. In this example, the code merely prints an error, but you would use it
    to take action to ensure that the memory allocation failure does not affect subsequent
    code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try`块中的任何代码引发异常控制，则将其传递到`catch`子句，忽略尚未执行的任何其他代码。`catch`子句检查异常对象的类型，如果是正确的类型（在本例中是分配故障），则创建对该对象的引用，并将控制传递到`catch`块，异常引用的范围是此块。在此示例中，代码仅打印错误，但您将使用它来采取措施以确保内存分配失败不会影响后续代码。
- en: Using other versions of the new operator
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他版本的new运算符
- en: Further, a custom type can define a placement operator `new`, which allows you
    to provide one or more parameters to the custom `new` function. The syntax of
    the placement `new` is to provide the placement fields through parentheses.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自定义类型可以定义放置运算符`new`，允许您为自定义`new`函数提供一个或多个参数。放置`new`的语法是通过括号提供放置字段。
- en: 'The C++ Standard Library version of the `new` operator provides a version that
    can take the constant `std::nothrow` as a placement field. This version will not
    throw an exception if the allocation fails, instead, the failure can only be assessed
    from the value of the returned pointer:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库版本的`new`运算符提供了一个可以将常量`std::nothrow`作为放置字段的版本。如果分配失败，此版本不会抛出异常，而是只能从返回指针的值来评估失败：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The parentheses before the type are used to pass placement fields. If you use
    parentheses after the type, these will give a value to initialize the object if
    the allocation is successful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型之前使用括号用于传递放置字段。如果在类型之后使用括号，这些将为成功分配内存的对象初始化一个值。
- en: Memory lifetime
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存寿命
- en: 'The memory allocated by `new` will remain valid until you call `delete`. This
    means that you may have memory with long lifetimes, and the code may be passed
    around various functions in your code. Consider this code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由`new`分配的内存将保持有效，直到调用`delete`。这意味着您可能拥有寿命很长的内存，并且代码可能在代码中的各种函数之间传递。考虑以下代码：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This code creates a pointer and initializes the memory it points to and then
    passes the pointer to a function, which itself returns a pointer. Since the `p1`
    pointer is no longer needed, it is deleted and assigned to `nullptr` so that it
    cannot be used again. This code looks fine, but the problem is what do you do
    with the pointer returned by the function? Imagine that the function simply manipulates
    the data pointed to by the pointer:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建一个指针并初始化其指向的内存，然后将指针传递给一个函数，该函数本身返回一个指针。由于不再需要`p1`指针，因此将其删除并分配为`nullptr`，以便不能再次使用。这段代码看起来不错，但问题是您如何处理函数返回的指针？想象一下，该函数只是操作指针指向的数据：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In effect, calling `do_something` creates a copy of a pointer, but not a copy
    of what it points to. This means that when the `p1` pointer is deleted, the memory
    it points to is no longer available, and so the pointer `p2` points to the invalid
    memory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，调用`do_something`会创建指针的副本，但不会创建指向的内容的副本。这意味着当删除`p1`指针时，它指向的内存将不再可用，因此指针`p2`指向无效内存。
- en: This problem can be addressed using a mechanism called **Resource Acquisition
    Is Initialization** (**RAII**), which means using the features of C++ objects
    to manage resources. RAII in C++ needs classes and in particular, copy constructors
    and destructors. A smart pointer class can be used to manage a pointer so that
    when it is copied, the memory it points to is also copied. A destructor is a function
    that is called automatically when the object goes out of scope and so a smart
    pointer can use this to free memory. Smart pointers and destructors will be covered
    in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一种称为**资源获取即初始化**（**RAII**）的机制来解决这个问题，这意味着使用C++对象的特性来管理资源。C++中的RAII需要类，特别是复制构造函数和析构函数。智能指针类可用于管理指针，以便在复制时也复制其指向的内存。析构函数是在对象超出范围时自动调用的函数，因此智能指针可以使用它来释放内存。智能指针和析构函数将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中进行介绍，*类*。
- en: The Windows SDK and pointers
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows SDK和指针
- en: 'Returning a pointer from a function has its inherent dangers: the responsibility
    for the memory is passed to the caller, and the caller must ensure that the memory
    is appropriately de-allocated, otherwise this could cause a memory leak with a
    corresponding loss of performance. In this section, we will look at some ways
    that the Window''s **Software Development Kit** (**SDK**) provides access to memory
    buffers and learn some techniques used in C++.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数返回指针具有其固有的危险：内存的责任被传递给调用者，调用者必须确保内存得到适当释放，否则可能导致内存泄漏和相应的性能损失。在本节中，我们将探讨Windows
    **软件开发工具包**（**SDK**）提供对内存缓冲区的访问以及学习C++中使用的一些技术。
- en: First, it is worth pointing out that any function in the Windows SDK that returns
    a string, or has a string parameter, will come in two versions. The version suffixed
    with `A` indicates that the function uses ANSI strings, and the `W` version will
    use wide character strings. For the purpose of this discussion, it is easier to
    use the ANSI functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，值得指出的是，Windows SDK中返回字符串或具有字符串参数的任何函数都将有两个版本。带有`A`后缀的版本表示该函数使用ANSI字符串，而`W`版本将使用宽字符字符串。对于本讨论，使用ANSI函数更容易。
- en: 'The `GetCommandLineA` function has the following prototype (taking into account
    the Windows SDK `typedef`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommandLineA`函数具有以下原型（考虑Windows SDK的`typedef`）：'
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: All Windows functions are defined as using the `__stdcall` calling convention.
    Usually, you will see the `typedef` of `WINAPI` used for the `__stdcall` calling
    convention.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Windows函数都被定义为使用`__stdcall`调用约定。通常，您会看到`WINAPI`的`typedef`用于`__stdcall`调用约定。
- en: 'The function can be called like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可以这样调用：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that we are making no effort to do anything about freeing the returned
    buffer. The reason is that the pointer points to memory that lives the lifetime
    of your process, so you *should not* release it. Indeed, if you were to release
    it, how would you do it? You cannot guarantee that the function was written with
    the same compiler, or the same libraries that you are using, so you cannot use
    the C++ `delete` operator or the C `free` function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有努力释放返回的缓冲区。原因是指针指向的内存存在于进程的生命周期中，因此您*不应*释放它。实际上，如果您释放它，您该如何做呢？您无法保证该函数是使用相同的编译器或您正在使用的相同库编写的，因此您无法使用C++的`delete`运算符或C的`free`函数。
- en: When a function returns a buffer, it is important to consult the documentation
    to see who allocated the buffer, and who should release it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回缓冲区时，重要的是查阅文档以查看是谁分配了缓冲区，以及谁应该释放它。
- en: 'Another example is `GetEnvironmentStringsA`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`GetEnvironmentStringsA`：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This also returns a pointer to a buffer, but this time the documentation is
    clear that after using the buffer you should release it. The SDK provides a function
    to do this called `FreeEnvironmentStrings`. The buffer contains one string for
    each environment variable in the form `name=value` and each string is terminated
    by a `NUL` character. The last string in the buffer is simply a `NUL` character,
    that is, there are two `NUL` characters at the end of the buffer. These functions
    can be used like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这也返回一个指向缓冲区的指针，但这次文档清楚地指出在使用缓冲区后应释放它。SDK提供了一个名为`FreeEnvironmentStrings`的函数来执行此操作。缓冲区中包含形式为`name=value`的每个环境变量的一个字符串，并且每个字符串都以`NUL`字符终止。缓冲区中的最后一个字符串只是一个`NUL`字符，也就是说，缓冲区的末尾有两个`NUL`字符。这些函数可以这样使用：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `strlen` function is part of the C runtime library and it returns the length
    of a string. You do not need to know how the `GetEnvironmentStrings` function
    allocates the buffer because the `FreeEnvironmentStrings` will call the correct
    deallocation code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`strlen`函数是C运行时库的一部分，它返回字符串的长度。您不需要知道`GetEnvironmentStrings`函数如何分配缓冲区，因为`FreeEnvironmentStrings`将调用正确的释放代码。'
- en: 'There are cases when the developer has the responsibility of allocating a buffer.
    The Windows SDK provides a function called `GetEnvironmentVariable` to return
    the value of a named environment variable. When you call this function, you do
    not know if the environment variable is set, or if it is set, or how big its value
    is, so this means that you will most likely have to allocate some memory. The
    prototype of the function is:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，开发人员有责任分配缓冲区。Windows SDK提供了一个名为`GetEnvironmentVariable`的函数，用于返回命名环境变量的值。当您调用此函数时，您不知道环境变量是否设置，或者如果设置了，其值有多大，因此这意味着您很可能需要分配一些内存。该函数的原型是：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: There are two parameters that are pointers to C strings. There is a problem
    here, a `char*` pointer could be passing *in* a string to the function, or it
    could be used to pass in a buffer for a string to be returned *out*. How do you
    know what a `char*` pointer is intended to be used for?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个参数是指向C字符串的指针。这里有一个问题，`char*`指针可以用于将*字符串传递给*函数，也可以用于传递*字符串返回的缓冲区*。您如何知道`char*`指针的预期用途是什么？
- en: You are given a clue with the full parameter declaration. The `lpName` pointer
    is marked `const` so the function will not alter the string it points to; this
    means that it is an *in* parameter. This parameter is used to pass in the name
    of the environment variable you want to obtain. The other parameter is simply
    a `char*` pointer, so it could be used to pass a string *in* to the function or
    *out*, or indeed, both *in* and *out*. The only way to know how to use this parameter
    is to read the documentation. In this case, it is an *out* parameter; the function
    will return the value of the environment variable in `lpBuffer` if the variable
    exists, or if the variable does not exist, the function will leave the buffer
    untouched and return the value 0\. It is your responsibility to allocate this
    buffer in whatever way you see fit, and you pass the size of this buffer in the
    last parameter, `nSize`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的参数声明给了你一个线索。`lpName`指针被标记为`const`，所以函数不会改变它指向的字符串；这意味着它是一个*输入*参数。这个参数用于传递你想要获取的环境变量的名称。另一个参数只是一个`char*`指针，所以它可以用来向函数传递一个字符串*输入*，或者*输出*，或者两者兼而有之。知道如何使用这个参数的唯一方法是阅读文档。在这种情况下，它是一个*输出*参数；如果变量存在，函数将返回`lpBuffer`中的环境变量的值，如果变量不存在，函数将保持缓冲区不变，并返回值0。你有责任以任何你认为合适的方式分配这个缓冲区，并且你要在最后一个参数`nSize`中传递这个缓冲区的大小。
- en: The function's return value has two purposes. It is used to indicate that an
    error has occurred (just one value, 0, which means you have to call the `GetLastError`
    function to get the error), and it is also used to give you information about
    the buffer, `lpBuffer`. If the function succeeds, then the return value is the
    number of characters copied into the buffer excluding the `NULL` terminating character.
    However, if the function determines that the buffer is too small (it knows the
    size of the buffer from the `nSize` parameter) to hold the environment variable
    value, no copy will happen, and the function will return the required size of
    the buffer, which is the number of characters in the environment variable including
    the `NULL` terminator.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值有两个目的。它用于指示发生了错误（只有一个值，0，这意味着你必须调用`GetLastError`函数来获取错误），它还用于提供有关缓冲区`lpBuffer`的信息。如果函数成功，则返回值是复制到缓冲区中的字符数，不包括`NULL`终止字符。然而，如果函数确定缓冲区太小（它从`nSize`参数知道缓冲区的大小）无法容纳环境变量值，将不会发生复制，并且函数将返回缓冲区所需的大小，即环境变量中的字符数，包括`NULL`终止符。
- en: 'A common way to call this function is to call it twice, first with a zero-sized
    buffer and then use the return value to allocate a buffer before calling it again:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数的常见方法是先用一个大小为零的缓冲区调用它，然后再使用返回值来分配一个缓冲区，然后再次调用它：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In general, as with all libraries, you have to read the documentation to determine
    how the parameters are used. The Windows documentation will tell you if a pointer
    parameter is in, out, or in/out. It will also tell you who owns the memory and
    whether you have the responsibility for allocating and/or freeing the memory.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，和所有的库一样，你必须阅读文档来确定参数的使用方式。Windows文档会告诉你指针参数是输入、输出还是输入/输出。它还会告诉你谁拥有内存，以及你是否有责任分配和/或释放内存。
- en: Whenever you see a pointer parameter for a function, take special care to check
    the documentation as to what the pointer is used for and how the memory is managed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到一个函数的指针参数时，一定要特别注意检查文档，了解指针的用途以及内存是如何管理的。
- en: Memory and the C++ Standard Library
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存和C++标准库
- en: The C++ Standard Library provides various classes to allow you to manipulate
    collections of objects. These classes, called the **Standard Template Library**
    (**STL**), provide a standard way to insert items into collection objects and
    ways to access the items and iterate through entire collections (called iterators).
    The STL defines collection classes that are implemented as queues, stacks, or
    as vectors with random access. These classes will be covered in depth [Chapter
    8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml), *Using the Standard Library Containers*,
    so in this section we will limit the discussion to just two classes that behave
    like C++ built in arrays.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了各种类来允许你操作对象的集合。这些类被称为**标准模板库**（**STL**），它们提供了一种标准的方式来向集合对象插入项目，并且访问项目并遍历整个集合（称为迭代器）。STL定义了作为队列、堆栈或具有随机访问的向量的集合类。这些类将在[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)中深入讨论，*使用标准库容器*，所以在本节中我们将仅限于讨论两个行为类似于C++内置数组的类。
- en: Standard Library arrays
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库数组
- en: The C+ Standard Library provides two containers that give random access via
    an indexer to the data. These two containers also allow you to access the underlying
    memory and since they guarantee to store the items sequentially and contiguous
    in memory, they can be used when you are required to provide a pointer to a buffer.
    These two types are both templates, which means that you can use them to hold
    built-in and custom types. These two collection classes are `array` and `vector`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了两个容器，通过索引器可以随机访问数据。这两个容器还允许你访问底层内存，并且由于它们保证将项目顺序存储并且在内存中是连续的，所以当你需要提供一个指向缓冲区的指针时，它们可以被使用。这两种类型都是模板，这意味着你可以用它们来保存内置类型和自定义类型。这两个集合类分别是`array`和`vector`。
- en: Using the stack-based array class
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于堆栈的数组类
- en: 'The `array` class is defined in the `<array>` header file. The class allows
    you to create fixed sized arrays on the stack and, as with built-in arrays, they
    cannot shrink or expand at runtime. Since they are allocated on the stack, they
    do not require a call to a memory allocator at runtime, but clearly, they should
    be smaller than the stack frame size. This means that an `array` is a good choice
    for small arrays of items. The size of an `array` must be known at compile time
    and it is passed as a template parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`类在`<array>`头文件中定义。该类允许您在堆栈上创建固定大小的数组，并且与内置数组一样，它们不能在运行时收缩或扩展。由于它们是在堆栈上分配的，因此它们不需要在运行时调用内存分配器，但显然，它们应该比堆栈帧大小小。这意味着`array`是小型项目的良好选择。`array`的大小必须在编译时知道，并作为模板参数传递：'
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this code, the first template parameter in the angle brackets (`<>`) is
    the type of each item in the array, and the second parameter is the number of
    items. This code initializes the array with an initialize list, but note that
    you still have to provide the size of the array in the template. This object will
    work like a built-in array (or indeed, any of the Standard Library containers)
    with ranged `for`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，尖括号（`<>`）中的第一个模板参数是数组中每个项目的类型，第二个参数是项目的数量。这段代码使用初始化列表初始化数组，但请注意，您仍然必须在模板中提供数组的大小。这个对象将像内置数组（或者确实，任何标准库容器）一样使用范围`for`：
- en: '[PRE60]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The reason is that `array` implements the `begin` and `end` functions that
    are required for this syntax. You can also use indexing to access items:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`array`实现了所需的`begin`和`end`函数，这是这种语法所必需的。您还可以使用索引来访问项目：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `size` function will return the size of the array and the square bracket
    indexer gives random access to members of the array. You can access memory outside
    of the bounds of the array, so for the previously defined array that has four
    members, you can access `arr[10]`. This may cause unexpected behavior at runtime,
    or even some kind of memory fault. To guard against this, the class provides a
    function, `at`, which will perform a range check and if the index is out of range
    the class will throw the C++ exception `out_of_range`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`函数将返回数组的大小，方括号索引器将随机访问数组的成员。您可以访问数组范围之外的内存，因此对于先前定义的具有四个成员的数组，您可以访问`arr[10]`。这可能会导致运行时出现意外行为，甚至某种内存故障。为了防范这种情况，该类提供了一个`at`函数，它将执行范围检查，如果索引超出范围，该类将抛出C++异常`out_of_range`。'
- en: 'The main advantage of using an `array` object is that you get compile time
    checks to see if you are inadvertently passing the object to a function as a dumb
    pointer. Consider this function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`array`对象的主要优势在于，您可以在编译时检查是否无意中将对象作为愚蠢的指针传递给函数。考虑这个函数：
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At runtime, the function does not know the size of the buffer passed to it,
    and in this case the documentation says that you must pass a buffer with 10 `int`
    type variables, but, as we have seen, C++ allows a built-in array to be used as
    a pointer:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，函数不知道传递给它的缓冲区的大小，在这种情况下，文档说您必须传递一个具有10个`int`类型变量的缓冲区，但是，正如我们所见，C++允许使用内置数组作为指针：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is no compiler check, nor any runtime check to catch this error. The
    `array` class will not allow such an error to happen because there is no automatic
    conversion into a dumb pointer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 没有编译器检查，也没有运行时检查来捕捉此错误。`array`类不会允许发生这样的错误，因为没有自动转换为愚蠢的指针：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you really insist in obtaining a dumb pointer, you can do this and be guaranteed
    to have access to the data as a contiguous block of memory where the items are
    stored sequentially:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您坚持要获得一个愚蠢的指针，您可以这样做，并保证以顺序存储的方式访问数据作为一个连续的内存块：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The class is not just a wrapper around a built-in array, it also provides some
    additional functionality. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该类不仅是内置数组的包装器，还提供了一些额外的功能。例如：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using the dynamically allocated vector class
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分配的向量类
- en: The Standard Library also provides the `vector` class in the `<vector>` header.
    Again, this class is a template, so you can use it with built-in and custom types.
    However, unlike `array`, the memory is dynamically allocated, which means that
    a `vector` can be expanded or shrunk at runtime. The items are stored contiguously
    so you can access the underlying buffer by calling the `data` function or accessing
    the address of the first item (to support resizing the collection, the buffer
    may change, so such pointers should only be used temporarily). And, of course,
    as with `array`, there is no automatic conversion to a dumb pointer. The `vector`
    class provides indexed random access with square bracket syntax and a range check
    with the `at` function. The class also implements the methods to allow the container
    to be used with Standard Library functions and with ranged `for`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还在`<vector>`头文件中提供了`vector`类。同样，这个类是一个模板，所以你可以用它来处理内置和自定义类型。然而，与`array`不同，内存是动态分配的，这意味着`vector`可以在运行时扩展或收缩。项目是连续存储的，因此您可以通过调用`data`函数或访问第一个项目的地址来访问底层缓冲区（为了支持调整集合的大小，缓冲区可能会改变，因此这样的指针应该只是暂时使用）。当然，与`array`一样，没有自动转换为愚蠢的指针。`vector`类提供了带方括号语法的索引随机访问和`at`函数的范围检查。该类还实现了允许容器与标准库函数和范围`for`一起使用的方法。
- en: The `vector` class has more flexibility than the `array` class because you can
    insert items, and move items around, but this does come with some overhead. Because
    instances of the class allocate memory dynamically at runtime there is a cost
    of using an allocator and there is some extra overhead in initialization and destruction
    (when the `vector` object goes out of scope). Objects of the `vector` class also
    take more memory than the data it holds. For this reason, it is not suitable for
    small numbers of items (when `array` is a better choice).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类比`array`类更灵活，因为您可以插入项目，并移动项目，但这会带来一些开销。因为类的实例在运行时动态分配内存，使用分配器的成本，以及在初始化和销毁时的一些额外开销（当`vector`对象超出范围时）。`vector`类的对象也比它所持有的数据占用更多的内存。因此，它不适用于少量项目（当`array`是更好的选择时）。'
- en: References
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用
- en: 'A reference is an alias to an object. That is, it is another name for the object,
    and so access to the object is the same through a reference as it is through the
    object''s variable name. A reference is declared using a `&` symbol on the reference
    name and it is initialized and accessed in exactly the same way as a variable:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 引用是对象的别名。也就是说，它是对象的另一个名称，因此通过引用访问对象与通过对象的变量名访问对象是相同的。引用使用`&`符号在引用名称上声明，并且它的初始化和访问方式与变量完全相同：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this code, a variable is declared and initialized, then a pointer is initialized
    to point to this data, and a reference is initialized as an alias for the variable.
    Reference `ri1` is initialized with an assignment operator, whereas reference
    `ri2` is initialized using initializer list syntax.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，声明并初始化了一个变量，然后初始化了一个指针以指向这个数据，并且初始化了一个引用作为变量的别名。引用`ri1`是使用赋值运算符初始化的，而引用`ri2`是使用初始化器列表语法初始化的。
- en: The pointer and reference have two different meanings. The reference is not
    initialized to the value of the variable, the variable's data; it is an alias
    for the variable name.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 指针和引用有两个不同的含义。引用不是初始化为变量的值，变量的数据；它是变量名的别名。
- en: Wherever the variable is used, the reference can be used; whatever you do to
    the reference is actually the same as performing the same operation on the variable.
    A pointer points to data, so you can change the data by dereferencing the pointer,
    but equally so, you can make the pointer point to any data and change that data
    by dereferencing the pointer (this is illustrated in the last two lines of the
    preceding code). You can have several aliases for a variable, and each must be
    initialized to the variable at the declaration. Once declared, you cannot make
    a reference refer to a different object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 无论变量在哪里被使用，都可以使用引用；对引用所做的任何操作实际上都等同于对变量执行相同的操作。指针指向数据，因此您可以通过取消引用指针来更改数据，同样，您也可以使指针指向任何数据，并通过取消引用指针来更改该数据（这在前面代码的最后两行中有所说明）。您可以为一个变量有几个别名，并且每个别名在声明时必须初始化为该变量。一旦声明，就不能使引用引用不同的对象。
- en: 'The following code will not compile:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将无法编译：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Since a reference is an alias for another variable, it cannot exist without
    being initialized to a variable. Likewise, you cannot initialize it to anything
    other than a variable name, so there is no concept of a *null reference*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用是另一个变量的别名，因此它不能存在而不被初始化为一个变量。同样，您不能将其初始化为除变量名以外的任何东西，因此没有*空引用*的概念。
- en: 'Once initialized, a reference is only ever an alias to the one variable. Indeed,
    when you use a reference as an operand to any operator, the operation is performed
    on the variable:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化，引用只是一个变量的别名。实际上，当您将引用用作任何运算符的操作数时，操作是在变量上执行的。
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In this code, `rx` is an alias to the variable `x`, so the assignment in the
    last line simply assigns `x` with the value of `y`: the assignment is performed
    on the aliased variable. Further, if you take the address of a reference, you
    are returned the address of the variable it references. While you can have a reference
    to an array, you cannot have an array of references.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`rx`是变量`x`的别名，因此最后一行的赋值只是将`x`赋值为`y`的值：赋值是在别名变量上执行的。此外，如果您取引用的地址，将返回引用的变量的地址。虽然您可以有一个数组的引用，但不能有一个引用的数组。
- en: Constant references
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量引用
- en: The reference used so far allows you to change the variable it is an alias for,
    therefore it has lvalue semantics. There are also `const` lvalue references, that
    is, a reference to an object that you can read, but not write to.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的引用允许您更改它是别名的变量，因此它具有左值语义。还有`const`左值引用，也就是说，引用一个对象，您可以读取，但不能写入。
- en: 'As with `const` pointers, you declare a `const` reference using the `const`
    keyword on a lvalue reference. This essentially makes the reference read-only:
    you can access the variable''s data to read it, but not to change it.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与`const`指针一样，您可以使用`const`关键字在左值引用上声明`const`引用。这基本上使引用只读：您可以访问变量的数据以读取它，但不能更改它。
- en: '[PRE70]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Returning references
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回引用
- en: 'Sometimes an object will be passed to a function and the semantics of the function
    is that the object should be returned. An example of this is the `<<` operator
    used with the stream objects. Calls to this operator are *chained*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个对象将被传递给一个函数，函数的语义是应该返回该对象。一个例子是与流对象一起使用的`<<`运算符。对此运算符的调用是*链接*的：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This is actually a series of calls to functions called `operator<<`, one that
    takes a `const char*` pointer, and another that takes an `int` parameter. These
    functions also have an `ostream` parameter for the stream object that will be
    used. However, if this is simply an `ostream` parameter then it would mean that
    a copy of the parameter would be made, and the insertion would be performed on
    the copy. Stream objects often use buffering, so changes to a copy of a stream
    object may not have the desired effect. Further, to enable the *chaining* of the
    insertion operators, the insertion functions will return the stream object passed
    as a parameter. The intention is to pass the same stream object through multiple
    function calls. If such a function returned an object then it would be a copy
    and not only would this means that a series of insertions would involve lots of
    copies being made, these copies would also be temporary and so any changes to
    the stream (for example, manipulators such as `std::hex`) would not persist. To
    address these issues, references are used. A typical prototype of such a function
    is:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一系列对名为`operator<<`的函数的调用，其中一个接受`const char*`指针，另一个接受`int`参数。这些函数还有一个`ostream`参数，用于指定将要使用的流对象。然而，如果这只是一个`ostream`参数，那么意味着会创建参数的副本，并且插入操作将在副本上执行。流对象通常使用缓冲，因此对流对象的副本进行更改可能不会产生预期的效果。此外，为了启用插入操作符的*链接*，插入函数将返回作为参数传递的流对象。意图是通过多个函数调用传递相同的流对象。如果这样的函数返回一个对象，那么它将是一个副本，这不仅意味着一系列插入将涉及大量的副本，这些副本也将是临时的，因此对流的任何更改（例如，`std::hex`等操作符）将不会持久存在。为了解决这些问题，使用引用。这样的函数的典型原型是：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Clearly you have to be careful about returning a reference since you have to
    ensure that the object lifetime lasts as long as the reference. This `operator<<`
    function will return the reference passed in the first parameter, but in the following
    code a reference is returned to an automatic variable:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你必须小心返回引用，因为你必须确保对象的生命周期与引用一样长。这个`operator<<`函数将返回第一个参数传递的引用，但在下面的代码中，引用将返回给一个自动变量：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, the `string` object only lives as long as the function,
    so the reference returned by this function will refer to an object that does not
    exist. Of course, you can return a reference to a `static` variable declared in
    a function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`string`对象的生存期只有函数的生存期那么长，因此这个函数返回的引用将指向一个不存在的对象。当然，你可以返回一个指向函数中声明的`static`变量的引用。
- en: Returning a reference from a function is a common idiom, but whenever you consider
    doing this make sure that the lifetime of the aliased variable is not the scope
    of the function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数返回引用是一种常见的习惯用法，但每当你考虑这样做时，一定要确保别名变量的生命周期不是函数的作用域。
- en: Temporaries and references
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时对象和引用
- en: 'The lvalue references must refer to a variable, but C++ has some odd rules
    when it comes to `const` references declared on the stack. If the reference is
    a `const`, the compiler will extend the lifetime of a temporary for the lifetime
    of the reference. For example, if you use the initialization list syntax, the
    compiler will create a temporary:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 左值引用必须引用一个变量，但是当涉及到堆栈上声明的`const`引用时，C++有一些奇怪的规则。如果引用是`const`，编译器将延长临时对象的生命周期，使其与引用的生命周期相同。例如，如果你使用初始化列表语法，编译器将创建一个临时对象：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this code, the compiler will create a temporary `int` and initialize it
    to a value and then alias it to the `cri` reference (it is important that this
    reference is `const`). The temporary is available through the reference while
    it is in scope. This may look a little odd, but consider using a `const` reference
    in this function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，编译器将创建一个临时的`int`并将其初始化为一个值，然后将其别名到`cri`引用（这个引用是`const`很重要）。只要引用在作用域内，临时对象就可以通过引用使用。这可能看起来有点奇怪，但考虑在这个函数中使用一个`const`引用：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can call this function with a `string` variable, a variable that will explicitly
    convert to a `string` or with a `string` literal:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个`string`变量、一个明确转换为`string`的变量或一个`string`字面量来调用这个函数：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In most cases, you'll not want to have a `const` reference to a built-in type,
    but with custom types where there will be an overhead in making copies there is
    an advantage and, as you can see here, the compiler will fall back to creating
    a temporary if required.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不会想要一个内置类型的`const`引用，但对于自定义类型，其中复制会有开销，这是一个优势，正如你在这里看到的，编译器将退回到创建临时对象的方式。
- en: The rvalue references
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 右值引用
- en: C++11 defines a new type of reference, rvalue references. Prior to C++11, there
    was no way that code (like an assignment operator) could tell if the rvalue passed
    to it was a temporary object or not. If such a function is passed a reference
    to an object, then the function has to be careful not to change the reference
    because this would affect the object it refers to. If the reference is to a temporary
    object, then the function can do what it likes to the temporary object because
    the object will not live after the function completes. C++11 allows you to write
    code specifically for temporary objects, so in the case of the assignment, the
    operator for temporary objects can just *move* the data from the temporary into
    the object being assigned. In contrast, if the reference is not to a temporary
    object then the data will have to be *copied*. If the data is large, then this
    prevents a potentially expensive allocation and copy. This enables so-called *move
    semantics*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: C++11定义了一种新类型的引用，即右值引用。在C++11之前，代码（比如赋值操作符）无法知道传递给它的右值是临时对象还是其他。如果这样的函数被传递一个对象的引用，那么函数必须小心不要改变引用，因为这会影响它所引用的对象。如果引用是指向临时对象的，那么函数可以对临时对象做任何喜欢的事情，因为对象在函数完成后不会存在。C++11允许你专门为临时对象编写代码，因此在赋值的情况下，临时对象的操作符可以将数据从临时对象移动到被赋值的对象中。相比之下，如果引用不是指向临时对象，那么数据将被*复制*。如果数据很大，那么这将阻止潜在的昂贵的分配和复制。这实现了所谓的*移动语义*。
- en: 'Consider this rather contrived code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个相当牵强的代码：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The three functions return a `string` object. In the first two cases, the `string`
    has the lifetime of the program and so a reference can be returned. In the last
    function, the function returns a string literal, so a temporary `string` object
    is constructed. All three can be used to provide a `string` value. For example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数返回一个`string`对象。在前两种情况下，`string`的生命周期为整个程序，因此可以返回一个引用。在最后一个函数中，函数返回一个字符串字面值，因此会构造一个临时的`string`对象。这三个函数都可以用来提供一个`string`值。例如：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: All three can provide a string that can be used to assign a `string` object.
    The important point is that the first two functions return along a lived object,
    but the third function returns a temporary object, but these objects can be used
    the same.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个函数都可以提供一个可以用来赋值给`string`对象的字符串。重要的是，前两个函数返回一个已经存在的对象，而第三个函数返回一个临时对象，但这些对象可以被同样使用。
- en: 'If these functions returned access to a large object, you would not want to
    pass the object to another function, so instead, in most cases, you''ll want to
    pass the objects returned by these functions as references. For example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些函数返回对一个大对象的访问，你可能不希望将对象传递给另一个函数，因此，在大多数情况下，你会希望将这些函数返回的对象作为引用传递。例如：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The reference parameter prevents another copy of the string. However, this
    is just half of the story. The `use_string` function could manipulate the string.
    For example, the following function creates a new `string` from the parameter,
    but replaces the letters a, b, and o with an underscore (indicating the gaps in
    words without those letters, replicating what life would be like without donations
    of the blood types A, B, and O). A simple implementation would look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 引用参数可以避免对字符串进行另一个复制。然而，这只是故事的一半。`use_string`函数可以操作字符串。例如，下面的函数从参数创建一个新的`string`，但用下划线替换了字母a、b和o（表示没有这些字母的单词中的空格，模拟没有A、B和O血型捐赠的生活）。一个简单的实现看起来像这样：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The string object has an index operator (`[]`), so you can treat it like an
    array of characters, both reading the values of characters and assigning values
    to character positions. The size of the `string` is obtained through the `length`
    function, which returns an `unsigned int` (`typedef` to `size_t`). Since the parameter
    is a reference, it means that any change to the `string` will be reflected in
    the `string` passed to the function. The intention of this code is to leave other
    variables intact, so it first makes a copy of the parameter. Then on the copy,
    the code iterates through all of the characters changing the `a`, `b`, and `o`
    characters to an underscore before printing out the result.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`对象有一个索引运算符（`[]`），因此可以将其视为一个字符数组，既可以读取字符的值，也可以为字符位置分配值。`string`的大小通过`length`函数获得，该函数返回一个`unsigned
    int`（`typedef`为`size_t`）。由于参数是一个引用，这意味着对`string`的任何更改都将反映在传递给函数的`string`中。这段代码的意图是保持其他变量不变，因此首先对参数进行复制。然后在副本上，代码遍历所有字符，将`a`、`b`和`o`字符更改为下划线，然后打印出结果。'
- en: This code clearly has a copy overhead--creating the `string`, `s`, from the
    reference, `rs`; but this is necessary if we want to pass strings like those from
    `get_global` or `get_static` to this function because otherwise the changes would
    be made to the actual global and `static` variables.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然有一个复制开销--从引用`rs`创建`string` `s`；但如果我们想要将`get_global`或`get_static`返回的字符串传递给这个函数，这是必要的，否则更改将会影响实际的全局和`static`变量。
- en: 'However, the temporary `string` returned from `get_temp` is another situation.
    This temporary object only exists until the end of the statement that calls `get_temp`.
    Thus, it is possible to make changes to the variable knowing that it will affect
    nothing else. This means that you can use move semantics:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从`get_temp`返回的临时`string`是另一种情况。这个临时对象只存在到调用`get_temp`的语句结束。因此，可以对变量进行更改，知道这不会影响其他东西。这意味着可以使用移动语义：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'There are just two changes here. The first is that the parameter is identified
    as an rvalue reference using the `&&` suffix to the type. The other change is
    that the changes are made on the object that the reference refers to because we
    know that it is a temporary and the changes will be discarded, so it will affect
    no other variables. Note that there are now *two* functions, overloads with the
    same name: one with an lvalue reference, and one with an rvalue reference. When
    you call this function, the compiler will call the right one according to the
    parameter passed to it:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有两个变化。第一个是参数被标识为一个右值引用，使用`&&`后缀来表示类型。另一个变化是对引用所指向的对象进行更改，因为我们知道它是一个临时对象，这些更改将被丢弃，因此不会影响其他变量。请注意，现在有*两个*函数，重载了相同的名称：一个带有左值引用，一个带有右值引用。当调用这个函数时，编译器将根据传递给它的参数调用正确的函数：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Recall that `get_global` and `get_static` return references to objects that
    will live the lifetime of the program, and for this reason the compiler chooses
    the `use_string` version that takes an lvalue reference. The changes are made
    on a temporary variable within the function, and this has a copy overhead. The
    `get_temp` returns a temporary object and so the compiler calls the overload of
    `use_string` that takes an rvalue reference. This function alters the object that
    the reference refers to, but this does not matter because the object will not
    last beyond the semicolon at the end of the line. The same can be said for calling
    `use_string` with a C-like string literal: the compiler will create a temporary
    `string` object and call the overload that has an rvalue reference parameter.
    In the final example in this code, a C++ `string` object is created on the stack
    and passed to `use_string`. The compiler sees that this object is an lvalue and
    potentially can be altered, so it calls the overload that takes an lvalue reference
    that is implemented in a way that only alters a temporary local variable in the
    function.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`get_global`和`get_static`返回将在程序的生命周期内存在的对象的引用，因此编译器选择了接受左值引用的`use_string`版本。更改是在函数内的临时变量上进行的，这会产生复制开销。`get_temp`返回一个临时对象，因此编译器调用接受右值引用的`use_string`的重载。这个函数改变了引用所指的对象，但这并不重要，因为该对象不会持续到行末的分号之后。对于使用类似C的字符串文字调用`use_string`也是一样的：编译器会创建一个临时的`string`对象，并调用带有右值引用参数的重载。在这段代码的最后一个例子中，一个C++
    `string`对象在堆栈上创建，并传递给`use_string`。编译器看到这个对象是一个左值，并且可能会被改变，因此调用了接受左值引用的重载，这种重载的实现方式只会改变函数中的临时局部变量。
- en: This example shows that the C++ compiler will detect when a parameter is a temporary
    object and will call the overload with an rvalue reference. Typically, this facility
    is used when writing *copy constructors* (special functions used to create a new
    custom type from an existing instance) and assignment operators so that these
    functions can implement the lvalue reference overload to copy the data from the
    parameter, and the rvalue reference overload to move the data from the temporary
    to the new object. Other uses are for writing custom types that are *move only*,
    where they use resources that cannot be copied, for example file handles.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，C++编译器会检测参数是否是临时对象，并调用带有右值引用的重载。通常，这种功能用于编写*复制构造函数*（用于从现有实例创建新自定义类型的特殊函数）和赋值运算符，以便这些函数可以实现左值引用重载以从参数复制数据，并实现右值引用重载以将数据从临时对象移动到新对象。其他用途是编写*仅移动*的自定义类型，它们使用无法复制的资源，例如文件句柄。
- en: Ranged for and references
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围`for`和引用
- en: 'As an example of what you can do with references, it is worth looking at the
    ranged `for` facility in C++11\. The following code is quite straightforward;
    the array `squares` is initialized with the squares of 0 to 4:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 作为引用的一个例子，值得看看C++11中的范围`for`功能。下面的代码非常简单；数组`squares`用0到4的平方初始化：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The compiler knows the size of the array so you can use ranged `for` to print
    out the values in the array. In the following, on each iteration, the local variable
    `j` is a copy of the item in the array. As a copy, it means that you can read
    the value, but any changes made to the variable will not be reflected to the array.
    So, the following code works as expected; it prints out the contents of the array:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器知道数组的大小，因此可以使用范围`for`来打印数组中的值。在下面的例子中，每次迭代，局部变量`j`都是数组中项目的副本。作为副本，这意味着你可以读取该值，但对变量所做的任何更改都不会反映到数组中。因此，下面的代码按预期工作；它打印出数组的内容。
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If you want to change the values in the array, then you have to have access
    to the actual values, and not a copy. The way to do this in a ranged `for` is
    to use a reference as the loop variable:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要更改数组中的值，那么必须访问实际的值，而不是副本。在范围`for`中实现这一点的方法是使用引用作为循环变量：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, on every iteration, the `k` variable is an alias to an actual member in
    the array, so whatever you do to the `k` variable is actually performed on the
    array member. In this example, every member of the `squares` array is multiplied
    by 2\. You cannot use `int*` for the type of `k` because the compiler sees that
    the type of the items in the array is `int` and will use this as the loop variable
    in the ranged `for`. Since a reference is an alias for a variable, the compiler
    will allow a reference as the loop variable, and moreover, since the reference
    is an alias, you can use it to change the actual array member.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在每次迭代中，`k`变量都是数组中实际成员的别名，因此对`k`变量所做的任何操作实际上都是在数组成员上执行的。在这个例子中，`squares`数组的每个成员都乘以2。你不能使用`int*`作为`k`的类型，因为编译器会看到数组中的项目类型是`int`，并将其作为范围`for`中的循环变量。由于引用是变量的别名，编译器将允许引用作为循环变量，并且由于引用是别名，你可以使用它来更改实际的数组成员。
- en: 'Ranged `for` becomes interesting for multidimensional arrays. For example,
    in the following, a two-dimensional array is declared and an attempt is made to
    use nested loops using `auto` variables:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多维数组，范围`for`变得很有趣。例如，在下面的例子中，声明了一个二维数组，并尝试使用`auto`变量来使用嵌套循环：
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Since a two-dimensional array is an array of arrays (each row is a one-dimensional
    array), the intention is to obtain each row in the outer loop and then in the
    inner loop access each item in the row. There are several issues with this approach,
    but the immediate issue is that this code will not compile.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二维数组是数组的数组（每一行都是一个一维数组），意图是在外部循环中获取每一行，然后在内部循环中访问每一行中的每个项目。这种方法存在一些问题，但是最直接的问题是这段代码无法编译。
- en: The compiler will complain about the inner loop, saying that it cannot find
    a `begin` or `end` function for the type `int*`. The reason is that ranged `for`
    uses iterator objects and for arrays it uses the C++ Standard Library functions,
    `begin` and `end,` to create these objects. The compiler will see from the `arr`
    array in the outer ranged for that each item is an `int[3]` array, and so in the
    outer `for` loop the loop variable will be a *copy* of each element, in this case
    an `int[3]` array. You cannot copy arrays like this, so the compiler will provide
    a pointer to the first element, an `int*`, and this is used in the inner `for`
    loop.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将抱怨内部循环，说它找不到类型`int*`的`begin`或`end`函数。原因是范围`for`使用迭代器对象，对于数组，它使用C++标准库函数`begin`和`end`来创建这些对象。编译器将从外部范围`for`中的`arr`数组中看到每个项目都是一个`int[3]`数组，因此在外部`for`循环中，循环变量将是每个元素的*副本*，在这种情况下是一个`int[3]`数组。你不能像这样复制数组，所以编译器将提供指向第一个元素的指针，一个`int*`，并且这在内部`for`循环中使用。
- en: The compiler will attempt to obtain iterators for `int*`, but this is not possible
    because an `int*` contains no information about how many items it points to. There
    is a version of `begin` and `end` defined for `int[3]` (and all sizes of arrays)
    but not for `int*`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将尝试为`int*`获取迭代器，但这是不可能的，因为`int*`不包含有关它指向多少项的信息。对于`int[3]`（以及所有大小的数组）定义了`begin`和`end`的版本，但对于`int*`没有定义。
- en: 'A simple change makes this code compile. Simply turn the `row` variable into
    a reference:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的更改使得这段代码可以编译。只需将`row`变量转换为引用即可：
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The reference parameter indicates that an alias is used for the `int[3]` array
    and, of course, an alias is the same as the element. Using `auto` hides the ugliness
    of what is actually going on. The inner loop variable is, of course, an `int`
    since this is the type of the item in the array. The outer loop variable is in
    fact `int (&)[3]`. That is, it is a reference to an `int[3]` (the parentheses
    used to indicate that it references an `int[3]` and is not an array of `int&`).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 引用参数表示`int[3]`数组使用别名，当然，别名与元素相同。使用`auto`隐藏了实际发生的丑陋。内部循环变量当然是`int`，因为这是数组中项目的类型。外部循环变量实际上是`int
    (&)[3]`。也就是说，它是一个`int[3]`的引用（括号用于指示它引用一个`int[3]`，而不是一个`int&`数组）。
- en: Using pointers in practice
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用指针
- en: A common requirement is to have a collection that can be an arbitrary size and
    can grow and shrink at runtime. The C++ Standard Library provides various classes
    to allow you to do this, as will be described in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*. The following example illustrates some
    of the principles of how these standard collections are implemented. In general,
    you should use the C++ Standard Library classes rather than implementing your
    own. Further, the Standard Library classes *encapsulate* code together in a class
    and since we have not covered classes yet, the following code will use functions
    that potentially can be called incorrectly. So, you should regard this example
    as just that, example code. A linked list is a common data structure. These are
    typically used for queues where the order of items is important. For example,
    a first-in-first-out queue where tasks are performed in the order that they are
    inserted in the queue. In this example, each task is represented as a structure
    that contains the task description and a pointer to the next task to be performed.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的要求是拥有一个可以在运行时是任意大小并且可以增长和缩小的集合。C++标准库提供了各种类来允许你做到这一点，将在[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)中描述，*使用标准库容器*。以下示例说明了这些标准集合是如何实现的一些原则。一般来说，你应该使用C++标准库类而不是实现你自己的。此外，标准库类将代码*封装*在一个类中，因为我们还没有涵盖类，所以下面的代码将使用潜在可能被错误调用的函数。因此，你应该把这个例子只是一个例子代码。链表是一种常见的数据结构。这些通常用于队列，其中项目的顺序很重要。例如，先进先出队列，其中任务按照它们插入队列的顺序执行。在这个例子中，每个任务都表示为一个包含任务描述和指向要执行的下一个任务的指针的结构。
- en: 'If the pointer to the next task is `nullptr` then this means the current task
    is the last task in the list:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个任务的指针是`nullptr`，那么这意味着当前任务是列表中的最后一个任务：
- en: '[PRE88]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Recall from the last chapter that you access members of a structure using the
    dot operator through an instance:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一章，你可以通过实例使用点运算符访问结构的成员：
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In this case, the compiler will create a `string` object initialized with the
    string literal `do something` and assign it to the `description` member of the
    instance called `item`. You can also create a `task` on the free store using the
    `new` operator:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器将创建一个用字符串字面量`do something`初始化的`string`对象，并将其分配给名为`item`的实例的`description`成员。你也可以使用`new`运算符在自由存储区创建一个`task`：
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In this case, the members of the object have to be accessed through a pointer,
    and C++ provides the `->` operator to give you this access:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，必须通过指针访问对象的成员，C++提供了`->`运算符来给你这种访问：
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Here the `description` member is assigned to the string. Note that since `task`
    is a structure there are no access restrictions, something that is important with
    classes and described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`description`成员被赋予了字符串。请注意，由于`task`是一个结构，没有访问限制，这在类中是很重要的，并在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中描述，*类*。
- en: Creating the project
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_04`. Start Visual
    C++ and create a C++ source file and save it to the folder you just created, as
    `tasks.cpp`. Add a simple `main` function without parameters, and provide support
    for input and output using C++ streams:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在`C:\Beginning_C++`下创建一个名为`Chapter_04`的新文件夹。启动Visual C++，创建一个C++源文件并将其保存到刚创建的文件夹中，命名为`tasks.cpp`。添加一个简单的没有参数的`main`函数，并使用C++流提供输入和输出支持：
- en: '[PRE92]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Above the `main` function, add a definition for the structure that represents
    a task in the list:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数上面，添加一个代表列表中任务的结构的定义：
- en: '[PRE93]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This has two members. The guts of the object is the `description` item. In our
    example, executing a task will involve printing the `description` item to the
    console. In an actual project, you'll most likely have many data items associated
    with the task, and you may even have member functions to execute the task, but
    we have not yet covered member functions; that's a topic for [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个成员。对象的核心是`description`项。在我们的例子中，执行任务将涉及将`description`项打印到控制台。在实际项目中，您很可能会有许多与任务相关的数据项，甚至可能有成员函数来执行任务，但我们还没有涵盖成员函数；这是[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*的主题。
- en: The plumbing of the linked list is the other member, `pNext`. Note that the
    `task` structure has not been completely defined at the point that the `pNext`
    member is declared. This is not a problem because `pNext` is a *pointer*. You
    cannot have a data member of an undefined, or a partially defined type, because
    the compiler will not know how much memory to allocate for it. You can have a
    pointer member to a partially defined type because a pointer member is the same
    size irrespective of what it points to.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的连接是另一个成员，`pNext`。请注意，在声明`pNext`成员时，`task`结构尚未完全定义。这不是问题，因为`pNext`是一个*指针*。您不能有一个未定义或部分定义类型的数据成员，因为编译器不知道为其分配多少内存。您可以有一个指向部分定义类型的指针成员，因为指针成员的大小不受其指向的内容的影响。
- en: 'If we know the first link in a list, then we can access the whole list and,
    in our example, this will be a global variable. When constructing the list, the
    construction functions need to know the end of the list so that they can attach
    a new link to the list. Again, for convenience, we will make this a global variable.
    Add the following pointers after the definition of the `task` structure:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道列表中的第一个链接，那么我们可以访问整个列表，在我们的例子中，这将是一个全局变量。在构造列表时，构造函数需要知道列表的末尾，以便它们可以将新的链接附加到列表上。同样，为了方便起见，我们将使其成为一个全局变量。在`task`结构的定义之后添加以下指针：
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As it stands, the code does nothing, but it is a good opportunity to compile
    the file to test that there are no typos:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，代码什么也没做，但这是一个很好的机会来编译文件，以测试是否有拼写错误：
- en: '[PRE95]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Adding a task object to the list
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向列表中添加任务对象
- en: The next thing to do to provide the code is to add a new task to the task list.
    This needs to create a new `task` object and initialize it appropriately and then
    add it to the list by altering the last link in the list to point to the new link.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供代码，下一步是向任务列表添加一个新任务。这需要创建一个新的`task`对象并适当地初始化它，然后通过改变列表中的最后一个链接来将其添加到列表中，使其指向新的链接。
- en: 'Above the `main` function, add the following function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数之前，添加以下函数：
- en: '[PRE96]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The parameter is a `const` reference because we will not change the parameter
    and we do not want the overhead of a copy being made. The first thing this function
    must do is create a new link, so add the following lines:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是`const`引用，因为我们不会改变参数，也不希望产生额外的复制开销。这个函数必须做的第一件事是创建一个新的链接，所以添加以下行：
- en: '[PRE97]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The first line creates a new link on the free store, and the following lines
    initialize it. This is not necessarily the best way of initializing such an object,
    and a better mechanism, a constructor, will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Notice that the `pNext` item is initialized to `nullptr`; this indicates
    that the link will be at the end of the list.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行在自由存储器上创建一个新的链接，接下来的行初始化它。这不一定是初始化这样一个对象的最佳方式，更好的机制，构造函数，将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*中介绍。请注意，`pNext`项被初始化为`nullptr`；这表示该链接将位于列表的末尾。
- en: 'The final part of this function adds the link to the list, that is, it makes
    the link the last in the list. However, if the list is empty, it means that this
    link is also the *first* link in the list. The code must perform both actions.
    Add the following code to the end of the function:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的最后部分将链接添加到列表中，即使链接成为列表中的最后一个。但是，如果列表为空，这意味着该链接也是列表中的*第一个*链接。代码必须执行这两个操作。在函数的末尾添加以下代码：
- en: '[PRE98]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The first line checks to see if the list is empty. If `pHead` is `nullptr`,
    it means that there are no other links and so the current link is the first link,
    and so both `pHead` and `pCurrent` are initialized to the new link pointer. If
    there are existing links in the list, the link has to be added to the last link,
    so in the `else` clause the first line makes the last link point to the new link
    and the second line initializes `pCurrent` with the new link pointer, making the
    new link the last link for any new insertions to the list.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检查列表是否为空。如果`pHead`是`nullptr`，这意味着没有其他链接，因此当前链接是第一个链接，因此`pHead`和`pCurrent`都初始化为新链接指针。如果列表中存在现有链接，则必须将链接添加到最后一个链接，因此在`else`子句中，第一行使最后一个链接指向新链接，第二行使用新链接指针初始化`pCurrent`，使新链接成为列表中任何新插入的最后一个链接。
- en: 'The items are added to the list by calling this function in the `main` function.
    In this example, we will queue the tasks to wallpaper a room. This involves removing
    the old wallpaper, filling any holes in the wall, sizing the wall (painting it
    with diluted paste to make the wall sticky), and then hanging the pasted wallpaper
    to the wall. You have to do these tasks in this order, you cannot change the order,
    so these tasks are ideal for a linked list. In the `main` function add the following
    lines:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`main`函数中调用此函数将项目添加到列表中。在这个例子中，我们将排队进行粘贴壁纸的任务。这涉及到去除旧壁纸，填补墙壁上的任何孔洞，调整墙壁大小（用稀释的糊状物涂抹墙壁，使墙壁变得粘性），然后将粘贴的壁纸贴到墙上。您必须按照这个顺序完成这些任务，不能改变顺序，因此这些任务非常适合使用链表。在`main`函数中添加以下行：
- en: '[PRE99]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: After the last line, the list has been created. The `pHead` variable points
    to the first item in the list and you can access any other item in the list simply
    by following the `pNext` member from one link to the next.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行之后，列表已创建。`pHead`变量指向列表中的第一项，您可以通过简单地从一个链接到下一个链接来访问列表中的任何其他项。
- en: You can compile the code, but there is no output. Worse, as the code stands,
    there is a memory leak. The program has no code to `delete` the memory occupied
    by the `task` objects created on the free store by the `new` operator.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编译代码，但没有输出。更糟糕的是，代码的当前状态存在内存泄漏。程序没有代码来`delete`由`new`运算符在自由存储器上创建的`task`对象所占用的内存。
- en: Deleting the task list
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除任务列表
- en: 'Iterating through the list is simple, you follow the `pNext` pointer from one
    link to the next. Before doing this, let''s first fix the memory leak introduced
    in the last section. Above the `main` function, add the following function:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表很简单，只需按照`pNext`指针从一个链接到下一个链接。在执行此操作之前，让我们先修复上一节中引入的内存泄漏。在`main`函数上面，添加以下函数：
- en: '[PRE100]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function will remove the link at the beginning of the list and make sure
    that the `pHead` pointer points to the next link, which will become the new beginning
    of the list. The function returns a `bool` value indicating if there are any more
    links in the list. If this function returns `false` then it means the entire list
    has been deleted.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将删除列表开头的链接，并确保`pHead`指针指向下一个链接，这将成为列表的新开头。该函数返回一个`bool`值，指示列表中是否还有其他链接。如果此函数返回`false`，则表示整个列表已被删除。
- en: 'The first line checks to see if this function has been called with an empty
    list. Once we are reassured that the list has at least one link, we create a temporary
    copy of this pointer. The reason is that the intention is to delete the first
    item and make `pHead` point to the next item, and to do that we have to do those
    steps in reverse: make `pHead` point to the next item and then delete the item
    that `pHead` previously pointed to.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行检查此函数是否已使用空列表调用。一旦我们确信列表至少有一个链接，我们就会创建此指针的临时副本。原因是打算删除第一项并使`pHead`指向下一项，为此我们必须反向执行这些步骤：使`pHead`指向下一项，然后删除`pHead`先前指向的项。
- en: 'To delete the entire list, you need to iterate through the links, and this
    can be carried out using a `while` loop. Below the `remove_head` function, add
    the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除整个列表，需要通过链接进行迭代，可以使用`while`循环进行。在`remove_head`函数下面，添加以下内容：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: To delete the entire list, and address the memory leak, add the following line
    to the bottom of the main function
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除整个列表，并解决内存泄漏问题，将以下行添加到主函数的底部
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: You can now compile the code, and run it. However, you'll see no output because
    all the code does is create a list and then delete it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编译代码并运行它。但是，您将看不到任何输出，因为所有代码只是创建一个列表，然后删除它。
- en: Iterating the task list
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历任务列表
- en: 'The next step is to iterate the list from the first link following each `pNext`
    pointer until we get to the end of the list. For each link accessed, the task
    should be executed. Start by writing a function that performs the execution by
    printing out the description of the task and then returning a pointer to the next
    task. Just above the `main` function, add the following code:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从第一个链接开始迭代列表，直到通过每个`pNext`指针到达列表的末尾。对于访问的每个链接，应执行任务。首先编写一个执行任务的函数，该函数通过打印任务的描述然后返回指向下一个任务的指针来执行任务。在`main`函数上面，添加以下代码：
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The parameter here is marked as `const` because we will not change the `task`
    object pointed to by the pointer. This indicates to the compiler that if the code
    does try to change the object there is an issue. The first line checks to make
    sure that the function is not called with a null pointer. If it was then the following
    line would dereference an invalid pointer and cause a memory access fault. The
    last line returns the pointer to the next link (which could be `nullptr` for the
    last link in the list), so that the function can be called in a loop. After this
    function, add the following to iterate the entire list:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数标记为`const`，因为我们不会改变指向的`task`对象。这告诉编译器，如果代码尝试更改对象，则会出现问题。第一行检查确保函数不是用空指针调用的。如果是，那么接下来的行将取消引用无效的指针并导致内存访问故障。最后一行返回指向下一个链接的指针（对于列表中的最后一个链接可能是`nullptr`），以便可以在循环中调用该函数。在此函数之后，添加以下内容以迭代整个列表：
- en: '[PRE104]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This code starts at the beginning, `pHead`, and calls `execute_task` on each
    link in the list until the function returns a `nullptr`. Add a call to this function
    towards the end of the `main` function:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从开头`pHead`开始，并在列表中的每个链接上调用`execute_task`，直到函数返回`nullptr`。在`main`函数的末尾添加对此函数的调用：
- en: '[PRE105]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can now compile and run the code. The result will be:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编译并运行代码。结果将是：
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Inserting items
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入项目
- en: One of the advantages of linked lists is that you can insert items into the
    list by only allocating one new item and changing the appropriate pointers to
    point to it, and make it point to the next item in the list. Contrast this to
    allocating an array of `task` objects; if you want to insert a new item somewhere
    in the middle, you would have to allocate a new array big enough for the old items
    and the new one and then copy the old items to the new array, copying in the new
    item in the right position.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 链表的一个优点是，您可以通过仅分配一个新项目并更改适当的指针来将项目插入列表，并使其指向列表中的下一个项目。与分配`task`对象的数组相比，这与在中间插入新项目要简单得多；如果要在中间插入新项目，您必须为旧项目和新项目分配足够大的新数组，然后将旧项目复制到新数组中，在正确的位置复制新项目。
- en: The problem with the wallpaper task list is that the room has some painted wood
    and, as any decorator knows, it is best to paint the woodwork before hanging the
    wallpaper, and usually before sizing the walls. We need to insert a new task between
    filling any holes and sizing the walls. Further, before you do any decorating,
    you should cover any furniture in the room before doing anything else, so you
    need to add a new task to the beginning.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 壁纸任务列表的问题在于房间有一些涂过油漆的木制品，正如任何装饰者所知，最好在贴壁纸之前先涂油漆，通常是在涂墙之前。我们需要在填补任何孔之后和调整墙壁之前插入一个新任务。此外，在进行任何装饰之前，您应该先覆盖房间中的任何家具，因此需要在开头添加一个新任务。
- en: 'The first step is to find the position where we want to put our new task to
    paint the woodwork. We will look for the task that we want to be before the task
    we are inserting. Before `main` add the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找到我们想要放置新任务的位置来粉刷木制品。我们将寻找我们要插入的任务之前的任务。在`main`之前添加以下内容：
- en: '[PRE107]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This code searches the entire list for a link with the `description` that matches
    the parameter. This is carried out through a loop which uses the `string` comparison
    operator, and if the required link is found, a pointer to that link is returned.
    If the comparison fails, the loop initializes the loop variable to the address
    of the next link and if this address is `nullptr` it means that the required task
    is not in the list.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码搜索整个列表，查找与参数匹配的`description`链接。这是通过循环执行的，循环使用`string`比较运算符，如果找到所需的链接，则返回指向该链接的指针。如果比较失败，循环将循环变量初始化为下一个链接的地址，如果此地址为`nullptr`，则意味着列表中没有所需的任务。
- en: 'After the list is created in the main function, add the following code to search
    for the `fill holes` task:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中创建列表后，添加以下代码来搜索`fill holes`任务：
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If the `find_task` function returns a valid pointer, then we can add an item
    at this point.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`find_task`函数返回有效指针，那么我们可以在此处添加一个项目。
- en: 'The function to do this will allow you to add a new item after any item in
    the list that you pass to it and, if you pass `nullptr`, it will add the new item
    to the beginning. It''s called `insert_after`, but clearly, if you pass `nullptr`
    it also means *insert before the beginning*. Add the following just above the
    `main` function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许您在传递给它的列表中的任何项目后添加新项目，如果传递`nullptr`，它将在开头添加新项目。它被称为`insert_after`，但显然，如果你传递`nullptr`，它也意味着*在开头之前插入*。在`main`函数上面添加以下内容：
- en: '[PRE109]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The second parameter is a `const` reference because we will not change the `string`,
    but the first parameter is not a `const` pointer because we will be changing the
    object that it points to. This function creates a new `task` object and initializes
    the `description` member to the new task name. It then checks to see if the `task`
    pointer passed to the function is null. If it is not, then the new item can be
    inserted *after* the specified link in the list. To do this, the new link `pNext`
    member is initialized to be the next item in the list, and the `pNext` member
    of the previous link is initialized to the address of the new link.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是`const`引用，因为我们不会改变`string`，但第一个参数不是`const`指针，因为我们将改变它指向的对象。此函数创建一个新的`task`对象，并将`description`成员初始化为新的任务名称。然后检查传递给函数的`task`指针是否为空。如果不是，则可以在列表中指定链接之后插入新项目。为此，新链接`pNext`成员被初始化为列表中的下一个项目，并且前一个链接的`pNext`成员被初始化为新链接的地址。
- en: What about inserting an item at the beginning, when the function is passed `nullptr`
    as the item to insert after? Add the following `else` clause.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数传递`nullptr`作为要插入的项目时，如何在开头插入一个项目？添加以下`else`子句。
- en: '[PRE110]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Here, we make the `pNext` member of the new item to point to the old beginning
    of the list and then change `pHead` to point to the new item.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使新项目的`pNext`成员指向旧列表的开头，然后将`pHead`更改为指向新项目。
- en: 'Now, in the `main` function, you can add a call to insert a new task to paint
    the woodwork, and since we also forgot to indicate that it is best to decorate
    a room after covering all furniture with dustsheets, add a task to do that first
    in the list:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中，您可以添加一个调用来插入一个新任务来粉刷木制品，因为我们还忘记指出最好在用防尘布覆盖所有家具后装饰房间，所以在列表中首先添加一个任务来做到这一点：
- en: '[PRE111]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'You can now compile the code. When you run the code, you should see the tasks
    performed in the required order:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以编译代码了。运行代码时，您应该按照所需的顺序执行任务：
- en: '[PRE112]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'It can be argued that one of the main reasons to use C++ is that you have direct
    access to memory using pointers. This is a feature that programmers of most other
    languages are prevented from doing. This means that as a C++ programmer, you are
    a special type of programmer: someone who is trusted with memory. In this chapter,
    you have seen how to obtain and use pointers and some examples of how inappropriate
    use of pointers can make your code go horribly wrong.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说使用C++的主要原因之一是你可以使用指针直接访问内存。这是大多数其他语言的程序员无法做到的特性。这意味着作为C++程序员，你是一种特殊类型的程序员：一个被信任处理内存的人。在本章中，你已经看到如何获取和使用指针，以及指针的不当使用如何使你的代码出现严重错误的一些示例。
- en: 'In the next chapter, we will cover functions which will include the description
    of another type of pointer: function pointers. If you are trusted with pointers
    to data and function pointers, you really are a special type of programmer.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍包括另一种指针类型的描述：函数指针。如果你被信任使用数据指针和函数指针，那么你真的是一种特殊类型的程序员。
