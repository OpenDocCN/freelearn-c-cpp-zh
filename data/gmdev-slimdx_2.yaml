- en: Chapter 2. Responding to Player Inputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 响应玩家输入
- en: 'Games by their very nature are interactive. They can respond to user input,
    unlike movies which play out exactly the same every time. So, you need a way to
    detect and respond to the user''s input via mouse, keyboard, or gamepad. How can
    we accomplish this in our game? There are two options we can use for this: **DirectInput**
    and **XInput**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的本质是交互式的。它们可以响应用户输入，而电影每次播放都是完全相同的。因此，你需要一种方法来检测和响应用户通过鼠标、键盘或游戏手柄的输入。我们如何在游戏中实现这一点？我们可以使用两种选项来完成这项任务：**DirectInput**和**XInput**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: DirectInput versus XInput
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectInput与XInput的比较
- en: Mouse and keyboard input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标和键盘输入
- en: Using joysticks with DirectInput
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DirectInput控制摇杆
- en: Using joysticks with XInput
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XInput控制摇杆
- en: DirectInput versus XInput
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DirectInput与XInput的比较
- en: So, which of these two options should we use? The answer is possibly both. Why
    both, you ask? The reason is that we need to use DirectInput to support older
    input devices that don't support the new features of XInput. An **input device**
    is any device that the user uses to provide input to the game, such as a mouse,
    keyboard, gamepad, and steering wheel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该选择这两个选项中的哪一个呢？答案是可能两者都要用。你可能会问，为什么两者都要用？原因是我们需要使用DirectInput来支持不支持XInput新特性的旧输入设备。**输入设备**是指用户用来向游戏提供输入的任何设备，例如鼠标、键盘、游戏手柄和方向盘。
- en: We could just use DirectInput, but this approach has some limitations. DirectInput
    can handle XInput devices, but the left and right trigger buttons on a gamepad
    will be treated as a single button. One trigger is treated as the positive direction
    and the other as the negative direction. So, the two triggers are treated together
    as a single axis. DirectInput also does not support XInput vibration effects,
    and you cannot query for headset devices. On the flip side, we could just use
    XInput but then people with older DirectInput devices would not be able to play
    our game with them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用DirectInput，但这种方法有一些局限性。DirectInput可以处理XInput设备，但游戏手柄上的左右扳机按钮将被视为单个按钮。一个扳机被视为正方向，另一个被视为负方向。因此，这两个扳机被一起视为一个单轴。DirectInput也不支持XInput振动效果，并且无法查询耳机设备。另一方面，我们也可以只使用XInput，但这样，拥有较老DirectInput设备的玩家将无法使用它们来玩游戏。
- en: To support these features of newer input devices, we will need to use XInput
    along with DirectInput. This allows people with XInput devices to take advantage
    of their new features, while at the same time allowing users with older DirectInput
    devices to still be able to play our game with them. The players will undoubtedly
    appreciate this. So, what is the true difference between DirectInput and XInput?
    XInput is geared specifically towards Xbox 360 controllers and specialized Xbox
    360 controllers, such as guitars. XInput supports a maximum of four controllers,
    each with no more than four axes, 10 buttons, two triggers, and an eight-directional
    digital pad.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些新输入设备的特性，我们需要使用XInput和DirectInput。这允许拥有XInput设备的玩家利用它们的新特性，同时允许使用较老DirectInput设备的用户仍然能够使用它们来玩游戏。玩家无疑会为此感到高兴。那么，DirectInput和XInput之间真正的区别是什么？XInput专门针对Xbox
    360控制器和专门的Xbox 360控制器，如吉他。XInput最多支持四个控制器，每个控制器最多有四个轴，10个按钮，两个扳机和一个八方向数字垫。
- en: XInput only really supports *next generation* controllers, and it does not support
    keyboards or mouse-type devices. DirectInput on the other hand is for all controllers
    and supports controllers with up to eight axes and 128 buttons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: XInput仅真正支持**下一代**控制器，并且不支持键盘或鼠标类型设备。另一方面，DirectInput适用于所有控制器，并支持最多八个轴和128个按钮的控制器。
- en: So, the true answer to the question of whether to use DirectInput, XInput, or
    both, truly depends on the game you are developing. Just be aware that Microsoft
    essentially forces us to use XInput if we want to support some features of Xbox
    360 and similar controllers in a PC game, as discussed earlier.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于是否使用DirectInput、XInput或两者都使用的真正答案，实际上取决于你正在开发的游戏。只需注意，正如之前讨论的那样，如果我们要在PC游戏中支持Xbox
    360及其类似控制器的某些功能，微软实际上强迫我们使用XInput。
- en: Mouse and keyboard input
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标和键盘输入
- en: Even though players can play games using gamepads and other types of controllers,
    mouse and keyboard input are still quite important in PC game development. Some
    games have too many commands to map all of them on a gamepad, for example. When
    we assign an in-game action to a specific button on a keyboard, mouse, or gamepad,
    we say that we have mapped that action to that particular button. This is also
    sometimes referred to as binding, because we are, in effect, binding a certain
    key or button to a specific in-game action.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管玩家可以使用游戏手柄和其他类型的控制器玩游戏，但在PC游戏开发中，鼠标和键盘输入仍然非常重要。例如，有些游戏有太多的命令，无法将它们全部映射到游戏手柄上。当我们将游戏中的动作分配给键盘、鼠标或游戏手柄上的特定按钮时，我们说我们已经将该动作映射到该特定按钮上。这也被称为绑定，因为我们实际上是将某个键或按钮绑定到特定的游戏动作上。
- en: 'Let''s first implement our mouse and keyboard input. Start Visual Studio and
    open the solution we worked on in the previous chapter. We are going to add a
    new class that will handle user input for us. Right-click on the `SlimFramework`
    project in the **Solution Explorer** pane and add a new class named `UserInput.cs`.
    We will make this class implement the `IDisposable` interface, just like we did
    with our `GameWindow.cs` class in [Chapter 1](ch01.html "Chapter 1. Getting Started"),
    *Getting Started*. So, we need to change the class declaration from `public class
    UserInput` to `public class UserInput : IDisposable`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们先实现我们的鼠标和键盘输入。启动Visual Studio并打开上一章中我们工作的解决方案。我们将添加一个新类来处理我们的用户输入。在**解决方案资源管理器**窗格中右键单击`SlimFramework`项目，并添加一个名为`UserInput.cs`的新类。我们将使这个类实现`IDisposable`接口，就像我们在[第1章](ch01.html
    "第1章。入门")中的`GameWindow.cs`类所做的那样。因此，我们需要将类声明从`public class UserInput`更改为`public
    class UserInput : IDisposable`。'
- en: 'We also need to add two `using` statements to the top of this class file. One
    for DirectInput and one for XInput:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在类文件顶部添加两个`using`语句。一个用于DirectInput，一个用于XInput：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we are ready to set up the member variables for our new user input class.
    We''ll create a member variables section just like we did in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*. Here is the code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备为我们的新用户输入类设置成员变量。我们将创建一个成员变量部分，就像我们在[第1章](ch01.html "第1章。入门")中做的那样，*入门*。以下是代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have a handful of member variables here. The first one is `m_IsDisposed`,
    which has the same purpose as the `m_IsDisposed` member variable that we created
    in our `GameWindow` class. The second variable, `m_DirectInput`, will hold our
    DirectInput object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有几个成员变量。第一个是`m_IsDisposed`，它具有与我们创建在`GameWindow`类中的`m_IsDisposed`成员变量相同的目的。第二个变量`m_DirectInput`将存储我们的DirectInput对象。
- en: Next, we have a group of three variables. The first one, `m_Keyboard`, holds
    the keyboard object. The next two keep track of the current and previous state
    of the keyboard. So, `m_KeyboardStateCurrent` holds the keyboard state for the
    current frame while `m_KeyboardStateLast` holds the keyboard state from the previous
    frame. Why do we need both? This is necessary, for example, if you want to detect
    whether or not the user is holding down a key, rather than simply pressing it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一组三个变量。第一个，`m_Keyboard`，存储键盘对象。接下来的两个变量跟踪键盘的当前和上一个状态。因此，`m_KeyboardStateCurrent`存储当前帧的键盘状态，而`m_KeyboardStateLast`存储上一个帧的键盘状态。为什么我们需要两者？例如，如果你想检测用户是否按下了某个键，而不仅仅是简单地按下它。
- en: Next, we have a set of three very similar variables for our mouse object and
    our current and previous mouse state (`m_Mouse`, `m_MouseStateCurrent`, and `m_MouseStateLast`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一组三个非常相似的变量用于我们的鼠标对象和当前和上一个鼠标状态（`m_Mouse`、`m_MouseStateCurrent`和`m_MouseStateLast`）。
- en: The constructor
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Now, we need to create our constructor to initialize our user input object.
    Here is the code to do so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的构造函数来初始化我们的用户输入对象。以下是初始化的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line calls the `InitDirectInput()` method to initialize DirectInput
    for us. We will create this method in a second, but first we need to finish looking
    at the `UserInput()` method. The next two lines initialize our keyboard state
    variables with the empty `KeyboardState` objects. This is necessary to prevent
    a crash that would occur if the program tries to access these variables on the
    first frame (when they would be uninitialized, and therefore null, which would
    result in a **Null Reference** exception). This type of exception occurs when
    the program tries to access a variable that is null. You can't use an object before
    you initialize it, after all!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用 `InitDirectInput()` 方法为我们初始化 DirectInput。我们将在下一秒创建这个方法，但首先我们需要完成对 `UserInput()`
    方法的查看。接下来的两行使用空的 `KeyboardState` 对象初始化我们的键盘状态变量。这是必要的，以防止程序在第一帧（当它们未初始化且因此为 null
    时）尝试访问这些变量时发生崩溃。这种异常发生在程序尝试访问一个 null 变量时。毕竟，在使用对象之前，您必须先初始化它！
- en: The last two lines do exactly the same thing, but this time for our mouse state
    variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行执行完全相同的事情，但这次是为了我们的鼠标状态变量。
- en: Initializing DirectInput
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 DirectInput
- en: 'Now that our constructor is done, we need to create our `InitDirectInput()`
    method. It is a pretty short method, and here is the code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构造函数已经完成，我们需要创建我们的 `InitDirectInput()` 方法。这是一个相当简短的方法，以下是代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method only has three lines of code at the moment. The first one creates
    and initializes our DirectInput object and stores it in our `m_DirectInput` member
    variable. The second line creates and initializes our keyboard object, storing
    it in our `m_Keyboard` member variable. The third line does the same thing, but
    for our mouse object, storing it in our `m_Mouse` member variable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个方法只有三行代码。第一行创建并初始化我们的 DirectInput 对象，并将其存储在我们的 `m_DirectInput` 成员变量中。第二行创建并初始化我们的键盘对象，并将其存储在我们的
    `m_Keyboard` 成员变量中。第三行做同样的事情，但针对我们的鼠标对象，将其存储在我们的 `m_Mouse` 成员变量中。
- en: The fact that this method is short as it is, owes itself to SlimDX helping us
    out. If you were to write this same code in C++ and without SlimDX, it would be
    much longer and also a bit more cryptic. This is one of the things that makes
    SlimDX a great framework to work with. It takes care of some stuff behind the
    scenes for us, while still allowing us to leverage the full power of DirectX.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法之所以如此简短，归功于 SlimDX 的帮助。如果您用 C++ 编写相同的代码而不使用 SlimDX，它将会更长，也可能更晦涩。这是 SlimDX
    成为一个优秀框架的原因之一。它在幕后为我们处理一些事情，同时仍然允许我们利用 DirectX 的全部功能。
- en: The Update() method
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Update() 方法
- en: 'Now, we are going to add an `Update()` method to our user input class. This
    method will be called once per frame to get the latest user input data. We will
    be calling this method from the `UpdateScene()` method in our `GameWindow` class.
    Here is the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的用户输入类添加一个 `Update()` 方法。这个方法将在每一帧被调用一次，以获取最新的用户输入数据。我们将从 `GameWindow`
    类的 `UpdateScene()` 方法中调用这个方法。以下是代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first two lines of code reacquire the keyboard and mouse devices in case
    another application has taken control of them since the previous frame. We have
    to acquire the mouse and keyboard devices so that our program has access to them.
    As long as the device is acquired, DirectInput makes its data available to our
    program. Acquiring the device is not permanent however, which is why we do it
    at the beginning of the `UpdateScene()` method. This ensures that we have access
    to the keyboard and mouse devices before we try to use them in the next lines
    of code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行代码重新获取键盘和鼠标设备，以防自上一帧以来另一个应用程序已经控制了它们。我们必须获取鼠标和键盘设备，以便我们的程序可以访问它们。只要设备被获取，DirectInput
    就会将其数据提供给我们的程序。然而，获取设备并不是永久的，这就是为什么我们在 `UpdateScene()` 方法的开头做这件事。这确保了在我们尝试在下一行代码中使用键盘和鼠标设备之前，我们已经可以访问这些设备。
- en: So, why is this acquisition mechanism needed? Firstly, DirectInput needs a way
    to tell our application if the flow of data from a device has been interrupted
    by the system. This would happen, for example, if the user switches to another
    application window using *Alt* + *Tab* and uses the same input device in that
    application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么需要这种获取机制呢？首先，DirectInput 需要一种方式来告诉我们的应用程序，如果系统中断了从设备的数据流，DirectInput 需要一种方式来告诉我们的应用程序，如果系统中断了从设备的数据流。例如，如果用户使用
    *Alt* + *Tab* 切换到另一个应用程序窗口并使用该应用程序中的相同输入设备，就会发生这种情况。
- en: The second reason this acquisition mechanism is needed is because our program
    can change the properties of a device. DirectInput requires us to release the
    device before changing its properties. This is done by calling its `Unacquire()`
    method. Then you would reacquire it once you've finished changing its properties.
    This ensures that the device is not being used when we're changing its properties
    as this could cause serious problems. Note that there is one exception to this
    rule, which is that you can change the gain of a force feedback device while it
    is acquired.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要这个获取机制的原因是因为我们的程序可以改变设备的属性。DirectInput 要求我们在改变属性之前释放设备。这是通过调用它的 `Unacquire()`
    方法来完成的。然后，在你完成属性更改后，你会重新获取它。这确保了在改变属性时设备没有被使用，因为这可能会引起严重问题。请注意，这里有一个例外，那就是你可以在获取设备时改变力反馈设备的增益。
- en: Back to our code. The next two lines update our keyboard state variables. First,
    the keyboard state that was current for the previous frame is copied from the
    `m_KeyboardStateCurrent` member variable into the `m_KeyboardStateLast` member
    variable. Then, we get the current keyboard state and store it in our `m_KeyboardStateCurrent`
    member variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码。接下来的两行更新了我们的键盘状态变量。首先，将上一帧的当前键盘状态从 `m_KeyboardStateCurrent` 成员变量复制到
    `m_KeyboardStateLast` 成员变量中。然后，我们获取当前的键盘状态并将其存储在我们的 `m_KeyboardStateCurrent` 成员变量中。
- en: The last two lines do the same thing, but with our mouse state member variables.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行与之前做的是同一件事，但这次是针对我们的鼠标状态成员变量。
- en: The IDisposable interface
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IDisposable` 接口'
- en: As you'll recall from earlier in this chapter, we changed the declaration of
    the `UserInput` class to make it implement the `IDisposable` interface. We covered
    this interface in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting
    Started*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本章前面的内容中回忆起来，我们更改了 `UserInput` 类的声明，使其实现 `IDisposable` 接口。我们在 [第 1 章](ch01.html
    "第 1 章。入门") 中介绍了这个接口，*入门*。
- en: 'As you may recall, we must implement two methods. The `public void Dispose()`
    method is identical to the one we created in our `GameWindow` class. So, I will
    not show it here. On the other hand, the `protected void Dispose(bool)` method
    is different. Here is its code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，我们必须实现两个方法。`public void Dispose()` 方法与我们之前在 `GameWindow` 类中创建的方法相同。所以，这里不会展示它。另一方面，`protected
    void Dispose(bool)` 方法是不同的。以下是它的代码：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the internal structure of this method is identical to the one
    we created in the `GameWindow` class. It has the same `if` statements inside it.
    The difference is that this time, we don't have an event to unhook, and we've
    added code to dispose of our DirectInput, keyboard, and mouse objects in the managed
    resources section of this method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个方法的内部结构与我们创建在 `GameWindow` 类中的结构相同。它里面也有相同的 `if` 语句。不同的是，这次我们没有要取消绑定的事件，并且在方法的托管资源部分添加了销毁我们的
    DirectInput、键盘和鼠标对象的代码。
- en: So, why is each of these objects disposed of inside its own little `if` statement?
    The reason for this is to prevent a potential crash that would happen if one of
    these objects is for some reason null. So, we check to see if the object is null.
    If it is not, then we dispose of it. Calling dispose on an object that is null
    will cause a Null Reference exception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这些对象都在它们自己的小 `if` 语句内部被销毁呢？这样做的原因是为了防止如果这些对象中的任何一个由于某种原因而为空时可能发生的潜在崩溃。因此，我们检查对象是否为空。如果不是，那么我们就销毁它。对一个空对象调用
    dispose 将会导致空引用异常。
- en: Now, we just have a few properties to add to our user input class. They are
    all very simple, and they just provide access to our member variables. Here are
    two of these properties. Check out the downloadable code for this chapter to see
    all of them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要向我们的用户输入类添加几个属性。它们都非常简单，只是提供了对我们成员变量的访问。以下是其中两个属性。查看本章的下载代码以查看所有属性。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this class now finished, we just need to modify our `GameWindow` class
    to make use of it now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个类已经完成，我们只需要修改我们的 `GameWindow` 类，使其现在可以使用它。
- en: Updating the GameWindow class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 `GameWindow` 类
- en: 'The first thing we need to do now is add a `using` statement to the top of
    the `GameWindow.cs` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的第一件事是在 `GameWindow.cs` 文件的顶部添加一个 `using` 语句：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will allow us to use the `Key` enumeration to specify which keys we want
    to check. Next, we need to add a new member variable to our `GameWindow` class.
    This variable will be called `m_UserInput` and it will contain our new `UserInput`
    object that we just finished creating. The declaration of this member variable
    looks like the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们使用 `Key` 枚举来指定我们想要检查的键。接下来，我们需要向我们的 `GameWindow` 类添加一个新的成员变量。这个变量将被命名为
    `m_UserInput`，它将包含我们刚刚创建的新 `UserInput` 对象。这个成员变量的声明如下代码所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to modify our constructor to create and initialize our user input
    object. To accomplish this, we simply add the following line of code to the end
    of our constructor, just above the closing `}`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的构造函数以创建和初始化我们的用户输入对象。为了完成这个任务，我们只需在构造函数的末尾添加以下代码行，就在关闭的 `}` 之上：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is a good idea to add some member methods to our `UserInput` class to make
    handling user input a bit simpler for us. So, let''s create a new method named
    `IsKeyPressed()`, which looks like the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `UserInput` 类中添加一些成员方法来简化我们对用户输入的处理是个好主意。所以，让我们创建一个新的方法，命名为 `IsKeyPressed()`，其代码如下：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method checks if the specified key is pressed, and returns `true` if it
    is or `false` if it is not. As you can see from the code in this method, the `KeyboardState`
    object has the `IsPressed()` method that we use to see if the specified key is
    pressed. It also has an `IsReleased()` method for testing if a key is not pressed.
    In addition to these, it has `PressedKeys` and `ReleasedKeys` properties that
    return a list of the currently pressed keys and currently not pressed keys respectively.
    And lastly, it has the `AllKeys` property that gives you the states of all keys
    on the keyboard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查指定的键是否被按下，如果按下则返回 `true`，如果没有按下则返回 `false`。从该方法中的代码可以看出，`KeyboardState`
    对象具有 `IsPressed()` 方法，我们使用它来检查指定的键是否被按下。它还包含一个 `IsReleased()` 方法，用于测试键是否没有被按下。除此之外，它还有
    `PressedKeys` 和 `ReleasedKeys` 属性，分别返回当前按下的键和当前未按下的键的列表。最后，它还有一个 `AllKeys` 属性，可以提供键盘上所有键的状态。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downloadable code for this chapter contains some additional keyboard handling
    methods like this one. They are `IsKeyReleased()` and `IsKeyHeldDown()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的可下载代码包含一些额外的键盘处理方法，如这个方法。它们是 `IsKeyReleased()` 和 `IsKeyHeldDown()`。
- en: 'There is now just one step left before we can see our keyboard input code in
    action. We need to add some code into our `UpdateScene()` method to check for
    some key presses. Here is the new code in the `UpdateScene()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够看到我们的键盘输入代码起作用之前，我们还需要做最后一步。我们需要在我们的 `UpdateScene()` 方法中添加一些代码来检查一些按键。这是
    `UpdateScene()` 方法中的新代码：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code adds some basic keyboard commands to our window. The first `if` statement
    checks to see if the user is holding down the *Return* key along with either the
    left or right *Alt* key. If this is the case, then the `if` statement calls the
    `ToggleFullscreen()` method.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码向我们的窗口添加了一些基本的键盘命令。第一个 `if` 语句检查用户是否同时按下 *Return* 键和左 *Alt* 键或右 *Alt* 键。如果是这种情况，那么
    `if` 语句将调用 `ToggleFullscreen()` 方法。
- en: The `else if` clause checks to see if the user is pressing the *Esc* key. If
    so, then we close the game window, and the program terminates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`else if` 子句检查用户是否正在按下 *Esc* 键。如果是这样，那么我们将关闭游戏窗口，程序终止。'
- en: 'Before we can test run the program, we need to add a single line of code into
    the `GameWindow` class'' `protected void Dispose(bool)` method. We need to add
    the following line of code into the managed resources section of the function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以测试运行程序之前，我们需要在 `GameWindow` 类的 `protected void Dispose(bool)` 方法中添加一行代码。我们需要在函数的资源管理部分添加以下代码行：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With that done, we can now test run the program. The game window looks identical
    to the way it did in the figure *The game window in action* in [Chapter 1](ch01.html
    "Chapter 1. Getting Started"), *Getting Started*. However, you can now close it
    by pressing the *Esc* key.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以测试运行程序了。游戏窗口看起来与图 *The game window in action* 中的方式相同，该图位于 [第 1 章](ch01.html
    "Chapter 1. Getting Started")，*入门*。然而，你现在可以通过按下 *Esc* 键来关闭它。
- en: If you press *Enter* + *Alt*, nothing will happen at the moment. As mentioned
    in the previous chapter, we can't toggle fullscreen mode yet since we are not
    using DirectX's graphics APIs yet. **Application Programming Interface** (**API**)
    simply refers collectively to all of the public methods and types that are made
    available by the API. For example, SlimDX is an API, as is DirectX.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同时按下*Enter* + *Alt*，目前不会有任何反应。正如前一章所述，我们无法切换全屏模式，因为我们还没有使用DirectX的图形API。**应用程序编程接口**（**API**）简单地指代API提供的所有公共方法和类型。例如，SlimDX是一个API，DirectX也是如此。
- en: Smaller parts of an API can sometimes be considered as APIs in their own right
    as well. For example, DirectX's DirectInput is an API in and of itself. DirectX
    is more like a collection of several different APIs for different purposes, as
    is SlimDX.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: API的较小部分有时也可以被视为独立的API。例如，DirectX的DirectInput本身就是API。DirectX更像是一个集合，包含针对不同目的的多个不同API，SlimDX也是如此。
- en: As you can see, keyboard input is fairly simple to implement with SlimDX. Mouse
    input, though we haven't really used any yet, is just as simple. Responding to
    mouse input is almost identical to doing so for keyboard input. Simply check the
    `X` and `Y` properties of the `MouseState` object to find out the mouse cursor's
    position. The `Z` property allows you to detect movement of the mouse's scroll
    wheel if it has one. If your mouse does not have a scroll wheel, then this property
    will simply return `0`. Note that the value of the `Z` property is a delta, or
    in other words it is the amount that the scroll wheel has moved since the last
    update. Lastly, you can use the `IsPressed()` and `IsReleased()` methods to detect
    if a given mouse button is pressed or released.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用SlimDX实现键盘输入相当简单。虽然我们还没有真正使用过，但鼠标输入也同样简单。响应鼠标输入几乎与键盘输入相同。只需检查`MouseState`对象的`X`和`Y`属性，以找出鼠标光标的当前位置。`Z`属性允许您检测鼠标滚轮（如果有的话）的移动。如果您的鼠标没有滚轮，则此属性将简单地返回`0`。请注意，`Z`属性的值是一个增量，换句话说，它是自上次更新以来滚轮移动的量。最后，您可以使用`IsPressed()`和`IsReleased()`方法来检测指定的鼠标按钮是否被按下或释放。
- en: Note that the downloadable code for this chapter also includes mouse handling
    methods added into our `UserInput` class. These are `IsMouseButtonPressed()`,
    `IsMouseButtonReleased()`, `IsMouseButtonHeldDown()`, `MouseHasMoved()`, and `MousePosition()`,
    among others. The `IsMouseButtonHeld()` method can be used to implement clicking-and-dragging
    behavior while the `HasMouseMoved()` method returns `true` if the mouse has moved
    since the previous frame, or `false` otherwise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章提供的可下载代码还包括添加到我们的`UserInput`类中的鼠标处理方法。这些方法包括`IsMouseButtonPressed()`、`IsMouseButtonReleased()`、`IsMouseButtonHeldDown()`、`MouseHasMoved()`和`MousePosition()`等。`IsMouseButtonHeld()`方法可以用来实现点击并拖拽的行为，而`HasMouseMoved()`方法在鼠标自上一帧以来有移动时返回`true`，否则返回`false`。
- en: Using joysticks with DirectInput
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DirectInput的摇杆
- en: Now, let's shift gears and take a look at using **joysticks**. In this book,
    we will use the term joystick to refer to any game controller. First, we will
    look at how to use joysticks with DirectInput.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们换挡，看看如何使用**摇杆**。在这本书中，我们将使用摇杆一词来指代任何游戏控制器。首先，我们将探讨如何使用DirectInput与摇杆配合。
- en: Enumerating devices
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举设备
- en: You've probably seen some games that let you choose which game controller you
    want to use if you have more than one attached to your PC. In this section, we
    are going to look at how to get the list of available devices. With SlimDX, it
    is actually quite easy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能见过一些游戏，如果您在PC上连接了多个游戏控制器，它们允许您选择想要使用的控制器。在本节中，我们将探讨如何获取可用设备的列表。使用SlimDX，这实际上相当简单。
- en: 'The `DirectInput` object (remember that we stored it in our `m_DirectInput`
    member variable) has a method named `GetDevices()`. To get a list of the available
    controllers, we would call that method like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectInput`对象（记住我们将其存储在`m_DirectInput`成员变量中）有一个名为`GetDevices()`的方法。要获取可用控制器的列表，我们可以像这样调用该方法：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To try this out, let''s add a new method to our `UserInput.cs` class. This
    method will simply write some debug output about the available devices. Here is
    the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个功能，让我们向我们的`UserInput.cs`类中添加一个新的方法。此方法将简单地输出有关可用设备的一些调试信息。以下是代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we create a variable named `deviceList`, get the list of game controllers,
    and store it in this new variable. For the first parameter of the `GetDevices()`
    method, we pass in the value `DeviceClass.GameController` to tell it that we are
    only interested in game controllers. For the second parameter, we give it the
    value `DeviceEnumerationFlags.AttachedOnly` because we only want devices that
    are actually installed and connected to the PC.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`deviceList`的变量，获取游戏控制器的列表，并将其存储在这个新变量中。对于`GetDevices()`方法的第一个参数，我们传入值`DeviceClass.GameController`来告诉它我们只对游戏控制器感兴趣。对于第二个参数，我们给它传入值`DeviceEnumerationFlags.AttachedOnly`，因为我们只想获取实际安装并连接到PC的设备。
- en: Next, we have an `if` statement that checks to see if the list of game controllers
    is empty. If so, it prints a debug message to let you know that no game controllers
    are connected to your computer. In the `else` clause of this `if` statement, we
    have a `foreach` loop that iterates through the list of game controllers that
    we just retrieved and stored in the `deviceList` variable. Inside the `foreach`
    loop, we have a single line of code. This line simply writes a single line of
    debug output into Visual Studio's **Output** pane for each game controller in
    the list. The **Output** pane is generally found at the bottom of the Visual Studio
    window. You may have to click on the **Output** tab in the lower-left corner of
    the window to display it if autohide is on. You can also access it by going to
    the **View** menu and selecting **Output**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`if`语句，用于检查游戏控制器的列表是否为空。如果是这样，它将打印一条调试消息来通知你没有游戏控制器连接到你的计算机。在`if`语句的`else`子句中，我们有一个`foreach`循环，它遍历我们刚刚检索并存储在`deviceList`变量中的游戏控制器列表。在`foreach`循环内部，我们只有一行代码。这一行代码只是将一行调试输出写入Visual
    Studio的**输出**面板，针对列表中的每个游戏控制器。**输出**面板通常位于Visual Studio窗口的底部。如果你启用了自动隐藏，你可能需要点击窗口左下角的**输出**选项卡来显示它。你还可以通过转到**视图**菜单并选择**输出**来访问它。
- en: By default, Visual Studio automatically displays the **Output** pane while you
    are running your program so that you can see your program's debug output, as shown
    in the following screenshot. If it does not show the **Output** pane, see the
    preceding paragraph for how to access it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio在运行你的程序时会自动显示**输出**面板，以便你可以看到你的程序的调试输出，如下面的截图所示。如果它没有显示**输出**面板，请参阅前面的段落了解如何访问它。
- en: 'Next, go to the `InitDirectInput()` method and add the following line of code
    to the end of the function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到`InitDirectInput()`方法，并在函数末尾添加以下代码行：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This makes a call to our new `GetJoysticks()` method at the end of the constructor.
    If you run this code now, you will see a list of game controllers displayed in
    Visual Studio''s **Output** pane. The following screenshot shows what this looks
    like on my system, where I have one game controller connected to the computer:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构造函数的末尾调用我们的新`GetJoysticks()`方法。如果你现在运行此代码，你将在Visual Studio的**输出**面板中看到游戏控制器的列表。以下截图显示了在我的系统上看起来是什么样子，其中我有一个游戏控制器连接到计算机：
- en: '![Enumerating devices](img/7389OS_02_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![设备枚举](img/7389OS_02_01.jpg)'
- en: The Output pane showing our Debug output
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们的调试输出的输出面板
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Your output from this code will most likely be different than mine. So, you
    will probably see a different list of controllers to what I have, so your output
    will likely differ from that shown in the preceding screenshot.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你从这个代码输出的结果很可能与我不同。所以，你可能会看到与我不同的控制器列表，因此你的输出可能会与前面截图中的输出不同。
- en: Getting input from the joystick
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从摇杆获取输入
- en: 'This is all well and good, but we still can''t get input from a joystick. So
    let''s look at that now. First, we need to add three member variables for our
    joystick, just like we did for the mouse and keyboard. Here are the three new
    member variables we need to add to our `UserInput.cs` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，但我们仍然无法从摇杆获取输入。所以，让我们现在看看这个问题。首先，我们需要为我们的摇杆添加三个成员变量，就像我们为鼠标和键盘所做的那样。以下是我们需要添加到`UserInput.cs`类中的三个新成员变量：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As before, we have a variable to hold our device object (in this case, a `Joystick`
    object), and two more variables to hold the joystick state for the current frame
    and for the previous frame.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有一个变量来保存我们的设备对象（在这种情况下，是一个`Joystick`对象），以及另外两个变量来保存当前帧和前一帧的摇杆状态。
- en: 'Now, we need to add two lines at the bottom of our constructor to initialize
    the joystick state variables. As discussed earlier in this chapter, this prevents
    a crash from potentially happening. Add these two lines at the end of the constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在构造函数的底部添加两行代码来初始化摇杆状态变量。正如本章前面所讨论的，这可以防止潜在的崩溃。在构造函数的末尾添加这两行代码：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s modify our `GetJoysticks()` method. We will simply make it use
    the first joystick in the returned list of controllers. Here is the new code for
    the `GetJoysticks()` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`GetJoysticks()`方法。我们将简单地让它使用返回的控制器列表中的第一个摇杆。以下是`GetJoysticks()`方法的新代码：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we've also added a second line inside the `if` statement. This
    sets the minimum and maximum possible values for each axis on our game controller.
    In this case, we set it to `-1,000` and `1,000`. This means when the joystick
    is all the way to the left, its horizontal position is `-1,000`. When it is all
    the way to the right, its horizontal position is `1,000`. The same is true for
    the vertical axis. When the joystick is centered, its position will be (0,0).
    It is important to know the range of possible values to make our controls work
    correctly. You can get the range from the `Joystick.Properties.LowerRange` and
    `Joystick.Properties.UpperRange` properties. Note that these properties can throw
    an exception in some cases depending on your game controller's drivers and your
    DirectX version.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在`if`语句内部也添加了第二行代码。这设置了游戏控制器上每个轴的最小和最大可能值。在这种情况下，我们将其设置为`-1,000`和`1,000`。这意味着当摇杆完全向左时，其水平位置是`-1,000`。当它完全向右时，其水平位置是`1,000`。垂直轴也是如此。当摇杆居中时，其位置将是`(0,0)`。了解可能值的范围对于使我们的控制正确工作非常重要。你可以从`Joystick.Properties.LowerRange`和`Joystick.Properties.UpperRange`属性中获取范围。请注意，这些属性在某些情况下可能会抛出异常，这取决于你的游戏控制器驱动程序和DirectX版本。
- en: 'Now, we need to add a couple of lines of code into our `Update()` method to
    get the latest joystick data. To do this, we first need to add a line at the beginning
    of this method to acquire the joystick. You can''t use a device without acquiring
    it first (see the *Mouse and keyboard input* section of this chapter for information
    on acquisition and why we need to do it). So, we will add the following line of
    code to acquire the joystick for us:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的`Update()`方法中添加几行代码来获取最新的摇杆数据。为此，我们首先需要在方法的开头添加一行代码来获取摇杆。在没有获取摇杆之前，你不能使用设备（参见本章的*鼠标和键盘输入*部分，了解获取信息以及为什么我们需要这样做）。因此，我们将添加以下代码行来为我们获取摇杆：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We are basically letting the system know that we wish to use the joystick now
    and get access to it. Now that we have gotten the access to the joystick, we need
    to add these two lines at the end of the `Update()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上是在通知系统我们现在希望使用摇杆并获取对它的访问权限。现在我们已经获取了对摇杆的访问权限，我们需要在`Update()`方法的末尾添加这两行代码：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we did with the mouse and keyboard, we do with our `Joystick` object too.
    We take the value of the `m_Joy1StateCurrent` member variable and copy it into
    the `m_Joy1StateLast` variable since this state data is now one frame old. Then
    we get the current joystick state and store it in the `m_Joy1StateCurrent` member
    variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对鼠标和键盘所做的那样，我们对`Joystick`对象也这样做。我们将`m_Joy1StateCurrent`成员变量的值复制到`m_Joy1StateLast`变量中，因为现在的状态数据已经是一帧之前的了。然后我们获取当前的摇杆状态并将其存储在`m_Joy1StateCurrent`成员变量中。
- en: 'Our user input class now supports the use of one joystick. You could support
    more by adding variables and code for the second joystick the same way we did
    for this first joystick. Now, let''s add some test code at the end of the `Update()`
    method to see this in action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户输入类现在支持使用一个摇杆。你可以通过添加与第一个摇杆相同的变量和代码来支持更多摇杆。现在，让我们在`Update()`方法的末尾添加一些测试代码，以查看其效果：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you don't have a game controller, then you won't see any of the output from
    the previous code. The program would still work, but there would not be any debug
    output since there is no game controller to get it from.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有游戏控制器，那么你将看不到前面代码的任何输出。程序仍然会工作，但由于没有游戏控制器来获取它，所以不会有调试输出。
- en: This test code is a simple group of `if` statements. The first `if` statement
    checks if button `0` is pressed. If so, it writes a line of debug output to show
    you that it has detected the button press. The second `if` statement checks if
    button `1` is pressed, and if so, writes a debug message saying so. And the last
    two `if` statements do the same for buttons `2` and `3`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段测试代码是一组简单的`if`语句。第一个`if`语句检查按钮`0`是否被按下。如果是，它将写入一行调试输出以显示它已经检测到按钮按下。第二个`if`语句检查按钮`1`是否被按下，如果是，则写入一条调试消息。最后两个`if`语句对按钮`2`和`3`做同样的处理。
- en: So, why are we using numbers here? The reason is because each joystick button
    has an index that we use to refer to it. So for example, on my gamepad, button
    `0` is the *A* button.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们在这里使用数字呢？原因是因为每个摇杆按钮都有一个索引，我们用它来引用它。例如，在我的游戏手柄上，按钮`0`是*A*按钮。
- en: 'We need to add two more lines of code to our `Dispose(bool)` method now. They
    will go in the managed resources section of the method. Here they are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的`Dispose(bool)`方法中添加两行代码。它们将放在方法的管理资源部分。下面是它们：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This simply checks if the `Joystick` object is null. If not, then we dispose
    of it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地检查`Joystick`对象是否为null。如果不是，那么我们就销毁它。
- en: Run the program and press the buttons on your game controller. If you press
    the buttons `0`, `1`, `2`, or `3`, you will see some new lines of debug output
    appearing on Visual Studio's **Output** pane. When one of these buttons we coded
    for is pressed, its message appears multiple times. This is due to the speed at
    which the game loop is running. It is running super fast right now since it doesn't
    even have to render any graphics or simulate anything yet! The downloadable code
    for this chapter adds more `if` statements to cover more buttons than we did here.
    It also has some commented out lines for displaying the current positions of the
    left and right joysticks, and the position of the axis that is being used to represent
    the triggers (these are the buttons you can press in a little bit, all the way,
    or not at all, and they are usually found on the shoulders of a gamepad style
    controller).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并按下你的游戏控制器上的按钮。如果你按下按钮`0`、`1`、`2`或`3`，你将在Visual Studio的**输出**面板上看到一些新的调试输出行。当我们编写的这些按钮之一被按下时，其消息会多次出现。这是由于游戏循环运行的速率。现在它运行得超级快，因为它甚至不需要渲染任何图形或模拟任何东西！本章节的可下载代码添加了更多的`if`语句来覆盖比这里更多的按钮。它还有一些注释掉的行，用于显示左右摇杆的当前位置以及用于表示扳机的轴的位置（这些是可以稍微按下、完全按下或不按下的按钮，通常位于游戏手柄式控制器的手肩上）。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can detect when the user presses the thumbstick buttons the same way you
    do normal buttons on the gamepad, you just need to figure out which index represents
    each thumbstick button. This is not normally a problem since most games let the
    user bind game actions to whichever buttons or axes they want. In other words,
    you should generally never hardcode the controls in your game as they might not
    be correct or desirable for some players.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用检测用户按下拇指按钮的方式检测用户按下摇杆按钮，你只需要找出哪个索引代表每个拇指按钮。这通常不是一个问题，因为大多数游戏允许用户将游戏动作绑定到他们想要的任何按钮或轴。换句话说，你通常不应该在游戏中硬编码控制，因为它们可能对某些玩家不正确或不理想。
- en: We've really only scratched the surface of using joysticks with DirectInput.
    Spend some time exploring the various properties of the `Joystick` object that
    we stored in our `m_Joystick1` member variable. You'll see that it has a lot of
    other properties we didn't use here. The `X` and `Y` properties, for example,
    will usually tell you what the left joystick is doing. The `RotationX` and `RotationY`
    properties will usually tell you the position of the right analog stick. A joystick
    has two axis as you can see. If the joystick is not moved at all, it is centered,
    so its position reading will be in the center of the ranges of both axis. If you
    push the joystick all the way to the right, it will be at its maximum value on
    its horizontal axis. If you push it up all the way, it will be at the minimum
    value for its vertical axis.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上只是刚刚触及了使用DirectInput摇杆的表面。花些时间探索我们存储在`m_Joystick1`成员变量中的`Joystick`对象的各种属性。你会发现还有很多我们没有在这里使用的其他属性。例如，`X`和`Y`属性通常会告诉你左摇杆正在做什么。`RotationX`和`RotationY`属性通常会告诉你右模拟摇杆的位置。摇杆有两个轴，正如你所见。如果摇杆完全没有移动，它就是居中的，因此它的位置读数将在两个轴的范围中心。如果你将摇杆推到最右边，它将在其水平轴上达到最大值。如果你将它完全向上推，它将在其垂直轴上达到最小值。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might expect the joystick's position to be (0,0) if you push it all the
    way up and left, but it isn't. This is because most joysticks have a circular
    range of movement and therefore the joystick will never be at the absolute upper-left
    corner of the movement range defined by its pair of axes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将摇杆推到最上方和最左侧，你可能会预期摇杆的位置是（0,0），但实际上并非如此。这是因为大多数摇杆都有一个圆形的运动范围，因此摇杆永远不会位于由其一对轴定义的运动范围的绝对左上角。
- en: The `Z` property will usually give you the value for the axis that represents
    the trigger buttons for gamepad style devices in most cases. If neither trigger
    is pressed, the value is in the middle of the range. If the left trigger is completely
    pressed, the `Z` property will have the maximum value for the axis, and of course
    if the right trigger is completely pressed, then `Z` will have the minimum value
    for the range of this axis. The range can vary and you can also modify stuff like
    this by messing with the `Properties` property of the `Joystick` object (remember
    that you have to release a device before you can change its properties). This
    range can vary from one controller to the next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`Z`属性会给出代表游戏手柄式设备上的扳机按钮的轴的值。如果两个扳机都没有被按下，则该值位于范围中间。如果左扳机完全按下，`Z`属性将具有该轴的最大值，当然，如果右扳机完全按下，那么`Z`将具有该轴范围的最低值。这个范围可能不同，你也可以通过修改`Joystick`对象的`Properties`属性来修改类似的内容（记住，在改变其属性之前，你必须释放设备）。这个范围可能因控制器而异。
- en: What about the Directional Pad though (often called a D-Pad for short)? How
    you handle these depends on how the controller reports it. Some may report the
    D-Pad as normal buttons, in which case it would be handled in the same way as
    normal buttons. Other controllers report the D-Pad as a POV (point of view) controller.
    In this case, you can access it using the `GetPointOfViewControllers()` method
    of the `JoystickState` object. It returns an `int` array. The first index represents
    the first POV controller on your game controller. The value of the first element
    of the array will change depending on which direction you are pressing. For mine,
    the first element has the value `0` when I press up, `9,000` when I press to the
    right, `18,000` when I press down, and `27,000` when I press to the left on the
    D-Pad.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于方向垫（通常简称为D-Pad）呢？你如何处理它取决于控制器如何报告它。有些可能将D-Pad报告为普通按钮，在这种情况下，它将以与普通按钮相同的方式处理。其他控制器将D-Pad报告为POV（视角）控制器。在这种情况下，你可以使用`JoystickState`对象的`GetPointOfViewControllers()`方法来访问它。它返回一个`int`数组。数组的第一个索引代表你的游戏控制器上的第一个POV控制器。数组第一个元素的值将根据你按的方向而变化。对于我来说，当我按下向上时，第一个元素的值是`0`，当我按下向右时是`9,000`，当我按下向下时是`18,000`，当我按下向左时是`27,000`在D-Pad上。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Much of this can vary depending on the type of game controller you are using
    and how DirectInput sees it. So, you may have to play around with different properties
    in the `JoystickState` object (remember we stored ours in the `m_Joy1StateCurrent`
    member variable) to find what you need.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中很多都可能因你所使用的游戏控制器类型以及DirectInput如何识别它而有所不同。因此，你可能需要在不同属性的`JoystickState`对象（记住我们将其存储在`m_Joy1StateCurrent`成员变量中）上尝试不同的设置，以找到你需要的内容。
- en: Feel free to experiment with the debug code we just added into the `Update()`
    method. Experimentation is a great way to learn new things. Sometimes, it's quicker
    than reading lots of boring documentation too! We won't fully cover DirectInput
    here as that could fill an entire book by itself.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试我们在`Update()`方法中刚刚添加的调试代码。实验是学习新事物的好方法。有时候，这比阅读大量枯燥的文档要快得多！在这里，我们不会全面介绍DirectInput，因为那可能需要一本书的篇幅来涵盖。
- en: The downloadable code for this chapter contains a bunch of handy joystick handling
    methods added to our `UserInput` class. They include `DI_LeftStickPosition()`,
    `DI_RightStickPosition`, and `DI_TriggersAxis()`, among others. **DI** is of course
    short for DirectInput. The `TriggersAxis()` method gets the current value of the
    axis that represents the triggers (discussed earlier). The joystick methods get
    the current position of the joysticks. For mine, each axis has a range of `0`
    to `65535`, and each joystick has two axes of course (horizontal and vertical).
    When the joystick is not pressed at all, its position will be in the center of
    both its horizontal and vertical axes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的可下载代码为我们的`UserInput`类添加了一些实用的摇杆处理方法。包括`DI_LeftStickPosition()`、`DI_RightStickPosition`和`DI_TriggersAxis()`等。当然，**DI**是DirectInput的缩写。`TriggersAxis()`方法获取表示扳机的轴的当前值（前面已讨论）。摇杆方法获取摇杆的当前位置。对于我的摇杆，每个轴的范围是`0`到`65535`，每个摇杆当然有两个轴（水平和垂直）。当摇杆没有被按下时，它的位置将在水平和垂直轴的中心。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These methods may not work quite right with some devices since different game
    controllers are set up differently. It should work correctly for most gamepad
    style controllers though.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可能不会与某些设备完全正常工作，因为不同的游戏控制器设置方式不同。但对于大多数游戏手柄式控制器，它应该可以正常工作。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you should really never hardcode the controls in your game. Players
    will be very annoyed if the controls are screwy or don't work on their particular
    game controller, and they find that they can't change them because you hardcoded
    the controls in your game.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你绝对不应该在游戏中硬编码控制。如果控制不正常或在他们特定的游戏控制器上不起作用，玩家会非常烦恼，并且发现他们无法更改它们，因为你在游戏中硬编码了控制。
- en: Using joysticks with XInput
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XInput摇杆
- en: 'Once again, we first need to add some member variables for our XInput device.
    They look a bit different this time, but here they are:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们首先需要为我们的XInput设备添加一些成员变量。这次它们看起来有些不同，但它们就在这里：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In XInput, we use the `Controller` class to represent a controller. The `Gamepad`
    structure stores the state of the controller. As before, we have one variable
    to hold our device, and two more to hold its current and previous state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在XInput中，我们使用`Controller`类来表示控制器。`Gamepad`结构存储控制器的状态。和之前一样，我们有一个变量来保存我们的设备，还有两个额外的变量来保存其当前和之前的状态。
- en: 'Now, we will add a very short new method named `InitXInput()`. Here is its
    code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个非常简短的新方法，名为`InitXInput()`。以下是它的代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code sets up one XInput controller for us to use. We pass into its constructor
    the value `UserIndex.One` to indicate that this controller will be used by player
    1.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为我们设置了一个XInput控制器以供使用。我们将其构造函数的值传递为`UserIndex.One`，以指示这个控制器将由玩家1使用。
- en: 'We need to modify the constructor of our user input class to call this new
    method now. We also need to add some code to initialize our XInput joystick state
    variables. As mentioned earlier, this is necessary to prevent the program from
    crashing. Here is what the constructor looks like now with the new bits of code
    highlighted:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改我们用户输入类的构造函数，现在来调用这个新方法。我们还需要添加一些代码来初始化我们的XInput摇杆状态变量。如前所述，这是防止程序崩溃所必需的。以下是现在带有新代码高亮的构造函数看起来像什么：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we must add the following code to the end of the `Update()` method in
    our user input class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将以下代码添加到我们用户输入类的`Update()`方法末尾：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code is very similar to our DirectInput joystick test code. It copies the
    state data from the previous frame into the `m_Controller1StateLast` member variable,
    and then gets the current controller state and stores it in the `m_Controller1StateCurrent`
    variable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前的DirectInput摇杆测试代码非常相似。它将前一帧的状态数据复制到`m_Controller1StateLast`成员变量中，然后获取当前控制器状态并将其存储在`m_Controller1StateCurrent`变量中。
- en: The `if` statements are just like the ones we used to test our DirectInput joystick
    code. The first one checks if the *A* button is pressed. If so, it prints a debug
    message saying so in Visual Studio's **Output** pane. The second `if` statement
    does this for the *B* button, and the last two `if` statements do the same for
    the *X* and *Y* buttons.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句就像我们用来测试DirectInput摇杆代码的那些一样。第一个检查*A*按钮是否被按下。如果是，它将在Visual Studio的**输出**面板中打印一条调试信息。第二个`if`语句对*B*按钮做同样的事情，最后两个`if`语句对*X*和*Y*按钮做相同处理。'
- en: You may have noticed that we didn't have to *acquire* the XInput controller
    at the beginning of the `Update()` method like we do with the mouse, keyboard,
    and joysticks under DirectInput. Instead, we simply set up the XInput controller
    in our `InitXInput()` method. You may also have noticed that we didn't need to
    add code in our `Dispose(bool)` method to dispose of the XInput controller object
    either. It doesn't even have a `Dispose()` method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们不需要在`Update()`方法的开头像处理DirectInput下的鼠标、键盘和摇杆那样*获取*XInput控制器。相反，我们只是在我们的`InitXInput()`方法中设置了XInput控制器。你也可能注意到，我们不需要在我们的`Dispose(bool)`方法中添加代码来释放XInput控制器对象。它甚至没有`Dispose()`方法。
- en: We are now ready to test our new code. You will need an XInput compatible controller
    to test it. If you don't have one, this code will still run, but it just won't
    do anything since there's no XInput controller for it to get input from.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好测试我们的新代码了。你需要一个XInput兼容的控制器来测试它。如果你没有，这段代码仍然可以运行，但它不会做任何事情，因为没有XInput控制器可以从中获取输入。
- en: 'If you have a controller that supports XInput, you may see dual output from
    this code because both the DirectInput and the XInput test code will be outputting
    debug messages to Visual Studio''s **Output** pane at the same time (if both are
    reading input from the same controller), as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个支持XInput的控制器，你可能会看到这段代码的双重输出，因为DirectInput和XInput测试代码将同时向Visual Studio的**输出**窗格输出调试信息（如果它们都从同一个控制器读取输入），如下面的截图所示：
- en: '![Using joysticks with XInput](img/7389OS_02_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用XInput摇杆](img/7389OS_02_02.jpg)'
- en: DirectInput and XInput both reading input from the same device
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: DirectInput和XInput同时从同一设备读取输入
- en: We have once again only really scratched the surface here. There is more to
    XInput than what we've looked at. For example, you can get the state of the left
    and right sticks by accessing the `LeftThumbX` and `LeftThumbY` properties for
    the left stick, and the `RightThumbX` and `RightThumbY` properties for the right
    stick. Note that the range for joystick axis values in XInput is always `-32,768`
    to `32,767`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是触及了表面。XInput还有更多我们尚未探讨的内容。例如，你可以通过访问左摇杆的`LeftThumbX`和`LeftThumbY`属性以及右摇杆的`RightThumbX`和`RightThumbY`属性来获取左右摇杆的状态。请注意，XInput中摇杆轴值的范围始终是`-32,768`到`32,767`。
- en: You also may have noticed that we didn't add properties to the user input class
    to provide access to our joystick objects. They would be just as simple as the
    properties we added in this chapter, so they've simply been omitted from the chapter
    to save space. They are, however, included in the downloadable code for this chapter.
    Also included are a bunch of joystick handling methods for XInput devices, including
    `XI_LeftStickPosition()`, `XI_RightStickPosition()`, `XI_LeftTrigger()`, and `XI_RightTrigger()`,
    among others. **XI** is of course short for XInput. Note that for the left and
    right triggers, their values are in the range of `0` to `255` depending on how
    much you press the trigger in. Also, in XInput the D-Pad is treated as regular
    buttons, so you will find button flags for all of its directions in the `GamepadButtonFlags`
    enumeration. This is also true for the thumbstick buttons.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能注意到，我们没有向用户输入类添加属性来提供对我们的摇杆对象的访问。它们将与我们在本章中添加的属性一样简单，所以它们已经被从章节中省略以节省空间。然而，它们确实包含在本章的可下载代码中。还包括了一组用于XInput设备的摇杆处理方法，包括`XI_LeftStickPosition()`、`XI_RightStickPosition()`、`XI_LeftTrigger()`和`XI_RightTrigger()`等。**XI**当然是指XInput。请注意，对于左右扳机，它们的值在`0`到`255`之间，具体取决于你按下扳机的程度。此外，在XInput中，D-Pad被视为常规按钮，因此你将在`GamepadButtonFlags`枚举中找到所有方向的按钮标志。这也适用于摇杆按钮。
- en: Explore the various properties of the XInput `Controller` object to learn more
    about what you can do. Remember that we stored our `Controller` object in the
    `m_Controller1` member variable. Experiment with this code and see what you can
    discover.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 探索XInput `Controller`对象的各个属性，以了解更多你可以做什么。记住，我们将我们的`Controller`对象存储在`m_Controller1`成员变量中。尝试这段代码，看看你能发现什么。
- en: Note that the downloadable code for this chapter also includes some additional
    test code for the keyboard and mouse input inside our `Update()` method in the
    `UserInput` class. This code is very similar to the joystick test code that was
    shown in this chapter for both DirectInput and XInput.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章的可下载代码还包括一些额外的测试代码，用于在`UserInput`类的`Update()`方法中测试键盘和鼠标输入。这段代码与本章中显示的DirectInput和XInput的摇杆测试代码非常相似。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a crash course in responding to user input. First we
    looked at the differences between DirectInput and XInput. Then we looked at how
    to detect and respond to mouse and keyboard input. Next, we moved on to using
    joysticks with DirectInput, where we first looked at how to get a list of the
    available game controllers that are connected to the computer. Then, for simplicity,
    we added code to obtain the first game controller from the list and get some input
    from it. We wrote test code that outputs some debug text when you press the `0`,
    `1`, `2`, or `3` buttons. And finally, we looked at XInput controllers. The code
    we implemented to get input from the XInput controller was very similar to the
    DirectInput code, but slightly different. And lastly, we added some code to write
    some debug text into Visual Studio's **Output** pane whenever you press the *A*,
    *B*, *X*, or *Y* buttons on the XInput controller. In the next chapter, we will
    learn how to draw 2D graphics on the screen and create a 2D tile-based game world.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速学习了如何响应用户输入。首先，我们探讨了DirectInput和XInput之间的区别。然后，我们了解了如何检测和响应用户的鼠标和键盘输入。接下来，我们转向使用DirectInput与游戏手柄配合，首先我们学习了如何获取连接到计算机的可用游戏控制器的列表。为了简化，我们添加了代码来从列表中获取第一个游戏控制器并从中获取一些输入。我们编写了测试代码，当按下`0`、`1`、`2`或`3`按钮时，会输出一些调试文本。最后，我们探讨了XInput控制器。我们从XInput控制器获取输入所实现的代码与DirectInput代码非常相似，但略有不同。最后，我们添加了一些代码，每当你在XInput控制器上按下*A*、*B*、*X*或*Y*按钮时，都会将一些调试文本写入Visual
    Studio的**输出**面板。在下一章中，我们将学习如何在屏幕上绘制2D图形并创建一个基于2D瓦片的游戏世界。
