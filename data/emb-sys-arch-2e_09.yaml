- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Distributed Systems and IoT Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统和物联网架构
- en: By accessing communication peripherals, such as network controllers and radio
    interfaces, microcontrollers are able to establish data communication with nearby
    devices and even with remote servers through the internet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问通信外围设备，如网络控制器和无线接口，微控制器能够与附近的设备以及通过互联网的远程服务器建立数据通信。
- en: A set of embedded targets connected together and interacting with each other
    can be seen as a self-contained distributed system. Homogeneous machine-to-machine
    communication can be implemented using non-standard, and even proprietary, protocols.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一组相互连接并交互的嵌入式目标可以被视为一个自包含的分布式系统。可以使用非标准，甚至专有的协议来实现同质化的机器到机器通信。
- en: Depending on the set of standard protocols it implements, an embedded system
    may be able to successfully communicate with heterogeneous, remote systems. Implementing
    standard protocols that are standardized or widely supported introduces the possibility
    to interact with gateways in the same geographic area, and with remote cloud servers
    across the internet.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它实现的协议集，嵌入式系统可能能够成功地与异构的远程系统通信。实现标准化的或广泛支持的协议引入了与同一地理区域内网关交互，以及通过互联网与远程云服务器交互的可能性。
- en: 'The connectivity range of small, embedded devices may include remote coordination
    using **Information Technology** (**IT**) systems. The encounter between the two
    worlds has changed the modern interpretation of distributed systems: low-power,
    inexpensive devices can now be part of services with solid roots in IT, which,
    in turn, can extend their branches into localized and specialized sensors and
    actuators, creating what has been known as the **Internet of** **Things** (**IoT**).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 小型嵌入式设备的连接范围可能包括使用**信息技术**（**IT**）系统进行远程协调。这两个世界的相遇改变了现代对分布式系统的解释：低功耗、低成本的设备现在可以成为根植于IT的服务的一部分，反过来，它们可以将分支扩展到本地化和专业化的传感器和执行器，从而创造出所谓的**物联网**（**IoT**）。
- en: This technological step, considered revolutionary by many, is capable of changing
    the way we access technology, and human-to-machine interaction processes, forever.
    Unfortunately, the security aspects of IoT communication have too often been neglected,
    leading to unpleasant incidents, which may compromise the confidentiality and
    integrity of the data transmitted and permit attackers to take control of remote
    devices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这一技术步骤被许多人视为革命性的，能够永远改变我们获取技术的方式，以及人机交互过程。不幸的是，物联网通信的安全方面往往被忽视，导致不愉快的事件，可能损害传输数据的机密性和完整性，并允许攻击者控制远程设备。
- en: This chapter analyzes the telecommunication technologies and protocols that
    are possible to integrate into embedded targets, using them to better understand
    the design from the point of view of the whole embedded system, up to integration
    within IoT networks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析了可以集成到嵌入式目标中的电信技术和协议，利用它们从整个嵌入式系统的角度更好地理解设计，直至集成到物联网网络中。
- en: We will learn about the networking model, starting from the physical layer and
    the possible technologies for establishing wireless or wired links, up to tailored
    embedded applications that can establish secure communication with cloud services,
    using standard communication protocols.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习网络模型，从物理层和建立无线或有线链路的可能技术开始，直至定制嵌入式应用程序，它们可以使用标准通信协议与云服务建立安全通信。
- en: 'In particular, we will look at the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其，我们将关注以下内容：
- en: Network interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络接口
- en: The Internet protocols
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网协议
- en: TLS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLS
- en: The application protocols
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用协议
- en: By the end of this chapter, you will have an in-depth understanding of today’s
    microcontroller’s IoT capabilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解当今微控制器的物联网功能。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we assume that you are familiar with general concepts of modern
    computer networking, although no previous experience with distributed applications
    is required. For a more complete background on network programming, which is relevant
    to the content of this chapter, we suggest, as further reading, *Hands On Network
    Programming with C* (L. Van Winkle – Packt Publishing 2019). There are no specific
    examples provided in the book’s repository for this chapter. More complete examples
    of TCP and **Transport Layer Security** (**TLS**) client/server communication
    can be found in the source code distribution of the open source projects presented
    here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设您已经熟悉现代计算机网络的一般概念，尽管不需要有分布式应用的经验。为了更全面地了解与本章内容相关的网络编程背景，我们建议进一步阅读《动手实践C语言网络编程》（L.
    Van Winkle – Packt Publishing 2019）。本书的仓库中没有提供本章的具体示例。更完整的TCP和**传输层安全性**（**TLS**）客户端/服务器通信示例可以在这里展示的开源项目的源代码分布中找到。
- en: Network interfaces
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口
- en: Embedded devices often integrate one or more communication interfaces. Many
    microcontrollers integrate the **Media Access Control** (**MAC**) portion of an
    Ethernet interface, so connecting a **Physical Layer Transceiver** (**PHY**) would
    enable LAN access. Some devices are coupled with radio transceivers, operating
    at fixed frequency ranges and implementing one or more protocols to communicate
    over wireless links. Frequently used frequencies for wireless communication are
    the 2.4 GHz band, in use by Bluetooth and 802.11 Wi-Fi, and some specific ISM
    ranges of frequency below 1 GHz, which depend on local regulations. Usable sub-GHz
    frequencies include the 868 MHz ISM band in the European Union and the 915 MHz
    ISM band in the US. Transceivers are usually designed to access the physical layer
    according to specific link protocols, regulating shared access to the physical
    media among two or more devices. While two interfaces accessing the same media
    can have different configurations, the MAC model implemented must follow the same
    specifications on all the endpoints in order to establish point-to-point communication.
    Part of the MAC layer may be implemented in the device itself, which, in turn,
    can use a parallel or a serial interface to transfer data to and from the microcontroller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备通常集成了一个或多个通信接口。许多微控制器集成了以太网接口的**媒体访问控制**（**MAC**）部分，因此连接一个**物理层收发器**（**PHY**）就可以实现局域网访问。一些设备与无线电收发器相连，在固定的频率范围内工作，并实现一个或多个协议以通过无线链路进行通信。无线通信中常用的频率是2.4
    GHz频段，蓝牙和802.11 Wi-Fi都在使用这个频段，以及一些低于1 GHz的特定ISM频段，这些频段取决于当地法规。可用的亚GHz频率包括欧盟的868
    MHz ISM频段和美国的915 MHz ISM频段。收发器通常设计为根据特定的链路协议访问物理层，调节两个或多个设备之间对物理媒体的共享访问。虽然访问相同媒体的两个接口可以有不同的配置，但实现的MAC模型必须遵循所有端点上的相同规范，以便建立点对点通信。MAC层的一部分可能是在设备本身中实现的，它反过来可以使用并行或串行接口将数据传输到和从微控制器。
- en: Hardware manufacturers may distribute the device drivers to access the link
    layer. When the full source code is made available, it is easier for a developer
    to customize the media access, integrate the device communication features, and
    tailor the communication to any protocol stack supported by the media. However,
    many device drivers are only partially open source, sometimes limiting the possibilities
    for integration with open standards. Moreover, integrating third-party proprietary
    code into an embedded system impacts the project maintenance and often requires
    workarounds for known issues or to enable features not foreseen by the manufacturer,
    and definitely impacts the security model of the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件制造商可能会分发设备驱动程序以访问链路层。当完整的源代码可用时，开发者更容易定制媒体访问，集成设备通信功能，并将通信定制为媒体支持的任何协议栈。然而，许多设备驱动程序只是部分开源，有时限制了与开放标准的集成可能性。此外，将第三方专有代码集成到嵌入式系统中会影响项目维护，通常需要解决已知问题或启用制造商未预见的功能，并且肯定会影响系统的安全模型。
- en: The implementation of device drivers in embedded systems, for either wired or
    wireless network interfaces, includes integrating the relevant access control
    mechanism in the communication logic and dealing with specific channel features.
    Some characteristics of the link may affect the design of higher-level communication,
    thus impacting the architecture of the entire distributed system. Alongside a
    reliable interaction with the MAC mechanisms, aspects such as bit rate, latency,
    and maximum packet size must be addressed and evaluated in the design phase to
    evaluate the resources required based on the goals of the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中实现设备驱动程序，无论是有线还是无线网络接口，包括在通信逻辑中集成相关的访问控制机制，并处理特定的信道特性。链路的一些特性可能会影响高级通信的设计，从而影响整个分布式系统的架构。在可靠地与MAC机制交互的同时，比特率、延迟和最大数据包大小等问题必须在设计阶段解决和评估，以根据系统的目标评估所需资源。
- en: The next section offers an overview of some popular network interfaces in the
    embedded world, typically used by connected devices to communicate with the other
    components of a broader distributed system. The subsequent section will suggest
    some criteria to navigate through the options for selecting the best technology
    for a specific purpose during the design of the communication infrastructures
    and protocols.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分提供了嵌入式世界中一些流行网络接口的概述，这些接口通常由连接的设备用于与其他分布式系统组件通信。接下来的部分将建议一些标准，以在通信基础设施和协议设计过程中选择最适合特定目的的技术。
- en: MAC
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAC
- en: The most important components to establish successful communication links over
    any physical media are grouped in the MAC logic, the implementation of which is
    often a shared responsibility between the software and hardware. Different technologies
    have evolved to define standards to access the links that are used nowadays for
    machine-to-machine communication, while only a few can scale within the context
    of a geographically distributed IoT system without intermediate gateways performing
    protocol conversions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何物理媒体上建立成功通信链路的最重要组件被归类在MAC逻辑中，其实现通常是软件和硬件共同的责任。不同的技术已经发展起来，以定义标准来访问现在用于机器对机器通信的链路，而只有少数能够在没有进行协议转换的中间网关的地理分布式物联网系统中扩展。
- en: Some of the standards are directly derived from the IT world and consist of
    adaptations of existing TCP/IP technologies capable of scaling down to fit within
    the limited resources available on embedded systems. Other standards have evolved
    entirely within the context of small, embedded devices, and interaction with the
    classic IT infrastructure is achieved through the modeling of TCP/IP protocols
    on top of low-power wireless technologies. In both cases, the research for convergence
    is dictated by the need for broader integration of small, inexpensive, self-powered
    devices into IoT services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准直接源自IT世界，并包括现有TCP/IP技术的改编，这些技术能够缩小规模以适应嵌入式系统有限的资源。其他标准完全在小型嵌入式设备的背景下发展起来，通过与经典IT基础设施的建模在低功耗无线技术之上实现TCP/IP协议的交互。在两种情况下，研究融合是由将小型、低成本、自供电设备更广泛集成到物联网服务中的需求所决定的。
- en: There is no such thing as a definitive one-size-fits-all solution to define
    network access for embedded systems. The differences in requirements across the
    embedded industry have encouraged the development of tailored MAC protocols and
    technologies, both standardized and proprietary, each of them tailored to respond
    to the need for specific features or a range of embedded systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统来说，没有一种万能的解决方案来定义网络访问。嵌入式行业的需求差异促使开发了定制的MAC协议和技术，这些协议和技术既有标准的也有专有的，每个都针对特定功能或一系列嵌入式系统的需求进行定制。
- en: In the following subsections, some of the most successful MAC technologies for
    machine-to-machine communication are described, taking into consideration the
    aspects related to the adoption of the technology and the modes of integration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子部分中，将描述一些最成功的机器对机器通信MAC技术，考虑到与采用该技术和集成模式相关的方面。
- en: Ethernet
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以太网
- en: Even though it may sound a little impractical for contexts in which the size
    of the whole system is comparable to an RJ-45 connector, Ethernet is still the
    most reliable and fastest channel of communication available to integrate into
    embedded systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于整个系统的大小与 RJ-45 连接器相当的情况可能听起来有点不切实际，以太网仍然是可集成到嵌入式系统中最可靠和最快的通信通道。
- en: Many Cortex-M microcontrollers are equipped with one Ethernet MAC controller,
    which must be integrated with an external PHY. Other link-layer protocols implement
    the same mechanism for link-layer addressing, consisting of a 14-byte preamble
    attached to each packet transmitted, indicating the source and destination link
    addresses and the type of payload contained in the packet being transported. The
    MAC addresses are rewritten every time a packet is routed toward an Ethernet-like
    interface by the TCP/IP stack so that they match the next link that the packet
    must cross in its journey toward its final destination.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Cortex-M 微控制器配备了一个以太网 MAC 控制器，该控制器必须与外部 PHY 集成。其他链路层协议实现了相同的链路层寻址机制，即在每个传输的包中附加一个
    14 字节的预头，指示源和目的链路地址以及正在传输的包中包含的有效载荷类型。每当数据包通过 TCP/IP 堆栈路由到类似以太网的接口时，MAC 地址都会被重写，以便与数据包在其前往最终目的地的旅程中必须穿越的下一个链路相匹配。
- en: Device drivers can activate filters to discard all the traffic that does not
    involve the host, which would otherwise impact the amount of background data communication
    unnecessarily being processed by the TCP/IP stack.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序可以激活过滤器，丢弃所有不涉及主机的流量，否则这些流量将不必要地影响 TCP/IP 堆栈处理的背景数据通信量。
- en: Wi-Fi
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wi-Fi
- en: Among all the possibilities in the wireless universe, 802.11 Wi-Fi is chosen
    for its high-speed, low-latency channel, and for the widest possible topological
    compatibility, including with personal computers and mobile devices. However,
    the power requirement of a Wi-Fi transceiver can sometimes be difficult to afford
    for low-power devices. The complexity of protocols and mechanisms to regulate
    media access requires a consistent amount of controlling software, which is often
    distributed in binary form, and thus impossible to debug and maintain without
    the support of the manufacturers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在无线宇宙的所有可能性中，802.11 Wi-Fi 被选中，因为它具有高速、低延迟的信道，以及最广泛可能的拓扑兼容性，包括与个人计算机和移动设备。然而，Wi-Fi
    收发器的功耗有时对于低功耗设备来说可能难以承受。调节媒体访问的协议和机制的复杂性需要一定量的控制软件，这些软件通常以二进制形式分发，因此没有制造商的支持，无法进行调试和维护。
- en: Wi-Fi provides large bandwidth and reasonably low latency and may implement
    authentication and encryption at the data-link level.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Wi-Fi 提供了大带宽和合理的低延迟，并且可以在数据链路层实现身份验证和加密。
- en: While it is technically possible to realize a local mesh network configuring
    the Wi-Fi transceivers to operate in an ad hoc mode, embedded systems equipped
    with 802.11 technology are mostly used to connect to existing infrastructures
    to interact with other portable devices and access the internet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在技术上可以通过配置 Wi-Fi 收发器以对等模式操作来实现本地网状网络，但配备 802.11 技术的嵌入式系统主要用于连接到现有基础设施，以与其他便携式设备交互并访问互联网。
- en: Several embedded low-cost platforms are available on the market, equipped with
    a TCP/IP stack and a built-in RTOS, which can be used as a standalone platform
    or integrated into complete systems to access wireless LAN, either as a station
    or to provide an access point.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上可提供几种嵌入式低成本平台，配备 TCP/IP 堆栈和内置的 RTOS，可以作为独立平台使用，或集成到完整的系统中，以作为工作站或提供接入点的方式访问无线局域网。
- en: Low-Rate Wireless Personal Area Networks (LR-WPANs)
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低速率无线个人区域网络 (LR-WPANs)
- en: Sensor mesh networks make extensive use of wireless technology to establish
    communication in a local geographical area. The 802.15.4 standard regulates the
    access to 2.4 GHz and sub-GHz frequencies to provide limited-range local area
    networks with a typical maximum bit rate of 250 Kbps, which can be accessed using
    low-cost, low-power transceivers. The media access is not based on infrastructure
    and supports contention resolution and collision detection at the MAC level, using
    a beaconing system. Each node can be addressed using 2 bytes, and the special
    address of `0xFFFF` is reserved for broadcast traffic to reach all the nodes in
    visibility. The maximum payload size for 802.15.4 frames is fixed to 127 bytes,
    and thus it is not possible to encapsulate full-size IP packets routed from an
    Ethernet or a wireless LAN link. Network protocol implementations that are capable
    of communicating through 802.15.4 interfaces are either application-specific,
    do not support IP networking, or offer fragmentation and compression mechanisms
    to transmit and receive each packet across multiple wireless frames.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器网状网络广泛使用无线技术，在局部地理区域内建立通信。802.15.4标准规定了2.4 GHz和亚GHz频段的接入，为有限范围的局域网提供典型最大比特率为250
    Kbps，可以使用低成本、低功耗的收发器进行访问。媒体接入不基于基础设施，并在MAC层支持争用解决和碰撞检测，使用信标系统。每个节点可以使用2个字节进行寻址，特殊地址`0xFFFF`保留用于广播流量，以到达所有可见节点。802.15.4帧的最大有效载荷大小固定为127字节，因此无法封装从以太网或无线局域网链路路由的全尺寸IP数据包。能够通过802.15.4接口进行通信的网络协议实现，要么是特定应用的，要么不支持IP网络，或者提供分片和压缩机制，以在多个无线帧之间传输和接收每个数据包。
- en: While not specifically designed for the IoT, and not directly compatible with
    classic IP infrastructures, there are multiple choices available to build networks
    on top of 802.15.4\. In fact, while the standard specifies the MAC protocol for
    exchanging frames among nodes that are in visibility, multiple link-layer technologies,
    standard and non-standard, have been developed to define networks on top of 802.15.4.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然LR-WPAN并不是专门为物联网设计的，也不直接与经典IP基础设施兼容，但有多种选择可以在802.15.4之上构建网络。事实上，虽然标准规定了在可见节点之间交换帧的MAC协议，但已经开发了多种链路层技术，包括标准和非标准技术，以在802.15.4之上定义网络。
- en: LR-WPAN industrial link-layer extensions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LR-WPAN工业链路层扩展
- en: Thanks to the flexibility of the transceivers, and the capability of transmitting
    and receiving 802.15.4 raw frames, it is relatively easy to implement networking
    protocols for LR-WPANs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了收发器的灵活性，以及传输和接收802.15.4原始帧的能力，实现LR-WPAN的网络协议相对容易。
- en: In the pre-IoT era, the process automation industry was the first to adopt the
    802.15.4 technology and had been searching for a standard protocol stack to enable
    compatibility among devices from different manufacturers for a long time. The
    Zigbee protocol stack endeavored to become a de facto, industry-imposed standard
    for 802.15.4 networking, with noticeable success, considering the proprietary,
    closed-source, and royalties applicable to its commercial use. In a parallel effort,
    the **International Society of Automation** (**ISA**) has created a proposal for
    the open standard ISA100.11a, which aims to define the guidelines for building
    networks based on 802.15.4 links to be used in industrial automation processes.
    Another industrial automation protocol, originally developed by a consortium of
    enterprises and then approved by the **International Electrotechnical Commission**
    (**IEC**) as a standard for industrial automation, is WirelessHART.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网时代之前，过程自动化行业是第一个采用802.15.4技术的，并且长期以来一直在寻找一个标准协议栈，以实现不同制造商设备之间的兼容性。Zigbee协议栈努力成为802.15.4网络的事实上、行业强制标准，考虑到其商业使用中适用的专有、封闭源代码和版税，取得了显著的成功。在平行努力中，**国际自动化学会**（**ISA**）提出了一份开放标准ISA100.11a的建议，旨在定义基于802.15.4链路构建网络的指南，用于工业自动化过程。另一个工业自动化协议，最初由一个企业联盟开发，然后由**国际电工委员会**（**IEC**）批准为工业自动化标准，是WirelessHART。
- en: Technologies such as Zigbee, ISA100.1, and WirelessHART define the entire protocol
    stack above 802.15.4, including network definition and transport mechanisms, providing
    custom address mechanisms and communication models, and exporting an API that
    can be used to integrate applications. From the perspective of the design of the
    distributed system, enabling internet connectivity for devices in a custom network,
    not implementing the IP stack, requires one or more devices to act as a gateway,
    rerouting and transforming each packet for the custom LR-WPAN protocol stack.
    The transformation procedure, however, violates the end-to-end semantics of TCP/IP
    communication, impacting various aspects of the communication, including end-to-end
    security.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Zigbee、ISA100.1和WirelessHART的技术定义了802.15.4之上的整个协议栈，包括网络定义和传输机制，提供定制地址机制和通信模型，并导出一个API，该API可用于集成应用程序。从分布式系统设计的角度来看，为定制网络中的设备启用互联网连接，不实现IP栈，需要一个或多个设备充当网关，重新路由和转换每个数据包以适应定制LR-WPAN协议栈。然而，这种转换过程违反了TCP/IP通信的端到端语义，影响了通信的各个方面，包括端到端安全。
- en: 6LoWPAN
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6LoWPAN
- en: 6LoWPAN, described in RFC 4944, is the IETF-standardized 802.15.4 link protocol
    that can transport IPv6 packets, and it is the established standard for IP-compatible
    LR-WPANs. 6LoWPAN makes it possible for embedded systems to access the internet
    using 802.15.4 interfaces, as long as the nodes implement TCP/IP networking, and
    the link layer provides mechanisms to transmit and receive full-size IP packets
    using short LR-WPAN frames. The content of the packet is fragmented and transmitted
    into consecutive transport units, and the network and transport headers are optionally
    compressed to reduce the transmission overhead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 6LoWPAN，在RFC 4944中描述，是IETF标准化的802.15.4链路协议，能够传输IPv6数据包，并且是IP兼容性LR-WPANs的既定标准。6LoWPAN使得嵌入式系统能够通过802.15.4接口访问互联网，只要节点实现了TCP/IP网络，并且链路层提供了使用短LR-WPAN帧传输和接收完整IP数据包的机制。数据包的内容被分割并传输到连续的传输单元中，网络和传输头部可以选压缩以减少传输开销。
- en: There is currently no IPv4 counterpart of the 6LoWPAN standard; however, IETF
    is evaluating proposals adopting a similar approach to enable legacy IPv4 connectivity
    for embedded nodes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有6LoWPAN标准的IPv4对应版本；然而，IETF正在评估采用类似方法的提案，以使嵌入式节点能够实现传统的IPv4连接。
- en: 6LoWPAN is part of several network stack implementations, and it is part of
    a recent attempt to create an industrial alliance, the Thread group, whose goal
    is to promote a fully IPv6, low-power mesh network technology based on open-standard
    protocols designed for the IoT. Multiple free and open source TCP/IP stacks and
    embedded operating systems support 6LoWPAN and can access 802.15.4 transceivers
    to provide the necessary link infrastructure to build IP networks based on the
    functionalities and the protocol implemented.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 6LoWPAN是多个网络栈实现的一部分，也是近期创建工业联盟Thread group的尝试之一，该联盟的目标是推广基于开放标准协议的完全IPv6、低功耗的网状网络技术，这些协议是为物联网设计的。多个免费和开源的TCP/IP栈以及嵌入式操作系统支持6LoWPAN，并且可以访问802.15.4收发器，提供构建基于功能和协议的IP网络的必要链路基础设施。
- en: Mesh networking can optionally be added to the link layer to provide a transparent
    bridge mechanism called mesh-under, where all the frames are repeated by the link
    layer to the remote corners of the mesh until their destination is reached.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网状网络可以可选地添加到链路层，以提供一种名为“网状下”的透明桥接机制，其中所有帧都由链路层重复发送到网状网络的远程角落，直到到达目的地。
- en: Because 6LoWPAN provides the infrastructure for building the network topology,
    mesh networking can be approached differently, using application-level protocols
    to update the routing tables at the IP level. These mechanisms, known as route-over
    mesh networking, are based on standardized dynamic routing mechanisms, and may
    also be used to extend the mesh network across different physical links.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于6LoWPAN为构建网络拓扑提供了基础设施，因此网状网络可以采用不同的方法，使用应用层协议在IP级别更新路由表。这些机制被称为“网状路由”，基于标准化的动态路由机制，也可以用于扩展跨越不同物理链路的网状网络。
- en: Bluetooth
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝牙
- en: Another machine-to-machine connectivity technology in constant evolution is
    Bluetooth. Its physical layer is based on 2.4 GHz communication to establish host/device
    communication or provide the infrastructure for PAN supporting multiple protocols,
    including TCP/IP communication. Thanks to its longtime success and its consequent
    wide adoption in the market of personal computers and portable devices, Bluetooth
    connectivity has started to gain popularity in the universe of embedded microcontrollers,
    mostly due to the recent evolution of the standard in the direction of lower power
    consumption.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不断发展的机器到机器连接技术是蓝牙。其物理层基于2.4 GHz通信来建立主机/设备通信或为支持多个协议（包括TCP/IP通信）的PAN提供基础设施。得益于其长期的成功及其在个人电脑和便携式设备市场中的广泛采用，蓝牙连接已经开始在嵌入式微控制器领域获得人气，这主要归因于最近标准在降低功耗方向上的发展。
- en: Initially designed as a wireless replacement for serial communication for devices
    at a close range, the *classic* Bluetooth technology has evolved to support integrated
    dedicated channels, including TCP/IP-capable network interfaces and dedicated
    audio and video streaming links.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最初设计为近距离设备的无线串行通信替代品，*经典*的蓝牙技术已经发展到支持集成专用通道，包括具有TCP/IP功能的网络接口和专用音频和视频流链接。
- en: A low-power variant of the protocol stack, introduced with version 4 of the
    standard definition, has been designed to limit energy consumption for embedded
    sensor nodes and introduces a new set of services. A sensor device may export
    a **Generic Attribute Profile** (**GATT**) that can be accessed by a client (usually
    a host machine) to establish communication with a device. When the transceiver
    on the target is inactive, it consumes a small amount of power, with it still
    remaining possible to discover its attribute and initiate a GATT transfer from
    a client. Bluetooth is mostly used nowadays for short-range communication; to
    access sensor nodes from personal computers and portable devices; to exchange
    multimedia content with remote audio devices such as speakers, headsets, and hands-free
    automotive voice interfaces; and in several healthcare applications, thanks to
    some profiles being specifically designed for this purpose.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 标准定义的第4版引入的协议栈的低功耗变体，旨在限制嵌入式传感器节点的能耗，并引入了一组新的服务。传感器设备可以导出**通用属性配置文件**（**GATT**），客户端（通常为主机机器）可以通过它来建立与设备的通信。当目标设备上的收发器处于非活动状态时，它消耗少量电力，同时仍然可以从客户端发现其属性并启动GATT传输。蓝牙现在主要用于短距离通信；从个人电脑和便携式设备访问传感器节点；与远程音频设备（如扬声器、耳机和无绳汽车语音接口）交换多媒体内容；以及在几个医疗保健应用中，因为一些配置文件专门为此目的而设计。
- en: Mobile networks
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动网络
- en: Connecting remote devices that have no fixed infrastructure available in their
    surroundings has been made possible using the same technology that portable devices
    use to access the internet over mobile networks, such as GSM/GPRS, 3G, and LTE.
    The increasing complexity, cost, and energy requirements characterizing the devices
    that access broadband mobile connectivity have increased the impact of integrating
    this sort of network communication into microcontroller-based embedded devices.
    Mobile networks support TCP/IP protocols natively and provide direct connectivity
    to the internet, or in some cases, to restricted networks provided by the access
    infrastructure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与便携式设备通过移动网络（如GSM/GPRS、3G和LTE）访问互联网相同的技术，现在可以将没有固定基础设施的远程设备连接起来。接入宽带移动连接的设备所具有的日益增长的复杂性、成本和能源需求，使得将此类网络通信集成到基于微控制器的嵌入式设备中的影响日益增加。移动网络原生支持TCP/IP协议，并提供直接连接到互联网，或在某些情况下，连接到接入基础设施提供的受限网络。
- en: Although still popular in some specific markets, such as automotive and railway,
    broadband network access profiles are usually overkill for transferring a small
    amount of information from remote sensor devices, while simpler modems to access
    older, narrow-bandwidth technologies are slowly disappearing from the market.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些特定市场（如汽车和铁路）中仍然很受欢迎，但宽带网络接入配置文件通常对于从远程传感器设备传输少量信息来说过于冗余，而用于访问较老、窄带宽技术的简单调制解调器正逐渐从市场上消失。
- en: While mobile network technologies evolve, focusing on the requirements of the
    mobile phone market, embedded device architects are in search of new technologies
    that better match the needs of distributed IoT systems. New technologies better
    meet the embedded market goals and evolution toward low-power, cost-effective,
    long-distance communication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动网络技术的发展，专注于手机市场的需求，嵌入式设备架构师正在寻找更适合分布式物联网系统需求的新技术。新技术更好地满足嵌入式市场的目标，并朝着低功耗、低成本、长距离通信的方向发展。
- en: Low-Power Wide Area Networks (LPWANs)
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 低功耗广域网（LPWANs）
- en: LWPANs are a family of emerging technologies that fill the market gap for cost-effective,
    low-power, long-distance, narrow-band communication. As for LR-WPANs, different
    industrial alliances have been formed in an attempt to conquer the market, and
    in some cases, establish a standard protocol stack for universal LPWAN networks.
    This process has led to healthy competition on features, costs, and power-saving
    features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: LWPANs是一系列新兴技术，填补了市场对低成本、低功耗、长距离、窄带通信的需求。至于LR-WPANs，不同的工业联盟已经形成，试图征服市场，并在某些情况下，为通用LPWAN网络建立标准协议栈。这个过程导致了在功能、成本和节能特性方面的健康竞争。
- en: LPWAN technologies are usually based on sub-GHz physical channels, but use different
    radio settings, allowing for an increased range. Devices can communicate with
    each other over the air, and, in some cases, use an infrastructure to increase
    coverage, even across thousands of kilometers, when in visibility of a base station.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LPWAN技术通常基于亚GHz的物理信道，但使用不同的无线电设置，从而增加了通信范围。设备可以通过空中相互通信，在某些情况下，使用基础设施来增加覆盖范围，甚至在基站可视范围内跨越数千公里。
- en: 'The most noticeable emerging technologies in this field include the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域最引人注目的新兴技术包括以下内容：
- en: '**LoRa**/**LoRaWAN**: Based on patented wireless radio access mechanisms and
    a fully proprietary protocol stack, this technology provides long-distance communication
    with a high bit rate compared to similar technologies. While it offers several
    interesting features, such as local node-to-node communication in the absence
    of infrastructure, the closed-protocol approach makes this approach less appealing
    for the embedded market, and less likely to keep its place in the LPWAN competition
    eventually in favor of more open standards.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoRa**/**LoRaWAN**：基于专利的无线接入机制和完全专有的协议栈，这项技术提供了与类似技术相比具有高比特率的远程通信。虽然它提供了几个有趣的功能，例如在无基础设施的情况下进行本地节点到节点的通信，但封闭的协议方法使得这种方法对嵌入式市场不太吸引人，并且不太可能最终在LPWAN竞争中保持其位置，而是更倾向于更开放的标准。'
- en: '**Sigfox**: This ultra-narrow-band radio technology requires an infrastructure
    to operate, and offers a particularly low bit rate on very long ranges. Regulated
    infrastructure access allows a limited number of bytes to be transferred from
    or to a node every day, and the payload of the messages is fixed at 12 bytes.
    While the physical layer implementation is proprietary, the protocol stack is
    distributed in source code form. Radio regulations in some countries are still
    an open point, though, and may impact the development of this technology worldwide,
    despite its considerable success in the European market.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sigfox**：这种超窄带无线电技术需要基础设施才能运行，并在非常长的范围内提供特别低的比特率。受监管的基础设施接入允许每天从或向节点传输有限数量的字节，并且消息的有效负载固定为12字节。尽管物理层实现是专有的，但协议栈以源代码形式分发。然而，一些国家的无线电法规仍然是一个开放的问题，可能会影响这项技术在全球范围内的开发，尽管它在欧洲市场取得了相当大的成功。'
- en: '**Weightless**: Another technology based on ultra-narrow-band, Weightless is
    a fully open standard for LPWAN operating in the sub-GHz range. Similar to Sigfox
    in terms of range and performance, it provides an improved security model as an
    alternative to the classic pre-shared keys deploying mechanisms, allowing for
    over-the-air security key negotiation mechanisms.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Weightless**：另一种基于超窄带的科技，Weightless是LPWAN在亚GHz范围内运行的完全开放标准。在范围和性能方面与Sigfox相似，它提供了一个改进的安全模型，作为经典预共享密钥部署机制的替代方案，允许通过空中安全密钥协商机制。'
- en: '**DASH7**: The youngest of the technologies described here is based on a fully
    open design. The source code for the entire lightweight protocol stack is provided
    by the DASH7 alliance, which allows for easier integration of the technology into
    embedded systems. This protocol stack is designed to provide flexibility while
    designing distributed systems, due to the multiple choices in defining the network
    topology.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DASH7**：这里描述的技术中最年轻的是基于完全开放的设计。整个轻量级协议栈的源代码由DASH7联盟提供，这使得该技术更容易集成到嵌入式系统中。这个协议栈旨在在设计分布式系统时提供灵活性，因为定义网络拓扑结构有多种选择。'
- en: LPWAN protocols are not directly compatible with IP and require one of the nodes
    on the network to generate TCP/IP traffic based on the long-range communication
    data acquired from the nodes. The sporadic, low-bit rate characteristics of the
    network traffic make these technologies operate in their own field, and require
    nodes capable of rerouting data from the nodes when the architecture of the distributed
    systems foresees accessing remote nodes on the internet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: LPWAN协议与IP不直接兼容，需要网络中的一个节点根据从节点获取的远程通信数据生成TCP/IP流量。网络流量的间歇性和低比特率特性使这些技术在其自己的领域内运行，并需要节点在分布式系统架构预见访问互联网上的远程节点时能够重新路由数据。
- en: Selecting the appropriate network interfaces
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的网络接口
- en: Depending on the use case, each embedded system may benefit from the communication
    facilities offered by the technologies described in this section. Due to the high
    specialization of some embedded devices, a design tailored to specific use cases
    may even go beyond this classification and use technologies that are designed
    for one specific use case. Wireless communication is impossible in some cases,
    due to emission regulations in some environments, and when the media is not capable
    of transporting radio waves reliably, such as underwater or through the human
    body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例，每个嵌入式系统都可能从本节中描述的技术提供的通信设施中受益。由于某些嵌入式设备的高度专业化，针对特定用例的设计甚至可能超出这种分类，并使用为特定用例设计的科技。在某些情况下，由于某些环境中的辐射法规或媒体无法可靠地传输无线电波（如水下或通过人体），无线通信是不可能的。
- en: Submarines may communicate via specific transceivers, using sound waves to represent
    the data. Other widespread technologies are available for wired communication
    as well. Power line communication allows existing wires to be reused to refit
    older devices and brings local network connectivity, extending Ethernet or serial
    interfaces buses using high-frequency modulation that does not impact the original
    purpose of the wires used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 潜艇可能通过特定的收发器进行通信，使用声波来表示数据。同时，也有其他广泛的技术可用于有线通信。电力线通信允许重用现有电线来更新旧设备，并带来本地网络连接，通过使用不会影响电线原有用途的高频调制来扩展以太网或串行接口总线。
- en: 'As it turns out, embedded devices have a broad range of possibilities when
    it comes to connectivity. The optimal choice always depends on the specific use
    case and the resources available on the system to implement protocols and standards
    required to reach the other endpoints of the communication. When selecting a communication
    technology, there might be several aspects to take into account:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，嵌入式设备在连接性方面有广泛的可能性。最佳选择始终取决于具体的用例和系统上可用的资源，这些资源用于实现达到通信另一端所需的协议和标准。在选择通信技术时，可能需要考虑几个方面：
- en: The range of communication
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信范围
- en: The bit rate required for data transfer
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输所需的比特率
- en: The total cost of ownership (transceiver price, integration effort, and service
    costs)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总拥有成本（收发器价格、集成努力和服务成本）
- en: Media-specific limitations, such as any latency introduced by the transceiver
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体特定的限制，例如由收发器引入的任何延迟
- en: The impact of RF interference on the hardware design requirements
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射频干扰对硬件设计要求的影响
- en: The maximum transfer unit
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大传输单元
- en: Power consumption and energy footprint
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功耗和能源足迹
- en: Protocols or standards supported for compatibility with third-party systems
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持与第三方系统兼容的协议或标准
- en: Compliance with Internet protocols for integration in IoT systems
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合互联网协议以集成到物联网系统中
- en: Topology flexibility, dynamic routing, and mesh network feasibility
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拓扑的灵活性、动态路由和网状网络可行性
- en: The security model
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全模型
- en: The resources required to implement drivers and protocols for a specific technology
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现特定技术驱动程序和协议所需资源
- en: The use of open standards to avoid lock-in for long-lived projects
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开放标准以避免长期项目的锁定
- en: Each and every technology for connected devices offers a different take on how
    these aspects are addressed in its intrinsic design, also depending on whether
    the technology has been borrowed from a different context, such as Ethernet or
    GSM/LTE, or has been designed with low-power embedded systems in mind, as in LR-WPAN
    and LWPAN protocols.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 连接设备的技术每一种都提供了不同的方法来处理其内在设计中这些方面的解决方式，也取决于技术是否是从不同的上下文中借用的，例如以太网或GSM/LTE，或者是否是为低功耗嵌入式系统设计的，如LR-WPAN和LWPAN协议。
- en: Selecting the appropriate communication channels when designing distributed
    systems is an operation that requires strict collaboration between hardware and
    software design. Creating connected devices involves one more level of complexity,
    especially in the low-power domain.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计分布式系统时选择适当的通信通道是一项需要硬件和软件设计严格协作的操作。创建连接设备涉及一个更复杂的层次，尤其是在低功耗领域。
- en: The next section focuses on how the implementation of Internet protocols can
    be adapted to scale down to embedded devices to produce network endpoints that
    operate within standards and are rich in features. TCP/IP stack implementation
    can be extended and configured to meet the requirements of an IoT-distributed
    system. Cases in which non-IP protocols are translated by a border gateway to
    integrate non-standard communication in IoT systems (edge gateways) are not covered
    here, as they often involve larger dedicated systems with multiple network interfaces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将重点介绍如何实现互联网协议以适应缩小到嵌入式设备，以产生在标准内操作且功能丰富的网络端点。TCP/IP堆栈实现可以扩展和配置以满足物联网分布式系统的需求。这里不涵盖将非IP协议通过边界网关翻译以在物联网系统中集成非标准通信的情况（边缘网关），因为这些通常涉及具有多个网络接口的更大专用系统。
- en: As we have observed, the embedded industry is specialized enough to operate
    at the edge of the standards, but a new research trend is bringing TCP/IP communication
    back to its original position as the established standard for network communication,
    due to the increasing influence of the existing IT infrastructure in distributed
    systems, including small, low-power, cost-effective embedded systems. This has
    also recently extended in the market to standard security functionality, increasing
    the presence of secure end-to-end communication protocols such as TLS and DTLS
    on embedded systems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所观察到的，嵌入式行业已经足够专业化，能够在标准边缘进行操作，但一个新的研究趋势正在将TCP/IP通信重新定位回其作为网络通信既定标准的原始位置，这是由于现有IT基础设施在分布式系统中的影响力日益增加，包括小型、低功耗、成本效益的嵌入式系统。这也最近在市场上扩展到标准安全功能，增加了在嵌入式系统中安全端到端通信协议（如TLS和DTLS）的存在。
- en: The Internet protocols
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议
- en: Standardized at the beginning of the 1980s, the IP stack, mostly referred to
    nowadays as TCP/IP, is a family of network, transport, and application protocols
    providing standard communication over a wide range of technologies and interfaces.
    In the upcoming subsections, we will discuss the integration of these standard
    protocols into embedded systems, describe the interfaces that embedded applications
    use to communicate with remote endpoints, and learn how to interact with the different
    layers of the stack, from the network interfaces up to the socket abstraction
    to establish connections or connectionless sessions with a remote peer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代初标准化，现在通常被称为TCP/IP的IP栈，是一组网络、传输和应用协议，提供在广泛的技术和接口上提供标准通信。在接下来的小节中，我们将讨论这些标准协议如何集成到嵌入式系统中，描述嵌入式应用程序用于与远程端点通信的接口，以及如何与堆栈的不同层进行交互，从网络接口到套接字抽象，以建立与远程对等方的连接或无连接会话。
- en: Standard protocols, custom implementations
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准协议，定制实现
- en: Designing distributed communication using non-standard protocol stacks is, in
    almost all cases, not worth the effort required to reinvent state-of-the-art technology.
    TCP/IP standards have been the subject of extensive research for many decades,
    and have been the main building block for the internet as we know it today, integrating
    billions of heterogeneous devices. Equipping an embedded system with TCP/IP capabilities
    is no longer a pioneering task, as several open source implementations exist,
    and they can easily be integrated into small embedded systems, as long as they
    can access physical communication channels providing data transfer capabilities
    between two or more endpoints.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非标准协议栈设计分布式通信，在几乎所有情况下，都不值得付出重新发明最先进技术的努力。TCP/IP标准已经经过了数十年的广泛研究，并且已经成为我们今天所知道的互联网的主要构建块，整合了数十亿种异构设备。为嵌入式系统配备TCP/IP功能不再是开创性的任务，因为存在几个开源实现，并且它们可以轻松地集成到小型嵌入式系统中，只要它们可以访问提供两个或更多端点之间数据传输能力的物理通信通道。
- en: Sockets are the standard way to access transport-layer communication from network
    applications. The Berkeley socket model, later standardized by POSIX, includes
    a naming standard for functions and components and the behavior in a UNIX operating
    system. If the TCP/IP stack is integrated with the operating system, the scheduler
    can provide a mechanism to suspend the caller while waiting for a specific input,
    and the socket call API can be implemented to match POSIX specifications. In a
    bare-metal event-based application, however, synchronization with the sockets
    is done using callbacks, in order to follow the event-based model of the main
    loop. For this reason, writing applications that interact with network protocols
    is slightly different in terms of the APIs and paradigms. In a non-blocking network
    application within a single thread, no operation should keep the CPU busy while
    waiting for events, except the main loop function itself. Socket function calls
    make no exception, requiring a mechanism to initiate an operation, register a
    callback function to handle the end of it, and then immediately return to the
    main loop.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是访问网络应用中传输层通信的标准方式。伯克利套接字模型，后来由POSIX标准化，包括函数和组件的命名标准以及UNIX操作系统的行为。如果TCP/IP栈与操作系统集成，调度器可以提供一个机制在等待特定输入时挂起调用者，并且可以实现对POSIX规范的套接字调用API的实现。然而，在裸机事件驱动应用程序中，使用回调与套接字同步，以遵循主循环的事件驱动模型。因此，编写与网络协议交互的应用程序在API和范例方面略有不同。在单个线程的非阻塞网络应用程序中，除了主循环函数本身外，没有任何操作应该在等待事件时使CPU忙碌。套接字函数调用也不例外，需要一种机制来启动操作，注册一个处理操作结束的回调函数，然后立即返回主循环。
- en: The TCP/IP stack
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP栈
- en: A modern TCP/IP stack is perhaps the most fundamental part of a distributed
    embedded system. The reliability of the communications depends on how accurately
    the standard protocols are implemented, and the security of the services running
    on the device may be compromised by defects hidden in the TCP/IP stack implementation,
    its interface drivers, and the glue code to provide socket abstractions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现代TCP/IP栈可能是分布式嵌入式系统最基本的部分。通信的可靠性取决于标准协议实现得有多准确，而设备上运行的服务安全性可能会因TCP/IP栈实现、其接口驱动程序以及提供套接字抽象的粘合代码中的缺陷而受到损害。
- en: The most popular open source TCP/IP library for embedded devices is the **lightweight
    IP** stack, best known as **lwIP**. Integrated with many real-time OSes and even
    distributed in a bundle by hardware manufacturers, lwIP provides the IPv4 and
    IPv6 network, UDP and TCP socket communication, DNS and DHCP client, and a rich
    bundle of application-layer protocols that can be integrated into an embedded
    system using just a few tens of KBs of memory. Despite being tailored for small
    microcontrollers, the resources required by a fully featured stack, such as lwIP,
    are out of range for some smaller devices, including most sensor processing targets
    with ultra-low power characteristics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的嵌入式设备开源TCP/IP库是**轻量级IP**栈，最好称为**lwIP**。它集成了许多实时操作系统，甚至由硬件制造商捆绑分发，lwIP提供了IPv4和IPv6网络、UDP和TCP套接字通信、DNS和DHCP客户端，以及可以仅使用几十KB内存集成到嵌入式系统中的丰富应用层协议。尽管为小型微控制器量身定制，但像lwIP这样的功能齐全的栈所需资源对于一些较小的设备来说超出了范围，包括大多数具有超低功耗特性的传感器处理目标。
- en: '**Micro IP**, mostly referred to as **uIP**, is a minimalistic TCP/IP implementation
    based on the unusual but brilliant intuition of processing one single buffer at
    a time. Not having to allocate multiple buffers in memory keeps the amount of
    RAM needed for TCP/IP communication as limited as possible, and reduces the complexity
    of the implementation of TCP and other protocols, and, as a result of this, the
    code size of the entire stack. uIP is not designed to scale up to a higher bit
    rate or for implementing advanced features, but it is sometimes the best compromise
    to connect nodes with very limited resources, mostly to LR-WPAN networks.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**微 IP**，通常称为 **uIP**，是一个基于处理单个缓冲区一次的非凡但绝妙的直觉的最小化 TCP/IP 实现。不需要在内存中分配多个缓冲区，可以将
    TCP/IP 通信所需的 RAM 量限制在尽可能小的范围内，并简化 TCP 和其他协议的实现复杂性，从而减少了整个堆栈的代码大小。uIP 并未设计用于扩展到更高的比特率或实现高级功能，但有时它是连接资源非常有限的节点（主要是
    LR-WPAN 网络）的最佳折衷方案。'
- en: picoTCP is a free software TCP/IP stack with a more recent history. It shares
    similar resource footprints and features lists with lwIP, but has a different
    modular design and a stronger focus on IoT protocols, providing dynamic routing,
    IP filtering, and NAT capabilities. With native support for 6LoWPAN over 802.15.4
    devices, picoTCP can be used to build mesh networks, using either the mesh-under
    capabilities in 6LoWPAN, or a more classic route-over approach, using dynamic
    routing protocols, such as OLSR and AODV, provided in the modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: picoTCP 是一个具有较近历史的免费软件 TCP/IP 堆栈。它与 lwIP 具有相似的资源占用和功能列表，但具有不同的模块化设计和对物联网协议的更强关注，提供动态路由、IP
    过滤和 NAT 功能。通过在 802.15.4 设备上对 6LoWPAN 的原生支持，picoTCP 可以用于构建网状网络，既可以利用 6LoWPAN 中的网状功能，也可以使用更经典的通过路由协议（如
    OLSR 和 AODV）提供的动态路由方法。
- en: Other implementations exist for both open source and proprietary TCP/IP stacks,
    which can be integrated into both bare-metal applications and embedded operating
    systems, often providing similar APIs for integrating interface drivers and interacting
    with the system to provide socket communication to higher-level applications.
    An embedded TCP/IP stack is connected to network devices through a device driver,
    providing a function to send frames to the network, and capable of delivering
    the received packets using an entry point function, which the TCP/IP stack uses
    to take the packet in charge. The packets that are currently being handled by
    the TCP/IP stack may require asynchronous operations, so the application, or the
    OS, must ensure that the stack loop function is called periodically so that it
    can process the packets in the buffers. Finally, a socket interface is provided
    by the transport layer for the application to create and use the socket to communicate
    with remote endpoints.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源和专有 TCP/IP 堆栈，都存在其他实现，这些实现可以集成到裸机应用程序和嵌入式操作系统中，通常提供类似的 API 以集成接口驱动程序并与系统交互，以向高级应用程序提供套接字通信。嵌入式
    TCP/IP 堆栈通过设备驱动程序连接到网络设备，提供发送帧到网络的功能，并能够使用入口点函数交付接收到的数据包，该函数是 TCP/IP 堆栈用来接管数据包的。当前由
    TCP/IP 堆栈处理的数据包可能需要异步操作，因此应用程序或操作系统必须确保定期调用堆栈循环函数，以便它可以处理缓冲区中的数据包。最后，传输层为应用程序提供套接字接口，以便创建和使用套接字与远程端点通信。
- en: Network device drivers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络设备驱动程序
- en: In order to integrate a driver for a network interface, the TCP/IP stack exposes
    an interface to its lowest layers, sending and receiving buffers containing frames
    or packets. If the device supports the link-layer Ethernet address, TCP/IP stacks
    must connect an additional component to deal with Ethernet frames, and activate
    the neighbor discovery protocols to find the MAC address of the receiving device
    before initiating any IP communication.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了集成网络接口的驱动程序，TCP/IP 堆栈向其底层暴露了一个接口，发送和接收包含帧或数据包的缓冲区。如果设备支持链路层以太网地址，TCP/IP 堆栈必须连接一个额外的组件来处理以太网帧，并激活邻居发现协议，在开始任何
    IP 通信之前找到接收设备的 MAC 地址。
- en: 'lwIP provides a `netif` structure, describing a network interface, which must
    be allocated by the driver code, but is then initialized automatically by the
    stack using the `netif_add` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: lwIP 提供了一个 `netif` 结构，描述了一个网络接口，该结构必须由驱动程序代码分配，但随后由堆栈使用 `netif_add` 函数自动初始化：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ipaddr`, `netmask`, and `gw` arguments can be used to set an initial IPv4
    configuration for the link created through this interface. lwIP supports one IPv4
    address and three IPv6 addresses per interface, but all of them can be reconfigured
    at a later stage by accessing the relative fields in the `netif` structure. The
    IP address can be configured either using a static IP address or a mechanism to
    automatically assign it, such as DHCP negotiation, or deriving it from link-local
    addresses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipaddr`、`netmask`和`gw`参数可用于设置通过此接口创建的链路的初始IPv4配置。lwIP支持每个接口一个IPv4地址和三个IPv6地址，但所有这些都可以在稍后通过访问`netif`结构中的相关字段进行重新配置。IP地址可以通过静态IP地址或自动分配机制进行配置，例如DHCP协商，或从链路本地地址推导。'
- en: The `state` variable is a user-defined pointer that can create an association
    between the net device and a private field that can be accessed using the `netif->state`
    pointer in the driver code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`state`变量是一个用户定义的指针，可以在驱动程序代码中使用`netif->state`指针创建网络设备和私有字段之间的关联。'
- en: The function pointer provided as the `init` argument is called during the initialization
    of the stack, with the same `netif` pointer, and it must be used by the driver
    to initialize the remaining fields for the `netif` device.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`init`参数的函数指针在栈初始化期间被调用，使用相同的`netif`指针，并且驱动程序必须使用它来初始化`netif`设备的剩余字段。
- en: The function pointer provided through the input argument describes the internal
    action that the stack has to perform when it receives a packet from the network.
    If the device communicates using Ethernet frames, the `ethernet_input` function
    should be supplied to indicate that additional processing for the Ethernet frame
    would be required before parsing the frame content and that the network supports
    neighbor discovery protocols to associate IP addresses to MAC addresses before
    transmitting the data. If the driver is handling naked IP packets instead, the
    receiving function to associate is `ip_input`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入参数提供的函数指针描述了栈在从网络接收到数据包时必须执行的内联操作。如果设备使用以太网帧进行通信，则应提供`ethernet_input`函数以指示在解析帧内容之前需要为以太网帧进行额外处理，并且网络支持邻居发现协议，在传输数据之前将IP地址关联到MAC地址。如果驱动程序处理裸IP数据包，则接收函数应为`ip_input`。
- en: 'The device driver initialization is finalized in the `init` function, which
    must also assign a value to other important fields in the `netif` structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序初始化在`init`函数中完成，该函数还必须为`netif`结构中的其他重要字段分配值：
- en: '`hw_addr`: Containing the MAC address for the Ethernet device, if supported.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw_addr`：包含以太网设备的MAC地址，如果支持的话。'
- en: '`mtu`: The maximum transfer unit size allowed by this interface.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mtu`：此接口允许的最大传输单元大小。'
- en: '`name`/`num`: For device identification on the system.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`/`num`：用于系统中的设备标识。'
- en: '`output`: This function pointer is called by the stack to append a custom link
    header to the IP packet ready for transmission. For Ethernet devices, this should
    point to `etharp_output` to trigger neighbor discovery mechanisms.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：此函数指针由栈调用，用于向准备传输的IP数据包追加自定义链路头。对于以太网设备，此指针应指向`etharp_output`以触发邻居发现机制。'
- en: '`link_output`: This function pointer is called by the stack when a buffer is
    ready to be transmitted.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_output`：当缓冲区准备好传输时，栈调用此函数指针。'
- en: After the link has been marked as `up` by calling `netif_up`, the device driver
    can call the input function upon the reception of new packets, and the stack itself
    will call the `output`/`link_output` functions to interact with the driver.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过调用`netif_up`将链路标记为`up`之后，设备驱动程序可以在接收到新数据包时调用输入函数，而栈本身将调用`output`/`link_output`函数与驱动程序进行交互。
- en: 'picoTCP exports a similar interface to implement device drivers, but it supports
    multiple addresses per interface, so the IP configuration is separate from the
    device drivers. Each device has a list of associated IPv4 and IPv6 links, each
    with its own IP configuration, to implement multi-homed services. A device driver
    structure in picoTCP must begin with a physical entry of the `pico_device` structure
    as its first field. This way, both structures point to the same address and the
    device can maintain its own private fields at the end of the `pico_device` structure.
    To initialize the device, the structure is allocated in the driver, and `pico_device_init`
    is called:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: picoTCP 导出类似的接口以实现设备驱动程序，但它支持每个接口多个地址，因此 IP 配置与设备驱动程序分开。每个设备都有一个与其关联的 IPv4 和
    IPv6 链接列表，每个链接都有自己的 IP 配置，以实现多宿主服务。在 picoTCP 中，设备驱动程序结构必须以 `pico_device` 结构的物理条目作为其第一个字段开始。这样，两个结构都指向相同的地址，设备可以在
    `pico_device` 结构的末尾维护自己的私有字段。为了初始化设备，结构在驱动程序中分配，并调用 `pico_device_init`：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The three arguments required are the pre-allocated device structure, a name
    used for identification within the system, and the Ethernet MAC address, if present.
    If the MAC is null, the stack bypasses the Ethernet protocol, and all the traffic
    handled by the driver is naked IP packets with no link-layer extensions. The driver
    must implement the `send` function that is used by the stack to deliver the frames
    or packets to be transmitted by the interface, and input is managed through the
    `pico_stack_recv` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的三个参数是预分配的设备结构、用于系统内识别的名称，以及如果有的话，以太网 MAC 地址。如果 MAC 为空，堆栈将绕过以太网协议，并且由驱动程序处理的全部流量都是没有链路层扩展的裸
    IP 数据包。驱动程序必须实现 `send` 函数，该函数由堆栈使用，以将接口要传输的帧或数据包发送出去，输入通过 `pico_stack_recv` 函数进行管理：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The device is passed again as an argument so that the stack automatically recognizes
    whether the interface is receiving an Ethernet frame or a raw IP packet with no
    headers, and reacts accordingly. IP addresses can be configured using `pico_ipv4_link_add`
    and `pico_ipv6_link_add`, and the routing table is accessed through its API to
    add gateways and static routes to specific networks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 设备再次作为参数传递，以便堆栈自动识别接口是接收以太网帧还是没有头部的原始 IP 数据包，并相应地做出反应。可以使用 `pico_ipv4_link_add`
    和 `pico_ipv6_link_add` 配置 IP 地址，并通过其 API 访问路由表以添加网关和特定网络的静态路由。
- en: Running the TCP/IP stack
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 TCP/IP 堆栈
- en: To integrate a network stack, the system must generally provide a few commodities,
    such as timekeeping and heap-memory management. All the system features required
    by the stack are associated at compile time using a system-specific configuration
    header, which associates functions and global values accordingly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成网络堆栈，系统通常必须提供一些商品，例如时间管理和堆内存管理。堆栈所需的全部系统功能在编译时通过系统特定的配置头文件关联，该文件相应地关联函数和全局值。
- en: Depending on the characteristics of the physical channels and the throughput
    to achieve, a TCP/IP stack may become very demanding in terms of heap memory used,
    allocating space for new incoming buffers until the upper layers can process them.
    Assigning separate memory pools to TCP/IP stack operations might help in some
    designs to keep the memory usage of the stack under control by placing thresholds
    and hard limits without impacting the functionality of the other components on
    the system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据物理通道的特性以及要达到的吞吐量，TCP/IP 堆栈在堆内存的使用上可能会变得非常苛刻，直到上层能够处理它们，它都会分配空间给新的接收缓冲区。在某些设计中，为
    TCP/IP 堆栈操作分配单独的内存池可能有助于通过设置阈值和硬限制来控制堆栈的内存使用，而不会影响系统上其他组件的功能。
- en: Most libraries implement their own internal timers using a monotonic counter,
    provided by the system and increased independently by another component in the
    system. The time tracking value can be increased using the `SysTick` interrupt,
    providing an acceptable accuracy at which the stack can organize timed operations
    for the protocols. For lwIP, it is sufficient to export a global variable called
    `lwip_sys_now`, which contains the time elapsed from booting, expressed in milliseconds.
    picoTCP needs to export a macro or an inline function called `PICO_TIME_MS` returning
    the same value. Both stacks expect that the main loop of the application provides
    recurring entry points, by calling a function in the core API, required to manage
    the internal states of the system protocols.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数库使用系统提供的单调计数器来实现自己的内部计时器，该计数器由系统提供并由系统中的另一个组件独立增加。可以通过使用`SysTick`中断来增加时间跟踪值，从而提供足够的精度，以便堆栈可以为协议组织定时操作。对于lwIP，只需导出一个名为`lwip_sys_now`的全局变量即可，该变量包含自启动以来经过的时间，以毫秒为单位。picoTCP需要导出一个名为`PICO_TIME_MS`的宏或内联函数，返回相同的值。这两个堆栈都期望应用程序的主循环通过调用核心API中的函数，提供重复的入口点，以管理系统协议的内部状态。
- en: To check whether any of the pending timers have expired, the system calls `sys_check_timeouts`
    in lwIP, or `pico_stack_tick` in picoTCP, from the main event loop or a dedicated
    thread when running within an OS. The interval between consecutive calls may impact
    timer accuracy, and, in general, should not be longer than a few milliseconds
    to ensure that the network stack is responsive to timed events.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否有任何挂起的计时器已过期，系统在lwIP中调用`sys_check_timeouts`，或在picoTCP中调用`pico_stack_tick`，从主事件循环或当在操作系统内运行时，调用一个专用线程。连续调用之间的间隔可能会影响计时器的精度，通常不应超过几毫秒，以确保网络堆栈对定时事件做出响应。
- en: Network interfaces must also be polled for input from the network, either continuously
    or through an appropriate interrupt handling implemented in the system. When new
    data is available, the device drivers allocate new buffers and initiate the processing
    by calling the input functions of the data link or the network layer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网络接口还必须轮询来自网络的输入，无论是连续的还是通过系统实现的适当中断处理。当有新数据可用时，设备驱动程序分配新的缓冲区，并通过调用数据链路或网络层的输入函数来启动处理。
- en: 'A typical bare-metal application using lwIP begins by performing all the initialization
    steps for the stack and the device driver. The structure for the network interface
    is allocated in the main function stack and initialized with a static IPv4 configuration.
    The following code assumes that the device driver exports a function called `driver_netdev_create`,
    which populates the interface-specific fields and callbacks:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lwIP的典型裸机应用程序首先执行堆栈和设备驱动程序的初始化步骤。网络接口的结构在主函数堆栈中分配，并使用静态IPv4配置初始化。以下代码假设设备驱动程序导出一个名为`driver_netdev_create`的函数，该函数填充接口特定的字段和回调：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The network interface is then activated in the TCP/IP stack:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在TCP/IP堆栈中激活网络接口：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before entering the main loop, the application initializes the communication
    by creating and configuring the sockets, and associating the callbacks:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入主循环之前，应用程序通过创建和配置套接字以及关联回调来初始化通信：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main loop relies on the driver to export a function called `driver_netdev_poll`
    in this case, which is the function where the driver calls `ethernet_input` whenever
    a new frame is received. Finally, `sys_check_timeouts` is called so that lwIP
    can keep track of the pending timers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，主循环依赖于驱动程序导出一个名为`driver_netdev_poll`的函数，这是驱动程序在接收到新帧时调用`ethernet_input`的函数。最后，调用`sys_check_timeouts`，以便lwIP可以跟踪挂起的计时器：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A similar procedure is expected from bare-metal applications running picoTCP.
    The initialization of the device driver is independent of the stack, and the driver
    is expected to call `pico_device_init` on a `pico_device` struct contained in
    the custom `driver_device` type as the mandatory first member. The only function
    exported by the driver is `driver_netdev_create`, which also associates its specific
    network-polling function pointer, which will be called by `pico_stack_tick`. The
    stack expects a callback to `pico_stack_recv` whenever the `poll` function of
    the driver has new incoming packets to process:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 预期裸机应用程序运行picoTCP时会有类似的流程。设备驱动程序的初始化与堆栈无关，并且驱动程序预期会在包含在自定义`driver_device`类型的`pico_device`结构中作为强制第一个成员调用`pico_device_init`。驱动程序仅导出`driver_netdev_create`函数，该函数还关联其特定的网络轮询函数指针，该指针将由`pico_stack_tick`调用。堆栈期望在驱动程序的`poll`函数有新到达的待处理数据包时调用`pico_stack_recv`回调：
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The IPv4 address configuration is performed by accessing the API of the IPv4
    module. Applications may associate one or more IP address configurations by calling
    `pico_ipv4_link_add` and specifying the address and netmask. A route in the IP
    protocol is created automatically to reach all the neighbors in the subnet through
    the interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址配置是通过访问IPv4模块的API来完成的。应用程序可以通过调用`pico_ipv4_link_add`并指定地址和子网掩码来关联一个或多个IP地址配置。在IP协议中自动创建一个路由，通过接口到达子网中的所有邻居：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add a default route, the gateway is associated with the `0.0.0.0` address
    (indicating any host) with a metric of `1`. The default gateway can be later overridden
    by defining more specific routes for other subnetworks:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加默认路由，将网关与`0.0.0.0`地址（表示任何主机）关联，并设置度量值为`1`。默认网关可以在以后通过为其他子网定义更具体的路由来覆盖：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As in the previous example, the application can now initialize its sockets
    and associate callbacks that will be called by the stack when needed:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例类似，应用程序现在可以初始化其套接字并关联堆栈在需要时将调用的回调：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This simple main loop calls `pico_stack_tick` repeatedly, which will poll all
    the associated network interfaces in a round-robin, and perform all the pending
    actions in all protocol modules:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的主循环会重复调用`pico_stack_tick`，这将轮询所有关联的网络接口，并在所有协议模块中执行所有挂起的操作：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the TCP/IP actions are associated with socket callbacks, which are called
    whenever the application is expected to react to network and timeout events, and
    timeouts are set up automatically by the stack when required to manage the internal
    states of the single protocols. The interface that is provided to access the socket
    communication in the absence of an operating system, as previously mentioned,
    is based on custom callbacks, depending on the implementation of the specific
    stack. The next section shows how to use non-blocking socket APIs in two different
    TCP/IP stack implementations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有TCP/IP操作都与套接字回调相关联，当应用程序需要响应网络和超时事件时，这些回调会被调用。当需要管理单个协议的内部状态时，堆栈会自动设置超时。如前所述，在无操作系统的环境中，提供访问套接字通信的接口基于自定义回调，具体取决于特定堆栈的实现。下一节将展示如何在两种不同的TCP/IP堆栈实现中使用非阻塞套接字API。
- en: Socket communication
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字通信
- en: The interface provided by lwIP for bare-metal socket communication, also called
    the raw socket API, consists of custom calls, each specifying a callback whenever
    an event is expected from the stack. When a specific event occurs, lwIP will call
    the callback from the main loop function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: lwIP为裸机套接字通信提供的接口，也称为原始套接字API，由自定义调用组成，每个调用都指定在堆栈期望事件发生时调用的回调。当发生特定事件时，lwIP将从主循环函数中调用回调。
- en: 'The description of a TCP socket in lwIP is contained in a TCP-specific protocol
    control block structure, `tcp_pcb`. To allocate a new control block for the listening
    TCP socket, the following function is used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: lwIP中对TCP套接字的描述包含在TCP特定的协议控制块结构中，即`tcp_pcb`。为了为监听TCP套接字分配一个新的控制块，使用以下函数：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To accept a TCP connection, a bare-metal lwIP TCP server would first call this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受TCP连接，裸机lwIP TCP服务器首先会调用以下：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These non-blocking functions bind the socket to a local address and put it into
    a listening state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非阻塞函数将套接字绑定到本地地址并将其置于监听状态。
- en: 'At this point, a POSIX application using blocking sockets would call the `accept`
    function, which would wait indefinitely for the next incoming connection on the
    socket. A lwIP bare-metal application instead calls the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，一个使用阻塞套接字的 POSIX 应用程序会调用 `accept` 函数，该函数会在套接字上无限期地等待下一个传入的连接。相反，lwIP 原生应用程序会调用以下函数：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This simply indicates that the server is ready to accept new connections, and
    wants to be called back to the address of the `accept` function that has been
    passed as a parameter when a new incoming connection is established.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅表明服务器已准备好接受新的连接，并且希望在建立新的传入连接时被回调到已作为参数传递的 `accept` 函数的地址。
- en: 'Using the same mechanism, to receive the next data segment, the application
    calls the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的机制，为了接收下一个数据段，应用程序调用以下函数：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This indicates to the TCP/IP stack that the application is ready to receive
    the next segment over the TCP connection, and the operation can be performed when
    a new buffer is available because the stack calls the actual `recv` function that
    has been specified as the argument when `tcp_recv` has been called.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示 TCP/IP 堆栈应用程序已准备好接收 TCP 连接上的下一个段，并且可以在有新缓冲区可用时执行操作，因为堆栈调用了在调用 `tcp_recv`
    时指定的实际 `recv` 函数。
- en: Similarly, picoTCP associates one callback with each socket object. The callback
    is a common point to react to any socket-related events, such as a new incoming
    TCP connection, new data to be read on the socket buffer, or the end of the previous
    write operation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，picoTCP 将一个回调函数与每个套接字对象关联起来。该回调函数是一个公共点，用于响应任何与套接字相关的事件，例如新的传入 TCP 连接、套接字缓冲区中有新数据要读取，或者上一个写入操作的结束。
- en: 'The callback is specified when the socket is created:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建套接字时指定回调函数：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding function creates a new socket object for use in the specified
    network and transport protocol context, the `net` and `proto` arguments respectively,
    and reacts to all socket events by calling the `wakeup` function that is provided
    by the application. Using this mechanism, picoTCP successfully detects half-closed
    socket connections and other events that are not specifically related to the current
    operation in progress but may occur due to a state change in the socket communication
    model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数在指定的网络和传输协议上下文中创建一个新的套接字对象，`net` 和 `proto` 参数分别，并通过调用应用程序提供的 `wakeup` 函数来响应所有套接字事件。使用此机制，picoTCP
    成功检测到半关闭的套接字连接和其他事件，这些事件可能不是与当前操作直接相关，但可能由于套接字通信模型中的状态变化而发生。
- en: 'A TCP socket server can be configured on the newly created socket using these
    functions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用这些函数在新建的套接字上配置 TCP 套接字服务器：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, the application has to wait for the incoming connections without
    calling `accept`. An event is generated, which calls the `wakeup` function, whenever
    a new incoming connection is established, and the application can finally call
    `accept` to generate the new socket object, corresponding to the incoming connection:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，应用程序必须等待传入的连接而不调用 `accept`。每当建立一个新的传入连接时，就会生成一个事件，该事件调用 `wakeup` 函数，然后应用程序最终可以调用
    `accept` 来生成新的套接字对象，对应于传入的连接：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first argument passed to the picoTCP `wakeup` callback is a bitmask indicating
    the event types that occurred on the socket. Events may be as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 picoTCP `wakeup` 回调函数的第一个参数是一个掩码，表示在套接字上发生的事件类型。事件可能如下所示：
- en: '`EV_RD`: Indicating that there is data to read on the incoming data buffer.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EV_RD`：指示在传入数据缓冲区中有数据可读。'
- en: '`EV_CONN`: Indicating that a new connection has been established, after calling
    `connect`, or while waiting in a listening state, before calling `accept`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EV_CONN`：指示在调用 `connect` 之后或处于监听状态等待时，已建立新的连接，在调用 `accept` 之前。'
- en: '`EV_CLOSE`: Triggered when the other side of the connection sends a `FIN` TCP
    segment, indicating that it has finished its transmission. The socket is in the
    `CLOSE_WAIT` state, meaning that the application may still send data before terminating
    the connection.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EV_CLOSE`：当连接的另一端发送一个 `FIN` TCP 段时触发，表示它已经完成了传输。套接字处于 `CLOSE_WAIT` 状态，意味着在终止连接之前，应用程序可能仍然可以发送数据。'
- en: '`EV_FIN`: Indicating that the socket has been closed, and it is not usable
    anymore after returning from the callback.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EV_FIN`：指示套接字已被关闭，并且在回调函数返回后不再可用。'
- en: '`EV_ERR`: An error occurred.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EV_ERR`：发生了错误。'
- en: The callback interface provided by the TCP/IP stacks may be a little obscure
    to use at the beginning, but it is a very efficient way to achieve higher throughput
    when correctly implemented in the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 堆栈提供的回调接口一开始可能使用起来有些晦涩，但它是实现更高吞吐量的非常有效的方法，当在应用中正确实现时。
- en: Both the TCP/IP stacks we have analyzed are capable of providing more standardized
    APIs in combination with an operating system, by running the TCP/IP library main
    loop in a separate thread and providing access to the sockets using system calls.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析的两个 TCP/IP 堆栈都能够通过在单独的线程中运行 TCP/IP 库主循环，并通过系统调用提供对套接字的访问，与操作系统结合提供更标准化的
    API。
- en: Socket communication is only one of the APIs exposed by the TCP/IP stacks. Other
    protocols implemented by the stack provide their own function signatures; these
    are described in both libraries’ manuals.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字通信只是 TCP/IP 堆栈公开的 API 之一。堆栈中实现的其它协议提供它们自己的函数签名；这些在两个库的手册中都有描述。
- en: Connectionless protocols
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无连接协议
- en: TCP is a widely used transport protocol, wherever the connection-oriented paradigm
    makes sense for the application. Its connectionless counterpart, UDP, is mostly
    used to solve a different range of problems, but it can, in some cases, cover
    all the needs of a small, resource-limited embedded system. TCP implementations
    are, in fact, large and, on some platforms, they take up a considerable portion
    of the available flash space. This is due to the complex internal mechanisms of
    TCP, which result in a lot of code to include to manage retransmissions, timeouts,
    and acknowledgments; organize buffers; and keep track of multiple state machines
    for each socket.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是一种广泛使用的传输协议，在连接导向模式对应用有意义的地方。它的无连接对应协议 UDP，主要用于解决不同范围的问题，但在某些情况下，它可以满足小型、资源受限的嵌入式系统的所有需求。实际上，TCP
    实现很大，在某些平台上，它们占据了可用的闪存空间相当大的部分。这是由于 TCP 的复杂内部机制，导致需要包含大量代码来管理重传、超时和确认；组织缓冲区；以及跟踪每个套接字的多态状态机。
- en: UDP, on the other hand, is quite simple and applies few transformations to the
    data from the socket interface to the network and vice-versa. Typically, UDP implementations
    are much smaller in size and due to the lack of reliability requirements, do not
    need to keep track of the order and gaps in the data already transmitted or received,
    impacting the runtime RAM usage as well. When the network characteristics permit
    it, using UDP for low-traffic redundant data transmission is often a viable option.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，UDP 非常简单，对从套接字接口到网络以及相反方向的数据进行很少的转换。通常，UDP 实现的大小要小得多，由于缺乏可靠性要求，不需要跟踪已传输或接收的数据的顺序和间隙，这影响了运行时
    RAM 的使用。当网络特性允许时，使用 UDP 进行低流量冗余数据传输通常是一个可行的选择。
- en: Mesh networks and dynamic routing
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网状网络和动态路由
- en: 'As previously mentioned, a link-layer protocol may be able to implement mesh-under
    mechanisms, which hide the complexity of the topology for the upper layers. A
    different approach is applied when the link-layer protocol does not implement
    this feature, or whenever the mesh solution may be extended across different network
    interfaces, and thus must implement a standard protocol that is interface-agnostic.
    Each link connects two devices in direct visibility, which, in turn, coordinates
    to detect the optimal network path to reach a remote node, based on the detected
    topology. Intermediate nodes along the path are configured to route the traffic
    toward the destination, based on the information available on the current topology:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，链路层协议可能能够实现网状下机制，这为上层隐藏了拓扑的复杂性。当链路层协议不实现此功能，或者当网状解决方案可能扩展到不同的网络接口时，采用不同的方法，此时必须实现一个标准协议，该协议与接口无关。每个链路直接连接两个设备，这些设备反过来协调以检测到达远程节点的最佳网络路径，基于检测到的拓扑。路径上的中间节点被配置为根据当前拓扑上的信息路由流量到目的地：
- en: '![Figure 9.1 – Example of a mesh network topology (node A chooses node C to
    route packets towards I, after detecting the optimal four-hop route)](img/B18730_09_01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 网状网络拓扑示例（节点 A 选择节点 C 将数据包路由到 I，在检测到最佳的四跳路由后）](img/B18730_09_01.jpg)'
- en: Figure 9.1 – Example of a mesh network topology (node A chooses node C to route
    packets towards I, after detecting the optimal four-hop route)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 网状网络拓扑示例（节点 A 选择节点 C 将数据包路由到 I，在检测到最佳的四跳路由后）
- en: In some scenarios, the topology is not fixed but evolves when nodes in the path
    become unavailable or change their location, altering their direct visibility
    with adjacent nodes. Mesh networks with non-static topology are referred to as
    **Mobile Ad Hoc Networks** (**MANETs**). Dynamic routing mechanisms designed for
    MANETs must be able to react to topology changes and update their routes accordingly,
    as the network is in continuous evolution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，拓扑不是固定的，而是在路径中的节点不可用或更改其位置时演变，改变其与相邻节点的直接可见性。具有非静态拓扑的网状网络被称为**移动自组织网络**
    (**MANETs**)。为MANETs设计的动态路由机制必须能够对拓扑变化做出反应并相应地更新其路由，因为网络是持续演变的。
- en: 'Route-over mesh mechanisms are implemented within the TCP/IP stack because
    they must be able to reconfigure the IP routing table at runtime, and access socket
    communication. Mesh networks based on dynamic IP routing rely on different protocols,
    which can be divided into two categories:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 路由在网状机制是在TCP/IP堆栈中实现的，因为它们必须能够在运行时重新配置IP路由表，并访问套接字通信。基于动态IP路由的网状网络依赖于不同的协议，这些协议可以分为两类：
- en: '**Proactive dynamic-routing protocols**: Each network node sends a broadcast
    message to announce its presence on the network, and other nodes can detect a
    neighbor’s presence by reading the messages, and communicating the neighbor list
    to the neighbors. The mesh network is ready to use at all times and requires a
    fixed reconfiguration time on topology changes.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主动动态路由协议**：每个网络节点发送广播消息来宣布其在网络上的存在，其他节点可以通过读取消息来检测邻居的存在，并将邻居列表传达给邻居。网状网络始终处于可用状态，并且在拓扑变化时需要固定的重新配置时间。'
- en: '**Reactive dynamic-routing protocols**: Nodes can be idling when there is no
    data to exchange, and then the path is configured by querying every neighbor,
    asking for a route to the destination. The message is then repeated, increasing
    a counter to keep track of the hops, until it reaches the destination, at which
    point, using the reply, the network can define the path requested by the sender.
    These mechanisms imply that dynamic routes are formed on demand, so the first
    messages of the communication can suffer an additional delay; on the other hand,
    it requires less power and may react faster to topology changes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反应式动态路由协议**：在没有数据交换时，节点可以处于空闲状态，然后通过查询每个邻居来配置路径，请求到达目的地的路由。然后重复消息，增加计数器以跟踪跳数，直到到达目的地，此时，使用回复，网络可以定义发送者请求的路径。这些机制意味着动态路由是在需要时形成的，因此通信的第一条消息可能会遭受额外的延迟；另一方面，它需要的能量更少，可能对拓扑变化的反应更快。'
- en: 'The most widely used protocols in the former group are the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前一组中最广泛使用的协议如下：
- en: '**Optimized Link-State Routing** (**OLSR**), standardized by IETF in RFC3626
    and RFC7181'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化链路状态路由** (**OLSR**)，由IETF在RFC3626和RFC7181中标准化'
- en: '**Better Approach to Mobile Ad Hoc** **Networking** (**B.A.T.M.A.N.**)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的移动自组织网络** **方法** (**B.A.T.M.A.N.**)'
- en: Babel (IETF RFC6126)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel (IETF RFC6126)
- en: '**Destination Sequence Distance** **Vector** (**DSDV**)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的序列距离** **向量** (**DSDV**)'
- en: 'The reactive, on-demand routing protocols standardized by IETF are the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: IETF标准化的反应式、按需路由协议如下：
- en: '**Ad-hoc, On-demand, Distance Vector** (**AODV**), RFC3561'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自组织、按需、距离向量** (**AODV**)，RFC3561'
- en: Dynamic Source Routing (RFC4728)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态源路由 (RFC4728)
- en: The choice of a routing protocol depends, once again, on the requirements of
    the mesh network that needs to be built. Reactive, on-demand protocols are the
    best fit in networks with sporadic data and battery-powered nodes, where a longer
    reaction time from the routing protocol is acceptable. Always-on, embedded systems
    may benefit from proactive routing mechanisms instead, which ensure that the routing
    tables are always updated to the last known state of the network, and each node
    knows the best route toward each possible destination at all times, but, at the
    same time, requires regular updates to travel across the network in the form of
    broadcast packets, constantly refreshing the status of the network nodes and their
    neighbors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议的选择，再次强调，取决于需要构建的网状网络的要求。在数据稀疏和电池供电的节点网络中，反应式、按需协议是最合适的，在这些网络中，路由协议的较长时间反应是可以接受的。始终开启的嵌入式系统可能从主动路由机制中受益，这些机制确保路由表始终更新到网络的最新已知状态，并且每个节点始终知道到达每个可能的最佳路由，但与此同时，需要定期更新以广播包的形式穿越网络，不断刷新网络节点及其邻居的状态。
- en: 'picoTCP, which has been designed to provide advanced routing technologies for
    IoT devices, supports one mesh-under mechanism, in the 6LoWPAN link layer, and
    two route-over protocols, namely OLSR (reactive) and AODV (proactive), giving
    broader choices for integrating TCP/IP communication into mobile, ad hoc networks.
    To enable OLSR, for example, it is sufficient to compile the stack with support
    for OLSR, and the OLSR daemon service will automatically be enabled and run within
    the main TCP/IP stack loop. All the devices that must participate in the definition
    of the mesh network must be added by calling `pico_olsr_add`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: picoTCP，它被设计用来为物联网设备提供高级路由技术，支持一种网状下层机制，在 6LoWPAN 链路层，以及两种路由上层协议，即 OLSR（反应式）和
    AODV（主动式），为将 TCP/IP 通信集成到移动、自组织网络提供了更广泛的选择。例如，要启用 OLSR，只需编译支持 OLSR 的堆栈，OLSR 守护服务将自动在主
    TCP/IP 堆栈循环中启用并运行。所有必须参与网状网络定义的设备都必须通过调用 `pico_olsr_add` 添加：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'AODV networking can be enabled similarly, and the interfaces are added using
    the `pico_aodv_add` function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: AODV 网络可以通过类似的方式启用，接口是通过 `pico_aodv_add` 函数添加的：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In both cases, the services will run transparently for the user and alter the
    routing table every time a new node is detected on the network in the case of
    OLSR, or every time that we request communication to a remote node and an on-demand
    route is created to reach it. Nodes that are not in direct visibility specify
    a first-hop gateway that guarantees that the destination node can be reached,
    using the routing metric as an indication of the number of hops so that when a
    new, shorter destination is found, the route is replaced and the communication
    can continue, ideally with no disruptions caused by the route being replaced.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，服务将透明地为用户运行，并在检测到网络上的新节点时更改路由表，对于 OLSR 来说是在检测到新节点时，或者每次我们请求与远程节点通信并创建一个按需路由以到达它时。不在直接可见范围内的节点指定一个第一跳网关，以确保目标节点可以通过路由度量作为跳数指示符被到达，这样当找到一个新的、更短的路径时，路由将被替换，通信可以继续，理想情况下不会因路由替换而造成中断。
- en: Routing protocols, such as OLSR, can consider other parameters rather than the
    number of hops when calculating the best path to a given destination in the mesh
    network. It is possible, for instance, to integrate information about the wireless
    link quality, such as the signal-to-noise ratio or the indication of the received
    signal strength, when calculating the best path. This allows us to select routes
    based on multiple parameters, and always select the best option available in terms
    of a wireless signal.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议，如 OLSR，在计算网状网络中给定目的地的最佳路径时，可以考虑比跳数更多的参数。例如，在计算最佳路径时，可以集成有关无线链路质量的信息，如信噪比或接收信号强度的指示。这允许我们根据多个参数选择路由，并始终选择无线信号方面的最佳选项。
- en: Route-over mesh network strategies do not foresee mechanisms to forward broadcast
    packets, which must be repeated by the link-layer protocol in order to reach all
    the nodes in the network. However, it is known that implementing such a mechanism
    can easily trigger a ping-pong effect where a single packet is bounced across
    two or more nodes, so broadcast-forwarding mechanisms implemented in the link
    layer must avoid retransmitting the same frame twice by keeping track of the last
    few frames forwarded this way.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 路由上层网状网络策略没有预见转发广播包的机制，这些广播包必须由链路层协议重复转发，以便到达网络中的所有节点。然而，已知实现此类机制可以轻易触发乒乓效应，即单个数据包在两个或更多节点之间弹跳，因此链路层实现的广播转发机制必须通过跟踪最近几帧通过这种方式转发的帧来避免重复转发相同的帧。
- en: For IoT systems in the real world, communication requires implementing security
    for data in transfer. This includes, but is not limited to, encryption to guarantee
    the confidentiality of the data transmitted.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界中的物联网系统，通信需要实现传输中数据的安全。这包括但不限于加密，以确保传输数据的机密性。
- en: Implementing standard security protocols guarantees interoperability between
    heterogeneous components in the network (for example, between the device and a
    remote server), in an end-to-end fashion and relying on software solutions that
    are perfectly compatible with the protocols used in the classic IT world. The
    next section approaches transport layer security and proposes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实施标准安全协议确保网络中异构组件（例如，设备与远程服务器之间）之间的互操作性，以端到端的方式，并依赖于与经典 IT 世界中使用的协议完美兼容的软件解决方案。下一节将探讨传输层安全，并提出了建议。
- en: TLS
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: Link-layer protocols often provide some basic security mechanisms to guarantee
    the authentication of the client connecting to a specific network and encrypt
    data by using symmetric keys such as AES. In most cases, authentication at the
    link layer is sufficient to guarantee a basic level of security. Nevertheless,
    pre-shared, well-known keys often used in LR-WPAN network stacks may be vulnerable
    to multiple kinds of attacks, and using a pre-shared key would allow an attacker
    to decipher any traffic that has been previously captured on the same link if
    the key was compromised. In other scenarios, encryption alone is not sufficient
    to guarantee that the other endpoint is what it claims to be, or that the data
    flow has not been altered during transmission.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 链路层协议通常提供一些基本的安全机制，以确保连接到特定网络的客户端的认证，并通过使用如AES之类的对称密钥加密数据。在大多数情况下，链路层的认证足以保证基本的安全级别。然而，在LR-WPAN网络堆栈中经常使用的预共享、众所周知的密钥可能容易受到多种攻击，并且如果密钥被泄露，使用预共享密钥将允许攻击者解密在同一链路上之前捕获的任何流量。
- en: 'A device that takes part in an IoT-distributed system is required to implement
    a higher grade of security, especially in embedded devices that do not protect
    the memory in any way and where any backdoor means that attackers can take control
    of the device, and retrieve all the sensitive information, such as private keys
    used for authentication and encryption in the communication with remote systems.
    TLS is a set of cryptography protocols aimed to provide secure communication over
    standard TCP/IP sockets. The responsibilities of this component are mostly focused
    on three key requirements for secure communication in distributed systems:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 参与物联网分布式系统的设备需要实现更高等级的安全性，尤其是在没有任何内存保护措施的嵌入式设备中，任何后门都意味着攻击者可以控制设备，并检索所有敏感信息，例如用于与远程系统通信的认证和加密的私钥。TLS是一套旨在通过标准TCP/IP套接字提供安全通信的加密协议。该组件的责任主要集中在分布式系统中安全通信的三个关键要求上：
- en: The **confidentiality** of communication between the parts involved through
    the use of symmetric cryptography. TLS defines cryptographic techniques aimed
    to generate one-time symmetric keys, which lose their validity at the end of the
    session they were generated for.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用对称加密，确保涉及部分之间的**机密性**。TLS定义了旨在生成一次性对称密钥的加密技术，这些密钥在它们生成的会话结束时失效。
- en: The **authentication** of the parts involved in the communication, using public-key
    cryptography to sign and verify a challenge payload. Due to the properties of
    asymmetric keys, only the part that owns the secret private key is able to sign
    a payload, while anyone can verify the authenticity of the signature by checking
    the signature with the public key counterpart of the key that signed the message.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公钥加密技术对通信中涉及的各方进行**认证**，以签署和验证挑战负载。由于非对称密钥的性质，只有拥有秘密私钥的部分才能签署负载，而任何人都可以通过检查与签名消息的公钥对应项来验证签名的真实性。
- en: The **integrity** of the communication, using message digests, which verify
    that the message has not been modified along its path.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息摘要确保通信的**完整性**，从而验证消息在其路径上没有被修改。
- en: A few open source implementations of the required protocol suite to enable standard
    cryptography algorithms and strategies for secure socket communications are available
    for the embedded market.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 几种开源的协议套件实现可用于嵌入式市场，以启用标准加密算法和安全的套接字通信策略。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Closed-source, proprietary implementations for security components should be
    avoided in this context as much as possible because security issues are much harder
    to track down in a closed system, and the source of the implementation has to
    be blindly trusted in terms of vulnerability management.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此背景下，应尽可能避免使用闭源的专有安全组件实现，因为在封闭系统中追踪安全问题是相当困难的，并且必须盲目信任实现源以进行漏洞管理。
- en: One of the most complete and up-to-date implementations is provided by the free
    and open source software library, **wolfSSL**. The library offers the latest standard
    version of both TLS and DTLS and is designed for performance and reliability on
    small embedded systems, including support for hardware accelerators and random
    number generators for many embedded platforms designed for system security.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由免费和开源软件库**wolfSSL**提供的实现是最完整和最新的之一。该库提供了TLS和DTLS的最新标准版本，并针对小型嵌入式系统中的性能和可靠性进行了设计，包括对许多用于系统安全的嵌入式平台的硬件加速器和随机数生成器的支持。
- en: wolfSSL implements the cryptographic primitives in its core library (`wolfCrypt`)
    and groups them in cipher suites used by TLS sockets that can be easily integrated
    into both, bare-metal network applications and any embedded operating system that
    provides a transport socket communication API. These cryptography primitives are
    optimized for embedded devices, and use assembly code for the most performance-critical
    operations for the best performance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: wolfSSL在其核心库（`wolfCrypt`）中实现了加密原语，并将它们分组为TLS套接字使用的密码套件，这些套接字可以轻松集成到裸机网络应用程序和任何提供传输套接字通信API的嵌入式操作系统中。这些加密原语针对嵌入式设备进行了优化，并使用汇编代码对性能最关键的操作进行优化，以获得最佳性能。
- en: The main advantage of a TLS/SSL library designed for microcontrollers is that
    it implements the same protocols as any PC or server on the internet, but with
    a fraction of the code size, and keeps the resources usage, such as memory usage
    during the most expensive cryptographic operations, under control at all times.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为微控制器设计的TLS/SSL库的主要优势是它实现了与互联网上任何PC或服务器相同的协议，但代码大小只有一小部分，并且在所有时候都保持资源使用（如最昂贵的加密操作期间的内存使用）在控制之下。
- en: The adoption of a TLS library with support for bleeding-edge cryptography algorithms
    allows perfect integration with the security measures implemented in the classic
    IT infrastructure components of the IoT network. On the cloud side, services meant
    to be accessed by remote embedded systems should allow the selection of more efficient
    cipher suites based on elliptic curves, as the classic RSA-based public key encryption
    requires larger keys and complex calculations to reach the same level of security.
    New standards for public-key-based encryption, such as Curve22519, are included
    in the TLS 1.3 specifications to provide more efficient key handling for systems
    with fewer resources while keeping the same security level of older algorithms.
    Selecting the right set of cryptographic algorithms for TLS communication among
    heterogeneous systems must take into account the computation times of the operations
    performed on the target, such as encryption, session key generation, payload signing,
    and verification.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 采用支持尖端加密算法的TLS库，可以使物联网网络中经典IT基础设施组件实施的安全措施实现完美集成。在云端，旨在由远程嵌入式系统访问的服务应允许根据椭圆曲线选择更高效的密码套件，因为基于RSA的公钥加密需要更大的密钥和复杂的计算才能达到相同的安全级别。TLS
    1.3规范中包含了基于公钥加密的新标准，如Curve22519，以提供更多资源系统的有效密钥处理，同时保持较老算法相同的安全级别。在选择异构系统之间TLS通信的加密算法时，必须考虑在目标上执行的操作的计算时间，例如加密、会话密钥生成、有效载荷签名和验证。
- en: Securing socket communication
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护套接字通信
- en: wolfSSL has built-in support for many embedded operating systems, to adapt to
    the specific memory configurations and socket interfaces provided by different
    paradigms, and can also be integrated into a bare-metal system with any compatible
    TCP/IP stack, or easily adapted thanks to a generic, callback-based **Input/Output**
    (**I/O**) interface.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: wolfSSL内置了对许多嵌入式操作系统的支持，以适应不同范例提供的特定内存配置和套接字接口，并且可以集成到任何兼容的TCP/IP堆栈的裸机系统中，或者通过通用的基于回调的**输入/输出**（**I/O**）接口轻松适应。
- en: In either case, bare-metal or OS, the application must be designed to access
    the `wolfSSL_accept` or `wolfSSL_connect`, in server mode or in client mode, respectively,
    to initiate the TLS handshake with the remote system. Data communication is then
    available using the `wolfSSL_read` and `wolfSSL_write` functions, instead of the
    normal socket read/write functions exported by the TCP/IP stack so that the stream
    can be processed by the additional SSL built by the TLS library on top.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，无论是裸机还是操作系统，应用程序都必须设计为访问 `wolfSSL_accept` 或 `wolfSSL_connect`，分别以服务器模式或客户端模式，以与远程系统启动
    TLS 握手。然后可以使用 `wolfSSL_read` 和 `wolfSSL_write` 函数进行数据通信，而不是使用 TCP/IP 堆栈导出的正常套接字读写函数，这样流就可以由
    TLS 库在顶部构建的附加 SSL 处理。
- en: The following usage example refers to using wolfSSL to create a TLS socket on
    top of a TCP connection. The approach for creating a DTLS socket, the TLS equivalent
    for connectionless socket, on top of UDP is quite similar, and still uses the
    same connect/accept paradigm as TLS, despite UDP being usually utilized in a peer-to-peer
    fashion that does not expose a net distinction between the client and the server
    side as well as TCP does. More information about creating DTLS connectionless
    secure sockets can be found in the wolfSSL user manual ([https://www.wolfssl.com/documentation/manuals/wolfssl/index.html](https://www.wolfssl.com/documentation/manuals/wolfssl/index.html)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下使用示例涉及使用 wolfSSL 在 TCP 连接之上创建 TLS 套接字。在 UDP 之上创建 DTLS 套接字（无连接套接字的 TLS 等价物）的方法相当类似，并且仍然使用与
    TLS 相同的连接/接受范例，尽管 UDP 通常以点对点方式使用，不暴露客户端和服务器之间的网络区别，而 TCP 则有这种区别。有关创建 DTLS 无连接安全套接字的更多信息，请参阅
    wolfSSL 用户手册 ([https://www.wolfssl.com/documentation/manuals/wolfssl/index.html](https://www.wolfssl.com/documentation/manuals/wolfssl/index.html))。
- en: 'In our simple usage example, the library is first initialized before accessing
    any API, using `wolfSSL_Init`. This is the only requirement to initialize and
    create new objects that are commonly called contexts. A single context implements
    one specific method (the TLS v. 1.2 server in this example) and will be associated
    with one or more existing sockets through a different abstraction called `WOLFSSL`.
    Multiple SSL objects generated from the same context share the same set of cryptography
    keys and I/O callback functions that wolfSSL can use to query the system for incoming
    data, or transmit the processed data through the socket connection:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单使用示例中，在访问任何 API 之前，首先使用 `wolfSSL_Init` 初始化库。这是初始化和创建通常称为上下文的新对象的要求。单个上下文实现一个特定方法（本例中的
    TLS v. 1.2 服务器）并将通过一个称为 `WOLFSSL` 的不同抽象与一个或多个现有套接字相关联。从同一上下文生成的多个 SSL 对象共享相同的加密密钥和
    I/O 回调函数，wolfSSL 可以使用这些函数查询系统以获取传入数据，或通过套接字连接传输处理后的数据：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The two callbacks are implemented in the system to access socket communication
    in the TCP/IP stack, by using the system-specific TCP socket API. Suppose, for
    example, that a custom TCP implementation exports read and write functions as
    `tcp_socket_write` and `tcp_socket_read` in a bare-metal context, and these functions
    return `0` when no action is taken because the TCP/IP stack is busy or not ready
    to process the buffers. The `wolfssl_send_cb` callback can be implemented to return
    the size of the processed data in case of success, or the `WOLFSSL_CBIO_ERR_WANT_WRITE`
    special value, which indicate that the I/O operation could not be completed without
    blocking:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中实现了两个回调函数，用于通过使用特定于系统的 TCP 套接字 API 访问 TCP/IP 堆栈中的套接字通信。例如，假设一个自定义 TCP 实现在裸机环境中导出读写函数为
    `tcp_socket_write` 和 `tcp_socket_read`，并且当 TCP/IP 堆栈忙碌或未准备好处理缓冲区时，这些函数返回 `0`。`wolfssl_send_cb`
    回调函数可以实现，以在成功的情况下返回处理的数据大小，或者返回特殊值 `WOLFSSL_CBIO_ERR_WANT_WRITE`，这表示 I/O 操作无法在不阻塞的情况下完成：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And the corresponding read callback will use the corresponding `WOLFSSL_CBIO_ERR_WANT_READ`
    special value to indicate that no data is available to process from the stack:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的读取回调将使用相应的 `WOLFSSL_CBIO_ERR_WANT_READ` 特殊值来指示从堆栈中没有可处理的数据：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For most commonly used operating systems and TCP/IP stack APIs, wolfSSL already
    provides default I/O callbacks, so implementing custom callback functions is not
    required as long as you activate the correct configuration options.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数常用的操作系统和 TCP/IP 堆栈 API，wolfSSL 已经提供了默认的 I/O 回调函数，因此只要激活正确的配置选项，就不需要实现自定义回调函数。
- en: 'The `wolfSSL_CTX` object, associated with SSL objects for every connection,
    must be equipped with a set of certificates and keys prior to initiating any communication.
    In a more complex system, certificates and keys are stored in the filesystem and
    can be accessed when wolfSSL has been integrated to use file operations. In embedded
    systems where filesystems are often not supported, certificates and keys can be
    stored in memory instead, and loaded into the context using pointers to their
    locations in memory:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个连接关联的`wolfSSL_CTX`对象，在开始任何通信之前必须配备一组证书和密钥。在更复杂的系统中，证书和密钥存储在文件系统中，当wolfSSL集成到使用文件操作时可以访问。在通常不支持文件系统的嵌入式系统中，证书和密钥可以存储在内存中，并使用指向内存中位置的指针将其加载到上下文中：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The socket context that is passed to the callbacks is set after the underlying
    TCP connection is established. For a server, this can be done contextually to
    the `accept` function, while a client can associate the socket to the specific
    SSL context after the `connect` function has returned successfully. Accepting
    an SSL connection on the server side requires the application to call `wolfSSL_accept`
    so that the SSL handshake can be finalized before any actual data transfers. The
    SSL accept procedure should follow the socket `accept` call, after the pointer
    to the TCP/IP socket object is associated as the context in the SSL object, and
    will be used as the `sk_ctx` argument for the callbacks related to this socket:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将套接字上下文传递给回调函数是在底层TCP连接建立之后设置的。对于服务器，这可以在`accept`函数的上下文中完成，而客户端可以在`connect`函数成功返回后关联套接字到特定的SSL上下文。在服务器端接受SSL连接需要应用程序调用`wolfSSL_accept`，以便在任何实际数据传输之前完成SSL握手。SSL接受过程应该在将TCP/IP套接字对象的指针关联为SSL对象的上下文之后，并用作与该套接字相关的回调函数的`sk_ctx`参数：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`wolfSSL_accept` is called after setting the socket context, because the `accept`
    mechanism may already need to call the underlying stack to progress through its
    states:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`wolfSSL_accept`是在设置套接字上下文之后调用的，因为`accept`机制可能已经需要调用底层堆栈以通过其状态：'
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the SSL handshake is successful, `wolfSSL_accept` returns the `WOLFSSL_SUCCESS`
    special value, so the secure socket is now ready for communication through the
    `wolfSSL_read` and `wolfSSL_write` functions. When running in a bare-metal application,
    `wolfSSL_read` and `wolfSSL_write` must be used in non-blocking mode, by setting
    this flag at runtime on the SSL session object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SSL握手成功，`wolfSSL_accept`返回`WOLFSSL_SUCCESS`特殊值，因此安全套接字现在可以通过`wolfSSL_read`和`wolfSSL_write`函数进行通信。在裸机应用程序中运行时，`wolfSSL_read`和`wolfSSL_write`必须在非阻塞模式下使用，通过在运行时在SSL会话对象上设置此标志：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using non-blocking I/O for wolfSSL functions ensures that the event-driven main
    loop model previously described for transport sockets can be kept because calling
    library functions never stalls the system. API functions in wolfSSL are designed
    to immediately return specific values (such as `WANT_WRITE` and `WANT_READ`) to
    indicate that the operation is in progress, and the associated function (for example,
    `wolfSSL_accept` in this case) should be called again later when new data from
    the underlying TCP socket is available.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非阻塞I/O为wolfSSL函数确保可以保持之前描述的用于传输套接字的事件驱动主循环模型，因为调用库函数永远不会使系统停滞。wolfSSL中的API函数被设计为立即返回特定的值（例如`WANT_WRITE`和`WANT_READ`），以指示操作正在进行中，并且相关的函数（例如，在这种情况下是`wolfSSL_accept`）应该在稍后当底层TCP套接字有新数据可用时再次调用。
- en: Once the communication between transport endpoints is secured, it is possible
    to exchange data using secure socket communications. What follows is an overview
    of some of the most common application protocols used by IoT systems.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运输端点之间的通信得到保障，就可以使用安全套接字通信来交换数据。以下是对物联网系统中使用的一些最常见应用协议的概述。
- en: Application protocols
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用协议
- en: 'In order to be able to communicate with remote devices and cloud servers in
    a distributed scenario, embedded systems must implement standard protocols that
    are compatible with the existing infrastructure. Two of the most common approaches
    taken when designing remote services are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在分布式场景中与远程设备和云服务器通信，嵌入式系统必须实现与现有基础设施兼容的标准协议。在设计远程服务时采取的最常见方法有两种：
- en: Web-based services
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Web的服务
- en: Message protocols
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息协议
- en: The former is mainly the classic, client-server, **Representational State Transfer**
    (**REST**)-based communication that is popular in web services accessed through
    personal computers or portable devices. Web services require no adaptation in
    particular on the cloud side to support embedded systems, except for the choice
    of an embedded-friendly cipher set, as described in the *Securing socket communication*
    section. However, the request-reply communication model introduces some restrictions
    on the design of distributed applications. The HTTP protocol can be upgraded by
    common agreement on the two HTTP endpoints, and support WebSocket, which is a
    protocol that provides the abstraction of a symmetric, bidirectional channel on
    top of the HTTP services.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前者主要是经典的、基于客户端-服务器的**表示状态转移**（**REST**）通信，这种通信在通过个人电脑或便携式设备访问的Web服务中很受欢迎。Web服务在云端不需要特别适应来支持嵌入式系统，除了选择一个嵌入式友好的密码集，如*安全套接字通信*部分所述。然而，请求-回复通信模型在分布式应用程序的设计上引入了一些限制。HTTP协议可以通过两个HTTP端点的共同协议升级，并支持WebSocket，这是一个在HTTP服务之上提供对称、双向通道抽象的协议。
- en: Message protocols are a different approach that better reflects the functions
    of a sensor- or actuator-embedded system, where information is exchanged by using
    short binary messages, which can be relayed by intermediate agents and gathered
    or distributed from server nodes. Message protocols are the preferred choice when
    the network includes smaller nodes because of the simpler presentation of the
    data, as opposed to web services, which are mostly based on human-readable strings
    and add a much larger overhead to the transport size and memory footprint of the
    targets having to handle the ASCII strings.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 消息协议是一种不同的方法，更好地反映了传感器或执行器嵌入式系统的功能，其中信息通过使用短二进制消息进行交换，这些消息可以通过中间代理进行中继，并从服务器节点收集或分发。当网络包括较小的节点时，消息协议是首选选择，因为与基于人类可读字符串的Web服务相比，它具有更简单的数据表示。Web服务通常基于人类可读字符串，并为必须处理ASCII字符串的目标增加了更大的传输大小和内存占用。
- en: In both cases, TLS should be supported at the infrastructure- and device-level,
    for end-to-end encryption and reliable device identification. Plaintext authentication
    and pre-shared key encryption are obsolete techniques and thus should not be part
    of the security strategy of modern distributed systems.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，TLS应在基础设施和设备级别得到支持，以实现端到端加密和可靠的设备识别。明文认证和预共享密钥加密是过时的技术，因此不应成为现代分布式系统安全策略的一部分。
- en: Message protocols
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息协议
- en: Message-based communication protocols are not a novelty in computer networking
    software but have found a particularly good match with IoT-distributed systems,
    especially in scenarios where a one-to-many message-based model allows us to reach
    many devices at a time and establish bidirectional communication, or multiple
    devices from different locations can communicate with each other using an external
    server that acts as a communication broker. The lack of standardization in this
    area has led to several different models, each one with its own API and network
    protocol definition.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息的通信协议在计算机网络软件中并非新奇，但与物联网分布式系统特别匹配，尤其是在一个基于消息的一对多模型允许我们同时到达许多设备并建立双向通信，或者来自不同位置的多个设备可以通过充当通信代理的外部服务器相互通信的场景中。这一领域的标准化不足导致了几个不同的模型，每个模型都有自己的API和网络协议定义。
- en: Some open standards in particular, however, have been designed to implement
    secure distributed messaging systems specifically tailored for a system with reduced
    resources and networks with limited bandwidth, by including specifications that
    are reasonably feasible to implement within a small code footprint. This is the
    case with the **Message-Queuing Telemetry Transport** (**MQTT**) protocol. Thanks
    to its publisher-subscriber model and the possibility to interconnect embedded
    devices at different physical locations over TCP/IP, MQTT has become widely used
    and is supported by several cloud architectures.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些特定的开放标准已经被设计用来实现安全的分布式消息系统，这些系统专门针对资源减少和带宽有限的网络，通过包括一些在小代码足迹内合理可行的规范。这种情况适用于**消息队列遥测传输**（**MQTT**）协议。得益于其发布者-订阅者模型和通过TCP/IP在不同物理位置互联嵌入式设备的能力，MQTT已被广泛使用，并得到多个云架构的支持。
- en: The protocol relies on TCP for establishing connections to a central broker,
    which dispatches messages from publishers to subscribers. Publishers push data
    for a certain topic, described by a URI, and subscribers can filter the topics
    they want to follow upon connection so that the broker selectively only forwards
    the messages matching the filters.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议依赖于TCP来建立与中央代理的连接，该代理将发布者的消息分发到订阅者。发布者推送特定主题的数据，该主题由URI描述，订阅者可以在连接时过滤他们想要跟踪的主题，以便代理只转发与过滤器匹配的消息。
- en: A few implementations for the client library exist for small, embedded devices
    too, although many of them lack support for security mechanisms. The protocol
    supports a plaintext password-authentication mechanism, which is not a valid security
    measure, and should never be used on top of clear TCP/IP communication because
    passwords can easily be intercepted along the path.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型嵌入式设备也存在一些客户端库的实现，尽管其中许多缺乏对安全机制的支持。该协议支持明文密码认证机制，这不是一种有效的安全措施，并且绝不应该在清晰的TCP/IP通信之上使用，因为密码很容易在路径中被截获。
- en: According to the standard, instead of the socket-based TCP communication through
    IANA-registered TCP port `1883`, it is possible to establish an SSL session, which
    uses TCP port `8883` instead. A secure implementation that uses SSL sessions on
    top of TCP is provided by wolfSSL, in a separate GPL library called **wolfMQTT**.
    This library offers secure MQTT socket connections by default. It is capable of
    implementing both client and server authentication through certificates and public
    keys and provides symmetric-key encryption through the established session.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准，除了通过IANA注册的TCP端口`1883`进行的基于套接字的TCP通信外，还可以建立一个SSL会话，该会话使用TCP端口`8883`。wolfSSL提供了一个使用SSL会话在TCP之上提供的安全实现，这是一个名为**wolfMQTT**的独立GPL库。该库默认提供安全的MQTT套接字连接。它能够通过证书和公钥实现客户端和服务器身份验证，并通过建立的会话提供对称密钥加密。
- en: The REST architectural pattern
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST架构模式
- en: '**REST** was a term introduced by Roy Fielding to describe the pattern used
    by web services to communicate with remote systems using a stateless protocol.
    In a REST-compliant system, resources are accessed in the form of HTTP requests
    targeting a specific URI, using the same protocol stack as web pages obtained
    through a request from a remote browser. In fact, REST requests are extended HTTP
    requests, representing all data as encoded strings, transported through TCP in
    a readable HTTP stream.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**是由Roy Fielding提出的术语，用于描述Web服务使用无状态协议与远程系统通信的模式。在符合REST的系统中，资源以针对特定URI的HTTP请求的形式访问，使用与通过远程浏览器请求获得的网页相同的协议栈。实际上，REST请求是扩展的HTTP请求，将所有数据表示为编码字符串，通过可读的HTTP流在TCP上传输。'
- en: Adopting this pattern provides a number of architectural benefits on the server
    side, and allows us to build distributed systems with very high scalability. Although
    not very efficient and definitely not designed with embedded systems resources
    in mind, embedded systems can interact with remote web services exposed by a RESTful
    system by implementing a simple REST client.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种模式在服务器端提供了许多架构上的好处，并允许我们构建具有非常高的可扩展性的分布式系统。尽管这种方法并不非常高效，而且肯定不是针对嵌入式系统资源设计的，但嵌入式系统可以通过实现一个简单的REST客户端与由RESTful系统公开的远程Web服务进行交互。
- en: Distributed systems – single points of failure
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式系统 – 单点故障
- en: Designing distributed systems also means taking into account link defects, unreachable
    gateways, and other failures. Embedded devices should not stop working when disconnected
    from the internet, but rather offer fallback mechanisms based on local gateways.
    Consider, for example, a demotic IoT system for controlling all the heating and
    cooling units in a house, accessible from portable devices and coordinated remotely
    using any network access. Temperature sensors, heaters, and coolers are controlled
    using a mesh network of embedded devices while the central control is on remote
    cloud servers. The system can control the actuators remotely based on user settings
    and sensor readings. This gives us the possibility to access the service even
    from a remote location, allowing the user to tune the system to set the desired
    temperature in each room, based on the commands sent from user interfaces, which
    are processed and relayed by the cloud to reach their destination in the embedded
    devices. As long as all the components are connected to the internet, the IoT
    system works as expected.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 设计分布式系统还意味着要考虑链路缺陷、不可达网关和其他故障。嵌入式设备在断开互联网连接时不应停止工作，而应提供基于本地网关的回退机制。例如，考虑一个用于控制房屋中所有加热和冷却单元的民用电物联网系统，可以通过便携式设备访问，并使用任何网络访问远程协调。温度传感器、加热器和冷却器使用嵌入式设备的网状网络进行控制，而中央控制位于远程云服务器上。系统可以根据用户设置和传感器读数远程控制执行器。这使我们能够在远程位置访问服务，允许用户根据用户界面发送的命令调整系统，以在每个房间设置所需的温度，这些命令由云处理并转发，以到达嵌入式设备。只要所有组件都连接到互联网，物联网系统就会按预期工作。
- en: Nevertheless, in the case of connection failure, users will not be able to control
    the system or activate any function. Terminating the application service on a
    local device within the local area network ensures the continuity of the services
    across failures of the link to the internet and any issues that would prevent
    the local network from accessing the remote cloud device. If this kind of mechanism
    is in place, a system disconnected from the internet would still provide a failover
    alternative to access sensors and actuators, assuming that all the actors at play
    are connected to a common LAN. Moreover, having a local system processing and
    relaying settings and commands reduces the latency of the actions requested because
    requests do not have to travel across the internet to be processed and forwarded
    back to the same network. Designing reliable IoT networks must include a careful
    assessment of the single points of failure among all the links and devices used
    to provide services, and this must include the backbone link used to reach services,
    message brokers, and remote devices that can cause malfunctions or other issues
    on the entire system.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在连接失败的情况下，用户将无法控制系统或激活任何功能。在局域网内终止本地设备上的应用程序服务确保了在互联网连接失败以及任何阻止本地网络访问远程云设备的故障情况下服务的连续性。如果这种机制得以实施，即使系统与互联网断开连接，仍可以提供故障转移替代方案来访问传感器和执行器，前提是所有参与者在一个共同的局域网中连接。此外，拥有一个本地系统处理和转发设置和命令可以减少请求动作的延迟，因为请求不需要穿越互联网进行处理和转发回同一网络。设计可靠的物联网网络必须包括对所有用于提供服务的链接和设备的单点故障的仔细评估，这必须包括用于访问服务、消息代理和远程设备的骨干链路，这些设备可能会在整个系统中引起故障或其他问题。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given us an overview of the design of machine-to-machine distributed
    systems and IoT services, including connected embedded devices, with a focus on
    security elements that are too often overlooked or underestimated in embedded
    development. The technology proposed allows full, professional-grade, secure,
    and fast TCP/IP connectivity on very small targets and uses state-of-the-art technology,
    such as the most recent version of the TLS cipher suites. Several approaches have
    been considered, both in terms of hardware and software technologies available
    for microcontroller-based targets, for a broader view of the technologies, protocols,
    and security algorithms available for building distributed embedded systems.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们概述了机器到机器分布式系统和物联网服务的架构设计，包括连接的嵌入式设备，重点关注在嵌入式开发中常被忽视或低估的安全元素。所提出的技术允许在非常小的目标上实现全面、专业级、安全和快速的TCP/IP连接，并使用最先进的技术，如最新的TLS加密套件。在考虑针对基于微控制器的目标可用的硬件和软件技术方面，已经考虑了多种方法，以更广泛地了解构建分布式嵌入式系统所用的技术、协议和安全算法。
- en: The next chapter will illustrate the multitasking possibilities of modern embedded
    microcontrollers by explaining how to write a small scheduler for Cortex-M microprocessors
    from scratch, and will summarize the key roles of a real-time operating system
    running on an embedded target.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过解释如何从头开始编写适用于Cortex-M微处理器的小型调度器，来展示现代嵌入式微控制器的多任务可能性，并将总结在嵌入式目标上运行的实时操作系统的关键角色。
- en: Part 4 – Multithreading
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分 – 多线程
- en: This part introduces parallel multithreaded applications through the development
    of a scheduler and an explanation of context change in an ARM CPU. In the last
    chapter, the TEE approach is explained, with examples of a system secured with
    TrustZone-M.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分通过调度器的开发和ARM CPU中上下文变化的解释，介绍了并行多线程应用程序。在最后一章中，解释了TEE方法，并举例说明了使用TrustZone-M安全系统。
- en: 'This part has the following chapters:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B18730_10.xhtml#_idTextAnchor357), *Parallel Tasks and Scheduling*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18730_10.xhtml#_idTextAnchor357)，*并行任务与调度*'
- en: '[*Chapter 11*](B18730_11.xhtml#_idTextAnchor403), *Trusted Execution Environment*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18730_11.xhtml#_idTextAnchor403)，*可信执行环境*'
