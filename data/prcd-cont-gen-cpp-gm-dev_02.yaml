- en: Chapter 2. Project Setup and Breakdown
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。项目设置和分解
- en: Before we get into the implementation of procedural generation for ourselves,
    we're going to take a quick tour through the game template that has been provided
    with the book. Moving forward, the focus will be on the procedural systems that
    we create, not the underlying template and engine. Given that, it will be beneficial
    to familiarize ourselves with the templates and engine before we start.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己实现过程生成之前，我们将快速浏览一下本书提供的游戏模板。未来，重点将放在我们创建的过程系统上，而不是底层模板和引擎。因此，在开始之前，熟悉模板和引擎将是有益的。
- en: We'll also take a look at **Simple Fast Multimedia Library** (**SFML**), the
    framework that we'll work with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一下**Simple Fast Multimedia Library**（**SFML**），这是我们将要使用的框架。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Choosing an **Integrated Development Environment** (**IDE**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**集成开发环境**（**IDE**）
- en: A breakdown of the provided game template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的游戏模板的分解
- en: An overview of SFML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML概述
- en: Polymorphism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Project setup and first compile
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置和第一次编译
- en: Object pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象管道
- en: Choosing an IDE
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择IDE
- en: Before we do anything, you're going to need a solid C++ IDE. You may already
    have one that you prefer to use. If you do have one, that's fine. But if you don't,
    here's a quick summary of two of my favorites.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，您需要一个可靠的C++ IDE。您可能已经有自己喜欢使用的IDE。如果您已经有一个，那很好。但如果没有，这是我喜欢的两个IDE的简要摘要。
- en: Microsoft Visual Studio
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio
- en: 'Microsoft Visual Studio is an industry-standard IDE from Microsoft. It supports
    a wide range of languages, and provides a large variety of testing and compatibility
    tools. It''s also tied in with a number of Microsoft services, making it the top
    choice for development on Windows PCs. The pros and cons to using Microsoft Visual
    Studio are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio是微软的行业标准IDE。它支持多种语言，并提供大量的测试和兼容性工具。它还与许多微软服务绑定在一起，使其成为Windows
    PC上开发的首选。使用Microsoft Visual Studio的优缺点如下：
- en: '**Pros:**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**'
- en: It has a number of free versions available
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有许多免费版本可用
- en: A wide range of languages are supported by Microsoft Visual Studio
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio支持多种语言
- en: It is widely supported by Microsoft
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它得到了微软的广泛支持
- en: It has a highly customizable environment with dockable windows
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有高度可定制的环境，可通过可停靠窗口进行定制
- en: It has intelligent code completion features
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有智能代码补全功能
- en: It is integrated with a number of Microsoft features
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与许多微软功能集成
- en: '**Cons:**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: Its full version is very expensive
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其完整版本非常昂贵
- en: Its free version is limited
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其免费版本受限
- en: Works only on Windows PC
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于Windows PC
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Microsoft Visual Studio and a wide range of other Microsoft technologies are
    available to students for free for the duration of their studies. To find out
    more about this, visit [https://www.dreamspark.com/Student/](https://www.dreamspark.com/Student/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio和其他许多微软技术可供学生免费使用。有关更多信息，请访问[https://www.dreamspark.com/Student/](https://www.dreamspark.com/Student/)。
- en: Code::Blocks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Code::Blocks
- en: The Code::Blocks IDE is a free, open source, and cross-platform IDE for development
    in C, C++, and Fortran programming languages. It's built around a plugin architecture,
    meaning it can be highly customized by installing various add-ons to create an
    IDE that best suits your needs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks IDE是一个免费、开源、跨平台的IDE，用于C、C++和Fortran编程语言的开发。它建立在插件架构之上，意味着可以通过安装各种插件来高度定制，以创建最适合您需求的IDE。
- en: '**Pros:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**'
- en: It is available for free
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是免费的
- en: It is available for all Operating Systems
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于所有操作系统
- en: It is highly customizable through the installation of add-ons
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过安装插件，它可以高度定制
- en: It supports multiple containers
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持多个容器
- en: It has intelligent code completion features
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有智能代码补全功能
- en: '**Cons:**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: It has fewer features and tools as compared to what Microsoft Visual Studio
    offers
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Microsoft Visual Studio提供的功能和工具相比，它具有较少的功能和工具
- en: Both IDEs have the required features that will allow us to create a game in
    C++. Therefore, it all boils down to personal preferences. I'll suggest Visual
    Studio, and it's the one that I'll use throughout the book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个IDE都具有我们在C++中创建游戏所需的功能。因此，一切都取决于个人偏好。我建议使用Visual Studio，并且这是我在整本书中将使用的IDE。
- en: Other IDEs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他IDE
- en: 'Visual Studio and Code::Blocks are just two examples of the many IDEs that
    are available. If you don''t prefer either, the following are a number of alternate
    cross-platform IDEs. All of them are capable of developing C++ code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio和Code::Blocks只是众多可用的IDE中的两个例子。如果您不喜欢这两个，以下是一些备选的跨平台IDE。它们都能够开发C++代码：
- en: NetBeans (Windows, Mac OS X, and Linux)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans（Windows、Mac OS X和Linux）
- en: Eclipse (Windows, Mac OS X, and Linux)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse（Windows、Mac OS X和Linux）
- en: Code Lite (Windows, Mac OS X, and Linux)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Code Lite（Windows、Mac OS X和Linux）
- en: Build systems
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建系统
- en: An alternative to using an IDE is compiling via a build system. These systems
    decouple the build process from the IDE or code editor that you're using, giving
    you more control over the process. Build systems allow you to automate various
    aspects of the build process. It may be something simple, such as incrementing
    a build number, or advanced, such as automated unit tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建系统是使用IDE的替代方法。这些系统将构建过程与您使用的IDE或代码编辑器分离，使您对过程有更多控制。构建系统允许您自动化构建过程的各个方面。它可能是一些简单的事情，比如递增构建号，或者高级的事情，比如自动化单元测试。
- en: 'There are a number of build systems available, including the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的构建系统，包括以下内容：
- en: Make
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Make
- en: CMake
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake
- en: MSBuild
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSBuild
- en: Gradle
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle
- en: We won't cover the setup or use of these systems in the book. So, head to each
    systems' respective site for documentation and instructions for use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在书中涵盖这些系统的设置或使用。因此，请前往每个系统的相关网站查找文档和使用说明。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on build systems and the benefits that they provide, visit
    [http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make](http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关构建系统及其提供的好处的更多信息，请访问[http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make](http://www.cs.virginia.edu/~dww4s/articles/build_systems.html#make)。
- en: Breaking down the game template
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分解游戏模板
- en: The best way to learn is by practicing. Examples are great, but there's nothing
    like getting stuck in and working on a real game. The game template provided will
    allow us to implement the systems that we're going to learn about in a real game
    as opposed to them being a collection of isolated exercises.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 学习的最佳方式是通过实践。例子很好，但没有什么比真正投入并在一个真正的游戏中工作更好。提供的游戏模板将允许我们在一个真正的游戏中实现我们将要学习的系统，而不是它们成为一系列孤立的练习。
- en: Familiarizing yourself with this template will not only help make the code examples
    throughout the book clearer, but also make the exercises at the end of each chapter
    easier. It will also allow you to use what you're learning to implement your own
    systems in the project once we're done with it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉这个模板不仅会帮助使本书中的代码示例更清晰，还会使每章末尾的练习更容易。这也将使您能够在项目完成后使用所学知识来实现自己的系统。
- en: Download templates
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载模板
- en: Before you start, download the game template so that you have the source code
    available as you run through some of the key points. The template is available
    for download on the official Packt Publishing website at [http://www.packtpub.com/support](http://www.packtpub.com/support).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请下载游戏模板，以便在浏览一些关键点时可以使用源代码。模板可在Packt Publishing官方网站[http://www.packtpub.com/support](http://www.packtpub.com/support)上下载。
- en: We'll set it up shortly, but for now, let's take a quick look at some of its
    key features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会设置它，但现在让我们快速查看一些其关键特性。
- en: The class diagram
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类图
- en: Included with the project download is an image of the complete class diagram
    for our solution. If at any point you have any questions about the structure of
    the template, refer to the diagram.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 项目下载包中包含了我们解决方案的完整类图像。如果您在任何时候对模板的结构有任何疑问，请参考该图表。
- en: Class diagrams are a great way of seeing the complete structure of your software.
    As your game gets bigger and bigger, it will inevitably get more convoluted as
    inheritance structures grow larger. If you have the tools available to do so,
    it's a great idea to view a class diagram regularly and keep on top of its structure.
    It will help you identify where your structure needs work, and where doesn't.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类图是查看软件完整结构的好方法。随着游戏变得越来越大，继承结构变得越来越复杂。如果您有可用的工具，定期查看类图并保持其结构是一个好主意。这将帮助您确定您的结构需要哪些工作，以及哪些不需要。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Creating diagrams in Microsoft Visual Studio is restricted to the Professional
    edition or higher. However, there are various free tools available, such as Doxygen
    at [http://www.stack.nl/~dimitri/doxygen/index.html](http://www.stack.nl/~dimitri/doxygen/index.html)
    and ArgoUML at [http://argouml.tigris.org/](http://argouml.tigris.org/), which
    create UML diagrams from source code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Visual Studio中创建图表受限于专业版或更高版本。但是，有各种免费工具可用，例如Doxygen [http://www.stack.nl/~dimitri/doxygen/index.html](http://www.stack.nl/~dimitri/doxygen/index.html)和ArgoUML
    [http://argouml.tigris.org/](http://argouml.tigris.org/)，它们可以从源代码创建UML图表。
- en: The object hierarchy
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象层次结构
- en: All objects in the template follow a set inheritance hierarchy. At the base
    of all classes is the `Object` class. This provides a `sprite`, a `position`,
    an `Update()` virtual function, and a `Draw()` virtual function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的所有对象都遵循一组继承层次结构。所有类的基础是`Object`类。这提供了一个`sprite`，一个`position`，一个`Update()`虚函数和一个`Draw()`虚函数。
- en: 'All classes extend from this base class, implementing their own behaviors by
    overriding these virtual functions. In our `main` game class we create containers
    for the main base classes, grouping all items and enemies into single collections
    that we can iterate over easily:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都从这个基类扩展，通过覆盖这些虚拟函数来实现它们自己的行为。在我们的`main`游戏类中，我们为主要基类创建容器，将所有物品和敌人分组到可以轻松迭代的单个集合中：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A vector of base class pointers allows us to take advantage of polymorphism
    and store all the classes that inherit from the same parent classes in a single
    data structure. Don't worry if you're unfamiliar with polymorphism. Towards the
    end of the chapter we'll take a look at both polymorphism and the object pipeline
    to add an object to the game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基类指针的向量使我们能够利用多态性，并将从相同父类继承的所有类存储在单个数据结构中。如果您对多态性不熟悉，不要担心。在本章的末尾，我们将研究多态性和对象管道，以将对象添加到游戏中。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We're using the `std::unique_ptr` C++11 smart pointer over raw pointers. For
    more information on smart pointers and their benefits, visit [https://msdn.microsoft.com/en-us/library/hh279674.aspx](https://msdn.microsoft.com/en-us/library/hh279674.aspx).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在C++11中使用`std::unique_ptr`智能指针而不是原始指针。有关智能指针及其好处的更多信息，请访问[https://msdn.microsoft.com/en-us/library/hh279674.aspx](https://msdn.microsoft.com/en-us/library/hh279674.aspx)。
- en: Level data
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级别数据
- en: 'The game template that is provided is a `roguelike` template. Given this, the
    level is described as a grid. The best way to represent a grid in this context
    is with a 2D array, and to store all the information that we need, we''ll use
    a custom data type named `Tile`, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的游戏模板是一个`roguelike`模板。鉴于此，级别被描述为一个网格。在这种情况下，表示网格的最佳方式是使用2D数组，并且为了存储我们需要的所有信息，我们将使用名为`Tile`的自定义数据类型，如下所示：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `struct` allows us to have a single 2D array of the `Tile` type, which
    can store all the information that each tile needs. This approach is incredibly
    common when creating a game of this type. The array is found in the `Level` class,
    which is instantiated at the beginning of the game. It encapsulates all the data
    pertaining to the level.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`允许我们拥有一个`Tile`类型的单个2D数组，可以存储每个瓦片需要的所有信息。在创建这种类型的游戏时，这种方法非常常见。该数组位于`Level`类中，在游戏开始时实例化。它封装了与级别相关的所有数据。
- en: For now, level data is stored in a simple text file which is parsed during the
    runtime by performing a simple lookup on an enumerator that defines all the tile
    types. We will work on an example of this towards the end of the chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，级别数据存储在一个简单的文本文件中，在运行时通过对定义所有瓦片类型的枚举进行简单查找来解析。我们将在本章末尾的示例中进行这方面的工作。
- en: 'The following screenshot shows how the level data is saved:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了级别数据是如何保存的：
- en: '![Level data](img/B04920_02_02.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![级别数据](img/B04920_02_02.jpg)'
- en: Collision
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞
- en: Collisions are based on the `ID` of the tile that you're currently standing
    on. Every time a player starts to move, the position that they will be in after
    a successful move is calculated. This position is then used to calculate the grid
    `tile` that they are placed on. This tile is then used to determine what action
    should be performed; the action can involve performing a blocking movement, picking
    up an item, or taking damage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞是基于您当前所站的瓦片的“ID”。每当玩家开始移动时，将计算成功移动后他们将处于的位置。然后使用这个位置来计算他们所在的网格“瓦片”。然后使用这个瓦片来确定应执行什么操作；操作可能涉及执行阻塞移动、拾取物品或受到伤害。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This type of collision can lead to the bullet through paper problem, but given
    the game's speed, this isn't an issue in our case. If you're unaware of what this
    problem is, look it up online; it may catch you out in later projects!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的碰撞可能导致子弹穿过纸的问题，但鉴于游戏的速度，这在我们的情况下不是问题。如果您不知道这个问题是什么，请在网上查找；它可能在以后的项目中让您出乎意料！
- en: Input
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入
- en: Input is handled through a custom static `Input` class. It works much like the
    `Input` class that is provided with SFML, but it combines a number of possible
    inputs into a single call. For example, when checking whether the left key is
    pressed, it will check the *A* key, Left arrow key, left *D*-Pad, and analog stick.
    If this was to be done using the standard `Input` class, you would have to check
    all four individually. The `Input` class provided streamlines this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是通过自定义的静态`Input`类处理的。它的工作方式很像SFML提供的`Input`类，但它将多个可能的输入组合成一个调用。例如，当检查左键是否按下时，它将检查*A*键、左箭头键、左*D*-Pad和模拟摇杆。如果使用标准的`Input`类来完成这个任务，您将不得不分别检查所有四个。提供的`Input`类简化了这一过程。
- en: 'A public `enum` of keycodes is defined in `input.h` and contains the following
    values that are used to poll input:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`input.h`中定义了一个公共的键码枚举，并包含以下用于轮询输入的值：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To check the input, we simply call `Inputs IsKeyPressed(KEY keycode)` statically,
    passing one of the aforementioned valid keycodes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查输入，我们只需静态调用`Inputs IsKeyPressed(KEY keycode)`，传递前面提到的有效键码之一。
- en: Simple and Fast Multimedia Library (SFML)
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML简单快速多媒体库
- en: Whilst you will have experience with C++, you may not have any prior experience
    with SFML. That's fine, the book doesn't assume any, so now let's take a brief
    tour through it
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能有C++的经验，但可能没有SFML的先验经验。没关系，本书不假设任何先验经验，所以现在让我们简要地浏览一下它
- en: Defining SFML
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义SFML
- en: '**SFML**, short for **Simple and Fast Multimedia Library**, is a software development
    library that provides easy access to multiple system components. It''s written
    in C++ and is split into the following succinct modules:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFML**，简称**Simple and Fast Multimedia Library**，是一个软件开发库，提供了对多个系统组件的简单访问。它是用C++编写的，并分为以下简洁的模块：'
- en: System
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统
- en: Windows
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口
- en: Graphics
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形
- en: Audio
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频
- en: Network
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: With this architecture you can easily pick and choose how you want to use SFML,
    ranging from a simple window manager to use OpenGL, to a complete multimedia library
    that is capable of making full video games and multimedia software.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构，您可以轻松地选择如何使用SFML，从简单的窗口管理器到使用OpenGL，再到完整的多媒体库，能够制作完整的视频游戏和多媒体软件。
- en: Why we'll be using SFML
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们会使用SFML
- en: SFML is both free, open-source, and has a vibrant community. With active forums
    and a selection of great tutorials on the official site, there are plenty of resources
    available for those who wish to learn. Another compelling reason to use SFML is
    that it's written in C++ and has bindings for many other languages, meaning you
    can pretty much code in any language that takes your fancy. There is probably
    a binding available for the language that you wish to use!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SFML既是免费的、开源的，又有一个充满活力的社区。在官方网站上有活跃的论坛和一系列优秀的教程，为那些希望学习的人提供了丰富的资源。使用SFML的另一个引人注目的原因是它是用C++编写的，并且有许多其他语言的绑定，这意味着您几乎可以用任何您喜欢的语言编程。您可能会发现您希望使用的语言已经有了绑定！
- en: The single most attractive feature of SFML is that it is a multiplatform library.
    An app written in SFML can compile and run on most common operating systems, including
    Windows, Linux, and Mac OS X, with the Android and iOS versions coming soon in
    the market at the time of writing this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: SFML最吸引人的特点是它是一个多平台库。使用SFML编写的应用程序可以在大多数常见操作系统上编译和运行，包括Windows、Linux和Mac OS
    X，在撰写本书时，Android和iOS版本即将上市。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For your app to be cross-compatible across various platforms, remember that
    you also have to ensure that your native code or the other libraries used, if
    any, are also cross-compatible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的应用程序跨各种平台兼容，请记住您还必须确保您的本地代码或其他使用的库（如果有的话）也是跨平台兼容的。
- en: Learning SFML
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习SFML
- en: 'During the course of the book, we''ll look at the features and functions of
    SFML that we''ll use to implement our procedural systems, but nothing more. We
    won''t be taking an in-depth look at the library, as that would require a whole
    book. Luckily, there are a few great books that are published by Packt Publishing
    dedicated to just that:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们将研究SFML的特点和功能，以实现我们的过程系统，但不会更多。我们不会深入研究这个库，因为那需要一整本书。幸运的是，Packt Publishing出版了一些专门针对这个问题的好书：
- en: SFML Game Development at [https://www.packtpub.com/game-development/sfml-game-development](https://www.packtpub.com/game-development/sfml-game-development)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML游戏开发网址[https://www.packtpub.com/game-development/sfml-game-development](https://www.packtpub.com/game-development/sfml-game-development)
- en: SFML Essentials at [https://www.packtpub.com/game-development/sfml-essentials](https://www.packtpub.com/game-development/sfml-essentials)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML基础位于[https://www.packtpub.com/game-development/sfml-essentials](https://www.packtpub.com/game-development/sfml-essentials)
- en: SFML Blueprints at [https://www.packtpub.com/game-development/sfml-blueprints](https://www.packtpub.com/game-development/sfml-blueprints)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML蓝图位于[https://www.packtpub.com/game-development/sfml-blueprints](https://www.packtpub.com/game-development/sfml-blueprints)
- en: If you want to learn more about SFML, then these books are a great place to
    start. There is also a selection of great tutorials on the official SFML site
    along with active forums. Visit [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)
    for more information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于SFML的信息，那么这些书是一个很好的起点。官方SFML网站上也有一些很棒的教程和活跃的论坛。访问[http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)获取更多信息。
- en: Alternatives
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方案
- en: While SFML is a great option for cross-platform game development, it's not the
    only one. There are a number of great libraries available, each with their own
    approaches and styles. Therefore, though we'll use SFML for this project, it's
    advised that you shop around for your next one. You may just run into your new
    favorite library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SFML是跨平台游戏开发的一个很好的选择，但并不是唯一的选择。有许多出色的库可供选择，每个都有自己的方法和风格。因此，虽然我们将在这个项目中使用SFML，但建议您为下一个项目四处寻找。您可能会遇到您新的最喜欢的库。
- en: 'Here are a few suggestions for future reference:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议供将来参考：
- en: SDL2 at [https://www.libsdl.org/download-2.0.php](https://www.libsdl.org/download-2.0.php)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDL2位于[https://www.libsdl.org/download-2.0.php](https://www.libsdl.org/download-2.0.php)
- en: Allegro at [http://liballeg.org/](http://liballeg.org/)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Allegro位于[http://liballeg.org/](http://liballeg.org/)
- en: MonoGame at [http://www.monogame.net/downloads/](http://www.monogame.net/downloads/)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MonoGame位于[http://www.monogame.net/downloads/](http://www.monogame.net/downloads/)
- en: Polymorphism
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Before we get started with the game template, we're going to take a look at
    polymorphism. It's an important feature of object-orientated programming that
    we will be taking advantage of in many of the procedural systems that we will
    create. Therefore, it's important that you have a solid understanding of not only
    what it is, but also the techniques that are used to achieve it and the potential
    pitfalls.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始游戏模板之前，我们将看一下多态。这是面向对象编程的一个重要特性，我们将在许多我们将创建的过程系统中充分利用它。因此，重要的是您不仅要对它有一个扎实的理解，还要了解用于实现它的技术和潜在的陷阱。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you already have a strong understanding of polymorphism, feel free to skip
    this section or head to [https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90)](https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90))
    for a more in-depth discussion of the topic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经对多态有很好的理解，可以跳过本节，或者访问[https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90)](https://msdn.microsoft.com/en-us/library/z165t2xk(v=vs.90))以深入讨论该主题。
- en: Polymorphism is the ability to access different objects through an individually
    implemented common interface. That's a very formal definition. So, let's break
    that down into the individual techniques and features that are used to achieve
    it. It's worth noting that while polymorphism is the standard approach in the
    games industry, it's still a choice among other schools of programming.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是通过独立实现的共同接口访问不同对象的能力。这是一个非常正式的定义。因此，让我们将其分解为用于实现它的各种技术和特性。值得注意的是，虽然多态是游戏行业的标准方法，但它仍然是编程的其他学派之一。
- en: Inheritance
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is perhaps the key component in achieving polymorphism. Inheritance
    is extending an existing class by inheriting its variables and functions, and
    then adding your own.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可能是实现多态的关键组成部分。继承是通过继承其变量和函数来扩展现有类，然后添加自己的内容。
- en: 'Let''s take a look at a typical game example. Let''s assume that we have a
    game with three different weapons: a sword, a wand, and an axe. These classes
    will share some common variables such as attack strength, durability, and attack
    speed. It would be a waste to create three individual classes and add this information
    to each, so instead we will create a parent class that includes all the shared
    information. Then, the children will inherit these values and use them the way
    they want.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个典型的游戏示例。假设我们有一个有三种不同武器的游戏：剑、魔杖和斧头。这些类将共享一些公共变量，如攻击力、耐久度和攻击速度。创建三个单独的类并将这些信息添加到每个类中将是一种浪费，因此我们将创建一个包含所有共享信息的父类。然后，子类将继承这些值并按照自己的方式使用它们。
- en: Inheritance creates an "is a" relationship. This means that since Axe is inherited
    from Weapon, Axe is a Weapon. This concept of creating a common interface in a
    parent class and implementing it in unique ways via child classes is the key to
    achieving polymorphism.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 继承创建了一个“是一个”关系。这意味着由于斧头是从武器继承而来，斧头就是一种武器。在父类中创建一个共同接口，并通过子类以独特的方式实现它的概念是实现多态的关键。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By interface, I mean the collection of functions and variables that the parent
    class passes to its children.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口，我指的是父类传递给子类的函数和变量集合。
- en: 'The following diagram illustrates this scenario in the form of a simple class
    diagram:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以简单的类图形式说明了这种情况：
- en: '![Inheritance](img/B04920_02_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/B04920_02_03.jpg)'
- en: The highlighted `Attack()` functions in the individual weapons are all inherited
    from the single `Attack()` function defined in the **Weapon** class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在各个武器中突出显示的`Attack()`函数都是从**Weapon**类中定义的单个`Attack()`函数继承而来的。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To maintain proper encapsulation and scope, it's important that our variables
    and functions are given the correct visibility modifiers. If you're unsure about
    this or you could do with a quick reminder, head to [https://msdn.microsoft.com/en-us/library/kktasw36.aspx](https://msdn.microsoft.com/en-us/library/kktasw36.aspx).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持适当的封装和范围，重要的是给予我们的变量和函数正确的可见性修饰符。如果您对此不确定，或者需要一个快速提醒，可以访问[https://msdn.microsoft.com/en-us/library/kktasw36.aspx](https://msdn.microsoft.com/en-us/library/kktasw36.aspx)。
- en: Virtual functions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚函数
- en: Continuing with the generic weapon example, we now have a parent class that
    provides a number of functions and variables that all child classes will inherit.
    In order to be able to denote our own behavior that is different from that of
    the parent class, we need to be able to override the parent functions. This is
    achieved through the use of virtual functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用通用武器示例，我们现在有一个父类，提供了许多函数和变量，所有子类都将继承。为了能够表示与父类不同的行为，我们需要能够重写父函数。这是通过使用虚函数实现的。
- en: 'Virtual functions are functions that can be overridden by implementing classes.
    In order for this to be possible, the parent class must mark the function as virtual.
    This is done by simply prefixing the virtual keyword to a function declaration
    like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数是可以被实现类重写的函数。为了实现这一点，父类必须将函数标记为虚函数。只需在函数声明前加上virtual关键字即可：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In a child class, we can then override that function by providing our own definition,
    provided the signatures of the two functions are identical. This override is done
    automatically, however, C++11 introduced the `override` keyword to specifically
    denote where a function will override the function of a parent. The override keyword
    is optional, but it''s considered good practice and it is recommended. It is used
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中，我们可以通过提供自己的定义来重写该函数，前提是两个函数的签名相同。这种重写是自动完成的，但是C++11引入了`override`关键字，用于明确指示函数将重写父类的函数。override关键字是可选的，但被认为是良好的实践，并且建议使用。使用方法如下：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'C++11 also introduced the `final` keyword. This keyword is used to designate
    virtual functions that cannot be overridden in a derived class. It can also be
    applied to classes that cannot be inherited. You can use the final keyword as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++11还引入了`final`关键字。该关键字用于指定不能在派生类中重写的虚函数。它也可以应用于不能被继承的类。您可以如下使用final关键字：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the `Attack()` function could not be overridden by inheriting
    classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Attack()`函数无法被继承类重写。
- en: Pure virtual functions
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯虚函数
- en: Virtual functions that we just covered allow a function to be *optionally* overridden
    by an inheriting class. The override is optional, as the parent class will provide
    a default implementation if one is not found in the child class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍的虚函数允许继承类*可选*地重写函数。重写是可选的，因为如果在子类中找不到默认实现，父类将提供默认实现。
- en: A pure virtual function however does not provide a default implementation. Hence,
    it must be implemented by inheriting classes. Furthermore, if a class contains
    a pure virtual function, it becomes abstract. This means that it cannot be instantiated,
    only inheriting classes, providing they provide an implementation for the pure
    virtual function, can be. If a class inherits from an abstract class and does
    not provide an implementation for pure virtual functions, then that class becomes
    abstract too.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，纯虚函数不提供默认实现。因此，它必须由继承类实现。此外，如果一个类包含纯虚函数，它就变成了抽象类。这意味着它无法被实例化，只有继承类可以，前提是它们为纯虚函数提供了实现。如果一个类从抽象类继承，并且没有为纯虚函数提供实现，那么该类也变成了抽象类。
- en: 'The syntax that is used to declare a pure virtual function is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 声明纯虚函数的语法如下：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the example of the `Weapon` parent class, which is inherited by `Sword`,
    `Axe` and `Wand`, it would make sense to make `Weapon` an abstract class. We will
    never instantiate a `Weapon` object; its sole purpose is to provide a common interface
    to its children. Since each child class needs to have an `Attack()` function,
    it then makes sense to make the `Attack()` function in `Weapon` pure virtual,
    as we know that every child will implement it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Weapon`父类的例子中，它被`Sword`，`Axe`和`Wand`继承，将`Weapon`设为抽象类是有意义的。我们永远不会实例化`Weapon`对象；它的唯一目的是为其子类提供一个公共接口。由于每个子类都需要有一个`Attack()`函数，因此在`Weapon`中将`Attack()`函数设为纯虚函数是有意义的，因为我们知道每个子类都会实现它。
- en: Pointers and object slicing
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针和对象切片
- en: 'The last part of the polymorphism puzzle is the use of pointers. Consider the
    following two lines of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 多态谜题的最后一部分是指针的使用。考虑以下两行代码：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first line, we are not using pointers; in the second one, we are. It
    is a seemingly small difference, but it produces extremely different results.
    To properly demonstrate this, we're going to look at a small program that defines
    a number of weapons.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们没有使用指针；在第二行中，我们使用了指针。这似乎是一个小差别，但它产生了极其不同的结果。为了正确演示这一点，我们将看一个定义了多种武器的小程序。
- en: Tip
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the `Weapon` class contains a pure virtual function, the first line of the
    preceding code won't be compiled since it will be abstract and cannot be instantiated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Weapon`类包含一个纯虚函数，前面代码的第一行将无法编译，因为它是抽象的，无法实例化。
- en: 'You can download the code for this program from the Packt Publishing website.
    It will be in the `Examples` folder, and the project name is `polymorphism_example`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Packt Publishing网站下载此程序的代码。它将在`Examples`文件夹中，项目名称为`polymorphism_example`：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code we created a base struct `Weapon`. We then inherit from it to create
    a specific implementation named `Sword`. The base `Weapon` struct defines the
    `GetItemType()` function and `Sword` overrides it to change and then return the
    item type. This is a pretty straightforward case of inheritance and polymorphism,
    but there are some important things that we need to know that could otherwise
    trip us up.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个基本结构`Weapon`。然后我们从中继承，创建了一个名为`Sword`的具体实现。基本`Weapon`结构定义了`GetItemType()`函数，而`Sword`重写它以更改并返回物品类型。这是一个很简单的继承和多态的例子，但有一些重要的事情我们需要知道，否则可能会让我们困惑。
- en: 'As the code currently stands, the `Weapon` object is instantiated in the following
    way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，代码中`Weapon`对象是这样实例化的：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the code and see what we get:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码，看看我们得到了什么：
- en: '![Pointers and object slicing](img/B04920_02_04.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![指针和对象切片](img/B04920_02_04.jpg)'
- en: Even though we assigned `myWeapon` a `Sword` object, it's a `Weapon` object.
    What's happening here? The problem is that `myWeapon` is given a fixed type of
    weapon. When we try to assign it a `Sword` object, it gets passed to the `copy`
    constructor of `Weapon` and gets sliced, leaving just a `Weapon` object. As a
    result, when we call the `GetItemType()` function, we call the function in `Weapon`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为`myWeapon`分配了一个`Sword`对象，但它是一个`Weapon`对象。这里发生了什么？问题在于`myWeapon`被赋予了一个固定类型的武器。当我们尝试为它分配一个`Sword`对象时，它被传递给`Weapon`的`copy`构造函数并被切割，只留下一个`Weapon`对象。因此，当我们调用`GetItemType()`函数时，我们调用的是`Weapon`中的函数。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a more in-depth explanation of object slicing, head to [http://www.bogotobogo.com/cplusplus/slicing.php](http://www.bogotobogo.com/cplusplus/slicing.php).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有关对象切割的更深入解释，请访问[http://www.bogotobogo.com/cplusplus/slicing.php](http://www.bogotobogo.com/cplusplus/slicing.php)。
- en: 'To avoid this and make good use of polymorphism, we need to work with pointers.
    Let''s make the following change to the code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以链接SFML：**静态**和**动态**库。静态库是编译到可执行文件中的库。这意味着您的可执行文件会更大，但您不必担心在运行时获取库。动态库不会链接到可执行文件中，这会导致可执行文件更小，但会创建依赖关系。
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Smart pointers such as `unique_ptr` require the `include <memory>`. So don't
    forget to add this to the top of the file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 像`unique_ptr`这样的智能指针需要`include <memory>`。所以不要忘记将其添加到文件的顶部。
- en: 'Since we''ve now changed `myWeapon` to a pointer, we also need to change the
    following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在把`myWeapon`改成了指针，我们还需要改变以下内容：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When working with pointers, we need to use the `->` operator to access its
    variables and functions. Now, let''s rerun the code and see what the output is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用指针时，我们需要使用`->`运算符来访问它的变量和函数。现在，让我们重新运行代码，看看输出是什么：
- en: '![Pointers and object slicing](img/B04920_02_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![指针和对象切割](img/B04920_02_05.jpg)'
- en: This time, we called the overridden function in the `Sword` struct as intended,
    and it boils down to the way we defined `myWeapon`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下载SFML
- en: Since `myWeapon` is now a pointer to a `Weapon` object, we avoid object slicing.
    Since `Sword` is derived from `Weapon`, pointing to a `Sword` in memory isn't
    a problem. They share a common interface, so we achieve this overriding behavior.
    Returning to the initial definition, polymorphism is the ability to access different
    objects through an individually implemented common interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`myWeapon`现在是指向`Weapon`对象的指针，我们避免了对象切割。由于`Sword`是从`Weapon`派生出来的，指向内存中的`Sword`并不是问题。它们共享一个公共接口，因此我们实现了这种重写行为。回到最初的定义，多态性是通过独立实现的公共接口访问不同对象的能力。
- en: The roguelike template setup
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来，您需要为您的编译器选择正确的软件包。如果您使用Microsoft Visual Studio，您只需要选择与您版本匹配的年份，如果您使用Code::Blocks，或者其他任何IDE，选择您正在使用的**GNU编译器集合（GCC）**的版本。
- en: A template is provided with this book for a `roguelike` game that was created
    specifically for the book. It's been designed to receive the work that we'll cover,
    and at the end of the book, you'll have a fully functional roguelike game that
    implements everything that you will have learned. Now that we've brushed up on
    our understanding of polymorphism, let's get the template setup. The first step
    is to download and link SFML.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供了一个专门为本书创建的`roguelike`游戏的模板。它被设计为接收我们将要涵盖的工作，并且在本书结束时，您将拥有一个完全功能的roguelike游戏，实现了您将学到的一切。现在我们已经复习了我们对多态性的理解，让我们开始设置模板。第一步是下载并链接SFML。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The project, as provided, is linked with SMFL 32-bit windows libraries. This
    should suit most systems. If this is compatible with your system, you can skip
    the following steps.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供的项目链接了SMFL 32位Windows库。这应该适合大多数系统。如果这与您的系统兼容，您可以跳过以下步骤。
- en: Downloading SFML
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载SFML
- en: 'SFML is available in a number of different precompiled packages. For example,
    the latest release at the time of writing this book has 12 packages available
    for Windows alone, so it''s important that you download the correct one for your
    system. The following steps will help you to download and setup SFML:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: SFML有许多不同的预编译软件包可用。例如，在撰写本书时的最新版本仅在Windows上就有12个软件包可用，因此重要的是您为您的系统下载正确的软件包。以下步骤将帮助您下载并设置SFML：
- en: Visit at [http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)
    to find the SFML download page. Unless you specifically need to target a 64-bit
    machine, choose the 32-bit libraries. A 32-bit program will work fine on a 64-bit
    machine.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)查找SFML下载页面。除非您特别需要针对64位机器，否则选择32位库。32位程序在64位机器上可以正常工作。
- en: Next, you need to choose the right package for your compiler. If you're using
    Microsoft Visual Studio, you just need to choose the year that matches your version,
    and if you're using Code::Blocks, or any other IDE for that matter, choose the
    version of **GNU Compiler Collection** (**GCC**) that you're using.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，我们按照预期调用了`Sword`结构中的重写函数，这归结为我们如何定义`myWeapon`。
- en: Once you've identified the correct version for your system, download it and
    extract the contents of the `.zip` file to where you want SFML to be saved. This
    location has nothing to do with your project; they don't need to share a directory.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了适合您系统的正确版本，请下载并提取`.zip`文件的内容到您想要保存SFML的位置。这个位置与您的项目无关；它们不需要共享一个目录。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can build SFML on your own to create a custom package if you wish or need
    to do so. For instructions on how to do so, visit [https://github.com/SFML/SFML](https://github.com/SFML/SFML).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望或需要这样做，可以自己构建SFML以创建自定义软件包。有关如何执行此操作的说明，请访问[https://github.com/SFML/SFML](https://github.com/SFML/SFML)。
- en: Linking SFML
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了避免这种情况并充分利用多态性，我们需要使用指针。让我们对代码进行以下更改：
- en: 'There are two ways to link SFML: **static** and **dynamic** libraries. A static
    library is the one that is compiled into your executable. This means that your
    executable is bigger, but you don''t have to worry about getting the library during
    the runtime. Dynamic libraries do not get linked into the executable, which results
    in a smaller executable, but creates dependencies.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 链接SFML
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more information on the difference between `static` and `dynamic` libraries,
    visit [http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/](http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`static`和`dynamic`库之间的区别的更多信息，请访问[http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/](http://www.learncpp.com/cpp-tutorial/a1-static-and-dynamic-libraries/)。
- en: We're going to link dynamically, which means that to run the game, you will
    need the `.dll` files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行动态链接，这意味着要运行游戏，您将需要`.dll`文件。
- en: To do so, first copy the `DLL` files that the game will need from the SFML source
    to the project's executable location. Copy all the files from `<sfml-install-path/bin>`
    to `<project-location/Debug>`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先从SFML源中将游戏需要的`DLL`文件复制到项目的可执行位置。将所有文件从`<sfml-install-path/bin>`复制到`<project-location/Debug>`。
- en: Next, we have to tell the compiler where the SFML headers are and the linker
    where the out libraries are. Headers are `.hpp` files, and libraries are `.lib`
    files. This step slightly differs depending on which IDE you're using.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须告诉编译器SFML头文件在哪里，链接器输出库在哪里。头文件是`.hpp`文件，库是`.lib`文件。这一步根据您使用的IDE有所不同。
- en: 'In Microsoft Visual Studio, add the following to the project''s properties:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Visual Studio中，将以下内容添加到项目的属性中：
- en: The path to the SFML headers (`<sfml-install-path>/include`) to **C/C++** |
    **General** | **Additional Include Directories**
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML头文件的路径（`<sfml-install-path>/include`）到**C/C++** | **General** | **Additional
    Include Directories**
- en: The path to the SFML libraries (`<sfml-install-path>/lib`) to **Linker** | **General**
    | **Additional Library Directories**
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML库的路径（`<sfml-install-path>/lib`）到**Linker** | **General** | **Additional
    Library Directories**
- en: 'In Code::Blocks, add the following to the project''s **Build Options** and
    **Search Directories** tab:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Code::Blocks中，将以下内容添加到项目的**Build Options**和**Search Directories**选项卡：
- en: The path to the SFML headers (`<sfml-install-path>/include`) to the `Compiler`
    search directories
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML头文件的路径（`<sfml-install-path>/include`）到`Compiler`搜索目录
- en: The path to the SFML libraries (`<sfml-install-path>/lib`) to the `Linker` search
    directories
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML库的路径（`<sfml-install-path>/lib`）到`Linker`搜索目录
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: These paths are the same in both the `Debug` and `Release` configurations. Therefore,
    they can be set globally for the project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径在`Debug`和`Release`配置中是相同的。因此，它们可以全局设置为项目。
- en: The final step is to link our project to the SFML libraries that are being used.
    SFML is made up of five modules, but we won't use all of them. We're using `System`,
    `Windows`, `Graphics`, and `Audio`. Therefore, we only need to link to these libraries.
    Unlike the previous step, the project configuration is important. There are separate
    libraries for the `Debug` and `Release` configurations. Therefore, you need to
    ensure that you link the correct ones.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们的项目链接到正在使用的SFML库。SFML由五个模块组成，但我们不会使用所有模块。我们使用`System`，`Windows`，`Graphics`和`Audio`。因此，我们只需要链接到这些库。与上一步不同，项目配置很重要。`Debug`和`Release`配置有单独的库。因此，您需要确保链接正确的库。
- en: 'In the `Debug` configuration, we need to add the following libraries:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Debug`配置中，我们需要添加以下库：
- en: '`sfml-system-d.lib`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfml-system-d.lib`'
- en: '`sfml-window-d.lib`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfml-window-d.lib`'
- en: '`sfml-graphics-d.lib`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfml-graphics-d.lib`'
- en: '`sfml-audio-d.lib`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sfml-audio-d.lib`'
- en: Now, do the same for the **Release** configuration. However, drop the `–d` from
    each. For example, we add `sfml-system-d.lib` in the **Debug** configuration,
    and we add `sfml-system.lib` in the **Release** configuration.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于**Release**配置做同样的事情。但是，从每个中删除`-d`。例如，在**Debug**配置中添加`sfml-system-d.lib`，在**Release**配置中添加`sfml-system.lib`。
- en: To add these to Microsoft Visual Studio, they must be added to the project's
    properties by navigating to **Linker** | **Input** | **Additional Dependencies**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们添加到Microsoft Visual Studio中，必须通过导航到**Linker** | **Input** | **Additional
    Dependencies**将它们添加到项目的属性中。
- en: To add these to Code::Blocks, they must be added to the **Link Libraries** list
    in the project's build options under the **Linker Settings** tab.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们添加到Code::Blocks中，必须在**Linker Settings**选项卡下的项目构建选项的**Link Libraries**列表中添加它们。
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have any queries regarding this setup, visit [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)
    for a complete breakdown along with images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此设置有任何疑问，请访问[http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php)获取完整的详细信息以及图片。
- en: Running the project
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'Now that SFML is linked to our project, we should be ready to perform the first
    build. The following screenshot shows our currently empty roguelike game:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在SFML已链接到我们的项目，我们应该准备进行第一次构建。以下截图显示了我们目前空白的地牢游戏：
- en: '![Running the project](img/B04920_02_06.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![运行项目](img/B04920_02_06.jpg)'
- en: As the project currently stands, we have a runnable application that spawns
    a player in a fixed room. The first task involves adding an item.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有一个可以运行的应用程序，在一个固定的房间中生成一个玩家。第一个任务涉及添加一个项目。
- en: Adding an item
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个项目
- en: All items that we create need to inherit from the base `Item` class because
    all game items are stored in a single vector of the `std::unique_ptr<Item>` type.
    With this data structure we can take advantage of polymorphism, and store all
    the item subclasses in a single structure; through this, we can update and draw
    each item.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有项目都需要继承自基类`Item`，因为所有游戏项目都存储在`std::unique_ptr<Item>`类型的单个向量中。通过这种数据结构，我们可以利用多态性，并将所有项目子类存储在一个结构中；通过这种方式，我们可以更新和绘制每个项目。
- en: To add to this vector, simply instantiate a new item via a unique pointer. Then,
    add it to the vector using the `.push_back()` method. Since we're using unique
    pointers, we have to use `std::move()` to do so.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加到这个向量中，只需通过唯一指针实例化一个新项目。然后，使用`.push_back()`方法将其添加到向量中。由于我们使用的是唯一指针，因此必须使用`std::move()`来实现。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you're unclear about why we have to use `std::move` here, look up for unique
    pointers on the Internet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不清楚为什么我们在这里必须使用`std::move`，请在互联网上搜索唯一指针。
- en: 'In the `Game::PopulateLevel` function, let''s add a gem item, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Game::PopulateLevel`函数中，让我们添加一个宝石项目，如下所示：
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All that we have to do is create a new object via a unique pointer, give it
    a position, and then add it to the list of all the items in the level using the
    `std::move` function. Easy!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是通过一个独特的指针创建一个新对象，给它一个位置，然后使用 `std::move` 函数将其添加到关卡中所有物品的列表中。简单！
- en: Updating and drawing
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和绘制
- en: 'Once an item is added to the vector of all the objects, it will be automatically
    updated:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦物品被添加到所有对象的向量中，它将自动更新：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function iterates over all the items, checking whether they have been collected;
    if this is not the case, it updates them. The `Update()` function of each object
    has a single parameter named `timeDelta`. This is a float that contains the time
    that has passed since the last update. It's used in the main outer game loop to
    keep the game logic fixed at 60 fps.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遍历所有的物品，检查它们是否被收集；如果不是，就更新它们。每个对象的 `Update()` 函数都有一个名为 `timeDelta` 的参数。这是一个包含自上次更新以来经过的时间的浮点数。它在主游戏循环中用于保持游戏逻辑固定在
    60 fps。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To know more about the main game loop, visit [http://gafferongames.com/game-physics/fix-your-timestep/](http://gafferongames.com/game-physics/fix-your-timestep/),
    which is a great article on the subject.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于主游戏循环的信息，请访问 [http://gafferongames.com/game-physics/fix-your-timestep/](http://gafferongames.com/game-physics/fix-your-timestep/)，这是一个关于这个主题的很棒的文章。
- en: 'Items are drawn in a similar way; their container is simply iterated over in
    the `Game::Draw` function. This loop is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 物品的绘制方式类似；它们的容器只是在 `Game::Draw` 函数中进行迭代。循环如下：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `m_window` variable is a pointer to the render window. Hence, we pass it
    to each object so that it can use it to draw itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_window` 变量是一个指向渲染窗口的指针。因此，我们将它传递给每个对象，以便它可以用它来绘制自己。'
- en: 'Now, if you run the game, you will see the gem in the room along with the gold,
    as shown in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏，你会看到房间里的宝石和金子，就像下面的截图所示：
- en: '![Updating and drawing](img/B04920_02_07.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![更新和绘制](img/B04920_02_07.jpg)'
- en: Exercises
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To help you test your knowledge of this chapter's content, here are a few exercises
    that you should work on. They are not imperative to the rest of the book, but
    working on them will help you assess your strengths and weakness on the material
    covered.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习题供你练习。它们对于本书的其余部分并不是必要的，但是练习它们将有助于你评估所涵盖材料的优势和劣势。
- en: Create a name for your game and change the text of the main window to reflect
    this change.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的游戏创建一个名称，并更改主窗口的文本以反映这一变化。
- en: 'Consider the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What is the visibility of `x`, `y`, and `z` in `class B`?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 类中 `x`、`y` 和 `z` 的可见性是什么？'
- en: Add more items to the level.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中添加更多物品。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we made preparations that are needed in order to start coding
    the game and create the procedural systems. We looked at the software and libraries
    that we will use, and the game template that we'll extend. We also took a crash
    course in polymorphism and the techniques that we will use to achieve it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了一些准备工作，以便开始编写游戏并创建程序系统。我们看了看将要使用的软件和库，以及我们将扩展的游戏模板。我们还快速学习了多态性和实现它的技术。
- en: We're now ready to start creating our own procedural systems. The groundwork
    that we just covered isn't terribly exciting, but it is crucial to understanding
    the work that we're going to cover when moving forward. In the next chapter we're
    going to use what we learned about random number generation with C++ data types
    to spawn random items, and give our player random stats.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始创建我们自己的程序系统。我们刚刚介绍的基础工作并不是非常令人兴奋，但对于理解我们将要涉及的工作至关重要。在下一章中，我们将利用我们在 C++
    数据类型中学到的关于随机数生成的知识来生成随机物品，并给我们的玩家随机属性。
