["```cpp\n//ch13_rca_uninit_variable.cpp\n#include <iostream>\nint main()\n{\n  int32_t x;\n  // ... //do something else but not assign value to x\n  if (x>0) {\n    std::cout << \"do A, x=\" << x << std::endl;\n  }\n  else {\n    std::cout << \"do B, x=\" << x << std::endl;\n  }\n  return 0;\n}\n```", "```cpp\n//ch13_rca_compound.cpp\n#include <iostream>\nint f(int x, int y)\n{\n  return x*y;\n}\n\nint main()\n{\n  int x = 3;\n  std::cout << f(++x, x) << std::endl; //bad,f(4,4) or f(4,3)?\n}\n```", "```cpp\n//ch13_rca_mix_sign_unsigned.cpp\n#include <iostream>\nusing namespace std;\nint main()\n{\n int32_t x = 10;\n uint32_t y = 20;\n uint32_t z = x - y; //z=(uint32_t)x - y\n cout << z << endl; //z=4294967286\\. \n}\n```", "```cpp\n//ch13_rca_order_of_evaluation.cpp\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  A(int x) : v2(v1), v1(x) {\n  };\n  void print() {\n    cout << \"v1=\" << v1 << \",v2=\" << v2 << endl;\n  };\nprotected:\n  //bad: the order of the class member is confusing, better\n  //separate it into two lines for non-ambiguity order declare   \n  int v1, v2; \n};\n\nclass B {\npublic:\n  //good: since the initialization order is: v1 -> v2, \n  //after this we have: v1==x, v2==x.\n  B(int x) : v1(x), v2(v1) {};\n\n  //wrong: since the initialization order is: v1 -> v2, \n  //after this we have: v1==uninitialized, v2==x. \n  B(float x) : v2(x), v1(v2) {};\n  void print() {\n    cout << \"v1=\" << v1 << \", v2=\" << v2 << endl;\n  };\n\nprotected:\n  int v1; //good, here the declaration order is clear\n  int v2;\n};\n\nint main()\n{\n  A a(10);\n  B b1(10), b2(3.0f);\n  a.print();  //v1=10,v2=10,v3=10 for both debug and release\n  b1.print(); //v1=10, v2=10 for both debug and release\n  b2.print(); //v1=-858993460,v2=3 for debug; v1=0,v2=3 for release.\n}\n```", "```cpp\n//check # of bits for int\n//courtesy: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\nint nBits = 0; // don't: avoidable code\nfor (int i = 1; i; i <<= 1){\n     ++nBits;\n}\nif (nBits < 32){\n    cerr << \"int too small\\n\";\n}\n```", "```cpp\n static_assert(sizeof(int) >= 4); //compile-time check\n```", "```cpp\nvoid read_into(int* p, int n); // a function to read max n integers into *p\n...\nint v[10];\nread_into(v, 100); //bad, off the end, but the compile cannot catch this error.\n```", "```cpp\nvoid read_into( span<int> buf); // read into a range of integers\n...\nint v[10];\nread_into(v); //better, the compiler will figure out the number of elements\n```", "```cpp\nvoid f_bad(){\n T* p = new T() ;\n  ...                 //do something with p\n delete p ;           //leak if throw or return before reaching this line \n}\n```", "```cpp\nvoid f_better()\n{\n std::auto_ptr<T> p(new T()) ; //other smart pointers is ok also\n ...                           //do something with p\n //will not leak regardless whether this point is reached or not\n}\n```", "```cpp\nvoid f_bad()\n{\n shared_ptr<Base> b = make_shared<Derived>();\n ...            \n} //b will be destroyed at here\n```", "```cpp\nvoid f_better()\n{\n unique_ptr<Base> b = make_unique<Derived>();\n ...            //use b locally\n}               //b will be destroyed at here\n```", "```cpp\n~wus1/chapter-13$ gdb --help \n```", "```cpp\nThis is the GNU debugger. Usage:\n gdb [options] [executable-file [core-file or process-id]]\n gdb [options] --args executable-file [inferior-arguments ...]\n\n Selection of debuggee and its files:\n --args Arguments after executable-file are passed to inferior\n --core=COREFILE Analyze the core dump COREFILE.\n --exec=EXECFILE Use EXECFILE as the executable.\n ...\n```", "```cpp\n~wus1/chapter-13$ s*udo apt-get install build-essential* \n```", "```cpp\n~wus1/chapter-13$***sudo yum install  build-essential***\n```", "```cpp\n~wus1/chapter-13$***brew install gdb***\n```", "```cpp\n//ch13_gdb_1.cpp\n#include <iostream>\nfloat multiple(float x, float y);\nint main()\n{\n float x = 10, y = 20;\n float z = multiple(x, y);\n printf(\"x=%f, y=%f, x*y = %f\\n\", x, y, z);\n return 0;\n}\n\nfloat multiple(float x, float y)\n{\n float ret = x + y; //bug, should be: ret = x * y;\n return ret;\n}\n```", "```cpp\n~wus1/chapter-13$ g++ -g ch13_gdb_1.cpp -o ch13_gdb_1.out\n```", "```cpp\nx=10.000000, y=20.000000, x*y = 30.000000\n```", "```cpp\n~wus1/chapter-13$ gdb ch13_gdb_1.out\n```", "```cpp\nGNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git\n Copyright (C) 2018 Free Software Foundation, Inc.\n License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n This is free software: you are free to change and redistribute it.\n There is NO WARRANTY, to the extent permitted by law. Type \"show copying\"\n and \"show warranty\" for details.\n This GDB was configured as \"aarch64-linux-gnu\".\n Type \"show configuration\" for configuration details.\n For bug reporting instructions, please see:\n <http://www.gnu.org/software/gdb/bugs/>.\n Find the GDB manual and other documentation resources online at:\n <http://www.gnu.org/software/gdb/documentation/>.\n For help, type \"help\".\n Type \"apropos word\" to search for commands related to \"word\"...\n Reading symbols from a.out...done.\n (gdb) \n```", "```cpp\n(gdb) b main\nBreakpoint 1 at 0x8ac: file ch13_gdb_1.cpp, line 6.\n(gdb) r\nStarting program: /home/nvidia/wus1/Chapter-13/a.out\n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library \"/lib/aarch64-linux-gnu/libthread_db.so.1\". \n\nBreakpoint 1, main () at ch13_gdb_1.cpp:6\n6 float x = 10, y = 20;\n```", "```cpp\n(gdb) n\n 7 float z = multiple(x, y);\n (gdb) p z\n $1 = 0\n (gdb) n\n 8 printf(\"x=%f, y=%f, x*y = %f\\n\", x, y, z);\n (gdb) p z\n $2 = 30\n (gdb) q\n A debugging session is active.\n Inferior 1 [process 29187] will be killed.\n Quit anyway? (y or n) y\n ~/wus1/Chapter-13$\n```", "```cpp\n~/wus1/Chapter-13$gdb ch13_gdb_1.out\n ...\n (gdb) b main\n Breakpoint 1 at 0x8ac: file ch13_gdb_1.cpp, line 6.\n (gdb) r\n The program being debugged has been started already.\n Start it from the beginning? (y or n) y\n Starting program: /home/nvidia/wus1/Chapter-13/a.out\n [Thread debugging using libthread_db enabled]\n Using host libthread_db library \"/lib/aarch64-linux-gnu/libthread_db.so.1\".                                                                                Breakpoint 1, main () at ch13_gdb_1.cpp:6\n 6 float x = 10, y = 20;\n (gdb) n\n 7 float z = multiple(x, y);\n (gdb) s\n multiple (x=10, y=20) at ch13_gdb_1.cpp:14\n 14 float s = x + y;\n (gdb) n\n 15 return s;\n (gdb) p s\n $1 = 30\n```", "```cpp\n(gdb) h b      \n Set breakpoint at specified location.\n break [PROBE_MODIFIER] [LOCATION] [thread THREADNUM] [if CONDITION]\n PROBE_MODIFIER shall be present if the command is to be placed in a\n probe point. Accepted values are `-probe' (for a generic, automatically\n guessed probe type), `-probe-stap' (for a SystemTap probe) or\n `-probe-dtrace' (for a DTrace probe).\n LOCATION may be a linespec, address, or explicit location as described\n below.\n  ....\n\n (gdb) h r\n Start debugged program.\n You may specify arguments to give it.\n Args may include \"*\", or \"[...]\"; they are expanded using the\n shell that will start the program (specified by the \"$SHELL\" environment\n variable). Input and output redirection with \">\", \"<\", or \">>\"\n are also allowed.\n\n (gdb) h s\n Step program until it reaches a different source line.\n Usage: step [N]\n Argument N means step N times (or till program stops for another reason).\n\n (gdb) h n\n Step program, proceeding through subroutine calls.\n Usage: next [N]\n Unlike \"step\", if the current source line calls a subroutine,\n this command does not enter the subroutine, but instead steps over\n the call, in effect treating it as a single source line.\n\n (gdb) h p\n Print value of expression EXP.\n Variables accessible are those of the lexical environment of the selected\n stack frame, plus all those whose scope is global or an entire file.\n\n (gdb) h h\n Print list of commands.\n (gdb) h help\n Print list of commands.\n (gdb) help h\n Print list of commands.\n (gdb) help help\n Print list of commands.\n```", "```cpp\n//ch13_gdb_2.cpp\n#include <iostream>\n\nfloat dotproduct( const float *x, const float *y, const int n);\nint main()\n{\n float sxx,sxy;\n float x[] = {1,2,3,4,5};\n float y[] = {0,1,1,1,1};\n\n sxx = dotproduct( x, x, 5);\n sxy = dotproduct( x, y, 5);\n printf( \"dot(x,x) = %f\\n\", sxx );\n printf( \"dot(x,y) = %f\\n\", sxy );\n return 0;\n}\n\nfloat dotproduct( const float *x, const float *y, const int n )\n{\n const float *p = x;\n const float *q = x;  //bug: replace x by y\n float s = 0;\n for(int i=0; i<n; ++i, ++p, ++q){\n        s += (*p) * (*q);\n }\n return s;\n}\n```", "```cpp\n~/wus1/Chapter-13$ g++ -g ch13_gdb_2.cpp -o ch13_gdb_2.out\n~/wus1/Chapter-13$ ./ch13_gdb_2.out\ndot(x,x) = 55.000000\ndot(x,y) = 55.000000\n```", "```cpp\n(gdb) b dot<Press TAB Key>\n```", "```cpp\n(gdb) b dotproduct(float const*, float const*, int)\n```", "```cpp\n(gdb) b MyClass::foo(<Press TAB key>\n```", "```cpp\n(gdb) b f.cpp:26 if s==0 //set a breakpoint in f.cpp, line 26 if s==0\n(gdb) b f.cpp:20 if ((int)strcmp(y, \"hello\")) == 0 \n```", "```cpp\n(gdb) i b (gdb) delete breakpoints 1 (gdb) delete breakpoints 2-5\n```", "```cpp\n(gdb) cond 1         //break point 1 is unconditional now\n```", "```cpp\n(gdb) watch v                 //watch the value of variable v\n(gdb) watch *(int*)0x12345678 //watch an int value pointed by an address\n(gdb) watch a*b + c/d         // watch an arbitrarily complex expression\n```", "```cpp\n//gdb output of example ch13_gdb_2.out -- part 1\n~/wus1/Chapter-13$ gdb ch13_gdb_2.out                     //cmd 1\n ...\n Reading symbols from ch13_gdb_2.out ... done.\n\n (gdb) b dotproduct(float const*, float const*, int)      //cmd 2\n Breakpoint 1 at 0xa5c: file ch13_gdb_2.cpp, line 20.\n (gdb) b ch13_gdb_2.cpp:24 if i==1                        //cmd 3\n Breakpoint 2 at 0xa84: file ch13_gdb_2.cpp, line 24.\n (gdb) i b                                                //cmd 4\n Num Type Disp Enb Address What\n 1 breakpoint keep y 0x0000000000000a5c in dotproduct(float const*, float const*, int) at ch13_gdb_2.cpp:20\n 2 breakpoint keep y 0x0000000000000a84 in dotproduct(float const*, float const*, int) at ch13_gdb_2.cpp:24\n stop only if i==1\n (gdb) cond 2                                            //cmd 5\n Breakpoint 2 now unconditional.\n (gdb) i b                                               //cmd 6\n Num Type Disp Enb Address What\n 1 breakpoint keep y 0x0000000000000a5c in dotproduct(float const*, float const*, int) at ch13_gdb_2.cpp:20\n 2 breakpoint keep y 0x0000000000000a84 in dotproduct(float const*, float const*, int) at ch13_gdb_2.cpp:24 \n```", "```cpp\n//gdb output of example ch13_gdb_2.out -- part 2 \n(gdb) r                                                //cmd 7\n Starting program: /home/nvidia/wus1/Chapter-13/ch13_gdb_2.out\n [Thread debugging using libthread_db enabled]\n Using host libthread_db library \"/lib/aarch64-linux-gnu/libthread_db.so.1\".\n\n Breakpoint 1, dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:20\n 20 const float *p = x;\n (gdb) p x                                            //cmd 8\n $1 = (const float *) 0x7fffffed68\n (gdb) c                                              //cmd 9 \n Continuing.\n\n Breakpoint 2, dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:24\n 24 s += (*p) * (*q);\n (gdb) p i                                           //cmd 10\n $2 = 0\n (gdb) n                                             //cmd 11\n 23 for(int i=0; i<n; ++i, ++p, ++q){\n (gdb) n                                             //cmd 12\n\n Breakpoint 2, dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:24\n 24 s += (*p) * (*q);\n (gdb) p s                                           //cmd 13 \n $4 = 1\n (gdb) watch s                                       //cmd 14 \n Hardware watchpoint 3: s\n```", "```cpp\n//gdb output of example ch13_gdb_2.out -- part 3 \n(gdb) n                                             //cmd 15 \n  Hardware watchpoint 3: s\n\n Old value = 1\n New value = 5\n dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:23\n 23 for(int i=0; i<n; ++i, ++p, ++q){\n (gdb) finish                                       //cmd 16\n Run till exit from #0 dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:23\n\n Breakpoint 2, dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:24\n 24 s += (*p) * (*q);\n (gdb) delete breakpoints 1-3                       //cmd 17\n (gdb) c                                            //cmd 18\n Continuing.\n\n dot(x,x) = 55.000000\n dot(x,y) = 55.000000\n [Inferior 1 (process 31901) exited normally]\n [Inferior 1 (process 31901) exited normally]\n (gdb) q                                           //cmd 19\n ~/wus1/Chapter-13$\n```", "```cpp\n(gdb) set logging on\n```", "```cpp\n(gdb) set logging off\n```", "```cpp\n~/wus1/Chapter-13$ gdb ch13_gdb_2.out           //cmd 1\n ...\nReading symbols from ch13_gdb_2.out...done.\n (gdb) set logging on                           //cmd 2\n Copying output to gdb.txt.\n (gdb) b ch13_gdb_2.cpp:24 if i==1              //cmd 3 \n Breakpoint 1 at 0xa84: file ch13_gdb_2.cpp, line 24.\n (gdb) r                                        //cmd 4 \n ...\n Breakpoint 1, dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:24\n 24 s += (*p) * (*q);\n (gdb) p i                                      //cmd 5 \n $1 = 1\n (gdb) p s                                      //cmd 6 \n $2 = 1\n (gdb) finish                                   //cmd 7 \n Run till exit from #0 dotproduct (x=0x7fffffed68, y=0x7fffffed68, n=5) at ch13_gdb_2.cpp:24\n 0x00000055555559e0 in main () at ch13_gdb_2.cpp:11\n 11 sxx = dotproduct( x, x, 5);\n Value returned is $3 = 55\n (gdb) delete breakpoints 1                    //cmd 8\n (gdb) set logging off                         //cmd 9\n Done logging to gdb.txt.\n (gdb) c                                       //cmd 10 \n Continuing.\n dot(x,x) = 55.000000\n dot(x,y) = 55.000000\n [Inferior 1 (process 386) exited normally]\n (gdb) q                                      //cmd 11\n ~/wus1/Chapter-13$ cat gdb.txt               //cmd 12\n```", "```cpp\n//ch13_static_analysis.cpp\n#include <iostream>\nint *getPointer(void)\n{\n    return 0;\n}\n\nint &getVal() {\n    int x = 5;\n    return x;\n}\n\nint main()\n{\n    int *x = getPointer();\n    if( x> 0 ){\n        *x = 5;\n   }\n   else{\n       std::cout << \"x is null\" << std::endl;\n   }\n\n   int &y = getVal();\n   std::cout << y << std::endl;\n   return 0;\n}\n```", "```cpp\ng++ -o ch13_static.out ch13_static_analysis.cpp \n```", "```cpp\ng++ -Wall -o ch13_static.out ch13_static_analysis.cpp\ng++ -Weffc++ -o ch13_static.out ch13_static_analysis.cpp\ng++ -Wextra -o ch13_static.out ch13_static_analysis.cpp\n```", "```cpp\nch13_static_analysis.cpp: In function \u2018int& getVal()\u2019:\nch13_static_analysis.cpp:9:6: warning: reference to local variable \u2018x\u2019 returned [-Wreturn-local-addr]\nint x = 5;\n ^\n```", "```cpp\n ch13_static_analysis.cpp: In function \u2018int& getVal()\u2019:\n ch13_static_analysis.cpp:9:6: warning: reference to local variable \u2018x\u2019 returned [-Wreturn-local-addr]\n int x = 5;\n ^\n ch13_static_analysis.cpp: In function \u2018int main()\u2019:\n ch13_static_analysis.cpp:16:10: warning: ordered comparison of pointer with integer zero [-Wextra]\n if( x> 0 ){\n ^\n```", "```cpp\n//ch13_dynamic_analysis.cpp\n#include <iostream>\nint main()\n{\n    int n=10;\n    float *p = (float *)malloc(n * sizeof(float));\n    for( int i=0; i<n; ++i){\n        std::cout << p[i] << std::endl;\n    }\n    //free(p);  //leak: free() is not called\n    return 0;\n}\n```", "```cpp\nsudo apt install valgrind //for Ubuntu, Debian, etc.\n```", "```cpp\nvalgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \\\n --verbose --log-file=valgrind-out.txt ./myExeFile myArgumentList\n```", "```cpp\ng++ -o ch13_dyn -std=c++11 -Wall ch13_dynamic_analysis.cpp\n```", "```cpp\nvalgrind --leak-check=full --show-leak-kinds=all --track-origins=yes \\\n --verbose --log-file=log.txt ./ch13_dyn\n```", "```cpp\n... //ignore many lines at begining\n by 0x108A47: main (in /home/nvidia/wus1/Chapter-13/ch13_dyn)\n ==18930== Uninitialised value was created by a heap allocation\n ==18930== at 0x4844BFC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-arm64-linux.so)\n ... //ignore many lines in middle\n ==18930== HEAP SUMMARY:\n ==18930== in use at exit: 40 bytes in 1 blocks\n ==18930== total heap usage: 3 allocs, 2 frees, 73,768 bytes allocated\n ==18930==\n ==18930== 40 bytes in 1 blocks are definitely lost in loss record 1 of 1\n ==18930== at 0x4844BFC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-arm64-linux.so)\n ==18930==\n ==18930== LEAK SUMMARY:\n ==18930== definitely lost: 40 bytes in 1 blocks\n ==18930== indirectly lost: 0 bytes in 0 blocks\n ==18930== possibly lost: 0 bytes in 0 blocks\n ==18930== still reachable: 0 bytes in 0 blocks\n ==18930== suppressed: 0 bytes in 0 blocks\n```", "```cpp\n//ch13_unit_test1.cpp\n#define BOOST_TEST_MODULE my_test //item 1, \"my_test\" is module name\n#include <boost/test/included/unit_test.hpp> //item 2, header-only\n\n//declare we begin a test suite and name it \"my_suite \"\nBOOST_AUTO_TEST_SUITE( my_suite ) \n\n//item 3, add a test case into test suit, here we choose \n//        BOOST_AUTO_TEST_CASE and name it \"test_case1\" \nBOOST_AUTO_TEST_CASE(test_case1) {\n char x = 'a';\n BOOST_TEST(x);        //item 4, checks if c is non-zero\n BOOST_TEST(x == 'a'); //item 4, checks if c has value 'a'\n BOOST_TEST(x == 'b'); //item 4, checks if c has value 'b'\n}\n\n//item 3, add the 2nd test case\nBOOST_AUTO_TEST_CASE( test_case2 )\n{\n  BOOST_TEST( true );\n}\n\n//item 3, add the 3rd test case\nBOOST_AUTO_TEST_CASE( test_case3 )\n{\n  BOOST_TEST( false );\n}\n\nBOOST_AUTO_TEST_SUITE_END() //declare we end test suite\n```", "```cpp\nsudo apt-get install libboost-all-dev\n```", "```cpp\n~/wus1/Chapter-13$ g++ -g  ch13_unit_test1.cpp \n~/wus1/Chapter-13$ ./a.out\n```", "```cpp\nRunning 3 test cases...\n ch13_unit_test1.cpp(13): error: in \"my_suite/test_case1\": check x == 'b' has failed ['a' != 'b']\n ch13_unit_test1.cpp(25): error: in \"my_suite/test_case3\": check false has failed\n\n *** 2 failures are detected in the test module \"my_test\"\n```", "```cpp\n// ch13_tdd_boost_UTF1.cpp\n#define BOOST_TEST_MODULE tdd_test\n#include <boost/test/included/unit_test.hpp>\n#include \"ch13_tdd_v1.h\"\n\nBOOST_AUTO_TEST_SUITE(tdd_suite)  //begin a test suite: \"tdd_suite\"\n\nBOOST_AUTO_TEST_CASE(test_case1) {\n  Mat<int> x(2, 3);            //create a 2 x 3 int matrix\n  x.print(\"int x=\");\n  BOOST_TEST(2 == x.rows());\n  BOOST_TEST(3 == x.cols());\n\n  Mat<float> y;              //create a 0 x 0 empty float matrix\n  y.print(\"float y=\");\n  BOOST_TEST(0 == y.rows());\n  BOOST_TEST(0 == y.cols());\n\n  Mat<char> z(1,10);       //create a 1 x 10 char matrix\n  z.print(\"char z=\");\n  BOOST_TEST(1 == z.rows());\n  BOOST_TEST(10 == z.cols());\n}\nBOOST_AUTO_TEST_SUITE_END() //end test suite\n```", "```cpp\n//file: ch13_tdd_v1.h\n#ifndef __ch13_TDD_V1__\n#define __ch13_TDD_V1__\n#include <iostream>\n#include <assert.h>\ntemplate< class T>\nclass Mat {\npublic:\n  Mat(const uint32_t m=0, const uint32_t n=0);\n  Mat(const Mat<T> &rhs) = delete;\n  ~Mat();\n\n  Mat<T>& operator = (const Mat<T> &x) = delete;\n\n  uint32_t rows() { return m_rows; }\n  uint32_t cols() { return m_cols; }\n  void print(const char* str) const;\n\nprivate:\n  void creatBuf();\n  void deleteBuf();\n  uint32_t m_rows; //# of rows\n  uint32_t m_cols; //# of cols\n  T* m_buf;\n};\n#include \"ch13_tdd_v1.cpp\"\n#endif\n```", "```cpp\n//file: ch13_tdd_v1.cpp\n#include \"ch13_tdd_v1.h\"\nusing namespace std;\n\ntemplate< class T>\nMat<T>::Mat(const uint32_t m, const uint32_t n)\n : m_rows(m)\n , m_cols(n)\n , m_buf(NULL)\n{\n creatBuf();\n}\n\ntemplate< class T>\nMat<T> :: ~Mat()\n{ \n deleteBuf(); \n}\n\ntemplate< class T>\nvoid Mat<T>::creatBuf()\n{\n uint32_t sz = m_rows * m_cols;\n if (sz > 0) {\n if (m_buf) { deleteBuf();}\n m_buf = new T[sz];\n assert(m_buf);\n }\n else {\n m_buf = NULL;\n }\n}\n\ntemplate< class T>\nvoid Mat<T>::deleteBuf()\n{\n if (m_buf) {\n delete[] m_buf;\n m_buf = NULL;\n }\n}\n\ntemplate< class T>\nvoid Mat<T> ::print(const char* str) const\n{\n cout << str << endl;\n cout << m_rows << \" x \" << m_cols << \"[\" << endl;\n const T *p = m_buf;\n for (uint32_t i = 0; i<m_rows; i++) {\n for (uint32_t j = 0; j < m_cols; j++) {\n cout << *p++ << \", \";\n }\n cout << \"\\n\";\n }\n cout << \"]\\n\";\n}\n```", "```cpp\n~/wus1/Chapter-13$ g++ -g ch13_tdd_boost_UTF1.cpp~/wus1/Chapter-13$ a.out \n```", "```cpp\nRunning 1 test case...\n int x=2 x 3[\n 1060438054, 1, 4348032,\n 0, 4582960, 0,\n ]\n float y=0 x 0[\n ]\n char z=1 x 10[\n s,s,s,s,s,s,s,s,s,s,\n ]\n```", "```cpp\n// ch13_tdd_Boost_UTF2.cpp\n#define BOOST_TEST_MODULE tdd_test\n#include <boost/test/included/unit_test.hpp>\n#include \"ch13_tdd_v2.h\"\n\n//declare we begin a test suite and name it \"tdd_suite\"\nBOOST_AUTO_TEST_SUITE(tdd_suite)\n\n//add the 1st test case\nBOOST_AUTO_TEST_CASE(test_case1) {\n  Mat<int> x(2, 3);\n  x.print(\"int x=\");\n  BOOST_TEST(2 == x.rows());\n  BOOST_TEST(3 == x.cols());\n\n  Mat<float> y;\n  BOOST_TEST(0 == y.rows());\n  BOOST_TEST(0 == y.cols());\n\n  Mat<char> z(1, 10);\n  BOOST_TEST(1 == z.rows());\n  BOOST_TEST(10 == z.cols());\n}\n\n//add the 2nd test case\nBOOST_AUTO_TEST_CASE(test_case2)\n{\n  Mat<int> x(2, 3, 10);\n  x.print(\"int x=\");\n  BOOST_TEST( 6 == x.numel() );\n  BOOST_TEST( false == x.empty() );\n\n  Mat<float> y;\n  BOOST_TEST( 0 == y.numel() );\n  BOOST_TEST( x.empty() ); //bug x --> y \n}\n\nBOOST_AUTO_TEST_SUITE_END() //declare we end test suite\n```", "```cpp\nRunning 2 test cases...\n int x=2x3[\n 1057685542, 1, 1005696,\n 0, 1240624, 0,\n ]\n int x=2x3[\n 10, 10, 10,\n 10, 10, 10,\n ]\n ../Chapter-13/ch13_tdd_Boost_UTF2.cpp(34): error: in \"tdd_suite/test_case2\": che\n ck x.empty() has failed [(bool)0 is false]\n```"]