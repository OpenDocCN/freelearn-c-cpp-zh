- en: Designing Concurrent Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计并发数据结构
- en: In the previous chapter, we touched on the basics of concurrency and multithreading
    in C++. One of the biggest challenges in concurrent code design is properly handling
    data races. Thread synchronization and orchestration is not an easy topic to grasp,
    although we might consider it the most important one. While we can use synchronization
    primitives such as mutexes everywhere that we have the slightest doubt about a
    data race, it's not a best practice that we would advise.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了C++中并发和多线程的基础知识。并发代码设计中最大的挑战之一是正确处理数据竞争。线程同步和协调并不是一个容易理解的话题，尽管我们可能认为它是最重要的话题。虽然我们可以在任何我们对数据竞争有丝毫怀疑的地方使用互斥量等同步原语，但这并不是我们建议的最佳实践。
- en: A better way of designing concurrent code is to avoid locks at all costs. That
    would not only increase the performance of the application but also make it much
    safer than before. Easier said than done – lock-free programming is a challenging
    topic that we are introducing in this chapter. In particular, we will go further
    into the fundamentals of designing lock-free algorithms and data structures. This
    is a hard topic being continuously researched by many outstanding developers.
    We will touch on the basics of lock-free programming, which will give you an idea
    of how to construct your code in an efficient way. After reading this chapter,
    you will be better able to picture problems with data races and acquire the basic
    knowledge needed to design concurrent algorithms and data structures. It might also
    be helpful for your general design skills to build fault-tolerant systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计并发代码的更好方式是尽量避免使用锁。这不仅会提高应用程序的性能，还会使其比以前更安全。说起来容易做起来难——无锁编程是一个具有挑战性的话题，我们将在本章中介绍。特别是，我们将更深入地了解设计无锁算法和数据结构的基础知识。这是一个由许多杰出的开发人员不断研究的难题。我们将简要介绍无锁编程的基础知识，这将让您了解如何以高效的方式构建代码。阅读完本章后，您将更好地能够理解数据竞争问题，并获得设计并发算法和数据结构所需的基本知识。这也可能有助于您的一般设计技能，以构建容错系统。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding data races and lock-based solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据竞争和基于锁的解决方案
- en: Using atomics in C++ code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++代码中使用原子操作
- en: Designing lock-free data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计无锁数据结构
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the `-std=c++2a` option is used to compile the examples
    in this chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用g++编译器的`-std=c++2a`选项来编译示例。您可以在以下链接找到本章中使用的源文件：[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: A closer look at data races
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更深入地了解数据竞争
- en: As already stated many times, data races are situations programmers try to avoid
    at all costs. In the previous chapter, we discussed a deadlock and ways to avoid
    it. The last example that we used in the previous chapter was making a thread-safe
    singleton pattern. Let's suppose we use a class for creating database connections
    (a classic example).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如已经多次提到的，数据竞争是程序员们尽量避免的情况。在上一章中，我们讨论了死锁及其避免方法。上一章中我们使用的最后一个示例是创建一个线程安全的单例模式。假设我们使用一个类来创建数据库连接（一个经典的例子）。
- en: 'Here''s a simple implementation of the pattern that tracks down the connections
    to the database. Keeping a separate connection each time we need access to the
    database is not a good practice. Instead, we reuse the existing connection for
    querying the database from different parts of the program:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个跟踪数据库连接的模式的简单实现。每次需要访问数据库时保持单独的连接并不是一个好的做法。相反，我们可以重用现有的连接来从程序的不同部分查询数据库：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s discuss that example in more detail. In the previous chapter, we incorporated
    locking to protect the `get_instance()` function from data races. Let''s illustrate
    in detail why we did so. To simplify this for the example, here are the four lines
    of interest to us:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论这个例子。在上一章中，我们加入了锁来保护`get_instance()`函数免受数据竞争的影响。让我们详细说明为什么这样做。为了简化这个例子，以下是我们感兴趣的四行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, imagine that we run a thread that accesses the `get_instance()` function.
    We name it `Thread A` and the first line that it executes is the conditional statement,
    as shown:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们运行一个访问`get_instance()`函数的线程。我们称它为`线程A`，它执行的第一行是条件语句，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will execute the instructions line by line. What interests us more is the
    second thread (marked as `Thread B`), which starts executing the function concurrent
    to `Thread A`. The following situation might arise during the concurrent execution
    of the function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它将逐行执行指令。我们更感兴趣的是第二个线程（标记为`线程B`），它开始并发执行`线程A`的函数。在函数并发执行期间可能出现以下情况：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Thread B` gets a positive result when it compares `instance_` against `nullptr`.
    `Thread A` has passed the same check and sets `instance_` to a new object. While
    from the perspective of `Thread A` everything looks fine, it just passed the conditional
    check, resets `instances`, and will move on to the next line to return `instance_`.
    However, `Thread B` compared `instance_` right before it had its value changed.
    Therefore, `Thread B` also moves on to setting the value of `instance_`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`线程B`在将`instance_`与`nullptr`进行比较时得到了一个正结果。`线程A`已经通过了相同的检查，并将`instance_`设置为一个新对象。从`线程A`的角度来看，一切都很正常，它刚刚通过了条件检查，重置了`instances`，并将继续执行下一行返回`instance_`。然而，`线程B`在它的值改变之前就比较了`instance_`。因此，`线程B`也继续设置`instance_`的值：'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding issue is that `Thread B` resets `instance_` after it has already
    been set. Also, we view `get_instance()` as a single operation; it consists of
    several instructions, each of which is executed sequentially by a thread. For
    two threads not to interfere with each other, the operation shouldn't consist
    of more than one instruction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的问题是`线程B`在`instance_`已经被设置之后重置了它。此外，我们将`get_instance()`视为一个单独的操作；它由几条指令组成，每条指令都由一个线程按顺序执行。为了让两个线程不相互干扰，操作不应该包含多于一条指令。
- en: 'The reason why we are concerned with data races is the gap pictured in the
    code block preceding. That gap between the lines is something that allows threads
    to interfere with each other. When you design a solution using a synchronization
    primitive, such as a mutex, you should picture all the gaps that you miss because
    the solution might not be the correct one. The following modification uses mutex
    and the `double-checked` locking pattern discussed in the previous chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注数据竞争的原因是代码块中的间隙。代码行之间的这个间隙允许线程相互干扰。当你使用互斥锁等同步原语设计解决方案时，你应该考虑你错过的所有间隙，因为解决方案可能不正确。下面的修改使用了在前一章讨论过的互斥锁和`双重检查`锁定模式：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s what happens when two threads try to access the `instance_` object:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个线程尝试访问`instance_`对象时会发生什么：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, even when both threads pass the first check, one of them locks the mutex.
    While one of the threads might try to lock the mutex, the other will reset the
    instance. To make sure it''s not already set, we use the second check (that''s
    why it''s called **double-checked locking**):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使两个线程都通过了第一次检查，其中一个线程也会锁定互斥锁。当一个线程尝试锁定互斥锁时，另一个线程会重置实例。为了确保它尚未设置，我们使用第二次检查（这就是为什么它被称为**双重检查锁定**）：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When `Thread A` finishes setting `instance_`, it then unlocks the mutex so
    `Thread B` can move on with locking and resetting `instance_`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当`线程A`完成设置`instance_`后，它会解锁互斥锁，这样`线程B`就可以继续锁定和重置`instance_`：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As a rule of thumb, you should always look between the lines of the code. There
    is always a gap between two statements, and that gap will make two or more threads
    interfere with each other. The next section discusses a classic example of incrementing
    a number in detail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，你应该总是查看代码中的细节。两个语句之间总是有一个间隙，这个间隙会导致两个或更多的线程相互干扰。接下来的部分将详细讨论一个经典的递增数字的例子。
- en: A synchronized increment
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步递增
- en: 'Almost every book touching on the topic of thread synchronization uses the
    classic example of incrementing a number as a data racing example. This book is
    not an exception. The example follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每本涉及线程同步主题的书都使用递增数字的经典例子作为数据竞争的例子。这本书也不例外。例子如下：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We added a couple more threads to make the example more complex. The preceding
    code does nothing more than increment the `counter` variable using four different
    threads. At first glance, at any point in time, only one of the threads increments
    `counter`. However, as we mentioned in the previous section, we should be attentive
    and look for gaps in the code. The `foo()` function seems to be missing one. The
    increment operator behaves in the following way (as pseudocode):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了几个线程，使示例变得更加复杂。前面的代码只是使用四个不同的线程递增`counter`变量。乍一看，任何时候只有一个线程递增`counter`。然而，正如我们在前一节中提到的，我们应该注意并寻找代码中的间隙。`foo()`函数似乎缺少一个。递增运算符的行为如下（伪代码）：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have discovered gaps where there weren''t supposed to be any. So now,
    at any point in time, only one thread executes one of the three preceding instructions.
    That is, something like the following is possible:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们发现了本不应该有的间隙。因此，任何时候只有一个线程执行前面三条指令中的一条。也就是说，类似下面的情况是可能的：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, for example, `thread B` might modify the value of `counter` while `thread
    A` reads its previous value. That means `thread A` will assign a new increment
    value to `counter` when it has been already done by `thread B`. The confusion
    introduces chaos and, sooner or later, our brains will explode trying to understand
    the ordering of operations. As a classic example, we''ll move on to solving it
    by using thread-locking mechanisms. Here''s a popular solution:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`线程B`可能在`线程A`读取其先前值时修改`counter`的值。这意味着`线程A`在`线程B`已经完成递增`counter`时会给`counter`赋予一个新的递增值。混乱引入了混乱，迟早，我们的大脑会因为尝试理解操作的顺序而爆炸。作为一个经典的例子，我们将继续使用线程锁定机制来解决这个问题。以下是一个常见的解决方案：
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Whichever thread arrives at `lock_guard` first locks `mutex`, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪个线程首先到达`lock_guard`都会锁定`mutex`，如下所示：
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem with using locking is performance. In theory, we use threads to
    speed up program execution, more specifically, data processing. In the case of
    big collections of data, using multiple threads might increase the program's performance
    drastically. However, in a multithreaded environment, we take care of concurrent
    access first because accessing the collection with multiple threads might lead
    to its corruption. For example, let's look at a thread-safe stack implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用锁定的问题在于性能。理论上，我们使用线程来加快程序执行，更具体地说，是数据处理。在处理大量数据的情况下，使用多个线程可能会极大地提高程序的性能。然而，在多线程环境中，我们首先要处理并发访问，因为使用多个线程访问集合可能会导致其损坏。例如，让我们看一个线程安全的堆栈实现。
- en: Implementing a thread-safe stack
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现线程安全的堆栈
- en: 'Recall the stack data structure adapter from [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),
    *Digging into Data Structures and Algorithms in STL*. We are going to implement
    a thread-safe version of the stack using locks. The stack has two basic operations,
    `push` and `pop`. Both of them modify the state of the container. As you know,
    the stack is not a container itself; it''s an adapter that wraps a container and
    provides an adapted interface to access. We will wrap `std::stack` in a new class
    by incorporating thread-safety. Besides construction and destruction functions,
    `std::stack` provides the following functions:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下来自[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)的栈数据结构适配器，《深入STL中的数据结构和算法》。我们将使用锁来实现栈的线程安全版本。栈有两个基本操作，`push`和`pop`。它们都修改容器的状态。正如您所知，栈本身不是一个容器；它是一个包装容器并提供适应接口以进行访问的适配器。我们将在一个新的类中包装`std::stack`，并加入线程安全性。除了构造和销毁函数外，`std::stack`提供以下函数：
- en: '`top()`: Accesses the top element of the stack'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top()`: 访问栈顶元素'
- en: '`empty()`: Returns true if the stack is empty'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()`: 如果栈为空则返回true'
- en: '`size()`: Returns the current size of the stack'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 返回栈的当前大小'
- en: '`push()`: Inserts a new item into the stack (at the top)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()`: 将新项插入栈中（在顶部）'
- en: '`emplace()`: Constructs an element in place at the top of the stack'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emplace()`: 在栈顶就地构造一个元素'
- en: '`pop()`: Removes the top element of the stack'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`: 移除栈顶元素'
- en: '`swap()`: Swaps the contents with another stack'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap()`: 与另一个栈交换内容'
- en: 'We will keep it simple and concentrate on the idea of thread-safety rather
    than making a powerful full-featured stack. The main concerns here are functions
    that modify the underlying data structure. Our interest lies in the `push()` and
    `pop()` functions. Those are functions that might corrupt the data structure if
    several threads interfere with each other. So, the following declaration is the
    class representing a thread-safe stack:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持简单，专注于线程安全的概念，而不是制作功能强大的完整功能栈。这里的主要关注点是修改底层数据结构的函数。我们感兴趣的是`push()`和`pop()`函数。这些函数可能在多个线程相互干扰时破坏数据结构。因此，以下声明是表示线程安全栈的类：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we declared `mutex_` as mutable because we locked it in the `empty()`
    const function. It's arguably a better design choice than removing the const-ness
    of `empty()`. However, you should know by now that using a mutable for any of
    the data members suggests that we have made bad design choices. Anyway, the client
    code for `safe_stack` won't care much about the inner details of the realization;
    it doesn't even know that the stack uses a mutex to synchronize concurrent access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`mutex_`声明为可变的，因为我们在`empty()` const函数中对其进行了锁定。这可能是一个比去除`empty()`的const性更好的设计选择。然而，您现在应该知道，对于任何数据成员使用可变性都意味着我们做出了糟糕的设计选择。无论如何，`safe_stack`的客户端代码不会太关心实现的内部细节；它甚至不知道栈使用互斥锁来同步并发访问。
- en: 'Let''s now look at the implementation of its member functions along with a
    short description. Let''s start with the copy constructor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下其成员函数的实现以及简短的描述。让我们从复制构造函数开始：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that we locked the mutex of the other stack. As unfair as it might seem,
    we need to make sure that the underlying data of the other stack won't get modified
    while we make a copy of it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们锁定了另一个栈的互斥锁。尽管这看起来不公平，但我们需要确保在复制它时，另一个栈的底层数据不会被修改。
- en: 'Next, let''s look at the implementation of the `push()` function. It''s obviously
    simple; we lock the mutex and push the data into the underlying stack:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`push()`函数的实现。显然很简单；我们锁定互斥锁并将数据推入底层栈：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Almost all functions incorporate thread synchronization in the same way: locking the
    mutex, doing the job, and unlocking the mutex. This ensures that only one thread
    is accessing the data at any one time. That said, to protect data from race conditions,
    we must ensure that the function invariants aren''t broken.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有函数都以相同的方式包含线程同步：锁定互斥锁，执行任务，然后解锁互斥锁。这确保了一次只有一个线程访问数据。也就是说，为了保护数据免受竞态条件的影响，我们必须确保函数不变量不被破坏。
- en: If you are not a fan of typing long C++ type names such as `std::lock_guard<std::mutex>`,
    use the `using` keyword to make short aliases for types, for example, using `locker
    = std::guard<std::mutex>;`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不喜欢输入长的C++类型名称，比如`std::lock_guard<std::mutex>`，可以使用`using`关键字为类型创建短别名，例如，使用`locker
    = std::guard<std::mutex>;`。
- en: 'Now, moving on to the `pop()` function, we can modify the class declaration
    to make `pop()` directly return the value at the top of the stack. We do this
    mostly because we don''t want someone to access the top of the stack (with a reference)
    and then pop that data from within another thread. So, we will modify the `pop()` function
    to make a shared object and then return the stack element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`pop()`函数，我们可以修改类声明，使`pop()`直接返回栈顶的值。我们这样做主要是因为我们不希望有人在另一个线程中访问栈顶（通过引用），然后从中弹出数据。因此，我们将修改`pop()`函数以创建一个共享对象，然后返回栈元素：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the declaration of the `safe_stack` class should also change according
    to the `pop()` function modifications. Also, we don't need `top()` anymore.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`safe_stack`类的声明也应根据`pop()`函数的修改而改变。此外，我们不再需要`top()`。
- en: Designing lock-free data structures
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计无锁数据结构
- en: If at least one thread is guaranteed to make progress, then we say it's a lock-free
    function. Compared to lock-based functions, where one thread can block another
    and they both might wait for some condition before making progress, a lock-free
    state ensures progress is made by at least one of the threads. We say that algorithms
    and data structures using data synchronization primitives are blocking, that is,
    a thread is suspended until another thread performs an action. That means the
    thread can't make progress until the block is removed (typically, unlocking a
    mutex). Our interest lies in data structures and algorithms that don't use blocking
    functions. We call some of them lock-free, although we should make a distinction
    between the types of non-blocking algorithms and data structures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个线程保证可以取得进展，那么我们称它是无锁函数。与基于锁的函数相比，其中一个线程可以阻塞另一个线程，它们可能都在等待某些条件才能取得进展，无锁状态确保至少一个线程取得进展。我们说使用数据同步原语的算法和数据结构是阻塞的，也就是说，线程被挂起，直到另一个线程执行操作。这意味着线程在解除阻塞之前无法取得进展（通常是解锁互斥锁）。我们感兴趣的是不使用阻塞函数的数据结构和算法。我们称其中一些为无锁，尽管我们应该区分非阻塞算法和数据结构的类型。
- en: Using atomic types
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子类型
- en: Earlier in the chapter, we introduced the gaps between lines of source code
    as the reason for data races. Whenever you have an operation that consists of
    more than one instruction, your brain should alert you about a possible issue.
    However, it doesn't matter how much you strive to make operations independent
    and singular; most of the time, you can't achieve anything without breaking operations
    into steps involving multiple instructions. C++ comes to the rescue by providing
    atomic types.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们介绍了源代码行之间的间隙是数据竞争的原因。每当您有一个由多个指令组成的操作时，您的大脑都应该警惕可能出现的问题。然而，无论您多么努力使操作独立和单一，大多数情况下，您都无法在不将操作分解为涉及多个指令的步骤的情况下取得任何成果。C++通过提供原子类型来拯救我们。
- en: 'First, let''s understand why the word atomic is used. In general, we understand
    atomic to mean something that can''t be broken down into smaller parts. That is,
    an atomic operation is an operation that can''t be half-done: it''s done or it
    isn''t. An example of an atomic operation might be the simple assignment of an
    integer:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解为什么使用原子这个词。一般来说，我们理解原子是指不能分解成更小部分的东西。也就是说，原子操作是一个无法半途而废的操作：要么完成了，要么没有。原子操作的一个例子可能是对整数的简单赋值：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If two threads access this line of code, neither of them can encounter it half-done.
    In other words, there are no gaps between the assignment. Of course, the same
    statement might have a lot of gaps if `num` represents a complex object with a
    user-defined assignment operator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个线程访问这行代码，它们都不可能遇到它是半成品的情况。换句话说，赋值之间没有间隙。当然，如果`num`表示具有用户定义赋值运算符的复杂对象，同一语句可能会有很多间隙。
- en: An atomic operation is an indivisible operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作是不可分割的操作。
- en: 'On the other hand, a non-atomic operation might be seen as half-done. The classic
    example is the increment operation that we discussed earlier. In C++, all operations
    on atomic types are also atomic. That means we can avoid gaps between lines by
    using atomic types. Before using atomics, we could create atomic operations by
    using mutexes. For example, we might consider the following function atomic:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，非原子操作可能被视为半成品。经典的例子是我们之前讨论过的增量操作。在C++中，对原子类型的所有操作也是原子的。这意味着我们可以通过使用原子类型来避免行之间的间隙。在使用原子操作之前，我们可以通过使用互斥锁来创建原子操作。例如，我们可能会考虑以下函数是原子的：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference between a real atomic operation and the fake one we just made
    is that atomic operations don't require locks. That's actually a big difference,
    because synchronization mechanisms such as mutexes incorporate overhead and performance
    penalties. To be more precise, atomic types leverage lower-level mechanisms to
    ensure the independent and atomic execution of instructions. The standard atomic
    types are defined in the `<atomic>` header. However, standard atomic types might
    also use internal locking. To make sure they don't use internal locking, all atomic
    types in the standard library expose the `is_lock_free()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的原子操作和我们刚刚制作的假操作之间的区别在于原子操作不需要锁。这实际上是一个很大的区别，因为诸如互斥锁之类的同步机制会带来开销和性能惩罚。更准确地说，原子类型利用低级机制来确保指令的独立和原子执行。标准原子类型在`<atomic>`头文件中定义。然而，标准原子类型可能也使用内部锁。为了确保它们不使用内部锁，标准库中的所有原子类型都公开了`is_lock_free()`函数。
- en: The only atomic type that doesn't have the `is_lock_free()` member function
    is `std::atomic_flag`. The operations on this type are required to be lock-free.
    It's a Boolean flag and most of the time it is used as a base to implement other
    lock-free types.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一没有`is_lock_free()`成员函数的原子类型是`std::atomic_flag`。对这种类型的操作要求是无锁的。它是一个布尔标志，大多数情况下被用作实现其他无锁类型的基础。
- en: 'That said, `obj.is_lock_free()` returns `true` if operations on `obj` are done
    directly with atomic instructions. If it returns false, it means internal locking
    is used. There is more: the `static constexpr` function `is_always_lock_free()`
    returns `true` if the atomic type is lock-free for all supported hardware. As
    the function is `constexpr`, it allows us to define whether the type is lock-free
    at compile time. That''s a big advancement and affects the organization and execution
    of the code in a good way. For example, `std::atomic<int>::is_always_lock_free()`
    returns `true` as `std::atomic<int>` is most probably always lock-free.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果`obj.is_lock_free()`返回`true`，则表示对`obj`的操作是直接使用原子指令完成的。如果返回false，则表示使用了内部锁。更重要的是，`static
    constexpr`函数`is_always_lock_free()`在所有支持的硬件上返回`true`，如果原子类型始终是无锁的。由于该函数是`constexpr`，它允许我们在编译时定义类型是否是无锁的。这是一个重大进步，以良好的方式影响代码的组织和执行。例如，`std::atomic<int>::is_always_lock_free()`返回`true`，因为`std::atomic<int>`很可能始终是无锁的。
- en: In Greek, a means not and tomo means cut. The word atom comes from the Greek
    atomos, which translates to uncuttable. That is, by atomic we consider indivisible
    smallest units. We use atomic types and operations to avoid gaps between instructions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在希腊语中，a 意味着不，tomo 意味着切。原子一词源自希腊语 atomos，意思是不可分割的。也就是说，原子意味着不可分割的最小单位。我们使用原子类型和操作来避免指令之间的间隙。
- en: 'We use specializations for atomic types, for example, `std::atomic<long>`;
    however, you can refer to the following table for more convenient names for atomic
    types. The left-hand column of the table contains the atomic type and the right-hand
    column contains its specialization:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用原子类型的特化，例如 `std::atomic<long>`；但是，您可以参考以下表格以获取更方便的原子类型名称。表格的左列包含原子类型，右列包含其特化：
- en: '| **Atomic type** | **Specialization** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **原子类型** | **特化** |'
- en: '| `atomic_bool` | `std::atomic<bool>` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_bool` | `std::atomic<bool>` |'
- en: '| `atomic_char` | `std::atomic<char>` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char` | `std::atomic<char>` |'
- en: '| `atomic_schar` | `std::atomic<signed char>` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_schar` | `std::atomic<signed char>` |'
- en: '| `atomic_uchar` | `std::atomic<unsigned char>` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uchar` | `std::atomic<unsigned char>` |'
- en: '| `atomic_int` | `std::atomic<int>` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_int` | `std::atomic<int>` |'
- en: '| `atomic_uint` | `std::atomic<unsigned>` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_uint` | `std::atomic<unsigned>` |'
- en: '| `atomic_short` | `std::atomic<short>` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_short` | `std::atomic<short>` |'
- en: '| `atomic_ushort` | `std::atomic<unsigned short>` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ushort` | `std::atomic<unsigned short>` |'
- en: '| `atomic_long` | `std::atomic<long>` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_long` | `std::atomic<long>` |'
- en: '| `atomic_ulong` | `std::atomic<unsigned long>` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ulong` | `std::atomic<unsigned long>` |'
- en: '| `atomic_llong` | `std::atomic<long long>` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_llong` | `std::atomic<long long>` |'
- en: '| `atomic_ullong` | `std::atomic<unsigned long long>` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_ullong` | `std::atomic<unsigned long long>` |'
- en: '| `atomic_char16_t` | `std::atomic<char16_t>` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char16_t` | `std::atomic<char16_t>` |'
- en: '| `atomic_char32_t` | `std::atomic<char32_t>` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_char32_t` | `std::atomic<char32_t>` |'
- en: '| `atomic_wchar_t` | `std::atomic<wchar_t>` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `atomic_wchar_t` | `std::atomic<wchar_t>` |'
- en: The preceding table represents basic atomic types. The fundamental difference
    between a regular type and, an atomic type is the kind of operations we can apply
    to them. Let's now discuss atomic operations in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上表代表了基本的原子类型。常规类型和原子类型之间的根本区别在于我们可以对它们应用的操作类型。现在让我们更详细地讨论原子操作。
- en: Operations on atomic types
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子类型的操作
- en: 'Recall the gaps we were discussing in the previous section. The goal of atomic
    types is to either eliminate gaps between instructions or provide operations that
    take care of combining several instructions together wrapped as a single instruction.
    The following are operations on atomic types:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在前一节讨论的间隙。原子类型的目标是要么消除指令之间的间隙，要么提供将多个指令组合在一起作为单个指令执行的操作。以下是原子类型的操作：
- en: '`load()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load()`'
- en: '`store()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store()`'
- en: '`exchange()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exchange()`'
- en: '`compare_exchange_weak()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_exchange_weak()`'
- en: '`compare_exchange_strong()`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_exchange_strong()`'
- en: '`wait()`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait()`'
- en: '`notify_one()`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_one()`'
- en: '`notify_all()`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_all()`'
- en: The `load()` operation atomically loads and returns the value of the atomic
    variable. `store()` atomically replaces the value of the atomic variable with
    the provided non-atomic argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 操作原子地加载并返回原子变量的值。`store()` 原子地用提供的非原子参数替换原子变量的值。'
- en: 'Both `load()` and `store()` are similar to regular read and assign operations
    for non-atomic variables. Whenever we access the value of an object, we execute
    a read instruction. For example, the following code prints the contents of the
    `double` variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()` 和 `store()` 与非原子变量的常规读取和赋值操作类似。每当我们访问对象的值时，我们执行一个读取指令。例如，以下代码打印了 `double`
    变量的内容：'
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the case of atomic types, a similar read operation is transformed into this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原子类型，类似的读取操作转换为：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Although the preceding code bears no meaning, we included the example to represent
    the differences in treating atomic types. Accessing atomic variables should be
    done through atomic operations. The following code represents definitions for
    the `load()`, `store()`, and `exchange()` functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管上述代码没有实际意义，但我们包含了这个例子来表示对待原子类型的不同方式。应该通过原子操作来访问原子变量。以下代码表示了 `load()`、`store()`
    和 `exchange()` 函数的定义： '
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, there is the additional parameter named `order` of type `std::memory_order`.
    We will describe it shortly. The `exchange()` function comprises the `store()`
    and `load()` functions in a way that atomically replaces the value with the provided
    argument and atomically obtains the previous value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，还有一个名为 `order` 的额外参数，类型为 `std::memory_order`。我们很快会对它进行描述。`exchange()`
    函数以一种方式包含了 `store()` 和 `load()` 函数，以便原子地用提供的参数替换值，并原子地获取先前的值。
- en: 'The `compare_exchange_weak()` and `compare_exchange_strong()` functions work
    similarly to each other. Here''s how they are defined:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare_exchange_weak()` 和 `compare_exchange_strong()` 函数的工作方式相似。它们的定义如下：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: They compare the first argument (`expected_value`) with the atomic variable
    and if they are equal, replace the variable with the second argument (`target_value`).
    Otherwise, they atomically load the value into the first argument (that's why
    it is passed by reference). The difference between weak and strong exchanges is
    that `compare_exchange_weak()` is allowed to fail falsely (called a **spurious
    failure**), that is, even when `expected_value` is equal to the underlying value,
    the function treats them as not equal. That's done because on some platforms it
    leads to increased performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将第一个参数（`expected_value`）与原子变量进行比较，如果它们相等，则用第二个参数（`target_value`）替换变量。否则，它们会原子地将值加载到第一个参数中（这就是为什么它是通过引用传递的）。弱交换和强交换之间的区别在于
    `compare_exchange_weak()` 允许出现错误（称为**虚假失败**），也就是说，即使 `expected_value` 等于底层值，该函数也会将它们视为不相等。这是因为在某些平台上，这会提高性能。
- en: The `wait()`, `notify_one()`, and `notify_all()` functions have been added since
    C++20\. The `wait()` function blocks the thread until the value of the atomic
    object modifies. It takes an argument to compare with the value of the atomic
    object. If the values are equal, it blocks the thread. To manually unblock the
    thread, we can call `notify_one()` or `notify_all()`. The difference between them
    is that `notify_one()` unblocks at least one blocked operation, while `notify_all()`
    unblocks all such operations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，已添加了`wait()`、`notify_one()`和`notify_all()`函数。`wait()`函数阻塞线程，直到原子对象的值修改。它接受一个参数与原子对象的值进行比较。如果值相等，它会阻塞线程。要手动解除线程阻塞，我们可以调用`notify_one()`或`notify_all()`。它们之间的区别在于`notify_one()`解除至少一个被阻塞的操作，而`notify_all()`解除所有这样的操作。
- en: Now, let's discuss the memory order that we encountered in the atomic type member
    functions declared previously. `std::memory_order` defines the order of memory
    accesses around atomic operation. When multiple threads simultaneously read and
    write to variables, a thread can read the changes in an order different from the
    order in which another thread stored them. The default order for atomic operations
    is sequentially consistent ordering – that's where `std::memory_order_seq_cst`
    comes in. There are several types of orders, including `memory_order_relaxed`,
    `memory_order_consume`, `memory_order_acquire`, `memory_order_release`, `memory_order_acq_rel`,
    and `memory_order_seq_cst`. In the next section, we'll design a lock-free stack
    that uses atomic types with the default memory order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论我们在先前声明的原子类型成员函数中遇到的内存顺序。`std::memory_order`定义了原子操作周围的内存访问顺序。当多个线程同时读取和写入变量时，一个线程可以按照与另一个线程存储它们的顺序不同的顺序读取更改。原子操作的默认顺序是顺序一致的顺序
    - 这就是`std::memory_order_seq_cst`的作用。有几种类型的顺序，包括`memory_order_relaxed`、`memory_order_consume`、`memory_order_acquire`、`memory_order_release`、`memory_order_acq_rel`和`memory_order_seq_cst`。在下一节中，我们将设计一个使用默认内存顺序的原子类型的无锁堆栈。
- en: Designing a lock-free stack
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计无锁堆栈
- en: One of the key things to keep in mind when designing a stack is to ensure that
    a pushed value is safe to return from another thread. Also important is ensuring
    that only one thread returns a value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 设计堆栈时要牢记的关键事项之一是确保从另一个线程返回的推送值是安全的。同样重要的是确保只有一个线程返回一个值。
- en: In the previous sections, we implemented a lock-based stack that wrapped `std::stack`.
    We know that a stack is not a real data structure but an adapter. Usually, when
    implementing a stack, we choose either a vector or a linked list as its underlying
    data structure. Let's look at an example of a lock-free stack based on a linked
    list. Pushing a new element into the stack involves creating a new list node,
    setting its `next` pointer to the current `head` node, and then setting the `head`
    node to point to the newly inserted node.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了一个基于锁的堆栈，它包装了`std::stack`。我们知道堆栈不是一个真正的数据结构，而是一个适配器。通常，在实现堆栈时，我们选择向量或链表作为其基础数据结构。让我们看一个基于链表的无锁堆栈的例子。将新元素推入堆栈涉及创建一个新的列表节点，将其`next`指针设置为当前的`head`节点，然后将`head`节点设置为指向新插入的节点。
- en: If you are confused by the terms head or next pointer, revisit [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),
    *Digging into Data Structures and Algorithms in STL*, where we discussed linked
    lists in detail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对头指针或下一个指针这些术语感到困惑，请重新阅读[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)《深入STL中的数据结构和算法》，在那里我们详细讨论了链表。
- en: 'In a single-threaded context, the steps described are fine; however, if there
    is more than one thread modifying the stack, we should start worrying. Let''s
    find the pitfalls of the `push()` operation. Here are the three main steps happening
    when a new element is pushed into the stack:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程环境中，上述步骤是可以的；但是，如果有多个线程修改堆栈，我们应该开始担心。让我们找出`push()`操作的陷阱。当将新元素推入堆栈时，发生了三个主要步骤：
- en: '`node* new_elem = new node(data);`'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`node* new_elem = new node(data);`'
- en: '`new_elem->next = head_;`'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new_elem->next = head_;`'
- en: '`head_ = new_elem;`'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`head_ = new_elem;`'
- en: In the first step, we declare the new node that will be inserted into the underlying
    linked list. The second step describes that we are inserting it at the front of
    the list – that's why the new node's `next` pointer points to `head_`. Finally,
    as the `head_` pointer represents the starting point of the list, we should reset
    its value to point to the newly added node, as done in step 3.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们声明将插入到基础链表中的新节点。第二步描述了我们将其插入到列表的前面 - 这就是为什么新节点的`next`指针指向`head_`。最后，由于`head_`指针表示列表的起始点，我们应该重置其值以指向新添加的节点，就像第3步中所做的那样。
- en: 'The node type is the internal struct that we use in the stack for representing
    a list node. Here''s how it is defined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 节点类型是我们在堆栈中用于表示列表节点的内部结构。以下是它的定义：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing that we suggest you do is look for gaps in the code – not in
    the preceding code, but in the steps we described when pushing a new element into
    the stack. Take a closer look at it. Imagine two threads are adding nodes at the
    same time. One thread at step 2 sets the next pointer of the new element to point
    to `head_`. The other thread makes `head_` point to the other new element. It''s
    already obvious that this might lead to data corruption. It''s crucial for a thread
    to have the same `head_` for both steps 2 and 3. To solve the race condition between
    steps 2 and 3, we should use an atomic compare/exchange operation to guarantee
    that `head_` wasn''t modified when we read its value previously. As we need to
    access the head pointer atomically, here''s how we modify `head_ member` in the `lock_free_stack`
    class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您首先查找代码中的空白 - 不是在前面的代码中，而是在我们描述将新元素推入堆栈时的步骤中。仔细看看。想象两个线程同时添加节点。一个线程在第2步中将新元素的下一个指针设置为指向`head_`。另一个线程使`head_`指向另一个新元素。很明显，这可能导致数据损坏。对于线程来说，在步骤2和3中有相同的`head_`是至关重要的。为了解决步骤2和3之间的竞争条件，我们应该使用原子比较/交换操作来保证在读取其值之前`head_`没有被修改。由于我们需要以原子方式访问头指针，这是我们如何修改`lock_free_stack`类中的`head_`成员的方式：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s how we implement a lock-free `push()` around the atomic `head_` pointer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在原子`head_`指针周围实现无锁`push（）`的方式：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use `compare_exchange_weak()` to ensure that the `head_` pointer has the
    same value as we stored in `new_elem->next`. If it is, we set it to `new_elem`.
    Once `compare_exchange_weak()` succeeds, we are sure the node has been successfully
    inserted into the list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`compare_exchange_weak（）`来确保`head_`指针的值与我们存储在`new_elem->next`中的值相同。如果是，我们将其设置为`new_elem`。一旦`compare_exchange_weak（）`成功，我们就可以确定节点已成功插入到列表中。
- en: 'See how we access nodes by using atomic operations. The atomic form of a pointer
    of type `T` - `std::atomic<T*>` - provides the same interface. Besides that, `std::atomic<T*>`
    provides pointer to the arithmetic operations `fetch_add()` and `fetch_sub()`.
    They do atomic addition and subtraction on the stored address. Here''s an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用原子操作访问节点。类型为`T`的指针的原子形式-`std::atomic<T*>`-提供相同的接口。除此之外，`std::atomic<T*>`还提供指针的算术操作`fetch_add（）`和`fetch_sub（）`。它们对存储的地址进行原子加法和减法。这是一个例子：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We intentionally named the pointer `old`, because `fetch_add()` adds the number
    to the address of the pointer and returns the `old` value. That's why `old` points
    to the same address that `arr` points to.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将指针命名为`old`，因为`fetch_add（）`将数字添加到指针的地址并返回`old`值。这就是为什么`old`指向与`arr`指向的相同地址。
- en: 'In the next section, we will introduce more operations available on atomic
    types. Now, let''s get back to our lock-free stack. To `pop()` an element, that
    is, to remove a node, we need to read `head_` and set it to the next element of
    `head_`, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍更多可用于原子类型的操作。现在，让我们回到我们的无锁栈。要`pop（）`一个元素，也就是移除一个节点，我们需要读取`head_`并将其设置为`head_`的下一个元素，如下所示：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, take a good look at the preceding code. Imagine several threads executing
    it concurrently. What if two threads removing items from the stack read the same
    value of `head_`? This and a couple of other race conditions lead us to the following
    implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好好看看前面的代码。想象几个线程同时执行它。如果两个从堆栈中移除项目的线程读取相同的`head_`值会怎样？这和其他一些竞争条件导致我们采用以下实现：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We applied almost the same logic in the preceding code as we did with the `push()`
    function. The preceding code isn't perfect; it should be enhanced. We suggest
    you make the effort to modify it to eliminate memory leaks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中几乎应用了与`push（）`函数相同的逻辑。前面的代码并不完美；它应该得到改进。我们建议您努力修改它以消除内存泄漏。
- en: We have seen that lock-free implementations rely heavily on atomic types and
    operations. The operations we discussed in the previous section are not final.
    Let's now discover some more atomic operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，无锁实现严重依赖于原子类型和操作。我们在上一节讨论的操作并不是最终的。现在让我们发现一些更多的原子操作。
- en: More operations on atomics
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作的更多操作
- en: 'In the previous section, we used `std::atomic<>` on a pointer to a user-defined
    type. That is, we declared the following structure for the list node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在用户定义类型的指针上使用了`std::atomic<>`。也就是说，我们为列表节点声明了以下结构：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The node struct is a user-defined type. Although in the previous section we
    instantiated `std::atomic<node*>`, in the same way, we can instantiate `std::atomic<>`
    for almost any user-defined type, that is, `std::atomic<T>`. However, you should
    note that the interface of `std::atomic<T>` is limited to the following functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 节点结构是用户定义的类型。尽管在上一节中我们实例化了`std::atomic<node*>`，但以同样的方式，我们几乎可以为任何用户定义的类型实例化`std::atomic<>`，也就是`std::atomic<T>`。但是，您应该注意`std::atomic<T>`的接口仅限于以下函数：
- en: '`load()`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load（）`'
- en: '`store()`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store（）`'
- en: '`exchange()`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exchange（）`'
- en: '`compare_exchange_weak()`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_exchange_weak（）`'
- en: '`compare_exchange_strong()`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare_exchange_strong（）`'
- en: '`wait()`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait（）`'
- en: '`notify_one()`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_one（）`'
- en: '`notify_all()`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify_all（）`'
- en: Let's now look at the complete list of operations available on atomic types
    based on the specifics of the underlying type.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们根据底层类型的特定情况来查看原子类型上可用的操作的完整列表。
- en: '`std::atomic<>` instantiated with an integral type (such as an integer or a
    pointer) has the following operations along with the ones we listed previously:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic<>`与整数类型（如整数或指针）实例化具有以下操作，以及我们之前列出的操作：'
- en: '`fetch_add()`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_add（）`'
- en: '`fetch_sub()`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_sub（）`'
- en: '`fetch_or()`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_or（）`'
- en: '`fetch_and()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_and（）`'
- en: '`fetch_xor()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch_xor（）`'
- en: 'Also, besides increment (`++`) and decrement (`--`), the following operators
    are also available: `+=`, `-=`, `|=`, `&=`, and `^=`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了增量（`++`）和减量（`--`）之外，还有以下运算符可用：`+=`，`-=`，`|=`，`&=`和`^=`。
- en: 'Finally, there is a special atomic type called `atomic_flag` with two available
    operations:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一种特殊的原子类型称为`atomic_flag`，具有两种可用操作：
- en: '`clear()`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear（）`'
- en: '`test_and_set()`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_and_set（）`'
- en: You should consider `std::atomic_flag` a bit with atomic operations. The `clear()`
    function clears it, while `test_and_set()` changes the value to `true` and returns
    the previous value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将`std::atomic_flag`视为具有原子操作的位。`clear（）`函数将其清除，而`test_and_set（）`将值更改为`true`并返回先前的值。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced a rather simple example of designing a stack.
    There are more complex examples to research and follow. When we discussed designing
    a concurrent stack, we looked at two versions, one of them representing a lock-free
    stack. Compared to lock-based solutions, lock-free data structures and algorithms
    are the ultimate goal for programmers as they provide mechanisms to avoid data
    races without even synchronizing the resources.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一个相当简单的设计堆栈的例子。还有更复杂的例子可以研究和遵循。当我们讨论设计并发堆栈时，我们看了两个版本，其中一个代表无锁堆栈。与基于锁的解决方案相比，无锁数据结构和算法是程序员的最终目标，因为它们提供了避免数据竞争的机制，甚至无需同步资源。
- en: We also introduced atomic types and operations that you can use in your projects
    to make sure instructions are indivisible. As you already know, if an instruction
    is atomic, there is no need to worry about its synchronization. We strongly suggest
    you continue researching the topic and build more robust and complex lock-free
    data structures. In the next chapter, we will see how to design world-ready applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了原子类型和操作，您可以在项目中使用它们来确保指令是不可分割的。正如您已经知道的那样，如果一条指令是原子的，就不需要担心它的同步。我们强烈建议您继续研究这个主题，并构建更健壮和复杂的无锁数据结构。在下一章中，我们将看到如何设计面向世界的应用程序。
- en: Questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why did we check the instance twice in the multithreaded singleton implementation?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多线程单例实现中为什么要检查实例两次？
- en: In the implementation of the lock-based stack's copy constructor, we locked
    the mutex of the other stack. Why?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于锁的栈的复制构造函数的实现中，为什么要锁定另一个栈的互斥量？
- en: What are atomic types and atomic operations?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原子类型和原子操作是什么？
- en: Why do we use `load()` and `store()` for atomic types?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么对原子类型使用`load()`和`store()`？
- en: What additional operations are supported on `std::atomic<T*>`?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::atomic<T*>`支持哪些额外操作？'
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Concurrent Patterns and Best Practices by Atul Khot*, at[ https://www.packtpub.com/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/application-development/concurrent-patterns-and-best-practices)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Atul Khot的并发模式与最佳实践》，网址为[https://www.packtpub.com/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/application-development/concurrent-patterns-and-best-practices)
- en: '*Mastering C++ Multithreading by Maya Posch*, at [https://www.packtpub.com/application-development/mastering-c-multithreading](https://www.packtpub.com/application-development/mastering-c-multithreading)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Maya Posch的C++多线程编程》,网址为[https://www.packtpub.com/application-development/mastering-c-multithreading](https://www.packtpub.com/application-development/mastering-c-multithreading)
