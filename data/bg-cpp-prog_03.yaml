- en: Exploring C++ Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C++类型
- en: In the last two chapters, you have learned how to put together a C++ program,
    learned about the files you use, and the ways to control execution flow. This
    chapter is about the data that you will use in your program: the type of data
    and the variables that will hold that data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，您已经学会了如何组合C++程序，了解了您使用的文件以及控制执行流程的方法。本章是关于您将在程序中使用的数据：数据类型和将保存该数据的变量。
- en: A variable can handle data of a particular format and with a particular behavior,
    and that is determined by the type of the variable. The type of the variable determines
    the operations you can perform on the data and on the format of the data when
    inputted or viewed by the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以处理特定格式和特定行为的数据，这由变量的类型确定。变量的类型确定您可以对数据执行的操作以及用户输入或查看数据的格式。
- en: 'Essentially, you can view three general categories of types: built-in types,
    custom types, and pointers. Pointers in general will be covered in the next chapter,
    and custom types, or classes, and pointers to them, will be covered in [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*. This chapter will cover
    the types that are provided as part of the C++ language.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，您可以查看三种一般类型：内置类型、自定义类型和指针。指针通常将在下一章中介绍，自定义类型或类以及指向它们的指针将在第6章《类》中介绍。本章将介绍作为C++语言一部分提供的类型。
- en: Exploring built-in types
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置类型
- en: C++ provides integer, floating point, and Boolean types. The `char` type is
    an integer but it can be used to hold individual characters and so its data can
    be viewed as a number or as a character. The C++ Standard Library provides the
    `string` class to allow you to use and manipulate strings of characters. Strings
    will be covered in depth in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供整数、浮点和布尔类型。`char`类型是整数，但它可以用于保存单个字符，因此其数据可以被视为数字或字符。C++标准库提供了`string`类，允许您使用和操作字符串。字符串将在第9章《使用字符串》中深入介绍。
- en: As the name suggests, integer types contain integral values where there are
    no fractional parts. If you perform calculations with integers you should expect
    that any fractional parts will be discarded unless you take steps to retain them
    (for example, through the remainder operator `%`). Floating point types hold numbers
    that may have a fractional part; because floating point types can hold numbers
    in a mantissa exponent format, they can hold exceptionally large or exceptionally
    small numbers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，整数类型包含没有小数部分的整数值。如果使用整数进行计算，您应该期望任何小数部分都将被丢弃，除非您采取措施保留它们（例如，通过取余运算符`%`）。浮点类型保存可能具有小数部分的数字；因为浮点类型可以以尾数指数格式保存数字，所以它们可以保存异常大或异常小的数字。
- en: A variable is an instance of a type; it is the memory allocated to hold the
    data that the type can hold. Integer and floating point variable declarations
    can be modified to tell the compiler how much memory to allocate, and thus the
    limits of the data that the variable can hold and the precision of the calculations
    performed on the variable. In addition, you can also indicate if the variable
    will hold a number where the sign is important. If the number is being used to
    hold bitmaps (where the bits do not make up a number, but have a separate meaning
    of their own) then it usually makes no sense to use a signed type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是类型的实例；它是分配的内存，用于保存类型可以保存的数据。整数和浮点变量声明可以修改以告诉编译器分配多少内存，从而限制变量可以保存的数据和对变量执行的计算的精度。此外，您还可以指示变量是否将保存重要的符号数字。如果数字用于保存位图（其中位不组成数字，而具有自己的独立含义），则通常没有意义使用有符号类型。
- en: In some cases, you will be using C++ to unpack data from a file or a network
    stream so that you can manipulate it. In this case, you will need to know whether
    the data is a floating point or integral, signed or unsigned, how many bytes are
    used and what order those bytes will be in. The order of the bytes (whether the
    first byte in a multi-byte number is the low or high part of the number) is determined
    by the processor which you are compiling for, and in most cases, you will not
    need to worry about it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您将使用C++从文件或网络流中解压数据，以便对其进行操作。在这种情况下，您需要知道数据是浮点还是整数，有符号还是无符号，使用了多少字节以及这些字节的顺序。字节的顺序（多字节数字中的第一个字节是数字的低位还是高位）由您正在编译的处理器确定，在大多数情况下，您不需要担心它。
- en: Similarly, sometimes you may need to know about the size of a variable and how
    it is aligned in memory; in particular, when you are using records of data, known
    in C++ as `structs`. C++ provides the `sizeof` operator to give the number of
    bytes used to hold a variable and the `alignof` operator to determine the alignment
    of the type in memory. For basic types, the `sizeof` and `alignof` operators return
    the same value; it is only necessary to call the `alignof` operator on custom
    types where it will return the alignment of the largest data member in the type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有时您可能需要了解变量的大小以及它在内存中的对齐方式；特别是当您使用C++中称为`structs`的数据记录时。C++提供了`sizeof`运算符来给出用于保存变量的字节数，以及`alignof`运算符来确定内存中类型的对齐方式。对于基本类型，`sizeof`和`alignof`运算符返回相同的值；只有在自定义类型上调用`alignof`运算符时，它才会返回类型中最大数据成员的对齐方式。
- en: Integers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: 'As the name suggests, an integer holds integral data, numbers that have no
    fractional part. For this reason, it makes little sense to do any arithmetic with
    an integer where the fractional part is important; in this case, you should use
    floating point numbers. An example of this was shown in the last chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，整数保存整数数据，即没有小数部分的数字。因此，在需要重视小数部分的情况下，使用整数进行任何算术运算几乎没有意义；在这种情况下，应该使用浮点数。上一章中展示了一个例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This gives an aspect ratio of 1, which is clearly untrue and serves no purpose.
    Even if you assign the result to a floating-point number, you will get the same
    result:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个明显不正确且毫无意义的宽高比。即使将结果分配给浮点数，您也会得到相同的结果：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The reason is that the arithmetic is performed in the expression `width / height`,
    which will use the division operator for integers that will throw away any fractional
    part of the result. To use the floating-point division operator you will have
    to cast one or other of the operands to a floating-point number so the floating-point
    operator is used:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是表达式`width / height`中的算术是在整数上执行的，这将使用整数的除法运算符丢弃结果的任何小数部分。要使用浮点除法运算符，您将需要将操作数之一强制转换为浮点数，以便使用浮点运算符：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will assign a value of 1.3333 (or 4 : 3) to the `aspect_ratio` variable.
    The cast operator used here is the C cast operator, which forces data of one type
    to be used as data of another type. (It is used because we have not yet introduced
    the C++ cast operators, and the syntax of C cast operators is clear.) There is
    no type safety in this cast. C++ provides cast operators, which are discussed
    in the following text, some of which will cast in a type-safe way, which becomes
    important when you use pointers to objects of custom types.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`aspect_ratio`变量分配一个值为1.3333（或4：3）。这里使用的强制转换运算符是C强制转换运算符，它强制将一个类型的数据用作另一个类型的数据。（这是因为我们还没有介绍C++强制转换运算符，并且C强制转换运算符的语法是清晰的。）这种转换没有类型安全性。C++提供了强制转换运算符，下文将讨论其中一些将以类型安全的方式进行转换，当您使用自定义类型的对象指针时，这将变得很重要。
- en: 'C++ provides integer types of various sizes, as summarized in the following
    table. These are the five standard integer types. The standard says that an `int`
    is the natural size of the processor and will have a value between (and including)
    `INT_MIN` and `INT_MAX` (defined in the `<climits>` header file). The size of
    the integer type has *at least as much storage as those preceding it in the list*,
    so an `int` is, at least, as big as a `short int` and a `long long int` types,
    which is at least as big as a `long int` type. The phrase *at least as big as* is
    not much use if the types are all the same size, so the `<climits>` header file
    defines ranges for the other fundamental integer types too. It is implementation-specific
    how many bytes are needed to store these integer ranges. This table gives the
    ranges of the fundamental types and the sizes on x86, 32-bit processors:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了各种大小的整数类型，如下表所总结。这些是五种标准整数类型。标准规定`int`是处理器的自然大小，并且其值在（包括）`INT_MIN`和`INT_MAX`之间（在`<climits>`头文件中定义）。整数类型的大小至少与列表中前面的整数类型一样大，因此`int`至少与`short
    int`和`long long int`类型一样大，至少与`long int`类型一样大。短语“至少与”如果这些类型都是相同大小，那么就没有多大用处，因此`<climits>`头文件还为其他基本整数类型定义了范围。存储这些整数范围需要多少字节是依赖于实现的。这个表给出了基本类型的范围和x86，32位处理器上的大小：
- en: '| **Type** | **Range** | **Size in bytes** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **范围** | **字节大小** |'
- en: '| `signed char` | -128 to 127 | 1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `signed char` | -128到127 | 1 |'
- en: '| `short int` | -32768 to 32767 | 2 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | -32768到32767 | 2 |'
- en: '| `int` | -2147483648 to 2147483647 | 4 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `int` | -2147483648到2147483647 | 4 |'
- en: '| `long int` | -2147483648 to 2147483647 | 4 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `long int` | -2147483648到2147483647 | 4 |'
- en: '| `long long int` | -9223372036854775808 to 9223372036854775807 | 8 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `long long int` | -9223372036854775808到9223372036854775807 | 8 |'
- en: In practice, rather than the `short int` type, you will use `short`; for `long
    int`, you will use `long`; and for `long long int`, you will typically use `long
    long`. As you can see from this table, the `int` and `long int` types are the
    same size, but they are still two different types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您将使用`short`而不是`short int`类型；对于`long int`，您将使用`long`；对于`long long int`，通常会使用`long
    long`。从这个表中可以看出，`int`和`long int`类型的大小相同，但它们仍然是两种不同的类型。
- en: Other than the `char` type, by default integer types are signed, that is, they
    can hold negative as well as positive numbers (for example, a variable of type
    `short` can have a value between -32,768 and 32,767). You can use the `signed`
    keyword to explicitly indicate that the type is signed. You can also have unsigned
    equivalents by using the `unsigned` keyword, which will give you an extra bit,
    but will also mean that bitwise operators and shift operators will work as you
    expect. You may find `unsigned` used without a type, in which case it refers to
    `unsigned int`. Similarly, `signed` used without a type refers to `signed int`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`char`类型，缺省情况下整数类型都是有符号的，也就是说，它们可以保存负数和正数（例如，`short`类型的变量的值可以在-32,768和32,767之间）。您可以使用`signed`关键字显式指示类型为有符号。您还可以使用`unsigned`关键字来获得无符号的等价类型，这将给您一个额外的位，但也意味着按位运算符和移位运算符将按您的预期工作。您可能会发现`unsigned`在没有类型的情况下使用，这种情况下它指的是`unsigned
    int`。类似地，没有类型的`signed`指的是`signed int`。
- en: The `char` type is a separate type to both `unsigned char` and `signed char`.
    The standard says that every bit in a `char` is used to hold character information,
    and so it is implementation-dependent as to whether a `char` can be treated as
    being able to hold negative numbers. If you want a `char` to hold a signed number,
    you should specifically use `signed char`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型是`unsigned char`和`signed char`的独立类型。标准规定`char`中的每一位都用于保存字符信息，因此根据实现的不同，`char`是否可以被视为能够保存负数是依赖于实现的。如果您希望`char`保存有符号数，您应该明确使用`signed
    char`。'
- en: The standard is imprecise about the size of the standard integer types and this
    may be an issue if you are writing code (for example, accessing data in a file,
    or a network stream) that contains a stream of bytes. The `<cstdlib>` header file
    defines named types that will hold specific ranges of data. These types have names
    which have the number of bits used in the range (although the actual type may
    require more bits). So, there are types with names such as `int16_t` and `uint16_t`,
    where the first type is a signed integer that will hold a range of 16-bit values
    and the second type is an unsigned integer. There are also types declared for
    8-, 32-, and 64-bit values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标准对于标准整数类型的大小并不精确，如果您正在编写代码（例如，访问文件中的数据或网络流），这可能是一个问题。`<cstdlib>`头文件定义了将保存特定数据范围的命名类型。这些类型具有包含在范围内使用的位数的名称（尽管实际类型可能需要更多位）。因此，有诸如`int16_t`和`uint16_t`之类的类型，其中第一个类型是将保存16位值范围的有符号整数，第二个类型是无符号整数。还声明了8位、32位和64位值的类型。
- en: 'The following shows the actual sizes of these types determined by the `sizeof`
    operator on an x86 machine:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了在x86机器上使用`sizeof`运算符确定的这些类型的实际大小：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition, the `<cstdlib>` header file defines types with names such as `int_least16_t`
    and `uint_least16_t` using the same naming scheme as before, and with versions
    for 8-, 16-,32-, and 64-bits. The `least` part of the name means that the type
    will hold values with at least the specified number of bits, but there could be
    more. There are also types with names such as `int_fast16_t` and `uint_fast16_t`
    with versions for 8-, 16-, 32-, and 64-bits which are regarded as the fastest
    types that can hold that number of bits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`<cstdlib>`头文件还定义了诸如`int_least16_t`和`uint_least16_t`之类的类型，使用与之前相同的命名方案，并且有8位、16位、32位和64位的版本。名称中的`least`部分表示该类型将保存至少指定数量的位的值，但可能会更多。还有诸如`int_fast16_t`和`uint_fast16_t`之类的类型，具有8位、16位、32位和64位的版本，被视为可以保存该位数的最快类型。
- en: Specifying integer literals
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定整数文字
- en: To assign a value to an integer variable you provide a number that has no fractional
    part. The compiler will identify the type with the nearest precision that the
    number represents and attempt to assign the integer, performing a conversion if
    necessary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要为整数变量赋值，您提供一个没有小数部分的数字。编译器将确定数字表示的最接近精度的类型，并尝试分配整数，必要时执行转换。
- en: 'To explicitly specify that a literal is a `long` value, you use the `l` or
    `L` suffix. Similarly, for an `unsigned long`, you use the suffix `ul` or `UL`.
    For `long long` values, you use `ll` or `LL` suffix, and use `ull` or `ULL` for
    `unsigned long long`. The `u` (or `U`) suffix is for `unsigned` (that is, `unsigned
    int`) and you do not need a suffix for `int`. The following illustrates this,
    using uppercase suffixes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确指定文字是`long`值，您可以使用`l`或`L`后缀。同样，对于`unsigned long`，您可以使用后缀`ul`或`UL`。对于`long
    long`值，您使用`ll`或`LL`后缀，并对于`unsigned long long`使用`ull`或`ULL`。`u`（或`U`）后缀用于`unsigned`（即`unsigned
    int`），对于`int`不需要后缀。以下是使用大写后缀的示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using a 10-based number system to specify a number that is a bitmap is confusing
    and cumbersome. The bits in a bitmap are the powers of 2, so it makes more sense
    to use a number system that is a power of 2\. C++ allows you to provide numbers
    in octal (base 8) or hexadecimal (base 16). To provide a literal in an octal you
    prefix the number with a zero character (`0`). To provide a literal in a hexadecimal
    you prefix the number with the `0x` character sequence. Octal numbers use the
    digits 0 through 7, but hexadecimal numbers need 16 digits, which means 0 through
    9 and a through f (or A through F), where A is 10 in base 10 and F is 15 in base
    10:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用10进制数字系统来指定位图的数字是令人困惑和繁琐的。位图中的位是2的幂，因此更合理的是使用2的幂的数字系统。C++允许您以八进制（基数8）或十六进制（基数16）提供数字。要在八进制中提供文字，您需要使用零字符（`0`）作为前缀。要在十六进制中提供文字，您需要使用`0x`字符序列作为前缀。八进制数字使用数字0到7，但十六进制数字需要16个数字，即0到9和a到f（或A到F），其中A在十进制中是10，F在十进制中是15：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, two 64-bit (in Visual C++) integers are assigned bitmap values,
    with every other bit set to 1\. The first variable starts with the bottom bit
    set, the second variable starts with the bottom bit unset, and the second lowest
    bit set. Before inserting the numbers, the stream is modified with three manipulators.
    The first `hex` indicates that integers should be printed on the console as hexadecimals,
    and `showbase` means that the leading `0x` will be printed. By default, the alphabetic
    digits (A to F) will be given in lowercase and, to specify that uppercase must
    be used, you use `uppercase`. Once the stream has been modified, the setting remains
    until it is changed. To change the stream subsequently to use lowercase for alphabetic
    hexadecimal digits you insert `nouppercase` into the stream and to print the number
    without the base, insert the `noshowbase` manipulator. To use octal digits, you
    insert the `oct` manipulator and to use decimals, insert the `dec` manipulator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，两个64位（在Visual C++中）整数被分配了位图值，其中每隔一位设置为1。第一个变量从底位设置，第二个变量从底位取消设置，并设置次低位。在插入数字之前，流被修改了三个操纵器。第一个`hex`表示整数应以十六进制形式打印在控制台上，`showbase`表示将打印前导的`0x`。默认情况下，字母数字（A到F）将以小写形式给出，要指定必须使用大写形式，您可以使用`uppercase`。一旦流被修改，设置将保持直到被更改。要随后更改流以使用小写字母十六进制数字，您可以在流中插入`nouppercase`，要打印没有基数的数字，插入`noshowbase`操纵器。要使用八进制数字，您可以插入`oct`操纵器，要使用十进制，插入`dec`操纵器。
- en: 'When you specify large numbers like this, it becomes difficult to see if you
    have specified the right number of digits. You can group together digits using
    a single quote (`''`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定这样的大数字时，很难看出您是否已经指定了正确数量的数字。您可以使用单引号（`'`）将数字分组在一起：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The compiler ignores the quote; it is just used as a visual aid. In the first
    example, the quote groups the digits into two byte groups; in the second case
    the quote groups a decimal number in thousands and millions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器忽略引号；它只是用作视觉辅助。在第一个示例中，引号将数字分组为两个字节组；在第二种情况下，引号将小数分组为千位和百万位。
- en: Using bitset to show bit patterns
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位集来显示位模式
- en: 'There is no manipulator to tell the `cout` object to print an integer as a
    bitmap, but you can simulate the behavior using a `bitset` object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有操纵器告诉`cout`对象将整数打印为位图，但是可以使用`bitset`对象模拟该行为：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result is:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here the `bitset` class is **parameterized,** which means that you provide a
    parameter through the angle brackets (`<>`) and in this case, 64 is used, indicating
    that the `bitset` object will accommodate 64-bits. In both cases, the initialization
    of the `bitset` object is carried out using a syntax that looks like a function
    call (in fact, it does call a function called a **constructor**) and this is the
    preferred way to initialize an object. Inserting the `bitset` object into the
    stream, prints out each bit starting with the highest bit. (The reason for this
    is that there is an `operator <<` function defined, which takes a `bitset` object,
    as is the case for most of the standard library classes).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bitset`类是**参数化**的，这意味着您通过尖括号（`<>`）提供一个参数，在这种情况下使用64，表示`bitset`对象将容纳64位。在这两种情况下，`bitset`对象的初始化使用看起来像函数调用的语法（实际上，它确实调用了一个称为**构造函数**的函数），这是初始化对象的首选方式。将`bitset`对象插入流中，打印出从最高位开始的每个位。（原因是定义了一个`operator
    <<`函数，它接受一个`bitset`对象，这是大多数标准库类的情况）。
- en: 'The `bitset` class is useful for accessing and setting individual bits as an
    alternative to using bitwise operators:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitset`类对于访问和设置单个位而不使用位运算符是有用的：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `set` function will set the bit in the specified position to a value of
    1\. The `to_ullong` function will return a `long long` number that the `bitset`
    represents.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`函数将在指定位置设置位为1。`to_ullong`函数将返回`bitset`表示的`long long`数字。'
- en: 'The call to the `set` function and the assignment has the same result as the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对`set`函数的调用和赋值具有与以下相同的结果：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Determining integer byte order
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定整数字节顺序
- en: The order of bytes in an integer is implementation-dependent; it depends on
    how the processor handles integers. In most cases, you do not need to know. However,
    if you are reading bytes from a file in binary mode, or bytes from a network stream,
    and you need to interpret two or more bytes as parts of an integer, you will need
    to know what order they are in, and if necessary convert them to the order recognized
    by the processor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整数中字节的顺序取决于实现；它取决于处理器如何处理整数。在大多数情况下，您不需要知道。但是，如果您以二进制模式从文件中读取字节，或者从网络流中读取字节，并且需要将两个或更多字节解释为整数的一部分，则需要知道它们的顺序，并且必要时将它们转换为处理器识别的顺序。
- en: The C network library (on Windows, it is called the **Winsock** library) contains
    a collection of functions that convert `unsigned short` and `unsigned long` types
    from the network order to the host order (that is, the order used by the processor
    on the current machine) and vice versa. The network order is big endian. **Big
    endian** means that the first byte will be the highest byte in the integer, whereas
    **little endian** means that the first byte is the smallest byte. When you transmit
    an integer to another machine you first convert from the order used by the processor
    of the source machine (the host order) to the network order and the receiving
    machine converts the integer from network order to the host order of the receiving
    machine before using the data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C网络库（在Windows上称为**Winsock**库）包含一组函数，用于将`unsigned short`和`unsigned long`类型从网络顺序转换为主机顺序（即当前机器上处理器使用的顺序），反之亦然。网络顺序是大端序。**大端序**意味着第一个字节将是整数中的最高字节，而**小端序**意味着第一个字节是最小字节。当您将整数传输到另一台机器时，您首先将其从源机器的处理器使用的顺序（主机顺序）转换为网络顺序，接收机在使用数据之前将整数从网络顺序转换为接收机的主机顺序。
- en: The functions to change the byte order are `ntohs` and `ntohl`; for converting
    `unsigned short` and `unsigned long` from the network order to the host order
    and `htons` and `htonl` for the conversion from the host order to the network
    order. Knowing the byte order will be important when you view memory when you
    are debugging code (for example, as in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml),
    *Diagnostics and Debugging*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更改字节顺序的函数是`ntohs`和`ntohl`；用于将`unsigned short`和`unsigned long`从网络顺序转换为主机顺序的函数，以及`htons`和`htonl`，用于将主机顺序转换为网络顺序。在调试代码时，了解字节顺序将是重要的（例如，如[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)中所述，*诊断和调试*）。
- en: 'It is easy to write code to reverse the byte order:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码以反转字节顺序很容易：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This uses bitwise operators to separate the two bytes that are assumed to make
    up the `unsigned short` into the lower byte, which is shifted eight bits left,
    and the upper byte that is shifted eight bits right and these two numbers are
    recombined as an `unsigned short` using the bitwise OR operator, `|`. It is simple
    to write versions of this function for 4-byte and 8-byte integers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用位运算符将假定组成`unsigned short`的两个字节分开为较低字节，将其左移八位，并将右移八位的上字节，然后使用按位或运算符`|`将这两个数字重新组合为`unsigned
    short`。编写此函数的4字节和8字节整数版本很简单。
- en: Floating point types
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'There are three basic floating point types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的浮点类型：
- en: '`float` (single precision)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`（单精度）'
- en: '`double` (double precision)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`（双精度）'
- en: '`long double` (extended precision)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double`（扩展精度）'
- en: 'All of these are signed. The actual format of the number in memory, and the
    number of bytes used, is specific to the C++ implementation, but the `<cfloat>`
    header file gives the ranges. The following table gives the positive ranges and
    number of bytes used on x86, 32-bit processors:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是有符号的。内存中数字的实际格式和使用的字节数是特定于C++实现的，但`<cfloat>`头文件给出了范围。以下表格给出了x86、32位处理器上使用的正数范围和字节数：
- en: '| **Type** | **Range** | **Size in bytes** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **范围** | **字节大小** |'
- en: '| float | 1.175494351e-38 to 3.402823466e+38 | 4 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: 浮点 | 1.175494351e-38 到 3.402823466e+38 | 4
- en: '| double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: 双精度 | 2.2250738585072014e-308 到 1.7976931348623158e+308 | 8
- en: '| long double | 2.2250738585072014e-308 to 1.7976931348623158e+308 | 8 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: 长双精度 | 2.2250738585072014e-308 到 1.7976931348623158e+308 | 8
- en: As you can see, in Visual C++ `double` and `long double` have the same ranges,
    but they are still two distinct types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在Visual C++中，`double`和`long double`具有相同的范围，但它们仍然是两种不同的类型。
- en: Specifying floating point literals
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定浮点文字
- en: 'A literal used to initialize a `double` is specified as a floating point by
    using either the scientific format, or simply by providing a decimal point:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 用于初始化`double`的文字是通过使用科学格式或简单地提供小数点来指定的浮点数：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first example indicates that the variable `one` is assigned to a floating-point
    value of 1.0\. The trailing zero is not important, as shown in the second variable,
    `two`; however, the trailing zero does make the code more readable since the period
    is easy to overlook. The third example uses scientific notation. The first part
    is the mantissa and can be signed and the part after the `e` is the exponent.
    The exponent is the power-of-10 magnitude of the number (which can be negative).
    The variable is assigned to a value of the mantissa multiplied by 10 and raised
    to the exponent. Although it is not recommended, you can write the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子表明变量`one`被赋予了浮点值1.0。结尾的零并不重要，如第二个变量`two`所示；然而，结尾的零确实使代码更易读，因为很容易忽略句号。第三个例子使用了科学计数法。第一部分是尾数，可以是有符号的，`e`后面的部分是指数。指数是数字的10的幂大小（可以是负数）。变量被赋予尾数乘以10并提升到指数的值。虽然不建议这样做，但您可以写以下内容：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The compiler will interpret the numbers appropriately. The first example is
    perverse, but the second makes some sense; it shows in your code that a billion
    is a thousand million.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将适当地解释这些数字。第一个例子是反常的，但第二个有些意义；它在您的代码中显示了十亿是一千万的意思。
- en: 'These examples assign double precision floating point values to `double` variables.
    To specify a value for single precision variables so that you can assign a `float`
    variable, use the `f` (or `F`) suffix. Similarly, for a `long double` literal
    use the `l` (or `L`) suffix:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例将双精度浮点值分配给`double`变量。要为单精度变量指定值，以便可以分配`float`变量，使用`f`（或`F`）后缀。类似地，对于`long
    double`文字，使用`l`（或`L`）后缀：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you use these suffixes, you still have to provide the number in the right
    format. A literal of `2f` is incorrect; you have to provide a decimal point, `2.f`.
    When you specify floating point numbers with a large number of digits you can
    use the single quote (`''`) to group digits. As stated before, this is just a
    visual aid to the programmer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用这些后缀，仍然必须以正确的格式提供数字。`2f`的文字是不正确的；您必须提供一个小数点，`2.f`。当您指定具有大量数字的浮点数时，可以使用单引号（`'`）来分组数字。如前所述，这只是对程序员的一种视觉辅助：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Characters and strings
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符和字符串
- en: The `string` class and C string functions will be covered in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; this section covers the basic use of character variables in your
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`类和C字符串函数将在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml)中介绍，*使用字符串*；本节介绍了代码中字符变量的基本用法。'
- en: Character types
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类型
- en: The `char` type is an integer, so `signed char` and `unsigned char` exist too.
    These are three distinct types; the `signed char` and `unsigned char` types should
    be treated as numeric types. The `char` type is used to hold a single character
    in the implementation's character set. In Visual C++, this is an eight-bit integer
    that can hold characters from the ISO-8859 or UTF-8 character set. These character
    sets are able to represent the characters used in English and most European languages.
    Characters from other languages take up more than one byte and C++ provides the
    `char16_t` type to hold 16-bit characters and `char32_t` to hold 32-bit characters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`类型是一个整数，所以也存在`signed char`和`unsigned char`。这是三种不同的类型；`signed char`和`unsigned
    char`类型应该被视为数值类型。`char`类型用于在实现的字符集中保存单个字符。在Visual C++中，这是一个可以容纳ISO-8859或UTF-8字符集中的字符的8位整数。这些字符集能够表示英语和大多数欧洲语言中使用的字符。其他语言的字符占用多个字节，C++提供了`char16_t`类型来保存16位字符和`char32_t`来保存32位字符。'
- en: There is also a type called `wchar_t` (wide character) that will be able to
    hold characters from the largest extended character set. In general, when you
    see a C Runtime Library or C++ Standard Library function with a `w` prefix, it
    will use wide character strings rather than `char` strings. So, the `cout` object
    will allow you to insert `char` strings and the `wcout` object will allow you
    to insert wide character strings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为`wchar_t`（宽字符）的类型，它将能够容纳来自最大扩展字符集的字符。通常，当您看到带有`w`前缀的C运行时库或C++标准库函数时，它将使用宽字符字符串而不是`char`字符串。因此，`cout`对象将允许您插入`char`字符串，而`wcout`对象将允许您插入宽字符字符串。
- en: 'The C++ standard says that every bit in a `char` is used to hold character
    information, and so it is implementation-dependent as to whether a `char` can
    be treated as being able to hold negative numbers. The following illustrates this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准规定`char`中的每个位都用于保存字符信息，因此根据实现，`char`是否可以被视为能够保存负数是依赖于实现的。以下是说明：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The range of a `signed char` is -128 to 127, but this code uses the separate
    type `char` and attempts to use it in the same way. The variable `c` is first
    assigned to the ASCII character `~` (126). When you insert a character into an
    output stream it will attempt to print a character rather than a number, so the
    next line prints this character to the console, to get the numeric value the code
    converts the variable to a `signed short` integer. (Again, a C cast is used for
    clarity.) Next, the variable is incremented by two, that is, the character is
    two characters further in the character set, which means the first character in
    the extended ASCII character set; the result is this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`signed char`的范围是-128到127，但此代码使用了单独的类型`char`并尝试以相同的方式使用它。变量`c`首先被赋值为ASCII字符`~`（126）。当您将字符插入输出流时，它将尝试打印一个字符而不是一个数字，因此下一行将此字符打印到控制台，为了获得数值，代码将变量转换为`signed
    short`整数。（再次，为了清晰起见，使用了C转换。）接下来，变量增加了两个，也就是说，字符在字符集中向后移动了两个字符，这意味着扩展ASCII字符集中的第一个字符；结果是这样的：'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first character in the extended character set is C-cedilla.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字符集中的第一个字符是C-锐音。
- en: It is rather counter-intuitive that a value of 126 incremented by two results
    is a value of -128, and this comes about from overflow calculations with signed
    types. Even if this is intentional, it is best to avoid doing this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值为126增加两个的结果是-128，这相当反直觉，并且这是由于带符号类型的溢出计算导致的。即使这是有意的，最好还是避免这样做。
- en: 'In Visual C++, the C-cedilla character is treated as -128 so you can write
    the following to have the same effect:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual C++中，C-锐音字符被视为-128，因此您可以编写以下内容以达到相同的效果：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is implementation-specific, so for portable code you should not rely upon
    it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是特定于实现的，因此对于可移植代码，您不应该依赖它。
- en: Using character macros
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符宏
- en: The `<cctype>` header contains various macros that you can use to examine the
    type of character a `char` holds. These are the C runtime macros declared in `<ctype.h>`.
    Some of the more useful macros to test character values are explained in the following
    table. Bear in mind that, since these are C routines, they will not return `bool`
    values; instead they return an `int` with a value of non-zero for `true` and zero
    for `false`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`<cctype>`头文件包含了各种宏，您可以使用这些宏来检查`char`包含的字符类型。这些是在`<ctype.h>`中声明的C运行时宏。以下表格中解释了一些更有用的测试字符值的宏。请记住，由于这些是C例程，它们不会返回`bool`值；而是返回一个具有非零值的`int`表示`true`，零表示`false`。'
- en: '| **Macro** | **Tests if the character is:** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '**宏** | **测试字符是否为：** |'
- en: '| `isalnum` | An alphanumeric character, A to Z, a to z, 0 to 9 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '`isalnum` | 字母数字字符，A到Z，a到z，0到9 |'
- en: '| `isalpha` | An alphabetic character, A to Z, a to z |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '`isalpha` | 一个字母字符，A到Z，a到z |'
- en: '| `isascii` | An ASCII character, 0x00 to 0x7f |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '`isascii` | 一个ASCII字符，0x00到0x7f |'
- en: '| `isblank` | A space or horizontal tab |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '`isblank` | 一个空格或水平制表符 |'
- en: '| `iscntrl` | A control character, 0x00 to 0x1f or 0x7f |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '`iscntrl` | 一个控制字符，0x00到0x1f或0x7f |'
- en: '| `isdigit` | A decimal digit 0 to 9 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '`isdigit` | 十进制数字0到9 |'
- en: '| `isgraph` | A printable character other than space, 0x21 to 0x7e |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '`isgraph` | 可打印字符，不包括空格，0x21到0x7e |'
- en: '| `islower` | A lowercase character, a to z |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '`islower` | 一个小写字符，a到z |'
- en: '| `isprint` | A printable character, 0x20 to 0x7e |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '`isprint` | 可打印字符，0x20到0x7e |'
- en: '| `ispunct` | A punctuation character, `! " # $ % & '' ( ) * + , - . / : ;
    < = > ? @ [ ] ^ _ ` { &#124; } ~ \` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '`ispunct` | 一个标点字符，`! " # $ % & '' ( ) * + , - . / : ; < = > ? @ [ ] ^ _ `
    { &#124; } ~ \` |'
- en: '| `isspace` | A space |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '`isspace` | 一个空格 |'
- en: '| `isupper` | An uppercase character, A to Z |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '`isupper` | 一个大写字符，A到Z |'
- en: '| `isxdigit` | A hexadecimal digit, 0 to 9, a to f, A to F |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '`isxdigit` | 一个十六进制数字，0到9，a到f，A到F |'
- en: 'For example, the following code loops while reading in a single character from
    the input stream (after each character, you need to press the *Enter* key). The
    loop finishes when a non-numeric value is provided:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码循环读取输入流中的单个字符（在每个字符后，您需要按*Enter*键）。当提供非数字值时，循环结束：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are also macros to change characters. Again, these will return an `int`
    value, which you should convert to a `char`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还有用于更改字符的宏。同样，这些将返回一个`int`值，您应该将其转换为`char`。
- en: '| **Macro** | **Returns** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '**宏** | **返回** |'
- en: '| `toupper` | The uppercase version of the character |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '`toupper` | 字符的大写版本 |'
- en: '| `tolower` | The lowercase version of the character |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '`tolower` | 字符的小写版本 |'
- en: 'In the following code, the character typed at the console is echoed back until
    the user types `q` or `Q`. If the character typed is a lowercase character, the
    echoed character is converted to uppercase:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，从控制台键入的字符被回显，直到用户键入`q`或`Q`为止。如果键入的字符是小写字符，则回显的字符会转换为大写：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Specifying character literals
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定字符文字
- en: You can initialize a `char` variable with literal characters. This will be a
    character from the supported character set. The ASCII character set includes some
    unprintable characters, and so that you can use these, C++ provides two character
    sequences using the backslash character (`\`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用文字字符初始化`char`变量。这将是受支持的字符集中的一个字符。ASCII字符集包括一些不可打印的字符，因此您可以使用这些，C++提供了两个使用反斜杠字符（`\`）的字符序列。
- en: '| **Name** | **ASCII name** | **C++ sequence** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '**名称** | **ASCII名称** | **C++序列** |'
- en: '| Newline | LF | `\n` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: 换行符 | LF | `\n` |
- en: '| Horizontal tab | HT | `\t` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: 水平制表符 | HT | `\t` |
- en: '| Vertical tab | VT | `\v` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: 垂直制表符 | VT | `\v` |
- en: '| Backspace | BS | `\b` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: 退格 | BS | `\b` |
- en: '| Carriage return | CR | `\r` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: 回车 | CR | `\r` |
- en: '| Form feed | FF | `\f` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: 换页符 | FF | `\f` |
- en: '| Alert | BEL | `\a` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: 警报 | BEL | `\a` |
- en: '| Backslash | \ | `\\` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: 反斜杠 | \ | `\\` |
- en: '| Question mark | ? | `\?` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: 问号 | ? | `\?` |
- en: '| Single quote | '' | `\''` |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: 单引号 | ' | `\'` |
- en: '| Double quote | " | `\"` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: 双引号 | " | `\"` |
- en: 'In addition, you can give the numeric value of that character as an octal or
    hexadecimal number. To provide an octal number you give the number as three characters
    (prefixed with one or two `0` characters if necessary) prefixed with a backslash.
    For a hexadecimal number, you prefix it with `\x`. The character `M`, is the character
    number 77 in decimal, 115 in octal, and 4d in hexadecimal, so you can initialize
    a character variable with an `M` character in three ways:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以将该字符的数值作为八进制或十六进制数给出。要提供八进制数，您需要使用三个字符（必要时前缀为一个或两个`0`字符）前缀为反斜杠。对于十六进制数，您需要使用`\x`前缀。字符`M`在十进制中是字符编号77，在八进制中是115，在十六进制中是4d，因此您可以用三种方式初始化一个字符变量为`M`字符。
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For completeness, it is worth pointing out that you can initialize a char as
    an integer, so the following will also initialize each variable to an `M` character:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，值得指出您可以将char初始化为整数，因此以下内容也将初始化每个变量为`M`字符：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of these methods are valid.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是有效的。
- en: Specifying string literals
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定字符串文字
- en: 'Strings are made up of one or more characters, and you can use the escaped
    characters in string literals too:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串由一个或多个字符组成，您也可以在字符串文字中使用转义字符。
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This rather unreadable string will be printed on the console as `This is C++`
    followed by a newline. The capital C is 43 in hexadecimal and the + symbol is
    2b in hexadecimal and 53 in octal. The `\n` character is a newline. Escaped characters
    are useful for printing characters that are not in the character set your C++
    compiler uses and for some unprintable characters (for example, `\t` to insert
    a horizontal tab). The `cout` object buffers the characters before writing them
    to the output stream. If you use `\n` as a newline it is treated like any other
    character in the buffer. The `endl` manipulator will insert `\n` into the buffer
    and then flush it so the characters are immediately written to the console.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当难读的字符串将被打印在控制台上，后面跟着一个换行符，显示为`This is C++`。大写字母C的十六进制是43，加号的十六进制是2b，八进制是53。`\n`字符是一个换行符。转义字符对于打印不在C++编译器使用的字符集中的字符以及一些不可打印的字符（例如，`\t`插入水平制表符）非常有用。`cout`对象在将字符写入输出流之前会对其进行缓冲。如果您使用`\n`作为换行符，它将被视为缓冲区中的任何其他字符。`endl`操作符将`\n`插入缓冲区，然后刷新缓冲区，使字符立即写入控制台。
- en: The *empty*, or `NULL` character, is a `\0`. This is an important character
    because it is unprintable, and it has no use other than to mark the end of a sequence
    of characters in a string. The empty string is `""`, but since strings are delimited
    by the `NULL` character the memory taken up by a string variable initialized with
    the empty string will have one character, that is `\0`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*空*或`NULL`字符是`\0`。这是一个重要的字符，因为它是不可打印的，并且除了标记字符串中字符序列的结束之外没有其他用途。空字符串是`""`，但由于字符串由`NULL`字符界定，因此使用空字符串初始化的字符串变量占用的内存将有一个字符，即`\0`。'
- en: 'The newline character allows you to put a newline within a string. This is
    useful if the only formatting you''ll do is with paragraphs and you are printing
    short paragraphs:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符允许您在字符串中插入换行符。如果您只对段落进行格式化，并且要打印短段落，这将非常有用。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This prints two lines on the console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这在控制台上打印了两行：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, you may want to initialize a string with a long sequence of characters
    and the limitations of the editor you are using may mean you want to split the
    string over several lines. You do this by putting each fragment of the string
    within double quotes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能希望使用长序列的字符初始化字符串，而您使用的编辑器的限制可能意味着您希望将字符串分割成几行。您可以通过将字符串的每个片段放在双引号内来实现这一点。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the following on the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在控制台上看到以下内容：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is no newline printed other than the one explicitly requested at the end
    with `endl`. This syntax allows you to make long strings more readable in your
    code; you can, of course, use the newline characters `\n`, in such strings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在最后使用`endl`明确请求的换行符外，不会打印其他换行符。这种语法允许您在代码中使长字符串更易读；当然，您也可以在这样的字符串中使用换行字符`\n`。
- en: Unicode literals
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unicode文字
- en: A `wchar_t` variable can also be initialized with a character and the compiler
    will promote the character to a wide character essentially by using the character's
    byte and assigning the remaining (higher) bytes to zero. However, it makes more
    sense to assign such a variable with a wide character, and you do this using the
    `L` prefix.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`wchar_t`变量也可以用字符初始化，编译器将通过使用字符的字节并将剩余（更高的）字节分配为零来将字符提升为宽字符。但是，将这样的变量分配为宽字符更有意义，您可以使用`L`前缀来实现这一点。'
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that, rather than using the `cout` object, this code uses `wcout`, the
    wide character version. The syntax of using the `\u` prefix within the quotes
    indicates that the following character is a Unicode character.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码使用的是`wcout`，而不是`cout`对象，使用引号内的`\u`前缀的语法表示后面的字符是Unicode字符。
- en: 'Bear in mind that, to show the Unicode character, you need to use a console
    that will show Unicode characters and, by default, the Windows console is set
    to **Code Page 850** which will not show Unicode characters. You can change the
    mode of the output console by calling `_setmode` (defined in `<io.h>`) on the
    standard output stream, `stdout`, specifying the UTF-16 file mode (using `_O_U16TEXT`
    defined in `<fcntl.h>`):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要显示Unicode字符，您需要使用一个可以显示Unicode字符的控制台，默认情况下，Windows控制台设置为**Code Page 850**，不会显示Unicode字符。您可以通过在标准输出流`stdout`上调用`_setmode`（在`<io.h>`中定义）来更改输出控制台的模式，指定UTF-16文件模式（使用`<fcntl.h>`中定义的`_O_U16TEXT`）：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can find a list of all of the characters supported by Unicode at [http://unicode.org/charts/](http://unicode.org/charts/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://unicode.org/charts/](http://unicode.org/charts/)找到Unicode支持的所有字符的列表。
- en: UTF-16 characters can also be assigned to `char16_t` variables, and UTF-32 characters
    can be assigned to `char32_t` variables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16字符也可以分配给`char16_t`变量，UTF-32字符也可以分配给`char32_t`变量。
- en: Raw strings
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始字符串
- en: When you use a raw string literal you essentially switch off the meaning of
    escape characters. Whatever you type into a raw string becomes its content, even
    if you use whitespace including newlines. The raw string is delimited with `R"(`
    and `)"`. That is, the string is between the inner parentheses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用原始字符串文字时，实质上是关闭了转义字符的含义。无论您输入什么内容到原始字符串中，甚至包括换行符在内，原始字符串都会将其作为内容。原始字符串用`R"(`和`)"`来界定。也就是说，字符串位于内部括号之间。
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that, the `()` is part of the syntax and is not part of the string. The
    preceding code prints the following to the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`()`是语法的一部分，不是字符串的一部分。前面的代码将以下内容打印到控制台：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Normally in a string `\n` is an escaped character and will be translated as
    a newline, but in a raw string it is not translated and is printed as two characters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在字符串中，`\n`是一个转义字符，将被翻译为换行符，但在原始字符串中，它不会被翻译，而是打印为两个字符。
- en: 'In a normal C++ string, you will have to escape some of the characters; for
    example, the double quote will have to be escaped to `\"` and the backslash escaped
    to `\\`. The following will give the same result without using a raw string:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的C++字符串中，您将不得不转义一些字符；例如，双引号必须转义为`\"`，反斜杠必须转义为`\\`。不使用原始字符串，以下将给出相同的结果：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also have newlines in raw strings:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在原始字符串中使用换行符：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this code, the newline after the comma will be printed to the console. Unfortunately,
    all whitespace will be printed on the console, so assuming that in the preceding
    code the indentation is three spaces and the `cout` is indented once, you will
    see the following on the console:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，逗号后面的换行符将被打印到控制台。不幸的是，所有空白字符都将被打印到控制台上，因此假设在前面的代码中缩进为三个空格，`cout`缩进一次，您将在控制台上看到以下内容：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are 14 spaces in front of `its` because there were 14 spaces in front
    of `its` in the source code. For this reason, you should be wary about using raw
    strings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`its`前面有14个空格，因为在源代码中`its`前面有14个空格。因此，您应该谨慎使用原始字符串。
- en: 'Perhaps, the best use for raw strings is to initialize variables with file
    paths on Windows. The folder separation character in Windows is a backslash, which
    means that for a literal string that represents a file path you will have to escape
    each of these separators; thus, the string will have a lot of double backslashes,
    with the possibility of missing one. With raw strings this escaping is not necessary.
    The two string variables in the following represent the same string:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，原始字符串的最佳用途是在Windows上初始化文件路径的变量。在Windows中，文件夹分隔符是反斜杠，这意味着对于表示文件路径的文字字符串，您将不得不转义每个这些分隔符；因此，字符串将有很多双反斜杠，有可能漏掉一个。使用原始字符串，这种转义是不必要的。以下的两个字符串变量代表相同的字符串：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These two strings have the same contents, but the second one is more readable
    since the C++ literal string does not have escaped backslashes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字符串具有相同的内容，但第二个更易读，因为C++文字字符串没有转义反斜杠。
- en: The requirement for escaping backslashes is only needed for literal strings
    declared in your code; it is an indication to the compiler of how to interpret
    the character. If you obtain a file path from a function (or via `argv[0]`), the
    separator will be backslashes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 转义反斜杠的要求仅适用于在代码中声明的文字字符串；这是对编译器如何解释字符的指示。如果您从函数（或通过`argv[0]`）获取文件路径，分隔符将是反斜杠。
- en: String byte order
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串字节顺序
- en: Extended character sets use more than one byte per character. If such characters
    are stored in a file, the order of the bytes becomes important. In this situation,
    the writer of the character must use the same order that will be used by potential
    readers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展字符集使用每个字符超过一个字节。如果这些字符存储在文件中，字节的顺序就变得重要起来。在这种情况下，字符的编写者必须使用与潜在读者将要使用的相同顺序。
- en: One way to do this is to use a **Byte Order Mark** (**BOM**). This is a known
    number of bytes with a known pattern, and is typically placed as the first item
    in a stream so that the reader of the stream can use it to determine the byte
    order of the remaining characters in the stream. Unicode defines the 16-bit character,
    `\uFEFF`, and the non-character, `\uFFFE`, as byte order marks. In the case of
    `\uFEFF`, all bits are set except for bit 8 (if the lowest bit is labeled as bit
    0). This BOM can be prefixed to data that is passed between machines. The destination
    machine can read the BOM into a 16-bit variable and test the bits. If bit 8 is
    zero it means the two machines have the same byte order and so the characters
    can be read as two byte values in the order in the stream. If bit 0 is zero then
    it means that the destination machine reads 16-bit variables in the opposite order
    to the source, and so action must be taken to ensure that, with 16-bit characters,
    the bytes are read in the right order.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用**字节顺序标记**（**BOM**）。这是已知字节数和已知模式的一组字节，通常作为流的第一项放置，以便流的读取者可以使用它来确定流中剩余字符的字节顺序。Unicode定义了16位字符`\uFEFF`和非字符`\uFFFE`作为字节顺序标记。对于`\uFEFF`，除了第8位（如果最低位标记为第0位）之外，所有位都被设置。这个BOM可以作为前缀添加到在机器之间传递的数据中。目标机器可以将BOM读入一个16位变量并测试位。如果第8位为零，这意味着两台机器具有相同的字节顺序，因此字符可以按照流中的顺序读取为两个字节值。如果第0位为零，则意味着目标机器以与源机器相反的顺序读取16位变量，因此必须采取措施确保以正确的顺序读取字节。
- en: 'The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字节顺序标记（BOM）序列化如下（十六进制）：
- en: '| **Character set** | **Byte order mark** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **字符集** | **字节顺序标记** |'
- en: '| UTF-8 | EF BB BF |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | EF BB BF |'
- en: '| UTF-16 big endian | FE FF |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16大尾 | FE FF |'
- en: '| UTF-16 little endian | FF FE |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16小尾 | FF FE |'
- en: '| UTF-32 big endian | 00 00 FE FF |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32大尾 | 00 00 FE FF |'
- en: '| UTF-32 little endian | FF FE 00 00 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32小尾 | FF FE 00 00 |'
- en: Bear this in mind that, when you read data from a file. The character sequence,
    FE FF, will be very rare in a non-Unicode file, and so if you read these as the
    first two bytes in a file it means that the file is Unicode. Since `\uFEFF` and
    `\uFFFE` are not printable Unicode characters, it means that a file that starts
    with either of these has a byte order mark, and you can then use the BOM to determine
    how to interpret the remaining bytes in the file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当您从文件中读取数据时。字符序列FE FF在非Unicode文件中非常罕见，因此如果您将它们读取为文件中的前两个字节，这意味着该文件是Unicode。由于`\uFEFF`和`\uFFFE`不是可打印的Unicode字符，这意味着以这两者之一开头的文件具有字节顺序标记，然后您可以使用BOM来确定如何解释文件中剩余的字节。
- en: Boolean
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔
- en: 'The `bool` type holds a Boolean value, that is, just one of two values: `true`
    or `false`. C++ allows you to treat 0 (zero) as being `false` and anything non-zero
    as being `true` but this can lead to mistakes, so it is better to get in to the
    habit of explicitly checking values:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`类型保存布尔值，即两个值中的一个：`true`或`false`。C++允许您将0（零）视为`false`，将任何非零值视为`true`，但这可能会导致错误，因此最好养成明确检查值的习惯：'
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The second of these two is preferable, since it is clearer what you are comparing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式中的第二种更可取，因为您正在比较的内容更清晰。
- en: Note that, even if a pointer is not a `nullptr`, it still may not be a valid
    pointer, but it is common practice to assign a pointer to `nullptr` to convey
    some other meaning, perhaps to say that the pointer operation is not appropriate.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使指针不是`nullptr`，它仍然可能不是有效的指针，但通常的做法是将指针分配给`nullptr`以传达其他含义，也许是说指针操作不合适。
- en: You can insert Boolean values into an output stream. However, the default behavior
    is to treat a Boolean as an integer. If you want `cout` to output `bool` values
    with string names, then insert the manipulator `boolalpha` in to the stream; this
    will make the stream print `true` or `false` to the console. The default behavior
    can be achieved by using the `noboolalpha` manipulator.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将布尔值插入输出流。但是，默认行为是将布尔值视为整数。如果要使`cout`输出带有字符串名称的`bool`值，则在流中插入操作符`boolalpha`；这将使流打印`true`或`false`到控制台。可以使用`noboolalpha`操作符来实现默认行为。
- en: void
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: void
- en: 'In some cases, you need to indicate that a function does not have parameters
    or will not return a value; in both cases, you can use the keyword `void`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要指示函数没有参数或不会返回值；在这两种情况下，您可以使用关键字`void`：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The use of `void` in the parameter list is optional; an empty pair of parentheses
    is acceptable and is preferable. This is the only way to indicate that a function
    returns no value other than returning `void`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数列表中使用`void`是可选的；接受空括号对并且更可取。这是唯一的一种方式来指示函数返回除返回`void`之外的值。
- en: 'Note that `void` is not really a type because you cannot create a `void` variable;
    it is the absence of a type. As you''ll find out in the next chapter, you can
    create pointers of the type `void`, but you will not be able to use the memory
    that such pointers point to without casting to a typed pointer: to use the memory
    you have to decide the type of the data that the memory holds.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`void`实际上不是一种类型，因为您无法创建`void`变量；它是没有类型。正如您将在下一章中了解到的那样，您可以创建`void`类型的指针，但是您将无法使用这些指针指向的内存而不进行类型转换：要使用内存，您必须决定内存保存的数据的类型。
- en: Initializers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化器
- en: Initializers were touched upon in the last chapter, but we will go into more
    depth here. For built-in types, you must initialize a variable before you use
    it. For custom types, it is possible for the type to define a default value, but
    there are some issues in doing this, which will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器在上一章中已经提到过，但我们将在这里更深入地讨论。对于内置类型，您必须在使用变量之前初始化变量。对于自定义类型，类型可能定义默认值，但在这样做时会出现一些问题，这将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中进行介绍，*类*。
- en: 'In all versions of C++, there are three ways to initialize a built-in type:
    assignment, function syntax, or calling a constructor. In C++11 another way to
    initialize variables was introduced: construction through a list initializer.
    These four ways are shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++的所有版本中，有三种初始化内置类型的方式：赋值、函数语法或调用构造函数。在C++11中引入了另一种初始化变量的方式：通过列表初始化进行构造。这四种方式如下所示：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first of these three is the clearest; it shows, using an easy to understand
    syntax, that the variable is being initialized to a value. The second example
    initializes a variable by calling the type as if it is a function. The third example
    calls the constructor of the `int` type. This is a typical way to initialize custom
    types, so it is best to reserve this syntax just for custom types.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方式中的第一种是最清晰的；它使用易于理解的语法显示变量正在初始化为一个值。第二个示例通过调用类型来初始化变量，就好像它是一个函数一样。第三个示例调用`int`类型的构造函数。这是初始化自定义类型的典型方式，因此最好将此语法保留给自定义类型。
- en: 'The fourth syntax is new to C++11 and initializes the variable using an initialize
    list between curly braces (`{}`). Just to confuse things slightly, you can also
    initialize a built-in type using the same syntax as an assignment to a single
    item list:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种语法是C++11中的新语法，并使用花括号（`{}`）之间的初始化列表初始化变量。稍微令人困惑的是，您还可以使用与分配给单个项目列表相同的语法来初始化内置类型：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is really confusing things, the type `n` is an integer, not an array.
    Recall that, in the last chapter, we created an array with the birth dates of
    The Beatles:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的让事情变得混乱，类型`n`是一个整数，而不是数组。回想一下，在上一章中，我们创建了一个包含The Beatles的出生日期的数组：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This creates an array of four integers; the type of each item is `int` but
    the type of the array variable is `int*`. The variable points to memory that holds
    four integers. Similarly, you can also initialize a variable to be an array of
    one item:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含四个整数的数组；每个项目的类型为`int`，但数组变量的类型为`int*`。该变量指向保存四个整数的内存。同样，您还可以将变量初始化为一个项目的数组：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is exactly the same initialization code that C++11 allows to initialize
    a single integer. In addition, the same syntax is used to initialize instances
    of record types (`structs`), adding another level of potential confusion about
    what the syntax means.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是C++11允许初始化单个整数的初始化代码。此外，相同的语法用于初始化记录类型（`structs`）的实例，增加了关于语法意义的另一层潜在混淆。
- en: It is best to avoid using the curly brace syntax for variable initialization
    and use it exclusively for initializing lists. However, there are advantages to
    this syntax for casting, as explained shortly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免使用花括号语法进行变量初始化，而将其专门用于初始化列表。然而，这种语法在类型转换方面有一些优势，稍后会解释。
- en: 'The curly brace syntax can be used to provide the initial values for any of
    the collection classes in the C++ Standard Library, as well as for C++ arrays.
    Even when used to initialize a collection object, there is a potential for confusion.
    For example, consider the `vector` collection class. This can hold a collection
    of the type provided through a pair of angled brackets (`<>`). The capacity of
    an object of this class can grow as you add more items to the object, but you
    can optimize its use by specifying an initial capacity:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号语法可以用于为C++标准库中的任何集合类提供初始值，以及用于C++数组。即使用于初始化集合对象，也存在混淆的可能。例如，考虑`vector`集合类。它可以保存通过一对尖括号(`<>`)提供的类型的集合。这个类的对象的容量可以随着向对象添加更多项目而增长，但你可以通过指定初始容量来优化其使用：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first line of this code says: create a `vector` object that can hold integers
    and start by reserving space for 42 integers, each initialized to a value of zero.
    The second line prints the size of the vector to the console (42) and the third
    line prints all the items in the array to the console and it will print 42 zeros.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一行表示：创建一个可以保存整数的`vector`对象，并开始为42个整数保留空间，每个整数初始化为零值。第二行将向控制台打印出向量的大小（42），第三行将向控制台打印出数组中的所有项目，它将打印出42个零值。
- en: 'Now consider the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下情况：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There is only one change here: the parentheses have been changed to braces
    but it means that the initialization has been changed entirely. The first line
    now means: create a `vector` that can hold integers and initialize it with the
    single integer, 42\. The size of `a2` is 1 and the last line will print just one
    value, 42.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只有一个变化：括号已经改为花括号，但这意味着初始化已经完全改变。第一行现在表示：创建一个可以保存整数的`vector`，并用单个整数42进行初始化。`a2`的大小为1，最后一行将只打印一个值，42。
- en: The great power of C++ is that it should be easy to write correct code, and
    to persuade the compiler to help you to avoid mistakes. The use of braces for
    single item initialization increases the possibility of hard-to-find errors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: C++的强大之处在于应该很容易编写正确的代码，并且说服编译器帮助你避免错误。使用花括号进行单个项目初始化会增加难以发现错误的可能性。
- en: Default values
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值
- en: Variables of built-in types should be initialized before you first use them,
    but there are some situations when the compiler will provide a default value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型的变量在首次使用前应该被初始化，但有一些情况下编译器会提供一个默认值。
- en: 'If you declare a variable at file scope, or globally in your project, and you
    do not give it an initial value, the compiler will give it a default value. For
    example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文件范围或项目中全局声明一个变量，并且没有给它一个初始值，编译器会给它一个默认值。例如：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This code will compile and run, printing a value of 1; the compiler has initialized
    `outside` to 0, which is then incremented to 1\. The following code will not compile:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将编译并运行，打印出一个值为1；编译器已经将`outside`初始化为0，然后递增为1。以下代码将无法编译：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The compiler will complain that the increment operator is being used on an uninitialized
    variable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨增量运算符被用在一个未初始化的变量上。
- en: 'In the last chapter, we saw another example of the compiler providing a default
    value: `static`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到编译器提供了默认值的另一个例子：`static`。
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a simple function that maintains a count. The variable `count` is marked
    with the `static` storage class modifier, meaning that the variable has the same
    lifetime as the application (allocated when the code starts and deallocated when
    the program ends); however, it has internal linkage, meaning the variable can
    only be used within the scope of where it is declared, the `counter` function.
    The compiler will initialize the `count` variable with a default value of zero,
    so that the first time the `counter` function is called it will return a value
    of 1.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，用于维护一个计数。变量`count`被标记为`static`存储类修饰符，意味着该变量与应用程序具有相同的生命周期（在代码启动时分配，在程序结束时释放）；然而，它具有内部链接，意味着该变量只能在声明它的范围内使用，即`counter`函数。编译器将使用默认值0初始化`count`变量，因此第一次调用`counter`函数时将返回值1。
- en: 'The new initialize list syntax of C++11 provides a way for you to declare a
    variable and specify that you want it initialized by the compiler to the default
    value for that type:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的新初始化列表语法提供了一种声明变量并指定你希望它由编译器初始化为该类型的默认值的方法：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Of course, when reading this code, you have to know what the default value
    for an `int` is (it is zero). Again, it is much easier and more explicit to simply
    initialize the variable to a value:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读这段代码时，你必须知道`int`的默认值是什么（是零）。再次强调，将变量简单地初始化为一个值要容易得多，也更明确：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The rules for default values are simple: a value of zero. Integers and floating
    point numbers have a default value of 0, for a character the default value is
    `\0`, for a `bool` it is `false,` and for a pointer the default is the constant,
    `nullptr`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值的规则很简单：零值。整数和浮点数的默认值为0，字符的默认值为`\0`，`bool`的默认值为`false`，指针的默认值为常量`nullptr`。
- en: Declarations without a type
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有类型的声明
- en: C++11 introduces a mechanism for declaring that a variable's type should be
    determined from the data it is initialized with, that is, `auto`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一种机制，声明变量的类型应该根据初始化的数据来确定，即`auto`。
- en: There is a minor confusion here because prior to C++11, the `auto` key was used
    to declare **automatic** variables, that is, variables that are automatically
    allocated on the stack in a function. Other than variables declared at file scope
    or as `static`, all the other variables in this book so far have been automatic
    variables and automatic variables are the most widely used **storage class** (explained
    shortly). Since it was optional and applicable to most variables, the `auto` keyword
    was rarely used in C++, so C++11 took advantage of this, removed the old meaning,
    and gave `auto` a new meaning.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小混淆，因为在C++11之前，`auto`关键字用于声明**自动**变量，即在函数中自动分配在堆栈上的变量。除了在文件范围内声明的变量或`static`变量之外，到目前为止本书中的所有其他变量都是自动变量，自动变量是最广泛使用的**存储类**（稍后解释）。由于它是可选的并且适用于大多数变量，`auto`关键字在C++中很少被使用，因此C++11利用了这一点，删除了旧的含义，并赋予了`auto`新的含义。
- en: If you are compiling old C++ code with a C++11 compiler and that old code uses
    `auto`, you will get errors because the new compiler will assume `auto` will be
    used with variables with no specified type. If this happens, simply search and
    delete each instance of `auto`; it was redundant in C++ prior to C++11, and there
    was little reason for a developer to use it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用C++11编译器编译旧的C++代码，并且那个旧代码使用了`auto`，你会得到错误，因为新的编译器会假定`auto`将用于没有指定类型的变量。如果发生这种情况，只需搜索并删除每个`auto`实例；在C++11之前的C++中，它是多余的，开发人员几乎没有理由使用它。
- en: 'The `auto` keyword means that the compiler should create a variable with the
    type of the data that is assigned to it. The variable can only have a single type,
    the type the compiler decides is the type it needs for the data assigned to it,
    and you cannot use the variable elsewhere to hold data of a different type. Because
    the compiler needs to determine the type from an initializer, it means that all
    `auto` variables must be initialized:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字意味着编译器应该创建一个与分配给它的数据类型相同的变量。变量只能有一个类型，编译器决定的类型是它需要的数据分配的类型，你不能在其他地方使用变量来保存不同类型的数据。因为编译器需要从初始化程序确定类型，这意味着所有`auto`变量必须被初始化：'
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that there is no syntax to specify that an integer value is a single byte
    or two bytes, so you cannot create `unsigned char` variables or `short` variables
    this way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有语法来指定整数值是单字节还是双字节，因此你不能以这种方式创建`unsigned char`变量或`short`变量。
- en: 'This is a trivial use of the `auto` keyword and you should not use it this
    way. The power of auto is when you use containers that can result in some fairly
    complicated looking types:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`auto`关键字的一个微不足道的用法，你不应该这样使用。`auto`的威力在于你使用可能导致一些看起来相当复杂的类型的容器时：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This code uses the `vector` container we have used before, but it stores two
    value items using a `tuple`. The `tuple` class is simple; you declare a list of
    the types of items in the `tuple` object in the declaration between the angle
    brackets. So, the `tuple<string, int>` declaration says that the object will hold
    a string and an integer, in that order. The `make_tuple` function is provided
    by the C++ Standard Library and will create a `tuple` object containing the two
    values. The `push_back` function will put the item into the vector container.
    After the four calls to the `push_back` function, the `beatles` variable will
    contain four items and each one is a `tuple` with a name and birth year.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了我们之前使用过的`vector`容器，但是使用`tuple`存储了两个值。`tuple`类很简单；在尖括号之间的声明中声明了`tuple`对象中项目类型的列表。因此，`tuple<string,
    int>`声明表示对象将按顺序保存一个字符串和一个整数。`make_tuple`函数由C++标准库提供，将创建一个包含两个值的`tuple`对象。`push_back`函数将项目放入向量容器中。在四次调用`push_back`函数之后，`beatles`变量将包含四个项目，每个项目都是一个带有姓名和出生年份的`tuple`。
- en: 'The range `for` loops through the container and on each loop assigns the `musician`
    variable with the next item in the container. The values in the `tuple` are printed
    to the console in the statements in the `for` loop. An item in the `tuple` is
    accessed using the `get` parameterized function (from `<tuple>`) where the parameter
    in the angle brackets indicates the index of the item (indexed from zero) to get
    from the `tuple` object passed as a parameter in the parentheses. In this example,
    the call to `get<0>` gets the name which is printed out, then a space, and then
    `get<1>` gets the year item in the `tuple`. The result of this code is:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 范围`for`循环遍历容器，并在每次循环中将`musician`变量分配给容器中的下一个项目。`tuple`中的值在`for`循环中的语句中打印到控制台。使用`get`参数化函数（来自`<tuple>`）访问`tuple`中的项目，尖括号中的参数指示从作为参数传递的`tuple`对象中获取的项目的索引（从零开始索引）。在这个例子中，对`get<0>`的调用获取了名字，然后是一个空格，然后`get<1>`获取了`tuple`中的年份项目。这段代码的结果是：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This text has poor formatting because it does not take into account the length
    of the names. This can be addressed using manipulators explained in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字格式不佳，因为它没有考虑名称的长度。这可以通过[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml)中解释的操作符来解决，*使用字符串*。
- en: 'Take another look at the `for` loop:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下`for`循环：
- en: '[PRE52]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The type of musician is `tuple<string, int>;`, this is a fairly simple type,
    and as you use the standard template more you could end up with some complicated
    types (particularly when you use **iterators**). This is where `auto` becomes
    useful. The following code is the same, but easier to read:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐家的类型是`tuple<string, int>;`，这是一个相当简单的类型，随着你使用标准模板更多，你可能会得到一些复杂的类型（特别是当你使用**迭代器**时）。这就是`auto`变得有用的地方。下面的代码是相同的，但更容易阅读：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The musician variable is still typed, it is a `tuple<string, int>`, but `auto`
    means you do not have to explicitly code this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐家变量仍然是有类型的，它是一个`tuple<string, int>`，但`auto`意味着你不必明确编写这个。
- en: Storage classes
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储类
- en: When declaring a variable, you can specify its storage class which indicates
    the lifetime, linkage (what other code can access it), and memory location of
    the variable.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，你可以指定它的存储类，这表示变量的生存期、链接（其他代码可以访问它的内容）和内存位置。
- en: You have already seen one storage class, `static`, which when applied to a variable
    in a function means that the variable can only be accessed within that function,
    but its lifetime is the same as the program. However, `static` can be used on
    variables declared at file scope, in which case it indicates that the variable
    can only be used in the current file, which is called **internal linkage**. If
    you omit the `static` keyword on a variable, defined at file scope, then it has
    an **external linkage,** which means the name of the variable is visible to code
    in other files. The `static` keyword can be used on a data member of a class,
    and on methods defined on a class, both of which have interesting effects that
    will be described in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一个存储类`static`，当应用于函数中的变量时，意味着该变量只能在该函数内访问，但其生存期与程序相同。然而，`static`可以用于在文件范围内声明的变量，这种情况下表明该变量只能在当前文件中使用，这被称为**内部链接**。如果在文件范围内声明的变量上省略`static`关键字，则具有**外部链接**，这意味着变量的名称对其他文件中的代码可见。`static`关键字可以用于类的数据成员和类中定义的方法，这两者都有有趣的影响，将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*中进行描述。
- en: The `static` keyword says that the variable can only be used in the current
    file. The `extern` keyword indicates the opposite; the variable (or function)
    has external linkage and can be accessed in other files in the project. In most
    cases, you will define a variable in one source file, and then declare it as `extern`
    in a header file so that the same variable can be used in other source files.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`关键字表示该变量只能在当前文件中使用。`extern`关键字表示相反；变量（或函数）具有外部链接，并且可以在项目的其他文件中访问。在大多数情况下，您将在一个源文件中定义一个变量，然后在头文件中声明它为`extern`，以便在其他源文件中使用相同的变量。'
- en: The final storage class specifier is `thread_local`. This is new to C++11 and
    it only applies to multithreaded code. This book does not cover threading, so
    only a brief description will be given here.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个存储类说明符是`thread_local`。这是C++11中的新功能，它只适用于多线程代码。本书不涉及线程，因此这里只会给出一个简要描述。
- en: A thread is a unit of execution and concurrency. You can have more than one
    thread running in a program, and it is possible to have two or more threads running
    the same code at the same time. This means that two different threads of execution
    could access and alter the same variable. Since concurrent access may have undesirable
    effects, multithreaded code often involves taking action to ensure that only one
    thread can access data at any time. If such code is not written carefully there
    is a danger of deadlocks, where the execution of threads is paused (in the worst
    cases, indefinitely) for exclusive access to the variable, negating the benefit
    of using threads.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是执行和并发的单位。程序中可以有多个线程运行，可能有两个或更多个线程同时运行相同的代码。这意味着两个不同的执行线程可以访问和更改同一个变量。由于并发访问可能会产生不良影响，多线程代码通常涉及采取措施确保只有一个线程可以在任何时候访问数据。如果这样的代码没有小心编写，就有死锁的危险，其中线程的执行被暂停（在最坏的情况下，是无限期地）以独占访问变量，从而抵消了使用线程的好处。
- en: The `thread_local` storage class indicates that each thread will have its own
    copy of a variable. So, if two threads access the same function and a variable
    in that function is marked as `thread_local,` it means that each thread only sees
    the changes it makes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread_local`存储类表示每个线程将有自己的变量副本。因此，如果两个线程访问同一个函数，并且该函数中的变量标记为`thread_local`，这意味着每个线程只看到它所做的更改。'
- en: You will sometimes see the storage class `register` used in older C++ code.
    This is now deprecated. It was used as a hint to the compiler that the variable
    has important consequences on the performance of the program and suggests to the
    compiler that if possible it should use a CPU register to hold the variable. The
    compiler could ignore this suggestion. In fact, in C++11 the compiler literally
    does ignore the keyword; code with `register` variables will compile with no errors
    or warnings and the compiler will optimize the code however it feels is necessary.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您有时会在旧的C++代码中看到存储类`register`的使用。这现在已经不推荐使用了。它被用作向编译器提示变量对程序性能有重要影响，并建议编译器尽可能使用CPU寄存器来保存变量。编译器可以忽略这个建议。事实上，在C++11中，编译器确实忽略了这个关键字；带有`register`变量的代码将编译而不会出现错误或警告，并且编译器将根据需要优化代码。
- en: Although it is not a storage class specifier, the `volatile` keyword has an
    effect on compiler code optimization. The `volatile` keyword indicates that a
    variable (perhaps through **Direct Memory Access** (**DMA**) to some hardware)
    can be altered by an external action, and so it is important that the compiler
    *does not* apply any optimizations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不是存储类说明符，但`volatile`关键字对编译器代码优化有影响。`volatile`关键字表示变量（可能通过**直接内存访问**（**DMA**）到某些硬件）可以被外部操作改变，因此对编译器来说很重要*不要*应用任何优化。
- en: There is one other storage class modifier called `mutable`. This can only be
    used on class members and so it will be covered in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个存储类修饰符叫做`mutable`。这只能用于类成员，因此将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*中进行介绍。
- en: Using type aliases
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型别名
- en: 'Sometimes the names of types can become quite cumbersome. If you use nested
    namespaces, the name of a type includes all of the namespaces used. If you define
    parameterized types (examples used so far in this chapter are `vector` and `tuple`),
    the parameters increase the name of the type. For example, earlier we saw a container
    for the names and birth years of musicians:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时类型的名称可能变得相当繁琐。如果您使用嵌套命名空间，类型的名称包括所有使用的命名空间。如果您定义参数化类型（本章迄今为止使用的示例是`vector`和`tuple`），参数会增加类型的名称。例如，我们之前看到了一个用于音乐家姓名和出生年份的容器：
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, the container is a `vector` and it holds items that are `tuple` items,
    each of which will hold a string and an integer. To make the type easier to use
    you could define a preprocessor symbol:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，容器是`vector`，它包含`tuple`项，每个项将包含一个字符串和一个整数。为了使类型更易于使用，您可以定义一个预处理器符号：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now you can use `name_year` instead of the `tuple` in your code, and the preprocessor
    will replace the symbol with the type before the code is compiled:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在代码中使用`name_year`而不是`tuple`，预处理器将在编译代码之前用该类型替换符号：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, because `#define` is a simple search and replace, there can be problems
    as explained earlier in this book. C++ provides the `typedef` statement to create
    an alias for a type:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于`#define`是一个简单的搜索和替换，正如本书前面解释的那样，可能会出现问题。C++提供了`typedef`语句来为类型创建别名：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, an alias called `name_year_t` is created for `tuple<string, int>`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为`tuple<string, int>`创建了一个名为`name_year_t`的别名。
- en: With a `typedef,` the alias usually comes at the end of the line preceded by
    the type it aliases. This is the opposite order to `#define,` where the symbol
    you are defining comes after `#define`, followed by its definition. Note also
    `typedef` is terminated with a semicolon. It becomes much more complicated with
    function pointers, as you'll see in [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml),
    *Using Functions*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typedef`时，别名通常位于行末，前面是它的别名。这与`#define`相反，其中您要定义的符号在`#define`之后，后面是其定义。还要注意，`typedef`以分号结束。对于函数指针，情况变得更加复杂，您将在[第5章](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml)
    *使用函数*中看到。
- en: 'Now, wherever you want use the `tuple`, you can use the alias:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时您想使用`tuple`，都可以使用别名：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can `typedef` aliases:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以`typedef`别名：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The type of the `beatles2` variable is `vector<tuple<string, int>>`. It is important
    to note that `typedef` creates an alias; it does not create a new type, so you
    can switch between the original type and its alias.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`beatles2`变量的类型是`vector<tuple<string, int>>`。重要的是要注意，`typedef`创建一个别名；它不会创建新类型，因此您可以在原始类型和其别名之间切换。'
- en: The `typedef` keyword is a well-established way to create aliases in C++.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef`关键字是在C++中创建别名的一种成熟方式。'
- en: 'C++11 introduces another way to create a type alias, the `using` statement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了另一种创建类型别名的方法，即`using`语句：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Again, this does not create a new type, it creates a new name for the same type,
    and semantically, this is the same as `typedef`. The `using` syntax can be more
    readable than using a `typedef` and it also allows you to use templates.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这不会创建新类型，而是为相同类型创建新名称，从语义上讲，这与`typedef`相同。`using`语法可能比使用`typedef`更易读，它还允许您使用模板。
- en: The `using` method of creating an alias is more readable than `typedef` because
    the use of the assignment follows the convention used for variables, that is,
    the new name on the left is used for the type on the right of the `=`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`using`方法创建别名比`typedef`更易读，因为赋值的使用遵循用于变量的约定，也就是说，左边的新名称用于`=`右边的类型。
- en: Aggregating data in record types
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在记录类型中聚合数据
- en: 'Often you will have data that is related and must be used together: an aggregated
    type. Such a record type allows you to encapsulate data into a single variable.
    C++ inherits from C `struct` and `union`, as ways of providing records.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将具有相关联且必须一起使用的数据：聚合类型。这样的记录类型允许您将数据封装到单个变量中。C++继承自C`struct`和`union`，作为提供记录的方式。
- en: Structures
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: 'In most applications, you will want to associate several data items together.
    For example, you may want to define a time record that has an integer for each
    of the following: the hour, the minute, and the second of the specified time.
    You can declare them like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，您将希望将多个数据项关联在一起。例如，您可能希望定义一个时间记录，其中每个时间都有一个整数：指定时间的小时、分钟和秒。您可以这样声明它们：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This approach becomes quite cumbersome and error-prone. There is no encapsulation,
    that is, the `_min` variables can be used in isolation to the other variables.
    Does the *minutes past the hour* make sense when it is used without the hour that
    it refers to? You can define a structure that associates these items:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法变得相当繁琐且容易出错。没有封装，也就是说，`_min`变量可以独立于其他变量使用。当没有它所指的小时时，“小时过去的分钟”是否有意义？您可以定义一个结构，将这些项关联起来：
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now you have the three values as part of one record, which means that you can
    declare variables of this type; although you can access individual items it is
    clear that the data is associated with the other members:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将三个值作为一个记录的一部分，这意味着您可以声明此类型的变量；尽管您可以访问单个项目，但很明显数据与其他成员相关联：
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we have two variables: one that represents the start time, and the other
    that represents the end time. The members of a `struct` are encapsulated within
    the `struct`, that is, you access the member through the instance of the `struct`.
    To do this, you use the dot operator. In this code, `start_work.sec` means that
    you are accessing the `sec` member of the instance of the `time_of_day` structure
    called `start_work`. The members of a structure are `public` by default, that
    is, code outside the `struct` has access to the members.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个变量：一个表示开始时间，另一个表示结束时间。`struct`的成员封装在`struct`内部，也就是说，您通过`struct`的实例访问成员。为此，您使用点运算符。在此代码中，`start_work.sec`表示您正在访问名为`start_work`的`time_of_day`结构的实例的`sec`成员。结构的成员默认为`public`，也就是说，`struct`外部的代码可以访问成员。
- en: Classes and structures can indicate the level of member access, and [Chapter
    6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*, will show how to do
    this. For example, it is possible to mark some members of a `struct` as `private`,
    which means that only code that is a member of the type can access the member.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构可以指示成员访问级别，[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml) *类*将展示如何做到这一点。例如，可以将`struct`的某些成员标记为`private`，这意味着只有类型的成员才能访问成员。
- en: 'A helper function called `print_time` is called to print the data to the console:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 调用名为`print_time`的辅助函数以将数据打印到控制台：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this case, the `setw` and `setfill` manipulators are used to set the width
    of the next inserted item to two characters and to fill any unfilled places with
    zeros (more details will be given in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using String*; in effect, `setw` gives the size of the column occupied by the
    next inserted data, and `setfill` specifies the padding character used).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`setw`和`setfill`操作器将下一个插入的项目的宽度设置为两个字符，并用零填充任何未填充的位置（更多细节将在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml)，“使用字符串”中给出；实际上，`setw`给出了下一个插入数据所占列的大小，`setfill`指定了所使用的填充字符）。
- en: '[Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*,
    will go into more detail about the mechanism of passing structures to functions
    and the most efficient way to do it, but for the purpose of this section we will
    use the simplest syntax here. The important point is that the caller has associated
    the three items of data together using a `struct` and all the items can be passed
    to a function as a unit.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml)，“使用函数”，将更详细地介绍将结构传递给函数的机制以及最有效的方法，但是为了本节的目的，我们将在这里使用最简单的语法。重要的是，调用者使用`struct`关联了三个数据项，并且所有数据项可以作为一个单元传递给函数。'
- en: Initializing
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: 'There are several ways to initialize an instance of a structure. The preceding
    code shows one method: accessing the member using the dot operator, and assigning
    it a value. You can also assign values to an instance of a `struct` through a
    specially provided function called a constructor. Since there are special rules
    about how to name a constructor and what you can do in them, this will be left
    until [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种初始化结构实例的方法。前面的代码显示了一种方法：使用点运算符访问成员，并为其赋值。您还可以通过一个特别提供的名为构造函数的函数为`struct`的实例分配值。由于有关如何命名构造函数以及您可以在其中执行的特殊规则，这将留到[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)，“类”。
- en: 'You can also initialize structures using the list initializer syntax using
    curly braces (`{}`). The items in the braces should match the members of the `struct`
    in the order of the members as declared. If you provide fewer values than there
    are members, the remaining members are initialized to zero. Indeed, if you provide
    no items between the curly braces then all members are set to zero. It is an error
    to provide more initializers than there are members. So, use the `time_of_day`
    record type defined previously:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用列表初始化程序语法使用大括号（`{}`）初始化结构。大括号中的项目应与`struct`的成员按照声明的成员顺序匹配。如果提供的值少于成员数量，则其余成员将初始化为零。实际上，如果在大括号之间不提供任何项目，则所有成员都将设置为零。如果提供的初始化程序多于成员数量，则会出错。因此，使用先前定义的`time_of_day`记录类型：
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the first example, the `lunch` variable is initialized to 1 PM. Notice that,
    because the `hour` member is declared as the third member in the type, it is initialized
    using the third item in the initialize list. In the second example, all members
    are set to zero, and of course, zero hours is midnight. The third example provides
    two values, so these are used to initialize `sec` and `min`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，`lunch`变量被初始化为下午1点。请注意，因为`hour`成员被声明为类型中的第三个成员，所以它是使用初始化列表中的第三个项目进行初始化的。在第二个示例中，所有成员都设置为零，当然，零小时是午夜。第三个示例提供了两个值，因此这些值用于初始化`sec`和`min`。
- en: 'You can have a member of a `struct` that is a `struct` itself, and this is
    initialized using nested braces:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有一个`struct`的成员本身是一个`struct`，并且可以使用嵌套的大括号进行初始化：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Structure fields
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构字段
- en: 'A structure can have members that are as small as a single bit, called a **bit-field**.
    In this case, you declare an integer member with the number of bits that the member
    will take up. You are able to declare unnamed members. For example, you may have
    a structure that holds information about the length of an item, and whether the
    item has been changed (is dirty). The item this refers to has a maximum size of
    1,023, so you need an integer with at least 10 bits of width to hold this. You
    could use an `unsigned short` to hold both the length and the dirty information:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以有最小为单个位的成员，称为**位字段**。在这种情况下，您声明一个整数成员，该成员将占用成员的位数。您可以声明未命名的成员。例如，您可能有一个结构，其中包含有关项目长度以及项目是否已更改（脏）的信息。此引用的项目的最大大小为1,023，因此您需要一个宽度至少为10位的整数来保存这个信息。您可以使用`unsigned
    short`来保存长度和脏信息：
- en: '[PRE67]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code separates the two pieces of information, and then prints them out.
    A bitmap like this is quite unfriendly to code. You can use a `struct` to hold
    this information using an `unsigned short` to hold the 10 bits of length information
    and a `bool` to hold the dirty information. Using bit fields you can define the
    structure like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将信息分开，然后将其打印出来。这样的位图对代码来说非常不友好。您可以使用`struct`来保存这些信息，使用`unsigned short`来保存10位长度信息，使用`bool`来保存脏信息。使用位字段，您可以定义结构如下：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `len` member is marked as `unsigned short` but only 10 bits are needed,
    so this is mentioned using the colon syntax. Similarly, a Boolean yes/no value
    can be held in just one bit. The structure indicates that there are five bits
    between the two values that are not used, and so have no name.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`成员标记为`unsigned short`，但只需要10位，因此使用冒号语法进行了说明。同样，一个布尔值可以仅用一个位来保存。结构指示两个值之间有五位未使用，因此没有名称。'
- en: 'Fields are simply a convenience. Although it looks like the `item_length` structure
    should only take up 16 bits (`unsigned short`), there is no guarantee that the
    compiler will do this. If you receive an `unsigned short` from a file or network
    stream you will have to extract the bits yourself:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 字段只是一种便利。尽管看起来`item_length`结构应该只占用16位（`unsigned short`），但不能保证编译器会这样做。如果您从文件或网络流接收到`unsigned
    short`，则必须自己提取位：
- en: '[PRE69]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using structure names
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构名
- en: 'In some cases, you may need to use a type before you have actually defined
    it. As long as you do not use the members, you can declare a type before defining
    it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要在实际定义之前使用类型。只要你不使用成员，你可以在定义之前声明类型：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This could be declared in a header, where it says that there is a function defined
    somewhere else that takes a `time_of_day` record and prints it out. To be able
    to declare the `print_day` function, you have to have declared the `time_of_day`
    name. The `time_of_day` struct must be defined somewhere else in your code before
    the function is defined, otherwise you will get an *undefined type* error.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在头文件中声明，在那里它说有一个在其他地方定义的函数，它接受一个`time_of_day`记录并将其打印出来。要能够声明`print_day`函数，你必须已经声明了`time_of_day`名称。`time_of_day`结构必须在代码的其他地方定义，然后才能定义函数，否则你将会得到一个*未定义类型*的错误。
- en: 'There is, however, an exception: a type can hold pointers to instances of the
    same type before the type is fully declared. This is because the compiler knows
    the size of a pointer, so it can allocate sufficient memory for the member. It
    is not until the entire type has been defined before you can create an instance
    of the type. The classic example of this is a linked list, but since this requires
    using pointers and dynamic allocation, that will be left to the next chapter.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个例外：在类型完全声明之前，类型可以保存指向相同类型实例的指针。这是因为编译器知道指针的大小，所以它可以为成员分配足够的内存。只有在整个类型定义之后，你才能创建类型的实例。这个经典的例子是链表，但由于这需要使用指针和动态分配，这将留到下一章节。
- en: Determining alignment
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定对齐
- en: 'One of the uses of structs is that if you know how data is held in memory you
    can deal with a struct as a block of memory. This is useful if you have a hardware
    device that is mapped into memory, where different memory locations refer to values
    controlling or returning values from the device. One way to access the device
    would be to define a struct that matches the memory layout of the device''s direct
    memory access to C++ types. Further, structs are also useful for files, or for
    packets of data that need to be transmitted over the network: you manipulate the
    struct and then copy the memory occupied by the struct to the file or to the network
    stream.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的一个用途是，如果你知道数据在内存中的存储方式，你可以将结构作为内存块处理。如果你有一个映射到内存中的硬件设备，不同的内存位置指向控制或返回设备值的值。访问设备的一种方式是定义一个与设备的直接内存访问到C++类型的内存布局匹配的结构。此外，结构对于文件或需要通过网络传输的数据包也是有用的：你操作结构，然后将结构占用的内存复制到文件或网络流中。
- en: The members of the struct are arranged in memory in the order that they are
    declared in the type. The items will take up *at least* as much memory as each
    type requires. A member may take more memory than the type requires, and the reason
    for this is a mechanism called **alignment**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 结构的成员在内存中按照它们在类型中声明的顺序排列。项将占用*至少*每个类型所需的内存。成员可能占用的内存比类型所需的内存更多，这是一种叫做**对齐**的机制。
- en: 'The compiler will place variables in memory in the way that is the most efficient,
    in terms of memory usage, or speed of access. The various types will be aligned
    to alignment boundaries. For example, a 32-bit integer will be aligned to a four-byte
    boundary, and if the next available memory location is not on this boundary the
    compiler will skip a few bytes and put the integer at the next alignment boundary.
    You can test the alignment of a specific type using the `alignof` operator passing
    the type name:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将以最有效的方式将变量放置在内存中，无论是在内存使用还是访问速度方面。各种类型将对齐到对齐边界。例如，32位整数将对齐到四字节边界，如果下一个可用的内存位置不在这个边界上，编译器将跳过几个字节，并将整数放在下一个对齐边界上。你可以使用`alignof`运算符传递类型名称来测试特定类型的对齐方式：
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The alignment of an `int` is 4 and this means that an `int` variable will be
    placed at the next four-byte boundary in memory. The alignment of a `double` is
    8 and this makes sense because in Visual C++ a `double` occupies eight bytes.
    So far, it looks like the result of `alignof` is the same as `sizeof`; however,
    this is not so.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`的对齐方式是4，这意味着`int`变量将被放置在内存中的下一个四字节边界上。`double`的对齐方式是8，这是有道理的，因为在Visual
    C++中，`double`占用八个字节。到目前为止，`alignof`的结果看起来与`sizeof`是一样的；然而，事实并非如此。'
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This example prints the alignment of the `time_of_day` struct, which we previously
    defined to be three integers. The alignment of this `struct` is 4, that is, the
    alignment of the largest item in the `struct`. This means that an instance of
    `time_of_day` will be placed on a 4-byte boundary; it does not say how the items
    within the `time_of_day` variable will be aligned.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子打印了`time_of_day`结构的对齐方式，我们之前定义为三个整数。这个`struct`的对齐方式是4，也就是说，`struct`中最大项的对齐方式。这意味着`time_of_day`的实例将被放置在4字节边界上；它并没有说明`time_of_day`变量内的项将如何对齐。
- en: 'As an example, consider the following `struct`, which has four members that
    occupy respectively one, two, four, and eight bytes:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下`struct`，它有四个成员，分别占用一、二、四和八个字节：
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The compiler will tell you that the alignment is 8 (the alignment of the largest
    item, `ull`), but that the size is 16, which may appear a little odd. If every
    item were aligned on 8-byte boundaries, then the size would have to be 32 (four
    times eight). If the items were stored in memory and packed as efficiently possible,
    then the size would be 15\. Instead, what is happening is that the second item
    is aligned on a two-byte boundary, which means that there is one byte of unused
    space between `uc` and `us`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会告诉你对齐是8（最大项`ull`的对齐），但大小是16，这可能看起来有点奇怪。如果每个项都对齐在8字节边界上，那么大小将是32（四倍八）。如果项被存储在内存中并尽可能有效地打包，那么大小将是15。相反，实际发生的是第二个项在两字节边界上对齐，这意味着在`uc`和`us`之间有一个字节的未使用空间。
- en: '![](img/7623b00b-908e-4290-9bc8-897ab73ff91e.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7623b00b-908e-4290-9bc8-897ab73ff91e.png)'
- en: 'If you want to align the internal items onto, say, the same boundaries as used
    by a `uint32_t` variable, you can mark an item with `alignas` and give the alignment
    that you need. Note that, because 8 is bigger than 4, any item aligned on an 8-byte
    boundary will also be aligned on a 4-byte boundary:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将内部项对齐到与`uint32_t`变量使用的相同边界上，可以使用`alignas`标记一个项，并给出所需的对齐方式。请注意，因为8大于4，因此在8字节边界上对齐的任何项也将在4字节边界上对齐：
- en: '[PRE74]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `uc` item will be aligned on a 4-byte boundary already (`alignof(test)`
    will be 8), and it will occupy one byte. The `us` member is a `uint16_t` but it
    is marked with `alignas(uint32_t)` to say that it should be aligned in the same
    way as a `uint32_t`, that is, on a 4-byte boundary. This means that both `uc`
    and `us` will be on 4-byte boundaries with padding provided. Of course, the `ui`
    member will also be aligned on a 4-byte boundary because it is a `uint32_t`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`uc`项已经对齐在4字节边界上（`alignof(test)`将为8），它将占用一个字节。`us`成员是一个`uint16_t`，但标有`alignas(uint32_t)`，表示它应该与`uint32_t`以相同的方式对齐，即在4字节边界上。这意味着`uc`和`us`都将在提供填充的4字节边界上。当然，`ui`成员也将对齐在4字节边界上，因为它是一个`uint32_t`。'
- en: 'If the `struct` has just these first three members, then the size would be
    12\. However, the `struct` has another member, the 8-byte `ull` member. This must
    be aligned on an 8-byte boundary, which means 16 bytes from the beginning of the
    `struct`, and to do this there needs to be 4 bytes of padding between `ui` and
    `ull`. As a consequence, the size of `test` is now reported as 24: 4 bytes for
    `uc` and for `us` (because the following item `ui` has to be aligned on the next
    four-byte boundary), 8 bytes for `ull` (because it is an 8-byte integer), and
    8 bytes for `ui` because the following item (`ull`) has to be on the next 8-byte
    boundary.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`struct`只有这三个成员，那么大小将是12。然而，`struct`还有另一个成员，即8字节的`ull`成员。这必须对齐在8字节边界上，这意味着从`struct`的开始到16字节，因此在`ui`和`ull`之间需要有4字节的填充。因此，`test`的大小现在报告为24：`uc`和`us`各占4字节（因为接下来的项`ui`必须对齐在下一个4字节边界上），`ull`占8字节（因为它是一个8字节整数），`ui`占8字节，因为接下来的项（`ull`）必须在下一个8字节边界上。
- en: 'The following diagram shows the location in memory of the various members of
    the `test` type:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`test`类型的各个成员在内存中的位置：
- en: '![](img/87f6fc03-7112-4760-a585-5d112f9cc07c.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87f6fc03-7112-4760-a585-5d112f9cc07c.png)'
- en: You cannot use `alignas` to relax alignment requirements, so you cannot mark
    a `uint64_t` variable to be aligned on a two-byte boundary that is not also an
    eight-byte boundary.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能使用`alignas`来放宽对齐要求，因此您不能将`uint64_t`变量标记为在不是8字节边界的情况下对齐在两字节边界上。
- en: In most cases, you will not need to worry about alignment; however, if you are
    accessing memory-mapped devices, or binary data from files, it is convenient if
    you can directly map this data to a `struct` and in this case, you will find that
    you will have to pay close attention to alignment. This is known as **plain old
    data** and you will often see structs referred to as **POD types**.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不需要担心对齐；但是，如果您正在访问内存映射设备或来自文件的二进制数据，如果您可以直接将这些数据映射到一个`struct`，那将非常方便，在这种情况下，您将发现必须非常注意对齐。这被称为**纯旧数据**，您经常会看到`struct`被称为**POD类型**。
- en: POD is an informal description, and sometimes it is used to describe types that
    have a simple construction and do not have virtual members (see [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*
    and [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction to
    Object-Oriented Programming*). The standard library provides a function in `<type_traits>`
    called `is_pod` that tests a type for these members.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: POD是一个非正式的描述，有时用来描述具有简单构造并且没有虚拟成员的类型（参见[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)，*类*和[第7章](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml)，*面向对象编程简介*）。标准库提供了`<type_traits>`中的一个名为`is_pod`的函数，用于测试这些成员的类型。
- en: Storing data in the same memory with unions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同一内存中存储数据的联合
- en: A union is a struct where all the members occupy the same memory. The size of
    such a type is the size of the largest member. Since a union can only hold one
    item of data, it is a mechanism to interpret the data in more than one way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 联合是一个结构，其中所有成员占用相同的内存。这种类型的大小是最大成员的大小。由于联合只能容纳一个数据项，它是一种以多种方式解释数据的机制。
- en: 'An example of a union is in the `VARIANT` type that is used to pass data between
    **Object Linking and Embedding** (**OLE**) objects in Microsoft''s **Component
    Object Model** (**COM**). The `VARIANT` type can hold data of any of the data
    types that COM is able to transmit between OLE objects. Sometimes OLE objects
    will be in the same process, but it is possible for them to be in different processes
    on the same machine or on different machines. COM guarantees that it can transmit
    `VARIANT` without the developer providing any additional networking code. The
    structure is complicated, but an edited version is shown here:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 联合的一个示例是用于在Microsoft的**组件对象模型**（**COM**）中的**对象链接和嵌入**（**OLE**）对象之间传递数据的`VARIANT`类型。`VARIANT`类型可以容纳COM能够在OLE对象之间传输的任何数据类型的数据。有时，OLE对象将在同一个进程中，但它们也可能在同一台机器上的不同进程中，或者在不同的机器上。COM保证可以在不需要开发人员提供任何额外的网络代码的情况下传输`VARIANT`。结构很复杂，但这里显示了一个编辑过的版本：
- en: '[PRE75]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Notice that you can use a union without a name: this is an anonymous `union`
    and from a member access point of view you access a member of the union as if
    it is a member of the `VARIANT` that contains it. The `union` contains a member
    for every type that can be transmitted between OLE objects, and the `vt` member
    indicates which one is used. When you create a `VARIANT` instance, you have to
    set `vt` to the appropriate value and then initialize the related member:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用没有名称的联合：这是一个匿名的`union`，从成员访问的角度来看，您访问联合的成员就像访问包含它的`VARIANT`的成员一样。`union`包含可以在OLE对象之间传输的每种类型的成员，并且`vt`成员指示使用哪种类型。当您创建`VARIANT`实例时，必须将`vt`设置为适当的值，然后初始化相关的成员：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This record ensures that only the memory that is needed is used, and the code
    that transmits the data from one process to another will be able to read the `vt`
    member to determine how the data needs to be processed so that it can be transmitted:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这条记录确保只使用所需的内存，并且从一个进程传输数据到另一个进程的代码将能够读取`vt`成员，以确定数据需要如何被处理以便传输：
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that you must be disciplined and only initialize the appropriate member.
    When your code receives a `VARIANT,` you must read `vt` to see which member you
    should use to access the data.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须自律，只初始化适当的成员。当你的代码接收到一个`VARIANT`时，你必须读取`vt`来查看应该使用哪个成员来访问数据。
- en: 'In general, when using unions you should access only the item that you initialize:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当使用联合时，你应该只访问你初始化的项目：
- en: '[PRE78]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Accessing runtime type information
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问运行时类型信息
- en: 'C++ provides an operator called `typeid` that will return type information
    about a variable (or a type) at runtime. **Runtime Type Information** (**RTTI**)
    is significant when you use custom types that can be used in a **polymorphic**
    way; details will be left until later chapters. RTTI allows you to check at runtime
    the type of a variable and process the variable accordingly. RTTI is returned
    through a `type_info` object (in the `<typeinfo>` header file):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一个名为`typeid`的运算符，它将在运行时返回关于变量（或类型）的类型信息。**运行时类型信息**（**RTTI**）在你使用可以以**多态**方式使用的自定义类型时很重要；具体细节将留到后面的章节。RTTI允许你在运行时检查变量的类型并相应地处理变量。RTTI通过一个`type_info`对象返回（在`<typeinfo>`头文件中）：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In both cases, you''ll see int printed as the type. The `type_info` class defines
    comparison operators (`==` and `!=`) so you can compare types:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你会看到`int`作为类型被打印出来。`type_info`类定义了比较运算符(`==`和`!=`)，所以你可以比较类型：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Determining type limits
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定类型限制
- en: 'The `<limits>` header contains a template class called `numeric_limits` and
    this is used through the specializations provided for each of the built-in types.
    The way to use these classes is to provide the type you want information for in
    the angle brackets and then call the `static` members on the class using the scope
    resolution operator (`::`). (Full details of `static` functions on classes will
    be given in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*).
    The following prints the limits of the `int` type to the console:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`<limits>`头文件包含一个名为`numeric_limits`的模板类，通过为每种内置类型提供的特化来使用。使用这些类的方法是在尖括号中提供你想要获取信息的类型，然后使用作用域解析运算符(`::`)在类上调用`static`成员。（有关类上的`static`函数的完整详情将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中给出，*类*）。以下将`int`类型的限制打印到控制台：'
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Converting between types
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类型之间进行转换
- en: Even if you try exceptionally hard to use the correct types in your code, at
    some point you will find that you will have to convert between types. For example,
    you may be using library functions that return a value of a particular type, or
    you may be reading in data from an external source that is a different type to
    your routine.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你非常努力地在你的代码中使用正确的类型，最终你会发现你必须在不同类型之间进行转换。例如，你可能正在使用返回特定类型值的库函数，或者你可能正在从外部来源读取与你的例程不同类型的数据。
- en: With built-in types, there are standard rules about conversion between different
    types, some of which will be automatic. For example, if you have an expression
    like `a + b`, and `a` and `b` are different types, then, if it is possible, the
    compiler will automatically convert one variable's value to the type of the other
    and the `+` operator for that type will be called.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内置类型，有关不同类型之间的转换有标准规则，其中一些将是自动的。例如，如果你有一个表达式`a + b`，并且`a`和`b`是不同的类型，那么，如果可能的话，编译器将自动将一个变量的值转换为另一个变量的类型，并调用该类型的`+`运算符。
- en: In other cases, you may need to force one type to another type so that the right
    operator is called and this will require a cast of some kind. C++ allows you to
    use C-like casts, but these do not have runtime tests, so it is far better to
    use C++ casts, which have various levels of runtime checks and type safety.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，你可能需要强制一种类型转换为另一种类型，以便调用正确的运算符，这将需要某种类型的转换。C++允许你使用类似C的转换，但这些转换没有运行时测试，因此最好使用C++转换，它具有各种级别的运行时检查和类型安全性。
- en: Type conversions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'Built-in conversions can have one of two outcomes: promotion or narrowing.
    A promotion is when a smaller type is promoted to a larger type and you will not
    lose data. A narrowing conversion happens when a value from a larger type is converted
    to a smaller type with potential loss of data.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 内置转换可能有两种结果：提升或缩小。提升是指将较小的类型提升为较大的类型，不会丢失数据。缩小转换发生在将较大类型的值转换为较小类型的值时，可能会丢失数据。
- en: Promoting conversions
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升转换
- en: In a mixed type expression, the compiler will attempt to promote smaller types
    to the larger type. So, a `char` or a `short` can be used in an expression where
    an `int` is needed because it can be promoted to the larger type with no loss
    of data.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合类型表达式中，编译器将尝试将较小的类型提升为较大的类型。因此，`char`或`short`可以在需要`int`的表达式中使用，因为它可以被提升为较大的类型而不会丢失数据。
- en: 'Consider a function declared as taking a parameter that is an `int`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个声明为接受`int`参数的函数：
- en: '[PRE82]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can write:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写：
- en: '[PRE83]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here the variable `s` is silently converted to an `int`. There are some cases
    that may appear odd:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这里变量`s`被悄悄地转换为`int`。有些情况可能看起来很奇怪：
- en: '[PRE84]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Again, the conversion is silent. The compiler assumes you know what you are
    doing and that your intention is that you want `false` treated as 0 and `true`
    treated as 1.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，转换是悄悄进行的。编译器假设你知道自己在做什么，你的意图是希望`false`被视为0，`true`被视为1。
- en: Narrowing conversions
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小转换
- en: In some cases, *narrowing* occurs. Be very careful of this because it loses
    data. In the following, an attempt is made to convert a `double` into an `int`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，*缩小*会发生。一定要非常小心，因为这会丢失数据。在下面的示例中，尝试将`double`转换为`int`。
- en: '[PRE85]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This is allowed, but the compiler will issue a warning:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是允许的，但编译器会发出警告：
- en: '[PRE86]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This code is clearly wrong, but the mistake is not an error because it may
    be intentional. For example, in the following code we have a function that has
    a parameter that is a floating point, and within the routine the parameter is
    used to initialize an `int`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显然是错误的，但这个错误并不是一个错误，因为它可能是有意的。例如，在下面的代码中，我们有一个函数，它有一个浮点参数，并且在例程中，参数用来初始化一个`int`：
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This may be intentional, but because there will be a loss of precision you should
    document why you are doing this. At the very least, use a cast operator so that
    it is obvious that you understand the consequence of the action.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是有意的，但因为会丢失精度，你应该记录为什么这样做。至少使用一个转换操作符，这样很明显你理解了这个行为的后果。
- en: Narrowing to bool
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小到bool
- en: 'As mentioned previously, pointers, integers, and floating point values can
    be implicitly converted to `bool` where a nonzero value converts to `true` and
    a zero value converts to `false`. This can result in a nasty bug that is difficult
    to notice:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，指针、整数和浮点值可以在非零值转换为`true`，零值转换为`false`的地方隐式转换为`bool`。这可能导致一个难以注意到的严重错误：
- en: '[PRE88]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, the compiler sees the assignment expression `x = 1`, which is a bug; it
    should be the comparison `x == 1`. However, this is valid C++ because the value
    of the expression is 1 and the compiler, helpfully, converts this to a `bool`
    value of `true`. This code will compile without even a warning, and not only will
    it produce a result that is the opposite of what you expect (you'll see `not zero`
    printed on the console), but also the assignment will have changed the value of
    the variable propagating the error throughout the program.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器看到赋值表达式`x = 1`，这是一个bug；它应该是比较`x == 1`。然而，这是有效的C++，因为表达式的值是1，编译器会将其转换为`true`的`bool`值。这段代码将编译而不会有警告，不仅会产生一个与你期望相反的结果（你会在控制台上看到`not
    zero`打印出来），而且赋值会改变变量的值，从而在整个程序中传播错误。
- en: 'It is easy to avoid this bug by getting into the habit of always constructing
    a comparison so that the rvalue of a potential assignment is on the left. In a
    comparison, there will be no concept of rvalue or lvalue, so this uses the compiler
    to catch an assignment when it is not intended:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过养成一个习惯，总是构造一个比较，使得潜在赋值的rvalue在左边，很容易避免这个bug。在比较中，将没有rvalue或lvalue的概念，因此这使用编译器来捕捉一个意外的赋值：
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Converting signed types
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换有符号类型
- en: 'Signed to unsigned conversions can happen and can cause unexpected results.
    For example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号到无符号的转换可能会发生，导致意外的结果。例如：
- en: '[PRE90]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `unsigned short` variable will be assigned with a value of `0xfffffffd`,
    that is, the two's compliment of 3\. This may be the result you want, but it is
    an odd way of getting it.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsigned short`变量将被赋值为`0xfffffffd`，即3的二进制补码。这可能是你想要的结果，但这是一个奇怪的方式来得到它。'
- en: 'Interestingly, if you try and compare these two variables, the compiler will
    issue a warning:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你尝试比较这两个变量，编译器会发出一个警告：
- en: '[PRE91]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The Visual C++ warning C4018 given here is `''<'': signed/unsigned mismatch`,
    which says that you cannot compare a signed and unsigned type, and to do so would
    need a cast.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '这里给出的Visual C++警告C4018是`''<'': signed/unsigned mismatch`，它表示你不能比较有符号和无符号类型，这样做需要一个转换。'
- en: Casting
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: In some cases, you will have to convert between types. For example, this may
    be because the data is provided in a different type to the routines that you use
    to process it. You may have a library that processes floating point numbers as
    `float`, but your data is inputted as `double`. You are aware that the conversion
    will lose precision but know that this will have little effect on the final result
    so you do not want the compiler warning you. What you want to do is tell the compiler
    that the coercion of one type to another is acceptable.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你需要在不同类型之间进行转换。例如，这可能是因为数据以不同的类型提供给你用来处理它的例程。你可能有一个库，它将浮点数作为`float`处理，但你的数据是以`double`输入的。你知道转换会丢失精度，但知道这对最终结果几乎没有影响，所以你不希望编译器警告你。你想告诉编译器，将一种类型强制转换为另一种类型是可以接受的。
- en: 'The following table summarizes the various cast operations you can use in C++11:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了C++11中可以使用的各种转换操作：
- en: '| **Name** | **Syntax** |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **语法** |'
- en: '| Construction | `{}` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 构造 | `{}` |'
- en: '| Remove `const` requirement | `const_cast` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 移除`const`要求 | `const_cast` |'
- en: '| Cast with no runtime checks | `static_cast` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 没有运行时检查的转换 | `static_cast` |'
- en: '| Bitwise casting of types | `reinterpret_cast` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 类型的位转换 | `reinterpret_cast` |'
- en: '| Cast between class pointers, with runtime checks | `dynamic_cast` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 在类指针之间进行转换，带有运行时检查 | `dynamic_cast` |'
- en: '| C style | `()` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| C风格 | `()` |'
- en: '| Function style | `()` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 函数风格 | `()` |'
- en: Casting away const-ness
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放弃const-ness
- en: 'As mentioned in the last chapter, the `const` specifier is used to indicate
    to the compiler that an item will not change, and that any attempt by your code
    to change the item is an error. There is another way to use this specifier, which
    will be explored in the next chapter. When `const` is applied to a pointer, it
    indicates that the memory that the pointer points to cannot be changed:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一章所述，`const`修饰符用于指示编译器一个项目不会改变，并且你的代码尝试改变项目是一个错误。还有另一种使用这个修饰符的方法，将在下一章中探讨。当`const`应用于指针时，它表示指针指向的内存不能被改变：
- en: '[PRE92]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This badly written code tells the compiler to create a string constant with
    the value `0123456` and then put the address of this memory into the string pointer
    `ptr`. The final line attempts to write to the string. This will compile but it
    will cause an access violation at runtime. Applying `const` to the pointer declaration
    will ensure that the compiler will check for such situations:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这段糟糕的代码告诉编译器创建一个值为`0123456`的字符串常量，然后将这个内存的地址放入字符串指针`ptr`。最后一行尝试写入字符串。这将编译，但会在运行时导致访问冲突。将`const`应用于指针声明将确保编译器检查这种情况：
- en: '[PRE93]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'More typical cases are applying `const` to pointers that are function parameters
    and the intention is the same: it indicates to the compiler that the data the
    pointer points to should be read-only. However, there may be situations when you
    want to remove the `const` property of such a pointer, and this is carried out
    using the `const_cast` operator:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 更典型的情况是将`const`应用于函数参数的指针，意图是相同的：它向编译器指示指针指向的数据应该是只读的。然而，可能存在你想要删除这样一个指针的`const`属性的情况，这可以使用`const_cast`操作符来实现：
- en: '[PRE94]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The syntax is simple. The type that you want to convert to is given in the angle
    brackets (`<>`) and the variable (which is a `const` pointer) is provided in the
    parentheses.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 语法很简单。要转换为的类型在尖括号(`<>`)中给出，变量（一个`const`指针）在括号中提供。
- en: You can also cast a pointer *to* a `const` pointer. This means that you can
    have one pointer that you can use to access the memory so that you can write to
    it, and then after you have made changes, you create a `const` pointer to the
    memory, in effect making the memory read-only through the pointer.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将指针*转换为*`const`指针。这意味着您可以有一个指针用于访问内存，以便您可以对其进行写入，然后在进行更改后，您可以创建一个指向内存的`const`指针，从而通过指针使内存只读。
- en: Clearly, once you have cast away the const-ness of a pointer you take responsibility
    for the damage that you do by writing to the memory, so the `const_cast` operator
    in your code is a good marker for you to examine code during a code review.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一旦你取消指针的const属性，你就要对写入内存造成的损害负责，所以你的代码中的`const_cast`操作符是你在代码审查期间检查代码的一个良好标记。
- en: Casting without runtime checks
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不带运行时检查的转换
- en: 'Most casts are performed using the `static_cast` operator, and this can be
    used to convert pointers to related pointer types as well as converting between
    numeric types. There are no runtime checks performed so you should be certain
    that the conversion is acceptable:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数转换都是使用`static_cast`操作符执行的，它可以用于将指针转换为相关的指针类型，以及在不同数值类型之间进行转换。不执行运行时检查，因此您应该确信转换是可接受的：
- en: '[PRE95]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here a `double` is converted to an `int`, which means that the fractional part
    is discarded. Normally the compiler would issue a warning that data is lost, but
    the `static_cast` operator shows that this is your intention and hence the warning
    is not given.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`double` 被转换为 `int`，这意味着小数部分被丢弃。通常编译器会发出警告，表示数据丢失，但`static_cast`操作符表明这是你的意图，因此不会发出警告。
- en: The operator is often used to convert `void*` pointers to a typed pointer. In
    the following code the `unsafe_d` function assumes that the parameter is a pointer
    to a double value in memory, and so it can convert the `void*` pointer to a `double*`
    pointer. The `*` operator used with the `pd` pointer *dereferences* the pointer
    to give the data that it points to. Thus, the `*pd` expression will return a `double`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作符通常用于将`void*`指针转换为类型化指针。在下面的代码中，`unsafe_d`函数假设参数是指向内存中double值的指针，因此它可以将`void*`指针转换为`double*`指针。与`pd`指针一起使用的`*`操作符*解引用*指针以提供它指向的数据。因此，`*pd`表达式将返回一个`double`。
- en: '[PRE96]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This is unsafe because you rely on the caller to ensure that the pointer actually
    points to a `double`. It could be called like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不安全的，因为您依赖调用者确保指针实际上指向`double`。可以这样调用它：
- en: '[PRE97]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `&` operator returns the memory address of the operand as a typed pointer.
    In the first case, a `double*` pointer is obtained and passed to the `unsafe_d`
    function. The compiler will automatically convert this pointer to the `void*`
    parameter. The compiler does this automatically with no checks that the pointer
    will be used correctly in the function. This is illustrated by the second call
    to `unsafe_d` where the `int*` pointer is converted to the `void*` parameter and
    then in the `unsafe_d` function it is cast by `static_cast` to a `double*` even
    though the pointer points to an `int`. Consequently, the dereference will return
    unpredictable data and `cout` will print nonsense.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`操作符将操作数的内存地址作为类型化指针返回。在第一种情况下，获得一个`double*`指针并传递给`unsafe_d`函数。编译器将自动将此指针转换为`void*`参数。编译器会自动执行此操作，而不检查指针在函数中是否被正确使用。这可以通过对`unsafe_d`的第二次调用来说明，在这次调用中，`int*`指针被转换为`void*`参数，然后在`unsafe_d`函数中，它被`static_cast`转换为`double*`，即使指针指向`int`。因此，解引用将返回不可预测的数据，`cout`将打印无意义的内容。'
- en: Casting pointers without runtime checks
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不带运行时检查的转换
- en: 'The `reinterpret_cast` operator allows pointers to one type to be converted
    to pointers of another type, and it can convert from a pointer to an integer and
    an integer to a pointer:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`reinterpret_cast`操作符允许将一个类型的指针转换为另一个类型的指针，并且可以从指针转换为整数，从整数转换为指针：'
- en: '[PRE98]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Unlike `static_cast`, this operator always involves a pointer: converting between
    pointers, converting from a pointer to an integral type, or converting from an
    integral type to a pointer. In this example, a pointer to a `double` variable
    is converted to an `int` and the value printed to the console. In effect, this
    prints out the memory address of the variable.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与`static_cast`不同，此操作符始终涉及指针：在指针之间进行转换，从指针转换为整数类型，或者从整数类型转换为指针。在这个例子中，将指向`double`变量的指针转换为`int`，并将值打印到控制台。实际上，这打印出了变量的内存地址。
- en: Casting with runtime checks
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有运行时检查的转换
- en: The `dynamic_cast` operator is used to convert pointers between related classes,
    and for this reason it will be explained in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. This operator involves runtime checks so that the conversion is only
    performed if the operand can be converted to the specified type. If the conversion
    is not possible then the operator returns `nullptr`, giving you an opportunity
    to only use converted pointers that point to an actual object of that type.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic_cast`操作符用于在相关类之间转换指针，因此将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*中进行解释。此操作符涉及运行时检查，因此只有在操作数可以转换为指定类型时才执行转换。如果转换不可能，则操作符返回`nullptr`，使您有机会仅使用指向该类型的实际对象的转换指针。'
- en: Casting with list initializer
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表初始化符进行转换
- en: 'The C++ compiler will allow some implicit conversions; in some cases, they
    may be intentional and in some cases, they may not be. For example, the following
    code is similar to code shown before: a variable is initialized to a `double`
    value and then later in the code it is used to initialize an `int`. The compiler
    will perform the conversion, and will issue a warning:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器将允许一些隐式转换；在某些情况下，它们可能是有意的，在某些情况下可能不是。例如，以下代码类似于之前显示的代码：变量初始化为`double`值，然后稍后在代码中用于初始化`int`。编译器将执行转换，并发出警告：
- en: '[PRE99]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If you ignore warnings then you may not notice this loss of precision, which
    may cause a problem. One way to get around this issue is to use initialization
    using curly braces:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略警告，则可能不会注意到这种精度损失，这可能会导致问题。解决此问题的一种方法是使用花括号进行初始化：
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In this case, if `pi` can be converted to an `int` without loss (for example,
    if `pi` is a `short`) then the code will compile without even a warning. However,
    if `pi` is an incompatible type (in this case, a `double`) the compiler will issue
    an error:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果`pi`可以在不损失的情况下转换为`int`（例如，如果`pi`是`short`），则代码将甚至不会发出警告而编译。但是，如果`pi`是不兼容的类型（在这种情况下是`double`），编译器将发出错误：
- en: '[PRE101]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here''s an interesting example. The `char` type is an integer, but the `<<`
    operator for `char` from the `osteam` class interprets a `char` variable as being
    a character, not a number, as per the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的例子。`char`类型是一个整数，但来自`osteam`类的`char`的`<<`运算符将`char`变量解释为字符，而不是数字，如下所示：
- en: '[PRE102]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This will print `#` on the console, not 35, because 35 is the ASCII code for
    "#". To get the variable to be treated as a number you can use one of the following:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印`#`，而不是35，因为35是“#”的ASCII码。要使变量被视为数字，可以使用以下之一：
- en: '[PRE103]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, the second version (construction) is just as readable, but is
    shorter than the first.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，第二个版本（构造）与第一个版本一样可读，但比第一个版本更短。
- en: Using C casts
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C转换
- en: 'Finally, you can use C style casts, but these are provided only so that you
    can compile legacy code. You should use one of the C++ casts instead. For completeness,
    the C style casts are shown here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用C样式转换，但这些仅提供以便您可以编译旧代码。您应该改用C++转换之一。为了完整起见，这里显示了C样式转换：
- en: '[PRE104]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'There are two versions: the first cast operator has the parentheses around
    the type to cast to, and in the second one the cast looks like a function call.
    In both cases, it would be better to use `static_cast` so that there is compile-time
    checking.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个版本：第一个转换运算符将括号放在要转换的类型周围，而在第二个版本中，转换看起来像函数调用。在这两种情况下，最好使用`static_cast`，以便进行编译时检查。
- en: Using C++ types
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++类型
- en: In this final part of the chapter, we will develop a command-line application
    that allows you to print out the contents of a file in a mixed alphanumeric and
    hex format.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将开发一个命令行应用程序，允许您以混合字母数字和十六进制格式打印文件的内容。
- en: The application must be run with the name of a file, but optionally you can
    specify how many lines to print. The application will print on the console the
    contents of the file, 16 bytes per line. On the left, it gives the hex representation
    and on the right, it gives the printable representation (or a dot if the character
    is not in the printable non-extended ASCII range).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须以文件名运行，但是您可以选择指定要打印多少行。该应用程序将在控制台上打印文件的内容，每行16个字节。左侧显示十六进制表示，右侧显示可打印表示（如果字符不在可打印的非扩展ASCII范围内，则显示一个点）。
- en: '![](img/39e2cc9a-8fb1-46fe-bb11-17960072dfb7.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39e2cc9a-8fb1-46fe-bb11-17960072dfb7.png)'
- en: 'Create a new folder under `C:\Beginning_C++` called `Chapter_03`. Start Visual
    C++ and create a C++ source file, and save it to the folder you just created as
    `hexdump.cpp`. Add a simple `main` function that allows the application to accept
    parameters, and provides support for input and output using C++ streams:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在`C:\Beginning_C++`下创建一个名为`Chapter_03`的新文件夹。启动Visual C++并创建一个C++源文件，并将其保存到刚创建的文件夹中，命名为`hexdump.cpp`。添加一个简单的`main`函数，允许应用程序接受参数，并使用C++流提供输入和输出支持：
- en: '[PRE105]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The application will have up to two parameters: the first is the name of the
    file and the second is the number of 16-byte blocks to print on the command-line.
    This means that you''ll need to check that the parameters are valid. Start by
    adding a `usage` function to give the application parameters and, if called with
    a non-null parameter, print out an error message:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序最多有两个参数：第一个是文件名，第二个是要在命令行上打印的16字节块的数量。这意味着您需要检查参数是否有效。首先添加一个`usage`函数，以提供应用程序参数，并且如果使用非空参数调用，则打印出错误消息：
- en: '[PRE106]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Add this function before the `main` function so that you can call it from there.
    The function can be called with a pointer to a C string or with `nullptr`. The
    parameter is `const`, indicating to the compiler that the string will not be changed
    in the function, so if there is any attempt to change the string, the compiler
    will generate an error.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数之前添加此函数，以便您可以从那里调用它。该函数可以使用指向C字符串的指针或`nullptr`来调用。参数是`const`，指示编译器在函数中不会更改字符串，因此如果有任何尝试更改字符串，编译器将生成错误。
- en: 'Add the following lines to the `main` function:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`main`函数中：
- en: '[PRE107]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Compile the file and confirm that there are no typos. Since this application
    uses the C++ Standard Library, you have to provide support for C++ exceptions
    with the `/EHsc` switch:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 编译文件并确认没有拼写错误。由于此应用程序使用C++标准库，因此必须使用`/EHsc`开关提供对C++异常的支持：
- en: '[PRE108]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You can test the application invoking it from the command-line with zero, one,
    two, and then three parameters. Confirm that the application will only allow it
    to be called with one or two parameters on the command-line (which actually means
    two or three parameters since `argc` and `argv` include the application name).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从命令行调用该应用程序并使用零、一个、两个，然后三个参数来测试它。确认该应用程序只允许在命令行上使用一个或两个参数进行调用（实际上意味着使用两个或三个参数，因为`argc`和`argv`包括应用程序名称）。
- en: 'The next task is to determine if the user provided a number to indicate how
    many 16-byte blocks to dump to the console and, if so, convert the string provided
    by the command line into an integer. This code will perform the conversion from
    a string to a number using the `istringstream` class, so you need to include the
    header file where this class is defined. Add the following to the top of the file:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是确定用户是否提供了一个数字来指示要将多少个16字节块转储到控制台，如果是的话，将命令行提供的字符串转换为整数。这段代码将使用`istringstream`类将字符串转换为数字，所以你需要包含定义这个类的头文件。在文件的顶部添加以下内容：
- en: '[PRE109]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'After the declaration of the `filename` variable add the following highlighted
    code:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在`filename`变量声明之后添加以下突出显示的代码：
- en: '[PRE110]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: By default, the application will dump one line of data (up to 16 bytes) from
    the file. If the user provided a different number of lines, the string-formatted
    number is converted to an integer by using an `istringstream` object. This is
    initialized with the argument and then the number is extracted from the stream
    object. If the user typed a value of zero, or if they typed a value that cannot
    be interpreted as a string, the code prints an error message. The error string
    is split over two lines, but it is still one string.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，应用程序将从文件中转储一行数据（最多16字节）。如果用户提供了不同数量的行，字符串格式的数字将通过`istringstream`对象转换为整数。这个对象被初始化为参数，然后从流对象中提取数字。如果用户输入了零值，或者输入的值无法解释为字符串，代码将打印错误消息。错误字符串被分成两行，但仍然是一个字符串。
- en: Notice that, the `if` statement uses short-circuiting; that is, if the first
    part of the expression (`ss.fail()`, meaning the conversion failed), is `true`,
    then the second expression (`0 >= blocks`, that is `blocks` must be greater than
    zero) will not be evaluated.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`if`语句使用了短路运算；也就是说，如果表达式的第一部分（`ss.fail()`，表示转换失败）为`true`，那么第二个表达式（`0 >= blocks`，也就是`blocks`必须大于零）将不会被评估。
- en: 'Compile this code and try it several times. For example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这段代码并尝试几次。例如：
- en: '[PRE111]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The first two should run without an error; the second two should generate an
    error.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个应该可以正常运行；后两个应该会生成错误。
- en: Don't worry that `readme.txt` does not exist, as it is only here as a test parameter.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心`readme.txt`不存在，因为它只是作为一个测试参数存在。
- en: 'Next, you''ll add the code to open a file and process it. Since you''ll use
    the `ifstream` class to input data from a file, add the following header file
    to the top of the file:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将添加打开文件并处理它的代码。由于你将使用`ifstream`类从文件中输入数据，所以在文件的顶部添加以下头文件：
- en: '[PRE112]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Then at the bottom of the `main` function add the code to open the file:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`main`函数的底部添加打开文件的代码：
- en: '[PRE113]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The first line creates a stream object called `file` and this is attached to
    the file specified through the path given in `filename`. If the file cannot be
    found, the `good` function will return `false`. This code negates the value using
    the `!` operator so that if the file *does not exist* the statements in the braces
    following the `if` are executed. If the file exists and the `ifstream` object
    can open it, the data is read 16 bytes at a time in a `while` loop. Notice that
    at the end of this code the `close` function is called on the `file` object. It
    is good practice to explicitly close resources when you have finished with them.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个名为`file`的流对象，并将其附加到`filename`中给定路径的文件。如果找不到文件，`good`函数将返回`false`。这段代码使用`!`运算符否定值，所以如果文件*不存在*，则执行`if`后面大括号中的语句。如果文件存在并且`ifstream`对象可以打开它，数据将以16字节的方式一次读取一次在`while`循环中。请注意，在这段代码的末尾，`file`对象上调用了`close`函数。当你完成资源的使用时，显式关闭资源是一个好的做法。
- en: 'The file will be accessed by the `read16` function on a byte-by-byte basis,
    including non-printable bytes, so that control characters like `\r` or `\n` have
    no special meaning and are still read in. However, the stream class treats the
    `\r` character in a special way: this is treated as the end of a line and normally
    the stream will silently consume this character. To prevent this, we open the
    file in binary mode using `ios::binary`.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`read16`函数将按字节访问文件，包括不可打印的字节，因此像`\r`或`\n`这样的控制字符没有特殊含义，并且仍然会被读取。然而，流类以特殊方式处理`\r`字符：这被视为一行的结束，通常流会默默地消耗这个字符。为了防止这种情况，我们使用`ios::binary`以二进制模式打开文件。'
- en: 'Review the `while` statement again:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 再次审查`while`语句：
- en: '[PRE114]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: There are two expressions here. The first expression decrements the `blocks`
    variable, which holds the number of 16-byte blocks that will be printed. The postfix
    decrement means that the value of the expression is the value of the variable
    *before* the decrement, so if the expression is called when `blocks` is zero the
    whole expression is short-circuited and the `while` looping ends. If the first
    expression is non-zero, then the `read16` function is called and if this returns
    a value of -1 (the end of the file is reached), the looping finishes. The actual
    work of the loop occurs within the `read16` function, so the `while` loop statement
    is the empty statement.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个表达式。第一个表达式递减`blocks`变量，该变量保存将要打印的16字节块的数量。后缀递减意味着表达式的值是递减之前的变量值，所以如果在`blocks`为零时调用表达式，整个表达式会被短路，`while`循环结束。如果第一个表达式非零，则调用`read16`函数，如果返回值为-1（到达文件结尾），则循环结束。循环的实际工作发生在`read16`函数内部，所以`while`循环语句是空语句。
- en: 'Now you must implement the `read16` function just above the `main` function.
    This function will use a constant that defines the length of each block, so add
    the following declaration near the top of the file:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须在`main`函数的上面实现`read16`函数。这个函数将使用一个常量来定义每个块的长度，所以在文件的顶部附近添加以下声明：
- en: '[PRE115]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Just before the `main` function, add this code:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数之前，添加以下代码：
- en: '[PRE116]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This is just skeleton code for the function. You'll add more code in a moment.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是函数的框架代码。你将在一会儿添加更多的代码。
- en: This function will read up to 16 bytes at a time and print the contents of those
    bytes to the console. The return value is the number of bytes that were read or
    -1 if the end of the file was reached. Notice the syntax used to pass the stream
    object to the function. This is a **reference**, a type of pointer to the actual
    object. The reason why a reference is used is because if we do not do this the
    function will get a *copy* of the stream. References will be covered in the next
    chapter and using object references as function parameters will be covered in
    [Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数每次最多读取16个字节，并将这些字节的内容打印到控制台。返回值是读取的字节数，如果到达文件末尾则返回-1。注意用于将流对象传递给函数的语法。这是一个**引用**，一种指向实际对象的指针类型。之所以使用引用是因为如果不这样做，函数将得到流的*副本*。引用将在下一章中介绍，使用对象引用作为函数参数将在[第5章](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml)中介绍，*使用函数*。
- en: The first line of this function test is to verify whether the end of the file
    has been reached, and if so, no more processing can be done and the value of -1
    is returned. The code will manipulate the `cout` object (for example, inserting
    the `hex` manipulator); and so that you always know the state of this object outside
    of the function, the function ensures that when it returns the `cout` object is
    in the same state as when the function was called. The initial formatting state
    of the `cout` object is obtained by calling the `flags` function, and this is
    used to reset the `cout` object just before the function returns by calling the
    `setf` function.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数测试的第一行是验证是否已经到达文件末尾，如果是，就不能再进行处理，返回-1的值。代码将操作`cout`对象（例如插入`hex`操纵器）；所以你总是知道函数外部的`cout`对象的状态，函数确保在返回时`cout`对象的状态与调用函数时相同。通过调用`flags`函数获取`cout`对象的初始格式状态，并在函数返回之前通过调用`setf`函数重置`cout`对象。
- en: This function does nothing, so it is safe to compile the file and confirm that
    you have no typos.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数什么也不做，所以可以安全地编译文件并确认没有拼写错误。
- en: 'The `read16` function does three things:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`read16`函数有三个作用：'
- en: It reads in, byte-by-byte, up to 16 bytes.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它按字节读取，最多16个字节。
- en: It prints out the hex value of each byte.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印出每个字节的十六进制值。
- en: It prints out the printable value of the byte.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印出字节的可打印值。
- en: 'This means that each line has two parts: the hex part on the left, and the
    printable part on the right. Replace the comment in the function with the highlighted
    code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每行有两部分：左边是十六进制部分，右边是可打印部分。用突出显示的代码替换函数中的注释：
- en: '[PRE117]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `for` loop will loop for a maximum of `block_length` times. The first statement
    reads a single character from the stream. This byte is read in as raw data. If
    `get` finds that there are no more characters in the stream, it will set a flag
    in the stream object, and this is tested by calling the `eof` function. If the
    `eof` function returns `true` it means that the end of the file has been reached
    and so the `for` loop finishes, but the function does not return immediately.
    The reason is that *some* bytes may have been read so more processing must be
    carried out.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将最多循环`block_length`次。第一条语句从流中读取一个字符。这个字节被作为原始数据读取。如果`get`发现流中没有更多的字符，它将在流对象中设置一个标志，并通过调用`eof`函数进行测试。如果`eof`函数返回`true`，意味着已经到达文件末尾，所以`for`循环结束，但函数不会立即返回。原因是*可能*已经读取了一些字节，所以必须进行更多的处理。'
- en: 'The remainder of the statements in the loop do two things:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的其余语句有两个作用：
- en: There are statements to print the hex value of the character on the console
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有语句在控制台打印字符的十六进制值
- en: There's a statement to store the character in a printable form in the `line`
    variable
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一条语句将字符以可打印形式存储在`line`变量中。
- en: 'We have already set the `cout` object to output hex values, but if the byte
    is less that 0x10 the value will not be printed prefixed with a zero. To get this
    format, we insert the `setw` manipulator to say that the data inserted will take
    up two character positions and `setfill` to say that a `0` character is used to
    pad the string. These two manipulators are available in the `<iomanip>` header,
    so add them to the top of the file:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`cout`对象设置为输出十六进制值，但如果字节小于0x10，则值不会以零为前缀打印。为了获得这种格式，我们插入`setw`操纵器，表示插入的数据将占用两个字符位置，并且`setfill`表示使用`0`字符填充字符串。这两个操纵器在`<iomanip>`头文件中可用，所以将它们添加到文件的顶部：
- en: '[PRE118]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Normally, when you insert a `char` into a stream the character value is shown,
    so the `char` variable is cast to a `short` so that the stream will print the
    hex numeric value. Finally, a single space is printed between each item.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你将一个`char`插入流中时，字符值会显示出来，所以`char`变量被转换为`short`，以便流打印十六进制数值。最后，每个项目之间打印一个空格。
- en: 'The final lines in the `for` loop are shown here:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环中的最后几行在这里显示：'
- en: '[PRE119]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This code checks to see if the byte is a printable character (" " to "~") using
    the `isprint` macro and if the character is printable it is appended to the end
    of the `line` variable. If the byte is not printable, a dot is appended to the
    end of the `line` variable as a placeholder.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查字节是否是可打印字符（" "到"~"）使用`isprint`宏，如果字符是可打印的，它就被追加到`line`变量的末尾。如果字节不可打印，则在`line`变量的末尾追加一个点作为占位符。
- en: 'The code so far will print the hex representation of the bytes to the console
    one after the other and the only formatting is the space between bytes. If you
    want to test the code, you can compile this and run it on the source file:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的代码将按顺序将字节的十六进制表示打印到控制台，唯一的格式是字节之间的空格。如果要测试代码，可以编译并在源文件上运行它：
- en: '[PRE120]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'You will see something unintelligible, such as the following:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些难以理解的东西，比如下面的内容：
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `23` values are #, `20` are spaces, and `0d` and `0a` are returns and newlines.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`23`的值是#，`20`是空格，`0d`和`0a`是回车和换行。'
- en: 'We now need to print the character representations in the `line` variable and
    carry out some formatting, and add line breaks. After the `for` loop, add the
    following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要打印`line`变量中的字符表示，并进行一些格式化，并添加换行符。在`for`循环之后，添加以下内容：
- en: '[PRE122]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: There will be at least *two* spaces between the hex display and the character
    display. One space will come from the last character printed out in the `for`
    loop, and the second space is provided in the initialization of the `padding`
    variable.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制显示和字符显示之间至少会有*两个*空格。一个空格来自`for`循环中打印的最后一个字符，第二个空格在`padding`变量的初始化中提供。
- en: 'The maximum number of bytes on each line should be 16 bytes (`block_length`)
    and thus 16 hex values printed on the console. If a fewer number of bytes are
    read then extra padding is required so that over successive lines the character
    representations align. The actual number of bytes read, will be the length of
    the `line` variable obtained by calling the `length` function, so the number of
    missing bytes is the expression `block_length - line.length()`. Since every hex
    representation takes up three characters (two for the digits and one space), the
    padding needed is three times the number of missing bytes. To create the appropriate
    number of spaces, the string constructor is called with two parameters: the number
    of copies and the character to copy.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的最大字节数应为16字节（`block_length`），因此控制台上打印16个十六进制值。如果读取的字节数少于16个，则需要额外的填充，以便在连续的行上字符表示对齐。实际读取的字节数将是通过调用`length`函数获得的`line`变量的长度，因此缺少的字节数是表达式`block_length
    - line.length()`。由于每个十六进制表示占用三个字符（两个用于数字，一个用于空格），所需的填充是缺少字节数的三倍。为了创建适当数量的空格，将使用字符串构造函数调用两个参数：复制的数量和要复制的字符。
- en: Finally, this padding string is printed to the console followed by the character
    representation of the bytes.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个填充字符串被打印到控制台，后面是字节的字符表示。
- en: 'At this point you should be able to compile the code with no errors or warnings.
    When you run the code on the source file, you should see something like this:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够编译代码而不会出现错误或警告。当您在源文件上运行代码时，您应该会看到类似以下的内容：
- en: '[PRE123]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now the bytes make more sense. Since the application does not change the files
    it dumps, it is safe to use this tool on binary files, including itself:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些字节更有意义了。由于应用程序不会更改转储的文件，因此可以放心地在二进制文件上使用此工具，包括本身：
- en: '[PRE124]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The MZ indicates that this is the DOS header part of Microsoft's **Portable
    Executable** (**PE**) file format. The actual PE header starts on the bottom line
    with the characters, PE.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: MZ表示这是Microsoft的**可移植可执行文件**（**PE**）文件格式的DOS头部部分。实际的PE头部从底部一行的字符PE开始。
- en: Summary
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about the various built-in types in C++, how
    to initialize them, and how to use them. You also learned how to convert variables
    to different types using casting operators. The chapter also introduced you to
    record types, a topic that will be expanded on in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*. Finally, you have seen various examples of pointers, a topic that will
    be examined in greater detail in the next chapter.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了C++中各种内置类型的初始化和使用方法。您还学会了如何使用转换运算符将变量转换为不同的类型。本章还向您介绍了记录类型，这是一个将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)
    *类*中进一步扩展的主题。最后，您已经看到了各种指针的示例，这是下一章将更详细地探讨的主题。
