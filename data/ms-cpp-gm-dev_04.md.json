["```cpp\n#pragma once \n#include <SDL/SDL_mixer.h> \n#include <string> \n#include <map> \n\nnamespace BookEngine \n{\n```", "```cpp\nclass SoundEffect \n { \n  public: \n    friend class AudioManager; \n    ///Plays the sound file \n    ///@param numOfLoops: If == -1, loop forever, \n    ///otherwise loop of number times provided + 1 \n    void Play(int numOfLoops = 0); \n\n  private: \n    Mix_Chunk* m_chunk = nullptr; \n  }; \n```", "```cpp\ntypedef struct { \n        int allocated; \n        Uint8 *abuf; \n        Uint32 alen; \n        Uint8 volume; \n} Mix_Chunk; \n```", "```cpp\nclass Music \n  { \n  public: \n    friend class AudioManager; \n    ///Plays the music file \n    ///@param numOfLoops: If == -1, loop forever, \n    ///otherwise loop of number times provided \n    void Play(int numOfLoops = -1); \n\n    static void Pause() { Mix_PauseMusic(); }; \n    static void Stop() { Mix_HaltMusic(); }; \n    static void Resume() { Mix_ResumeMusic(); }; \n\n  private: \n    Mix_Music* m_music = nullptr; \n  }; \n```", "```cpp\nclass AudioManager \n  { \n  public: \n    AudioManager(); \n    ~AudioManager(); \n\n    void Init(); \n    void Destroy(); \n\n    SoundEffect LoadSoundEffect(const std::string& filePath); \n    Music LoadMusicEffect(const std::string& filePath); \n  private: \n    std::map<std::string, Mix_Chunk*> m_effectList; \n    std::map<std::string, Mix_Music*> m_musicList; \n    bool m_isInitialized = false; \n  }; \n} \n```", "```cpp\n#include \"AudioManager.h\"\n#include \"Exception.h\" \n#include \"Logger.h\"\n\nnamespace BookEngine \n{ \n\n  AudioManager::AudioManager() \n  { \n  } \n\n  AudioManager::~AudioManager() \n  { \n    Destroy(); \n  } \n```", "```cpp\nvoid BookEngine::AudioManager::Init() \n  { \n    //Check if we have already been initialized \n    if (m_isInitialized) \n      throw Exception(\"Audio manager is already initialized\"); \n```", "```cpp\n//Can be Bitwise combination of  \n//MIX_INIT_FAC, MIX_INIT_MOD, MIX_INIT_MP3, MIX_INIT_OGG \nif(Mix_Init(MIX_INIT_OGG || MIX_INIT_MP3) == -1) \n throw Exception(\"SDL_Mixer could not initialize! Error: \" + \n std::string(Mix_GetError()));\n```", "```cpp\nif(Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, \n 1024) == -1)      throw Exception(\"Mix_OpenAudio Error: \" + \n std::string(Mix_GetError()));\n```", "```cpp\nint Mix_OpenAudio(int frequency, Uint16 format, int channels, int chunksize)\n```", "```cpp\nm_isInitialized = true; \n  } \n```", "```cpp\n  void BookEngine::AudioManager::Destroy() \n  { \n    if (m_isInitialized) \n    { \n      m_isInitialized = false; \n\n      //Release the audio resources \n      for(auto& iter : m_effectList) \n        Mix_FreeChunk(iter.second); \n      for(auto& iter : m_musicList) \n        Mix_FreeMusic(iter.second); \n      Mix_CloseAudio(); \n      Mix_Quit(); \n    } \n  } \n```", "```cpp\n SoundEffect BookEngine::AudioManager::LoadSoundEffect(const std::string & filePath)\n  { \n    SoundEffect effect; \n```", "```cpp\n//Lookup audio file in the cached list \nauto iter = m_effectList.find(filePath); \n```", "```cpp\n//Failed to find in cache, load \n    if (iter == m_effectList.end()) \n    { \n      Mix_Chunk* chunk = Mix_LoadWAV(filePath.c_str()); \n      //Error Loading file \n      if(chunk == nullptr) \n        throw Exception(\"Mix_LoadWAV Error: \" + \n              std::string(Mix_GetError())); \n\n      effect.m_chunk = chunk; \n      m_effectList[filePath] = chunk; \n    } \n\n```", "```cpp\nelse //Found in cache \n    { \n      effect.m_chunk = iter->second; \n    } \n\n    return effect; \n  } \n```", "```cpp\nMusic BookEngine::AudioManager::LoadMusic(const std::string & filePath) \n  { \n    Music music; \n\n    //Lookup audio file in the cached list \n    auto iter = m_musicList.find(filePath); \n\n    //Failed to find in cache, load \n    if (iter == m_musicList.end()) \n    { \n      Mix_Music* chunk = Mix_LoadMUS(filePath.c_str()); \n      //Error Loading file \n      if (chunk == nullptr) \n           throw Exception(\"Mix_LoadMUS Error: \" +\n            std::string(Mix_GetError())); \n\n      music.m_music = chunk; \n      m_musicList[filePath] = chunk; \n    } \n    else //Found in cache \n    { \n      music.m_music = iter->second; \n    } \n\n    return music; \n  } \n```", "```cpp\n void SoundEffect::Play(int numOfLoops) \n  { \n    if(Mix_PlayChannel(-1, m_chunk, numOfLoops) == -1) \n      if (Mix_PlayChannel(0, m_chunk, numOfLoops) == -1) \n          throw Exception(\"Mix_PlayChannel Error: \" + \n                std::string(Mix_GetError())); \n  } \n\n  void Music::Play(int numOfLoops) \n  { \n    if (Mix_PlayMusic(m_music, numOfLoops) == -1) \n      throw Exception(\"Mix_PlayMusic Error: \" + \n                 std::string(Mix_GetError())); \n  }   \n} \n```", "```cpp\nprivate: \n  void CheckInput(); \n  BookEngine::AudioManager m_AudioManager; \n  BookEngine::Music m_bgMusic; \n}; \n```", "```cpp\nvoid GameplayScreen::OnEntry() \n{ \n  m_AudioManager.Init(); \n  m_bgMusic = m_audioManager.LoadMusic(\"Audio/bensound-epic.mp3\"); \n  m_bgMusic.Play(); \n} \n```", "```cpp\nm_bgMusic.Stop(); \n```", "```cpp\n  m_AudioManager.Destroy(); \n```", "```cpp\n#pragma once \n#include \"TextureCache.h\"\n#include <string> \nnamespace BookEngine \n{ \nclass ResourceManager \n  { \n  public: \n    static GLTexture GetTexture(std::string pathToTextureFile); \n  private: \n    static TextureCache m_textureCache; \n  }; \n} \n```", "```cpp\n#include \"ResourceManager.h\"\nnamespace BookEngine \n{ \n  TextureCache ResourceManager::m_textureCache; \n\n  GLTexture ResourceManager::GetTexture(std::string texturePath) \n  { \n    return m_textureCache.GetTexture(texturePath); \n  } \n} \n```", "```cpp\n#pragma once \n#include <GL/glew.h> \nnamespace BookEngine \n{ \n  struct GLTexture \n  { \n    GLuint id; \n    int width; \n    int height; \n  }; \n} \n```", "```cpp\n#pragma once \n#include <map> \n#include \"GLTexture.h\"\n\nnamespace BookEngine \n{ \n  class TextureCache \n  { \n  public: \n    TextureCache(); \n    ~TextureCache(); \n\n    GLTexture GetTexture(std::string texturePath);  \n  private: \n    std::map<std::string, GLTexture> m_textureMap; \n\n  }; \n} \n```", "```cpp\nGLTexture TextureCache::GetTexture(std::string texturePath) { \n\n    //lookup the texture and see if it''''s in the map \n    auto mit = m_textureMap.find(texturePath); \n\n    //check if its not in the map \n    if (mit == m_textureMap.end()) \n    { \n      //Load the texture \n      GLTexture newTexture = ImageLoader::LoadPNG(texturePath); \n\n      //Insert it into the map \n      m_textureMap.insert(std::make_pair(texturePath, newTexture)); \n\n      //std::cout << \"Loaded Texture!\\n\"; \n      return newTexture; \n    } \n    //std::cout << \"Used Cached Texture!\\n\"; \n    return mit->second; \n  }\n```", "```cpp\n#pragma once \n#include \"GLTexture.h\" \n#include <string> \nnamespace BookEngine \n{ \n  class ImageLoader \n  { \n  public: \n    static GLTexture LoadPNG(std::string filePath);\n    static GLTexture LoadDDS(const char * imagepath);\n  }; \n} \n```", "```cpp\n... \n  GLTexture ImageLoader::LoadPNG(std::string filePath) { \nunsigned long width, height;     \nGLTexture texture = {}; \nstd::vector<unsigned char> in; \n  std::vector<unsigned char> out; \n```", "```cpp\n  ... \n  //Read in the image file contents into a buffer \n    if (IOManager::ReadFileToBuffer(filePath, in) == false) {\n      throw Exception(\"Failed to load PNG file to buffer!\");\n    }\n\n    //Decode the .png format into an array of pixels\n    int errorCode = DecodePNG(out, width, height, &(in[0]), in.size());\n    if (errorCode != 0) {\n      throw Exception(\"decodePNG failed with error: \" + std::to_string(errorCode));\n    }\n  ... \n```", "```cpp\nvoid Sprite::Init(float x, float y, float width, float height, std::string texturePath) { \n        //Set up our private vars \n        m_x = x; \n        m_y = y; \n        m_width = width; \n        m_height = height; \n\n        m_texture = ResourceManager::GetTexture(texturePath); \n```", "```cpp\nnamespace BookEngine \n{ \n  class Mesh \n  { \n  public: \n    Mesh(); \n    ~Mesh(); \n    void Init(); \n    void Draw(); \n  private: \n    GLuint m_vao; \n    GLuint m_vertexbuffer; \n    GLuint m_uvbuffer; \n    GLTexture m_texture;   \n\n    std::vector<glm::vec3> m_vertices; \n    std::vector<glm::vec2> m_uvs; \n    std::vector<glm::vec3> m_normals; \n    // Won''''t be used at the moment. \n  }; \n} \n```", "```cpp\nnamespace BookEngine \n{ \n  Mesh::Mesh() \n  { \n    m_vertexbuffer = 0; \n    m_uvbuffer = 0; \n    m_vao == 0; \n  }\n```", "```cpp\nOBJModel::~OBJModel() \n  { \n    if (m_vertexbuffer != 0) \n      glDeleteBuffers(1, &m_vertexbuffer); \n    if (m_uvbuffer != 0)  \n      glDeleteBuffers(1, &m_uvbuffer); \nif (m_vao != 0) \n      glDeleteVertexArrays(1, &m_vao); \n  } \n```", "```cpp\nvoid OBJModel::Init() \n  {   \n    bool res = LoadOBJ(\"Meshes/Dwarf_2_Low.obj\", m_vertices, m_uvs, m_normals); \n    m_texture = ResourceManager::GetTexture(\"Textures/dwarf_2_1K_color.png\"); \n```", "```cpp\nbool LoadOBJ( \n    const char * path, \n    std::vector<glm::vec3> & out_vertices, \n    std::vector<glm::vec2> & out_uvs, \n    std::vector<glm::vec3> & out_normals \n  ); \n```", "```cpp\n# Simple 3D Cube Model \nmtllib cube.mtl \nv 1.000000 -1.000000 -1.000000 \nv 1.000000 -1.000000 1.000000 \nv -1.000000 -1.000000 1.000000 \nv -1.000000 -1.000000 -1.000000 \nv 1.000000 1.000000 -1.000000 \nv 0.999999 1.000000 1.000001 \nv -1.000000 1.000000 1.000000 \nv -1.000000 1.000000 -1.000000 \nvt 0.748573 0.750412 \nvt 0.749279 0.501284 \nvt 0.999110 0.501077 \nvt 0.999455 0.750380 \nvt 0.250471 0.500702 \nvt 0.249682 0.749677 \nvt 0.001085 0.750380 \nvt 0.001517 0.499994 \nvt 0.499422 0.500239 \nvt 0.500149 0.750166 \nvt 0.748355 0.998230 \nvt 0.500193 0.998728 \nvt 0.498993 0.250415 \nvt 0.748953 0.250920 \nvn 0.000000 0.000000 -1.000000 \nvn -1.000000 -0.000000 -0.000000 \nvn -0.000000 -0.000000 1.000000 \nvn -0.000001 0.000000 1.000000 \nvn 1.000000 -0.000000 0.000000 \nvn 1.000000 0.000000 0.000001 \nvn 0.000000 1.000000 -0.000000 \nvn -0.000000 -1.000000 0.000000 \nusemtl Material_ray.png \ns off \nf 5/1/1 1/2/1 4/3/1 \nf 5/1/1 4/3/1 8/4/1 \nf 3/5/2 7/6/2 8/7/2 \nf 3/5/2 8/7/2 4/8/2 \nf 2/9/3 6/10/3 3/5/3 \nf 6/10/4 7/6/4 3/5/4 \nf 1/2/5 5/1/5 2/9/5 \nf 5/1/6 6/10/6 2/9/6 \nf 5/1/7 8/11/7 6/10/7 \nf 8/11/7 7/12/7 6/10/7 \nf 1/2/8 2/9/8 3/13/8 \nf 1/2/8 3/13/8 4/14/8 \n```", "```cpp\n... \nbool LoadOBJ( \n    std::string path, \n    std::vector<glm::vec3> & out_vertices, \n    std::vector<glm::vec2> & out_uvs, \n    std::vector<glm::vec3> & out_normals \n    )  \n{ \n    WriteLog(LogType::RUN, \"Loading OBJ file \" + path + \" ...\"); \n    std::vector<unsigned int> vertexIndices, uvIndices, normalIndices; \n    std::vector<glm::vec3> temp_vertices; \n    std::vector<glm::vec2> temp_uvs; \n    std::vector<glm::vec3> temp_normals; \n```", "```cpp\n    try  \n{ \nstd::ifstream in(path, std::ios::in); \n```", "```cpp\nif (!in) {\nthrow Exception(\"Error opening OBJ file: \" + path); }\n```", "```cpp\nstd::string line; \nwhile (std::getline(in, line)) \n  { \n```", "```cpp\n  if (line.substr(0, 2) == \"v \") { \n    std::istringstream v(line.substr(2)); \n    glm::vec3 vert; \n    double x, y, z; \n    v >> x; v >> y; v >> z; \n    vert = glm::vec3(x, y, z); \n    temp_vertices.push_back(vert); \n  } \n```", "```cpp\nelse if (line.substr(0, 2) == \"vt\")  \n{ \nstd::istringstream v(line.substr(3)); \n          glm::vec2 uv; \n          double U, V; \n          v >> U;v >> V; \n          uv = glm::vec2(U, V); \n          uv.y = -uv.y; \n          temp_uvs.push_back(uv); \n        } \n```", "```cpp\n        else if (line.substr(0, 2) == \"vn\") \n { \n\n          std::istringstream v(line.substr(3)); \n          glm::vec3 normal; \n          double x, y, z; \n          v >> x;v >> y;v >> z; \n          normal = glm::vec3(x, y, z); \n          temp_normals.push_back(normal); \n        } \n```", "```cpp\n\n        else if (line.substr(0, 2) == \"f \") \n        { \n          unsigned int vertexIndex[3], uvIndex[3], normalIndex[3]; \n          const char* cstring = line.c_str(); \n          int matches = sscanf_s(cstring, \"f %d/%d/%d %d/%d/%d %d/%d/%d\\n\", &vertexIndex[0], &uvIndex[0], &normalIndex[0], &vertexIndex[1], &uvIndex[1], &normalIndex[1], &vertexIndex[2], &uvIndex[2], &normalIndex[2]); \n```", "```cpp\nif (matches != 9) \n    throw Exception(\"Unable to parse format\"); \n```", "```cpp\n          vertexIndices.push_back(vertexIndex[0]); \n          vertexIndices.push_back(vertexIndex[1]); \n          vertexIndices.push_back(vertexIndex[2]); \n          uvIndices.push_back(uvIndex[0]); \n          uvIndices.push_back(uvIndex[1]); \n          uvIndices.push_back(uvIndex[2]); \n          normalIndices.push_back(normalIndex[0]); \n          normalIndices.push_back(normalIndex[1]); \n          normalIndices.push_back(normalIndex[2]); \n        } \n      }\n```", "```cpp\n      for (unsigned int i = 0; i < vertexIndices.size(); i++)  \n{ \n        // Get the indices of its attributes \n        unsigned int vertexIndex = vertexIndices[i]; \n        unsigned int uvIndex = uvIndices[i]; \n        unsigned int normalIndex = normalIndices[i]; \n```", "```cpp\n        glm::vec3 vertex = temp_vertices[vertexIndex - 1]; \n        glm::vec2 uv = temp_uvs[uvIndex - 1]; \n        glm::vec3 normal = temp_normals[normalIndex - 1]; \n```", "```cpp\n        out_vertices.push_back(vertex); \n        out_uvs.push_back(uv); \n        out_normals.push_back(normal); \n      } \n    } \n```", "```cpp\n    catch (Exception e) \n    { \n      WriteLog(LogType::ERROR, e.reason); \n      return false; \n    } \n    return true; \n  } \n  ...\n```", "```cpp\n    if (m_vao == 0)  \n      glGenVertexArrays(1, &m_vao); \n    glBindVertexArray(m_vao); \n```", "```cpp\n    if (m_vertexbuffer == 0) \nglGenBuffers(1, &m_vertexbuffer); \n    if (m_uvbuffer == 0)  \n      glGenBuffers(1, &m_uvbuffer); \n```", "```cpp\n    glBindBuffer(GL_ARRAY_BUFFER, m_vertexbuffer); \n    glBufferData(GL_ARRAY_BUFFER, m_vertices.size() * sizeof(glm::vec3), &m_vertices[0], GL_STATIC_DRAW); \n    glBindBuffer(GL_ARRAY_BUFFER, m_uvbuffer); \n    glBufferData(GL_ARRAY_BUFFER, m_uvs.size() * sizeof(glm::vec2), &m_uvs[0], GL_STATIC_DRAW); \n  }\n```", "```cpp\n  void Mesh::Draw() \n  {   \n    glActiveTexture(GL_TEXTURE0); \n    glBindTexture(GL_TEXTURE_2D, m_texture.id); \n```", "```cpp\n    glBindBuffer(GL_ARRAY_BUFFER, m_vertexbuffer); \n    glVertexAttribPointer( 0,  3,  GL_FLOAT,  GL_FALSE,  0, (void*)0); \n    glBindBuffer(GL_ARRAY_BUFFER, m_uvbuffer); \n    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (void*)0); \n```", "```cpp\n    glDrawArrays(GL_TRIANGLES, 0, m_vertices.size()); \n```", "```cpp\n    glDisableVertexAttribArray(0); \n    glDisableVertexAttribArray(1); \n    glBindBuffer(GL_ARRAY_BUFFER, 0); \n  } \n}\n```", "```cpp\n ... \n//Init Model \n  m_model.Init(\"Meshes/Dwarf_2_Low.obj\", \"Textures/dwarf_2_1K_color.png\"); \n  ... \n```", "```cpp\n  ... \n//Draw Model \n  m_model.Draw(); \n... \n```"]