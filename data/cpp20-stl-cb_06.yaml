- en: '*Chapter 6*: STL Algorithms'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：STL 算法'
- en: Much of the power of the STL is in the standardization of container interfaces.
    If a container has a particular capability, there's a good chance that the interface
    for that capability is standardized across container types. This standardization
    makes possible a library of *algorithms* that operate seamlessly across containers
    and sequences sharing a common interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: STL 的许多功能都体现在容器接口的标准化上。如果一个容器具有特定的功能，那么该功能的接口很可能在所有容器类型中都是标准化的。这种标准化使得一个库成为可能，该库中的
    *算法* 可以无缝地在具有公共接口的容器和序列上运行。
- en: 'For example, if we want to sum all the elements in a `vector` of `int`, we
    could use a loop:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想计算 `vector` 中所有 `int` 元素的总和，我们可以使用循环：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or we could use an algorithm:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用一个算法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This same syntax works with other containers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法同样适用于其他容器：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The algorithm version is not necessarily shorter, but it is easier to read and
    easier to maintain. And an algorithm is often more efficient than the equivalent
    loop.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 算法版本不一定更短，但它更容易阅读和维护。而且算法通常比等效循环更高效。
- en: Beginning with C++20, the `ranges` library provides a set of alternative algorithms
    that operate with *ranges* and *views*. This book will demonstrate those alternatives
    where appropriate. For more information on ranges and views, refer to the recipe
    *Create views into containers with ranges* in [*Chaper 1*](B18267_01_ePub.xhtml#_idTextAnchor027),
    *New C++20 Features*, of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++20 开始，`ranges` 库提供了一套操作于 *ranges* 和 *views* 的替代算法。本书将适当地演示这些替代方案。有关 ranges
    和 views 的更多信息，请参阅本书第 1 章 *Chaper 1* 中的配方 *使用 ranges 创建容器视图*，*New C++20 Features*。
- en: Most of the algorithms are in the `algorithm` header. Some numeric algorithms,
    notably `accumulate()`, are in the `numeric` header, and some memory-related algorithms
    are in the `memory` header.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数算法都在 `algorithm` 头文件中。一些数值算法，特别是 `accumulate()`，在 `numeric` 头文件中，一些与内存相关的算法在
    `memory` 头文件中。
- en: 'We will cover STL algorithms in the following recipes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下配方中介绍 STL 算法：
- en: Copy from one iterator to another
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个迭代器复制到另一个迭代器
- en: Join container elements into a string
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器元素连接成一个字符串
- en: Sort containers with `std::sort`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::sort` 对容器进行排序
- en: Modify containers with `std::transform`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::transform` 修改容器
- en: Find items in a container
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中查找项目
- en: Limit the values of a container to a range with `std::clamp`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::clamp` 限制容器的值在一个范围内
- en: Sample data sets with `std::sample`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::sample` 的示例数据集
- en: Generate permutations of data sequences
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成数据序列的排列
- en: Merge sorted containers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并排序后的容器
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件：[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap06)。
- en: Copy from one iterator to another
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个迭代器复制到另一个迭代器
- en: The *copy algorithms* are generally used to copy from and to containers, but
    in fact, they work with iterators, which is far more flexible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*复制算法* 通常用于在容器之间复制数据，但实际上，它们与迭代器一起工作，这要灵活得多。'
- en: How to do it…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will experiment with `std::copy` and `std::copy_n` to get
    a good understanding of how they work:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将通过实验 `std::copy` 和 `std::copy_n` 来深入了解它们的工作原理：
- en: 'Let''s start with a function to print a container:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们从打印容器的函数开始：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `main()`, we define a `vector` and print it with `printc()`:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 中，我们定义一个 `vector` 并使用 `printc()` 打印它：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We get this output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s create a second `vector` with enough space to copy the first `vector`:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们创建第二个 `vector`，它有足够的空间来复制第一个 `vector`：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can copy `v1` to `v2` using the `std::copy()` algorithm:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `std::copy()` 算法将 `v1` 复制到 `v2`：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `std::copy()` algorithm takes two iterators for the range of the copy source,
    and one iterator for the destination. In this case, we give it the `begin()` and
    `end()` iterators of `v1` to copy the entire `vector`. The `begin()` iterator
    of `v2` serves as the destination for the copy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::copy()` 算法接受两个迭代器作为复制源的范围，以及一个迭代器作为目标。在这种情况下，我们给它 `v1` 的 `begin()` 和
    `end()` 迭代器来复制整个 `vector`。`v2` 的 `begin()` 迭代器作为复制的目标。'
- en: 'Our output is now:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的输出是：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `copy()` algorithm does not allocate space for the destination. So, `v2`
    must already have the space for the copy. Alternately, you can use the `back_inserter()`
    iterator adapter to insert the elements at the back of the `vector`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()` 算法不会为目的地分配空间。因此，`v2` 必须已经为复制分配了空间。或者，您可以使用 `back_inserter()` 迭代器适配器在
    `vector` 的末尾插入元素：'
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use the `ranges::copy()` algorithm to copy an entire *range*. A
    container object serves as a range so we can use `v1` as the source. We still
    use an iterator for the destination:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用 `ranges::copy()` 算法来复制整个**范围**。容器对象作为范围，因此我们可以使用 `v1` 作为源。我们仍然使用迭代器作为目标：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This also works with `back_inserter()`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以与 `back_inserter()` 一起使用：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can copy a certain number of elements using `copy_n()`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `copy_n()` 复制一定数量的元素：
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the second argument, the `copy_n()` algorithm is a *count* for the number
    of elements to copy. The output is:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个参数中，`copy_n()` 算法是复制元素数量的**计数**。输出如下：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s also a `copy_if()` algorithm that uses a Boolean *predicate function*
    to determine which elements to copy:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个使用布尔**谓词函数**来决定哪些元素需要复制的 `copy_if()` 算法：
- en: '[PRE15]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There''s also a `ranges` version of `copy_if()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `ranges` 版本的 `copy_if()`：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output includes only strings longer than `4` characters:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出仅包括长度超过 `4` 个字符的字符串：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the value `beta` is excluded.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，值 `beta` 被排除了。
- en: 'You can use any of these algorithms to copy to or from any sequence, including
    a stream iterator:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用这些算法中的任何一个将数据复制到或从任何序列中，包括流迭代器：
- en: '[PRE18]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `std::copy()` algorithm is very simple. An equivalent function would look
    like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::copy()` 算法非常简单。等效函数可能看起来像这样：'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `copy()` function uses the destination iterator's assignment operator to
    copy from the input iterator to the output iterator until it reaches the end of
    the input range.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy()` 函数使用目标迭代器的赋值运算符从输入迭代器复制到输出迭代器，直到达到输入范围的末尾。'
- en: 'There is also a version of this algorithm called `std::move()`, which moves
    elements instead of copying them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为 `std::move()` 的算法版本，它移动元素而不是复制它们：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This performs a move instead of copy assignment. After the move operation,
    the elements in `v1` will be empty, and the elements that were in `v1` are now
    in `v2`. The output looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行的是移动赋值而不是复制赋值。移动操作后，`v1` 中的元素将为空，而原本在 `v1` 中的元素现在在 `v2` 中。输出如下所示：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is also a `ranges` version of the `move()` algorithm that performs the
    same operation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `ranges` 版本的 `move()` 算法执行相同的操作：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The power of these algorithms lies in their simplicity. By letting the iterators
    manage the data, these simple, elegant functions allow you to seamlessly copy
    or move between any of the STL containers that support the required iterators.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的强大之处在于它们的简单性。通过让迭代器管理数据，这些简单、优雅的函数允许您无缝地在支持所需迭代器的任何 STL 容器之间复制或移动。
- en: Join container elements into a string
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器元素连接成一个字符串
- en: Sometimes, there is no algorithm in the library to accomplish a task at hand.
    We can use iterators, with the same techniques as the `algorithms` library, to
    easily write one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，库中没有算法来完成手头的任务。我们可以使用迭代器，使用与 `algorithms` 库相同的技巧，轻松编写一个。
- en: 'For example, we often need to join elements from a container, with separators,
    into a string. One common solution is to use a simple `for()` loop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们经常需要将容器中的元素，带分隔符，连接成一个字符串。一个常见的解决方案是使用简单的 `for()` 循环：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The problem with this otherwise simple solution is that it leaves a trailing
    separator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的缺点是它留下了一个尾随分隔符：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This may be fine in a testing environment, but in any production system, that
    trailing comma is unacceptable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这在测试环境中可能没问题，但在任何生产系统中，尾随逗号都是不可接受的。
- en: 'The `ranges::views` library has a `join()` function, but it doesn''t provide
    a separator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges::views` 库有一个 `join()` 函数，但它不提供分隔符：'
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `views::join()` function returns a `ranges::view` object. This requires
    a separate step to display or turn into a string. We can cycle through the view
    with a `for()` loop:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`views::join()` 函数返回一个 `ranges::view` 对象。这需要额外的步骤来显示或将其转换为字符串。我们可以使用 `for()`
    循环遍历视图：'
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It's all there, but we need a proper separator between the elements to make
    it useful for our purposes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的内容都在那里，但我们需要一个合适的分隔符来使其对我们的目的有用。
- en: Since the `algorithms` library does not have a function that suits our needs,
    we'll write one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `algorithms` 库中没有适合我们需求的函数，我们将编写一个。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, we will take the elements of a container and join them into
    a string with separators:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将取容器中的元素，并用分隔符将它们连接成一个字符串：
- en: 'In our `main()` function, we declare a vector of strings:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `main()` 函数中，我们声明了一个字符串向量：
- en: '[PRE30]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s write a simple `join()` function that uses an `ostream` object
    to join elements with a separator:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个简单的 `join()` 函数，该函数使用 `ostream` 对象将元素与分隔符连接起来：
- en: '[PRE31]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I've put this in my own `bw` namespace to avoid name collisions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这个函数放在了自己的 `bw` 命名空间中，以避免名称冲突。
- en: 'We can call it with `cout` like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `cout` 来调用它：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because it returns the `ostream` object, we can follow it with `<<` to add a
    *newline* to the stream.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它返回 `ostream` 对象，所以我们可以跟在它后面使用 `<<` 向流中添加一个 *换行符*。
- en: 'Output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ll often want a `string`, instead of directly writing to `cout`. We can
    overload this function for a version that returns a `string` object:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经常想要一个 `string`，而不是直接写入 `cout`。我们可以为此函数重载一个返回 `string` 对象的版本：
- en: '[PRE34]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This also goes in the `bw` namespace. This function creates an `ostringstream`
    object to pass to the `ostream` version of `bw::join()`. It returns a `string`
    object from the `str()` method of the `ostringstream` object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这也放在了 `bw` 命名空间中。这个函数创建了一个 `ostringstream` 对象，并将其传递给 `bw::join()` 的 `ostream`
    版本。它从 `ostringstream` 对象的 `str()` 方法返回一个 `string` 对象。
- en: 'We can use it like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s add one final overload to make this easier to use:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们添加一个最终的重载，使其更容易使用：
- en: '[PRE37]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This version just takes a container and a separator, which should satisfy most
    use cases nicely:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本只接受一个容器和一个分隔符，这应该可以很好地满足大多数用例：
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Most of the work in this recipe is done by the iterators and the `ostream`
    object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱中的大部分工作都是由迭代器和 `ostream` 对象完成的：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The separators go after the first element, between each of the successive elements,
    and stop before the final element. This means we can either add a separator *before*
    each element, skipping the first, or *after* each element, skipping the last.
    The logic is simpler if we test for, and skip, the first element. We do that in
    the line just before the `while()` loop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符放在第一个元素之后，在连续元素之间，并在最终元素之前停止。这意味着我们可以在每个元素 *之前* 添加一个分隔符，跳过第一个，或者在每个元素 *之后*
    添加，跳过最后一个。如果我们在 `while()` 循环之前测试并跳过第一个元素，逻辑会更简单。我们就在 `while()` 循环之前这样做：
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once we have the first element out of the way, we can simply add a separator
    before each remaining element:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理掉了第一个元素，我们就可以在剩余的每个元素前简单地添加一个分隔符：
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We return the `ostream` object as a convenience. This allows the user to easily
    add a newline, or other objects, to the stream:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回 `ostream` 对象作为便利。这使用户能够轻松地向流中添加换行符或其他对象：
- en: '[PRE43]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'As with any of the library algorithms, the `join()` function will work with
    any container that supports *forward iterators*. For example, here''s a `list`
    of `double` constants from the `numbers` library:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与库中的任何算法一样，`join()` 函数可以与任何支持 *forward iterators* 的容器一起工作。例如，这里有一个来自 `numbers`
    库的 `double` 常量 `list`：
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It will even work with a `ranges::view` object, like the `greek_view` defined
    earlier in this recipe:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以与 `ranges::view` 对象一起工作，就像在这个菜谱中之前定义的 `greek_view`：
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE48]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Sort containers with std::sort
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::sort 对容器进行排序
- en: The problem of how to efficiently sort comparable elements is essentially solved.
    For most applications, there's no reason to re-invent this wheel. The STL provides
    an excellent sorting solution via the `std::sort()` algorithm. While the standard
    does not specify a sorting algorithm, it does specify a worst-case complexity
    of *O*(*n* log *n*), when applied to a range of *n* elements.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如何有效地对可比较元素进行排序的问题本质上已经解决。对于大多数应用来说，没有必要重新发明轮子。STL 通过 `std::sort()` 算法提供了一个出色的排序解决方案。虽然标准没有指定排序算法，但它确实指定了当应用于
    *n* 个元素的范围内时，最坏情况下的复杂度为 *O*(*n* log *n*)。
- en: Just a few decades ago, the *quicksort* algorithm was considered a good compromise
    for most uses and was generally faster than other comparable algorithms. Today
    we have *hybrid* algorithms that choose between different approaches according
    to the circumstances, often switching algorithms on the fly. Most current C++
    libraries use a hybrid approach with some combination of *introsort* and an *insertion
    sort*. `std::sort()` provides exceptional performance under most common circumstances.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在几十年前，*快速排序* 算法被认为是对大多数用途的良好折衷方案，并且通常比其他类似算法更快。今天，我们有 *混合* 算法，这些算法会根据情况选择不同的方法，通常在运行时切换算法。大多数当前的
    C++ 库使用一种混合方法，结合了 *introsort* 和 *插入排序*。`std::sort()` 在大多数常见情况下提供了卓越的性能。
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we''ll examine the `std::sort()` algorithm. The `sort()` algorithm
    works with any container with random-access iterators. Here, we will use a `vector`
    of `int`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将检查 `std::sort()` 算法。`sort()` 算法与任何具有随机访问迭代器的容器一起工作。这里，我们将使用 `int`
    的 `vector`：
- en: 'We''ll start with a function to test if a container is sorted:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从测试容器是否排序的函数开始：
- en: '[PRE49]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This uses the `std::is_sorted()` algorithm and prints either `"sorted:"` or
    `"unsorted:"` according to the result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了 `std::is_sorted()` 算法，并根据结果打印 `"sorted:"` 或 `"unsorted:"`。
- en: 'We''ll need a function to print our `vector`:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来打印我们的 `vector`：
- en: '[PRE50]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function calls `check_sorted()` to display the status of the container
    before the value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用 `check_sorted()` 来显示在值之前容器的状态。
- en: 'Now we can define and print a `vector` of `int` in the `main()` function:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以定义并打印 `main()` 函数中的 `int` 的 `vector`：
- en: '[PRE51]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to test the `std::sort()` algorithm, we need an unsorted vector. Here''s
    a simple function to randomize our container:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试 `std::sort()` 算法，我们需要一个未排序的向量。这是一个简单的函数来随机化我们的容器：
- en: '[PRE53]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `std::random_device` class uses your system's hardware *entropy* source.
    Most modern systems have one, otherwise the library will simulate it. The `std::default_random_engine()`
    function generates random numbers from the entropy source. This is used by `std::shuffle()`
    to randomize the container.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::random_device` 类使用你的系统硬件 *熵* 源。大多数现代系统都有一个，否则库将模拟它。`std::default_random_engine()`
    函数从熵源生成随机数。这被 `std::shuffle()` 用于随机化容器。'
- en: 'We can now call `randomize()` with our container and print the result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用我们的容器调用 `randomize()` 并打印结果：
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE55]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of course, your output will be different because it''s randomized. In fact,
    I get a different result every time I run it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的输出会不同，因为它被随机化了。事实上，每次我运行它时，我都会得到不同的结果：
- en: '[PRE56]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE57]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To sort the vector, we simply call `std::sort()`:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要对向量进行排序，我们只需调用 `std::sort()`：
- en: '[PRE58]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE59]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: By default, the `sort()` algorithm uses the `<` operator to sort the elements
    in the range specified by the supplied iterators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sort()` 算法使用 `<` 操作符对指定迭代器范围的元素进行排序。
- en: 'The `partial_sort()` algorithm will sort part of the container:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial_sort()` 算法将排序容器的一部分：'
- en: '[PRE60]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`partial_sort()` takes three iterators: beginning, middle, and end. It sorts
    the container such that the elements before the middle are sorted. The elements
    after the middle are not guaranteed to be in the original order. Here''s the output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial_sort()` 接受三个迭代器：开始、中间和结束。它将容器排序，使得中间之前的元素是有序的。中间之后的元素不保证保持原始顺序。以下是输出：'
- en: '[PRE61]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Notice that the first five elements are sorted, and the rest are not.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前五个元素是有序的，其余的不是。
- en: 'The `partition()` algorithm *does not* sort anything. It rearranges the container
    so that certain elements appear at the front of the container:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition()` 算法 *不会* 对任何东西进行排序。它重新排列容器，使某些元素出现在容器的前面：'
- en: '[PRE62]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The third argument is a *predicate* lambda that determines which elements will
    be moved to the front.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个 *谓词* lambda，它确定哪些元素将被移动到前面。
- en: 'Output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE63]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that the values `>5` are moved to the front of the container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意值 `>5` 被移动到容器的前面。
- en: 'The `sort()` algorithms support an optional comparison function that may be
    used for non-standard comparisons. For example, given a class called `things`:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()` 算法支持一个可选的比较函数，可用于非标准比较。例如，给定一个名为 `things` 的类：'
- en: '[PRE64]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can create a `vector` of `things`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `vector` 的 `things`：
- en: '[PRE65]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We''ll need a function to print them out:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数来打印它们：
- en: '[PRE66]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now we can sort and print the `vector` of `things`:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以排序并打印 `things` 的 `vector`：
- en: '[PRE67]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE68]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Notice the comparison function sorts on the `i_` member, so the result is sorted
    by `i_`. We could instead sort on the `s_` member:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意比较函数按 `i_` 成员排序，所以结果是按 `i_` 排序的。我们也可以按 `s_` 成员排序：
- en: '[PRE69]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we get this output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到这个输出：
- en: '[PRE70]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `sort()` functions work by applying a sorting algorithm to a range of elements
    indicated by two iterators, for the beginning and end of the range.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 函数通过将排序算法应用于由两个迭代器指示的元素范围（范围的开始和结束）来工作。'
- en: 'By default, these algorithms use the `<` operator to compare elements. Optionally,
    they may use a *comparison function*, often provided as a lambda:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些算法使用 `<` 操作符来比较元素。可选地，它们可能使用 *比较函数*，通常作为 lambda 提供的：
- en: '[PRE71]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The comparison function takes two arguments and returns a `bool`. It has a
    signature equivalent to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 比较函数接受两个参数并返回一个 `bool`。它的签名等同于以下：
- en: '[PRE72]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `sort()` functions use `std::swap()` to move elements. This is efficient
    in both compute cycles and memory usage, as it relieves the need to allocate space
    for reading and writing the objects being sorted. This is also why the `partial_sort()`
    and `partition()` functions cannot guarantee the order of unsorted elements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 函数使用 `std::swap()` 来移动元素。这在计算周期和内存使用上都很高效，因为它避免了为读取和写入正在排序的对象分配空间的需求。这也是为什么
    `partial_sort()` 和 `partition()` 函数不能保证未排序元素的顺序。'
- en: Modify containers with std::transform
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::transform 修改容器
- en: The `std::transform()` function is remarkably powerful and flexible. One of
    the more commonly deployed algorithms in the library, it applies a *function*
    or *lambda* to each element in a container, storing the results in another container
    while leaving the original in place.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::transform()` 函数非常强大且灵活。它是库中更常用的一些算法之一，它将一个 *函数* 或 *lambda* 应用到容器中的每个元素上，同时将结果存储在另一个容器中，而原始容器保持不变。'
- en: Given its power, it's deceptively simple to use.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其强大的功能，使用起来出奇地简单。
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: 'In this recipe, we will explore a few applications for the `std::transform()`
    function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨 `std::transform()` 函数的一些应用：
- en: 'We''ll start with a simple function that prints the contents of a container:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个简单的打印容器内容的函数开始：
- en: '[PRE73]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We'll use this to view the results of our transformations.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它来查看转换的结果。
- en: 'In the `main()` function, let''s declare a couple of vectors:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，让我们声明几个向量：
- en: '[PRE74]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This prints out the contents of `v1`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 `v1` 的内容：
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we can use the `transform()` function to insert the square of each value
    into `v2`:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `transform()` 函数将每个值的平方插入到 `v2` 中：
- en: '[PRE76]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `transform()` function takes four arguments. The first two are the `begin()`
    and `end()` iterators for the source range. The third argument is the `begin()`
    iterator for the destination range. In this case, we're using the `back_inserter()`
    algorithm to insert the results in `v2`. The fourth argument is the transformation
    function. In this case, we're using a simple lambda to square the value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform()` 函数接受四个参数。前两个参数是源范围的 `begin()` 和 `end()` 迭代器。第三个参数是目标范围的 `begin()`
    迭代器。在这种情况下，我们使用 `back_inserter()` 算法将结果插入到 `v2` 中。第四个参数是转换函数。在这种情况下，我们使用一个简单的
    lambda 来平方值。'
- en: 'Output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE77]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Of course, we can use `transform()` with any type. Here''s an example that
    converts a `vector` of `string` objects to lowercase. First, we need a function
    to return the lowercase value of a string:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，我们可以用 `transform()` 函数处理任何类型。以下是一个将 `string` 对象的 `vector` 转换为小写的示例。首先，我们需要一个函数来返回字符串的小写值：
- en: '[PRE78]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now we can use the `str_lower()` function with transform:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `str_lower()` 函数与 `transform` 一起使用：
- en: '[PRE79]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This calls `str_lower()` for every element in `vstr1` and inserts the results
    into `vstr2`. The result is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这会对 `vstr1` 中的每个元素调用 `str_lower()` 并将结果插入到 `vstr2` 中。结果是：
- en: '[PRE80]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: (Yes, Pluto will always be a planet to me.)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: （是的，对我来说，冥王星始终是行星。）
- en: 'There''s also a `ranges` version of transform:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一个 `ranges` 版本的 `transform`：
- en: '[PRE81]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `ranges` version has a more succinct syntax and returns a `view` object,
    rather than populating another container.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges` 版本具有更简洁的语法，并返回一个 `view` 对象，而不是填充另一个容器。'
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::transform()` function works very much like `std::copy()`, with the
    addition of the user-provided function. Each element in the input range is passed
    to the function, and the return value from the function is copy-assigned to the
    destination iterator. This makes `transform()` a singularly useful and powerful
    algorithm.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::transform()` 函数的工作方式非常类似于 `std::copy()`，它增加了用户提供的函数。输入范围内的每个元素都会传递给该函数，函数的返回值会被复制分配给目标迭代器。这使得
    `transform()` 成为一个独特且强大的算法。'
- en: 'It''s worth noting that `transform()` does not guarantee the elements will
    be processed in order. If you need to ensure the order of the transformation,
    you will want to use a `for` loop instead:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`transform()` 函数并不能保证元素会按顺序处理。如果你需要确保转换的顺序，你应该使用 `for` 循环代替：
- en: '[PRE82]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE83]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Find items in a container
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中查找项目
- en: The `algorithm` library contains a set of functions for finding elements in
    a container. The `std::find()` function, and its derivatives, search sequentially
    through a container and return an iterator pointing to the first matching element,
    or the `end()` element if there's no match.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`algorithm` 库包含了一组用于在容器中查找元素的函数。`std::find()` 函数及其衍生函数会顺序遍历容器，并返回一个指向第一个匹配元素的迭代器，如果没有匹配则返回
    `end()` 元素。'
- en: How to do it…
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `find()` algorithm works with any container that satisfies the *Forward*
    or *Input* iterator qualifications. For this recipe, we''ll use `vector` containers.
    The `find()` algorithm searches sequentially for the first matching element in
    a container. In this recipe, we''ll walk through a few examples:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 算法与满足 *Forward* 或 *Input* 迭代器资格的任何容器一起工作。对于这个配方，我们将使用 `vector` 容器。`find()`
    算法在容器中顺序搜索第一个匹配元素。在这个配方中，我们将通过几个示例来讲解：'
- en: 'We''ll start by declaring a `vector` of `int` in the `main()` function:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先在 `main()` 函数中声明一个 `int` 类型的 `vector`：
- en: '[PRE84]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let''s search for the element with the value `7`:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们搜索值为 `7` 的元素：
- en: '[PRE85]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `find()` algorithm takes three arguments: the `begin()` and `end()` iterators,
    and the value to search. It returns an iterator to the first element it finds,
    or the `end()` iterator if the search failed to find a match.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 算法接受三个参数：`begin()` 和 `end()` 迭代器，以及要搜索的值。它返回指向它找到的第一个元素的迭代器，或者在搜索未成功找到匹配项时返回
    `end()` 迭代器。'
- en: 'Output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE86]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can also search for something more complex than a scalar. The object needs
    to support the equality comparison operator, `==`. Here''s a simple struct with
    an `operator==()` overload:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以搜索比标量更复杂的东西。该对象需要支持相等比较运算符 `==`。这里有一个简单的结构体，它重载了 `operator==()`：
- en: '[PRE87]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Notice that the `operator=()` overload only compares the `name` members.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`operator=()` 重载只比较 `name` 成员。
- en: I've also included an `str()` function that returns a `string` representation
    of a `City` element.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我还包含了一个 `str()` 函数，它返回 `City` 元素的字符串表示形式。
- en: 'Now we can declare a `vector` of `City` elements:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以声明一个 `City` 元素的 `vector`：
- en: '[PRE88]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can search the `vector` of `City` just as we did with the `vector` of `int`:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以像搜索 `int` 类型的 `vector` 一样搜索 `City` 类型的 `vector`：
- en: '[PRE89]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE90]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If we want to search on the `pop` member instead of `name`, we can use the
    `find_if()` function with a predicate:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想搜索 `pop` 成员而不是 `name`，我们可以使用带有谓词的 `find_if()` 函数：
- en: '[PRE91]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The predicate tests the `pop` member, so we get this output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词测试 `pop` 成员，所以我们得到这个输出：
- en: '[PRE92]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Notice that the result from `find_if()` returns only the first element that
    satisfies the predicate, even though there are two elements in the `vector` with
    `pop` values greater than 20,000,000.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，`find_if()` 的结果只返回满足谓词的第一个元素，即使 `vector` 中有两个元素的 `pop` 值大于 20,000,000。
- en: 'The `find()` and `find_if()` functions return only one iterator. The `ranges`
    library provides `ranges::views::filter()`, a *view adapter* that will give us
    all the matching iterators without disturbing our `vector`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 和 `find_if()` 函数只返回一个迭代器。`ranges` 库提供了 `ranges::views::filter()`，这是一个
    *视图适配器*，它将给我们所有匹配的迭代器，而不会干扰我们的 `vector`：'
- en: '[PRE93]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This gives us both matching elements in our output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了输出中的所有匹配元素：
- en: '[PRE94]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `find()` and `find_if()` functions search sequentially through a container,
    checking each element until it finds a match. If it finds a match, it returns
    an iterator pointing to that match. If it reaches the `end()` iterator without
    finding a match, it returns the `end()` iterator to indicate no match was found.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 和 `find_if()` 函数顺序遍历容器，检查每个元素，直到找到匹配项。如果找到匹配项，它返回指向该匹配项的迭代器。如果在没有找到匹配项的情况下达到
    `end()` 迭代器，它返回 `end()` 迭代器以指示没有找到匹配项。'
- en: 'The `find()` function takes three arguments, the `begin()` and `end()` iterators,
    and a search value. The signature looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 函数接受三个参数，即 `begin()` 和 `end()` 迭代器，以及搜索值。其签名如下：'
- en: '[PRE95]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `find_if()` function uses a predicate instead of a value:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_if()` 函数使用谓词而不是值：'
- en: '[PRE96]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: There's more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'Both `find()` functions search sequentially and return when they find the first
    match. If you want to find more matching elements, you can use the `filter()`
    function from the `ranges` library:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `find()` 函数都是顺序搜索，并在找到第一个匹配项时返回。如果你想找到更多匹配的元素，你可以使用 `ranges` 库中的 `filter()`
    函数：
- en: '[PRE97]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `filter()` function returns a *view*, a non-destructive window into the
    container with only the filtered elements. We can then use the view as we would
    any other container:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 函数返回一个 *视图*，这是一个非破坏性的容器窗口，只包含过滤后的元素。然后我们可以像使用任何其他容器一样使用这个视图：'
- en: '[PRE98]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE99]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Limit the values of a container to a range with std::clamp
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::clamp 限制容器中的值范围
- en: Introduced with C++17, the `std::clamp()` function can be used to limit the
    range of a numeric scalar to within minimum and maximum values. The function is
    optimized to use *move semantics*, where possible, for maximum speed and efficiency.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C++17 的引入，`std::clamp()` 函数可以用来限制数值标量的范围，使其在最小值和最大值之间。该函数尽可能优化使用 *移动语义*，以实现最大速度和效率。
- en: How to do it…
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can use `clamp()` to constrain the values of a container by using it in a
    loop, or with the `transform()` algorithm. Let's look at some examples.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在循环中使用 `clamp()` 或使用 `transform()` 算法来通过它约束容器中的值。让我们看看一些例子。
- en: 'We''ll start with a simple function for printing out the values of a container:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从一个简单的函数开始，用于打印容器中的值：
- en: '[PRE100]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Notice the *format string* `"{:>5} "`. This right-aligns each value to `5` spaces,
    for a tabular view.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 *格式字符串* `"{:>5} "`。这会将每个值右对齐到 `5` 个空格，以实现表格视图。
- en: 'In the `main()` function, we''ll define an *initializer list* for use with
    our container. This allows us to use the same values more than once:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将定义一个 *初始化列表* 以用于我们的容器。这允许我们多次使用相同的值：
- en: '[PRE101]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: That's a nice range of values to work with `clamp()`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的值范围，可以与 `clamp()` 一起使用。
- en: 'Let''s also define some constants for use as our limits:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们也定义一些常数作为我们的限制：
- en: '[PRE102]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We'll use these values in our calls to `clamp()`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在对 `clamp()` 的调用中使用这些值。
- en: 'Now we can define a container in our `main()` function. We''ll use a `vector`
    of `int`:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `main()` 函数中定义一个容器。我们将使用 `int` 的 `vector`：
- en: '[PRE103]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Using the values from our initializer list, the output is:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的初始化列表中的值，输出如下：
- en: '[PRE104]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now we can use a `for` loop with `clamp()` to limit the values to between 0
    and 500:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用带有 `clamp()` 的 `for` 循环来限制值在 0 和 500 之间：
- en: '[PRE105]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This applies the `clamp()` function to each value in the container, using 0
    and 500 for the low and high limits, respectively. Now, the output is:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将 `clamp()` 应用到容器中的每个值，分别使用 0 和 500 作为低和高限制。现在，输出如下：
- en: '[PRE106]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: After the `clamp()` operation, the negative values are 0 and the values greater
    than 500 are 500.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `clamp()` 操作之后，负值变为 0，大于 500 的值变为 500。
- en: 'We can do the same thing with the `transform()` algorithm, using `clamp()`
    in a lambda. This time we''ll use a `list` container:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `transform()` 算法，在 lambda 中使用 `clamp()` 来做同样的事情。这次我们将使用一个 `list` 容器：
- en: '[PRE107]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The output is the same as in the version with a `for` loop:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与带有 `for` 循环的版本相同：
- en: '[PRE108]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `clamp()` algorithm is a simple function that looks something like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`clamp()` 算法是一个简单的函数，看起来像这样：'
- en: '[PRE109]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: If the value of `v` is less than `lo`, it returns `lo`. If `hi` is less than
    `v`, it returns `hi`. The function is fast and efficient.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `v` 的值小于 `lo`，则返回 `lo`。如果 `hi` 小于 `v`，则返回 `hi`。该函数快速且高效。
- en: 'In our examples, we used a `for` loop to apply `clamp()` to a container:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用 `for` 循环将 `clamp()` 应用到容器中：
- en: '[PRE110]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We also used the `transform()` algorithm with `clamp()` in a lambda:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 lambda 在 `transform()` 算法中与 `clamp()` 一起使用：
- en: '[PRE111]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: In my experiments, both versions gave the same results, and both produced similar
    code from the GCC compiler. There was a slight difference in compiled size (the
    version with the `for` loop was smaller, as expected) and a negligible difference
    in performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的实验中，两个版本都给出了相同的结果，并且都生成了类似 GCC 编译器的代码。编译大小（带有 `for` 循环的版本更小，正如预期的那样）和性能差异可以忽略不计。
- en: In general, I prefer the `for` loop, but the `transform()` version may be more
    flexible in other applications.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我更喜欢 `for` 循环，但 `transform()` 版本在其他应用中可能更灵活。
- en: Sample data sets with std::sample
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::sample 的样本数据集
- en: The `std::sample()` algorithm takes a random *sample* of a sequence of values
    and populates a destination container with the sample. It is useful for analyzing
    a larger set of data, where the random sample is taken to be representative of
    the whole.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sample()` 算法从一系列值中随机抽取 *样本*，并将样本填充到目标容器中。这对于分析较大的数据集很有用，其中随机样本被认为是整个集合的代表。'
- en: A sample set allows us to approximate the characteristics of a large set of
    data, without analyzing the full set. This provides efficiency in exchange for
    accuracy, a fair trade-off in many circumstances.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 样本集允许我们近似大量数据的特征，而无需分析整个集合。这以准确性为代价提供了效率，在很多情况下是一个公平的交易。
- en: How to do it…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this recipe, we'll use an array of 200,000 random integers, with *standard
    normal distribution*. We'll sample a few hundred values to create a histogram
    of the frequency of each value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个包含 200,000 个随机整数的数组，具有 *标准正态分布*。我们将采样几百个值来创建每个值的频率直方图。
- en: 'We''ll start with a simple function to return a rounded `int` from a `double`.
    The standard library lacks such a function and we''ll need it later:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从返回一个从`double`舍入的`int`的简单函数开始。标准库缺少这样的函数，我们稍后需要它：
- en: '[PRE112]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The standard library provides several versions of `std::round()`, including
    one that returns a `long int`. But we need an `int`, and this is a simple solution
    that avoids compiler warnings about narrowing conversion while hiding away the
    unsightly `static_cast`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个版本的`std::round()`，包括一个返回`long int`的版本。但我们需要一个`int`，这是一个简单的解决方案，它避免了编译器关于缩窄转换的警告，同时隐藏了难看的`static_cast`。
- en: 'In the `main()` function, we''ll start with some useful constants:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将开始一些有用的常量：
- en: '[PRE113]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We have values for `n_data` and `n_samples`, used for the size of the data and
    sample containers, respectively. We also have values for `mean` and `dev`, the
    *mean* and *standard deviation* parameters for the *normal distribution* of random
    values.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`n_data`和`n_samples`的值，分别用于数据容器和样本容器的尺寸。我们还有`mean`和`dev`的值，这是随机值正态分布的*均值*和*标准差*参数。
- en: 'We now set up our *random number generator* and *distribution* objects. These
    are used to initialize the source data set:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在设置我们的*随机数生成器*和*分布*对象。这些用于初始化源数据集：
- en: '[PRE114]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The `random_device` object provides access to the hardware random number generator.
    The `mt19937` class is an implementation of the *Mersenne Twister* random number
    algorithm, a high-quality algorithm that will perform well on most systems with
    a data set of the size we're using. The `normal_distribution` class provides a
    distribution of random numbers around the *mean* with the *standard deviation*
    provided.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`random_device`对象提供了对硬件随机数生成器的访问。`mt19937`类是*Mersenne Twister*随机数算法的一个实现，这是一个在大多数系统上表现良好的高质量算法，适用于我们使用的数据集大小。`normal_distribution`类提供了一个围绕*均值*的随机数分布，并提供了*标准差*。'
- en: 'Now we populate an array with an `n_data` number of random `int` values:'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们用一个`n_data`数量的随机`int`值填充一个数组：
- en: '[PRE115]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `array` container is fixed in size, so the template parameters include a
    `size_t` value for the number of elements to allocate. We use a `for()` loop to
    populate the array.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`容器的大小是固定的，所以模板参数包括一个`size_t`值，表示要分配的元素数量。我们使用`for()`循环来填充数组。'
- en: The `rng` object is the hardware random number generator. This is passed to
    `dist()`, our `normal_distribution` object, and then to `iround()`, our integer
    rounding function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`rng`对象是硬件随机数生成器。这个对象被传递给我们的`normal_distribution`对象`dist()`，然后传递给我们的整数舍入函数`iround()`。'
- en: 'At this point, we have an array with 200,000 data points. That''s a lot to
    analyze, so we''ll use the `sample()` algorithm to take a sample of 500 values:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个包含200,000个数据点的数组。这有很多要分析，所以我们将使用`sample()`算法来抽取500个值的样本：
- en: '[PRE116]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We define another `array` object to hold the samples. This one is `n_samples`
    in size. Then we use the `sample()` algorithm to populate the array with `n_samples`
    random data points.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义另一个`array`对象来存储样本。这个数组的大小是`n_samples`。然后我们使用`sample()`算法用`n_samples`个随机数据点填充数组。
- en: 'We create a histogram to analyze the samples. A `map` structure is perfect
    for this as we can easily map the frequency of each value:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个直方图来分析样本。`map`结构非常适合这个用途，因为我们可以轻松地将每个值的频率映射出来：
- en: '[PRE117]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `for()` loop takes each value from the `samples` container and uses it as
    a key in the `map`. The increment expression `++hist[i]` counts the number of
    occurrences of each value in the sample set.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`for()`循环从`samples`容器中取每个值，并将其用作`map`中的键。增量表达式`++hist[i]`计算样本集中每个值的出现次数。'
- en: 'We print out the histogram using the C++20 `format()` function:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用C++20的`format()`函数打印出直方图：
- en: '[PRE118]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `format()` specifiers that look like `{:>3}` make space for a certain number
    of characters. The angle bracket specifies alignment, right or left.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`{:>3}`的`format()`指定符为一定数量的字符留出空间。尖括号指定了对齐方式，是右对齐还是左对齐。
- en: The `string(count, char)` constructor creates a `string` with a character repeated
    the number of times specified, in this case, *n* asterisk characters `*`, where
    *n* is `count/scale`, the frequency of a value in the histogram, divided by the
    `scale` constant.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`string(count, char)`构造函数创建一个`string`，其中包含重复指定次数的字符，在这种情况下，*n*个星号字符`*`，其中*n*是`count/scale`，即直方图中一个值的频率除以`scale`常量。'
- en: 'The output looks like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE119]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This is a nice graphical representation of the histogram. The first number is
    the value, the second number is the frequency of the value, and the asterisks
    are a visual representation of the frequency, where each asterisk represents `scale`
    (3) occurrences in the sample set.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的直方图图形表示。第一个数字是值，第二个数字是该值的频率，星号是频率的视觉表示，其中每个星号代表样本集中`scale`（3）次出现。
- en: Your output will differ each time you run the code.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行代码时，你的输出都会不同。
- en: How it works…
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::sample()` function selects a specific number of elements from random
    locations in the source container and copies them to the destination container.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sample()`函数从源容器中的随机位置选择特定数量的元素，并将它们复制到目标容器中。'
- en: 'The signature of `sample()` looks like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()`的签名如下所示：'
- en: '[PRE120]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The first two arguments are `begin()` and `end()` iterators on a container with
    the full data set. The third argument is an iterator for the destination of the
    samples. The fourth argument is the sample size, and the final argument is a random
    number generator function.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是容器中完整数据集的`begin()`和`end()`迭代器。第三个参数是样本目的地的迭代器。第四个参数是样本大小，最后一个参数是随机数生成函数。
- en: The `sample()` algorithm uses *uniform distribution*, so each data point has
    the same chance of being sampled.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()`算法使用*均匀分布*，因此每个数据点被抽样的机会相同。'
- en: Generate permutations of data sequences
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成数据序列的排列组合
- en: There are many use cases for permutations, including testing, statistics, research,
    and more. The `next_permutation()` algorithm generates permutations by re-ordering
    a container to the next *lexicographical* permutation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 排列组合有许多用途，包括测试、统计学、研究等。`next_permutation()`算法通过重新排列容器以生成下一个*字典序*排列组合。
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, we will print out the permutations of a set of three strings:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将打印出一组三个字符串的排列组合：
- en: 'We''ll start by creating a short function for printing the contents of a container:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个用于打印容器内容的简短函数：
- en: '[PRE121]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: We'll use this simple function to print our data set and permutations.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个简单的函数来打印我们的数据集和排列组合。
- en: In the `main()` function, we declare a `vector` of `string` objects and sort
    it with the `sort()` algorithm.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们声明一个`string`对象的`vector`并使用`sort()`算法对其进行排序。
- en: '[PRE122]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `next_permutation()` function requires a sorted container.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_permutation()`函数需要一个有序容器。'
- en: 'Now we can list the permutations with `next_permutation()` in a `do` loop:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`next_permutation()`在`do`循环中列出排列组合：
- en: '[PRE123]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `next_permutation()` function modifies the container and returns `true`
    if there is another permutation, or `false` if not.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_permutation()`函数会修改容器，如果还有另一个排列组合则返回`true`，如果没有则返回`false`。'
- en: 'The output lists six permutations of our three pets:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了我们三只宠物的六种排列组合：
- en: '[PRE124]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How it works…
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `std::next_permutation()` algorithm generates *lexicographical* permutations
    of a set of values, that is, permutations based on dictionary ordering. The input
    must be sorted because the algorithm steps through permutations in lexicographical
    order. So, if you start with a set like 3, 2, 1, it will terminate immediately
    as this is the last lexicographical order of those three elements.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::next_permutation()`算法生成一组值的*字典序*排列组合，即基于字典顺序的排列组合。输入必须是有序的，因为算法按字典序遍历排列组合。所以，如果你从一个像3,
    2, 1这样的集合开始，它将立即终止，因为这是这三个元素的最后一种字典序排列。'
- en: 'For example:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE125]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'This gives us the following output:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了以下输出：
- en: '[PRE126]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: While the term *lexicographical* implies alphabetical ordering, the implementation
    uses standard comparison operators, so it works on any sortable values.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语*字典序*暗示了字母顺序，但实现使用标准比较运算符，因此它适用于任何可排序的值。
- en: 'Likewise, if values in the set repeat, they are only counted according to *lexicographical*
    order. Here we have a `vector` of `int` with two repeating sequences of five values:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果集合中的值重复，它们只按*字典序*计数。这里有一个包含两个重复序列的五个值的`vector`：
- en: '[PRE127]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Output:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE128]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: There are 113,400 permutations of these values. Notice that it's not *10!* (3,628,800)
    because some values repeat. Since *3,3* and *3,3* sort the same, they are not
    different *lexicographical* permutations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值的排列组合共有113,400种。请注意，这不是*10!*（3,628,800），因为有些值是重复的。由于*3,3*和*3,3*排序相同，它们不是不同的*字典序*排列组合。
- en: 'In other words, if I list the permutations of this short set:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我列出这个短集合的排列组合：
- en: '[PRE129]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We get only three permutations, not *3!* (9), because of the repeating values:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有重复的值，我们只得到三个排列，而不是 *3!*（9）：
- en: '[PRE130]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Merge sorted containers
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并排序容器
- en: The `std::merge()` algorithm takes two sorted sequences and creates a third
    merged and sorted sequence. This technique is often used as part of a *merge sort*,
    allowing very large amounts of data to be broken down into chunks, sorted separately,
    and merged into one sorted target.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::merge()` 算法接受两个排序序列，并创建一个第三合并和排序的序列。这种技术通常作为 *归并排序* 的一部分，允许将大量数据分解成块，分别排序，然后合并到一个排序的目标中。'
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: For this recipe, we'll take two sorted `vector` containers and merge them into
    a third `vector` using `std::merge()`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将取两个排序的 `vector` 容器，并使用 `std::merge()` 将它们合并到第三个 `vector` 中。
- en: 'We''ll start with a simple function to print the contents of a container:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从打印容器内容的一个简单函数开始：
- en: '[PRE131]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: We'll use this to print the source and destination sequences.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个结果来打印源和目标序列。
- en: 'In the `main()` function, we''ll declare our source vectors, along with the
    destination vector, and print them out:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将声明我们的源向量，以及目标向量，并将它们打印出来：
- en: '[PRE132]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The output is:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE133]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now we can sort our vectors and print them again:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以对向量进行排序并再次打印它们：
- en: '[PRE134]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Output:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果：
- en: '[PRE135]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now that our source containers are sorted, we can merge them for our final
    merged result:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经对源容器进行了排序，我们可以将它们合并以得到最终的合并结果：
- en: '[PRE136]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Output:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果：
- en: '[PRE137]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This output represents the merge of the two sources into one sorted vector.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出表示将两个源合并到一个排序向量中。
- en: How it works…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `merge()` algorithm takes `begin()` and `end()` iterators from both the
    sources and an output iterator for the destination:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()` 算法从两个源中获取 `begin()` 和 `end()` 迭代器，并为目标提供一个输出迭代器：'
- en: '[PRE138]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: It takes the two input ranges, performs its merge/sort operation, and sends
    the resulting sequence to the output iterator.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受两个输入范围，执行其合并/排序操作，并将结果序列发送到输出迭代器。
