- en: Introduction to WebGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL简介
- en: After Apple created the Canvas element, the Mozilla Foundation began working
    on a Canvas 3D prototype in 2006, and by 2007, there were implementations of this
    early version, which would eventually become WebGL. In 2009, a consortium called
    the Kronos Group began a WebGL Working Group. By 2011, this group had produced
    the 1.0 version of WebGL, which is based on the OpenGL ES 2.0 API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果创建Canvas元素之后，Mozilla基金会于2006年开始研究Canvas 3D原型，并在2007年实现了这个早期版本，最终成为WebGL。2009年，一个名为Kronos
    Group的财团成立了一个WebGL工作组。到2011年，该组织已经制定了基于OpenGL ES 2.0 API的WebGL 1.0版本。
- en: As I stated earlier, WebGL was seen as a 3D rendering API that would be used
    with the HTML5 Canvas element. Its implementation eliminates some of the rendering
    bottlenecks of the traditional 2D canvas API and gives near-direct access to the
    computer's GPU. Because of this, it is typically faster to use WebGL to render
    2D images to the HTML5 canvas than it is to use the original 2D canvas implementation.
    However, WebGL is significantly more complicated to use due to the added complexity
    of three-dimensional rendering. Because of this, several libraries are built on
    top of WebGL. This allows users to work with WebGL but use a simplified 2D API.
    If we were writing our game in traditional JavaScript, we might use a library
    such as Pixi.js or Cocos2d-x for 2D rendering on top of WebGL in order to simplify
    our code. Right now, WebAssembly uses an implementation of **Simple DirectMedia
    Layer** (**SDL**), and is the library that's used by most developers to write
    games. This WebAssembly version of SDL is built on top of WebGL and provides high-end
    performance, but is much easier to use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，WebGL被视为与HTML5 Canvas元素一起使用的3D渲染API。它的实现消除了传统2D画布API的一些渲染瓶颈，并几乎直接访问计算机的GPU。因此，使用WebGL将2D图像渲染到HTML5画布通常比使用原始2D画布实现更快。然而，由于增加了三维渲染的复杂性，使用WebGL要复杂得多。因此，有几个库是建立在WebGL之上的。这允许用户使用WebGL，但使用简化的2D
    API。如果我们在传统的JavaScript中编写游戏，我们可能会使用像Pixi.js或Cocos2d-x这样的库来简化我们的代码，以便在WebGL上进行2D渲染。现在，WebAssembly使用**Simple
    DirectMedia Layer**（**SDL**）的实现，这是大多数开发人员用来编写游戏的库。这个WebAssembly版本的SDL是建立在WebGL之上的，并提供高端性能，但使用起来更容易。
- en: Using SDL does not prevent you from also using WebGL directly from within the
    C++ code compiled into WebAssembly. There are times where we may be interested
    in directly interacting with WebGL because the features we are interested in are
    not directly available from within SDL. One example of these use cases is creating
    custom shaders that allow for special 2D lighting effects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDL并不妨碍您直接从编译为WebAssembly的C++代码中直接使用WebGL。有时，我们可能对直接与WebGL进行交互感兴趣，因为我们感兴趣的功能在SDL内部并不直接可用。这些用例的一个例子是创建允许特殊2D光照效果的自定义着色器。
- en: 'In this chapter, you will need an image file from the GitHub project to run
    the examples. The app requires the `/Chapter03/spaceship.png` image file from
    the project directory. Please download the project from the following URL: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要从GitHub项目中获取图像文件来运行示例。该应用程序需要项目目录中的`/Chapter03/spaceship.png`图像文件。请从以下网址下载项目：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: WebGL and canvas contexts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL和画布上下文
- en: An introduction to WebGL shaders
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL着色器简介
- en: WebGL and JavaScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebGL和JavaScript
- en: WebGL and canvas contexts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL和画布上下文
- en: WebGL is a rendering context for drawing to the HTML5 element, and is an alternative
    to the 2D rendering context. Often, when someone mentions the canvas, they are
    referring to the 2D rendering context, which is accessed by calling `getContext`
    and passing in the string `2d`. Both contexts are methods of rendering to the
    HTML5 canvas element. A context is a type of API for immediate mode rendering.
    Two different WebGL contexts can be requested, both of which provide access to
    different versions of the WebGL API. These contexts are *webgl* and *webgl2*.
    In the following examples, I will be using the *webgl* context and will be using
    the WebGL 1.0 API. There is also a rarely used context for rendering a bitmap
    to the canvas that we can access by passing in `bitmaprenderer` as a string value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL是用于绘制HTML5元素的渲染上下文，是2D渲染上下文的替代品。通常，当有人提到画布时，他们指的是2D渲染上下文，通过调用`getContext`并传入字符串`2d`来访问。这两个上下文都是用于绘制到HTML5画布元素的方法。上下文是一种用于即时模式渲染的API类型。可以请求两种不同的WebGL上下文，两者都提供对不同版本的WebGL
    API的访问。这些上下文是*webgl*和*webgl2*。在接下来的示例中，我将使用*webgl*上下文，并将使用WebGL 1.0 API。还有一个很少使用的上下文，用于将位图渲染到画布上，我们可以通过传入`bitmaprenderer`作为字符串值来访问。
- en: I want to point out that the term canvas is sometimes used to refer to the 2D
    canvas context and sometimes used to refer to the immediate mode rendering HTML5
    canvas element. When I refer to canvas in this book without mentioning the 2D
    context, I am referring to the HTML5 canvas element.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出，术语画布有时用于指代2D画布上下文，有时用于指代即时模式渲染的HTML5画布元素。当我在本书中提到画布而没有提到2D上下文时，我指的是HTML5画布元素。
- en: In the next section, I will introduce you to shaders and the GLSL shader language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向您介绍着色器和GLSL着色器语言。
- en: An introduction to WebGL shaders
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL着色器简介
- en: When OpenGL or WebGL interact with a GPU, they pass in data to tell the GPU
    the geometry and textures it needs to render. At this point, the GPU needs to
    know how it must render those textures and the geometry associated with them into
    a single 2D image that will be displayed on your computer monitor. **OpenGL Shader
    Language** (**GLSL**) is a language that is used with both OpenGL and WebGL to
    instruct the GPU on how to render a 2D image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当OpenGL或WebGL与GPU交互时，它们传递数据告诉GPU需要渲染的几何图形和纹理。此时，GPU需要知道如何将这些纹理和与之相关的几何图形渲染成一个在计算机显示器上显示的单个2D图像。**OpenGL着色器语言**（**GLSL**）是一种用于指导GPU如何渲染2D图像的语言，它与OpenGL和WebGL一起使用。
- en: Technically, WebGL uses the GLSL ES shader language (sometimes referred to as
    ELSL), which is a subset of the GLSL language. GLSL ES is the shader language
    that's used with OpenGL ES, a mobile-friendly subset of OpenGL (the ES is for
    Embedded Systems). Because WebGL is based on OpenGL ES, it inherited the GLSL
    ES shader language. Note that whenever I refer to GLSL within the context of WebGL
    or WebAssembly, I am referring to GLSL ES.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，WebGL使用GLSL ES着色器语言（有时称为ELSL），它是GLSL语言的一个子集。GLSL ES是与OpenGL ES一起使用的着色器语言，OpenGL
    ES是OpenGL的一个移动友好子集（ES代表嵌入式系统）。因为WebGL基于OpenGL ES，它继承了GLSL ES着色器语言。请注意，每当我在WebGL或WebAssembly的上下文中提到GLSL时，我指的是GLSL
    ES。
- en: The WebGL rendering pipeline requires us to write two types of shaders to render
    an image to the screen. These are the vertex shader, which renders the geometry
    on a per-vertex basis, and the fragment shader, which renders pixel candidates
    known as fragments. The GLSL looks a lot like the C language, so the code will
    look somewhat familiar if you work in C or C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL渲染管道要求我们编写两种类型的着色器来将图像渲染到屏幕上。这些是顶点着色器，它以每个顶点为基础渲染几何图形，以及片段着色器，它渲染像素候选，称为片段。GLSL看起来很像C语言，所以如果你在C或C++中工作，代码会看起来有些熟悉。
- en: 'This introduction to GLSL shaders will not go into a lot of detail. In a later
    chapter, I will discuss WebGL shaders more extensively. Right now, I only want
    to introduce the concept and show you a very simple 2D WebGL shader. I will go
    into a lot more detail in the chapter on 2D lighting. Here is an example of a
    simple vertex shader that is used to render quads for a 2D WebGL rendering engine:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GLSL着色器的介绍不会详细讨论。在后面的章节中，我将更详细地讨论WebGL着色器。现在，我只想介绍这个概念，并向你展示一个非常简单的2D WebGL着色器。在关于2D光照的章节中，我将更详细地讨论这个问题。这是一个用于渲染2D
    WebGL渲染引擎中四边形的简单顶点着色器的示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This very simple shader takes in the position of a vertex and moves it based
    on a positional uniform value that's passed into the shader through WebGL. This
    shader will run on every single vertex in our geometry. In a 2D game, all geometry
    would be rendered as a quad (that is, a rectangle). Using WebGL in this way allows
    us to make better use of the computer's GPU. Let me briefly discuss what is going
    on in the code of this vertex shader.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的着色器接收顶点的位置，并根据通过WebGL传递到着色器中的位置统一值移动它。这个着色器将在我们的几何图形中的每个顶点上运行。在2D游戏中，所有几何图形都将被渲染为四边形。以这种方式使用WebGL可以更好地利用计算机的GPU。让我简要地讨论一下这个顶点着色器代码中发生了什么。
- en: If you are new to game development, the concept of vertex and pixel shaders
    may feel a little foreign. They are not as mysterious as they may first seem.
    You may want to quickly read over the Wikipedia *Shader* article if you want a
    better understanding of what shaders are ([https://en.wikipedia.org/wiki/Shader](https://en.wikipedia.org/wiki/Shader)).
    If you are still feeling lost, feel free to ask me questions on Twitter (`@battagline`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是游戏开发的新手，顶点着色器和像素着色器的概念可能会感到有些陌生。它们并不像一开始看起来那么神秘。如果你想更好地理解着色器是什么，你可能想快速阅读一下维基百科的*着色器*文章（[https://en.wikipedia.org/wiki/Shader](https://en.wikipedia.org/wiki/Shader)）。如果你仍然感到迷茫，可以随时在Twitter上问我问题（`@battagline`）。
- en: 'The first line of this shader sets the floating-point precision:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个着色器的第一行设置了浮点精度：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All floating-point operations on a computer are approximations for real fractions.
    We can approximate 1/3 with a low precision using 0.333 and with higher precision
    with 0.33333333\. The precision line of the code indicates the precision of the
    floating-point values on the GPU. We can use one of three possible precisions:
    `highp`, `mediump`, or `lowp`. The higher the floating-point precision, the slower
    the GPU will execute the code, but the higher the accuracy of all the values of
    the computations. In general, I have kept this value at `mediump`, and that has
    worked well for me. If you have an application that demands performance over precision,
    you can change this to `lowp`. If you require high precision, be sure that you
    know the capabilities of the target GPUs. Not all GPUs support `highp`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机上的所有浮点运算都是对实数分数的近似。我们可以用0.333来低精度地近似1/3，用0.33333333来高精度地近似。代码中的精度行表示GPU上浮点值的精度。我们可以使用三种可能的精度：`highp`、`mediump`或`lowp`。浮点精度越高，GPU执行代码的速度就越慢，但所有计算值的精度就越高。一般来说，我将这个值保持在`mediump`，这对我来说效果很好。如果你有一个需要性能而不是精度的应用程序，你可以将其更改为`lowp`。如果你需要高精度，请确保你了解目标GPU的能力。并非所有GPU都支持`highp`。
- en: 'The attribute variables are values that are passed in with the vertex arrays
    into the pipeline. In our code, these values include the texture coordinates associated
    with the vertex, as well as the 2D translation matrix associated with the vertex:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 属性变量是与顶点数组一起传递到管道中的值。在我们的代码中，这些值包括与顶点相关的纹理坐标，以及与顶点相关的2D平移矩阵：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The uniform variable type is a type of variable that remains constant across
    all vertices and fragments. In this vertex shader, we are passing in one uniform
    vector, `u_translate`. Typically, you would not want to translate all your vertices
    by the same amount unless it is for a camera, but because we are only writing
    a WebGL program to draw a single sprite, using a `uniform` variable for `translate`
    will work fine:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: uniform变量类型是一种在所有顶点和片段中保持恒定的变量类型。在这个顶点着色器中，我们传入一个uniform向量`u_translate`。通常情况下，除非是为了相机，您不会希望将所有顶点平移相同的量，但因为我们只是编写一个用于绘制单个精灵的WebGL程序，所以使用`uniform`变量来进行`translate`将是可以的：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `varying` variables (sometimes known as interpolators) are values that
    are passed from the vertex shader into the fragment shader, with each fragment
    in the fragment shader getting an interpolated version of that value. In this
    code, the only `varying` variable is the texture coordinate for the vertex:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`varying`变量（有时被称为插值器）是从顶点着色器传递到片段着色器的值，片段着色器中的每个片段都会得到该值的插值版本。在这段代码中，唯一的`varying`变量是顶点的纹理坐标：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In mathematics, an interpolated value is a calculated intermediate value. For
    example, if we interpolate the halfway point between 0.2 and 1.2, we would get
    a value of 0.7\. That is, the starting value of 0.2, plus the average of (1.2
    - 0.2) / 2 = 0.5\. So, 0.2 + 0.5 = 0.7\. Values passed from the vertex shader
    to the fragment shader using the `varying` keyword will be interpolated based
    on the position of the fragments relative to the vertex.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，插值值是计算出的中间值。例如，如果我们在0.2和1.2之间进行插值，我们将得到一个值为0.7。也就是说，0.2的起始值，加上(1.2-0.2)/2的平均值=0.5。所以，0.2+0.5=0.7。使用`varying`关键字从顶点着色器传递到片段着色器的值将根据片段相对于顶点的位置进行插值。
- en: 'Finally, the code executed in the vertex shader is inside of the `main` function.
    This code takes the position of the vertex and multiplies it by the translation
    matrix to get the world coordinates of the vertex so that it can place them into
    `gl_Position`. It then sets the texture coordinate that''s passed into the vertex
    shader directly into the varying variable so that it can pass it into the fragment
    shader:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在顶点着色器中执行的代码位于`main`函数内。该代码获取顶点的位置，并将其乘以平移矩阵以获得顶点的世界坐标，以便将其放入`gl_Position`中。然后，它将直接将传递到顶点着色器的纹理坐标设置为插值变量，以便将其传递到片段着色器中：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the vertex shader has been run, all the fragments that vertex shader generated
    are run through the fragment shader, which interpolates all of the varying variables
    for each fragment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器运行后，顶点着色器生成的所有片段都会通过片段着色器运行，片段着色器会为每个片段插值所有的`varying`变量。
- en: 'Here is a simple example of a fragment shader:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个片段着色器的简单示例：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just like in our vertex shader, we start by setting our floating-point precision
    to `mediump`. The fragments have a `uniform sample2D` texture that defines the
    texture map that''s used to generate the 2D sprites in our game:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的顶点着色器中一样，我们首先将浮点精度设置为`mediump`。片段有一个`uniform sample2D`纹理，定义了用于在我们的游戏中生成2D精灵的纹理映射：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`uniform` is a little like a global variable that is passed into the pipeline
    and applies to either every vertex or every fragment in the shader that uses it.
    The code that''s executed in the `main` function is also straightforward. It takes
    the interpolated texture coordinate from the `v_texcoord` varying variable and
    retrieves the color value from our sampled texture, and then uses that value to
    set the color of the `gl_FragColor` fragment:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform`有点像是传递到管道中并应用于着色器中使用它的每个顶点或每个片段的全局变量。`main`函数中执行的代码也很简单。它获取从`v_texcoord`变量中插值的纹理坐标，并从我们采样的纹理中检索颜色值，然后使用该值设置`gl_FragColor`片段的颜色：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Drawing a simple 2D image to the screen using WebGL directly inside of JavaScript
    requires a lot more code. In the next section, we will write out the simplest
    version of a 2D sprite rendering WebGL app I can think of, which happens to be
    a new version of the 2D canvas app we wrote in the previous chapter. I think it
    is worthwhile to see the differences between the two methods of rendering 2D images
    to the HTML canvas. Knowing more about WebGL will also help us understand what
    is going on behind the scenes when we eventually use the SDL API in WebAssembly.
    I am going to try and keep the demonstration and code as simple as I possibly
    can while creating the WebGL JavaScript app.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在JavaScript中使用WebGL将一个简单的2D图像绘制到屏幕上需要更多的代码。在下一节中，我们将编写我能想到的最简单版本的2D精灵渲染WebGL应用程序，这恰好是我们在上一章中编写的2D画布应用程序的新版本。我认为值得看到两种方法在HTML画布上渲染2D图像之间的区别。了解更多关于WebGL的知识也将有助于我们理解当我们最终在WebAssembly中使用SDL
    API时发生了什么。在创建WebGL JavaScript应用程序时，我会尽量保持演示和代码的简单。
- en: As I mentioned previously, the point of this chapter is for you to get some
    hands-on experience with WebGL. For most of this book, we will not directly deal
    with WebGL, but rather use the simpler SDL API. If you are not interested in writing
    your own shaders, you can consider this chapter optional but beneficial information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，本章的目的是让您亲身体验WebGL。在本书的大部分内容中，我们不会直接处理WebGL，而是使用更简单的SDL API。如果您对编写自己的着色器不感兴趣，您可以将本章视为可选但有益的信息。
- en: In the next section, we will learn how to draw to the canvas with WebGL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用WebGL绘制到画布上。
- en: WebGL and JavaScript
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL和JavaScript
- en: As we learned in the previous chapter, working with the 2D canvas was pretty
    straightforward. To draw an image, you just need to translate the context to the
    pixel coordinates where you want to draw the image, and call the `drawImage` context
    function by passing in the image, its width, and its height. You could make this
    even simpler and forget about the translation passing the x and y coordinates
    directly into the `drawImage` function if you prefer. With the 2D canvas, you
    are working with images, but with WebGL, you are always working with 3D geometry,
    even when you are coding a 2D game. With WebGL, you will need to render textures
    onto geometry. You need to work with vertex buffers and texture coordinates. The
    vertex shader we wrote earlier takes 3D coordinate data and texture coordinates
    and passes those values onto a fragment shader that will interpolate between the
    geometry, and use a texture sampling function to retrieve the proper texture data
    to render pixels to the canvas.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，使用2D画布非常简单。要绘制图像，你只需要将上下文转换为要绘制图像的像素坐标，并调用`drawImage`上下文函数，传入图像、宽度和高度。如果你愿意，你甚至可以更简单地忘记转换，直接将x和y坐标传递到`drawImage`函数中。在2D画布中，你在使用图像，但在WebGL中，即使在编写2D游戏时，你总是在使用3D几何。在WebGL中，你需要将纹理渲染到几何体上。你需要使用顶点缓冲区和纹理坐标。我们之前编写的顶点着色器接收3D坐标数据和纹理坐标，并将这些值传递到片段着色器，后者将在几何体之间进行插值，并使用纹理采样函数来检索正确的纹理数据，以将像素渲染到画布上。
- en: WebGL coordinate system versus 2D canvas
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL坐标系统与2D画布
- en: 'With WebGL, the center of the canvas element is the origin point (0,0). **Positive
    Y** is up, whereas **Positive X** is to the right. This is a bit more intuitive
    for someone who has never worked with 2D graphics, as it is similar to quadrants
    in coordinate geometry, which we learned about in grade school. With the 2D canvas,
    you are always working with pixels, and there are no negative numbers that appear
    on the canvas:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebGL，画布元素的中心是原点(0,0)。**正Y**向上，而**正X**向右。对于从未使用过2D图形的人来说，这更直观一些，因为它类似于我们在小学学到的坐标几何中的象限。在2D画布中，你总是在使用像素，并且画布上不会出现负数。
- en: '![](img/4eec22e0-cd90-4ea2-9e50-e58c4ba7f9b3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4eec22e0-cd90-4ea2-9e50-e58c4ba7f9b3.png)'
- en: 'When you called `drawImage`, the X and Y coordinates were where the top left
    corner of the image would draw. WebGL is a bit different. Everything is using
    geometry, and both a vertex and a pixel shader are required. We convert the image
    into a texture and then stretch it over the geometry so that it''s displayed.
    Here is what the WebGL coordinate system looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`drawImage`时，X和Y坐标是图像的左上角绘制的位置。WebGL有点不同。一切都使用几何，需要顶点着色器和像素着色器。我们将图像转换为纹理，然后将其拉伸到几何上，以便显示。这是WebGL坐标系统的样子：
- en: '![](img/9e188d87-56e7-4899-baff-52a2cd299f30.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e188d87-56e7-4899-baff-52a2cd299f30.png)'
- en: 'If you want to place an image at a specific pixel location on the canvas, you
    have to know the width and height of your canvas. The **center point** of your
    canvas is **(0,0)**, the **Top left corner** is **(-1, 1)**, and the **Bottom
    right corner** is **(1, -1)**. So, if you want to place an image at x=150, y=160
    you need to use the following equation to find the WebGL x coordinate:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在画布上的特定像素位置放置图像，你需要知道画布的宽度和高度。你的画布的**中心点**是**(0,0)**，**左上角**是**(-1, 1)**，**右下角**是**(1,
    -1)**。因此，如果你想在x=150，y=160处放置图像，你需要使用以下方程来找到WebGL的x坐标：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, for a `pixel_x` position of 150, we have to subtract 400 from 150 to get
    -250\. Then, we have to divide -250 by 400, and we would get -0.625\. We have
    to do something similar to get the y coordinate for WebGL, but the sign of the
    axes are flipped, so instead of what we did for the `pixel_x` value, we need to
    do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`pixel_x`位置为150，我们需要从150减去400得到-250。然后，我们需要将-250除以400，我们会得到-0.625。我们需要做类似的事情来获取WebGL的y坐标，但是轴的符号是相反的，所以我们需要做以下操作来获取`pixel_x`值，而不是我们之前做的：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By plugging in the values, we get ((600 / 2) - 160) / (600 / 2) or (300 - 160)
    / 300 = 0.47.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过插入值，我们得到((600 / 2) - 160) / (600 / 2) 或 (300 - 160) / 300 = 0.47。
- en: 'I am skipping a lot of information about WebGL to simplify this explanation.
    WebGL is not a 2D space, even though I am treating it as a 2D space in this example.
    Because it is a 3D space, the size of the canvas in units is based on a view area
    known as clip space. Mozilla has an excellent article on clip space if you would
    like to learn more: [https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过了很多关于WebGL的信息，以简化这个解释。WebGL不是一个2D空间，即使在这个例子中我把它当作一个2D空间。因为它是一个3D空间，单位中画布的大小是基于一个称为裁剪空间的视图区域。如果你想了解更多，Mozilla有一篇关于裁剪空间的优秀文章：[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection)。
- en: Vertex and UV data
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点和UV数据
- en: 'Before we look at a large chunk of scary WebGL JavaScript code, I want to briefly
    discuss data buffers and how we are going to pass the geometry and texture coordinate
    data into the shaders. We will be passing in 32-bit floating point data in a large
    buffer that will contain a combination of the X and Y coordinates for the vertex
    and UV texture coordinates for that same vertex. UV mapping is the method by which
    your GPU maps 2D texture coordinates onto 3D geometry:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一大段可怕的WebGL JavaScript代码之前，我想简要讨论数据缓冲区以及我们将如何将几何和纹理坐标数据传递到着色器中。我们将在一个大缓冲区中传递32位浮点数据，该缓冲区将包含顶点的X和Y坐标的组合以及该顶点的UV纹理坐标。UV映射是GPU将2D纹理坐标映射到3D几何的方法：
- en: '![](img/8f2d81e2-1594-408e-85bc-6a01b00b9973.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f2d81e2-1594-408e-85bc-6a01b00b9973.png)'
- en: WebGL and OpenGL accomplish this by assigning a U and V coordinate to every
    vertex. A UV coordinate of (0,0) assigned to a vertex means that the vertex will
    be colored based on the color in the texture in the top left corner. A UV coordinate
    of (1,1) would imply that it would be painted based on what color is in the texture
    on the bottom right. As we interpolate between the points in our 3D object, we
    also interpolate between the different UV coordinates inside of the texture. Those
    UV coordinates can be sampled in our fragment shader using the `texture2D` built-in
    function by passing in the texture and the current UV coordinates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL和OpenGL通过为每个顶点分配U和V坐标来实现这一点。分配给顶点的UV坐标（0,0）意味着该顶点的颜色将基于纹理左上角的颜色。UV坐标（1,1）意味着它将根据纹理右下角的颜色进行着色。当我们在3D对象的点之间进行插值时，我们还在纹理内部的不同UV坐标之间进行插值。这些UV坐标可以在我们的片段着色器中使用`texture2D`内置函数进行采样，通过传入纹理和当前UV坐标。
- en: 'Let''s take a look at the vertex and texture data array that we are using inside
    of this WebGL app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们在这个WebGL应用程序中使用的顶点和纹理数据数组：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This data has been typed out in rows and columns. Even though this is a linear
    array of data, the formatting allows you to see that we have four floating-point
    values that will be passed in for each vertex. There is a comment above the data
    showing what each column represents. The first two data values are the X and Y
    coordinates of the geometry. The second two values are the U and V coordinates
    that map the texture to the X and Y coordinates in the geometry. There are six
    rows here, even though we are rendering a rectangle. The reason we need six points
    instead of just four is that the geometry used by WebGL typically consists of
    triangles. Because of this, we will need to repeat two of the vertices.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据已经按行和列输入。尽管这是一组线性数据，但格式允许您看到我们将为每个顶点传递四个浮点值。数据上方有一条注释，显示每列代表什么。前两个数据值是几何图形的X和Y坐标。接下来的两个值是将纹理映射到几何图形的X和Y坐标的U和V坐标。这里有六行，尽管我们正在渲染一个矩形。我们需要六个点而不是四个的原因是，WebGL通常使用三角形组成的几何图形。因此，我们需要重复两个顶点。
- en: You may be wondering, *why triangles?* Well, there was a time when computer
    graphics used geometry that was not decomposed into triangles. But a problem arises
    when you have a quad, and not all the points are coplanar (in the same plane).
    This is the same problem I have whenever I go to a bar that uses four-legged stools.
    I am pretty sure the existence of the four-legged stool is some sort of Illuminati
    plot to keep me off balance, but I digress. Because three points define a plane,
    a triangle is, by definition, always coplanar, just like a three-legged stool
    will never wobble.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想，*为什么是三角形？*嗯，曾经有一段时间，计算机图形使用的几何图形并不是分解成三角形的。但是当你有一个四边形，而不是所有的点都共面（在同一个平面上）时就会出现问题。这与我去使用四条腿凳子的酒吧时遇到的问题是一样的。我很确定四条腿凳子的存在是某种秘密组织的阴谋，目的是让我失去平衡，但我岔开了话题。因为三个点定义一个平面，所以三角形根据定义总是共面的，就像一个三条腿的凳子永远不会摇摆一样。
- en: 2D canvas to WebGL
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D画布到WebGL
- en: Let's begin by copying out canvas code from the `Chapter02` directory into the
    `Chapter03` directory. Next, we are going to rename the `canvas_shell.html` file
    to `webgl_shell.html`. We will rename `canvas.css` to `webgl.css`. Lastly, we
    will rename the `canvas.c` file `webgl.c`. We will also need to make sure that
    we copy over the `spaceship.png` file. We are not going to be changing the `webgl.css`
    file at all. We will make the most significant changes to the `webgl_shell.html`
    file. There is a lot of code that must be added to make the switch from 2D canvas
    to WebGL; almost all of it is additional JavaScript code. We will need to make
    some minor tweaks to `webgl.c` so that the ship's position in the `MoveShip` function
    reflects the WebGL coordinate system with its origin in the center of the canvas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Chapter02`目录中复制出画布代码到`Chapter03`目录中。接下来，我们将把`canvas_shell.html`文件重命名为`webgl_shell.html`。我们将把`canvas.css`重命名为`webgl.css`。最后，我们将把`canvas.c`文件重命名为`webgl.c`。我们还需要确保复制`spaceship.png`文件。我们不会对`webgl.css`文件进行任何更改。我们将对`webgl_shell.html`文件进行最重要的更改。有很多代码需要添加，以完成从2D画布到WebGL的切换；几乎所有的代码都是额外的JavaScript代码。我们需要对`webgl.c`进行一些微小的调整，以使`MoveShip`函数中飞船的位置反映出带有原点在画布中心的WebGL坐标系统。
- en: Before we begin, I would like to mention that this WebGL code is not meant to
    be production ready. The game we will be creating will not use WebGL in the way
    that I am demonstrating here. That is not the most efficient or scalable code.
    What we are writing will not be able to render more than one sprite at a time
    without significant changes. The reason I am walking you through what it takes
    to render 2D images using WebGL is to give you an idea of what is going on behind
    the scenes when you are using a library like SDL. If you do not care how things
    work behind the scenes, no one will fault you for skipping ahead. Personally,
    I always prefer knowing a little more.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想提一下，这个WebGL代码并不是为了投入生产。我们将要创建的游戏不会像我在这里演示的方式使用WebGL。那不是最有效或可扩展的代码。我们所编写的代码将无法在没有重大更改的情况下一次渲染多个精灵。我之所以向你演示使用WebGL渲染2D图像的过程，是为了让你了解在使用类似SDL这样的库时发生了什么。如果你不在乎幕后的工作原理，那么跳过也没人会责怪你。就我个人而言，我总是更愿意多了解一点。
- en: Minor tweaks to the head tag
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对head标签进行微小调整
- en: 'Inside of our `head` tag, we will want to change `title`, and because we renamed
    `canvas.css` to `webgl.css`, we will need to point our `link` tag to the new stylesheet
    name. Here are the only two tags that must change at the beginning of the HTML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`head`标签内，我们需要改变`title`，因为我们将`canvas.css`重命名为`webgl.css`，所以我们需要将我们的`link`标签指向新的样式表名称。以下是在HTML开头必须更改的唯一两个标签：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Later in the HTML, we will remove the `img` tag where the `src` is set to `"spaceship.png"`.
    It is not strictly necessary to do this. In the canvas version, we were using
    this tag to render an image to the canvas. In this WebGL version, we will load
    the image dynamically, so it is not necessary to keep it around, but if you forget
    to remove it, having it there will not harm the app in any way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在HTML中，我们将删除`img`标签，其中`src`设置为`"spaceship.png"`。这并不是必须的。在画布版本中，我们使用此标签将图像呈现到画布上。在这个WebGL版本中，我们将动态加载图像，因此没有必要保留它，但如果您忘记删除它，将不会以任何方式损害应用程序。
- en: Major JavaScript changes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要JavaScript更改
- en: 'The `Module` code inside of the JavaScript portion of the `webgl_shell.html`
    file will remain the same, so you do not have to worry about modifying anything
    after the following line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`webgl_shell.html`文件中JavaScript部分内的`Module`代码将保持不变，因此您无需担心在以下行之后修改任何内容：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, the top half of the code in the `script` tag is going to require some
    significant modifications. You may want to start fresh and delete the entire module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`script`标签中代码的前半部分将需要进行一些重大修改。您可能希望重新开始并删除整个模块。
- en: WebGL global variables
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebGL全局变量
- en: 'The first thing we are going to do is create a lot of JavaScript global variables.
    If this code were meant for more than demonstration, using this many global variables
    is generally frowned upon and considered bad practice. But for what we are doing
    right now, it helps simplify things:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建许多JavaScript全局变量。如果此代码不仅仅是用于演示，使用这么多全局变量通常是不受欢迎的，被认为是不良实践。但就我们现在所做的事情而言，它有助于简化事情：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first variable, `gl`, is the new version of the rendering context. Typically,
    if you are using a 2D rendering context, you call it `ctx`, and if you are using
    a WebGL rendering context, you name it `gl`. The second line defines the program
    variable. When we compile the vertex and fragment shaders, we get a compiled version
    in the form of a `WebGLProgram` object stored inside of this `program` variable.
    The `texture` variable will hold a `WebGLTexture` that we will be loading from
    the `spaceship.png` image file. That is the image that we used in the previous
    chapter for the 2D canvas tutorial. The `img` variable will be used to load the
    `spaceship.png` image file that will be used to load the texture. The canvas variable
    will once again be a reference to our HTML canvas element and `image_width`, and
    `image_height` will hold the height and width of the `spaceship.png` image once
    it is loaded.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量`gl`是渲染上下文的新版本。通常，如果您使用2D渲染上下文，您称之为`ctx`，如果您使用WebGL渲染上下文，您将其命名为`gl`。第二行定义了`program`变量。当我们编译顶点和片段着色器时，我们会得到一个编译后的版本，以`WebGLProgram`对象的形式存储在`program`变量中。`texture`变量将保存我们将从`spaceship.png`图像文件加载的`WebGLTexture`。这是我们在上一章中用于2D画布教程的图像。`img`变量将用于加载将用于加载纹理的`spaceship.png`图像文件。`canvas`变量将再次是对我们的HTML画布元素的引用，`image_width`和`image_height`将在加载后保存`spaceship.png`图像的高度和宽度。
- en: The `vertex_texture_buffer` attribute is a buffer that will be used to transfer
    vertex geometry and texture data to the GPU so that the shader we wrote in the
    previous section can use it. The `a_texcoord_location` and `a_position_location`
    variables will be used to hold references to the `a_texcoord` and `a_position`
    attribute variables in the vertex shader, and finally, `u_translate_location`
    and `u_texture_location` are used to reference the `u_translate` and `u_texture`
    uniform variables in the shader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertex_texture_buffer`属性是一个缓冲区，将用于将顶点几何和纹理数据传输到GPU，以便我们在上一节中编写的着色器可以使用它。`a_texcoord_location`和`a_position_location`变量将用于保存对顶点着色器中`a_texcoord`和`a_position`属性变量的引用，最后，`u_translate_location`和`u_texture_location`用于引用着色器中的`u_translate`和`u_texture`统一变量。'
- en: The return of vertex and texture data
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回顶点和纹理数据
- en: 'Would you be upset if I told you we had some more variables to discuss? Well,
    the next one is a variable we discussed earlier, but I will mention it again because
    it is important. The `vertex_texture_data` array is an array that stores all of
    the vertex geometry and UV texture coordinate data that are used for rendering:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你我们还有一些变量要讨论，你会不会不高兴？好吧，下一个变量是我们之前讨论过的变量，但我会再次提到它，因为它很重要。`vertex_texture_data`数组是一个存储用于渲染的所有顶点几何和UV纹理坐标数据的数组：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One thing I did not mention earlier is why the `x` and `y` values range from
    `-0.16` to `0.16` on the x-axis and `-0.213` to `0.213` on the y-axis. Because
    we are rendering a single image, we do not need to scale the geometry to fit the
    image dynamically. The spaceship image we are using is 128 x 128 pixels. The canvas
    size we are using is 800 x 600 pixels. As we discussed earlier, no matter what
    size we use for the canvas, WebGL fits both axes into a range from -1 to +1\.
    This makes the coordinate (0, 0) the center of the canvas element. It also means
    that the canvas width is always 2 and the canvas height is always 2, no matter
    how many pixels wide or high the canvas element is. So, if we want to figure out
    how wide we want our geometry to be to have it match the width of the image, we
    have to do some calculations. First, we need to figure out how many units of WebGL
    clip space width corresponds to one pixel. The WebGL clip space has a width of
    2.0, and the actual canvas has a width of 800 pixels, so the width of a single
    pixel in WebGL space is 2.0 / 800 = 0.0025\. We need to know how wide our image
    is in WebGL clip space, so we will multiply the 128 pixels by 0.0025 and get a
    WebGL clip space width of 0.32\. Because we would like to have the x value at
    the center of our geometry to be 0, we have our x geometry range from -0.16 to
    +0.16.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有提到的一件事是，为什么`x`和`y`值在x轴上的范围是`-0.16`到`0.16`，在y轴上的范围是`-0.213`到`0.213`。因为我们正在渲染一张单独的图像，我们不需要动态地缩放几何图形以适应图像。我们正在使用的太空船图像是128
    x 128像素。我们使用的画布大小是800 x 600像素。正如我们之前讨论的，无论我们为画布使用什么大小，WebGL都会将两个轴都适应到-1到+1的范围内。这使得坐标（0,
    0）成为画布元素的中心。这也意味着画布的宽度始终为2，高度始终为2，无论画布元素有多少像素宽或高。因此，如果我们想要计算出我们的几何图形有多宽，以使其与图像的宽度匹配，我们需要进行一些计算。首先，我们需要弄清楚WebGL剪辑空间宽度的一个单位对应于一个像素的宽度。WebGL剪辑空间的宽度为2.0，实际画布的宽度为800像素，因此在WebGL空间中一个像素的宽度为2.0
    / 800 = 0.0025。我们需要知道我们的图像在WebGL剪辑空间中有多宽，因此我们将128像素乘以0.0025，得到WebGL剪辑空间宽度为0.32。因为我们希望我们的几何图形的x值在中心为0，我们的x几何范围从-0.16到+0.16。
- en: Now that we have done the width, let's tackle the height. The height of the
    canvas is 600 pixels, but in WebGL clip space, the height of the canvas is always
    2.0 (-1.0 Y to +1.0 Y). So, how many WebGL units are in a single pixel? 2.0 /
    600 = 0.00333333…repeating. Obviously, this is an instance where floating-point
    precision is unable to match a real-world value. We are going to lop off some
    of those trailing 3s and hope that the precision is enough. Going back to figuring
    out the height of the image in WebGL clip space, it is 128-pixels high, so we
    need to multiply 128 by 0.0033333…repeating. The result is 0.4266666…repeating,
    which we will truncate to 0.426\. So, our y geometry must go from `-0.213` to
    `+0.213`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了宽度，让我们来解决高度。画布的高度为600像素，但在WebGL剪辑空间中，画布的高度始终为2.0（-1.0 Y到+1.0 Y）。因此，一个像素中有多少个WebGL单位？2.0
    / 600 = 0.00333333…重复。显然，这是一个浮点精度无法匹配实际值的情况。我们将截掉一些尾随的3，并希望精度足够。回到计算图像在WebGL剪辑空间中的高度，它高128像素，所以我们需要将128乘以0.0033333…重复。结果是0.4266666…重复，我们将截断为0.426。因此，我们的y几何必须从`-0.213`到`+0.213`。
- en: 'I am doing my best to ignore the complexity of the WebGL clip space. This is
    a 3D volume and not a simple 2D drawing area like the 2D canvas context. For more
    information on this topic, please consult the Mozilla developer docs for clip
    space: [https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#Clip_space](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#Clip_space).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在尽力忽略WebGL剪辑空间的复杂性。这是一个3D体积，而不是像2D画布上下文那样简单的2D绘图区域。有关此主题的更多信息，请参阅Mozilla开发人员文档的剪辑空间部分：[https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#Clip_space](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_model_view_projection#Clip_space)。
- en: As I said earlier, a lot of this will be managed for us by SDL when we work
    on our game, but in the future, you may wish to work with OpenGL in WebAssembly.
    The OpenGL ES 2.0 and OpenGL ES 3.0 libraries have been ported to WebAssembly,
    and those libraries more or less have direct analogs with WebGL. WebGL 1.0 is
    a modified version of OpenGL ES 2.0, which was a version of OpenGL that was designed
    to run on mobile hardware. WebGL 2.0 is a modified version of OpenGL ES 3.0\.
    Understanding what WebGL is doing through calls to SDL can make us better game
    developers, even if SDL is doing a lot of the heavy lifting for us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说的，当我们开发游戏时，SDL会为我们处理很多事情，但是在将来，您可能希望在WebAssembly中使用OpenGL。OpenGL ES 2.0和OpenGL
    ES 3.0库已经移植到WebAssembly，并且这些库或多或少地与WebGL具有直接的类比。WebGL 1.0是OpenGL ES 2.0的修改版本，它是设计用于在移动硬件上运行的OpenGL的一个版本。WebGL
    2.0是OpenGL ES 3.0的修改版本。通过对SDL的调用理解WebGL正在做什么，可以使我们成为更好的游戏开发人员，即使SDL为我们做了很多繁重的工作。
- en: Buffer constants
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区常量
- en: 'I have chosen to use a single `Float32Array` to hold all of the vertex data
    for this application. That includes the X and Y coordinate data, as well as U
    and V texture coordinate data. Because of this, we are going to need to tell WebGL
    how to separate this data into different attributes when we load this data into
    the GPU''s buffer. We will use the following constants to tell WebGL how the data
    in `Float32Array` is broken out:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用一个单独的`Float32Array`来保存此应用程序的所有顶点数据。这包括X和Y坐标数据，以及U和V纹理坐标数据。因此，当我们将这些数据加载到GPU的缓冲区中时，我们需要告诉WebGL如何将这些数据分开成不同的属性。我们将使用以下常量来告诉WebGL`Float32Array`中的数据是如何分解的：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `FLOAT32_BYTE_SIZE` constant is the size of each variable in `Float32Array`.
    The `STRIDE` constant will be used to tell WebGL how many bytes are used for the
    data of a single vertex. The four columns we defined in the previous code represent
    *x*, *y*, *u*, and *v*. Since each one of those variables uses four bytes of data,
    we will multiply the number of variables by the number of bytes that are used
    by each variable to get the *stride*, or how many bytes are used by a single vertex.
    The `XY_OFFSET` constant is the starting location inside of each stride where
    we will find the *x* and *y* coordinate data. For consistency, I multiplied the
    floating-point byte size by the position, but since it is `0`, we could have just
    used `const XY_OFFSET = 0`. Now, `UV_OFFSET` is the offset in bytes from the beginning
    of each stride where we will find the UV texture coordinate data. Since those
    are in positions 2 and 3, the offset is the number of bytes that's used for each
    variable, multiplied by `2`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`FLOAT32_BYTE_SIZE`常量是`Float32Array`中每个变量的大小。`STRIDE`常量将用于告诉WebGL单个顶点数据使用了多少字节。我们在前面的代码中定义的四列代表*x*、*y*、*u*和*v*。由于这些变量中的每一个使用了四个字节的数据，我们将变量的数量乘以每个变量使用的字节数来得到*stride*，或者单个顶点使用的字节数。`XY_OFFSET`常量是每个stride内的起始位置，我们将在那里找到*x*和*y*坐标数据。为了保持一致，我将浮点字节大小乘以位置，但由于它是`0`，我们可以直接使用`const
    XY_OFFSET = 0`。现在，`UV_OFFSET`是从每个stride开始的偏移量，我们将在那里找到UV纹理坐标数据。由于它们在位置2和3，偏移量是每个变量使用的字节数乘以`2`。'
- en: Defining the shaders
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义着色器
- en: 'I walked through everything that''s being done by the shaders in the previous
    section. You may want to go through that section again as a refresher. The next
    part of the code defines the vertex shader code and the fragment shader code in
    multiline JavaScript strings. Here is the vertex shader code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前一节中详细介绍了着色器所做的一切。你可能想再次浏览一下那一节作为复习。代码的下一部分定义了多行JavaScript字符串中的顶点着色器代码和片段着色器代码。以下是顶点着色器代码：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The fragment shader code is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器代码如下：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a look at the attribute in the vertex shader code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看顶点着色器代码中的属性：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Those two attributes will be passed in from the data in `Float32Array`. One
    of the neat tricks in WebGL is that if you are not using all four position variables
    (*x*,*y*,*z*,*w*), you can pass in the two you are using (*x*,*y*) and the GPU
    will know how to use appropriate values in the other two positions. These shaders
    will require passing in two attributes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性将从`Float32Array`中的数据中传递。在WebGL中的一个很棒的技巧是，如果你没有使用所有四个位置变量（*x*，*y*，*z*，*w*），你可以传递你正在使用的两个（*x*，*y*），GPU将知道如何在其他两个位置使用适当的值。这些着色器将需要传递两个属性：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once again, we will be doing this using buffers and `Float32Array`. We will
    also need to pass in two `uniform` variables. The `u_translate` variable will
    be used by the vertex shader to translate the position of the sprite, and `u_texture`
    is a texture buffer that will be used by the fragment shader. These shaders are
    almost as simple as they get. Many tutorials start you out without a texture and
    just hardcode the color output of the fragment shader, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用缓冲区和`Float32Array`来完成这个任务。我们还需要传递两个`uniform`变量。`u_translate`变量将被顶点着色器用于平移精灵的位置，`u_texture`是片段着色器将使用的纹理缓冲区。这些着色器几乎是尽可能简单的。许多教程都是从没有纹理开始，只是硬编码片段着色器的颜色输出，就像这样：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Making this change would cause the fragment shader to always output a red color,
    so please don't make this change. The only things I can think of that could have
    made this tutorial simpler are not loading the texture and rendering a solid color,
    and not allowing the geometry to be moved.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这个改变将导致片段着色器始终输出红色，所以请不要做这个改变。我能想到的唯一让这个教程更简单的事情是不加载纹理并渲染纯色，以及不允许几何体被移动。
- en: The ModuleLoaded function
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ModuleLoaded`函数'
- en: 'In the old 2D canvas code, we defined the `ShipPosition` JavaScript function
    before the `ModuleLoaded` function, but we have swapped these two functions for
    the WebGL demo. I felt it was better to explain the WebGL initialization before
    the rendering portion of the code. Here is the new version of the `ModuleLoaded`
    function in its entirety:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的2D画布代码中，我们在`ModuleLoaded`函数之前定义了`ShipPosition` JavaScript函数，但是我们已经将这两个函数互换了。我觉得在渲染部分之前解释WebGL初始化会更好。以下是`ModuleLoaded`函数的新版本：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first few lines get the `canvas` element and use that to get a WebGL context.
    If the JavaScript fails to get the WebGL context, we alert the user, letting them
    know they have a browser that does not support WebGL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行获取了`canvas`元素，并使用它来获取WebGL上下文。如果JavaScript未能获取WebGL上下文，我们会警告用户，让他们知道他们的浏览器不支持WebGL：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The two lines after that turn on alpha blending:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行打开了alpha混合：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compiling, loading, and linking the vertex and the fragment shader is a lot
    of challenging code. I am not sure why there is no function inside of the WebGL
    library that does all of this in one step. Almost everyone writing webgl for 2D
    to do this, and they either put it into a separate `.js` file, or they copy and
    paste it into their code for every project. For now, all you need to know about
    the following batch of code is that it is taking the vertex and fragment shader
    we wrote earlier and compiling it into the program variable. From that point on,
    we will be using the program variable to interact with the shaders. Here is the
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译、加载和链接顶点和片段着色器是一项具有挑战性的工作。我不确定为什么WebGL库中没有一个函数可以一步完成所有这些工作。几乎每个为2D编写webgl的人都要做到这一点，他们要么将其放入一个单独的`.js`文件中，要么将其复制粘贴到每个项目的代码中。目前，你需要知道关于下面的代码批处理的是，它正在将我们之前编写的顶点和片段着色器编译成程序变量。从那时起，我们将使用程序变量与着色器进行交互。以下是代码：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have the `WebGLProgram` object in our `program` variable, we can
    use that object to interact with our shaders.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`program`变量中有了`WebGLProgram`对象，我们可以使用该对象与我们的着色器进行交互。
- en: 'The first thing we are going to do is grab references to the `uniform` variables
    in our shader programs:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是获取我们着色器程序中的`uniform`变量的引用：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, we will use the `program` object to get references to the attribute
    variables that are used by our vertex shader:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将使用`program`对象来获取我们顶点着色器使用的属性变量的引用：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, it is time to start working with buffers. Do you remember when we created
    that `Float32Array` with all of our vertex data in it? It is time to use buffers
    to send that data to the GPU:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候开始使用缓冲区了。您还记得我们创建了包含所有顶点数据的`Float32Array`吗？现在是使用缓冲区将该数据发送到GPU的时候了：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first line creates a new buffer called `vertex_texture_buffer`. The line
    that starts with `gl.bindBuffer` binds `vertex_texture_buffer` to `ARRAY_BUFFER`,
    and then `bufferData` adds the data we had in `vertex_texture_data` to `ARRAY_BUFFER`.
    After that, we need to use the references to `a_position` and `a_texcoord` that
    we created earlier in the `a_position_location` and `a_texcoord_location` variables
    to tell WebGL where in this array buffer it will find the data for the `a_position`
    and `a_texcoord` attributes. The first thing it does is call `enableVertexAttribArray`
    to enable that attribute using the location variable we created. Next, `vertexAttribPointer`
    uses the `STRIDE` and `XY_OFFSET` or `UV_OFFSET` to tell WebGL where the attribute
    data is inside of the buffer data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个名为`vertex_texture_buffer`的新缓冲区。以`gl.bindBuffer`开头的行将`vertex_texture_buffer`绑定到`ARRAY_BUFFER`，然后`bufferData`将`vertex_texture_data`中的数据添加到`ARRAY_BUFFER`中。之后，我们需要使用之前在`a_position_location`和`a_texcoord_location`变量中创建的对`a_position`和`a_texcoord`的引用告诉WebGL在这个数组缓冲区中找到`a_position`和`a_texcoord`属性的数据。它首先调用`enableVertexAttribArray`来使用我们创建的位置变量启用该属性。接下来，`vertexAttribPointer`使用`STRIDE`和`XY_OFFSET`或`UV_OFFSET`告诉WebGL属性数据在缓冲区数据中的位置。
- en: 'After that, we will create and bind a texture buffer:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将创建并绑定纹理缓冲区：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have a bound texture buffer, we can configure that buffer for mirror
    wrapping and nearest neighbor interpolation when scaling:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个绑定的纹理缓冲区，我们可以在缩放时配置该缓冲区为镜像包裹和最近邻插值：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are using `gl.NEAREST` instead of `gl.LINEAR` because I would like the game
    to have an old-school pixelated look. In your game, you may prefer a different
    algorithm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`gl.NEAREST`而不是`gl.LINEAR`，因为我希望游戏具有老式的像素化外观。在您的游戏中，您可能更喜欢不同的算法。
- en: 'After configuring the texture buffer, we are going to download the `spaceship.png`
    image and load that image data into the texture buffer:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置纹理缓冲区后，我们将下载`spaceship.png`图像并将该图像数据加载到纹理缓冲区中：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final thing we will do is set the viewport to go from (0,0) to the canvas
    width and height. The viewport tells WebGL how the space in the canvas element
    will relate to our WebGL clip space:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的最后一件事是将视口设置为从（0,0）到画布的宽度和高度。视口告诉WebGL画布元素中的空间如何与我们的WebGL裁剪空间相关联：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The ShipPosition function
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ShipPosition函数
- en: 'If this were production quality code, I would be doing a lot of the work that
    I am currently doing inside of the initialization routine in this rendering function.
    Moving sprites around independently on the canvas would require updates to our
    array buffers. I probably wouldn''t define my geometry in the way I did, that
    is, calculating the sizes by hand. I am not currently making any changes to the
    array buffer or the texture buffer; I am trying to keep this code to the bare
    minimum necessary to render a sprite onto the canvas using WebGL. Here is what
    I have:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是生产质量的代码，我将在渲染函数中执行目前在初始化例程中执行的大部分工作。在画布上独立移动精灵将需要更新我们的数组缓冲区。我可能不会以我所做的方式定义几何形状，也就是手动计算大小。我目前没有对数组缓冲区或纹理缓冲区进行任何更改；我试图保持这段代码尽可能少，以便使用WebGL将精灵渲染到画布上。这是我拥有的内容：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The first few lines check to see whether the image download has completed.
    If not, we will exit out of this function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前几行检查图像下载是否已完成。如果没有，我们将退出该函数：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we tell WebGL to load the uniform `u_translate` uniform variable with
    our spaceship''s coordinates:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们告诉WebGL使用我们飞船坐标加载`u_translate`统一变量：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we instruct WebGL to draw triangles with the six vertices in our array
    buffer:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们指示WebGL使用数组缓冲区中的六个顶点绘制三角形：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The MoveShip function
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MoveShip函数
- en: 'We are going to need to jump back into the WebAssembly C module. The `webgl.c`
    file is a copied version of `canvas.c` where the only changes we need to make
    are inside of the `MoveShip` function. Here is the new version of `MoveShip`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回到WebAssembly C模块。`webgl.c`文件是`canvas.c`的复制版本，我们需要做的唯一更改是在`MoveShip`函数内部。这是`MoveShip`的新版本：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The changes are all conversions from pixel space into WebGL clip space. In
    the 2D canvas version, we were adding two pixels to the ship''s `x` coordinate
    and one pixel to the ship''s `y` coordinate every frame. But in WebGL, moving
    the `x` coordinate by two would be moving it by the entire width of the screen.
    So, instead, we have to modify these values into small units that would work with
    the WebGL coordinate system:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更改都是从像素空间转换为WebGL裁剪空间。在2D画布版本中，我们每帧将两个像素添加到飞船的`x`坐标和一个像素添加到飞船的`y`坐标。但是在WebGL中，将`x`坐标移动两个像素将使其移动整个屏幕的宽度。因此，我们必须将这些值修改为与WebGL坐标系统兼容的小单位：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Adding `0.002` to the `x` coordinate moves the ship by 1/500th of the width
    of the canvas each frame. Moving the `y` coordinate by `0.001` moves the ship
    on the y-axis by 1/1,000th of the height of the screen each frame. You may notice
    that in the 2D canvas version of this app, the ship was moving to the right and
    down. That was because increasing the `y` coordinate in the 2D canvas coordinate
    system moves an image down the screen. In the WebGL coordinate system, the ship
    moves up. The only other thing we have to do is change the coordinates at which
    the ship wrapped its `x` and `y` coordinates to WebGL clip space:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将`0.002`添加到`x`坐标会使飞船每帧移动画布宽度的1/500。将`y`坐标移动`0.001`会使飞船在y轴上每帧移动屏幕高度的1/1,000。你可能会注意到，在这个应用程序的2D画布版本中，飞船向右下方移动。这是因为在2D画布坐标系统中增加`y`坐标会使图像向下移动。在WebGL坐标系统中，飞船向上移动。我们唯一需要做的另一件事就是改变飞船包裹其`x`和`y`坐标的坐标，以适应WebGL剪辑空间：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we have all of our source code, go ahead and run `emcc` to compile
    our new `webgl.html` file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有的源代码，继续运行`emcc`来编译我们的新`webgl.html`文件。
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once you have `webgl.html` compiled, load it into a web browser. It should
    look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编译了`webgl.html`，将其加载到Web浏览器中。它应该看起来像这样：
- en: '![](img/bb758221-c27c-49c3-9aef-70052e0c0fff.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb758221-c27c-49c3-9aef-70052e0c0fff.png)'
- en: 'Figure 3.1: Screenshot of our WebGL app'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：我们的WebGL应用程序的屏幕截图
- en: It is important to remember that the app must be run from a web server, or using
    `emrun`. If you do not run the app from a web server, or use `emrun`, you will
    receive a variety of errors when the JavaScript glue code attempts to download
    the WASM and data files. You should also know that IIS requires additional configuration
    in order to set the proper MIME types for the `.wasm` and `.data` file extensions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，应用程序必须从Web服务器上运行，或者使用`emrun`。如果你不从Web服务器上运行应用程序，或者使用`emrun`，当JavaScript粘合代码尝试下载WASM和数据文件时，你将会收到各种错误。你还应该知道，IIS需要额外的配置才能为`.wasm`和`.data`文件扩展名设置正确的MIME类型。
- en: Now that we have all of this working in WebGL, in the next chapter, I will talk
    about how much easier all of this would have been if we just did it using SDL
    in the first place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在WebGL中完成了所有这些工作，下一章中，我将谈论如果一开始就使用SDL，所有这些工作将会更容易。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed WebGL and how it can improve performance
    in web games. I have introduced you to the concept of GLSL shaders and talked
    about vertex shaders and fragment shaders, what the differences between the two
    types of shaders are, and how they are used to render a combination of geometry
    and images to the HTML5 canvas.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了WebGL以及它如何提高网络游戏的性能。我向你介绍了GLSL着色器的概念，并讨论了顶点着色器和片段着色器，这两种着色器之间的区别，以及它们如何用于将几何图形和图像渲染到HTML5画布上。
- en: We also recreated the moving spaceship that we created with the 2D canvas using
    WebGL. We have discussed how to use vertex geometry to render 2D images to a 3D
    canvas. We also talked about the differences between the pixel-based 2D canvas
    coordinate system and the 3D WebGL coordinate system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用WebGL重新创建了我们在2D画布上创建的移动飞船。我们讨论了如何使用顶点几何来将2D图像渲染到3D画布上。我们还讨论了基于像素的2D画布坐标系统和3D
    WebGL坐标系统之间的区别。
- en: WebGL is a broad topic to cover, so a single chapter can only give a very cursory
    introduction at best. WebGL is a 3D rendering space, and in this chapter, I went
    out of my way to ignore that and treat it like a 2D space. You could take what
    we have done here and build on it, but to improve the performance of our application,
    we will be using the WebAssembly SDL API for all of our interactions with WebGL
    in the future. If you would like to learn more about WebGL, Packt has a large
    selection of books devoted entirely to WebGL at [https://search.packtpub.com/?query=webgl](https://search.packtpub.com/?query=webgl).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL是一个广泛的主题，因此单独一章只能给出一个非常粗略的介绍。WebGL是一个3D渲染空间，在这一章中，我刻意忽略了这一点，将其视为2D空间。你可以在我们所做的基础上进行扩展，但为了提高应用程序的性能，我们将来使用WebAssembly
    SDL API与WebGL进行所有交互。如果你想了解更多关于WebGL的知识，Packt有大量专门致力于WebGL的图书可供查阅[https://search.packtpub.com/?query=webgl](https://search.packtpub.com/?query=webgl)。
- en: In the next chapter, I will teach you the basics of SDL, what it is, and how
    it works with WebAssembly. We will also learn how to render a sprite to the HTML5
    canvas using SDL, animate it, and move it around the canvas.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将教你SDL的基础知识，它是什么，以及它如何与WebAssembly一起工作。我们还将学习如何使用SDL将精灵渲染到HTML5画布上，对其进行动画处理，并在画布上移动它。
