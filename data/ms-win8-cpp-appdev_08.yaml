- en: Chapter 8. Contracts and Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。合同和扩展
- en: Windows Store applications run in a tight sandbox known as **AppContainer**.
    This container does not allow applications to communicate directly with other
    applications on the machine (such as Win32 kernel object handles and shared memory).
    This makes sense in a way, because an app can't assume anything about the computing
    environment in which it's installed from the Store, except for the CPU architecture
    and capabilities that were requested by the app. There's no way to know for sure
    that an app exists, for instance, and even if there was a way, there's no good
    way to make sure it can actually talk to this app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Store应用程序在一个称为**AppContainer**的严格沙箱中运行。该容器不允许应用程序直接与机器上的其他应用程序通信（例如Win32内核对象句柄和共享内存）。从某种意义上讲，这是有道理的，因为应用程序不能假设安装自商店的计算环境的任何内容，除了应用程序请求的CPU架构和功能。没有办法确切地知道应用程序是否存在，即使有办法，也没有好的方法来确保它实际上可以与这个应用程序通信。
- en: Instead, Windows defines a set of contracts for app to app communication. Such
    contracts allow applications to implement some functionality without knowing which
    other app is going to use it. The contracts are well defined, and with the help
    of the operating system to make the necessary connections, they allow apps to
    communicate indirectly. We'll examine some of the common contracts in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Windows为应用程序之间的通信定义了一组合同。这些合同允许应用程序实现一些功能，而不知道将使用它的其他应用程序是哪个。这些合同是明确定义的，并且在操作系统的帮助下进行必要的连接，它们允许应用程序间接通信。我们将在本章中研究一些常见的合同。
- en: Applications can also provide "plugins" into some of the operating system's
    provided functionality. These "plugins" are called extensions, and we'll take
    a look at one of them, the Settings extension.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序还可以为操作系统提供的某些功能提供“插件”。这些“插件”称为扩展，我们将看一下其中的一个，即设置扩展。
- en: Capabilities
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能
- en: Windows Store apps cannot directly communicate with other apps, but what about
    the system itself? What about files, folders, or devices? It turns out that, by
    default, these are also restricted, and must be given permission by the user at
    the application install time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Store应用程序不能直接与其他应用程序通信，但是系统本身呢？文件、文件夹或设备呢？事实证明，默认情况下，这些也受到限制，必须在应用程序安装时由用户授予权限。
- en: 'Applications must declare all intended system usage that is defined by Windows,
    as something the user must agree to. These are **capabilities** , and are part
    of the application manifest. Visual Studio provides a graphical view of capabilities
    in its manifest view which we have already used in previous chapters:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须声明所有由Windows定义的预期系统使用，作为用户必须同意的内容。这些是**功能**，是应用程序清单的一部分。Visual Studio在其清单视图中提供了功能的图形视图，我们在之前的章节中已经使用过：
- en: '![Capabilities](img/5022_08_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![功能](img/5022_08_01.jpg)'
- en: 'The image shows all currently supported capabilities. By default, just one
    capability is enabled: the ability to make outbound network calls.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图像显示了当前支持的所有功能。默认情况下，只启用了一个功能：进行出站网络调用的能力。
- en: Accessing the user's "My" libraries (documents, pictures, videos, and music)
    must be explicitly requested, otherwise an "access denied" exception will be thrown
    upon access; the Documents library also demands the app specifies which file types
    it accepts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 必须明确请求访问用户的“我的”库（文档、图片、视频和音乐），否则在访问时将抛出“访问被拒绝”的异常；文档库还要求应用程序指定其接受的文件类型。
- en: Device access is naturally an issue, represented by capabilities such as **Microphone**,
    **Webcam**, **Location**, and **Proximity**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设备访问自然是一个问题，由**麦克风**、**网络摄像头**、**位置**和**接近度**等功能表示。
- en: Note, that there is no capability that can grant an application access to Windows
    system folders, such as `Program Files`, `System32`, and so on; this is simply
    beyond a Windows Store app—and so it should be. No app should need such high privilege
    access.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有能够授予应用程序访问Windows系统文件夹（如`Program Files`、`System32`等）的功能；这对于Windows Store应用程序来说是不可能的，也应该是如此。没有应用程序需要这样高权限的访问。
- en: Contracts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同
- en: Contracts are defined by Windows for app to app communication; it's a kind of
    agreement between apps, mediated by the operating system, that allows apps to
    communicate indirectly. Let's look at two common examples of contracts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 合同由Windows为应用程序之间的通信定义；这是一种由操作系统调解的应用程序之间的协议，允许应用程序间接通信。让我们看看两个常见合同的例子。
- en: Share contract
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享合同
- en: The **share contract** operates between an app that is a **share source** (has
    something to share) and a **share target** app (that wants to do something with
    the shared data). An application can be a share source, a share target, or both.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享合同**在一个是**共享源**（有东西可以共享）的应用程序和一个**共享目标**应用程序（想要对共享的数据进行操作）之间运作。一个应用程序可以是共享源、共享目标，或者两者兼有。'
- en: Sharing is usually initiated by using the Share charm. When activated from a
    share source app, a list of possible target apps is provided by Windows—all the
    installed apps that implement the share target contract, and accept at least one
    of the data types provided by the source. Let's see how to create a share source
    and a share target.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过使用共享魅力来启动共享。当从共享源应用程序激活时，Windows会提供一个可能的目标应用程序列表——所有实现共享目标合同并至少接受源提供的一种数据类型的安装应用程序。让我们看看如何创建共享源和共享目标。
- en: Share source
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分享源
- en: Becoming a share source is easier than being a share target. A share source
    needs to notify Windows of any potential data it can provide. Most of the work
    required for share resides in the `Windows::ApplicationMode::DataTransfer` namespace.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 成为共享源比成为共享目标更容易。共享源需要通知Windows它可以提供任何潜在数据。共享所需的大部分工作都在`Windows::ApplicationMode::DataTransfer`命名空间中。
- en: 'A share source must register for the `DataTransferManager::DataRequested` event
    when the application or the main page initializes, with code such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 共享源在应用程序或主页面初始化时必须注册`DataTransferManager::DataRequested`事件，代码如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code registers the `OnDataRequested` private method as the handler that
    is invoked by the Share Broker Windows component that manages the sharing operation.
    When the method is called, the application needs to provide the data. Here''s
    a simple app that shows the flags of the world:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将`OnDataRequested`私有方法注册为由管理共享操作的共享代理Windows组件调用的处理程序。当调用该方法时，应用程序需要提供数据。以下是一个显示世界国旗的简单应用程序：
- en: '![Share source](img/5022_08_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![共享源](img/5022_08_02.jpg)'
- en: 'This app wants to share a selected flag image and some text, being the name
    of the selected country. The `OnDataRequested` method is implemented as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序想要共享一个选定的国旗图像和一些文本，即选定国家的名称。`OnDataRequested`方法实现如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing the method does is check whether any flag is selected (`_gridFlags`
    is a `GridView` holding all flags). If nothing is selected then the method simply
    exits. If the user tries to share when nothing is selected, Windows displays a
    message, **There's nothing to share right now**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的第一件事是检查是否选定了任何国旗（`_gridFlags`是一个包含所有国旗的`GridView`）。如果没有选定任何内容，则该方法简单地退出。如果用户在没有选定任何内容时尝试共享，Windows会显示消息**现在没有可共享的内容**。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s possible to set another text line to indicate to the user the exact reason
    why sharing was unavailable. Here''s an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置另一行文本来向用户指示共享不可用的确切原因。以下是一个示例：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `DataRequestedEventArgs` has a single property (`Request`, of type `DataRequest`),
    which has a `Data` property (a `DataPackage` object), that's used to fill in sharing
    data. In the preceding code snippet, a string is set with the `DataPackage::SetText`
    method. Next, `DataPackage::SetBitmap` is used to set an image (with the helper
    `RandomAccessStreamReference` class).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataRequestedEventArgs`有一个属性（`Request`，类型为`DataRequest`），它有一个`Data`属性（一个`DataPackage`对象），用于填充共享数据。在前面的代码片段中，使用`DataPackage::SetText`方法设置了一个字符串。接下来，使用`DataPackage::SetBitmap`设置了一个图像（使用辅助类`RandomAccessStreamReference`）。'
- en: A package also contains a bunch of properties that can be set, of which `Title`
    is the only one that's required. The example sets the thumbnail to the same flag
    image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包还包含一堆可以设置的属性，其中`Title`是唯一必需的。该示例将缩略图设置为相同的国旗图像。
- en: Other formats are acceptable by the `DataPackage`, with methods such as `SetHtmlFormat`,
    `SetUri`, `SetRtf`, and `SetStorageItems` (sharing of files/folders).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataPackage`还可以接受其他格式，例如`SetHtmlFormat`、`SetUri`、`SetRtf`和`SetStorageItems`（共享文件/文件夹）的方法。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Another method, `SetDataProvider`, allows the app to register a delegate that
    will be queried when the data is actually needed, and not before that. This may
    be useful if obtaining the data is expensive, and should only be done if actually
    needed; also, it provides a way to share custom data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法`SetDataProvider`允许应用程序注册一个委托，当数据实际需要时将对其进行查询，而不是在之前。如果获取数据很昂贵，并且只有在实际需要时才应该进行；此外，它提供了一种共享自定义数据的方式。
- en: Once the method completes, the data is available to a share target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦方法完成，数据就可以提供给共享目标。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`DataRequest` has a `GetDeferral` method that allows the app to make asynchronous
    calls without the sharing broker considering the data ready when the method returns
    (a similar mechanism to the one we''ve seen for background tasks). Calling `DataRequestDeferral::Complete`
    signals the actual readiness of the data to be shared.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataRequest`有一个`GetDeferral`方法，允许应用程序进行异步调用，而在方法返回时共享代理不会认为数据已准备就绪（类似于我们在后台任务中看到的机制）。调用`DataRequestDeferral::Complete`表示数据实际准备好可以共享了。'
- en: Share target
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享目标
- en: Becoming a share target is more difficult than a share source. One reason for
    this, is that the share target application may not be running when sharing is
    requested. This means the system must know beforehand which applications are capable
    of being share targets and what kind of data these applications can receive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 成为共享目标比共享源更困难。其中一个原因是，共享目标应用程序在请求共享时可能尚未运行。这意味着系统必须事先知道哪些应用程序能够成为共享目标，以及这些应用程序可以接收什么类型的数据。
- en: 'The first step in becoming a share target is declaring in the application manifest
    that the app is, in fact, a share target, and specifying the kinds of data it''s
    willing to accept. Here''s a screenshot of the manifest showing an application
    that is willing to receive bitmaps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 成为共享目标的第一步是在应用程序清单中声明应用程序实际上是一个共享目标，并指定它愿意接受的数据类型。以下是清单的屏幕截图，显示了一个愿意接收位图的应用程序：
- en: '![Share target](img/5022_08_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![共享目标](img/5022_08_03.jpg)'
- en: A share target app must support at least one data format (**Bitmap** in this
    example), or at least one file type (such as `.doc`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 共享目标应用程序必须支持至少一种数据格式（在本例中为**位图**），或者至少一种文件类型（如`.doc`）。
- en: 'Here''s how this app appears in the share pane when a flag is selected:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当选定国旗时，这个应用程序在共享窗格中的显示如下：
- en: '![Share target](img/5022_08_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![共享目标](img/5022_08_04.jpg)'
- en: The application named **ShareTargetDemo** is part of the downloadable code for
    this chapter, which is a simple image viewer for the Pictures library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 名为**ShareTargetDemo**的应用程序是本章可下载代码的一部分，它是图片库的一个简单图像查看器。
- en: Once the user selects our application, it's activated (executed) if not already
    in memory. The system calls the virtual method `Application::OnShareTargetActivated`.
    This method indicates the app is being activated as a share target, and must respond
    appropriately.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择我们的应用程序，如果尚未在内存中，则会被激活（执行）。系统调用虚拟方法`Application::OnShareTargetActivated`。该方法指示应用程序正在作为共享目标激活，并且必须做出适当响应。
- en: Specifically, the application must provide some user interface for the share
    pane, indicating what data it's about to consume and provide some button control
    to allow the user to actually confirm the share.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，应用程序必须为共享窗格提供一些用户界面，指示它即将使用的数据，并提供一些按钮控件，允许用户实际确认共享。
- en: 'Here''s a simple share page UI that allows for some text labels, an image,
    and a **Share** button:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的共享页面UI，允许一些文本标签、一个图像和一个**共享**按钮：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The bindings expect a relevant `ViewModel` to use, which is defined like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定期望使用相关的`ViewModel`，定义如下：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The target app in this case is willing to accept images. The `Image` element
    would show a preview of the image to accept. Once the user clicks the **Share**
    button, the sharing operation is executed and the entire sharing operation is
    deemed complete.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目标应用程序愿意接受图像。`Image`元素将显示要接受的图像的预览。一旦用户点击**共享**按钮，共享操作就会执行，整个共享操作被视为完成。
- en: 'The `Application::OnShareTargetActivated` override is responsible for activating
    the share page UI:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application::OnShareTargetActivated`重写负责激活共享页面UI：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`SharePage` is the class holding the share UI defined previously. The `Activate`
    method is an application-defined method that should extract the sharing information
    and initialize the UI as appropriate:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharePage`是之前定义的共享UI的类。`Activate`方法是一个应用程序定义的方法，应该提取共享信息并根据需要初始化UI：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing to do is to save the operation object for later use when the
    **Share** button is clicked (`_operation` is a field of type `ShareOperation`
    located in the `Windows::ApplicationModel::DataTransfer::ShareTarget` namespace).
    The sharing data itself is in the `ShareOperation::Data` property (a `DataPackageView`
    object, similar to a `DataPackage` object on the share source side, but a read-only
    view of that data).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要做的第一件事是在单击**共享**按钮时保存操作对象以供以后使用（`_operation`是`Windows::ApplicationModel::DataTransfer::ShareTarget`命名空间中的`ShareOperation`类型的字段）。共享数据本身位于`ShareOperation::Data`属性中（类似于共享源端的`DataPackage`对象，但是该数据的只读视图）。
- en: Next, the required information is extracted from the data object and placed
    in the `ShareViewModel` instance. If a thumbnail is provided, it's extracted by
    opening the `RandomAccessStreamReference` object and using a `BitmapImage` to
    load the image before placing it into the `ImageSource` used by the `ShareViewModel`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从数据对象中提取所需的信息，并将其放入`ShareViewModel`实例中。如果提供了缩略图，可以通过打开`RandomAccessStreamReference`对象并使用`BitmapImage`加载图像来提取它，然后将其放入`ShareViewModel`使用的`ImageSource`中。
- en: 'Finally, the `DataContext` is set to the `ShareViewModel` instance and the
    page is made the current window content before actual activation. Here''s how
    this looks when the share source is the flags application (China''s flag is selected
    before sharing):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`DataContext`设置为`ShareViewModel`实例，并在实际激活之前将页面设置为当前窗口内容。当共享源是标志应用程序（在共享之前选择了中国的标志）时，情况如下：
- en: '![Share target](img/5022_08_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![共享目标](img/5022_08_05.jpg)'
- en: Now, the user can interact with the sharing pane. If closed, nothing happens
    and the target application is terminated, if it wasn't running prior to share
    activation. If, on the other hand, the user decides to do the actual share (by
    clicking the **Share** button), the application needs to do whatever is appropriate
    for such a case. For example, the built-in Mail application shows a new e-mail
    UI that adds the shared data (typically text) to an empty e-mail that can be sent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以与共享窗格交互。如果关闭，将不会发生任何事情，并且目标应用程序将被终止，如果在共享激活之前未运行。另一方面，如果用户决定执行实际共享（通过单击**共享**按钮），应用程序需要执行适当的操作。例如，内置的邮件应用程序会显示一个新的电子邮件UI，将共享的数据（通常是文本）添加到可以发送的空电子邮件中。
- en: 'Our sharing target app wants to save the provided image to the Pictures library
    for the current user. Here''s the `Click` handler for the **Share** button for
    this app:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的共享目标应用程序希望将提供的图像保存到当前用户的图片库中。以下是此应用程序的**共享**按钮的`Click`处理程序：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code may seem complex, because it attempts to save the provided image to
    a file, and because most of the operations are asynchronous, several tasks are
    involved to make sure the operations are performed in the right order. Here''s
    a quick rundown of the performed operations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来很复杂，因为它试图将提供的图像保存到文件中，并且因为大多数操作都是异步的，所以涉及多个任务以确保操作按正确顺序执行。以下是执行的操作的快速摘要：
- en: A check is made to make sure the data package indeed includes a bitmap; this
    is somewhat redundant in this case, as the application has indicated in the manifest
    that bitmaps is the only supported data. Still, this check may be useful in more
    complex scenarios.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查确保数据包确实包含位图；在这种情况下有些多余，因为应用程序在清单中指示位图是唯一支持的数据。但在更复杂的情况下，这种检查可能会有用。
- en: The bitmap is extracted using `DataPackageView::GetBitmapAsync`, returning a
    `RandomAccessStreamReference` object.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DataPackageView::GetBitmapAsync`提取位图，返回一个`RandomAccessStreamReference`对象。
- en: '`RandomAccessStreamReference::OpenReadAsync` is called to get the image data
    as an `IRandomAccessStream` object. This object is used to instantiate a `BitmapDecoder`
    object that is capable of decoding the image bits, by calling the static factory
    method `BitmapDecoder::CreateAsync`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`RandomAccessStreamReference::OpenReadAsync`以获取图像数据作为`IRandomAccessStream`对象。使用此对象来实例化一个`BitmapDecoder`对象，该对象能够通过调用静态工厂方法`BitmapDecoder::CreateAsync`来解码图像位。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `BitmapDecoder` and `BitmapEncoder` types are located in the `Windows::Graphics::Imaging`
    namespace. The factory method that creates the `BitmapDecoder` automatically identifies
    the stored bitmap format.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapDecoder`和`BitmapEncoder`类型位于`Windows::Graphics::Imaging`命名空间中。创建`BitmapDecoder`的工厂方法会自动识别存储的位图格式。'
- en: Once the resulting decoder is obtained, a new file is created named `SharedImage.jpg`
    in the Pictures library (`KnownFolders::PicturesLibrary` returns a `StorageFolder`).
    Then the file is opened for read/write access.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦获得了结果解码器，就在图片库中创建一个名为`SharedImage.jpg`的新文件（`KnownFolders::PicturesLibrary`返回一个`StorageFolder`）。然后打开文件以进行读/写访问。
- en: A `BitmapEncoder` is created based on the decoder information (`BitmapEncoder::CreateForTranscodingAsync`)
    and the image saving is completed by the call to `BitmapEncoder::FlushAsync`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于解码器信息创建`BitmapEncoder`（`BitmapEncoder::CreateForTranscodingAsync`），并通过调用`BitmapEncoder::FlushAsync`完成图像保存。
- en: The last thing to do (for any sharing operation) is to indicate to the system
    that the operation is complete by calling `ShareOperation::ReportComplete`.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后要做的事情（对于任何共享操作）是通过调用`ShareOperation::ReportComplete`来向系统指示操作已完成。
- en: Sharing files
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享文件
- en: Text, URLs, and images are not the only things that applications can share.
    Files can be shared as well, by calling the `DataPackage::SetStorageItems` from
    a source sharing app. These storage items can actually be files or folders (based
    on the `IStorageItem` interface).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 文本、URL 和图片并不是应用程序可以共享的唯一内容。文件也可以通过从源共享应用程序调用 `DataPackage::SetStorageItems`
    来共享。这些存储项实际上可以是文件或文件夹（基于 `IStorageItem` 接口）。
- en: On the share target side, the storage items are available using the `DataPackageView::GetStorageItemsAsync`
    method, returning a read-only collection (`IVectorView`) of `IStorageItem` objects.
    The app can then access these files/folders in any way that's appropriate for
    the app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享目标方面，可以使用 `DataPackageView::GetStorageItemsAsync` 方法来获取存储项，返回一个只读集合（`IVectorView`）的
    `IStorageItem` 对象。然后应用程序可以以适合应用程序的任何方式访问这些文件/文件夹。
- en: Sharing page UI generation
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享页面 UI 生成
- en: 'Visual Studio provides a default page template for a share target operation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 为共享目标操作提供了默认的页面模板。
- en: '![Sharing page UI generation](img/5022_08_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Sharing page UI generation](img/5022_08_06.jpg)'
- en: This adds a default UI for sharing, including a default `ViewModel` for data
    binding.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这为共享添加了默认的 UI，包括用于数据绑定的默认 `ViewModel`。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the app project was created with the "Blank App" template, Visual Studio
    will add some helper classes that exist in other project templates, such as `SuspensionManager`,
    `LayoutAwarePage`, and so on because the share page it creates derives from `LayoutAwarePage`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序项目是使用“空白应用程序”模板创建的，Visual Studio 将添加一些辅助类，这些辅助类存在于其他项目模板中，例如 `SuspensionManager`、`LayoutAwarePage`
    等，因为它创建的共享页面派生自 `LayoutAwarePage`。
- en: FileOpenPicker contract
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileOpenPicker 合同
- en: 'The `FileOpenPicker` class is used to pick a file from the filesystem—that''s
    pretty obvious; what''s not so obvious is that this same `FileOpenPicker` can
    be used to get a file from any application supporting the `FileOpenPicker` contract.
    When an application calls `FileOpenPicker::PickSingleFileAsync` or `PickMultipleFilesAsync`,
    a hosting process running the image `PickerHost.exe` is launched, where the `FileOpenPicker`
    is created. Besides the list of folders and files we can see applications:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileOpenPicker` 类用于从文件系统中选择文件——这是相当明显的；不那么明显的是，这个相同的 `FileOpenPicker` 可以用于从支持
    `FileOpenPicker` 合同的任何应用程序获取文件。当应用程序调用 `FileOpenPicker::PickSingleFileAsync` 或
    `PickMultipleFilesAsync` 时，将启动运行图像 `PickerHost.exe` 的托管进程，其中创建了 `FileOpenPicker`。除了我们可以看到的文件夹和文件列表外，还有应用程序：'
- en: '![FileOpenPicker contract](img/5022_08_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![FileOpenPicker contract](img/5022_08_07.jpg)'
- en: The listed applications (**Bing**, **Camera**, and so on) are implementing the
    `FileOpenPicker` contract, so they can be contacted to get back a file. For example,
    SkyDrive allows browsing through the user's files and selecting a file or files
    to download. The Camera application provides a user interface that allows taking
    a picture right here and now with some camera connected, or embedded, in the device,
    returning the resulting image file to the calling application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的应用程序（**Bing**、**Camera** 等）都实现了 `FileOpenPicker` 合同，因此可以联系它们以获取文件。例如，SkyDrive
    允许浏览用户的文件并选择要下载的文件。相机应用程序提供了一个用户界面，允许在此处立即使用连接的相机拍照，或者在设备中嵌入拍摄，将生成的图像文件返回给调用应用程序。
- en: Implementing a FileOpenPicker contract
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 FileOpenPicker 合同
- en: 'The first step in implementing the `FileOpenPicker` contract is to declare
    this in the app manifest. This is required, as the implementing app may not be
    running at the time a `FileOpenPicker` is opened from some other app:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `FileOpenPicker` 合同的第一步是在应用清单中声明这一点。这是必需的，因为实现应用程序可能在从其他应用程序打开 `FileOpenPicker`
    时不在运行：
- en: '![Implementing a FileOpenPicker contract](img/5022_08_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Implementing a FileOpenPicker contract](img/5022_08_08.jpg)'
- en: As can be seen from the image, the app can support any file type, or a set of
    predefined file types, such as `.jpg`, `.doc`, and so on. This limits the applications
    that are considered candidates to be listed in the `FileOpenPicker`, depending
    on the file types specified with the `FileOpenPicker::FileTypeFilter` property
    by the calling application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从图像中可以看出，应用程序可以支持任何文件类型，或一组预定义的文件类型，例如 `.jpg`、`.doc` 等。这限制了被列在 `FileOpenPicker`
    中的候选应用程序，取决于调用应用程序通过 `FileOpenPicker::FileTypeFilter` 属性指定的文件类型。
- en: If the user actually selects the app within the `FileOpenPicker`, the app is
    launched (if it's not already running), and the `Application::OnFileOpenPickerActivated`
    virtual method is called. This idea is similar to the share target scenario we've
    looked at previously in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在 `FileOpenPicker` 中选择了应用程序，应用程序将被启动（如果尚未运行），并调用 `Application::OnFileOpenPickerActivated`
    虚拟方法。这个想法与我们在本章前面看过的共享目标场景类似。
- en: The `FileOpenPicker` window is built with a header with the app's name (this
    is customizable by the app) and a footer with the **Open** and **Cancel** buttons.
    The middle section is where the app's specific selection UI is located.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileOpenPicker` 窗口由一个带有应用程序名称的标题（这可以由应用程序自定义）和一个带有**打开**和**取消**按钮的页脚构成。中间部分是应用程序特定的选择
    UI 所在。'
- en: 'The following example makes the Flags application a `FileOpenPicker` provider.
    The app should provide a view of the flags, allowing selection when an image is
    requested. The user interface for the flag selection is built like so:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将 Flags 应用程序作为 `FileOpenPicker` 提供程序。该应用程序应提供旗帜的视图，允许在请求图像时进行选择。旗帜选择的用户界面构建如下：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `GridView` hosts the collection of flags, bound to a collection of objects
    of type `CountryInfo`, defined like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 托管了旗帜的集合，绑定到 `CountryInfo` 类型的对象集合，定义如下：'
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `DataTemplate` for the `GridView` uses both properties to show an image
    of the flag and its corresponding country name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 的 `DataTemplate` 使用这两个属性来显示旗帜的图像和相应的国家名称。'
- en: 'The `GridView` event `SelectionChanged` is handled to provide the `FileOpenPicker`
    files to select or deselect. Before we get to that, we need to implement the `Application::OnFileOpenPickerActivated`
    method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridView` 事件 `SelectionChanged` 被处理以提供 `FileOpenPicker` 文件进行选择或取消选择。在此之前，我们需要实现
    `Application::OnFileOpenPickerActivated` 方法：'
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code simply instantiates our custom `FileOpenPickerPage` class and calls
    an app-specific method on that page named `Activate`, passing the activation information
    provided by the system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码只是实例化我们自定义的`FileOpenPickerPage`类，并调用该页面上的一个特定于应用程序的方法，该方法名为`Activate`，并传递系统提供的激活信息。
- en: 'The preceding `Activate` method does very little:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Activate`方法几乎没有做什么：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `FileOpenPickerActivatedEventArgs` is saved in the `_filePickerArgs` field,
    to be used later when flags are actually selected or deselected. The call to `OnNavigatedTo`
    sets up all flag data and the new page becomes the `Window`'s content and is activated.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileOpenPickerActivatedEventArgs`保存在`_filePickerArgs`字段中，以便在实际选择或取消选择标志时稍后使用。调用`OnNavigatedTo`设置所有标志数据，新页面成为`Window`的内容并被激活。'
- en: '`OnNavigatedTo` does the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnNavigatedTo`执行以下操作：'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The flag's image files are retrieved from the application installation location
    (`ms-appx:` scheme) and the country name is extracted from the image `Uri` by
    the helper method `FlagUriToName` (not shown); the country collection is updated,
    and finally the `DataContext` is set to the collection.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 标志图像文件从应用程序安装位置（`ms-appx:`方案）中检索，并且通过辅助方法`FlagUriToName`（未显示）从图像`Uri`中提取国家名称；国家集合得到更新，最后将`DataContext`设置为该集合。
- en: 'After the app is deployed (using a full build or by selecting **Build** | **Deploy
    Solution** in the Visual Studio menu), we can do a basic picker test by launching
    another app, such as the simple image viewer demonstrated in [Chapter 1](ch01.html
    "Chapter 1. Introduction to Windows 8 Apps"), *Introduction to Windows 8 Apps*.
    When clicking the **Open Image** button, the Flags application is displayed in
    the picker''s custom apps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序部署后（使用完整构建或在Visual Studio菜单中选择**构建** | **部署解决方案**），我们可以通过启动另一个应用程序进行基本的选择器测试，例如在[第1章](ch01.html
    "第1章。Windows 8应用程序简介")中演示的简单图像查看器，*Windows 8应用程序简介*。单击**打开图像**按钮时，Flags应用程序将显示在选择器的自定义应用程序中：
- en: '![Implementing a FileOpenPicker contract](img/5022_08_09.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![实现FileOpenPicker合同](img/5022_08_09.jpg)'
- en: 'If the Flags app is selected, the following is shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了Flags应用程序，则显示如下内容：
- en: '![Implementing a FileOpenPicker contract](img/5022_08_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![实现FileOpenPicker合同](img/5022_08_10.jpg)'
- en: 'At this time, selecting any flag does nothing—the **Open** button remains disabled.
    We need to tell the `FileOpenPicker` that a file is selected. This is handled
    by the `SelectionChanged` event of the `GridView`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，选择任何标志都不起作用——**打开**按钮仍然被禁用。我们需要告诉`FileOpenPicker`文件已被选中。这由`GridView`的`SelectionChanged`事件处理：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The class keeps track of the currently selected file with the `_currentFile`
    field. If nothing is selected in the `GridView` and a file was previously selected,
    the `FileOpenPickerUI::RemoveFile` method is called to indicate this file should
    be removed from selection; if this is the last one selected, the **Open** button
    is disabled by the `FileOpenPicker`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用`_currentFile`字段跟踪当前选定的文件。如果在`GridView`中没有选择任何内容，并且以前选择了文件，则调用`FileOpenPickerUI::RemoveFile`方法以指示应该从选择中删除此文件；如果这是最后一个被选择的文件，则`FileOpenPicker`会禁用**打开**按钮。
- en: If a flag is selected (`GridView::SelectedIndex` is zero or greater), the file
    for the flag image is obtained by calling the static `StorageFile::GetFileFromApplicationUriAsync`
    method, and passed into `FileOpenPickerUI::AddFile`. The result (`AddFileResult`
    enumeration) indicates whether this succeeded or not. This can fail if the `FileOpenPicker`
    was not opened with that file type in mind. For example, in an image viewer that
    did not specify the GIF file extension, the addition would fail, as all flag images
    are in GIF format.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了标志（`GridView::SelectedIndex`为零或更大），则通过调用静态的`StorageFile::GetFileFromApplicationUriAsync`方法获取标志图像的文件，并传递给`FileOpenPickerUI::AddFile`。结果（`AddFileResult`枚举）指示是否成功。如果`FileOpenPicker`没有考虑到该文件类型而打开，则可能会失败。例如，在未指定GIF文件扩展名的图像查看器中，添加将失败，因为所有标志图像都是以GIF格式保存的。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simple code provided here is a bit too simple. One thing that is not handled
    is multiselection. The `GridView` is configured to use single selection only,
    but this should really be configured according to the way the `FileOpenPicker`
    was opened. This information is available in the `FileOpenPickerUI::SelectionMode`
    property (`Single` or `Multiple`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的简单代码有点太简单了。没有处理的一件事是多选。`GridView`配置为仅使用单选，但实际上应根据打开`FileOpenPicker`的方式进行配置。此信息可在`FileOpenPickerUI::SelectionMode`属性中获得（`Single`或`Multiple`）。
- en: If used as intended, the `SelectionChanged` event handler should use the `AddedItems`
    and `RemovedItems` properties of the `SelectionChangedEventArgs` object to manage
    selection and deselection.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按预期使用，`SelectionChanged`事件处理程序应使用`SelectionChangedEventArgs`对象的`AddedItems`和`RemovedItems`属性来管理选择和取消选择。
- en: Note, that just as with share targets, Visual Studio provides a page template
    for the `FileOpenPicker` contract.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与共享目标一样，Visual Studio为`FileOpenPicker`合同提供了页面模板。
- en: Debugging contracts
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试合同
- en: 'Debugging contracts may seem difficult at first, as the application may not
    be running at the time, so setting a breakpoint will not automatically attach
    Visual Studio''s debugger to the launched instance. This can be easily handled
    with one of the following two ways:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，调试合同可能看起来很困难，因为应用程序可能在运行时不会运行，因此设置断点不会自动将Visual Studio的调试器附加到启动的实例。可以通过以下两种方式轻松处理：
- en: Attach the Visual Studio debugger after the specific app is selected from the
    file picker. This is enough to hit a breakpoint when selecting or unselecting.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从文件选择器中选择特定应用程序后，附加Visual Studio调试器。这足以在选择或取消选择时触发断点。
- en: Run the application with the debugger as usual, and then navigate to another
    app that shows a file picker. If the app is selected, any breakpoint will hit
    as usual.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像往常一样使用调试器运行应用程序，然后导航到显示文件选择器的另一个应用程序。如果选择了该应用程序，任何断点都会像往常一样被触发。
- en: Extensions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: Extensions are a kind of contract between an app and the operating system. Extensions
    are implemented similarly to contracts, by overriding certain methods and providing
    certain functionality expected by the OS. Let's look at an example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是应用程序和操作系统之间的一种合同。扩展与合同类似，通过覆盖某些方法并提供操作系统期望的某些功能来实现。让我们看一个例子。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The distinction between contracts and extensions is not important in practice.
    They both have one important trait in common: implement some functionality defined
    by Windows, whether it''s for app to app communication, or app to Windows.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，合同和扩展之间的区别并不重要。它们都有一个共同的重要特征：实现了Windows定义的一些功能，无论是用于应用程序之间的通信，还是应用程序与Windows之间的通信。
- en: Settings extension
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置扩展
- en: The Settings charm opens up a Settings pane; its lower part shows standard Windows
    customization options, such as **Volume**, **Brightness**, **Power**, and so on.
    The top part of the settings pane can be used by applications to add app-specific
    settings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 设置魅力打开了一个设置窗格；它的下部显示了标准的Windows自定义选项，如**音量**、**亮度**、**电源**等。设置窗格的上部可以被应用程序用来添加特定于应用程序的设置。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although Settings is documented as being a contract rather than extension, I
    feel it's an extension, as it does not involve another app—just the user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置被记录为合同而不是扩展，但我觉得它是一个扩展，因为它不涉及另一个应用程序——只涉及用户。
- en: 'For example, we''ll add a settings extension to the Flags application, to allow
    the user to view the flags in three different sizes. The first thing to do is
    indicate to the system that the app is interested in supporting the settings extension:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将为Flags应用程序添加一个设置扩展，允许用户以三种不同的大小查看旗帜。首先要做的是告诉系统应用程序有兴趣支持设置扩展：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This call registers the `SettingsPane::CommandRequested` event, raised when
    the user opens the Settings pane and the application is in the foreground.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用注册了`SettingsPane::CommandRequested`事件，当用户打开设置窗格并且应用程序在前台时触发。
- en: 'When the event is fired, we can add commands to be displayed in the settings
    pane like so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被触发时，我们可以添加命令以在设置窗格中显示，就像这样：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `SettingsCommand` constructor accepts an app-specific command ID that can
    be used to disambiguate commands in a common handler. The second argument is the
    text to show and the third is the handler to the command. In this example, all
    commands are handled by the same method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`SettingsCommand`构造函数接受一个特定于应用程序的命令ID，可以用于在一个公共处理程序中消除命令的歧义。第二个参数是要显示的文本，第三个是命令的处理程序。在这个例子中，所有命令都由相同的方法处理：'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `IUICommand` interface (in the `Windows::UI::Popups` namespace) provided
    is actually a `SettingsCommand` object which is currently the only class implementing
    that interface. It holds the properties of the command (`Id`, `Label`, and `Invoked`—the
    exact arguments to `SettingsCommand`, in that order).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUICommand`接口（在`Windows::UI::Popups`命名空间中）实际上是一个`SettingsCommand`对象，它目前是实现该接口的唯一类。它保存了命令的属性（`Id`，`Label`和`Invoked`—按照这个顺序精确的参数传递给`SettingsCommand`）。'
- en: '`ImageWidth` and `ImageHeight` are properties bound to the `DataTemplate` that
    drives the flags image appearance. This is how the Settings pane looks when opened
    from the Flags'' application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageWidth`和`ImageHeight`是绑定到驱动旗帜图像外观的`DataTemplate`的属性。这是从Flags应用程序打开设置窗格时的外观：'
- en: '![Settings extension](img/5022_08_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![设置扩展](img/5022_08_11.jpg)'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Permissions** command is provided by the system and lists the capabilities
    that the application requires (such as internet connection, webcam, Pictures library,
    and so on).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**权限**命令由系统提供，并列出应用程序需要的功能（如互联网连接、网络摄像头、图片库等）。'
- en: Other contracts and extensions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他合同和扩展
- en: 'Some other contracts and extensions, not shown here, include:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他合同和扩展，这里没有显示，包括：
- en: File save picker – similar to a file open picker, but for save operations
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件保存选择器 – 类似于文件打开选择器，但用于保存操作
- en: Search – provides a way for the app to participate in search, providing results
    that users can use to activate the app
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索 – 提供了一种让应用程序参与搜索的方式，提供用户可以用来激活应用程序的结果
- en: Cached file updater – used to track file changes (used by SkyDrive, for instance)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存文件更新程序 – 用于跟踪文件更改（例如SkyDrive使用）
- en: Auto play – allows the app to be listed when new devices are plugged in to the
    machine
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动播放 – 允许应用程序在新设备插入到计算机时被列出
- en: File activation – allows the app to be registered as handling a file type
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件激活 – 允许应用程序注册为处理文件类型
- en: Game explorer – allows the app to register as a game, providing a way for family
    safety features to be considered for the game
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏资源管理器 – 允许应用程序注册为游戏，为游戏考虑家庭安全功能提供了一种方式
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Contracts and extensions provide ways for an application to integrate better
    with Windows and other applications; for example, users can share data by using
    the Share charm, regardless of the kind of app. Contracts and extensions provide
    consistency in the user experience, not just the programming model. This makes
    the application more useful; it looks as though a lot of thought and care has
    been poured into the app. In general, this makes the app more likely to be used—which
    is one very important goal when building applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 合同和扩展提供了应用程序与Windows和其他应用程序更好地集成的方式；例如，用户可以使用共享魅力通过共享数据，而不管是什么类型的应用程序。合同和扩展提供了用户体验的一致性，而不仅仅是编程模型。这使得应用程序更有用；它看起来好像已经投入了很多思考和关怀到这个应用程序中。总的来说，这使得应用程序更有可能被使用——这是构建应用程序时一个非常重要的目标。
- en: In the next (and last) chapter we'll take a quick look at application deployment
    and the Windows Store.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（也是最后一章）中，我们将快速查看应用程序部署和Windows商店。
