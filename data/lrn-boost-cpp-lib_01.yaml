- en: Chapter 1. Introducing Boost
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍Boost
- en: 'Welcome to learning about the richest collection of C++ libraries around, that
    is, Boost. In this introductory chapter, we will take a look at:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来了解关于最丰富的C++库集合Boost。在这个介绍性章节中，我们将看到：
- en: The history and evolution of Boost
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的历史和发展
- en: What is Boost?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost是什么？
- en: Getting started with Boost libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost库入门
- en: Like all the chapters in the book, this is a hands-on chapter that will require
    you to type in commands, write and test your code. Therefore, you should have
    access to a computer with a reasonably modern C++ compiler and an internet connection
    to download free software, including Boost libraries.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的所有章节一样，这是一个需要您输入命令、编写和测试代码的实践性章节。因此，您应该有一台配备相当现代的C++编译器和互联网连接的计算机，以下载免费软件，包括Boost库。
- en: How it all started
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切是如何开始的
- en: Sometime around 1997-98, when the draft of the first C++ Standard was being
    finalized for publication as an ISO/IEC Standard, Robert Klarer from the IBM Labs
    conceived the idea of a programming language that would be called BOOSE (pronounced
    "booz"), and which would compete with Java in the area of high-performance embedded
    software development, which the latter had been aimed at. In a 1998 article for
    the now defunct *C++ Report* magazine, C++ guru Herb Sutter wrote a tongue-in-cheek
    spoof on this new language, whose name ostensibly expanded to Bjarne's Object
    Oriented Software Environment. In this article, he claimed that portability and
    *potability* were, among other things, key advantages of this language, which
    also supposedly promoted extraordinary camaraderie in team environments and made
    developers excessively happy, communicative, and passionate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在1997-98年，当第一个C++标准的草案定稿为ISO/IEC标准出版时，IBM实验室的Robert Klarer构想了一个名为BOOSE（发音为“booz”）的编程语言的想法，它将与Java在高性能嵌入式软件开发领域竞争，而后者一直以来都是针对这个领域的。在1998年为现已停刊的*C++
    Report*杂志撰写的一篇文章中，C++专家Herb Sutter以一种半开玩笑的方式讽刺了这种新语言，它的名字据说扩展为Bjarne的面向对象软件环境。在这篇文章中，他声称可移植性和“可饮性”是这种语言的关键优势之一，它还据说在团队环境中促进了非凡的友谊，并使开发人员过分快乐、善于交流和充满激情。
- en: 'While this was an April Fools'' Day article in 1998, the fact remained that
    the first C++ Standard was going to have a fairly basic standard library consisting
    of a memory allocation subsystem, type-generic containers and algorithms, a string
    class, basic abstractions for input and output devices, and sundry utilities.
    Now around the same time, a few folks from the C++ Standards Committee formed
    a group that worked on producing a collection of high-quality, peer-reviewed,
    free, and open source libraries in C++ that would have wide applicability and
    complement the features in standard C++. Inspired by BOOSE, perhaps for its stated
    competition with Java, which was a newer language but with a much richer library,
    they named this initiative Boost, a working title that stuck (source: FAQ on the
    Boost website, [http://www.boost.org](http://www.boost.org)).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是1998年愚人节的一篇文章，但事实仍然是，第一个C++标准将拥有一个相当基本的标准库，包括内存分配子系统、类型通用容器和算法、字符串类、输入和输出设备的基本抽象，以及各种实用工具。大约在同一时间，C++标准委员会的一些人成立了一个小组，致力于制作一套高质量、经过同行评审、免费且开源的C++库集合，这些库将具有广泛的适用性，并补充标准C++的功能。受到BOOSE的启发，也许是因为它声称与Java竞争，后者是一种更新的语言，但具有更丰富的库，他们将这一倡议命名为Boost，这个工作名称一直沿用至今（来源：Boost网站的常见问题解答，[http://www.boost.org](http://www.boost.org)）。
- en: What is Boost?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost是什么？
- en: Boost is a collection of free, peer-reviewed, portable, open source libraries
    in C++. Over the last decade and a half, there have been, as of this writing,
    57 releases of the Boost libraries. In this span, Boost has released libraries
    of compelling usefulness that promote correct, portable, efficient, and readable
    C++ code. A number of prominent Standards Committee members are also the most
    active participants in Boost and subsequent directions of C++ standardization
    have been heavily influenced by the work done at Boost. Boost has provided the
    Standards Committee with the laboratory they need to perfect their ideas for the
    best new features that C++ should have. Several Boost libraries were included
    in the *Technical Report 1* of the C++ Standards Committee, which considerably
    enhanced the functionality defined in the C++ 2003 revised standard; these included
    both language and library features. Most of these libraries made it to the C++11
    Standard published in 2011\. A couple more library features that originated in
    Boost have been added to the latest revision of the C++ Standard known as C++14
    (published in 2014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Boost是一套免费、经过同行评审、可移植、开源的C++库。截至目前为止，Boost已经发布了57个版本的库。在这段时间里，Boost发布了一些非常有用的库，促进了正确、可移植、高效和可读的C++代码。一些著名的标准委员会成员也是Boost最活跃的参与者，C++标准化的后续方向受到了Boost工作的重大影响。Boost为标准委员会提供了他们需要完善的想法，以便C++应该具有最佳新功能。一些Boost库被包括在C++标准委员会的*技术报告1*中，这大大增强了C++
    2003修订标准中定义的功能；这些功能包括语言和库功能。其中大多数库已经包含在2011年发布的C++11标准中。一些起源于Boost的库功能已经添加到最新的C++标准修订版C++14（2014年发布）中。
- en: 'Over the years, Boost has added libraries for string and text processing, including
    regular expression handling, generic containers compatible with the Standard Library,
    smart pointers for efficient exception-safe memory management, concurrent programming,
    network programming, interprocess communication, filesystem handling, template
    metaprogramming, and many others. The following table lists some of the prominent
    Boost libraries grouped by category. This is by no means exhaustive:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Boost增加了用于字符串和文本处理的库，包括正则表达式处理，与标准库兼容的通用容器，用于高效异常安全内存管理的智能指针，并发编程，网络编程，进程间通信，文件系统处理，模板元编程等等。以下表格列出了一些主要的Boost库，按类别分组。这只是一部分：
- en: '| Category | Libraries |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 库 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Memory management | Smart Ptr, Align, Pool |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 内存管理 | 智能指针，对齐，池 |'
- en: '| Data structures | Container, Array, Multi-Index, Bimap, Pointer Container,
    Optional, Variant, Any, Tuple, Assign |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 数据结构 | 容器，数组，多索引，双向映射，指针容器，可选，变体，任意，元组，分配 |'
- en: '| Algorithms | Algorithm, Range |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 算法，范围 |'
- en: '| String and text | Conversion, String Algo, Regex, Tokenizer, Spirit, Xpressive
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 字符串和文本 | 转换，字符串算法，正则表达式，标记化器，Spirit，Xpressive |'
- en: '| Systems programming | System, Filesystem, Chrono, Date Time, Thread, Asio,
    Interprocess |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 系统编程 | 系统，文件系统，Chrono，日期时间，线程，Asio，Interprocess |'
- en: '| I/O | IOStreams, Locale, Serialization, Format |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| I/O | IOStreams，Locale，Serialization，Format |'
- en: '| Higher-order programming | Function, Bind, Phoenix, Signals2 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 高阶编程 | 函数，绑定，Phoenix，Signals2 |'
- en: '| Generic programming | Enable If, Type Traits, MPL, Fusion, Proto |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 通用编程 | 启用If，类型特征，MPL，Fusion，Proto |'
- en: '| Language features emulation | Foreach, Move, Exception, Parameter |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 语言特性仿真 | Foreach，Move，Exception，Parameter |'
- en: '| Correctness and testing | Test, Static Assert |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 正确性和测试 | 测试，静态断言 |'
- en: '| Miscellaneous | Utility, Log, Uuid, Program Options, CRC |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | 实用程序，日志，UUID，程序选项，CRC |'
- en: Boost libraries have found varied use in the industry because of some very high-performance
    libraries (such as Boost.Asio and Boost.Intrusive), and because of a very permissive
    and uncomplicated Boost license, which allows source redistribution, distribution
    of derivative work, and distribution in a binary form for noncommercial as well
    as commercial purposes with minimal constraints. In the next section, we will
    set up a development environment that enables us to use any Boost library in our
    C++ code using consistent conventions. This should serve us well for the rest
    of the book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些高性能库（如Boost.Asio和Boost.Intrusive）以及非常宽松和简单的Boost许可证，允许源重新分发、派生作品的分发以及非商业和商业目的的二进制形式的分发，Boost库在行业中得到了各种用途。在接下来的部分中，我们将设置一个开发环境，使我们能够使用一致的约定在我们的C++代码中使用任何Boost库。这应该能够为我们在本书的其余部分提供帮助。
- en: Getting started with Boost libraries
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Boost库
- en: We shall now set up a development sandbox for you to write code using the Boost
    libraries. We can either install a binary distribution of the Boost libraries,
    or build them from source. If we build them from source, we have a whole range
    of concerns to take care of from choosing a suitable naming convention for the
    library files and building the libraries, to making sure that we are linking them
    to the correct versions of the library. There are platform-specific differences
    too that need to be handled; we shall take a look at both the Linux and Windows
    environments.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为您设置一个开发沙箱，以便您可以使用Boost库编写代码。我们可以安装Boost库的二进制发行版，也可以从源代码构建它们。如果我们从源代码构建它们，我们需要解决一系列问题，从选择适当的库文件命名约定和构建库，到确保我们将它们链接到正确版本的库。还有需要处理的特定于平台的差异；我们将看看Linux和Windows环境。
- en: Necessary software
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必要的软件
- en: On Linux, we will only consider the C++ compiler (g++) version 4.8.1 or later,
    distributed with the **GNU Compiler Collection** (**GCC**). On Windows, we will
    use Visual Studio 2013\. You can get more elaborate software support matrices
    for each Boost release on the Boost website.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们只考虑C++编译器（g++）版本4.8.1或更高版本，与**GNU编译器集合**（**GCC**）一起分发。在Windows上，我们将使用Visual
    Studio 2013。您可以在Boost网站上获取每个Boost版本的更详尽的软件支持矩阵。
- en: Linux toolchain
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux工具链
- en: You should be able to build Boost on most major Linux distributions. I use a
    Lubuntu 14.04 32-bit installation with GCC 4.8.1 and Clang 3.4\. You can possibly
    build on much older distributions, as the Boost website lists GCC 3.3 as the minimum
    supported version. If you also want good C++11 support, use GCC 4.8 or higher.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在大多数主要的Linux发行版上构建Boost。我使用的是Lubuntu 14.04 32位安装，配备了GCC 4.8.1和Clang 3.4。您可能也可以在更旧的发行版上构建，因为Boost网站将GCC
    3.3列为最低支持的版本。如果您还想要良好的C++11支持，请使用GCC 4.8或更高版本。
- en: '| Required software | Minimum version | Recommended version | Ubuntu package
    | Fedora/CentOS package |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 所需软件 | 最低版本 | 推荐版本 | Ubuntu软件包 | Fedora/CentOS软件包 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| GNU C++ compiler | 4.8.x | 4.8.4 | g++ | gcc-c++ |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| GNU C++编译器 | 4.8.x | 4.8.4 | g++ | gcc-c++ |'
- en: '| GNU Standard C++ Library | 4.8.x | 4.8.4 | libstdc++-dev | libstdc++-devel
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| GNU标准C++库 | 4.8.x | 4.8.4 | libstdc++-dev | libstdc++-devel |'
- en: '| GNU Standard C++ runtime | 4.8.x | 4.8.4 | libstdc++ | libstdc++ |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| GNU标准C++运行时 | 4.8.x | 4.8.4 | libstdc++ | libstdc++ |'
- en: 'If you want to use Clang instead of GCC, the recommended version is 3.4 or
    higher. Here are the required packages on Ubuntu:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Clang而不是GCC，则推荐版本为3.4或更高版本。以下是Ubuntu上所需的软件包：
- en: '| Required software | Minimum version | Recommended version | Ubuntu package
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: 所需软件 | 最低版本 | 推荐版本 | Ubuntu软件包
- en: '| --- | --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| LLVM compiler toolchain | 3.2 | 3.4 | llvm |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| LLVM编译器工具链 | 3.2 | 3.4 | llvm |'
- en: '| LLVM C, C++, and Objective-C compiler | 3.2 | 3.4 | clang |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| LLVM C、C++和Objective-C编译器 | 3.2 | 3.4 | clang |'
- en: '| LLVM C++ Standard Library | 3.2 | 3.4 | libc++-dev |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| LLVM C++标准库 | 3.2 | 3.4 | libc++-dev |'
- en: Windows toolchain
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows工具链
- en: 'You should be able to build Boost on Visual Studio 7.1 upwards. I use Visual
    Studio 2013 on a Windows 7 64-bit installation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在Visual Studio 7.1及更高版本上构建Boost。我在Windows 7 64位安装的Visual Studio 2013上使用：
- en: '| Requiredsoftware | Minimum version | Recommended version |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 所需软件 | 最低版本 | 推荐版本 |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Visual Studio with Visual C++ | 7.1 | 12 (2013) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Visual Studio与Visual C++ | 7.1 | 12（2013） |'
- en: I would also recommend installing 7-Zip on Windows to extract Boost sources
    from the `.7z` or `.tar.bz2` archives, which offer much better compression than
    the `.zip` archives.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议在Windows上安装7-Zip，以从`.7z`或`.tar.bz2`存档中提取Boost源代码，这比`.zip`存档具有更好的压缩效果。
- en: Obtaining and building Boost libraries
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和构建Boost库
- en: You can build the Boost libraries from source or install them as an operating
    system package on platforms where such as package is available. All examples in
    this book use Boost version 1.57\. You may choose to download a more recent version
    of the sources and most of the discussion here should still hold. However, few
    details may change from one release to the next, so you should be prepared to
    dig into the online documentation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从源代码构建Boost库，也可以在支持此类包的平台上将其安装为操作系统包。本书中的所有示例都使用Boost版本1.57。您可以选择下载更近期的源代码版本，大部分讨论仍然适用。但是，一些细节可能会在不同版本之间发生变化，因此您应该准备查阅在线文档。
- en: Planning your Boost sandbox
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划您的Boost沙盒
- en: As part of our day-to-day development work using Boost, we would need access
    to Boost's header files and Boost's libraries. A vast number of Boost libraries
    are *header-only*, which means that you just need to include the appropriate headers
    and build your sources. Some others have to be built into binary libraries that
    can be *linked statically or dynamically* to your application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为日常开发工作的一部分，我们需要访问Boost的头文件和库。大量的Boost库是*仅头文件*，这意味着您只需要包含适当的头文件并构建您的源代码。其他一些库必须构建为可以*静态或动态链接*到您的应用程序的二进制库。
- en: If we build from source, we will first identify a directory on our development
    machine, where we would like to install these files. The choice is arbitrary,
    but we can follow conventions if they exist. So on Linux, we can choose to install
    the library headers and binaries under `/opt/boost`. On Windows, this could be
    `f:\code\libraries\Boost`. You are free to choose different paths, just avoid
    spaces within them for less hassle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从源代码构建，我们首先会在开发机器上确定一个目录，用于安装这些文件。选择是任意的，但如果存在惯例，我们可以遵循。因此，在Linux上，我们可以选择将库头文件和二进制文件安装在`/opt/boost`下。在Windows上，可以是`f:\code\libraries\Boost`。您可以选择不同的路径，只需避免其中包含空格以减少麻烦。
- en: Library naming conventions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库命名约定
- en: Boost library binaries can have names that are difficult to decipher at first.
    So, we shall learn about what goes into naming the libraries. Library names have
    different layouts. Depending on the layout, different components are added to
    the base name in order to identify different facets of the library's binary compatibility
    and functionality.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库二进制文件的名称可能一开始很难解读。因此，我们将学习库名称的构成。库名称有不同的布局。根据布局的不同，不同的组件会被添加到基本名称中，以便识别库的二进制兼容性和功能的不同方面。
- en: Library name components
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库名称组件
- en: 'Each library, whether static or shared, is named according to a well-defined
    scheme. The name of a library can be split into several components, not all of
    which are mandatory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库，无论是静态的还是共享的，都按照一个明确定义的方案命名。库的名称可以分为几个组件，其中并非所有都是必需的：
- en: '**Prefix**: Libraries may have a prefix, typically `lib`. On Windows, only
    static libraries have this prefix while on Unix, all libraries have this prefix.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀**：库可能有一个前缀，通常是`lib`。在Windows上，只有静态库有这个前缀，而在Unix上，所有库都有这个前缀。'
- en: '**Toolset identifier**: Library names may be tagged with the string, identifying
    the toolset with which it was built. Roughly speaking, a toolset or toolchain
    is the set of system utilities, including compiler, linker, archiver, and so on,
    that are used to build libraries and programs. For example, `vc120` identifies
    the Microsoft Visual C++ 12.0 toolchain.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具集标识符**：库名称可能会被标记为一个字符串，用于标识构建时所使用的工具集。工具集或工具链大致上是一组系统工具，包括编译器、链接器、存档工具等，用于构建库和程序。例如，`vc120`标识了Microsoft
    Visual C++ 12.0工具链。'
- en: '**Threading model**: If a library is thread-safe, that is, it can be used in
    multithreaded programs without additional synchronization, then its name may be
    tagged with `mt`, which stands for multithreaded.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程模型**：如果一个库是线程安全的，也就是说，它可以在多线程程序中使用而不需要额外的同步，那么它的名称可能会被标记为`mt`，代表多线程。'
- en: '**ABI**: ABI stands for **application binary interface**. This component captures
    details, such as whether the library is a debug library (`d`) or not, whether
    it is linked to a debug version of the runtime (`g`) or not, and whether the link
    to the runtime is static (`s`) or not. Thus, a debug library that is statically
    linked to a release version of the runtime would be marked with only `sd`, while
    one that is dynamically linked to a debug version would be marked with `gd`. A
    release version of the library dynamically linked to a release version of the
    runtime will have a blank ABI marker.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ABI**：ABI代表**应用程序二进制接口**。这个组件包含了一些细节，比如库是否是调试库（`d`），是否链接到调试版本的运行时（`g`），以及链接到运行时的方式是静态的（`s`）还是动态的。因此，一个静态链接到发布版本运行时的调试库只会被标记为`sd`，而一个动态链接到调试版本的库会被标记为`gd`。动态链接到发布版本运行时的发布版本库将没有ABI标记。'
- en: '**Version**: This is the version string of the Boost library. For example,
    `1_57` would be the version marker for the Boost 1.57 libraries.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：这是Boost库的版本字符串。例如，`1_57`将是Boost 1.57库的版本标记。'
- en: '**Extension**: Library extensions identify the file types. On Windows, dynamic
    libraries have the extension `.dll`, while static libraries and import libraries
    have the extension `.lib`. On Linux and some other Unix systems, dynamic libraries
    have the extension `.so`, while static libraries or archives have the extension
    `.a`. Dynamic library extensions often have a version suffix, for example, `.so.1.57.0`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展名**：库扩展名标识文件类型。在Windows上，动态库的扩展名是`.dll`，而静态库和导入库的扩展名是`.lib`。在Linux和其他一些Unix系统上，动态库的扩展名是`.so`，而静态库或存档的扩展名是`.a`。动态库扩展名通常带有版本后缀，例如`.so.1.57.0`。'
- en: Library name layouts
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库名称布局
- en: 'How a library name is made up of its components determines its name layout.
    There are three kinds of name layouts supported by Boost: versioned, system, and
    tagged.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 库名称由其组件组成的方式决定了其名称布局。Boost支持三种名称布局：带版本号的、系统的和带标签的。
- en: Versioned layout
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带版本号的布局
- en: 'It is the most elaborate layout and is the default layout on Windows. The general
    structure of the versioned layout name is `libboost_<name>-<toolset>-<threading>-<ABI>-<version>.<ext>`.
    For example, here is the `Boost.Filesystem` library debug DLL for Windows: `boost_filesystem-vc100-mt-gd-1_57.dll`.
    The tokens in the filename tell the complete story. This DLL was built using Visual
    C++ 10.0 compiler (`-vc100`), is thread-safe (`-mt`), and is a debug DLL (`d`)
    linked dynamically to the debug version of the runtime (`g`). The version of Boost
    is 1.57 (`1_57`).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最复杂的布局，也是Windows上的默认布局。版本化布局名称的一般结构是`libboost_<name>-<toolset>-<threading>-<ABI>-<version>.<ext>`。例如，这是Windows上`Boost.Filesystem`库的调试DLL：`boost_filesystem-vc100-mt-gd-1_57.dll`。文件名中的标记讲述了完整的故事。这个DLL是使用Visual
    C++ 10.0编译器（`-vc100`）构建的，是线程安全的（`-mt`），是一个调试DLL（`d`），动态链接到调试版本的运行时（`g`）。Boost的版本是1.57（`1_57`）。
- en: System layout
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 系统布局
- en: 'The default layout on Unix is the system layout that removes all the name decorations.
    The general structure of library names in this layout is `libboost_<name>.<ext>`.
    For example, here is the `Boost.System` shared library on Linux: `libboost_filesystem.so.1.57.0`.
    Looking at it, there is no way to tell whether it supports multithreading, whether
    it is a debug library, or any other detail that you could wean from a filename
    in the versioned layout. The `1.57.0` suffix of the extension indicates the version
    of the shared library. This is the Unix convention for versioning shared libraries
    and is not affected by the Boost name layout.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Unix上的默认布局是系统布局，去除了所有的名称装饰。在这个布局中，库名称的一般结构是`libboost_<name>.<ext>`。例如，这是Linux上的`Boost.System`共享库：`libboost_filesystem.so.1.57.0`。看着它，无法判断它是否支持多线程，是否是调试库，或者从版本化布局的文件名中获取的任何其他细节。扩展名的`1.57.0`后缀表示共享库的版本。这是Unix共享库版本的约定，不受Boost名称布局的影响。
- en: Tagged layout
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标记布局
- en: There is a third layout called the tagged layout, which is midway between the
    versioned and system layouts in terms of detail. It removes all the version information
    but retains other information. Its general structure is `libboost_<name>-<threading>-<ABI>.<ext>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种布局称为标记布局，它在细节上介于版本化布局和系统布局之间。它去除了所有版本信息，但保留了其他信息。它的一般结构是`libboost_<name>-<threading>-<ABI>.<ext>`。
- en: 'Here is the `Boost.Exception` static library from Windows built using the non-default
    tagged layout: `libboost_filesystem-mt.lib`. This is a static library as indicated
    by its `lib-` prefix. Also, `-mt` indicates that this library is thread-safe,
    and the lack of an ABI indicator means that this is not a debug library (`d`),
    nor does it link to the static runtime (`s`). Also, it does not link to the debug
    version of the runtime (`g`).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用非默认标记布局构建的Windows上的`Boost.Exception`静态库：`libboost_filesystem-mt.lib`。这是一个静态库，其`lib-`前缀表示。此外，`-mt`表示此库是线程安全的，缺少ABI指示器意味着这不是调试库（`d`），也不链接到静态运行时（`s`）。此外，它不链接到调试版本的运行时（`g`）。
- en: The versioned layout is a bit unwieldy. On systems where you need to manually
    specify names of libraries to link against, moving from one version of Boost to
    the next would require some effort to fix the build scripts. The system layout
    is a bit minimalistic and is great for environments where you need only one variant
    of a given library. However, you cannot have both debug and release versions of
    the library, or thread-safe and thread-unsafe ones side by side, with system layout.
    For this reason, in the rest of this book, we will only use tagged layout for
    the libraries. We will also only build thread-safe libraries (`-mt`) and shared
    libraries (`.dll` or `.so`). Some libraries can only be built as static libraries
    and, as such, would be automatically created by the Boost build system. So now,
    we finally get to the point where we have enough information to start creating
    our Boost sandbox.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 版本化布局有点笨拙。在需要手动指定要链接的库名称的系统上，从一个Boost版本移动到下一个版本需要一些努力来修复构建脚本。系统布局有点简约，非常适合只需要给定库的一个变体的环境。但是，系统布局不能同时拥有库的调试版本和发布版本，或者线程安全和线程不安全的库。因此，在本书的其余部分，我们将只使用库的标记布局。我们还将只构建线程安全库（`-mt`）和共享库（`.dll`或`.so`）。一些库只能构建为静态库，并且会被Boost构建系统自动创建。因此，现在我们终于有足够的信息来开始创建我们的Boost沙箱。
- en: Installing a Boost binary distribution
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Boost二进制发行版
- en: 'On Microsoft Windows and several distributions of Linux, you can install a
    binary distribution of the Boost libraries. The following table lists the methods
    of installing Boost on some of the popular operating systems:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Windows和几个Linux发行版上，您可以安装Boost库的二进制发行版。以下表格列出了在一些流行操作系统上安装Boost的方法：
- en: '| Operating system | Package name | Install method |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 包名称 | 安装方法 |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Microsoft Windows | `boost_1_57_0-msvc-12.0-64.exe` (64-bit)`boost_1_57_0-msvc-12.0-32.exe`
    (32-bit) | Download executable from [http://sourceforge.net/projects/boost/files/boost-binaries/](http://sourceforge.net/projects/boost/files/boost-binaries/)
    and install it by running the executable |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft Windows | `boost_1_57_0-msvc-12.0-64.exe`（64位）`boost_1_57_0-msvc-12.0-32.exe`（32位）|
    从[http://sourceforge.net/projects/boost/files/boost-binaries/](http://sourceforge.net/projects/boost/files/boost-binaries/)下载可执行文件并运行可执行文件进行安装
    |'
- en: '| Ubuntu | `libboost-all-dev` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Ubuntu | `libboost-all-dev` |'
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Fedora/CentOS | `boost-devel` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Fedora/CentOS | `boost-devel` |'
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Installing a binary distribution is convenient because it is the fastest way
    to be up and running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装二进制发行版很方便，因为这是最快的上手方式。
- en: Installing on Windows
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: Starting with Boost 1.54, you can download a binary distribution of the Boost
    libraries, built using Microsoft Visual Studio, from SourceForge. The download
    is available as a 64-bit or 32-bit installable executable that contains header
    files, libraries, sources, documentation, and tools. There are separate distributions
    for different versions of Visual Studio, from version 12 (VS 2013) backward through
    version 8 (VS 2005). The name of the executable is of the form `boost_ver-msvc-vcver-W.exe`,
    where `ver` is the Boost version (for example, 1_57_0), `vcver` is the version
    of Visual C++ (for example, 12.0 for Visual Studio 2013), and `W` is the native
    word size of your operating system (for example, 64 or 32).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从Boost 1.54开始，您可以从SourceForge下载使用Microsoft Visual Studio构建的Boost库的二进制发行版。下载可用作64位或32位可安装可执行文件，其中包含头文件、库、源代码、文档和工具。不同版本的Visual
    Studio有单独的发行版，从版本12（VS 2013）向后退到版本8（VS 2005）。可执行文件的名称形式为`boost_ver-msvc-vcver-W.exe`，其中`ver`是Boost版本（例如1_57_0），`vcver`是Visual
    C++的版本（例如Visual Studio 2013的12.0），`W`是您操作系统的本机字长（例如64或32）。
- en: 'As part of the installation, you can choose the directory where you want to
    install the Boost libraries. Let us consider that you choose to install it under
    `boost-dir`. Then, the following directories contain the necessary headers and
    libraries:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安装的一部分，您可以选择要安装Boost库的目录。假设您选择将其安装在`boost-dir`下。然后，以下目录包含必要的头文件和库：
- en: '| Directory | Files |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 文件 |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boost-dir` | This is the base directory of the Boost installation. All the
    header files are present in a hierarchy under the `boost` subdirectory. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir` | 这是Boost安装的基本目录。所有头文件都在`boost`子目录下的层次结构中。 |'
- en: '| `boost-dir/libW-msvc-vcver` | This directory contains all variants of the
    Boost libraries, static and shared (DLLs), debug and release. The library filenames
    follow the versioned layout.W: 32 or 64 depending on whether you installed a 32-bit
    version or 64-bit version.vcver: Visual Studio version. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir/libW-msvc-vcver` | 此目录包含所有变体的Boost库，静态和共享（DLL），调试和发布。库文件名遵循版本布局。W：32或64，取决于您安装的是32位版本还是64位版本。vcver：Visual
    Studio版本。 |'
- en: '| `boost-dir/doc` | This directory contains the library documentation in the
    HTML format and contains scripts to build PDF docs. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir/doc` | 此目录包含HTML格式的库文档，并包含构建PDF文档的脚本。 |'
- en: Installing on Linux
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'On Ubuntu, you need to install the `libboost-all-dev` package. You need to
    perform the installation using superuser privileges, so run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，您需要安装`libboost-all-dev`软件包。您需要使用超级用户权限执行安装，因此运行以下命令：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This installs the necessary headers and libraries in the following directories:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以下目录中安装必要的头文件和库：
- en: '| Directory | Files |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 文件 |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/usr/include` | This contains all the header files present in a hierarchy
    under the `boost` subdirectory. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/include` | 这包含了`boost`子目录下层次结构中存在的所有头文件。 |'
- en: '| `/usr/lib/arch-linux-gnu` | This contains all the Boost libraries, static
    and shared (DSOs). The library filenames follow the system layout.Replace arch
    with `x86_64` for 64-bit operating systems and with `i386` for 32-bit operating
    systems. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/lib/arch-linux-gnu` | 这包含了所有Boost库，静态和共享（DSO）。库文件名遵循系统布局。用`x86_64`替换arch以用于64位操作系统，用`i386`替换arch以用于32位操作系统。
    |'
- en: 'On CentOS/Fedora, you need to install the `boost-devel` package. You need to
    perform the installation using superuser privileges, so this is the command to
    run:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS/Fedora上，您需要安装`boost-devel`软件包。您需要使用超级用户权限执行安装，因此运行以下命令：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This installs the necessary headers and libraries in the following directories:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以下目录中安装必要的头文件和库：
- en: '| Directory | Files |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 文件 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/usr/include` | This contains all the header files present in a hierarchy
    under the boost directory. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/include` | 这包含了boost目录下层次结构中存在的所有头文件。 |'
- en: '| `/usr/lib` | This contains all the Boost libraries, static and shared (DSOs).
    The library filenames follow the system layout. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/lib` | 这包含了所有Boost库，静态和共享（DSO）。库文件名遵循系统布局。 |'
- en: Building and installing the Boost libraries from source
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码构建和安装Boost库
- en: Building the Boost libraries from source offers more flexibility, as it is easy
    to customize the build, use alternative compilers/toolchains, and change the default
    name layout like we plan to. We shall build the Boost libraries from a source
    archive downloaded from the Boost website [http://www.boost.org](http://www.boost.org)
    or [http://sourceforge.net/projects/boost](http://sourceforge.net/projects/boost).
    I prefer the 7-Zip or the bzip2 archives, as they have the best compression ratios.
    We will use Boost libraries Version 1.57, and we will look at building them only
    on Linux and Windows operating systems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建Boost库提供了更多的灵活性，因为可以轻松定制构建、使用替代编译器/工具链，并更改默认的名称布局，就像我们计划的那样。我们将从Boost网站[http://www.boost.org](http://www.boost.org)或[http://sourceforge.net/projects/boost](http://sourceforge.net/projects/boost)下载源代码存档。我更喜欢7-Zip或bzip2存档，因为它们具有最佳的压缩比。我们将使用Boost库版本1.57，并且只会在Linux和Windows操作系统上构建它们。
- en: Optional packages
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选软件包
- en: 'There are several *optional* packages that are used to provide additional functionality
    by certain Boost libraries when present. These include:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在时，有几个*可选*软件包用于提供某些Boost库的额外功能。这些包括：
- en: The `zlib` and `bzip2` development libraries, used by `Boost.IOStream` to read
    and write compressed archives in `gzip` and `bzip2` formats
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zlib`和`bzip2`开发库，被`Boost.IOStream`用于读取和写入`gzip`和`bzip2`格式的压缩存档'
- en: The `ICU i18n` development libraries, which are heavily used by `Boost.Locale`
    and also by `Boost.Regex` to support Unicode regular expressions
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICU i18n`开发库，被`Boost.Locale`和`Boost.Regex`用于支持Unicode正则表达式'
- en: The `expat` XML parser library, used by the `Boost.Graph` library to support
    the GraphML XML vocabulary for describing graphs
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expat` XML解析器库，被`Boost.Graph`库用于支持描述图形的GraphML XML词汇'
- en: 'Some of these libraries may be made available through your native package management
    systems, particularly on Linux. When installed from such packages, the Boost build
    system may find these libraries automatically and link them by default. If you
    chose to build these libraries from source and installed them at non-standard
    locations instead, then you should use specific environment variables to point
    to the installation directory of these libraries or to the `include` and `library`
    directories. The following table summarizes these optional libraries, their source
    websites, Ubuntu package names, and the environment variables needed by Boost
    to identify them when installed from source:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些库可能通过您的本地软件包管理系统提供，特别是在Linux上。当从这些软件包安装时，Boost构建系统可能会自动找到这些库并默认链接它们。如果您选择从源代码构建这些库并将它们安装在非标准位置，那么您应该使用特定的环境变量来指向这些库的安装目录或`include`和`library`目录。以下表总结了这些可选库、它们的源网站、Ubuntu软件包名称以及Boost在从源代码安装时识别它们所需的环境变量：
- en: '| Library | Details |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 库 | 详情 |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Zlib library ([http://www.zlib.net](http://www.zlib.net)) | Environment variable:
    `ZLIB_SOURCE` (extracted source directory)Ubuntu packages: `zlib1g`, `zlib1g-dev`,
    and `zlib1c` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| Zlib库([http://www.zlib.net](http://www.zlib.net)) | 环境变量：`ZLIB_SOURCE`（提取的源目录）Ubuntu软件包：`zlib1g`，`zlib1g-dev`和`zlib1c`
    |'
- en: '| Bzip2 library ([http://www.bzip.org/downloads.html](http://www.bzip.org/downloads.html))
    | Environment variable: `BZIP2_SOURCE` (extracted source directory)Ubuntu packages:
    `libbz2` and `libbz2-dev` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Bzip2库([http://www.bzip.org/downloads.html](http://www.bzip.org/downloads.html))
    | 环境变量：`BZIP2_SOURCE`（提取的源目录）Ubuntu软件包：`libbz2`和`libbz2-dev` |'
- en: '| ICU library ([http://www.icu-project.org/download](http://www.icu-project.org/download))
    | Environment variables:`HAVE_ICU=1``ICU_PATH` (installation root)Ubuntu package:
    `libicu-dev` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| ICU库([http://www.icu-project.org/download](http://www.icu-project.org/download))
    | 环境变量：`HAVE_ICU=1``ICU_PATH`（安装根目录）Ubuntu软件包：`libicu-dev` |'
- en: '| Expat library ([http://sourceforge.net/projects/expat](http://sourceforge.net/projects/expat))
    | Environment variables: `EXPAT_INCLUDE` (expat include dir) and `EXPAT_LIBPATH`
    (expat library dir)Ubuntu packages: `libexpat1` and `libexpat1-dev` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Expat库([http://sourceforge.net/projects/expat](http://sourceforge.net/projects/expat))
    | 环境变量：`EXPAT_INCLUDE`（expat包含目录）和`EXPAT_LIBPATH`（expat库目录）Ubuntu软件包：`libexpat1`和`libexpat1-dev`
    |'
- en: We will be using the `gzip` and `bzip2` libraries in [Chapter 9](ch09.html "Chapter 9. Files,
    Directories, and IOStreams"), *Files, Directories, and IOStreams*, to compress
    data, while we will not be using the ICU and Expat libraries for the code examples
    in this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章。文件，目录和IOStreams")*文件，目录和IOStreams*中使用`gzip`和`bzip2`库来压缩数据，而我们将不会在本书的代码示例中使用ICU和Expat库。
- en: Building the Boost libraries on Linux
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Linux上构建Boost库
- en: 'If you choose not to install a binary distribution of Boost or if such a distribution
    is not available for your platform, then you must build the Boost libraries from
    source. Download the source archives for the Boost libraries, `zlib` and `bzip2`.
    Assuming that you want to install Boost in the`/opt/boost` directory, perform
    the following steps from a shell command prompt to build Boost with the GNU toolchain:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择不安装Boost的二进制发行版，或者如果您的平台上没有这样的发行版可用，那么您必须从源代码构建Boost库。下载Boost库、`zlib`和`bzip2`的源代码存档。假设您想要将Boost安装在`/opt/boost`目录中，从shell命令提示符执行以下步骤来使用GNU工具链构建Boost：
- en: 'Create a directory and extract the Boost source archive in it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录并在其中提取Boost源代码存档：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Generate the Boost build system for your toolset. The following should work
    if you are building with **g++**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的工具集生成Boost构建系统。如果您正在使用**g++**构建，以下内容应该有效。
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are using Clang instead, run the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Clang，运行以下命令：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Extract the `bzip2` and `zlib` source archives and make a note of the directories
    they have been extracted to.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取`bzip2`和`zlib`源代码存档，并记下它们被提取到的目录。
- en: 'Build the libraries and install them. For GCC, run the following command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建库并安装它们。对于GCC，运行以下命令：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For Clang, run the following command instead:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Clang，改为运行以下命令：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last step should build all the Boost libraries and install them under the
    `/opt/boost` directory, as identified by the `--prefix` option. All the libraries
    will be installed under `/opt/boost/lib` and all include files under `/opt/boost/include`.
    In addition to the Boost libraries, you should also see `libboost_zlib-mt.so`
    and `libboost_bzip2-mt.so`—the dynamic shared objects for `zlib` and `bzip2`,
    which `libboost_iostreams-mt.so` depends on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步应该构建所有的Boost库并将它们安装在`/opt/boost`目录下，由`--prefix`选项标识。所有的库将安装在`/opt/boost/lib`下，所有的包含文件将安装在`/opt/boost/include`下。除了Boost库之外，您还应该看到`libboost_zlib-mt.so`和`libboost_bzip2-mt.so`——`zlib`和`bzip2`的动态共享对象，`libboost_iostreams-mt.so`依赖于它们。
- en: The `--build-dir` option would identify the directory in which the intermediate
    products of the build are created.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-dir`选项将标识构建的中间产品所在的目录。'
- en: The `--layout=tagged` option chooses the tagged layout for library names.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--layout=tagged`选项选择了库名称的标记布局。'
- en: We will build only thread-safe (`threading=multi`) shared libraries (`link=shared`)
    if possible, linked them to the dynamic runtime (`runtime-link=shared`). We would
    need both debug and release versions of the library (`variant=debug,release`).
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，我们将只构建线程安全（`threading=multi`）的共享库（`link=shared`），将它们链接到动态运行时（`runtime-link=shared`）。我们需要库的调试和发布版本（`variant=debug,release`）。
- en: The `-sZLIB_SOURCE=<zlib-source-dir>` option is used to point the build to the
    directory under which the `zlib` sources were extracted in step 3; likewise, for
    the `bzip2` source directory, using `-sBZIP2_SOURCE=<bzip2-source-dir>`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-sZLIB_SOURCE=<zlib-source-dir>`选项来指向构建目录，在第3步中提取`zlib`源代码的目录；同样，对于`bzip2`源代码目录，使用`-sBZIP2_SOURCE=<bzip2-source-dir>`。
- en: If you want to build Boost libraries using support for C++11, then you should
    use the `cxxflags="-std=c++11"` option. Throughout the rest of the book, many
    of the code examples use features from C++11\. Enabling a C++11 build of Boost
    at this point might be a good idea. Make sure that your compiler has good support
    for C++11\. For g++, it would be version 4.8.1 or later. Also, make sure that
    you compile all your own code using the Boost libraries with C++11 as well.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想要使用对C++11的支持构建Boost库，那么您应该使用`cxxflags="-std=c++11"`选项。在本书的其余部分，许多代码示例使用了C++11的特性。在这一点上启用Boost的C++11构建可能是一个好主意。确保您的编译器对C++11有良好的支持。对于g++，版本应为4.8.1或更高。此外，确保您编译所有自己的代码时也使用了Boost库的C++11。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most of the examples in this book use C++11 features, and so you should keep
    the C++11 option on while compiling Boost. Appendix provides a short introduction
    to the important C++11 features used in this book, and also describes how you
    can emulate them in C++03 using Boost if you are still using an older compiler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例使用了C++11的特性，因此在编译Boost时应该保持C++11选项开启。附录提供了本书中使用的重要C++11特性的简要介绍，并描述了如果您仍在使用旧编译器，如何使用Boost在C++03中模拟它们。
- en: Building the Boost libraries on Windows
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows上构建Boost库
- en: 'Once you have downloaded the Boost source archive, from a Windows Explorer
    session, create a directory called `boost-src` and extract the source archive
    inside this directory. Assuming that you want to install Boost in the `boost-dir`
    directory and `boost-build` is the directory in which the intermediate products
    of the build are kept, perform the following steps from a command prompt:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您下载了Boost源存档，在Windows资源管理器会话中，创建一个名为`boost-src`的目录，并在此目录中提取源存档。假设您想要在`boost-dir`目录中安装Boost，并且`boost-build`是保存构建中间产品的目录，请从命令提示符执行以下步骤：
- en: 'Initialize the 32-bit Visual C++ build environment to build the Boost build
    system (even if you want to build 64-bit):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化32位Visual C++构建环境以构建Boost构建系统（即使您想要构建64位）：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On a 64-bit system with a 32-bit Visual Studio installation, Visual Studio
    is typically installed under `C:\Program Files (x86)`, so you will have to run
    this command instead:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在64位系统上安装32位Visual Studio时，Visual Studio通常安装在`C:\Program Files (x86)`下，因此您将不得不运行以下命令：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Generate the Boost build system for your toolset:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的工具集生成Boost构建系统：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to build 64-bit Boost libraries, initialize the 64-bit Visual C++
    build environment:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要构建64位Boost库，请初始化64位Visual C++构建环境：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On a 64-bit system with 32-bit Visual Studio installation, you will have to
    run this command instead:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在64位系统上安装32位Visual Studio时，您将不得不运行以下命令：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Extract the `bzip2` and `zlib` source archives, and make a note of the directories
    they have been extracted to.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取`bzip2`和`zlib`源存档，并记下它们被提取到的目录。
- en: 'Build the libraries and install them. If you want to build 32-bit libraries,
    use the following command line:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建库并安装它们。如果您想要构建32位库，请使用以下命令行：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you want to build 64-bit libraries, use the following command line:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要构建64位库，请使用以下命令行：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This last step builds and installs the necessary headers and libraries in the
    following directories:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步在以下目录中构建并安装了必要的头文件和库：
- en: '| Directory | Files |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | 文件 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boost-dir/include` | All header files present in a hierarchy under the `boost`
    directory. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir/include` | `boost`目录下的所有头文件。 |'
- en: '| `boost-dir/libs` | All 32-bit Boost libraries, static and shared libraries
    (DLLs), debug and release. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir/libs` | 所有32位Boost库，静态和共享库（DLL），调试和发布。 |'
- en: '| `boost-dir/libs64` | All 64-bit Boost libraries, static and shared libraries
    (DLLs), debug and release |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `boost-dir/libs64` | 所有64位Boost库，静态和共享库（DLL），调试和发布。 |'
- en: In addition to the Boost libraries, you should also see `boost_zlib-mt.dll`
    and `boost_bzip2-mt.dll`—the DLLs for `zlib` and `bzip2`, which `boost_iostreams-mt.dll`
    depends on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Boost库，您还应该看到`boost_zlib-mt.dll`和`boost_bzip2-mt.dll`——`boost_iostreams-mt.dll`依赖的`zlib`和`bzip2`的DLL。
- en: 'Let us take a look at the various options we have used in the preceding commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们在前面命令中使用的各种选项：
- en: The `--build-dir` option will identify the directory in which the intermediate
    products of the build are created.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build-dir`选项将标识出构建的中间产品所在的目录。'
- en: The `--layout=tagged` option chooses the tagged layout for the library names,
    as explained earlier.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--layout=tagged`选项选择了库名称的标记布局，如前所述。'
- en: We will build only the shared libraries (`link=shared`). If possible, link them
    to the dynamic runtime (`runtime-link=shared`), and create thread-safe libraries
    (`threading=multi`).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将只构建共享库（`link=shared`）。如果可能的话，将它们链接到动态运行时（`runtime-link=shared`），并创建线程安全库（`threading=multi`）。
- en: We will want both debug and release versions of the library (`variant=debug,release`).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要库的调试版本和发布版本（`variant=debug,release`）。
- en: The 32- and 64-bit builds will take place in separate intermediate directories
    identified by the `--build-dir` option and will be copied to separate library
    directories identified by the `--libdir` option.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位和64位构建将在由`--build-dir`选项标识的不同中间目录中进行，并将被复制到由`--libdir`选项标识的不同库目录中。
- en: The `address-model=64` option would trigger the 64-bit build.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address-model=64`选项将触发64位构建。'
- en: Under Visual Studio 2013, C++11 support is automatically enabled, and you do
    not need to use any specific switches for the purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio 2013下，C++11支持会自动启用，您无需为此使用任何特定的开关。
- en: Using Boost libraries in your projects
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的项目中使用Boost库
- en: We shall now write our first small C++ program that uses the Boost Filesystem
    library to check for the existence of a file whose name is passed to on the command
    line and then build on Linux and Windows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写我们的第一个小型C++程序，该程序使用Boost文件系统库来检查命令行传递的文件名的存在，并在Linux和Windows上构建。
- en: 'Here is the listing for `chkfile.cpp`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`chkfile.cpp`的清单：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Linking against Boost libraries on Linux
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux上链接Boost库
- en: 'If you have installed Boost in a nonstandard location (which is typically the
    case if you have not installed it from a native package), then you will need to
    make sure that your preprocessor can find the Boost header files you have included
    using the `–I` option in the compiler:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在非标准位置安装了Boost（如果您没有从本机包安装它，这通常是情况），那么您需要确保您的预处理器可以使用编译器中的`-I`选项找到您包含的Boost头文件：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This step will create an object file called `chkfile.o`, which we will link
    to the binary. You can specify which library to link to using the `-l` option.
    In case of a nonstandard installation, you will need to ensure that the linker
    can find the path to the library you want to link against using the `-L` option:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步将创建一个名为`chkfile.o`的目标文件，我们将把它链接到二进制文件。您可以使用`-l`选项指定要链接到的库。在非标准安装的情况下，您需要确保链接器可以使用`-L`选项找到要链接的库的路径：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the `-std=c++11` option only if you built your Boost libraries using C++11.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用C++11构建Boost库时才使用`-std=c++11`选项。
- en: 'The preceding command line will work for either a static or a shared library.
    However, if both types of library are found, it will use the shared version. You
    can override this with appropriate linker options:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令行将适用于静态库或共享库。但是，如果找到了两种类型的库，它将使用共享版本。您可以使用适当的链接器选项覆盖此行为：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding case, the `filesystem` library is linked statically while others
    are linked dynamically. The `-Wl` switch is used to pass its arguments to the
    linker. In this case, it passes the `-Bstatic` and `-Bdynamic` switches.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的案例中，`filesystem`库是静态链接的，而其他库是动态链接的。使用`-Wl`开关将其参数传递给链接器。在这种情况下，它传递了`-Bstatic`和`-Bdynamic`开关。
- en: 'If it is a shared library that you link against, then at runtime the dynamic
    linker needs to locate the shared library and load it too. The way to ensure this
    varies from one version of Unix to the other. One way to ensure this is to embed
    a search path in your executable using the `rpath` linker directive:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您链接的是共享库，那么在运行时，动态链接器需要定位共享库并加载它。确保这一点的方法因Unix的不同版本而异。确保这一点的一种方法是使用`rpath`链接器指令在可执行文件中嵌入一个搜索路径：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On the target system, where the binary `mytest` is run, the dynamic linker would
    look for the `filesystem` and `system` shared libraries under `/opt/boost/lib`
    and `/usr/lib/boost`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行二进制文件`mytest`的目标系统上，动态链接器将在`/opt/boost/lib`和`/usr/lib/boost`下查找`filesystem`和`system`共享库。
- en: Other ways besides using the `rpath` mechanism also exist. Linux uses a utility
    called `ldconfig` to locate shared libraries and update search paths. For more
    details, look at the man pages for `ldconfig (8)`. On Solaris, the `crle` utility
    performs a similar action.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`rpath`机制之外，还有其他方法。Linux使用一个叫做`ldconfig`的实用程序来定位共享库并更新搜索路径。有关更多详细信息，请查看`ldconfig
    (8)`的man页面。在Solaris上，`crle`实用程序执行类似的操作。
- en: Linking against Boost libraries on Windows
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上链接Boost库
- en: Using the Visual Studio IDE, we will have to tweak certain project settings
    in order to link against the Boost libraries.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio IDE，我们将不得不调整某些项目设置，以便链接到Boost库。
- en: 'First, ensure that your compiler is able to find the necessary header files:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您的编译器能够找到必要的头文件：
- en: Open your C++ project in Visual Studio. From the menu, select **Project** |
    **Project Properties**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开您的C++项目。从菜单中选择**项目** | **项目属性**。
- en: In the **Property Pages** dialog that comes up, expand **Configuration Properties**
    and select **C/C++**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的**属性页**对话框中，展开**配置属性**并选择**C/C++**。
- en: Edit the value of **Additional Include Directories** by adding the path to your
    Boost, include directories. Separate it from other entries in the field using
    a semicolon:![Linking against Boost libraries on Windows](img/1217OT_01_01.jpg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加路径到您的Boost包含目录，编辑**附加包含目录**的值。用分号与字段中的其他条目分隔开：![在Windows上链接Boost库](img/1217OT_01_01.jpg)
- en: Next, ensure that your linker is able to find the shared or static libraries.
    In the **Project Properties** dialog, under **Configuration Properties**, choose
    **Linker**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保您的链接器能够找到共享或静态库。在**项目属性**对话框中，在**配置属性**下，选择**链接器**。
- en: Edit the **Additional Library Directories** field to add the path to the Boost
    libraries, separated by a semicolon from any other entries:![Linking against Boost
    libraries on Windows](img/1217OT_01_02.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑**附加库目录**字段，添加路径到Boost库，用分号与字段中的其他条目分隔开：![在Windows上链接Boost库](img/1217OT_01_02.jpg)
- en: Now you can leverage Boost's *auto-linking* feature on Windows to automatically
    link to the correct libraries. To enable this, you have to define the `BOOST_ALL_DYN_LINK`
    preprocessor symbol. To do this, in the **Project Properties** dialog, navigate
    to **Configuration Properties** | **C/C++** | **Preprocessor**, and add `BOOST_ALL_DYN_LINK`
    to the **Preprocessor Definitions** field, separating it from other entries with
    a semicolon.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在Windows上利用Boost的*自动链接*功能自动链接到正确的库。要启用此功能，您必须定义`BOOST_ALL_DYN_LINK`预处理符号。要做到这一点，在**项目属性**对话框中，导航到**配置属性**
    | **C/C++** | **预处理器**，并将`BOOST_ALL_DYN_LINK`添加到**预处理器定义**字段中，并用分号与其他条目分隔开。
- en: 'If you built your Boost libraries on Windows with the default layout (versioned),
    this is all you will need to do for linking correctly. If we use the tagged layout,
    we must also define a second preprocessor symbol `BOOST_AUTO_LINK_TAGGED`. If
    we use system layout for naming, we will need to define `BOOST_AUTO_LINK_NOMANGLE`
    instead. You will get a linker error without these definitions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上使用默认布局（带版本号）构建了Boost库，这就是您正确链接所需做的一切。如果我们使用了标记布局，我们还必须定义第二个预处理符号`BOOST_AUTO_LINK_TAGGED`。如果我们使用系统布局进行命名，我们将需要定义`BOOST_AUTO_LINK_NOMANGLE`。如果没有这些定义，您将收到链接器错误：
- en: '![Linking against Boost libraries on Windows](img/1217OT_01_03.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![在Windows上链接Boost库](img/1217OT_01_03.jpg)'
- en: 'You should now be able to build your project from your IDE without any problems.
    In order to run your program, the dynamic linker must be able to locate the dynamic
    library. To take care of this, on Windows, you can add the path of your Boost
    libraries to the PATH environment variable. For running your programs from within
    the IDE, you can add the path of your Boost libraries to the PATH variable by
    navigating to **Debugging** | **Environment**, as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够在IDE中构建你的项目而不会出现任何问题。为了运行你的程序，动态链接器必须能够找到动态库。在Windows上，你可以将Boost库的路径添加到PATH环境变量中。在IDE中运行程序时，你可以通过导航到**调试**
    | **环境**，将Boost库的路径添加到PATH变量中，如下截图所示：
- en: '![Linking against Boost libraries on Windows](img/1217OT_01_04.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![在Windows上链接Boost库](img/1217OT_01_04.jpg)'
- en: Building the code listings in this book
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建本书中的代码示例
- en: Each chapter in this book includes the example source code, which is also available
    for download from the Packt website ([http://www.packtpub.com](http://www.packtpub.com)).
    You should download and build these examples on your development machines.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的每一章都包括示例源代码，也可以从Packt网站（[http://www.packtpub.com](http://www.packtpub.com)）下载。你应该在你的开发机器上下载并构建这些示例。
- en: CMake
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake
- en: In order to build the examples, you need to install CMake, which is one of the
    most popular cross-platform build tools for C++ programs. With CMake, you can
    easily generate a build system of your choice on an operating system of your choice,
    using a single set of CMake specifications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建示例，你需要安装CMake，这是C++程序最流行的跨平台构建工具之一。使用CMake，你可以在你选择的操作系统上轻松生成一个构建系统，使用一组CMake规范。
- en: You can download a binary package for CMake from [www.cmake.org](http://www.cmake.org),
    or download a source archive and build it on a platform of your choice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[www.cmake.org](http://www.cmake.org)下载CMake的二进制包，或者下载源代码存档并在你选择的平台上构建它。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Minimum version required**: CMake 2.8.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**最低版本要求**：CMake 2.8。'
- en: '**Windows**: A 32-bit exe-installer is available for Windows that works for
    both 32-bit and 64-bit builds.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**：Windows有一个32位的exe安装程序，适用于32位和64位版本。'
- en: '**Linux**: CMake is usually bundled with all major Linux distributions and
    is available as an optional package. Consult your distribution''s package repository.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux**：CMake通常捆绑在所有主要的Linux发行版中，并作为一个可选包提供。请查阅你的发行版软件包库。'
- en: Code examples
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'Download the source code archive and extract it to a directory on your development
    machine. The layout of the extracted directory would look like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下载源代码存档并将其解压到开发机器上的一个目录。解压后的目录布局如下：
- en: '![Code examples](img/1217OT_01_05.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/1217OT_01_05.jpg)'
- en: The source code archive available for download contains separate directories
    for each chapter. Within each chapter directory, you will find the complete source
    code for each example. The source code files are named based on the listing identifier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的源代码存档包含每一章的单独目录。在每个章节目录中，你会找到每个示例的完整源代码。源代码文件的命名基于列表标识符。
- en: 'A listing identifier is a unique tag used for examples in this book, as shown
    in the following screenshot:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表标识符是本书中示例的唯一标签，如下截图所示：
- en: '![Code examples](img/1217OT_01_06.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例](img/1217OT_01_06.jpg)'
- en: Here, the listing identifier is **Listing 11.18** and indicates that this is
    the eighteenth example in [Chapter 11](ch11.html "Chapter 11. Network Programming
    Using Boost Asio"), *Network Programming Using Boost Asio*. Therefore, in the
    `ch11` folder, you will find `listing11_18.cpp`, which contains the asynchronous
    UDP server example that appears in [Chapter 11](ch11.html "Chapter 11. Network
    Programming Using Boost Asio"), *Network Programming Using Boost Asio*. In some
    cases, a big example is broken down into multiple listings in the text, but they
    all form part of the same source file. In such cases the listings are tagged with
    letters; for example, listing 7.22a, 7.22b, 7.22c, and so on. You can still expect
    a file called `listing7_22.cpp`, which combines the code from these listings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，列表标识符是**列表11.18**，表示这是[第11章](ch11.html "第11章。使用Boost Asio进行网络编程")中的第18个示例，*使用Boost
    Asio进行网络编程*。因此，在`ch11`文件夹中，你会找到`listing11_18.cpp`，其中包含了出现在[第11章](ch11.html "第11章。使用Boost
    Asio进行网络编程")中的异步UDP服务器示例，*使用Boost Asio进行网络编程*。在某些情况下，一个大的示例被分解成文本中的多个列表，但它们都是同一个源文件的一部分。在这种情况下，列表会被标记为字母；例如，列表7.22a，7.22b，7.22c等。你仍然可以期望有一个名为`listing7_22.cpp`的文件，其中包含了这些列表中的代码。
- en: 'In order to build all the examples in this book, you need to follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中的所有示例，你需要按照以下步骤进行：
- en: Make sure that CMake 2.8 or higher is installed.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装了CMake 2.8或更高版本。
- en: Extract the source archive for the book to a directory, say `srcdir`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本书的源代码存档解压到一个目录，比如`srcdir`。
- en: 'Change to the `cmake_bin` directory under the source directory:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到源目录下的`cmake_bin`目录：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Export the `BOOST_DIR` environment variable to point to the Boost installation
    directory.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出`BOOST_DIR`环境变量，指向Boost安装目录。
- en: 'For example, if it is `/opt/boost` on Linux, you can run the following command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Linux上，如果是`/opt/boost`，你可以运行以下命令：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you have installed Boost from a standard package in the package repository
    of your distribution, then you can skip this step.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从发行版的软件包库中安装了Boost，那么你可以跳过这一步。
- en: 'On Windows, if you have installed it under `f:\boost`, you can run this command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，如果你已经安装在`f:\boost`下，你可以运行这个命令：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the Boost include directory and the Boost library directory do not share
    a common parent, as may be the case if you installed a binary distribution of
    Boost, then you should skip setting `BOOST_DIR` and instead set the following
    two environment variables:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Boost的包含目录和库目录没有共同的父目录，比如你安装了一个二进制发行版的Boost，那么你应该跳过设置`BOOST_DIR`，而是设置以下两个环境变量：
- en: '`BOOST_INCDIR` should be set to the directory that contains the Boost header
    files, for example, `/usr/include` on Ubuntu.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_INCDIR`应该设置为包含Boost头文件的目录，例如，在Ubuntu上为`/usr/include`。'
- en: '`BOOST_LIBDIR` should be set to the directory that contains the Boost library
    files, for example, `/usr/lib/x86_64-linux-gnu` on Ubuntu.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_LIBDIR`应该设置为包含Boost库文件的目录，例如，在Ubuntu上为`/usr/lib/x86_64-linux-gnu`。'
- en: Generate the build system of your choice using CMake.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CMake生成你选择的构建系统。
- en: 'On Linux, run the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，运行以下命令：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This generates a Makefile-based build system using GNU g++. If you want to
    use clang++ instead, export the environment variables CC and CXX, as shown here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用GNU g++生成基于Makefile的构建系统。如果你想使用clang++，可以像这样导出环境变量CC和CXX：
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On Windows, run the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，运行以下命令：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This generates a Visual C++ 2013 solution file and project files. The string
    passed with the `-G` option is called the generator string and identifies the
    toolchain for which you want to generate the build system. The CMake documentation
    lists all the supported generator strings. For our purposes, we will use **Visual
    Studio 12** or **Visual Studio 12 Win64**.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个Visual C++ 2013解决方案文件和项目文件。使用`-G`选项传递的字符串称为生成器字符串，用于标识要生成构建系统的工具链。CMake文档列出了所有支持的生成器字符串。对于我们的目的，我们将使用**Visual
    Studio 12**或**Visual Studio 12 Win64**。
- en: Build the sources using the generated build system.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的构建系统构建源代码。
- en: 'On Linux, you can build it by simply running the following command:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，你可以通过简单地运行以下命令来构建它：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On Windows, it is best to build by opening the generated solution file in Visual
    C++ IDE and then building all the sources or a single source at a time. You can
    run the examples by running the executables formed under `srcdir/lbcpp-src/bin`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，最好通过在Visual C++ IDE中打开生成的解决方案文件，然后构建所有源文件或一次构建一个源文件来构建。你可以通过运行在`srcdir/lbcpp-src/bin`下生成的可执行文件来运行示例。
- en: We do not cover CMake in this book. It is worth exploring CMake further on your
    own, and a great place to get started is the CMake Wiki ([http://www.cmake.org/Wiki/CMake](http://www.cmake.org/Wiki/CMake)).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中没有涵盖CMake。值得自己进一步探索CMake，一个很好的起点是CMake Wiki（[http://www.cmake.org/Wiki/CMake](http://www.cmake.org/Wiki/CMake)）。
- en: Self-test questions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: What are the different types of name layouts supported by Boost libraries?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost库支持的不同类型的名称布局是什么？
- en: a. Tagged, native, and mangled
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: a. 标记，本地和混淆
- en: b. Tagged, mangled, and versioned
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: b. 标记，混淆和版本化
- en: c. Tagged, versioned, and system
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: c. 标记，版本化和系统
- en: d. Versioned, systems, and decorated
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: d. 版本化，系统和装饰
- en: Boost allows you to automatically link to necessary Boost libraries on Windows.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Boost允许你在Windows上自动链接到必要的Boost库。
- en: a. True
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: a. 真
- en: b. False
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: What does the following filename tell you about the library?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下文件名对你有什么了解？
- en: '`boost_date_time-vc100-mt-gd-1_57.dll`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost_date_time-vc100-mt-gd-1_57.dll`'
- en: Tick all that apply.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有适用的选项。
- en: a. It is the DateTime library.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: a. 这是DateTime库。
- en: b. It is a thread-safe library.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: b. 这是一个线程安全的库。
- en: c. It was built using g++.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它是使用g++构建的。
- en: d. It is not a debug library.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: d. 这不是一个调试库。
- en: What is the name layout of the following library?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下库的名称布局是什么？
- en: '`libboost_exception-mt-gd.lib`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`libboost_exception-mt-gd.lib`'
- en: a. Tagged
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: a. 标记
- en: b. System
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: b. 系统
- en: c. Versioned
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: c. 版本化
- en: d. Default
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: d. 默认
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we got an overview of the Boost C++ libraries and set up a
    development environment for us, which should help us to easily build and run C++
    programs, using Boost libraries that we will learn in the rest of the book.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了Boost C++库，并为我们设置了一个开发环境，这应该帮助我们轻松地构建和运行C++程序，使用我们将在本书的其余部分学习的Boost库。
- en: In the next chapter, we will learn a variety of techniques using different Boost
    libraries, which simplify some common day-to-day programming tasks and set us
    up for the heavy lifting to be done in the later chapters.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用不同的Boost库的各种技术，这些库简化了一些日常编程任务，并为我们在后面的章节中要完成的繁重工作做好了准备。
