- en: Working with Numbers and Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字和字符串
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的示例有：
- en: Converting between numeric and string types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字和字符串类型之间进行转换
- en: Limits and other properties of numeric types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类型的限制和其他属性
- en: Generating pseudo-random numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成伪随机数
- en: Initializing all bits of internal state of a pseudo-random number generator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化伪随机数生成器的内部状态的所有位
- en: Using raw string literals to avoid escaping characters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量来避免转义字符
- en: Creating cooked user-defined literals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建熟练的用户定义字面量
- en: Creating raw user-defined literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原始用户定义字面量
- en: Creating a library of string helpers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字符串助手库
- en: Verifying the format of a string using regular expressions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式验证字符串的格式
- en: Parsing the content of a string using regular expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串的内容
- en: Replacing the content of a string using regular expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式替换字符串的内容
- en: Using string_view instead of constant string references
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用string_view而不是常量字符串引用
- en: Converting between numeric and string types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数字和字符串类型之间进行转换
- en: Converting between number and string types is a ubiquitous operation. Prior
    to C++11, there was little support for converting numbers to strings and back,
    and developers had to resort mostly to type-unsafe functions and usually wrote
    their own utility functions in order to avoid writing the same code over and over
    again. With C++11, the standard library provides utility functions for converting
    between numbers and strings. In this recipe, you will learn how to convert between
    numbers and strings and the other way around using modern C++ standard functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字和字符串类型之间进行转换是一种普遍的操作。在C++11之前，几乎没有支持将数字转换为字符串和反向转换的功能，开发人员大多需要使用不安全的类型函数，并通常编写自己的实用函数，以避免一遍又一遍地编写相同的代码。有了C++11，标准库提供了用于在数字和字符串之间进行转换的实用函数。在本示例中，您将学习如何使用现代C++标准函数在数字和字符串之间进行转换。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the utility functions mentioned in this recipe are available in the `<string>`
    header.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中提到的所有实用函数都位于`<string>`头文件中。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use the following standard conversion functions when you need to convert between
    numbers and strings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要在数字和字符串之间进行转换时，请使用以下标准转换函数：
- en: 'To convert from an integer or floating point type to a string type, use `std::to_string()`
    or `std::to_wstring()` as shown in the following code snippet:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将整数或浮点类型转换为字符串类型，请使用`std::to_string()`或`std::to_wstring()`，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To convert from a string type to an integer type, use `std::stoi()`, `std::stol()`,
    `std::stoll()`, `std::stoul()`, or `std::stoull()`; refer to the following code
    snippet:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字符串类型转换为整数类型，请使用`std::stoi()`，`std::stol()`，`std::stoll()`，`std::stoul()`或`std::stoull()`；请参阅以下代码片段：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To convert from a string type to a floating point type, use `std::stof()`,
    `std::stod()`, or `std::stold()`, as shown in the following code snippet:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字符串类型转换为浮点类型，请使用`std::stof()`，`std::stod()`或`std::stold()`，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: To convert between an integral or floating point type to a string type, you
    can use either the `std::to_string()` or `std::to_wstring()` function. These functions
    are available in the `<string>` header and have overloads for signed and unsigned
    integer and real types. They produce the same result as `std::sprintf()` and `std::swprintf()`
    would produce when called with the appropriate format specifier for each type.
    The following code snippet list all the overloads of these two functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在整数或浮点类型与字符串类型之间进行转换，可以使用`std::to_string()`或`std::to_wstring()`函数。这些函数位于`<string>`头文件中，并且对于有符号和无符号整数和实数类型都有重载。它们产生与调用适当格式说明符的`std::sprintf()`和`std::swprintf()`产生的相同结果。以下代码片段列出了这两个函数的所有重载。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When it comes to the opposite conversion, there is an entire set of functions
    that have the name with the format **ston** (**string to number**), where **n**
    stands for **i** (`integer`), **l** (`long`), **ll** (`long long`), **ul** (`unsigned
    long`), or **ull** (`unsigned long long`). The following listing shows all these
    functions, each of them with two overloads, one that takes an `std::string` and
    one that takes an `std::wstring` as the first parameter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行相反的转换时，有一整套函数，它们的名称格式为**ston**（**字符串到数字**），其中**n**代表**i**（`整数`），**l**（`长整型`），**ll**（`长长整型`），**ul**（`无符号长整型`）或**ull**（`无符号长长整型`）。以下清单显示了所有这些函数，每个函数都有两个重载，一个接受`std::string`，另一个接受`std::wstring`作为第一个参数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The way the string to integral type functions work is by discarding all white
    spaces before a non-whitespace character, then taking as many characters as possible
    to form a signed or unsigned number (depending on the case), and then converting
    that to the requested integral type (`stoi()` will return an `integer`, `stoul()`
    will return an `unsigned long`, and so on). In all the following examples, the
    result is integer `42`, except for the last example where the result is `-42`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串到整数类型函数的工作方式是在非空白字符之前丢弃所有空格，然后尽可能多地取字符以形成有符号或无符号数字（取决于情况），然后将其转换为请求的整数类型（`stoi()`将返回`整数`，`stoul()`将返回`无符号长整型`，依此类推）。在所有以下示例中，结果都是整数`42`，除了最后一个示例，结果是`-42`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A valid integral number may consist of the following parts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的整数可能由以下部分组成：
- en: A sign, plus (`+`) or minus (`-`) (optional).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个符号，加号（`+`）或减号（`-`）（可选）。
- en: Prefix `0` to indicate an octal base (optional).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀`0`表示八进制基数（可选）。
- en: Prefix `0x` or `0X` to indicate a hexadecimal base (optional).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀`0x`或`0X`表示十六进制基数（可选）。
- en: A sequence of digits.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数字。
- en: The optional prefix `0` (for octal) is applied only when the specified base
    is `8` or `0`. Similarly, the optional prefix `0x` or `0X` (for hexadecimal) is
    applied only when the specified base is `16` or `0`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可选前缀`0`（表示八进制）仅在指定基数为`8`或`0`时应用。类似地，可选前缀`0x`或`0X`（表示十六进制）仅在指定基数为`16`或`0`时应用。
- en: 'The functions that convert a string to an integer have three parameters:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为整数的函数具有三个参数：
- en: The input string.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字符串。
- en: A pointer that when not null will receive the number of characters that were
    processed and that can include any leading white spaces that were discarded, the
    sign, and the base prefix, so it should not be confused with the number of digits
    the integral value has.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针，如果不为空，将接收处理的字符数，可以包括任何被丢弃的前导空格，符号和基数前缀，因此不应与整数值的数字数量混淆。
- en: A number indicating the base; by default, this is `10`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示基数的数字；默认情况下为`10`。
- en: The valid digits in the input string depend on the base. For base `2`, the only
    valid digits are `0` and `1`; for base `5`, they are `01234`. For base `11`, the
    valid digits are `0-9` and characters `A` and `a`. This continues until we reach
    base `36` that has valid characters `0-9`, `A-Z`, and `a-z`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符串中的有效数字取决于基数。对于基数`2`，唯一有效的数字是`0`和`1`；对于基数`5`，它们是`01234`。对于基数`11`，有效数字是`0-9`和字符`A`和`a`。这一直持续到我们达到基数`36`，它具有有效字符`0-9`，`A-Z`和`a-z`。
- en: 'The following are more examples of strings with numbers in various bases converted
    to decimal integers. Again, in all cases, the result is either `42` or `-42`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将各种基数的字符串转换为十进制整数的更多示例。同样，在所有情况下，结果要么是`42`，要么是`-42`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An important thing to note is that these conversion functions throw if the
    conversion fails. There are two exceptions that can be thrown:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，如果转换失败，这些转换函数会抛出异常。可以抛出两种异常：
- en: '`std::invalid_argument`: If the conversion cannot be performed:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::invalid_argument`：如果无法执行转换：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`std::out_of_range`: If the converted value is outside the range of the result
    type (or if the underlying function sets `errno` to `ERANGE`):'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::out_of_range`：如果转换后的值超出了结果类型的范围（或者如果底层函数将`errno`设置为`ERANGE`）：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The other set of functions that convert a string to a floating point type is
    very similar, except that they don''t have a parameter for the numeric base. A
    valid floating point value can have different representations in the input string:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为浮点类型的另一组函数非常相似，只是它们没有用于数字基数的参数。有效的浮点值可以在输入字符串中有不同的表示：
- en: Decimal floating point expression (optional sign, sequence of decimal digits
    with optional point, optional `e` or `E` followed by exponent with optional sign).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制浮点表达式（可选符号，带有可选小数点的十进制数字序列，可选的`e`或`E`后跟带有可选符号的指数）。
- en: Binary floating point expression (optional sign, `0x` or `0X` prefix, sequence
    of hexadecimal digits with optional point, optional `p` or `P` followed by exponent
    with optional sign).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制浮点表达式（可选符号，`0x`或`0X`前缀，带有可选小数点的十六进制数字序列，可选的`p`或`P`后跟带有可选符号的指数）。
- en: Infinity expression (optional sign followed by case insensitive `INF` or `INFINITY`).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷大表达式（可选符号后跟不区分大小写的`INF`或`INFINITY`）。
- en: A non-number expression (optional sign followed by case insensitive `NAN` and
    possibly other alphanumeric characters).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非数字表达式（可选符号后跟不区分大小写的`NAN`和可能的其他字母数字字符）。
- en: 'The following are various examples of converting strings to doubles:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将字符串转换为双精度浮点数的各种示例：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The floating-point base 2 scientific notation, seen earlier in the form `0xF.6E6666p3`,
    is not the topic of this recipe. However, for a clear understanding, a short description
    is provided; although, it is recommended that you see additional references for
    details. A floating-point constant in the base 2 scientific notation is composed
    of several parts:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前看到的浮点基数2科学计数法，以`0xF.6E6666p3`的形式出现，不是本篇文章的主题。但是，为了清楚起见，提供了一个简短的描述；尽管建议您查看其他参考资料以获取详细信息。基数2科学计数法中的浮点常数由几个部分组成：
- en: The hexadecimal prefix `0x`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制前缀`0x`。
- en: An integer part, in this example was `F`, which in decimal is 15.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数部分，在这个例子中是`F`，在十进制中是15。
- en: 'A fractional part, which in this example was `6E6666`, or `011011100110011001100110`
    in binary. To convert that to decimal, we need to add inverse powers of two: `1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小数部分，在这个例子中是`6E6666`，或者用二进制表示为`011011100110011001100110`。要将其转换为十进制，我们需要加上二的倒数幂：`1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`。
- en: A suffix, representing a power of 2; in this example, `p3` means 2 at the power
    of 3.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后缀，表示2的幂；在这个例子中，`p3`表示2的3次幂。
- en: The value of the decimal equivalent is determined by multiplying the significant
    (composed of the integer and fractional parts) and the base at the power of exponent.
    For the given hexadecimal base 2 floating point literal, the significant is `15.4312499...`
    (note that digits after the seventh one are not shown), the base is 2, and the
    exponent is 3\. Therefore, the result is `15.4212499... * 8`, which is `123.44999980926514`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制等价值的值由乘以有效数字（由整数和小数部分组成）和基数的幂决定。对于给定的十六进制基数2浮点文字，有效数字是`15.4312499...`（注意第七位后的数字没有显示），基数是2，指数是3。因此，结果是`15.4212499...
    * 8`，即`123.44999980926514`。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**Limits and other properties of numeric types**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字类型的限制和其他属性**'
- en: Limits and other properties of numeric types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型的限制和其他属性
- en: Sometimes, it is necessary to know and use the minimum and maximum values representable
    with a numeric type, such as `char`, `int`, or `double`. Many developers are using
    standard C macros for this, such as `CHAR_MIN`/`CHAR_MAX`, `INT_MIN`/`INT_MAX`,
    or `DBL_MIN`/`DBL_MAX`. C++ provides a class template called `numeric_limits`
    with specializations for every numeric type that enables you to query the minimum
    and maximum value of a type, but is not limited to that and offers additional
    constants for type properties querying, such as whether a type is signed or not,
    how many bits it needs for representing its values, for floating point types whether
    it can represent infinity, and many others. Prior to C++11, the use of `numeric_limits<T>`
    was limited because it could not be used in places where constants were needed
    (examples can include the size of arrays and switch cases). Due to that, developers
    preferred to use the C macros throughout their code. In C++11, that is no longer
    the case, as all the static members of `numeric_limits<T>` are now `constexpr`,
    which means they can be used everywhere a constant expression is expected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要知道和使用数值类型表示的最小和最大值，比如`char`、`int`或`double`。许多开发人员在这方面使用标准C宏，如`CHAR_MIN`/`CHAR_MAX`、`INT_MIN`/`INT_MAX`或`DBL_MIN`/`DBL_MAX`。C++提供了一个名为`numeric_limits`的类模板，为每种数值类型提供了特化，使您能够查询类型的最小和最大值，但不仅限于此，并提供了用于查询类型属性的其他常量，例如类型是否有符号，它需要多少位来表示其值，对于浮点类型是否可以表示无穷大等。在C++11之前，`numeric_limits<T>`的使用是有限的，因为它不能在需要常量的地方使用（例如数组的大小和switch
    case）。因此，开发人员更喜欢在他们的代码中使用C宏。在C++11中，情况已经不再是这样了，因为`numeric_limits<T>`的所有静态成员现在都是`constexpr`，这意味着它们可以在需要常量表达式的所有地方使用。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `numeric_limits<T>` class template is available in the namespace `std` in
    the `<limits>` header.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`numeric_limits<T>`类模板在`<limits>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use `std::numeric_limits<T>` to query various properties of a numeric type
    `T`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::numeric_limits<T>`来查询数值类型`T`的各种属性：
- en: 'Use `min()` and `max()` static methods to get the smallest and largest finite
    numbers of a type:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`min()`和`max()`静态方法来获取类型的最小和最大有限数：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use other static methods and static constants to retrieve other properties
    of a numeric type:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他静态方法和静态常量来检索数值类型的其他属性：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In C++11, there is no limitation to where `std::numeric_limits<T>` can be used;
    therefore, preferably use it over C macros in your modern C++ code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，`std::numeric_limits<T>`的使用没有限制；因此，在现代C++代码中最好使用它而不是C宏。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::numeric_limits<T>` is a class template that enables developers to
    query property of numeric types. Actual values are available through specializations,
    and the standard library provides specializations for all the built-in numeric
    types (`char`, `short`, `int`, `long`, `float`, `double`, and so on). In addition,
    third parties may provide additional implementation for other types. An example
    could be a numeric library that implements a `bigint` integer type and a `decimal`
    type and provides specializations of `numeric_limits` for these types (such as
    `numeric_limits<bigint>` and `numeric_limits<decimal>`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::numeric_limits<T>`是一个类模板，使开发人员能够查询数值类型的属性。实际值可以通过特化获得，并且标准库为所有内置数值类型（`char`、`short`、`int`、`long`、`float`、`double`等）提供了特化。此外，第三方可能为其他类型提供额外的实现。例如，一个数值库可能实现了`bigint`整数类型和`decimal`类型，并为这些类型提供了`numeric_limits`的特化（如`numeric_limits<bigint>`和`numeric_limits<decimal>`）。'
- en: 'The following specializations of numeric types are available in the `<limits>` header.
    Note that specializations for `char16_t` and `char32_t` are new in C++11; the
    others were available previously. Apart from the specializations listed ahead,
    the library also includes specializations for every `cv-qualified` version of
    these numeric types, and they are identical to the unqualified specialization.
    For example, consider type `int`; there are four actual specializations (and they
    are identical): `numeric_limits<int>`, `numeric_limits<const int>`, `numeric_limits<volatile
    int>`, and `numeric_limits<const volatile int>`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数值类型的特化在`<limits>`头文件中可用。请注意，`char16_t`和`char32_t`的特化是C++11中的新内容；其他的在此之前就已经可用了。除了列出的特化之外，该库还包括了这些数值类型的每个`cv-qualified`版本的特化，并且它们与未经修饰的特化相同。例如，考虑类型`int`；有四个实际的特化（它们是相同的）：`numeric_limits<int>`、`numeric_limits<const
    int>`、`numeric_limits<volatile int>`和`numeric_limits<const volatile int>`：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As mentioned earlier, in C++11, all static members of `numeric_limits` are
    `constexpr`, which means they can be used in all places where constant expressions
    are needed. These have several major advantages over C++ macros:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在C++11中，`numeric_limits`的所有静态成员都是`constexpr`，这意味着它们可以在需要常量表达式的所有地方使用。它们比C++宏有几个主要优势：
- en: They are easier to remember, as the only thing you need to know is the name
    of the type that you should know anyway, and not countless names of macros.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更容易记住，因为你唯一需要知道的是你本来就应该知道的类型的名称，而不是无数的宏名称。
- en: They support types that are not available in C, such as `char16_t` and `char32_t`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持在C中不可用的类型，比如`char16_t`和`char32_t`。
- en: They are the only possible solution for templates where you don't know the type.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是你不知道类型的模板的唯一可能的解决方案。
- en: Minimum and maximum are only two of the various properties of types it provides;
    therefore, its actual use is beyond the numeric limits. As a side note, for this
    reason, the class should have been perhaps called `numeric_properties`, instead
    of `numeric_limits`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值和最大值只是它提供的各种类型属性中的两个；因此，它的实际用途超出了数值限制。顺便说一句，因此，这个类可能本应该被称为`numeric_properties`，而不是`numeric_limits`。
- en: 'The following function template `print_type_properties()` prints the minimum
    and maximum finite values of the type as well as other information:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数模板`print_type_properties()`打印类型的最小和最大有限值以及其他信息：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we call the `print_type_properties()` function for unsigned `short`, `int`,
    and `double`, it will have the following output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为无符号`short`，`int`和`double`调用`print_type_properties()`函数，将得到以下输出：
- en: '| `unsigned short` | `int` | `double` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short` | `int` | `double` |'
- en: '| min=0max=65535bits=16decdigits=4integral=1signed=0exact=1infinity=0 | min=-2147483648max=2147483647bits=31decdigits=9integral=1signed=1exact=1infinity=0
    | min=2.22507e-308max=1.79769e+308bits=53decdigits=15integral=0signed=1exact=0infinity=1
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| min=0max=65535bits=16decdigits=4integral=1signed=0exact=1infinity=0 | min=-2147483648max=2147483647bits=31decdigits=9integral=1signed=1exact=1infinity=0
    | min=2.22507e-308max=1.79769e+308bits=53decdigits=15integral=0signed=1exact=0infinity=1
    |'
- en: 'The one thing to take note of is the difference between the `digits` and `digits10`
    constants:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是`digits`和`digits10`常量之间的区别：
- en: '`digits` represent the number of bits (excluding the sign bit if present) and
    padding bits (if any) for integral types and the number of bits of the mantissa
    for floating point types.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digits`表示整数类型的位数（如果有符号位，则不包括符号位，如果有填充位，则包括填充位），浮点类型的尾数位数。'
- en: '`digits10` is the number of decimal digits that can be represented by a type
    without a change. To understand this better, let''s consider the case of `unsigned
    short`. This is a 16-bit integral type. It can represent numbers between 0 and
    65536\. It can represent numbers up to five decimal digits, 10,000 to 65,536,
    but it cannot represent all five decimal digit numbers, as numbers from 65,537
    to 99,999 require more bits. Therefore, the largest numbers that it can represent
    without requiring more bits have four decimal digits (numbers from 1,000 to 9,999).
    This is the value indicated by `digits10`. For integral types, it has a direct
    relationship to constant `digits`; for an integral type `T`, the value of `digits10`
    is `std::numeric_limits<T>::digits * std::log10(2)`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digits10`是类型可以表示的十进制数字的数量，而不需要更改。为了更好地理解这一点，让我们考虑一下`unsigned short`的情况。这是一个16位整数类型。它可以表示0到65536之间的数字。它可以表示多达五位十进制数字，即从10,000到65,536，但它不能表示所有五位十进制数字，因为从65,537到99,999的数字需要更多的位。因此，它可以表示的最大数字而不需要更多位的是四位十进制数字（从1,000到9,999）。这是`digits10`指示的值。对于整数类型，它与常量`digits`有直接关系；对于整数类型`T`，`digits10`的值为`std::numeric_limits<T>::digits
    * std::log10(2)`。'
- en: Generating pseudo-random numbers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成伪随机数
- en: Generating random numbers is necessary for a large variety of applications,
    from games to cryptography, from sampling to forecasting. However, the term *random
    numbers* is not actually correct, as the generation of numbers through mathematical
    formulas is deterministic and does not produce true random numbers, but numbers
    that look random and are called *pseudo-random*. True randomness can only be achieved
    through hardware devices, based on physical processes, and even that can be challenged,
    as one may consider even the universe to be actually deterministic. Modern C++
    provides support for generating pseudo-random numbers through a pseudo-random
    number library containing number generators and distributions. Theoretically,
    it can also produce true random numbers, but in practice, those could actually
    be only pseudo-random.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数对于各种应用程序都是必要的，从游戏到密码学，从抽样到预测。然而，“随机数”这个术语实际上并不正确，因为通过数学公式生成数字是确定性的，不会产生真正的随机数，而是看起来随机的数字，称为“伪随机”。真正的随机性只能通过基于物理过程的硬件设备实现，即使这也可能受到质疑，因为人们甚至可能认为宇宙实际上是确定性的。现代C++提供了通过包含数字生成器和分布的伪随机数库来生成伪随机数的支持。从理论上讲，它也可以产生真正的随机数，但在实践中，这些实际上可能只是伪随机数。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we discuss the standard support for generating pseudo-random
    numbers. Understanding the difference between random and pseudo-random numbers
    is the key. On the other hand, being familiar with various statistical distributions
    is a plus. It is mandatory, though, that you know what a uniform distribution
    is because all engines in the library produce numbers that are uniformly distributed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们讨论了生成伪随机数的标准支持。理解随机和伪随机数之间的区别是关键。另一方面，熟悉各种统计分布也是一个优势。然而，你必须知道均匀分布是什么，因为库中的所有引擎都产生均匀分布的数字。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To generate pseudo-random numbers in your application, you should perform the
    following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中生成伪随机数，应执行以下步骤：
- en: 'Include the header `<random>`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含头文件`<random>`：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use an `std::random_device` generator for seeding a pseudo-random engine:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::random_device`生成器来为伪随机引擎提供种子：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use one of the available engines for generating numbers and initialize it with
    a random seed:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可用的引擎之一生成数字并用随机种子初始化它：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use one of the available distributions for converting the output of the engine
    to one of the desired statistical distributions:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可用的分布之一将引擎的输出转换为所需的统计分布之一：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Generate the pseudo-random numbers:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成伪随机数：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The pseudo-random number library contains two types of components:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数库包含两种类型的组件：
- en: '*Engines*, which are generators of random numbers; these could produce either
    pseudo-random numbers with a uniform distribution or, if available, actual random
    numbers.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引擎*是随机数的生成器；这些可以产生具有均匀分布的伪随机数，或者如果可用，实际随机数。'
- en: '*Distributions* that convert the output of an engine into a statistical distribution.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分布*将引擎的输出转换为统计分布。'
- en: 'All engines (except for `random_device`) produce integer numbers in a uniform
    distribution, and all engines implement the following methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎（除了`random_device`）都以均匀分布产生整数，所有引擎都实现以下方法：
- en: '`min()`: This is a static method that returns the minimum value that can be
    produced by the generator.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()`: 这是一个静态方法，返回生成器可以产生的最小值。'
- en: '`max()`: This is a static method that returns the maximum value that can be
    produced by the generator.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`: 这是一个静态方法，返回生成器可以产生的最大值。'
- en: '`seed()`: This initializes the algorithm with a start value (except for `random_device`,
    which cannot be seeded).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed()`: 用起始值初始化算法（除了 `random_device`，它不能被种子化）。'
- en: '`operator()`: This generates a new number uniformly distributed between `min()`
    and `max()`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator()`: 生成一个在 `min()` 和 `max()` 之间均匀分布的新数字。'
- en: '`discard()`: This generates and discards a given number of pseudo-random numbers.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard()`: 生成并丢弃给定数量的伪随机数。'
- en: 'The following engines are available:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引擎可用：
- en: '`linear_congruential_engine`: This is a linear congruential generator that
    produces numbers using the following formula:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性同余引擎：这是一个使用以下公式产生数字的线性同余生成器：
- en: '*x(i) = (A * x(i-1) + C) mod M*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*x(i) = (A * x(i-1) + C) mod M*'
- en: '`mersenne_twister_engine`: This is a Mersenne twister generator that keeps
    a value on *W * (N-1) * R* bits; each time a number needs to be generated, it
    extracts *W* bits. When all bits have been used, it twists the large value by
    shifting and mixing the bits so that it has a new set of bits to extract from.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mersenne_twister_engine：这是一个 Mersenne twister 生成器，保留了 *W * (N-1) * R* 位的值；每次需要生成一个数字时，它提取
    *W* 位。当所有位都被使用时，它通过移位和混合位来扭转大值，以便它有一个新的位组来提取。
- en: '`subtract_with_carry_engine`: This is a generator that implements a *subtract
    with carry* algorithm based on the following formula:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: subtract_with_carry_engine：这是一个基于以下公式实现 *减去进位* 算法的生成器：
- en: '*x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*x(i) = (x(i - R) - x(i - S) - cy(i - 1)) mod M*'
- en: 'In the preceding formula, *cy* is defined as:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述公式中，*cy* 定义为：
- en: '*cy(i) = x(i - S) - x(i - R) - cy(i - 1) < 0 ? 1 : 0*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*cy(i) = x(i - S) - x(i - R) - cy(i - 1) < 0 ? 1 : 0*'
- en: 'In addition, the library provides engine adapters that are also engines wrapping
    another engine and producing numbers based on the output of the base engine. Engine
    adapters implement the same methods mentioned earlier for the base engines. The
    following engine adapters are available:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该库还提供了引擎适配器，它们也是包装另一个引擎并基于基础引擎的输出生成数字的引擎。引擎适配器实现了前面提到的基础引擎的相同方法。以下引擎适配器可用：
- en: '`discard_block_engine`: A generator that from every block of P numbers generated
    by the base engine keeps only R numbers, discarding the rest.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: discard_block_engine：从基础引擎生成的每个P个数字块中仅保留R个数字，丢弃其余数字。
- en: '`independent_bits_engine`: A generator that produces numbers with a different
    number of bits than the base engine.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: independent_bits_engine：生成具有与基础引擎不同位数的数字的生成器。
- en: '`shuffle_order_engine`: A generator that keeps a shuffled table of K numbers
    produced by the base engine and returns numbers from this table, replacing them
    with numbers generated by the base engine.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shuffle_order_engine：保持基础引擎生成的K个数字的洗牌表，并从该表返回数字，用基础引擎生成的数字替换它们。
- en: All these engines and engine adaptors are producing pseudo-random numbers. The
    library, however, provides another engine called `random_device` that is supposed
    to produce non-deterministic numbers, but this is not an actual constraint as
    physical sources of random entropy might not be available. Therefore, implementations
    of `random_device` could actually be based on a pseudo-random engine. The `random_device` class
    cannot be seeded like the other engines and has an additional method called `entropy()` that
    returns the random device entropy, which is 0 for a deterministic generator and
    nonzero for a non-deterministic generator. However, this is not a reliable method
    for determining whether the device is actually deterministic or non-deterministic.
    For instance, both GNU `libstdc++` and LLVM `libc++` implement a non-deterministic
    device, but return `0` for entropy. On the other hand, `VC++` and `boost.random`
    return `32` and `10`, respectively, for entropy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些引擎和引擎适配器都产生伪随机数。然而，该库还提供了另一个称为 `random_device` 的引擎，它应该产生非确定性数字，但这并不是一个实际的约束，因为可能没有随机熵的物理来源。因此，`random_device`
    的实现实际上可能基于伪随机引擎。`random_device` 类不能像其他引擎一样进行种子化，并且具有一个额外的名为 `entropy()` 的方法，返回随机设备的熵，对于确定性生成器为0，对于非确定性生成器为非零。然而，这并不是确定设备实际上是确定性还是非确定性的可靠方法。例如，GNU
    `libstdc++` 和 LLVM `libc++` 实现了一个非确定性设备，但对于熵返回 `0`。另一方面，`VC++` 和 `boost.random`
    对于熵分别返回 `32` 和 `10`。
- en: 'All these generators produce integers in a uniform distribution. This is, however,
    only one of the many possible statistical distributions that random numbers are
    needed in most applications. To be able to produce numbers (either integer or
    real) in other distributions, the library provides several classes that are called
    *distributions* and are converting the output of an engine according to the statistical
    distribution it implements. The following distributions are available:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生成器产生均匀分布的整数。然而，这只是大多数应用程序中需要的许多可能统计分布中的一个。为了能够以其他分布（整数或实数）产生数字，该库提供了几个称为
    *分布* 的类，它们根据它们实现的统计分布将引擎的输出转换为数字。以下分布可用：
- en: '| **Type** | **Class name** | **Numbers** | **Statistical distribution** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '**类型** | **类名** | **数字** | **统计分布** |'
- en: '| Uniform | `uniform_int_distribution` | integer | Uniform |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: 均匀 | 均匀整数分布 | 整数 | 均匀 |
- en: '|  | `uniform_real_distribution` | real | Uniform |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: 均匀实数分布 | 实数 | 均匀 |
- en: '| Bernoulli | `bernoulli_distribution` | boolean | Bernoulli |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: 伯努利 | 伯努利分布 | 布尔 | 伯努利 |
- en: '|  | `binomial_distribution` | integer | binomial |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: 二项式 | 二项分布 | 整数 | 二项式 |
- en: '|  | `negative_binomial_distribution` | integer | negative binomial |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: 负二项式 | 负二项分布 | 整数 | 负二项式 |
- en: '|  | `geometric_distribution` | integer | geometric |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: 几何分布 | 整数 | 几何 |
- en: '| Poisson | `poisson_distribution` | integer | poisson |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: 泊松 | 泊松分布 | 整数 | 泊松 |
- en: '|  | `exponential_distribution` | real | exponential |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: 指数 | 指数分布 | 实数 | 指数 |
- en: '|  | `gamma_distribution` | real | gamma |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: 伽玛 | 伽玛分布 | 实数 | 伽玛 |
- en: '|  | `weibull_distribution` | real | Weibull |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: 威布尔 | 威布尔分布 | 实数 | 威布尔 |
- en: '|  | `extreme_value_distribution` | real | extreme value |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: 极值分布 | 实数 | 极值 |
- en: '| Normal | `normal_distribution` | real | standard normal (Gaussian) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 正态 | `normal_distribution` | real | 标准正态（高斯） |'
- en: '|  | `lognormal_distribution` | real | lognormal |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | `lognormal_distribution` | real | 对数正态 |'
- en: '|  | `chi_squared_distribution` | real | chi-squared |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | `chi_squared_distribution` | real | 卡方 |'
- en: '|  | `cauchy_distribution` | real | Cauchy |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | `cauchy_distribution` | real | 柯西 |'
- en: '|  | `fisher_f_distribution` | real | Fisher''s F-distribution |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | `fisher_f_distribution` | real | 费舍尔F分布 |'
- en: '|  | `student_t_distribution` | real | Student''s t-distribution |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | `student_t_distribution` | real | 学生t分布 |'
- en: '| Sampling | `discrete_distribution` | integer | discrete |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 采样 | `discrete_distribution` | 整数 | 离散 |'
- en: '|  | `piecewise_constant_distribution` | real | values distributed on constant
    subintervals |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | `piecewise_constant_distribution` | real | 在常数子区间上分布的值 |'
- en: '|  | `piecewise_linear_distribution` | real | values distributed on defined
    subintervals |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | `piecewise_linear_distribution` | real | 在定义的子区间上分布的值 |'
- en: Each of the engines provided by the library has advantages and disadvantages.
    The linear congruential engine has a small internal state, but it is not very
    fast. On the other hand, the subtract with carry engine is very fast, but requires
    more memory for its internal state. The Mersenne twister is the slowest of them
    and the one that has the largest internal state, but when initialized appropriately
    can produce the longest non-repeating sequence of numbers. In the following examples,
    we will use `std::mt19937`, a 32-bit Mersenne twister with 19,937 bits of internal
    state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 库提供的每个引擎都有优缺点。线性同余引擎具有较小的内部状态，但速度不是很快。另一方面，减法进位引擎非常快，但需要更多内部状态的内存。Mersenne扭曲器是它们中最慢的，也是内部状态最大的一个，但在适当初始化时可以产生最长的不重复数字序列。在以下示例中，我们将使用`std::mt19937`，一个32位Mersenne扭曲器，内部状态有19,937位。
- en: 'The simplest way to generate random numbers looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的最简单方法如下：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, `mtgen` is an `std::mt19937` Mersenne twister. To generate
    numbers, you only need to use the call operator that advances the internal state
    and returns the next pseudo-random number. However, this code is flawed, as the
    engine is not seeded. As a result, it always produces the same sequence of numbers,
    which is probably not what you want in most cases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mtgen`是一个`std::mt19937` Mersenne扭曲器。要生成数字，只需要使用调用运算符来推进内部状态并返回下一个伪随机数。然而，这段代码有缺陷，因为引擎没有被种子化。因此，它总是产生相同的数字序列，这在大多数情况下可能不是你想要的。
- en: 'There are different approaches for initializing the engine. One approach, common
    with the C rand library, is to use the current time. In modern C++, it should
    look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来初始化引擎。一种方法，与C rand库常见，是使用当前时间。在现代C++中，应该是这样的：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, `seed` is a number representing the number of ticks since
    the clock''s epoch until the present moment. This number is then used to seed
    the engine. The problem with this approach is that the value of that `seed` is
    actually deterministic, and in some classes of applications it could be prone
    to attacks. A more reliable approach is to seed the generator with actual random
    numbers. The `std::random_device` class is an engine that is supposed to return
    true random numbers, though implementations could actually be based on a pseudo-random
    generator:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`seed`是一个表示自时钟时代以来的滴答数的数字，直到当前时刻。然后使用这个数字来种子化引擎。这种方法的问题是`seed`的值实际上是确定性的，在某些类别的应用中可能容易受到攻击。更可靠的方法是用真正的随机数来种子化生成器。`std::random_device`类是一个应该返回真正随机数的引擎，尽管实现实际上可能基于伪随机生成器：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Numbers produced by all engines follow a uniform distribution. To convert the
    result to another statistical distribution, we have to use a distribution class.
    To show how generated numbers are distributed according to the selected distribution,
    we will use the following function. This function generates a specified number
    of pseudo-random numbers and counts their repetition in a map. The values from
    the map are then used to produce a bar-like diagram showing how often each number
    occurred:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎产生的数字都遵循均匀分布。要将结果转换为另一个统计分布，我们必须使用分布类。为了展示生成的数字如何根据所选的分布进行分布，我们将使用以下函数。该函数生成指定数量的伪随机数，并计算它们在映射中的重复次数。然后使用映射中的值生成类似条形图的图表，显示每个数字发生的频率：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code generates random numbers using the `std::mt19937` engine
    with a uniform distribution in the range `[1, 6]`; that is basically what you
    get when you throw a dice:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`std::mt19937`引擎生成在范围`[1, 6]`内均匀分布的随机数；这基本上就是掷骰子时得到的结果：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of the program looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/0aa92f90-d587-4c3d-880b-bd0a859d81b4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0aa92f90-d587-4c3d-880b-bd0a859d81b4.png)'
- en: 'In the next and final example, we change the distribution to a normal distribution
    with the mean `5` and the standard deviation `2`. This distribution produces real
    numbers; therefore, in order to use the previous `generate_and_print()` function,
    the numbers must be rounded to integers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个和最后一个例子中，我们将分布更改为均值为`5`，标准差为`2`的正态分布。这个分布产生实数；因此，为了使用先前的`generate_and_print()`函数，数字必须四舍五入为整数：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following will be the output of the earlier code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前代码的输出：
- en: '![](img/2f94f238-cc47-44ce-a685-b2e9e437441e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f94f238-cc47-44ce-a685-b2e9e437441e.png)'
- en: See also
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Initializing all bits of internal state of a pseudo-random number generator*'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化伪随机数生成器的所有内部状态位*'
- en: Initializing all bits of internal state of a pseudo-random number generator
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化伪随机数生成器的所有内部状态位
- en: In the previous recipe, we have looked at the pseudo-random number library with
    its components and how it can be used to produce numbers in different statistical
    distributions. One important factor that was overlooked in that recipe is the proper
    initialization of the pseudo-random number generators. In this recipe, you will
    learn how to initialize a generator in order to produce the best sequence of pseudo-random
    numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们已经看过了伪随机数库及其组件以及如何用它来产生不同统计分布中的数字。 在那个教程中忽略的一个重要因素是伪随机数生成器的正确初始化。
    在本教程中，您将学习如何初始化生成器以产生最佳序列的伪随机数。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Generating pseudo-random numbers*, to
    get an overview of what the pseudo-random number library offers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读前一个教程，*生成伪随机数*，以了解伪随机数库提供了什么。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To properly initialize a pseudo-random number generator to produce the best
    sequence of pseudo-random numbers, perform the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确初始化伪随机数生成器以产生最佳序列的伪随机数，请执行以下步骤：
- en: 'Use an `std::random_device` to produce random numbers to be used as seeding
    values:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::random_device`生成随机数以用作种子值：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Generate random data for all internal bits of the engine:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为引擎的所有内部位生成随机数据：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create an `std::seed_seq` object from the previously generated pseudo-random
    data:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从先前生成的伪随机数据创建一个`std::seed_seq`对象：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create an engine object and initialize all the bits representing the internal
    state of the engine; for example, a `mt19937` has 19,937 bits of internal states:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建引擎对象并初始化表示引擎内部状态的所有位；例如，`mt19937`有19,937位的内部状态：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the appropriate distribution based on the requirements of the application:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据应用程序的要求使用适当的分布：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In all examples shown in the previous recipe, we used an `std::mt19937` engine
    to produce pseudo-random numbers. Though the Mersenne twister is slower than the
    other engines, it can produce the longest sequences of non-repeating numbers and
    with the best spectral characteristics. However, initializing the engine in the
    manner shown in the previous recipe will not have this effect. With a careful
    analysis (that is beyond the purpose of this recipe or this book), it can be shown
    that the engine has a bias toward producing some values repeatedly and omitting
    others, thus generating numbers not in a uniform distribution, but rather in a
    binomial or Poisson distribution. The problem is that the internal state of `mt19937`
    has 624 32-bit integers, and in the examples from the previous recipe we have
    only initialized one of them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中显示的所有示例中，我们使用了一个`std::mt19937`引擎来产生伪随机数。 尽管梅森旋转器比其他引擎慢，但它可以产生最长的非重复数字序列，并具有最佳的频谱特性。
    但是，以前的教程中显示的引擎初始化不会产生这种效果。 通过仔细分析（超出了本教程或本书的目的），可以证明引擎倾向于重复产生一些值并省略其他值，从而生成不均匀分布的数字，而是二项式或泊松分布。
    问题在于`mt19937`的内部状态有624个32位整数，在上一个教程的示例中，我们只初始化了其中一个。
- en: 'When working with the pseudo-random number library, remember the following
    rule of thumb (shown in the information box):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用伪随机数库时，请记住以下经验法则（在信息框中显示）：
- en: In order to produce the best results, engines must have all their internal state
    properly initialized before generating numbers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生最佳结果，引擎在生成数字之前必须正确初始化其所有内部状态。
- en: The pseudo-random number library provides a class for this particular purpose,
    called `std::seed_seq`. This is a generator that can be seeded with any number
    of 32-bit integers and produces a requested number of integers evenly distributed
    in the 32-bit space.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数库提供了一个特定目的的类，称为`std::seed_seq`。 这是一个可以用任意数量的32位整数进行种子化，并在32位空间中产生请求的整数数量的生成器。
- en: In the preceding code from the *How to do it...* section, we defined an array
    called `seed_data` with a number of 32-bit integers equal to the internal state
    of the `mt19937` generator; that is 624 integers. Then, we initialized the array
    with random numbers produced by an `std::random_device`. The array was later used
    to seed an `std::seed_seq`, which in turn was used to seed the `mt19937` generator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分的上述代码中，我们定义了一个名为`seed_data`的数组，其中包含与`mt19937`生成器的内部状态相等的32位整数数量；即624个整数。
    然后，我们使用`std::random_device`生成的随机数初始化了数组。 稍后，该数组用于种子`std::seed_seq`，而`std::seed_seq`又用于种子`mt19937`生成器。
- en: Creating cooked user-defined literals
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建熟悉的用户定义文字
- en: Literals are constants of built-in types (numerical, boolean, character, character
    string, and pointer) that cannot be altered in a program. The language defines
    a series of prefixes and suffixes to specify literals (and the prefix/suffix is
    actually part of the literal). C++11 allows creating user-defined literals by
    defining functions called *literal operators* that introduce suffixes for specifying
    literals. These work only with numerical character and character string types.
    This opens the possibility of defining both standard literals in future versions
    and allows developers to create their own literals. In this recipe, we will see
    how we can create our own cooked literals.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 文字是内置类型（数字，布尔，字符，字符串和指针）的常量，不能在程序中更改。 语言定义了一系列前缀和后缀来指定文字（前缀/后缀实际上是文字的一部分）。 C++11允许通过定义称为*文字运算符*的函数来创建用户定义的文字，引入后缀以指定文字。
    这些仅适用于数字字符和字符串类型。 这打开了在将来版本中定义标准文字并允许开发人员创建自己的文字的可能性。 在本教程中，我们将看到如何创建我们自己的熟悉文字。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'User-defined literals can have two forms: *raw* and *cooked*. Raw literals
    are not processed by the compiler, whereas cooked literals are values processed
    by the compiler (examples can include handling escape sequences in a character
    string or identifying numerical values such as integer 2898 from literal 0xBAD).
    Raw literals are only available for integral and floating-point types, whereas
    cooked literals are also available for character and character string literals.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义文字可以有两种形式：*原始*和*熟*。原始文字不会被编译器处理，而熟文字是编译器处理的值（示例可以包括处理字符字符串中的转义序列或从文字0xBAD中识别整数值2898）。原始文字仅适用于整数和浮点类型，而熟文字也适用于字符和字符字符串文字。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To create cooked user-defined literals, you should follow these steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建熟用户定义文字，应遵循以下步骤：
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的文字定义在单独的命名空间中，以避免名称冲突。
- en: Always prefix the user-defined suffix with an underscore (`_`).
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终使用下划线（`_`）作为用户定义后缀的前缀。
- en: 'Define a literal operator of the following form for cooked literals:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为熟文字定义以下形式的文字运算符：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following example creates a user-defined literal for specifying kilobytes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个用于指定千字节的用户定义文字：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the compiler encounters a user-defined literal with a user-defined suffix
    `S` (it always has a leading underscore for third-party suffixes, as the suffixes
    without a leading underscore are reserved for the standard library) it does an
    unqualified name lookup in order to identify a function with the name operator
    `"operator "" S`. If it finds one, then it calls it according to the type of the
    literal and the type of the literal operator. Otherwise, the compiler will yield
    and error.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到具有用户定义后缀`S`的用户定义文字时（对于第三方后缀，它总是具有前导下划线，因为没有前导下划线的后缀是为标准库保留的），它会进行无限定名称查找，以便识别具有名称`operator
    "" S`的函数。如果找到一个，那么根据文字的类型和文字运算符的类型调用它。否则，编译器将产生错误。
- en: In the example from the *How to do it...* section, the literal operator is called
    `operator "" _KB` and has an argument of type `unsigned long long int`. This is
    the only integral type possible for literal operators for handling integral types.
    Similarly, for floating-point user-defined literals, the parameter type must be
    `long double` since for numeric types the literal operators must be able to handle
    the largest possible values. This literal operator returns a `constexpr` value
    so that it can be used where compile time values are expected, such as specifying
    the size of an array as shown in the above example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做到...*部分的示例中，文字运算符称为`operator "" _KB`，其参数类型为`unsigned long long int`。这是处理整数类型的文字运算符的唯一可能类型。类似地，对于浮点数用户定义文字，参数类型必须是`long
    double`，因为对于数值类型，文字运算符必须能够处理可能的最大值。此文字运算符返回`constexpr`值，以便在需要编译时值的地方使用，例如在上面示例中指定数组大小时。
- en: 'When the compiler identifies a user-defined literal and has to call the appropriate
    user-defined literal operator, it will pick the overload from the overload set
    according to the following rules:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器识别用户定义文字并且必须调用适当的用户定义文字运算符时，它将根据以下规则从重载集中选择重载：
- en: '**For integral literals**: It calls in the following order: the operator that
    takes an `unsigned long long`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于整数文字**：按以下顺序调用：接受`unsigned long long`的运算符，接受`const char*`的原始文字运算符，或文字运算符模板。'
- en: '**For floating-point literals**: It calls in the following order: the operator
    that takes a `long double`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于浮点文字**：按以下顺序调用：接受`long double`的运算符，接受`const char*`的原始文字运算符，或文字运算符模板。'
- en: '**For character literals**: It calls the appropriate operator depending on
    the character type (`char`, `wchar_t`, `char16_t`, and `char32_t`).'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符文字**：根据字符类型（`char`、`wchar_t`、`char16_t`和`char32_t`）调用适当的运算符。'
- en: '**For string literals**: It calls the appropriate operator, depending on the
    string type that takes a pointer to the string of characters and the size.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符串文字**：根据接受指向字符字符串和大小的指针的字符串类型调用适当的运算符。'
- en: 'In the following example, we define a system of units and quantities. We want
    to operate with kilograms, pieces, liters, and other types of units. This could
    be useful in a system that can process orders and you need to specify the amount
    and unit for each article. The following are defined in the namespace `units`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个单位和数量的系统。我们希望使用千克、件、升和其他类型的单位进行操作。这在需要处理订单并且需要为每个商品指定数量和单位的系统中可能很有用。以下内容在命名空间`units`中定义：
- en: 'A scoped enumeration for the possible types of units (kilogram, meter, liter,
    and pieces):'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于单位可能类型（千克、米、升和件）的作用域枚举：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A class template to specify quantities of a particular unit (such as 3.5 kilograms
    or 42 pieces):'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指定特定单位的数量的类模板（例如3.5千克或42件）：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `operator+` and `operator-` functions for the `quantity` class template
    in order to be able to add and subtract quantities:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`类模板的`operator+`和`operator-`函数，以便能够添加和减去数量：'
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Literal operators to create `quantity` literals, defined in an inner namespace
    called `unit_literals`. The purpose of this is to avoid possible name clashes
    with literals from other namespaces. If such collisions do happen, developers
    could select the ones that they should use using the appropriate namespace in
    the scope where the literals need to be defined:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文字运算符用于创建`quantity`文字，定义在名为`unit_literals`的内部命名空间中。这样做的目的是避免与其他命名空间中的文字可能发生的名称冲突。如果确实发生这样的冲突，开发人员可以在需要定义文字的范围中使用适当的命名空间来选择他们应该使用的文字：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By looking carefully, you can note that the literal operators defined earlier
    are not the same:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，可以注意到先前定义的文字运算符不同：
- en: '`_kg` is defined for both integral and floating point literals; that enables
    us to create both integral and floating point values such as `1_kg` and `1.0_kg`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_kg`既适用于整数文字，也适用于浮点文字；这使我们能够创建整数值和浮点值，比如`1_kg`和`1.0_kg`。'
- en: '`_l` and `_m` are defined only for floating point literals; that means we can
    only define quantity literals for these units with floating points, such as `4.5_l`
    and `10.0_m`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_l`和`_m`仅适用于浮点文字；这意味着我们只能使用浮点数定义这些单位的数量文字，比如`4.5_l`和`10.0_m`。'
- en: '`_pcs` is only defined for integral literals; that means we can only define
    quantities of an integer number of pieces, such as `42_pcs`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_pcs`仅适用于整数字面值；这意味着我们只能定义整数数量的片数，比如`42_pcs`。'
- en: 'Having these literal operators available, we can operate with various quantities.
    The following examples show both valid and invalid operations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些文字操作符，我们可以操作各种数量。以下示例显示了有效和无效的操作：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`q1` is a quantity of 1 kg; that is an integer value. Since an overloaded `operator
    "" _kg(unsigned long long const)` exists, the literal can be correctly created
    from the integer 1\. Similarly, `q2` is a quantity of 4.5 kilograms; that is a
    real value. Since an `overload operator "" _kg(long double)` exists, the literal
    can be created from the double floating point value 4.5.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`q1`是1千克的数量；这是一个整数值。由于存在重载的`operator "" _kg(unsigned long long const)`，因此可以从整数1正确地创建文字。同样，`q2`是4.5千克的数量；这是一个实数值。由于存在`overload
    operator "" _kg(long double)`，因此可以从双精度浮点值4.5创建文字。'
- en: On the other hand, `q6` is a quantity of 1 liter. Since there is no overloaded `operator
    "" _l(unsigned long long)`, the literal cannot be created. It would require an
    overload that takes a `unsigned long long`, but such an overload does not exist.
    Similarly, `q7` is a quantity of 2.0 pieces, but piece literals can only be created
    from integer values and, therefore, this generates another compiler error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`q6`是1升的数量。由于没有重载的`operator "" _l(unsigned long long)`，因此无法创建文字。这将需要一个接受`unsigned
    long long`的重载，但这样的重载不存在。同样，`q7`是2.0个零件的数量，但零件文字只能从整数值创建，因此这将生成另一个编译器错误。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Though user-defined literals are available from C++11, standard literal operators
    have been available only from C++14\. The following is a list of these standard
    literal operators:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户定义文字从C++11开始可用，但标准文字操作符仅从C++14开始可用。以下是这些标准文字操作符的列表：
- en: '`operator""s` for defining `std::basic_string` literals:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator""s`用于定义`std::basic_string`文字：'
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`operator""h`, `operator""min`, `operator""s`, `operator""ms`, `operator""us`,
    and `operator""ns` for creating a `std::chrono::duration` value:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator""h`、`operator""min`、`operator""s`、`operator""ms`、`operator""us`和`operator""ns`用于创建`std::chrono::duration`值：'
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`operator""if`, `operator""i`, and `operator""il` for creating a `std::complex`
    value:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator""if`、`operator""i`和`operator""il`用于创建`std::complex`值：'
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using raw string literals to avoid escaping characters*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原始字符串文字来避免转义字符*'
- en: '*Creating raw user-defined literals*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建原始用户定义文字*'
- en: Creating raw user-defined literals
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建原始用户定义文字
- en: In the previous recipe, we have looked at the way C++11 allows library implementers
    and developers to create user-defined literals and the user-defined literals available
    in the C++14 standard. However, user-defined literals have two forms, a cooked
    form, where the literal value is processed by the compiler before being supplied
    to the literal operator, and a raw form, in which the literal is not parsed by
    the compiler. The latter is only available for integral and floating-point types.
    In this recipe, we will look at creating raw user-defined literals.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们已经看到了C++11允许库实现者和开发人员创建用户定义文字以及C++14标准中可用的用户定义文字的方式。然而，用户定义文字有两种形式，一种是熟练的形式，在这种形式中，文字值在提供给文字操作符之前由编译器处理，另一种是原始形式，在这种形式中，文字不会被编译器解析。后者仅适用于整数和浮点类型。在本教程中，我们将看看如何创建原始用户定义文字。
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Before continuing with this recipe, it is strongly recommended that you go through
    the previous one, *Creating cooked user-defined literals*, as general details
    about user-defined literals will not be reiterated here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本教程之前，强烈建议您阅读上一个教程《创建熟悉的用户定义文字》，因为这里不会重复介绍有关用户定义文字的一般细节。
- en: To exemplify the way raw user-defined literals can be created, we will define
    binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned)
    types. These types will be called `byte8`, `byte16`, and `byte32`, and the literals
    we create will be called `_b8`, `_b16`, and `_b32`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明原始用户定义的文字如何创建，我们将定义二进制文字。这些二进制文字可以是8位、16位和32位（无符号）类型。这些类型将被称为`byte8`、`byte16`和`byte32`，我们创建的文字将被称为`_b8`、`_b16`和`_b32`。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'To create raw user-defined literals, you should follow these steps:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建原始用户定义文字，您应该按照以下步骤进行：
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的文字定义在一个单独的命名空间中，以避免名称冲突。
- en: Always prefix the used-defined suffix with an underscore (`_`).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 始终使用下划线（`_`）前缀来定义使用的后缀。
- en: 'Define a literal operator or literal operator template of the following form:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义以下形式的文字操作符或文字操作符模板：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following sample shows a possible implementation of 8-bit, 16-bit, and
    32-bit binary literals:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了8位、16位和32位二进制文字的可能实现：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: The implementation in the previous section enables us to define binary literals
    of the form 1010_b8 (a `byte8` value of decimal 10) or 000010101100_b16 (a `byte16`
    value of decimal 2130496). However, we want to make sure that we do not exceed
    the number of digits for each type. In other words, values such as 111100001_b8
    should be illegal and the compiler should yield an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的实现使我们能够定义二进制文字的形式1010_b8（十进制值为10的`byte8`值）或000010101100_b16（十进制值为2130496的`byte16`值）。但是，我们要确保不超过每种类型的数字位数。换句话说，像111100001_b8这样的值应该是非法的，编译器应该产生错误。
- en: First of all, we define everything inside a namespace called `binary` and start
    with introducing several type aliases (`byte8`, `byte16`, and `byte32`).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在一个名为`binary`的命名空间中定义了所有内容，并开始引入几个类型别名（`byte8`、`byte16`和`byte32`）。
- en: The literal operator templates are defined in a nested namespace called `binary_literal_internals`.
    This is a good practice in order to avoid name collision with other literal operators
    from other namespaces. Should something like that happen, you can choose to use
    the appropriate namespace in the right scope (such as one namespace in a function
    or block and another namespace in another function or block).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 文字操作符模板定义在一个名为`binary_literal_internals`的嵌套命名空间中。这是一个很好的做法，以避免与其他命名空间中的其他文字操作符发生名称冲突。如果发生这样的情况，您可以选择在正确的范围内使用适当的命名空间（例如，在一个函数或块中使用一个命名空间，在另一个函数或块中使用另一个命名空间）。
- en: The three literal operator templates are very similar. The only things that
    are different are their names (`_b8`, `_16`, and `_b32`), return type (`byte8`,
    `byte16`, and `byte32`), and the condition in the static assert that checks the
    number of digits.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个文字操作符模板非常相似。唯一不同的是它们的名称（`_b8`、`_16`和`_b32`）、返回类型（`byte8`、`byte16`和`byte32`）以及在静态断言中检查数字个数的条件。
- en: 'We will explore the details of variadic template and template recursion in
    a later recipe; however, for a better understanding, this is how this particular
    implementation works: `bits` is a template parameter pack, that is not a single
    value, but all the values the template could be instantiated with. For example,
    if we consider the literal `1010_b8`, then the literal operator template would
    be instantiated as `operator"" _b8<''1'', ''0'', ''1'', ''0''>()`. Before proceeding
    with computing the binary value, we check the number of digits in the literal.
    For `_b8`, this must not exceed eight (including any trailing zeros). Similarly,
    it should be up to 16 digits for `_b16` and 32 for `_b32`. For this, we use the
    `sizeof...` operator that returns the number of elements in a parameter pack (in
    this case, `bits`).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后的配方中探讨可变参数模板和模板递归的细节；然而，为了更好地理解，这就是这个特定实现的工作原理：`bits`是一个模板参数包，不是单个值，而是模板可以实例化的所有值。例如，如果我们考虑文字`1010_b8`，那么文字操作符模板将被实例化为`operator""
    _b8<'1', '0', '1', '0'>()`。在继续计算二进制值之前，我们检查文字中的数字个数。对于`_b8`，这个数字不能超过八个（包括任何尾随的零）。类似地，对于`_b16`，它应该是最多16位数字，对于`_b32`，它应该是32位。为此，我们使用`sizeof...`操作符，它返回参数包中的元素数（在这种情况下是`bits`）。
- en: If the number of digits is correct, we can proceed to expand the parameter pack
    and recursively compute the decimal value represented by the binary literal. This
    is done with the help of an additional class template and its specializations.
    These templates are defined in yet another nested namespace, called `binary_literals_internals`.
    This is also a good practice because it hides (without proper qualification) the
    implementation details from the client (unless an explicit using namespace directive
    makes them available to the current namespace).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字个数正确，我们可以继续展开参数包并递归计算二进制文字表示的十进制值。这是通过另一个类模板及其专业化的帮助完成的。这些模板定义在另一个名为`binary_literals_internals`的嵌套命名空间中。这也是一个很好的做法，因为它将实现细节（除非使用了显式的using
    namespace指令将其提供给当前命名空间）隐藏起来，不让客户端看到。
- en: Even though this looks like recursion, it is not a true runtime recursion, because
    after the compiler expands and generates the code from templates, what we end
    up with is basically calls to overloaded functions with a different number of
    parameters. This is later explained in the recipe *Writing a function template
    with a variable number of arguments*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像是递归，但它并不是真正的运行时递归，因为在编译器展开并从模板生成代码之后，我们最终得到的基本上是对具有不同参数数量的重载函数的调用。这在后面的配方*使用可变数量参数的函数模板*中有进一步解释。
- en: 'The `binary_struct` class template has a template type `CharT` for the return
    type of the function (we need this because our literal operator templates should
    return either `byte8`, `byte16`, or `byte32`) and a parameter pack:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_struct`类模板有一个模板类型`CharT`，用于函数的返回类型（我们需要这个，因为我们的文字操作符模板应该返回`byte8`、`byte16`或`byte32`），还有一个参数包：'
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Several specializations of this class template are available with parameter
    pack decomposition. When the first digit of the pack is ''0'', the computed value
    remains the same, and we continue expanding the rest of the pack. If the first
    digit of the pack is ''1'', then the new value is 1 shifted to the left with the
    number of digits in the remainder of the pack bit, or the value of the rest of
    the pack:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类模板的几个专业化版本都带有参数包分解。当包的第一个数字是'0'时，计算出的值保持不变，我们继续展开包的其余部分。如果包的第一个数字是'1'，那么新值就是1左移包剩余位数的数字，或者包的其余部分的值：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last specialization covers the case when the pack is empty; in this case
    we return 0:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个专业化涵盖了包为空的情况；在这种情况下，我们返回0：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After defining these helper classes, we could implement the `byte8`, `byte16`,
    and `byte32` binary literals as intended. Note that we need to bring the content
    of the namespace `binary_literals` in the current namespace in order to use the
    literal operator templates:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些辅助类之后，我们可以按预期实现`byte8`、`byte16`和`byte32`二进制文字。请注意，我们需要将`binary_literals`命名空间的内容引入当前命名空间，以便使用文字操作符模板：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following definitions trigger compiler errors because the condition in
    `static_assert` is not met:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义触发编译器错误，因为`static_assert`中的条件不满足：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See also
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using raw string literals to avoid escaping character*s'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原始字符串文字来避免转义字符*'
- en: '*Creating cooked user-defined literals*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建熟悉的用户定义文字*'
- en: '*Writing a function template with variable number of arguments* recipe of [Chapter
    10](5ca9534c-f23e-4ef3-a59f-7bd377721eea.xhtml), *Exploring Functions*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用可变数量参数的函数模板* [第10章](5ca9534c-f23e-4ef3-a59f-7bd377721eea.xhtml) 的配方，*探索函数*'
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板*食谱[第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)，*学习现代核心语言特性*'
- en: Using raw string literals to avoid escaping characters
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始字符串文字来避免转义字符
- en: Strings may contain special characters, such as non-printable characters (newline,
    horizontal and vertical tab, and so on), string and character delimiters (double
    and single quotes) or arbitrary octal, hexadecimal, or Unicode values. These special
    characters are introduced with an escape sequence that starts with a backslash,
    followed by either the character (examples include `'` and `"`), its designated
    letter (examples include `n` for a new line, `t` for a horizontal tab), or its
    value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As a result,
    the backslash character itself has to be escaped with another backslash character.
    This leads to more complicated literal strings that can be hard to read.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可能包含特殊字符，例如非打印字符（换行符、水平和垂直制表符等）、字符串和字符分隔符（双引号和单引号）或任意的八进制、十六进制或Unicode值。这些特殊字符以反斜杠开头的转义序列引入，后面跟着字符（例如`'`和`"`）、其指定的字母（例如`n`表示换行，`t`表示水平制表符）或其值（例如八进制050、十六进制XF7或Unicode
    U16F0）。因此，反斜杠字符本身必须用另一个反斜杠字符转义。这导致更复杂的文字字符串，很难阅读。
- en: To avoid escaping characters, C++11 introduced raw string literals that do not
    process escape sequences. In this recipe, you will learn how to use the various
    forms of raw string literals.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免转义字符，C++11引入了不处理转义序列的原始字符串文字。在这个示例中，您将学习如何使用各种形式的原始字符串文字。
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, and throughout the rest of the book, I will use the `s` suffix
    to define `basic_string` literals. This has been covered in the recipe *Creating
    cooked user-defined literals*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，以及本书的其余部分，我将使用`s`后缀来定义`basic_string`文字。这已经在食谱*创建熟用户定义的文字*中介绍过。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To avoid escaping characters, define the string literals with the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免转义字符，使用以下定义字符串文字：
- en: '`R"( literal )"` as the default form:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`R"( literal )"`作为默认形式：'
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`R"delimiter( literal )delimiter"` where `delimiter` is any character sequence
    not present in the actual string when the sequence `)"` should actually be part
    of the string. Here is an example with `!!` as delimited:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`R"delimiter( literal )delimiter"`其中`delimiter`是实际字符串中不存在的任何字符序列，当序列`)"`实际上应该是字符串的一部分时。这里有一个以`!!`为分隔符的例子：'
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When string literals are used, escapes are not processed, and the actual content
    of the string is written between the delimiter (in other words, what you see is
    what you get). The following example shows what appears as the same raw literal
    string; however, the second one still contains escaped characters. Since these
    are not processed in the case of string literals, they will be printed as they
    are in the output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字符串文字时，转义不会被处理，字符串的实际内容将被写在分隔符之间（换句话说，你看到的就是你得到的）。下面的例子显示了看起来相同的原始文字字符串；然而，第二个字符串仍然包含转义字符。由于在字符串文字的情况下不处理这些字符，它们将按原样打印在输出中：
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In case the text has to contain the `)"` sequence, then a different delimiter
    must be used, in the `R"delimiter( literal )delimiter"` form. According to the
    standard, the possible characters in a delimiter can be as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本必须包含`)"`序列，则必须使用不同的分隔符，形式为`R"delimiter( literal )delimiter"`。根据标准，分隔符中可能包含以下字符：
- en: 'any member of the basic source character set except: space, the left parenthesis
    (the right parenthesis ), the backslash \, and the control characters representing
    horizontal tab, vertical tab, form feed, and newline.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 基本源字符集的任何成员，除了：空格、左括号（右括号）、反斜杠\和表示水平制表符、垂直制表符、换页和换行的控制字符。
- en: 'Raw string literals can be prefixed by one of `L`, `u8`, `u`, and `U` to indicate
    a wide, UTF-8, UTF-16, or UTF-32 string literal. The following are examples of
    such string literals. Note that the presence of string literal `operator ""s`
    at the end of the string makes the compiler deduce the type as various string
    classes and not character arrays:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串文字可以由`L`、`u8`、`u`和`U`中的一个前缀，表示宽字符、UTF-8、UTF-16或UTF-32字符串文字。以下是这种字符串文字的例子。请注意，字符串末尾的`operator
    ""s`存在使编译器推断类型为各种字符串类而不是字符数组：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating cooked user-defined literals*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建熟用户定义的文字*'
- en: Creating a library of string helpers
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个字符串助手库
- en: The string types from the standard library are a general purpose implementation
    that lacks many helpful methods, such as changing the case, trimming, splitting,
    and others that may address different developer needs. Third-party libraries that
    provide rich sets of string functionalities exist. However, in this recipe, we
    will look at implementing several simple, yet helpful, methods you may often need
    in practice. The purpose is rather to see how string methods and standard general
    algorithms can be used for manipulating strings, but also to have a reference
    to reusable code that can be used in your applications.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的字符串类型是一个通用实现，缺少许多有用的方法，例如更改大小写、修剪、拆分和其他可能满足不同开发人员需求的方法。存在提供丰富的字符串功能集的第三方库。然而，在这个示例中，我们将看到实现几种简单但有用的方法，这些方法在实践中经常需要。目的是看看如何使用字符串方法和标准通用算法来操作字符串，但也是为了有一个可重用的代码参考，可以在您的应用程序中使用。
- en: 'In this recipe, we will implement a small library of string utilities that
    will provide functions for the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现一个小型字符串工具库，该库将提供以下功能的函数：
- en: Changing a string to lowercase or uppercase.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串更改为小写或大写。
- en: Reversing a string.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转字符串。
- en: Trimming white spaces from the beginning and/or the end of the string.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串的开头和/或结尾修剪空格。
- en: Trimming a specific set of characters from the beginning and/or the end of the
    string.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串的开头和/或结尾修剪特定的字符集。
- en: Removing occurrences of a character anywhere in the string.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中的任何位置删除字符的出现。
- en: Tokenizing a string using a specific delimiter.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定分隔符对字符串进行标记化。
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The string library we will be implementing should work with all the standard
    string types, `std::string`, `std::wstring`, `std::u16string`, and `std::u32string`.
    To avoid specifying long names such as `std::basic_string<CharT, std::char_traits<CharT>,
    std::allocator<CharT>>`, we will use the following alias templates for strings
    and string streams:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的字符串库应该适用于所有标准字符串类型，`std::string`、`std::wstring`、`std::u16string`和`std::u32string`。为了避免指定诸如`std::basic_string<CharT,
    std::char_traits<CharT>, std::allocator<CharT>>`这样的长名称，我们将使用以下字符串和字符串流的别名模板：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To implement these string helper functions, we need to include the header `<string>`
    for strings and `<algorithm>` for the general standard algorithms we will use.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些字符串辅助函数，我们需要包含`<string>`头文件用于字符串和`<algorithm>`用于我们将使用的一般标准算法。
- en: In all the examples in this recipe, we will use the standard user-defined literal
    operators for strings from C++14, for which we need to explicitly use the `std::string_literals` namespace.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中的所有示例中，我们将使用C++14的标准用户定义的字符串字面量操作符，因此我们需要显式使用`std::string_literals`命名空间。
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To convert a string to lowercase or uppercase, apply the `tolower()` or `toupper()`
    functions on the characters of a string using the general purpose algorithm `std::transform()`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将字符串转换为小写或大写，使用通用目的算法`std::transform()`对字符串的字符应用`tolower()`或`toupper()`函数：
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To reverse a string, use the general purpose algorithm `std::reverse()`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要颠倒字符串，使用通用目的算法`std::reverse()`：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To trim a string, at the beginning, end, or both, use `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修剪字符串，在开头、结尾或两者都使用`std::basic_string`的`find_first_not_of()`和`find_last_not_of()`方法：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To trim characters in a given set from a string, use overloads of `std::basic_string`''s
    methods `find_first_not_of()` and `find_last_not_of()`, that take a string parameter
    that defines the set of characters to look for:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从字符串中修剪给定集合中的字符，使用`std::basic_string`的`find_first_not_of()`和`find_last_not_of()`的重载方法，它们接受一个字符串参数，定义要查找的字符集：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To remove characters from a string, use `std::remove_if()` and `std::basic_string::erase()`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从字符串中删除字符，使用`std::remove_if()`和`std::basic_string::erase()`：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To split a string based on a specified delimiter, use `std::getline()` to read
    from an `std::basic_stringstream` initialized with the content of the string.
    The tokens extracted from the stream are pushed into a vector of strings:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据指定的分隔符拆分字符串，使用`std::getline()`从初始化为字符串内容的`std::basic_stringstream`中读取。从流中提取的标记被推入字符串向量中：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'For implementing the utility functions from the library, we have two options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现库中的实用函数，我们有两个选择：
- en: Functions would modify a string passed by a reference.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将修改通过引用传递的字符串。
- en: Functions would not alter the original string but return a new string.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不会改变原始字符串，而是返回一个新字符串。
- en: The second option has the advantage that it preserves the original string, which
    may be helpful in many cases. Otherwise, in those cases, you would first have
    to make a copy of the string and alter the copy. The implementation provided in
    this recipe takes the second approach.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项的优点是它保留了原始字符串，这在许多情况下可能有所帮助。否则，在这些情况下，您首先必须复制字符串并更改副本。此处提供的实现采用了第二种方法。
- en: 'The first functions we implemented in the *How to do it...* section were `to_upper()`
    and `to_lower()`. These functions change the content of a string either to uppercase
    or lowercase. The simplest way to implement this is using the `std::transform()`
    standard algorithm. This is a general purpose algorithm that applies a function
    to every element of a range (defined by a begin and end iterator) and stores the
    result in another range for which only the begin iterator needs to be specified.
    The output range can be the same as the input range, which is exactly what we
    did to transform the string. The applied function is `toupper()` or `tolower()`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*如何做...*部分中实现的第一个函数是`to_upper()`和`to_lower()`。这些函数将字符串的内容更改为大写或小写。实现这个最简单的方法是使用`std::transform()`标准算法。这是一个通用目的算法，它对范围的每个元素应用一个函数（由开始和结束迭代器定义），并将结果存储在另一个范围中，只需要指定开始迭代器。输出范围可以与输入范围相同，这正是我们用来转换字符串的方法。应用的函数是`toupper()`或`tolower()`：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The next function we considered was `reverse()`, that, as the name implies,
    reverses the content of a string. For this, we used the `std::reverse()` standard
    algorithm. This general purpose algorithm reverses the elements of a range defined
    by a begin and end iterator:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的下一个函数是`reverse()`，正如其名称所示，它颠倒了字符串的内容。为此，我们使用了`std::reverse()`标准算法。这个通用目的算法颠倒了由开始和结束迭代器定义的范围的元素：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When it comes to trimming, a string can be trimmed at the beginning, end, or
    both sides. Because of that, we implemented three different functions: `trim()`
    for trimming at both ends, `trimleft()` for trimming at the beginning of a string,
    and `trimright()` for trimming at the end of a string. The first version of the
    functions trims only spaces. In order to find the right part to trim, we use the `find_first_not_of()`
    and `find_last_not_of()` methods of `std::basic_string`. These return the first
    and last characters in the string that are not the specified character. Subsequently,
    a call to the `substr()` method of `std::basic_string` returns a new string. The
    `substr()` method takes an index in the string and a number of elements to copy
    to the new string:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在修剪方面，字符串可以在开头、结尾或两侧修剪。因此，我们实现了三个不同的函数：`trim()`用于两端修剪，`trimleft()`用于修剪字符串开头，`trimright()`用于修剪字符串结尾。函数的第一个版本仅修剪空格。为了找到要修剪的正确部分，我们使用`std::basic_string`的`find_first_not_of()`和`find_last_not_of()`方法。这些方法返回字符串中不是指定字符的第一个和最后一个字符。随后，调用`std::basic_string`的`substr()`方法返回一个新字符串。`substr()`方法接受字符串中的索引和要复制到新字符串的元素数：
- en: '[PRE60]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It could be sometimes useful to trim other characters and then spaces from
    a string. In order to do that, we provided overloads for the trimming functions
    that specify a set of characters to be removed. That set is also specified as
    a string. The implementation is very similar to the previous one because both
    `find_first_not_of()` and `find_last_not_of()` have overloads that take a string
    containing the characters to be excluded from the search:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有时从字符串中修剪其他字符和空格可能很有用。为了做到这一点，我们为修剪函数提供了重载，指定要删除的一组字符。该集合也被指定为一个字符串。实现非常类似于之前的实现，因为`find_first_not_of()`和`find_last_not_of()`都有重载，接受包含要从搜索中排除的字符的字符串：
- en: '[PRE61]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If removing characters from any part of the string is necessary, the trimming
    methods are not helpful because they only treat a contiguous sequence of characters
    at the start and end of a string. For that, however, we implemented a simple `remove()`
    method. This uses the `std:remove_if()` standard algorithm. Both `std::remove()`
    and `std::remove_if()` work in a way that may not be very intuitive at first.
    They remove elements that satisfy the criteria from a range defined by a first
    and last iterator by rearranging the content of the range (using move assignment).
    The elements that need to be removed are placed at the end of the range, and the
    function returns an iterator to the first element in the range that represents
    the removed elements. This iterator basically defines the new end of the range
    that was modified. If no element was removed, the returned iterator is the end
    iterator of the original range. The value of this returned iterator is then used
    to call the `std::basic_string::erase()` method that actually erases the content
    of the string defined by two iterators. The two iterators in our case are the
    iterator returned by `std::remove_if()` and the end of the string:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从字符串的任何部分删除字符，则修剪方法将无效，因为它们只处理字符串开头和结尾的连续字符序列。为此，我们实现了一个简单的`remove()`方法。这使用了`std:remove_if()`标准算法。`std::remove()`和`std::remove_if()`都以一种可能一开始不太直观的方式工作。它们通过重新排列范围的内容（使用移动赋值）来删除满足条件的元素。需要删除的元素被放置在范围的末尾，并且该函数返回一个指向表示已删除元素的范围中的第一个元素的迭代器。这个迭代器基本上定义了修改后的范围的新结尾。如果没有删除任何元素，则返回的迭代器是原始范围的结束迭代器。然后使用返回的迭代器的值调用`std::basic_string::erase()`方法，该方法实际上擦除了由两个迭代器定义的字符串的内容。在我们的情况下，两个迭代器是`std::remove_if()`返回的迭代器和字符串的末尾：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The last method we implemented splits the content of a string based on a specified
    delimiter. There are various ways to implement this. In this implementation, we
    used `std::getline()`. This function reads characters from an input stream until
    a specified delimiter is found and places the characters in a string. Before starting
    to read from the input buffer, it calls `erase()` on the output string to clear
    its content. Calling this method in a loop produces tokens that are placed in
    a vector. In our implementation, empty tokens were skipped from the result set:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的最后一个方法基于指定的分隔符拆分字符串的内容。有各种方法可以实现这一点。在这个实现中，我们使用了`std::getline()`。这个函数从输入流中读取字符，直到找到指定的分隔符，并将字符放入一个字符串中。在从输入缓冲区开始读取之前，它调用`erase()`方法清除输出字符串的内容。在循环中调用此方法会产生放置在向量中的标记。在我们的实现中，从结果集中跳过了空标记：
- en: '[PRE63]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Creating cooked user-defined literals*'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建熟制用户定义的字面量*'
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建类型别名和别名模板* [第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml) 的配方，*学习现代核心语言特性*'
- en: Verifying the format of a string using regular expressions
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式验证字符串的格式
- en: Regular expressions are a language intended for performing pattern matching
    and replacements in texts. C++11 provides support for regular expressions within
    the standard library through a set of classes, algorithms, and iterators available
    in the header `<regex>`. In this recipe, we will see how regular expressions can
    be used to verify that a string matches a pattern (examples can include verifying
    an e-mail or IP address formats).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种用于在文本中执行模式匹配和替换的语言。C++11通过标准库提供了对正则表达式的支持，通过`<regex>`头文件中提供的一组类、算法和迭代器。在本配方中，我们将看到如何使用正则表达式来验证字符串是否与模式匹配（示例可以包括验证电子邮件或IP地址格式）。
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Throughout this recipe, we will explain whenever necessary the details of the
    regular expressions that we use. However, you should have at least some basic
    knowledge of regular expressions in order to use the C++ standard library for
    regular expressions. A description of regular expressions syntax and standards
    is beyond the purpose of this book; if you are not familiar with regular expressions,
    it is recommended that you read more about them before continuing with the recipes
    that focus on regular expressions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将在必要时解释我们使用的正则表达式的细节。但是，为了使用C++标准库进行正则表达式，您应该至少具有一些正则表达式的基本知识。正则表达式语法和标准的描述超出了本书的目的；如果您对正则表达式不熟悉，建议您在继续专注于正则表达式的配方之前先阅读更多相关内容。
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'In order to verify that a string matches a regular expression, perform the
    following steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证字符串是否与正则表达式匹配，请执行以下步骤：
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括头文件`<regex>`和`<string>`以及命名空间`std::string_literals`，用于C++14标准用户定义的字符串字面量：
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    most e-mails formats:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量指定正则表达式，以避免转义反斜杠（可能经常发生）。以下正则表达式验证大多数电子邮件格式：
- en: '[PRE65]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`std::regex`/`std::wregex`对象（取决于所使用的字符集）来封装正则表达式：
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To ignore casing or specify other parsing options, use an overloaded constructor
    that has an extra parameter for regular expression flags:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '- 要忽略大小写或指定其他解析选项，请使用具有额外参数的重载构造函数，用于正则表达式标志：'
- en: '[PRE67]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use `std::regex_match()` to match the regular expression to an entire string:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '- 使用`std::regex_match()`来将正则表达式与整个字符串匹配：'
- en: '[PRE68]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 工作原理...'
- en: 'Considering the problem of verifying the format of e-mail addresses, even though
    this may look like a trivial problem, in practice it is hard to find a simple
    regular expression that covers all the possible cases for valid e-mail formats.
    In this recipe, we will not try to find that ultimate regular expression, but
    rather to apply a regular expression that is good enough for most cases. The regular
    expression we will use for this purpose is this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '- 考虑验证电子邮件地址格式的问题，尽管这看起来可能是一个微不足道的问题，但实际上很难找到一个简单的正则表达式，涵盖所有可能的有效电子邮件格式。在这个示例中，我们不会试图找到那个最终的正则表达式，而是应用一个对大多数情况来说足够好的正则表达式。我们将用于此目的的正则表达式是：'
- en: '[PRE69]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following table explains the structure of the regular expression:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '- 以下表格解释了正则表达式的结构：'
- en: '| **Part** | **Description** |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '- **部分** | **描述** |'
- en: '| `^` | Start of string |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '- `^` | 字符串的开头'
- en: '| `[A-Z0-9._%+-]+` | At least one character in the range A-Z, 0-9, or one of
    -, %, + or - that represents the local part of the email address |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '- `[A-Z0-9._%+-]+` | 至少一个字符在A-Z，0-9范围内，或者是-，%，+或-中的一个，表示电子邮件地址的本地部分'
- en: '| `@` | Character @ |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '- `@` | 字符@'
- en: '| `[A-Z0-9.-]+` | At least one character in the range A-Z, 0-9, or one of -,
    %, + or - that represents the hostname of the domain part |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '- `[A-Z0-9.-]+` | 至少一个字符在A-Z，0-9范围内，或者是-，%，+或-中的一个，表示域部分的主机名'
- en: '| `\.` | A dot that separates the domain hostname and label |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '- `\.` | 分隔域名主机名和标签的点'
- en: '| `[A-Z]{2,}` | The DNS label of a domain that can have between 2 and 63 characters
    |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '- `[A-Z]{2,}` | 可以包含2到63个字符的域的DNS标签'
- en: '| `$` | End of the string |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '- `$` | 字符串的结尾'
- en: Bear in mind that in practice a domain name is composed of a hostname followed
    by a dot-separated list of DNS labels. Examples include `localhost`, `gmail.com`,
    or `yahoo.co.uk`. This regular expression we are using does not match domains
    without DNS labels, such as localhost (an e-mail, such as `root@localhost` is
    a valid e-mail). The domain name can also be an IP address specified in brackets,
    such as `[192.168.100.11]` (as in `john.doe@[192.168.100.11]`). E-mail addresses
    containing such domains will not match the regular expression defined above. Even
    though these rather rare formats will not be matched, the regular expression can
    cover most of the e-mail formats.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '- 请记住，实际上域名由主机名后跟一个以点分隔的DNS标签列表组成。例如`localhost`，`gmail.com`或`yahoo.co.uk`。我们使用的这个正则表达式不匹配没有DNS标签的域，比如localhost（例如`root@localhost`是一个有效的电子邮件）。域名也可以是用括号指定的IP地址，例如`[192.168.100.11]`（如`john.doe@[192.168.100.11]`）。包含这些域的电子邮件地址将不匹配上面定义的正则表达式。尽管这些相对罕见的格式不会被匹配，但是正则表达式可以覆盖大多数电子邮件格式。'
- en: The regular expression in the example in this chapter is provided for didactical
    purposes only, and it is not intended for being used as it is in production code.
    As explained earlier, this sample does not cover all possible e-mail formats.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '- 本章示例中的正则表达式仅用于教学目的，并不打算直接用于生产代码。正如前面所解释的，此示例并未涵盖所有可能的电子邮件格式。'
- en: 'We began by including the necessary headers, `<regex>` for regular expressions
    and `<string>` for strings. The `is_valid_email()` function shown in the following (that
    basically contains the samples from the *How to do it...* section) takes a string
    representing an e-mail address and returns a boolean indicating whether the e-mail
    has a valid format or not. We first construct an `std::regex` object to encapsulate
    the regular expression indicated with the raw string literal. Using raw string
    literals is helpful because it avoids escaping backslashes that are used for escape
    characters in regular expressions too. The function then calls `std::regex_match()`,
    passing the input text and the regular expression:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '- 我们首先包含了必要的头文件，`<regex>`用于正则表达式，`<string>`用于字符串。下面显示的`is_valid_email()`函数（基本上包含了*如何操作...*部分的示例）接受一个表示电子邮件地址的字符串，并返回一个布尔值，指示该电子邮件是否具有有效格式。我们首先构造一个`std::regex`对象，以封装用原始字符串文字指示的正则表达式。使用原始字符串文字是有帮助的，因为它避免了在正则表达式中用于转义字符的反斜杠。然后函数调用`std::regex_match()`，传递输入文本和正则表达式：'
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `std::regex_match()` method tries to match the regular expression against
    the entire string. If successful it returns `true`, otherwise `false`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '- `std::regex_match()`方法尝试将正则表达式与整个字符串匹配。如果成功，则返回`true`，否则返回`false`：'
- en: '[PRE71]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this simple test, the only e-mails that do not match the regular expression
    are `ROOT@LOCALHOST` and `john.doe@domain.com`. The first contains a domain name
    without a dot-prefixed DNS label and that case is not covered in the regular expression.
    The second contains only lowercase letters, and in the regular expression, the
    valid set of characters for both the local part and the domain name was uppercase
    letters, A to Z.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '- 在这个简单的测试中，唯一不匹配正则表达式的电子邮件是`ROOT@LOCALHOST`和`john.doe@domain.com`。第一个包含一个没有点前缀DNS标签的域名，这种情况在正则表达式中没有涵盖。第二个只包含小写字母，在正则表达式中，本地部分和域名的有效字符集都是大写字母A到Z。'
- en: 'Instead of complicating the regular expression with additional valid characters
    (such as `[A-Za-z0-9._%+-]`), we can specify that the match can ignore the case.
    This can be done with an additional parameter to the constructor of the `std::basic_regex`
    class. The available constants for this purpose are defined in the `regex_constants`
    namespace. The following slight change to the `is_valid_email_format()` will make
    it ignore the case and allow e-mails with both lowercase and uppercase letters
    to correctly match the regular expression:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用额外的有效字符（例如`[A-Za-z0-9._%+-]`）使正则表达式复杂化，我们可以指定匹配时忽略大小写。这可以通过`std::basic_regex`类的构造函数的额外参数来实现。用于此目的的可用常量在`regex_constants`命名空间中定义。对`is_valid_email_format()`的以下轻微更改将使其忽略大小写，并允许大小写字母的电子邮件正确匹配正则表达式：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This `is_valid_email_format()` function is pretty simple, and if the regular
    expression was provided as a parameter along with the text to match, it could
    be used for matching anything. However, it would be nice to be able to handle
    with a single function not only multi-byte strings (`std::string`) but also wide
    strings (`std::wstring`). This can be achieved by creating a function template
    where the character type is provided as a template parameter:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`is_valid_email_format()`函数非常简单，如果正则表达式与要匹配的文本一起作为参数提供，它可以用于匹配任何内容。但是，希望能够使用单个函数处理不仅是多字节字符串（`std::string`），还包括宽字符串（`std::wstring`）。这可以通过创建一个函数模板来实现，其中字符类型作为模板参数提供：
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We start by creating an alias template for `std::basic_string` in order to
    simplify its use. The new `is_valid_format()` function is a function template
    very similar to our implementation of `is_valid_email()`**.** However, we now
    use `std::basic_regex<CharT>` instead of the typedef `std::regex,` which is `std::basic_regex<char>,`
    and the pattern is provided as the first argument. We now implement a new function
    called `is_valid_email_format_w()` for wide strings that relies on this function
    template. The function template, however, can be reused for implementing other
    validations, such as if a license plate has a particular format:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了`std::basic_string`的别名模板，以简化其使用。新的`is_valid_format()`函数是一个函数模板，与我们的`is_valid_email()`的实现非常相似。但是，现在我们使用`std::basic_regex<CharT>`而不是`std::regex`的`typedef`，它是`std::basic_regex<char>`，并且模式作为第一个参数提供。我们现在实现了一个名为`is_valid_email_format_w()`的新函数，用于宽字符串，它依赖于这个函数模板。但是，函数模板可以被重用来实现其他验证，例如车牌是否具有特定格式：
- en: '[PRE74]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Of all the examples shown above, the only one that does not match is `ROOT@LOCAHOST`,
    as already expected.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面显示的所有示例中，唯一不匹配的是`ROOT@LOCAHOST`，这是预期的。
- en: The `std::regex_match()` method has, in fact, several overloads, and some of
    them have a parameter that is a reference to an `std::match_results` object to
    store the result of the match. If there is no match, then `std::match_results`
    is empty and its size is 0\. Otherwise, if there is a match, the `std::match_results`
    object is not empty and its size is 1 plus the number of matched subexpressions.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_match()`方法实际上有多个重载版本，其中一些版本有一个参数，是指向`std::match_results`对象的引用，用于存储匹配结果。如果没有匹配，则`std::match_results`为空，大小为0。否则，如果有匹配，`std::match_results`对象不为空，大小为匹配的子表达式数加1。'
- en: 'The following version of the function uses the mentioned overloads and returns
    the matched subexpressions in an `std::smatch` object. Note that the regular expression
    is changed, as three caption groups are defined-- one for the local part, one
    for the hostname part of the domain, and one for the DNS label. If the match is
    successful, then the `std::smatch` object will contain four submatch objects:
    the first to match the entire string, the second for the first capture group (the
    local part), the third for the second capture group (the hostname), and the fourth
    for the third and last capture group (the DNS label). The result is returned in
    a tuple, where the first item actually indicates success or failure:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的以下版本使用了上述重载，并将匹配的子表达式返回到`std::smatch`对象中。请注意，正则表达式已更改，因为定义了三个标题组--一个用于域的本地部分，一个用于主机名部分，一个用于DNS标签。如果匹配成功，则`std::smatch`对象将包含四个子匹配对象：第一个匹配整个字符串，第二个匹配第一个捕获组（本地部分），第三个匹配第二个捕获组（主机名），第四个匹配第三个和最后一个捕获组（DNS标签）。结果以元组的形式返回，其中第一个项目实际上表示成功或失败：
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Following the preceding code, we use C++17 structured bindings to unpack the
    content of the tuple into named variables:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码之后，我们使用C++17结构化绑定将元组的内容解包到命名变量中：
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output of the program will be as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There's more...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are multiple versions of regular expressions, and the C++ standard library
    supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and
    egrep (grep with option `-E`). The default grammar used is ECMAScript, and in
    order to use another, you explicitly have to specify the grammar when defining
    the regular expression. In addition to specifying the grammar, you can also specify
    parsing options, such as matching by ignoring the case.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式有多个版本，C++标准库支持其中的六个：ECMAScript，基本POSIX，扩展POSIX，awk，grep和egrep（带有选项`-E`的grep）。默认使用的语法是ECMAScript，为了使用其他语法，您必须在定义正则表达式时显式指定语法。除了指定语法，还可以指定解析选项，例如忽略大小写匹配。
- en: 'The standard library provides more classes and algorithms than what we have
    seen so far. The main classes available in the library are the following (all
    of them are class templates and, for convenience, `typedef`s are provided for
    different character types):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供的类和算法比我们迄今所见的更多。库中提供的主要类如下（它们都是类模板，为方便起见，为不同的字符类型提供了`typedef`）：
- en: 'The class template `std::basic_regex` defines the regular expression object:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板`std::basic_regex`定义了正则表达式对象：
- en: '[PRE78]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The class template `std::sub_match` represents a sequence of characters that
    matches a capture group; this class is actually derived from `std::pair`, and
    its `first` and `second` members represent iterators to the first and the one-past-end
    characters in the match sequence; if there is no match sequence, the two iterators
    are equal:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板`std::sub_match`表示与捕获组匹配的字符序列；这个类实际上是从`std::pair`派生出来的，它的`first`和`second`成员表示匹配序列中第一个和最后一个字符的迭代器；如果没有匹配序列，则这两个迭代器是相等的：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The class template `std::match_results` is a collection of matches; the first
    element is always a full match in the target, and the other elements are matches
    of subexpressions:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板`std::match_results`是匹配的集合；第一个元素始终是目标中的完全匹配，其他元素是子表达式的匹配：
- en: '[PRE80]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The algorithms available in the regular expressions standard library are the
    following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标准库中可用的算法如下：
- en: '`std::regex_match()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to an entire string.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_match()`: 这尝试将正则表达式（由`std::basic_regex`实例表示）与整个字符串匹配。'
- en: '`std::regex_search()`: This tries to match a regular expression (represented
    by a `std::basic_regex` instance) to a part of a string (including the entire
    string).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_search()`: 这尝试将正则表达式（由`std::basic_regex`实例表示）与字符串的一部分（包括整个字符串）匹配。'
- en: '`std::regex_replace()`: This replaces matches from a regular expression according
    to a specified format.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_replace()`: 这根据指定的格式替换正则表达式的匹配项。'
- en: 'The iterators available in the regular expressions standard library are the
    following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标准库中可用的迭代器如下：
- en: '`std::regex_interator`: A constant forward iterator used to iterate through
    the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex`
    that must live until the iterator is destroyed. Upon creation and when incremented,
    the iterator calls `std::regex_search()` and stores a copy of the `std::match_results`
    object returned by the algorithm.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_interator`：用于遍历字符串中模式出现的常量前向迭代器。它有一个指向`std::basic_regex`的指针，必须存活到迭代器被销毁。在创建和递增时，迭代器调用`std::regex_search()`并存储算法返回的`std::match_results`对象的副本。'
- en: '`std::regex_token_iterator`: A constant forward iterator used to iterate through
    the submatches of every match of a regular expression in a string. Internally,
    it uses an `std::regex_iterator` to step through the submatches. Since it stores
    a pointer to an `std::basic_regex` instance, the regular expression object must
    live until the iterator is destroyed.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_token_iterator`：用于遍历字符串中正则表达式的每个匹配的子匹配的常量前向迭代器。在内部，它使用`std::regex_iterator`来遍历子匹配。由于它存储指向`std::basic_regex`实例的指针，因此正则表达式对象必须存活到迭代器被销毁。'
- en: See also
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Parsing the content of a string using regular expressions*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式解析字符串的内容*'
- en: '*Replacing the content of a string using regular expressions*'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式替换字符串的内容*'
- en: '*Using structured bindings to handle multi-return values* recipe of [Chapter
    8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning Modern Core Language
    Features*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用结构化绑定处理多返回值* [第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)的示例，*学习现代核心语言特性*'
- en: Parsing the content of a string using regular expressions
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串的内容
- en: In the previous recipe, we have looked at how to use `std::regex_match()` to
    verify that the content of a string matches a particular format. The library provides
    another algorithm called `std::regex_search()` that matches a regular expression
    against any part of a string, and not only the entire string as `regex_match()`
    does. This function, however, does not allow searching through all the occurrences
    of a regular expression in an input string. For this purpose, we need to use one
    of the iterator classes available in the library.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已经看到如何使用`std::regex_match()`来验证字符串的内容是否与特定格式匹配。库提供了另一个名为`std::regex_search()`的算法，它可以匹配字符串的任何部分，而不仅仅是整个字符串，如`regex_match()`所做的那样。然而，这个函数不允许在输入字符串中搜索所有正则表达式的出现。为此，我们需要使用库中可用的迭代器类之一。
- en: 'In this recipe, you will learn how to parse the content of a string using regular
    expressions. For this purpose, we will consider the problem of parsing a text
    file containing name-value pairs. Each such pair is defined on a different line
    having the format `name = value`, but lines starting with a `#` represent comments
    and must be ignored. The following is an example:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用正则表达式解析字符串的内容。为此，我们将考虑解析包含名称-值对的文本文件的问题。每个这样的对在不同行上定义，格式为`name
    = value`，但以`#`开头的行表示注释，必须被忽略。以下是一个例子：
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Getting ready
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe. Basic
    knowledge of regular expressions is required for proceeding with this recipe.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 有关C++11中正则表达式支持的一般信息，请参阅*使用正则表达式验证字符串的格式*示例。需要基本的正则表达式知识才能继续进行这个示例。
- en: 'In the following examples, `text` is a variable defined as shown here:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`text`是一个变量，定义如下：
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How to do it...
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to search for occurrences of a regular expression through a string
    you should perform the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搜索字符串中正则表达式的出现，您应该执行以下操作：
- en: 'Include headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user-defined literals for strings:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括头文件`<regex>`和`<string>`以及命名空间`std::string_literals`，用于C++14标准用户定义的字符串字面量：
- en: '[PRE83]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (that can occur frequently). The following regular expression validates
    the file format proposed earlier:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量指定正则表达式，以避免转义反斜杠（这可能经常发生）。以下正则表达式验证了先前提出的文件格式：
- en: '[PRE84]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`std::regex`/`std::wregex`对象（取决于所使用的字符集）来封装正则表达式：
- en: '[PRE85]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To search for the first occurrence of a regular expression in a given text,
    use the general purpose algorithm `std::regex_search()` (example 1):'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在给定文本中搜索正则表达式的第一个匹配项，使用通用算法`std::regex_search()`（示例1）：
- en: '[PRE86]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To find all the occurrences of a regular expression in a given text, use the
    iterator `std::regex_iterator` (example 2):'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在给定文本中查找正则表达式的所有出现，使用迭代器`std::regex_iterator`（示例2）：
- en: '[PRE87]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To iterate through all the subexpressions of a match, use the iterator `std::regex_token_iterator`
    (example 3):'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要遍历匹配的所有子表达式，请使用迭代器`std::regex_token_iterator`（示例3）：
- en: '[PRE88]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'A simple regular expression that can parse the input file shown earlier may
    look like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的正则表达式，可以解析之前显示的输入文件，可能看起来像这样：
- en: '[PRE89]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This regular expression is supposed to ignore all lines that start with a `#`;
    for those that do not start with `#`, match a name followed by the equal sign
    and then a value that can be composed of alphanumeric characters and several other
    characters (underscore, dot, comma, and so on). The exact meaning of this regular
    expression is explained as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式应该忽略所有以`#`开头的行；对于不以`#`开头的行，匹配一个名称，后面跟着一个等号，然后是由字母数字字符和几个其他字符（下划线、点、逗号等）组成的值。这个正则表达式的确切含义如下所述：
- en: '| **Part** | **Description** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **描述** |'
- en: '| `^` | Start of line |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 行首 |'
- en: '| `(?!#)` | A negative lookahead that makes sure that it is not possible to
    match the # character |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `(?!#)` | 负向先行断言，确保不可能匹配#字符。'
- en: '| `(\w)+` | A capturing group representing an identifier of at least a one
    word character |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `(\w)+` | 代表至少一个单词字符的捕获组 |'
- en: '| `\s*` | Any white spaces |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `\s*` | 任何空格 |'
- en: '| `=` | Equal sign |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 等号 |'
- en: '| `\s*` | Any white spaces |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `\s*` | 任何空格 |'
- en: '| `([\w\d]+[\w\d._,\-:]*)` | A capturing group representing a value that starts
    with an alphanumeric character, but can also contain a dot, comma, backslash,
    hyphen, colon, or an underscore. |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `([\w\d]+[\w\d._,\-:]*)` | 代表以字母数字字符开头的值的捕获组，但也可以包含点、逗号、反斜杠、连字符、冒号或下划线。'
- en: '| `$` | End of line |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行尾 |'
- en: We can use `std::regex_search()` to search for a match anywhere in the input
    text. This algorithm has several overloads, but in general they work in the same
    way. You must specify the range of characters to work through, an output `std::match_results`
    object that will contain the result of the match, and a `std::basic_regex` object
    representing the regular expression and matching flags (that define the way the
    search is done). The function returns `true` if a match was found or `false` otherwise.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::regex_search()`在输入文本中搜索匹配项。这个算法有几个重载，但一般来说它们的工作方式相同。您必须指定要处理的字符范围，一个输出`std::match_results`对象，它将包含匹配的结果，以及表示正则表达式和匹配标志的`std::basic_regex`对象（定义搜索方式）。如果找到了匹配项，函数返回`true`，否则返回`false`。
- en: 'In the first example from the previous section (see the 4th list item), `match`
    is an instance of `std::smatch` that is a `typedef` of `std::match_results` with
    `string::const_iterator` as the template type. If a match was found, this object
    will contain the matching information in a sequence of values for all matched
    subexpressions. The submatch at index 0 is always the entire match. The submatch
    at index 1 is the first subexpression that was matched, the submatch at index
    2 is the second subexpression that was matched, and so on. Since we have two capturing
    groups (that are subexpressions) in our regular expression, the `std::match_results`
    will have three submatches in case of success. The identifier representing the
    name is at index 1, and the value after the equal sign is at index 2\. Therefore,
    this code only prints the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的第一个示例中（参见第4个列表项），`match`是`std::smatch`的一个实例，它是`std::match_results`的`typedef`，模板类型为`string::const_iterator`。如果找到了匹配项，这个对象将包含所有匹配子表达式的一系列值的匹配信息。索引为0的子匹配始终是整个匹配。索引为1的子匹配是第一个匹配的子表达式，索引为2的子匹配是第二个匹配的子表达式，依此类推。由于我们的正则表达式中有两个捕获组（即子表达式），所以在成功的情况下，`std::match_results`将有三个子匹配。表示名称的标识符在索引1处，等号后面的值在索引2处。因此，这段代码只打印以下内容：
- en: '[PRE90]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `std::regex_search()` algorithm is not able to iterate through all the possible
    matches in a text. To do that, we need to use an iterator. `std::regex_iterator` is intended
    for this purpose. It allows not only iterating through all the matches, but also
    accessing all the submatches of a match. The iterator actually calls `std::regex_search()`
    upon construction and on each increment, and it remembers the result `std::match_results`
    from the call. The default constructor creates an iterator that represents the
    end of the sequence and can be used to test when the loop through the matches
    should stop.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_search()`算法无法遍历文本中所有可能的匹配项。为了做到这一点，我们需要使用迭代器。`std::regex_iterator`用于此目的。它不仅允许遍历所有匹配项，还允许访问匹配项的所有子匹配项。迭代器实际上在构造时调用`std::regex_search()`，并在每次递增时记住调用的结果`std::match_results`。默认构造函数创建一个表示序列末尾的迭代器，可用于测试何时应该停止遍历匹配项的循环。'
- en: 'In the second example from the previous section (see the 5th list item), we
    first create an end of sequence iterator, and then we start iterating through
    all the possible matches. When constructed, it will call `std::regex_match()`,
    and if a match is found, we can access its results through the current iterator.
    This will continue until no match is found (end of the sequence). This code will
    print the following output:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的第二个示例中（参见第5个列表项），我们首先创建一个序列结束迭代器，然后开始遍历所有可能的匹配项。在构造时，它将调用`std::regex_match()`，如果找到匹配项，我们可以通过当前迭代器访问其结果。这将一直持续，直到找不到匹配项（序列结束）。这段代码将打印以下输出：
- en: '[PRE91]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'An alternative to `std::regex_iterator` is `std::regex_token_iterator`. This
    works similar to the way `std::regex_iterator` works and, in fact, it contains
    such an iterator internally, except that it enables us to access a particular
    subexpression from a match. This is shown in the third example in the *How to
    do it..*. section (the the 6th list item). We start by creating an end-of-sequence
    iterator and then loop through the matches until the end-of-sequence is reached.
    In the constructor we used, we did not specify the index of the subexpression
    to access through the iterator; therefore, the default value of 0 is used. That
    means this program will print the entire matches:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_iterator`的替代方法是`std::regex_token_iterator`。它的工作方式类似于`std::regex_iterator`的工作方式，并且实际上在内部包含这样一个迭代器，只是它使我们能够访问匹配的特定子表达式。这在*如何做...*部分的第三个示例中（第6个列表项）中显示。我们首先创建一个序列末尾的迭代器，然后循环遍历匹配，直到达到序列末尾。在我们使用的构造函数中，我们没有指定通过迭代器访问的子表达式的索引；因此，将使用默认值0。这意味着此程序将打印整个匹配：'
- en: '[PRE92]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we wanted to access only the first subexpression (that means the names in
    our case), all we had to do was specify the index of the subexpression in the
    constructor of the token iterator. This time, the output that we get is only the
    names:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想访问第一个子表达式（在我们的情况下是名称），我们只需要在令牌迭代器的构造函数中指定子表达式的索引。这次，我们得到的输出只有名称：
- en: '[PRE93]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'An interesting thing about the token iterator is that it can return the unmatched
    parts of the string if the index of the subexpressions is `-1`, in which case
    it returns an `std::match_results` object that corresponds to the sequence of
    characters between the last match and the end of the sequence:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 关于令牌迭代器的一个有趣之处是，如果子表达式的索引为`-1`，它可以返回字符串的未匹配部分，此时它返回一个与最后匹配和序列末尾之间的字符序列相对应的`std::match_results`对象：
- en: '[PRE94]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This program will output the following (note that the empty lines are actually
    part of the output):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将输出以下内容（请注意，空行实际上是输出的一部分）：
- en: '[PRE95]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: See also
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Verifying the format of a string using regular expressions*'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式验证字符串格式*'
- en: '*Replacing the content of a string using regular expressions*'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式替换字符串的内容*'
- en: Replacing the content of a string using regular expressions
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式替换字符串的内容
- en: In the last two recipes, we have looked at how to match a regular expression
    on a string or a part of a string and iterate through matches and submatches.
    The regular expression library also supports text replacement based on regular
    expressions. In this recipe, we will see how to use `std::regex_replace()` to
    perform such text transformations.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个示例中，我们已经看到如何在字符串或字符串的一部分上匹配正则表达式，并遍历匹配和子匹配。正则表达式库还支持基于正则表达式的文本替换。在本示例中，我们将看到如何使用`std::regex_replace()`执行此类文本转换。
- en: Getting ready
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For general information about regular expressions support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++11中正则表达式支持的一般信息，请参考*使用正则表达式验证字符串格式*的示例。
- en: How to do it...
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to perform text transformations using regular expressions, you should
    perform the following:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用正则表达式执行文本转换，您应该执行以下操作：
- en: 'Include the `<regex>` and `<string>` and the namespace `std::string_literals`
    for C++14 standard user defined literals for strings:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '包括`<regex>`和`<string>`，以及命名空间`std::string_literals`，用于C++14标准用户定义的字符串字面量： '
- en: '[PRE96]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Use the `std::regex_replace()` algorithm with a replacement string as the third argument.
    Consider this example: replace all words composed of exactly three characters
    that are either `a`, `b`, or `c` with three hyphens:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::regex_replace()`算法，并将替换字符串作为第三个参数。考虑以下示例：用三个连字符替换由`a`、`b`或`c`组成的恰好三个字符的所有单词：
- en: '[PRE97]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Use the `std::regex_replace()` algorithm with match identifiers prefixed with
    a `$` for the third argument. For example, replace names in the "lastname, firstname"
    with names in the format "firstname lastname", as follows:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::regex_replace()`算法，并在第三个参数中使用以`$`为前缀的匹配标识符。例如，将“姓，名”中的名替换为“名 姓”，如下所示：
- en: '[PRE98]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works...
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `std::regex_replace()` algorithm has several overloads with different types
    of parameters, but the meaning of the parameters is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_replace()`算法有几个重载，具有不同类型的参数，但参数的含义如下：'
- en: The input string on which the replacement is performed.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行替换的输入字符串。
- en: An `std::basic_regex` object that encapsulates the regular expression used to
    identify the parts of the strings to be replaced.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装了用于标识要替换的字符串部分的正则表达式的`std::basic_regex`对象。
- en: The string format used for replacement.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于替换的字符串格式。
- en: Optional matching flags.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的匹配标志。
- en: 'The return value is, depending on the overload used, either a string or a copy
    of the output iterator provided as an argument. The string format used for replacement
    can either be a simple string or a match identifier indicated with a `$` prefix:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值取决于使用的重载，可以是字符串，也可以是作为参数提供的输出迭代器的副本。用于替换的字符串格式可以是简单字符串，也可以是以`$`前缀表示的匹配标识符：
- en: '`$&` indicates the entire match.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$&`表示整个匹配。'
- en: '`$1`, `$2`, `$3`, and so on, indicate the first, second, third submatch, and
    so on.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`，`$2`，`$3`等表示第一个、第二个、第三个子匹配等。'
- en: '`$`` indicates the part of the string before the first match.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``表示第一个匹配前的字符串部分。'
- en: '`$''` indicates the part of the string after the last match.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$''`表示最后匹配后的字符串部分。'
- en: In the first example shown in the *How to do it...* section, the initial text
    contains two words made of exactly three `a`, `b`, or `c` characters, `abc` and
    `bca`. The regular expression indicates an expression of exactly three characters
    between word boundaries. That means a subtext, such as `bbbb`, will not match
    the expression. The result of the replacement is that the string text will be
    `--- aa --- ca bbbb`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分所示的第一个例子中，初始文本包含由恰好三个`a`、`b`或`c`字符组成的两个单词，`abc`和`bca`。正则表达式指示在单词边界之间恰好有三个字符的表达式。这意味着一个子文本，比如`bbbb`，将不会匹配该表达式。替换的结果是字符串文本将会是`---
    aa --- ca bbbb`。
- en: 'Additional flags for the match can be specified to the `std::regex_replace()`
    algorithm. By default, the matching flag is `std::regex_constants::match_default`
    that basically specifies ECMAScript as the grammar used for constructing the regular
    expression. If we want, for instance, to replace only the first occurrence, then
    we can specify `std::regex_constants::format_first_only`. In the next example,
    the result is `--- aa bca ca bbbb` as the replacement stops after the first match
    is found:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为`std::regex_replace()`算法指定匹配的附加标志。默认情况下，匹配标志是`std::regex_constants::match_default`，基本上指定了ECMAScript作为用于构造正则表达式的语法。例如，如果我们想要只替换第一次出现的匹配，那么我们可以指定`std::regex_constants::format_first_only`。在下一个例子中，结果是`---
    aa bca ca bbbb`，因为替换在找到第一个匹配后停止。
- en: '[PRE99]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The replacement string, however, can contain special indicators for the whole
    match, a particular submatch, or the parts that were not matched, as explained
    earlier. In the second example shown in the *How to do it...* section, the regular
    expression identifies a word of at least one character, followed by a coma and
    possible white spaces and then another word of at least one character. The first
    word is supposed to be the last name and the second word is supposed to be the
    first name. The replacement string has the `$2 $1` format. This is an instruction
    to replace the matched expression (in this example, the entire original string)
    with another string formed of the second submatch followed by space and then the
    first submatch.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，替换字符串可以包含特殊指示符，用于整个匹配、特定子匹配，或者未匹配的部分，如前面所解释的。在*如何做...*部分所示的第二个例子中，正则表达式识别至少一个字符的单词，后面跟着逗号和可能的空格，然后是另一个至少一个字符的单词。第一个单词应该是姓，第二个单词应该是名。替换字符串采用`$2
    $1`格式。这是一个指令，用另一个字符串替换匹配的表达式（在这个例子中，整个原始字符串），由第二个子匹配后跟一个空格，然后是第一个子匹配。
- en: 'In this case, the entire string was a match. In the next example, there will
    be multiple matches inside the string, and they will all be replaced with the
    indicated string. In this example, we are replacing the indefinite article *a*
    when preceding a word that starts with a vowel (this, of course, does not cover
    words that start with a vowel sound) with the indefinite article *an*:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整个字符串都是一个匹配。在下一个例子中，字符串内将有多个匹配，并且它们都将被替换为指定的字符串。在这个例子中，我们替换了在元音字母开头的单词之前的不定冠词*a*为不定冠词*an*（当然，这并不包括以元音音素开头的单词）：
- en: '[PRE100]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The regular expression identifies the letter *a* as a single word (`\b` indicates
    a word boundary, so `\ba` means a word with a single letter *a*) followed by a
    space and a word of at least two characters starting with a vowel. When such a
    match is identified, it is replaced with a string formed of the fixed string *an*
    followed by a space and the first subexpression of the match, which is the word
    itself. In this example, the `newtext` string will be *this is an example with
    an error*.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式将字母*a*识别为一个单词（`\b`表示单词边界，所以`\ba`表示一个只有一个字母*a*的单词），后面跟着一个空格和至少以元音字母开头的至少两个字符的单词。当识别到这样的匹配时，它将被替换为一个由固定字符串*an*后跟一个空格和匹配的第一个子表达式（即单词本身）组成的字符串。在这个例子中，`newtext`字符串将是*this
    is an example with an error*。
- en: 'Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there
    are other identifiers for the entire match (`$&`), the part of the string before
    the first match (`$``) and the part of the string after the last match (`$''`).
    In the last example, we change the format of a date from `dd.mm.yyyy` to `yyyy.mm.dd`,
    but also show the matched parts:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 除了子表达式的标识符（`$1`，`$2`等），还有其他标识符用于整个匹配（`$&`），第一个匹配之前的字符串部分（`$``），以及最后一个匹配之后的字符串部分（`$'`）。在最后一个例子中，我们改变了日期的格式从`dd.mm.yyyy`到`yyyy.mm.dd`，同时显示了匹配的部分。
- en: '[PRE101]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The regular expression matches a one- or two-digit number followed by a dot,
    hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen,
    or slash; and last a four-digit number.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式匹配一个或两位数字，后面跟着一个点、连字符或斜杠；然后是另一个一位或两位数字；然后是一个点、连字符或斜杠；最后是四位数字。
- en: For `newtext1`, the replacement string is `$5$4$3$2$1`; that means year, followed
    by the second separator, then month, the first separator, and finally day. Therefore,
    for the input string *"today is 1.06.2016!"*, the result is *"today is 2016.06.1!!"*.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`newtext1`，替换字符串是`$5$4$3$2$1`；这意味着年份，后面是第二个分隔符，然后是月份，第一个分隔符，最后是日期。因此，对于输入字符串*"today
    is 1.06.2016!"*，结果是*"today is 2016.06.1!!"*。
- en: For `newtext2`, the replacement string is `[$`][$&][$']`; that means the part
    before the first match, followed by the entire match, and finally the part after
    the last match are in square brackets. However, the result is not *"[!!][1.06.2016][today
    is ]"* as you perhaps might expect at a first glance, but *"today is [today is
    ][1.06.2016][!!]!!"*. The reason is that what is replaced is the matched expression,
    and, in this case, that is only the date (*"1.06.2016"*). This substring is replaced
    with another string formed of the all parts of the initial string.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`newtext2`，替换字符串是`[$`][$&][$']`；这意味着第一个匹配之前的部分，后面跟着整个匹配，最后是最后一个匹配之后的部分都在方括号中。然而，结果并不是*"[!!][1.06.2016][today
    is ]"*，这可能是你第一眼期望的，而是*"today is [today is ][1.06.2016][!!]!!"*。原因是被替换的是匹配的表达式，在这种情况下，那只是日期（*"1.06.2016"*）。这个子字符串被另一个字符串替换，由初始字符串的所有部分组成。
- en: See also
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Verifying the format of a string using regular expressions*'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式验证字符串的格式*'
- en: '*Parsing the content of a string using regular expressions*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式解析字符串的内容*'
- en: Using string_view instead of constant string references
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`string_view`代替常量字符串引用
- en: When working with strings, temporary objects are created all the time, even
    if you might not be really aware of it. Many times the temporary objects are irrelevant
    and only serve the purpose of copying data from one place to another (for example,
    from a function to its caller). This represents a performance issue because they
    require memory allocation and data copying, which is desirable to be avoided.
    For this purpose, the C++17 standard provides a new string class template called
    `std::basic_string_view` that represents a non-owning constant reference to a
    string (that is, a sequence of characters). In this recipe, you will learn when
    and how you should use this class.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，临时对象经常被创建，即使你可能并不真正意识到。许多时候，临时对象是无关紧要的，只是为了将数据从一个地方复制到另一个地方（例如，从函数到其调用者）。这代表了一个性能问题，因为它们需要内存分配和数据复制，这是希望避免的。为此，C++17标准提供了一个名为`std::basic_string_view`的新字符串类模板，它表示对字符串（即字符序列）的非拥有常量引用。在这个示例中，你将学习何时以及如何使用这个类。
- en: Getting ready
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `string_view` class is available in the namespace `std` in the `string_view` header.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view`类在`string_view`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You should use `std::string_view` to pass a parameter to a function (or return
    a value from a function), instead of `std::string const &` unless your code needs
    to call other functions that take `std::string` parameters (in which case, conversions
    would be necessary):'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用`std::string_view`来传递参数给函数（或者从函数返回值），而不是`std::string const &`，除非你的代码需要调用其他需要`std::string`参数的函数（在这种情况下，需要进行转换）：
- en: '[PRE102]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works...
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Before we look at how the new string type works, let's consider the following
    example of a function that is supposed to extract the name of a file without its
    extension. This is basically how you would write the function from the previous
    section before C++17.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看新字符串类型如何工作之前，让我们考虑下面的一个函数的例子，该函数应该提取没有扩展名的文件名。这基本上是在C++17之前你会如何编写前一节中的函数。
- en: Note that in this example the file separator is `\` (backslash) as in Windows.
    For Linux-based systems, it has to be changed to `/` (slash).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，文件分隔符是`\`（反斜杠），就像在Windows中一样。对于基于Linux的系统，它必须更改为`/`（斜杠）。
- en: '[PRE103]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is a relatively simple function. It takes a constant reference to an `std::string`
    and identifies a substring bounded by the last file separator and the last dot
    that basically represents a filename without an extension (and without folder
    names).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的函数。它接受一个`std::string`的常量引用，并识别由最后一个文件分隔符和最后一个点界定的子字符串，基本上表示一个没有扩展名（也没有文件夹名称）的文件名。
- en: The problem with this code, however, is that it creates one, two, or, possibly,
    even more temporaries, depending on the compiler optimizations. The function parameter
    is a constant `std::string` reference, but the function is called with a string
    literal, which means `std::string` needs to be constructed from the literal. These
    temporaries need to allocate and copy data, which is both time- and resource-consuming.
    In the last example, all we want to do is check whether the first character of
    the filename is an underscore, but we create at least two temporary string objects
    for that purpose.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码的问题在于，它创建了一个、两个，甚至可能更多的临时对象，这取决于编译器的优化。函数参数是一个常量`std::string`引用，但函数被调用时使用了一个字符串字面值，这意味着需要从字面值构造`std::string`。这些临时对象需要分配和复制数据，这既耗时又消耗资源。在最后一个例子中，我们只想检查文件名的第一个字符是否是下划线，但为此我们至少创建了两个临时字符串对象。
- en: The `std::basic_string_view` class template is intended to solve this problem.
    This class template is very similar to `std::basic_string`, the two having almost
    the same interface. The reasons for this is that the `std::basic_string_view`
    is intended to be used instead of a constant reference to an `std::basic_string`
    without further code changes.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_string_view`类模板旨在解决这个问题。这个类模板与`std::basic_string`非常相似，两者几乎具有相同的接口。原因是`std::basic_string_view`旨在用来代替对`std::basic_string`的常量引用，而不需要进一步的代码更改。'
- en: 'Just like with `std::basic_string`, there are specializations for all types
    of standard characters:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`std::basic_string`一样，对于所有类型的标准字符都有特殊化：
- en: '[PRE104]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `std::basic_string_view` class template defines a reference to a constant
    contiguous sequence of characters. As the name implies, it represents a view and
    cannot be used to modify the reference sequence of characters. An `std::basic_string_view`
    object has a relatively small size because all that it needs is a pointer to the
    first character in the sequence and the length. It can be constructed not only
    from an `std::basic_string` object but also from a pointer and a length or from
    a null-terminated sequence of characters (in which case, it will require an initial
    traversing of the string in order to find the length). Therefore, the `std::basic_string_view`
    class template can also be used as a common interface for multiple types of strings
    (as long as data only needs to be read). On the other hand, converting from an `std::basic_string_view`
    to an `std::basic_string` is easy because the former has both a `to_string()`
    and a converting `operator std::basic_string` to create a new `std::basic_string`
    object.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_string_view`类模板定义了对字符的一个常量连续序列的引用。顾名思义，它表示一个视图，不能用于修改字符的引用序列。一个`std::basic_string_view`对象的大小相对较小，因为它所需的只是指向序列中第一个字符的指针和长度。它不仅可以从`std::basic_string`对象构造，还可以从指针和长度或者以空字符结尾的字符序列构造（在这种情况下，它将需要对字符串进行初始遍历以找到长度）。因此，`std::basic_string_view`类模板也可以用作多种类型字符串的通用接口（只要数据只需要被读取）。另一方面，从`std::basic_string_view`转换为`std::basic_string`很容易，因为前者既有`to_string()`又有一个转换的`operator
    std::basic_string`来创建一个新的`std::basic_string`对象。'
- en: Passing `std::basic_string_view` to functions and returning `std::basic_string_view`
    still creates temporaries of this type, but these are small size objects on the
    stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore,
    they should incur fewer performance costs than allocating heap space and copying
    data.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 将`std::basic_string_view`传递给函数并返回`std::basic_string_view`仍然会创建这种类型的临时对象，但这些对象在堆栈上是小型对象（对于64位平台，指针和大小可能为16字节）；因此，它们应该比分配堆空间和复制数据产生更少的性能成本。
- en: Notice that all major compilers provide an implementation of std::basic_string
    that includes a small string optimization. Although the implementation details
    are different, they typically rely on having a statically allocated buffer of
    a number of characters (16 for VC++ and gcc 5 or newer) that does not involve
    heap operations, which are only required when the size of the string exceeds that
    number of characters.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有主要的编译器都提供了std::basic_string的实现，其中包括小字符串优化。尽管实现细节不同，但它们通常依赖于具有静态分配的字符数（对于VC++和gcc
    5或更新版本为16）的缓冲区，不涉及堆操作，只有在字符串的大小超过该字符数时才需要堆操作。
- en: 'In addition to the methods that are identical to those available in `std::basic_string`,
    the `std::basic_string_view` has two more:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与`std::basic_string`中可用的相同的方法之外，`std::basic_string_view`还有两个：
- en: '`remove_prefix()`: Shrinks the view by incrementing the start with *N* characters
    and decrementing the length with *N* characters.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_prefix()`: 通过增加*N*个字符来缩小视图的起始位置，并通过减少*N*个字符来缩小长度。'
- en: '`remove_suffix()`: Shrinks the view by decrementing the length with *N* characters.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_suffix()`: 通过减少*N*个字符来缩小视图的长度。'
- en: 'The two member functions are used in the following example to trim an `std::string_view`
    from spaces, both at the beginning and the end. The implementation of the function
    first looks for the first element that is not a space and then for the last element
    that is not a space. Then, it removes from the end everything after the last non-space
    character, and from the beginning everything until the first non-space character.
    The function returns the new view trimmed at both ends:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中使用这两个成员函数来修剪`std::string_view`中的空格，无论是在开头还是结尾。函数的实现首先查找第一个不是空格的元素，然后查找最后一个不是空格的元素。然后，它从末尾删除最后一个非空格字符之后的所有内容，并从开头删除第一个非空格字符之前的所有内容。函数返回修剪后的新视图：
- en: '[PRE105]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When using an `std::basic_string_view`, you must be aware of two things: you
    cannot change the underlying data referred by a view and you must manage the lifetime
    of the data, as the view is a non-owning reference.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`std::basic_string_view`时，您必须注意两件事：您不能更改视图引用的基础数据，必须管理数据的生命周期，因为视图是一个非拥有引用。
- en: See also
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '*Creating a library of string helpers*'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建字符串助手库*'
