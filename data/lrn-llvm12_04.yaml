- en: '*Chapter 3*: The Structure of a Compiler'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：编译器的结构'
- en: 'Compiler technology is a well-studied field of computer science. Its high-level
    task is to translate a source language into machine code. Typically, this task
    is divided into two parts: the frontend and the backend. The frontend mainly deals
    with the source language, while the backend is responsible for generating machine
    code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器技术是计算机科学中一个深入研究的领域。它的高级任务是将源语言翻译成机器码。通常，这个任务分为两部分：前端和后端。前端主要处理源语言，而后端负责生成机器码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The building blocks of a compiler, in which you will learn about the components
    typically found in a compiler.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器的构建模块，您将了解到编译器中通常找到的组件。
- en: An arithmetic expression language, which will introduce you to an example language.
    You will learn how grammar is used to define a language.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术表达式语言，将为您介绍一个示例语言。您将学习语法如何用于定义语言。
- en: Lexical analysis, which will discuss how you implement lexers for the language.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法分析，将讨论如何为语言实现词法分析器。
- en: Syntactical analysis, which covers how to construct a parser from grammar.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法分析，涵盖如何从语法构建解析器。
- en: Semantic analysis, in which you will learn how a sematic check can be implemented.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义分析，您将学习如何实现语义检查。
- en: Code generation with the LLVM backend, which will discuss how to interface with
    the LLVM backend and how you can glue all the phases together to create a complete
    compiler.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LLVM后端进行代码生成，将讨论如何与LLVM后端进行接口，以及如何将所有阶段连接在一起创建完整的编译器。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下链接找到：[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter03/calc)
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到代码的操作视频：[https://bit.ly/3nllhED](https://bit.ly/3nllhED)
- en: Building blocks of a compiler
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器的构建模块
- en: After computers became available in the middle of the last century, it quickly
    became apparent that a more abstract language than assembler would be useful for
    programming. As early as 1957, Fortran was the first available higher programming
    language. Since then, thousands of programming languages have been developed.
    It turns out that all compilers must solve the same tasks and that the implementation
    of a compiler is best structured according to these tasks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自从上个世纪中期计算机问世以来，很快就显而易见，比汇编语言更抽象的语言对编程是有用的。早在1957年，Fortran就是第一种可用的高级编程语言。从那时起，成千上万种编程语言被开发出来。事实证明，所有编译器都必须解决相同的任务，并且编译器的实现最好根据这些任务进行结构化。
- en: 'At the highest level, a compiler consists of two parts: the frontend and the
    backend. The frontend is responsible for language-specific tasks. It reads a source
    file and computes a semantic analyzed representation of it, usually an annotated
    **abstract syntax tree** (**AST**). The backend creates optimized machine code
    from the frontend''s result. The motivation behind there being a distinction between
    the frontend and the backend is reusability. Let''s assume that the interface
    between the frontend and the backend is well defined. Here, you can connect a
    C and a Modula-2 frontend to the same backend. Alternatively, if you have one
    backend for X86 and one for Sparc, then you can connect your C++ frontend to both.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别上，编译器由两部分组成：前端和后端。前端负责特定于语言的任务。它读取源文件并计算其语义分析表示，通常是带注释的**抽象语法树**（**AST**）。后端从前端的结果创建优化的机器码。前端和后端之间有区分的动机是可重用性。假设前端和后端之间的接口定义良好。在这里，您可以将C和Modula-2前端连接到相同的后端。或者，如果您有一个用于X86的后端和一个用于Sparc的后端，那么您可以将C++前端连接到两者。
- en: 'The frontend and backend have specific structures. The frontend usually performs
    the following tasks:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前端和后端有特定的结构。前端通常执行以下任务：
- en: The lexer reads the source file and produces a token stream.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 词法分析器读取源文件并生成标记流。
- en: The parser creates an AST from the token stream.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器从标记流创建AST。
- en: The semantic analyzer adds semantic information to the AST.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语义分析器向AST添加语义信息。
- en: The code generator produces an **intermediate representation** (**IR**) from
    the AST.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码生成器从AST生成**中间表示**（**IR**）。
- en: 'The intermediate representation is the interface of the backend. The backend
    does the following tasks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 中间表示是后端的接口。后端执行以下任务：
- en: The backend performs target-independent optimization on the IR.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后端对IR进行与目标无关的优化。
- en: It then selects instructions for the IR code.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它为IR代码选择指令。
- en: After, it performs target-dependent optimizations on the instructions.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它对指令执行与目标相关的优化。
- en: Finally, it emits assembler code or an object file.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它会发出汇编代码或目标文件。
- en: Of course, these instructions are only at a conceptual level. The implementations
    vary a lot. The LLVM core libraries define an intermediate representation as a
    standard interface to the backend. Other tools could use the annotated AST. The
    C preprocessor is a language of its own. It can be implemented as a standalone
    application that outputs preprocessed C source or as an additional component between
    the lexer and the parser. In some cases, the AST must not be constructed explicitly.
    If the language to be implemented is not too complex, then combining the parser
    and the semantic analyzer, and then emitting code while parsing, is a common approach.
    Even if a given implementation of a programing language does not explicitly name
    these components, it is good to remember that the tasks must still be done.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些说明仅在概念层面上。实现方式各不相同。LLVM核心库定义了一个中间表示作为后端的标准接口。其他工具可以使用带注释的AST。C预处理器是一种独立的语言。它可以作为一个独立的应用程序实现，输出预处理的C源代码，或者作为词法分析器和解析器之间的附加组件。在某些情况下，AST不必显式构造。如果要实现的语言不太复杂，那么将解析器和语义分析器结合起来，然后在解析过程中生成代码是一种常见的方法。即使程序设计语言的特定实现没有明确命名这些组件，也要记住这些任务仍然必须完成。
- en: In the following sections, we will construct a compiler for an expression language
    that produces LLVM IR from its input. The LLVM static compiler, `llc`, which represents
    the backend, can then be used to compile the IR into object code. It all begins
    with defining the language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为一个表达式语言构建一个编译器，该编译器可以从输入中生成LLVM IR。LLVM静态编译器`llc`代表后端，然后可以用于将IR编译成目标代码。一切都始于定义语言。
- en: An arithmetic expression language
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术表达式语言
- en: 'Arithmetic expressions are part of every programming language. Here is an example
    of an arithmetic expression calculation language called **calc**. calc expressions
    are compiled into an application that evaluates the following expression:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式是每种编程语言的一部分。这里有一个名为**calc**的算术表达式计算语言的示例。calc表达式被编译成一个应用程序，用于计算以下表达式：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variables that are used in the expression must be declared with the `with`
    keyword. This program is compiled into an application, which asks the user for
    the values of the `a` and `b` variables and prints the result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中使用的变量必须使用`with`关键字声明。这个程序被编译成一个应用程序，该应用程序要求用户输入`a`和`b`变量的值，并打印结果。
- en: Examples are always welcome but as a compiler writer, you need a more thorough
    specification than this for implementation and testing. The vehicle for the syntax
    of the programming language is its grammar.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 示例总是受欢迎的，但作为编译器编写者，你需要比这更彻底的规范来进行实现和测试。编程语言的语法的载体是其语法。
- en: Formalism for specifying the syntax of a programming language
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于指定编程语言语法的形式化方法
- en: The elements of a language, such as its keywords, identifiers, strings, numbers,
    and operators, are called **tokens**. In this sense, a program is a sequence of
    tokens, and the grammar specifies which sequences are valid.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的元素，如关键字、标识符、字符串、数字和运算符，被称为**标记**。从这个意义上说，程序是一系列标记的序列，语法规定了哪些序列是有效的。
- en: 'Usually, grammar is written in the **extended Backus-Naur form (EBNF)**. One
    of the rules of grammar is that it has a left-hand side and a right-hand side.
    The left-hand side is just a single symbol called a **non-terminal**. The right-hand
    side of a rule consists of non-terminals, tokens, and meta-symbols for alternatives
    and repetitions. Let''s have a look at the grammar for the calc language:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，语法是用**扩展的巴科斯-瑙尔范式（EBNF）**编写的。语法的一个规则是它有左侧和右侧。左侧只是一个称为**非终结符**的单个符号。规则的右侧由非终结符、标记和用于替代和重复的元符号组成。让我们来看看calc语言的语法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line, `calc` is a non-terminal. If not otherwise stated, then the
    first non-terminal of grammar is the start symbol. The colon, `:`, is the separator
    between the left-hand side and the right-hand side of the rule. `"with"`, `","`,
    and `":"` are tokens that represent this string. Parentheses are used for grouping.
    A group can be optional or repeated. A question mark, `?`, after the closing parenthesis
    denotes an optional group. A star, `*`, denotes zero or more repetitions, while
    a plus, `+`, denotes one or more repetitions. `ident` and `expr` are non-terminals.
    For each, another rule exists. The semicolon, `;`, marks the end of a rule. The
    pipe, `|`, in the second line, denotes an alternative. Finally, the brackets,
    `[ ]`, in the last two lines denote a character class. The valid characters are
    written inside the brackets. For example, the `[a-zA-Z]` character classes matches
    an uppercase or lowercase letter and `([a-zA-Z])+` matches one or more of these
    letters. This corresponds to a regular expression.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，`calc`是一个非终结符。如果没有另外说明，那么语法的第一个非终结符是起始符号。冒号`:`是规则左侧和右侧的分隔符。`"with"`、`,`和`":"`是代表这个字符串的标记。括号用于分组。一个组可以是可选的或重复的。括号后面的问号`?`表示一个可选组。星号`*`表示零次或多次重复，加号`+`表示一次或多次重复。`ident`和`expr`是非终结符。对于每一个，都存在另一个规则。分号`;`标记了规则的结束。第二行中的竖线`|`表示一个替代。最后，最后两行中的方括号`[]`表示一个字符类。有效的字符写在方括号内。例如，`[a-zA-Z]`字符类匹配大写或小写字母，`([a-zA-Z])+`匹配一个或多个这些字母。这对应于一个正则表达式。
- en: How grammar helps the compiler writer
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法如何帮助编译器编写者
- en: Such grammar may look like a theoretical toy, but it is of value to the compiler
    writer. First, all the tokens are defined, which is needed to create the lexical
    analyzer. The rules of the grammar can be translated into the parser. And of course,
    if questions arise regarding whether the parser works correctly, then the grammar
    serves as a good specification.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的语法可能看起来像一个理论上的玩具，但对于编译器编写者来说是有价值的。首先，定义了所有的标记，这是创建词法分析器所需的。语法的规则可以被转换成解析器。当然，如果对解析器是否正确工作有疑问，那么语法就是一个很好的规范。
- en: However, grammar does not define all the aspects of a programming language.
    The meaning – the semantics – of the syntax must also be defined. Formalisms for
    this purpose were developed too, but often, it is specified in plain text, similar
    to when the language was first introduced.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，语法并没有定义编程语言的所有方面。语法的含义 - 语义 - 也必须被定义。为此目的开发了形式化方法，但通常是以纯文本的方式指定的，类似于语言首次引入时的情况。
- en: Equipped with this knowledge, the next two sections will show you how lexical
    analysis turns the input into a sequence of tokens and how grammar is coded in
    C++ for syntactical analysis.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，接下来的两节将向您展示词法分析如何将输入转换为标记序列，以及如何在C++中对语法进行编码以进行语法分析。
- en: Lexical analysis
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法分析
- en: As we saw in the example in the previous section, a programming language consists
    of many elements, such as keywords, identifiers, numbers, operators, and so on.
    The task of lexical analysis is to take the textual input and create a sequence
    of tokens from it. The calc language consists of the `with`, `:`, `+`, `-`, `*`,
    `/`, `(`, and `)` tokens and the `([a-zA-Z])+` (an identifier) and `([0-9])+`
    (a number) regular expressions. We assign a unique number to each token to make
    handling them easier.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节的示例中看到的，编程语言由许多元素组成，如关键字、标识符、数字、运算符等。词法分析的任务是接受文本输入并从中创建一个标记序列。calc语言由`with`、`:`、`+`、`-`、`*`、`/`、`(`和`)`标记以及`([a-zA-Z])+`（标识符）和`([0-9])+`（数字）正则表达式组成。我们为每个标记分配一个唯一的数字，以便更容易地处理它们。
- en: A handwritten lexer
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手写词法分析器
- en: 'The implementation of a lexical analyzer is often called a `Lexer`. Let''s
    create a header file called `Lexer.h` and start defining `Token`. It begins with
    the usual header guard and the required headers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 词法分析器的实现通常称为`Lexer`。让我们创建一个名为`Lexer.h`的头文件，并开始定义`Token`。它以通常的头文件保护和所需的头文件开始：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `llvm::MemoryBuffer` class provides read-only access to a block of memory,
    filled with the content of a file. On request, a trailing zero character (`''\x00''`)
    is added to the end of the buffer. We use this feature to read through the buffer
    without checking the length of the buffer at each access. The `llvm::StringRef`
    class encapsulates a pointer to a C string and its length. Because the length
    is stored, the string doesn''t need to be terminated with a zero character (`''\x00''`)
    like normal C strings. This allows an instance of `StringRef` to point to the
    memory managed by `MemoryBuffer`. Let''s take a look at this in more detail:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm::MemoryBuffer`类提供对填充有文件内容的内存块的只读访问。在请求时，会在缓冲区的末尾添加一个尾随的零字符（`''\x00''`）。我们使用这个特性来在不检查每次访问时缓冲区的长度的情况下读取缓冲区。`llvm::StringRef`类封装了指向C字符串及其长度的指针。由于长度被存储，字符串不需要像普通的C字符串那样以零字符（`''\x00''`）结尾。这允许`StringRef`的实例指向由`MemoryBuffer`管理的内存。让我们更详细地看一下这个：'
- en: 'First, the `Token` class contains the definition of the enumeration for the
    unique token numbers mentioned previously:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Token`类包含了先前提到的唯一标记数字的枚举定义：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Besides defining a member for each token, we added two additional values: `eoi`
    and `unknown`. `eoi` stands for `unknown` is used in case of an error at the lexical
    level; for example, `#` is not a token of the language, so it would be mapped
    to `unknown`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为每个标记定义一个成员之外，我们还添加了两个额外的值：`eoi`和`unknown`。`eoi`代表结束输入，`unknown`用于在词法级别出现错误的情况下；例如，`#`不是语言的标记，因此会被映射为`unknown`。
- en: 'In addition to the enumeration, the class has a member, `Text`, which points
    to the start of the text of the token. It uses the `StringRef` class mentioned
    previously:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了枚举之外，该类还有一个成员`Text`，它指向标记文本的开头。它使用了之前提到的`StringRef`类：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is useful for semantic processing, in that it is useful to know the identifier's
    name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于语义处理很有用，因为知道标识符的名称是很有用的。
- en: 'The `is()` and `isOneOf()` methods are used to test if the token is of a certain
    kind. The `isOneOf()` method uses a variadic template, which allows a variable
    number of arguments:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`is()`和`isOneOf()`方法用于测试标记是否属于某种类型。`isOneOf()`方法使用可变模板，允许可变数量的参数：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Lexer` class itself has a similar simple interface and comes next in the
    header file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Lexer`类本身具有类似的简单接口，并在头文件中紧随其后：'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Except for the constructor, the public interface only contains the `next()`
    method, which returns the next token. The method acts like an iterator, always
    advancing to the next available token. The only members of the class are pointers
    to the beginning of the input and to the next unprocessed character. It is assumed
    that the buffer ends with a terminating `0` (like a C string).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数之外，公共接口只包含`next()`方法，它返回下一个标记。该方法的行为类似于迭代器，总是前进到下一个可用的标记。该类的唯一成员是指向输入开头和下一个未处理字符的指针。假定缓冲区以终止`0`（类似于C字符串）结束。
- en: 'Let''s implement the `Lexer` class in the `Lexer.cpp` file. It begins with
    some helper functions to help classify characters:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Lexer.cpp`文件中实现`Lexer`类。它以一些辅助函数开始，以帮助对字符进行分类：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These functions are used to make conditions more readable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数用于使条件更易读。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are not using the functions provided by the `<cctype>` standard library header
    for two reasons. First, these functions change behavior based on the locale defined
    in the environment. For example, if the locale is a German-language local, then
    German umlauts can be classified as letters. This is usually not wanted in a compiler.
    Second, since the functions have `int` as a parameter type, we must convert from
    the `char` type. The result of this conversion depends on whether `char` is treated
    as a signed or unsigned type, which causes portability problems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`<cctype>`标准库头文件提供的函数有两个原因。首先，这些函数根据环境中定义的区域设置而改变行为。例如，如果区域设置是德语区域设置，则德语变音符可以被分类为字母。这通常不是编译器所希望的。其次，由于这些函数的参数类型为`int`，我们必须从`char`类型转换。这种转换的结果取决于`char`是作为有符号类型还是无符号类型处理，这会导致可移植性问题。
- en: 'From the grammar in the previous section, we know all the tokens of the language.
    But the grammar does not define the characters that should be ignored. For example,
    a space or a new line only adds whitespace and is often ignored. The `next()`
    method begins by ignoring these characters:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一节中的语法，我们知道语言的所有标记。但是语法并没有定义应该忽略的字符。例如，空格或换行符只会添加空白并经常被忽略。`next()`方法首先忽略这些字符：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, make sure that there are still characters left to process:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，确保仍有字符需要处理：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is at least one character to process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有一个字符需要处理。
- en: 'So, we first check whether the character is lowercase or uppercase. In this
    case, the token is either an identifier or the `with` keyword, because the regular
    expression for the identifier also matches the keyword. The common solution is
    to collect the characters that are matched by the regular expression and check
    if the string happens to be the keyword:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们首先检查字符是小写还是大写。在这种情况下，标记要么是标识符，要么是`with`关键字，因为标识符的正则表达式也匹配关键字。常见的解决方案是收集正则表达式匹配的字符，并检查字符串是否恰好是关键字：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The private `formToken()` method is used to populate the token.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`formToken()`方法用于填充标记。
- en: 'Next, we check for a number. The following code is very similar to the code
    shown previously:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否为数字。以下代码与先前显示的代码非常相似：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, only the tokens defined by fixed strings are left. This is done easily
    with a `switch`. Since all these tokens have only one character, the `CASE` preprocessor
    macro is used to reduce typing:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只剩下由固定字符串定义的标记。这很容易用`switch`来实现。由于所有这些标记只有一个字符，所以使用`CASE`预处理宏来减少输入：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we need to check for unexpected characters:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要检查是否有意外的字符：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Only the private helper method, `formToken()`, is still missing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 只有私有的辅助方法`formToken()`还缺失。
- en: 'This private helper method populates the members of the `Token` instance and
    updates the pointer to the next unprocessed character:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个私有的辅助方法填充了`Token`实例的成员并更新了指向下一个未处理字符的指针：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we'll have a look at how to construct a parser for syntactical
    analysis.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下如何构建用于语法分析的解析器。
- en: Syntactical analysis
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法分析
- en: Syntactical analysis is done by the parser, which we will implement next. Its
    base is the grammar and the lexer from the previous sections. The result of the
    parsing process is a dynamic data structure called an **abstract syntax tree**
    (**AST**). The AST is a very condensed representation of the input and is well-suited
    for semantic analysis. First, we will implement the parser. After that, we will
    have a look at the AST.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 语法分析由我们将在下一步实现的解析器完成。它的基础是前几节的语法和词法分析器。解析过程的结果是一种称为**抽象语法树**（**AST**）的动态数据结构。AST是输入的非常简洁的表示形式，并且非常适合语义分析。首先，我们将实现解析器。之后，我们将看一下AST。
- en: A handwritten parser
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手写解析器
- en: 'The interface of the parser is defined in the `Parser.h` header file. It begins
    with some `include` statements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的接口在`Parser.h`头文件中定义。它以一些`include`语句开始：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `AST.h` header file declares the interface for the AST and will be shown
    later. The coding guidelines from LLVM forbid the use of the `<iostream>` library,
    so the header of the equivalent LLVM functionality must be included. It is required
    to emit an error message. Let''s take a look at this in more detail:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`AST.h`头文件声明了AST的接口，并将在稍后显示。LLVM的编码指南禁止使用`<iostream>`库，因此必须包含等效的LLVM功能的头文件。需要发出错误消息。让我们更详细地看一下这个：'
- en: 'First, the `Parser` class declares some private members:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`Parser`类声明了一些私有成员：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Lex` and `Tok` are instances of the classes from the previous section. `Tok`
    stores the next token (the look-ahead), while `Lex` is used to retrieve the next
    token from the input. The `HasError` flag indicates if an error was detected.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lex`和`Tok`是前一节中的类的实例。`Tok`存储下一个标记（向前看），而`Lex`用于从输入中检索下一个标记。`HasError`标志指示是否检测到错误。'
- en: 'A couple of methods deal with the token:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有几种方法处理标记：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`advance()` retrieves the next token from the lexer. `expect()` tests whether
    the look-ahead is of the expected kind and emits an error message if not. Finally,
    `consume()` retrieves the next token if the look-ahead is of the expected kind.
    If an error message is emitted, the `HasError` flag is set to true.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`advance()`从词法分析器中检索下一个标记。`expect()`测试向前看是否是预期的类型，如果不是则发出错误消息。最后，`consume()`如果向前看是预期的类型，则检索下一个标记。如果发出错误消息，则将`HasError`标志设置为true。'
- en: 'For each non-terminal in the grammar, a method to parse the rule is declared:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于语法中的每个非终结符，声明了一个解析规则的方法：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are no methods for `ident` and `number`. Those rules only return the token
    and are replaced by the corresponding token.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ident`和`number`没有方法。这些规则只返回标记，并由相应的标记替换。'
- en: 'The public interface follows. The constructor initializes all the members and
    retrieves the first token from the lexer:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是公共接口。构造函数初始化所有成员并从词法分析器中检索第一个标记：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A function is required to get the value of the error flag:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一个函数来获取错误标志的值：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `parse()` method is the main entry point into parsing:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`parse()`方法是解析的主要入口点：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the next section, we will learn to implement the parser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何实现解析器。
- en: Parser implementation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析器实现
- en: 'Let''s dive into the implementation of the parser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解解析器的实现：
- en: 'The implementation of the parser can be found in the `Parser.cpp` file and
    begins with the `parse()` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析器的实现可以在`Parser.cpp`文件中找到，并以`parse()`方法开始：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main point of the `parse()` method is that the whole input has been consumed.
    Do you remember that the parsing example in the first section added a special
    symbol to denote the end of the input? We'll check this here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse()`方法的主要目的是整个输入已被消耗。您还记得第一节中解析示例添加了一个特殊符号来表示输入的结束吗？我们将在这里检查这一点。'
- en: 'The `parseCalc()` method implements the corresponding rule. It''s worth having
    a closer look at this method as the other parsing methods follow the same patterns.
    Let''s recall the rule from the first section:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parseCalc()`方法实现了相应的规则。让我们回顾一下第一节的规则：'
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The method begins by declaring some local variables:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法开始声明一些局部变量：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first decision to be made is whether the optional group must be parsed
    or not. The group begins with the `with` token, so we compare the token to this
    value:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做出的决定是是否必须解析可选组。该组以`with`标记开始，因此我们将标记与此值进行比较：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we expect an identifier:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们期望一个标识符：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there is an identifier, then we save it in the `Vars` vector. Otherwise,
    it is a syntax error, which is handled separately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个标识符，那么我们将其保存在`Vars`向量中。否则，这是一个语法错误，需要单独处理。
- en: 'In the grammar now follows a repeating group, which parses more identifiers,
    it''s separated by a comma:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语法中现在跟随一个重复组，它解析更多的标识符，用逗号分隔：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At this point, this should not be surprising to you. The repetition group begins
    with the, token. The test for the token becomes the condition of the `while` loop,
    implementing zero or more repetition. The identifier inside the loop is treated
    as it was previously.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点现在对你来说应该不足为奇了。重复组以`the`标记开始。标记的测试成为`while`循环的条件，实现零次或多次重复。循环内的标识符被视为之前处理的方式。
- en: 'Finally, the optional group requires a colon at the end:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可选组需要在末尾加上冒号：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, the rule for `expr` must be parsed:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，必须解析`expr`规则：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With this call, the rule has been parsed successfully. The information that
    we''ve collected is now used to create the AST node for this rule:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个调用，规则已经成功解析。我们收集的信息现在用于创建这个规则的AST节点：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, only the error handling code is missing. Detecting a syntax error is easy
    but recovering from it is surprisingly complicated. Here, a simple approach called
    **panic mode** must be used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有错误处理代码还缺失。检测语法错误很容易，但从中恢复却令人惊讶地复杂。在这里，必须使用一种称为**恐慌模式**的简单方法。
- en: In panic mode, tokens are deleted from the token stream until one is found that
    the parser can use to continue its work. Most programming languages have symbols
    that denote an end; for example, in C++, we can use `;` (end of a statement) or
    `}` (end of a block). Such tokens are good candidates to look for.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在恐慌模式中，从标记流中删除标记，直到找到解析器可以继续工作的标记为止。大多数编程语言都有表示结束的符号；例如，在C++中，我们可以使用`;`（语句的结束）或`}`（块的结束）。这些标记是寻找的好候选者。
- en: On the other hand, the error can be that the symbol we are looking for is missing.
    In this case, a lot of tokens are probably deleted before the parser can continue.
    This is not as bad as it sounds. Today, it is more important that a compiler is
    fast. In case of an error, the developer looks at the first error message, fixes
    it, and restarts the compiler. This is quite different from using punch cards,
    where it was important to get as many error messages as possible, since the next
    run of the compiler would only be possible on the next day.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，错误可能是我们正在寻找的符号丢失了。在这种情况下，可能会在解析器继续之前删除很多标记。这并不像听起来那么糟糕。今天，编译器的速度更重要。在出现错误时，开发人员查看第一个错误消息，修复它，然后重新启动编译器。这与使用穿孔卡完全不同，那时尽可能多地获得错误消息非常重要，因为下一次运行编译器只能在第二天进行。
- en: Error handling
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Instead of using some arbitrary tokens, another set of tokens is used. For
    each non-terminal, there is a set of tokens that can follow this non-terminal
    in a rule. Let''s take a look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不是使用一些任意的标记，而是使用另一组标记。对于每个非终端，都有一组可以在规则中跟随这个非终端的标记。让我们来看一下：
- en: 'In the case of `calc`, only the end of the input follows this non-terminal.
    Its implementation is trivial:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calc`的情况下，只有输入的结尾跟随这个非终端。它的实现是微不足道的：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The other parsing methods are constructed in a similar fashion. `parseExpr()`
    is the translation of the rule for `expr`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他解析方法的构造方式类似。`parseExpr()`是对`expr`规则的翻译：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The repeated group inside the rule is translated into a `while` loop. Note how
    the use of the `isOneOf()` method simplifies the check for several tokens.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 规则内的重复组被翻译成了`while`循环。请注意`isOneOf()`方法的使用简化了对多个标记的检查。
- en: 'The coding of the `term` rule looks the same:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`term`规则的编码看起来是一样的：'
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method is strikingly similar to `parseExpr()`, and you may be tempted to
    combine them into one. In grammar, it is possible to have one rule that deals
    with multiplicative and additive operators. The advantage of using two rules instead
    of one is that the precedence of the operators fits well with the mathematical
    order of evaluation. If you combine both rules, then you need to figure out the
    evaluation order somewhere else.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与`parseExpr()`非常相似，你可能会想将它们合并成一个。在语法中，可以有一个处理乘法和加法运算符的规则。使用两个规则而不是一个的优势在于运算符的优先级与数学计算顺序很匹配。如果合并这两个规则，那么你需要在其他地方找出评估顺序。
- en: 'Finally, you need to implement the rule for `factor`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要实现`factor`规则：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Instead of using a chain of `if` and `else if` statements, a `switch` statement
    seems more suitable here, because each alternative begins with just one token.
    In general, you should think about which translation patterns you like to use.
    If you need to change the parsing methods later, then it is an advantage if not
    every method has a different way of implementing a grammar rule.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用一系列`if`和`else if`语句不同，这里似乎更适合使用`switch`语句，因为每个备选方案都以一个标记开始。一般来说，你应该考虑使用哪种翻译模式。如果以后需要更改解析方法，那么如果不是每个方法都有不同的实现语法规则的方式，那就是一个优势。
- en: 'If you use a `switch` statement, then error handling happens in the `default`
    case:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用`switch`语句，那么错误处理发生在`default`情况下：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We guard emitting the error message here because of the fall-through.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里防止发出错误消息，因为会出现错误。
- en: 'If there was a syntax error in the parenthesis expression, then an error message
    would have been emitted. The guard prevents a second error message from being
    emitted:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果括号表达式中有语法错误，那么会发出错误消息。保护措施防止发出第二个错误消息：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That was easy, wasn't it? As soon as you have memorized the used patterns, it
    is almost tedious to code the parser based on the grammar rules. This type of
    parser is called a **recursive descent parser**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易，不是吗？一旦你记住了使用的模式，根据语法规则编写解析器几乎是乏味的。这种类型的解析器称为**递归下降解析器**。
- en: A recursive descent parser can't be constructed from all grammar
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降解析器无法从所有语法构造出来
- en: 'Grammar must satisfy certain conditions to be suitable for constructing a recursive
    descent parser. This class of grammar is called LL(1). In fact, most grammar that
    you can find on the internet does not belong to this class of grammar. Most books
    about the theory of compiler construction explain the reason for this. The classic
    book on this topic is the so-called "dragon book", *Compilers: Principles, Techniques,
    and Tools* by Aho, Lam, Sethi, and Ullman.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 语法必须满足一定条件才能适合构造递归下降解析器。这类语法称为LL(1)。事实上，大多数你可以在互联网上找到的语法都不属于这类语法。大多数关于编译器构造理论的书都解释了这个原因。这个主题的经典书籍是所谓的“龙书”，即Aho、Lam、Sethi和Ullman的*编译器原理、技术和工具*。
- en: The abstract syntax tree
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象语法树
- en: The result of the parsing process is an `;`, denotes the end of a single statement.
    Of course, this information is important for the parser. As soon as we turn the
    statement into an in-memory representation, the semicolon is not important anymore
    and can be dropped.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解析过程的结果是一个`;`，表示单个语句的结束。当然，这对解析器很重要。一旦我们将语句转换为内存表示，分号就不再重要，可以被丢弃。
- en: 'If you look at the first rule of the example expression language, then it is
    clear that the `with` keyword, the comma, `,`, and the colon, `:`, are not really
    important for the meaning of a program. What is important is the list of declared
    variables that could be used in the expression. The result is that only a couple
    of classes are required to record the information: `Factor` holds a number or
    an identifier, `BinaryOp` holds the arithmetic operator and the left-hand and
    right-hand sides of an expression, and `WithDecl` stores the list of declared
    variables and the expression. `AST` and `Expr` are only used to create a common
    class hierarchy.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下例子表达式语言的第一个规则，那么很明显`with`关键字，逗号`,`和冒号`:`对程序的含义并不重要。重要的是声明的变量列表，这些变量可以在表达式中使用。结果是只需要几个类来记录信息：`Factor`保存数字或标识符，`BinaryOp`保存算术运算符和表达式的左右两侧，`WithDecl`保存声明的变量列表和表达式。`AST`和`Expr`仅用于创建一个公共类层次结构。
- en: 'In addition to the information from the parsed input, tree traversal while
    using the `AST.h` header file. Let''s take a look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从解析输入中获得的信息外，还要在使用`AST.h`头文件时进行树遍历。让我们来看一下：
- en: 'It begins with the visitor interface:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它以访问者接口开始：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The visitor pattern needs to know each class it must visit. Because each class
    also refers to the visitor, we declare all the classes at the top of the file.
    Please note that the `visit()` methods for `AST` and `Expr` have a default implementation,
    which does nothing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式需要知道它必须访问的每个类。因为每个类也引用了访问者，我们在文件顶部声明所有类。请注意，`AST`和`Expr`的`visit()`方法具有默认实现，什么也不做。
- en: 'The `AST` class is the root of the hierarchy:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AST`类是层次结构的根：'
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similarly, `Expr` is the root for the `AST` classes related to expressions:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`Expr`是与表达式相关的`AST`类的根：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Factor` class stores a number or the name of a variable:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Factor`类存储数字或变量的名称：'
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, numbers and variables are treated almost identically, so we
    decided to create only one AST node class to represent them. The `Kind` member
    tells us which of both cases the instances represent. In more complex languages,
    you usually want to have different AST classes, such as a `NumberLiteral` class
    for numbers and a `VariableAccess` class for a reference to a variable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数字和变量几乎被处理得一样，因此我们决定只创建一个AST节点类来表示它们。`Kind`成员告诉我们实例代表这两种情况中的哪一种。在更复杂的语言中，通常希望有不同的AST类，比如`NumberLiteral`类用于数字，`VariableAccess`类用于引用变量。
- en: 'The `BinaryOp` class holds the data that''s needed to evaluate an expression:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BinaryOp`类保存了评估表达式所需的数据：'
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In contrast to the parser, the `BinaryOp` class makes no distinction between
    multiplicative and additive operators. The precedence of the operators is implicitly
    available in the tree structure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与解析器相比，`BinaryOp`类在乘法和加法运算符之间没有区别。运算符的优先级隐含在树结构中。
- en: 'Finally, `WithDecl` stores the declared variables and the expression:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`WithDecl`存储了声明的变量和表达式：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The AST is constructed during parsing. The semantic analysis checks that the
    tree adheres to the meaning of the language (for example, that used variables
    are declared) and possibly augments the tree. After that, the tree is used for
    code generation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: AST在解析过程中构建。语义分析检查树是否符合语言的含义（例如，使用的变量是否已声明），并可能增强树。之后，树被用于代码生成。
- en: Semantic analysis
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义分析
- en: The semantic analyzer walks the AST and checks for various semantic rules of
    the language; for example, a variable must be declared before use or types of
    variables must be compatible in an expression. The semantic analyzer can also
    print out warnings if it finds a situation that can be improved. For the example
    expression language, the sematic analyzer must check that each used variable is
    declared, because that is what the language requires. A possible extension (which
    will not be implemented here) is to print a warning message if a declared variable
    is not used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 语义分析器遍历 AST 并检查语言的各种语义规则；例如，变量必须在使用前声明，或者表达式中的变量类型必须兼容。如果语义分析器发现可以改进的情况，还可以打印警告。对于示例表达语言，语义分析器必须检查每个使用的变量是否已声明，因为语言要求如此。可能的扩展（这里不会实现）是在未使用的情况下打印警告消息。
- en: 'The semantic analyzer is implemented in the `Sema` class, and semantic analysis
    is performed by the `semantic()` method. Here is the complete `Sema.h` header
    file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 语义分析器实现在 `Sema` 类中，语义分析由 `semantic()` 方法执行。以下是完整的 `Sema.h` 头文件：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The implementation is in the `Sema.cpp` file. The interesting part is the semantic
    analysis, which is implemented using a visitor. The basic idea is that the name
    of each declared variable is stored in a set. While the set it being created,
    we can check that each name is unique and then check that the name is in the set
    later:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实现在 `Sema.cpp` 文件中。有趣的部分是语义分析，它使用访问者来实现。基本思想是每个声明的变量名都存储在一个集合中。在创建集合时，我们可以检查每个名称是否唯一，然后稍后检查名称是否在集合中：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Like in the `Parser` class, a flag is used to indicate that an error occurred.
    The names are stored in a set called `Scope`. In a `Factor` node that holds a
    variable name, we check that the variable name is in the set:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Parser` 类一样，使用标志来指示是否发生错误。名称存储在名为 `Scope` 的集合中。在包含变量名的 `Factor` 节点中，我们检查变量名是否在集合中：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For a `BinaryOp` node, we only need to check that both sides exist and have
    been visited:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `BinaryOp` 节点，我们只需要检查两侧是否存在并已被访问：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In a `WithDecl` node, the set is populated and the walk over the expression
    is started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `WithDecl` 节点中，集合被填充，并开始对表达式的遍历：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `semantic()` method only starts the tree walk and returns an error flag:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`semantic()` 方法只是开始树遍历并返回错误标志：'
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If required, much more could be done here. It would also be possible to print
    a warning message if a declared variable is not used. We leave it to you to implement
    this. If the semantic analysis finishes without error, then we can generate the
    LLVM IR from the AST. We will do this in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，这里可以做更多的工作。还可以打印警告消息，如果声明的变量未被使用。我们留给您来实现。如果语义分析没有错误完成，那么我们可以从 AST 生成 LLVM
    IR。我们将在下一节中进行这个操作。
- en: Generating code with the LLVM backend
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLVM 后端生成代码
- en: The backend's task is to create optimized machine code from an **IR** of a module.
    The IR is the interface to the backend and can be created using a C++ interface
    or in textual form. Again, the IR is generated from the AST.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 后端的任务是从模块的 **IR** 创建优化的机器代码。IR 是后端的接口，可以使用 C++ 接口或文本形式创建。同样，IR 是从 AST 生成的。
- en: Textual representation of the LLVM IR
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM IR 的文本表示
- en: 'Before trying to generate the LLVM IR, we need to understand what we want to
    generate. For the example expression language, the high-level plan is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试生成 LLVM IR 之前，我们需要了解我们想要生成什么。对于示例表达语言，高级计划如下：
- en: Ask the user for the value of each variable.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问用户每个变量的值。
- en: Calculate the value of the expression.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算表达式的值。
- en: Print the result.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'To ask the user to provide a value for a variable and to print the result,
    two library functions, `calc_read()` and `calc_write()`, are used. For the `with
    a: 3*a` expression, the generated IR is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '要求用户为变量提供一个值并打印结果，使用了两个库函数 `calc_read()` 和 `calc_write()`。对于 `with a: 3*a`
    表达式，生成的 IR 如下：'
- en: 'The library functions must be declared, like in C. The syntax also resembles
    C. The type before the function name is the return type. The type names surrounded
    by parenthesis are the argument types. The declaration can appear anywhere in
    the file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库函数必须像 C 语言一样声明。语法也类似于 C 语言。函数名前的类型是返回类型。括号中的类型是参数类型。声明可以出现在文件的任何位置：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `calc_read()` function takes the variable name as a parameter. The following
    construct defines a constant, holding `a` and the null byte that''s used as a
    string terminator in C:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`calc_read()` 函数以变量名作为参数。以下结构定义了一个常量，保存了 `a` 和在 C 语言中用作字符串终结符的空字节：'
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It follows the `main()` function. The parameter''s names are omitted because
    they are not used. Like in C, the body of the function is enclosed in braces:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它跟在 `main()` 函数后面。参数的名称被省略，因为它们没有被使用。与 C 语言一样，函数的主体用大括号括起来：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Each basic block must have a label. Because this is the first basic block of
    the function, we name it `entry`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个基本块必须有一个标签。因为这是函数的第一个基本块，我们将其命名为 `entry`：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `calc_read()` function is called to read the value for the `a` variable.
    The nested `getelemenptr` instruction performs an index calculation to compute
    the pointer to the first element of the string constant. The function''s result
    is assigned to the unnamed `%2` variable:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `calc_read()` 函数来读取 `a` 变量的值。嵌套的 `getelemenptr` 指令执行索引计算以计算字符串常量的第一个元素的指针。函数的结果被赋值给未命名的
    `%2` 变量：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, the variable is multiplied by `3`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，变量乘以 `3`：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result is printed to the console via a call to the `calc_write()` function:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果通过调用 `calc_write()` 函数打印到控制台：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, the `main()` function returns `0` to indicate successful execution:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main()` 函数返回 `0` 表示执行成功：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Each value in LLVM IR is typed, with `i32` denoting the 32-bit bit integer type
    and `i8*` denoting a pointer to a byte. IR code is very readable (maybe except
    for the `getelementptr` operation, which will be explained in detail in [*Chapter
    5*](B15647_05_ePub_RK.xhtml#_idTextAnchor079)*, Basics of IR Generation*). Since
    it is now clear what the IR looks like, let's generate it from the AST.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM IR中的每个值都是有类型的，`i32`表示32位整数类型，`i8*`表示指向字节的指针。IR代码非常可读（也许除了`getelementptr`操作之外，在[*第5章*](B15647_05_ePub_RK.xhtml#_idTextAnchor079)*，IR生成基础*中将详细解释）。现在清楚了IR的样子，让我们从AST生成它。
- en: Generating the IR from the AST
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从AST生成IR。
- en: 'The interface, which is provided in the `CodeGen.h` header file, is very small:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CodeGen.h`头文件中提供的接口非常小：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Because the AST contains the information from semantic analysis phase, the
    basic idea is to use a visitor to walk the AST. The `CodeGen.cpp` file is implemented
    as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为AST包含了语义分析阶段的信息，基本思想是使用访问者遍历AST。`CodeGen.cpp`文件的实现如下：
- en: 'The required includes are at the top of the file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所需的包含在文件顶部：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The namespace of the LLVM libraries is used for name lookups:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM库的命名空间用于名称查找：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, some private members are declared in the visitor. Each compilation unit
    is represented in LLVM by the `Module` class and the visitor has a pointer to
    the module call, `M`. For easy IR generation, the `Builder` (of the `IRBuilder<>`
    type) is used. LLVM has a class hierarchy to represent types in IR. You can look
    up the instances for basic types such as `i32` in the LLVM context. These basic
    types are used often. To avoid repeated lookup, we cache the needed type instance,
    which can be either `VoidTy`, `Int32Ty`, `Int8PtrTy`, `Int8PtrPtrTy`, or `Int32Zero`.
    `V` is the current calculated value, which is updated through tree traversal.
    Finally, `nameMap` maps a variable name to the value that''s returned by the `calc_read()`
    function:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在访问者中声明了一些私有成员。LLVM中，每个编译单元都由`Module`类表示，访问者有一个指向模块调用`M`的指针。为了方便生成IR，使用了`Builder`（`IRBuilder<>`类型）。LLVM有一个类层次结构来表示IR中的类型。您可以在LLVM上下文中查找基本类型的实例，比如`i32`。这些基本类型经常被使用。为了避免重复查找，我们缓存所需的类型实例，可以是`VoidTy`、`Int32Ty`、`Int8PtrTy`、`Int8PtrPtrTy`或`Int32Zero`。`V`是当前计算的值，通过树遍历更新。最后，`nameMap`将变量名映射到`calc_read()`函数返回的值：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The constructor initializes all the members:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化了所有成员：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For each function, a `FunctionType` instance must be created. In C++ terminology,
    this is a function prototype. A function itself is defined with a `Function` instance.
    First, the `run()` method defines the `main()` function in LLVM IR:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个函数，必须创建一个`FunctionType`实例。在C++术语中，这是一个函数原型。函数本身是用`Function`实例定义的。首先，`run()`方法在LLVM
    IR中定义了`main()`函数：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we create the `BB` basic block with the `entry` label and attach it to
    the IR builder:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`entry`标签创建`BB`基本块，并将其附加到IR构建器：
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this preparation done, tree traversal can begin:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备工作完成后，树遍历可以开始：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After tree traversal, the computed value is printed via a call to the `calc_write()`
    function. Again, a function prototype (an instance of `FunctionType`) must be
    created. The only parameter is the current value, `V`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历后，通过调用`calc_write()`函数打印计算出的值。再次，必须创建函数原型（`FunctionType`的实例）。唯一的参数是当前值`V`：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The generation finishes by returning a `0` from the `main()` function:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成完成后，从`main()`函数返回`0`：
- en: '[PRE66]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A `WithDecl` node holds the names of the declared variables. First, we must
    create a function prototype for the `calc_read()` function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WithDecl`节点保存了声明变量的名称。首先，必须为`calc_read()`函数创建函数原型：'
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The method loops through the variable names:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法循环遍历变量名：
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For each variable, a string with a variable name is created:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个变量创建一个带有变量名的字符串：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, the IR code to call the `calc_read()` function is created. The string
    that we created in the previous step is passed as a parameter:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建调用`calc_read()`函数的IR代码。将在上一步中创建的字符串作为参数传递：
- en: '[PRE70]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The returned value is stored in the `mapNames` map for later use:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的值存储在`mapNames`映射中以供以后使用：
- en: '[PRE71]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Tree traversal continues with the expression:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树遍历继续进行，表达式如下：
- en: '[PRE72]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A `Factor` node is either a variable name or a number. For a variable name,
    the value is looked up in the `mapNames` map. For a number, the value is converted
    into an integer and turned into a constant value:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Factor`节点可以是变量名或数字。对于变量名，在`mapNames`映射中查找值。对于数字，将值转换为整数并转换为常量值：'
- en: '[PRE73]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, for a `BinaryOp` node, the right calculation operation must be used:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于`BinaryOp`节点，必须使用正确的计算操作：
- en: '[PRE74]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With this, the visitor class is complete. The `compile()` method creates the
    global context and the module, runs the tree traversal, and dumps the generated
    IR to the console:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，访问者类就完成了。`compile()`方法创建全局上下文和模块，运行树遍历，并将生成的IR转储到控制台：
- en: '[PRE75]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With that, we have implemented the frontend of the compiler, from reading the
    source to generating the IR. Of course, all these components must work together
    on user input, which is the task of the compiler driver. We also need to implement
    the functions that are required at runtime. We will cover both of these in the
    next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经实现了编译器的前端，从读取源代码到生成IR。当然，所有这些组件必须在用户输入上一起工作，这是编译器驱动程序的任务。我们还需要实现运行时所需的函数。我们将在下一节中涵盖这两个方面。
- en: The missing pieces – the driver and the runtime library
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失的部分 - 驱动程序和运行时库
- en: 'All the phases from the previous sections are glued together by the `Calc.cpp`
    driver, which we will implement here. At this point, a parameter for the input
    expression is declared, the LLVM is initialized, and all the phases from the previous
    sections are called. Let''s take a look:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节的所有阶段都由`Calc.cpp`驱动程序连接在一起，我们将在这里实现。此时，声明了输入表达式的参数，初始化了LLVM，并调用了前几节的所有阶段。让我们来看一下：
- en: 'First, we must include the required header files:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，必须包含所需的头文件：
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'LLVM comes with its own system for declaring command-line options. You only
    need to declare a static variable for each option you need. In doing so, the option
    is registered with a global command-line parser. The advantage of this approach
    is that each component can add command-line options when needed. We must declare
    an option for the input expression:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM有自己的命令行选项声明系统。您只需要为每个需要的选项声明一个静态变量。这样做，选项就会在全局命令行解析器中注册。这种方法的优势在于每个组件都可以在需要时添加命令行选项。我们必须为输入表达式声明一个选项：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Inside the `main()` function, the LLVM libraries are initialized. You need
    to call `ParseCommandLineOptions` to handle the options on the command line. This
    also handles printing help information. In the case of an error, this method exits
    the application:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数内，初始化了LLVM库。您需要调用`ParseCommandLineOptions`来处理命令行上的选项。这也处理打印帮助信息。在出现错误的情况下，此方法会退出应用程序：
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we call the lexer and the parser. After syntactical analysis, we check
    if errors occurred. If this is the case, then we exit the compiler with a return
    code, indicating a failure:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用词法分析器和语法分析器。在语法分析之后，我们检查是否发生了错误。如果是这种情况，那么我们以一个返回代码退出编译器，表示失败：
- en: '[PRE79]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And we do the same if there was a semantic error:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有语义错误，我们也会这样做。
- en: '[PRE80]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, in the driver, the code generator is called:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在驱动程序中，调用了代码生成器：
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: With that, we have successfully created IR code for the user input. We delegated
    the object code generation to the LLVM static compiler, `llc`, so this finishes
    the implementation of our compiler. We must link all the components together to
    create the `calc` application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经成功地为用户输入创建了IR代码。我们将对象代码生成委托给LLVM静态编译器`llc`，因此这完成了我们的编译器的实现。我们必须将所有组件链接在一起，以创建`calc`应用程序。
- en: 'The runtime library consists of a single file called `rtcalc.c`. It contains
    the implementation of the `calc_read()` and `calc_write()` functions, written
    in C:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时库由一个名为`rtcalc.c`的单个文件组成。它包含了用C编写的`calc_read()`和`calc_write()`函数的实现：
- en: '[PRE82]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`calc_write()` only writes the resulting value to the terminal:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_write()`只是将结果值写入终端：'
- en: '[PRE83]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`calc_read()` reads an integer number from the terminal. Nothing prevents the
    user from entering letters or other characters, so we must carefully check the
    input. If the input is not a number, we exit the application. A more complex approach
    would be to make the user aware of the problem and ask for a number again.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc_read()`从终端读取一个整数。没有任何限制阻止用户输入字母或其他字符，因此我们必须仔细检查输入。如果输入不是数字，我们就退出应用程序。一个更复杂的方法是让用户意识到问题，并再次要求输入一个数字。'
- en: 'Now, we can try out our compiler. The `calc` application creates IR from an
    expression. The LLVM static compiler, `llc`, compiles the IR as an object file.
    Then, you can use your favorite C compiler to link against the small runtime library.
    On Unix, you can type the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试我们的编译器。`calc`应用程序从表达式创建IR。LLVM静态编译器`llc`将IR编译为一个目标文件。然后，您可以使用您喜欢的C编译器链接到小型运行时库。在Unix上，您可以输入以下内容：
- en: '[PRE84]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'On Windows, you will most likely use the `cl` compiler:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您很可能会使用`cl`编译器：
- en: '[PRE85]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With that, you have created your first LLVM-based compiler! Please take some
    time to play around with the various expressions. Also check that multiplicative
    operators are evaluated before additive operators and that using parentheses changes
    the evaluation order, as we expect from a basic calculator.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您已经创建了您的第一个基于LLVM的编译器！请花一些时间玩弄各种表达式。还要检查乘法运算符在加法运算符之前进行评估，并且使用括号会改变评估顺序，这是我们从基本计算器中期望的。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about the typical components of a compiler. An
    arithmetic expression language was used to introduce you to grammar for programming
    languages. You then learned how to develop the typical components of a frontend
    for this language: a lexer, a parser, a semantic analyzer, and a code generator.
    The code generator only produced LLVM IR, and the LLVM static compiler, `llc`,
    was used to create object files from it. Finally, you developed your first LLVM-based
    compiler!'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了编译器的典型组件。一个算术表达式语言被用来向您介绍编程语言的语法。然后，您学会了如何为这种语言开发典型的前端组件：词法分析器、语法分析器、语义分析器和代码生成器。代码生成器只产生了LLVM
    IR，LLVM静态编译器`llc`用它来创建目标文件。最后，您开发了您的第一个基于LLVM的编译器！
- en: In the next chapter, you will deepen this knowledge to construct the frontend
    for a programming language.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将加深这些知识，以构建一个编程语言的前端。
