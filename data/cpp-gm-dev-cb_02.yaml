- en: Chapter 2. Object-Oriented Approach and Design in Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。游戏中的面向对象方法和设计
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下教程：
- en: Using classes for data encapsulation and abstraction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类进行数据封装和抽象
- en: Using polymorphism to reuse code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多态性来重用代码
- en: Using copy constructors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复制构造函数
- en: Using operator overloading to reuse operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符重载来重用运算符
- en: Using function overloading to reuse functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数重载来重用函数
- en: Using files for input and output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件进行输入和输出
- en: Creating your first simple text-based game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个简单的基于文本的游戏
- en: Templates – when to use them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板 - 何时使用它们
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The following diagram shows the main concepts of **OOP** (**Object-oriented
    programming**). Let us consider that we need to make a car racing game. So, a
    car is made up of an engine, wheels, chassis, and so on. All these parts can be
    considered as individual components, which can be used for other cars as well.
    Similarly, every car's engine can be different and so we can add different functionalities,
    states, and properties to each individual component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了**OOP**（**面向对象编程**）的主要概念。让我们假设我们需要制作一款赛车游戏。因此，汽车由发动机、车轮、底盘等组成。所有这些部分都可以被视为单独的组件，也可以用于其他汽车。同样，每辆汽车的发动机都可以是不同的，因此我们可以为每个单独的组件添加不同的功能、状态和属性。
- en: 'All this can be achieved through object-oriented programming:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过面向对象编程实现：
- en: '![Introduction](img/B04929_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/B04929_02_01.jpg)'
- en: We need to use an object-oriented system in any design that consists of states
    and behaviors. Let us consider a game like *Space Invaders*. The game consists
    of two main characters, the player ship and the enemy. There is also a boss, but
    that is just an advanced version of the enemy. The player ship can have different
    states such as alive, idle, moving, attack, and dead. It also has a few behaviors,
    such as left/right movement, single shoot/burst shoot/missile. Similarly, the
    enemy has states and behaviors. This is an ideal condition to use an object-oriented
    design. The boss is just an advanced form of the enemy, so we can use the concepts
    of polymorphism and inheritance to achieve the result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在任何包含状态和行为的设计中使用面向对象的系统。让我们考虑一个像*Space Invaders*的游戏。游戏由两个主要角色组成，玩家飞船和敌人。还有一个boss，但那只是敌人的高级版本。玩家飞船可以有不同的状态，如存活、空闲、移动、攻击和死亡。它还有一些行为，比如左/右移动，单发/连发/导弹。同样，敌人也有状态和行为。这是使用面向对象设计的理想条件。boss只是敌人的高级形式，因此我们可以使用多态性和继承的概念来实现结果。
- en: Using classes for data encapsulation and abstraction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类进行数据封装和抽象
- en: A class is used to organize information into meaningful states and behaviors.
    In games, we deal with so many different types of weapon, player, enemy, and terrain,
    each with its own type of state and behavior, so an object-oriented design with
    classes is a must.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类用于将信息组织成有意义的状态和行为。在游戏中，我们处理许多不同类型的武器、玩家、敌人和地形，每种都有自己的状态和行为类型，因此必须使用具有类的面向对象设计。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need a machine running Windows. You need
    to have a working copy of Visual Studio installed on your Windows machine. No
    other prerequisites are required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，您需要一台运行Windows的计算机。您需要在Windows计算机上安装Visual Studio的工作副本。不需要其他先决条件。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to create a game framework using
    object-oriented programming in C++:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到使用C++中的面向对象编程轻松创建游戏框架有多容易：
- en: Open Visual Studio.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add source files called `Source.cpp`, `CEnemy.h`, and `CEnemy.cpp`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`、`CEnemy.h`和`CEnemy.cpp`的源文件。
- en: 'Add the following lines of code to `Souce.cpp`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Souce.cpp`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following lines of code to `CEnemy.h`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CEnemy.h`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following lines of code to `CEnemy.cpp`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CEnemy.cpp`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To create an object-oriented program, we need to create classes and objects.
    Although we can write the definition and declaration of a class in the same file,
    it is advisable to have two separate files for definition and declaration. A declaration
    class file is called a header file, whereas a definition class file is called
    a source file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个面向对象的程序，我们需要创建类和对象。虽然我们可以在同一个文件中编写类的定义和声明，但建议将定义和声明分开为两个单独的文件。声明类文件称为头文件，而定义类文件称为源文件。
- en: In the `CEnemy` header file, we define the member variables and the functions
    that we need. In a class, we have the option to separate out the variables as
    public, protected, or private. A public state indicates that they are accessible
    from outside the class, a protected state indicates that only the child class
    that inherits from the current base class has access to it, whereas a private
    state indicates that they are accessible by any instance of the class. By default,
    everything in a C++ class is private. Hence, we have created all the member functions
    as public so that we can access them from the driver program, which in this example
    is `Source.cpp`. The member variables in the header file are all private, as they
    should not be directly accessible from outside the class. This is what we call
    abstraction. We define a string type variable for name and armor, and an integer
    type for health and age. It is also advisable to create a constructor and destructor,
    even if we do not have any functionality for them at present. It is also good
    to use a copy constructor. The reason for this is explained later on in the chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CEnemy`头文件中，我们定义了我们需要的成员变量和函数。在一个类中，我们可以选择将变量分为公共、受保护或私有。公共状态表示它们可以从类外部访问，受保护状态表示只有从当前基类继承的子类可以访问它，而私有状态表示它们可以被类的任何实例访问。在C++类中，默认情况下，一切都是私有的。因此，我们将所有成员函数都创建为公共的，以便我们可以从驱动程序中访问它们，例如本例中的`Source.cpp`。头文件中的成员变量都是私有的，因为它们不应该直接从类外部访问。这就是我们所说的抽象。我们为名称和护甲定义了一个字符串类型的变量，为健康和年龄定义了一个整数类型的变量。即使我们目前没有为它们创建任何功能，也建议创建构造函数和析构函数。最好还使用一个复制构造函数。稍后在本章中会解释这个原因。
- en: In the `CEnemy` source file, we have the initialization of the member variables
    and also the declarations of the functions. We have used the `const` keyword at
    the end of each function because we do not want the function to change the contents
    of the member variables. We just want them to return the values that are already
    assigned. As a rule of thumb, we should always use it unless it's necessary not
    to use it. It makes the code more secure, organized, and readable. We have initialized
    the variables in the constructor; we could have also created parameterized constructors
    and assigned values to them from the driver program. Alternatively, we can also
    have set functions to assign values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CEnemy`源文件中，我们对成员变量进行了初始化，并声明了函数。我们在每个函数的末尾使用了`const`关键字，因为我们不希望函数改变成员变量的内容。我们只希望它们返回已经分配的值。作为一个经验法则，除非有必要不使用它，我们应该总是使用它。这使得代码更安全、有组织和可读。我们在构造函数中初始化了变量；我们也可以创建参数化构造函数，并从驱动程序中分配值给它们。或者，我们也可以创建设置函数来分配值。
- en: From the driver program, we create a pointer object of the type `CEnemy`. When
    the object is initialized, it calls its appropriate constructors and the values
    are assigned to them. Then we call the functions by dereferencing the pointer
    using the `->` operator. So when we call the `p->` function, it is the same as
    (`*p`).function. As we are dynamically allocating memory, we should also delete
    the object or else we will get a memory leak. We have used `vld` to check for
    memory leaks. This program does not have any, as we have used the `delete` keyword.
    Just comment out the line `delete pEnemy;` and you will notice that the program
    has few memory leaks on exiting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从驱动程序中，我们创建一个`CEnemy`类型的指针对象。当对象被初始化时，它调用适当的构造函数并将值分配给它们。然后我们通过使用`->`运算符对指针进行解引用来调用函数。因此，当我们调用`p->`函数时，它与(`*p`).function相同。由于我们是动态分配内存，我们还应该删除对象，否则会出现内存泄漏。我们已经使用`vld`来检查内存泄漏。这个程序没有任何内存泄漏，因为我们使用了`delete`关键字。只需注释掉`delete
    pEnemy;`这一行，你会注意到程序在退出时有一些内存泄漏。
- en: Using polymorphism to reuse code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多态来重用代码
- en: Polymorphism means having several forms. Typically, we use polymorphism when
    there is a hierarchy of classes and they are related in some way. We generally
    achieve this level of relation by using inheritance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多态意味着具有多种形式。通常，当类的层次结构存在某种关联时，我们使用多态。我们通常通过使用继承来实现这种关联。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在Windows机器上安装Visual Studio的工作副本。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how we can use the same function and override it
    with different functionalities based on our needs. Also, we will see how we can
    share values across base and derived classes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用相同的函数并根据需要覆盖它们的不同功能。此外，我们还将看到如何在基类和派生类之间共享值：
- en: Open Visual Studio.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called Source.cpp and three header files called `Enemy.h`,
    `Dragon.h`, and `Soldier.h`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为Source.cpp的源文件和三个名为`Enemy.h`、`Dragon.h`和`Soldier.h`的头文件。
- en: 'Add the following lines of code to `Enemy.h`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`Enemy.h`中：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following lines of code to `Dragon.h`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`Dragon.h`中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following lines of code to `Soldier.h`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`Soldier.h`中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到`Source.cpp`中：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Polymorphism is the ability to have different forms. So in this example, we
    have an `Enemy` interface that does not have any functionality for calculating
    total health. However, we know that all types of enemy should have a function
    to calculate total health. So we have made the function in the base class as a
    pure virtual function by assigning it to `0`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是具有不同形式的能力。因此，在这个例子中，我们有一个`Enemy`接口，它没有任何用于计算总体健康的功能。然而，我们知道所有类型的敌人都应该有一个计算总体健康的功能。因此，我们通过将基类中的函数设置为纯虚函数（通过将其分配为`0`）来实现这个功能。
- en: This enables, or rather forces, all the child classes to have their own implementation
    for calculating total health. So the `CSoldier` class and `CDragon` class have
    their own implementation of `TotalHP`. The advantage of such a structure is that
    we can create a pointer object of the child from the base and when it resolves,
    it calls the correct function of the child class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得所有子类都必须有自己的实现来计算总健康值。因此，`CSoldier`类和`CDragon`类都有自己的`TotalHP`实现。这种结构的优势在于，我们可以从基类创建子类的指针对象，并且在解析时，它调用子类的正确函数。
- en: If we do not create a virtual function, then the functions in the child classes
    would have hidden the function of the base class. With a pure virtual function,
    however, this is not true as this would create a compiler error. The way the compiler
    resolves the functions at run time is by a technique called dynamic dispatch.
    Most languages use dynamic dispatch. C++ uses single-cast dynamic dispatch. It
    does so with the help of virtual tables. When the `CEnemy` class defines the virtual
    function `TotalHP`, the compiler adds a hidden member variable to the class which
    points an array of pointers to functions called the **virtual** **method table**
    (**VMT** or **Vtable**). At runtime, these pointers will be set to point to the
    right function, because at compile time, it is not yet known if the base function
    is to be called or a derived one implemented by `CDragon` and `CSoldier`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不创建虚函数，那么子类中的函数将隐藏基类的函数。然而，使用纯虚函数，这是不正确的，因为这将创建一个编译器错误。编译器在运行时解析函数的方式是通过一种称为动态分派的技术。大多数语言使用动态分派。C++使用单一转发动态分派。它借助虚拟表来实现。当`CEnemy`类定义虚函数`TotalHP`时，编译器向类添加一个隐藏的成员变量，该成员变量指向一个名为虚方法表（VMT）或Vtable的函数指针数组。在运行时，这些指针将被设置为指向正确的函数，因为在编译时还不知道是调用基函数还是由`CDragon`和`CSoldier`实现的派生函数。
- en: The member variables in the base class are protected. This means that the derived
    class also has access to the member variables. From the driver program, because
    we have allocated memory dynamically, we should also delete, or else we will have
    memory leaks. When the destructor is marked as virtual, we ensure that the right
    destructor is called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基类中的成员变量是受保护的。这意味着派生类也可以访问成员变量。从驱动程序中，因为我们动态分配了内存，我们也应该删除，否则我们将会有内存泄漏。当析构函数标记为虚函数时，我们确保调用正确的析构函数。
- en: Using copy constructors
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用复制构造函数
- en: Copy constructors are used to copy one object to another. C++ provides us with
    a default copy constructor, but it is not recommended. We should write our own
    copy constructor for better coding and organizing practices. It also minimizes
    crashes and bugs that may arise if we use the default copy constructor provided
    by C++.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数用于将一个对象复制到另一个对象。C++为我们提供了一个默认的复制构造函数，但不建议使用。我们应该为更好的编码和组织实践编写自己的复制构造函数。它还可以最小化使用C++提供的默认复制构造函数可能引起的崩溃和错误。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows机器上安装Visual Studio的工作副本。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will see how easy it is to write a copy constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到编写复制构造函数有多么容易：
- en: Open Visual Studio.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add source files called `Source.cpp` and `Terrain.h`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`和`Terrain.h`的源文件。
- en: 'Add the following lines of code to `Terrain.h`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Terrain.h`中添加以下代码行：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Source.cpp`中添加以下代码行：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we have created our own copy constructor and an assignment
    operator. When we assign two objects that are already initialized, then the assignment
    operator is called. When we initialize an object and set it to the other object,
    a copy constructor is called. If we do not create our own copy constructor, the
    newly created object just holds a shallow reference of the object it is being
    assigned to. If the object gets destroyed, then the shallow object becomes lost
    as the memory is also lost. If we create our own copy constructor, a deep copy
    is created and even if the first object is deleted, the second object stills holds
    the information in a different memory location.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了自己的复制构造函数和赋值运算符。当我们给已经初始化的两个对象赋值时，赋值运算符被调用。当我们初始化一个对象并将其设置为另一个对象时，复制构造函数被调用。如果我们不创建自己的复制构造函数，新创建的对象只是持有被赋值对象的浅层引用。如果对象被销毁，那么浅层对象也会丢失，因为内存也会丢失。如果我们创建自己的复制构造函数，就会创建一个深层复制，即使第一个对象被删除，第二个对象仍然在不同的内存位置中保存信息。
- en: '![How it works…](img/4929_02_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_02_02.jpg)'
- en: 'So in effect, a shallow copy (or member-wise copy) copies the exact values
    of one object''s member variables into another object. Pointers in both objects
    end up pointing to the same memory. A deep copy copies the values allocated on
    the free store to newly allocated memory. So in shallow deleting, the object in
    the shallow copy is disastrous:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，浅层复制（或成员逐一复制）将一个对象的成员变量的确切值复制到另一个对象中。两个对象中的指针最终指向相同的内存。深层复制将在自由存储器上分配的值复制到新分配的内存中。因此，在浅层删除中，浅层复制中的对象是灾难性的：
- en: '![How it works…](img/4929_02_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_02_03.jpg)'
- en: 'However, a deep copy solves this problem for us:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，深层复制为我们解决了这个问题：
- en: '![How it works…](img/4929_02_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_02_04.jpg)'
- en: Use operator overloading to reuse operators
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运算符重载来重用运算符
- en: There are lots of operators that are provided for us by C++. However, sometimes
    we need to overload these operators so that we can use them on data structures
    that we create ourselves. Of course, we can overload the operators to change the
    meaning as well. For example, we can change + (plus) to behave like - (minus),
    but this is not recommended as this usually does not serve any purpose or help
    us in any way. Also, it may confuse other programmers who are using the same code
    base.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C++为我们提供了许多运算符。但是，有时我们需要重载这些运算符，以便我们可以在自己创建的数据结构上使用它们。当然，我们也可以重载运算符以改变其含义。例如，我们可以将+（加号）改为行为像-（减号），但这并不推荐，因为这通常没有任何意义或帮助我们。此外，这可能会让使用相同代码库的其他程序员感到困惑。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows机器上安装Visual Studio的工作副本。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we will see how we can overload an operator and which operators
    are allowed to be overloaded in C++.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何重载运算符以及在C++中允许重载哪些运算符。
- en: Open Visual Studio.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `Source.cpp`, `vector3.h`, and `vector3.cpp`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`、`vector3.h`和`vector3.cpp`的源文件。
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Source.cpp`：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following lines of code to `vector3.h`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`vector3.h`：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following lines of code to `vector3.cpp`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`vector3.cpp`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'C++ has built-in types: int, char, and float. Each of these types has a number
    of built-in operators, such as addition (+) and multiplication (*). C++ allows
    you to add these operators to your own classes as well. Operators on built-in
    types (int, float) cannot be overloaded. The precedence order cannot be changed.
    There are many reasons for proceeding with caution when overloading an operator.
    The goal is to increase usability and understanding. In our example, we have overloaded
    the basic multiplication operators so that we can add, subtract, and so on our
    `vector3` objects that we create. This is extremely handy, as we can find the
    distance of an object in our game if we know the position vectors of the two objects.
    We have used const functions as much as possible. The compiler will enforce the
    promise to not modify the object. This can be a great way to make sure that your
    code has no unanticipated side effects.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++具有内置类型：int、char和float。每种类型都有许多内置运算符，如加法（+）和乘法（*）。C++还允许您将这些运算符添加到自己的类中。内置类型（int、float）上的运算符不能被重载。优先级顺序不能被改变。在重载运算符时要谨慎的原因有很多。目标是增加可用性和理解。在我们的示例中，我们已经重载了基本的乘法运算符，以便我们可以对我们创建的`vector3`对象进行加法、减法等操作。这非常方便，因为如果我们知道两个对象的位置向量，我们就可以在游戏中找到对象的距离。我们尽可能使用const函数。编译器将强制执行不修改对象的承诺。这可以是确保您的代码没有意外副作用的好方法。
- en: All functions that accept vectors accept a constant reference to a vector. We
    have to remember that passing an argument by value to a function invokes a constructor.
    Inheritance will not be very useful to the vector class, as we know `CVector3`
    is speed critical. The V-table adds 25% to the class size, so it is not advisable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受向量的函数都接受向量的常量引用。我们必须记住，将参数按值传递给函数会调用构造函数。继承对于向量类并不是非常有用，因为我们知道`CVector3`是速度关键的。虚函数表会使类大小增加25%，因此不建议使用。
- en: 'Also, data hiding does not make too much sense, as we need the values of the
    vector class. Some operators can be overloaded in C++. The operators that C++
    does not allow us to overload are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据隐藏并没有太多意义，因为我们需要向量类的值。在C++中可以重载一些运算符。C++不允许我们重载的运算符是：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use function overloading to reuse functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数重载来重用函数
- en: Function overloading is an important concept in C++. Sometimes, we want to use
    the same function name but have different functions to work on different data
    types or a different number of types. This is useful as the client can choose
    the correct function based on its needs. C++ allows us to do this by using function
    overloading.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是C++中的一个重要概念。有时，我们希望使用相同的函数名称，但有不同的函数来处理不同的数据类型或不同数量的类型。这是有用的，因为客户端可以根据自己的需求选择正确的函数。C++允许我们通过函数重载来实现这一点。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要一台安装有Visual Studio工作副本的Windows机器。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will learn how to overload a function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何重载函数：
- en: Open Visual Studio.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select a **Win32 Console Application**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add source files called `main.cpp`, `Cspeed.h`, and `Cspeed.cpp`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`main.cpp`、`Cspeed.h`和`Cspeed.cpp`的源文件。
- en: 'Add the following lines of code to `main.cpp`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.cpp`：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following lines of code to `CSpeed.cpp`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CSpeed.cpp`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following lines of code to `CSpeed.h`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CSpeed.h`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Overloading a function is a type of functional polymorphism. A function can
    be overloaded only by the number of parameters in the argument list and the type
    of parameter. A function cannot be overloaded only by the return type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是一种函数多态的类型。函数只能通过参数列表中的参数数量和参数类型进行重载。函数不能仅通过返回类型进行重载。
- en: We have created a class to calculate the sum of speeds. We can use the function
    to add two speeds, three speeds, or speeds of different data types. The compiler
    will resolve which function to call based on the signature. One might argue that
    we could create different objects with different speeds and then add them using
    operator overloading, or use templates and write one template function. However,
    we have to remember that in simple templates the implementation will remain the
    same, but in function overloading we can change the implementation of each function
    as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个类来计算速度的总和。我们可以使用该函数来添加两个速度、三个速度或不同数据类型的速度。编译器将根据签名解析要调用的函数。有人可能会认为我们可以创建不同速度的不同对象，然后使用运算符重载来添加它们，或者使用模板编写一个模板函数。然而，我们必须记住，在简单的模板中，实现将保持不变，但在函数重载中，我们也可以更改每个函数的实现。
- en: Using files for input and output
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件进行输入和输出
- en: Files are really useful for saving data locally, so we can retrieve it the next
    time the program is run or analyze the data after the program exits. For all data
    structures that we create in code and populate with values, the values will get
    lost after the application quits unless we save them locally or to the server/cloud.
    Files serve the purpose of containing the saved data. We can create text files,
    binary files, or even a file with our own encryption. Files are very handy when
    we want to log errors or generate a crash report.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对于保存本地数据非常有用，这样我们可以在程序下次运行时检索数据，或者在程序退出后分析数据。对于我们在代码中创建并填充值的所有数据结构，除非我们将它们保存在本地或服务器/云端，否则这些值在应用程序退出后将丢失。文件用于包含保存的数据。我们可以创建文本文件、二进制文件，甚至具有我们自己加密的文件。当我们想要记录错误或生成崩溃报告时，文件非常方便。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will find out how to use file handling operations in C++
    to write or read from a text file. We can even use C++ operations to create binary
    files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将了解如何在C++中使用文件处理操作来读取或写入文本文件。我们甚至可以使用C++操作来创建二进制文件。
- en: Open Visual Studio.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add source files called `Source.cpp`, `File.h`, and `File.cpp`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`、`File.h`和`File.cpp`的源文件。
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Source.cpp`中：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following lines of code to `File.cpp`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`File.cpp`中：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following lines of code to `File.h`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`File.h`中：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We use file handling for a variety of reasons. Some of the most important reasons
    are to log data while the game is running, to load data from a text file to be
    used in the game, or to encrypt the save data or load data of a game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件处理有各种原因。其中一些最重要的原因是在游戏运行时记录数据、从文本文件中加载数据以在游戏中使用，或者加密保存数据或加载游戏数据。
- en: We have created a class called `CFile`. This class helps us to write data to
    a new file, to append to a file, and to read from a file. We use the `fstream`
    header file to load all the file handling operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`CFile`的类。这个类帮助我们向新文件写入数据，向文件追加数据，并从文件中读取数据。我们使用`fstream`头文件来加载所有文件处理操作。
- en: Everything in a file is written and read in terms of streams. While doing C++
    programming, we must write information to a file from our program using the stream
    insertion operator (`<<`), just as we use that operator to output information
    to the screen. The only difference is that you use an `ofstream` or `fstream`
    object, instead of the `cout` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的所有内容都是以流的形式写入和读取的。在进行C++编程时，我们必须使用流插入运算符(`<<`)从程序中向文件写入信息，就像我们使用该运算符向屏幕输出信息一样。唯一的区别是，您使用`ofstream`或`fstream`对象，而不是`cout`对象。
- en: We have created a constructor to contain initial data if a file is created without
    any data in it. If we just create or write to a file, each time a new file will
    be created with the new data. This is sometimes useful if we just want to write
    the most recently updated or latest data. However, if we want to add data to an
    existing file, we can use the `append` function. The append function starts writing
    to an existing file from the last file-position pointer position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个构造函数，用于在没有任何数据的情况下创建文件时包含初始数据。如果我们只是创建或写入文件，每次都会创建一个新文件，并带有新数据。如果我们只想写入最近更新或最新的数据，这有时是有用的。但是，如果我们想向现有文件添加数据，我们可以使用`append`函数。追加函数从最后的文件位置指针位置开始向现有文件写入。
- en: The read function starts reading data from the file until it reaches the last
    line of written data. We can display the result to the screen or, if needed, we
    could then write the contents to another file. We also must remember to close
    the file after each operation, or it might lead to ambiguity in the code. We can
    also use the `seekp` and `seekg` functions to reposition the file-position pointer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 读取函数开始从文件中读取数据，直到达到最后一行写入的数据。我们可以将结果显示到屏幕上，或者如果需要，然后将内容写入另一个文件。我们还必须记住在每次操作后关闭文件，否则可能会导致代码的歧义。我们还可以使用`seekp`和`seekg`函数来重新定位文件位置指针。
- en: Creating your first simple game
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个简单游戏
- en: Creating a simple text-based game is really easy. All we need to do is to create
    some rules and logic and we will have ourselves a game. Of course, as the game
    gets more complex we need to add more functions. When the game reaches a point
    where there are multiple behaviors and states of objects and enemies, we should
    use classes and inheritance to achieve the desired result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的基于文本的游戏非常容易。我们所需要做的就是创建一些规则和逻辑，我们就会有一个游戏。当然，随着游戏变得更加复杂，我们需要添加更多的函数。当游戏达到一个点，其中有多个对象和敌人的行为和状态时，我们应该使用类和继承来实现所需的结果。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要一台运行Windows的机器。您还需要在Windows机器上安装一个可用的Visual Studio副本。不需要其他先决条件。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will learn how to create a simple luck-based lottery game:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个简单的基于运气的抽奖游戏：
- en: Open Visual Studio.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a `Source.cpp` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Source.cpp`文件。
- en: 'Add the following lines of code to it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到其中：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The game works by creating a random number from 1 to 100 and asks the user to
    guess that number. Hints are provided as to whether the number guessed is higher
    or lower than the actual number. The user is given just 20 tries to guess the
    number. We first need a pseudo seeder, based on which we are going to generate
    a random number. The pseudo seeder in this case is `srand`. We have chosen TIME
    as a value to generate our random range.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的工作原理是创建一个从1到100的随机数，并要求用户猜测该数字。会提供提示，告诉用户猜测的数字是高于还是低于实际数字。用户只有20次机会来猜测数字。我们首先需要一个伪随机数生成器，基于它我们将生成一个随机数。在这种情况下，伪随机数生成器是`srand`。我们选择了时间作为生成随机范围的值。
- en: We need to execute the program in an infinite loop so that the program breaks
    only when all tries are used up or when the user correctly guesses the number.
    We can set a variable for tries and increment for every guess a user takes. The
    random number is generated by the rand function. We use `rand%100+1` so that the
    random number is in the range 1 to 100\. We ask the user to input the guessed
    number and then we check whether that number is less than, greater than, or equal
    to the randomly generated number. We then display the correct message. If the
    user has guessed correctly, or all tries have been used, the program should break
    out of the main loop. At this point, we ask the user whether they want to play
    the game again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在一个无限循环中执行程序，这样程序只有在所有尝试用完或用户正确猜出数字时才会中断。我们可以为尝试设置一个变量，并为用户每次猜测增加一个。随机数由rand函数生成。我们使用`rand%100+1`，这样随机数就在1到100的范围内。我们要求用户输入猜测的数字，然后我们检查该数字是小于、大于还是等于随机生成的数字。然后显示正确的消息。如果用户猜对了，或者所有尝试都已经用完，程序应该跳出主循环。在这一点上，我们询问用户是否想再玩一次游戏。
- en: Then, depending on the answer, we go back into the main loop and start the process
    of selecting a random number.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据答案，我们重新进入主循环，并开始选择一个随机数的过程。
- en: Templates – when to use them
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板-何时使用它们
- en: Templates are a C++ programming way to lay the foundations for writing a generic
    program. Using templates, we can write code in such a way that it is independent
    of any particular data type. We can use function templates or class templates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++编程的一种方式，为编写泛型程序奠定基础。使用模板，我们可以以独立于任何特定数据类型的方式编写代码。我们可以使用函数模板或类模板。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要一台安装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we will find out the importance of templates, how to use them,
    and the advantages that using them provides us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将了解模板的重要性，如何使用它们以及使用它们提供给我们的优势。
- en: Open Visual Studio.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Add source files called `Source.cpp` and `Stack.h`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`和`Stack.h`的源文件。
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Source.cpp`中：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following lines of code to `Stack.h`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Stack.h`中：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Templates are the foundation of generic programming in C++. If the implementation
    of a function or a class is the same but we need them to operate on different
    data types, it is advisable to use templates instead of writing a new class or
    function. One can argue that we can overload a function to achieve the same thing,
    but keep in mind that while overloading a function, we can change the implementation
    based on the data type and we are still writing a new function. With templates,
    the implementation has to be the same for all data types. This is the advantage
    of templates: writing one function is enough. With advanced templates and C++11
    features, we can even change the implementation, but we will reserve that discussion
    for later.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++中泛型编程的基础。如果函数或类的实现相同，但我们需要它们操作不同的数据类型，建议使用模板而不是编写新的类或函数。有人可能会说我们可以重载一个函数来实现相同的功能，但请记住，当重载一个函数时，我们可以根据数据类型改变实现，而且我们仍然在编写一个新的函数。使用模板，实现必须对所有数据类型都相同。这就是模板的优势：编写一个函数就足够了。使用高级模板和C++11特性，我们甚至可以改变实现，但我们将把这个讨论留到以后。
- en: We have used function templates and class templates in this example. The function
    template is defined in `Source.cpp` itself. On top of the `print` function, we
    have added the line template `<class T>`. The `keyword` class could be replaced
    by `typename` as well. The reason for two keywords is a historic one and we do
    not need to discuss it here. The remaining part of the function definition is
    normal, except instead of using a particular data type, we have used `T`. So when
    we call the function from main, `T` gets replaced with the correct data type.
    In this way, by just using one function, we can print all data types. We can even
    create our own data type and pass it to the function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了函数模板和类模板。函数模板是在`Source.cpp`中定义的。在`print`函数的顶部，我们添加了模板`<class T>`。`关键字`类也可以被`typename`替换。两个关键字的原因是历史性的，我们不需要在这里讨论。函数定义的其余部分是正常的，只是我们使用了`T`代替了特定的数据类型。所以当我们从主函数调用函数时，`T`会被正确的数据类型替换。通过这种方式，只需使用一个函数，我们就可以打印所有数据类型。我们甚至可以创建自己的数据类型并将其传递给函数。
- en: '`Stack.h` is an example of a class template, as the data type that the class
    uses is a generic one. We have selected a stack as it is a very popular data structure
    in games programming. It''s a **LIFO** (**Last In First Out**) structure, so we
    can display the latest content from the stack as per our requirements. The push
    function pushes an element onto the stack, whereas a pop removes an element from
    the stack. The top function displays the top-most element of the stack and the
    empty function empties the stack. By using this generic stack class, we can store
    and display the data type of our choice.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack.h` 是一个类模板的示例，因为类使用的数据类型是通用的。我们选择了堆栈，因为它是游戏编程中非常流行的数据结构。它是一个**LIFO**（**后进先出**）结构，因此我们可以根据我们的需求显示堆栈中的最新内容。push函数将一个元素推入堆栈，而pop函数将一个元素从堆栈中移除。top函数显示堆栈中的顶部元素，empty函数清空堆栈。通过使用这个通用的堆栈类，我们可以存储和显示我们选择的数据类型。'
- en: One thing to be kept in mind while using templates is that the compiler must
    know at compile time the correct implementation of the template, so generally
    template definition and declaration are both done in the header file. However,
    if you want to separate out the two, you can do so with two popular methods. One
    method is to have another header file and list the implementation at the end of
    it. The other implementation is to create an `.ipp` or `.tpp` file extension and
    have the implementation in those files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板时需要记住的一件事是，编译器必须在编译时知道模板的正确实现，因此通常模板的定义和声明都在头文件中完成。然而，如果你想将两者分开，可以使用两种流行的方法。一种方法是使用另一个头文件，并在其末尾列出实现。另一种方法是创建一个`.ipp`或`.tpp`文件扩展名，并在这些文件中进行实现。
