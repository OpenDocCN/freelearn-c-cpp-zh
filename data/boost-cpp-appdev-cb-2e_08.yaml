- en: Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using type vector of types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型向量
- en: Manipulating vector of types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作类型向量
- en: Getting a function's result type at compile time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时获取函数的结果类型
- en: Making a higher-order metafunction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个高阶元函数
- en: Evaluating metafunctions lazily
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟评估元函数
- en: Converting all the tuple elements to string
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有元组元素转换为字符串
- en: Splitting tuples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分元组
- en: Manipulating heterogeneous containers in C++14
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++14中操作异构容器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter is devoted to some cool and hard to understand metaprogramming
    methods. These methods are not for everyday use, but they may be of real help
    for the development of generic libraries.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍一些酷而难以理解的元编程方法。这些方法不是为日常使用而设计的，但它们可能对开发通用库有所帮助。
- en: '[Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, already covered the basics of metaprogramming. Reading it is recommended
    for better understanding. In this chapter, we''ll go deeper and see how multiple
    types can be packed in a single tuple like type. We''ll make functions for manipulating
    collections of types, we''ll see how types of compile-time collections may be
    changed, and how compile-time tricks can be mixed with runtime. All this is metaprogramming.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*编译时技巧*，已经涵盖了元编程的基础知识。建议阅读以便更好地理解。在本章中，我们将深入探讨如何将多个类型打包在单个类似元组的类型中。我们将创建用于操作类型集合的函数，看看如何改变编译时集合的类型，以及如何将编译时技巧与运行时混合。所有这些都是元编程。'
- en: Fasten your seat belts and get ready, lets go...!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系好安全带，准备好，让我们开始...！
- en: Using type vector of types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型向量
- en: 'There are situations when it would be great to work with all the template parameters
    like they were in a container. Imagine that we are writing something, such as
    `Boost.Variant`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，希望能够像在容器中一样处理所有模板参数。想象一下，我们正在编写一些东西，比如`Boost.Variant`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is the place where all the following interesting tasks start
    to happen:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是所有以下有趣任务开始发生的地方：
- en: How can we remove constant and volatile qualifiers from all the types?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何去除所有类型的常量和易失性限定符？
- en: How can we remove duplicate types?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何去除重复类型？
- en: How can we get the sizes of all the types?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何获得所有类型的大小？
- en: How can we get the maximum size of the input parameters?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何获得输入参数的最大大小？
- en: All these tasks can be easily solved using `Boost.MPL`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都可以很容易地使用`Boost.MPL`解决。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: A basic knowledge of [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, is required for this recipe. Accumulate some courage before
    reading--there will be a lot of metaprogramming in this recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)的*编译时技巧*有基本了解才能使用这个示例。在阅读之前要鼓起一些勇气--这个示例中会有很多元编程。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We already saw how a type can be manipulated at compile time. Why can't we go
    further and combine multiple types in an array and perform operations for each
    element of that array?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在编译时操作类型。为什么我们不能进一步组合多个类型在一个数组中，并对该数组的每个元素执行操作呢？
- en: 'First of all, let''s pack all the types in one of the `Boost.MPL` type''s container:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将所有类型打包在`Boost.MPL`类型的容器中：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s make our example less abstract and see how it works if we specify types:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们的示例变得不那么抽象，看看如果我们指定类型会发生什么：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We may check everything at compile time. Let''s assert that types is not empty:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在编译时检查所有内容。让我们断言类型不为空：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We may also check that, for example, the `non_declared` types is still at index
    `4` position:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以检查，例如，`non_declared`类型仍然在索引`4`位置：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And that the last type is still `std::string`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且最后一个类型仍然是`std::string`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We may carry out some transformations. Let''s start with removing constant
    and volatile qualifiers:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以进行一些转换。让我们从去除常量和易失性限定符开始：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s how we can remove the duplicate types:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何去除重复类型的方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We may check that the vector contains only `5` types:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查向量只包含`5`种类型：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s how we can compute sizes of each element:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算每个元素的大小：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is how to get the maximum size from the `sizes_type` type:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是如何从`sizes_type`类型中获取最大大小的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We may assert that the maximum size of the type is equal to the declared size
    of the structure, which must be the biggest one in our example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以断言类型的最大大小等于结构声明的大小，这必须是我们示例中最大的大小：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::mpl::vector` class is a compile-time container that holds types.
    To be more precise, it is a type that holds types. We do not make instances of
    it; instead, we are just using it in `typedef`s.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::mpl::vector`类是一个在编译时保存类型的容器。更准确地说，它是一个保存类型的类型。我们不创建它的实例；相反，我们只是在`typedef`中使用它。'
- en: 'Unlike the standard library containers, the `Boost.MPL` containers have no
    member methods. Instead, methods are declared in a separate header. So to use
    some methods, we need to:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准库容器不同，`Boost.MPL`容器没有成员方法。相反，方法在单独的头文件中声明。因此，要使用一些方法，我们需要：
- en: Include the correct header.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含正确的头文件。
- en: Call that method, usually by specifying the container as a first parameter.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常通过指定容器作为第一个参数来调用该方法。
- en: We already saw metafunctions in [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*. We were using some metafunctions (such as `boost::is_same`)
    from the familiar `Boost.TypeTraits` library.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)中看到了元函数，*编译时技巧*。我们使用了一些元函数（如`boost::is_same`）来自熟悉的`Boost.TypeTraits`库。
- en: So, in *step* *3*, *step* *4*, and *step* *5* we are just calling metafunctions
    for our container type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在*步骤* *3*、*步骤* *4*和*步骤* *5*中，我们只是为我们的容器类型调用元函数。
- en: The hardest part is coming up!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的部分即将到来！
- en: 'Placeholders are widely used by the `Boost.MPL` library for combining the metafunctions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 占位符被`Boost.MPL`库广泛用于组合元函数：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `boost::mpl::_1` is a placeholder and the whole expression means, for
    each type in `types`, do `boost::remove_cv<>::type` and push back that type to
    the resulting vector. Return the resulting vector via `::type`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`boost::mpl::_1` 是一个占位符，整个表达式的意思是，对于 `types` 中的每种类型，执行 `boost::remove_cv<>::type`
    并将该类型推回到结果向量中。通过 `::type` 返回结果向量。
- en: 'Let''s move to *step* *7*. Here, we specify a comparison metafunction for `boost::mpl::unique`
    using the `boost::is_same<boost::mpl::_1, boost::mpl::_2>` template parameter,
    where `boost::mpl::_1` and `boost::mpl::_2` are placeholders. You may find it
    similar to `boost::bind(std::equal_to(), _1, _2)`, and the whole expression in
    *step* *7* is similar to the following pseudo code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 *步骤7*。在这里，我们使用 `boost::is_same<boost::mpl::_1, boost::mpl::_2>` 模板参数为
    `boost::mpl::unique` 指定了一个比较元函数，其中 `boost::mpl::_1` 和 `boost::mpl::_2` 是占位符。你可能会发现它类似于
    `boost::bind(std::equal_to(), _1, _2)`，*步骤7* 中的整个表达式类似于以下伪代码：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is something interesting, which is required for better understanding,
    in *step* *9*. In the preceding code, `sizes_types` is not a vector of values,
    but rather a vector of integral constants-types representing numbers. The `sizes_types
    typedef` is actually a following type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤9* 中有一些有趣的东西，这对于更好地理解是必要的。在前面的代码中，`sizes_types` 不是一个值的向量，而是一个表示数字的整数常量类型的向量。`sizes_types
    typedef` 实际上是以下类型：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The final step must be clear now. It just gets the maximum element from the
    `sizes_types` `typedef`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步现在一定很清楚了。它只是从 `sizes_types` `typedef` 中获取最大的元素。
- en: We may use the `Boost.MPL` metafunctions at any place where typedefs are allowed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何允许 typedef 的地方使用 `Boost.MPL` 元函数。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.MPL` library usage results in longer compilation times, but gives
    you the ability to do everything you want with types. It does not add runtime
    overhead and won't even add a single instruction to the resulting binary. C++17
    has no `Boost.MPL` classes, and `Boost.MPL` does not use features of modern C++,
    such as the variadic templates. This makes the `Boost.MPL` compilation times not
    as short as possible on C++11 compilers, but makes the library usable on C++03
    compilers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL` 库的使用会导致更长的编译时间，但可以让您对类型进行任何想要的操作。它不会增加运行时开销，甚至不会向结果二进制文件添加一条指令。C++17
    没有 `Boost.MPL` 类，而 `Boost.MPL` 也不使用现代 C++ 的特性，比如可变模板。这使得在 C++11 编译器上，`Boost.MPL`
    的编译时间不会尽可能短，但使得该库可以在 C++03 编译器上使用。'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks* for information basics of metaprogramming
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见 [第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*编译时技巧*，了解元编程的基础知识
- en: The *Manipulating vector of types* recipe will give you even more information
    about metaprogramming and the `Boost.MPL` library
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作类型向量* 配方将为您提供有关元编程和 `Boost.MPL` 库的更多信息'
- en: See the official documentation of `Boost.MPL` for more examples and full reference
    at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 [http://boost.org/libs/mpl](http://boost.org/libs/mpl) 上的 `Boost.MPL` 官方文档，了解更多示例和完整参考资料
- en: Manipulating a vector of types
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作类型向量
- en: 'The task of this recipe is to modify the content of one `boost::mpl::vector`
    function depending on the content of a second `boost::mpl::vector` function. We''ll
    be calling the second vector as the vector of modifiers and each of those modifiers
    may have the following type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的任务是根据第二个 `boost::mpl::vector` 函数的内容修改一个 `boost::mpl::vector` 函数的内容。我们将调用第二个向量为修改器向量，每个修改器可能具有以下类型：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, where shall we start from?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从哪里开始呢？
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The basic knowledge of `Boost.MPL` is required. Reading the *Using type vector
    of types* recipe and [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks,* may help.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解 `Boost.MPL`。阅读 *使用类型向量* 配方和 [第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*编译时技巧*，可能会有所帮助。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: This recipe is similar to the previous one, but it also uses conditional compile-time
    statements. Get ready, it won't be easy!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方与之前的配方类似，但它还使用了条件编译时语句。准备好了，这不会容易！
- en: 'We shall start with headers:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从头文件开始：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s put all the metaprogramming magic inside the structure, for simpler
    reuse:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将所有的元编程魔法放入结构中，以便更简单地重用：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is a good thought to check that the passed vectors have the same size:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查传递的向量是否具有相同的大小是一个好主意：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s take care of the modifying metafunction:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们处理修改元函数：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And the final step:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will now run some tests and make sure that our metafunction works great:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一些测试，确保我们的元函数运行良好：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In step *3,* we assert that sizes are equal, but we do it in an unusual way.
    The `boost::mpl::size<Types>::type` metafunction actually returns an integral
    constant `struct boost::mpl::long_<4>`, so in a static assertion, we actually
    compare two types, not two numbers. This can be rewritten in a more familiar way:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤3* 中，我们断言大小相等，但我们以一种不寻常的方式来做。`boost::mpl::size<Types>::type` 元函数实际上返回一个整数常量
    `struct boost::mpl::long_<4>`，因此在静态断言中，我们实际上比较的是两种类型，而不是两个数字。这可以以更熟悉的方式重写：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the `typename` keyword we use. Without it, the compiler won't be able
    to decide if `::type` is actually a type or some variable. Previous recipes did
    not require it, because parameters for the metafunction were fully known at the
    point where we were using them. But in this recipe, parameter for the metafunction
    is a template.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用的 `typename` 关键字。没有它，编译器无法确定 `::type` 到底是一个类型还是某个变量。之前的配方不需要它，因为在使用它们的地方，元函数的参数是完全已知的。但在这个配方中，元函数的参数是一个模板。
- en: 'We''ll take a look at *step 5*, before taking care of *step 4*. In *step 5*,
    we provide the `Types`, `Modifiers`, and `binary_operator_t` parameters from *step
    4* to the `boost::mpl::transform` metafunction. This metafunction is rather simple--for
    each passed vector, it takes an element and passes it to a third parameter--a
    binary metafunction. If we rewrite it in pseudo code, it will look like the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理*步骤4*之前，我们将先看一下*步骤5*。在*步骤5*中，我们将`Types`、`Modifiers`和`binary_operator_t`参数从*步骤4*传递给`boost::mpl::transform`元函数。这个元函数非常简单--对于每个传递的向量，它获取一个元素并将其传递给第三个参数--一个二进制元函数。如果我们用伪代码重写它，它将看起来像下面这样：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Step 4* may make someone''s head hurt. At this step, we write a metafunction
    that is called for each pair of types from the `Types` and `Modifiers` vectors
    (see the preceding pseudo code):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*可能会让某些人头疼。在这一步中，我们为`Types`和`Modifiers`向量中的每对类型编写一个元函数（请参阅前面的伪代码）：'
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we already know, `boost::mpl::_2` and `boost::mpl::_1` are placeholders.
    In this recipe, `_1` is a placeholder for a type from the `Types` vector and `_2`
    is a placeholder for a type from the `Modifiers` vector.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，`boost::mpl::_2`和`boost::mpl::_1`是占位符。在这个配方中，`_1`是`Types`向量中类型的占位符，`_2`是`Modifiers`向量中类型的占位符。
- en: 'So, the whole metafunction works like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个元函数的工作方式如下：
- en: Compares the second parameter passed to it (via `_2`) with an `unsigned` type.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递给它的第二个参数（通过`_2`）与一个`unsigned`类型进行比较。
- en: If types are equal, makes the first parameter passed to it (via `_1`) unsigned
    and returns that type.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类型相等，使传递给它的第一个参数（通过`_1`）变为无符号，并返回该类型。
- en: Otherwise, it compares the second parameter passed to it (via `_2`) with a constant
    type.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它将传递给它的第二个参数（通过`_2`）与一个常量类型进行比较。
- en: If types are equal, it makes the first parameter passed to it (via `_1`) constant
    and, returns that type.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类型相等，它会使传递给它的第一个参数（通过`_1`）变为常量，并返回该类型。
- en: Otherwise, it returns the first parameter passed to it (via `_1`).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它返回传递给它的第一个参数（通过`_1`）。
- en: 'We need to be very careful while constructing this metafunction. Additional
    care should be taken as to not call `::type` at the end of it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个元函数时，我们需要非常小心。还需要特别注意不要在最后调用`::type`：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we call `::type`, the compiler will attempt to evaluate the binary operator
    at this point, and this leads to a compilation error. In pseudo code, such an
    attempt would look like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`::type`，编译器将尝试在此处评估二进制运算符，这将导致编译错误。在伪代码中，这样的尝试看起来像这样：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Working with metafunctions requires some practice. Even your humble servant
    cannot write some functions correctly from the first attempt (second and third
    attempts are also not good though). Do not be afraid or confused to experiment!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元函数需要一些实践。即使是您谦卑的仆人也不能在第一次尝试时正确地编写一些函数（尽管第二次和第三次尝试也不好）。不要害怕或困惑去尝试！
- en: 'The `Boost.MPL` library is not a part of C++17 and does not use modern C++
    features, but it can be used with C++11 variadic templates:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`库不是C++17的一部分，也不使用现代C++特性，但可以与C++11可变模板一起使用：'
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Just as always, metafunctions do not add a single instruction to the resulting
    binary file and do not make performance worse. However, using them you may make
    your code more tuned to a specific situation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以往一样，元函数不会向生成的二进制文件添加一条指令，也不会使性能变差。但是，使用它们可以使您的代码更加适应特定情况。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read this chapter from the beginning to get more simple examples of the `Boost.MPL`
    usage
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，以获取`Boost.MPL`用法的更多简单示例
- en: See [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, especially the *Selecting an optimal operator for a template parameter*
    recipe, which contains code similar to the `binary_operator_t` metafunction
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*编译时技巧*，特别是*为模板参数选择最佳运算符*配方，其中包含类似于`binary_operator_t`元函数的代码
- en: Official documentation of `Boost.MPL` has more examples and a full table of
    contents at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.MPL`的官方文档在[http://boost.org/libs/mpl](http://boost.org/libs/mpl)上有更多示例和完整的目录'
- en: Getting a function's result type at compile time
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时获取函数的结果类型
- en: 'Many good features were added to C++11 to simplify the metaprogramming. One
    such feature is the alternative function syntax. It allows deducing the result
    type of a template function. Here is an example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++11添加了许多良好的功能，以简化元编程。其中一个功能是替代函数语法。它允许推断模板函数的结果类型。这里是一个例子：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It allows us to write generic functions more easily:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它使我们更容易编写通用函数：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But, Boost has a lot of functions like these and it does not require C++11 to
    work. How is that possible and how can we make a C++03 version of the `my_function_cpp11`
    function?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Boost有很多类似的函数，它不需要C++11就可以工作。这是怎么可能的，我们如何制作`my_function_cpp11`函数的C++03版本？
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and templates is required for this recipe.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++和模板知识。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'C++11 greatly simplifies metaprogramming. A lot of code must be written in
    C++03 to make something close to the alternative functions syntax:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C++11极大地简化了元编程。必须使用C++03编写大量代码，以实现接近替代函数语法的功能：
- en: 'We have to include the following header:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须包含以下头文件：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s make a metafunction in the `result_of` namespace for any types:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为任何类型在`result_of`命名空间中制作一个元函数：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And specialize it for types `s1` and `s2`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并为类型`s1`和`s2`专门化它：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we are ready to write the `my_function_cpp03` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备写`my_function_cpp03`函数：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That''s it! Now, we can use this function like a C++11 one:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们可以像使用C++11一样使用这个函数：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main idea of this recipe is that we may make a special metafunction that
    deduces the resulting type. Such a technique can be seen all around the Boost
    libraries, for example, in the `Boost.Variant`'s implementation of `boost::get<>`
    or in almost any function from `Boost.Fusion`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的主要思想是，我们可以制作一个特殊的元函数来推断结果类型。这样的技术可以在Boost库的各个地方看到，例如，在`Boost.Variant`的`boost::get<>`实现中，或者在`Boost.Fusion`的几乎任何函数中。
- en: Now, let's move step-by-step. The `result_of` namespace is just some kind of
    a tradition, but you may use your own and it does not matter. The `boost::common_type<>`
    metafunction deduces a type common of several types, so we use it for a general
    case. We also added two template specializations of the `result_of::my_function_cpp03`
    structures for the `s1` and `s2` types.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地进行。`result_of`命名空间只是一种传统，但您可以使用自己的，这并不重要。`boost::common_type<>`元函数推断出几种类型的公共类型，因此我们将其用于一般情况。我们还为`s1`和`s2`类型添加了`result_of::my_function_cpp03`结构的两个模板特化。
- en: The disadvantage of writing metafunctions in C++03 is that sometimes we are
    required to write a lot. Compare the amount of code for `my_function_cpp11` and
    `my_function_cpp03` including the `result_of` namespace to feel the difference.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++03中编写元函数的缺点是，有时我们需要写很多代码。比较`my_function_cpp11`和`my_function_cpp03`的代码量，包括`result_of`命名空间，以感受其中的差异。
- en: 'When the metafunction is ready, we may deduce the resulting type without C++11:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当元函数准备好后，我们可以在没有C++11的情况下推断出结果类型：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This technique does not add runtime overhead but it may slow down compilation
    a little bit. You may use it on modern C++ compilers as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不会增加运行时开销，但可能会稍微减慢编译速度。您也可以在现代C++编译器上使用它。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipes *Enabling the usage of templated functions for integral types*,
    *Disabling templated function usage for real types*, and *Selecting an optimal
    operator for a template parameter* recipes from [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, will give you much more information about `Boost.TypeTraits`
    and metaprogramming
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)的食谱*启用整数类型的模板函数使用*、*禁用实数类型的模板函数使用*和*为模板参数选择最佳运算符*将为您提供有关`Boost.TypeTraits`和元编程的更多信息'
- en: Consider the official documentation of `Boost.TypeTraits` for more information
    about ready metafunctions at [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑官方文档`Boost.TypeTraits`，了解有关准备好的元函数的更多信息[http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
- en: Making a higher-order metafunction
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作高阶元函数
- en: 'Functions that accept other functions as an input parameter or functions that
    return other functions are called **higher-order** functions. For example, the
    following functions are higher order:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为输入参数或返回其他函数的函数称为**高阶**函数。例如，以下函数是高阶函数：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We already saw higher-order metafunctions in the recipes *Using type vector
    of types* and *Manipulating vector of types* recipes from this chapter, where
    we used `boost::mpl::transform`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的*使用类型类型向量*和*操作类型向量*食谱中看到了高阶元函数，我们在那里使用了`boost::mpl::transform`。
- en: 'In this recipe, we''ll try to make our own higher-order metafunction named
    `coalesce`, which accepts two types and two metafunctions. The `coalesce` metafunction
    applies the first type-parameter to the first metafunction and compares the resulting
    type with the `boost::mpl::false_` type. If the resulting type is the `boost::mpl::false_`
    type, it returns the result of applying the second type-parameter to the second
    metafunction, otherwise, it returns the first resulting type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将尝试制作自己的高阶元函数，名为`coalesce`，它接受两种类型和两个元函数。`coalesce`元函数将第一个类型参数应用于第一个元函数，并将结果类型与`boost::mpl::false_`类型进行比较。如果结果类型是`boost::mpl::false_`类型，则返回将第二个类型参数应用于第二个元函数的结果，否则返回第一个结果类型：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: This recipe (and chapter) is a tricky one. Reading this chapter from the beginning
    is highly recommended.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱（和章节）有点棘手。强烈建议从头开始阅读本章。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Boost.MPL` metafunctions are actually structures that can be easily passed
    as a template parameter. The hard part is to use it correctly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.MPL`元函数实际上是可以轻松作为模板参数传递的结构。困难的部分是正确使用它：'
- en: 'We need the following headers to write a higher-order metafunction:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件来编写高阶元函数：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to evaluate our functions:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是评估我们的函数：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we need to choose the correct result type:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要选择正确的结果类型：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That''s it! We have completed a higher-order metafunction! Now, we may use
    it just like that:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经完成了一个高阶元函数！现在，我们可以像这样使用它：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main problem with writing the higher-order metafunctions is taking care
    of the placeholders. That's why we shall not call `Func1<Param1>::type` directly.
    Instead of that, we must use the `boost::mpl::apply` metafunction, which accepts
    one function and up to five parameters that shall be passed to this function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高阶元函数的主要问题是要注意占位符。这就是为什么我们不应该直接调用`Func1<Param1>::type`。而是必须使用`boost::mpl::apply`元函数，它接受一个函数和最多五个参数，这些参数将传递给这个函数。
- en: You may configure `boost::mpl::apply` to accept even more parameters, defining
    the `BOOST_MPL_LIMIT_METAFUNCTION_ARITY` macro to the required amount of parameters,
    for example, to 6.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置`boost::mpl::apply`以接受更多参数，将`BOOST_MPL_LIMIT_METAFUNCTION_ARITY`宏定义为所需的参数数量，例如为6。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has nothing close to the `Boost.MPL` library to apply a metafunction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有任何接近`Boost.MPL`库应用元函数的东西。
- en: Modern C++ has a bunch of features that may help you achieve the `Boost.MPL`
    functionality. For example, C++11 has a `<type_traits>` header and **basic** **constexpr**
    support. C++14 has an **extended constexpr** support, in C++17 there's an `std::apply`
    function that works with tuples and is usable in constant expressions. Also, in
    C++17 lambdas are constexpr by default and there is an **if constexpr** (expr).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++有很多功能，可以帮助你实现`Boost.MPL`的功能。例如，C++11有一个`<type_traits>`头文件和**基本** **constexpr**支持。C++14有**扩展constexpr**支持，C++17有一个可以与元组一起使用并且可以在常量表达式中使用的`std::apply`函数。此外，在C++17中，lambda默认是constexpr，并且有一个**if
    constexpr**（expr）。
- en: Writing your own solution would waste a lot of time and probably would not work
    on older compilers. So, `Boost.MPL` still remains one of the most suitable solutions
    for metaprogramming.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的解决方案会浪费很多时间，而且可能在旧编译器上无法工作。因此，`Boost.MPL`仍然是最适合元编程的解决方案之一。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the official documentation, especially the *Tutorial* section, for more
    information about `Boost.MPL` at [http://boost.org/libs/mpl](http://boost.org/libs/mpl).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 查看官方文档，特别是*Tutorial*部分，了解有关`Boost.MPL`的更多信息，请访问[http://boost.org/libs/mpl](http://boost.org/libs/mpl)。
- en: Evaluating metafunctions lazily
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性评估元函数
- en: Lazy evaluation means that the function is not called until we really need its
    result. Knowledge of this recipe is highly recommended for writing good metafunctions.
    The importance of lazy evaluation will be shown in the following example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估意味着在真正需要其结果之前不会调用函数。了解这个方法对于编写良好的元函数非常重要。惰性评估的重要性将在以下示例中展示。
- en: 'Imagine that we are writing some metafunction that accepts a function `Func`,
    a parameter `Param`, and a condition `Cond`. The resulting type of that function
    must be a `fallback` type if applying the `Cond` to `Param` returns `false`, otherwise
    the result must be a `Func` applied to `Param`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在编写一些元函数，它接受一个函数`Func`，一个参数`Param`和一个条件`Cond`。如果将`Cond`应用于`Param`返回`false`，那么该函数的结果类型必须是一个`fallback`类型，否则结果必须是将`Func`应用于`Param`的结果：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This metafunction is the place where we cannot live without lazy evaluation,
    because it may be impossible to apply `Func` to `Param` if the `Cond` is not met.
    Such attempts will always result in compilation failure and `Fallback` is never
    returned.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元函数是我们无法离开惰性评估的地方，因为如果`Cond`不满足，可能无法将`Func`应用于`Param`。这样的尝试总是会导致编译失败，并且永远不会返回`Fallback`。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-time Tricks*, is highly recommended. However, a good knowledge of metaprogramming
    should be enough.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*Compile-time
    Tricks*，是非常推荐的。然而，对元编程的良好了解应该足够了。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Keep an eye on the small details, like not calling `::type` in the example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些小细节，比如在示例中不调用`::type`：
- en: 'We''ll need the following headers:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以下头文件：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The beginning of the function is simple:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的开始很简单：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We shall be careful here:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里要小心：
- en: '[PRE45]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Additional care must be taken when evaluating an expression:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在评估表达式时需要额外小心：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s it! Now we are free to use it like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们可以自由地这样使用它：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main idea of this recipe is that we must not execute the metafunction if
    the condition is `false`, because when the condition is `false`, there is a chance
    that the metafunction for that type can''t be applied:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的主要思想是，如果条件为`false`，我们就不应该执行元函数，因为当条件为`false`时，该类型的元函数可能无法应用：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, how do we evaluate a metafunction lazily?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何才能惰性评估元函数呢？
- en: 'The compiler does look inside the metafunction if there is no access to the
    metafunction''s internal types or values. In other words, the compiler tries to
    compile the metafunction when we try to get one of its members via `::`. This
    can be a call to `::type` or `::value`. That is how an incorrect version of `apply_if`
    looks like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有访问元函数的内部类型或值，编译器将不会查看元函数的内部。换句话说，当我们通过`::`尝试获取其成员之一时，编译器会尝试编译元函数。这可以是对`::type`或`::value`的调用。这就是`apply_if`的不正确版本的样子：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This differs from our example, where we did not call `::type` at *step 3* and
    implemented *step 4* using `eval_if_c`, which calls `::type` only for one of its
    parameters. The `boost::mpl::eval_if_c` metafunction is implemented like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的示例不同，在*步骤3*中我们没有调用`::type`，并且使用`eval_if_c`实现了*步骤4*，它只对其一个参数调用`::type`。`boost::mpl::eval_if_c`元函数的实现如下：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Because `boost::mpl::eval_if_c` calls `::type` for a succeeded condition and
    `fallback` has no `::type`, we were required to wrap `fallback` into the `boost::mpl::identity`
    class. This class is very simple, but useful structure that returns its template
    parameter via a `::type` call and does nothing more:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`boost::mpl::eval_if_c`对于成功的条件调用了`::type`，而`fallback`没有`::type`，所以我们需要将`fallback`包装到`boost::mpl::identity`类中。这个类非常简单，但是通过`::type`调用返回其模板参数，并且不执行其他操作：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we already mentioned, C++11 has no classes of `Boost.MPL`, but we may use
    `std::common_type<T>` with a single argument just like `boost::mpl::identity<T>`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，C++11没有`Boost.MPL`的类，但我们可以像使用`boost::mpl::identity<T>`一样，使用带有单个参数的`std::common_type<T>`。
- en: Just as always, metafunctions do not add a single line to the output binary
    file, you can use metafunctions as many times as you want. The more you do at
    compile time, the less remains for the runtime.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，元函数不会在输出的二进制文件中增加一行代码，你可以随意使用元函数。在编译时做得越多，运行时剩下的就越少。
- en: See also...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: The `boost::mpl::identity` type can be used to disable **Argument Dependent
    Lookup** (**ADL**) for template functions. See sources of `boost::implicit_cast`
    in the `<boost/implicit_cast.hpp>` header.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::mpl::identity`类型可用于禁用模板函数的**Argument Dependent Lookup**（**ADL**）。请参阅`<boost/implicit_cast.hpp>`头文件中`boost::implicit_cast`的源代码。'
- en: Reading this chapter from the beginning and the official documentation of `Boost.MPL`
    at [http://boost.org/libs/mpl](http://boost.org/libs/mpl) may help.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章和`Boost.MPL`的官方文档，网址为[http://boost.org/libs/mpl](http://boost.org/libs/mpl)，可能会有所帮助。
- en: Converting all the tuple elements to strings
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有元组元素转换为字符串
- en: This recipe and the next one are devoted to a mix of compile time and runtime
    features. We'll be using the `Boost.Fusion` library and see what it can do.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方和下一个配方都致力于混合编译时和运行时特性。我们将使用`Boost.Fusion`库并看看它能做什么。
- en: Remember that we were talking about tuples and arrays in the first chapter?
    Now, we want to write a single function that can stream elements of tuples and
    arrays to strings.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在第一章谈论过元组和数组吗？现在，我们想要编写一个单一的函数，可以将元组和数组的元素流式传输到字符串。
- en: '![](img/00016.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should be aware of the `boost::tuple` and `boost::array` classes and of
    the `boost::lexical_cast` function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该了解`boost::tuple`和`boost::array`类以及`boost::lexical_cast`函数。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We already know almost all the functions and classes that will be used in this
    recipe. We just need to gather all of them together:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几乎了解了本配方中将要使用的所有函数和类。我们只需要把它们全部聚集在一起：
- en: 'We need to write a functor that converts any type to string:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写一个将任何类型转换为字符串的函数：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And now is the tricky part of the code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是代码的棘手部分：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s all! Now, we may convert anything we want to string:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止！现在，我们可以将任何想要的东西转换为字符串：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The preceding example outputs the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子输出如下：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main problem of the `stringize` function is that neither `boost::tuple`
    nor `std::pair` have `begin()` or `end()` methods, so we cannot call `std::for_each`.
    This is where the `Boost.Fusion` steps in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringize`函数的主要问题是，`boost::tuple`和`std::pair`都没有`begin()`或`end()`方法，所以我们无法调用`std::for_each`。这就是`Boost.Fusion`发挥作用的地方。'
- en: The `Boost.Fusion` library contains lots of terrific algorithms that may manipulate
    structures at compile time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`库包含许多可以在编译时操作结构的出色算法。'
- en: The `boost::fusion::for_each` function iterates through elements of sequence
    and applies a functor for each of the elements.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::fusion::for_each`函数遍历序列的元素，并对每个元素应用一个函数。'
- en: 'Note that we have included:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们已经包括了：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is required because by default `Boost.Fusion` works only with its own
    classes. `Boost.Fusion` has its own tuple class, `boost::fusion::vector`, which
    is quite close to `boost::tuple`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是必需的，因为默认情况下`Boost.Fusion`只能使用自己的类。`Boost.Fusion`有自己的元组类，`boost::fusion::vector`，它与`boost::tuple`非常接近：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But `boost::fusion::vector` is not as simple as `boost::tuple`. We'll see the
    difference in the *Splitting tuples* recipe.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但`boost::fusion::vector`不像`boost::tuple`那么简单。我们将在*拆分元组*配方中看到两者之间的区别。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is one fundamental difference between `boost::fusion::for_each` and `std::for_each`.
    The `std::for_each` function contains a loop inside it and determinates at runtime,
    how many iterations must be done. However, `boost::fusion::for_each()` knows iterations
    count at compile time and fully unrolls the loop. For the `boost::tuple<cat, int,
    std::string> tup2`, the `boost::fusion::for_each(tup2, functor)` call is equivalent
    to the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::fusion::for_each`和`std::for_each`之间有一个根本的区别。`std::for_each`函数内部包含一个循环，并在运行时确定必须执行多少次迭代。然而，`boost::fusion::for_each()`在编译时知道迭代次数，并完全展开循环。对于`boost::tuple<cat,
    int, std::string> tup2`，`boost::fusion::for_each(tup2, functor)`调用等同于以下代码：'
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: C++11 contains no `Boost.Fusion` classes. All the methods of `Boost.Fusion`
    are very effective. They do as much as possible at compile time and have some
    very advanced optimizations.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: C++11不包含`Boost.Fusion`类。`Boost.Fusion`的所有方法都非常有效。它们尽可能多地在编译时执行，并具有一些非常高级的优化。
- en: 'C++14 adds `std::integer_sequence` and `std::make_integer_sequence` to simplify
    for with variadic templates. Using those entities it is possible to hand write
    the `boost::fusion::for_each` functionality and implement the `stringize` function
    without `Boost.Fusion`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: C++14添加了`std::integer_sequence`和`std::make_integer_sequence`来简化使用可变模板的`for`。使用这些实体，可以手动编写`boost::fusion::for_each`功能，并在没有`Boost.Fusion`的情况下实现`stringize`函数：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you may see a lot of code was written to do that and such code is not simple
    to read and understand.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有很多代码被编写来做到这一点，这样的代码并不容易阅读和理解。
- en: 'Ideas on adding something close to a `constexpr for` to the C++20 Standard
    are discussed in the C++ Standardization Working Group. With that feature, some
    day we could write the following code (syntax may change!):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在C++20标准中添加类似于`constexpr for`的功能的想法在C++标准化工作组中进行了讨论。有了这个功能，有一天我们可以编写以下代码（语法可能会改变！）：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Until then, `Boost.Fusion` seems to be the most portable and simple solution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，`Boost.Fusion`似乎是最通用和简单的解决方案。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Splitting tuples* recipe will give more information about the true power
    of `Boost.Fusion`
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拆分元组*配方将提供有关`Boost.Fusion`真正能力的更多信息。'
- en: The official documentation of `Boost.Fusion` contains some interesting examples
    and full references, which can be found at [http://boost.org/libs/fusion](http://boost.org/libs/fusion)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`的官方文档包含一些有趣的例子和完整的参考资料，可以在[http://boost.org/libs/fusion](http://boost.org/libs/fusion)找到'
- en: Splitting tuples
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分元组
- en: This recipe will show a tiny piece of the `Boost.Fusion` library's abilities.
    We'll be splitting a single tuple into two tuples, one with arithmetic types and
    the other with all other types.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示`Boost.Fusion`库能力的一小部分。我们将把一个单一的元组分成两个元组，一个包含算术类型，另一个包含所有其他类型。
- en: '![](img/00017.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of `Boost.MPL`, placeholders, and `Boost.Tuple`.
    Reading this chapter from the beginning is recommended.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解`Boost.MPL`，占位符和`Boost.Tuple`。建议从头开始阅读本章。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This is possibly one of the hardest recipes in this chapter. The resulting
    types are determined at compile time and values for those types are filled at
    runtime:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本章中最难的配方之一。生成的类型在编译时确定，并且这些类型的值在运行时填充：
- en: 'To implement that mix, we need the following headers:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这种混合，我们需要以下头文件：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we are ready to make a function that returns non-arithmetic types:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备编写一个返回非算术类型的函数：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And a function that returns arithmetic types:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及一个返回算术类型的函数：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That''s it! Now, we are capable of doing the following tasks:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们能够执行以下任务：
- en: '[PRE64]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The idea behind `Boost.Fusion` is that the compiler knows the structure layout
    at compile time and whatever the compiler knows at compile time, we may change
    at the same time. The `Boost.Fusion` allows us to modify different sequences,
    adding and removing fields, and changing field types. This is what we did in *step
    2* and *step 3*; we removed the non-required fields from the tuple.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`的理念是编译器在编译时知道结构布局，无论编译器在编译时知道什么，我们都可以同时改变。`Boost.Fusion`允许我们修改不同的序列，添加和删除字段，并更改字段类型。这就是我们在*步骤2*和*步骤3*中所做的；我们从元组中删除了非必需的字段。'
- en: 'Now, let''s take a very close look at `get_nonarithmetics`. First of all, its
    result type is deduced using the following construction:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细看看`get_nonarithmetics`。首先，它的结果类型是使用以下结构推导出来的：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This must be familiar to us. We saw something like this in the *Getting function
    result type at compile-time* recipe in this chapter. The `Boost.MPL`'s placeholder
    `boost::mpl::_1` works well with the `boost::fusion::result_of::remove_if` metafunction
    that returns a new sequence type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说应该很熟悉。我们在本章的*在编译时获取函数结果类型*配方中看到了类似的东西。`Boost.MPL`的占位符`boost::mpl::_1`与`boost::fusion::result_of::remove_if`元函数很搭配，它返回一个新的序列类型。
- en: 'Now, let''s move inside the function and we watch the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入函数内部，看看以下代码：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Remember that the compiler knows all the types of `seq` at compile time. This
    means that `Boost.Fusion` may apply metafunctions for different elements of `seq`
    and get the metafunction results for them. This also means that `Boost.Fusion`
    knows how to copy required fields from the old structure to the new one.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 记住编译器在编译时知道`seq`的所有类型。这意味着`Boost.Fusion`可以为`seq`的不同元素应用元函数，并为它们获取元函数结果。这也意味着`Boost.Fusion`知道如何从旧结构复制必需的字段到新结构中。
- en: However, `Boost.Fusion` tries not to copy fields as long as possible.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Boost.Fusion`尽可能地避免复制字段。
- en: The code in *step 3* is very similar to the code in *step 2*, but it has a negated
    predicate for removing non-required types.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*中的代码与*步骤2*中的代码非常相似，但它具有一个用于删除非必需类型的否定谓词。'
- en: Our functions can be used with any type supported by `Boost.Fusion` and not
    just with `boost::fusion::vector`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数可以与`Boost.Fusion`支持的任何类型一起使用，而不仅仅是`boost::fusion::vector`。
- en: There's more...
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You may use `Boost.MPL` functions for the `Boost.Fusion` containers. You just
    need to include `#include <boost/fusion/include/mpl.hpp>`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为`Boost.Fusion`容器使用`Boost.MPL`函数。您只需要包含`#include <boost/fusion/include/mpl.hpp>`：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We used `boost::fusion::result_of::value_at_c` instead of `boost::fusion::result_of::at_c`
    because `boost::fusion::result_of::at_c` returns the exact return type of the
    `boost::fusion::at_c` call, which is a reference. `boost::fusion::result_of::value_at_c`
    returns type without a reference.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`boost::fusion::result_of::value_at_c`而不是`boost::fusion::result_of::at_c`，因为`boost::fusion::result_of::at_c`返回`boost::fusion::at_c`调用的确切返回类型，即引用。`boost::fusion::result_of::value_at_c`返回没有引用的类型。
- en: The `Boost.Fusion` and `Boost.MPL` libraries are not a part of C++17\. `Boost.Fusion`
    is extremely fast. It has many optimizations.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`和`Boost.MPL`库不是C++17的一部分。`Boost.Fusion`非常快。它有许多优化。'
- en: It is worth mentioning that we saw only a tiny part of the `Boost.Fusion` abilities.
    A separate book can be written about it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，我们只看到了`Boost.Fusion`能力的一小部分。可以写一本单独的书来介绍它。
- en: See also
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Good tutorials and full documentation for `Boost.Fusion` is available at [http://boost.org/libs/fusion](http://boost.org/libs/fusion)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Fusion`的良好教程和完整文档可在[http://boost.org/libs/fusion](http://boost.org/libs/fusion)上找到。'
- en: You may also wish to see an official documentation for `Boost.MPL` at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能还希望查看[http://boost.org/libs/mpl](http://boost.org/libs/mpl)上的`Boost.MPL`的官方文档
- en: Manipulating heterogeneous containers in C++14
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++14中操作异构容器
- en: Most of the metaprogramming tricks that we saw in this chapter were invented
    long before C++11\. Probably, you've already heard about some of that stuff.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的大多数元编程技巧都是在C++11之前发明的。可能你已经听说过其中的一些东西。
- en: How about something brand new? How about implementing the previous recipe in
    C++14 with a library that puts the metaprogramming upside down and makes your
    eyebrows go up? Fasten your seatbelts, we're diving into the world of `Boost.Hana`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样来点全新的？怎么样用C++14实现上一个配方，使用一个将元编程颠倒过来并让你眉毛竖起来的库？系好安全带，我们要进入`Boost.Hana`的世界了。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires knowledge of C++11 and C++14, especially lambdas. You will
    need a truly C++14 compatible compiler to compile the example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要了解C++11和C++14，特别是lambda表达式。您需要一个真正兼容C++14的编译器来编译示例。
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now, let''s make everything in the `Boost.Hana` way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`Boost.Hana`的方式来做一切：
- en: 'Start with including the header:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包含头文件开始：
- en: '[PRE68]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We create an `is_arithmetic_` functional object:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`is_arithmetic_`函数对象：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we implement the `get_nonarithmetics` function:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实现`get_nonarithmetics`函数：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let's define `get_arithmetics` the other way around. Just for fun!
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用另一种方式定义`get_arithmetics`。就是为了好玩！
- en: '[PRE71]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'That''s it. Now, we can use these functions:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们可以使用这些函数：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The code may seem simple at first glance, but that's not true. The `Boost.Hana`
    puts the metaprogramming the other way around! In the previous recipes, we were
    working with types directly, but `Boost.Hana` makes a variable that holds a type
    and works with variable most of the time.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，代码可能看起来很简单，但事实并非如此。`Boost.Hana`将元编程颠倒过来了！在以前的配方中，我们直接使用类型，但`Boost.Hana`创建了一个保存类型并大部分时间使用变量的变量。
- en: 'Take a look at the `typeid_` call in *step 2*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下*步骤2*中的`typeid_`调用：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It actually returns a variable. Information about the type is now hidden inside
    the `type` variable and could be extracted by calling `decltype(type)::type`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上返回一个变量。有关类型的信息现在隐藏在`type`变量内部，并且可以通过调用`decltype(type)::type`来提取。
- en: But let's move line by line. In *step 2,* we store the generic lambda into the
    `is_arithmetic_` variable. From this point, we can use that variable as a functional
    object. Inside the lambda, we create a `type` variable that now holds information
    about the type of the `v`. The next line is a special wrapper around `std::is_arithmetic`
    that extracts information about the `v` type from the `type` variable and passes
    it to the `std::is_arithmetic` trait. Result of that call is a Boolean integral
    constant.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们一行一行地来。在*步骤2*中，我们将通用lambda存储在`is_arithmetic_`变量中。从这一点开始，我们可以将该变量用作函数对象。在lambda内部，我们创建了一个`type`变量，它现在保存了有关`v`类型的信息。下一行是对`std::is_arithmetic`的特殊包装，它从`type`变量中提取有关`v`类型的信息，并将其传递给`std::is_arithmetic`特性。该调用的结果是一个布尔整数常量。
- en: 'And now, the magic part! Lambda stored inside the `is_arithmetic_` variable
    is actually never called by `boost::hana::remove_if` and `boost::hana::filter`
    functions. All the `Boost.Hana`''s functions that use it only need the result
    type of the lambda function, but not its body. We can safely change the definition
    and the whole example will continue to work well:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，神奇的部分来了！存储在`is_arithmetic_`变量内的lambda实际上从未被`boost::hana::remove_if`和`boost::hana::filter`函数调用。所有使用它的`Boost.Hana`函数只需要lambda函数的结果类型，而不需要它的主体。我们可以安全地更改定义，整个示例将继续正常工作：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In *steps 3* and *4,* we call `boost::hana::remove_if` and `boost::hana::filter`
    functions, respectively. In *step 3,* we used `is_arithmetic_` inside the lambda.
    In *step 4,* we used it directly. You can use any syntax you'd like, it's just
    a matter of habit.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*和*4*中，我们分别调用`boost::hana::remove_if`和`boost::hana::filter`函数。在*步骤3*中，我们在lambda内部使用了`is_arithmetic_`。在*步骤4*中，我们直接使用了它。你可以使用任何你喜欢的语法，这只是一个习惯问题。
- en: 'Finally in `main()`, we check that everything works as expected and that the
    element in tuple by index 0 is equal to `8`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在`main()`中，我们检查一切是否按预期工作，并且元组中索引为0的元素是否等于`8`：
- en: '[PRE75]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The best way to understand the `Boost.Hana` library is to experiment with it.
    You can do it online at [http://apolukhin.github.io/Boost-Cookbook/](http://apolukhin.github.io/Boost-Cookbook/).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Boost.Hana`库的最佳方法是进行实验。你可以在[http://apolukhin.github.io/Boost-Cookbook/](http://apolukhin.github.io/Boost-Cookbook/)上在线进行。
- en: There's more...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a small detail left undescribed. How does the tuple access by `operator[]`
    work? It is impossible to have a single function that returns different types!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个小细节没有描述。`operator[]`如何访问元组？不可能有一个单一的函数返回不同的类型！
- en: 'This is very interesting if you meet this trick at first time. `Boost.Hana`''s
    `operator ""_c` works with literals and constructs different types depending on
    the literal:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次遇到这个技巧，这是非常有趣的。`Boost.Hana`的`operator ""_c`可以与文字一起工作，并根据文字构造不同的类型：
- en: If you write `0_c`, then `integral_constant<long long, 0>` is returned
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你写`0_c`，那么将返回`integral_constant<long long, 0>`
- en: If you write `1_c`, then `integral_constant<long long, 1>` is returned
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你写`1_c`，那么将返回`integral_constant<long long, 1>`
- en: If you write `2_c`, then `integral_constant<long long, 2>` is returned
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你写`2_c`，那么将返回`integral_constant<long long, 2>`
- en: The `boost::hana::tuple` class actually has many `operator[]` overloads, accepting
    different types of `integral_constant`. Depending on the value of integral constant
    the correct tuple element is returned. For example, if you write `some_tuple[1_c]`
    then `tuple::operator[](integral_constant<long long, 1>)` is called the the element
    by index `1` is returned.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::hana::tuple`类实际上有许多`operator[]`重载，接受不同类型的`integral_constant`。根据整数常量的值，返回正确的元组元素。例如，如果你写`some_tuple[1_c]`，那么将调用`tuple::operator[](integral_constant<long
    long, 1>)`，并返回索引为`1`的元素。'
- en: '`Boost.Hana` is not a part of C++17\. However, the author of the library participates
    in the C++ Standardization meetings and proposes different interesting things
    for inclusion into the C++ Standard.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Hana`不是C++17的一部分。然而，该库的作者参与了C++标准化会议，并提出了不同的有趣事物，以纳入C++标准。'
- en: If you are expecting order of magnitude better compile times from `Boost.Hana`
    than from `Boost.MPL` then don't. Currently compilers do not handle the `Boost.Hana`
    approach extremely well. This may change some day.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望从`Boost.Hana`获得比从`Boost.MPL`更好的编译时间，那就不要指望了。目前编译器对`Boost.Hana`的方法处理得并不是非常好。也许有一天会改变。
- en: It's worth looking at the source codes of the `Boost.Hana` library to discover
    new interesting ways of using C++14 features. All the Boost libraries could be
    found at GitHub [https://github.com/boostorg.](https://github.com/boostorg)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一看`Boost.Hana`库的源代码，以发现使用C++14特性的新有趣方法。所有Boost库都可以在GitHub上找到[https://github.com/boostorg](https://github.com/boostorg)。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation has more examples, a full reference section, some more
    tutorials, and a compile-time performance section. Enjoy the `Boost.Hana` library
    at [http://boost.org/libs/hana.](http://boost.org/libs/hana)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档中有更多示例，完整的参考部分，一些更多的教程，以及一个编译时性能部分。在[http://boost.org/libs/hana](http://boost.org/libs/hana)上享受`Boost.Hana`库。
