- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Test Results
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试结果
- en: So far, we have a test library that can only have a single test. You’ll see
    what happens in this chapter when we try to add another test and you’ll see how
    to enhance the test library to support multiple tests. We’ll need to use an old
    and rarely used capability of C++ that actually comes from its early C roots to
    support multiple tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个只能有一个测试的测试库。在本章中，当尝试添加另一个测试时，您将看到会发生什么，您将看到如何增强测试库以支持多个测试。我们将需要使用C++的一个古老且很少使用的功能，这个功能实际上源于其早期的C语言根源，以支持多个测试。
- en: Once we get more than one test, we’ll need a way to view the results. This will
    let you tell at a glance whether everything passed or not. And finally, we’ll
    fix the result output so that it no longer assumes `std::cout`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了多个测试，我们需要一种查看结果的方法。这将让您一眼就能看出是否一切顺利。最后，我们将修复结果输出，使其不再假设`std::cout`。
- en: 'We’ll cover the following main topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: Reporting a single test result based on exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于异常报告单个测试结果
- en: Enhancing the test library to support multiple tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强测试库以支持多个测试
- en: Summarizing the test results to clearly see what failed and what passed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总结测试结果，以便清楚地看到哪些失败和哪些通过
- en: Redirecting the test result so the output can go to any stream
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试结果重定向，以便输出可以流向任何流。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this chapter uses standard C++ that builds on any modern C++ 17
    or later compiler and standard library. The code is based on and continues from
    the previous chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码均使用标准C++，它基于任何现代C++ 17或更高版本的编译器和标准库构建。代码基于上一章并继续发展。
- en: 'You can find all the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub仓库找到本章所有代码：[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)。
- en: Reporting a single test result
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告单个测试结果
- en: So far, our single test just prints its hardcoded name when run. There was some
    early thinking that we might need a result in addition to the test name. This
    is actually a good example of adding something to the code that is not needed
    or used. Okay, a minor example because we will need something to keep track of
    whether the test passes or fails, but it’s still a good example of getting ahead
    of ourselves because we have actually never used the `mResult` data member yet.
    We’re going to fix that now with a better way to track the result of running a
    test.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的单个测试在运行时只是打印其硬编码的名称。早期有一些想法，我们可能需要一个除了测试名称之外的结果。这实际上是一个向代码中添加不必要或不使用的功能的良好例子。好吧，这是一个小的例子，因为我们需要一些东西来跟踪测试是否通过或失败，但它仍然是一个超越自己的好例子，因为我们实际上从未使用过`mResult`数据成员。我们现在将用一种更好的方式来跟踪测试的运行结果。
- en: We’ll assume that a test succeeds unless something happens to cause it to fail.
    What can happen? There will eventually be a lot of ways you can cause a test to
    fail. For now, we’ll just consider exceptions. This could be an exception that
    a test throws on purpose when it detects something is wrong or it could be an
    unexpected exception that gets thrown.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设测试成功，除非发生某些导致其失败的情况。可能会发生什么？最终会有很多导致测试失败的方法。现在，我们只考虑异常。这可能是一个测试在检测到有问题时故意抛出的异常，也可能是一个意外抛出的异常。
- en: We don’t want any exceptions to stop the tests from running. An exception thrown
    from one test shouldn’t be a reason to stop running others. We still only have
    a single test but we can make sure that an exception doesn’t stop the entire test
    process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望任何异常停止测试的运行。一个测试抛出的异常不应该成为停止运行其他测试的理由。我们仍然只有一个测试，但我们可以确保异常不会停止整个测试过程。
- en: 'What we want is to wrap the `run` function call in a `try` block so that any
    exceptions will be treated as a failure, like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是将`run`函数调用包裹在`try`块中，以便任何异常都将被视为失败，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When an exception is caught, we want to do two things. The first is to mark
    the test as a failure. The second is to set a message so that the result can be
    reported. The problem is that we don’t have a method called `setFailed` on the
    `TestInterface` class. It’s actually good to first write the code as we’d like
    it to be.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获到异常时，我们想要做两件事。第一是标记测试为失败。第二是设置一个消息，以便可以报告结果。问题是我们在`TestInterface`类上没有名为`setFailed`的方法。实际上，首先编写我们希望它成为的样子是很好的。
- en: In fact, the idea of `TestInterface` was for it to be a set of pure virtual
    methods like an interface. We could add a new method called `setFailed` but then
    the implementation would need to be written in a derived class. This seems like
    a basic part of a test to be able to hold the result and a message.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`TestInterface` 的想法是使其成为一组纯虚方法，就像一个接口。我们可以添加一个名为 `setFailed` 的新方法，但实现将需要在派生类中编写。这似乎是测试的一个基本部分，能够保存结果和消息。
- en: 'So, let’s refactor the design and change `TestInterface` into more of a base
    class and call it `TestBase` instead. We can also move the data members from the
    class declared inside the `TEST` macro and put them in the `TestBase` class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重构设计，将 `TestInterface` 改造成一个更基础的类，并改名为 `TestBase`。我们还可以将 `TEST` 宏内部声明的类中的数据成员移动到
    `TestBase` 类中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the new `setFailed` method, it no longer made sense to have an `mResult`
    data member. Instead, there’s an `mPassed` member, along with the `mName` member;
    both came from the `TEST` macro. It also seemed like a good idea to add some getter
    methods, especially now that there’s also an `mReason` data member. Altogether,
    each test can now store its name, remember whether it passed or not, and the reason
    for failure, if it failed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `setFailed` 方法后，保留 `mResult` 数据成员就不再有意义了。相反，有一个 `mPassed` 成员，以及 `mName`
    成员；这两个都来自 `TEST` 宏。添加一些获取方法似乎也是一个好主意，尤其是现在还有一个 `mReason` 数据成员。总的来说，每个测试现在可以存储其名称，记住它是否通过，以及失败的原因（如果失败的话）。
- en: 'Only a slight change is needed in the `getTests` function to refer to the `TestBase`
    class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getTests` 函数中，只需要进行细微的更改来引用 `TestBase` 类：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The rest of the changes simplify the `TEST` macro like this to remove the data
    members, which are now in the base class, and to inherit from `TestBase`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的更改简化了 `TEST` 宏，如下所示，以删除现在在基类中的数据成员，并从 `TestBase` 继承：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Checking to make sure everything builds and runs again shows that we are back
    to a running program with the same result as before. You’ll see this technique
    often with a refactor. It’s good to keep any functional changes to a minimum when
    refactoring and focus mostly on just getting back to the same behavior as before.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以确保一切构建并再次运行，这表明我们又回到了一个运行程序，其结果与之前相同。你将看到在重构时经常使用这种技术。在重构时，最好将任何功能更改保持在最低限度，并主要关注恢复到之前的行为。
- en: 'Now, we can make some changes that *will* affect observable behavior. We want
    to report what is happening while the test is running. For now, we’ll just send
    the output to `std::cout`. We’ll change this later in this chapter to avoid assuming
    the output destination. The first change is to include `iostream` in `Test.h`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进行一些将*确实*影响可观察行为的更改。我们想要报告测试运行时发生的事情。目前，我们将输出发送到 `std::cout`。我们将在本章的后面部分更改这一点，以避免假设输出目标。第一个更改是在
    `Test.h` 中包含 `iostream`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, change the `runTests` function to report the progress of the test being
    run, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `runTests` 函数修改为报告正在运行的测试进度，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The original `try/catch` remains unchanged. All we do is print some dashes for
    a separator and the name of the test. It’s probably a good idea to flush this
    line to the output right away. In the case that something happens later, at least
    the name of the test will be recorded. After the test is run, the test is checked
    to see whether it passed or not, and the appropriate message is displayed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `try/catch` 代码保持不变。我们只是打印一些破折号作为分隔符和测试的名称。立即将这一行输出到输出流中可能是一个好主意。如果之后发生某些事情，至少测试的名称将被记录。测试运行后，检查测试是否通过，并显示适当的消息。
- en: We’ll also change the test in `Creation.cpp` to throw something to make sure
    we get a failure. We no longer need to include `iostream` because it’s usually
    not a good idea to display anything from the test itself. You can display output
    from the test if you want to but any output in the test itself tends to mess up
    the reporting of the test results. When I sometimes need to display output from
    within a test, it’s usually temporary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将修改 `Creation.cpp` 中的测试，使其抛出异常以确保我们得到失败的结果。我们不再需要包含 `iostream`，因为这通常不是一个好主意，从测试本身显示任何内容。如果你想显示测试的输出，可以这样做，但测试本身中的任何输出往往会弄乱测试结果的报告。当我有时需要从测试内部显示输出时，这通常是临时的。
- en: 'Here is the test modified to throw an int:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是修改后抛出整数的测试：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Normally, you would write code that throws something other than a simple `int`
    value, but at this point, we just want to show what happens when something does
    get thrown.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会编写抛出除简单`int`值之外内容的代码，但在这个阶段，我们只想展示当确实抛出某些内容时会发生什么。
- en: 'Building and running it now shows the expected failure due to an unexpected
    exception:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建和运行它显示了预期的失败，因为出现了意外的异常：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can remove the `throw` statement from the test so that the body is completely
    empty and the test will now pass:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从测试中移除`throw`语句，使主体完全为空，这样测试现在就会通过了：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We don’t want to keep modifying the test for different scenarios. It’s time
    to add support for multiple tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望为不同的场景不断修改测试。是时候添加对多个测试的支持了。
- en: Enhancing the test declaration to support multiple tests
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强测试声明以支持多个测试
- en: 'While a single test works, trying to add another one does not build. This is
    what I tried to do in `Creation.cpp` by adding another test. One of the tests
    is empty and the second test throws an int. These are the two scenarios we were
    just trying to work with:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个测试可以工作，但尝试添加另一个测试却无法构建。这就是我在`Creation.cpp`中尝试添加另一个测试时所做的。其中一个测试是空的，第二个测试抛出一个整数值。这是我们刚刚试图处理的两种情况：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The failure is due to the `Test` class being declared twice, as well as the
    `run` method. The `TEST` macro declares a new global instance of the `Test` class
    each time it’s used. Each instance is called `test`. We don’t see the classes
    or the instances in the code because they are hidden by the `TEST` macro.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 失败是由于`Test`类被声明了两次，以及`run`方法。每次使用`TEST`宏时，它都会声明一个新的全局`Test`类实例。每个实例都称为`test`。我们看不到这些类或实例在代码中，因为它们被`TEST`宏隐藏了。
- en: 'We’ll need to modify the `TEST` macro so that it will generate unique class
    and instance names. And while we’re doing that, let’s also fix the name of the
    test itself. We don’t want all tests to have the name `"testCanBeCreated"`, and
    since the name will need to come from the test declaration, we’ll need to also
    modify the `TEST` macro to accept a string. Here is how the new `Creation.cpp`
    file should look:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`TEST`宏，使其能够生成唯一的类和实例名称。同时，我们也要修复测试本身的名称。我们不希望所有测试都使用名称`"testCanBeCreated"`，并且由于名称需要来自测试声明，我们还需要修改`TEST`宏以接受一个字符串。以下是新的`Creation.cpp`文件应该看起来像这样：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This lets us give sentence names to each test, instead of treating the name
    like a single-word function name. We still need to modify the `TEST` macro but
    it’s good to start with the intended usage first and then make it work.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以为每个测试赋予句子名称，而不是像处理单个单词的函数名称那样对待名称。我们仍然需要修改`TEST`宏，但最好先从预期的使用开始，然后再让它工作。
- en: For making unique class and instance names, we could just ask for something
    unique from the programmer, but the type name of the class and the instance name
    of that class really are details that the programmer writing tests shouldn’t need
    to worry about. Requiring a unique name to be supplied would only make the details
    visible. We could instead use a base name and add to it the line number where
    the test is declared to make both the class and instance names unique.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成唯一的类和实例名称，我们本可以直接要求程序员提供一些独特的东西，但类的类型名称和该类的实例名称实际上是一些编写测试的程序员不需要关心的细节。要求提供唯一的名称只会使这些细节变得可见。我们可以改用一个基本名称，并在其中添加测试声明的行号，以使类和实例名称都变得唯一。
- en: Macros have the ability to get the line number of the source code file where
    the macro is used. All we have to do is modify the resulting class and instance
    names by appending this line number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 宏有获取宏使用源代码文件行号的能力。我们只需要通过在生成的类和实例名称后附加这个行号来修改它们。
- en: It would be nice if this was easy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这很容易就好了。
- en: All the macros are handled by the preprocessor. It’s actually a bit more complicated
    than that but thinking in terms of the preprocessor is a good simplification.
    The preprocessor knows how to do simple text replacement and manipulation. The
    compiler never sees the original code that is written with the macro. The compiler
    instead sees the end result after the preprocessor is done.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有宏都由预处理器处理。实际上，这比那要复杂一些，但以预处理器为思考方式是一种很好的简化。预处理器知道如何进行简单的文本替换和操作。编译器从未看到使用宏编写的原始代码。编译器看到的只是预处理器处理后的最终结果。
- en: We will need two sets of macros declared in `Test.h`. One set will generate
    a unique class name, such as `Test7` if the `TEST` macro was used on line 7\.
    The other set of macros will generate a unique instance name, such as `test7`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Test.h` 中声明两组宏。一组将生成一个唯一的类名，例如如果第7行使用了 `TEST` 宏，则生成 `Test7` 这样的类名。另一组宏将生成一个唯一的实例名，例如
    `test7`。
- en: 'We need a set of macros because going from a line number to a concatenated
    result such as `Test7` requires multiple steps. If this is the first time you’ve
    seen macros used like this, it’s normal to find them confusing. Macros use simple
    text replacement rules that can seem like extra work for us at first. Going from
    a line number to a unique name requires multiple steps of text replacement that
    are not obvious. The macros look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一组宏，因为从行号到像 `Test7` 这样的连接结果需要多个步骤。如果你第一次看到宏以这种方式使用，发现它们令人困惑是正常的。宏使用简单的文本替换规则，起初可能看起来像是额外的劳动。从行号到唯一名称需要多个文本替换步骤，这些步骤并不明显。宏看起来是这样的：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each set needs three macros. The macro to use is the last in each set, `MERETDD_CLASS`
    and `MERETDD_INSTANCE`. Each of these will be replaced with the `relay` macro
    using the `__LINE__` value. The `relay` macro will see the real line number instead
    of `__LINE__` and the `relay` macro will then be replaced with the final macro
    and the line number it was given. The final macro will use the `##` operator to
    do the concatenation. I did warn you that it would be nice if this was easy. I’m
    sure this is one of the reasons so many programmers avoid macros. At least you’ve
    already made it through the most difficult usage of macros in this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每组需要三个宏。每组中要使用的宏是最后一个，即 `MERETDD_CLASS` 和 `MERETDD_INSTANCE`。这些都将被 `relay` 宏替换，使用
    `__LINE__` 的值。`relay` 宏将看到实际的行号而不是 `__LINE__`，然后 `relay` 宏将被替换为最终的宏和它所给的行号。最终的宏将使用
    `##` 操作符来进行连接。我确实警告过，如果这很容易那就好了。我确信这是许多程序员避免使用宏的原因之一。至少你已经通过了这本书中最难使用的宏。
- en: The end result will be, for example, `Test7` for the class name and `test7`
    for the instance name. The only real difference between these two sets of macros
    is that the class name uses a capital *T* for `Test` and the instance name uses
    a lowercase *t* for `test`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将是，例如，类名为 `Test7`，实例名为 `test7`。这两组宏之间唯一的真正区别是，类名使用大写 *T* 表示 `Test`，而实例名使用小写
    *t* 表示 `test`。
- en: The class and instance macros need to be added to `Test.h` right above the definition
    of the `TEST` macro that will need to use them. All of this works because, even
    though the `TEST` macro looks like it uses many source code lines, remember that
    each line is terminated with a backslash. This causes everything to end up on
    a single line of code. This way, all the line numbers will be the same each time
    the `TEST` macro is used and the line number will be different the next time it’s
    used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将类和实例宏添加到 `Test.h` 中，位于需要使用它们的 `TEST` 宏定义之上。所有这些工作都是因为，尽管 `TEST` 宏看起来像使用了多行源代码，但请记住，每一行都是以反斜杠结尾的。这导致所有内容最终都位于单行代码中。这样，每次使用
    `TEST` 宏时，所有行号都将相同，下一次使用时行号将不同。
- en: 'The new `TEST` macro looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `TEST` 宏看起来是这样的：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `MERETDD_CLASS` macro is used to declare the class name, declare the constructor,
    declare the type of the global instance, and scope the `run` method declaration
    to the class. All four of these macros will use the same line number because of
    the backslashes at the end of each line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERETDD_CLASS` 宏用于声明类名，声明构造函数，声明全局实例的类型，并将 `run` 方法声明的作用域限定在类中。这四个宏都将使用相同的行号，因为每个宏的末尾都有反斜杠。'
- en: The `MERETDD_INSTANCE` macro is used just once to declare the name of the global
    instance. It will also use the same line number as the class name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`MERETDD_INSTANCE` 宏仅使用一次来声明全局实例的名称。它也将使用与类名相同的行号。'
- en: 'Building the project and running now shows that the first test passes because
    it doesn’t really do anything and the second test fails because it throws the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目并现在运行显示，第一个测试通过，因为它实际上并没有做任何事情，而第二个测试失败，因为它抛出了以下错误：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output ends a bit abruptly and it’s time to fix that. We’ll add a summary
    next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结束得有些突然，现在是时候修复这个问题了。我们将添加一个总结。
- en: Summarizing the results
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结结果
- en: The summary can begin with a count of how many tests will be run. I thought
    about adding a running count for each test but decided against that because the
    tests are run in no particular order right now. I don’t mean that they will be
    run in a different order each time the testing application is run but they could
    be reordered if the code is changed and the project is rebuilt. This is because
    there is no fixed order when creating the final application that the linker will
    use between multiple `.cpp` compilation units. Of course, we would need tests
    spread across multiple files to see the reordering, and right now, all the tests
    are in `Creation.cpp`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总结可以从将要运行的测试数量开始。我曾考虑为每个测试添加一个运行计数，但最终决定不这样做，因为当前的测试没有特定的顺序。我的意思不是每次运行测试应用程序时都会以不同的顺序运行，但如果代码更改并且项目重新构建，它们可能会重新排序。这是因为创建最终应用程序时，链接器在多个`.cpp`编译单元之间没有固定的顺序。当然，我们需要将测试分散在多个文件中，以便看到重新排序，而现在，所有测试都在`Creation.cpp`中。
- en: The point is that the tests register themselves based on how the global instances
    get initialized. Within a single `.cpp` source file, there is a defined order,
    but there is no guaranteed order between multiple files. Because of this, I decided
    not to include a number next to each test result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是测试根据全局实例的初始化方式注册自己。在单个`.cpp`源文件中，有一个定义的顺序，但在多个文件之间没有保证的顺序。正因为如此，我决定不在每个测试结果旁边包含一个数字。
- en: We’ll keep track of how many tests passed and how many failed, and at the end
    of the `for` loop that runs all the tests, a summary can be displayed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟踪通过和失败的测试数量，并在运行所有测试的`for`循环结束时显示总结。
- en: As an additional benefit, we can also change the `runTests` function to return
    the count of how many tests failed. This will let the `main` function return the
    failed count too so that a script can test this value to see whether the tests
    passed or how many failed. An application exit code of zero will mean that nothing
    failed. Anything other than zero will represent a failed run and will indicate
    how many tests have failed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，我们还可以将`runTests`函数更改为返回失败的测试数量。这将允许`main`函数也返回失败计数，以便脚本可以测试此值以查看测试是否通过或失败了多少。应用程序退出代码为零表示没有失败。任何非零值都表示失败的运行，并将指示失败的测试数量。
- en: 'Here is the simple change to `main.cpp` to return the failed count:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`main.cpp`中的简单更改，以返回失败计数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, here is the new `runTests` function with the summary changes. The changes
    are described in three parts. All of this is a single function. Only the description
    is broken into three parts. The first part just displays the count of how many
    tests will be run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这是带有总结更改的新`runTests`函数。更改分为三个部分。所有这些都是一个函数。只有描述被分为三个部分。第一部分只是显示将要运行的测试数量：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the second part, we need to keep track of how many tests pass and how many
    fail, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们需要跟踪通过和失败的测试数量，如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in the third part, after looping through all the tests and counting how
    many passed and how many failed, we display a summary with the counts, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分中，在遍历所有测试并计算通过和失败的测试数量之后，我们显示一个带有计数的总结，如下所示：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running the project now shows an initial count, the individual test results,
    and a final summary, and you can also see the application exit code is `1` because
    of the failed test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行项目会显示初始计数、单个测试结果和最终总结，你还可以看到由于测试失败，应用程序退出代码是`1`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final line that displays the exit code is not actually part of the testing
    application. This is normally not shown when the application is run. It’s part
    of the development environment that I am using to write this code. You would normally
    be interested in the exit code if you were running the testing application from
    a script such as Python as part of an automated build script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 显示退出代码的最后一行实际上不是测试应用程序的一部分。通常在运行应用程序时不会显示它。它是编写此代码的开发环境的一部分。如果你从脚本（如Python）中运行测试应用程序作为自动化构建脚本的一部分，你通常会对退出代码感兴趣。
- en: We have one bit of cleanup still to do with the results. You see, right now,
    everything gets sent to `std::cout` and this assumption should be fixed so that
    the results can be sent to any output stream. The next section will do this cleanup.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一项清理工作要做，与结果有关。你看，现在，所有内容都发送到`std::cout`，这个假设应该得到修复，以便结果可以发送到任何输出流。下一节将完成此清理。
- en: Redirecting the output results
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向输出结果
- en: This is a simple edit that should not cause any real change to the application
    so far. Right now, the `runTests` function uses `std::cout` directly when displaying
    the results. We’re going to change this so that the `main` function will pass
    `std::cout` as an argument to `runTests`. Nothing will actually change because
    we’ll still be using `std::cout` for the results but this is a better design because
    it lets the testing application decide where to send the results, instead of the
    testing library.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的编辑，不会对到目前为止的应用程序造成任何实际变化。目前，`runTests` 函数在显示结果时直接使用 `std::cout`。我们将改变这一点，让
    `main` 函数将 `std::cout` 作为参数传递给 `runTests`。实际上不会有任何变化，因为我们仍然会使用 `std::cout` 来显示结果，但这是一个更好的设计，因为它允许测试应用程序决定将结果发送到何处，而不是测试库。
- en: By the testing library, I mean the `Test.h` file. This is the file that other
    applications will include in order to create and run tests. With the project we
    have so far, it’s a bit different because we’re writing tests to test the library
    itself. So, the whole application is just the `Test.h` file and the `tests` folder
    containing the testing application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的测试库是指 `Test.h` 文件。这是其他应用程序包含以创建和运行测试的文件。在我们目前的项目中，它有点不同，因为我们正在编写测试来测试库本身。因此，整个应用程序就是
    `Test.h` 文件和包含测试应用程序的 `tests` 文件夹。
- en: 'We first need to change `main.cpp` to include `iostream` and then pass `std::cout`
    to `runTests`, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要将 `main.cpp` 修改为包含 `iostream`，然后将 `std::cout` 传递给 `runTests`，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we no longer need to include `iostream` in `Test.h`, because it really
    doesn’t need any input and it doesn’t need to refer to `std::cout` directly. All
    it needs is to include `ostream` for the output stream. This could be the standard
    output, a file, or some other stream:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们不再需要在 `Test.h` 中包含 `iostream`，因为它实际上不需要任何输入，也不需要直接引用 `std::cout`。它只需要包含
    `ostream` 以支持输出流。这可以是标准输出、一个文件或任何其他流：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Most of the changes are to replace `std::cout` with a new parameter called
    `output`, like this in the `runTests` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数更改都是将 `std::cout` 替换为一个新的参数，称为 `output`，就像在 `runTests` 函数中这样：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not all of the changes are shown in the previous code. All you need to do is
    replace every use of `std::cout` with `output`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中并没有显示所有的更改。你所需要做的就是将所有使用 `std::cout` 的地方替换为 `output`。
- en: This was a simple change and does not affect the output of the application at
    all. In fact, it’s good to make changes like this that are isolated from other
    changes, just so the new results can be compared with previous results to make
    sure nothing unexpected has changed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的更改，根本不影响应用程序的输出。实际上，做出这样的独立更改是好事，这样就可以将新结果与之前的结果进行比较，以确保没有发生意外变化。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced macros and their ability to generate code based on the
    line number as a way to enable multiple tests. Each test is its own class with
    its own uniquely named global object instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了宏及其根据行号生成代码的能力，作为启用多个测试的一种方式。每个测试都是一个具有自己唯一命名全局对象实例的类。
- en: Once multiple tests were supported, then you saw how to track and report the
    results of each test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦支持了多个测试，你就看到了如何跟踪和报告每个测试的结果。
- en: The next chapter will use the build failures in this chapter to show you the
    first step in the TDD process. We’ve been following these process steps already
    without specifically mentioning them. You’ll learn more about the TDD process
    in the next chapter, and the way that the test library has been developed so far
    should start making more sense as you understand the reasons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将使用本章中的构建失败来展示 TDD 流程的第一步。我们已经遵循了这些流程步骤，但没有特别提及。你将在下一章中了解更多关于 TDD 流程的内容，以及测试库到目前为止是如何开发的，随着你理解这些原因，这些内容应该会变得更加有意义。
