- en: Improving the Performance of Your Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高代码性能
- en: In this chapter, we will learn how to speed up the execution of any C program.
    We will learn to keep the frequently used content in CPU registers, and we will
    learn how to take input faster from the user. We will also learn to apply loop
    unrolling in C programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何加快任何C程序的执行速度。我们将学习如何在CPU寄存器中保存频繁使用的内容，以及如何更快地从用户那里获取输入。我们还将学习如何在C程序中应用循环展开。
- en: 'The following are the recipes we will work through in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将要处理的菜谱：
- en: Using the `register` keyword in C code for better efficiency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C代码中使用`register`关键字以获得更好的效率
- en: Taking input faster in C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C中更快地获取输入
- en: Applying loop unrolling for faster results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用循环展开以获得更快的速度
- en: Let's begin with the first recipe.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个菜谱开始。
- en: Using the register keyword in C code for better efficiency
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C代码中使用`register`关键字以获得更好的效率
- en: The access time when using registers is quite a bit lower than that of accessing
    content from any memory variable. So, to take advantage of this, content that
    is frequently used in any program is kept in registers. The `register` keyword
    is used to indicate the content that needs to be kept in these registers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器时的访问时间比从任何内存变量中访问内容低得多。因此，为了利用这一点，任何程序中频繁使用的内容都保存在寄存器中。使用`register`关键字来指示需要保存在这些寄存器中的内容。
- en: In this recipe, we will find out the cost of renting a car for a specified distance.
    The car rent not only depends on the distance but also on the type of car, that
    is, whether the car has **air conditioning** (**AC**) or not. The rent of the
    AC car per kilometer, the rent of the non-AC car per kilometer, and the service
    tax percentage values are all stored in register variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将找出指定距离租车所需的费用。租车费用不仅取决于距离，还取决于车型，即汽车是否有**空调**（**AC**）。
- en: How to do it...
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps for finding total car rent for a specified distance with a specified
    car type using register variables are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器变量查找指定距离和指定车型汽车总租金的步骤如下：
- en: The user is asked to enter the distance of the planned journey.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入计划旅程的距离。
- en: The user is asked to specify the type of the car, that is, whether the car should
    have AC or not.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求指定汽车的类型，即汽车是否应该有空调。
- en: Two register variables are defined to indicate the rent per kilometer for the
    AC and non-AC car, respectively.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了两个寄存器变量，分别表示空调和非空调汽车的每公里租金。
- en: One more register variable is defined that is set to represent the service tax
    percentage.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了一个额外的寄存器变量，用于表示服务税百分比。
- en: On the basis of the type of the car chosen by the user, the distance value is
    multiplied by the respective register variable to find out the total amount.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户选择的车型，距离值乘以相应的寄存器变量以找出总金额。
- en: The service tax is computed and added to the total amount. The service tax percentage
    is accessed from the respective register variable.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务税被计算并加到总金额上。服务税百分比是从相应的寄存器变量中获取的。
- en: The total rent of the car is displayed on the screen.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汽车总租金显示在屏幕上。
- en: 'The program for computing the total rent of the car for the specified car type
    and journey length using the register variables is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用寄存器变量计算指定车型和行程长度的汽车总租金的程序如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The user is asked to specify how many kilometers the vehicle is required to
    be rented for. The value entered by the user is assigned to the `distance` variable.
    Thereafter, the user is asked to specify what kind of car they want to rent: an
    AC car or a non-AC car. The option entered by the user is assigned to the `car_type` variable. Three
    register variables are defined by the names `Acperkm`, `Nonacperkm`, and `servicetax`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被要求指定需要租用多少公里。用户输入的值被分配给`distance`变量。之后，用户被要求指定他们想要租用的车型：空调车或非空调车。用户输入的选项被分配给`car_type`变量。定义了三个寄存器变量，分别命名为`Acperkm`、`Nonacperkm`和`servicetax`。
- en: Because the register variables stay closer to the CPU and their access time
    is very low when compared to accessing content from memory variables, the register
    variables are used for those values that are frequently required in computation.
    The three register variables, `Acperkm`, `Nonacperkm`, and `servicetax`, are initialized
    to 3, 2, and 1, respectively, to indicate that the rate for an AC car is $3 per
    kilometer and that of a non-AC car is $2 per kilometer. The service tax is assumed
    to be 1% of the total amount.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为寄存器变量更靠近CPU，与从内存变量访问内容相比，它们的访问时间非常低，所以寄存器变量用于那些在计算中频繁需要的值。三个寄存器变量`Acperkm`、`Nonacperkm`和`servicetax`分别初始化为3、2和1，以表示AC车的费用是每公里3美元，非AC车的费用是每公里2美元。服务税假定为总金额的1%。
- en: String comparison is done to know the type of car that is specified by the user.
    If the type of car selected is an AC car, the values in the `distance` variable
    and the `Acperkm` register variable are multiplied.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过字符串比较来确定用户指定的车型。如果选定的车型是AC车，`distance`变量和`Acperkm`寄存器变量的值将被相乘。
- en: Similarly, if the type of car selected is a non-AC car, the values in the `distance` and
    `Nonacperkm` variables are multiplied together. The result of the multiplication
    is the total amount to be assigned to the `carRent` variable. To this total amount,
    a 1% service tax rate is added to find out the total rent. The total rent of the
    car for the specified distance and type of car is then displayed on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果选定的车型是非AC车，`distance`和`Nonacperkm`变量的值将被相乘。乘法的结果将被分配给`carRent`变量。然后，在这个总额上加上1%的服务税，以计算出总租金。然后，在屏幕上显示指定距离和车型下汽车的租金总额。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no errors appear on compilation, that means the `tourvehicle.c` program has successfully
    been compiled into an EXE file, `tourvehicle.exe`. On executing the file, the
    user is prompted to enter the number of kilometers for which the car is required
    on rent. The user will also be asked to specify the type of car that is required
    on rent. The program then displays the total rent of the car, as shown in the
    screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为没有在编译时出现错误，这意味着`tourvehicle.c`程序已成功编译成EXE文件，即`tourvehicle.exe`。在执行文件时，用户将被提示输入租车所需的公里数。用户还将被要求指定所需的车型。然后程序显示汽车的租金总额，如截图所示：
- en: '![](img/9fb9c91b-a0a1-4c7a-83b8-95b09bb6454a.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9fb9c91b-a0a1-4c7a-83b8-95b09bb6454a.png)'
- en: Figure 15.1
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1
- en: Voilà! We have successfully used register variables to speed up processing in
    C. Now let's move on to the next recipe!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用寄存器变量来加速C语言中的处理。现在让我们继续下一个菜谱！
- en: Taking input faster in C
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C语言中更快地获取输入
- en: In this recipe, we will learn to take input faster from the user. We will ask
    the user to enter a number and the entered number will be displayed on the screen.
    We will make use of the `getchar_unlocked()` function for this purpose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何从用户那里更快地获取输入。我们将要求用户输入一个数字，输入的数字将在屏幕上显示。为此，我们将使用`getchar_unlocked()`函数。
- en: The `getchar_unlocked()` function works similarly to `getchar()` function, with
    the difference that it is not thread-safe. As a result, it overlooks certain input
    constraints and so is quite a bit faster than `getchar()`. It is used for taking
    long input data in a situation where a single thread is being used for handling
    input and other streams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`getchar_unlocked()`函数与`getchar()`函数的工作方式类似，不同之处在于它不是线程安全的。因此，它忽略了某些输入约束，所以比`getchar()`快得多。它用于在仅使用单个线程处理输入和其他流的情况下获取长输入数据。'
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps for taking a number from the user using a faster input approach are
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速输入方法从用户那里获取数字的步骤如下：
- en: The user is asked to enter a number.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入一个数字。
- en: The number that will be entered by the user is accepted by the `getchar_unlocked()`
    function. Only one digit at a time is accepted by this function.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将要输入的数字将通过`getchar_unlocked()`函数接受。该函数一次只接受一个数字。
- en: The value entered by the user is first checked to ensure that it is a digit
    only. If it is not, the user is asked to re-enter the value.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入的值首先会被检查以确保它仅是一个数字。如果不是，用户将被要求重新输入值。
- en: If the value entered by the user is a digit, its ASCII value is saved in the
    variable. This is because `getchar_unlocked()` assigns the ASCII value of the
    entered value to the variable.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入的值是一个数字，它的ASCII值被保存在变量中。这是因为`getchar_unlocked()`将输入值的ASCII值赋给变量。
- en: From the ASCII of the entered value, 48 is subtracted to convert it into the
    actual digit that the user has entered.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入值的ASCII码中减去48，将其转换为用户实际输入的数字。
- en: If the digit is the first digit entered by the user, then it is simply assigned
    to another variable. But if it is not the first digit, then the existing digit
    in the variable is multiplied by 10 and the new digit is then added to the variable.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的数字是用户输入的第一个数字，那么它将被简单地赋给另一个变量。但如果它不是第一个数字，那么变量中现有的数字乘以10，然后将新数字加到变量上。
- en: '*Steps 2* through *7* are repeated for every digit entered by the user until
    the user presses the *Enter* key.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*步骤2*至*7*会重复进行，直到用户按下*Enter*键，对用户输入的每一位数字进行操作。'
- en: The number in the variable is the actual number entered by the user and, hence,
    is displayed on the screen.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量中的数字是用户实际输入的数字，因此显示在屏幕上。
- en: 'The program for entering a number using a fast input technique is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速输入技术输入数字的程序如下：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The user is asked to enter a number. A user-defined `getdata()` function is invoked
    and the value returned by the function is assigned to the `numb` variable, which
    in return is then displayed on the screen. The `getdata` function will keep asking
    for the digits of the number and will return the number when the *Enter* key is
    pressed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被要求输入一个数字。调用用户定义的`getdata()`函数，并将函数返回的值赋给`numb`变量，然后该变量被显示在屏幕上。`getdata`函数会不断请求输入数字的每一位，并在按下*Enter*键时返回该数字。
- en: Let's assume that the user wants to enter `20`. Within the `getdata` function,
    the `getchar_unlocked()` function is invoked. So, on entering the first digit,
    2 (of the number 20), it will be assigned to the `cdigit` variable, which is of
    the character data type. The ASCII value of 2 is 50, so the value 50 is actually
    assigned to the `cdigit` variable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户想要输入`20`。在`getdata`函数中，调用`getchar_unlocked()`函数。因此，在输入第一个数字2（数字20的一部分）时，它将被赋给`cdigit`变量，该变量是字符数据类型。2的ASCII值是50，所以实际上将50赋给`cdigit`变量。
- en: Before proceeding further, we ensure that the value entered by the user is a
    digit, and not a character or some other symbol. If the user enters something
    other than a digit, the `getchar_unlocked()` function is again invoked, asking
    the user to enter a valid digit. If the value entered is a digit, then 48 is subtracted
    from its ASCII value to convert it to its actual value. This is because the ASCII
    value of 2 is 50; on subtracting 48 from 50, the result will be 2, which is the
    actual digit that was entered by the user. The value of 2 is assigned to the `cnumb`
    variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们确保用户输入的值是一个数字，而不是字符或其他符号。如果用户输入的不是数字，则再次调用`getchar_unlocked()`函数，要求用户输入有效的数字。如果输入的值是数字，则从其ASCII值中减去48以将其转换为实际值。这是因为2的ASCII值是50；从50中减去48，结果是2，这是用户实际输入的数字。2的值被赋给`cnumb`变量。
- en: Since the next digit of the number 20 is 0, the `getchar_unlocked ()` function
    is invoked and the value 0 is assigned to the `cdigit` variable. Again, it is
    checked that the value entered by the user is a digit and nothing else. The ASCII
    value of 0 is 48\. From the ASCII value of 0, the value 48 is subtracted to make
    its value 0\. The current value in `cnumb` is 2, which is then multiplied by 10
    and the value of `cdigit` is added to the result. The result of this computation
    will be 20 and it is assigned to the `cnumb` variable. The value in the `cnumb`
    variable is returned to the main function to be displayed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数字20的下一位是0，因此调用`getchar_unlocked()`函数，并将值0赋给`cdigit`变量。再次检查用户输入的值是否为数字，而不是其他。0的ASCII值是48。从0的ASCII值中减去48，使其值变为0。`cnumb`变量中的当前值是2，然后将其乘以10，并将`cdigit`的值加到结果中。这次计算的结果将是20，并将其赋给`cnumb`变量。`cnumb`变量中的值返回到主函数以显示。
- en: In short, whatever digit is entered by the user, its ASCII value is assigned
    to the variable and the numerical value 48 is subtracted from the ASCII value
    of the digit to convert it into the actual digit that was entered by the user.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，无论用户输入的是哪个数字，其ASCII值都会被分配给变量，并从该数字的ASCII值中减去数值48，以将其转换为用户实际输入的数字。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `fastinp.c` program has successfully
    been compiled into an EXE file, `fastinp.exe`. On executing the file, the user
    is prompted to enter a number. The number is accepted using a fast input technique.
    After entering all the digits of the number, when the user presses the *Enter*
    key, the entered number is displayed on the screen as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为没有错误出现在编译过程中，这意味着`fastinp.c`程序已经成功编译成EXE文件，`fastinp.exe`。在执行文件时，用户被提示输入一个数字。该数字使用快速输入技术接受。在输入所有数字后，当用户按下*Enter*键时，输入的数字将显示在屏幕上，如下面的截图所示：
- en: '![](img/6fde6641-6ea1-4041-8752-3f6cd84bb150.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fde6641-6ea1-4041-8752-3f6cd84bb150.png)'
- en: Figure 15.2
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2
- en: Voilà! We have successfully configured faster input of numbers in C. Now let's
    move on to the next recipe!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà！我们已经成功配置了C语言中数字的快速输入。现在让我们继续下一个菜谱！
- en: Applying loop unrolling for faster results
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用循环展开以获得更快的速度
- en: In this recipe, we will learn to print the sum of a sequence of numbers from
    1 to a limit entered by the user using the loop unrolling technique. Loop unrolling
    means reducing or removing the loops from the program to reduce overheads applied
    while running the loops. Basically, for running a loop, the operating system has
    to manage two overheads – the first overhead is to maintain the count of the loop
    and the second overhead is to do conditional branching. Loop unrolling helps in
    avoiding these two overheads. Let's see how.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用循环展开技术打印用户输入限制的从1到限制的数字序列之和。循环展开意味着减少或从程序中移除循环以减少运行循环时的开销。基本上，为了运行一个循环，操作系统必须管理两个开销——第一个开销是维护循环计数，第二个开销是进行条件分支。循环展开有助于避免这两个开销。让我们看看它是如何做到的。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps for finding the sum of the first *n* sequence of numbers using the
    loop unrolling technique are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环展开技术求前*n*个数字序列之和的步骤如下：
- en: The `sum` variable in which the addition of sequence numbers will be stored
    is initialized to 0.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用于存储序列数加和的`sum`变量初始化为0。
- en: The user is asked to enter the limit up to which the sum of the sequence of
    numbers is desired. The value entered by the user is assigned to the `limit` variable.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入一个限制，即希望求和的数字序列的上限。用户输入的值被分配给`limit`变量。
- en: We need to find the number between 9 to 1 that perfectly divides the value in
    the `limit` variable. To find this, we set a `for` loop to execute from 9 to 1.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找到一个在9到1之间的数字，它能完美地整除`limit`变量中的值。为了找到这个数字，我们设置一个从9到1的`for`循环。
- en: Within the `for` loop, the value in the `limit` variable is divided by the `for`
    loop variable.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环中，`limit`变量中的值被除以`for`循环变量。
- en: If the number in the `limit` variable is divisible by the `for` loop variable,
    the `for` loop will break.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`limit`变量中的数字可以被`for`循环变量整除，则`for`循环将中断。
- en: If the number in the `limit` variable is not divisible by the `for` loop variable,
    the next iteration of the loop is executed with a reduced value, that is, with
    the value of 8\. The steps are repeated until the value in the `limit` variable
    is perfectly divisible by the `for` loop variable.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`limit`变量中的数字不能被`for`循环变量整除，则循环将使用减少的值执行下一次迭代，即使用值8。重复这些步骤，直到`limit`变量中的值能被`for`循环变量完美整除。
- en: Once we get the integer by which the limit is divisible, we reduce the number
    of `for` loops by that integer, that is, the increment of the `for` loop is set
    to that integer value.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们得到了可以整除limit的整数，我们就将`for`循环的数量减少那个整数，即，将`for`循环的增量设置为那个整数值。
- en: Within the `for` loop, a `while` loop is used that adds the sequence of numbers
    into the `sum` variable.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环中，使用了一个`while`循环，该循环将数字序列添加到`sum`变量中。
- en: Finally, the addition of the sequence of numbers in the `sum` variable is displayed
    on the screen.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`sum`变量中数字序列的加和显示在屏幕上。
- en: 'The program for printing the sum of a sequence of numbers using the loop unrolling
    technique is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环展开技术打印数字序列和的程序如下：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's go behind the scenes to understand the code better.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解代码，以更好地理解它。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program finds the sum of sequence numbers from 1 up to the limit entered
    by the user. The user is asked to enter the limit, and the value entered by the
    user is assigned to the `limit` variable. For adding the sequence numbers, we
    will make use of a `for` loop. To do loop unrolling or to reduce the number of
    iterations of the loop, we find the integer by which the limit can be divided.
    That is, we divide the value in the `limit` variable by integers from 9 to 1\.
    Once we get the integer by which the limit is divisible, we reduce the number
    of `for` loops by that integer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序找出用户输入的上限值以内的序列数字之和。程序会要求用户输入上限值，用户输入的值被分配给 `limit` 变量。为了加和序列数字，我们将使用一个
    `for` 循环。为了进行循环展开或减少循环的迭代次数，我们找到可以整除上限的整数。也就是说，我们将 `limit` 变量中的值除以从 9 到 1 的整数。一旦我们得到可以整除上限的整数，我们就减少
    `for` 循环的次数。
- en: Let's assume that the user enters a limit of 40, which is assigned to the `limit` variable. A
    `for` loop is set to run from the values 9 to 1, and every value from 9 to 1 will
    be used to try to divide the value in the `limit` variable. On any division, if
    the remainder appears as 0, the `for` loop will break; else, the next iteration
    will execute with the decreased value. Currently, the value in the `limit` variable
    is 40 and the value of `i` in the first iteration is 9\. The remainder of dividing
    40 by 9 is a non zero value, so the next iteration of the `for` loop will begin
    with the next decreased value, 8.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户输入了一个上限值 40，并将其分配给 `limit` 变量。设置一个 `for` 循环从 9 到 1 运行，并且从 9 到 1 的每个值都将用来尝试除以
    `limit` 变量中的值。在任何除法中，如果余数为 0，则 `for` 循环将中断；否则，将执行下一个迭代，并使用减少的值。目前，`limit` 变量中的值是
    40，第一次迭代的 `i` 值是 9。40 除以 9 的余数是一个非零值，所以 `for` 循环的下一个迭代将从下一个减少的值开始，即 8。
- en: Because, on dividing 40 by 8, you get a remainder of 0, the `for` loop will
    break and the control will jump to the statement immediately after the `for` loop.
    The value of `i` at that time is 8, so the value of 8 is assigned to the `incr` variable. That
    is, the `for` loop will increment by a value of 8\. It also means that we are
    applying loop unrolling by reducing the iterations of the `for` loop by 8 times.
    In other words, the `for` loop will be set to run from 1 until the limit, which
    is 40, with an increment of 8 after every iteration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，当 40 除以 8 时，你得到一个余数为 0，`for` 循环将中断，控制将跳转到 `for` 循环后的下一个语句。那时的 `i` 值是 8，所以
    8 的值被分配给 `incr` 变量。也就是说，`for` 循环将以 8 的增量增加。这也意味着我们通过减少 `for` 循环的迭代次数 8 倍来应用循环展开。换句话说，`for`
    循环将被设置为从 1 运行到上限 40，每次迭代后增加 8。
- en: In the first iteration, the value of `i` is 1\. The `sum` variable, in which
    the addition of the sequence of numbers will be computed, is initialized to 0\.
    The value of `i` is added to the `sum` variable. As said earlier, the next iteration
    of the `for` loop will increment the value of `i` by 8\. So, within the `for`
    loop, a `while` loop is used. Within the `while` loop, a variable, `x`, is used
    that executes from 0 to the value of the `incr` variable (that is, until the value
    of 8). In other words, the `while` loop will add the sequence of numbers from
    1 to 8 into the `sum` variable.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`i` 的值为 1。用于计算数字序列加和的 `sum` 变量被初始化为 0。`i` 的值被加到 `sum` 变量上。正如之前所说的，`for`
    循环的下一个迭代将 `i` 的值增加 8。所以，在 `for` 循环内部，使用了一个 `while` 循环。在 `while` 循环内部，使用了一个变量 `x`，它从
    0 执行到 `incr` 变量的值（即，直到 8 的值）。换句话说，`while` 循环将把从 1 到 8 的数字序列加到 `sum` 变量中。
- en: Once the sum of the first eight values of the sequence of numbers is computed
    and assigned to the `sum` variable, the next iteration of the `for` loop will
    begin with the value of `i` incremented to 9\. Again within the `for` loop, the
    `while` loop will execute to compute the sum of the sequence of numbers from 9
    to 16\. Again, the next iteration of the `for` loop will increase the value of
    `i` to 17\. The process continues until the `for` loop completes. In short, the
    `for` loop is unrolled to the value assigned to the `incr` variable. Finally,
    the sum of the sequence of numbers is displayed on the screen.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算并分配了数字序列前八个值的总和到`sum`变量，`for`循环的下一个迭代将从`i`的值增加至9开始。再次在`for`循环内，`while`循环将执行以计算从9到16的数字序列的总和。同样，`for`循环的下一个迭代将`i`的值增加到17。这个过程会一直持续到`for`循环完成。简而言之，`for`循环被展开到`incr`变量所赋的值。最后，数字序列的总和在屏幕上显示。
- en: 'The program is compiled using GCC, as shown in the following screenshot. Because
    no error appears on compilation, that means the `loopunrolling.c` program has
    successfully been compiled into an EXE file, `loopunrolling.exe`. On executing
    the file, the user is prompted to enter the limit up to which the sum of the sequence
    of numbers is desired. The program will not only print the sum of the sequence
    of numbers but will also print how many loop iterations it took for the sum to
    be computed, as shown in the following screenshot:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用GCC编译，如下面的截图所示。因为没有错误出现在编译过程中，这意味着`loopunrolling.c`程序已经成功编译成EXE文件，名为`loopunrolling.exe`。在执行文件时，用户将被提示输入想要计算数字序列总和的上限。程序不仅会打印数字序列的总和，还会打印出计算总和所需的循环迭代次数，如下面的截图所示：
- en: '![](img/e620d676-79ab-408a-8c1e-b2142318be78.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/e620d676-79ab-408a-8c1e-b2142318be78.png)'
- en: Figure 15.3
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3
- en: Voilà! We have successfully executed loop unrolling to generate a faster result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Voilà! 我们已经成功执行了循环展开以生成更快的结果。
