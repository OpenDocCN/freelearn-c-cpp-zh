- en: Architectural Styles
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 架构风格
- en: This chapter introduces the different architectural approaches or styles. Each
    section will discuss a different approach to designing software with its pros
    and cons, as well as describe when and how to apply it to reap its benefits. We'll
    begin this chapter by comparing stateful and stateless architectures. Next, we'll
    go from monolith systems, through various types of service-oriented designs, all
    the way to microservices. Then, we'll start to look at architectural styles from
    different angles by describing event-based systems, layered systems, and finally,
    modular designs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了不同的架构方法或风格。每个部分都将讨论设计软件的不同方法及其优缺点，并描述何时以及如何应用它以获得其好处。我们将从比较有状态和无状态架构开始本章。接下来，我们将从单体系统，通过各种类型的面向服务的设计，一直到微服务。然后，我们将开始从不同角度描述架构风格，包括事件驱动系统、分层系统，最后是模块化设计。
- en: 'Once you have completed this chapter, you''ll be familiar with the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将熟悉以下主题：
- en: Deciding between stateful and stateless approaches
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有状态和无状态之间做出决定
- en: Understanding monoliths—why they should be avoided, and recognizing exceptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单体系统——为什么应该避免它们，并识别例外情况
- en: Understanding services and microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务和微服务
- en: Exploring event-based architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索基于事件的架构
- en: Understanding layered architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解分层架构
- en: Learning module-based architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模块化架构
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to know what a software service is and be able to read code in
    C++11.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道软件服务是什么，并且能够阅读C++11中的代码。
- en: 'The code from this chapter can be found at the following GitHub page: [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub页面找到：[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter02)。
- en: Deciding between stateful and stateless approaches
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在有状态和无状态之间做出决定
- en: Stateful and stateless are two opposite ways to write software, each with their
    own pros and cons.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态和无状态是编写软件的两种相反的方式，各有其优缺点。
- en: As the name suggests, stateful software's behavior depends on its internal state.
    Let's take a web service, for instance. If it remembers its state, the consumer
    of the service can send less data in each request, because the service remembers
    the context of those requests. However, saving on the request size and bandwidth
    has a hidden cost on the web service's side. If the user sends many requests at
    the same time, the service now has to synchronize its work. As multiple requests
    could change the state, at the same time, not having synchronization could lead
    to data races.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，有状态软件的行为取决于其内部状态。让我们以网络服务为例。如果它记住了自己的状态，服务的消费者可以在每个请求中发送更少的数据，因为服务记住了这些请求的上下文。然而，在请求大小和带宽上节省的同时，网络服务的一方面隐藏了成本。如果用户同时发送多个请求，服务现在必须同步其工作。由于多个请求可能同时更改状态，没有同步可能导致数据竞争。
- en: If the service was stateless, however, then each request coming to it would
    need to contain all the data needed to process it successfully. This means that
    the requests would get bigger and use up more bandwidth, but on the other hand,
    it would allow for better performance and scaling of the service. If you're familiar
    with functional programming, you would probably find stateless services intuitive.
    Processing each request can be understood as a call to a pure function. In fact,
    many of the advantages that stateless programming provides stem from its functional
    programming roots. Mutable state is the enemy of concurrent code. Functional programming
    relies on immutable values, even if this means making copies instead of modifying
    existing objects. Thanks to this, each thread can work independently and no data
    races are possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果服务是无状态的，那么每个发送到它的请求都需要包含处理它所需的所有数据。这意味着请求会变得更大，使用更多的带宽，但另一方面，它将允许更好的性能和服务的扩展。如果您熟悉函数式编程，您可能会发现无状态服务很直观。处理每个请求可以被理解为对纯函数的调用。事实上，无状态编程提供的许多优势都源于其函数式编程的根基。可变状态是并发代码的敌人。函数式编程依赖于不可变的值，即使这意味着复制而不是修改现有对象。由于这个原因，每个线程可以独立工作，不可能发生数据竞争。
- en: Since there are no race conditions, no locks are required as well, which can
    be an enormous boost in terms of performance. No locks also mean that you will
    no longer need to deal with deadlocks. Having pure functions means that your code
    will be easier to debug, too, since you don't have any side effects. Not having
    side effects, in turn, is also helpful for compilers, as optimizing code without
    side effects is a much easier task and can be performed more aggressively. Yet
    another benefit of writing code in a functional manner is that the sources you
    write tend to be more terse and expressive, especially when compared to code that
    heavily depends on the **Gang of Four** (**GoF**) design patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有竞争条件，也不需要锁，这在性能方面可以带来巨大的提升。没有锁也意味着您将不再需要处理死锁。拥有纯函数意味着您的代码也更容易调试，因为您没有任何副作用。没有副作用反过来也有助于编译器，因为优化没有副作用的代码是一个更容易的任务，可以更积极地执行。以函数式方式编写代码的另一个好处是，您编写的源代码往往更简洁和表达力强，特别是与严重依赖**四人帮**（**GoF**）设计模式的代码相比。
- en: This doesn't necessarily mean that if bandwidth is not an issue, you should
    always go with stateless. Those decisions can be made on many levels, from single
    classes or functions to whole applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不一定意味着如果带宽不是问题，您应该总是选择无状态。这些决定可以在许多层面上进行，从单个类或函数到整个应用程序。
- en: Take classes, for example. If you're modeling, say, a `Consultant`, it makes
    sense that the class would contain fields such as the consultant's name, contact
    data, hourly rate, current and past projects, and whatnot. It is natural for it
    to be stateful. Now, imagine that you need to calculate the pay they receive for
    their work. Should you create a `PaymentCalculator` class? Should you add a member
    or a free function to calculate this? If you go with the class approach, should
    you pass a `Consultant` as a constructor parameter or a method argument? Should
    the class have properties such as allowances?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以类为例。如果您正在建模，比如一个`Consultant`，那么类中包含诸如顾问的姓名、联系方式、小时费率、当前和过去的项目等字段是有意义的。它是自然而然地有状态的。现在，想象一下，您需要计算他们的工作所得。您应该创建一个`PaymentCalculator`类吗？您应该添加一个成员函数还是自由函数来计算这个？如果您选择类的方法，您应该将`Consultant`作为构造函数参数还是方法参数传递？类是否应该具有津贴等属性？
- en: 'Adding a member function to calculate the pay would break the **Single Responsibility
    Principle** (**SRP)**, as now the class would then have two responsibilities:
    calculating the pay and storing the consultant''s data (state). This means introducing
    a free function or a separate class for this purpose should be preferred to having
    such hybrid classes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个成员函数来计算薪水会违反**单一责任原则**（**SRP**），因为现在该类将有两个责任：计算薪水和存储顾问的数据（状态）。这意味着引入一个自由函数或一个单独的类来实现这个目的应该优于拥有这样的混合类。
- en: Should there be a state in such a class in the first place? Let's discuss the
    different approaches to our `PaymentCalculator` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的类首先应该有状态吗？让我们讨论一下我们的`PaymentCalculator`类的不同方法。
- en: 'One approach would be to expose the properties required for calculation purposes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是公开用于计算目的所需的属性：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach has two cons. The first is that it's not thread-safe; a single
    instance of such a `PaymentCalculator` class cannot be used in multiple threads
    without locks. The second is that once our calculations become more complicated,
    the class will probably start duplicating more fields from our `Consultant` class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个缺点。第一个是它不是线程安全的；这样的`PaymentCalculator`类的单个实例在没有锁的情况下不能在多个线程中使用。第二个是一旦我们的计算变得更加复杂，该类可能会开始从我们的`Consultant`类中复制更多字段。
- en: 'To eliminate the duplication, we could rework our class to store a `Consultant`
    instance like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除重复，我们可以重新设计我们的类来存储一个`Consultant`实例，就像这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that since we cannot rebind references easily, we're using a helper class
    from the **Guideline Support Library** (**GSL**) to store a rebindable pointer
    in a wrapper that automatically ensures we're not storing a null value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们不能轻松地重新绑定引用，我们正在使用**指南支持库**（**GSL**）中的一个辅助类来存储可重新绑定的指针，该辅助类会自动确保我们不存储空值。
- en: 'This approach still has the disadvantage of not being thread-safe. Can we do
    any better? It turns out that we can make the class thread-safe by making it stateless:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仍然有不是线程安全的缺点。我们能做得更好吗？事实证明，我们可以通过使其无状态来使类线程安全：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If there is no state to manage, it doesn't really matter if you decide to create
    free functions (perhaps in a distinct namespace) or group them as static functions
    of a class, as we did in the preceding snippet. In terms of classes, it's useful
    to distinguish between value (entity) types and operation types, as mixing them
    can lead to SRP violations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有状态需要管理，那么您决定创建自由函数（可能在不同的命名空间中）还是将它们作为类的静态函数分组，就不是很重要，就像我们在前面的片段中所做的那样。在类方面，有必要区分值（实体）类型和操作类型，因为混合它们可能导致SRP违规。
- en: Stateless and stateful services
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态和有状态的服务
- en: The same principles that we discussed for classes can be mapped to higher-level
    concepts, for instance, microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论类的相同原则可以映射到更高级别的概念，例如微服务。
- en: What does a stateful service look like? Let's take FTP as an example. If it's
    not anonymous, it requires the user to pass a username and password to create
    a session. The server stores this data to identify the user as still connected,
    so it's constantly storing state. Each time the user changes the working directory,
    the state gets updated. Each change done by the user is reflected as a change
    of state, even when they disconnect. Having a stateful service means that depending
    on the state, you can be returned different results for two identically looking
    `GET` requests. If the server loses the state, your requests can even stop processing
    correctly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态服务是什么样的？让我们以FTP为例。如果不是匿名的，它需要用户传递用户名和密码来创建会话。服务器存储这些数据以识别用户仍然连接，因此它不断地存储状态。每次用户更改工作目录时，状态都会更新。用户所做的每个更改都会反映为状态的更改，即使他们断开连接也是如此。拥有有状态的服务意味着根据状态，对于两个看起来相同的`GET`请求，可以返回不同的结果。如果服务器丢失状态，您的请求甚至可能停止正确处理。
- en: Stateful services can also have issues with incomplete sessions or unfinished
    transactions and added complexity. How long should you keep the sessions open?
    How can you verify whether the client has crashed or disconnected? When should
    we roll back any changes made? While you can come up with answers to those questions,
    it's usually easier to rely on the consumers of your service communicating with
    it in a dynamic, "intelligent" way. Since they'll be maintaining some kind of
    state on their own, having a service that also maintains the state is not only
    unnecessary but often wasteful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的服务也可能存在不完整的会话或未完成的事务以及增加的复杂性。会话应该保持多久？如何验证客户端是否崩溃或断开连接？我们何时应该回滚任何更改？虽然您可以回答这些问题，但通常更容易依赖服务的消费者以一种动态的“智能”方式与其进行通信。由于他们将自己维护某种状态，因此拥有一个也维护状态的服务不仅是不必要的，而且通常是浪费的。
- en: Stateless services, as the REST ones described later in the book, take the opposite
    approach. Each request must contain all the data required in order for it to be
    successfully processed, so two identical idempotent requests (such as `GET`) will
    cause identical replies. This is assuming the data stored on the server doesn't
    change, but data is not necessarily the same thing as state. All that matters
    is that each request is self-contained.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态服务，如本书后面描述的REST服务，采用相反的方法。每个请求必须包含处理请求所需的所有数据，以便成功处理，因此两个相同的幂等请求（如`GET`）将导致相同的回复。这是在假设服务器上存储的数据不会改变的情况下，但数据不一定等同于状态。重要的是每个请求都是自包含的。
- en: Statelessness is fundamental in modern internet services. The HTTP protocol
    is stateless, while many service APIs, for example, Twitter's, are stateless as
    well. REST, which Twitter's API relies on, is designed to be functionally stateless.
    The whole concept behind this acronym, **Representational State Transfer** (**REST**),
    carries the notion that all the state required for processing the request must
    be transferred within it. If this is not the case, you can't say you have a RESTful
    service. There are, however, some exceptions to the rule, driven by practical
    needs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态性在现代互联网服务中是基本的。HTTP协议是无状态的，而许多服务API，例如Twitter的，也是无状态的。REST，Twitter的API依赖的协议，旨在实现功能上的无状态。这个缩写背后的整个概念，**表现层状态转移**（**REST**），传达了请求处理所需的所有状态必须在其中传输的概念。如果不是这种情况，你就不能说你有一个符合REST原则的服务。然而，由于实际需求，也有一些例外情况。
- en: If you're building an online store, you probably want to store information pertaining
    to your customers, such as their order history and shipping addresses. The client
    on the customer's side probably stores an authentication cookie, while the server
    will probably store some user data in a database. The cookie replaces our need
    for managing a session, as it'd be done in a stateful service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个在线商店，你可能希望存储与客户相关的信息，如他们的订单历史和送货地址。客户端可能会存储身份验证cookie，而服务器可能会在数据库中存储一些用户数据。cookie取代了我们在有状态服务中管理会话的需求。
- en: 'Keeping sessions on the server side is a bad approach for services for several
    reasons: they add a lot of complexity that could be avoided, they make bugs harder
    to replicate, and most importantly, they don''t scale. If you''d want to distribute
    the load to another server, chances are you''d have trouble replicating the sessions
    with the load and synchronizing them between servers. All session information
    should be kept on the client''s side.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将会话保留在服务器端是服务的不良方法，原因有几个：它们增加了许多可以避免的复杂性，使错误更难复制，最重要的是，它们不具备可伸缩性。如果你想将负载分布到另一台服务器上，很可能会遇到在负载和服务器之间复制会话以及同步它们的困难。所有会话信息都应该保存在客户端。
- en: This means that if you wish to have a stateful architecture, you need to have
    a good reason to. Take the FTP protocol, for instance. It has to replicate the
    changes both on the client side and server side. The user only authenticates to
    a single, specific server, in order to perform single-stated data transfers. Compare
    this with services such as Dropbox, where the data is often shared between users
    and the file access is abstracted away through an API, to see why a stateless
    model would suit this case better.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你希望有一个有状态的架构，你需要有一个很好的理由。以FTP协议为例。它必须在客户端和服务器端复制更改。用户只需要对一个特定的服务器进行身份验证，以执行单状态数据传输。将其与Dropbox等服务进行比较，其中数据通常在用户之间共享，并且文件访问是通过API抽象的，就可以看出无状态模型更适合这种情况。
- en: Understanding monoliths—why they should be avoided, and recognizing exceptions
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单体应用——为什么应该避免，并识别例外情况
- en: The simplest architectural style in which you can develop your application is
    a monolithic one. This is why many projects are started using this style. A monolithic
    application is just one big block, meaning that functionally distinguishable parts
    of the application, such as dealing with I/O, data processing, and the user interface,
    are all interwoven instead of being in separate architectural components. Another
    notable example of this architectural style is the Linux kernel. Note that the
    kernel being monolithic does not stop it from being modular.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开发应用程序的最简单的架构风格是单体架构。这就是为什么许多项目都是以这种风格开始的原因。单体应用程序只是一个大块，这意味着应用程序的功能可区分部分（如处理I/O、数据处理和用户界面）都是交织在一起，而不是在单独的架构组件中。
- en: It can be easier to deploy such a monolithic application than a multi-component
    one as there is simply one thing that needs to be deployed. It can also be easier
    to test, as end-to-end testing just requires that you launch a single component.
    Integration is easier too since, as well as scaling your solution, you can just
    add more instances behind a load balancer. With all those advantages, why would
    anyone dread this architectural style? It turns out that despite those advantages,
    there are also many drawbacks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 部署这样的单体应用可能比多组件应用更容易，因为只需要部署一个东西。测试也可能更容易，因为端到端测试只需要启动一个单一组件。集成也更容易，因为除了扩展解决方案，你只需要在负载均衡器后面添加更多实例。尽管有这些优势，为什么会有人对这种架构风格感到畏惧呢？事实证明，尽管有这些优势，也存在许多缺点。
- en: The scalability offered sounds nice in theory, but what if your application
    has modules with different resource requirements? How about needing to scale just
    one module from your application? The lack of modularity, an inherent property
    of monolithic systems, is the source of many flaws associated with this architecture.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上提供的可伸缩性听起来不错，但如果你的应用程序具有不同资源需求的模块怎么办？如果只需要扩展应用程序中的一个模块怎么办？单体系统固有的缺乏模块化是与这种架构相关的许多缺陷的根源。
- en: What's more, the longer you develop a monolithic application, the more problems
    you'll have in maintaining it. It's a challenge to keep the internals of such
    an application loosely coupled, as it's so easy to just add yet another dependency
    between its modules. As such an application grows, it becomes harder and harder
    to understand it, so the development process will most probably slow down over
    time because of the added complexity. It can also be hard to maintain **Design-Driven
    Development**'s (**DDD**) bounded contexts when developing monoliths.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你开发单片应用程序的时间越长，你在维护它时遇到的问题就越多。保持这样一个应用程序内部的松耦合是一个挑战，因为很容易在其模块之间添加另一个依赖。随着这样一个应用程序的增长，理解它变得越来越困难，因此由于增加的复杂性，开发过程很可能会随着时间的推移而变得越来越慢。在开发单片应用程序时，也很难维护**设计驱动开发**（**DDD**）的边界上下文。
- en: Having one big application has drawbacks regarding the deployment and execution
    sides as well. It will take a lot longer to start such an application than it
    would take to start more, smaller services. And regardless of what you change
    in the application, you might not like that it forces you to redeploy the whole
    application at once. Now, imagine that one of your developers introduces a resource
    leak in the application. If the leaky code is executed over and over, it will
    not only bring down its single aspect of the app's functionality, it can also
    bring down the rest of the application as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个大型应用程序在部署和执行方面也有缺点。启动这样的应用程序所需的时间比启动更多、更小的服务要长得多。而且无论你在应用程序中做了什么改变，你可能不喜欢它强迫你一次性重新部署整个应用程序。现在，想象一下，你的一个开发人员在应用程序中引入了一个资源泄漏。如果泄漏的代码一遍又一遍地执行，它不仅会使应用程序的功能部分崩溃，还可能使整个应用程序崩溃。
- en: If you're a fan of using bleeding-edge technologies in your project, a monolithic
    style doesn't bring any great news either. Since you now need to migrate your
    whole application at once, it's harder to update any libraries or frameworks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢在项目中使用尖端技术，单片式风格也不会带来什么好消息。因为现在你需要一次性迁移整个应用程序，所以更难更新任何库或框架。
- en: The preceding explanation suggests that a monolithic architecture is only good
    for simple and small applications. There is, however, one more situation where
    it could actually be a good idea to use it. If you care about performance, having
    a monolith can sometimes help you to squeeze more from your app in terms of latency
    or throughput when compared to microservices. Inter-process communication will
    always incur some overhead, which monolithic applications don't need to pay. If
    you're interested in measurements, see the paper listed in the *Further reading*
    section of this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解释表明，单片架构只适用于简单和小型应用程序。然而，还有一种情况，它实际上可能是一个好主意。如果你关心性能，单片架构有时可以帮助你在延迟或吞吐量方面比微服务更充分地利用你的应用程序。进程间通信总会带来一些开销，而单片应用程序则不需要支付。如果你对测量感兴趣，请参阅本章的*进一步阅读*部分中列出的论文。
- en: Understanding services and microservices
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务和微服务
- en: Because of the drawbacks of monolithic architectures, other approaches have
    emerged. A common idea is to split your solution into multiple services that communicate
    with each other. You can then split the development between different teams, each
    taking care of a separate service. The boundaries of each team's work are clear,
    unlike in the monolithic architecture style.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单片架构的缺点，其他方法已经出现。一个常见的想法是将解决方案分成多个相互通信的服务。然后，你可以将开发分配给不同的团队，每个团队负责一个单独的服务。每个团队的工作边界是清晰的，不像单片架构风格。
- en: A **service-oriented architecture**, or **SOA** for short, means that the business
    functions are modularized and presented as separate services for the consumer
    applications to use. Each service should have a self-describing interface and
    hide any implementation details, such as the internal architecture, technologies,
    or the programming language used. This allows for multiple teams to develop the
    services however they like, meaning that under the hood, each can use what suits
    their needs best. If you have two teams of developers, one proficient in C# and
    one in C++, they can develop two services that can easily communicate with one
    another.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向服务的架构**，简称**SOA**，意味着业务功能被模块化，并作为独立的服务呈现给消费者应用程序使用。每个服务应该有一个自我描述的接口，并隐藏任何实现细节，比如内部架构、技术或所使用的编程语言。这允许多个团队以他们喜欢的方式开发服务，这意味着在幕后，每个团队可以使用最适合他们需求的东西。如果你有两个开发团队，一个精通C#，一个精通C++，他们可以开发两个可以轻松相互通信的服务。'
- en: 'Advocates of SOA came up with a manifesto prioritizing the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SOA的支持者提出了一项优先考虑以下内容的宣言：
- en: Business value over technical strategy
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务价值优于技术策略
- en: Strategic goals over project-specific benefits
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战略目标优于项目特定的利益
- en: Intrinsic interoperability over custom integration
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内在互操作性优于自定义集成
- en: Shared services over purpose-specific implementations
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享服务优于特定目的的实现
- en: Flexibility over optimization
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性优于优化
- en: Evolutionary refinement over pursuit of initial perfection
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演进式改进优于追求初始完美
- en: 'Even though this manifesto doesn''t bind you to a specific tech stack, or implementation,
    or type of services, the two most common types of services are SOAP and REST.
    Aside from those, recently, there''s a third one that has been growing in popularity:
    gRPC-based. You can find out more about these in the chapters on services-oriented
    architecture and microservices.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这份宣言不限制你使用特定的技术栈、实现或服务类型，但最常见的两种服务类型是SOAP和REST。除此之外，最近，还有一种第三种类型的服务正在日益流行：基于gRPC的服务。你可以在关于面向服务的架构和微服务的章节中了解更多关于这些的信息。
- en: Microservices
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: As the name suggests, microservices is a software development pattern where
    an application is split as a collection of loosely-coupled services that communicate
    using lightweight protocols. The microservices pattern is similar to the UNIX
    philosophy stating that a program should only have one purpose. According to UNIX
    philosophy, advanced problems are solved by composing such programs into UNIX
    pipelines. Similarly, microservice-based systems are composed of many microservices
    and supporting services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，微服务是一种软件开发模式，其中应用程序被拆分为使用轻量级协议进行通信的松耦合服务集合。微服务模式类似于UNIX哲学，即一个程序应该只有一个目的。根据UNIX哲学，复杂的问题可以通过将这些程序组合成UNIX管道来解决。同样，基于微服务的系统由许多微服务和支持服务组成。
- en: Let's start with an overview of the pros and cons of this architectural style.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来概述这种架构风格的优缺点。
- en: Benefits and disadvantages of microservices
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的优势和劣势
- en: The small size of services in a microservice architecture means that they're
    faster to develop, deploy, and understand. As the services are built independently
    of each other, the time necessary to compile their new versions can be drastically
    reduced. Thanks to this, it is easier to employ rapid prototyping and development
    when dealing with this architectural style. This, in turn, makes it possible to
    reduce the lead-time, meaning that business requirements can be introduced and
    evaluated much quicker.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构中服务的小尺寸意味着它们开发、部署和理解起来更快。由于服务是彼此独立构建的，编译它们的新版本所需的时间可以大大缩短。由此，使用这种架构风格处理时更容易进行快速原型设计和开发。这反过来使得缩短交付时间成为可能，这意味着业务需求可以更快地引入和评估。
- en: 'Some other benefits of a microservice-based approach include the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务方法的其他优点包括以下内容：
- en: Modularity, which is inherent to this architectural style.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化是这种架构风格的固有特性。
- en: Better testability.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的可测试性。
- en: Flexibility when replacing system parts (such as single services, databases,
    message brokers, or cloud providers).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换系统部分（如单个服务、数据库、消息代理或云提供商）的灵活性。
- en: 'Integration with legacy systems: it is not necessary to migrate an entire application,
    just the parts that require current development.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与传统系统集成：无需迁移整个应用程序，只需迁移需要当前开发的部分。
- en: 'Enabling distributed development: independent development teams can work on
    multiple microservices in parallel.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用分布式开发：独立的开发团队可以并行地开发多个微服务。
- en: 'Scalability: a microservice may be scaled independently of the others.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可伸缩性：微服务可以独立扩展。
- en: 'On the other hand, here are some disadvantages of microservices:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下是微服务的一些缺点：
- en: They require a mature DevOps approach and reliance on CI/CD automation.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们需要成熟的DevOps方法和依赖于CI/CD自动化。
- en: They are harder to debug, and require better monitoring and distributed tracing.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更难调试，需要更好的监控和分布式跟踪。
- en: Additional overhead (in terms of auxiliary services) may outweigh the benefits
    for smaller applications.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的开销（辅助服务方面）可能会超过较小应用程序的好处。
- en: Let's now discuss what are the characteristics of services written in this architectural
    style.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下以这种架构风格编写的服务的特点。
- en: Characteristics of microservices
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的特点
- en: 'Since the microservice style is fairly recent, there is no single definition
    for microservices. According to Martin Fowler, there are several essential characteristics
    of microservices, which we will describe next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务风格相对较新，因此没有单一的微服务定义。根据Martin Fowler的说法，微服务具有几个基本特征，接下来我们将描述这些特征：
- en: Each service should be an independently replaceable and upgradeable component.
    This is connected to easier deployment and loose coupling between the services,
    as opposed to components being libraries in a monolithic application. In the latter
    case, when you replace one library, you often have to redeploy the whole application.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都应该是一个可以独立替换和升级的组件。这与组件作为单块应用程序库的紧耦合相对，后者在替换一个库时通常需要重新部署整个应用程序。
- en: Each service should be developed by a cross-functional team, focused on a specific
    business capability. Ever heard of Conway's law?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都应该由一个专注于特定业务能力的跨职能团队开发。听说过康威定律吗？
- en: '*"Any organization that designs a system (defined broadly) will produce a design
    whose structure is a copy of the organization''s communication structure."**–
    Melvyn Conway, 1967*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*"任何设计系统（广义上定义）的组织都会产生一个结构，其结构是组织的沟通结构的复制。"**– Melvyn Conway, 1967*'
- en: If you don't have cross-functional teams, you end up with software silos. The
    lack of communication that comes with them will make you constantly jump through
    hurdles to successfully deliver.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有跨职能团队，你最终会陷入软件孤岛。与之伴随的沟通缺失将使您不断地跨越障碍才能成功交付。
- en: Each service should be a product, which is owned by the development team throughout
    its lifetime. This stays in contrast to the project mentality, where you develop
    software and just pass it on for someone to maintain.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都应该是一个产品，由开发团队在其整个生命周期内拥有。这与项目思维形成鲜明对比，项目思维中你只是开发软件然后交给其他人去维护。
- en: Services should have smart endpoints and use dump pipes, not the other way around.
    This stands in contrast to traditional services, which often rely on the logic
    of an **Enterprise Service Bus** (**ESB**), which often manages the routing of
    messages and transforms them according to business rules. In microservices, you
    achieve cohesiveness by storing the logic in the service and avoid coupling with
    messaging components. Using "dumb" message queues, such as ZeroMQ, can help with
    this goal.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该具有智能端点并使用哑管道，而不是相反。这与传统服务形成对比，传统服务通常依赖于**企业服务总线**（**ESB**）的逻辑，ESB通常管理消息的路由并根据业务规则进行转换。在微服务中，通过将逻辑存储在服务中并避免与消息组件耦合，可以实现内聚性。使用"哑"消息队列，如ZeroMQ，可以帮助实现这一目标。
- en: Services should be governed in a decentralized way. Monoliths are usually written
    using one specific technology stack. When they're being split into microservices,
    each one can choose whatever suits its own specific needs best. Governing and
    assuring that each microservice runs 24/7 is done by a team responsible for this
    specific service instead of a central department. Companies such as Amazon, Netflix,
    and Facebook follow this approach and observe that making developers responsible
    for the flawless execution of their services in production helps to ensure high
    quality.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该以分散的方式进行管理。单体通常使用特定的技术堆栈编写。当它们被拆分为微服务时，每个微服务可以选择最适合自己特定需求的技术。确保每个微服务24/7运行的管理工作由负责该特定服务的团队负责，而不是由一个中央部门负责。亚马逊、Netflix和Facebook等公司遵循这种方法，并观察到让开发人员对其服务在生产中的无缺陷执行负责有助于确保高质量。
- en: Services should manage their data in a decentralized way. Instead of having
    one database for all of them, each microservice can choose a database that best
    matches its needs. Having decentralized data can lead to some challenges with
    handling updates, but allows for better scaling. This is why microservices often
    coordinate in a transaction-free manner and offer eventual consistency.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务应该以分散的方式管理它们的数据。每个微服务可以选择最符合其需求的数据库，而不是为它们所有选择一个数据库。分散的数据可能会导致一些处理更新的挑战，但可以实现更好的扩展。这就是为什么微服务通常以无事务的方式协调并提供最终一致性。
- en: The infrastructure used by services should be managed automatically. To deal
    with dozens of microservices in an efficient manner, you need to have Continuous
    Integration and Continuous Delivery in place, as otherwise, deploying your services
    will be hell. Automated runs of all your tests will save you lots of time and
    trouble. Implementing Continuous Deployment on top of that will shorten the feedback
    loop and allow your customers to use your new features faster, too.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务使用的基础设施应该是自动管理的。为了有效地处理数十个微服务，您需要进行持续集成和持续交付，否则，部署您的服务将是一场噩梦。自动运行所有测试将为您节省大量时间和麻烦。在此基础上实施持续部署将缩短反馈周期，也能让您的客户更快地使用您的新功能。
- en: Microservices should be prepared for the failure of other services that they
    depend on. In a distributed deployment environment with so many moving parts,
    it's normal for some of them to break from time to time. Your services should
    be able to handle such failures gracefully. Patterns such as Circuit Breaker or
    Bulkhead (described later in the book) can help to achieve this. To make your
    architecture resilient, it's also critical to be able to bring failing services
    back up efficiently or even to know ahead of time that they're going to crash.
    Real-time monitoring of latency, throughput, and resource usage is essential for
    this. Get to know Netflix's Simian Army toolkit as it's invaluable for creating
    a resilient architecture.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应该能够应对它们所依赖的其他服务的故障。在分布式部署环境中，由于有太多的运行部件，一些部件偶尔出现故障是正常的。您的服务应该能够优雅地处理这些故障。诸如断路器或舱壁（在本书后面有描述）的模式可以帮助实现这一点。为了使您的架构具有弹性，能够有效地将失败的服务重新启动甚至提前知道它们将崩溃也是至关重要的。实时监控延迟、吞吐量和资源使用情况对此至关重要。了解Netflix的Simian
    Army工具包，因为它对创建具有弹性的架构非常宝贵。
- en: Architectures based on microservices should be ready to constantly evolve. You
    should design microservices and the cooperation between them in a manner that
    allows for easy replacement of a single microservice, or sometimes even groups
    of them. It's tricky to design the services properly, especially since some of
    the complexity that was once in the code of one bigger module can now be present
    as complex communication schemes between services, where it's harder to manage
    – so-called Spaghetti Integration. This means the experience and skill set of
    the architect plays a more important role than with traditional services or a
    monolithic approach.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的架构应该准备不断演进。您应该以一种允许轻松替换单个微服务甚至一组微服务的方式设计微服务和它们之间的合作。正确设计服务是有技巧的，特别是因为曾经存在于一个更大模块的代码中的一些复杂性现在可能存在于服务之间的复杂通信方案中，这更难以管理——所谓的意大利面集成。这意味着架构师的经验和技能比传统服务或单片式方法更加重要。
- en: 'On top of that, here are some other characteristics shared by many (but not
    all) microservices:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，许多（但并非全部）微服务共享的其他特征包括：
- en: Using separate processes that communicate over network protocols
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通过网络协议进行通信的独立进程
- en: Using technology-agnostic protocols (such as HTTP and JSON)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用技术无关的协议（如HTTP和JSON）
- en: Keeping services small and with a low runtime overhead
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持服务小型且运行时开销低
- en: Now, you should have a good understanding of what the characteristics of microservice-based
    systems are, so let's see how this approach compares with other architectural
    styles.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对基于微服务的系统的特征有了很好的理解，让我们看看这种方法与其他架构风格相比如何。
- en: Microservices and other architectural styles
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务和其他架构风格
- en: Microservices may be used as an architectural pattern on their own. However,
    they are often combined with other architectural choices, such as cloud-native
    computing, serverless applications, and mostly with lightweight application containers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以作为一种独立的架构模式使用。然而，它们通常与其他架构选择结合使用，例如云原生计算、无服务器应用程序，以及大多数轻量级应用容器。
- en: Service-oriented architectures bring loose coupling and high cohesion. Microservices
    can do it too, when applied correctly. However, it can be somewhat challenging
    because it requires good intuition to partition the system into the usually vast
    amount of microservices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构带来了松散耦合和高内聚。当正确应用时，微服务也可以做到。然而，这可能有些具有挑战性，因为需要很好的直觉来将系统划分为通常庞大数量的微服务。
- en: There are more similarities between microservices and their bigger cousins as
    they, too, can have SOAP-, REST-, or gRPC-based messaging and use technologies
    such as message queues for being event-driven. They also have well-known patterns
    to help with achieving the required quality attributes, such as fault tolerance
    (for example, through the isolation of faulty components), but in order to have
    an efficient architecture, you must decide on your approach to elements such as
    API gateways, service registries, load balancing, fault tolerance, monitoring,
    configuration management, and, of course, the technology stack to use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和它们的大型兄弟之间有更多的相似之处，它们也可以使用基于SOAP、REST或gRPC的消息传递，并使用诸如消息队列之类的技术来进行事件驱动。它们也有众所周知的模式来帮助实现所需的质量属性，例如容错（例如通过隔离故障组件），但为了拥有高效的架构，您必须决定您对诸如API网关、服务注册表、负载平衡、容错、监控、配置管理以及当然要使用的技术栈等元素的方法。
- en: Scaling microservices
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的扩展
- en: Microservices scale differently to monolithic applications. In monoliths, the
    entire functionality is handled by a single process. Scaling the application means
    replicating this process across different machines. Such scaling doesn't take
    into account which of the functionalities are heavily used and which do not require
    additional resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务与单片应用的扩展方式不同。在单片应用中，整个功能由单个进程处理。扩展应用程序意味着在不同的机器上复制此进程。这种扩展并不考虑哪些功能被大量使用，哪些不需要额外资源。
- en: With microservices, each functional element is handled as a separate service,
    which means a separate process. In order to scale a microservices-based application,
    only the parts that require more resources can be replicated to different machines.
    Such an approach makes it easier to better use the available resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务，每个功能元素都作为一个单独的服务处理，这意味着一个单独的进程。为了扩展基于微服务的应用程序，只需复制需要更多资源的部分到不同的机器上。这种方法使得更容易更好地利用可用资源。
- en: Transitioning to microservices
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过渡到微服务
- en: Most companies have some kind of existing monolithic code that they don't want
    to immediately rewrite using microservices, but still want to transition to this
    kind of architecture. In such cases, it's possible to adapt microservices incrementally,
    by adding more and more services that interact with the monolith. You can create
    new functionalities as microservices or just cut out some parts of the monolith
    and create microservices out of them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公司都有某种现有的单片代码，他们不想立即使用微服务进行重写，但仍希望过渡到这种架构。在这种情况下，可以通过逐步添加越来越多与单片交互的服务来逐步适应微服务。您可以将新功能创建为微服务，或者只是剪切单片的一些部分并将其创建为微服务。
- en: More details regarding microservices, including how to build your own from scratch,
    are available in [Chapter 13](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml), *Designing
    Microservices*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有关微服务的更多详细信息，包括如何从头开始构建自己的微服务，请参阅[第13章](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml)，*设计微服务*。
- en: Exploring event-based architecture
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索基于事件的架构
- en: Event-based systems are those whose architecture revolves around processing
    events. There are components that generate events, the channels through which
    the events propagate, and the listeners who react to them, potentially triggering
    new events too. It's a style that promotes asynchrony and loose coupling, which
    makes it a good way to increase performance and scalability, as well as an easy
    solution to deploy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件的系统是围绕处理事件的架构。有产生事件的组件，事件传播的通道，以及对其做出反应的监听器，可能还会触发新的事件。这是一种促进异步和松耦合的风格，这使得它成为提高性能和可伸缩性的好方法，也是一种易于部署的解决方案。
- en: With those advantages, there are also some challenges to solve. One of them
    is the complexity to create a system of this type. All the queues must be made
    fault-tolerant so that no events are lost in the middle of being processed. Processing
    transactions in a distributed way is also a challenge on its own. Using the Correlation
    ID pattern to track events between processes, along with monitoring techniques,
    can save you hours of debugging and scratching your head.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些优势之外，还有一些需要解决的挑战。其中之一是创建这种类型系统的复杂性。所有队列必须具有容错能力，以便在处理过程中不会丢失任何事件。以分布式方式处理事务也是一个挑战。使用相关ID模式跟踪进程之间的事件，以及监控技术，可以节省您数小时的调试和苦思冥想。
- en: Examples of event-based systems include stream processors and data integrations,
    as well as systems aiming for low latency or high scalability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件的系统的示例包括流处理器和数据集成，以及旨在实现低延迟或高可伸缩性的系统。
- en: Let's now discuss common topologies used in such systems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论在这种系统中常用的拓扑结构。
- en: Common event-based topologies
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的基于事件的拓扑结构
- en: The two main topologies of event-driven architectures are broker-based and mediator-based.
    Those topologies differ in how the events flow through the system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于事件的架构的两种主要拓扑结构是基于代理的和基于中介者的。这些拓扑结构在事件如何在系统中流动方面有所不同。
- en: The mediator topology is best used when processing an event that requires multiple
    tasks or steps that can be performed independently. All events produced initially
    land in the mediator's event queue. The mediator knows what needs to be done in
    order to handle the event, but instead of performing the logic itself, dispatches
    the event to appropriate event processors through each processor's event channel.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理需要执行多个独立任务或步骤的事件时，中介者拓扑结构最适用。最初产生的所有事件都会进入中介者的事件队列。中介者知道如何处理事件，但它不执行逻辑，而是通过每个处理器的事件通道将事件分派给适当的事件处理器。
- en: 'If this reminds you of how business processes flow, then you''ve got good intuition.
    You can implement this topology in **Business Process Management** (**BPM**) or
    **Business Process Execution Language** (**BPEL**). However, you can also implement
    it using technologies such as Apache Camel, Mule ESB, and others:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让您想起了业务流程是如何流动的，那么您的直觉很准确。您可以在业务流程管理（BPM）或业务流程执行语言（BPEL）中实现这种拓扑结构。然而，您也可以使用诸如Apache
    Camel、Mule ESB等技术来实现它：
- en: '![](img/50e74bcc-6cd2-4a56-b3ab-d0913cd785d9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50e74bcc-6cd2-4a56-b3ab-d0913cd785d9.png)'
- en: Figure 2.1 – The mediator topology
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 中介者拓扑结构
- en: 'A broker, on the other hand, is a lightweight component that contains all the
    queues and doesn''t orchestrate the processing of an event. It can require that
    the recipients subscribe to specific kinds of events and then simply forwards
    all the ones that are interesting for them. Many message queues rely on brokers,
    for example, ZeroMQ, which is written in C++ and aims for zero waste and low latency:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，经纪人是一个轻量级组件，包含所有队列，不编排事件的处理。它可以要求接收者订阅特定类型的事件，然后简单地转发所有对他们有兴趣的事件。许多消息队列依赖于经纪人，例如ZeroMQ，它是用C++编写的，旨在实现零浪费和低延迟：
- en: '![](img/7ccd1a75-053f-4283-8776-6b8d9d759295.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ccd1a75-053f-4283-8776-6b8d9d759295.png)'
- en: Figure 2.2 – The broker topology
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 经纪人拓扑结构
- en: Now that you know the two common topologies used in event-based systems, let's
    learn about a powerful architectural pattern using events at its core.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了基于事件的系统中使用的两种常见拓扑结构，让我们了解一种以事件为核心的强大架构模式。
- en: Event sourcing
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源
- en: 'You can think of events as notifications that contain additional data for the
    notified services to process. There is, however, another way to think of them:
    a change of state. Think how easy it would be to debug issues with your application
    logic if you''d be able to know the state in which it was when the bug occurred
    and what change was requested of it. That''s one benefit of event sourcing. In
    essence, it captures all the changes that happen to the system by simply recording
    all the events in the sequence they happened.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将事件视为包含额外数据的通知，供通知的服务处理。然而，还有另一种思考方式：状态的改变。想象一下，如果您能够知道应用逻辑在出现错误时所处的状态以及对其请求了什么改变，那么调试问题将会变得多么容易。这就是事件溯源的一个好处。实质上，它通过简单记录事件发生的顺序来捕获系统中发生的所有变化。
- en: 'Often, you''ll find that the service no longer needs to persist its state in
    a database, as storing the events somewhere else in the system is enough. Even
    if it does, it can be done asynchronously. Another benefit that you derive from
    event sourcing is a complete audit log for free:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现服务不再需要在数据库中持久化其状态，因为在系统的其他地方存储事件就足够了。即使需要，也可以异步完成。从事件溯源中获得的另一个好处是免费的完整审计日志：
- en: '![](img/86b71086-b197-4f3a-8d89-33613cb3b087.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86b71086-b197-4f3a-8d89-33613cb3b087.png)'
- en: Figure 2.3 – Event sourcing architecture. Providing a unified view of the application
    state can allow for consuming it and creating periodic snapshots for faster recovery
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 事件溯源架构。提供应用程序状态的统一视图可以允许消费它并创建定期快照以实现更快的恢复
- en: Thanks to the reduced need for data synchronization, event-sourced systems often
    offer low latency, which makes them a good fit for trading systems and activity
    trackers, among others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于减少了数据同步的需求，基于事件的系统通常具有低延迟，这使它们非常适合交易系统和活动跟踪器等应用。
- en: Let's now learn about another popular architectural style.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们了解另一种流行的架构风格。
- en: Understanding layered architecture
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分层架构
- en: If your architecture starts to look like spaghetti or you just want to prevent
    it, having your components structured in layers may help. Remember Model-View-Controller?
    Or maybe similar patterns, such as Model-View-ViewModel or Entity-Control-Boundary?
    Those are all typical examples of a layered architecture (also called N-tier architecture
    if the layers are physically separated from each other). You can structure code
    in layers, you can create layers of microservices, or apply this pattern to other
    areas where you think it could bring its benefits. Layering provides abstraction
    and the separation of concerns, and this is the main reason why it's being introduced.
    However, it can also help reduce complexity, while improving modularity, reusability,
    and maintainability of your solution.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的架构开始看起来像意大利面条，或者您只是想要防止这种情况发生，那么将组件结构化为层可能会有所帮助。还记得模型-视图-控制器吗？或者类似的模式，如模型-视图-视图模型或实体-控制-边界？这些都是分层架构的典型例子（如果层是物理上相互分离的，则也称为N层架构）。您可以将代码结构化为层，可以创建微服务层，或者将此模式应用于您认为可以带来好处的其他领域。分层提供了抽象和关注点的分离，这是引入它的主要原因。然而，它还可以帮助减少复杂性，同时提高解决方案的模块化、可重用性和可维护性。
- en: 'A real-world example would be in self-driving cars, where layers can be used
    to hierarchically make decisions: the lowest layer would handle the car''s sensors,
    then another layer would deal with single features consuming the sensor data,
    and on top of that one, there could be another one to ensure that all the features
    result in safe behavior. When sensors are replaced in another model of the car,
    only the lowest layer will need to be replaced.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的例子是自动驾驶汽车，其中层可以用于分层地做出决策：最低层将处理汽车的传感器，然后另一层将处理消耗传感器数据的单个功能，再上面可能会有另一层来确保所有功能都能产生安全行为。当传感器在汽车的另一个型号中被替换时，只需要替换最低层。
- en: 'A layered architecture is often pretty easy to implement since most developers
    already know the notion of layers – they simply need to develop several layers
    and stack them as in the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构通常很容易实现，因为大多数开发人员已经了解层的概念 - 他们只需要开发几个层并像下图中那样堆叠它们：
- en: '![](img/4b4d8943-f07f-46d2-b950-2885cbcd3668.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b4d8943-f07f-46d2-b950-2885cbcd3668.png)'
- en: Figure 2.4 – An example of a 3-tiered architecture using a textual interface
    in the presentation layer
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 使用文本界面的3层架构示例
- en: The challenge with creating an efficient layered architecture lays in specifying
    stable, well-defined interfaces between the layers. Often, you can have several
    layers on top of one. For instance, if you have a layer for domain logic, it can
    be a base for a presentation layer and a layer for providing APIs to other services.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建高效的分层架构的挑战在于规定层之间的稳定、明确定义的接口。通常，你可以在一个层之上有几个层。例如，如果你有一个领域逻辑层，它可以作为呈现层和向其他服务提供
    API 的基础层。
- en: This doesn't mean that layering is always a good thing. With microservices,
    there are two main scenarios where layering emerges. The first is when you want
    to separate one group of services from another. For instance, you could have a
    fast-changing layer to engage with your business partners, with content that changes
    frequently, and another business capabilities-oriented layer. The latter is not
    being changed at such a fast pace and is using stable technologies. Separating
    those two makes sense. There's also a notion that less stable components should
    rely on more stable components, so it's easy to see that you could have two layers
    here with the customer-facing one depending on the business capabilities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着分层始终是一件好事。在微服务中，有两种主要情况下会出现分层。第一种是当你想要将一组服务与另一组服务分开时。例如，你可以有一个快速变化的层与你的业务合作伙伴进行交互，内容经常变化，还有一个面向业务能力的层。后者的变化速度不那么快，使用的技术也比较稳定。分开这两个层是有意义的。还有一个概念是不太稳定的组件应该依赖于更稳定的组件，因此很容易看出你可以在这里有两个层，其中面向客户的层依赖于业务能力。
- en: The other scenario is when layers are created to reflect the communication structure
    of the organization (hello again, Conway's law). This will probably reduce communication
    between the teams, which can result in a decrease in innovation as now the teams
    won't know the internals or ideas of each other that well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是创建层以反映组织的通信结构（再见，康威定律）。这可能会减少团队之间的沟通，从而导致创新减少，因为现在团队不会那么了解彼此的内部或想法。
- en: Let's now discuss another example of a layered architecture often used with
    microservices—Backends for Frontends.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论另一个经常与微服务一起使用的分层架构的例子——面向前端的后端。
- en: Backends for Frontends
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向前端的后端
- en: It's not uncommon to see many frontends that rely on the same backend. Let's
    say you have a mobile application and a web application, both using the same backend.
    It may be a good design choice at first. However, once the requirements and usage
    scenarios of those two applications diverge, your backend will require more and
    more changes, serving just one of the frontends. This can lead to the backend
    having to support competing requirements, like two separate ways to update the
    data store or different scenarios for providing data. Simultaneously, the frontends
    start to require more bandwidth to communicate with the backend properly, which
    also leads to more battery usage in mobile apps. At this point, you should consider
    introducing a separate backend for each frontend.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看到许多前端依赖于相同的后端并不罕见。假设你有一个移动应用和一个 web 应用，两者都使用相同的后端。起初这可能是一个不错的设计选择。然而，一旦这两个应用的需求和使用场景开始分歧，你的后端就需要越来越多的改变，只为其中一个前端提供服务。这可能导致后端需要支持竞争性的需求，比如两种不同的更新数据存储的方式或者提供数据的不同场景。同时，前端开始需要更多的带宽来与后端进行正确的通信，这也导致移动应用的电池使用更多。在这一点上，你应该考虑为每个前端引入一个单独的后端。
- en: 'This way, you can think of a user-facing application as being a single entity
    having two layers: the frontend and the backend. The backend can depend on another
    layer, consisting of downstream services. Refer to the following diagram:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以将用户界面应用程序视为一个具有两个层的单个实体：前端和后端。后端可以依赖于另一层，包括下游服务。参考以下图表：
- en: '![](img/c197d4bb-ac3f-46e2-afea-c68ec914cf38.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c197d4bb-ac3f-46e2-afea-c68ec914cf38.png)'
- en: Figure 2.5 – The Backends for Frontends pattern
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 面向前端的后端模式
- en: The drawback of using **Backends for Frontends** (**BFFs**) is that some code
    must be duplicated. As long as this speeds up development and is not a burden
    in the long term, it's OK. But it also means that you should be on the watch for
    possibilities to aggregate duplicated logic in a downstream service. Sometimes,
    introducing a service just to aggregate similar calls can help solve duplication
    issues. Often, if you have many frontends, some can still share a backend and
    not cause it to have competing requirements. If you're creating mobile applications
    for iOS and Android, for instance, you could think of reusing the same backend
    for those, and having separate ones for web and/or desktop applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**面向前端的后端**（**BFFs**）的缺点是一些代码必须重复。只要这加快了开发并且从长远来看不是负担，那就没问题。但这也意味着你应该留意聚合重复逻辑到下游服务的可能性。有时，引入一个服务来聚合类似的调用可以帮助解决重复问题。通常，如果你有许多前端，一些前端仍然可以共享一个后端，而不会导致它有竞争性的需求。例如，如果你为
    iOS 和 Android 创建移动应用，你可以考虑重用相同的后端，并为 web 和/或桌面应用程序单独创建后端。
- en: Learning module-based architecture
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于学习模块的架构
- en: In this section, by modules, we mean software components that can be loaded
    and unloaded in runtime. For C++20's modules, refer to [Chapter 5](315eea2a-c029-4bc3-a159-4f897d393639.xhtml),
    *Leveraging C++ Language Features.*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，通过模块，我们指的是可以在运行时加载和卸载的软件组件。有关 C++20 模块，请参阅[第5章](315eea2a-c029-4bc3-a159-4f897d393639.xhtml)，*利用
    C++ 语言特性*。
- en: If you've ever needed to run a component with as little downtime as possible,
    but for any reason couldn't apply the usual fault-tolerance patterns, such as
    redundant copies of your service, making this component module-based can come
    to save your day. Or you may just be attracted by a vision of a modular system
    with versioning of all the modules, with an easy lookup of all the available services,
    along with the decoupling, testability, and enhancing teamwork that module-based
    systems can cause. All of this is why **Open Service Gateway Initiative** (**OSGi**)
    modules were created for Java and got ported to C++ in more than a few frameworks.
    Examples of architectures using modules include IDEs such as Eclipse, **Software
    Defined Networking** (**SDN**) projects such as OpenDaylight, or home automation
    software such as OpenHAB.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经需要尽可能少地运行一个组件，但由于任何原因无法应用通常的容错模式，例如服务的冗余副本，那么将该组件基于模块化可能会挽救您的一天。或者您可能只是被一个具有所有模块版本化的模块化系统的愿景所吸引，可以轻松查找所有可用服务，以及模块化系统可能引起的解耦、可测试性和增强团队合作。这就是为什么**开放服务网关倡议**（**OSGi**）模块被创建用于Java，并在多个框架中被移植到C++中。使用模块的架构示例包括诸如Eclipse的IDE、**软件定义网络**（**SDN**）项目，如OpenDaylight，或家庭自动化软件，如OpenHAB。
- en: OSGi also allows for automatic dependency management between modules, controlling
    their initialization and unloading, as well as controlling their discovery. Since
    it's service-oriented, you can think of using OSGi services as something akin
    to having tiny (micro?) services in one "container". This is why one of the C++
    implementations is named C++ Micro Services. To see them in action, refer to their
    *Getting Started* guide from the *Further reading* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OSGi还允许模块之间的自动依赖管理，控制它们的初始化和卸载，以及控制它们的发现。由于它是面向服务的，您可以将使用OSGi服务视为在一个“容器”中拥有微小（微？）服务。这就是为什么C++实现之一被命名为C++
    Micro Services。要看到它们的实际效果，请参考*进一步阅读*部分的*入门指南*。
- en: One interesting concept adopted by the C++ Micro Services framework is a new
    way to deal with singletons. The `GetInstance()` static function will, instead
    of just passing a static instance object, return a service reference obtained
    from the bundled context. So effectively, singleton objects will get replaced
    by services that you can configure. It can also save you from the static deinitialization
    fiasco, where multiple singletons that depend on each other have to unload in
    a specific order.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C++ Micro Services框架采用的一个有趣的概念是一种处理单例的新方法。`GetInstance()`静态函数将不再只传递静态实例对象，而是返回从捆绑上下文中获取的服务引用。因此，单例对象将被您可以配置的服务所取代。它还可以避免静态去初始化的困境，其中相互依赖的多个单例必须按特定顺序卸载。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've discussed the various architectural styles that you can
    encounter in the wild and apply to your software. We've discussed monolithic architecture,
    went through service-oriented architecture, moved onto microservices, and discussed
    the various ways in which they can provide external interfaces and interact with
    each other. You learned how to write RESTful services and how to create a resilient
    and easy-to-maintain microservice architecture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了您可以在实际中遇到并应用于您的软件的各种架构风格。我们讨论了单体架构，通过面向服务的架构，转向了微服务，并讨论了它们可以提供外部接口并相互交互的各种方式。您学会了如何编写RESTful服务，以及如何创建一个弹性且易于维护的微服务架构。
- en: 'We''ve also shown how to create simple clients to consume equally simple services.
    Later on, we discussed various other approaches to architecture: an event-driven
    one, a runtime module-based one, and showed where layering can be spotted and
    why. You now know how to implement event sourcing and recognize when to use BFFs.
    Moreover, you now know how architecture styles can help you achieve several quality
    attributes and what challenges this can bring.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了如何创建简单的客户端来消费同样简单的服务。随后，我们讨论了架构的各种其他方法：事件驱动的方法，运行时基于模块的方法，并展示了分层可以被发现的地方以及原因。您现在知道如何实现事件溯源，并知道何时使用BFFs。此外，您现在知道架构风格如何帮助您实现多个质量属性以及这可能带来的挑战。
- en: In the next chapter, you'll learn how to know which of those attributes are
    important in a given system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何知道在给定系统中哪些属性是重要的。
- en: Questions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 1\. What are the traits of a RESTful service?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. RESTful服务的特征是什么？
- en: 2\. What toolkit can you use to aid you in creating a resilient distributed
    architecture?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 您可以使用哪些工具包来帮助您创建弹性的分布式架构？
- en: 3\. Should you use centralized storage for your microservices? Why/why not?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 您应该为您的微服务使用集中式存储吗？为什么/为什么不？
- en: 4\. When should you write a stateful service instead of a stateless one?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 何时应该编写有状态服务而不是无状态服务？
- en: 5\. How does a broker differ from a mediator?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 经纪人和中介之间有何不同？
- en: 6\. What is the difference between an N-tier and an N-layer architecture?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. N层和N层架构有什么区别？
- en: 7\. How should you approach replacing a monolith with a microservice-based architecture?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 您应该如何处理用微服务架构替换单体架构？
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Flygare, R., and Holmqvist, A. (2017). *Performance characteristics between
    monolithic and microservice-based systems (Dissertation*). Retrieved from [http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888](http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flygare, R., and Holmqvist, A. (2017). *单体架构和基于微服务的系统之间的性能特征（论文）*。取自[http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888](http://urn.kb.se/resolve?urn=urn:nbn:se:bth-14888)
- en: Engelen, Robert. (2008). *A framework for service-oriented computing with C
    and C++ web service components*. ACM Trans. Internet Techn. 8\. 10.1145/1361186.1361188
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Engelen, Robert. (2008). *使用C和C++ Web服务组件进行面向服务的计算的框架*。ACM Trans. Internet Techn.
    8\. 10.1145/1361186.1361188
- en: Fowler, Martin. *Microservices – A definition of this new architectural term*.
    Retrieved from [https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fowler, Martin. *微服务-对这个新的架构术语的定义*。来源：[https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa](https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa)
- en: '*Getting Started – C++ Micro Services documentation*. Retrieved from [http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html](http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*入门-C++ 微服务文档*。来源：[http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html](http://docs.cppmicroservices.org/en/stable/doc/src/getting_started.html)'
