- en: Example - Soil Humidity Monitor with Wi-Fi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-带Wi-Fi的土壤湿度监测器
- en: Keeping indoor plants alive is no small feat. The example project in this chapter
    will show you how to create a Wi-Fi-enabled soil humidity monitor with actuator
    options for a pump or similar, like a valve and gravity-fed water tank. Using
    the built-in web server, we will be able to use its browser-based UI for monitoring
    the plant health and control system features, or integrate it into a larger system
    using its HTTP-based REST API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 保持室内植物存活并不是一件小事。本章的示例项目将向您展示如何创建一个具有执行器选项（如泵或类似的阀门和重力供水箱）的Wi-Fi土壤湿度监测器。使用内置的Web服务器，我们将能够使用其基于浏览器的UI来监测植物健康和控制系统功能，或者使用其基于HTTP的REST
    API将其集成到更大的系统中。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Programming an ESP8266 microcontroller
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程ESP8266微控制器
- en: Connecting sensors and actuators to an ESP8266
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器和执行器连接到ESP8266
- en: Implementing an HTTP server on this platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个平台上实现一个HTTP服务器
- en: Developing a web-based UI for monitoring and control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用于监测和控制的基于Web的UI
- en: Integrating the project into a larger network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目集成到更大的网络中
- en: Keeping plants happy
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持植物快乐
- en: 'To keep plants alive, you need a number of things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要保持植物存活，你需要一些东西：
- en: Nutrients
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 营养
- en: Light
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线
- en: Water
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水
- en: Of these, the first two are usually handled by nutrient-rich soil and putting
    the plant in a well-lit place, respectively. The main issue with keeping plants
    alive after satisfying those two points is usually the third point, as this has
    to be handled on a daily basis.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，前两者通常由富含营养的土壤和将植物放在光照充足的地方来处理。在满足这两点后，保持植物存活的主要问题通常是第三点，因为这需要每天处理。
- en: Here, it's not just a simple matter of keeping the water topped up, but instead
    of staying within the range where the soil has enough but not too much water.
    The presence of too much water in the soil affects how much oxygen the plant can
    absorb via its roots. As a result, with too much water in the soil, the plant
    will wither and die.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不仅仅是简单地保持水位，而是要保持在土壤有足够但不过多水分的范围内。土壤中水分过多会影响植物通过根部吸收氧气的量。因此，土壤中水分过多会导致植物枯萎死亡。
- en: On the other hand, too little water means that the plant cannot take up enough
    water to compensate for the water that is being evaporated through its leaves,
    nor can it get the nutrients into its roots. In this case, the plant will also
    wither and die.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，水分过少意味着植物无法吸收足够的水来补偿叶子蒸发的水，也无法将养分输送到根部。在这种情况下，植物也会枯萎死亡。
- en: When manually watering plants, we tend to use rough estimates of when the plant
    will likely need more water, along with a superficial testing of the humidity
    of the top soil, using our fingers. This tells us little about how much water
    is actually present around the roots of the plant, far below the upper layer of
    soil.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工浇水时，我们倾向于粗略估计植物可能需要更多水的时间，以及通过手指对表层土壤的湿度进行肤浅测试。这告诉我们很少关于植物根部下方土壤中实际存在多少水。
- en: 'To measure the humidity of the soil with more precision, we can use a number
    of methods:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更精确地测量土壤的湿度，我们可以使用多种方法：
- en: '| **Type** | **Principle** | **Notes** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **原理** | **备注** |'
- en: '| Gypsum block | Resistance—– | Water is absorbed by the gypsum, dissolving
    some of it, which allows a current to flow between two electrodes. The resistance
    value indicates soil moisture tension. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 石膏块 | 电阻—– | 水被石膏吸收，溶解了一些石膏，从而允许电流在两个电极之间流动。电阻值表示土壤湿度张力。'
- en: '| Tensiometer | Vacuum | A hollow tube has a vacuum meter on one end and a
    porous tip at the other, allowing water to enter and leave freely. Water getting
    sucked out of the tube by the soil increases the vacuum sensor readings, indicating
    that it''s harder to extract moisture from the soil for plants (moisture tension).
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 张力计 | 真空 | 一根空心管的一端有一个真空计，另一端有一个多孔的尖端，允许水自由进出。土壤吸走管中的水会增加真空传感器的读数，表明植物从土壤中提取水分变得更困难（湿度张力）。'
- en: '| Capacitance probe | **Frequency Domain Reflectometry** (**FDR**) | Uses the
    dielectric constant between two metal electrodes (in the soil) in an oscillator
    circuit to measure changes to this constant due to changing moisture levels. Indicates
    moisture content. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 电容探针 | **频域反射计**（**FDR**）| 利用土壤中两个金属电极之间的介电常数在振荡电路中的变化来测量由于湿度变化而引起的这一常数的变化。指示湿度。'
- en: '| Microwave sensor | **Time Domain Reflectometry** (**TDR**) | Measures the
    time required for a microwave signal to travel to the end of the parallel probes
    and back, which differs depending on the dielectric constant of the soil. Measures
    moisture content. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 微波传感器 | **时域反射计**（**TDR**）| 测量微波信号传播到并返回平行探针末端所需的时间，这取决于土壤的介电常数。测量湿度。'
- en: '| ThetaProbe | RF amplitude impedance | A 100 MHz sine wave radio signal is
    sent among four probes enclosing a soil cylinder. The change in the impedance
    of the sine wave is used to calculate the water in the soil. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| ThetaProbe | 射频幅度阻抗 | 一个100 MHz正弦波无线电信号被发送到包围土壤圆柱体的四个探针之间。正弦波阻抗的变化用于计算土壤中的水分。'
- en: '| Resistance probe | Resistance | This is similar to the gypsum block, except
    with just the electrodes. Thus, this only measures water presence (and its conductivity)
    instead of soil moisture tension. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 电阻探针 | 电阻 | 这类似于石膏块，只是有电极。因此，这只能测量水分存在（及其导电性），而不能测量土壤湿度张力。'
- en: All of these sensor types come with their own sets of advantages of disadvantages.
    In the case of the gypsum block and tensiometer, there is a significant amount
    of maintenance, as the former relies on there being enough of the gypsum remaining
    to dissolve and not throw off the calibration, whereas in the latter case, it
    is imperative that the airtight seal remains so as not to let air into the tube.
    Any gap in this seal would immediately render the vacuum sensor useless.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些传感器类型都有各自的优点和缺点。在石膏块和张力计的情况下，需要进行大量的维护，因为前者依赖于石膏残留量足够溶解而不会影响校准，而在后者的情况下，必须保持密封以防止空气进入管道。这种密封的任何缺口都会立即使真空传感器失效。
- en: 'Another big point is that of cost. While FDR- and TDR-based probes may be quite
    accurate, they also tend to be very expensive. This usually leads people who just
    want to experiment with soil moisture sensors to pick either the resistance or
    capacitance-based sensors. Here, the main disadvantage of the former sensor type
    becomes obvious in a month or less of usage: corrosion.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的问题是成本。虽然基于FDR和TDR的探头可能非常准确，但它们也往往非常昂贵。这通常导致只是想要尝试土壤湿度传感器的人选择电阻或电容传感器。在这里，前者传感器类型的主要缺点在一个月或更短的使用期内就变得明显：腐蚀。
- en: With two electrodes suspended in a solution containing ions and a current being
    applied to one of the electrodes, simple chemistry results in one of the electrodes
    rapidly corroding (losing material), until it is no longer functional. This also
    pollutes the soil with metal molecules. The use of an **alternating current**
    (**AC**) instead of a direct current on a single electrode can reduce the corrosive
    effect somewhat, but it remains an issue.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个含有离子的溶液中悬浮着两个电极，并且在其中一个电极上施加电流，简单的化学反应导致其中一个电极迅速腐蚀（失去材料），直到它不再起作用。这也会使土壤受到金属分子的污染。在单个电极上使用**交流**（**AC**）而不是直流可以在一定程度上减少腐蚀作用，但仍然存在问题。
- en: Among cheap and still accurate soil moisture sensors, only the capacitance probe
    ticks all of the boxes. Its accuracy is decent enough for sensible measurements
    and comparisons (after calibration), it is unaffected by the moisture in the soil,
    and it does not affect the soil in any manner either.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在便宜而仍然准确的土壤湿度传感器中，只有电容探头符合所有要求。它的准确性足够进行合理的测量和比较（经过校准），不受土壤湿度的影响，也不会对土壤产生任何影响。
- en: To actually get water to the plant, we need to have a way to get just the right
    amount to it. Here, it's mostly the scale of the system that determines the choice
    of water delivery. For watering an entire field, we could use an impeller-based
    pump, capable of delivering many liters of water per minute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要给植物浇水，我们需要有一种方法来给它适量的水。在这里，系统的规模大部分决定了水的输送方式。对于整个田地的灌溉，我们可以使用叶轮泵，能够每分钟输送许多升的水。
- en: For a single plant, we would need to be able to deliver in the order of a few
    hundred milliliters per minute at most. Here, something such as a peristaltic
    pump would be pretty much ideal. This is the kind of pump you would also use in
    laboratories and medical applications where you have to provide a small amount
    of fluid with high accuracy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个植物，我们需要能够以最多几百毫升每分钟的速度进行供水。在这里，蠕动泵就非常理想。这是你在实验室和医疗应用中也会使用的泵，可以提供高精度的少量流体。
- en: Our solution
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的解决方案
- en: To keep things simple, we will just be building something that can take care
    of a single plant. This will provide us with the most flexibility in terms of
    placement, as we would just have a single system next to each plant, no matter
    whether it's on a windowsill, table, or terrace somewhere.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们只会建造一个可以照顾单个植物的系统。这将为我们提供最大的灵活性，因为无论植物放在窗台、桌子还是露台上，我们只需要在每棵植物旁边放置一个系统。
- en: In addition to measuring the soil moisture level, we would also want to be able
    to have the system automatically water the plant at set trigger levels and for
    us to be able to monitor this process. This requires some kind of network access,
    preferably wireless so that we don't have to run any more cables than the power
    connector.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测量土壤湿度水平外，我们还希望系统能够在设定的触发水平自动给植物浇水，并且我们能够监控这个过程。这需要某种网络访问，最好是无线的，这样我们就不必再布置更多的电缆了。
- en: This makes the ESP8266 MCU very attractive, with the NodeMCU development board
    an attractive target for developing and debugging the system. We'd hook up a soil
    moisture sensor to it, along with a peristaltic pump.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得ESP8266 MCU非常有吸引力，NodeMCU开发板是开发和调试系统的理想目标。我们会将一个土壤湿度传感器连接到它上面，还有一个蠕动泵。
- en: By connecting to the ESP8266 system's IP address using a web browser, we would
    see the current status of the system, with the soil humidity level and optionally
    much more. Configuring the system and more would be done over the commonly used,
    compact binary MQTT protocol, with the system also publishing the current system
    status so that we can read it into a database for display and analysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Web浏览器连接到ESP8266系统的IP地址，我们可以看到系统的当前状态，包括土壤湿度水平和其他可选信息。配置系统等操作将通过常用的紧凑二进制MQTT协议进行，系统还会发布当前系统状态，以便我们将其读入数据库进行显示和分析。
- en: This way, we can also write a backend service later on that combines many of
    such nodes into a coherent system with central control and management. This is
    something that we will actually look at in great detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Monitoring and Control*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们还可以后续编写一个后端服务，将这些节点组合成一个统一的系统，并进行集中控制和管理。这实际上是我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中详细讨论的内容，*示例-建筑监控和控制*。
- en: The hardware
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Our ideal solution would have the most accurate sensor, without breaking the
    bank. This means that we pretty much have to use a capacitance sensor, as we saw
    earlier in this chapter. These sensors can be obtained as capacitive soil moisture
    sensors for little more than a few euros or dollars for a simple 555 timer IC-based
    design such as these:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理想的解决方案将具有最准确的传感器，而不会花费太多。这意味着我们基本上必须使用电容传感器，就像我们在本章前面看到的那样。这些传感器可以作为电容土壤湿度传感器获得，价格不到几欧元或美元，用于简单的基于555定时器IC的设计，如下所示：
- en: '![](img/9473a55a-2149-4762-9a3d-1580277a0462.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9473a55a-2149-4762-9a3d-1580277a0462.png)'
- en: You would simply stick these into the soil up to the point where the circuitry
    begins, then connect it with a power source as well as the connection to the analog
    to digital converter of the MCU.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需将它们插入土壤，直到电路开始的地方，然后将其连接到电源以及连接到MCU的模拟到数字转换器。
- en: Most peristaltic pumps one can purchase require 12V. This means that we need
    to either have a power supply that can provide both 5V and 12V, or use a so-called
    boost converter to convert the 5V to 12V. Either way, we would also need to have
    some method to turn the pump on or off. With the boost converter, we can use its
    *enable* pin to turn its output on or off using a GPIO pin on our MCU.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数蠕动泵需要12V。这意味着我们需要一个可以提供5V和12V的电源，或者使用所谓的升压转换器将5V转换为12V。无论哪种方式，我们还需要一些方法来打开或关闭泵。使用升压转换器，我们可以使用其*使能*引脚，通过MCU上的GPIO引脚来打开或关闭其输出。
- en: 'For prototyping, we can use one of these common 5V to 12V boost converter modules
    that use an ME2149 step-up switching regulator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原型设计，我们可以使用其中一个常见的5V到12V升压转换器模块，它使用ME2149升压开关稳压器：
- en: '![](img/97a91881-f1ca-4bbf-a786-fd122d1bba40.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97a91881-f1ca-4bbf-a786-fd122d1bba40.png)'
- en: 'These do not have the enable pin broken out in any way, but we can easily solder
    on a wire to the pin in question:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块没有使能引脚，但我们可以轻松地焊接一根导线到相关引脚上：
- en: '![](img/d992fb6a-fb74-480f-9d5c-4cec48efd14b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d992fb6a-fb74-480f-9d5c-4cec48efd14b.png)'
- en: 'This boost-converter module''s outputs are then connected to the peristaltic
    pump:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个升压转换器模块的输出连接到蠕动泵：
- en: '![](img/9e0cb710-095e-4f43-b2ba-b9c0145085ea.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e0cb710-095e-4f43-b2ba-b9c0145085ea.png)'
- en: Here, we need to get some tubing of the right diameter to connect it to the
    water reservoir and the plant. The pump itself will rotate either direction. As
    it consists of essentially a set of rollers on the section of internal tubing,
    which push the liquid inside one way, either side of the pump can be the input
    or output.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要获得一些合适直径的管道，将其连接到水箱和植物。泵本身将旋转任何方向。因为它基本上是内部管道部分上的一组滚轮，它们将液体推入一个方向，泵的任一侧都可以是输入或输出。
- en: Be sure to test the flow direction beforehand with two containers and some water,
    and mark the direction on the pump casing, along with the positive and negative
    terminal connections used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要事先用两个容器和一些水测试流向，并在泵壳上标出流向，以及使用的正负端子连接。
- en: 'In addition to these components, we also want to have an RGB LED connected
    for some signaling and just for looks. For this, we will use the **APA102** RGB
    LED module, which connects to the ESP8266 over the SPI bus:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些组件，我们还想连接一个RGB LED进行一些信号传输和外观。为此，我们将使用**APA102** RGB LED模块，它通过SPI总线连接到ESP8266：
- en: '![](img/080f68db-2083-4eff-b67e-536e6aee587c.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080f68db-2083-4eff-b67e-536e6aee587c.png)'
- en: We can use a single power supply that can be provide 5V with 1A or more, as
    well as cope with the sudden power draw from the boost converter every time that
    the pump is activated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个电源，可以提供5V和1A或更多的电流，并且可以应对每次泵启动时增压转换器突然的功率需求。
- en: 'The whole system would look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 整个系统看起来会像这样：
- en: '![](img/541c3d8a-ca18-49c7-96cc-1e863fb62a79.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/541c3d8a-ca18-49c7-96cc-1e863fb62a79.png)'
- en: The firmware
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固件
- en: For this project, we will be implementing a module for the same firmware that
    we will be using in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Monitoring and Control*. Therefore, this chapter will only cover the
    parts that are unique to this plant-watering module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中实现一个模块，*示例-建筑监控和控制*中使用的相同固件。因此，本章将仅涵盖与此植物浇水模块独特的部分。
- en: Before we can start with the firmware itself, we first have to set up the development
    environment. This involves the installation of the ESP8266 SDK and the Sming framework.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写固件之前，我们首先必须设置开发环境。这涉及安装ESP8266 SDK和Sming框架。
- en: Setting up Sming
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Sming
- en: The Sming-based ESP8266 development environment can be used on Linux, Windows,
    and macOS. You want to preferably use the development branch of Sming, however,
    which is where using it on Linux (or in a Linux VM, or Windows 10's **Windows
    Subsystem for Linux** (**WSL**)) is the easiest way, and definitely recommended.
    On Linux installing in the `/opt` folder is recommended for consistency with the
    Sming quick start guide.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Sming的ESP8266开发环境可以在Linux、Windows和macOS上使用。最好使用Sming的开发分支，在Linux上使用它是最简单的方法，也是最推荐的方法。在Linux上，建议在`/opt`文件夹中安装，以保持与Sming快速入门指南的一致性。
- en: This quick start guide for Linux can be found at [https://github.com/SmingHub/Sming/wiki/Linux-Quickstart](https://github.com/SmingHub/Sming/wiki/Linux-Quickstart).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的快速入门指南可以在[https://github.com/SmingHub/Sming/wiki/Linux-Quickstart](https://github.com/SmingHub/Sming/wiki/Linux-Quickstart)找到。
- en: 'On Linux, we can use the Open SDK for ESP8266, which takes the official Espressif
    (non-RTOS) SDK, and replaces all the non-open components it can with open source
    alternatives. This can be installed using this code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，我们可以使用ESP8266的Open SDK，它使用官方的Espressif（非RTOS）SDK，并用开源替代品替换所有非开源组件。可以使用以下代码进行安装：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will get the current source for the Open SDK and compile it, targeting
    version 1.5.4 of the official SDK. While a 2.0 version of the SDK already exists,
    some compatibility issues within the Sming framework can remain. Using the 1.5.4
    version offers pretty much the same experience while using well-tested code. This
    will of course change over time, so be sure to check the official Sming documentation
    for updated instructions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取当前的Open SDK源代码并进行编译，目标是官方SDK的1.5.4版本。虽然SDK的2.0版本已经存在，但Sming框架内可能存在一些兼容性问题。使用1.5.4版本提供了几乎相同的体验，同时使用经过充分测试的代码。当然，随着时间的推移，这将会改变，所以请务必查看官方Sming文档以获取更新的说明。
- en: The `STANDALONE` option means that the SDK will be built as a standalone installation
    of the SDK and the toolchain, without further dependencies. This is the desired
    option for use with Sming.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`STANDALONE`选项意味着SDK将作为SDK和工具链的独立安装进行构建，没有进一步的依赖关系。这是在使用Sming时所期望的选项。'
- en: 'Installing `Sming` is as easy as this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`Sming`就像这样简单：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will build the Sming framework. If we are adding new libraries to Sming
    in its `Libraries` folder, we have to execute the last step again to have a new
    Sming shared library instance to be built and installed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建Sming框架。如果我们在其`Libraries`文件夹中添加新的库到Sming中，我们必须再次执行最后一步，以构建和安装一个新的Sming共享库实例。
- en: For this project, copy the folders in the `libs` folder of the software project
    for this chapter to the `Sming/Sming/Libraries` folder prior to compiling Sming,
    or the project code will not compile.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，将本章软件项目的`libs`文件夹复制到编译Sming之前的`Sming/Sming/Libraries`文件夹中，否则项目代码将无法编译。
- en: We can also compile Sming with SSL support. This requires us to compile it with
    the `ENABLE_SSL=1` parameter to Make. This will enable the axTLS-based encryption
    support throughout the Sming library as it is compiled.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用SSL支持编译Sming。这要求我们使用`ENABLE_SSL=1`参数对Make进行编译。这将使得在整个编译过程中，Sming库都启用基于axTLS的加密支持。
- en: 'With these steps complete, we just have to install `esptool.py` and `esptool2`.
    While in the `/opt` folder, execute these commands to obtain esptool:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们只需安装`esptool.py`和`esptool2`。在`/opt`文件夹中，执行以下命令以获取esptool：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Esptool.py` is a Python script that allows us to communicate with the SPI
    ROM that is part of each ESP8266 module. It is the way we will flash the MCU''s
    ROM with our code. This tool is automatically used by Sming:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Esptool.py`是一个Python脚本，允许我们与每个ESP8266模块的SPI ROM进行通信。这是我们将用来将MCU的ROM闪存为我们的代码的方式。这个工具会被Sming自动使用：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `esptool2` utility is an alternative to the set of scripts in the official
    SDK that turn the linker output into a ROM format that we can write to the ESP8266\.
    It is called by Sming when we are compiling our application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`esptool2`实用程序是官方SDK中一组脚本的替代品，这些脚本将链接器输出转换为我们可以写入ESP8266的ROM格式。在编译应用程序时，Sming会调用它。'
- en: 'Finally, assuming that we installed the SDK and Sming under `/opt`, we can
    add the following global variables and addition to the system `PATH` variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们在`/opt`下安装了SDK和Sming，我们可以添加以下全局变量和添加到系统`PATH`变量中：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last line adds the toolchain's binaries to the path, which we will need
    when debugging ESP8266 applications, as will see in [Chapter 7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml),
    *Testing Resource-Restricted Platforms*. At this point, we can develop with Sming
    and create ROM images that we can write to the MCU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将工具链的二进制文件添加到路径中，这在调试ESP8266应用程序时是必需的，我们将在[第7章](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml)中看到，*测试资源受限平台*。在这一点上，我们可以使用Sming进行开发，并创建可以写入MCU的ROM映像。
- en: Plant module code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 植物模块代码
- en: In this section, we will look at the basic source code for this project, starting
    with the core module, `OtaCore`, and continuing with the `BaseModule` class, which
    all firmware modules register with. Finally, we look at the `PlantModule` class
    itself, which contains the business logic for the project requirements that we
    discussed in this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看该项目的基本源代码，从核心模块`OtaCore`开始，继续使用所有固件模块注册的`BaseModule`类。最后，我们将查看`PlantModule`类本身，其中包含了我们在本章讨论的项目需求的业务逻辑。
- en: Also of note is that for this project we enabled both the rBoot bootmanager
    and the rBoot Big Flash options in the project Makefile. What this does is create
    four 1 MB blocks in the 4 MB of ROM that we have available on our ESP8266 module
    (which is all ESP-12E/F modules), of which two are used for firmware images and
    the remaining two for file storage (using the SPIFFS filesystem).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，对于这个项目，我们在项目的Makefile中启用了rBoot引导管理器和rBoot大Flash选项。这样做的作用是在我们的ESP8266模块上创建4个1MB的块（我们可用的4MB
    ROM中），其中两个用于固件映像，剩下的两个用于文件存储（使用SPIFFS文件系统）。
- en: The rBoot bootloader is then written to the beginning of the ROM, so that it
    will be loaded first on each boot. Of the firmware slots, only one is active at
    any given time. A handy feature of this setup is that it allows us to easily perform
    **over-the-air** (**OTA**) updates, by writing the new firmware image to the inactive
    firmware slot, changing the active slot, and restarting the MCU. If rBoot fails
    to boot from the new firmware image, it will fall back on the other firmware slot,
    which is our known working firmware that we performed the OTA update from.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，rBoot引导加载程序被写入到ROM的开头，以便在每次启动时首先加载它。在固件插槽中，任何时候只有一个是活动的。这种设置的一个方便的特性是，它允许我们轻松执行**空中**（**OTA**）更新，方法是将新的固件映像写入到非活动的固件插槽，更改活动插槽，并重新启动MCU。如果rBoot无法从新的固件映像启动，它将退回到另一个固件插槽，这是我们已知的工作固件，我们从中执行了OTA更新。
- en: Makefile-user.mk
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile-user.mk
- en: 'In the root of the `project` folder, we find this Makefile. It contains a number
    of settings that we may want to set to suit our purposes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`project`文件夹的根目录中，我们找到了这个Makefile。它包含了一些设置，我们可能想要根据我们的目的进行设置：
- en: '| **Name** | **Description** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `COM_PORT` | If we always connect the board to the same serial port, we can
    hardcode it here to save ourselves some typing. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `COM_PORT` | 如果我们总是连接板子到同一个串行端口，我们可以在这里硬编码它，以节省一些输入。 |'
- en: '| `SPI_MODE` | This sets the SPI mode used while flashing the firmware images
    to the SPI ROM. With `dio` only two data lines (`SD_D0`, `D1`) or four (`SD_D0-3`).
    Not all SPI ROMs have all four data lines connected. The `qio` mode is faster,
    but `dio` should always work. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `SPI_MODE` | 在刷写固件映像到SPI ROM时设置使用的SPI模式。使用 `dio` 只有两条数据线（`SD_D0`，`D1`）或四条（`SD_D0-3`）。并非所有SPI
    ROM都连接了所有四条数据线。`qio` 模式更快，但 `dio` 应该总是有效的。 |'
- en: '| `RBOOT_ENABLED` | When set to 1, this enables rBoot bootloader support. We
    want this enabled. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_ENABLED` | 当设置为1时，这将启用rBoot引导加载程序支持。我们希望启用这个。 |'
- en: '| `RBOOT_BIG_FLASH` | With 4 MB of ROM available, we wish to use all of this.
    Enable this as well. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_BIG_FLASH` | 有4MB的ROM可用，我们希望全部使用。也要启用这个。 |'
- en: '| `RBOOT_TWO_ROMS` | This option can be used if we wish to place two firmware
    images in a single 1 MB ROM chip instead. This applies to some ESP8266 modules
    and derivatives. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `RBOOT_TWO_ROMS` | 如果我们希望将两个固件映像放在单个1MB ROM芯片中，可以使用此选项。这适用于一些ESP8266模块和衍生产品。
    |'
- en: '| `SPI_SIZE` | Here, we set the size of the SPI ROM chip, which should be 4M
    for this project. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `SPI_SIZE` | 在这里，我们设置SPI ROM芯片的大小，对于这个项目应该是4M。 |'
- en: '| `SPIFF_FILES` | The location of the folder containing the files that will
    be put on the SPIFFS ROM image that will be written to the MCU. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `SPIFF_FILES` | 包含将写入MCU的SPIFFS ROM映像的文件的文件夹的位置。 |'
- en: '| `SPIFFS_SIZE` | The size of the SPIFFS ROM image to create. Here, 64 KB is
    standard, but we could use up to 1 MB if we needed to when using a 4 MB ROM with
    the `RBOOT_BIG_FLASH` option enabled. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `SPIFFS_SIZE` | 要创建的SPIFFS ROM映像的大小。这里，64KB是标准的，但如果需要的话，我们可以在启用`RBOOT_BIG_FLASH`选项时使用高达1MB。
    |'
- en: '| `WIFI_SSID` | The SSID of the Wi-Fi network that we wish to connect to. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `WIFI_SSID` | 我们希望连接的Wi-Fi网络的SSID。 |'
- en: '| `WIFI_PWD` | The password for the Wi-Fi network. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `WIFI_PWD` | Wi-Fi网络的密码。 |'
- en: '| `MQTT_HOST` | The URL or IP address of the MQTT server (broker) to use. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_HOST` | 要使用的MQTT服务器（代理）的URL或IP地址。 |'
- en: '| `ENABLE_SSL` | Enable this with SSL support compiled into Sming to make the
    firmware use TLS-encrypted connections with the MQTT broker. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `ENABLE_SSL` | 启用此选项，编译SSL支持到Sming中，使固件使用与MQTT代理的TLS加密连接。 |'
- en: '| `MQTT_PORT` | The port of the MQTT broker. This depends on whether SSL is
    enabled. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PORT` | MQTT代理的端口。这取决于是否启用了SSL。 |'
- en: '| `USE_MQTT_PASSWORD` | Set to true if you wish to connect to the MQTT broker
    with a username and password. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `USE_MQTT_PASSWORD` | 如果希望使用用户名和密码连接到MQTT代理，则设置为true。 |'
- en: '| `MQTT_USERNAME` | The MQTT broker username, if required. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_USERNAME` | MQTT代理用户名，如果需要的话。 |'
- en: '| `MQTT_PWD` | The MQTT broker password, if required. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PWD` | MQTT代理密码，如果需要的话。 |'
- en: '| `MQTT_PREFIX` | A prefix you can optionally add in front of each MQTT topic
    used by the firmware, if necessary. It has to end with a slash if not left empty.
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `MQTT_PREFIX` | 可选地在固件使用的每个MQTT主题前面添加的前缀，如果需要的话。如果不为空，必须以斜杠结尾。 |'
- en: '| `OTA_URL` | The hardcoded URL that will be used by the firmware whenever
    an OTA update is requested. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `OTA_URL` | 每当请求OTA更新时固件将使用的硬编码URL。 |'
- en: Of these, the Wi-Fi, MQTT, and OTA settings are essential, as they will allow
    the application to connect to the network and MQTT broker, as well as receive
    firmware updates without having to flash the MCU over its serial interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，Wi-Fi、MQTT和OTA设置是必不可少的，因为它们将允许应用程序连接到网络和MQTT代理，并且接收固件更新，而无需通过串行接口刷写MCU。
- en: Main
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Main
- en: 'The main source file and with it the application entry point is pretty uneventful:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主源文件以及应用程序的入口点都非常平凡：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the `OtaCore` class containing the main application logic, we merely call
    its static initialization function while providing a callback function if we wish
    to execute any further logic after the core class has finished setting up the
    network, MQTT, and other functionality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`OtaCore`类包含了主要的应用逻辑，我们只需调用它的静态初始化函数，同时提供一个回调函数，如果我们希望在核心类完成设置网络、MQTT和其他功能后执行任何进一步的逻辑。
- en: OtaCore
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OtaCore
- en: 'In this class, we set up all of the basic network functionality for the specific
    feature modules, in addition to providing utility functions for logging and MQTT
    functionality. This class also contains the main command processor for commands
    received over MQTT:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们为特定的功能模块设置了所有基本的网络功能，还提供了用于日志记录和MQTT功能的实用函数。这个类还包含了通过MQTT接收到的命令的主要命令处理器：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These two includes are required to make use of the Sming framework. With them,
    we include the main headers of the SDK (`user_config.h`) and those of Sming (`SmingCore.h`).
    This also defines a number of preprocessor statements, such as to use the open
    source **Light-Weight IP stack** (**LWIP**) and to deal with some issues in the
    official SDK.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个包含是使用Sming框架所必需的。通过它们，我们包含了SDK的主要头文件（`user_config.h`）和Sming的头文件（`SmingCore.h`）。这还定义了许多预处理器语句，比如使用开源的**轻量级IP堆栈**（**LWIP**）以及处理官方SDK中的一些问题。
- en: 'Also of note is the `esp_cplusplus.h` header, which is indirectly included
    this way. Its source file implements the `new` and `delete` functions, as well
    as a few handlers for class-related functionality, such as `vtables` when using
    virtual classes. This enables compatibility with the STL:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是`esp_cplusplus.h`头文件，它是间接包含的。它的源文件实现了`new`和`delete`函数，以及一些与类相关功能的处理程序，比如在使用虚拟类时的`vtables`。这使得与STL兼容：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These two enumerations define the logging levels, and the individual GPIO and
    other pins of the ESP8266 that we may want to use. The values for the ESP8266
    pin enumeration correspond to positions in a bitmask:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个枚举定义了日志级别，以及我们可能想要使用的ESP8266的各个GPIO和其他引脚。ESP8266引脚枚举的值对应于位掩码中的位置：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we define the fixed pins for the I2C bus. These correspond to GPIO 4 and
    5, also known as **D1** and **D2** on NodeMCU boards. The main reason for having
    these pins predefined is that they are two of the few *safe* pins on the ESP8266.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了I2C总线的固定引脚。这些对应于NodeMCU板上的GPIO 4和5，也被称为**D1**和**D2**。预定义这些引脚的主要原因是它们是ESP8266上为数不多的*安全*引脚之一。
- en: Many pins of the ESP8266 will change levels during startup before settling,
    which can cause unwanted behavior with any connected peripherals.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，ESP8266的许多引脚在稳定之前会改变电平，这可能会导致任何连接的外围设备出现意外行为。
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We define two function pointers, one to be used by feature modules when they
    wish to register an MQTT topic, along with a callback function. The other is the
    callback we saw in the main function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数指针，一个用于功能模块在希望注册MQTT主题时使用，以及一个回调函数。另一个是我们在主函数中看到的回调。
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The class declaration itself gives a good overview of the functionality provided
    by this class. The first thing we notice is that it is completely static. This
    ensures that this class's functionality is immediately initialized when the firmware
    starts, and that it can be accessed globally without having to worry about specific
    instances.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明本身很好地概述了该类提供的功能。我们注意到的第一件事是它是完全静态的。这确保了当固件启动时立即初始化了该类的功能，并且可以在全局范围内访问，而不必担心特定实例。
- en: We can also see the first use of the `uint32` type, which along with other integer
    types is defined similar to those in the `cstdint` header.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到`uint32`类型的第一次使用，它与其他整数类型一样定义，类似于`cstdint`头文件中的定义。
- en: 'Moving on, here is the implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是实现部分：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We include the `BaseModule` class's header here, so that we can call its own
    initialization function later on after we have finished setting up the basic functionality.
    The static class members are also initialized here, with a number of default values
    assigned where relevant.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里包含了`BaseModule`类的头文件，以便在设置基本功能后，我们可以调用其自己的初始化函数。静态类成员也在这里初始化，其中相关的默认值被赋予。
- en: Of note here is the initializing of a second serial interface object in addition
    to the default Serial object instance. These correspond to the first (UART0, Serial)
    and second (UART1, Serial1) UART on the ESP8266.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是除了默认的Serial对象实例之外，还初始化了第二个串行接口对象。这对应于ESP8266上的第一个（UART0，Serial）和第二个（UART1，Serial1）UART。
- en: With older versions of Sming, the SPIFFS-related file functions had trouble
    with binary data (due to internally assuming null-terminated strings), which is
    why the following alternative functions were added. Their naming is a slightly
    inverted version from the original function name to prevent naming collisions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的Sming中，与二进制数据有关的SPIFFS文件函数存在问题（由于内部假定空终止字符串），这就是为什么添加了以下替代函数的原因。它们的命名是原始函数名称的略微倒置版本，以防止命名冲突。
- en: Since TLS certificates and other binary data files stored on SPIFFS have to
    be able to be written and read for the firmware to function correctly, this was
    a necessary compromise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SPIFFS上存储的TLS证书和其他二进制数据文件必须能够被写入和读取，以使固件能够正确运行，这是一个必要的妥协。
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function reads the entire contents of the specified file into a `String`
    instance that is returned.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将指定文件的整个内容读入返回的`String`实例中。
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function replaces the existing content in a file with the new data in the
    provided `String` instance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数用提供的`String`实例中的新数据替换文件中的现有内容。
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is similar to `getFileContent()`, but returns a simple character
    buffer instead of a `String` instance. It's mostly used for reading in the certificate
    data, which is passed into a C-based TLS library (called axTLS), where converting
    to a `String` instance would be wasteful with the copying involved, especially
    where certificates can be a few KB in size.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数类似于`getFileContent()`，但返回一个简单的字符缓冲区，而不是一个`String`实例。它主要用于读取证书数据，该数据传递到基于C的TLS库（称为axTLS）中，在那里将其转换为`String`实例会涉及到复制，尤其是证书可能有几KB大小时，这种复制是浪费的。
- en: 'Next is the initialization function for this class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是该类的初始化函数：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We first initialize the two UARTs (serial interfaces) in the NodeMCU. Although
    officially there are two UARTs in the ESP8266, the second one consists only out
    of a TX output line (GPIO 2, by default). Because of this, we want to keep the
    first UART free for applications requiring a full serial line, such as some sensors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在NodeMCU中初始化了两个UART（串行接口）。尽管ESP8266中正式有两个UART，但第二个仅由TX输出线（默认为GPIO 2）组成。因此，我们希望保持第一个UART空闲，以供需要完整串行线的应用程序使用，比如一些传感器。
- en: The first UART (`Serial`) is thus initialized so that we can later use it with
    feature modules, while the second UART (`Serial1`) is initialized to the default
    baud rate of 115,200, along with the system's debug output (WiFi/IP stack, and
    so on) being directed to this serial output as well. This second serial interface
    will thus be used solely for logging output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首个UART（`Serial`）被初始化，以便我们以后可以将其与功能模块一起使用，而第二个UART（`Serial1`）被初始化为默认波特率115,200，系统的调试输出（WiFi/IP堆栈等）也被定向到此串行输出。因此，这第二个串行接口将仅用于日志输出。
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, the `BaseModule` static class is initialized as well. This causes all
    feature modules active in this firmware to be registered, allowing them to be
    activated later on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`BaseModule`静态类也被初始化。这使得在该固件中激活的所有功能模块都被注册，从而可以在以后激活它们。
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Automatically mounting the SPIFFS filesystem while using the rBoot bootloader
    did not work with older releases of Sming, which is why we are doing it manually
    here. To do this, we get the current firmware slot from rBoot, using which we
    can pick the proper offset, either at the start of the second megabyte in the
    ROM, or of the fourth megabyte.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用rBoot引导加载程序时自动挂载SPIFFS文件系统在较旧版本的Sming中无法正常工作，这就是为什么我们在这里手动执行它的原因。为此，我们从rBoot获取当前固件槽，然后我们可以选择适当的偏移量，可以是在ROM中的第二兆字节的开头，也可以是第四兆字节的开头。
- en: With the offset determined, we use the SPIFFS manual-mounting function with
    our offset and the size of the SPIFFS section. We are now able to read and write
    to our storage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了偏移量后，我们使用SPIFFS手动挂载函数以及我们的偏移量和SPIFFS部分的大小。现在我们可以读写我们的存储空间了。
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we print out a few system details to the serial debug output. This includes
    the ESP8266 SDK version we compiled against, the current free heap size, CPU frequency,
    the MCU ID (32-bit ID), and the ID of the SPI ROM chip.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在串行调试输出中打印出一些系统详细信息。这包括我们编译的ESP8266 SDK版本、当前的空闲堆大小、CPU频率、MCU ID（32位ID）和SPI
    ROM芯片的ID。
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We create a new MQTT client on the heap, providing the callback that will be
    called when we receive a new message. The MQTT broker host and port are filled
    in by the preprocessor from the details we added in the user Makefile for the
    project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在堆上创建一个新的MQTT客户端，提供一个回调函数，当我们接收到新消息时将被调用。MQTT代理主机和端口由预处理器填充，从用户为项目添加的细节中获取。
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the final steps in the initialization, we output the current firmware slot
    that we are running from, then enable the Wi-Fi client while disabling the **wireless
    access point** (**WAP**) functionality. The WiFi client is told to connect to
    the WiFi SSID with the credentials that we specified previously in the Makefile.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始化的最后步骤，我们输出当前固件槽，然后启用Wi-Fi客户端，同时禁用**无线接入点**（WAP）功能。Wi-Fi客户端被告知连接到我们在之前的Makefile中指定的Wi-Fi
    SSID和凭据。
- en: Finally, we define the handlers for a successful WiFi connection and for a failed
    connection attempt, before calling the callback function we were provided with
    as a parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了成功的WiFi连接和连接尝试失败的处理程序，然后调用我们作为参数提供的回调函数。
- en: 'After an OTA update of the firmware, the following callback function will be
    called:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 固件OTA更新后，将调用以下回调函数：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this callback, we change the active ROM slot if the OTA update was successful,
    followed by a reboot of the system. Otherwise, we simply log an error and do not
    restart.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个回调中，如果OTA更新成功，我们会更改活动的ROM槽，然后重新启动系统。否则，我们只是记录一个错误，不重新启动。
- en: 'Next are a few MQTT-related functions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一些与MQTT相关的函数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These two functions allow feature modules to respectively register and deregister
    an MQTT topic along with a callback. The MQTT broker is called with a subscription
    or unsubscribe request and the `HashMap` instance is updated accordingly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数分别允许特性模块注册和注销一个MQTT主题以及回调函数。MQTT代理通过订阅或取消订阅请求进行调用，并相应地更新`HashMap`实例：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Any feature modules can publish an MQTT message on any topic using this function.
    The **Quality of Service** (**QoS**) parameter determines the publish mode. By
    default, messages are published in *retain* mode, meaning that the broker will
    retain the last published message for a particular topic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特性模块都可以使用此函数在任何主题上发布MQTT消息。**服务质量**（QoS）参数确定发布模式。默认情况下，消息以*retain*模式发布，这意味着代理将保留特定主题的最后一条发布消息。
- en: 'The entry point for the OTA update functionality is found in the following
    function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新功能的入口点在以下函数中找到：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For an OTA update, we need to create a clean `rBootHttpUpdate` instance. We
    then need to configure this instance with the details of the current firmware
    slot, for which we obtain the configuration from rBoot and with it the current
    firmware slot number. This we use to give the number of the other firmware slot
    to the OTA updater.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OTA更新，我们需要创建一个干净的`rBootHttpUpdate`实例。然后，我们需要使用rBoot获取当前固件槽的详细信息，并从中获取当前固件槽号。我们使用这个号码将另一个固件槽的号码提供给OTA更新程序。
- en: Here, we only configure it to update the firmware slot, but we could also update
    the SPIFFS section for the other firmware slot as well this way. The firmware
    will be fetched over HTTP from the fixed URL we set before. The ESP8266's MAC
    address is affixed to the end of it as a unique query string parameter so that
    the update server knows which firmware image fits this system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只配置它来更新固件槽，但我们也可以以这种方式更新其他固件槽的SPIFFS部分。固件将通过HTTP从我们之前设置的固定URL获取。ESP8266的MAC地址将作为唯一的查询字符串参数附加到URL的末尾，以便更新服务器知道哪个固件映像适合这个系统。
- en: 'After setting the `callback` function that we looked at earlier, we start the
    update:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了我们之前查看的`callback`函数之后，我们开始更新：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we define the MQTT disconnection handler. It is called whenever the connection
    with the MQTT broker fails so that we can try reconnecting after a two-second
    delay.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了MQTT断开连接处理程序。每当与MQTT代理的连接失败时，都会调用它，以便我们可以在两秒延迟后尝试重新连接。
- en: The flag parameter is set to true if we previously were connected, and false
    if the initial MQTT broker connection failed (no network access, wrong address,
    and so on).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前已连接，则将标志参数设置为true，如果初始MQTT代理连接失败（无网络访问、错误的地址等），则设置为false。
- en: 'Next is the function to configure and start the MQTT client:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是配置和启动MQTT客户端的函数：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We stop the procTimer timer if it's running in case we were being called from
    a reconnect timer. Next, we set the **last will and testament** (**LWT**) for
    this device, which allows us to set a message that the MQTT broker will publish
    when it loses the connection with the client (us).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是从重新连接定时器调用的，我们会停止procTimer定时器。接下来，我们为该设备设置**遗嘱**（LWT），这允许我们设置一个消息，当MQTT代理与客户端（我们）失去连接时，代理将发布该消息。
- en: 'Next, we define three different execution paths, only one of which will be
    compiled, depending on whether we are using TLS (SSL), a username/password login,
    or anonymous access:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了三条不同的执行路径，只有其中一条将被编译，取决于我们是否使用TLS（SSL）、用户名/密码登录或匿名访问：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we are using TLS certificates, we establish a connection with the MQTT broker,
    using our `MAC` as client identifier, then enable the SSL option for the connection.
    The available heap space is printed to the serial logging output for debugging
    purposes. Usually, at this point, we should have around 25 KB of RAM left, which
    is sufficient for holding the certificate and key in memory, along with the RX
    and TX buffers for the TLS handshake if the latter are configured on the SSL endpoint
    to be an acceptable size using the SSL fragment size option. We will look at this
    in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml), *Example
    - Building Management and Control*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用TLS证书，我们将使用我们的`MAC`作为客户端标识符与MQTT代理建立连接，然后为连接启用SSL选项。可用的堆空间将被打印到串行日志输出以进行调试。通常，在这一点上，我们应该还剩下大约25KB的RAM，这足以在内存中保存证书和密钥，以及TLS握手的RX和TX缓冲区，如果后者使用SSL分段大小选项配置为可接受的大小。我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地讨论这个问题，*示例-建筑管理和控制*。
- en: Next, we read the DER-encoded (binary) certificate and key files from SPIFFS.
    These files have a fixed name. For each file, we print out the file size, along
    with the current free heap size. If either file size is zero bytes, we consider
    the read attempt to have failed and we abort the connection attempt.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从SPIFFS中读取DER编码（二进制）证书和密钥文件。这些文件有固定的名称。对于每个文件，我们都会打印出文件大小，以及当前的空闲堆大小。如果任一文件大小为零字节，我们将认为读取尝试失败，并中止连接尝试。
- en: Otherwise, we use the key and certificate data with the MQTT connection, which
    should lead to a successful handshake and establishing an encrypted connection
    with the MQTT broker.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将使用密钥和证书数据进行MQTT连接，这应该导致成功的握手并与MQTT代理建立加密连接。
- en: 'After deleting the key and certificate file data, we print out the free heap
    size to allow us to check that the cleanup was successful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除密钥和证书文件数据后，我们打印出空闲堆大小，以便我们可以检查清理是否成功：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When using an MQTT username and password to log in to the broker, we just need
    to call the previous function on the MQTT client instance, providing our MAC as
    client identifier along with the username and password:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MQTT用户名和密码登录代理时，我们只需要在MQTT客户端实例上调用先前的函数，提供我们的MAC作为客户端标识符，以及用户名和密码。
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To connect anonymously, we set up a connection with the broker and pass our
    `MAC` as the client identifier:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要匿名连接，我们与代理建立连接，并将我们的`MAC`作为客户端标识符传递：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we first set the MQTT disconnect handler. Then, we subscribe to a number
    of topics that we wish to respond to. These all relate to management functionality
    for this firmware, allowing the system to be queried and configured over MQTT.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先设置了MQTT断开处理程序。然后，我们订阅了一些我们希望响应的主题。所有这些都与此固件的管理功能有关，允许系统通过MQTT进行查询和配置。
- en: After subscribing, we briefly (100 ms) wait to give the broker some time to
    process these subscriptions before we publish on the central notification topic,
    using our `MAC` to let any interested clients and servers know that this system
    just came online.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅后，我们稍微（100毫秒）等待，以便代理有时间处理这些订阅，然后我们在中央通知主题上发布，使用我们的`MAC`来让任何感兴趣的客户端和服务器知道这个系统刚刚上线。
- en: 'Next are the WiFi connection handlers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是WiFi连接处理程序：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This handler is called when we have successfully connected to the configured
    WiFi network using the provided credentials. After connecting, we keep a copy
    of our `MAC` in memory as our unique ID.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们成功使用提供的凭据连接到配置的WiFi网络时，将调用此处理程序。连接后，我们将`MAC`的副本保存在内存中作为我们的唯一ID。
- en: This firmware also supports specifying a user-defined string as our location
    or similar identifier. If one has been defined before, we load it from SPIFFS
    and use it; otherwise, our location string is simply the `MAC`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此固件还支持指定用户定义的字符串作为我们的位置或类似标识符。如果之前已定义了一个，我们将从SPIFFS加载它并使用它；否则，我们的位置字符串就是`MAC`。
- en: 'Similarly, we load the 32-bit bitmask that defines the feature module configuration
    from SPIFFS if it exists. If not, all feature modules are initially left deactivated.
    Otherwise, we read the bitmask and pass it to the `updateModules()` function so
    that the relevant modules will be activated:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果存在，我们会从SPIFFS加载定义特征模块配置的32位位掩码。如果不存在，所有特征模块最初都处于未激活状态。否则，我们读取位掩码并将其传递给`updateModules()`函数，以便激活相关模块：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If connecting to the Wi-Fi network fails, we log this fact, then tell the MCU's
    watchdog timer that we are still alive to prevent a soft restart before we attempt
    to connect again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接到WiFi网络失败，我们会记录这一事实，然后告诉MCU的看门狗定时器我们仍然活着，以防止在我们再次尝试连接之前发生软重启。
- en: 'This finishes all of the initialization functions. Next up are the functions
    used during normal activity, starting with the MQTT message handler:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了所有的初始化函数。接下来是在正常活动期间使用的函数，从MQTT消息处理程序开始：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We registered this callback when we initially created the MQTT client instance.
    Every time a topic that we subscribed to receives a new message on the broker,
    we are notified and this callback receives a string containing the topic and another
    string containing the actual message (payload).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在最初创建MQTT客户端实例时注册了此回调。每当我们订阅的主题在代理上接收到新消息时，我们都会收到通知，并且此回调会接收一个包含主题的字符串和另一个包含实际消息（有效载荷）的字符串。
- en: We can compare the topic with the topics we registered for, and perform the
    required operation, whether it is to perform an OTA update (if it specifies our
    `MAC`), respond to a ping request by returning a pong response with our `MAC`,
    or to restart the system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将主题与我们注册的主题进行比较，并执行所需的操作，无论是执行OTA更新（如果指定了我们的`MAC`），通过返回带有我们的`MAC`的pong响应来响应ping请求，还是重新启动系统。
- en: 'The next topic is a more generic maintenance one, allowing one to configure
    active feature modules, set the location string, and request the current status
    of the system. The payload format consists out of the command string followed
    by a semicolon, and then the payload string:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题是一个更通用的维护主题，允许配置活动特征模块，设置位置字符串，并请求系统的当前状态。有效负载格式由命令字符串后跟一个分号，然后是有效负载字符串组成：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We start by extracting the command from the payload string using a simple find
    and substring approach. We then read in the remaining payload string, taking care
    to read it in as a binary string. For this, we use the remaining string's length
    and as starting position, the character right after the semicolon.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用简单的查找和子字符串方法从有效负载字符串中提取命令。然后，我们读取剩余的有效负载字符串，注意以二进制字符串形式读取。为此，我们使用剩余字符串的长度，并将分号后的字符作为起始位置。
- en: 'At this point, we have extracted the command and payload and can see what we
    have to do:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经提取了命令和有效负载，并可以看到我们需要做什么：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This command sets which feature modules should be active. Its payload should
    be an unsigned 32-bit integer forming a bitmask, which we check to make sure that
    we have received exactly four bytes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令设置应该激活哪些特征模块。其有效负载应该是一个无符号32位整数形成的位掩码，我们检查以确保我们确实收到了四个字节。
- en: 'In the bitmask, the bits each match up with a module, which at this point are
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在位掩码中，每个位与一个模块相匹配，这些模块目前是以下这些：
- en: '| **Bit position** | **Value** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **位位置** | **值** |'
- en: '| 0x01 | THPModule |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | THPModule |'
- en: '| 0x02 | CO2Module |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | CO2Module |'
- en: '| 0x04 | JuraModule |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | JuraModule |'
- en: '| 0x08 | JuraTermModule |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 0x08 | JuraTermModule |'
- en: '| 0x10 | MotionModule |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 0x10 | MotionModule |'
- en: '| 0x20 | PwmModule |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 0x20 | PwmModule |'
- en: '| 0x40 | IOModule |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 0x40 | IOModule |'
- en: '| 0x80 | SwitchModule |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | SwitchModule |'
- en: '| 0x100 | PlantModule |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0x100 | PlantModule |'
- en: Of these, the CO2, Jura, and JuraTerm modules are mutually exclusive, since
    they all use the first UART (`Serial`). If two or more of these are still specified
    in the bitmask, only the first module will be enabled and the others ignored.
    We will look at these other feature modules in more detail in [Chapter 9](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml),
    *Example - Building Management and Control*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，CO2、Jura和JuraTerm模块是互斥的，因为它们都使用第一个UART（`Serial`）。如果在位掩码中仍然指定了其中两个或更多个，只有第一个模块将被启用，其他模块将被忽略。我们将在[第9章](d165297b-8be7-44f5-90b5-53b3bcb51d3b.xhtml)中更详细地查看这些其他特征模块，*示例-建筑管理和控制*。
- en: 'After we obtain the new configuration bitmask, we send it to the `updateModules()`
    function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取新的配置位掩码后，我们将其发送到`updateModules()`函数：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this command, we set the new location string, if it is different then
    the current one, also saving it to the location file in SPIFFS to persist it across
    a reboot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，如果新位置字符串与当前位置字符串不同，则设置新的位置字符串，并将其保存到SPIFFS中的位置文件中，以便在重新启动时保持：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last three commands in this section return the current bitmask for the
    active feature modules, the firmware version, and trigger an OTA upgrade:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的最后三个命令返回活动特征模块的当前位掩码、固件版本，并触发OTA升级：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last entry in the `if...else` block looks at whether the topic is perhaps
    found in our list of callbacks for the feature modules. If found, the callback
    is called with the MQTT message string.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`块中的最后一个条目查看主题是否可能在我们的特征模块回调列表中找到。如果找到，将使用MQTT消息字符串调用回调。'
- en: 'Naturally, this means that only one feature module can register itself to a
    specific topic. Since each module tends to operate under its own MQTT sub-topic
    to segregate the message flow, this is generally not a problem:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只有一个特征模块可以向特定主题注册自己。由于每个模块倾向于在自己的MQTT子主题下运行以分隔消息流，这通常不是问题：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function is pretty simple. It mostly serves as a pass-through for the `BaseModule`
    class, but it also ensures that we keep the configuration file in SPIFFS up to
    date, writing the new bitmask to it when it has changed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单。它主要作为`BaseModule`类的一个传递，但它还确保我们保持SPIFFS中的配置文件是最新的，在更改时将新的位掩码写入其中。
- en: 'We absolutely must prevent unnecessary writes to SPIFFs, as the underlying
    Flash storage has finite write cycles. Limiting write cycles can significantly
    extend the lifespan of the hardware, as well as reduce overall system load:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对必须防止对SPIFFs的不必要写入，因为底层闪存存储具有有限的写入周期。限制写入周期可以显著延长硬件的使用寿命，同时减少整个系统的负载：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This function maps the given GPIO pin number to its position in the internal
    bitmask. It uses the enumeration we looked at for the header file for this class.
    With this mapping, we can set the used/unused state of GPIO pins of the ESP8266
    module using just a single uint32 value:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将给定的GPIO引脚号映射到其在内部位掩码中的位置。它使用我们为此类的头文件查看的枚举。有了这个映射，我们可以使用一个单一的uint32值设置ESP8266模块的GPIO引脚的使用/未使用状态：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the logging method, we append the log level to the message string before
    writing it to the serial output, as well as publishing it on MQTT. Here, we publish
    on a single topic, but as a refinement you could log on a different topic depending
    on the specified level.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录方法中，我们在将消息字符串写入串行输出之前将日志级别附加到消息字符串，并在MQTT上发布它。在这里，我们在一个单一主题上发布，但作为改进，您可以根据指定的级别在不同主题上记录。
- en: 'What makes sense here depends a great deal on what kind of backend you have
    set up to listen for and process logging output from the ESP8266 systems running
    this firmware:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的合理性取决于您设置的用于侦听和处理运行此固件的ESP8266系统的日志输出的后端类型：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function starts the I2C bus if it hasn't been started already. It tries
    to register the pins it wishes to use for the I2C bus. If these are available,
    it will set the clock line (SCL) to output mode and first pulse it eight times
    to unfreeze any I2C devices on the bus.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果I2C总线尚未启动，此函数将启动它。它尝试注册它希望用于I2C总线的引脚。如果这些引脚可用，它将将时钟线（SCL）设置为输出模式，并首先脉冲它八次以解冻总线上的任何I2C设备。
- en: After pulsing the clock line like his, we start the I2C bus on the pins and
    make a note of the active state of this bus.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样脉冲时钟线后，我们在引脚上启动I2C总线，并记录此总线的活动状态。
- en: 'Frozen I2C devices can occur if the MCU power cycles when the I2C devices do
    not, and remain in an indeterminate state. With this pulsing, we make sure that
    the system won''t end up in a non-functional state, requiring manual intervention:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果MCU断电时I2C设备没有断电并保持在不确定状态，可能会发生冻结的I2C设备。通过这种脉冲，我们确保系统不会陷入非功能状态，需要手动干预：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Starting the SPI bus is similar to staring the I2C bus, except without a similar
    recovery mechanism:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 启动SPI总线类似于启动I2C总线，但没有类似的恢复机制：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This overloaded function is used to register a GPIO pin by a feature module
    before it starts, to ensure that no two modules attempt to use the same pins at
    the same time. One version accepts a pin number (GPIO) and uses the mapping function
    we looked at earlier to get the bit address in the `esp8266_pins` bitmask before
    passing it on to the other version of the function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载函数用于在启动之前由特征模块注册GPIO引脚，以确保没有两个模块同时使用相同的引脚。一个版本接受引脚号（GPIO），并使用我们之前查看的映射函数来获取`esp8266_pins`位掩码中的位地址，然后将其传递给函数的另一个版本。
- en: 'In that function, the pin enumeration is used to do a bitwise `AND` comparison.
    If the bit has not been set yet, it is toggled and true is returned. Otherwise,
    the function returns false and the calling module knows that it cannot proceed
    with its initialization:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，引脚枚举用于进行按位`AND`比较。如果位尚未设置，则切换并返回true。否则，函数返回false，调用模块知道它无法继续初始化：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This overloaded function, to release a pin when a feature module is shutting
    down, works in a similar manner. One uses the mapping function to get the bit
    address, the other performs a bitwise `AND` operation to check that the pin has
    in fact been set, and toggles it to an off position with the bitwise `OR` assignment
    operator if it was set.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载函数用于在特征模块关闭时释放引脚，工作方式类似。一个使用映射函数获取位地址，另一个执行按位`AND`操作来检查引脚是否已经设置，并使用按位`OR`赋值运算符将其切换到关闭位置。
- en: BaseModule
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BaseModule
- en: 'This class contains the logic for registering and keeping track of which feature
    modules are currently active or inactive. Its header file looks as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含了注册和跟踪当前活动或非活动特征模块的逻辑。其头文件如下所示：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The inclusion of the `OtaCore` header is to allow us to use the logging feature.
    Beyond this, we create another enumeration, which maps a specific feature module
    to a particular bit in the feature module bitmask (`active_mods`).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`OtaCore`头文件是为了让我们能够使用日志记录功能。此外，我们创建另一个枚举，将特定特征模块映射到特征模块位掩码（`active_mods`）中的特定位。
- en: 'Finally, function pointers are defined, which are used for respectively starting
    and shutting down a feature module. These will be defined by the feature modules
    as they register themselves:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义了函数指针，分别用于启动和关闭特征模块。这些将由特征模块在注册自己时定义：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the feature modules that currently exist for this firmware as of writing.
    Since we only need the plant module for this project, we could comment out all
    header files for the other modules, along with their initialization in the initialization
    function of this class.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是目前存在于该固件中的特征模块。由于我们只需要植物模块用于这个项目，我们可以注释掉所有其他模块的头文件，以及它们在该类的初始化函数中的初始化。
- en: This would not affect the resulting firmware image in any way other than that
    we cannot enable those modules since they do not exist.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会影响生成的固件映像，除了我们不能启用那些模块，因为它们不存在。
- en: 'Finally, here is the class declaration itself:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是类声明本身：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Each feature module is represented internally by a `SubModule` instance, the
    details of which we can see in a moment in the class definition:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特征模块在内部由一个`SubModule`实例表示，我们可以在类定义中看到其详细信息：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since this is a static class, we first initialize its class variables. We have
    an array with space for 32 `SubModule` instances, to fit the full bitmask. Beyond
    this, no modules are active, so everything is initialized to zero and false:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个静态类，我们首先初始化其类变量。我们有一个数组，可以容纳32个`SubModule`实例，以适应完整的位掩码。此外，没有模块是活动的，所以一切都初始化为零和假：
- en: '[PRE51]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we called this function in `OtaCore`, we also triggered the registration
    of the feature modules defined here. By selectively removing or commenting out
    modules in this function, we can remove them from the final firmware image. Those
    modules that are called here will call the following function to register themselves:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`OtaCore`中调用此函数时，我们还触发了在此处定义的特征模块的注册。通过在此函数中有选择地删除或注释掉模块，我们可以将它们从最终的固件映像中移除。在这里调用的那些模块将调用以下函数来注册自己：
- en: '[PRE52]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The first feature module that calls this function will trigger the initialization
    of the `SubModule` array, setting all of its values to a neutral setting, while
    also creating the bitmask for this position in the array, which allows us to update
    the `active_mods` bitmask, as we will see in a moment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数的第一个特征模块将触发`SubModule`数组的初始化，将其所有值设置为中性设置，同时为数组中的此位置创建位掩码，这允许我们更新`active_mods`位掩码，我们将在一会儿看到。
- en: 'After initializing the array, we check whether this position in the array already
    has a module registered for it. If it has, we return false. Otherwise, we register
    the module''s function pointers for starting and shutting down, and increase the
    active module count before returning true:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组后，我们检查数组中的这个位置是否已经有模块为其注册。如果有，我们返回false。否则，在返回true之前，我们注册模块的启动和关闭函数指针，并增加活动模块计数：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The input parameter to this function is the bitmask we extracted from the MQTT
    payload in `OtaCore`. Here, we use a bitwise XOR comparison with the active modules
    bitmask to obtain a new bitmask indicating any changes to be made. If the result
    is zero, we know that they're identical and we can return without further action
    being required.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的输入参数是我们从`OtaCore`中提取的MQTT有效载荷中的位掩码。在这里，我们使用按位异或比较与活动模块位掩码，以获得指示要进行的任何更改的新位掩码。如果结果为零，我们知道它们是相同的，我们可以返回而无需进一步操作。
- en: The `uint32` bitmask we have thus obtained indicates which modules should be
    toggled on or off. For this, we check each bit of the mask. If it is a `1` (AND
    operator returns a value that's not zero), we check whether the module at that
    position in the array exists and has been started yet.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们获得的`uint32`位掩码指示应该打开或关闭哪些模块。为此，我们检查掩码的每一位。如果它是`1`（AND运算符返回一个不为零的值），我们检查数组中该位置的模块是否存在并且是否已经启动。
- en: If the module has been started, we attempt to shut it down. If the module's
    shutdown() function succeeds (returns true), we toggle the bit in the `active_mods`
    bitmask to update its status. Similarly, if the module has not been started yet,
    a module has been registered at that location, we attempt to start it, updating
    the active modules if this succeeds.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块已启动，我们尝试关闭它。如果模块的shutdown()函数成功（返回true），我们切换`active_mods`位掩码中的位以更新其状态。同样，如果模块尚未启动，模块已经在该位置注册，我们尝试启动它，如果成功，更新活动模块。
- en: We check that a start function callback has been registered to ensure that we
    do not accidentally call an improperly registered module and crash the system.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查是否已注册启动函数回调，以确保我们不会意外调用未正确注册的模块并使系统崩溃。
- en: PlantModule
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PlantModule
- en: At this point, we have had a detailed look at the underlying, supporting code
    that makes life easy when writing a new module because we don't have to do all
    of the housekeeping ourselves. The only thing we haven't seen yet is an actual
    module, or code directly pertaining to this chapter's project.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细查看了在编写新模块时使生活变得轻松的支持代码。因为我们不必自己做所有的杂务。我们还没有看到的唯一的事情是一个实际的模块，或者直接与本章项目有关的代码。
- en: 'In this section, we will look at the last part of the puzzle, the `PlantModule`
    itself:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下谜题的最后一部分，即`PlantModule`本身：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Of note in this class declaration is the inclusion of the APA102 library header.
    This is a simple library that allows us to write color and brightness data to
    APA102 RGB (full-spectrum) LEDs, over the SPI bus.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类声明中需要注意的是包含了APA102库头文件。这是一个简单的库，允许我们将颜色和亮度数据写入APA102 RGB（全光谱）LED，通过SPI总线。
- en: We also define the pin that we wish to use to trigger the peristaltic pump (GPIO
    5) and the number of connected APA102 LED modules (1). You can add multiple APA102
    LEDs in series if you want, simply updating the definition to match the count.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了我们希望用来触发蠕动泵（GPIO 5）的引脚以及连接的APA102 LED模块的数量（1）。如果需要，您可以串联多个APA102 LED，只需更新定义以匹配计数。
- en: 'Next is the class implementation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是类的实现：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this section, we initialize the static class members, setting the GPIO pin
    and defining the initial sensor value at which the pump should be triggered. This
    trigger value should be updated to match your own sensor calibration results.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们初始化静态类成员，设置GPIO引脚并定义触发泵应该触发的初始传感器值。应该更新此触发值以匹配您自己的传感器校准结果。
- en: 'Finally, we define an enumeration containing the possible commands for this
    module that can be sent to it over MQTT:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个包含可以通过MQTT发送到该模块的可能命令的枚举：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the initialization function the `BaseModule` calls on startup. As we
    can see, it causes this module to register itself with preset values, including
    its start and shutdown callbacks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`BaseModule`在启动时调用的初始化函数。正如我们所看到的，它导致该模块使用预设值注册自身，包括其启动和关闭回调：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When this module starts, we attempt to claim the pin we wish to use for triggering
    the pump, as well as register a callback for an MQTT topic so that we can accept
    commands using the command handler callback. The topic on which we will responses
    after processing a command is also defined here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当此模块启动时，我们尝试声明我们希望用于触发泵的引脚，并注册一个MQTT主题的回调，以便我们可以使用命令处理程序回调接受命令。在此还定义了在处理完命令后我们将响应的主题。
- en: The output pin mode is set, followed by the starting of the HTTP server on port
    80, registering a basic handler for client requests. Next, we create a new `APA102`
    class instance and use it to get the connected LED to display green at about half
    of full brightness.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 设置输出引脚模式，然后在端口80上启动HTTP服务器，注册客户端请求的基本处理程序。接下来，我们创建一个新的`APA102`类实例，并使用它使连接的LED显示绿色，亮度约为全亮度的一半。
- en: 'Finally, we start a timer that will trigger the reading out of the connected
    soil sensor every minute:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动一个定时器，每分钟触发一次连接的土壤传感器的读数：
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When shutting down this module, we release the pin we registered previously,
    stop the web server, delete the RGB LED class instance (with a check to see that
    deleting it is necessary), deregister our MQTT topic, and finally stop the sensor
    timer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭此模块时，我们释放先前注册的引脚，停止Web服务器，删除RGB LED类实例（检查是否需要删除它），注销我们的MQTT主题，最后停止传感器定时器。
- en: '[PRE59]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This callback is called whenever a message is published on the MQTT topic we
    registered. In our messages, we expect to find a single byte (uint8) value that
    defines the command, up to eight distinct commands. For this module, we earlier
    defined three commands.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在注册的MQTT主题上发布消息时，都会调用此回调。在我们的消息中，我们期望找到一个定义命令的单个字节（uint8）值，最多八个不同的命令。对于此模块，我们之前定义了三个命令。
- en: 'These commands are defined as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的定义如下：
- en: '| **Command** | **Meaning** | **Payload** | **Return value** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **意义** | **有效载荷** | **返回值** |'
- en: '| 0x01 | Get soil moisture | - | 0xXXXX |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 0x01 | 获取土壤湿度 | - | 0xXXXX |'
- en: '| 0x02 | Set trigger level | uint16 (new trigger level) | - |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 0x02 | 设置触发级别 | uint16（新触发级别） | - |'
- en: '| 0x04 | Get trigger level | - | 0xXXXX |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 0x04 | 获取触发级别 | - | 0xXXXX |'
- en: Here, every command returns the requested value, if applicable.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个命令返回请求的值（如果适用）。
- en: After checking that the message string we got has at least one byte in it, we
    extract the first byte and try to interpret it as a command. If we are setting
    a new trigger point, we also extract the new value as a uint16 from the message
    after making sure that we have a properly formed message.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查我们得到的消息字符串至少有一个字节后，我们提取第一个字节，并尝试将其解释为一个命令。如果我们正在设置一个新的触发点，我们还会从消息中提取新值作为uint16，然后确保我们有一个格式正确的消息。
- en: 'Finally, here is the function in which all of the magic happens that we have
    been working toward in this project:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个函数，在这个项目中我们一直在努力实现的所有魔术都发生在这个函数中：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As the first step, we read out the current sensor value from the analog input
    of the ESP8266 and publish it on the MQTT topic for this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们从ESP8266的模拟输入中读取当前传感器值，并将其发布到MQTT主题上：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: During calibration of one prototype with a soil moisture sensor, it was found
    that the value for a completely dry sensor (held in the air) was approximately
    766, whereas having the same sensor submerged in water got 379 as a value. From
    this, we can deduce that 60% moisture content should be roughly around a reading
    of 533, which matches the initial value we set during the static initialization
    step. The ideal trigger point and target soil moisture level of course depends
    on the soil type and specific plant.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在校准一个带有土壤湿度传感器的原型机时，发现完全干燥的传感器（悬空）的值约为766，而将相同的传感器浸入水中得到379的值。由此，我们可以推断出60%的含水量大约应该在533左右的读数，这与我们在静态初始化步骤中设置的初始值相匹配。理想的触发点和目标土壤湿度水平当然取决于土壤类型和具体植物。
- en: With this trigger level reached, we set the output pin that is connected to
    the enable pin of the boost converter to high, causing it to turn on its output,
    which in turn starts the pump. We wish to let it pump for about ten seconds.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到这个触发电平时，我们将设置连接到升压转换器使能引脚的输出引脚为高电平，导致其打开输出，从而启动泵。我们希望让它泵送大约十秒钟。
- en: During this time we set the LED color to blue, then during each second we drop
    its brightness from 100% to nearly off and then back to full brightness again,
    creating a pulsating effect.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们将LED颜色设置为蓝色，然后在每秒钟内将其亮度从100%降低到几乎关闭，然后再次提高到全亮度，从而产生脉动效果。
- en: 'After this, we set the output pin back to low, which disables the pump, and
    we await the next soil moisture sensor reading:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将输出引脚设置回低电平，从而禁用泵，并等待下一个土壤湿度传感器读数：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, we see here the request handler for our web server. What it does is
    read in a template file from SPIFFS (detailed in the next section), gets the list
    of variables in this template file, and then proceeds to read out the current
    sensor value.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在这里看到了我们的Web服务器的请求处理程序。它的作用是从SPIFFS中读取模板文件（在下一节中详细介绍），获取此模板文件中的变量列表，然后继续读取当前传感器值。
- en: Using this value, it calculates the current soil moisture percentage and uses
    both the raw and calculated numbers to fill in the two variables in the template
    before returning it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个值，它计算当前土壤湿度百分比，并使用原始和计算出的数字填充模板中的两个变量，然后返回它。
- en: Index.html
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Index.html
- en: 'For use with the PlantModule''s web server, we have to add the following template
    file to SPIFFS:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与PlantModule的Web服务器配合使用，我们必须将以下模板文件添加到SPIFFS中：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Compiling and flashing
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和刷写
- en: 'After finishing the code for our application, we can compile it with a single
    command in the project''s root folder:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 完成应用程序的代码后，我们可以在项目的根目录中用一个命令编译它：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After this completes, we can find the binaries including the ROM images in the
    `out` folder. Since we are using both the rBoot bootloader and SPIFFs, we get
    three ROM images in total in the `firmware` folder.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以在`out`文件夹中找到包括ROM映像在内的二进制文件。由于我们同时使用rBoot引导加载程序和SPIFFs，因此在`firmware`文件夹中总共有三个ROM映像。
- en: At this point, we can connect an ESP8266 module, either in the form of a NodeMCU
    board or one of the many alternatives, and note the serial port that it will be
    connected to. On Windows, this will be something like `COM3`; on Linux, USB-to-serial
    adapters usually are registered as `/dev/ttyUSB0` or similar.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以连接一个ESP8266模块，可以是NodeMCU板或其他许多替代品，并注意它将连接到的串行端口。在Windows上，这将类似于`COM3`；在Linux上，USB转串口适配器通常注册为`/dev/ttyUSB0`或类似的。
- en: 'Unless we have specified the serial port (`COM_PORT`) in the user Makefile,
    we have to specify it explicitly when we flash to the ESP8266 module:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在用户Makefile中指定了串行端口（`COM_PORT`），否则在刷写到ESP8266模块时，我们必须明确指定它：
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After executing this command, we should see the output from the `esptool.py`
    utility, as it connects to the ESP8266's ROM and starts writing the ROM images
    to it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这个命令后，我们应该看到`esptool.py`实用程序的输出，因为它连接到ESP8266的ROM并开始将ROM映像写入其中。
- en: Once this is complete, the MCU will restart and it should boot straight into
    the new firmware image, where it will await our commands to configure it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，MCU将重新启动，并且应该直接启动到新的固件映像中，等待我们的命令来配置它。
- en: First-time configuration
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首次配置
- en: As noted earlier in this chapter, this firmware is designed to be configured
    and maintained over MQTT. This requires that an MQTT broker is available. An MQTT
    broker such as Mosquitto ([http://mosquitto.org/](http://mosquitto.org/)) is popular.
    Since it's a lightweight server, it can be installed on a desktop system, a small
    SBC, inside a virtual machine, and so on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面所述，这个固件是设计为通过MQTT进行配置和维护的。这需要有一个MQTT代理可用。像Mosquitto（[http://mosquitto.org/](http://mosquitto.org/)）这样的MQTT代理很受欢迎。由于它是一个轻量级服务器，它可以安装在桌面系统、小型SBC、虚拟机等内部。
- en: In addition the broker and the ESP8266 running the firmware, we also need our
    own client
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理和运行固件的ESP8266外，我们还需要我们自己的客户端
- en: to interact with the firmware. Since we use binary protocols, our choice there
    is somewhat
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与固件交互。由于我们使用二进制协议，我们在那里的选择有些受限
- en: limited, as most common MQTT desktop clients assume text-based messages. One
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有限，因为大多数常见的MQTT桌面客户端都假定是基于文本的消息。一个
- en: approach one can use to publish binary messages is to use the MQTT publish client
    that
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 发布二进制消息的一种方法是使用MQTT发布客户端，
- en: comes with Mosquitto and use the **echo** command-line tool's hexadecimal input
    to send
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Mosquitto附带的**echo**命令行工具的十六进制输入来发送
- en: binary data to it as a stream to be published by the client tool
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数据作为流由客户端工具发布
- en: 'Because of this, the author of this book has developed a new MQTT desktop client
    (based on C++ and Qt) that is designed around the use and debugging of binary
    protocols on MQTT: [https://github.com/MayaPosch/MQTTCute](https://github.com/MayaPosch/MQTTCute).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本书的作者开发了一个新的MQTT桌面客户端（基于C++和Qt），旨在围绕MQTT上的二进制协议的使用和调试：[https://github.com/MayaPosch/MQTTCute](https://github.com/MayaPosch/MQTTCute)。
- en: With all three components in place—ESP8266 running the project, the MQTT broker
    and desktop client—we can have the entire plant monitoring and watering system
    assembled and send it the command to enable the plant module.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个组件——运行该项目的ESP8266、MQTT代理和桌面客户端——我们可以组装整个植物监测和浇水系统，并发送命令以启用植物模块。
- en: While monitoring the cc/config topic for messages, we should see the ESP8266
    report its presence by publishing its `MAC`. We can also get this by hooking up
    a USB to TTL serial adapter to the serial logging output pin (`D4` on NodeMCU).
    By looking at the output on our serial console, we will see both the IP address
    and the `MAC` of the system.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视cc/config主题以获取消息时，我们应该看到ESP8266通过发布其`MAC`来报告其存在。我们也可以通过将USB连接到TTL串行适配器并连接到串行日志输出引脚（NodeMCU上的`D4`）来获得这一点。通过查看串行控制台上的输出，我们将看到系统的IP地址和`MAC`。
- en: 'When we compose a new topic of the format `cc/<MAC>`, we can then publish commands
    to the firmware, for example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们组成一个新的主题格式为`cc/<MAC>`时，我们可以发布命令到固件，例如：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This would set the location name of the system to `plant001`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把系统的位置名称设置为`plant001`。
- en: 'When using the MQTTCute client, we can use echo-style binary input, using hexadecimal
    input, to activate the plant module:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MQTTCute客户端时，我们可以使用回声式二进制输入，使用十六进制输入来激活植物模块：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This would send the `mod` command to the firmware, along with a bitmask with
    the value 0 x 100\. After this, the plant module should be activated and running.
    Since we are persisting both the location string and the configuration, we do
    not have to repeat this step any more unless we do an OTA update, at which point
    the new firmware will have an empty SPIFFS filesystem, unless we flash the same
    SPIFFS image on both SPIFFS slots on the ROM.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向固件发送`mod`命令，以及值为0 x 100的位掩码。之后，植物模块应该被激活并运行。由于我们持久化了位置字符串和配置，除非我们进行OTA更新，否则我们不必再重复这一步骤，此时新的固件将具有一个空的SPIFFS文件系统，除非我们在ROM的两个SPIFFS插槽上都刷入相同的SPIFFS映像。
- en: Here, we could expand the OTA code to also download a SPIFFS ROM image in addition
    to the firmware one, though this might add the complication of possibly overwriting
    the existing SPIFFS files.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以扩展OTA代码，除了固件之外还可以下载SPIFFS ROM映像，尽管这可能会增加可能覆盖现有SPIFFS文件的复杂性。
- en: At this point, we should have a working plant-monitoring and -watering system.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该有一个工作的植物监测和浇水系统。
- en: Using the system
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统
- en: We can use the measured values and store them in a database by subscribing to
    the `nsa/plant/moisture_raw` topic. The trigger point can be adjusted by sending
    a new command to the `plant/<location string>` topic.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用测量值并将其存储在数据库中，通过订阅`nsa/plant/moisture_raw`主题。可以通过向`plant/<位置字符串>`主题发送新命令来调整触发点。
- en: The web server on the device can be accessed by taking the IP address, which
    we can find either by looking at the output on the serial console, as described
    in the previous section, or by looking at the active IP addresses in your router.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的Web服务器可以通过获取IP地址来访问，我们可以通过查看串行控制台上的输出（如前一节所述），或者查看路由器中的活动IP地址来找到IP地址。
- en: By opening this IP address in the browser, we should see the HTML template filled
    in with the current values.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器中打开此IP地址，我们应该可以看到HTML模板填充了当前的值。
- en: Taking it further
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步进行
- en: 'You also need to have the following considerations:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要考虑以下事项：
- en: At this point, you can further refine the system by implementing plant-watering
    profiles to add dry periods or to adjust for certain soil types. You can add new
    RGB LED modes to make full use of the color choices available.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一点上，您可以通过实施植物浇水配置来进一步完善系统，以增加干旱期或调整特定土壤类型。您可以添加新的RGB LED模式，充分利用可用的颜色选择。
- en: The entire hardware could be built into an enclosure, to make it blend into
    the background, or maybe to make it more visible.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个硬件可以构建成一个外壳，使其融入背景，或者使其更加可见。
- en: The web interface could be extended to allow for controlling the trigger point
    and such from the browser, instead of having to use an MQTT client.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web界面可以扩展以允许从浏览器控制触发点等，而不必使用MQTT客户端。
- en: In addition to the moisture sensor, you could also add a brightness sensor,
    a temperature sensor, and so on, to measure more aspects that affect the plant's
    health.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了湿度传感器，您还可以添加亮度传感器、温度传感器等，以测量影响植物健康的更多方面。
- en: For bonus points, you could automate the applying of (liquid) fertilizer to
    the plant.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为额外加分项，您可以自动施加（液体）肥料到植物上。
- en: Complications
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂性
- en: One possible complication you may encounter with the ESP8266's ADC is that on
    the NodeMCU boards, the first reserved (RSV) pin that is right next to the ADC
    pin is directly connected to the ESP8266 module's ADC input. This can potentially
    cause issues with electrostatic discharge ESD exposure. Essentially the discharging
    of a high voltage, but low current, into the MCU. Adding a small capacitor on
    this RSV pin to ground can help reduce this risk.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的ESP8266的ADC的一个可能的复杂性是，在NodeMCU板上，紧邻ADC引脚的第一个保留（RSV）引脚直接连接到ESP8266模块的ADC输入。这可能会导致静电放电ESD暴露的问题。基本上是将高电压，但低电流的放电输入到MCU。在这个RSV引脚上添加一个小电容到地可以帮助减少这种风险。
- en: One thing that this system obviously cannot help with is to keep your plants
    pest-free. This means that though the watering may be automated, that doesn't
    mean that you can just ignore the plants. The regular checking of the plants for
    any issues, as well as the system for any issues that may be developing (disconnected
    tubing, things that have fallen over due to cats, and so on) remains an important
    task.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统显然无法帮助你保持植物免受害虫侵害。这意味着尽管浇水可能是自动的，但这并不意味着你可以忽视植物。定期检查植物是否有任何问题，以及系统是否存在任何可能正在发展的问题（断开的管道，因猫而倒下的东西等）仍然是一项重要任务。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to take a simple ESP8266-based project from
    theory and simple requirements to a functioning design with a versatile firmware
    and a collection of input and output options, using which we can ensure that a
    connected plant gets just the right amount of water to stay healthy. We also saw
    how to set up a development environment for the ESP8266.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何将基于简单ESP8266的项目从理论和简单要求转变为一个功能设计，具有多功能固件和一系列输入和输出选项，使用这些选项我们可以确保连接的植物得到恰到好处的水分以保持健康。我们还看到了如何为ESP8266建立开发环境。
- en: The reader should now be able to create projects for the ESP8266, program the
    MCU with new firmware, and have a solid grasp on both the strengths and limitations
    of this development platform.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该能够为ESP8266创建项目，用新固件对MCU进行编程，并对这个开发平台的优势和局限性有一个扎实的掌握。
- en: In the next chapter, we will be looking at how to test embedded software written
    for SoCs and other large, embedded platforms.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何测试为SoCs和其他大型嵌入式平台编写的嵌入式软件。
