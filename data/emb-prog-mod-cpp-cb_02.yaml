- en: Setting Up the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'To start working with an embedded system, we need to set up an environment.
    Unlike the environment we use for desktop development, the environment for embedded programming
    requires two systems:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用嵌入式系统，我们需要设置一个环境。与我们用于桌面开发的环境不同，嵌入式编程的环境需要两个系统：
- en: '**A build system**: The system you use to write the code'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建系统**：用于编写代码的系统'
- en: '**A target system**: The system your code is going to be run on'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标系统**：您的代码将在其上运行的系统'
- en: In this chapter, we will learn how to set up these two systems and connect them
    together. Configurations of build systems may vary significantly— there may be
    different operating systems, compilers, and IDEs. The variance in target system
    configurations is even greater since each embedded system is unique. Moreover,
    while you can use your laptop or desktop as a build system, you do need some sort
    of embedded board as a target system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何设置这两个系统并将它们连接在一起。构建系统的配置可能会有很大的差异——可能有不同的操作系统、编译器和集成开发环境。目标系统配置的差异甚至更大，因为每个嵌入式系统都是独特的。此外，虽然您可以使用笔记本电脑或台式机作为构建系统，但您确实需要某种嵌入式板作为目标系统。
- en: 'It would be impossible to cover all the possible combinations of build and
    target systems. Instead, we will just learn how to use one popular configuration:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能涵盖所有可能的构建和目标系统的组合。相反，我们将学习如何使用一个流行的配置：
- en: Ubuntu 18.04 as the build system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04作为构建系统
- en: Raspberry Pi as the target system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派作为目标系统
- en: We will use Docker to run Ubuntu in a virtual environment on your laptop or
    desktop. Docker supports Windows, macOS, and Linux, but, if you already use Linux,
    you can use it directly without running a container on top of it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Docker在笔记本电脑或台式机上的虚拟环境中运行Ubuntu。Docker支持Windows、macOS和Linux，但如果您已经使用Linux，可以直接使用它，而无需在其上运行容器。
- en: We will use **Quick EMUlator** (**QEMU**)to emulate the Raspberry Pi board.
    This will teach us how to build applications for embedded boards even without
    access to the real hardware. Carrying out the initial phases of development in
    an emulated environment is common and, in many cases, the only possible practical
    solution, given that the target hardware may not be available when the software
    development starts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Quick EMUlator**（**QEMU**）来模拟树莓派板。这将教会我们如何在没有真实硬件访问权限的情况下为嵌入式板构建应用程序。在模拟环境中进行开发的初始阶段是常见的，在许多情况下，这是唯一可能的实际解决方案，因为在软件开发开始时，目标硬件可能不可用。
- en: 'This chapter will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the build system in a Docker container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中设置构建系统
- en: Working with emulators
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟器
- en: Cross-compilation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译
- en: Connecting to an embedded system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到嵌入式系统
- en: Debugging embedded applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试嵌入式应用程序
- en: Using gdbserver for remote debugging
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gdbserver进行远程调试
- en: Using CMake as a build system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake作为构建系统
- en: Setting up the build system in a Docker container
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker容器中设置构建系统
- en: In this recipe, we will set up a Docker container to run Ubuntu 18.04 on your
    desktop or laptop. It does not matter what operating system runs on your machine,
    as Docker supports Windows, macOS, and Linux. As a result of this recipe, you
    will have a unified, virtualized Ubuntu Linux build system running within your
    host operating system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将设置一个Docker容器，在您的台式机或笔记本电脑上运行Ubuntu 18.04。无论您的机器上运行什么操作系统，Docker都支持Windows、macOS和Linux。作为这个步骤的结果，您将在主机操作系统中运行一个统一的、虚拟化的Ubuntu
    Linux构建系统。
- en: If your operating system already runs Ubuntu Linux, feel free to skip to the
    next recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的操作系统已经运行Ubuntu Linux，请随时跳到下一个步骤。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'We are going to install the Docker application on our laptop or desktop and
    then use a ready-made image of Ubuntu to run this operating system in a virtual
    environment:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在笔记本电脑或台式机上安装Docker应用程序，然后使用Ubuntu的现成镜像在虚拟环境中运行这个操作系统：
- en: 'In your web browser, open the following link and follow the instructions to
    set up Docker for your operating system:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中，打开以下链接并按照说明为您的操作系统设置Docker：
- en: For Windows: [https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows：[https://docs.docker.com/docker-for-windows/install/](https://docs.docker.com/docker-for-windows/install/)
- en: For macOS: [https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于macOS：[https://docs.docker.com/docker-for-mac/install/](https://docs.docker.com/docker-for-mac/install/)
- en: 'Open a terminal window (Command Prompt in Windows, the Terminal app in macOS)
    and run the following command to check that it has been installed correctly:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口（Windows中的命令提示符，macOS中的终端应用程序）并运行以下命令以检查是否已正确安装：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run this command to use an Ubuntu image:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令使用Ubuntu镜像：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a working directory. In either macOS, Linux shell, or Windows PowerShell,
    run the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个工作目录。在macOS、Linux shell或Windows PowerShell中运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, run the downloaded image in the container:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在容器中运行下载的镜像：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, run the `uname -a` command to get information about the system:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`uname -a`命令以获取有关系统的信息：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You are now in a virtual Linux environment, which we will use for the subsequent
    recipes in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在处于一个虚拟的Linux环境中，我们将在本书的后续步骤中使用它。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first step, we install Docker—a virtualization environment that allows
    an isolated Linux operating system to run on Windows, macOS, or Linux. This is
    a convenient way of distributing and deploying containers that uniformly encapsulate
    all of the libraries and programs required for any operating system you use.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们安装了Docker——一个虚拟化环境，允许在Windows、macOS或Linux上运行一个隔离的Linux操作系统。这是一种方便的方式，可以统一地封装所使用的任何操作系统所需的所有库和程序，以便分发和部署容器。
- en: 'After installing Docker, run a quick command to check whether it has been installed
    correctly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，运行一个快速命令来检查是否已正确安装：
- en: '![](img/79bd5436-f274-476e-b093-973afff3e233.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79bd5436-f274-476e-b093-973afff3e233.png)'
- en: 'After checking the installation, we need to fetch the ready-made Ubuntu image
    from the Docker repository. Docker images have tags; we can use the `bionic` tag
    to find Ubuntu version 18.04:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 检查安装后，我们需要从Docker存储库中获取现成的Ubuntu镜像。Docker镜像有标签；我们可以使用`bionic`标签来找到Ubuntu 18.04版本：
- en: '![](img/5d3e8e8d-05b8-4ae5-b232-5a85936edf50.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d3e8e8d-05b8-4ae5-b232-5a85936edf50.png)'
- en: It takes time for the image to download. Once the image is fetched, we can create
    a directory, which we will use for development. The directory content will be
    shared between your operating system and Linux, running in Docker. This way, you
    can use your favorite text editor to work on code but still use the Linux build
    tools to compile the code into the binary executable files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像下载需要时间。一旦镜像被获取，我们可以创建一个目录，用于开发。目录内容将在您的操作系统和在Docker中运行的Linux之间共享。这样，您可以使用您喜欢的文本编辑器来编写代码，但仍然可以使用Linux构建工具将代码编译成二进制可执行文件。
- en: 'Then, we can start a Docker container using the Ubuntu image fetched in step
    4\. The `option -v $HOME/test:/mnt` command line makes the folder created in step
    5 visible to Ubuntu as the `/mnt` directory. This means that all of the files
    you create in the `~/test` directory automatically appear in `/mnt`. The `-ti` option
    makes the container interactive, giving you access to the Linux shell environment
    (bash):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用第4步中获取的Ubuntu镜像启动Docker容器。`选项-v $HOME/test:/mnt`命令行使第5步中创建的文件夹对Ubuntu可见，作为`/mnt`目录。这意味着您在`~/test`目录中创建的所有文件都会自动出现在`/mnt`中。`-ti`选项使容器交互，让您访问Linux
    shell环境（bash）：
- en: '![](img/4702bc3f-9e14-4604-9fd1-aa4c28db0b03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4702bc3f-9e14-4604-9fd1-aa4c28db0b03.png)'
- en: 'Finally, we run a quick sanity check of the `. uname` container, which displays
    information about the Linux kernel, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对`.uname`容器进行了快速的健全性检查，它显示了有关Linux内核的信息，如下所示：
- en: '![](img/d836a658-c6fa-4c21-bfd5-ce05d6bb5e53.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d836a658-c6fa-4c21-bfd5-ce05d6bb5e53.png)'
- en: Although the exact version of your kernel may differ, we can see that we are
    running Linux and our architecture is `x86`. This means we have set up our build
    environment, where we will be able to compile our code in a unified way, whatever
    operating system is running on our computer. However, we are still not able to
    run the compiled code because our target architecture is **Acorn RISC Machines** (**ARM**), not
    `x86`. We will learn how to set up an emulated ARM environment in the next recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您的内核确切版本可能不同，但我们可以看到我们正在运行Linux，我们的架构是`x86`。这意味着我们已经设置了我们的构建环境，我们将能够以统一的方式编译我们的代码，无论计算机上运行的操作系统是什么。但是，我们仍然无法运行编译后的代码，因为我们的目标架构是**Acorn
    RISC Machines**（**ARM**），而不是`x86`。我们将在下一个步骤中学习如何设置模拟的ARM环境。
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Docker is a powerful and flexible system. Moreover, its repository contains
    lots of ready-made images that contain tools that are useful to most developers.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个功能强大且灵活的系统。此外，其存储库包含许多包含对大多数开发人员有用的工具的现成镜像。
- en: Go to [https://hub.docker.com/search?q=&type=image](https://hub.docker.com/search?q=&type=image) and
    browse through the most popular images. You can also search for images using keywords,
    such as *embedded*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://hub.docker.com/search?q=&type=image](https://hub.docker.com/search?q=&type=image)并浏览最受欢迎的镜像。您还可以使用关键字搜索镜像，例如*嵌入式*。
- en: Working with emulators
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟器
- en: Using a real embedded board is not always possible or practical—hardware is
    not yet ready, or the number of boards is limited. Emulators help developers use
    an environment that's as close to the target system as possible, yet do not depend
    on hardware availability. It is also the best way to start learning embedded development.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是可能或实际使用真实的嵌入式板—硬件尚未准备好，或板的数量有限。模拟器帮助开发人员使用尽可能接近目标系统的环境，但不依赖于硬件可用性。这也是开始学习嵌入式开发的最佳方式。
- en: In this recipe, we will learn how to set up QEMU (a hardware emulator) and configure
    it to emulate an ARM-based embedded system running Debian Linux.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何设置QEMU（硬件模拟器）并配置它以模拟运行Debian Linux的基于ARM的嵌入式系统。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We need a virtual environment that, unlike Docker, can emulate processors with
    architectures that differ from the architecture of our computer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个虚拟环境，与Docker不同，它可以模拟具有与计算机架构不同的处理器的处理器：
- en: Navigate to [https://www.qemu.org/download/](https://www.qemu.org/download/)
    and click on the tab that matches your operating system—Linux, macOS, or Windows—and
    follow the installation instructions.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.qemu.org/download/](https://www.qemu.org/download/)，并单击与您的操作系统匹配的选项卡—Linux、macOS或Windows—，然后按照安装说明进行操作。
- en: 'Create a test directory, unless one already exists:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试目录，除非已经存在：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Download the following files and copy them over to the `~/raspberry` directory
    you created in the previous step:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载以下文件并复制到您在上一步中创建的`~/raspberry`目录中：
- en: '**Raspbian Lite zip-archive**: [http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip](http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Raspbian Lite zip存档**：[http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip](http://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2019-07-12/2019-07-10-raspbian-buster-lite.zip)'
- en: '**Kernel imag**e: [https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核镜像**：[https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/kernel-qemu-4.14.79-stretch)'
- en: '**Device tree blob**: [https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备树blob**：[https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb](https://github.com/dhruvvyas90/qemu-rpi-kernel/raw/master/versatile-pb.dtb)'
- en: Change the directory to `~/raspberry` and extract the Raspbian Lite zip archive
    downloaded in the previous step. It contains a single file named ` 2019-07-10-raspbian-buster-lite.img`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录更改为`~/raspberry`并提取在上一步中下载的Raspbian Lite zip存档。它包含一个名为`2019-07-10-raspbian-buster-lite.img`的单个文件。
- en: 'Open a terminal window and run QEMU. For Windows and Linux, the command line
    is as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口并运行QEMU。对于Windows和Linux，命令行如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A new window should show up, displaying the Linux boot process. In a few seconds,
    a login prompt will be displayed.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该出现一个新窗口，显示Linux引导过程。几秒钟后，将显示登录提示。
- en: 'Log in using `pi` as the username and `raspberry` as the password. Then, type
    the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pi`作为用户名和`raspberry`作为密码登录。然后，输入以下命令：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Check the output of the command. It indicates that our system architecture is
    `ARM`, not `x86`. Now we can use this environment to test applications built for
    the ARM platform.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查命令的输出。它指示我们的系统架构是`ARM`，而不是`x86`。现在我们可以使用这个环境来测试为ARM平台构建的应用程序。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first step, we install the QEMU emulator. Without the loadable code
    images, this virtual machine doesn''t have much use. Then, we can fetch the three
    images required to run a Linux operating system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们安装了QEMU模拟器。没有可加载的代码映像，这个虚拟机没有太多用处。然后，我们可以获取运行Linux操作系统所需的三个映像：
- en: '**The Linux root filesystem**: Contains a snapshot of Raspbian Linux, used
    on Raspberry Pi devices'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux根文件系统**：包含Raspbian Linux的快照，用于树莓派设备'
- en: '**The Linux kernel**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux内核**'
- en: '**The Device tree blob**: Contains a description of the hardware components
    of a system'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备树blob**：包含系统的硬件组件描述'
- en: Once all the images are fetched and put into the `~/raspberry` directory, we
    run QEMU, providing paths to the images as command-line parameters. Additionally,
    we configure the virtual network, which allows us to connect to the Linux system
    running in the virtual environment from our native environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有镜像都被获取并放入`~/raspberry`目录中，我们就运行QEMU，提供镜像路径作为命令行参数。此外，我们配置虚拟网络，这使我们能够从本机环境连接到虚拟环境中运行的Linux系统。
- en: 'After QEMU starts, we can see a window with a Linux login prompt:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU启动后，我们可以看到一个带有Linux登录提示的窗口：
- en: '![](img/1681dd1f-e0a3-43b8-a1aa-dbc92d5a9f73.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1681dd1f-e0a3-43b8-a1aa-dbc92d5a9f73.png)'
- en: 'After logging into the system, we can run a quick sanity check by running the
    `uname` command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 登录系统后，我们可以通过运行`uname`命令进行快速健全性检查：
- en: '![](img/23196296-b663-4e7f-9a88-e4f588196eb3.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23196296-b663-4e7f-9a88-e4f588196eb3.png)'
- en: Similar to the sanity check we ran in the previous recipe, *Setting up the build
    system in a Docker container*, this shows that we are running a Linux operating
    system, but, in this case, we can see that the target architecture is `ARM`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在上一个配方中运行的健全性检查，*在Docker容器中设置构建系统*，这表明我们正在运行Linux操作系统，但在这种情况下，我们可以看到目标架构是`ARM`。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: QEMU is a powerful processor emulator that supports other multiple architectures
    aside from x86 and ARM, such as PowerPC, SPARC64, SPARC32, and **Microprocessor
    without Interlocked Pipelined Stages** (**MIPS**). One aspect that makes it so
    powerful is its flexibility, due to its many configuration options. Go to [https://qemu.weilnetz.de/doc/qemu-doc.html](https://qemu.weilnetz.de/doc/qemu-doc.html)
    to configure QEMU to your needs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU是一个强大的处理器模拟器，支持除x86和ARM之外的其他多种架构，如PowerPC、SPARC64、SPARC32和**无锁流水级阶段微处理器**（**MIPS**）。使其如此强大的一个方面是其灵活性，由于其许多配置选项。转到[https://qemu.weilnetz.de/doc/qemu-doc.html](https://qemu.weilnetz.de/doc/qemu-doc.html)根据您的需求配置QEMU。
- en: Microcontroller vendors also often provide emulators and simulators. When starting
    development for particular hardware, check for the available emulation options,
    as it might significantly affect the development time and effort.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器供应商通常也提供模拟器和仿真器。在开始为特定硬件进行开发时，请检查可用的仿真选项，因为这可能会显着影响开发时间和精力。
- en: Cross-compilation
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译
- en: 'We have already learned that the environment for embedded development consists
    of two systems: the build system, where you write and build code, and the host
    system, which runs the code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道嵌入式开发环境由两个系统组成：构建系统，您在其中编写和构建代码，以及运行代码的主机系统。
- en: 'We now have two virtualized environments set up:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个虚拟化环境：
- en: Ubuntu Linux in a Docker container, which will be our build system
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker容器中的Ubuntu Linux，这将是我们的构建系统
- en: QEMU running Raspbian Linux, which will be our host system
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Raspbian Linux的QEMU，这将是我们的主机系统
- en: In this recipe, we will set up the cross-compilation tools required to build
    Linux applications for the ARM platform and build a simple *Hello, world!* application
    to test the setup.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将设置构建Linux应用程序所需的交叉编译工具，并构建一个简单的*Hello, world!*应用程序来测试设置。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: To set up the cross-compilation toolkit, we will need to use Ubuntu Linux, which
    we set up in the *Setting up the build system in a Docker container* recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置交叉编译工具包，我们需要使用我们在*Docker容器中设置构建系统*配方中设置的Ubuntu Linux。
- en: We also need the `~/test` directory to exchange our source code between our
    operating system and the Ubuntu container.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`~/test`目录来在我们的操作系统和Ubuntu容器之间交换我们的源代码。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by creating a simple C++ program, which we want to compile for
    our target platform:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个简单的C++程序，我们希望为我们的目标平台进行编译：
- en: Create a file named `hello.cpp` in the `~/test` directory.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`~/test`目录中创建一个名为`hello.cpp`的文件。
- en: 'Use your favorite text editor to add the following code snippet to it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器将以下代码片段添加到其中：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have the code for the `Hello, world!` program, we need to compile
    it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`Hello, world!`程序的代码，我们需要编译它。
- en: Switch to the Ubuntu (our build system) console.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到Ubuntu（我们的构建系统）控制台。
- en: 'Get the up-to-date list of packages available for the installation by running
    the following command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令获取可用于安装的软件包的最新列表：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will take some time to fetch the package descriptions from the Ubuntu servers. Run
    the following command to install the cross-compilation tools:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Ubuntu服务器获取软件包描述需要一些时间。运行以下命令安装交叉编译工具：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will see a long list of packages to install. Press *Y* to confirm the installation.As
    a sanity check, run a cross-compiler with no parameters:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到一个要安装的包的长列表。按*Y*确认安装。作为健全性检查，运行一个没有参数的交叉编译器：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Change the directory to `/mnt`
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改目录到`/mnt`
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `hello.cpp` file that we created in step 1 is located here. Let''s now
    build it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在第1步中创建的`hello.cpp`文件位于这里。现在让我们来构建它：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command generates an executable file named `hello`. You may be wondering
    why it doesn't have any extensions. In Unix systems, extensions are completely
    optional and binary executable files usually do not have any extensions. Try to
    run the file. It should fail with an error.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个命令生成一个名为`hello`的可执行文件。您可能想知道为什么它没有任何扩展名。在Unix系统中，扩展名是完全可选的，二进制可执行文件通常没有任何扩展名。尝试运行文件。它应该会出现错误。
- en: Let's generate the details about the executable binary using the `file` tool.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`file`工具生成关于可执行二进制文件的详细信息。
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first step, we created a simple *Hello, World!* C++ program. We put this
    into the `~/test` directory, which makes it accessible from the Docker container
    running Linux.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了一个简单的*Hello, World!* C++程序。我们将其放入`~/test`目录中，这样它就可以从运行Linux的Docker容器中访问。
- en: To build the source code, we switched to the Ubuntu shell.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建源代码，我们切换到了Ubuntu shell。
- en: If we try to run a standard Linux  g++ compiler to build it, we will get an
    executable for the build platform, which is x86\. However, we need an executable
    for the ARM platform. To build it, we need a version of the compiler that can
    run on x86, building the ARM code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行标准的Linux g++编译器来构建它，我们将得到一个用于构建平台的可执行文件，即x86。然而，我们需要一个用于ARM平台的可执行文件。为了构建它，我们需要一个可以在x86上运行的编译器版本，构建ARM代码。
- en: 'As a preliminary step, we need to update the information about the packages
    available in the Ubuntu packages distributive:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为预备步骤，我们需要更新Ubuntu软件包分发中可用软件包的信息：
- en: '![](img/1973b89b-07cc-4125-a9fe-000c0969f05d.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1973b89b-07cc-4125-a9fe-000c0969f05d.png)'
- en: 'We can install this compiler, along with a set of related tools, by running
    `apt-get install crossbuild-essential-armel`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`apt-get install crossbuild-essential-armel`来安装这个编译器以及一组相关工具：
- en: '![](img/dc1bdb2c-8f41-4ec3-9073-ffd6ff23487d.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc1bdb2c-8f41-4ec3-9073-ffd6ff23487d.png)'
- en: 'The quick sanity check carried out in step 9 shows that it was properly installed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步进行的快速健全性检查表明它已正确安装：
- en: '![](img/2d99fc73-58e6-4651-8d87-e5bfe30c77e2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d99fc73-58e6-4651-8d87-e5bfe30c77e2.png)'
- en: Now, we need to build `hello.cpp` using the cross-compiler. It generates the
    executable for the ARM platform, which is why our attempt to run it in the build
    system in step 12 fails.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用交叉编译器构建`hello.cpp`。它为ARM平台生成可执行文件，这就是为什么我们在第12步中尝试在构建系统中运行它失败的原因。
- en: 'To make sure it is really an ARM executable, we need to run the `file` command.
    Its output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它确实是一个ARM可执行文件，我们需要运行`file`命令。其输出如下：
- en: '![](img/7fbe1b85-47b4-4f1c-aada-898888a43b66.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fbe1b85-47b4-4f1c-aada-898888a43b66.png)'
- en: As you can see, the binary is built for the ARM platform, which is why it fails
    to run on a build system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该二进制文件是为ARM平台构建的，这就是为什么它无法在构建系统上运行的原因。
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Many cross-compilation toolkits exist for various architectures. Some of them
    are readily available in the Ubuntu repository; some may require manual installation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多交叉编译工具包适用于各种架构。其中一些可以在Ubuntu存储库中轻松获得；一些可能需要手动安装。
- en: Connecting to the embedded system
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到嵌入式系统
- en: After an embedded application is built on a build system using a cross-compiler,
    it should be transferred to the target system. The best way to do this on Linux-based
    embedded systems is by using networking connectivity and a remote shell. **Secure
    Shell** (**SSH**) is widely used due to its security and versatility. It allows
    you to not only run shell commands on a remote host but also copy files from one
    machine to another using cryptographic encryption and key-based authentication.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用交叉编译器在构建系统上构建嵌入式应用程序之后，应将其传输到目标系统。在基于Linux的嵌入式系统上，最好的方法是使用网络连接和远程shell。**安全外壳**（**SSH**）由于其安全性和多功能性而被广泛使用。它不仅允许您在远程主机上运行shell命令，还允许您使用加密和基于密钥的身份验证从一台机器复制文件到另一台机器。
- en: In this recipe, we will learn how to copy the application binary to the emulated
    ARM system using secure copy, connect to it using SSH, and run the executable
    in SSH.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用安全拷贝将应用程序二进制文件复制到模拟的ARM系统中，使用SSH连接到它，并在SSH中运行可执行文件。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will use the Raspberry Pi emulator we set up in the *Working with emulators*
    recipe as our target system. Also, we need our Ubuntu build system and the executable
    `hello` file we built in the *Cross-compilation* recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在*使用模拟器*教程中设置的树莓派模拟器作为目标系统。此外，我们需要我们的Ubuntu构建系统和我们在*交叉编译*教程中构建的可执行文件`hello`。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to access our target system via the network. QEMU provides a virtual
    network interface for the emulated machine, and we can use it without connecting
    to a real network. In order to do so, we need to figure out an IP address to use
    and make sure that the SSH server is running in our virtual environment:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过网络访问我们的目标系统。QEMU为模拟机提供了一个虚拟网络接口，我们可以在不连接到真实网络的情况下使用它。为了这样做，我们需要找出一个要使用的IP地址，并确保SSH服务器在我们的虚拟环境中运行：
- en: In your native operating system environment, work out the IP address of your
    machine. Open a Terminal window or PowerShell. Run `ifconfig` on macOS, or Linux,
    or `ipconfig` for Windows, and check its output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本机操作系统环境中，找出您的机器的IP地址。打开一个终端窗口或PowerShell。在macOS或Linux上运行`ifconfig`，或在Windows上运行`ipconfig`，并检查其输出。
- en: In the next steps, we will use `192.168.1.5` as a template IP address; you will
    need to replace it with your actual IP address.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用`192.168.1.5`作为模板IP地址；您需要用您的实际IP地址替换它。
- en: 'Switch to the Raspberry Pi emulator and enable SSH services by running the
    following command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到树莓派模拟器并通过运行以下命令启用SSH服务：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Switch to the Ubuntu window and install the SSH client:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到Ubuntu窗口并安装SSH客户端：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can copy the `hello` executable to the target system:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将`hello`可执行文件复制到目标系统：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When asked for a password, type `raspberry`. Switch back to the Raspberry Pi
    emulator window. Check that the executable we just copied is there:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当要求输入密码时，输入`raspberry`。切换回树莓派模拟器窗口。检查我们刚刚复制的可执行文件是否存在：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, run the program:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, the program is now running as expected.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，程序现在按预期运行。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we set up a data exchange between two virtual environments—Docker
    and QEMU—using SSH. To do this, we need an SSH server to be running and accepting
    connections on the target system (QEMU), and an SSH client initiating connections
    on the build system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用SSH在两个虚拟环境——Docker和QEMU——之间建立了数据交换。为此，我们需要在目标系统（QEMU）上运行并接受连接的SSH服务器，并在构建系统上启动连接的SSH客户端。
- en: In step 2, we set up the SSH client on our build system. Our target system,
    running in QEMU, already had an SSH server up and running. During the *Working
    with emulators* recipe, we configured QEMU to forward connections from our host
    port, `22023`, to our virtual machine port, `22`, which is SSH.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们在构建系统上设置了SSH客户端。我们的目标系统在QEMU中运行，已经启动并运行了SSH服务器。在*使用模拟器*的步骤中，我们配置了QEMU以将主机端口`22023`转发到虚拟机端口`22`，即SSH。
- en: 'Now, we can use `scp` to copy a file from the build system to the target system
    using a secure network connection. We can specify our system IP address (discovered
    in step 1) and port `22023`, configured for QEMU forwarding, as parameters for `scp`
    to connect to:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`scp`通过安全网络连接将文件从构建系统复制到目标系统。我们可以指定我们的系统IP地址（在第1步中发现）和端口`22023`，作为`scp`连接的参数，以连接到：
- en: '![](img/bc75eea7-7ccb-43ea-9e30-f3f3857a007a.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc75eea7-7ccb-43ea-9e30-f3f3857a007a.png)'
- en: After we have copied the file, we can log in to the target system with SSH using
    the same IP address, port, and username as we used for `scp`. It opens a login
    prompt similar to the local console and, after authorization, we get the same
    command shell as the local terminal.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们复制文件之后，我们可以使用相同的IP地址、端口和用户名通过SSH登录到目标系统。它会打开一个类似于本地控制台的登录提示，并在授权后，我们会得到与本地终端相同的命令shell。
- en: The `hello` application we copied in the previous step should be available in
    the `home` directory. We checked this in step 5 by running the `ls` command.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一步中复制的`hello`应用程序应该在`home`目录中可用。我们通过运行`ls`命令在第5步中检查了这一点。
- en: 'Finally, we can run the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行应用程序：
- en: '![](img/087a7c0c-6ec1-4a7f-bcba-097249ccd47a.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/087a7c0c-6ec1-4a7f-bcba-097249ccd47a.png)'
- en: When we tried to run it on our build system, we received an error. Now, the
    output is `Hello, world!`. This is what we would expect, since our application
    is built for the ARM platform and being run on the ARM platform.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在构建系统上运行它时，我们收到了一个错误。现在，输出是`Hello, world!`。这是我们所期望的，因为我们的应用程序是为ARM平台构建并在ARM平台上运行的。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although we ran the recipe to connect to the emulated system, the same steps
    are applicable for real embedded systems. Even if a target system does not have
    a display, you can set up SSH using the serial console connection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们运行了连接到模拟系统的示例，但相同的步骤也适用于真实的嵌入式系统。即使目标系统没有显示器，也可以使用串行控制台连接设置SSH。
- en: 'In this recipe, we only copied files to our target system. Besides copying,
    it is a common practice to open an interactive SSH session to the embedded system.
    Usually, it is more efficient and convenient to use than a serial console. It
    is established in a similar way to `scp`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只是将文件复制到目标系统。除了复制，通常还会打开一个交互式SSH会话到嵌入式系统。通常，这比串行控制台更有效、更方便。它的建立方式与`scp`类似：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: SSH provides various authentication mechanisms. Once you enable and set up public
    key authentication, there is no need to type in your password for every copy or
    login. This makes the development process faster and more convenient for developers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: SSH提供各种身份验证机制。一旦启用并设置了公钥身份验证，就无需为每次复制或登录输入密码。这使得开发过程对开发人员来说更快速、更方便。
- en: To learn more about ss keys, go to [https://www.ssh.com/ssh/key/](https://www.ssh.com/ssh/key/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于ss密钥的信息，请访问[https://www.ssh.com/ssh/key/](https://www.ssh.com/ssh/key/)。
- en: Debugging embedded applications
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试嵌入式应用程序
- en: Debugging embedded applications depends significantly on the type of the target
    embedded systems. Microcontroller manufacturers often provide specialized debuggers
    for their **microcontroller units** (**MCUs**) as well as hardware support for
    remote debugging using a **Joint Test Action Group** (**JTAG**) protocol. It allows
    developers to debug the microcontroller code immediately after the MCU starts
    executing instructions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 调试嵌入式应用程序在很大程度上取决于目标嵌入式系统的类型。微控制器制造商通常为他们的**微控制器单元**（**MCU**）提供专门的调试器，以及使用**联合测试动作组**（**JTAG**）协议进行远程调试的硬件支持。它允许开发人员在MCU开始执行指令后立即调试微控制器代码。
- en: If the target board runs Linux, the most practical method of debugging is to
    use an extensive debug output and to use GDB as an interactive debugger.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标板运行Linux，则调试的最实用方法是使用广泛的调试输出，并使用GDB作为交互式调试器。
- en: In this recipe, we will learn how to run our application in a command-line debugger: GDB.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在命令行调试器GDB中运行我们的应用程序。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We have already learned how to transfer executable files to the target system.
    We will use the *Connecting to the embedded system* recipe as a starting point
    to learn how to use a debugger on the target system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将可执行文件传输到目标系统。我们将使用*连接到嵌入式系统*的示例作为学习如何在目标系统上使用调试器的起点。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have learned how to copy an application to the target system and run it
    there. Now, let''s learn how to start debugging an application on a target system
    using GDB. In this recipe, we will only learn how to invoke the debugger and run
    applications in the debugger environment. It will be used as a foundation for
    more advanced and practical debugging techniques later:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将应用程序复制到目标系统并在那里运行。现在，让我们学习如何在目标系统上使用GDB开始调试应用程序。在这个配方中，我们只会学习如何调用调试器并在调试器环境中运行应用程序。这将作为以后更高级和实用的调试技术的基础：
- en: Switch to the `QEMU` window.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`QEMU`窗口。
- en: If you have not done so already, log in using `pi` as the username and `raspberry`
    as the password.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请使用`pi`作为用户名和`raspberry`作为密码登录。
- en: 'Run the following command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will open the `gdb` command line.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开`gdb`命令行。
- en: 'Type `run` to run the application:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`run`来运行应用程序：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should see `Hello, world` in the output.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在输出中看到`Hello, world`。
- en: 'Now, run the `quit` command, or just `q`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行`quit`命令，或者只需输入`q`：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This terminates the debugging session and returns us back to the Linux shell.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将终止调试会话并将我们返回到Linux shell。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Raspberry Pi image we use for emulation comes with a pre-installed GNU debugger,
    so we can use it right away.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于仿真的Raspberry Pi映像预先安装了GNU调试器，因此我们可以立即使用它。
- en: In the `home` user directory, we should find the `hello` executable file, which
    we copied from our build system as part of the *Connecting to the embedded system*
    recipe.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home`用户目录中，我们应该找到`hello`可执行文件，这是作为*连接到嵌入式系统*配方的一部分从我们的构建系统复制过来的。
- en: 'We run `gdb`, passing the path to the `hello` executable as a parameter. This
    command opens the `gdb` shell but does not run the application itself. To run
    it, we type in the `run` command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行`gdb`，将`hello`可执行文件的路径作为参数传递。这个命令打开了`gdb` shell，但并没有运行应用程序本身。要运行它，我们输入`run`命令：
- en: '![](img/7730a5e6-f9ba-4ae2-99c8-d775757b5df3.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7730a5e6-f9ba-4ae2-99c8-d775757b5df3.png)'
- en: 'The application runs, printing the  `Hello world!` message on the screen, and
    then terminates. However, we are still in the debugger. To exit the debugger,
    we type the `quit` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行，在屏幕上打印`Hello world!`消息，然后终止。但是，我们仍然在调试器中。要退出调试器，我们输入`quit`命令：
- en: '![](img/4c14581e-4665-4e97-9cc1-b58a262cd717.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c14581e-4665-4e97-9cc1-b58a262cd717.png)'
- en: You can see that the command-line prompt has changed. It is an indication that
    we are not in the `gdb` environment anymore. We have returned to the default shell
    environment of Raspberry Pi Linux, which we were using before running GDB.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到命令行提示已经改变。这表明我们不再处于`gdb`环境中。我们已经返回到Raspberry Pi Linux的默认shell环境，这是我们在运行GDB之前使用的环境。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A GNU debugger is pre-installed in this case, but it may not be in your real
    target system. If it is Debian-based, you can install it by running the following
    command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，GNU调试器是预先安装的，但可能不在您的真实目标系统中。如果它是基于Debian的，您可以通过运行以下命令来安装它：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In other Linux-based systems, different commands to install GDB are required.
    In many cases, you will need to build it from source code and install it manually,
    similarly to the `hello` application we have built and tested as part of the recipes
    in this chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他基于Linux的系统中，需要不同的命令来安装GDB。在许多情况下，您需要从源代码构建并手动安装它，类似于我们在本章的配方中构建和测试的`hello`应用程序。
- en: In this recipe, we only learned how to run an application using GDB, which is
    a complex tool with lots of commands, techniques, and best practices. We will
    discuss some of them in the [Chapter 5](345afa8f-ca7a-48f8-a941-1f34c08e4844.xhtml), *Debugging,
    Logging, and Profiling*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们只学会了如何使用GDB运行应用程序，GDB是一个具有许多命令、技术和最佳实践的复杂工具。我们将在[第5章](345afa8f-ca7a-48f8-a941-1f34c08e4844.xhtml)中讨论其中一些。
- en: Using gdbserver for remote debugging
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gdbserver进行远程调试
- en: As we have discussed, the environment for embedded development usually involves
    two systems—a build system and a target system (or emulator). Sometimes, interactive
    debugging on the target system is impractical because of the high latency of remote
    communication.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，嵌入式开发环境通常涉及两个系统 - 构建系统和目标系统（或仿真器）。有时，由于远程通信的高延迟，目标系统上的交互式调试是不切实际的。
- en: In such situations, developers can use remote debugging support provided by
    GDB. In this setup, an embedded application is launched on the target system using
    **gdbserver**. Developers run GDB on a build system and connect to gdbserver over
    the network.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发人员可以使用GDB提供的远程调试支持。在这种设置中，使用**gdbserver**在目标系统上启动嵌入式应用程序。开发人员在构建系统上运行GDB，并通过网络连接到gdbserver。
- en: In this recipe, we will learn how to start debugging an application using GDB
    and gdbserver.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用GDB和gdbserver开始调试应用程序。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In the *Connecting to the embedded system* recipe, we learned how to make our
    application available on the target system. We will use that recipe as a starting
    point to learn a remote debugging technique.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*连接到嵌入式系统*配方中，我们学会了如何使我们的应用程序在目标系统上可用。我们将以此配方为起点，学习远程调试技术。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are going to install and run the gdbserver application, which will allow
    us to run GDB on our build system and forward all commands to the target system. Switch
    to the Raspberry Pi emulator window.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装并运行gdbserver应用程序，这将允许我们在构建系统上运行GDB并将所有命令转发到目标系统。切换到Raspberry Pi仿真器窗口。
- en: Log in as `pi` using the `raspberry` password, unless you're already logged
    in.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`pi`身份登录，密码为`raspberry`，除非您已经登录。
- en: 'To install gdbserver, run the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装gdbserver，请运行以下命令：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the `hello` application under `gdbserver`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gdbserver`下运行`hello`应用程序：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Switch to the build system terminal and change the directory to `/mnt/hello`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建系统终端并将目录更改为`/mnt/hello`：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Install the `gdb-multiarch` package, which provides the necessary support for
    the ARM platform:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`gdb-multiarch`软件包，它提供了对ARM平台的必要支持：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, run `gdb`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行`gdb`：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Configure the remote connection by typing the following command in the `gdb`
    command line (make sure you replace `192.168.1.5` with your actual IP address):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`gdb`命令行中输入以下命令来配置远程连接（确保您用实际IP地址替换`192.168.1.5`）：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Type the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The program will now run.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在将运行。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the Raspberry Pi image we used, `gdbserver` is not installed by default.
    So, as a first step, we install `gdbserver`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的Raspberry Pi镜像中，默认情况下未安装`gdbserver`。因此，作为第一步，我们安装`gdbserver`：
- en: '![](img/09463e0a-5205-4696-9876-eccdbfae92b5.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09463e0a-5205-4696-9876-eccdbfae92b5.png)'
- en: 'After the installation is complete, we run `gdbserver`, passing the name of
    the application that needs to be debugged, the IP address, and the port to listen
    out for incoming connections as its parameters. We use `0.0.0.0` as the IP address
    to indicate that we want to accept connections on any IP address:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们运行`gdbserver`，将需要调试的应用程序的名称、IP地址和要监听传入连接的端口作为参数传递给它。我们使用`0.0.0.0`作为IP地址，表示我们希望接受任何IP地址上的连接：
- en: '![](img/0dbebcae-bc8b-4787-8b91-684276dde525.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dbebcae-bc8b-4787-8b91-684276dde525.png)'
- en: 'Then, we switch to our build system and run `gdb` there. But, instead of running
    the application in GDB directly, we instruct `gdb` to initiate a connection to
    a remote host using the IP address and port provided:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们切换到我们的构建系统并在那里运行`gdb`。但是，我们不直接在GDB中运行应用程序，而是指示`gdb`使用提供的IP地址和端口启动与远程主机的连接：
- en: '![](img/4a3f076e-ed50-4130-8ebf-c13b191c319b.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a3f076e-ed50-4130-8ebf-c13b191c319b.png)'
- en: 'After that, all the commands you type at the `gdb` prompt will be transferred
    to gdbserver and executed there. When we run the application, we will see the
    resulting output in the `gdb` console of the build system, even if we run the
    ARM executable:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您在`gdb`提示符下键入的所有命令都将传输到gdbserver并在那里执行。当我们运行应用程序时，即使我们运行ARM可执行文件，我们也将在构建系统的`gdb`控制台中看到生成的输出：
- en: '![](img/c6f43a8b-2667-4422-ad15-e67e910f560f.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6f43a8b-2667-4422-ad15-e67e910f560f.png)'
- en: 'An explanation is simple—the binary runs on a remote ARM system: our Raspberry
    Pi emulator. This is a convenient way of debugging applications on a target platform,
    allowing you to remain in the more comfortable environment of your build system.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 解释很简单——二进制文件在远程ARM系统上运行：我们的Raspberry Pi模拟器。这是一种方便的调试应用程序的方式，允许您保持在构建系统更舒适的环境中。
- en: There's more...
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Make sure that the versions of GDB and gdbserver that you are using match, otherwise
    there can be issues with communication between them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您使用的GDB和gdbserver的版本匹配，否则它们之间可能会出现通信问题。
- en: Using CMake as a build system
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CMake作为构建系统
- en: In the previous recipes, we learned how to compile a program that consists of
    one C++ file. Real applications, however, usually have a more complex structure.
    They can contain multiple source files, depend on other libraries, and be split
    into independent projects.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的示例中，我们学习了如何编译由一个C++文件组成的程序。然而，真实的应用程序通常具有更复杂的结构。它们可以包含多个源文件，依赖于其他库，并被分割成独立的项目。
- en: We need a way to conveniently define build rules for any type of application.
    CMake is one of the most well-known and widely used tools that allow developers
    to define high-level rules and translate them into a lower-level build system,
    such as a Unix make.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方便地为任何类型的应用程序定义构建规则的方法。CMake是最知名和广泛使用的工具之一，它允许开发人员定义高级规则并将它们转换为较低级别的构建系统，如Unix
    make。
- en: In this recipe, we will learn how to set up CMake and create a simple project
    definition for our *Hello, world!* application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何设置CMake并为我们的*Hello, world!*应用程序创建一个简单的项目定义。
- en: Getting ready
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'As discussed earlier, a common embedded development workflow includes two environments:
    a build system and a target system. CMake is part of the build system. We are
    going to use the Ubuntu build system, created as a result of the *Setting up the
    build system in a Docker container* recipe, as a starting point.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，常见的嵌入式开发工作流程包括两个环境：构建系统和目标系统。CMake是构建系统的一部分。我们将使用Ubuntu构建系统作为起点，该系统是作为*在Docker容器中设置构建系统*配方的结果创建的。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Our build system does not have CMake installed yet. To install it, run the
    following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的构建系统尚未安装CMake。要安装它，请运行以下命令：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Switch back to your native operating system environment.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回本机操作系统环境。
- en: In the `~/test` directory, create a subdirectory, `hello`. Use your favorite
    text editor to create a file, called `CMakeLists.txt`, in the `hello` subdirectory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`~/test`目录中，创建一个子目录`hello`。使用您喜欢的文本编辑器在`hello`子目录中创建一个名为`CMakeLists.txt`的文件。
- en: 'Enter the following lines:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下行：
- en: '[PRE32]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Save the file and switch to the Ubuntu console.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并切换到Ubuntu控制台。
- en: 'Switch to the `hello` directory:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`hello`目录：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run CMake:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行CMake：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, build the application by running the following:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令构建应用程序：
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Get information about the resulting executable binary using the `file` command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`file`命令获取有关生成的可执行二进制文件的信息：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, the build is native to the x86 platform. We need to add cross-compilation
    support. Switch back to the text editor, open `CMakeLists.txt`, and add the following
    lines:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，构建是本地的x86平台。我们需要添加交叉编译支持。切换回文本编辑器，打开`CMakeLists.txt`，并添加以下行：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Save it and switch to the Ubuntu terminal.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并切换到Ubuntu终端。
- en: 'Run the `cmake` command again to re-generate the build files:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`cmake`命令以重新生成构建文件：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build the code by running `make`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`make`来构建代码：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check the type of the resulting output file again:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查生成的输出文件的类型：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, we have an executable file built for our target system using CMake.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用CMake为我们的目标系统构建了一个可执行文件。
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we install CMake to our build system. Once the installation is complete,
    we switch to the native environment to create `CMakeLists.txt`. This file contains
    high-level build instructions about the project's composition and properties.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将CMake安装到我们的构建系统中。安装完成后，我们切换到本机环境创建`CMakeLists.txt`。这个文件包含关于项目组成和属性的高级构建指令。
- en: We name our project *hello*, which creates an executable, called `hello`, from
    a source file named `hello.cpp`*.* Additionally, we specify the minimal version
    of CMake required to build our application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目命名为*hello*，它从名为`hello.cpp`的源文件创建一个名为`hello`的可执行文件。此外，我们指定了构建我们的应用程序所需的CMake的最低版本。
- en: After we have created the project definition, we can switch back to the build
    system shell and generate low-level build instructions by running `make`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了项目定义之后，我们可以切换回构建系统shell，并通过运行`make`生成低级构建指令。
- en: It is common practice to create a dedicated build directory to keep all our
    build artifacts. By doing this, the object files generated by a compiler or files
    generated by CMake do not pollute the source code directories.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个专用的构建目录来保存所有构建产物是一种常见的做法。通过这样做，编译器生成的目标文件或CMake生成的文件不会污染源代码目录。
- en: In a single command line, we create a `build` directory, change to the newly-created
    directory, and run CMake.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个命令行中，我们创建一个`build`目录，切换到新创建的目录，并运行CMake。
- en: 'We pass the parent directory as a parameter to let CMake know where to look
    for `CMakeListst.txt`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将父目录作为参数传递，让CMake知道在哪里查找`CMakeListst.txt`：
- en: '![](img/14a5bf44-2185-478b-a144-94f6030053c3.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14a5bf44-2185-478b-a144-94f6030053c3.png)'
- en: 'By default, CMake generates the `Makefile` files for the traditional Unix `make`
    utility. We run `make `to actually build the application:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake为传统的Unix `make`实用程序生成`Makefile`文件。我们运行`make`来实际构建应用程序：
- en: '![](img/f5983eee-a06d-4d26-9441-8274013cf7be.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5983eee-a06d-4d26-9441-8274013cf7be.png)'
- en: 'It works, but results in an executable binary built for the x86 platform, while
    our target system is ARM:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以工作，但会导致为x86平台构建的可执行二进制文件，而我们的目标系统是ARM：
- en: '![](img/2f2aedf6-d441-4e80-a11a-4778c32d273e.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f2aedf6-d441-4e80-a11a-4778c32d273e.png)'
- en: 'To solve this, we add several options to our `CMakeLists.txt` file to configure
    cross-compilation. Repeating the build steps again, we get a new `hello` binary,
    now for the ARM platform:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们在我们的`CMakeLists.txt`文件中添加了几个选项来配置交叉编译。再次重复构建步骤，我们得到了一个新的`hello`二进制文件，现在是为ARM平台而构建的：
- en: '![](img/cfdf7699-32f3-41bf-a3fe-54adbf11e341.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfdf7699-32f3-41bf-a3fe-54adbf11e341.png)'
- en: As we can see in the output of the `file` command, we have built the executable
    file for the ARM platform, not x86, which we used as a build platform. This means
    that this program will not run on the build machine, but can be successfully copied
    to our target platform and run there.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`file`命令的输出中所看到的，我们已经为ARM平台构建了可执行文件，而不是x86，我们用作构建平台。这意味着这个程序将无法在构建机器上运行，但可以成功地复制到我们的目标平台并在那里运行。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The best way to configure cross-compilation for CMake is by using the so-called
    **toolchain** files. Toolchain files define all the settings and parameters of
    the build rules specific to the particular target platform, such as a compiler
    prefix, compilation flags, and the location of the libraries pre-built on the
    target platform. An application can be rebuilt for different target platforms
    by using different toolchain files. See the CMake toolchains documentation at
    [https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html)
    for more details.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 配置CMake进行交叉编译的最佳方法是使用所谓的**工具链**文件。工具链文件定义了特定目标平台的构建规则的所有设置和参数，例如编译器前缀、编译标志以及目标平台上预先构建的库的位置。通过使用不同的工具链文件，可以为不同的目标平台重新构建应用程序。有关更多详细信息，请参阅CMake工具链文档[https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html)。
