- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Debugging Using LLVM Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM工具进行调试
- en: LLVM comes with a set of tools that helps you identify certain errors in your
    application. All these tools make use of the LLVM and **clang** libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM附带了一套工具，可以帮助您识别应用程序中的某些错误。所有这些工具都使用了LLVM和**clang**库。
- en: In this chapter, you will learn how to instrument an application with **sanitizers**,
    as well as how to use the most common sanitizer to identify a wide range of bugs,
    after which you’ll implement fuzz testing for your application. This will help
    you identify bugs that are usually not found with unit testing. You will also
    learn how to identify performance bottlenecks in your application, run the **static
    analyzer** to identify problems normally not found by the compiler, and create
    your own clang-based tool, in which you can extend clang with new functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用**清理器**对应用程序进行检测，以及如何使用最常用的清理器来识别广泛的各种错误，之后您将为应用程序实现模糊测试。这将帮助您识别通常在单元测试中找不到的错误。您还将学习如何识别应用程序中的性能瓶颈，运行**静态分析器**来识别编译器通常找不到的问题，并创建自己的基于clang的工具，在其中您可以扩展clang以添加新功能。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Instrumenting an application with sanitizers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用清理器对应用程序进行检测
- en: Finding bugs with **libFuzzer**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**libFuzzer**查找错误
- en: Performance profiling with **XRay**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**XRay**进行性能分析
- en: Checking the source with the **Clang** **Static Analyzer**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Clang** **静态分析器**检查源代码
- en: Creating your own clang-based tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的clang工具
- en: By the end of this chapter, you will know how to use the various LLVM and clang
    tools to identify a large category of errors in an application. You will also
    acquire the knowledge to extend clang with new functionality, for example, to
    enforce naming conventions or to add new source analysis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何使用各种LLVM和clang工具来识别应用程序中的大量错误。您还将获得扩展clang以添加新功能的知识，例如强制命名约定或添加新的源分析。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To create the **flame graph** in the *Performance profiling with XRay* section,
    you need to install the scripts from [https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph).
    Some systems, such as **Fedora** and **FreeBSD**, provide a package for these
    scripts, which you can also use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在*使用XRay进行性能分析*部分创建**火焰图**，您需要安装来自[https://github.com/brendangregg/FlameGraph](https://github.com/brendangregg/FlameGraph)的脚本。某些系统，如**Fedora**和**FreeBSD**，提供了这些脚本的软件包，您也可以使用。
- en: To view the **Chrome visualization** in the same section, you need to have the
    **Chrome** browser installed. You can download the browser from [https://www.google.com/chrome/](https://www.google.com/chrome/)
    or use the package manager of your system to install **Chrome** browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要在同一部分查看**Chrome可视化**，您需要安装**Chrome**浏览器。您可以从[https://www.google.com/chrome/](https://www.google.com/chrome/)下载浏览器或使用系统的包管理器安装**Chrome**浏览器。
- en: Additionally, to run the static analyzer via the `scan-build` script, you need
    to have the `perl-core` package installed on **Fedora** and **Ubuntu**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了通过`scan-build`脚本来运行静态分析器，您需要在**Fedora**和**Ubuntu**上安装`perl-core`软件包。
- en: Instrumenting an application with sanitizers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用清理器对应用程序进行检测
- en: LLVM comes with a couple of `compiler-rt` project. The sanitizers can be enabled
    in clang, which makes them very comfortable to use. To build the `compiler-rt`
    project, we can simply add the `-DLLVM_ENABLE_RUNTIMES=compiler-rt` CMake variable
    to the initial CMake configuration step when building LLVM.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM附带了一些`compiler-rt`项目。可以在clang中启用清理器，这使得它们非常易于使用。要构建`compiler-rt`项目，我们可以在构建LLVM时，简单地将`-DLLVM_ENABLE_RUNTIMES=compiler-rt`
    CMake变量添加到初始CMake配置步骤。
- en: In the following sections, we will look at the `address`, `memory`, and `thread`
    sanitizers. First, we’ll look at the `address` sanitizer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将查看`address`、`memory`和`thread`清理器。首先，我们将查看`address`清理器。
- en: Detecting memory access problems with the address sanitizer
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用地址清理器检测内存访问问题
- en: You can use the `address` sanitizer to detect different types of memory access
    bugs within an application. This includes common errors such as using dynamically
    allocated memory after freeing it or writing to dynamically allocated memory outside
    the boundaries of the allocated memory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`address`清理器来检测应用程序中不同类型的内存访问错误。这包括常见的错误，例如在释放动态分配的内存后使用它或在分配内存边界之外写入动态分配的内存。
- en: When enabled, the `address` sanitizer replaces calls to the `malloc()` and `free()`
    functions with its own version and instruments all memory accesses with a checking
    guard. Of course, this adds a lot of overhead to the application, and you will
    only use the `address` sanitizer during the testing phase of the application.
    If you are interested in the implementation details, then you can find the source
    of the pass in the `llvm/lib/Transforms/Instrumentation/AddressSanitzer.cpp` file
    and a description of the implemented algorithm at [https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，`address` sanitizers会替换对`malloc()`和`free()`函数的调用，并使用自己的版本，并使用检查保护器对所有的内存访问进行仪器化。当然，这会给应用程序添加很多开销，你将在应用程序的测试阶段使用`address`
    sanitizers。如果你对实现细节感兴趣，你可以在`llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp`文件中找到pass的源代码，并在[https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm](https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm)找到实现的算法描述。
- en: Let’s run a short example to show the capabilities of the `address` sanitizer!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个简短的示例来展示`address` sanitizers的能力！
- en: 'The following example application, `outofbounds.c`, allocates `12` bytes of
    memory, but initializes `14` bytes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应用程序，`outofbounds.c`，分配了`12`字节的内存，但初始化了`14`字节：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can compile and run this application without noticing a problem as this
    behavior is typical for this kind of error. Even in larger applications, such
    kinds of bugs can go unnoticed for a long time. However, if you enable the `address`
    sanitizer with the `-fsanitize=address` option, then the application stops after
    detecting the error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编译并运行这个应用程序而不会注意到问题，因为这种行为是这类错误的典型表现。即使在更大的应用程序中，这类错误也可能长时间不被发现。然而，如果你使用`-fsanitize=address`选项启用`address`
    sanitizers，那么应用程序在检测到错误后会停止。
- en: 'It is also useful to enable debug symbols with the `–g` options because it
    helps identify the location of the error in the source. The following code is
    an example of how to compile the source file with the `address` sanitizer and
    debug symbols enabled:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 也有必要使用`-g`选项启用调试符号，因为它有助于识别源代码中错误的地点。以下代码是使用`address` sanitizers和启用调试符号编译源文件的示例：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, you get a lengthy error report when running the application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你会得到一个冗长的错误报告：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The report also contains detailed information about the memory content. The
    important information is the type of the error – `outofbounds.c` file, which is
    the line containing the call to `memset()`. This is the exact place where the
    buffer overflow happens.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 报告还包含了关于内存内容的详细信息。重要信息是错误的类型 – `outofbounds.c`文件，这是包含对`memset()`调用的行。这正是缓冲区溢出的确切位置。
- en: 'If you replace the line containing `memset(p, 0, 14);` in the `outofbounds.c`
    file with the following code, then you can introduce access to memory once you’ve
    freed the memory. You’ll need to store the source in the `useafterfree.c` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`outofbounds.c`文件中将包含`memset(p, 0, 14);`的行替换为以下代码，那么一旦释放了内存，你就可以引入对内存的访问。你需要将源代码存储在`useafterfree.c`文件中：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Again, if you compile and run it, the sanitizer detects the use of the pointer
    after the memory is freed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你编译并运行它，sanitizer会检测到在内存释放后使用指针的情况：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, the report points to *line 8*, which contains dereferencing of the
    `p` pointer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，报告指向*第8行*，其中包含对`p`指针的解引用。
- en: On `ASAN_OPTIONS` environment variable to `detect_leaks=1` before running the
    application, then you also get a report about memory leaks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，将`ASAN_OPTIONS`环境变量设置为`detect_leaks=1`，那么你也会得到关于内存泄漏的报告。
- en: 'On the command line, you can do this as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上，你可以这样做：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `address` sanitizer is very useful because it catches a category of bugs
    that are otherwise difficult to detect. The `memory` sanitizer does a similar
    task. We’ll examine its use cases in the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`address` sanitizers非常有用，因为它可以捕获一类其他情况下难以检测到的错误。`memory` sanitizers执行类似的任务。我们将在下一节中检查其用例。'
- en: Finding uninitialized memory accesses with the memory sanitizer
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存sanitizer查找未初始化的内存访问
- en: Using uninitialized memory is another category of bugs that are hard to find.
    In **C** and **C++**, the general memory allocation routines do not initialize
    the memory buffer with a default value. The same is true for automatic variables
    on the stack.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未初始化的内存是另一类难以找到的错误。在**C**和**C++**中，一般的内存分配例程不会用默认值初始化内存缓冲区。对于堆栈上的自动变量也是如此。
- en: There are lots of opportunities for errors, and the memory sanitizer helps find
    these bugs. If you are interested in the implementation details, you can find
    the source for the memory sanitizer pass in the `llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp`
    file. The comment at the top of the file explains the ideas behind the implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多错误的机会，内存sanitizer有助于找到这些错误。如果你对实现细节感兴趣，可以在`llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp`文件中找到内存sanitizer
    pass的源代码。文件顶部的注释解释了实现背后的思想。
- en: 'Let’s run a small example and save the following source as the `memory.c` file.
    Note that the `x` variable is not initialized and is used as a `return` value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个小示例，并将以下源代码保存为`memory.c`文件。注意，`x`变量未初始化，并被用作`return`值：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Without the sanitizer, the application will run just fine. However, you will
    get an error report if you use the `-``fsanitize=memory` option:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用sanitizer时，应用程序将正常运行。然而，如果你使用`-fsanitize=memory`选项，你会得到一个错误报告：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Like the `address` sanitizer, the memory sanitizer stops the application at
    the first error that’s found. As shown here the memory sanitizer provides a **use
    of initialized** **value** warning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与`address` sanitizer类似，内存sanitizer会在找到的第一个错误处停止应用程序。如这里所示，内存sanitizer提供了**已初始化**的**值**警告。
- en: Finally, in the next section, we’ll look at how we can use the `thread` sanitizer
    to detect data races in multi-threaded applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在下一节中，我们将探讨如何使用`thread` sanitizer来检测多线程应用程序中的数据竞争。
- en: Pointing out data races with the thread sanitizer
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用thread sanitizer指出数据竞争
- en: To leverage the power of modern CPUs, applications now use multiple threads.
    This is a powerful technique, but it also introduces new sources of errors. A
    very common problem in multi-threaded applications is that the access to global
    data is not protected, for example, with a `thread` sanitizer can detect data
    races in `llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp` file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用现代CPU的强大功能，应用程序现在使用多个线程。这是一个强大的技术，但也引入了新的错误来源。在多线程应用程序中一个非常常见的问题是全局数据的访问没有得到保护，例如，使用`thread`
    sanitizer可以在`llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp`文件中检测数据竞争。
- en: To demonstrate the functionality of the `thread` sanitizer, we will create a
    very simple producer-consumer-style application. The producer thread increments
    a global variable, while the consumer thread decrements the same variable. Access
    to the global variable is not protected, so this is a data race.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`thread` sanitizer的功能，我们将创建一个非常简单的生产者-消费者风格的程序。生产者线程增加一个全局变量，而消费者线程减少相同的变量。对全局变量的访问没有得到保护，因此这是一个数据竞争。
- en: 'You’ll need to save the following source in the `thread.c` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将以下源代码保存到`thread.c`文件中：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, the `data` variable is shared between two threads. Here,
    it is of the `int` type to make the example simple since often, a data structure
    such as the `std::vector` class or similar would be used. Furthermore, these two
    threads run the `producer()` and `consumer()` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`data`变量在两个线程之间共享。这里，它被声明为`int`类型，以使示例简单，因为通常，会使用类似`std::vector`类这样的数据结构。此外，这两个线程运行`producer()`和`consumer()`函数。
- en: The `producer()` function only increments the `data` variable, while the `consumer()`
    function decrements it. No access protection is implemented, so this constitutes
    a data race. The `main()` function starts both threads with the `pthread_create()`
    function, waits for the end of the threads with the `pthread_join()` function,
    and returns the current value of the `data` variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer()`函数只增加`data`变量，而`consumer()`函数减少它。没有实现访问保护，因此这构成了数据竞争。`main()`函数使用`pthread_create()`函数启动两个线程，使用`pthread_join()`函数等待线程结束，并返回`data`变量的当前值。'
- en: If you compile and run this application, then you will note no error – that
    is, the return value is always zero. An error – in this case, a return value not
    equal to zero – will appear if the number of loops that are performed is increased
    by a factor of 100\. At this point, you will begin to notice other values appear.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编译并运行这个应用程序，你将不会注意到任何错误——也就是说，返回值总是零。如果执行的循环数量增加100倍，则会显示错误——在这种情况下，返回值不等于零。此时，你将开始注意到其他值出现。
- en: 'We can use the `thread` sanitizer to identify the data race within our program.
    To compile with the `thread` sanitizer enabled, you’ll need to pass the `-fsanitize=thread`
    option to clang. Adding debug symbols with the `–g` options gives you line numbers
    in the report, which is also helpful. Note that you also need to link the `pthread`
    library:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`thread`检查器来识别程序中的数据竞争。要启用`thread`检查器进行编译，你需要将`-fsanitize=thread`选项传递给clang。使用`–g`选项添加调试符号会在报告中提供行号，这也有帮助。请注意，你还需要链接`pthread`库：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The report points us to *lines 6* and *11* of the source file, where the global
    variable is accessed. It also shows that two threads named *T1* and *T2* accessed
    the variable and the file and line number of the respective calls to the `pthread_create()`
    function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 报告指向源文件的*第6行*和*第11行*，其中访问了全局变量。它还显示两个名为*T1*和*T2*的线程访问了该变量，以及`pthread_create()`函数相应调用的文件和行号。
- en: With that, we’ve learned how to use three different types of sanitizers to identify
    common problems in applications. The `address` sanitizer helps us identify common
    memory access errors, such as out-of-bounds accesses or using memory after it’s
    been freed. Using the `memory` sanitizer, we can find access to uninitialized
    memory, and the `thread` sanitizer helps us identify data races.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何使用三种不同类型的检查器来识别应用程序中的常见问题。`address`检查器帮助我们识别常见的内存访问错误，例如越界访问或使用已释放的内存。使用`memory`检查器，我们可以找到对未初始化内存的访问，而`thread`检查器帮助我们识别数据竞争。
- en: In the next section, we’ll try to trigger the sanitizers by running our application
    on random data. This process is known as **fuzz testing**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试通过在随机数据上运行我们的应用程序来触发检查器，这个过程被称为**模糊测试**。
- en: Finding bugs with libFuzzer
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用libFuzzer查找错误
- en: To test your application, you’ll need to write **unit tests**. This is a great
    way to make sure your software behaves correctly and as you might expect. However,
    because of the exponential number of possible inputs, you’ll probably miss certain
    weird inputs, and a few bugs as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的应用程序，你需要编写**单元测试**。这是一种确保你的软件按预期正确运行的好方法。然而，由于可能的输入数量呈指数级增长，你可能会错过某些奇怪的输入，也可能会有一些错误。
- en: '**Fuzz testing** can help here. The idea is to present your application with
    randomly generated data, or data based on valid input but with random changes.
    This is done repeatedly, so your application is tested with a large number of
    inputs, which is why fuzz testing can be a powerful testing approach. It has been
    noted that fuzz testing has assisted in finding hundreds of bugs within web browsers
    and other software.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**可以在这里提供帮助。其思路是向你的应用程序提供随机生成数据，或者基于有效输入但带有随机变化的数据。这个过程会重复进行，因此你的应用程序会使用大量输入进行测试，这就是为什么模糊测试可以是一种强大的测试方法。据记录，模糊测试已帮助在网页浏览器和其他软件中找到数百个错误。'
- en: Interestingly, LLVM comes with its own fuzz testing library. Originally part
    of the LLVM core libraries, the `compiler-rt`. The library is designed to test
    small and fast functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，LLVM自带了自己的模糊测试库。最初是LLVM核心库的一部分，即`compiler-rt`。该库旨在测试小型且快速的函数。
- en: Let’s run a small example to see how libFuzzer works. First, you will need to
    provide the `LLVMFuzzerTestOneInput()` function. This function is called by the
    **fuzzer driver** and provides you with some input. The following function counts
    consecutive ASCII digits in the input. Once it’s done that, we’ll feed random
    input to it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一个小示例来看看libFuzzer是如何工作的。首先，你需要提供`LLVMFuzzerTestOneInput()`函数。这个函数由**模糊测试驱动程序**调用，并提供一些输入。以下函数计算输入中的连续ASCII数字。完成这个操作后，我们将随机输入喂给它。
- en: 'You’ll need to save the example in the `fuzzer.c` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将示例保存到`fuzzer.c`文件中：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, the `count()` function counts the number of digits in
    the memory pointed to by the `Data` variable. The size of the data is only checked
    to determine if there are any bytes available. Inside the `while` loop, the size
    is not checked.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`count()`函数计算`Data`变量指向的内存中的数字数量。数据的大小仅用于确定是否有可用的字节。在`while`循环内部，不检查大小。
- en: Used with normal `0` byte. The `LLVMFuzzerTestOneInput()` function is the so-called
    `0`, which is currently the only allowed value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正常的`0`字节。`LLVMFuzzerTestOneInput()`函数被称为`0`，目前是唯一允许的值。
- en: 'To compile the file with libFuzzer, you must add the `-fsanitize=fuzzer` option.
    The recommendation is to also enable the `address` sanitizer and the generation
    of debug symbols. We can use the following command to compile the `fuzzer.c` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用libFuzzer编译文件，必须添加`-fsanitize=fuzzer`选项。建议同时启用`address`检查器和调试符号的生成。我们可以使用以下命令来编译`fuzzer.c`文件：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run the test, it emits a lengthy report. The report contains more
    information than a stack trace, so let’s have a closer look at it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试时，它会生成一个冗长的报告。报告包含的信息比堆栈跟踪更多，所以让我们更仔细地看看它：
- en: 'The first line tells you the seed that was used to initialize the random number
    generator. You can use the `–seed=` option to repeat this execution:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行告诉你用于初始化随机数生成器的种子。你可以使用`–seed=`选项来重复此执行：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, libFuzzer limits inputs to, at most, `4096` bytes. You can change
    the default by using the `–``max_len=` option:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，libFuzzer将输入限制在最多`4096`字节。你可以通过使用`–max_len=`选项来更改默认值：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can run the test without providing sample input. The set of all sample
    inputs is called `corpus`, and it is empty for this run:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以不提供样本输入来运行测试。所有样本输入的集合称为`corpus`，对于这次运行它是空的：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some information about the generated test data will follow. It shows you that
    `28` inputs were tried and `6` inputs, which together have a length of `19` bytes,
    were found, which together cover `6` coverage points or basic blocks:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下将展示关于生成测试数据的详细信息。它显示你尝试了`28`个输入，并找到了`6`个输入，这些输入的总长度为`19`字节，它们共同覆盖了`6`个覆盖率点或基本块：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After this, a buffer overflow was detected, and it followed the information
    from the `address` sanitizer. Lastly, the report tells you where the input causing
    the buffer overflow is saved:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，检测到缓冲区溢出，并跟随`address`检查器提供的信息。最后，报告告诉你导致缓冲区溢出的输入被保存的位置：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the saved input, the test case can be executed with the same crashing
    input again:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用保存的输入，可以再次使用相同的崩溃输入来执行测试用例：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This helps identify the problem as we can use the saved input as a direct reproducer
    to fix whatever problems that may arise. However, only using random data is often
    not very helpful in every situation. If you try to fuzz test the `tinylang` lexer
    or parser, then pure random data leads to immediate rejection of the input because
    no valid token can be found.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于识别问题，因为我们可以使用保存的输入作为直接重现器来修复可能出现的任何问题。然而，仅使用随机数据在每种情况下通常并不很有帮助。如果你尝试模糊测试`tinylang`词法分析器或解析器，那么纯随机数据会导致立即拒绝输入，因为找不到任何有效令牌。
- en: In such cases, it is more useful to provide a small set of valid input, called
    the corpus. In this situation, the files of the corpus are randomly mutated and
    used as input. You can think of the input as mostly valid, with just a few bits
    flipped. This also works great with other input, which must have a certain format.
    For example, for a library that processes `corpus`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，提供一小组有效输入，称为corpus，更有用。在这种情况下，corpus的文件会被随机变异并用作输入。你可以认为输入主要是有效的，只有少数位被翻转。这也非常适合其他必须具有特定格式的输入。例如，对于一个处理`corpus`的库：
- en: 'An example of providing the corpus looks like this. You can save the corpus
    files in one or more directories and you can create a simple corpus for our fuzz
    test with the help of the `printf` command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提供corpus的一个例子如下。你可以将corpus文件保存到一个或多个目录中，并且你可以使用`printf`命令帮助我们创建一个简单的corpus用于我们的模糊测试：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When running the test, you must provide the directory on the command line:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试时，必须在命令行上提供目录：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The corpus is then used as the base for generating random input, as the report
    tells you:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后corpus被用作生成随机输入的基础，正如报告所告知的：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Furthermore, if you are testing a function that works on tokens or other magic
    values, such as a programming language, then you can speed up the process by providing
    a dictionary with the tokens. For a programming language, the dictionary would
    contain all the keywords and special symbols used in the language. Moreover, the
    dictionary definitions follow a simple key-value style. For example, to define
    the `if` keyword in the dictionary, you can add the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你正在测试一个处理令牌或其他魔法值（如编程语言）的函数，那么通过提供一个包含令牌的字典可以加快这个过程。对于编程语言，字典将包含语言中使用的所有关键字和特殊符号。此外，字典定义遵循简单的键值风格。例如，要在字典中定义`if`关键字，你可以添加以下内容：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, the key is optional, and you can leave it out. Now, you can specify
    the dictionary file on the command line with the `–``dict=` option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，密钥是可选的，您可以省略它。现在，您可以使用 `–dict=` 选项在命令行上指定字典文件。
- en: Now that we’ve covered using libFuzzer to find bugs, let’s look at the limitations
    and alternatives for the libFuzzer implementation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何使用 libFuzzer 来查找错误，让我们来看看 libFuzzer 实现的局限性和替代方案。
- en: Limitations and alternatives
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性和替代方案
- en: 'The libFuzzer implementation is fast but poses several restrictions on the
    test target. They are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: libFuzzer 的实现速度快，但对测试目标施加了几个限制。它们如下：
- en: The function under `test` must accept the input as an array in memory. Some
    library functions require a file path to the data instead, and they cannot be
    tested with libFuzzer.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `test` 下的函数必须接受内存中的数组作为输入。一些库函数需要数据的文件路径，并且不能使用 libFuzzer 进行测试。
- en: The `exit()` function should not be called.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应调用 `exit()` 函数。
- en: The global state should not be altered.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局状态不应被修改。
- en: Hardware random number generators should not be used.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应使用硬件随机数生成器。
- en: The first two restrictions are an implication of the implementation of libFuzzer
    as a library. The latter two restrictions are needed to avoid confusion in the
    evaluation algorithm. If one of these restrictions is not met, then two identical
    calls to the fuzz target can yield different results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个限制是 libFuzzer 作为库实现的推论。后两个限制是为了避免评估算法中的混淆。如果这些限制中的任何一个没有得到满足，那么对模糊目标进行两次相同的调用可能会得到不同的结果。
- en: The best-known alternative tool for fuzz testing is **AFL**, which can be found
    at [https://github.com/google/AFL](https://github.com/google/AFL). AFL requires
    an instrumented binary (an LLVM plugin for instrumentation is provided) and requires
    the application to take the input as a file path on the command line. AFL and
    libFuzzer can share the same corpus and the same dictionary files. Thus, it is
    possible to test an application with both tools. Furthermore, where libFuzzer
    is not applicable, AFL may be a good alternative.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的模糊测试替代工具是 **AFL**，可以在 [https://github.com/google/AFL](https://github.com/google/AFL)
    找到。AFL 需要一个已插入的二进制文件（提供了一个用于插入的 LLVM 插件）并且需要应用程序将输入作为命令行上的文件路径。AFL 和 libFuzzer
    可以共享相同的语料库和相同的字典文件。因此，可以使用这两个工具测试应用程序。此外，当 libFuzzer 不适用时，AFL 可能是一个不错的选择。
- en: There are many more ways of influencing the way libFuzzer works. You can read
    the reference page at [https://llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)
    for more details.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他方法可以影响 libFuzzer 的工作方式。您可以阅读 [https://llvm.org/docs/LibFuzzer.html](https://llvm.org/docs/LibFuzzer.html)
    上的参考页面以获取更多详细信息。
- en: In the next section, we look at a different problem an application can have
    – we’ll try to identify performance bottlenecks while using the XRay tool.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨应用程序可能遇到的不同问题——我们将尝试使用 XRay 工具来识别性能瓶颈。
- en: Performance profiling with XRay
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XRay 进行性能分析
- en: If your application seems to run slow, then you might want to know where the
    time is spent in the code. Here, instrumenting the code with `llvm/lib/XRay/`
    directory. The runtime portion is part of `compiler-rt`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序似乎运行缓慢，那么您可能想知道代码中的时间是如何花费的。在这里，使用 `llvm/lib/XRay/` 目录对代码进行插入。运行时部分是
    `compiler-rt` 的一部分。
- en: 'In the following example source, real work is simulated by calling the `usleep()`
    function. The `func1()` function sleeps for 10 µs. The `func2()` function calls
    `func1()` or sleeps for 100 µs, depending on if the `n` parameter is odd or even.
    Inside the `main()` function, both functions are called inside a loop. This is
    already enough to get interesting information. You’ll need to save the following
    source code in the `xraydemo.c` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例源代码中，通过调用 `usleep()` 函数来模拟实际工作。`func1()` 函数休眠 10 µs。`func2()` 函数根据 `n`
    参数是奇数还是偶数来调用 `func1()` 或休眠 100 µs。在 `main()` 函数内部，这两个函数都在循环中被调用。这已经足够获取有趣的信息。您需要将以下源代码保存到
    `xraydemo.c` 文件中：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To enable the XRay instrumentation during compilation, you will need to specify
    the `-fxray-instrument` option. It is worth noting that functions with less than
    200 instructions are not instrumented. This is because this is an arbitrary threshold
    defined by the developers, and in our case, the functions would not be instrumented.
    The threshold can be specified with the `-``fxray-instruction-threshold=` option.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在编译期间启用 XRay 代码插桩，您需要指定 `-fxray-instrument` 选项。值得注意的是，指令数少于 200 的函数不会进行代码插桩。这是因为这是一个由开发者定义的任意阈值，在我们的情况下，这些函数不会进行代码插桩。阈值可以使用
    `-fxray-instruction-threshold=` 选项指定。
- en: 'Alternatively, we can add a function attribute to control if a function should
    be instrumented. For example, adding the following prototype would result in us
    always instrumenting the function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以添加一个函数属性来控制是否应该对函数进行代码插桩。例如，添加以下原型将导致我们始终对函数进行代码插桩：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Likewise, by using the `xray_never_instrument` attribute, you can turn off instrumentation
    for a function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过使用 `xray_never_instrument` 属性，您可以关闭对函数的代码插桩。
- en: 'We will now use the command-line option and compile the `xraydemo.c` file,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用命令行选项并编译 `xraydemo.c` 文件，如下所示：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the resulting binary, instrumentation is turned off by default. If you run
    the binary, you will note no difference compared to a non-instrumented binary.
    The `XRAY_OPTIONS` environment variable is used to control the recording of runtime
    data. To enable data collection, you can run the application as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的二进制文件中，代码插桩默认是关闭的。如果您运行这个二进制文件，您将注意到与未进行代码插桩的二进制文件相比没有区别。`XRAY_OPTIONS`
    环境变量用于控制运行时数据的记录。要启用数据收集，您可以按如下方式运行应用程序：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `xray_mode=xray-basic` option tells the runtime that we want to use basic
    mode. In this mode, all runtime data is collected, which can result in large log
    files. When the `patch_premain=true` option is given, functions that are run before
    the `main()` function are also instrumented.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`xray_mode=xray-basic` 选项告知运行时我们想要使用基本模式。在这种模式下，所有运行时数据都会被收集，这可能导致日志文件变得很大。当提供
    `patch_premain=true` 选项时，也会对在 `main()` 函数之前运行的函数进行代码插桩。'
- en: After running this command, a new file will be created in the directory, in
    which the collected data is stored. You will need to use the **llvm-xray** tool
    to extract any readable information from this file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，在目录中会创建一个新文件，其中存储了收集的数据。您需要使用 **llvm-xray** 工具从该文件中提取任何可读信息。
- en: The llvm-xray tool supports various sub-commands. First of all, you can use
    the `account` sub-command to extract some basic statistics. For example, to get
    the top 10 most called functions, you can add the `-top=10` option to limit the
    output, and the `-sort=count` option to specify the function call count as the
    sort criteria. You can also influence the sort order with the `-``sortorder=`
    option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: llvm-xray 工具支持各种子命令。首先，您可以使用 `account` 子命令提取一些基本统计信息。例如，要获取前 10 个最常调用的函数，您可以添加
    `-top=10` 选项来限制输出，并添加 `-sort=count` 选项来指定函数调用次数作为排序标准。您还可以使用 `-sortorder=` 选项来影响排序顺序。
- en: 'The following commands can be run to get the statistics from our program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以运行以下命令来从我们的程序中获取统计信息：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the `func1()` function is called most often; you can also see
    the accumulated time spent in this function. This example only has three functions,
    so the `–top=` option has no visible effect here, but for real applications, it
    is very useful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`func1()` 函数被调用得最频繁；您还可以看到在这个函数中花费的累积时间。这个例子只有三个函数，所以 `–top=` 选项在这里没有可见效果，但对于实际应用来说，它非常有用。
- en: 'From the collected data, it is possible to reconstruct all the stack frames
    that occurred during runtime. You use the `stack` sub-command to view the top
    10 stacks. The output shown here has been reduced for brevity:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从收集的数据中，可以重建运行时发生的所有堆栈帧。您可以使用 `stack` 子命令查看前 10 个堆栈。这里显示的输出已被缩减以节省篇幅：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A `func2()` function is called by the `main()` function, and this is the stack
    frame with the largest accumulated time. The depth depends on how many functions
    are called, and the stack frames are usually large.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数调用了 `func2()` 函数，这是累积时间最长的堆栈帧。深度取决于调用了多少个函数，堆栈帧通常较大。'
- en: This sub-command can also be used to create a `flamegraph.pl` script, you can
    convert the data into a **scalable vector graphics** (**SVG**) file that you can
    view in your browser.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此子命令还可以用于创建 `flamegraph.pl` 脚本，您可以将数据转换为可在浏览器中查看的 **可缩放矢量图形**（**SVG**）文件。
- en: 'With the following command, you instruct `llvm-xray` to output all stack frames
    with the `–all-stacks` option. Using the `–stack-format=flame` option, the output
    is in the format expected by the `flamegraph.pl` script. Moreover, with the `–aggregation-type`
    option, you can choose if stack frames are aggregated by total time or by the
    number of invocations. The output of `llvm-xray` is piped into the `flamegraph.pl`
    script, and the resulting output is saved in the `flame.svg` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，您指示 `llvm-xray` 使用 `–all-stacks` 选项输出所有堆栈帧。使用 `–stack-format=flame` 选项，输出格式符合
    `flamegraph.pl` 脚本预期的格式。此外，使用 `–aggregation-type` 选项，您可以选择堆栈帧是按总时间还是按调用次数聚合。`llvm-xray`
    的输出通过管道传递到 `flamegraph.pl` 脚本，并将结果输出保存到 `flame.svg` 文件中：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After running the command and generating the new flame graph, you can open
    the generated `flame.svg` file in your browser. The graphic looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令并生成新的火焰图后，您可以在浏览器中打开生成的 `flame.svg` 文件。图形如下所示：
- en: '![Figure 10.1 – Flame graph produced by llvm-xray](img/B19561_10_1.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 由 llvm-xray 生成的火焰图](img/B19561_10_1.jpg)'
- en: Figure 10.1 – Flame graph produced by llvm-xray
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 由 llvm-xray 生成的火焰图
- en: Flame graphs can be confusing at first glance because the *X*-axis does not
    have the usual meaning of elapsed time. Instead, the functions are simply sorted
    alphabetically by name. Furthermore, the *Y*-axis of the flame graph shows the
    stack depth, where the bottom begins counting from zero. The colors are chosen
    to have a good contrast and have no other meaning. From the preceding graph, you
    can easily determine the call hierarchy and the time spent in a function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图一开始可能会让人感到困惑，因为 *X* 轴并没有表示经过时间的通常意义。相反，函数只是按名称字母顺序排序。此外，火焰图的 *Y* 轴显示堆栈深度，底部从零开始计数。颜色选择是为了有良好的对比度，没有其他含义。从前面的图中，您可以轻松地确定调用层次结构和函数中花费的时间。
- en: 'Information about a stack frame is displayed only after you move the mouse
    cursor over the rectangle representing the frame. By clicking on the frame, you
    can zoom into this stack frame. Flame graphs are of great help if you want to
    identify functions worth optimizing. To find out more about flame graphs, please
    visit the website of Brendan Gregg, the inventor of flame graphs: [http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在将鼠标光标移至表示帧的矩形上时，才会显示堆栈帧的信息。通过单击帧，您可以放大此堆栈帧。如果您想识别值得优化的函数，火焰图非常有帮助。要了解更多关于火焰图的信息，请访问火焰图的发明者布伦丹·格雷格的网站：[http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html)。
- en: 'Additionally, you can use the `convert` subcommand to convert the data into
    `.yaml` format or the format used by the `xray.evt` file, you can run the following
    command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用 `convert` 子命令将数据转换为 `.yaml` 格式或 `xray.evt` 文件使用的格式，您可以运行以下命令：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you do not specify the `–symbolize` option, then no function names are shown
    in the resulting graph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有指定 `–symbolize` 选项，则结果图中不会显示函数名称。
- en: 'Once you’ve done that, open Chrome and type `chrome:///tracing`. Next, click
    on the `xray.evt` file. You will see the following visualization of the data:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，打开 Chrome 并输入 `chrome:///tracing`。然后，单击 `xray.evt` 文件。您将看到以下数据可视化：
- en: '![Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray](img/B19561_10_2.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 由 llvm-xray 生成的 Chrome 跟踪查看器可视化](img/B19561_10_2.jpg)'
- en: Figure 10.2 – Chrome Trace Viewer Visualization generated by llvm-xray
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 由 llvm-xray 生成的 Chrome 跟踪查看器可视化
- en: In this view, the stack frames are sorted by the time the function call occurs.
    For further interpretation of the visualization, please read the tutorial at [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此视图中，堆栈帧按函数调用发生的时间排序。为了进一步解释可视化结果，请阅读位于 [https://www.chromium.org/developers/how-tos/trace-event-profiling-tool](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool)
    的教程。
- en: Tip
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The llvm-xray tool has more functionality that is applicable for performance
    profiling. You can read about it on the LLVM website at [https://llvm.org/docs/XRay.html](https://llvm.org/docs/XRay.html)
    and [https://llvm.org/docs/XRayExample.html](https://llvm.org/docs/XRayExample.html).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: llvm-xray 工具有更多适用于性能分析的功能。您可以在 LLVM 网站上阅读有关信息：[https://llvm.org/docs/XRay.html](https://llvm.org/docs/XRay.html)
    和 [https://llvm.org/docs/XRayExample.html](https://llvm.org/docs/XRayExample.html)。
- en: In this section, we learned how to instrument an application with XRay, how
    to collect runtime information, and how to visualize that data. We can use this
    knowledge to find performance bottlenecks in applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用XRay对应用程序进行仪器化，如何收集运行时信息，以及如何可视化这些数据。我们可以使用这些知识来查找应用程序中的性能瓶颈。
- en: Another approach to identifying errors in an application is to analyze the source
    code, which is done with the clang static analyzer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 识别应用程序中的错误的另一种方法是分析源代码，这可以通过clang静态分析器来完成。
- en: Checking the source with the clang static analyzer
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用clang静态分析器检查源代码
- en: The **clang static analyzer** is a tool that performs additional checks on C,
    C++, and **Objective C** source code. The checks that are performed by the static
    analyzer are more thorough than the checks the compiler performs. They are also
    more costly in terms of time and required resources. The static analyzer has a
    set of checkers, which check for certain bugs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**clang静态分析器**是一个对C、C++和**Objective C**源代码执行额外检查的工具。静态分析器执行的检查比编译器执行的检查更彻底。它们在时间和所需资源方面也更具成本。静态分析器有一套检查器，用于检查特定的错误。'
- en: The tool performs a symbolic interpretation of the source code, which looks
    at all code paths through an application and derives constraints on the values
    used in the application from it. **Symbolic interpretation** is a common technique
    that’s used in compilers, for example, to identify constant values. In the context
    of the static analyzer, the checkers are applied to the derived values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 工具对源代码进行符号解释，它检查应用程序的所有代码路径，并从中推导出应用于应用程序的值的约束。**符号解释**是一种在编译器中常用的技术，例如，用于识别常量值。在静态分析器的上下文中，检查器应用于推导出的值。
- en: 'For example, if the divisor of a division is zero, then the static analyzer
    warns us about it. We can check this with the following example stored in the
    `div.c` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果除法的除数为零，则静态分析器会警告我们。我们可以通过以下存储在`div.c`文件中的示例来检查这一点：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The static analyzer will warn about a division by `0` in this example. However,
    when compiling, the file, when compiled with the `clang -Wall -c div.c` command,
    will show no warning.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，静态分析器将警告除以`0`。然而，当使用`clang -Wall -c div.c`命令编译文件时，将不会显示任何警告。
- en: 'There are two ways to invoke the static analyzer from the command line. The
    older tool is `scan-build` tool is the easiest solution. You simply pass the `compile`
    command to the tool; everything else is done automatically:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行调用静态分析器有两种方法。较老的工具是`scan-build`工具，这是最简单的解决方案。你只需将`compile`命令传递给工具；其他所有操作都会自动完成：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output on the screen already tells you that a problem was found – that is,
    the `core.DivideZero` checker was triggered. However, that is not all. You will
    find a complete report in HTML in the mentioned subdirectory of the `/tmp` directory.
    You can then use the `scan-view` command to view the report or open the `index.html`
    file found in the subdirectory in your browser.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的输出已经告诉你已经发现了一个问题——也就是说，触发了`core.DivideZero`检查器。然而，这还不是全部。你将在`/tmp`目录的指定子目录中找到一个完整的HTML报告。然后你可以使用`scan-view`命令来查看报告或在浏览器中打开子目录中找到的`index.html`文件。
- en: 'The first page of the report shows you a summary of the bugs that were found:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的第一页显示了发现的错误摘要：
- en: '![Figure 10.3 – Summary page](img/B19561_10_3.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 摘要页面](img/B19561_10_3.jpg)'
- en: Figure 10.3 – Summary page
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 摘要页面
- en: For each error that was found, the summary page shows the type of the error,
    the location in the source, and the path length after which the analyzer found
    the error. A link to a detailed report for the error is also provided.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发现的每个错误，摘要页面都会显示错误的类型、源代码中的位置以及分析器找到错误后的路径长度。还会提供一个错误详细报告的链接。
- en: 'The following screenshot shows the detailed report for the error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了错误的详细报告：
- en: '![Figure 10.4 – Detailed report](img/B19561_10_4.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 详细报告](img/B19561_10_4.jpg)'
- en: Figure 10.4 – Detailed report
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 详细报告
- en: With this detailed report, you can verify the error by following the numbered
    bubbles. Our simple example shows how passing `0` as a parameter value leads to
    a division by zero error.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这份详细的报告，你可以通过跟随编号的气泡来验证错误。我们的简单示例展示了将`0`作为参数值传递会导致除以零错误。
- en: Thus, human verification is required. If the derived constraints are not precise
    enough for a certain checker, then false positives are possible – that is, an
    error is reported for perfectly fine code. Based on the report, you can use them
    to identify false positives.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要人工验证。如果派生的约束对于某个检查器来说不够精确，则可能出现假阳性 – 即，对于完全正常的代码报告了错误。根据报告，您可以使用它们来识别假阳性。
- en: You are not limited to checkers that are provided with the tool – you can also
    add new checkers. The next section demonstrates how to do this.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于使用工具提供的检查器 – 您还可以添加新的检查器。下一节将演示如何做到这一点。
- en: Adding a new checker to the clang static analyzer
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将新的检查器添加到 clang 静态分析器
- en: Many C libraries provide functions that must be used in pairs. For example,
    the C standard library provides the `malloc()` and `free()` functions. The memory
    that’s allocated by `malloc()` function must be freed exactly one time by the
    `free()` function. Not calling the `free()` function, or calling it several times,
    is a programming error. There are many more instances of this coding pattern,
    and the static analyzer provides checkers for some of them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 C 库提供了必须成对使用的函数。例如，C 标准库提供了 `malloc()` 和 `free()` 函数。由 `malloc()` 函数分配的内存必须由
    `free()` 函数精确释放一次。不调用 `free()` 函数，或者多次调用它，是编程错误。这种编码模式还有很多实例，静态分析器为其中一些提供了检查器。
- en: The `iconv_open()` and `iconv_close()` functions, which must be used in pairs,
    similar to the memory management functions. No checker is implemented for those
    functions, so let’s implement one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconv_open()` 和 `iconv_close()` 函数，必须成对使用，类似于内存管理函数。尚未为这些函数实现检查器，所以让我们来实现一个。'
- en: To add a new checker to the clang static analyzer, you must create a new subclass
    of the `Checker` class. The static analyzer tries all possible paths through the
    code. The analyzer engine generates events at certain points – for example, before
    or after a function call. Moreover, your class must provide callbacks for these
    events if you need to handle them. The `Checker` class and the registrations for
    the events are provided in the `clang/include/clang/StaticAnalyzer/Core/Checker.h`
    header file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的检查器添加到 clang 静态分析器，您必须创建 `Checker` 类的新子类。静态分析器尝试代码的所有可能路径。分析器引擎在特定点生成事件
    – 例如，在函数调用之前或之后。此外，如果需要处理这些事件，您的类必须提供回调。`Checker` 类和事件的注册在 `clang/include/clang/StaticAnalyzer/Core/Checker.h`
    头文件中提供。
- en: Usually, a checker needs to track some symbols. However, the checker cannot
    manage the state because it does not know which code path the analyzer engine
    currently tries. Therefore, the tracked state must be registered with the engine,
    and can only be changed using a `ProgramStateRef` instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，检查器需要跟踪一些符号。然而，检查器无法管理状态，因为它不知道分析器引擎当前尝试哪个代码路径。因此，跟踪的状态必须注册到引擎中，并且只能使用 `ProgramStateRef`
    实例来更改。
- en: To detect the errors, the checker needs to track the descriptor that’s returned
    from the `iconv_open()` function. The analyzer engine returns a `SymbolRef` instance
    for the return value of the `iconv_open()` function. We associate this symbol
    with a state to reflect if `iconv_close()` was called or not. For the state, we
    create the `IconvState` class, which encapsulates a `bool` value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测错误，检查器需要跟踪从 `iconv_open()` 函数返回的描述符。分析器引擎为 `iconv_open()` 函数的返回值返回一个 `SymbolRef`
    实例。我们将此符号与一个状态关联，以反映是否调用了 `iconv_close()`。对于状态，我们创建了 `IconvState` 类，它封装了一个 `bool`
    值。
- en: 'The new `IconvChecker` class needs to handle four types of events:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `IconvChecker` 类需要处理四种类型的事件：
- en: '`PostCall`, which occurs after a function call. After the `iconv_open()` function
    was called, we retrieved the symbol for the return value and remembered it as
    being in an “opened” state.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostCall`，发生在函数调用之后。在调用 `iconv_open()` 函数之后，我们检索了返回值的符号，并将其记住为处于“打开”状态。'
- en: '`PreCall`, which occurs before a function call. Before the `iconv_close()`
    function is called, we check if the symbol for the descriptor is in an “opened”
    state. If not, then the `iconv_close()` function was already called for the descriptor,
    and we have detected a double call to the function.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreCall`，发生在函数调用之前。在调用 `iconv_close()` 函数之前，我们检查描述符的符号是否处于“打开”状态。如果不是，那么对于该描述符已经调用了
    `iconv_close()` 函数，并且我们已经检测到该函数的双重调用。'
- en: '`DeadSymbols`, which occurs when unused symbols are cleaned up. We check if
    an unused symbol for a descriptor is still in an “opened” state. If it is, then
    we have detected a missing call to `iconv_close()`, which is a resource leak.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当未使用的符号被清理时，会发生 `DeadSymbols`。我们检查描述符的未使用符号是否仍然处于“打开”状态。如果是，那么我们就检测到了对 `iconv_close()`
    的缺失调用，这是一个资源泄露。
- en: '`PointerEscape`, which is called when the symbols can no longer be tracked
    by the analyzer. In this case, we remove the symbol from the state because we
    can no longer reason about whether the descriptor was closed or not.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当符号无法被分析器跟踪时，会调用 `PointerEscape`。在这种情况下，我们从状态中删除符号，因为我们无法再推断描述符是否已关闭。
- en: 'We can create a new directory to implement the new checker as a clang plugin,
    and add the implementations within the `IconvChecker.cpp` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的目录来实现新的检查器作为 clang 插件，并在 `IconvChecker.cpp` 文件中添加实现：
- en: 'For the implementation, we need to include several header files. The `include`
    file, `BugType.h` is required for emitting reports. The header file, `Checker.h`,
    provides the declaration of the `Checker` class and the callbacks for the events,
    which are declared in the `CallEvent` file Moreover, the `CallDescription.h` file
    helps with matching functions and methods. Finally, the `CheckerContext.h` file
    is required for declaring the `CheckerContext` class, which is the central class
    that provides access to the state of the analyzer:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于实现，我们需要包含几个头文件。`include` 文件 `BugType.h` 是用于生成报告所必需的。头文件 `Checker.h` 提供了 `Checker`
    类的声明以及事件的回调，这些事件在 `CallEvent` 文件中声明。此外，`CallDescription.h` 文件有助于匹配函数和方法。最后，`CheckerContext.h`
    文件是声明 `CheckerContext` 类所必需的，这是一个提供对分析器状态访问的中心类：
- en: '[PRE32]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To avoid typing the namespace names, we can use the `clang` and `ento` namespaces:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免输入命名空间名称，我们可以使用 `clang` 和 `ento` 命名空间：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We associate a state with each symbol representing an iconv descriptor. The
    state can be open or closed, and we use a `bool` typed variable, with `true` value
    for the open state. The state value is encapsulated in the `IconvState` struct.
    This struct is used with a `FoldingSet` data structure, which is a hash set that
    filters duplicate entries. To be usable with this data structure implementation,
    the `Profile()` method is added here, which sets the unique bits of this struct.
    We put the struct into an anonymous namespace to avoid polluting the global namespace.
    Instead of exposing the `bool` value, the class provides the `getOpened()` and
    `getClosed()` factory methods and the `isOpen()` query method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将一个状态与表示 iconv 描述符的每个符号关联起来。状态可以是打开或关闭的，我们使用一个 `bool` 类型的变量，对于打开状态使用 `true`
    值。状态值封装在 `IconvState` 结构体中。这个结构体与 `FoldingSet` 数据结构一起使用，这是一个过滤重复条目的哈希集合。为了与这个数据结构实现兼容，这里添加了
    `Profile()` 方法，它设置这个结构体的唯一位。我们将结构体放入匿名命名空间中，以避免污染全局命名空间。而不是暴露 `bool` 值，类提供了 `getOpened()`
    和 `getClosed()` 工厂方法以及 `isOpen()` 查询方法：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `IconvState` struct represents the state of an iconv descriptor, which
    is represented by a symbol of the `SymbolRef` class. This is best done with a
    map, which has the symbol as the key and the state as the value. As explained
    earlier, the checker cannot hold the state. Instead, the state must be registered
    with the global program state, which is done with the `REGISTER_MAP_WITH_PROGRAMSTATE`
    macro. This macro introduces the `IconvStateMap` name, which we will use later
    to access the map:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvState` 结构体表示 iconv 描述符的状态，描述符由 `SymbolRef` 类的符号表示。这最好通过一个映射来实现，其中符号作为键，状态作为值。如前所述，检查器无法保持状态。相反，状态必须与全局程序状态注册，这通过
    `REGISTER_MAP_WITH_PROGRAMSTATE` 宏来完成。此宏引入了 `IconvStateMap` 名称，我们将在稍后使用它来访问映射：'
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also implement the `IconvChecker` class in an anonymous namespace. The requested
    `PostCall`, `PreCall`, `DeadSymbols`, and `PointerEscape` events are template
    parameters to the `Checker` base class:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在匿名命名空间中实现了 `IconvChecker` 类。请求的 `PostCall`、`PreCall`、`DeadSymbols` 和 `PointerEscape`
    事件是 `Checker` 基类模板参数：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `IconvChecker` class has fields of the `CallDescription` type, which are
    used to identify function calls to `iconv_open()`, `iconv()`, and `iconv_close()`in
    the program:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvChecker` 类具有 `CallDescription` 类型的字段，这些字段用于识别程序中对 `iconv_open()`、`iconv()`
    和 `iconv_close()` 的函数调用：'
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The class also holds references to the detected bug types:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类还持有检测到的错误类型的引用：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, the class has a couple of methods. Besides the constructor and the
    methods for the call events, we also need a method to emit a bug report:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这个类有几个方法。除了构造函数和调用事件的方法之外，我们还需要一个方法来发出错误报告：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation of the constructor of the `IconvChecker` class initializes
    the `CallDescription` fields using the name of the functions, and creates the
    objects representing the bug types:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IconvChecker`类的构造函数的实现使用函数的名称初始化`CallDescription`字段，并创建代表错误类型的对象：'
- en: '[PRE40]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we can implement the first call event method, `checkPostCall()`. This
    method is called after the analyzer has executed a function call. If the executed
    function is not a global C function and not named `iconv_open`, then there is
    nothing to do:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以实现第一个调用事件方法，`checkPostCall()`。这个方法在分析器执行函数调用后被调用。如果执行的函数不是全局C函数也不是名为`iconv_open`的函数，那么就没有什么要做的：
- en: '[PRE41]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Otherwise, we can try to get the return value of the function as a symbol.
    To store the symbol with the open state in the global program state, we need to
    get a `ProgramStateRef` instance from the `CheckerContext` instance. The state
    is immutable, so adding the symbol to the state results in a new state. Finally,
    the analyzer engine is informed about the new state with a call to the `addTransition()`
    method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们可以尝试将函数的返回值作为一个符号。为了将符号以打开状态存储在全局程序状态中，我们需要从`CheckerContext`实例中获取一个`ProgramStateRef`实例。状态是不可变的，因此将符号添加到状态会导致一个新的状态。最后，通过调用`addTransition()`方法通知分析器引擎新的状态：
- en: '[PRE42]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Likewise, the `checkPreCall()` method is called before the analyzer executes
    a function. Only a global C function called `iconv_close` is of interest to us:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在分析器执行函数之前调用`checkPreCall()`方法。只有名为`iconv_close`的全局C函数对我们感兴趣：
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the symbol for the first argument of the function, which is the iconv descriptor,
    is known, then we can retrieve the state of the symbol from the program state:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数的第一个参数的符号（即iconv描述符）是已知的，那么我们可以从程序状态中检索符号的状态：
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the state represents the closed state, then we have detected a double close
    error, and we can generate a bug report for it. The call to `generateErrorNode()`
    can return a `nullptr` value if an error report was already generated for this
    path, so we have to check for this situation:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果状态表示关闭状态，那么我们检测到了双重关闭错误，并且可以为此生成一个错误报告。如果已经为该路径生成了错误报告，`generateErrorNode()`的调用可以返回一个`nullptr`值，因此我们必须检查这种情况：
- en: '[PRE45]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Otherwise, we must set the state for the symbol to the “closed” state:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们必须将符号的状态设置为“关闭”状态：
- en: '[PRE46]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `checkDeadSymbols()` method is called to clean up unused symbols. We loop
    over all symbols we track and ask the `SymbolReaper` instance if the current symbol
    is dead:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`checkDeadSymbols()`方法来清理未使用的符号。我们遍历所有我们跟踪的符号，并询问`SymbolReaper`实例当前符号是否无效：
- en: '[PRE47]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the symbol is dead, then we need to check the state. If the state is still
    open, then this is a potential resource leak. There is one exception: `iconv_open()`
    returns `-1` in case of an error. If the analyzer is in a code path that handles
    this error, then it is wrong to assume a resource leak because the function call
    failed. We try to get the value of the symbol from the `ConstraintManager` instance,
    and we do not consider the symbol as a resource leak if this value is `-1`. We
    add a leaked symbol to a `SmallVector` instance to generate the error report later.
    Finally, we remove the dead symbol from the program state:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果符号是无效的，那么我们需要检查状态。如果状态仍然是打开的，那么这是一个潜在的资源泄露。有一个例外：`iconv_open()`在出错时返回`-1`。如果分析器在一个处理这个错误的代码路径中，那么假设资源泄露是错误的，因为函数调用失败了。我们尝试从`ConstraintManager`实例中获取符号的值，并且如果这个值是`-1`，我们不将符号视为资源泄露。我们将泄露的符号添加到一个`SmallVector`实例中，以便稍后生成错误报告。最后，我们将无效的符号从程序状态中移除：
- en: '[PRE48]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After the loop, we call the `generateNonFatalErrorNode()` method. This method
    transitions to the new program state and returns an error node if there is not
    already an error node for this path. The `LeakedSyms` container holds the (possibly
    empty) list of leaked symbols, and we call the `report()` method to generate an
    error report:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，我们调用`generateNonFatalErrorNode()`方法。这个方法过渡到新的程序状态，如果没有为该路径生成错误节点，则返回一个错误节点。`LeakedSyms`容器持有（可能为空）的泄露符号列表，我们调用`report()`方法来生成错误报告：
- en: '[PRE49]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `checkPointerEscape()` function is called when the analyzer detects a function
    call for which the parameters cannot be tracked. In such a case, we must assume
    that we do not know if the iconv descriptor will be closed inside the function
    or not. The exceptions are a call to `iconv()`, which does the conversion and
    is known to not call the `iconv_close()` function, and the `iconv_close()` function
    itself, which we handle in the `checkPreCall()` method. We also do not change
    the state if the call is inside a system header file, and if we know that the
    arguments do not escape in the called function. In all other cases, we remove
    the symbol from the state:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当分析器检测到一个无法跟踪参数的函数调用时，会调用`checkPointerEscape()`函数。在这种情况下，我们必须假设我们不知道iconv描述符是否会在函数内部关闭。例外情况是调用`iconv()`，它执行转换并且已知不会调用`iconv_close()`函数，以及`iconv_close()`函数本身，我们在`checkPreCall()`方法中处理它。我们也不会改变调用在系统头文件内部的状态，如果我们知道参数不会在调用函数中逃逸。在所有其他情况下，我们从状态中删除符号：
- en: '[PRE50]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `report()` method generates an error report. The important parameters of
    the method are an array of symbols, the type of the bug, and a bug description.
    Inside the method, a bug report is created for each symbol, and the symbol is
    marked as the interesting one for the bug. If a source range is provided as a
    parameter, then this is also added to the report. Finally, the report is emitted:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`report()`方法生成错误报告。该方法的重要参数是一个符号数组、错误类型和错误描述。在方法内部，为每个符号创建一个错误报告，并将符号标记为对错误感兴趣的。如果提供了源范围作为参数，那么它也会添加到报告中。最后，报告被发出：'
- en: '[PRE51]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, the new checker needs to be registered at a `CheckerRegistry` instance.
    When our plugin is loaded, the `clang_registerCheckers()` function is used, in
    which we perform the registration. Each checker has a name and belongs to a package.
    We call the `IconvChecker` checker and put it into the `unix` packager because
    the iconv library is a standard POSIX interface. This is the first parameter of
    the `addChecker()` method. The second parameter is a brief documentation of the
    functionality, and the third parameter can be a URI to a document that provides
    more information about the checker:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，新的检查器需要在`CheckerRegistry`实例中进行注册。当我们的插件被加载时，使用`clang_registerCheckers()`函数，在其中进行注册。每个检查器都有一个名称，并属于一个包。我们调用`IconvChecker`检查器，并将其放入`unix`包中，因为iconv库是一个标准的POSIX接口。这是`addChecker()`方法的第一个参数。第二个参数是对功能功能的简要说明，第三个参数可以是一个指向提供有关检查器更多信息文档的URI：
- en: '[PRE52]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we need to declare the version of the static analyzer API we are using,
    which enables the system to determine if the plugin is compatible:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要声明我们使用的静态分析器API的版本，这使系统能够确定插件是否兼容：
- en: '[PRE53]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This finishes the implementation of the new checker. To build the plugin, we
    also need to create a build description in the `CMakeLists.txt` file which lives
    in the same directory as `IconvChecker.cpp`:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了新检查器的实现。为了构建插件，我们还需要在`CMakeLists.txt`文件中创建一个构建描述，该文件位于`IconvChecker.cpp`相同的目录中：
- en: 'Begin by defining the required **CMake** version and the name of the project:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义所需的**CMake**版本和项目名称：
- en: '[PRE54]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, include the LLVM files. If CMake can’t find the files automatically,
    then you have to set the `LLVM_DIR` variable so that it points to the LLVM directory
    containing the CMake files:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包含LLVM文件。如果CMake无法自动找到文件，那么你必须设置`LLVM_DIR`变量，使其指向包含CMake文件的LLVM目录：
- en: '[PRE55]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Append the LLVM directory with the CMake files to the search path, and include
    the required modules from LLVM:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含CMake文件的LLVM目录添加到搜索路径中，并从LLVM包含所需的模块：
- en: '[PRE56]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, load the CMake definitions for clang. If CMake can’t find the files automatically,
    then you have to set the `Clang_DIR` variable so that it points to the clang directory
    containing the CMake files:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载clang的CMake定义。如果CMake无法自动找到文件，那么你必须设置`Clang_DIR`变量，使其指向包含CMake文件的clang目录：
- en: '[PRE57]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, append the Clang directory with the CMake files to the search path, and
    include the required modules from Clang:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将包含CMake文件的Clang目录添加到搜索路径中，并从Clang包含所需的模块：
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, define where the header files and the library files are located, and
    which definitions to use:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义头文件和库文件的位置，以及要使用的定义：
- en: '[PRE59]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The previous definitions set up the build environment. Insert the following
    command, which defines the name of your plugin, the source file(s) of the plugin,
    and that it is a clang plugin:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的定义设置了构建环境。插入以下命令，该命令定义了你的插件名称、插件的源文件以及它是一个clang插件：
- en: '[PRE60]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On **Windows**, the plugin support is different from **Unix**, and the required
    LLVM and clang libraries must be linked in. The following code ensures this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Windows** 上，插件支持与 **Unix** 不同，必须链接所需的 LLVM 和 clang 库。以下代码确保了这一点：
- en: '[PRE61]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we can configure and build the plugin, assuming that the `CMAKE_GENERATOR`
    and `CMAKE_BUILD_TYPE` environment variables are set:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置和构建插件，假设 `CMAKE_GENERATOR` 和 `CMAKE_BUILD_TYPE` 环境变量已设置：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can test the new checker with the following source saved in the `conv.c`
    file, which has two calls to the `iconv_close()` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下源代码在 `conv.c` 文件中测试新的检查器，该文件有两个对 `iconv_close()` 函数的调用：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To use the plugin with the `scan-build` script, you need to specify the path
    to the plugin via the `-load-plugin` option. A run with the `conv.c` file looks
    like:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `scan-build` 脚本与插件一起使用，你需要通过 `-load-plugin` 选项指定插件的路径。使用 `conv.c` 文件的一个运行示例如下：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With that, you’ve learned how to extend the clang static analyzer with your
    own checker. You can use this knowledge to either create new general checkers
    and contribute them to the community or create checkers specifically built for
    your needs, to raise the quality of your product.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何使用自己的检查器扩展 clang 静态分析器。你可以使用这些知识来创建新的通用检查器并将其贡献给社区，或者创建专门为你的需求定制的检查器，以提高你产品的质量。
- en: The static analyzer is built by leveraging the clang infrastructure. The next
    section introduces you to how can build your own plugin extending clang.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器是通过利用 clang 基础设施构建的。下一节将介绍如何构建自己的插件以扩展 clang。
- en: Creating your own clang-based tool
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的基于 clang 的工具
- en: The static analyzer is an impressive example of what you can do with the clang
    infrastructure. It is also possible to extend clang with plugins so that you can
    add your own functionality to clang. The technique is very similar to adding a
    pass plugin to LLVM.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器是利用 clang 基础设施所能做到的令人印象深刻的例子。也有可能通过插件扩展 clang，以便你可以在 clang 中添加自己的功能。这种技术非常类似于向
    LLVM 添加一个 pass 插件。
- en: Let’s explore the functionality with a simple plugin. The LLVM coding standard
    requires function names to begin with a lowercase letter. However, the coding
    standard has evolved, and there are many instances in which a function begins
    with an uppercase letter. A plugin that warns about a violation of the naming
    rule can help fix this issue, so let’s give it a try.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的插件来探索功能。LLVM 编码标准要求函数名以小写字母开头。然而，编码标准已经发展，有许多函数以大写字母开头的情况。一个警告关于命名规则违规的插件可以帮助解决这个问题，所以让我们试试看。
- en: Because you want to run a user-defined action over the AST, you need to define
    a subclass of the `PluginASTAction` class. If you write your own tool using the
    clang libraries, then you can define subclasses of the `ASTFrontendAction` class
    for your actions. The `PluginASTAction` class is a subclass of the `ASTFrontendAction`
    class, with the additional ability to parse command-line options.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你想在 AST 上运行用户定义的操作，你需要定义 `PluginASTAction` 类的子类。如果你使用 clang 库编写自己的工具，那么你可以为你的操作定义
    `ASTFrontendAction` 类的子类。`PluginASTAction` 类是 `ASTFrontendAction` 类的子类，具有解析命令行选项的附加功能。
- en: 'The other class you need is a subclass of the `ASTConsumer` class. An AST consumer
    is a class using which you can run an action over an AST, regardless of the origin
    of the AST. Nothing more is needed for our first plugin. You can create the implementation
    in the `NamingPlugin.cpp` file as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个 `ASTConsumer` 类的子类。AST 消费者是一个你可以使用它来在 AST 上运行操作的类，无论 AST 的来源如何。对于我们的第一个插件，不需要更多。你可以在
    `NamingPlugin.cpp` 文件中创建实现，如下所示：
- en: 'Begin by including the required header files. Besides the mentioned `ASTConsumer`
    class, you also need an instance of the compiler and the plugin registry:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时，包括所需的头文件。除了提到的 `ASTConsumer` 类之外，你还需要编译器和插件注册表的实例：
- en: '[PRE65]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `clang` namespace and put your implementation into an anonymous `namespace`
    to avoid name clashes:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clang` 命名空间，并将你的实现放入一个匿名 `namespace` 中，以避免名称冲突：
- en: '[PRE66]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Next, define your subclass of the `ASTConsumer` class. Later, you will want
    to emit warnings in case you detect a violation of the naming rule. To do so,
    you need a reference to a `DiagnosticsEngine` instance.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义你的 `ASTConsumer` 类的子类。稍后，如果你检测到命名规则的违规，你将想要发出警告。为此，你需要一个 `DiagnosticsEngine`
    实例的引用。
- en: 'You’ll need to store a `CompilerInstance` instance in the class, after which
    you can ask for a `DiagnosticsEngine` instance:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在类中存储一个 `CompilerInstance` 实例，之后你可以请求一个 `DiagnosticsEngine` 实例：
- en: '[PRE67]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'An `ASTConsumer` instance has several entry methods. The `HandleTopLevelDecl()`
    method fits our purpose. The method is called for each declaration at the top
    level. This includes more than functions – for example, variables. So, you must
    use the LLVM RTTI `dyn_cast<>()` function to determine if the declaration is a
    function declaration. The `HandleTopLevelDecl()` method has a declaration group
    as a parameter, which can contain more than a single declaration. This requires
    a loop over the declarations. The following code shows the `HandleTopLevelDecl()`
    method:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ASTConsumer`实例有几个入口方法。`HandleTopLevelDecl()`方法符合我们的目的。该方法为顶级声明调用。这包括不仅仅是函数——例如，变量。因此，你必须使用LLVM
    RTTI `dyn_cast<>()`函数来确定声明是否为函数声明。`HandleTopLevelDecl()`方法有一个声明组作为参数，它可以包含多个声明。这需要遍历声明。以下代码显示了`HandleTopLevelDecl()`方法：'
- en: '[PRE68]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After finding a function declaration, you’ll need to retrieve the name of the
    function. You’ll also need to make sure that the name is not empty:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在找到函数声明后，你需要检索函数名称。同时，你还需要确保名称不为空：
- en: '[PRE69]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the function name does not start with a lowercase letter, then you’ll have
    a violation of the naming rule that was found:'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果函数名称不以小写字母开头，那么你将违反找到的命名规则：
- en: '[PRE70]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To emit a warning, you need a `DiagnosticsEngine` instance. Additionally, you
    need a message ID. Inside clang, the message ID is defined as an enumeration.
    Because your plugin is not part of clang, you need to create a custom ID, which
    you can then use to emit the warning:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发出警告，你需要一个`DiagnosticsEngine`实例。此外，你还需要一个消息ID。在clang中，消息ID被定义为枚举。因为你的插件不是clang的一部分，你需要创建一个自定义ID，然后你可以使用它来发出警告：
- en: '[PRE71]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Except for closing all open braces, you need to return `true` from this function
    to indicate that processing can continue:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了关闭所有未闭合的大括号外，你需要从这个函数返回`true`以指示处理可以继续：
- en: '[PRE72]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, you need to create the `PluginASTAction` subclass, which implements the
    interface called by clang:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要创建实现clang调用的`PluginASTAction`子类：
- en: '[PRE73]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The first method you must implement is the `CreateASTConsumer()` method, which
    returns an instance of your `NamingASTConsumer` class. This method is called by
    clang, and the passed `CompilerInstance` instance gives you access to all the
    important classes of the compiler. The following code demonstrates this:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你必须实现的第一种方法是`CreateASTConsumer()`方法，它返回你的`NamingASTConsumer`类的实例。该方法由clang调用，传递的`CompilerInstance`实例为你提供了访问编译器所有重要类的权限。以下代码演示了这一点：
- en: '[PRE74]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A plugin also has access to command-line options. Your plugin has no command-line
    parameters, and you will only return `true` to indicate success:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件还可以访问命令行选项。你的插件没有命令行参数，你将只返回`true`以指示成功：
- en: '[PRE75]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The action type of a plugin describes when the action is invoked. The default
    value is `Cmdline`, which means that the plugin must be named on the command line
    to be invoked. You’ll need to override the method and change the value to `AddAfterMainAction`,
    which automatically runs the action:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插件的动作类型描述了动作何时被调用。默认值是`Cmdline`，这意味着插件必须在命令行上指定才能被调用。你需要重写该方法并将值更改为`AddAfterMainAction`，这将自动运行动作：
- en: '[PRE76]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The implementation of your `PluginNamingAction` class is finished; only the
    closing braces for the class and the anonymous namespace are missing. Add them
    to the code, as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的`PluginNamingAction`类的实现已完成；只缺少类和匿名命名空间的闭合大括号。将它们添加到代码中，如下所示：
- en: '[PRE77]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Lastly, you need to register the plugin. The first parameter is the name of
    the plugin, while the second parameter is help text:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要注册插件。第一个参数是插件名称，第二个参数是帮助文本：
- en: '[PRE78]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This finishes the implementation of the plugin. To compile the plugin, create
    a build description in the `CMakeLists.txt` file. The plugin lives outside the
    clang source tree, so you need to set up a complete project. You can do so by
    following these steps:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了插件的实现。要编译插件，请在`CMakeLists.txt`文件中创建一个构建描述。由于插件位于clang源树之外，因此你需要设置一个完整的项目。你可以通过以下步骤来完成：
- en: 'Begin by defining the required **CMake** version and the name of the project:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始时，定义所需的**CMake**版本和项目名称：
- en: '[PRE79]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, include the LLVM files. If CMake can’t find the files automatically,
    then you have to set the `LLVM_DIR` variable so that it points to the LLVM directory
    containing the CMake files:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包含LLVM文件。如果CMake无法自动找到文件，那么你必须设置`LLVM_DIR`变量，使其指向包含CMake文件的LLVM目录：
- en: '[PRE80]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Append the LLVM directory with the CMake files to the search path, and include
    some required modules:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 LLVM 目录和 CMake 文件夹添加到搜索路径中，并包含一些必需的模块：
- en: '[PRE81]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, load the CMake definitions for clang. If CMake can’t find the files automatically,
    then you have to set the `Clang_DIR` variable so that it points to the clang directory
    containing the CMake files:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，加载 clang 的 CMake 定义。如果 CMake 无法自动找到文件，那么你必须设置 `Clang_DIR` 变量，使其指向包含 CMake
    文件的 clang 目录：
- en: '[PRE82]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Next, define where the headers files and the library files are located, and
    which definitions to use:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义头文件和库文件的位置以及要使用的定义：
- en: '[PRE83]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The previous definitions set up the build environment. Insert the following
    command, which defines the name of your plugin, the source file(s) of the plugin,
    and that it is a clang plugin:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的定义设置了构建环境。插入以下命令，它定义了你的插件名称、插件源文件以及它是一个 clang 插件：
- en: '[PRE84]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'On **Windows**, the plugin support is different from **Unix**, and the required
    LLVM and clang libraries must be linked in. The following code ensures this:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **Windows** 上，插件支持与 **Unix** 不同，必须链接所需的 LLVM 和 clang 库。以下代码确保了这一点：
- en: '[PRE85]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, we can configure and build the plugin, assuming that the `CMAKE_GENERATOR`
    and `CMAKE_BUILD_TYPE` environment variables are set:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以配置和构建插件，假设 `CMAKE_GENERATOR` 和 `CMAKE_BUILD_TYPE` 环境变量已设置：
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: These steps create the `NamingPlugin.so` shared library in the `build` directory.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在 `build` 目录中创建了 `NamingPlugin.so` 共享库。
- en: 'To test the plugin, save the following source as the `naming.c` file. The function
    name, `Func1`, violates the naming rule, but not the `main` name:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试插件，将以下源代码保存为 `naming.c` 文件。函数名 `Func1` 违反了命名规则，但 `main` 名称没有：
- en: '[PRE87]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To invoke the plugin, you need to specify the `–``fplugin=` option:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用插件，你需要指定 `–fplugin=` 选项：
- en: '[PRE88]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This kind of invocation requires that you override the `getActionType()` method
    of the `PluginASTAction` class and that you return a value different from the
    `Cmdline` default value.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种调用需要你重写 `PluginASTAction` 类的 `getActionType()` 方法，并返回一个不同于 `Cmdline` 默认值的值。
- en: 'If you did not do this – for example, because you want to have more control
    over the invocation of the plugin action – then you can run the plugin from the
    compiler command line:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样做 - 例如，因为你想要对插件动作的调用有更多的控制 - 那么你可以从编译器命令行运行插件：
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Congratulations – you have built your first clang plugin!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你 - 你已经构建了你的第一个 clang 插件！
- en: 'The disadvantage of this approach is that it has certain limitations. The `ASTConsumer`
    class has different entry methods, but they are all coarse-grained. This can be
    solved by using the `RecursiveASTVisitor` class. This class traverses all AST
    nodes, and you can override the `VisitXXX()` methods you are interested in. You
    can rewrite the plugin so that it uses the visitor by following these steps:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它有一定的局限性。`ASTConsumer` 类有不同的入口方法，但它们都是粗粒度的。这可以通过使用 `RecursiveASTVisitor`
    类来解决。这个类遍历所有 AST 节点，你可以重写你感兴趣的 `VisitXXX()` 方法。你可以按照以下步骤重写插件，使其使用访问者：
- en: 'You need an additional `include` for the definition of the `RecursiveASTVisitor`
    class. Insert it as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要额外的 `include` 来定义 `RecursiveASTVisitor` 类。按照以下方式插入它：
- en: '[PRE90]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then, define the visitor as the first class in the anonymous namespace. You
    will only store a reference to the AST context, which will give you access to
    all the important methods for AST manipulation, including the `DiagnosticsEngine`
    instance, which is required for emitting the warning:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将访问者定义为匿名命名空间中的第一个类。你将只存储对 AST 上下文的引用，这将为你提供访问所有重要的 AST 操作方法，包括用于发出警告的 `DiagnosticsEngine`
    实例：
- en: '[PRE91]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'During traversal, the `VisitFunctionDecl()` method is called whenever a function
    declaration is discovered. Copy the body of the inner loop inside the `HandleTopLevelDecl()`
    function here:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遍历过程中，每当发现函数声明时，都会调用 `VisitFunctionDecl()` 方法。将内循环的体复制到 `HandleTopLevelDecl()`
    函数中：
- en: '[PRE92]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This finishes the visitor’s implementation. In your `NamingASTConsumer` class,
    you will now only store a visitor instance:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了访问者的实现。在你的 `NamingASTConsumer` 类中，你现在将只存储一个访问者实例：
- en: '[PRE93]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Remove the `HandleTopLevelDecl()` method – the functionality is now in the
    visitor class, so you’ll need to override the `HandleTranslationUnit()` method
    instead. This class is called once for each translation unit. You will start the
    AST traversal here:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `HandleTopLevelDecl()` 方法 - 功能现在在访问者类中，所以你需要重写 `HandleTranslationUnit()`
    方法。这个类对每个翻译单元调用一次。你将在这里开始 AST 遍历：
- en: '[PRE94]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This new implementation has the same functionality. The advantage is that it
    is easier to extend. For example, if you want to examine variable declarations,
    then you must implement the `VisitVarDecl()` method. Alternatively, if you want
    to work with a statement, then you must implement the `VisitStmt()` method. With
    this approach, you have a visitor method for each entity of the C, C++, and Objective
    C languages.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的实现具有相同的功能。优点是它更容易扩展。例如，如果您想检查变量声明，那么您必须实现`VisitVarDecl()`方法。或者，如果您想处理一个语句，那么您必须实现`VisitStmt()`方法。采用这种方法，您为C、C++和Objective-C语言的每个实体都有一个访问者方法。
- en: Having access to the AST allows you to build plugins that perform complex tasks.
    Enforcing naming conventions, as described in this section, is a useful addition
    to clang. Another useful addition you could implement as a plugin is the calculation
    of a software metric such as **cyclomatic complexity**. You can also add or replace
    AST nodes, allowing you, for example, to add runtime instrumentation. Adding plugins
    allows you to extend clang in the way you need it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问AST允许您构建执行复杂任务的插件。如本节所述，强制执行命名约定是clang的一个有用补充。您还可以通过插件实现另一个有用的补充，例如计算软件度量，如**循环复杂度**。您还可以添加或替换AST节点，例如，允许您添加运行时仪表。添加插件允许您以您所需的方式扩展clang。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to apply various sanitizers. You detected pointer
    errors with the `address` sanitizer, uninitialized memory access with the `memory`
    sanitizer, and performed data races with the `thread` sanitizer. Application errors
    are often triggered by malformed input, and you implemented fuzz testing to test
    your application with random data.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何应用各种清理器。您使用`address`清理器检测指针错误，使用`memory`清理器检测未初始化的内存访问，并使用`thread`清理器执行数据竞争。应用程序错误通常由格式不正确的输入触发，并且您实现了模糊测试来使用随机数据测试您的应用程序。
- en: You also instrumented your application with XRay to identify the performance
    bottlenecks, and you also learned about the various ways you can visualize the
    data. This chapter also taught you how to utilize the clang static analyzer for
    identifying potential errors by interpreting the source code, and how to create
    your own clang plugin.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您还使用XRay对您的应用程序进行仪表化，以识别性能瓶颈，并且您还学习了各种可视化数据的方法。本章还教您如何利用clang静态分析器通过解释源代码来识别潜在错误，以及如何创建您自己的clang插件。
- en: These skills will help you raise the quality of the applications you build as
    it is certainly good to find runtime errors before your application users complain
    about them. Applying the knowledge you’ve gained in this chapter, you can not
    only find a wide range of common errors, but you can also extend clang with new
    functionality.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技能将帮助您提高您构建的应用程序的质量，因为在你应用程序的用户抱怨之前发现运行时错误无疑是件好事。应用本章所获得的知识，您不仅可以找到各种常见错误，还可以扩展clang以添加新功能。
- en: In the next chapter, you will learn how to add a new backend to LLVM.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何向LLVM添加新的后端。
