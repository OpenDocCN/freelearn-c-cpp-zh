- en: Chapter 3. Numerical Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 数值方法
- en: In the previous chapter, we reviewed some of the key mathematical models used
    to describe the behavior of the underlying assets of financial derivatives. We
    saw, in particular, how these models are used to describe the future behavior
    of these assets based on the information we have today. These models are generally
    expressed in terms of SDEs and **Partial Differential Equations (PDEs)**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们回顾了一些用于描述金融衍生品基础资产行为的关键数学模型。特别是，我们看到了这些模型如何用于根据我们今天拥有的信息描述这些资产的未来行为。这些模型通常用SDEs和**偏微分方程（PDEs）**来表示。
- en: 'In this chapter, we are going to describe the three main numerical methods
    used in the financial markets today in the context of financial derivatives. They
    are a way to use actual numerical values to the abstract mathematical formulas
    we saw in the previous chapter. These numerical methods are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述当今金融市场上用于金融衍生品的三种主要数值方法。它们是一种将实际数值应用于我们在上一章中看到的抽象数学公式的方法。这些数值方法如下：
- en: '**Monte Carlo** (**MC**) simulation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蒙特卡洛**（**MC**）模拟'
- en: '**Binomial Trees** (**BT**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二叉树**（**BT**）'
- en: '**Finite Difference Methods** (**FDM**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有限差分方法**（**FDM**）'
- en: In the context of the Bento Box template, this chapter corresponds to box 3—numerical
    methods. There is a fourth family of methods, less frequently used, called **quadrature
    methods**, which are used for numerical integration. These will not be discussed
    here.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bento Box模板的背景下，本章对应于第3个盒子——数值方法。还有一种不太常用的第四类方法，称为**积分方法**，用于数值积分。这些不会在这里讨论。
- en: The Monte Carlo simulation method
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟方法
- en: Monte Carlo simulation is named after the famous casino in the principality
    of Monaco. It is the most widely used numerical method to price financial derivatives
    in the industry because of its simplicity, flexibility, and extensibility.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟是以摩纳哥公国著名的赌场命名的。由于其简单性、灵活性和可扩展性，它是工业中用于定价金融衍生品的最广泛使用的数值方法。
- en: The basic idea of the method is to construct a simulation engine that will allow
    us to predict a number of possible ways (or trajectories) in which the underlying
    assets can evolve in the future. These trajectories can be thought of as potential
    economic or financial scenarios. With MC simulation, we attempt to answer questions
    such as "given the observed price of Vodafone stock today, what could be the likely
    prices of the stock each day for the next month?"
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的基本思想是构建一个模拟引擎，使我们能够预测基础资产未来可能发展的多种方式（或轨迹）。这些轨迹可以被视为潜在的经济或金融场景。通过蒙特卡洛模拟，我们试图回答诸如“鉴于今天的沃达丰股票价格，未来一个月内每天的股票价格可能是多少？”这样的问题。
- en: As we cannot be certain of the future evolution of prices, our result needs
    to be based on probability, and, thus, we need large number of samples. Using
    the stochastic models that we saw in the previous chapter to simulate one possible
    trajectory, with MC simulation, we are going to simulate many possible trajectories
    and, for each, compute the payoff that the contract would have had if the prices
    had followed that specific path in future. Afterwards, we are going to take all
    these possible payoffs and compute their expected value, that is, the mean or
    average value. This will give us an estimate of how much this contract will be
    worth in the future.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法确定价格的未来演变，我们的结果需要基于概率，因此我们需要大量的样本。使用我们在上一章中看到的随机模型来模拟一个可能的轨迹，通过蒙特卡洛模拟，我们将模拟许多可能的轨迹，并且对于每一个，计算合同如果价格按照未来的特定路径发展的话将会有的回报。然后，我们将取所有这些可能的回报并计算它们的期望值，即平均值。这将给我们一个估计，即这份合同在未来将价值多少。
- en: MC simulation then allows us to compute the fair price of a financial derivative
    as its expected discounted payoff. This concept stems from the financial principle
    of fair pricing, which states that the price that a contract should have if the
    sum of the cash flows that we expect to receive are the same as the sum of the
    cash flows that we expect to pay. For more details on MC simulation, you are invited
    to refer to *Monte Carlo Methods in Financial Engineering*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟随后允许我们计算金融衍生品的公平价格，即其预期贴现回报。这个概念源自公平定价的金融原则，即合同应该具有的价格，如果我们预期收到的现金流总和与我们预期支付的现金流总和相同。有关蒙特卡洛模拟的更多细节，欢迎参考《金融工程中的蒙特卡洛方法》。
- en: 'In order to have an intuition of why this is the case, consider the following
    simple example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地理解为什么会这样，考虑以下简单的例子：
- en: Imagine that you have bought a plain vanilla European Call option contract at
    time *t=0*. This contract will give you a payoff of ![The Monte Carlo simulation
    method](img/00095.jpeg) at maturity *t=T*. Because the value of the underlying
    at maturity is uncertain, that is, *S_T* is a random variable, the payoff function
    *H(S_T)* is also uncertain. We can write that the expected value of the payoff
    function ![The Monte Carlo simulation method](img/00096.jpeg) is the expectation
    ![The Monte Carlo simulation method](img/00097.jpeg). In addition, in a European
    Call contract, we pay a premium today in order to have the right to exercise the
    option or not at maturity *t=T*. How much should we pay for the premium for this
    contract today?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您在*t=0*时购买了一个普通的欧式看涨期权合同。该合同将在到期日*t=T*给您一笔回报！因为到期时的基础价值是不确定的，即*S_T*是一个随机变量，回报函数*H(S_T)*也是不确定的。我们可以写出回报函数的期望值！此外，在欧式看涨合同中，我们今天支付保险费，以便在到期日*t=T*行使期权或不行使期权。我们今天应该为这份合同支付多少保险费？
- en: 'As we said before, in a fair value setting, what we expect to receive should
    be equal to what we expect to pay. By putting all these cashflows together (positive
    indicating to be received, negative to be paid) we can write the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，在公允价值设置中，我们期望收到的应该等于我们期望支付的。通过将所有这些现金流合并在一起（正数表示应收，负数表示应付），我们可以写成以下形式：
- en: Amount paid at *t=0* is written as ![The Monte Carlo simulation method](img/00098.jpeg)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t=0*时支付的金额写为![蒙特卡洛模拟方法](img/00098.jpeg)'
- en: Amount to be received at *t=T* is written as ![The Monte Carlo simulation method](img/00099.jpeg)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t=T*时应收金额写为![蒙特卡洛模拟方法](img/00099.jpeg)'
- en: 'If we now compute the present value of these cash flows, we get the following
    equation:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在计算这些现金流的现值，我们得到以下方程：
- en: '![The Monte Carlo simulation method](img/00100.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛模拟方法](img/00100.jpeg)'
- en: 'In other words, it can be summarized as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可以总结如下：
- en: '![The Monte Carlo simulation method](img/00101.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛模拟方法](img/00101.jpeg)'
- en: The object of the MC simulation method is precisely to help us compute the expectation
    of the payoff ![The Monte Carlo simulation method](img/00102.jpeg); once you compute
    this, discount this value to obtain the premium of the derivative.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MC模拟方法的目的正是帮助我们计算支付的期望值![蒙特卡洛模拟方法](img/00102.jpeg)；一旦计算出这个值，就将其折现以获得衍生品的保费。
- en: This same idea can be generalized to more complex settings with many complex
    payoffs and underlyings.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法也可以推广到更复杂的设置，包括许多复杂的支付和标的资产。
- en: Algorithm of the MC method
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MC方法的算法
- en: 'For European-type derivatives, MC simulation is composed of the following three
    steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于欧式衍生品，MC模拟包括以下三个步骤：
- en: The first step is to generate trajectories.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成轨迹。
- en: 'Simulate *M* trajectories for the evolution of the underlying from *t=0* to
    maturity *t=T*. In this step, we use the discretized version of SDE that describes
    the evolution of the underlying. In our case, we use GBM as SDE, which will allow
    us to take the value of the stock from its current value *S_0* to the value at
    maturity *t=T*. A discretized version is essentially an approximate version applicable
    to finite time steps rather than continuous time steps. For more details, please
    refer to *Monte Carlo Methods in Financial Engineering*. We discretize the life
    of the option contract in *N* steps, each of size *dt*, which can be succinctly
    written as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟从*t=0*到到期*t=T*的标的资产的* M*条轨迹。在这一步中，我们使用描述标的资产演变的SDE的离散化版本。在我们的情况下，我们使用GBM作为SDE，这将允许我们将股票的价值从当前价值*S_0*取到到期时的价值*t=T*。离散化版本本质上是一个适用于有限时间步长而不是连续时间步长的近似版本。有关更多细节，请参考《金融工程中的蒙特卡洛方法》。我们将期权合同的寿命离散化为*N*步，每步大小为*dt*，可以简洁地写成如下形式：
- en: '![Algorithm of the MC method](img/00103.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00103.jpeg)'
- en: 'At the end of this step, we should have a vector of *M* values for *S_T*, as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步结束时，我们应该得到一个*S_T*的值向量，如下所示：
- en: '![Algorithm of the MC method](img/00104.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00104.jpeg)'
- en: These represent a set of possible scenarios for the value of the underlying
    *S* at time *t=T*. We use GBM to generate multiple paths that will serve a prediction
    of where the value of *S_T* will be at maturity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表了在*t=T*时*S*的潜在价值的一组可能情景。我们使用GBM生成多条路径，这些路径将用于预测到期时*S_T*的价值。
- en: The next step is to compute the expectation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是计算期望。
- en: 'Once we have the set of values of the underlying at maturity, we now need to
    compute the expectation of the payoff at maturity. So we take each of these values
    and compute the payoff for each value as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到到期时标的资产的价值集合，现在需要计算到期时支付的期望。因此，我们取这些价值中的每一个，并按如下方式计算每个价值的支付：
- en: '![Algorithm of the MC method](img/00105.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00105.jpeg)'
- en: 'The preceding equation will give us a vector of payoffs. In order to compute
    the expectation, we need to simply take the average of the payoffs as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方程将给我们一个支付向量。为了计算期望，我们只需要简单地取支付的平均值，如下所示：
- en: '![Algorithm of the MC method](img/00106.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00106.jpeg)'
- en: Now discount the expectation to the present.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将期望值折现到现在。
- en: 'The final step is to discount the value of the payoff from maturity to the
    present time. In order to do this, we will use the following formula:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将到期时的支付价值折现到现在。为了做到这一点，我们将使用以下公式：
- en: '![Algorithm of the MC method](img/00101.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00101.jpeg)'
- en: 'Alternatively, we can also use continuous compounding, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用连续复利，如下所示：
- en: '![Algorithm of the MC method](img/00107.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![MC方法的算法](img/00107.jpeg)'
- en: The preceding equation will give us the value of the derivative ![Algorithm
    of the MC method](img/00108.jpeg). Note that in this case, we have assumed that
    there is no correlation between the interest rates and the price of stock. That
    is why we can neatly separate the two effects in the preceding equation. If the
    interest rates and the price of stock were correlated, then we will not be able
    to separate the discount factor and the expectation. This no-correlation assumption
    is standard for simple pricing models.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方程将给我们衍生品的价值![MC方法的算法](img/00108.jpeg)。请注意，在这种情况下，我们假设利率和股票价格之间没有相关性。这就是为什么我们可以在前述方程中清晰地分离这两种影响。如果利率和股票价格相关，那么我们将无法分离贴现因子和期望。这种无相关性的假设是简单定价模型的标准。
- en: Example of the MC method
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MC方法的示例
- en: 'Consider the example where we would like to price a six-month European Call
    option on Vodafone equity (VOD.L). The current equity price of Vodafone is £100.00,
    with a volatility of 20 percent and a strike of £100\. We assume that the stock
    pays no dividends. The current risk-free rate is 5 percent pa. How do we proceed
    to solve this problem using MC simulation? We proceed using the following three
    phases:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们想要定价沃达丰股票（VOD.L）的六个月欧式看涨期权。沃达丰的当前股价是£100.00，波动率为20%，行权价为£100。我们假设股票不支付股息。当前无风险利率为5%。我们如何使用蒙特卡洛模拟来解决这个问题？我们通过以下三个阶段进行：
- en: The first step is to generate trajectories.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成轨迹。
- en: 'We apply GBM to simulate the value of VOD.L stock from the spot price today
    *S_0 = £100.00*. For simplicity, we choose to discretize the life of the option
    from *t=[0,T]* into *N=5* time steps and to do *M=5* simulations using GBM in
    discrete terms, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用GBM来模拟从今天的现货价格*S_0 = £100.00*开始的VOD.L股票价值。为简单起见，我们选择将期权的生命周期从*t=[0,T]*离散化为*N=5*个时间步，并使用离散的GBM进行*M=5*次模拟，如下所示：
- en: '![Example of the MC method](img/00109.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00109.jpeg)'
- en: 'The five trajectories will thus be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 五条轨迹将如下所示：
- en: '![Example of the MC method](img/00110.jpeg)![Example of the MC method](img/00111.jpeg)![Example
    of the MC method](img/00112.jpeg)![Example of the MC method](img/00113.jpeg)![Example
    of the MC method](img/00114.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00110.jpeg)![蒙特卡洛方法的示例](img/00111.jpeg)![蒙特卡洛方法的示例](img/00112.jpeg)![蒙特卡洛方法的示例](img/00113.jpeg)![蒙特卡洛方法的示例](img/00114.jpeg)'
- en: 'The prices of the stock at maturity will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到期时的股票价格将如下所示：
- en: '![Example of the MC method](img/00115.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00115.jpeg)'
- en: The next step is to compute the expectation.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是计算期望。
- en: 'For each of the values of the underlyings, we now compute the payoffs as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个标的物的价值，我们现在计算如下的支付：
- en: '![Example of the MC method](img/00116.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00116.jpeg)'
- en: 'We now use the specific form of the payoff to describe a European Call option
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用特定形式的支付来描述欧式看涨期权如下：
- en: '![Example of the MC method](img/00117.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00117.jpeg)'
- en: 'We apply the following numbers to the preceding equation to get the following
    result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下数字应用于前述方程，得到以下结果：
- en: '![Example of the MC method](img/00118.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00118.jpeg)'
- en: 'The expected value of the preceding calculation is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前述计算的期望值如下：
- en: '![Example of the MC method](img/00119.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00119.jpeg)'
- en: Now discount the expectation to the present.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将期望贴现到现在。
- en: 'We now use the following continuous compounding to discount the expected payoff
    we just calculated in step 2 in order to determine the value of the premium:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用以下连续复利来贴现我们刚刚在步骤2中计算的期望支付，以确定保费的价值：
- en: '![Example of the MC method](img/00120.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00120.jpeg)'
- en: In this example, we have used only five scenarios for our MC price. In practice,
    hundreds or even thousands of scenarios are required in order to obtain an acceptable
    error. Clearly, the more scenarios you use, the more accurate the approximation.
    It is possible to derive some error-bound formulas for the MC method and show
    the speed of convergence. For more details, the reader is invited to refer to
    *Monte Carlo Methods in Financial Engineering*. Putting together all the trajectories
    for the five MC scenarios, we obtain the table shown in the following screenshot.
    Here, we see that all the trajectories start at *S0=100* and lead to some final
    value *S5*. For each trajectory, we compute the payoff *H*, which is then averaged
    to compute its expected value. The result is then discounted to obtain the present
    value of the derivative.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只使用了五种情景来计算我们的蒙特卡洛价格。实际上，为了得到可接受的误差，需要数百甚至数千种情景。显然，使用的情景越多，逼近的精度就越高。可以推导出一些蒙特卡洛方法的误差界限公式，并展示收敛速度。有关更多细节，请参考《金融工程中的蒙特卡洛方法》。将五个蒙特卡洛情景的所有轨迹放在一起，我们得到了下面截图中显示的表格。在这里，我们看到所有的轨迹都从*S0=100*开始，导致一些最终值*S5*。对于每条轨迹，我们计算*H*的支付，然后对其进行平均以计算其期望值。然后将结果打折以获得衍生品的现值。
- en: '![Example of the MC method](img/00121.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![蒙特卡洛方法的示例](img/00121.jpeg)'
- en: Example of the Monte Carlo simulation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟的示例
- en: The Binomial Trees method
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二项树方法
- en: '**Binomial Trees** (**BT**) can be traced to the work of (Cox, Ross, and Rubinstein
    1979). Like MC methods, they are based on the idea of how the discretization of
    stock prices can jump up or down. Unlike the MC methods, BT are not based on simulation
    of many possible paths, but on the construction of a single path of possible future
    prices that bifurcates at every node. These prices, as well as their associated
    probabilities, constitute the tree. Once this tree is built, the prices of the
    underlying at maturity can be determined, and the the payoff at maturity can be
    then computed and discounted to the present time in order to determine the premium
    of the derivative.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**二项树**（**BT**）可以追溯到（Cox，Ross和Rubinstein 1979）的工作。与MC方法一样，它们基于股票价格的离散化如何可以向上或向下跳跃的想法。与MC方法不同，BT不是基于模拟许多可能的路径，而是基于构建一个在每个节点分叉的可能未来价格的单一路径。这些价格以及它们的相关概率构成了树。一旦建立了这棵树，就可以确定到期时的标的物价格，并且可以计算到期时的支付，并将其贴现到现在的时间，以确定衍生品的保费。'
- en: Algorithm of the BT method
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BT方法的算法
- en: 'The BT method when applied to price derivatives is composed of three phases:
    the construction of the tree of prices (forward phase), the computation of the
    payoffs (maturity phase), and the discounting of the payoffs to the present time
    (backward phase). We will now explain the BT method in the simplified context
    of a two-step BT. This can be easily generalized to an *N* step tree.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于定价衍生品时，BT方法由三个阶段组成：价格树的构建（前向阶段）、支付的计算（到期阶段）和支付的贴现到现在的时间（后向阶段）。我们现在将在一个两步BT的简化环境中解释BT方法。这可以很容易地推广到*N*步树。
- en: 'To start with, we assume that the underlying can only go up or down in the
    next time step. So we specify the up factor *u* to describe how much the value
    today changes to a higher value and the down factor *d* to describe how much the
    value today changes to a lower value, such that the up value is *S(T)= u S(0)*,
    and the down value is *S(T)= d S(0)*. Furthermore, refer to "Option pricing: A
    simplified approach". The formula for the up and down values can be shown as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们假设标的物在下一个时间步只能上升或下降。因此，我们指定上升因子*u*来描述今天的价值如何变化为更高的价值，下降因子*d*来描述今天的价值如何变为更低的价值，使得上升值为*S(T)=
    u S(0)*，下降值为*S(T)= d S(0)*。此外，参考“期权定价：一种简化的方法”。上升和下降值的公式如下所示：
- en: '![Algorithm of the BT method](img/00122.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00122.jpeg)'
- en: 'The following is the formula for the probabilities of going up:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上升概率的公式：
- en: '![Algorithm of the BT method](img/00123.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00123.jpeg)'
- en: 'The probability of going down is ![Algorithm of the BT method](img/00124.jpeg).
    We can now proceed to construct our binomial tree in the following three phases:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下降的概率是![BT方法的算法](img/00124.jpeg)。现在我们可以继续在以下三个阶段构建我们的二叉树：
- en: The first phase is the forward phase.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一阶段是向前阶段。
- en: 'Here we construct the tree. Like in MC simulation, time is discretized in steps
    *dt* from *t=0* to *t=T*. From one step *tp*, the next price of the underlying
    can either go up or down by a factor *u* or *d* as shown in the following formulas:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们构建树。与MC模拟一样，时间从*t=0*到*t=T*以步长*dt*离散化。从一个步骤*tp*，标的物的下一个价格可以根据以下公式中的因子*u*或*d*上升或下降：
- en: '![Algorithm of the BT method](img/00125.jpeg)![Algorithm of the BT method](img/00126.jpeg)![Algorithm
    of the BT method](img/00127.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00125.jpeg)![BT方法的算法](img/00126.jpeg)![BT方法的算法](img/00127.jpeg)'
- en: 'Thus, the values of the tree at maturity are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到期时树的价值如下：
- en: '![Algorithm of the BT method](img/00128.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00128.jpeg)'
- en: 'In general case, we proceed in a similar manner until we arrive at the maturity
    *T*, and we have *N+1* values for the variable *S*. We will calculate these values
    with the help of the following equation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，我们以类似的方式进行，直到到达到期日*T*，变量*S*有*N+1*个值。我们将利用以下方程计算这些值：
- en: '![Algorithm of the BT method](img/00129.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00129.jpeg)'
- en: 'The preceding equation in our case can be summarized as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，前面的方程可以总结如下：
- en: '![Algorithm of the BT method](img/00130.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00130.jpeg)'
- en: 'This entire process is illustrated in the following diagram:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程如下图所示：
- en: '![Algorithm of the BT method](img/00131.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00131.jpeg)'
- en: The second phase is the payoff phase.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二阶段是支付阶段。
- en: 'In this phase, we use the values of the underlying at maturity and for each
    of them, we compute the value of the payoff, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们使用到期时的标的物价值，对于每个价值，我们计算支付的价值如下：
- en: '![Algorithm of the BT method](img/00132.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00132.jpeg)'
- en: 'In our case, the equation can be summarized as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，方程可以总结如下：
- en: '![Algorithm of the BT method](img/00133.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00133.jpeg)'
- en: 'The following in turn are the values of the option at maturity *T*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是到期时期权的价值*T*：
- en: '![Algorithm of the BT method](img/00134.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00134.jpeg)'
- en: 'In our case, the preceding equation can be summarized as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，前面的方程可以总结如下：
- en: '![Algorithm of the BT method](img/00135.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00135.jpeg)'
- en: The third phase is the backward phase.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三阶段是向后阶段。
- en: 'In this final phase, we take the values of the payoff at maturity and proceed
    in a backward manner. We move from the last node to the previous nodes, by computing
    the option value as the discounted expected payoff in the previous nodes using
    the weighted probabilities, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后阶段，我们取到期时的支付价值，并向后进行。我们通过计算期望的折现支付在前一节点中的加权概率来从最后一个节点移动到前一个节点，计算期权价值如下：
- en: '![Algorithm of the BT method](img/00136.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00136.jpeg)'
- en: 'In our case, in the second step, the equations are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，在第二步，方程如下：
- en: '![Algorithm of the BT method](img/00137.jpeg)![Algorithm of the BT method](img/00138.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00137.jpeg)![BT方法的算法](img/00138.jpeg)'
- en: 'And, in the first step, the equation is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，在第一步，方程如下：
- en: '![Algorithm of the BT method](img/00139.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的算法](img/00139.jpeg)'
- en: The premium of the derivative, the option price, is the value ![Algorithm of
    the BT method](img/00140.jpeg).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 衍生品的保费，期权价格，是值![BT方法的算法](img/00140.jpeg)。
- en: Example of the BT method
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BT方法的示例
- en: Consider the example where we would like to price a six-month European Call
    option on Rolls Royce equity (RR.L). The current equity price of the stock is
    £100.00, with a volatility of 30 percent p.a. and a strike of £90\. We assume
    the stock pays no dividends. The current risk-free rate is 5 percent pa. How do
    we proceed to solve this problem using BT?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们想要定价劳斯莱斯(RR.L)股票的六个月欧式看涨期权。股票的当前股价为£100.00，年波动率为30%，行权价为£90。我们假设股票不支付股息。当前无风险利率为5%。我们如何使用BT解决这个问题？
- en: 'To start with, we divide the life of the option in two steps, thus *dt=0.25*.
    The tables in the following screenshot illustrate the numerical values for each
    of the three steps applied to this problem:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将期权的生命周期分为两个步骤，因此*dt=0.25*。以下截图中的表格说明了应用于此问题的三个步骤的数值值：
- en: '![Example of the BT method](img/00141.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00141.jpeg)'
- en: Example of Binomial Trees pricing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树定价的示例。
- en: 'We first compute the up and down factors as well as the up probability *p*.
    In numerical terms, these are calculated using the following equations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算上升和下降因子以及上升概率*p*。在数值上，这些是使用以下方程计算的：
- en: '![Example of the BT method](img/00142.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00142.jpeg)'
- en: 'The following are the probabilities of going up and down respectively:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下分别是上升和下降的概率：
- en: '![Example of the BT method](img/00143.jpeg)![Example of the BT method](img/00144.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00143.jpeg)![BT方法的示例](img/00144.jpeg)'
- en: 'With all these parameters, we can now proceed to construct our tree in three
    phases, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些参数，我们现在可以按照以下三个阶段构建我们的树：
- en: The first phase is the forward phase.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一阶段是向前的阶段。
- en: We can now construct the two levels of the tree as follows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式构建树的两个层次。
- en: '![Example of the BT method](img/00145.jpeg)![Example of the BT method](img/00146.jpeg)![Example
    of the BT method](img/00147.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00145.jpeg)![BT方法的示例](img/00146.jpeg)![BT方法的示例](img/00147.jpeg)'
- en: 'Thus, the values of the tree at maturity are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到期时树的值如下：
- en: '![Example of the BT method](img/00148.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00148.jpeg)'
- en: The second phase is the payoff phase.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二阶段是支付阶段。
- en: 'In this phase, we use the values of the underlying at maturity, and for each
    of them, we compute the value of the payoff, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们使用到期时的标的物价值，对于每个标的物价值，我们计算支付的价值，如下：
- en: '![Example of the BT method](img/00132.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00132.jpeg)'
- en: 'In our case, the equation can be summarized as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，方程可以总结如下：
- en: '![Example of the BT method](img/00149.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00149.jpeg)'
- en: 'The following in turn are the values of the option at maturity *T*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来依次是到期时期权的价值*T*：
- en: '![Example of the BT method](img/00134.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00134.jpeg)'
- en: 'In our case, the preceding equation can be summarized as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，前面的方程可以总结如下：
- en: '![Example of the BT method](img/00150.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00150.jpeg)'
- en: The third phase is the backward phase.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三阶段是向后的阶段。
- en: 'In this final phase, we take the values of the payoff at maturity and proceed
    in a backward manner. We move from the last node to the previous nodes, by computing
    the option value as discounted expected payoff in the previous nodes using the
    weighted probabilities, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后阶段，我们取到期时的支付价值，并向后进行。我们通过计算在先前节点中以加权概率折现的预期支付来从最后一个节点移动到先前的节点，如下：
- en: '![Example of the BT method](img/00151.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00151.jpeg)'
- en: 'In our case, in the second step, the equations are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，在第二步，方程如下：
- en: '![Example of the BT method](img/00152.jpeg)![Example of the BT method](img/00153.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00152.jpeg)![BT方法的示例](img/00153.jpeg)'
- en: 'And in the first step, the equation is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 而在第一步中，方程如下：
- en: '![Example of the BT method](img/00154.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![BT方法的示例](img/00154.jpeg)'
- en: The Finite Difference method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限差分法
- en: The Finite Difference (FD) method is a numerical technique that focuses directly
    on the approximate solution of a differential equation. As shown by (Black and
    Scholes 1973) for equity financial derivatives (contingent claims), the problem
    is expressed in terms of a **Partial Differential Equation** (**PDE**).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分（FD）方法是一种数值技术，直接关注微分方程的近似解。正如（Black and Scholes 1973）所示，对于股票金融衍生品（有条件的索赔），问题是用**偏微分方程**（**PDE**）来表达的。
- en: 'The basic idea of FDM is to discretize a differential equation. The method
    transforms the derivatives in the differential equation into quantities or ratios
    that approximate the derivatives. These quantities are not any more infinitesimal
    but finite, that is, they have a finite length. This is the origin of the name
    of finite differences. For more details, the reader can refer to *The Mathematics
    of Financial Derivatives: A Student Introduction*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: FDM的基本思想是离散化微分方程。该方法将微分方程中的导数转化为近似导数的量或比率。这些量不再是无穷小的，而是有限的，即它们有一个有限的长度。这就是有限差分名称的由来。有关更多细节，读者可以参考《金融衍生品的数学：学生导论》。
- en: 'Consider the following illustration where a continuous function *f(X)* and
    the first derivative of the function is defined as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示，其中连续函数*f(X)*和函数的一阶导数定义如下：
- en: '![The Finite Difference method](img/00155.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00155.jpeg)'
- en: The preceding function is also known as the **slope,** which is the ratio between
    the growth (or decrease) in the function with respect to the step size *dx*. Using
    the preceding finite difference allows us to calculate the slope of the *f(x)*
    function in terms of algebraic quantities.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数也被称为**斜率**，它是函数相对于步长*dx*的增长（或减少）的比率。使用前面的有限差分允许我们计算*f(x)*函数的斜率，用代数量表示。
- en: 'In quantitative finance, we encounter various types of PDEs. The most important
    is the Black-Scholes PDE, which is expressed as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在量化金融中，我们遇到各种类型的PDE。最重要的是Black-Scholes PDE，它表示如下：
- en: '![The Finite Difference method](img/00156.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00156.jpeg)'
- en: 'We now consider solving this equation in a rectangular domain in the *S* and
    *t* axes. In the *S* axis, the domain is [a,b]. In the *t* axis the domain is
    [0,T]. This can be written mathematically as the domain ![The Finite Difference
    method](img/00157.jpeg). In the case of a European Call, it has a final condition
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在考虑在*S*和*t*轴上的矩形域中解决这个方程。在*S*轴上，域是[a,b]。在*t*轴上，域是[0,T]。这可以用数学表示为域![有限差分法](img/00157.jpeg)。对于欧式看涨期权，它有以下最终条件：
- en: '![The Finite Difference method](img/00158.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00158.jpeg)'
- en: 'And the following are the boundary conditions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是边界条件：
- en: '![The Finite Difference method](img/00159.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00159.jpeg)'
- en: 'Rather than solving the Black-Scholes PDE directly (that is, using variables
    *S* and *t*) we will be following (Wilmott et al. 1995), and we are going to propose
    a change of variables. This will transform the original PDE into an equivalent
    PDE, which is easier to solve and in fact is the classical equation of heat diffusion.
    The change of variables is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接解决Black-Scholes PDE（即使用变量*S*和*t*），而是按照（Wilmott et al. 1995）的方法，我们将提出一个变量的改变。这将把原始PDE转化为一个等价的更容易解决的PDE，实际上是热扩散的经典方程。变量的改变如下：
- en: '![The Finite Difference method](img/00160.jpeg)![The Finite Difference method](img/00161.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00160.jpeg)![有限差分法](img/00161.jpeg)'
- en: 'The preceding equations transform the Black-Scholes PDE into the classical
    equation of heat diffusion, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方程将Black-Scholes PDE转换为热扩散的经典方程，如下所示：
- en: '![The Finite Difference method](img/00162.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00162.jpeg)'
- en: 'And the European Call payoff is transformed into the following equation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 欧式看涨期权的回报被转换成以下方程：
- en: '![The Finite Difference method](img/00163.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分法](img/00163.jpeg)'
- en: 'where the parameter *k* is: ![The Finite Difference method](img/00164.jpeg).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其中参数*k*为：![有限差分法](img/00164.jpeg)。
- en: Algorithm of FDM
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FDM算法
- en: 'The application of FDM to the preceding PDE requires the first derivative with
    respect to time and the second derivative with respect to *x*, which leads to
    the following equations:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将FDM应用于前述PDE需要对时间的一阶导数和对*x*的二阶导数，得到以下方程：
- en: '![Algorithm of FDM](img/00165.jpeg)![Algorithm of FDM](img/00166.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![FDM算法](img/00165.jpeg)![FDM算法](img/00166.jpeg)'
- en: The preceding approximations can be derived from a Taylor series expansion.
    See (Wilmott et al. 1995) as we did in the preceding section.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的近似可以从泰勒级数展开中得出。参见（Wilmott等人，1995年），就像我们在前一节中所做的那样。
- en: In order to do this, we need to discretize the domain of the function to a discrete
    set of nodes. In the case of the BS equation, there will be *N* division's (or
    *N+1*) nodes in the spatial dimension and *M* division's (or *M+1*) nodes in the
    temporal dimension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要将函数的域离散化为一组离散节点。在BS方程的情况下，空间维度将有*N*个划分（或*N+1*）节点，时间维度将有*M*个划分（或*M+1*）节点。
- en: 'If we now put together our previous approximations, we will obtain the following
    formula:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将前述的近似放在一起，我们将得到以下公式：
- en: '![Algorithm of FDM](img/00167.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![FDM算法](img/00167.jpeg)'
- en: 'Solving for the term on the LHS of the preceding equation, we finally obtain
    the following discretized version of the PDE:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解出前述方程左侧的项，最终得到PDE的离散版本如下：
- en: '![Algorithm of FDM](img/00168.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![FDM算法](img/00168.jpeg)'
- en: Where in the preceding equation ![Algorithm of FDM](img/00169.jpeg).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中![FDM算法](img/00169.jpeg)。
- en: 'The discretized version of the PDE can be solved iteratively in time, using
    the **explicit** or **forward** finite difference method (FDM) as it''s the simplest
    possible implementation of finite difference techniques for pricing options. We
    are now ready to follow the next phases to apply the FDM, which are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: PDE的离散版本可以通过时间迭代求解，使用**显式**或**前向**有限差分法（FDM），因为这是期权定价的有限差分技术的最简单实现。我们现在准备按照以下步骤应用FDM，如下所示：
- en: First, discretize the domain.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将域离散化。
- en: Perform this step both in space and time dimensions with time steps ![Algorithm
    of FDM](img/00170.jpeg).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间和时间维度中执行此步骤，时间步长为![FDM算法](img/00170.jpeg)。
- en: Now approximate each of the derivatives with finite differences.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用有限差分逼近每个导数。
- en: Just as we have shown in the preceding section, we will apply the principle
    of transforming the continuous derivatives of the PDE into a finite approximation.
    This finite approximation will lead to algebraic equations. In literature, this
    set of equations is called a **stencil**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前一节中所示的那样，我们将应用将PDE的连续导数转换为有限近似的原则。这种有限近似将导致代数方程。在文献中，这组方程被称为**模板**。
- en: Next collocate the stencil to all the nodes of the domain.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来将模板放置到域的所有节点上。
- en: We now apply the stencil to all the nodes in the domain with the exception of
    the nodes that represent the initial and boundary conditions. For these nodes,
    we know the value is a priori, and, hence, it does not need to be computed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将模板应用于域中的所有节点，但不包括代表初始和边界条件的节点。对于这些节点，我们知道值是先验的，因此不需要计算。
- en: Iterate the solution in time with the stencil until we cover the full domain.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间上使用模板迭代解决，直到覆盖整个域。
- en: In explicit FDM, you simply advance and compute the values for the unknown function
    *u*. Note that in other forms of FDM (such as implicit FDM), we need to solve
    a system of equations via a matrix problem. Please refer to (Wilmott et al. 1995)
    for further details on implicit methods.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式FDM中，您只需推进并计算未知函数*u*的值。请注意，在其他形式的FDM（如隐式FDM）中，我们需要通过矩阵问题解决一组方程。有关隐式方法的更多细节，请参阅（Wilmott等人，1995年）。
- en: Example of the FD method
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FD方法示例
- en: Consider the example where we would like to price a six-month European Call
    option on Barclays equity (BARC.L). The current equity price of BARC is £75, with
    a volatility of 30 percent p.a. and a strike of £75\. We assume the stock pays
    no dividends. The current risk-free rate is 5 percent pa. How do we proceed to
    solve this problem using the FDM?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们想要定价巴克莱股票（BARC.L）的六个月欧式看涨期权。BARC的当前股价为75英镑，年波动率为30%，行权价为75英镑。我们假设股票不支付股息。当前无风险利率为5%。我们如何使用FDM解决这个问题？
- en: 'We know that equity financial derivatives satisfy the Black-Scholes PDE when
    the stock is modelled using GBM. So we solve the heat diffusion equation we described
    in the previous section. As we did earlier, we apply the following four phases
    to solve our FDM problem:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，当股票使用GBM进行建模时，股票金融衍生品满足Black-Scholes PDE。因此，我们解决了我们在前一节中描述的热扩散方程。就像我们之前做的那样，我们将应用以下四个阶段来解决我们的FDM问题：
- en: First discretize the domain.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将域离散化。
- en: We divide the domain into *N* space divisions *dS* and *M* time divisions *dt*,
    thus *N=5* and *M=4*. We first apply these values both in space and time dimensions
    with time steps ![Example of the FD method](img/00170.jpeg).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将域划分为*N*个空间划分*dS*和*M*个时间划分*dt*，因此*N=5*，*M=4*。我们首先在空间和时间维度中应用这些值，时间步长为![FD方法示例](img/00170.jpeg)。
- en: 'Thus, we obtain six points in time as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到六个时间点如下：
- en: '![Example of the FD method](img/00171.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![FD方法示例](img/00171.jpeg)'
- en: 'Five points in space is shown as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 空间上的五个点如下所示：
- en: '![Example of the FD method](img/00172.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分方法的示例](img/00172.jpeg)'
- en: Now approximate each of the derivatives with finite differences as follows.![Example
    of the FD method](img/00168.jpeg)In the preceding equation, ![Example of the FD
    method](img/00173.jpeg).
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用有限差分逼近每个衍生品如下。![有限差分方法的示例](img/00168.jpeg)在前面的方程中，![有限差分方法的示例](img/00173.jpeg)。
- en: Collocate the stencil to all the nodes of the domain.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图案对准域的所有节点。
- en: 'The following is the initial condition:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是初始条件：
- en: '![Example of the FD method](img/00163.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分方法的示例](img/00163.jpeg)'
- en: 'Alternatively, the following is the condition with numerical values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下是具有数值的条件：
- en: '![Example of the FD method](img/00174.jpeg)In the preceding equation, ![Example
    of the FD method](img/00175.jpeg).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![有限差分方法的示例](img/00174.jpeg)在前面的方程中，![有限差分方法的示例](img/00175.jpeg)。'
- en: 'The following is the final boundary condition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最终边界条件：
- en: '![Example of the FD method](img/00176.jpeg) and ![Example of the FD method](img/00177.jpeg).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![有限差分方法的示例](img/00176.jpeg)和![有限差分方法的示例](img/00177.jpeg)。'
- en: Iterate the solution in time with the stencil until we cover the full domain.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用图案在时间上迭代解决方案，直到覆盖整个域。
- en: 'The following are the internal nodes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内部节点：
- en: '![Example of the FD method](img/00168.jpeg)![Example of the FD method](img/00178.jpeg)![Example
    of the FD method](img/00179.jpeg)![Example of the FD method](img/00180.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分方法的示例](img/00168.jpeg)![有限差分方法的示例](img/00178.jpeg)![有限差分方法的示例](img/00179.jpeg)![有限差分方法的示例](img/00180.jpeg)'
- en: 'We can arrange the numerical results from our algorithm as shown in the table
    in the following screenshot, using the transformed variables (upper table) or
    the original variables (lower table), where we can find that for *S=75* and *t=0*,
    the option price is *£4,20*:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将算法的数值结果排列如下的表格中，使用变换后的变量（上表）或原始变量（下表），在这里我们可以发现，对于*S=75*和*t=0*，期权价格为*£4.20*。
- en: '![Example of the FD method](img/00181.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![有限差分方法的示例](img/00181.jpeg)'
- en: Example of Finite Difference pricing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分定价的示例。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the basics of the three key numerical methods used
    to price financial derivatives today. For each of them, we have provided an algorithm
    and a numerical example. Further, more advanced features of these methods can
    be found in excellent textbooks by (Glasserman 2003), (Kloeden and Platen 1992),
    and (Wilmott et al. 1995) as mentioned in all the previously discussed sections.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了今天用于定价金融衍生品的三种关键数值方法的基础知识。对于每一种方法，我们都提供了算法和数值示例。此外，这些方法的更高级特性可以在(Glasserman
    2003)、(Kloeden and Platen 1992)和(Wilmott et al. 1995)等优秀教科书中找到，正如在前面讨论的所有部分中提到的那样。
- en: Not all methods are applicable in all situations, just like the tools in a toolbox.
    Some methods are more effective to solve some specific problems. For example,
    with a binomial tree, it is simple to evaluate American options also, while for
    Monte Carlo, it is not so straightforward. Monte Carlo is more powerful in high-dimensional
    problems, while finite differences can be used effectively for low-dimensional
    problems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有方法都适用于所有情况，就像工具箱中的工具一样。有些方法更有效地解决一些特定的问题。例如，使用二项树，评估美式期权也很简单，而对于蒙特卡洛，就不那么直接了。蒙特卡洛在高维问题中更加强大，而有限差分可以有效地用于低维问题。
