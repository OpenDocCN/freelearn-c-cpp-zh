- en: Elements of WebAssembly - Wat, Wasm, and the JavaScript API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly的元素-Wat、Wasm和JavaScript API
- en: '[Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    described the history of WebAssembly and provided a high-level overview of the
    technology as well as the potential use cases and limitations. WebAssembly was
    described as being composed of multiple elements, not just the binary instruction
    format specified in the official definition.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)《什么是WebAssembly？》描述了WebAssembly的历史，并提供了技术的高层概述以及潜在的用例和限制。WebAssembly被描述为由多个元素组成，不仅仅是官方定义中指定的二进制指令格式。'
- en: In this chapter, we will dig into the elements that correspond to the official
    specifications created by the WebAssembly Working Group. We will examine the Wat
    and the binary format in greater detail to gain a better understanding of how
    they relate to modules. We will review the *JavaScript API* and *Web API* to ensure
    you're able to utilize the WebAssembly effectively in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究与WebAssembly工作组创建的官方规范相对应的元素。我们将更详细地检查Wat和二进制格式，以更好地理解它们与模块的关系。我们将审查*JavaScript
    API*和*Web API*，以确保您能够有效地在浏览器中使用WebAssembly。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下内容：
- en: How the text and binary formats are related
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本和二进制格式之间的关系
- en: What Wat is and where it fits in to the development process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wat是什么以及它在开发过程中的作用
- en: The binary format and module (Wasm) file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制格式和模块（Wasm）文件
- en: The components of the JavaScript and Web API and how they relate to the Wasm
    module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript和Web API的组件以及它们与Wasm模块的关系
- en: How to utilize WasmFiddle to evaluate the phases of WebAssembly (C/C++ > Wat
    > Wasm)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用WasmFiddle评估WebAssembly的阶段（C/C++ > Wat > Wasm）
- en: Common structure and abstract syntax
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共同结构和抽象语法
- en: 'In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about how the binary and text formats of WebAssembly both map to a common
    structure in the form of an abstract syntax. Before getting into the nuts and
    bolts of these formats, it''s worth mentioning how these are related within the
    *Core Specification*. The following diagram is a visual representation of the
    table of contents (with some sections excluded for clarity):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)中，《什么是WebAssembly？》，我们讨论了WebAssembly的二进制和文本格式如何映射到抽象语法的共同结构。在深入了解这些格式之前，值得一提的是它们在*核心规范*中的关系。以下图表是目录的可视化表示（为了清晰起见，排除了一些部分）：
- en: '![](img/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png)*Core Specification* table
    of contents'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/24a8a8a0-7afd-4ffe-892c-bb162b09b784.png)*核心规范*目录'
- en: As you can see, the **Text Format** and **Binary Format** sections contain subsections
    for **Values**, **Types**, **Instructions**, and **Modules** that correlate with
    the **Structure** section. Consequently, much of what we cover in the next section
    for the text format have direct corollaries with the binary format. With that
    in mind, let's dive into the text format.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，**文本格式**和**二进制格式**部分包含与**结构**部分相关的**值**、**类型**、**指令**和**模块**的子部分。因此，我们在下一节中涵盖的许多内容与二进制格式有直接的对应关系。考虑到这一点，让我们深入了解文本格式。
- en: Wat
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wat
- en: The *Text Format* section of the *Core Specification* provides technical descriptions
    for common language concepts such as values, types, and instructions. These are
    important concepts to know and understand if you're planning on building tooling
    for WebAssembly, but not necessary if you just plan on using it in your applications.
    That being said, the text format is an important part of WebAssembly, so there
    are concepts you should be aware of. In this section, we will dig into some of
    the details of the text format and highlight important points from the *Core Specification*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本格式*部分提供了对常见语言概念（如值、类型和指令）的技术描述。如果您打算为WebAssembly构建工具，这些都是重要的概念，但如果您只打算在应用程序中使用它，则不是必需的。话虽如此，文本格式是WebAssembly的重要部分，因此有一些概念您应该了解。在本节中，我们将深入了解文本格式的一些细节，并从*核心规范*中突出重点。'
- en: Definitions and S-expressions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和S表达式
- en: 'To understand Wat, let''s start with the first sentence of the description
    taken directly from the WebAssembly *Core Specification*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Wat，让我们从直接从WebAssembly *核心规范*中提取的描述的第一句开始：
- en: '"The textual format for WebAssembly modules is a rendering of their abstract
    syntax into S-expressions."'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '"WebAssembly模块的文本格式是它们的抽象语法渲染成S表达式。"'
- en: So what are **symbolic expressions** (**S-expressions**)? S-expressions are
    notations for nested list (tree-structured) data. Essentially, they provide a
    simple and elegant way to represent list-based data in textual form. To understand
    how textual representations of nested lists map to a tree structure, let's extrapolate
    the tree structure from an HTML page. The following example contains a simple
    HTML page and the corresponding tree structure diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是**符号表达式**（**S表达式**）？S表达式是嵌套列表（树形结构）数据的表示。基本上，它们提供了一种在文本形式中表示基于列表的数据的简单而优雅的方式。要理解文本表示的嵌套列表如何映射到树形结构，让我们从HTML页面中推断树形结构。以下示例包含一个简单的HTML页面和相应的树形结构图。
- en: 'A simple HTML page:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的HTML页面：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding tree structure is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的树形结构是：
- en: '![](img/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbdfac80-c6f7-45cb-beb9-5ebdc2ed8ffe.png)'
- en: A tree structure diagram for an HTML page
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面的树形结构图
- en: Even if you've never seen a tree structure before, it's still clear to see how
    the HTML maps to the tree in terms of structure and hierarchy. Mapping HTML elements
    is relatively simple because it's a markup language with well-defined tags and
    no actual logic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你以前从未见过树形结构，也很容易看出HTML如何在结构和层次结构方面映射到树形结构。映射HTML元素相对简单，因为它是一种具有明确定义标签且没有实际逻辑的标记语言。
- en: 'Wat represents modules that can have multiple functions with varying parameters.
    To demonstrate the relationship between source code, Wat, and the corresponding
    tree structure, let''s start with a simple C function that adds 2 to the number
    that is passed in as a parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Wat表示可以具有多个具有不同参数的函数的模块。为了演示源代码、Wat和相应的树结构之间的关系，让我们从一个简单的C函数开始，该函数将2添加到作为参数传入的数字中：
- en: 'Here is a C function that adds `2` to the `num` argument passed in and returns
    the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将`2`添加到传入的`num`参数并返回结果的C函数：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Converting the `addTwo` function to valid Wat produces this result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将`addTwo`函数转换为有效的Wat会产生以下结果：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [Chapter 1](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml), *What is WebAssembly?*,
    we talked about language concepts associated with the *Core Specification* (*Functions*,
    *Linear Memory*, *Tables*, and so on). Within that specification, the *Structure*
    section defines each of these concepts in the context of an abstract syntax. The
    *Text Format* section of the specification corresponds with these concepts as
    well, and you can see them defined by their keywords in the preceding snippet
    (`func`, `memory`, `table`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](15ca4834-5544-4dd8-b307-f0bc95c63a21.xhtml)中，*什么是WebAssembly？*，我们谈到了与*核心规范*相关的语言概念（*函数*、*线性内存*、*表*等）。在该规范中，*结构*部分在抽象语法的上下文中定义了每个这些概念。规范的*文本格式*部分也与这些概念对应，您可以在前面的片段中通过它们的关键字来定义它们（`func`、`memory`、`table`）。
- en: 'Tree Structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 树结构：
- en: '![](img/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28fa4fdc-1b9e-4672-b752-8bb1a272e9e0.png)'
- en: A tree structure diagram for Wat
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Wat的树结构图
- en: The entire tree would be too large to fit on a page, so this diagram is limited
    to the first five lines of the Wat source text. Each filled-in dot represents
    a list node (or the contents of a set of parentheses). As you can see, code written
    in s-expressions can be clearly and concisely expressed in a tree structure, which
    is why s-expressions were chosen for WebAssembly's text format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 整个树太大，无法放在一页上，因此此图表仅限于Wat源文本的前五行。每个填充的点代表一个列表节点（或一组括号的内容）。正如您所看到的，用s表达式编写的代码可以以树结构清晰简洁地表达，这就是为什么s表达式被选择为WebAssembly的文本格式的原因。
- en: Values, types, and instructions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值、类型和指令
- en: 'Although detailed coverage of the *Text Format* section of the *Core Specification*
    is out of the scope of this text, it''s worth demonstrating how some of the language
    concepts map to the corresponding Wat. The following diagram demonstrates these
    mappings in a sample Wat snippet. The C code that this was compiled from represents
    a function that takes a word as a parameter and returns the square root of the
    character count:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管详细覆盖*核心规范*的*文本格式*部分超出了本文的范围，但值得演示一些语言概念如何映射到相应的Wat。以下图表演示了这些映射在一个样本Wat片段中。这是从C代码编译而来的，表示一个以单词作为参数并返回字符数的平方根的函数：
- en: '![](img/7c3b4124-7f45-49c6-a933-de3bf3861864.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c3b4124-7f45-49c6-a933-de3bf3861864.png)'
- en: Wat example with language concept details
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 具有语言概念细节的Wat示例
- en: If you intend on writing or editing Wat, note that it supports block and line
    comments. The instructions are split up into blocks and consist of setting and
    getting memory associated with variables with valid types. You are able to control
    the flow of logic using `if` statements and loops are supported using the `loop`
    keyword.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算编写或编辑Wat，请注意它支持块和行注释。指令被分成块，并包括设置和获取与有效类型相关联的变量的内存。您可以使用`if`语句控制逻辑流，并且使用`loop`关键字支持循环。
- en: Role in the development process
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发过程中的作用
- en: 'The text format allows for the representation of a binary Wasm module in textual
    form. This has some profound implications with regard to the ease of development
    and debugging. Having a textual representation of a WebAssembly module allows
    developers to view the source of a loaded module in a browser, which eliminates
    the black-box issues that inhibited the adoption of NaCl. It also allows for tooling
    to be built around troubleshooting modules. The official website describes the
    use cases that drove the design of the text format:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式允许以文本形式表示二进制Wasm模块。这对于开发和调试的便利性有一些深远的影响。拥有WebAssembly模块的文本表示允许开发人员在浏览器中查看加载模块的源代码，从而消除了抑制NaCl采用的黑匣子问题。它还允许围绕故障排除模块构建工具。官方网站描述了驱动文本格式设计的用例：
- en: • View Source on a WebAssembly module, thus fitting into the Web (where every
    source can be viewed) in a natural way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: • 在WebAssembly模块上查看源代码，从而自然地适应Web（其中可以查看每个源代码）。
- en: • Presentation in browser development tools when source maps aren't present
    (which is necessarily the case with the Minimum Viable Product (MVP)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: • 在没有源映射的情况下，在浏览器开发工具中呈现（这在最小可行产品（MVP）的情况下是必然的）。
- en: • Writing WebAssembly code directly for reasons including pedagogical, experimental,
    debugging, optimization, and testing of the spec itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • 直接编写WebAssembly代码的原因包括教学、实验、调试、优化和测试规范本身。
- en: The last item in the list reflects that the text format isn't intended to be
    written by hand in the course of normal development, but rather generated from
    a tool like Emscripten. You probably won't see or manipulate any `.wat` files
    when you're generating modules, but you may be viewing them in a debugging context.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一项反映了文本格式并不打算在正常开发过程中手动编写，而是从诸如Emscripten之类的工具生成。在生成模块时，您可能不会看到或操作任何`.wat`文件，但在调试上下文中可能会查看它们。
- en: Not only is the text format valuable with regards to debugging, but having this
    intermediate format reduces the amount of reliance on a single tool for compilation.
    Several different tools currently exist to consume and emit this s-expression
    syntax, some of which are used by Emscripten to compile your code down to a `.wasm`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文本格式不仅在调试方面有价值，而且具有这种中间格式可以减少对单个编译工具的依赖。目前存在多种不同的工具来消耗和发出这种s表达式语法，其中一些工具被Emscripten用于将您的代码编译成`.wasm`文件。
- en: Binary format and the module file (Wasm)
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制格式和模块文件（Wasm）
- en: The *Binary Format* section of the *Core Specification* provides the same level
    of detail with regard to language concepts as the *Text format* section. In this
    section, we will briefly cover some high-level details about the binary format
    and discuss the various sections that make up a Wasm module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制格式*部分的*核心规范*提供了与*文本格式*部分相同级别的语言概念细节。在本节中，我们将简要介绍二进制格式的一些高级细节，并讨论构成Wasm模块的各个部分。'
- en: Definition and module overview
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和模块概述
- en: The binary format is defined as a dense linear encoding of the abstract syntax.
    Without getting too technical, that essentially means it's an efficient form of
    binary that allows for fast decoding, small file size, and reduced memory usage.
    The file representation of the binary format is a `.wasm` file, which will be
    the compilation output from Emscripten that we'll use for our examples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制格式被定义为抽象语法的密集线性编码。不要过于技术化，这基本上意味着它是一种高效的二进制形式，可以快速解码，文件大小小，内存使用减少。二进制格式的文件表示是`.wasm`文件，这将是Emscripten的编译输出，我们将用于示例。
- en: The *Values*, *Types*, and *Instructions* subsections of the *Core Specification*
    for the binary format correlate directly to the *Text Format* section. Each of
    these concepts is covered in the context of encoding. For example, according to
    the specification, the Integer types are encoded using the LEB128 variable-length
    integer encoding, in either unsigned or signed variant. These are important details
    to know if you wish to develop tooling for WebAssembly, but not necessary if you
    just plan on using it on your website.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*、*类型*和*指令*子部分在二进制格式的*核心规范*中与*文本格式*部分直接相关。每个概念都在编码的上下文中进行了介绍。例如，根据规范，整数类型使用LEB128可变长度整数编码进行编码，可以是无符号或有符号变体。如果您希望为WebAssembly开发工具，这些都是重要的细节，但如果您只打算在网站上使用它，则不是必需的。'
- en: 'The *Structure*, *Binary Format*, and *Text Format* *(wat)* sections of the
    *Core Specification* have a *Module* subsection. We didn''t cover aspects of the
    module in the previous section because it''s more prudent to describe them in
    the context of a binary. The official WebAssembly site offers the following description
    for a module:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构*、*二进制格式*和*文本格式*（wat）部分的*核心规范*都有一个*模块*子部分。我们在上一节中没有涵盖模块的方面，因为在二进制的上下文中描述它们更为谨慎。官方的WebAssembly网站为模块提供了以下描述：'
- en: '"The distributable, loadable, and executable unit of code in WebAssembly is
    called a **module**. At runtime, a module can be **instantiated** with a set of
    import values to produce an **instance**, which is an immutable tuple referencing
    all the state accessible to the running module."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"WebAssembly中的可分发、可加载和可执行的代码单元称为**模块**。在运行时，可以使用一组导入值对模块进行**实例化**，以产生一个**实例**，它是一个不可变的元组，引用了运行模块可访问的所有状态。"'
- en: We will discuss how to interact with the module using the JavaScript and Web
    APIs later in this chapter, so let's establish some context to understand how
    the module elements map to the API methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论如何使用JavaScript和Web API与模块进行交互，因此让我们建立一些上下文，以了解模块元素如何映射到API方法。
- en: Module sections
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块部分
- en: 'A module is made up of several sections, some of which you''ll be interacting
    with through the JavaScript API:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块由几个部分组成，其中一些您将通过JavaScript API进行交互：
- en: 'Imports (`import`) are elements that can be accessed within the module and
    can be one of the following:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入（`import`）是可以在模块内访问的元素，可以是以下之一：
- en: Function, which can be called inside the module using the `call` operator
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数，可以在模块内使用`call`运算符调用
- en: Global, which can be accessed inside the module via the `global` operators
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量，可以通过`global`运算符在模块内访问
- en: Linear Memory, which can be accessed inside the module via the `memory` operators
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性内存，可以通过`memory`运算符在模块内访问
- en: Table, which can be accessed inside the module using `call_indirect`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表，可以通过`call_indirect`在模块内访问
- en: Exports (`export`) are elements that can be accessed by the consuming API (that
    is, called by a JavaScript function)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出（`export`）是可以由消费API（即由JavaScript函数调用）访问的元素
- en: Module start function (`start`) is called after the module instance is initialized
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块启动函数（`start`）在模块实例初始化后调用
- en: Global (`global`) contains the internal definition of global variables
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局（`global`）包含全局变量的内部定义
- en: Linear memory (`memory`) contains the internal definition of linear memory with
    an initial memory size and optional maximum size
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性内存（`memory`）包含具有初始内存大小和可选最大大小的线性内存的内部定义
- en: Data (`data`) contains an array of data segments which specify the initial contents
    of fixed ranges of a given memory
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据（`data`）包含数据段数组，指定给定内存的固定范围的初始内容
- en: 'Table (`table`) is a linear memory whose elements are opaque values of a particular
    table element type:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表（`table`）是一个线性内存，其元素是特定表元素类型的不透明值：
- en: In the MVP, its primary purpose is to implement indirect function calls in C/C++
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MVP中，其主要目的是在C/C++中实现间接函数调用
- en: Elements (`elements`) is a section that allows a module to initialize the elements
    of any import or internally defined table with any other definition in the module
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素（`elements`）是一个允许模块使用任何其他模块中的任何导入或内部定义表的元素进行初始化的部分
- en: 'Function and code:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和代码：
- en: The function section declares the signatures of each internal function defined
    in the module
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数部分声明了模块中定义的每个内部函数的签名
- en: The code section contains the function body of each function declared by the
    function section
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码部分包含由函数部分声明的每个函数的函数体
- en: Some of the keywords (`import`, `export`, and so on) should look familiar; they're
    present in the contents of the Wat file in the previous section. WebAssembly's
    components follow a logical mapping that directly correspond to the APIs  (for
    example, you pass a `memory` and `table` instance into JavaScript's `WebAssembly.instantiate()`
    function). Your primary interaction with a module in binary format will be through
    these APIs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关键字（`import`，`export`等）可能看起来很熟悉；它们出现在前一节的Wat文件的内容中。WebAssembly的组件遵循一个直接对应API的逻辑映射（例如，您将`memory`和`table`实例传递给JavaScript的`WebAssembly.instantiate()`函数）。您与二进制格式的模块的主要交互将通过这些API进行。
- en: The JavaScript and Web APIs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和Web API
- en: 'In addition to the *WebAssembly Core Specification*, there are two API specifications
    for interacting with WebAssembly modules: the *WebAssembly JavaScript Interface* (JavaScript
    API) and the *WebAssembly Web API*. In the previous sections, we covered pertinent
    aspects of the *Core Specification* to become familiar with the underlying technology.
    If you never read the *Core Specification* (or if you skipped the first few sections
    of this chapter), it wouldn''t inhibit the use of WebAssembly in your application.
    That is not the case for the APIs, as they describe the methods and interface
    required to instantiate and interact with your compiled Wasm module. In this section,
    we will review the Web and JavaScript APIs and describe how to load and communicate
    with a Wasm module using JavaScript.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*WebAssembly核心规范*之外，还有两个用于与WebAssembly模块交互的API规范：*WebAssembly JavaScript接口*（JavaScript
    API）和*WebAssembly Web API*。在前面的章节中，我们涵盖了*核心规范*的相关方面，以便熟悉基础技术。如果您从未阅读过*核心规范*（或者跳过了本章的前几节），这并不会阻碍您在应用程序中使用WebAssembly。但对于API来说情况并非如此，因为它们描述了实例化和与编译后的Wasm模块交互所需的方法和接口。在本节中，我们将回顾Web和JavaScript
    API，并描述如何使用JavaScript加载和与Wasm模块进行通信。
- en: WebAssembly store and object caches
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly存储和对象缓存
- en: 'Before digging into interactions, let''s discuss the relationship between JavaScript
    and WebAssembly in the context of execution. The *Core Specification* contains
    the following description in the *Execution* section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论交互之前，让我们讨论JavaScript和WebAssembly在执行上下文中的关系。*核心规范*在*执行*部分包含了以下描述：
- en: '"WebAssembly code is executed when instantiating a module or invoking an exported
    function on the resulting module instance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"在实例化模块或调用结果模块实例上的导出函数时，将执行WebAssembly代码。'
- en: Execution behavior is defined in terms of an abstract machine that models the
    program state. It includes a stack, which records operand values and control constructs,
    and an abstract store containing global state."
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行行为是根据模拟程序状态的抽象机器来定义的。它包括一个堆栈，记录操作数值和控制结构，以及包含全局状态的抽象存储。"
- en: 'Under the hood, JavaScript uses something called **agents** to manage execution.
    The *store* being referred to in the definition is contained within an agent.
    The following diagram represents a JavaScript agent:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，JavaScript使用称为**代理**的东西来管理执行。定义中提到的*存储*包含在代理中。以下图表代表了一个JavaScript代理：
- en: '![](img/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d01b7a99-69fe-4b97-b7f2-b4fed202aff1.png)'
- en: JavaScript agent elements
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代理元素
- en: The store represents the state of the abstract machine. WebAssembly operations
    take a store and return an updated store. Each agent is associated with caches
    that map JavaScript objects to WebAssembly addresses. So why is this important?
    It represents the underlying method of interaction between WebAssembly modules
    and JavaScript. The JavaScript objects correspond to the WebAssembly namespace
    within the *JavaScript API*. With that in mind, let's dig into the interface.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 存储表示抽象机器的状态。WebAssembly操作接受存储并返回更新后的存储。每个代理都与将JavaScript对象映射到WebAssembly地址的缓存相关联。那么这为什么重要呢？它代表了WebAssembly模块与JavaScript之间交互的基本方法。JavaScript对象对应于*JavaScript
    API*中的WebAssembly命名空间。考虑到这一点，让我们深入了解接口。
- en: Loading a module and the WebAssembly namespace methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载模块和WebAssembly命名空间方法
- en: 'The *JavaScript API* covers the various objects available on the global `WebAssembly`
    object in the browser. Before we discuss those, we''ll start with the methods
    available on the `WebAssembly` object, with a brief overview of their intended
    purposes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript API*涵盖了浏览器中全局`WebAssembly`对象上可用的各种对象。在讨论这些对象之前，我们将从`WebAssembly`对象上可用的方法开始，简要概述它们的预期目的：'
- en: '`instantiate()` is the primary API for compiling and instantiating WebAssembly
    code'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instantiate()`是用于编译和实例化WebAssembly代码的主要API'
- en: '`instantiateStreaming()` performs the same functionality as `instantiate()`,
    but it uses streaming to compile and instantiate the module, which eliminates
    an intermediate step'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instantiateStreaming()`执行与`instantiate()`相同的功能，但它使用流式处理来编译和实例化模块，从而消除了一个中间步骤'
- en: '`compile()` only compiles a WebAssembly module, but doesn''t instantiate it'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile()`只编译WebAssembly模块，但不实例化它'
- en: '`compileStreaming()` also only compiles a WebAssembly module, but it uses streaming
    similar to `instantiateStreaming()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compileStreaming()`也只编译WebAssembly模块，但它使用类似于`instantiateStreaming()`的流式处理'
- en: '`validate()` checks the WebAssembly binary code to ensure the bytes are valid
    and returns true if valid or false if not valid'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate()`检查WebAssembly二进制代码以确保字节有效，并在有效时返回true，无效时返回false'
- en: The `instantiateStreaming()` and `compileStreaming()` methods are currently
    only present in the *Web API*. In fact, these two methods comprise the entire
    specification. The methods available on the `WebAssembly` object are focused primarily
    on compiling and instantiating modules. With that in mind, let's discuss how to
    fetch and instantiate a Wasm module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`instantiateStreaming()`和`compileStreaming()`方法目前仅存在于*Web API*中。事实上，这两种方法构成了整个规范。`WebAssembly`对象上可用的方法主要用于编译和实例化模块。考虑到这一点，让我们讨论如何获取和实例化一个Wasm模块。'
- en: When you perform a fetch call to get a module, it returns a Promise that resolves
    with the raw bytes of that module, which need to be loaded into an `ArrayBuffer`
    and instantiated. Going forward, we will refer to this process as loading a module.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行一个fetch调用来获取一个模块时，它会返回一个Promise，该Promise解析为该模块的原始字节，这些字节需要加载到一个`ArrayBuffer`中并进行实例化。从现在开始，我们将把这个过程称为加载模块。
- en: 'The following diagram demonstrates this process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了这个过程：
- en: '![](img/368f1c3b-c24a-4265-967f-6347f5fa8b34.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/368f1c3b-c24a-4265-967f-6347f5fa8b34.png)'
- en: Fetching and loading a WebAssembly module
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和加载WebAssembly模块
- en: 'This process is actually quite simple using Promises. The following code demonstrates
    how a module is loaded. The `importObj` argument passes any data or functions
    to the Wasm module. You can disregard it for now, as we''ll be discussing it in
    greater detail in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating
    and Loading a WebAssembly Module*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Promises实际上非常简单。以下代码演示了如何加载一个模块。`importObj`参数传递任何数据或函数给Wasm模块。您现在可以忽略它，因为我们将在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中更详细地讨论它，*创建和加载WebAssembly模块*：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example dictates the method for loading the module using the
    `instantiate()` method. The `instantiateStreaming()` method is a little different
    and simplifies the process even more by fetching, compiling, and instantiating
    a module in a single step. The following code achieves the same goal (loading
    a module) using this method:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例规定了使用`instantiate()`方法加载模块的方法。`instantiateStreaming()`方法有些不同，并通过一步完成获取、编译和实例化模块来简化这个过程。以下代码使用这种方法实现了相同的目标（加载模块）：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The instantiation methods return a Promise that resolves with an object containing
    a compiled `WebAssembly.Module` (`module`) and `WebAssembly.Instance` (`instance`),
    both of which will be covered later in this section. In most cases, you will use
    one of these methods to load a Wasm module on your site. The instance contains
    all of the exported WebAssembly functions that you can call from your JavaScript
    code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化方法返回一个Promise，该Promise解析为一个包含编译的`WebAssembly.Module`（`module`）和`WebAssembly.Instance`（`instance`）的对象，这两者将在本节后面进行详细介绍。在大多数情况下，您将使用其中一种方法在您的站点上加载Wasm模块。实例包含了所有可以从JavaScript代码调用的导出的WebAssembly函数。
- en: The `compile()` and `compileStreaming()` methods return a Promise that only
    resolves with a compiled `WebAssembly.Module`. This is useful if you want to compile
    a module and instantiate it at a later time. **Mozilla Developer Network** (**MDN**),
    the web docs site managed by Mozilla, provides an example in which the compiled
    module is passed to a Web Worker.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile()`和`compileStreaming()`方法返回一个Promise，该Promise只解析为一个编译的`WebAssembly.Module`。如果您想要在以后编译一个模块并实例化它，这将非常有用。**Mozilla开发者网络**（**MDN**），由Mozilla管理的Web文档站点，提供了一个示例，其中编译的模块被传递给了一个Web
    Worker。'
- en: As far as the `validate()` method is concerned, its only purpose is to test
    whether the typed array or `ArrayBuffer` passed in as a parameter is valid. This
    would be called after the raw bytes of the response are loaded into an `ArrayBuffer`.
    This method wasn't included in the code examples because attempting to instantiate
    or compile an invalid Wasm module will throw either a `TypeError` or one of the
    `Error` objects present on the `WebAssembly` object. We will cover these `Error`
    objects later in this section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就`validate()`方法而言，它的唯一目的是测试作为参数传入的类型数组或`ArrayBuffer`是否有效。这将在响应的原始字节加载到`ArrayBuffer`后调用。这个方法没有包含在代码示例中，因为尝试实例化或编译无效的Wasm模块将抛出`TypeError`或`WebAssembly`对象上存在的`Error`对象之一。我们将在本节后面介绍这些`Error`对象。
- en: WebAssembly objects
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly对象
- en: 'In addition to the methods covered in the *Loading a module and the WebAssembly
    namespace methods* section, the global `WebAssembly` object has child objects
    that are used to interact with and troubleshoot WebAssembly. These objects correlate
    directly to the concepts we discussed in the sections on the WebAssembly binary
    and text formats. The following list contains these objects as well as their definitions
    taken from MDN:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在*加载模块和WebAssembly命名空间方法*部分介绍的方法之外，全局`WebAssembly`对象还有子对象，用于与和排查WebAssembly交互。这些对象直接对应我们在WebAssembly二进制和文本格式部分讨论的概念。以下列表包含了这些对象以及它们的定义，这些定义来自MDN：
- en: The `WebAssembly.Module` object contains stateless WebAssembly code that has
    already been compiled by the browser and can be efficiently shared with workers,
    cached in `IndexedDB`, and instantiated multiple times
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Module`对象包含了已经被浏览器编译的无状态WebAssembly代码，可以有效地与worker共享，缓存在`IndexedDB`中，并且可以被多次实例化'
- en: The `WebAssembly.Instance` object is a stateful, executable instance of a `WebAssembly.Module`
    which contains all of the exported WebAssembly functions that allow calling into
    WebAssembly code from JavaScript
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance`对象是`WebAssembly.Module`的一个有状态的可执行实例，其中包含了所有导出的WebAssembly函数，允许从JavaScript调用WebAssembly代码'
- en: '`WebAssembly.Memory`, when called with the constructor, creates a new `Memory`
    object which is a resizable `ArrayBuffer` that holds the raw bytes of memory accessed
    by a WebAssembly `Instance`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Memory`，在使用构造函数调用时，创建一个新的`Memory`对象，它是一个可调整大小的`ArrayBuffer`，保存着被WebAssembly
    `Instance`访问的内存的原始字节'
- en: '`WebAssembly.Table`, when called with the constructor, creates a new `Table`
    object of the given size and element type that represents a WebAssembly `Table`
    (which stores function references)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.Table`，在使用构造函数调用时，创建一个给定大小和元素类型的新`Table`对象，表示一个WebAssembly `Table`（存储函数引用）'
- en: '`WebAssembly.CompileError`, when called with the constructor, creates an error
    which indicates that an issue occurred during WebAssembly decoding, or validation'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.CompileError`在使用构造函数调用时，创建一个错误，指示在WebAssembly解码或验证过程中发生了问题'
- en: '`WebAssembly.LinkError`, when called with the constructor, creates an error
    which indicates that an issue occurred during module instantiation'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.LinkError`在使用构造函数调用时，创建一个错误，指示在模块实例化过程中发生了问题'
- en: '`WebAssembly.RuntimeError`, when called with the constructor, creates an error
    which indicates that WebAssembly specified a trap (for example, stack overflow
    occurred)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebAssembly.RuntimeError`在调用构造函数时创建一个错误，指示WebAssembly指定了一个陷阱（例如，发生了堆栈溢出）。'
- en: Let's dig into each one individually, starting with the `WebAssembly.Module`
    object.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分别深入研究每一个，从`WebAssembly.Module`对象开始。
- en: WebAssembly.Module
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Module
- en: The `WebAssembly.Module` object is the intermediate step between the `ArrayBuffer`
    and the instantiated module. The `compile()` and `instantiate()` methods (and
    their streaming counterparts) return a Promise that resolves with a module (module
    in lowercase represents the compiled `Module`). A module can also be created synchronously
    by passing a typed array or `ArrayBuffer` directly into the constructor, but this
    is discouraged for large modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Module`对象是`ArrayBuffer`和实例化模块之间的中间步骤。`compile()`和`instantiate()`方法（以及它们的流式处理对应方法）返回一个解析为模块的Promise（小写的module表示已编译的`Module`）。一个模块也可以通过直接将类型化数组或`ArrayBuffer`传递给构造函数来同步创建，但对于大型模块，这是不鼓励的。'
- en: 'The `Module` object also has three static methods: `exports()`, `imports()`,
    and `customSections()`. All three take a module as a parameter, but `customSections()`
    takes a string representing the section name as its second parameter. Custom sections
    are described in the *Binary Format* section of the *Core Specification* and are
    intended to be used for debugging information or third-party extensions. In most
    cases, you won''t need to define these. The `exports()` function is useful if
    you''re using a Wasm module that you didn''t create, although you''ll only be
    able to see the name and kind (for example, `function`) of each export.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module`对象还有三个静态方法：`exports()`、`imports()`和`customSections()`。所有三个方法都以模块作为参数，但`customSections()`以表示部分名称的字符串作为其第二个参数。自定义部分在*Core
    Specification*的*Binary Format*部分中描述，并且旨在用于调试信息或第三方扩展。在大多数情况下，你不需要定义这些。`exports()`函数在你使用一个你没有创建的Wasm模块时很有用，尽管你只能看到每个导出的名称和种类（例如，`function`）。'
- en: For simple use cases, you won't be dealing directly with the `Module` object
    or compiled module. Most of the interaction will take place with an `Instance`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的用例，你不会直接处理`Module`对象或已编译的模块。大部分交互将在`Instance`中进行。
- en: WebAssembly.Instance
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Instance
- en: The `WebAssembly.Instance` object is the instantiated WebAssembly module, which
    means you can call exported WebAssembly functions from it. Calling `instantiate()`
    or `instantiateStreaming()` returns a Promise that resolves with an object containing
    an instance. You call WebAssembly functions by referencing the name of the function
    on the instance's `export` property. For example, if a module contained an exported
    function named `sayHello()`, you'd call the function using `instance.exports.sayHello()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Instance`对象是实例化的WebAssembly模块，这意味着你可以从中调用导出的WebAssembly函数。调用`instantiate()`或`instantiateStreaming()`会返回一个解析为包含实例的对象的Promise。你可以通过引用实例的`export`属性上函数的名称来调用WebAssembly函数。例如，如果一个模块包含一个名为`sayHello()`的导出函数，你可以使用`instance.exports.sayHello()`来调用该函数。'
- en: WebAssembly.Memory
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Memory
- en: The `WebAssembly.Memory` object holds the memory accessed by a WebAssembly `Instance`.
    This memory can be accessed and changed from both JavaScript and WebAssembly.
    To create a new instance of `Memory`, you need to pass an object with an `initial`
    and (optional) `maximum` value to the `WebAssembly.Memory()` constructor. These
    values are in units of WebAssembly pages, where one page is 64 KB. You increase
    the size of the memory instance by calling the `grow()` function with a single
    parameter that represents the number of WebAssembly pages to grow by. You can
    also access the current buffer contained in the memory instance through its `buffer`
    property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Memory`对象保存了WebAssembly `Instance`访问的内存。这个内存可以从JavaScript和WebAssembly中访问和改变。要创建一个新的`Memory`实例，你需要通过`WebAssembly.Memory()`构造函数传递一个带有`initial`和（可选的）`maximum`值的对象。这些值以WebAssembly页面为单位，其中一个页面是64KB。通过调用带有表示要增长的WebAssembly页面数量的单个参数的`grow()`函数来增加内存实例的大小。你也可以通过其`buffer`属性访问内存实例中包含的当前缓冲区。'
- en: MDN describes two ways to get to a `WebAssembly.Memory` object. The first way
    is to construct it from JavaScript (`var memory = new WebAssembly.Memory(...)`),
    while the second way is to have it exported by a WebAssembly module. The important
    takeaway is that memory can be passed easily between JavaScript and WebAssembly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MDN描述了获取`WebAssembly.Memory`对象的两种方法。第一种方法是从JavaScript中构造它（`var memory = new
    WebAssembly.Memory(...)`），而第二种方法是由WebAssembly模块导出它。重要的一点是内存可以在JavaScript和WebAssembly之间轻松传递。
- en: WebAssembly.Table
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly.Table
- en: The `WebAssembly.Table` object is an array-like structure that is used to store
    function references. Just as with `WebAssembly.Memory`, a `Table` can be accessed
    and changed from both JavaScript and WebAssembly. As of the time of writing, tables
    can only store function references, but it's likely that, as the technology evolves,
    additional entities will be able to be stored in tables as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebAssembly.Table`对象是一个类似数组的结构，用于存储函数引用。与`WebAssembly.Memory`一样，`Table`可以从JavaScript和WebAssembly中访问和改变。在撰写时，表只能存储函数引用，但随着技术的发展，很可能还可以存储其他实体。'
- en: To create a new `Table` instance, you need to pass an object with an `element`,
    `initial`, and (optional) `maximum` value. The `element` member is a string that
    represents the type of value stored in the table; currently the only valid value
    is `"anyfunc"` (for functions). The `initial` and `maximum` values represent the
    number of elements in the WebAssembly `Table`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`Table`实例，你需要传递一个带有`element`、`initial`和（可选的）`maximum`值的对象。`element`成员是一个表示表中存储的值类型的字符串；目前唯一有效的值是`"anyfunc"`（用于函数）。`initial`和`maximum`值表示WebAssembly
    `Table`中的元素数量。
- en: You can access the number of elements in the `Table` instance using the `length`
    property. The instance also includes methods to manipulate and query elements
    in the table. The `get()` method allows you to access the element at the given
    index, which is passed in as a parameter. The `set()` method allows you to set
    an element at the index specified as the first parameter to the value specified
    as the second parameter (per the preceding note, only functions are supported).
    Finally, `grow()` allows you to increase the size of the `Table` instance (number
    of elements) by the number passed in as a parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`length`属性访问`Table`实例中的元素数量。该实例还包括用于操作和查询表中元素的方法。`get()`方法允许您访问给定索引处的元素，该索引作为参数传递。`set()`方法允许您将第一个参数指定的索引处的元素设置为第二个参数指定的值（根据前面的说明，仅支持函数）。最后，`grow()`允许您增加`Table`实例（元素数量）的大小，增加的数量作为参数传递。
- en: WebAssembly errors (CompileError, LinkError, RuntimeError)
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly错误（CompileError、LinkError、RuntimeError）
- en: The JavaScript API provides constructors to create instances of the `Error`
    objects specific to WebAssembly, but we won't spend too much time covering these
    objects. The object definition list at the beginning of this section describes
    the nature of each error, which may be raised if the specified condition is met.
    All three errors can be constructed with a message, filename, and line number
    parameter (all of which are optional), and has the same properties and methods
    as the standard JavaScript `Error` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript API提供了用于创建特定于WebAssembly的`Error`对象实例的构造函数，但我们不会花太多时间来介绍这些对象。本节开头的对象定义列表描述了每个错误的性质，如果满足指定条件，则可能引发这些错误。这三个错误都可以使用消息、文件名和行号参数（均为可选）进行构造，并且具有与标准JavaScript
    `Error`对象相同的属性和方法。
- en: Connecting the dots with WasmFiddle
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WasmFiddle连接各个部分
- en: We spent this chapter reviewing the various elements of WebAssembly and the
    corresponding JavaScript and Web APIs, but understanding how the pieces fit together
    can still be confusing. As we progress through the examples in this book and you're
    able to see how C/C++, WebAssembly, and JavaScript interact, these concepts will
    become clearer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中回顾了WebAssembly的各个元素以及相应的JavaScript和Web API，但是理解这些元素如何组合在一起仍然可能会令人困惑。随着我们在本书中的示例中的进展，您将能够看到C/C++、WebAssembly和JavaScript是如何相互交互的，这些概念将变得更加清晰。
- en: That being said, a demonstration of this interaction may help in clearing up
    some of the confusion. In this section, we're going to use an online tool called
    WasmFiddle to demonstrate the relationship between these elements so you can see
    WebAssembly in action and get a high-level overview of the development workflow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，演示这种交互可能有助于澄清一些困惑。在本节中，我们将使用一个名为WasmFiddle的在线工具来演示这些元素之间的关系，以便您可以看到WebAssembly的实际运行情况，并对开发工作流程有一个高层次的概述。
- en: What is WasmFiddle?
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是WasmFiddle？
- en: 'WasmFiddle, located at [https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/),
    is an online code editing tool that allows you to write some C or C++ code and
    convert it to Wat, compile it to Wasm, or interact with it directly using JavaScript.
    The C/C++ and JavaScript editors are minimal and aren''t intended to be used as
    your primary development environment, but it offers a valuable service in the
    Wasm compiler. In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting
    Up A Development Environment*, you''ll discover that going from square one to
    generating Wasm files requires a little bit of work—being able to paste your C
    code into the browser and hitting a couple of buttons makes things much more convenient.
    The following diagram gives a quick overview of the interface:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: WasmFiddle位于[https://wasdk.github.io/WasmFiddle/](https://wasdk.github.io/WasmFiddle/)，是一个在线代码编辑工具，允许您编写一些C或C++代码并将其转换为Wat，编译为Wasm，或者直接使用JavaScript进行交互。C/C++和JavaScript编辑器都很简单，不打算用作您的主要开发环境，但它在Wasm编译器中提供了有价值的服务。在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)
    *设置开发环境*中，您将发现从零开始生成Wasm文件需要一些工作——能够将您的C代码粘贴到浏览器中并点击几个按钮会使事情变得更加方便。以下图表快速概述了界面：
- en: '![](img/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a30bacbd-3e98-45bf-a2af-c4c7b35c24ea.png)'
- en: Components of the WasmFiddle user interface
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WasmFiddle用户界面的组件
- en: As you can see, the interface is relatively simple. Let's try out some code!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，界面相对简单。让我们尝试一些代码！
- en: C code to Wat
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C代码转换为Wat
- en: 'The upper-left pane in the following screenshot contains a simple C function
    that adds 2 to the number specified as a parameter. The lower-left pane contains
    the corresponding Wat:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图中左上角的窗格包含一个简单的C函数，该函数将2添加到指定为参数的数字。左下角的窗格包含相应的Wat：
- en: '![](img/14cdb18b-d295-4891-a9a6-a4ab72246a22.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14cdb18b-d295-4891-a9a6-a4ab72246a22.png)'
- en: C function and the corresponding Wat
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C函数和相应的Wat
- en: If this looks familiar, it's because this same code was used for the explanation
    of Wat's s-expressions in the beginning of this chapter. Digging a little deeper,
    you can see how the C code corresponds to the Wat output. The `addTwo()` function
    is exported from the module as a string on line `5`. Line `5` also contains `(func
    $addTwo)`, which references the `$addTwo` function on line `6`. Line `6` specifies
    that a single parameter of type `i32` (an integer) can be passed in and the result
    returned is also an `i32`. Pressing the Build button in the upper-right corner
    (or above the C/C++ editor) will compile the C code into a Wasm file. The Wasm
    will be available for download or interaction with JavaScript once the build is
    completed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很熟悉，那是因为相同的代码在本章开头对Wat的s表达式进行了解释时使用过。深入挖掘一下，您可以看到C代码如何对应于Wat输出。`addTwo()`函数作为字符串从模块中导出，位于第`5`行。第`5`行还包含`(func
    $addTwo)`，它引用了第`6`行上的`$addTwo`函数。第`6`行指定可以传入一个`i32`类型（整数）的单个参数，并且返回的结果也是`i32`。在左上角（或C/C++编辑器上方）按下“Build”按钮将把C代码编译成Wasm文件。一旦构建完成，Wasm将可以供下载或与JavaScript进行交互。
- en: Wasm to JavaScript
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Wasm到JavaScript
- en: 'The upper-right pane in the following screenshot contains some JavaScript code
    to compile the Wasm that was generated in the previous step. The `wasmCode` was
    generated when the build finished, so it should be available automatically. Rather
    than use the `instantiate()` method, WasmFiddle creates a compiled `WebAssembly.Module`
    instance and passes that into the constructor of a new `WebAssembly.Instance`.
    The `wasmImports` object is currently empty, although we could pass in a `WebAssembly.Memory`
    and `WebAssembly.Table` instance if desired:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图中的右上方窗格包含一些JavaScript代码，用于编译在上一步生成的Wasm。`wasmCode`是在构建完成时生成的，因此应该自动可用。WasmFiddle不使用`instantiate()`方法，而是创建一个编译后的`WebAssembly.Module`实例，并将其传递给新的`WebAssembly.Instance`的构造函数。`wasmImports`对象目前为空，但如果需要，我们可以传入`WebAssembly.Memory`和`WebAssembly.Table`实例：
- en: '![](img/82dade82-c419-4ccb-85d2-89f58e525bcb.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82dade82-c419-4ccb-85d2-89f58e525bcb.png)'
- en: JavaScript code calling the C function from the compiled Wasm module
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码调用从编译后的Wasm模块中的C函数
- en: The final line of JavaScript prints the result of `addTwo()` to the output in
    the lower-right pane when passed the number `2`. The `log()` method is a custom
    function that ensures the output is printed to the lower-right pane (the number
    `4`). Note how the JavaScript code interacts with `wasmInstance`. The `addTwo()`
    function is called from the instance's `exports` object. Although this was a contrived
    example, it demonstrates the steps C or C++ code goes through before it can be
    used by JavaScript as a Wasm module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的最后一行将`addTwo()`的结果打印到右下窗格中，当传入数字`2`时。`log()`方法是一个自定义函数，确保输出打印到右下窗格（数字`4`）。请注意JavaScript代码如何与`wasmInstance`交互。`addTwo()`函数是从实例的`exports`对象中调用的。尽管这是一个人为的例子，但它演示了C或C++代码在被JavaScript用作Wasm模块之前经历的步骤。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the elements of WebAssembly and their relationship.
    The structure of the *Core Specification* was used to describe the mapping of
    the text and binary formats to a common abstract syntax. We highlighted aspects
    of the text format (Wat) that can be useful in the context of debugging and development,
    as well as why s-expressions are an excellent fit for the textual representation
    of the abstract syntax. We also reviewed details pertaining to the binary format
    and the various elements that make up a module. The methods and objects within
    the JavaScript and Web APIs were defined with descriptions of their roles with
    regard to WebAssembly interaction. Finally, a simple example of the relationship
    between source code, Wat, and JavaScript was presented using the WasmFiddle tool.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了WebAssembly的元素及其关系。 *核心规范*的结构被用来描述文本和二进制格式到一个共同的抽象语法的映射。我们强调了文本格式（Wat）在调试和开发环境中的有用性，以及为什么s表达式非常适合抽象语法的文本表示。我们还回顾了有关二进制格式和构成模块的各种元素的细节。在JavaScript和Web
    API中定义了方法和对象，并描述了它们在WebAssembly交互中的作用。最后，使用WasmFiddle工具演示了源代码、Wat和JavaScript之间的关系的简单示例。
- en: In [Chapter 3](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml), *Setting Up a Development
    Environment*, we'll install the development tooling we'll use to work effectively
    with WebAssembly.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](706c89b2-c820-4fb0-906c-2f2e49602d27.xhtml)中，*设置开发环境*，我们将安装开发工具，以便有效地使用WebAssembly进行工作。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What kind of data are s-expressions good at representing?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: s表达式擅长表示什么类型的数据？
- en: What are the four language concepts that are shared between the binary and text
    formats?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制和文本格式之间共享的四个语言概念是什么？
- en: What is one of the use cases for the text format?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本格式的一个用例是什么？
- en: What is the only element type that can be stored in a WebAssembly `Table`?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以存储在WebAssembly `Table`中的唯一元素类型是什么？
- en: What does the JavaScript engine use to manage execution?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript引擎使用什么来管理执行？
- en: Which method requires less code to instantiate a module, `instantiate()` or
    `instantiateStreaming()`?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法需要更少的代码来实例化一个模块，`instantiate()`还是`instantiateStreaming()`？
- en: What error objects are available on the `WebAssembly` JavaScript object and
    what event causes each one?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebAssembly` JavaScript对象上有哪些错误对象，以及是什么事件导致了每一个错误对象？'
- en: Further reading
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: WebAssembly on MDN: [https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDN上的WebAssembly：[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
- en: 'WasmFiddle: [https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WasmFiddle：[https://wasdk.github.io/WasmFiddle](https://wasdk.github.io/WasmFiddle)
- en: 'S-expressions on Wikipedia: [https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维基百科上的s表达式：[https://en.wikipedia.org/wiki/S-expression](https://en.wikipedia.org/wiki/S-expression)
- en: 'Examples of Trees: [http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html](http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树的示例：[http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html](http://interactivepython.org/runestone/static/pythonds/Trees/ExamplesofTrees.html)
