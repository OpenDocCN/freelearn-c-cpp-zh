- en: Chapter 4. Windows App Development with Code::Blocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用Code::Blocks进行Windows应用程序开发
- en: In the previous chapters, focus of our app development was on console based
    app. This is also known as text only app as console based apps can only display
    text and ASCII art. However, our focus in this chapter will be on app development
    for Windows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们的应用程序开发重点是基于控制台的应用程序。这也被称为纯文本应用程序，因为基于控制台的应用程序只能显示文本和ASCII艺术。然而，在本章中，我们的重点将放在Windows应用程序开发上。
- en: Windows is one of the most widely used operating systems around the world. Code::Blocks
    can be used to develop apps for Windows, Linux, or Mac. Keeping in view the popularity
    of the Windows platform we shall restrict our focus to Windows platforms only.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是世界上使用最广泛的操作系统之一。Code::Blocks可以用于开发Windows、Linux或Mac的应用程序。考虑到Windows平台的流行，我们将把重点限制在Windows平台上。
- en: 'Apps for Windows are also known as GUI (Graphical User Interface) based apps.
    User interaction with app is done by mouse and keyboard. Notepad app is an example
    of GUI based apps that come bundled with Windows operating system. The following
    screenshot displays the Notepad app:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Windows应用程序也被称为GUI（图形用户界面）应用程序。用户与应用程序的交互是通过鼠标和键盘完成的。记事本应用程序是Windows操作系统捆绑的GUI应用程序的一个例子。以下截图显示了记事本应用程序：
- en: '![Windows App Development with Code::Blocks](img/3415OS_04_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![使用Code::Blocks进行Windows应用程序开发](img/3415OS_04_01.jpg)'
- en: Code::Blocks comes along with all the tools required for Windows app development.
    Let's develop an app and learn it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks随附了所有用于Windows应用程序开发的工具。让我们开发一个应用程序并学习它。
- en: First Windows app
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个Windows应用程序
- en: 'Following the tradition of Hello World app, we''ll create our first Windows
    app. To do so perform the following steps:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Hello World应用程序的传统，我们将创建我们的第一个Windows应用程序。要做到这一点，请执行以下步骤：
- en: Go to **File** | **New** | **Project…** menu option. Choose the **Win32 GUI
    project** option as in the following screenshot and click on the **Go** button:![First
    Windows app](img/3415OS_04_03.jpg)
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**文件** | **新建** | **项目...**菜单选项。选择**Win32 GUI项目**选项，如下截图所示，然后单击**Go**按钮：![第一个Windows应用程序](img/3415OS_04_03.jpg)
- en: Click on the **Next** button on the first page of wizard as shown in the following
    screenshot. Choose **Frame based** option and click on the **Next** button. Dialog
    based apps can't contain menu bar or a toolbar. So we are choosing Frame based
    app.![First Windows app](img/3415OS_04_04.jpg)
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导的第一页上单击**下一步**按钮，如下截图所示。选择**基于框架**选项，然后单击**下一步**按钮。基于对话框的应用程序不能包含菜单栏或工具栏。因此，我们选择了基于框架的应用程序。![第一个Windows应用程序](img/3415OS_04_04.jpg)
- en: Enter `App9` as project title and choose folder to create project. Now click
    on the **Next** button and then click on the **Finish** button to complete the
    wizard.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`App9`作为项目标题输入，并选择创建项目的文件夹。现在单击**下一步**按钮，然后单击**完成**按钮以完成向导。
- en: 'Replace code inside the `main.cpp` file with following code:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`文件中用以下代码替换代码：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now click on the build icon in compiler toolbar. Click on the run button in
    compiler toolbar. Our `App9` window will be similar to the following screenshot:![First
    Windows app](img/3415OS_04_07.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在编译器工具栏中单击构建图标。在编译器工具栏中单击运行按钮。我们的`App9`窗口将类似于以下截图：![第一个Windows应用程序](img/3415OS_04_07.jpg)
- en: Congratulations! We have successfully compiled our first app for Windows.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜！我们已成功编译了我们的第一个Windows应用程序。
- en: Let's understand the code we have written for this app. We are including `windows.h`
    file in the beginning of code. This file must be included in all Windows app as
    it contains relevant function declarations for Windows. Subsequently we have a
    function called `WinMain()` and this is the **entry point** of a Windows app.
    An entry point is the first function that is called at app start up.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解我们为这个应用程序编写的代码。我们在代码开头包含了`windows.h`文件。这个文件必须包含在所有Windows应用程序中，因为它包含了Windows的相关函数声明。随后我们有一个名为`WinMain()`的函数，这是Windows应用程序的**入口点**。入口点是在应用程序启动时调用的第一个函数。
- en: The `WinMain()` functions accepts four parameters—handle to the current instance,
    handle to the previous instance, command line string pointer, and show state of
    window that controls how a app should be displayed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`WinMain()`函数接受四个参数——当前实例的句柄，先前实例的句柄，命令行字符串指针，以及控制应用程序应如何显示的窗口显示状态。'
- en: We are calling the `MessageBox()` function to display a message box. It accepts
    four parameters—handle to the parent window (`NULL` or no one in our case), message
    text, dialog box title, and a combination of flags that controls buttons and icons
    to be shown. In our case we have used a combination of `MB_OK` and `MB_ICONINFORMATION`,
    which instructs the `MessageBox()` function to display a **OK** button and an
    information icon respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`MessageBox()`函数来显示一个消息框。它接受四个参数——父窗口的句柄（在我们的情况下为`NULL`或没有），消息文本，对话框标题，以及控制要显示的按钮和图标的标志的组合。在我们的情况下，我们使用了`MB_OK`和`MB_ICONINFORMATION`的组合，这指示`MessageBox()`函数分别显示一个**OK**按钮和一个信息图标。
- en: 'But why are we getting a console for a GUI app? Answer is that by default Code::Blocks
    creates debug target as a console app. We can confirm this by navigating to **Project**
    | **Properties…** menu option and then clicking on the **Build targets** tab.
    Refer to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们为GUI应用程序获取了一个控制台？答案是，默认情况下，Code::Blocks将调试目标创建为控制台应用程序。我们可以通过导航到**项目**
    | **属性...**菜单选项，然后单击**构建目标**选项卡来确认这一点。参考以下截图：
- en: '![First Windows app](img/3415OS_04_08.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![第一个Windows应用程序](img/3415OS_04_08.jpg)'
- en: 'Advantage of this method is that debug output can be printed to that console
    for easier debugging. This can be disabled by changing app type to **GUI application**
    in the **Type:** combo box as shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是可以将调试输出打印到控制台，以便更容易进行调试。可以通过在**类型：**组合框中将应用程序类型更改为**GUI应用程序**来禁用此功能，如下截图所示：
- en: '![First Windows app](img/3415OS_04_09.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![第一个Windows应用程序](img/3415OS_04_09.jpg)'
- en: This will stop launching that console window.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止启动控制台窗口。
- en: Windows App and Unicode
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows应用和Unicode
- en: 'Unicode is a standard to encode, store and represent text in World''s most
    languages. C++ `char` data type is 1 byte in size. It is only able to represent
    text available in English language. To enable Unicode support in a Windows app
    we have to use a special data type called `wchar_t`, which is 2 byte in size.
    Let''s say Hello World in the Hindi language. To do this we will replace previous
    `MessageBox()` code with the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是一种用于编码、存储和表示世界大多数语言文本的标准。C++的`char`数据类型大小为1字节。它只能表示英语中可用的文本。要在Windows应用程序中启用Unicode支持，我们必须使用一个称为`wchar_t`的特殊数据类型，其大小为2字节。让我们用印地语说Hello
    World。为此，我们将用以下代码替换以前的`MessageBox（）`代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Code::Blocks editor window will look similar to the following screenshot.
    Editor font size has been changed to 16 point in order to work with Devnagiri
    script:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks编辑器窗口将类似于以下屏幕截图。编辑器字体大小已更改为16点，以便使用Devnagiri脚本：
- en: '![Windows App and Unicode](img/3415OS_04_41.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Windows App and Unicode](img/3415OS_04_41.jpg)'
- en: We have decorated Hindi text with a `TEXT()` macro. This macro is used to translated
    a Unicode string to a `wchar_t*` when a `UNICODE` or `_UNICODE` pre-processor
    definition is defined. It returns a `char*` when Unicode support is not enabled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用`TEXT（）`宏装饰了印地语文本。当定义了`UNICODE`或`_UNICODE`预处理器定义时，此宏用于将Unicode字符串转换为`wchar_t*`。当未启用Unicode支持时，它返回`char*`。
- en: Next we'll define following pre-processor defines. Go to **Project** | **Build
    options…** menu option. Then select `App9` in the tree on the left side and click
    on the **Compiler settings** and then **#defines** tab.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义以下预处理器定义。转到**项目** | **构建选项…**菜单选项。然后在左侧的树中选择`App9`，然后单击**编译器设置**，然后单击**#defines**选项卡。
- en: '![Windows App and Unicode](img/3415OS_04_10.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Windows App and Unicode](img/3415OS_04_10.jpg)'
- en: 'Add `UNICODE` and `_UNICODE` to the text control and click on the **OK** button.
    Click on the build button and then click on the run button in compiler toolbar.
    Now `App9` will show Hello World in Hindi language, as shown in the following
    screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将`UNICODE`和`_UNICODE`添加到文本控件中，然后单击**确定**按钮。单击编译器工具栏中的构建按钮，然后单击运行按钮。现在`App9`将以印地语显示Hello
    World，如下面的屏幕截图所示：
- en: '![Windows App and Unicode](img/3415OS_04_11.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Windows App and Unicode](img/3415OS_04_11.jpg)'
- en: Please note that we'll enable Unicode support in all subsequent apps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将在所有后续应用程序中启用Unicode支持。
- en: Event driven Windows app
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动的Windows应用程序
- en: Windows apps are **event driven** apps. An event can be an external or internal
    input to an app. Event driven apps run a message loop, which parses incoming events
    and then calls appropriate functions corresponding to that event. Code::Blocks
    default code generated by **Win32 GUI project** wizard generates a boilerplate
    code of an event driven app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Windows应用程序是**事件驱动**应用程序。事件可以是应用程序的外部或内部输入。事件驱动应用程序运行一个消息循环，该循环解析传入的事件，然后调用与该事件对应的适当函数。由**Win32
    GUI项目**向导生成的Code::Blocks默认代码生成了一个事件驱动应用程序的样板代码。
- en: In order to understand event driven programming we shall be using following
    example to learn and understand it. We shall be using native Win32 API for this
    example. Win32 API is the base of several toolkits. Thus we should have an understanding
    of it in order to understand other toolkits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解事件驱动编程，我们将使用以下示例来学习和理解。我们将使用本示例的本机Win32 API。Win32 API是几个工具包的基础。因此，我们应该了解它以便了解其他工具包。
- en: Let's create another GUI app and name it `App10`. Replace wizard generated code
    with the following code. Also enable Unicode support as per the steps laid out
    in the previous example. As the code snippet is large we'll understand and paste
    it in editor window in several steps.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`App10`的GUI应用程序。用以下代码替换向导生成的代码。还要按照前面示例中的步骤启用Unicode支持。由于代码片段很大，我们将分步理解并粘贴到编辑器窗口中。
- en: 'The following code snippet shows the header declaration, global variable declaration,
    and declaration of callback function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了头文件声明、全局变量声明和回调函数声明：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the following snippet we'll define the `WinMain()` function. We will define
    an object of `WNDCLASSEX` structure inside the `WinMain()` function. This structure
    takes several inputs. With `wincl.lpfnWndProc` we have assigned a callback function
    `WindowProcedure()` to the `wincl` object. This instructs app to call that function
    for event processing. Finally the `wincl` object will get registered with the
    `RegisterClassEx()` function. Once the object is registered successfully we create
    a window of that class using the `CreateWindowEx()` function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将定义`WinMain（）`函数。我们将在`WinMain（）`函数内定义`WNDCLASSEX`结构的对象。此结构需要几个输入。通过`wincl.lpfnWndProc`，我们已经将回调函数`WindowProcedure（）`分配给了`wincl`对象。这指示应用程序调用该函数进行事件处理。最后，`wincl`对象将使用`RegisterClassEx（）`函数注册。一旦对象成功注册，我们就可以使用`CreateWindowEx（）`函数创建该类的窗口。
- en: We will display newly created window using the `ShowWindow()` function. After
    the window is displayed we will run an event processing loop using the `GetMessage()`
    function inside a `while` loop. All incoming events are then sent to the `WindowProcedure()`
    function by `DispatchMessage()` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ShowWindow（）`函数显示新创建的窗口。窗口显示后，我们将使用`GetMessage（）`函数在`while`循环内运行事件处理循环。所有传入的事件都将通过`DispatchMessage（）`函数发送到`WindowProcedure（）`函数。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WM_CREATE` event is sent out by Windows OS when a window is being created.
    We will then create a button using the `CreateWindow()` function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口正在创建时，Windows操作系统会发送`WM_CREATE`事件。然后，我们将使用`CreateWindow（）`函数创建一个按钮。
- en: We shall be processing button press by processing the `WM_COMMAND` event in
    the `WindowProcedure()` function. We will then display a message box whenever
    this button is clicked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`WindowProcedure（）`函数中处理`WM_COMMAND`事件来处理按钮按下。然后，每当单击此按钮时，我们将显示一个消息框。
- en: Finally we will be processing the `WM_DESTROY` event, which will be issued whenever
    window is being destroyed. A return value of `0` will be posted with the `PostQuitMessage()`
    function emitting a `WM_QUIT` event to the message queue.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理`WM_DESTROY`事件，每当窗口被销毁时都会发出该事件。`PostQuitMessage()`函数将发布值为`0`的返回值，发出`WM_QUIT`事件到消息队列。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This completes our Windows app. Hit *F9* key (an alternative to clicking on
    the build and then run icon in build toolbar) to build and run this app. Following
    screenshot will be presented:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的Windows应用程序。按下*F9*键（构建和运行工具栏中的构建和运行图标的替代方法）来构建和运行此应用程序。将呈现以下截图：
- en: '![Event driven Windows app](img/3415OS_04_42.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![事件驱动的Windows应用程序](img/3415OS_04_42.jpg)'
- en: 'Advantages of Win32 API:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API的优势：
- en: Produces smaller executable size
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的可执行文件大小更小
- en: Produces faster code due to less overhead
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于开销较少，生成的代码速度更快
- en: 'Disadvantages of Win32 API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API的缺点：
- en: Requires longer development time due larger amount of code to be written
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于需要编写更多的代码，开发时间更长
- en: Minimal set of GUI controls (for example, a text box, button, and so on) are
    available to developer
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以使用最小的一组GUI控件（例如文本框、按钮等）
- en: To solve this problem, GUI toolkit was developed. The GUI toolkit simplifies
    development process allowing reuse of code and a smaller code base. It also contains
    complex GUI control (for example, rich text control, HTML control, and so on).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发了GUI工具包。GUI工具包简化了开发过程，允许代码重用和更小的代码库。它还包含复杂的GUI控件（例如，富文本控件、HTML控件等）。
- en: wxWidgets GUI toolkit
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wxWidgets GUI toolkit
- en: 'A GUI toolkit is a set of header files and libraries that makes GUI development
    easier for developers. There are several GUI toolkits available in the market,
    few of them are stated as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GUI工具包是一组头文件和库，使开发人员更容易开发GUI。市场上有几种GUI工具包可用，以下是其中的一些：
- en: '**Microsoft Foundation Class** (**MFC**): It is a set of classes that acts
    as a wrapper to Win32 api. This comes bundled with commercial versions of Visual
    Studio. MFC is proprietary and requires a Visual Studio license in order to use
    it. MFC app have native look and feel.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Foundation Class**（**MFC**）：这是一组作为Win32 API包装器的类。它随商业版本的Visual
    Studio捆绑提供。MFC是专有的，需要Visual Studio许可证才能使用。MFC应用程序具有本地外观和感觉。'
- en: '**Qt** (pronounced as "cute"): It is a Open source and cross-platform GUI toolkit
    developed by **Digia**. Qt is licensed under both commercial and GPL/LGPL license.
    It is available on wide range of platforms including Windows, Linux, Mac, and
    so on. Qt drawn GUI is a custom drawn UI and may differ from a standard app on
    a platform.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt**（发音为“cute”）：这是由**Digia**开发的开源跨平台GUI工具包。Qt根据商业和GPL/LGPL许可证提供。它可在包括Windows、Linux、Mac等在内的广泛平台上使用。Qt绘制的GUI是自定义绘制的UI，可能与平台上的标准应用程序不同。'
- en: '**wxWidgets**: It is another open source and cross-platform GUI toolkit licensed
    under wxWindows license (based on LGPL but less restrictive). It''s generated
    UI has native look and feel as it uses platform standard UI elements.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wxWidgets**：这是另一个开源的跨平台GUI工具包，根据wxWindows许可证（基于LGPL但限制较少）许可。它生成的UI具有本地外观和感觉，因为它使用平台标准的UI元素。'
- en: We'll focus on wxWidgets toolkit in this book due to its simpler licensing model,
    native look and feel, and cross-platform development capability. A compiled copy
    of wxWidgets is also provided with the book. This book assumes that reader has
    extracted compiled wxWidgets to `Z:\wxWidgets` folder.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其更简单的许可模型、本地外观和感觉以及跨平台开发能力，本书将专注于wxWidgets工具包。本书假定读者已将编译后的wxWidgets提取到`Z:\wxWidgets`文件夹中。
- en: In order to understand similarities between Win32 API and wxWidgets we will
    recreate `App9` functionalities with wxWidgets.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Win32 API和wxWidgets之间的相似之处，我们将使用wxWidgets重新创建`App9`的功能。
- en: Go to **File** | **New** | **Project…** menu option. Then choose the **wxWidgets
    project** wizard.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**文件** | **新建** | **项目…**菜单选项。然后选择**wxWidgets项目**向导。
- en: Next click on the **Go** button and then click on the **Next** button in the
    next window. Choose **wxWidgets 2.9.x (SVN Version)** option in the wizard page
    and click on the **Next** button, as shown in the following screenshot:![wxWidgets
    GUI toolkit](img/3415OS_04_14.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来单击**Go**按钮，然后在下一个窗口中单击**下一步**按钮。在向导页面中选择**wxWidgets 2.9.x（SVN版本）**选项，然后单击**下一步**按钮，如下截图所示：![wxWidgets
    GUI toolkit](img/3415OS_04_14.jpg)
- en: Enter `App11` as the Project title and click on the **Next** button. Click on
    the **Next** button to skip Project details page.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`App11`输入为项目标题，然后单击**下一步**按钮。单击**下一步**按钮跳过项目详细信息页面。
- en: Choose **Frame Based** application type as shown in the following screenshot.
    Frame based apps are apps which can have menus, toolbars, and are suitable for
    large apps. Leave **Preferred GUI Builder** option to **None** as we'll be writing
    GUI code ourselves.![wxWidgets GUI toolkit](img/3415OS_04_16.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**基于框架**的应用程序类型，如下截图所示。基于框架的应用程序可以拥有菜单、工具栏，适用于大型应用程序。将**首选GUI生成器**选项保留为**无**，因为我们将自己编写GUI代码。![wxWidgets
    GUI toolkit](img/3415OS_04_16.jpg)
- en: In the following window `$(#wx`) is a global variable, which is pointing to
    wxWidgets installation directory. Alternatively full path to wxWidgets that is
    `Z:\wxWidgets` in our case may be entered here:![wxWidgets GUI toolkit](img/3415OS_04_17.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的窗口中，`$(#wx`)是一个全局变量，指向wxWidgets安装目录。或者，可以在此处输入我们的情况下的wxWidgets的完整路径，即`Z:\wxWidgets`：![wxWidgets
    GUI toolkit](img/3415OS_04_17.jpg)
- en: If this global variable is undefined at this point following window will pop
    up. It will not pop up if the global variable has already been defined.![wxWidgets
    GUI toolkit](img/3415OS_04_18.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此全局变量在此时未定义，将弹出以下窗口。如果全局变量已经定义，则不会弹出。![wxWidgets GUI toolkit](img/3415OS_04_18.jpg)
- en: Complete the text boxes as per the previous screenshot and click on the **Close**
    button. Then click on the **Next** button twice.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一个截图完成文本框的内容，然后单击**关闭**按钮。然后连续单击两次**下一步**按钮。
- en: Check the **Enable unicode** option in the following screenshot to enable Unicode
    support and click on the **Next** button. Click on the **Finish** button in the
    next page to close this wizard. Wizard will generate necessary code and set up
    a project to develop app using the wxWidgets toolkit.![wxWidgets GUI toolkit](img/3415OS_04_19.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的截图中，勾选**启用Unicode**选项以启用Unicode支持，然后单击**下一步**按钮。在下一页中单击**完成**按钮以关闭此向导。向导将生成必要的代码并设置一个使用wxWidgets工具包开发应用程序的项目。![wxWidgets
    GUI toolkit](img/3415OS_04_19.jpg)
- en: 'Replace code in the `App11Main.h` file with the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`App11Main.h`文件中的代码：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An `App11Frame` class has been derived from a `wxFrame` class. A `wxFrame` class
    represents a basic window. Member variable `m_btnClickMe` has been defined to
    create and store button and `idBtnClick` will store it's ID for event processing.
    We have placed a `DECLARE_EVENT_TABLE()` function macro to create boiler plate
    code for event handling related to this class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`App11Frame`类是从`wxFrame`类派生而来的。`wxFrame`类表示一个基本窗口。成员变量`m_btnClickMe`已经被定义用来创建和存储按钮，`idBtnClick`将存储它的ID以进行事件处理。我们放置了一个`DECLARE_EVENT_TABLE()`函数宏来创建与该类相关的事件处理的样板代码。'
- en: 'Next replace code in the `App11Main.cpp` file with the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来用以下代码替换`App11Main.cpp`文件中的代码：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An event table has been laid out using `BEGIN_EVENT_TABLE()` and `END_EVENT_TABLE()`
    macros. This defines relationship of callback functions with respective events.
    The `OnClickMe()` function has been connected to button press event. It will show
    a message whenever the **Click Me!** button is pressed by the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BEGIN_EVENT_TABLE()`和`END_EVENT_TABLE()`宏布置了一个事件表。这定义了回调函数与相应事件的关系。`OnClickMe()`函数已连接到按钮按下事件。每当用户按下**Click
    Me!**按钮时，它将显示一条消息。
- en: The `OnClose()` function will be called when app closed. It calls a `Destroy()`
    function that initiates app shutdown.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序关闭时，`OnClose()`函数将被调用。它调用了一个`Destroy()`函数来启动应用程序关闭。
- en: 'Now replace code in the `App11App.h` file with the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用以下代码替换`App11App.h`文件中的代码：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding file we have derived a class `App11App` from `wxApp`. A virtual
    function `OnInit()` is implemented in this class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，我们从`wxApp`派生了一个`App11App`类。在这个类中实现了一个虚函数`OnInit()`。
- en: 'Next type the following code in the `App11App.cpp` file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来在`App11App.cpp`文件中输入以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the implementation of `OnInit()` function an object named `frame` has been
    derived from the `App11Frame` class. Resource files are available only on Windows
    platform. Thus it has been enclosed within a pre-processor macro `__WXMSW__` and
    subsequently app is launched in line number `12`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnInit()`函数的实现中，一个名为`frame`的对象是从`App11Frame`类派生出来的。资源文件仅在Windows平台上可用。因此，它已被包含在预处理器宏`__WXMSW__`中，并随后在第12行启动了应用程序。
- en: Leave code inside `resource.rc` file as it is.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`resource.rc`文件中的代码保持不变。
- en: 'Hit *F9* button to compile and run. Following window will be launched. We find
    that our application is now working fine:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*F9*按钮进行编译和运行。将启动以下窗口。我们发现我们的应用程序现在运行正常：
- en: '![wxWidgets GUI toolkit](img/3415OS_04_43.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![wxWidgets GUI toolkit](img/3415OS_04_43.jpg)'
- en: Earlier we mentioned about cross-platform development capability of wxWidgets.
    Let's put that capability into action. We'll compile `App11` source without any
    change on Linux platform. For this example, we are using **CentOS 6** Linux.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到了wxWidgets的跨平台开发能力。让我们将这种能力付诸实践。我们将在Linux平台上编译`App11`源码而不做任何更改。在这个例子中，我们使用**CentOS
    6** Linux。
- en: In order to compile on Linux platform, we'll use a `Makefile`. Remember we can
    also use the Code::Blocks wxWidgets project wizard to generate a project targeted
    at Linux platform. However in my opinion developers should be familiar with the
    `Make` tool.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Linux平台上编译，我们将使用一个`Makefile`。请记住，我们也可以使用Code::Blocks wxWidgets项目向导来生成一个针对Linux平台的项目。但是在我看来，开发人员应该熟悉`Make`工具。
- en: Make is a build tool that can be used any number of source files to a binary
    based files on a set of rules inside a text file known as a `Makefile`. Make handles
    build dependencies efficiently and for a large project make will only compile
    relevant files, which has changed since last build. This saves time and also eliminates
    any human error in the entire build process.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Make是一个构建工具，可以根据一个名为`Makefile`的文本文件中的一组规则将任意数量的源文件编译成二进制文件。Make有效地处理构建依赖关系，对于一个大型项目，Make只会编译自上次构建以来发生变化的相关文件。这样可以节省时间，也可以消除整个构建过程中的任何人为错误。
- en: 'Perform the following steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Paste the following code into a file and save it with filename `Makefile`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码粘贴到一个文件中，并将其保存为文件名`Makefile`：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this file several variables are defined in first four lines. The `CPP` variable
    defines C++ compiler binary, `CXXFLAGS` stores necessary compiler flags for a
    `wxWidgets` project by running a script `wx-config`. The wxWidgets project provides
    a shell script known as `wx-config` that can be used determine compiler and linker
    flags.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，前四行定义了几个变量。`CPP`变量定义了C++编译器二进制文件，`CXXFLAGS`存储了通过运行脚本`wx-config`为`wxWidgets`项目提供的必要编译器标志。wxWidgets项目提供了一个名为`wx-config`的shell脚本，可以用来确定编译器和链接器标志。
- en: '`LDFLAGS` stores necessary linker flags used for executable binary generation.
    `SOURCES` variable define the sources that are to be compiled. Do note that we
    are not using `resource.rc` file anymore as resource compiler doesn''t exist on
    Linux platform.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDFLAGS`存储了用于生成可执行二进制文件的必要链接器标志。`SOURCES`变量定义了要编译的源文件。请注意，我们不再使用`resource.rc`文件，因为在Linux平台上不存在资源编译器。'
- en: '`App11:` line defines a make target `App11` which comprises two sub-targets
    `App11Main.o` and `App11App.o`. There is a shell command defined in the following
    line which indicates the command to be executed after all sub-targets are built
    successfully. Subsequently both these targets are also defined in a similar manner.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`App11：`行定义了一个名为`App11`的make目标，其中包括两个子目标`App11Main.o`和`App11App.o`。在接下来的一行中定义了一个shell命令，该命令指示在所有子目标成功构建后要执行的命令。随后，这两个目标也以类似的方式定义。'
- en: 'clean: target executes a command to delete all object files and our executable
    binary.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`目标执行一个命令来删除所有对象文件和我们的可执行二进制文件。'
- en: 'Next issue the following command in Linux shell prompt to compile our app:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux shell提示符下发出以下命令来编译我们的应用程序：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To run our app use the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的应用程序，请使用以下命令：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Following window will be displayed:![wxWidgets GUI toolkit](img/3415OS_04_44.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示以下窗口：![wxWidgets GUI工具包](img/3415OS_04_44.jpg)
- en: We find that our app now runs on Linux platform flawlessly. It behaves exactly
    as we wanted it to. We didn't make any changes to the code we wrote for Windows
    platform. But our GUI toolkit has internally mapped our code to appropriate functions
    for Linux platform. This gives an immense advantage to a developer as targeting
    multiple platforms becomes a lot easier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现我们的应用程序现在在Linux平台上完美运行。它的行为与我们想要的完全一样。我们没有对我们为Windows平台编写的代码进行任何更改。但是我们的GUI工具包已经将我们的代码内部映射到适用于Linux平台的适当函数。这对开发人员来说是一个巨大的优势，因为面向多个平台变得更加容易。
- en: Rapid app development with wxSmith
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用wxSmith进行快速应用程序开发
- en: We have learned about app development for Windows platform in the last few sections.
    But all our code was hand-written. We also noticed that even for a simple GUI
    we have to write several lines of code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几节中，我们已经了解了Windows平台的应用程序开发。但是我们所有的代码都是手写的。我们还注意到，即使对于一个简单的GUI，我们也必须编写几行代码。
- en: So, can we do something about it? How about automatic code generation of GUI
    codes? Sound interesting! Code::Blocks comes with a plugin, called **wxSmith**,
    which can generate C++ code (using wxWidgets toolkit) based on the user generated
    GUI inside a Visual editor. We'll learn this with another example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们能做些什么呢？自动生成GUI代码怎么样？听起来有趣！Code::Blocks带有一个名为**wxSmith**的插件，它可以根据用户在可视化编辑器中生成的GUI生成基于wxWidgets工具包的C++代码。我们将通过另一个示例来学习这个功能。
- en: Create a new wxWidgets project. This time we'll name it something meaningful.
    In the following window enter project title as `MyNotePad`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的wxWidgets项目。这次我们将给它取一个有意义的名字。在下面的窗口中，将项目标题输入为`MyNotePad`。
- en: In the following page, select **wxSmith** as **Preferred GUI Builder**. This
    option configures wxWidgets project to use wxSmith GUI builder. Refer the following
    screenshot:![Rapid app development with wxSmith](img/3415OS_04_23.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的页面中，将**wxSmith**选择为**首选GUI生成器**。此选项配置wxWidgets项目以使用wxSmith GUI生成器。参考以下截图：![使用wxSmith进行快速应用程序开发](img/3415OS_04_23.jpg)
- en: After the project generation is complete files following window will be displayed:![Rapid
    app development with wxSmith](img/Image1.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目生成完成后，将显示以下文件窗口：![使用wxSmith进行快速应用程序开发](img/Image1.jpg)
- en: 'The preceding window have the following three major components:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的窗口有以下三个主要组件：
- en: 'The **wxSmith** window: This window shows editable UI elements'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wxSmith窗口：此窗口显示可编辑的UI元素
- en: 'The **Resource** tree: This window gives an overall view of the project showing
    hierarchy of GUI elements of that particular project'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源树：此窗口提供了项目的整体视图，显示了该特定项目的GUI元素的层次结构
- en: 'The **Property** window: This window shows properties of currently selected
    object in wxSmith window'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性窗口：此窗口显示了wxSmith窗口中当前选定对象的属性
- en: Click on the `MyNotePadFrame` item shown in the following screenshot on the
    resource tree and then click on the **Title** property in the property window.
    Type `MyNotePad` in that text box. This will set title of our app to `MyNotePad`.![Rapid
    app development with wxSmith](img/3415OS_04_26.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击资源树中显示的`MyNotePadFrame`项目，然后点击属性窗口中的**Title**属性。在文本框中输入`MyNotePad`。这将把我们的应用程序标题设置为`MyNotePad`。![使用wxSmith进行快速应用程序开发](img/3415OS_04_26.jpg)
- en: Now we'll add a `wxTextCtrl` control to our app. This will add a text box to
    our app. Click on the `wxTextCtrl` control button on the toolbar below. Immediately
    the **MyNotePadFrame** window shown inside wxSmith window will be selected.![Rapid
    app development with wxSmith](img/3415OS_04_27.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将向我们的应用程序添加一个`wxTextCtrl`控件。这将向我们的应用程序添加一个文本框。在下方的工具栏上点击`wxTextCtrl`控件按钮。立即在wxSmith窗口内显示的**MyNotePadFrame**窗口将被选中。![使用wxSmith进行快速应用程序开发](img/3415OS_04_27.jpg)
- en: Click on it and this text control will be added to that. The wxSmith window
    will look similar to the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_28.jpg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击它，这个文本控件将被添加到其中。wxSmith窗口将看起来类似于以下截图：![使用wxSmith进行快速应用程序开发](img/3415OS_04_28.jpg)
- en: 'In the property window change the following properties:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中更改以下属性：
- en: '**Text** property: It is an empty string. This property stores the text inside
    a text control'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本属性：它是一个空字符串。此属性存储文本控件中的文本
- en: '**Var name** property: Change this to `TextCtrlNotePad`. This property will
    be used to name object of the `wxTextCtrl` class.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名属性：将其更改为`TextCtrlNotePad`。此属性将用于命名`wxTextCtrl`类的对象。
- en: '**Identifier** property `ID_TEXTCTRL_NOTEPAD`: It will be assigned a unique
    integer and then will be used to assign it with an event handler and an event
    type.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**属性`ID_TEXTCTRL_NOTEPAD`：它将被分配一个唯一的整数，然后将用于为其分配事件处理程序和事件类型。'
- en: Scroll down the property window and click on the **Style** property. Click on
    the **wxTE_MULTILINE** property to check it. This will enable text control show
    text in multiple lines.![Rapid app development with wxSmith](img/3415OS_04_29.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中向下滚动并点击**Style**属性。点击**wxTE_MULTILINE**属性进行选择。这将使文本控件显示多行文本。![使用wxSmith进行快速应用程序开发](img/3415OS_04_29.jpg)
- en: In this next step, we'll edit menu bar. Double-click on the menu bar icon (shown
    in following screenshot):![Rapid app development with wxSmith](img/3415OS_04_30.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们将编辑菜单栏。双击菜单栏图标（如下截图所示）：![使用wxSmith进行快速应用程序开发](img/3415OS_04_30.jpg)
- en: The **MenuBar editor** window will pop up. Select the **Quit** menu option as
    in the following screenshot in the menu tree on the left side and then click on
    the **New** button:![Rapid app development with wxSmith](img/3415OS_04_31.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 菜单栏编辑器窗口将弹出。在左侧的菜单树中选择“退出”菜单选项，然后点击“新建”按钮：![使用wxSmith进行快速应用程序开发](img/3415OS_04_31.jpg)
- en: Click on the **^** button to move the new menu item above, **Quit** menu option.
    Four buttons shown in the following screenshot can be used to rearrange menu items
    in the menu tree:![Rapid app development with wxSmith](img/Image2.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**^**按钮将新菜单项移动到**退出**菜单选项之上。如下屏幕截图所示，可以使用以下四个按钮重新排列菜单树中的菜单项：![wxSmith快速应用程序开发](img/Image2.jpg)
- en: 'Now select the new menu option in the menu tree and change the following properties
    on the right side:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在菜单树中选择新菜单选项，并在右侧更改以下属性：
- en: 'The **Id** property: Change this to `idFileOpen`. This property will be defined
    as a unique integer and will be used to assign it with an event handler and an
    event type.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID属性：将其更改为`idFileOpen`。此属性将被定义为一个唯一的整数，并将用于将其分配给事件处理程序和事件类型。
- en: 'The **Label** property: Change this property to `&Open`. This text defines
    the menu label and `&O` text will define an accelerator key. This menu can now
    be selected and clicked by pressing *O* button whenever this menu option is visible.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签属性：将此属性更改为“&Open”。此文本定义了菜单标签，“&O”文本将定义加速键。只要此菜单选项可见，就可以通过按下*O*按钮选择并单击此菜单。
- en: 'The **Accelerator** property: Change this one to `Ctrl+O`. This property defines
    a keyboard accelerator to this menu option. A keyboard accelerator is a unique
    combination of keystrokes that will generate a click event for this menu option
    irrespective of menu item''s visibility.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速器属性：将此属性更改为`Ctrl+O`。此属性为此菜单选项定义了一个键盘加速器。键盘加速器是一组唯一的按键组合，无论菜单项的可见性如何，都将生成此菜单选项的单击事件。
- en: 'The **Help** property: Change this to `Opens a file...` text. This will display
    this text in the status bar whenever this option is selected by mouse cursor or
    keyboard.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助属性：将其更改为“打开文件...”文本。每当鼠标光标或键盘选择此选项时，将在状态栏中显示此文本。
- en: '![Rapid app development with wxSmith](img/3415OS_04_33.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![wxSmith快速应用程序开发](img/3415OS_04_33.jpg)'
- en: Click on the **OK** button to close this window. We have now added a menu option
    to our existing menu bar. Before we add code to open a file with this menu option
    we need to add a file open save control.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**确定**按钮关闭此窗口。我们现在已经向现有菜单栏添加了一个菜单选项。在我们添加代码以使用此菜单选项打开文件之前，我们需要添加一个文件打开保存控件。
- en: Click on the **Dialogs** tab and then click on the **wxFileDialog** control
    button. This will add a standard file open and save dialog to the `MyNotePadFrame`
    class.![Rapid app development with wxSmith](img/3415OS_04_34.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**对话框**选项卡，然后单击**wxFileDialog**控件按钮。这将向`MyNotePadFrame`类添加一个标准的文件打开和保存对话框。![wxSmith快速应用程序开发](img/3415OS_04_34.jpg)
- en: 'Change the following properties in property window:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性窗口中更改以下属性：
- en: '**Wildcard** to `*.txt`. This will set the filter text to files with `.txt`
    extension.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**通配符**更改为`*.txt`。这将将过滤文本设置为具有`.txt`扩展名的文件。
- en: '**Var name** to `NotePadFileDialog`. This will be used to create an object
    of the `wxFileDialog` class that represents a standard open or save dialog.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**变量名**更改为`NotePadFileDialog`。这将用于创建`wxFileDialog`类的对象，该对象表示标准的打开或保存对话框。
- en: '![Rapid app development with wxSmith](img/3415OS_04_35.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![wxSmith快速应用程序开发](img/3415OS_04_35.jpg)'
- en: Now we are set to add code to newly added menu option. Click on the **&Open**
    item in the resource tree and then click on the **{}** button in property window.
    Click on the dropdown box and choose the **-- Add new handler --** menu option
    as in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_36.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备添加代码到新添加的菜单选项。单击资源树中的**&Open**项目，然后单击属性窗口中的**{}**按钮。单击下拉框，选择如下屏幕截图中的**--添加新处理程序--**菜单选项：![wxSmith快速应用程序开发](img/3415OS_04_36.jpg)
- en: Enter `OnFileOpen` text in the dialog box and then click on the **OK** button,
    as shown in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_37.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中输入`OnFileOpen`文本，然后单击**确定**按钮，如下屏幕截图所示：![wxSmith快速应用程序开发](img/3415OS_04_37.jpg)
- en: Code editor window will be open. Add the following code to the `MyNotePadFrame::OnFileOpen()`
    function.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码编辑器窗口将打开。将以下代码添加到`MyNotePadFrame::OnFileOpen()`函数中。
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's explain preceding code. We have defined couple of variables in the beginning.
    We are showing file open dialog using the `ShowModal()` function and result of
    this dialog will be stored inside the `result` variable. Next line checks that
    we have received a `wxID_OK` value, which indicates that user has selected a file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释前面的代码。我们在开头定义了一对变量。我们使用`ShowModal()`函数显示文件打开对话框，此对话框的结果将存储在`result`变量中。下一行检查我们是否收到了`wxID_OK`值，这表示用户已选择了一个文件。
- en: We are opening a text file in using the `Open()` function with the filename
    received from dialog box. If file opening succeeds then we'll create a loop to
    read all lines one by one. The `fileContent` variable appends a line read from
    file and then appends a new line (`\r\n` on Windows) to this string. When we are
    done reading all lines opened text file is closed with the `Close()` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Open()`函数打开文本文件，并使用从对话框中接收的文件名。如果文件打开成功，那么我们将创建一个循环逐行读取所有行。`fileContent`变量附加从文件中读取的行，然后附加一个新行（在Windows上为`\r\n`）到此字符串。当我们完成读取所有行时，打开的文本文件将使用`Close()`函数关闭。
- en: Finally we set text stored inside `fileContent` variable is stored to our main
    text control.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将存储在`fileContent`变量中的文本存储到我们的主文本控件中。
- en: 'We also need to include an extra header file in order to use the `wxTextFile`
    class. Add the following line after the `#include <wx/msgdlg.h>` line in the `MyNotePadMain.cpp`
    file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要包含一个额外的头文件，以便使用`wxTextFile`类。在`MyNotePadMain.cpp`文件的`#include <wx/msgdlg.h>`行之后添加以下行：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are now ready to compile our little notepad app. Hit *F9* key to build and
    run it. Our app will look similar to the following screenshot:![Rapid app development
    with wxSmith](img/3415OS_04_38.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备编译我们的小记事本应用程序。按下*F9*键进行构建和运行。我们的应用程序将类似于以下屏幕截图：![wxSmith快速应用程序开发](img/3415OS_04_38.jpg)
- en: Go to **File** | **Open** menu option and following dialog box will be opened:![Rapid
    app development with wxSmith](img/3415OS_04_39.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**文件** | **打开**菜单选项，将打开以下对话框：![wxSmith快速应用程序开发](img/3415OS_04_39.jpg)
- en: Click on the **Open** button and the selected text file will now be opened by
    our app, as shown in the following screenshot:![Rapid app development with wxSmith](img/3415OS_04_40.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Open**按钮，我们的应用程序现在将打开所选的文本文件，如下面的屏幕截图所示：![Rapid app development with wxSmith](img/3415OS_04_40.jpg)
- en: Our app is now working! We wrote most of our GUI related code with the help
    of Code::Blocks. Only code that was manually written was the one we have inserted
    to open a text file. Code::Blocks offers an excellent cross-platform and rapid
    application development platform. We can develop a GUI app with Code::Blocks easily
    using this approach.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在可以工作了！我们在Code::Blocks的帮助下编写了大部分与GUI相关的代码。唯一手动编写的代码是我们插入的用于打开文本文件的代码。Code::Blocks提供了一个出色的跨平台和快速应用程序开发平台。我们可以使用这种方法轻松地在Code::Blocks中开发GUI应用程序。
- en: Exercise
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We have learned and developed our own notepad app in the previous section. However,
    our app was limited to opening a file. In this exercise we will extend our app
    to save a text file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习并开发了我们自己的记事本应用程序。但是，我们的应用程序仅限于打开文件。在这个练习中，我们将扩展我们的应用程序以保存文本文件。
- en: 'We''ll perform the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下步骤：
- en: Add a menu item `&Save` to file menu after `&Open` menu option, with `Ctrl+S`
    as keyboard accelerator, `idFileSave` as ID and `Saves a file...` as Help text.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`&Open`菜单选项后的文件菜单中添加一个菜单项`&Save`，使用`Ctrl+S`作为键盘加速器，`idFileSave`作为ID，`Saves
    a file...`作为帮助文本。
- en: Add an event handler to this menu option and add event handler function `OnFileSave()`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此菜单选项添加事件处理程序，并添加事件处理程序函数`OnFileSave()`。
- en: 'Finally add the following code to the `MyNotePadFrame::OnFileSave()` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到`MyNotePadFrame::OnFileSave()`函数中：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is similar to the code we wrote for the `OnFileOpen()` function. We
    are using the `wxTextCtrl::FileSave()` function to save our file in line number
    `5`. Code in line number `6` ensures that an error message should be shown when
    a file can't be written.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于我们为`OnFileOpen()`函数编写的代码。我们使用`wxTextCtrl::FileSave()`函数在第5行保存我们的文件。第6行的代码确保在无法写入文件时显示错误消息。
- en: I leave it to you to follow earlier steps and complete this exercise. You can
    refer accompanying MyNotePad app source code for this completed exercise.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它留给你来按照之前的步骤并完成这个练习。您可以参考附带的MyNotePad应用程序源代码来完成此练习。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have learned app development for Windows using Win32 api
    and Code::Blocks. We then focused on GUI toolkit and developed our first app for
    Windows and Linux using wxWidgets toolkit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用Win32 api和Code::Blocks在Windows上开发应用程序。然后，我们专注于GUI工具包，并使用wxWidgets工具包在Windows和Linux上开发了我们的第一个应用程序。
- en: Code::Blocks also has a rapid application development toolkit and we used it
    to develop our own Notepad app.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks还具有快速应用程序开发工具包，我们使用它来开发我们自己的记事本应用程序。
- en: In the next chapter we'll take one app and learn how to plan and develop it
    from scratch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将选择一个应用程序，并学习如何从头开始规划和开发它。
