- en: '*Chapter 6*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*'
- en: Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Lesson Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够：
- en: Compose classes that inherit properties from other classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合继承其他类属性的其他类
- en: Implement polymorphism in C++ programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 程序中实现多态。
- en: Implement interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Use best practices to manage dynamic memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最佳实践来管理动态内存
- en: In this chapter, you will learn how to use the advanced features of C++ to create
    dynamic programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 C++ 的高级特性来创建动态程序。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: In earlier chapters, we learned about templates that are used to create functions
    and classes that work with arbitrary types. This avoids duplication of work. However,
    using templates is not applicable in all cases, or may not be the best approach.
    The limitation of templates is that their types need to be known when the code
    is compiled.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了模板，它用于创建与任意类型一起工作的函数和类。这避免了工作重复。然而，在所有情况下使用模板并不适用，或者可能不是最佳方法。模板的限制是它们的类型需要在代码编译时已知。
- en: In real-world cases, this is not always possible. A typical example would be
    a program that determines what logging infrastructure to use depending on the
    value of a configuration file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的案例中，这并不总是可能的。一个典型的例子是程序根据配置文件中的值确定要使用什么日志基础设施。
- en: 'Consider the following problems:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：
- en: While developing the application and executing tests, the application would
    use a logger that prints detailed information.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发和执行测试应用程序时，应用程序会使用一个打印详细信息的记录器。
- en: On the other hand, when the application is deployed to the PCs of its users,
    the application would use a logger that prints **error summaries** and notifies
    the developers if there are any errors.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，当应用程序部署到用户的 PC 上时，应用程序会使用一个打印**错误摘要**并通知开发者的记录器，如果有任何错误。
- en: We can solve these problems using the concept of inheritance in C++.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 C++ 继承的概念来解决这些问题。
- en: Inheritance
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance allows the combination of one or more classes. Let''s look at an
    example of inheritance:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许组合一个或多个类。让我们看看继承的一个例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `Car` class inherits from the `Vehicle` class, or, we can
    say `Car` derives from `Vehicle`. In C++ terminology, `Vehicle` is the *base*
    class, and `Car` is the *derived* class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Car` 类继承自 `Vehicle` 类，或者说 `Car` 从 `Vehicle` 继承。在 C++ 术语中，`Vehicle` 是*基*类，而
    `Car` 是*派生*类。
- en: 'When defining a class, we can specify the classes it derives from by appending
    `:`, followed by one or more classes, separated by a comma:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个类时，我们可以通过在后面跟一个冒号 `:`，然后跟一个或多个用逗号分隔的类来指定它继承的类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When specifying the list of classes to derive from, we can also specify the
    visibility of the inheritance – `private`, `protected`, or `public`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定要继承的类列表时，我们还可以指定继承的可见性 – `private`、`protected` 或 `public`。
- en: The visibility modifier specifies who can know about the inheritance relationship
    between the classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性修饰符指定谁可以了解类之间的继承关系。
- en: 'The methods of the base class can be accessed as methods of the derived class
    based on the following rules:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基类的方法可以根据以下规则作为派生类的方法访问：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the inheritance is `public`, the code external to the class knows that
    `Car` derives from `Vehicle`. All the public methods of the base class are accessible
    as *public* method of the derived class by the code in the program. The protected
    methods of the base class can be accessed as *protected* by the methods of the
    derived class. When inheritance is `protected`, all the public and protected members
    are accessible as *protected* by the derived class. Only the derived class and
    classes that derive from it know about inheritance; external code sees the two
    classes as unrelated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当继承是 `public` 时，类外部的代码知道 `Car` 继承自 `Vehicle`。基类的所有公共方法都可以作为派生类的*公共*方法被程序中的代码访问。基类的受保护方法可以通过派生类的方法作为*受保护*访问。当继承是
    `protected` 时，所有公共和受保护成员都可以作为派生类的*受保护*访问。只有派生类及其从它派生的类知道关于继承的信息；外部代码看到这两个类是无关的。
- en: Finally, when deriving with a `private` modifier, all the `public` and `protected`
    methods and fields of the base class are accessible by the derived class as `private`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用 `private` 修饰符进行继承时，基类的所有 `public` 和 `protected` 方法字段都可以由派生类作为 `private`
    访问。
- en: The private methods and fields of a class are *never accessible* outside of
    that class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的私有方法和字段在该类外部*永远不可访问*。
- en: Accessing the fields of the base class follows the same rules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 访问基类的字段遵循相同的规则。
- en: 'Let''s see a summary:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个总结：
- en: '![](img/C11557_06_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C11557_06_01.jpg)'
- en: 'Figure 6.1: Base class methods and the access level they provide'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.1：基类方法和它们提供的访问级别
- en: Inheritance creates a hierarchy of derived and base classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 继承创建了一个派生类和基类的层次结构。
- en: 'The `Orange` class can be derived from a `Citrus` class, which is in turn derived
    from a `Fruit` class. Here is how it can be written:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Orange` 类可以从 `Citrus` 类派生，而 `Citrus` 类又从 `Fruit` 类派生。以下是它的写法：'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The class `Citrus` can access the public and protected methods of class `Fruit`,
    whereas class `Orange` will be able to access both `Citrus`' and `Fruit`'s public
    and protected methods (`Fruit`'s public methods are accessible through `Citrus`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Citrus` 可以访问类 `Fruit` 的公共和受保护方法，而类 `Orange` 将能够访问 `Citrus` 和 `Fruit` 的公共和受保护方法（`Fruit`
    的公共方法可以通过 `Citrus` 访问）。
- en: 'Exercise 20: Creating a Program to Illustrate Inheritance in C++'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 20：创建一个演示 C++ 继承的程序
- en: 'Let''s perform the following exercise to create a derived class that inherits
    from multiple base classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行以下练习，创建一个从多个基类继承的派生类：
- en: 'Add the header file at the start of the program:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始处添加头文件：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the first base class, named `Vehicle`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个基类，命名为 `Vehicle`：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now add the second base class, named `CollectorItem`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加第二个基类，命名为 `CollectorItem`：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the derived class, named `Ferrari250GT`, as illustrated here:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为 `Ferrari250GT` 的派生类，如图所示：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, in the `main` function, instantiate the `Ferrari250GT` class and call
    the `getValue()` method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `main` 函数中，实例化 `Ferrari250GT` 类并调用 `getValue()` 方法：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output will be as follows:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The specifier is not mandatory. If it is omitted, it defaults to *public for
    structs* and to *private for classes*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 指定符不是强制的。如果省略，则对于结构体默认为 *public*，对于类默认为 *private*。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you use inheritance to group together some functionality when implementing
    a class, it is often correct to use **private inheritance**, as that is a detail
    of how you are implementing the class, and it is not part the **public interface**
    of the class. If, instead, you want to write a derived class that can be used
    in place of the base class, use public inheritance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用继承来在实现类时组合一些功能，通常正确的是使用**私有继承**，因为这是你实现类的细节，并且它不是类的一部分**公共接口**。相反，如果你想编写一个可以作为基类使用的派生类，请使用公共继承。
- en: 'When inheriting from a class, the base class gets **embedded** into the derived
    class. This means that all the data of the base class also becomes part of the
    derived class in its **memory representation**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当从类继承时，基类会被**嵌入**到派生类中。这意味着基类的所有数据也成为了派生类在它的**内存表示**中的一部分：
- en: '![Figure 6.2: Representation of the derived class and the base class](img/C11557_06_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：派生类和基类的表示](img/C11557_06_02.jpg)'
- en: 'Figure 6.2: Representation of the derived class and the base class'
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6.2：派生类和基类的表示
- en: A question might come up at this point – we are embedding the base class inside
    the derived class. This means that we need to initialize the base class when we
    initialize the derived class, otherwise, part of the class would be left uninitialized.
    When do we initialize the base class?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能会出现一个问题——我们在派生类中嵌入基类。这意味着我们需要在初始化派生类时初始化基类，否则类的一部分将保持未初始化状态。我们何时初始化基类？
- en: When writing the constructor of the derived class, the compiler will implicitly
    call the default constructor of the base class before any initialization takes
    place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写派生类的构造函数时，编译器会在任何初始化之前隐式调用基类的默认构造函数。
- en: If the base class does not have a default constructor but has a constructor
    that accepts parameters, then the derived class constructor can explicitly call
    it in the initialization list. Otherwise, there will be an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基类没有默认构造函数，但有一个接受参数的构造函数，那么派生类的构造函数可以在初始化列表中显式调用它。否则，将出现错误。
- en: 'In a similar way to how the compiler calls the constructor of the base class
    when the derived class is constructed, the compiler takes care of always calling
    the destructor of the base class after the destructor of the derived class has
    run:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与编译器在构造派生类时调用基类的构造函数类似，编译器会在派生类的析构函数运行后始终调用基类的析构函数：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When `B`''s constructor is called, the `A` needs to be initialized. Since `A`
    doesn''t have a default constructor, the compiler cannot initialize it for us:
    we have to call `A`''s constructor explicitly.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`B`类的构造函数时，需要初始化`A`。由于`A`没有默认构造函数，编译器无法为我们初始化它：我们必须显式调用`A`类的构造函数。
- en: The **copy constructor** and the **assignment operator** generated by the compiler
    take care of calling the constructor and operator of the base class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的**复制构造函数**和**赋值运算符**负责调用基类的构造函数和运算符。
- en: When, instead, we write our implementation of the copy constructor and the assignment
    operators, we need to take care of calling the copy constructor and assignment
    operator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写自己的复制构造函数和赋值运算符的实现时，我们需要注意调用复制构造函数和赋值运算符。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In many compilers, you can enable additional warnings that notify you if you
    forget to add the calls to the base constructor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编译器中，你可以启用额外的警告，这些警告会在你忘记添加对基构造函数的调用时通知你。
- en: It is important to understand that inheritance needs to model an `A` to inherit
    from another class, `B`, you are saying that `A` `B`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，继承需要模型一个`A`从另一个类`B`继承，你是在说`A`是`B`。
- en: 'To understand this, a vehicle is a good example: a car is a vehicle, a bus
    is a vehicle, and a truck is also a vehicle. A bad example would be for a car
    to inherit from an engine. While the engine might have similar functionality to
    a car, such as a `start` method, it is wrong to say that a car is an engine. The
    relationship, in this case, is **has a**: the car has an engine; this relationship
    represents composition.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，一个车辆是一个很好的例子：汽车是一种车辆，公共汽车是一种车辆，卡车也是一种车辆。一个不好的例子是汽车继承自发动机。虽然发动机可能具有与汽车相似的功能，例如`start`方法，但说汽车是发动机是不正确的。在这种情况下，关系是**has
    a**：汽车有一个发动机；这种关系表示组合。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using an **is a** test to understand whether a relationship can use inheritance
    can fail in some cases: for example, a **square** inheriting from a **rectangle**.
    When the width of the rectangle is doubled, the area of the rectangle doubles,
    but the area of the square quadruples. This means that code that expects to interact
    with rectangles might get surprising results when using a square, even if the
    square, mathematically, is a rectangle.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**is a**测试来理解是否可以使用继承来表示关系在某些情况下可能会失败：例如，一个**正方形**继承自一个**矩形**。当矩形的宽度加倍时，矩形的面积加倍，但正方形的面积会四倍增加。这意味着当使用正方形时，预期与矩形交互的代码可能会得到令人惊讶的结果，即使从数学上讲，正方形是一个矩形。
- en: A more general rule is to use the `A` class inherits from `B`, we could replace
    the `A` class anywhere the `B` class is used, and the code would still behave
    correctly.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更一般的规则是，如果`A`类继承自`B`类，我们可以在`B`类被使用的地方替换`A`类，代码仍然可以正确运行。
- en: 'Up to now, we have seen examples of single inheritance: a derived class has
    a single base class. C++ supports multiple inheritance: a class can derive from
    multiple classes. Let''s look at an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了单重继承的例子：派生类有一个基类。C++支持多重继承：一个类可以继承自多个类。让我们看看一个例子：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the `C` struct derives both from `A` and from `B`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`C`结构体同时从`A`和`B`继承。
- en: 'The rules on how inheritance works are the same for single and multiple inheritance:
    the methods of all the derived classes are visible based on the visibility access
    specified, and we need to make sure to call the appropriate constructors and assign
    an operator for all of the base classes.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 继承如何工作的规则对单重继承和多重继承是相同的：所有派生类的所有方法都基于指定的可见性访问权限可见，我们需要确保为所有基类调用适当的构造函数和赋值运算符。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is usually best to have a shallow inheritance hierarchy: there should not
    be many levels of derived classes.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好有一个浅层继承层次结构：不应该有太多的派生类层次。
- en: When using a multi-level inheritance hierarchy or multiple inheritance, it's
    more likely that you'll encounter some problems, such as **ambiguous calls**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多层继承层次结构或多重继承时，你可能会遇到一些问题，例如**模糊调用**。
- en: 'A call is ambiguous when the compiler cannot clearly understand which method
    to call. Let''s explore the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器无法清楚地理解要调用哪个方法时，调用是模糊的。让我们看看以下示例：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, it is not clear which `foo()` to call, `A`''s or `B`''s. We
    can disambiguate that by prepending the name of the class followed by two columns:
    `A::foo()`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，不清楚要调用哪个`foo()`，是`A`类的还是`B`类的。我们可以通过在类名前加上两个冒号来消除歧义：`A::foo()`。
- en: 'Exercise 21: Using Multiple Inheritance to Create a "Welcome to the Community"
    Message Application'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：使用多重继承创建“欢迎加入社区”消息应用程序
- en: 'Let''s use multiple inheritance to create an application to print a "welcome
    to the community" message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用多重继承来创建一个打印“欢迎加入社区”消息的应用程序：
- en: 'First, add the required header files in the program, as illustrated:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在程序中添加所需的头文件，如图所示：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, add the required classes, `DataScienceDev` and `FutureCppDev`, with the
    required print statement:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加所需的类`DataScienceDev`和`FutureCppDev`以及所需的打印语句：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the `Student` class as illustrated here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加如上图所示的`Student`类：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, invoke the `Student` class in the `main` function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中调用`Student`类：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output will be as follows:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Activity 23: Creating Game Characters'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动23：创建游戏角色
- en: We want to write a new game, and in that game, create two types of characters
    – a hero and enemies. Enemies can swing their swords, and the hero can cast a
    spell.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想编写一个新游戏，并在该游戏中创建两种类型的角色——英雄和敌人。敌人可以挥舞剑，而英雄可以施展法术。
- en: 'Here is how you can achieve the task:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何完成任务的方法：
- en: Create a `Character` class that has a public method, `moveTo`, that prints `Moved
    to position`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有公共方法`moveTo`的`Character`类，该方法打印`Moved to position`。
- en: 'Create a `Position` struct:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Position`结构体：
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create two classes, `Hero` and `Enemy`, that are derived from the Character
    class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个类，`Hero`和`Enemy`，它们从`Character`类派生：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `Spell` class with the constructor that takes the name of the spell:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有接受法术名称构造函数的`Spell`类：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Hero` class should have a `public` method to cast a spell. Use the value
    from the `Spell` class.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Hero`类应该有一个`public`方法来施展法术。使用`Spell`类的值。'
- en: The `Enemy` class should have a `public` method to swing a sword, which prints
    `Swinging sword`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Enemy`类应该有一个`public`方法来挥舞剑，这将打印`Swinging sword`。'
- en: 'Implement the main method, which calls these methods in various classes:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现主方法，该方法在各个类中调用这些方法：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 309.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第309页找到。
- en: Polymorphism
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: In the previous section, we mentioned that inheritance is a solution that allows
    you to change the behavior of code while a program is running. This is because
    inheritance enables polymorphism in C++.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到继承是一种允许你在程序运行时更改代码行为的解决方案。这是因为继承使C++具有多态性。
- en: '**Polymorphism** means *many forms* and represents the ability of objects to
    behave in different ways.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态性**意味着*多种形式*，表示对象能够以不同的方式行为。'
- en: We mentioned earlier that templates are a way to write code that works with
    many different types at compilation time and, depending on the types used to instantiate
    the template, the behavior will change.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，模板是在编译时与许多不同类型一起工作的代码的方式，并且根据用于实例化模板的类型，行为将发生变化。
- en: This kind of pattern is called **static polymorphism** – static because it is
    known during compilation time. C++ also supports **dynamic polymorphism** – having
    the behavior of methods change while the program is running. This is powerful
    because we can react to information we obtain only after we have compiled our
    program, such as user input, values in configurations, or the kind of hardware
    the code is running on. This is possible thanks to two features – **dynamic binding**
    and **dynamic dispatch**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为**静态多态性**——静态是因为它在编译时已知。C++也支持**动态多态性**——在程序运行时方法的行为可以改变。这很强大，因为我们可以在编译程序之后仅对获得的信息做出反应，例如用户输入、配置中的值或代码运行的硬件类型。这要归功于两个特性——**动态绑定**和**动态分派**。
- en: Dynamic Binding
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态绑定
- en: '**Dynamic binding** is the ability for a reference or a pointer of a base type
    to point to an object of a derived type at runtime. Let''s explore the following
    example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态绑定**是指基类型引用或指针在运行时指向派生类型对象的能力。让我们探索以下示例：'
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To allow dynamic binding, the code must *know* that the derived class derives
    from the base class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许动态绑定，代码必须*知道*派生类从基类派生。
- en: If the inheritance's visibility is `private`, then only code inside the derived
    class will be able to bind the object to a *pointer* or *reference* of the base
    class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继承的可见性是`private`，则只有派生类中的代码能够将对象绑定到基类的*指针*或*引用*。
- en: If the inheritance is `protected`, then the derived class and every class deriving
    from it will be able to perform dynamic binding. Finally, if the inheritance is
    `public`, the dynamic binding will always be *allowed*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继承是`protected`，那么派生类以及从它派生的所有类都将能够执行动态绑定。最后，如果继承是`public`，动态绑定将始终被*允许*。
- en: This creates the distinction between the `static` type and the `dynamic` (or
    run-time) type. The static type is the type we can see in the source code. In
    this case, we can see that `ref1` has a static type of a reference to the `A`
    struct.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`static`类型和`dynamic`（或运行时）类型之间创建了区别。静态类型是我们可以在源代码中看到的类型。在这种情况下，我们可以看到`ref1`的静态类型是`A`结构的引用。
- en: 'The dynamic type is the real type of the object: the type that has been constructed
    in the object''s memory location at runtime. For example, the static type of both
    `ref1` and `ref2` is a reference to the `A` struct, but the `ref1` dynamic type
    is `B`, since `ref1` refers to a memory location in which an object of type `B`
    has been created, and the `ref2` dynamic type is `C` for the same reason.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型是对象的实际类型：在运行时在对象的内存位置上构建的类型。例如，`ref1`和`ref2`的静态类型都是`A`结构的引用，但`ref1`的动态类型是`B`，因为`ref1`指向一个在内存位置上创建了类型为`B`的对象的内存位置，而`ref2`的动态类型是`C`，原因相同。
- en: 'As said, the dynamic type can change at runtime. While the static type of a
    variable is always the same, its dynamic type can change: `ptr` has a static type,
    which is a pointer to `A`, but its dynamic type could change during the execution
    of the program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所说，动态类型可以在运行时改变。虽然变量的静态类型始终相同，但其动态类型可以改变：`ptr`有一个静态类型，即指向`A`的指针，但它的动态类型在程序执行过程中可能会改变：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is important to understand that only references and pointers can be assigned
    values from a derived class safely. If we were to assign an object to a value
    type, we would get a surprising result – the object would get sliced.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，只有引用和指针可以从派生类安全地赋值。如果我们将对象赋值给值类型，我们会得到一个令人惊讶的结果 - 对象会被切割。
- en: 'We said earlier that a base class is **embedded** inside a derived class. Say,
    for example, we were to try and assign to a value, like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，基类是**嵌入**在派生类中的。比如说，如果我们尝试赋值，就像这样：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code would compile, but only the embedded part of `A` inside of `B` would
    be copied – when we declare a variable of type `A`, the compiler dedicates an
    area of the memory big enough to contain an object of type `A`, so there cannot
    be enough space for `B`. When this happens, we say that we sliced the object,
    as we took only a part of the object when assigning or copying.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将编译，但只有`B`中嵌入的`A`的部分将被复制 - 当我们声明一个类型为`A`的变量时，编译器分配一个足够大的内存区域来容纳类型为`A`的对象，因此没有足够的空间来容纳`B`。当这种情况发生时，我们说我们切割了对象，因为我们赋值或复制时只取了对象的一部分。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is not the intended behavior to slice the object. Be mindful of this interaction
    and try to avoid it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 切割对象不是预期的行为。请注意这种交互，并尽量避免它。
- en: 'This behavior happens because C++ uses *static dispatch* by default for function
    and method calls: when the compiler sees a method call, it will check the static
    type of the variable on which the method is called, and it will execute the `A`
    is called, and it only copies the part of `A` inside `B`, ignoring the remaining
    fields.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为发生是因为C++默认使用*静态调度*进行函数和方法调用：当编译器看到方法调用时，它会检查被调用方法变量的静态类型，并且它将执行`A`被调用，并且它只复制`A`中`B`内部的这部分，忽略剩余的字段。
- en: 'As said before, C++ supports dynamic dispatch. This is done by marking a method
    with a special keyword: **virtual**.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C++支持动态调度。这是通过使用特殊关键字标记方法来完成的：**virtual**。
- en: If a method is marked with the `virtual` keyword, when the method is called
    on a *reference* or a *pointer*, the compiler will execute the implementation
    of the dynamic type instead of the static type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法被标记为`virtual`关键字，当在*引用*或*指针*上调用该方法时，编译器将执行动态类型的实现而不是静态类型。
- en: 'These two features enable *polymorphism* – we can write a function that accepts
    a reference to a base class, call methods on this base class, and the methods
    of the derived classes will be executed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性实现了*多态性* - 我们可以编写一个接受基类引用的函数，调用这个基类的方法，并且派生类的方法将被执行：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then call the function with many different types of vehicles, and the
    appropriate methods will be executed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用许多不同类型的车辆调用该函数，并且将执行适当的方法：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A typical pattern is to create an interface that only specifies the methods
    that are required for some functionality.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的模式是创建一个接口，它只指定了实现某些功能所需的方法。
- en: Classes that need to be used with such functionality must derive the interface
    and implement all the required methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用这种功能的功能类必须继承接口并实现所有必需的方法。
- en: Virtual Methods
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟方法
- en: We've learned the advantages of dynamic dispatch in C++ and how it can enable
    us to execute the methods of a derived class by calling a method on a reference
    or pointer to a base class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了C++中动态分发的优势以及它是如何使我们能够通过在基类的引用或指针上调用方法来执行派生类的方法。
- en: In this section, we will take an in-depth look at how to tell the compiler to
    perform dynamic dispatch on a method. The way to specify that we want to use dynamic
    dispatch for a method is to use the `virtual` keyword.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解如何告诉编译器在方法上执行动态分发。指定我们想要为方法使用动态分发的方式是使用`virtual`关键字。
- en: 'The `virtual` keyword is used in front of a method when declaring it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明方法时，在方法前使用`virtual`关键字：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We need to remember that the compiler decides how to perform method dispatch
    based on the static type of the variable that is used when calling the method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，编译器根据调用方法时使用的变量的静态类型来决定如何执行方法分发。
- en: This means that we need to apply the virtual keyword to the type we are using
    in the code. Let's examine the following exercise to explore the virtual keyword.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要将虚拟关键字应用于代码中使用的类型。让我们检查以下练习来探索虚拟关键字。
- en: 'Exercise 22: Exploring the Virtual Method'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 22：探索虚拟方法
- en: 'Let''s create a program using the concept of inheritance using the virtual
    keyword:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用虚拟关键字的继承概念的程序：
- en: First, make sure to add the required header file and namespace to compile the
    program.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保添加所需的头文件和命名空间以编译程序。
- en: 'Now, add the `Vehicle` class as illustrated:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如所示添加`Vehicle`类：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `Car` class, add the `virtual` keyword as illustrated :'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car`类中，如所示添加`virtual`关键字：
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in the main function, invoke the `Car` class and pass the `car` object
    in the `myTurnOn()` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数中，调用`Car`类并在`myTurnOn()`函数中传递`car`对象：
- en: '[PRE31]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output will be as follows:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE32]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the call will not be dynamically dispatched, and the call to the implementation
    of `Vehicle::turnOn()` will be executed. The reason is that the static type of
    the variable is `Vehicle`, and we did not mark the method as `virtual`, so the
    compiler uses static dispatch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，调用不会进行动态分发，而是会执行`Vehicle::turnOn()`的实现。原因是变量的静态类型是`Vehicle`，我们没有将方法标记为`virtual`，所以编译器使用静态分发。
- en: The fact that we wrote a `Car` class that declares the method virtual is not
    important, since the compiler only sees the `Vehicle` class being used in `myTurnOn()`.
    When a method is declared `virtual`, we can override it in a derived class.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个声明方法为虚拟的`Car`类的事实并不重要，因为编译器只看到了在`myTurnOn()`中使用`Vehicle`类。当方法被声明为`virtual`时，我们可以在派生类中重写它。
- en: 'To override a method, we need to declare it with the same signature as the
    parent class: the same return type, name, parameters (including `const`-ness and
    `ref`-ness), `const` qualifier, and the other attributes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写方法，我们需要使用与父类相同的签名声明它：相同的返回类型、名称、参数（包括`const`-性、`ref`-性），`const`限定符和其他属性。
- en: 'If the signature does not match, we will create an overload for the function.
    The overload will be callable from the derived class, but it will never be executed
    with a dynamic dispatch from a base class, for example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名不匹配，我们将为函数创建一个重载。重载可以从派生类中调用，但它永远不会从基类进行动态分发，例如：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a class overrides a virtual method of the base class, the method of the
    *most derived class* will be executed when the method is called on a base class.
    This is `true` even if the method is called from inside the base class, for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类重写基类的虚拟方法时，当在基类上调用该方法时，将执行*最派生类*的方法。即使该方法是从基类内部调用的，这也是`true`，例如：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see a new keyword in the preceding example: the `override` keyword.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到一个新关键字：`override`关键字。
- en: C++11 introduced this keyword to enable us to specify that we are overriding
    a method explicitly. This allows the compiler to give us an error message if we
    use the `override` keyword, but the signature does not match any base class' virtual
    method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了这个关键字，使我们能够显式地指定我们正在重写一个方法。这允许编译器在我们使用`override`关键字但签名与基类的任何虚拟方法不匹配时给出错误信息。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Always use the `override` keyword when you are overriding a method. It is easy
    to change the signature of the base class and forget to update all the locations
    where we overrode the method. If we do not update them, they will become a new
    overload instead of an override!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重写一个方法时，始终使用`override`关键字。很容易更改基类的签名并忘记更新我们重写方法的所有位置。如果我们不更新它们，它们将变成一个新的重载而不是重写！
- en: In the example, we also used the `virtual` keyword for each function. This is
    not necessary, since a virtual method on a base class makes every method with
    the same signature in the derived classes virtual as well.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们也为每个函数使用了`virtual`关键字。这并非必要，因为基类上的虚拟方法会使派生类中具有相同签名的每个方法也变为虚拟方法。
- en: It is good to be explicit `virtual` keyword, but if we are already using the
    `override` keyword, it might be redundant – in these cases, the best way is to
    follow the coding standard of the project you are working on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 明确使用`virtual`关键字是好的，但如果我们已经使用了`override`关键字，它可能就多余了——在这些情况下，最好的方式是遵循你正在工作的项目的编码标准。
- en: The `virtual` keyword can be applied to any method. Since the constructor is
    not a method, the constructor cannot be marked as virtual. Additionally, dynamic
    dispatch is disabled inside constructors and destructors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`关键字可以应用于任何方法。由于构造函数不是方法，因此构造函数不能被标记为虚拟。此外，在构造函数和析构函数内部禁用动态分派。'
- en: The reason is that when constructing a hierarchy of derived classes, the constructor
    of the base class is executed before the constructor of the derived class. This
    means that if we were to call the virtual method on the derived class when constructing
    the base class, the derived class would not be initialized yet.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于，当构建派生类的层次结构时，基类的构造函数会在派生类的构造函数之前执行。这意味着如果我们试图在构建基类时调用派生类的虚拟方法，派生类尚未初始化。
- en: Similarly, when calling the destructor, the destructors of the whole hierarchy
    are executed in reverse order; first the derived and then the base class. Calling
    a `virtual` method in the destructor would call the method on a derived class
    that has already been destructed, which is an error.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当调用析构函数时，整个层次结构的析构函数会按相反的顺序执行；首先调用派生类，然后是基类。在析构函数中调用虚拟方法将调用已经析构的派生类的该方法，这是错误的。
- en: While the constructor cannot be marked as virtual, the destructor can. If a
    class defines a virtual method, then it should also declare a virtual destructor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构造函数不能被标记为虚拟，但析构函数可以。如果一个类定义了一个虚拟方法，那么它也应该声明一个虚拟析构函数。
- en: Declaring a destructor virtual is extremely important when classes are created
    on dynamic memory, or the heap. We are going to see later in this chapter how
    to manage dynamic memory with classes, but for now, it is important to know that
    if a destructor is not declared virtual, then an object might be only partially
    destructed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当在动态内存或堆上创建类时，声明析构函数为虚拟非常重要。我们将在本章后面看到如何使用类管理动态内存，但到目前为止，重要的是要知道，如果析构函数没有被声明为虚拟，那么一个对象可能只被部分析构。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If a method is marked virtual, then the destructor should also be marked virtual.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法被标记为虚拟，那么析构函数也应该被标记为虚拟。
- en: 'Activity 24: Calculating Employee Salaries'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动24：计算员工工资
- en: We are writing a system to compute the paycheques for the employees of a company.
    Each employee has a base salary plus a bonus.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个系统来计算一家公司员工的工资。每位员工都有一个基本工资加上奖金。
- en: 'For employee who are not managers, the bonus is computed from the performance
    of the department: they get 10% of the base salary if the department reached its
    goal.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是经理的员工，奖金是根据部门的业绩计算的：如果部门达到了目标，他们将获得基本工资的10%。
- en: 'The company also has managers, for whom the bonus is computed in a different
    way: they get 20% of the base salary if the department reached its goal, plus
    1% of the difference between the achieved result of the department and the expected
    one.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司还有经理，他们的奖金计算方式不同：如果部门达到了目标，他们将获得基本工资的20%，加上部门实际成果与预期成果之间差异的1%。
- en: We want to create a function that takes an employee and computes their total
    salary, summing the base salary and the bonus, regardless of whether they are
    a manager or not.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要创建一个函数，它接受一个员工并计算他们的总工资，将基本工资和奖金相加，无论他们是否是经理。
- en: 'Perform the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'The Department class accepts the expected earning and the effective earning
    when constructed, and stores them in two fields:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当构造`Department`类时，它接受预期的收入和实际收入，并将它们存储在两个字段中：
- en: '[PRE35]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define an `Employee` class with two `virtual` functions, `getBaseSalary()`,
    and `getBonus()`. Within it, implement the logic for employee bonus calculation
    if the department goal is met:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有两个`virtual`函数`getBaseSalary()`和`getBonus()`的`Employee`类。在其中，实现如果部门目标达成，员工奖金计算的逻辑：
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create another function that provides the total compensation:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个提供总补偿的函数：
- en: '[PRE37]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a `Manager` class that derives from `Employee`. Again, create the same
    virtual functions, `getBaseSalary()` and `getBonus()`. Within it, implement the
    logic for a `Manager` bonus calculation if the department goal is met:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从`Employee`派生的`Manager`类。再次，创建相同的虚函数`getBaseSalary()`和`getBonus()`。在其中，实现如果部门目标达成，`Manager`奖金计算的逻辑：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the `main` program, and run the program:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现主程序，并运行程序：
- en: 'The output will be as follows:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 311.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第311页找到。
- en: Interfaces in C++
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的接口
- en: In the previous section, we saw how to define a method that is virtual, and
    how the compiler will do dynamic dispatch when calling it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何定义一个虚方法，以及编译器在调用它时将如何进行动态分派。
- en: We have also talked about interfaces throughout the chapter, but we never specified
    what an interface is.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中也讨论了接口，但我们从未指定接口是什么。
- en: An interface is a way for the code to specify a contract that the caller needs
    to provide to be able to call some functionality. We looked at an informal definition
    when talking about the templates and the requirements they impose on the types
    used with them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是代码指定调用者需要提供以能够调用某些功能的一种方式。我们在讨论模板及其对使用它们的类型所施加的要求时看到了一个非正式的定义。
- en: 'Functions and methods which accepts parameters as interface are a way of saying:
    in order to perform my actions, I need these functionalities; it''s up to you
    to provide them.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接受参数作为接口的函数和方法是一种说法：为了执行我的操作，我需要这些功能；这取决于你提供它们。
- en: To specify an interface in C++, we can use an **Abstract Base Class** (**ABC**).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中指定接口，我们可以使用**抽象基类**（**ABC**）。
- en: 'Let''s dive into the name; the class is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下这个名字；这个类是：
- en: '**Abstract**: This means that it cannot be instantiated'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：这意味着它不能被实例化'
- en: '**Base**: This means it is designed to be derived from'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基类**：这意味着它被设计为可以从中派生的'
- en: 'Any class that defines a pure virtual method is `abstract`. A pure virtual
    method is a virtual method that ends with `= 0`, for example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 任何定义了纯虚方法的类都是`抽象`的。纯虚方法是一个以`= 0`结尾的虚方法，例如：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A pure virtual method is a method that does not have to be defined. Nowhere
    in the previous code have we specified the implementation of `Vehicle::turnOn()`.
    Because of this, the `Vehicle` class cannot be instantiated, as we do not have
    any code to call for its pure virtual methods.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚方法是一个不需要定义的方法。在前面的代码中，我们没有任何地方指定`Vehicle::turnOn()`的实现。正因为如此，`Vehicle`类不能被实例化，因为我们没有为其纯虚方法提供任何可调用的代码。
- en: 'We can instead derive from the class and override the pure virtual method.
    If a class derives from an abstract base class, it can be either of the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从类中派生并覆盖纯虚方法。如果一个类从抽象基类派生，它可以是以下两种情况之一：
- en: Another abstract base class if it declares an additional pure virtual method,
    or if it does not override all the pure virtual methods of the base class
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它声明了额外的纯虚方法，或者如果没有覆盖基类的所有纯虚方法，则另一个抽象基类
- en: A regular class if it overrides all the pure virtual methods of the base class
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它覆盖了基类的所有纯虚方法，则是一个常规类
- en: 'Let''s continue with the previous example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续上一个例子：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, `Vehicle` is an abstract base class and `GasolineVehicle` is
    too, since it does not override all the pure virtual methods of `Vehicle`. It
    also defines an additional virtual method, which the `Car` class overrides together
    with the `Vehicle::turnOn()` method. This makes `Car` the only concrete class,
    a class that can be instantiated.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Vehicle`是一个抽象基类，`GasolineVehicle`也是，因为它没有覆盖`Vehicle`的所有纯虚方法。它还定义了一个额外的虚拟方法，`Car`类与`Vehicle::turnOn()`方法一起覆盖了这个方法。这使得`Car`成为唯一的具体类，一个可以实例化的类。
- en: 'The same concept applies when a class is deriving from multiple abstract base
    classes: all the pure virtual methods of all the classes that need to be overridden
    in order to make the class concrete and thus instantiable.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类从多个抽象基类派生时，同样的概念也适用：所有需要覆盖以使类具体并因此可实例化的类的纯虚方法。
- en: While abstract base classes cannot be instantiated, we can define references
    and pointers to them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然抽象基类不能被实例化，但我们可以定义它们的引用和指针。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to instantiate an abstract base class, the compiler will give an
    error specifying which methods are still pure virtual, thus making the class abstract.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试实例化一个抽象基类，编译器将给出错误，指定哪些方法仍然是纯虚的，从而使该类成为抽象的。
- en: Functions and methods that require specific methods can accept references and
    pointers to abstract base classes, and instances of concrete classes that derive
    from them can be bound to such references.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 需要特定方法的功能的函数和方法可以接受抽象基类的引用和指针，以及从它们派生的具体类的实例可以被绑定到这样的引用上。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice for the consumer of the interface to define the interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接口的消费者来说，定义接口是一种良好的实践。
- en: A function, method, or class that requires some functionality to perform its
    actions should define the interface. Classes that should be used with such entities
    should implement the interface.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 需要某些功能来执行其操作的函数、方法或类应该定义接口。应该与这些实体一起使用的类应该实现该接口。
- en: 'Since C++ does not provide a specialized keyword for defining interfaces and
    interfaces are simply abstract base classes, there are some guidelines that it''s
    best practice to follow when designing an interface in C++:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++没有提供专门的关键字来定义接口，而接口仅仅是抽象基类，因此在C++中设计接口时，有一些最佳实践指南需要遵循：
- en: An abstract base class should *not* have any data members or fields.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类**不应**有任何数据成员或字段。
- en: The reason for this is that an interface specifies behavior, which should be
    independent of the data representation. It derives that abstract base classes
    should only have a default constructor.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种情况的原因在于，一个接口指定了行为，这些行为应该独立于数据表示。由此得出结论，抽象基类应该只包含默认构造函数。
- en: An abstract base class should always define a `virtual ~Interface() = default`.
    We are going to see why it is important for the destructor to be virtual later.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类应该始终定义一个`virtual ~Interface() = default`。我们将在稍后看到为什么析构函数是虚拟的很重要。
- en: All the methods of an abstract base class should be pure virtual.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类中的所有方法应该是纯虚的。
- en: The interface represents an expected functionality that needs to be implemented;
    a method which is not pure is an implementation. The implementation should be
    separate from the interface.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口代表需要实现的可预期功能；一个非纯方法是一个实现。实现应该与接口分开。
- en: All of the methods of an abstract base class should be `public`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类中的所有方法都应该声明为`public`。
- en: Similar to the previous point, we are defining a set of methods that we expect
    to call. We should not limit which classes can call the method only to classes
    deriving from the interface.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与前一点类似，我们正在定义一组我们期望调用的方法。我们不应该仅将可以调用该方法的功能限制为从接口派生的类。
- en: All the methods of an abstract base class should be regarding a single functionality.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类中的所有方法都应该针对单一功能。
- en: If our code requires multiple functionalities, separate interfaces can be created,
    and the class can derive from all of them. This allows us to compose interfaces
    more easily.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们的代码需要多个功能，可以创建单独的接口，并且类可以从中派生所有这些接口。这使得我们更容易组合接口。
- en: 'Consider disabling the copy and move constructors and assignment operators
    on the interface. Allowing the interface to be copied can cause the slicing problem
    we were describing before:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑禁用接口上的复制构造函数和移动构造函数以及赋值运算符。允许接口被复制可能会导致我们之前描述的切片问题：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With the last assignment, we only copied the `Vehicle` part, since the copy
    constructor of the `Vehicle` class has been called. The copy constructor is not
    virtual, so the implementation in `Vehicle` is called, and since it only knows
    about the data members of the `Vehicle` class (which should be none), the ones
    defined inside `Car` have not been copied! This results in problems that are very
    hard to identify.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个赋值操作中，我们只复制了 `Vehicle` 部分，因为已经调用了 `Vehicle` 类的拷贝构造函数。拷贝构造函数不是虚拟的，所以调用的是
    `Vehicle` 中的实现，并且因为它只知道 `Vehicle` 类的数据成员（应该是没有的），所以 `Car` 中定义的成员没有被复制！这导致了一些非常难以识别的问题。
- en: 'A possible solution is to disable the interface copy and move construct and
    assign operator: `Interface(const Interface&) = delete`; and similar. This has
    the drawback of disabling the compiler from creating the copy constructor and
    assign operators of the derived classes.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是禁用接口的拷贝和移动构造函数以及赋值运算符：`Interface(const Interface&) = delete` 以及类似的。这的缺点是阻止编译器为派生类创建拷贝构造函数和赋值运算符。
- en: An alternative is to declare copy/move constructor/assignment protected so that
    only derived classes can call them, and we don't risk assigning interfaces while
    using them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是声明拷贝/移动构造函数/赋值运算符为受保护的，这样只有派生类可以调用它们，我们使用它们时不会冒分配接口的风险。
- en: 'Activity 25: Retrieving User Information'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动 25：检索用户信息
- en: We are writing an application to allow users to buy and sell items. When a user
    logs in, we need to retrieve several pieces of information to populate their profile,
    such as the URL for the profile picture and the full name.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个应用程序，允许用户购买和出售物品。当用户登录时，我们需要检索一些信息来填充他们的个人资料，例如个人资料的 URL 和全名。
- en: Our service is running in many data centers around the world, to always be close
    to its customers. Because of that, sometimes we want to retrieve information for
    the user from a cache, but sometimes we want to retrieve it from our main database.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务在全球许多数据中心运行，以便始终靠近其客户。因此，有时我们想从缓存中检索用户信息，但有时我们想从我们的主数据库中检索。
- en: 'Perform the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: 'Let''s write the code, which can be independent of where the data is coming
    from, so we create an abstract `UserProfileStorage` class to retrieve the `CustomerProfile`
    from `UserId`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写代码，使其可以独立于数据来源，因此我们创建一个抽象的 `UserProfileStorage` 类来从 `UserId` 获取 `CustomerProfile`：
- en: '[PRE43]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, write the `UserProfileCache` class, which inherits from `UserProfileStorage`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写继承自 `UserProfileStorage` 的 `UserProfileCache` 类：
- en: '[PRE44]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `main` function, instantiate the `UserProfileCache` class and the call
    `exampleOfUsage` function as illustrated:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，实例化 `UserProfileCache` 类并调用 `exampleOfUsage` 函数，如图所示：
- en: '[PRE45]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 312.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第 312 页找到。
- en: Dynamic Memory
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态内存
- en: In this chapter, we have come across the term dynamic memory. Now let's understand
    in more detail what dynamic memory is, what problems it solves, and when to use
    it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了动态内存这个术语。现在让我们更详细地了解什么是动态内存，它解决了什么问题，以及何时使用它。
- en: '**Dynamic memory** is the part of the memory that the program can use to store
    objects, for which the program is responsible for maintaining the correct lifetime.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态内存**是程序可以用来存储对象的内存部分，程序负责维护其正确的生命周期。'
- en: It is usually also called the **heap** and is often the alternative to the stack,
    which instead is handled automatically by the program. Dynamic memory can usually
    store much larger objects than the stack, which usually has a limit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常也被称为 **堆**，并且通常是栈的替代品，而栈则由程序自动处理。动态内存通常可以存储比栈大得多的对象，而栈通常有一个限制。
- en: A program can interact with the operating system to get pieces of dynamic memory
    that it can use to store objects, and later it must take care to return such memory
    to the operating system.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以与操作系统交互以获取动态内存块，这些内存块可以用来存储对象，之后程序必须注意将其归还给操作系统。
- en: Historically, developers would make sure they called the appropriate functions
    to get and return memory, but modern C++ automates most of this, so it is much
    easier to write correct programs nowadays.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，开发者会确保调用适当的函数来获取和归还内存，但现代 C++ 自动化了大部分这个过程，因此现在编写正确的程序要容易得多。
- en: In this section, we are going to show how and when it is recommended to use
    dynamic memory in a program.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示何时以及如何推荐在程序中使用动态内存。
- en: 'Let''s start with an example: we want to write a function that will create
    a logger. When we execute tests, we create a logger specifically for the test
    called `TestLogger`, and when we run our program for users, we want to use a different
    logger, called `ReleaseLogger`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始：我们想要编写一个创建记录器的函数。当我们执行测试时，我们创建一个名为`TestLogger`的特定于测试的记录器，当我们为用户运行程序时，我们想要使用不同的记录器，称为`ReleaseLogger`。
- en: We can see a good fit for interfaces here – we can write a logger abstract base
    class that defines all the methods needed for logging and have `TestLogger` and
    `ReleaseLogger` derive from it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到接口的一个很好的匹配点——我们可以编写一个定义所有所需日志方法的记录器抽象基类，并且`TestLogger`和`ReleaseLogger`从它派生。
- en: All our code will then use a reference to the logger when logging.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们所有的代码在日志时都会使用记录器的引用。
- en: How can we write such a function?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写这样的函数？
- en: As we learned in *Chapter 2*, *Functions*, we cannot create the logger inside
    the function and then return a reference to it, since it would be an automatic
    variable and it would be destructed just after the return, leaving us with a dangling
    reference.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第二章*，*函数*中学到的，我们不能在函数内部创建记录器，然后返回对其的引用，因为它将是一个自动变量，它将在返回后立即被销毁，留下一个悬垂引用。
- en: We cannot create the logger before calling the function and let the function
    initialize it either, since the types are different, and the function knows which
    type should be created.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在调用函数之前创建记录器，也不能让函数初始化它，因为类型不同，函数知道应该创建哪种类型。
- en: We would need some storage that is valid until we need the logger, to put the
    logger in it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些存储，直到我们需要记录器时才有效，以便将记录器放入其中。
- en: Given only an interface, we cannot know the size of the classes implementing
    it, since multiple classes could implement it and they could have different sizes.
    This prevents us from reserving some space in memory and passing a pointer to
    such space to the function, so that it could store the logger in it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 只给出一个接口，我们无法知道实现它的类的尺寸，因为可能有多个类实现它，并且它们可能有不同的大小。这阻止了我们为内存中预留一些空间并将指向该空间的指针传递给函数，以便它可以在其中存储记录器。
- en: Since classes can have different sizes, the storage not only needs to remain
    valid longer than the function, but it also needs to be variable. That is **dynamic
    memory**!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类可以有不同的大小，存储不仅需要比函数保持有效的时间更长，还需要是可变的。这就是**动态内存**！
- en: In C++, there are two keywords to interact with dynamic memory – **new** and
    **free**.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，有两个关键字用于与动态内存交互——**new**和**free**。
- en: 'The `new` expression is used to create a new object in dynamic memory – it
    is composed by the `new` keyword, followed by the type of the object to create
    and the parameters to pass to the constructor, and returns a pointer to the requested
    type:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`表达式用于在动态内存中创建新对象——它由`new`关键字组成，后跟要创建的对象的类型以及传递给构造函数的参数，并返回指向请求类型的指针：'
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `new` expression requests a piece of dynamic memory big enough to hold the
    object created and instantiates an object in that memory. It then returns a pointer
    to such an instance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`表达式请求足够大的动态内存来容纳创建的对象，并在该内存中实例化一个对象。然后它返回指向该实例的指针。'
- en: 'The program can now use the object pointed to by `myCar` until it decides to
    delete it. To delete a pointer, we can use the delete expression: it is composed
    by the `delete` keyword followed by a variable, which is a pointer:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在可以使用`myCar`指向的对象，直到它决定删除它。要删除指针，我们可以使用`delete`表达式：它由`delete`关键字后跟一个变量组成，该变量是一个指针：
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `delete` keyword calls the destructor of the object pointed to by the pointer
    provided to it, and then gives the memory we initially requested back to the operating
    system.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`关键字调用由其提供的指针指向的对象的析构函数，然后将其最初请求的内存返回给操作系统。'
- en: 'Deleting pointers to automatic variables lead to an error as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 删除指向自动变量的指针会导致以下错误：
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is of absolute importance that, for each new expression, we call the `delete`
    expression only once, with the same returned pointer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`new`表达式，绝对重要的是，我们只调用一次`delete`表达式，并且使用相同的返回指针。
- en: 'If we forget to call the `delete` function on an object returned by calling
    the `new` function, we will have two major problems:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记调用`new`函数返回的对象的`delete`函数，我们将有两个主要问题：
- en: The memory will not be returned to the operating system when we do not need
    it anymore. This is known as a **memory leak**. If this repeatedly happens during
    the execution of the program, our program will take more and more memory, until
    it consumes all the memory it can get.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不再需要内存时，不会将其返回给操作系统。这被称为**内存泄漏**。如果在程序执行期间反复发生，我们的程序将消耗越来越多的内存，直到消耗掉它能获取的所有内存。
- en: The destructor of the object will not be called.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的析构函数不会被调用。
- en: We saw in previous chapters that, in C++, we should make use of RAII and get
    the resources we need in the constructor and return them in the destructor.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中看到，在 C++ 中，我们应该利用 RAII（资源获取即初始化）在构造函数中获取所需的资源，并在析构函数中返回它们。
- en: If we do not call the destructor, we might not return some resources. For example,
    a connection to the database would be kept open, and our database would struggle
    due to too many connections being open, even if we are using only one.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不调用析构函数，我们可能不会返回一些资源。例如，数据库连接将保持打开状态，即使我们只使用一个连接，我们的数据库也会因为打开的连接太多而挣扎。
- en: The problem that arises if we call `delete` multiple times on the same pointer
    is that all the calls after the first one will access memory they should not be
    accessing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对同一个指针多次调用 `delete`，会出现的问题是在第一次调用之后的所有调用都将访问它们不应访问的内存。
- en: The result can range from our program crashing to deleting other resources our
    program is currently using, resulting in incorrect behavior.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能从我们的程序崩溃到删除我们程序当前正在使用的其他资源，导致行为不正确。
- en: 'We can now see why it is extremely important to define a virtual destructor
    in the base class if we derive from it: we need to make sure that the destructor
    of the runtime type is called when calling the `delete` function on the base object.
    If we call `delete` on a pointer to the base class while the runtime type is the
    derived class, we will only call the destructor of the base class and not fully
    destruct the derived class.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，如果我们从基类派生，定义基类中的虚拟析构函数为什么非常重要：我们需要确保在调用基对象的 `delete` 函数时调用运行时类型的析构函数。如果我们对基类指针调用
    `delete`，而运行时类型是派生类，我们只会调用基类的析构函数，而不会完全析构派生类。
- en: Making the destructor of the base class virtual will ensure that we are going
    to call the derived destructor, since we are using dynamic dispatch when calling
    it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将基类的析构函数设置为虚函数将确保我们将调用派生类的析构函数，因为我们调用它时使用了动态分派。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For every call to the `new` operator, there must be exactly one call to `delete`
    with the pointer returned by `new`!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次调用 `new` 操作符，必须有且只有一个调用 `delete`，使用 `new` 返回的指针！
- en: This error is extremely common and leads to many errors.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误非常常见，并导致许多错误。
- en: 'Like single objects, we can also use dynamic memory to create arrays of objects.
    For such use cases, we can use the `new[]` and `delete[]` expressions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单个对象一样，我们也可以使用动态内存来创建对象的数组。对于此类用例，我们可以使用 `new[]` 和 `delete[]` 表达式：
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `new[]` expression will create enough space for `n Car` instances and will
    initialize them, returning a pointer to the first element created. Here, we are
    not providing the arguments to the constructor, so the class must have a default
    constructor.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`new[]` 表达式将为 `n Car` 实例创建足够的空间并将它们初始化，返回指向创建的第一个元素的指针。在这里，我们没有提供构造函数的参数，因此类必须有一个默认构造函数。'
- en: With `new[]`, we can specify how many elements we want it to initialize. This
    is different from `std::array` and the built-in array we saw earlier because `n`
    can be decided at runtime.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `new[]`，我们可以指定我们想要初始化多少个元素。这与 `std::array` 和我们之前看到的内置数组不同，因为 `n` 可以在运行时决定。
- en: We need to call `delete[]` on the pointer returned by `new[]` when we do not
    need the objects anymore.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要对象时，我们需要在 `new[]` 返回的指针上调用 `delete[]`。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For every call to `new[]`, there must be exactly one call to `delete[]` with
    the pointer returned by `new[]`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次调用 `new[]`，必须有且只有一个调用 `delete[]`，使用 `new[]` 返回的指针。
- en: The `new` operator and `new[]` function calls, and `delete` and `delete[]` function
    calls, cannot be intermixed. Always pair the ones for an array or the ones for
    single elements!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 操作符和 `new[]` 函数调用，以及 `delete` 和 `delete[]` 函数调用，不能混合使用。始终为数组或单个元素配对！'
- en: Now that we have seen how to use dynamic memory, we can write the function to
    create our logger.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用动态内存，我们可以编写创建我们日志记录器的函数。
- en: 'The function will call the new expression in its body to create an instance
    of the correct class, and it will then return a pointer to the base class so that
    the code calling it does not need to know about the type of logger created:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将在其主体中调用 `new` 表达式来创建正确类的实例，然后返回基类指针，这样调用它的代码就不需要知道创建的 logger 类型：
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There are two things to note in this function:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中有两点需要注意：
- en: Even if we wrote the `new` expression twice, `new` will be called only once
    per function call.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们将 `new` 表达式写了两遍，每次函数调用中 `new` 也只会被调用一次。
- en: This shows us that it is not enough to make sure we type `new` and `delete`
    an equal number of times; we need to understand how our code is executed.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明仅仅确保我们输入 `new` 和 `delete` 的次数相等是不够的；我们需要理解我们的代码是如何执行的。
- en: There is no call to `delete`! This means that the code calling the `createLogger`
    function needs to make sure to call `delete`.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有调用 `delete`！这意味着调用 `createLogger` 函数的代码需要确保调用 `delete`。
- en: From these two points, we can can see why it is error prone to manage memory
    manually, and why it should be avoided whenever possible.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两点来看，我们可以看到手动管理内存为什么容易出错，以及为什么应该尽可能避免这样做。
- en: 'Let''s look at an example of how to call the function correctly:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何正确调用函数的例子：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `myOperation` does not call `delete` on the logger, this is a *correct* use
    of dynamic memory. Dynamic memory is a powerful tool, but doing it manually is
    risky, error prone, and easy to get wrong.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `myOperation` 没有在 logger 上调用 `delete`，这是动态内存的**正确**使用。动态内存是一个强大的工具，但手动操作是危险的，容易出错，并且容易出错。
- en: Fortunately, modern C++ provides some facilities to make all this much easier
    to do. It is possible to write entire programs without ever using `new` and `delete`
    directly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现代 C++ 提供了一些工具，使得所有这些操作都变得容易得多。可以编写整个程序而不直接使用 `new` 和 `delete`。
- en: We will see how in the next section.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到这一点。
- en: Safe and Easy Dynamic Memory
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全且易于使用的动态内存
- en: In the previous section, we learned how dynamic memory could be useful when
    working with interfaces, especially when creating new instances of derived classes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了在处理接口时动态内存如何有用，尤其是在创建派生类的新实例时。
- en: We also saw how working with dynamic memory can be hard – we need to make sure
    to call new and delete in pairs, and failing to do so always has negative effects
    on our program. Fortunately for us, since C++11, there are tools in the standard
    library to help us overcome such limitations – **smart pointers**.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何处理动态内存可能会很困难——我们需要确保成对地调用 `new` 和 `delete`，否则总是会对我们的程序产生负面影响。幸运的是，自从
    C++11 以来，标准库中有工具可以帮助我们克服这些限制——**智能指针**。
- en: Smart pointers are types that behave like pointers, which are called **raw pointers**
    in this context, but have additional functionality.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针是类似指针的类型，在此语境中称为**原始指针**，但具有额外的功能。
- en: 'We are going to look at two smart pointers from the standard library: `std::unique_ptr`
    and `std::shared_ptr` (read as `delete` appropriately.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨标准库中的两个智能指针：`std::unique_ptr` 和 `std::shared_ptr`（适当地读作 `delete`）。
- en: They represent different ownership models. The owner of an object is the code
    that determines the lifetime of the object – the part of the code that decides
    when to create and when to destroy the object.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 它们代表了不同的所有权模型。对象的所有者是确定对象生存期的代码——决定何时创建和销毁对象的代码部分。
- en: 'Usually, ownership is associated with the scope a function or method, since
    the lifetime of automatic variables is controlled by it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有权与函数或方法的作用域相关联，因为自动变量的生存期由它控制：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this case, the scope of `foo()` owns the `number` object, and it will make
    sure it is destroyed when the scope exits.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`foo()` 函数的作用域拥有 `number` 对象，并且它将确保在作用域退出时销毁它。
- en: 'Alternatively, classes might own objects when they are declared as value types
    between the data members of the class. In that case, the lifetime of the object
    will be the same as the lifetime of the class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当类被声明为值类型，位于类的数据成员之间时，类可能拥有对象。在这种情况下，对象的生存期将与类的生存期相同：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`number` will be constructed when the `A` class is constructed and will be
    destroyed when the `A` class is destroyed. This is automatically done because
    the field `number` is embedded inside the class and the constructor and destructor
    of the class will automatically initialize `number`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`number` 将在 `A` 类构造时构造，并在 `A` 类销毁时销毁。这是自动完成的，因为字段 `number` 嵌入在类中，类的构造函数和析构函数将自动初始化
    `number`。'
- en: When managing objects in dynamic memory, ownership is not enforced by the compiler
    anymore, but it is helpful to apply the concept of ownership to the dynamic memory
    as well – the owner is who decides when to delete the object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当管理动态内存中的对象时，编译器不再强制执行所有权，但将所有权概念应用于动态内存也是有帮助的——所有者是决定何时删除对象的人。
- en: 'A function could be the owner of an object when the object is allocated with
    the new call inside the function, as in the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象在函数内部使用`new`调用分配时，函数可以是对象的所有者，如下面的示例所示：
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or a class might own it, by calling `new` in the constructor and storing the
    pointer in its fields, and calling `delete` on it in the destructor:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个类可能通过在构造函数中调用`new`并将指针存储在其字段中，并在析构函数中调用`delete`来拥有它：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: But the ownership of dynamic objects can also be passed around.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 但动态对象的所有权也可以传递。
- en: We looked at an example earlier with the `createLogger` function. The function
    creates an instance of **Logger** and then passes the ownership to the parent
    scope. Now, the parent scope is in charge of making sure the object is valid until
    it is accessed in the program and deleted afterward.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经通过`createLogger`函数的示例进行了查看。该函数创建了一个`Logger`实例，然后将所有权传递给父作用域。现在，父作用域负责确保对象在程序中被访问直到删除。
- en: Smart pointers allow us to specify the ownership in the type of the pointer
    and make sure it is respected so that we do not have to keep track of it manually
    anymore.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针允许我们在指针的类型中指定所有权，并确保它得到尊重，这样我们就不必再手动跟踪它了。
- en: Note
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Always use smart pointers to represent the ownership of objects.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用智能指针来表示对象的所有权。
- en: In a code base, smart pointers should be the pointers that control the lifetime
    of objects, and raw pointers, or regular pointers, are used only to reference
    objects.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中，智能指针应该是控制对象生命周期的指针，而原始指针或常规指针仅用于引用对象。
- en: A Single Owner Using std::unique_ptr
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用std::unique_ptr的单个所有者
- en: '`unique_ptr` is the pointer type that''s used by default. The unique pointer
    points to an object that has a single owner; there is a single place in the program
    that decides when to delete the object.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`是默认使用的指针类型。唯一指针指向一个只有一个所有者的对象；程序中只有一个地方决定何时删除该对象。'
- en: 'An example is the logger from before: there is a single place in the program
    that determines when to delete the object. Since we want the logger to be available
    as long as the program is running, to always be able to log information, we will
    destroy the logger only at the end of the program.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，之前的日志记录器：程序中只有一个地方决定何时删除对象。由于我们希望日志记录器在程序运行期间始终可用，以便始终能够记录信息，我们将在程序结束时销毁日志记录器。
- en: 'The unique pointer guarantees the uniqueness of ownership: the unique pointer
    cannot be copied. This means that once we have created a unique pointer for an
    object, there can be only one.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一指针保证了所有权的唯一性：唯一指针不能被复制。这意味着一旦我们为对象创建了一个唯一指针，就只能有一个。
- en: Additionally, when the unique pointer is destroyed, it deletes the object it
    owns. This way, we have a concrete object that tells us the ownership of the created
    object, and we do not have to manually make sure that only one place is calling
    `delete` for the object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当唯一指针被销毁时，它会删除它拥有的对象。这样，我们就有一个具体的对象，它告诉我们创建的对象的所有权，我们不必手动确保只有一个地方调用`delete`来删除对象。
- en: 'A unique pointer is a template that can take one argument: the *type of the
    object*.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一指针是一个模板，它可以接受一个参数：*对象的类型*。
- en: 'We could rewrite the previous example as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将前面的示例重写如下：
- en: '[PRE57]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'While this code would compile, we would not be respecting the guideline we
    mentioned previously regarding always using smart pointers for ownership: `createLogger`
    returns a raw pointer, but it passes ownership to the parent scope.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以编译，但我们不会遵守之前提到的始终使用智能指针进行所有权的指南：`createLogger`返回一个原始指针，但它将所有权传递给父作用域。
- en: 'We can update the signature of `createLogger` to return a smart pointer:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`createLogger`函数的签名更新为返回智能指针：
- en: '[PRE58]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, the signature expresses our intention, and we can update the implementation
    to make use of smart pointers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，签名表达了我们的意图，我们可以更新实现以使用智能指针。
- en: 'As we mentioned earlier, with the use of smart pointers, code bases should
    not use `new` and `delete` anywhere. This is possible because the standard library,
    since C++14, offers a convenient function: `std::make_unique. make_unique` is
    a template function that takes the type of the object to create, and creates it
    in dynamic memory, passing its arguments to the object''s constructor and returning
    a unique pointer to it:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，随着智能指针的使用，代码库不应在任何地方使用`new`和`delete`。这是可能的，因为自C++14以来，标准库提供了一个方便的函数：`std::make_unique`。`make_unique`是一个模板函数，它接受要创建的对象的类型，并在动态内存中创建它，将参数传递给对象的构造函数，并返回一个指向它的唯一指针：
- en: '[PRE59]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are three important points regarding this function:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此功能有三个重要点：
- en: There is no longer a new expression in the body; it has been replaced with `make_unique`.
    The `make_unique` function is simple to call because we can provide all the arguments
    we would pass to the constructor of the type and have it created automatically.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数体中不再有新的表达式；它已经被`make_unique`所取代。`make_unique`函数调用简单，因为我们可以提供所有传递给类型构造函数的参数，并自动创建它。
- en: We are creating a `unique_ptr` to a derived class, but we are returning a `unique_ptr`
    to a base class.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个指向派生类的`unique_ptr`，但我们返回一个指向基类的`unique_ptr`。
- en: Indeed, `unique_ptr` emulates the ability of raw pointers to convert pointers
    to derived classes to pointers to base classes. This makes using `unique_ptr`
    as simple as using **raw pointers**.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，`unique_ptr`模拟了原始指针将派生类指针转换为基类指针的能力。这使得使用`unique_ptr`与使用**原始指针**一样简单。
- en: We are using the move on the `unique_ptr`. As we said earlier, we cannot copy
    `unique_ptr`, but we are returning from a function, so we must use a value; otherwise,
    a reference would become invalid after the function returns, as we saw in *Chapter
    2*, *Functions*.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用`unique_ptr`的移动操作。正如我们之前所说的，我们不能复制`unique_ptr`，但我们需要从函数返回一个值；否则，在函数返回后，引用将变得无效，就像我们在*第二章*，*函数*中看到的那样。
- en: While it cannot be copied, `unique_ptr` can be moved. When we move `unique_ptr`,
    we are transferring the ownership of the object to which it points to the recipient
    of the value. In this case, we are returning value, so we are transferring the
    ownership to the caller of the function.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然`unique_ptr`不能被复制，但它可以被移动。当我们移动`unique_ptr`时，我们将指向的对象的所有权转移到值的接收者。在这种情况下，我们返回值，因此我们将所有权转移到函数的调用者。
- en: 'Let''s now see how we can rewrite the class that owns the number we showed
    before:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看我们如何重写之前展示的拥有数字的类：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Thanks to the fact that `unique_ptr` deletes the object automatically when it
    is destroyed, we did not have to write the destructor for the class, making our
    code even easier.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`unique_ptr`在销毁时自动删除对象，我们不必为类编写析构函数，这使得我们的代码更加简单。
- en: If we need to pass a pointer to the object, without transferring ownership,
    we can use the `get()` method on the raw pointer. Remember that raw pointers should
    not be used for ownership, and code accepting the raw pointer should never call
    `delete` on it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要传递对象的指针，而不转移所有权，我们可以使用原始指针上的`get()`方法。记住，原始指针不应用于所有权，接受原始指针的代码永远不应该调用`delete`。
- en: Thanks to these features, `unique_ptr` should be the default choice to keep
    track of the ownership of an object.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些特性，`unique_ptr`应该是跟踪对象所有权的默认选择。
- en: Shared Ownership Using std::shared_ptr
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`std::shared_ptr`实现共享所有权
- en: '`shared_ptr` represents an object that has multiple owners: one out of several
    objects will delete the owned object.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`表示一个有多个所有者的对象：几个对象中的一个将删除拥有的对象。'
- en: An example could make a TCP connection, which is established by multiple threads
    to send data. Each thread uses the TCP connection to send data and then terminates.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以建立一个TCP连接，该连接由多个线程建立以发送数据。每个线程使用TCP连接发送数据然后终止。
- en: We want to delete the TCP connection when the last thread has finished executing,
    but it is not always the same thread that terminates last; it could be any of
    the threads.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在最后一个线程执行完毕时删除TCP连接，但最后一个终止的线程不一定是同一个；它可能是任何线程。
- en: Alternatively, if we are modeling a graph of connected nodes, we might want
    to delete a node when every connection to it is removed from the graph. `unique_ptr`
    does not solve these cases, since there is not a single owner for the object.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们正在模拟一个连接节点的图，我们可能希望在从图中删除所有连接后删除一个节点。`unique_ptr`不能解决这些情况，因为对象没有单一的所有者。
- en: '`shared_ptr` can be used in such situations: `shared_ptr` can be copied many
    times, and the object pointed to by the pointer will remain alive until the last
    `shared_ptr` is destroyed. We guarantee that the object remains valid as long
    as there is at least one `shared_ptr` instance pointing to it.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`可以用于这种情况：`shared_ptr`可以被复制多次，并且指针所指向的对象将保持活跃，直到最后一个`shared_ptr`被销毁。我们保证只要至少有一个`shared_ptr`实例指向它，对象就保持有效。'
- en: 'Let''s look at an example making use of it:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个利用它的例子：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here, we can see that we are holding many `shared_ptr` instance to nodes. If
    we have a `shared_ptr` instance to a node, we want to be sure that the node exists,
    but when we remove the shared pointer, we do not care about the node anymore:
    it might be deleted, or it might be kept alive if there is another node connected
    to it.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们持有许多指向节点的`shared_ptr`实例。如果我们有一个指向节点的`shared_ptr`实例，我们想要确保节点存在，但当我们移除共享指针时，我们不再关心节点：它可能被删除，或者如果另一个节点与之连接，它可能仍然保持活跃。
- en: Similar to the `unique_ptr` counterpart, when we want to create a new node,
    we can use the `std::make_shared` function, which takes the type of the object
    to construct as the template argument and the arguments to pass to the constructor
    of the object and returns `shared_ptr` to the object.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 与`unique_ptr`的对应物类似，当我们想要创建一个新的节点时，我们可以使用`std::make_shared`函数，它将构造对象的类型作为模板参数，并将传递给对象构造函数的参数作为参数，并返回指向对象的`shared_ptr`。
- en: 'You might notice that there might be a problem in the example we showed: what
    happens if node `A` is connected to node `B` and node `B` is connected to node
    `A`?'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在我们展示的例子中可能存在一个问题：如果节点`A`连接到节点`B`，而节点`B`又连接到节点`A`，会发生什么？
- en: Both nodes have a `shared_ptr` instance to the other, and even if no other node
    has a connection to them, they will remain alive because a `shared_ptr` instance
    to them exists. This is an example of circular dependency.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 两个节点都有一个指向对方的`shared_ptr`实例，即使没有其他节点与它们连接，它们也会保持活跃，因为存在指向它们的`shared_ptr`实例。这是一个循环依赖的例子。
- en: 'When using shared pointers, we must pay attention to these cases. The standard
    library offers a different kind of pointer to handle these situations: `std::weak_ptr`
    (read as **weak pointer**).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用共享指针时，我们必须注意这些情况。标准库提供了一种不同类型的指针来处理这些情况：`std::weak_ptr`（读作**弱指针**）。
- en: '`weak_ptr` is a smart pointer that can be used in conjunction with `shared_ptr`
    to solve the circular dependencies that might happen in our programs.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`是一种智能指针，可以与`shared_ptr`一起使用，以解决我们程序中可能出现的循环依赖问题。'
- en: Generally, `shared_ptr` is enough to model most cases where `unique_ptr` does
    not work, and together they cover the majority of the uses of dynamic memory in
    a code base.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，`shared_ptr`足以模拟大多数`unique_ptr`无法处理的情况，并且它们共同覆盖了代码库中动态内存的大部分使用。
- en: 'Lastly, we are not helpless if we want to use dynamic memory for arrays of
    which we know the size only at runtime. `unique_ptr` can be used with array types,
    and `shared_ptr` can be used with array types starting from C++17:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想在运行时才知道大小的数组中使用动态内存，我们并不无助。`unique_ptr`可以与数组类型一起使用，从C++17开始，`shared_ptr`也可以与数组类型一起使用：
- en: '[PRE62]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Activity 26: Creating a Factory for UserProfileStorage'
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动26：为UserProfileStorage创建工厂
- en: 'Our code needs to create new instances of the `UserProfileStorage` interface
    we wrote during *Activity 25: Retrieving User Information*:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码需要创建我们在*活动25：检索用户信息*期间编写的`UserProfileStorage`接口的新实例：
- en: 'Write a new `UserProfileStorageFactory` class. Now create a new `create` method
    which returns a `UserProfileStorage`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个新的`UserProfileStorageFactory`类。现在创建一个新的`create`方法，它返回一个`UserProfileStorage`：
- en: 'In the `UserProfileStorageFactory` class, return `unique_ptr` so that it manages
    the lifetime of the interface:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserProfileStorageFactory`类中，返回`unique_ptr`以便它管理接口的生存期：
- en: '[PRE63]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, in the `main` function, call the `UserProfileStorageFactory` class.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`函数中，调用`UserProfileStorageFactory`类。
- en: Note
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 313.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决这个活动的方案可以在第313页找到。
- en: 'Activity 27: Using a Database Connection for Multiple Operations'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动27：使用数据库连接进行多项操作
- en: In our online store, after a user has paid for a purchase, we want to update
    their order list so that it is displayed on their profile. At the same time, we
    also need to schedule the processing of the order.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的在线商店中，用户支付购买后，我们想要更新他们的订单列表，以便在他们的个人资料中显示。同时，我们还需要安排订单的处理。
- en: To do so, we need to update the records in our database.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要更新我们数据库中的记录。
- en: 'We don''t want to wait for one operation to perform the other, so we process
    the updates in parallel:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望等待一个操作完成后再执行另一个操作，因此我们并行处理更新：
- en: Let's create a `DatabaseConnection` class that can be used in parallel. We want
    to reuse this as much as possible, and we know we can use `std::async` to start
    a new parallel task.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`DatabaseConnection`类，它可以并行使用。我们希望尽可能多地重用它，我们知道我们可以使用`std::async`来启动一个新的并行任务。
- en: 'Assuming that there are two functions, `updateOrderList(DatabaseConnection&)`
    and `scheduleOrderProcessing(DatabaseConnection&)`, write two functions, `updateWithConnection()`
    and `scheduleWithConnection()` which take a shared pointer to `DatabaseConnection`
    and call the respective function defined above:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有两个函数，`updateOrderList(DatabaseConnection&)`和`scheduleOrderProcessing(DatabaseConnection&)`，编写两个函数`updateWithConnection()`和`scheduleWithConnection()`，它们接受指向`DatabaseConnection`的共享指针并调用上面定义的相应函数：
- en: '[PRE64]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use `shared_ptr` and keep a copy of `shared_ptr` in order to make sure that
    the connection remains valid.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shared_ptr`并保留`shared_ptr`的副本，以确保连接保持有效。
- en: 'Now let''s write the `main` function, where we create a shared pointer to the
    connection and then we call `std::async` with the two functions we defined above,
    as illustrated:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编写`main`函数，其中我们创建一个指向连接的共享指针，然后我们调用上面定义的两个函数`std::async`，如下所示：
- en: '[PRE65]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output is as follows:'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE66]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at page 314.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决这个活动的方案可以在第314页找到。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how inheritance can be used to combine classes in C++.
    We saw what a base class is and what a derived class is, how to write a class
    that derives from another, and how to control the visibility modifier. We talked
    about how to initialize a base class in a derived one by calling the base class
    constructor.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在C++中使用继承来组合类。我们看到了基类是什么，派生类是什么，如何编写从另一个类派生的类，以及如何控制可见性修饰符。我们讨论了如何在派生类中通过调用基类构造函数来初始化基类。
- en: We then explained polymorphism and the ability of C++ to dynamically bind a
    pointer or reference of a derived class to a pointer or reference of the base
    class. We explained what dispatch for functions is, how it works statically by
    default, and how we can make it dynamic with the use of the virtual keyword. Following
    that, we explored how to properly write virtual functions and how we can override
    them, making sure to mark such overrode functions with the `override` keyword.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们解释了多态以及C++动态绑定派生类指针或引用到基类指针或引用的能力。我们解释了函数调用的分派是什么，默认情况下它是如何静态工作的，以及如何使用虚关键字使其动态化。随后，我们探讨了如何正确编写虚函数以及如何覆盖它们，确保用`override`关键字标记这样的覆盖函数。
- en: Next, we showed how to define interfaces with abstract base classes and how
    to use pure virtual methods. We also provided guidelines on how to correctly define
    interfaces.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们展示了如何使用抽象基类定义接口以及如何使用纯虚方法。我们还提供了如何正确定义接口的指南。
- en: Lastly, we delved into dynamic memory and what problems it solves, but we also
    saw how easy it is to use it incorrectly.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入探讨了动态内存及其解决的问题，但也看到了如何容易地错误使用它。
- en: 'We concluded the chapter by showing how modern C++ makes using dynamic memory
    painless by providing smart pointers that handle complex details for us: `unique_ptr`
    to manage objects with a single owner, and `shared_ptr` for objects owned by multiple
    objects.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示现代C++如何通过提供智能指针来简化动态内存的使用，从而结束了本章的内容，这些智能指针为我们处理复杂的细节：`unique_ptr`用于管理单个所有者的对象，`shared_ptr`用于多个所有者的对象。
- en: All these tools can be effective at writing solid programs that can be effectively
    evolved and maintained, while retaining the performance C++ is famous for.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都可以有效地编写出既能够有效进化又能够维护的稳固程序，同时保留C++所著名的性能。
