- en: '*Chapter 18*: Applying the Adapter Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第18章*：应用适配器模式'
- en: This chapter will extend our quest to expand your C++ programming skills beyond
    core OOP concepts, with the goal of enabling you to solve recurring types of coding
    problems utilizing common design patterns. Incorporating design patterns in coding
    solutions can not only provide elegant solutions, but enhance code maintenance
    and provide potential opportunities for code reuse.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将扩展我们的探索，超越核心面向对象编程概念，旨在使您能够利用常见的设计模式解决重复出现的编码问题。在编码解决方案中应用设计模式不仅可以提供优雅的解决方案，还可以增强代码的维护性，并为代码重用提供潜在机会。
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Adapter pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在C++中有效实现**适配器模式**。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the Adapter pattern and how it contributes to OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解适配器模式及其对面向对象编程的贡献
- en: Understanding how to implement the Adapter pattern in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在C++中实现适配器模式
- en: By the end of this chapter, you will understand the essential Adapter pattern
    and how it can be used to either allow two incompatible classes to communicate
    or to upgrade unseemly code to well-designed OO code. Adding another key design
    pattern to your knowledge set will refine your programming skills to help make
    you a more valuable programmer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将了解基本的适配器模式以及如何使用它来允许两个不兼容的类进行通信，或者将不合适的代码升级为设计良好的面向对象代码。向您的知识库中添加另一个关键设计模式将使您的编程技能得到提升，帮助您成为更有价值的程序员。
- en: Let's increase our programming skill set by examining another common design
    pattern, the Adapter pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究另一个常见的设计模式，即适配器模式，来增加我们的编程技能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter18`
    subdirectory in a file named `Chp18-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节编号相对应，后跟该章节中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录中的`Chapter18`子目录中的名为`Chp18-Ex1.cpp`的文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2Pfg9VA](https://bit.ly/2Pfg9VA).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/2Pfg9VA](https://bit.ly/2Pfg9VA)。
- en: Understanding the Adapter pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解适配器模式
- en: The **Adapter pattern** is a structural design pattern that provides a means
    for converting an existing, undesirable interface of a class to an interface which
    another class expects. An **Adapter class** will be the link for communication
    between two existing components, adapting the interfaces so that the two may share
    and exchange information. An Adapter allows two or more classes to work together,
    which otherwise could not do so.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器模式**是一种结构设计模式，提供了一种将现有类的不良接口转换为另一个类所期望的接口的方法。**适配器类**将成为两个现有组件之间通信的链接，调整接口以便两者可以共享和交换信息。适配器允许两个或更多类一起工作，否则它们无法这样做。'
- en: Ideally, an Adapter will not add functionality, but will add the preferred interface
    for usage (or conversion) to either allow one class to be used in an expected
    manner or for two otherwise incompatible classes to communicate with one another.
    In its most simple form, an Adapter simply converts an existing class to support
    an expected interface as may be specified in an OO design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，适配器不会添加功能，而是会添加所需的接口以便允许一个类以预期的方式使用，或者使两个不兼容的类相互通信。在其最简单的形式中，适配器只是将现有的类转换为支持OO设计中可能指定的预期接口。
- en: An Adapter can be either associated to, or derived from, the class for which
    it is providing an adaptive interface. If inheritance is used, a private or protected
    base class is appropriate to hide the underlying implementation. If, instead,
    the Adapter class is associated to the class with the undesirable interface, the
    methods in the Adapter class (with the new interfaces) will merely delegate the
    work to its associated class.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器可以与其提供自适应接口的类相关联或派生自该类。如果使用继承，适合使用私有或受保护的基类来隐藏底层实现。如果适配器类与具有不良接口的类相关联，适配器类中的方法（具有新接口）将仅将工作委托给其关联类。
- en: The Adapter pattern can also be used to add an OO interface to (that is, to
    *wrap an OO interface around*) a series of functions or other classes, allowing
    assorted existing components to be utilized more naturally in an OO system. This
    specific type of Adapter is known as a `extern C`, to allow the linker to resolve
    linkage conventions between the two languages).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式还可以用于为一系列函数或其他类添加OO接口（即*在一系列函数或其他类周围包装OO接口*），从而使各种现有组件在OO系统中更自然地被利用。这种特定类型的适配器称为`extern
    C`，以允许链接器解析两种语言之间的链接约定。
- en: Utilizing the Adapter pattern has benefits. The Adapter allows the reuse of
    existing code by providing a shared interface to allow otherwise unrelated classes
    to communicate. The OO programmer will now use the Adapter class directly, allowing
    for easier maintenance of the application. That is, most programmer interaction
    will be with a well-designed Adapter class, rather than with two or more odd components.
    A small drawback of using an Adapter is slightly decreased performance from the
    added layer of code. However, most often, reusing existing components through
    providing a clean interface to support their interaction is a winning proposition,
    despite a (hopefully small) performance trade-off.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 利用适配器模式有好处。适配器允许通过提供共享接口来重用现有代码，以便否则无关的类进行通信。面向对象的程序员现在可以直接使用适配器类，从而更容易地维护应用程序。也就是说，大多数程序员的交互将是与设计良好的适配器类，而不是与两个或更多奇怪的组件。使用适配器的一个小缺点是由于增加了代码层，性能略有下降。然而，通常情况下，通过提供清晰的接口来支持它们的交互来重用现有组件是一个成功的选择，尽管会有（希望是小的）性能折衷。
- en: 'The Adapter pattern will include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式将包括以下内容：
- en: An **Adaptee** class, which represents the class with desirable utilities, yet
    which exists in a form which is not suitable or as expected.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**Adaptee**类，代表具有可取用功能的类，但以不合适或不符合预期的形式存在。
- en: An **Adapter** class, which adapts the interface of the Adaptee class to meet
    the needs of the desired interface.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**适配器**类，它将适配Adaptee类的接口以满足所需接口的需求。
- en: A **Target** class, which represents the specific, desired interface of the
    application at hand. A class may be both a Target and an Adapter.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**目标**类，代表应用程序所需接口的具体接口。一个类可以既是目标又是适配器。
- en: Optional **Client** classes, which will interact with the Target class to fully
    define the application at hand.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的**客户端**类，它们将与目标类交互，以完全定义正在进行的应用程序。
- en: An Adapter pattern allows the reuse of qualified, existing components which
    do not meet the interface needs of current application designs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式允许重用合格的现有组件，这些组件不符合当前应用程序设计的接口需求。
- en: Let's move forward to see two common applications of the Adapter pattern; one
    will have two potential means for implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看适配器模式的两个常见应用；其中一个将有两种潜在的实现方式。
- en: Implementing the Adapter pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现适配器模式
- en: Let's explore two common uses of the Adapter pattern. That is, creating an Adapter
    to bridge the gap between two incompatible class interfaces or building an Adapter
    to simply wrap an existing set of functions with an OO interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨适配器模式的两种常见用法。即，创建一个适配器来弥合两个不兼容的类接口之间的差距，或者创建一个适配器来简单地用OO接口包装一组现有函数。
- en: We will start with the usage of an *Adapter* providing a connector between two
    (or more) incompatible classes. The *Adaptee* will be a well-tested class which
    we would like to reuse (but which has an undesirable interface), and the *Target*
    classes will be those specified in our OO design for an application in the making.
    Let's now specify an Adapter to allow our Adaptee to work with our Target classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用*适配器*提供连接器来连接两个（或更多）不兼容的类开始。*Adaptee*将是一个经过充分测试的类，我们希望重用它（但它具有不理想的接口），*Target*类将是我们在进行中的应用程序的OO设计中指定的类。现在让我们指定一个适配器，以使我们的Adaptee能够与我们的Target类一起工作。
- en: Using an Adapter to provide a necessary interface to an existing class
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器为现有类提供必要的接口
- en: To implement the Adapter pattern, we will first need to identify our Adaptee
    class. We will then create an Adapter class to modify the interface of the Adaptee.
    We will also identify our Target class, representing the class we need to model
    per our OO design. At times, our Adapter and Target may be rolled into a single
    class. In an actual application, we will additionally have Client classes, representing
    the full complement of classes found in the final application at hand. Let's start
    with the Adaptee and Adapter classes, as these class definitions will begin the
    foundation on which to build our pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现适配器模式，我们首先需要确定我们的Adaptee类。然后我们将创建一个适配器类来修改Adaptee的接口。我们还将确定我们的Target类，代表我们需要根据我们的OO设计来建模的类。有时，我们的适配器和目标可能会合并成一个单一的类。在实际应用中，我们还将有客户端类，代表着最终应用程序中的所有类。让我们从Adaptee和Adapter类开始，因为这些类定义将为我们构建模式奠定基础。
- en: In our example, we will specify our Adaptee class as one we are accustomed to
    seeing – `Person`. We will imagine that our planet has recently become aware of
    many other exoplanets capable of supporting life and that we have benevolently
    made allies with each such civilization. Further imagining that the various software
    systems on Earth would like to welcome and include our new friends, including
    `Romulans` and `Orkans`, we would like to adapt some of our existing software
    to easily accommodate the new demographics of our exoplanet neighbors. With that
    in mind, we will transform our `Person` class to include more interplanetary terminology
    by creating an Adapter class, `Humanoid`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将指定我们习惯看到的Adaptee类为“Person”。我们将想象我们的星球最近意识到许多其他能够支持生命的系外行星，并且我们已经与每个文明友好地结盟。进一步想象，地球上的各种软件系统希望欢迎和包容我们的新朋友，包括`Romulans`和`Orkans`，我们希望调整一些现有软件以轻松适应我们系外行星邻居的新人口统计。考虑到这一点，我们将通过创建一个适配器类`Humanoid`来将我们的`Person`类转换为包含更多系外行星术语。
- en: In our forthcoming implementation, we will use private inheritance to inherit
    `Humanoid` (Adapter) from `Person` (Adaptee), therefore hiding the underlying
    implementation of the Adaptee. We could have alternatively associated a `Humanoid`
    to a `Person` (an implementation we will also review in this section). We can
    then flesh out some derived classes of `Humanoid` within our hierarchy, such as
    `Orkan`, `Romulan` and `Earthling`, to accommodate the intergalactic application
    at hand. The `Orkan`, `Romulan` and `Earthling` classes can be considered our
    Target classes, or those which our application will instantiate. We will choose
    to make our Adapter class, `Humanoid`, abstract so that it is not directly instantiable.
    Because our specific derived classes (Target classes) can be generalized by their
    abstract base class type (`Humanoid`) in our application (Client), we can also
    consider `Humanoid` a Target class. That is, `Humanoid` can be viewed primarily
    as an Adapter, but secondarily as a generalized Target class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将实现的代码中，我们将使用私有继承来从`Person`（被适配者）继承`Humanoid`（适配器），从而隐藏被适配者的底层实现。我们也可以将`Humanoid`关联到`Person`（这也是我们将在本节中审查的一种实现）。然后，我们可以在我们的层次结构中完善一些`Humanoid`的派生类，比如`Orkan`、`Romulan`和`Earthling`，以适应手头的星际应用。`Orkan`、`Romulan`和`Earthling`类可以被视为我们的目标类，或者我们的应用将实例化的类。我们选择将我们的适配器类`Humanoid`设为抽象，以便它不能直接实例化。因为我们的具体派生类（目标类）可以在我们的应用程序（客户端）中由它们的抽象基类类型（`Humanoid`）进行泛化，所以我们也可以将`Humanoid`视为目标类。也就是说，`Humanoid`可以被视为主要是一个适配器，但次要是一个泛化的目标类。
- en: Our various Client classes can utilize derived classes of `Humanoid`, making
    instances of each of its concrete descendants. These instances may be stored in
    their own specialized type or genericized using `Humanoid` pointers. Our implementation
    is a modern take on the well-used Adapter design pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的各种客户端类可以利用`Humanoid`的派生类，创建每个具体后代的实例。这些实例可以存储在它们自己的专门类型中，或者使用`Humanoid`指针进行泛型化。我们的实现是对广泛使用的适配器设计模式的现代化改进。
- en: Specifying the Adaptee and Adapter (private inheritance technique)
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定被适配者和适配器（私有继承技术）
- en: 'Let''s take a look at the mechanics for the first usage of our Adapter pattern,
    beginning by reviewing the definition for our Adaptee class, `Person`. This example
    can be found as a complete program in our GitHub repository:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的适配器模式的第一个用法的机制，首先回顾我们的被适配者类`Person`的定义。这个例子可以在我们的GitHub存储库中找到一个完整的程序。
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex1.cpp)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous class definition, we notice our `Person` class definition is
    as we have been accustomed to seeing it in many other examples throughout this
    book. This class is instantiable; however, `Person` is not an appropriate class
    to instantiate in our intergalactic application. Instead, the expected interface
    would be to utilize that found in `Humanoid`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们注意到我们的`Person`类定义与本书中许多其他示例中看到的一样。这个类是可实例化的；然而，在我们的星际应用中，`Person`不是一个适当的类来实例化。相反，预期的接口应该是利用`Humanoid`中找到的接口。
- en: 'With that in mind, let''s take a look at our Adapter class, `Humanoid`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们来看看我们的适配器类`Humanoid`：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned `Humanoid` class, our goal is to provide an Adapter to
    contribute the expected interface that our intergalactic application requires.
    We simply derive `Humanoid` from `Person` using private inheritance, hiding the
    public interfaces found in `Person` from use outside the scope of `Humanoid`.
    We understand that the target application (Client) would not wish for the public
    interfaces found in `Person` to be utilized by various subtypes of `Humanoid`
    instances. Notice that we are not adding functionality, only adapting the interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Humanoid`类中，我们的目标是提供一个适配器，以满足我们星际应用所需的接口。我们只需使用私有继承，将`Humanoid`从`Person`派生，将`Person`中的公共接口隐藏在`Humanoid`的范围之外。我们知道目标应用（客户端）不希望`Person`中的公共接口被`Humanoid`的各种子类型实例使用。请注意，我们并没有添加功能，只是在适配接口。
- en: We then notice the public methods introduced in `Humanoid` that provide the
    desired interfaces for the Target class(es). The implementation of these interfaces
    is often straightforward. We simply call the inherited method defined in `Person`
    which will easily complete the task at hand (but which uses an unacceptable interface
    to do so). For example, our `Humanoid::GetPrimaryName()` method simply calls `Person::GetLastName();`
    to complete the task. However, `GetPrimaryName()` may more so represent appropriate
    intergalactic lingo than `Person::GetLastName()`. We can see how `Humanoid` is
    serving as an Adapter for `Person`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们注意到`Humanoid`中引入的公共方法，为目标类提供了所需的接口。这些接口的实现通常很简单。我们只需调用`Person`中定义的继承方法，就可以轻松完成手头的任务（但使用了不可接受的接口）。例如，我们的`Humanoid::GetPrimaryName()`方法只是调用`Person::GetLastName();`来完成任务。然而，`GetPrimaryName()`可能更多地代表适当的星际术语，而不是`Person::GetLastName()`。我们可以看到`Humanoid`是作为`Person`的适配器。
- en: Note that it is not necessary to precede the calls to `Person` base class methods
    within Humanoid methods with `Person::` (except when a `Humanoid` method calls
    the same named method in `Person`, such as with `GetTitle()`). The scope resolution
    usage of `Person::` avoids potential recursion in these situations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`Humanoid`方法中调用`Person`基类方法时，不需要在调用前加上`Person::`（除非`Humanoid`方法调用`Person`中同名的方法，比如`GetTitle()`）。`Person::`的作用域解析用法避免了这些情况中的潜在递归。
- en: We also notice that `Humanoid` introduces an abstract polymorphic method (that
    is, a pure virtual function) with the specification of `virtual const char *Converse()
    = 0;`. We have made the design decision that only derived classes of `Humanoid`
    will be instantiable. Nonetheless, we understand that public descendant classes
    may still be collected by their base class type of `Humanoid`. Here, `Humanoid`
    serves primarily as the Adapter class and secondarily as a Target class offering
    the suite of acceptable interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到`Humanoid`引入了一个抽象的多态方法（即纯虚函数），其规范为`virtual const char *Converse() = 0;`。我们已经做出了设计决策，即只有`Humanoid`的派生类才能被实例化。尽管如此，我们理解公共的派生类仍然可以被其基类类型`Humanoid`收集。在这里，`Humanoid`主要作为适配器类，其次作为一个目标类，提供一套可接受的接口。
- en: Notice that our pure virtual function `virtual const char *Converse() = 0;`
    includes a default implementation. This is rare, but allowed so long as the implementation
    is not written inline. Here, we utilize the opportunity to specify a default behavior
    for `Humanoid::Converse()` by simply calling `Person::Speak()`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的纯虚函数`virtual const char *Converse() = 0;`包括一个默认实现。这是罕见的，但只要实现不是内联写的，就是允许的。在这里，我们利用机会通过简单调用`Person::Speak()`来为`Humanoid::Converse()`指定默认行为。
- en: Deriving concrete classes from the Adapter
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从适配器派生具体类
- en: 'Next, let''s extend our Adapter (`Humanoid`) and take a look at one of our
    concrete, derived Target classes, `Orkan`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们扩展我们的适配器（`Humanoid`）并看看我们的一个具体的、派生的目标类`Orkan`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our aforementioned `Orkan` class, we use public inheritance to derive `Orkan`
    from `Humanoid`. An `Orkan` *Is-A* `Humanoid`. As such, all of the public interfaces
    in `Humanoid` are available to `Orkan` instances. Notice that our alternate constructor
    sets the default greeting message to `"Nanu nanu"`, per the `Orkan` dialect.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面提到的`Orkan`类中，我们使用公共继承来从`Humanoid`派生`Orkan`。`Orkan` *是一个* `Humanoid`。因此，`Humanoid`中的所有公共接口都对`Orkan`实例可用。请注意，我们的替代构造函数将默认问候消息设置为`"Nanu
    nanu"`，符合`Orkan`方言。
- en: Because we wish `Orkan` to be a concrete, instantiable class, we must override
    `Humanoid::Converse()` and provide an implementation in the `Orkan` class. Notice,
    however, that `Orkan::Converse()` simply calls `Humanoid::Converse();`. Perhaps
    `Orkan` finds the default implementation in its base class acceptable. Notice
    that we use the `Humanoid::` scope resolution to qualify `Converse()` within the
    `Orkan::Converse()` method to avoid recursion.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望`Orkan`是一个具体的、可实例化的类，所以我们必须重写`Humanoid::Converse()`并在`Orkan`类中提供一个实现。然而，请注意，`Orkan::Converse()`只是调用了`Humanoid::Converse();`。也许`Orkan`认为其基类中的默认实现是可以接受的。请注意，我们在`Orkan::Converse()`方法中使用`Humanoid::`作用域解析来限定`Converse()`，以避免递归。
- en: Interestingly, had `Humanoid` not been an abstract class, `Orkan` would not
    have had to override `Converse()` – the default behavior would have automatically
    been inherited. Yet, with `Humanoid` defined as abstract, the override of `Converse()`
    is necessary in `Orkan`, otherwise `Orkan` will also be viewed as an abstract
    class. No worries! We can utilize the benefit of the default behavior of `Humanoid::Converse()`
    merely by calling it within `Orkan::Converse()`. This will satisfy the requirements
    for making `Orkan` concrete, while allowing `Humanoid` to remain abstract, while
    still providing the rare default behavior for `Converse()`!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果`Humanoid`不是一个抽象类，`Orkan`就不需要重写`Converse()` - 默认行为会自动继承。然而，由于`Humanoid`被定义为抽象类，所以在`Orkan`中重写`Converse()`是必要的，否则`Orkan`也会被视为抽象类。别担心！我们可以通过在`Orkan::Converse()`中调用`Humanoid::Converse()`来利用`Humanoid::Converse()`的默认行为。这将满足使`Orkan`具体化的要求，同时允许`Humanoid`保持抽象，同时为`Converse()`提供罕见的默认行为！
- en: 'Now, let''s take a look at our next concrete Target class, `Romulan`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下我们的下一个具体的目标类`Romulan`：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Taking a comparably quick look at the aforementioned `Romulan` class, we notice
    that this concrete Target is similar to its sibling class, `Orkan`. We notice
    that the default message for the greeting passed up to our base class constructor
    is `"jolan'tru"` to reflect `Romulan` dialect. Though we could have made our implementation
    of `Romulan::Converse()` more intricate, we chose not to do so. We can quickly
    understand the full scope of this class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下前面提到的`Romulan`类，我们注意到这个具体的目标与其兄弟类`Orkan`相似。我们注意到传递给我们基类构造函数的默认问候消息是`"jolan'tru"`，以反映`Romulan`方言。虽然我们可以使`Romulan::Converse()`的实现更加复杂，但我们选择不这样做。我们可以快速理解这个类的全部范围。
- en: 'Next, let''s take a look at our third Target class, `Earthling`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下我们的第三个目标类`Earthling`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, taking another comparably quick look at the aforementioned `Earthling`
    class, we notice that this concrete Target is similar to its sibling classes,
    `Orkan` and `Romulan`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次快速看一下前面提到的`Earthling`类，我们注意到这个具体的目标与其兄弟类`Orkan`和`Romulan`相似。
- en: Now that we have defined our Adaptee, Adapter and multiple Target classes, let's
    bring the pieces together by examining the Client portion of our program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的被适配者、适配器和多个目标类，让我们通过检查程序的客户端部分来将这些部分组合在一起。
- en: Bringing the pattern components together
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件结合在一起
- en: Finally, let us consider what a sample Client may look like in our overall application.
    Certainly, it may consist of many files with a variety of classes. In its simplest
    form, as shown next, our Client will contain a `main()` function to drive the
    application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一下我们整个应用程序中的一个示例客户端可能是什么样子。当然，它可能由许多文件和各种类组成。在其最简单的形式中，如下所示，我们的客户端将包含一个`main()`函数来驱动应用程序。
- en: 'Let''s now take a look at our `main()` function to see how our pattern is orchestrated:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下我们的`main()`函数，看看我们的模式是如何被编排的：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reviewing our aforementioned `main()` function, we first create an `STL` `list`
    of `Humanoid` pointers with `list<Humanoid *> allies;`. We then instantiate an
    `Orkan`, `Romulan` and an `Earthling` and add each to the list using `allies.push_back()`.
    Again, using the `STL`, we next create a list iterator to walk through the list
    of pointers to `Humanoid` instances. As we iterate through our generalized list
    of allies, we call the approved interfaces of `GetInfo()` and `Converse()` on
    each item in our list (that is, for each specific type of `Humanoid`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们上述的`main()`函数，我们首先创建一个`STL` `list` of `Humanoid`指针，使用`list<Humanoid *> allies;`。然后，我们实例化一个`Orkan`，`Romulan`和一个`Earthling`，并使用`allies.push_back()`将它们添加到列表中。再次使用`STL`，我们接下来创建一个列表迭代器，以遍历指向`Humanoid`实例的指针列表。当我们遍历我们的盟友的通用列表时，我们对列表中的每个项目调用`GetInfo()`和`Converse()`的批准接口（也就是说，对于每种特定类型的`Humanoid`）。
- en: Next, we specify one specific `Humanoid`, an `Earthling`, and change this instance's
    default greeting by invoking `e1->SetSalutation("Bonjour");`. By calling `Converse()`
    again on this instance (we first did so on this object generically in the aforementioned
    loop), we can request that the `Earthling` uses `"Bonjour"` to greet allies instead
    of `"Hello"` (the default greeting for `Earthling`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定一个特定的`Humanoid`，一个`Earthling`，并通过调用`e1->SetSalutation("Bonjour");`来更改这个实例的默认问候语。通过再次在这个实例上调用`Converse()`（我们首先在上述循环中以通用方式这样做），我们可以请求`Earthling`使用`"Bonjour"`来向盟友打招呼，而不是使用`"Hello"`（`Earthling`的默认问候语）。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the aforementioned output, notice that the planetary specification for each
    `Humanoid` is displayed (`Orkan`, `Romulan`, `Earthling`), followed by their secondary
    and primary names. Then the appropriate greeting is displayed for the particular
    `Humanoid`. Notice that `Earthling` `Eve Xu` first converses using `"Hello"` and
    then later converses using `"Bonjour"`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，请注意每个`Humanoid`的行星规格（`Orkan`，`Romulan`，`Earthling`），然后显示它们的次要和主要名称。然后显示特定`Humanoid`的适当问候语。请注意，`Earthling`
    `Eve Xu`首先使用`"Hello"`进行对话，然后稍后使用`"Bonjour"`进行对话。
- en: An advantage of the preceding implementation (using a private base class to
    derive Adapter from Adaptee) is that the coding is very straightforward. With
    this approach, any protected methods in the Adaptee class can easily be carried
    down to be used within the scope of the Adapter methods. We will soon see that
    protected members will be an issue should we instead use association as a means
    of connecting the Adapter to Adaptee.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前述实现的优点（使用私有基类从Adaptee派生Adapter）是编码非常简单。通过这种方法，Adaptee类中的任何受保护的方法都可以轻松地传递下来在Adapter方法的范围内使用。我们很快会看到，如果我们改用关联作为连接Adapter到Adaptee的手段，受保护的成员将成为一个问题。
- en: A disadvantage of the prior mentioned approach is that it is a C++ specific
    implementation. Other languages do not support private base classes. Alternatively,
    using a public base class to define the relationship between Adapter and Adaptee
    would fail to conceal the unwanted Adaptee interface, and would be a very poor
    design choice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法的缺点是它是一个特定于C++的实现。其他语言不支持私有基类。另外，使用公共基类来定义Adapter和Adaptee之间的关系将无法隐藏不需要的Adaptee接口，并且是一个非常糟糕的设计选择。
- en: Considering an alternate specification of Adaptee and Adapter (association)
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑Adaptee和Adapter的替代规范（关联）
- en: Let us now briefly consider a slightly revised version of the aforementioned
    Adapter pattern implementation. We will instead use an association to model the
    relationship between the Adaptee and Adapter. The concrete derived classes (Targets)
    will still be derived from the Adapter as before.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地考虑一下稍微修改过的上述Adapter模式实现。我们将使用关联来模拟Adaptee和Adapter之间的关系。具体的派生类（Targets）仍将像以前一样从Adapter派生。
- en: 'Here is an alternative implementation of our Adapter class, `Humanoid`, using
    an association between Adapter and Adaptee. Though we will only review the portion
    of the code which differs from our initial approach, the full implementation can
    be found as a complete program in our GitHub:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们Adapter类`Humanoid`的另一种实现，使用Adapter和Adaptee之间的关联。虽然我们只会审查与我们最初的方法不同的代码部分，但完整的实现可以在我们的GitHub上找到作为一个完整的程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex2.cpp)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex2.cpp)'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice in the aforementioned implementation of our Adapter class, `Humanoid`
    is no longer derived from `Person`. Instead, `Humanoid` will add a private data
    member `Person *life;` which will represent an association between the Adapter
    (`Humanoid`) and the Adaptee (`Person`). In our Humanoid constructors, we will
    need to allocate the underlying implementation of the Adaptee (`Person`). We will
    also need to delete the Adaptee (`Person`) in our destructor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们上述的Adapter类的实现中，`Humanoid`不再是从`Person`派生的。相反，`Humanoid`将添加一个私有数据成员`Person
    *life;`，它将表示Adapter（`Humanoid`）和Adaptee（`Person`）之间的关联。在我们的Humanoid构造函数中，我们需要分配Adaptee（`Person`）的基础实现。我们还需要在析构函数中删除Adaptee（`Person`）。
- en: Similar to our last implementation, `Humanoid` offers the same member functions
    within its public interface. However, notice that each `Humanoid` method delegates,
    through the associated object, a call to the appropriate Adaptee methods. For
    example, `Humanoid::GetSecondaryName()` merely calls `life->GetFirstName();` to
    delegate the request (versus calling the inherited, corresponding Adaptee methods).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们上次的实现类似，`Humanoid`在其公共接口中提供相同的成员函数。但是，请注意，每个`Humanoid`方法通过关联对象委托调用适当的Adaptee方法。例如，`Humanoid::GetSecondaryName()`仅调用`life->GetFirstName();`来委托请求（而不是调用继承的相应Adaptee方法）。
- en: As in our initial implementation, our derived classes from `Humanoid` (`Orkan`,
    `Romulan` and `Earthling`) are specified in the same fashion, as is our Client
    within our `main()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们最初的实现一样，我们从`Humanoid`（`Orkan`，`Romulan`和`Earthling`）派生的类以相同的方式指定，我们的客户端也在`main()`函数中。
- en: Choosing the relationship between Adaptee and Adapter
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择被适配者和适配器之间的关系
- en: An interesting point to consider when choosing between private inheritance or
    association as the relationship between Adapter and Adaptee is whether or not
    the Adaptee contains any protected members. Recall, the original code for `Person`
    included a protected `ModifyTitle()` method. Should protected members exist in
    the Adaptee class, the private base class implementation allows those inherited,
    protected members to continue to be accessed within the scope of the Adapter class
    (that is, by methods of the Adapter). However, using the association-based implementation,
    the protected methods in the Adaptee (`Person`) are unusable in the scope of the
    Adapter. To make this example work, we were required to move `Person::ModifyTitle()`
    to the public access region. However, modifying the Adaptee class is not always
    possible, nor is it necessarily recommended. Considering the protected member
    issue, our initial implementation using a private base class is the stronger implementation,
    as it does not depend on us modifying the class definition of the Adaptee (`Person`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择适配器和被适配者之间的关系时，一个有趣的点是选择私有继承还是关联的关系，这取决于被适配者是否包含任何受保护的成员。回想一下，`Person`的原始代码包括一个受保护的`ModifyTitle()`方法。如果被适配者类中存在受保护的成员，私有基类实现允许在适配器类的范围内继续访问这些继承的受保护成员（也就是适配器的方法）。然而，使用基于关联的实现，被适配者（`Person`）中的受保护方法在适配器的范围内是无法使用的。为了使这个例子工作，我们需要将`Person::ModifyTitle()`移到公共访问区域。然而，修改被适配者类并不总是可能的，也不一定推荐。考虑到受保护成员的问题，我们最初使用私有基类的实现是更强大的实现，因为它不依赖于我们修改被适配者（`Person`）的类定义。
- en: Let us now take a brief look at an alternate usage of the Adapter pattern. We
    will simply be using an Adapter class as a wrapper class. We will add an OO interface
    to an otherwise loosely arranged set of functions which work well, but lack the
    desired interface our application (Client) desires.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简要地看一下适配器模式的另一种用法。我们将简单地使用一个适配器类作为包装类。我们将为一个本来松散排列的一组函数添加一个面向对象的接口，这些函数工作得很好，但缺乏我们的应用程序（客户端）所需的接口。
- en: Using an Adapter as a wrapper
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适配器作为包装器
- en: As an alternative usage of the Adapter pattern, we will wrap an OO interface
    around a grouping of related external functions. That is, we will create a wrapper
    class to encapsulate these functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为适配器模式的另一种用法，我们将在一组相关的外部函数周围包装一个面向对象的接口。也就是说，我们将创建一个包装类来封装这些函数。
- en: In our example, the external functions will represent a suite of existing database
    access functions. We will assume that the core database functionality is well
    tested for our data type (`Person`) and has been used problem-free. However, these
    external functions, by themselves, present an undesirable and unexpected functional
    interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，外部函数将代表一套现有的数据库访问函数。我们将假设核心数据库功能对于我们的数据类型（`Person`）已经经过了充分测试，并且已经被无问题地使用。然而，这些外部函数本身提供了一个不可取和意外的功能接口。
- en: We will instead wrap the external functions by creating an Adapter class to
    encapsulate their collective functionality. Our Adapter class will be `CitizenDataBase`,
    representing an encapsulated means for reading and writing `Person` instances
    from and to a database. Our existing external functions will provide the implementation
    for our `CitizenDataBase` member functions. Let us assume that the OO interfaces
    as defined in our Adapter class meet the requirements of our OO design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将通过创建一个适配器类来封装这些外部函数的集体功能。我们的适配器类将是`CitizenDataBase`，代表了一个封装的方式，用于从数据库中读取和写入`Person`实例。我们现有的外部函数将为我们的`CitizenDataBase`成员函数提供实现。让我们假设在我们的适配器类中定义的面向对象的接口满足我们的面向对象设计的要求。
- en: 'Let''s take a look at the mechanics for our simple wrapper Adapter pattern,
    beginning by examining external functions providing the database access functionality.
    This example can be found as a complete program in our GitHub repository:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们简单包装的适配器模式的机制，首先要检查提供数据库访问功能的外部函数。这个例子可以在我们的GitHub仓库中找到一个完整的程序：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex3.cpp)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter18/Chp18-Ex3.cpp)'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our previously defined external functions, let's assume all functions are
    well tested and allow `Person` instances to be read from or written to a database.
    To support this simulation, we have created an external `Person` instance with
    `Person objectRead;` to provide a brief, non-stack located storage place for a
    newly read instance (used by `db_read()`) until the newly read instance is captured
    as a return value. Keep in mind that the existing external functions do not represent
    an encapsulated solution.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前定义的外部函数中，让我们假设所有函数都经过了充分测试，并且允许从数据库中读取或写入`Person`实例。为了支持这个模拟，我们创建了一个外部`Person`实例`Person
    objectRead;`，提供了一个简短的、非堆栈位置的存储位置，用于新读取的实例（被`db_read()`使用），直到新读取的实例被捕获为返回值。请记住，现有的外部函数并不代表一个封装的解决方案。
- en: 'Now, let''s create a simple wrapper class to encapsulate these external functions.
    The wrapper class, `CitizensDataBase`, will represent our Adapter class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的包装类来封装这些外部函数。包装类`CitizensDataBase`将代表我们的适配器类：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In our aforementioned class definition for our Adapter class, we simply encapsulate
    the external database functionality within the `CitizenDataBase` class. Here,
    `CitizenDataBase` is not only our Adapter class, but our Target class as it contains
    the interfaces our application at hand (Client) expects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上述的适配器类定义中，我们只是在`CitizenDataBase`类中封装了外部数据库功能。在这里，`CitizenDataBase`不仅是我们的适配器类，也是我们的目标类，因为它包含了我们手头应用程序（客户端）期望的接口。
- en: 'Now, let''s take a look at our `main()` function, which is a streamlined version
    of a Client:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的`main()`函数，这是一个客户端的简化版本：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the aforementioned `main()` function, we first instantiate three `Person`
    instances. We then instantiate a `CitizenDataBase` to provide encapsulated access
    to write or read our `Person` instances to or from the database. The methods for
    our `CitizenDataBase` constructors call the external function `db_open()` to open
    the database. Likewise, the destructor calls `db_close()`. As expected, our `CitizenDataBase`
    methods for `Read()` and `Write()` will each, respectively, call the external
    functions `db_read()` or `db_write()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`main()`函数中，我们首先实例化了三个`Person`实例。然后实例化了一个`CitizenDataBase`，以提供封装的访问权限，将我们的`Person`实例写入或从数据库中读取。我们的`CitizenDataBase`构造函数的方法调用外部函数`db_open()`来打开数据库。同样，析构函数调用`db_close()`。正如预期的那样，我们的`CitizenDataBase`的`Read()`和`Write()`方法分别调用外部函数`db_read()`或`db_write()`。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the aforementioned output, we can notice the correlation between the various
    member functions to the wrapped, external functions via construction, a call to
    write and read, and then the destruction of the database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以注意到各个成员函数与包装的外部函数之间的相关性，通过构造、调用写入和读取，然后销毁数据库。
- en: Our simple `CitizenDataBase` wrapper is a very straightforward, but reasonable
    use of the Adapter pattern. Interestingly, our `CitizenDataBase` also has commonalities
    with the **Data Access Object pattern**, as this wrapper provides a clean interface
    to a data storage mechanism, concealing the implementation (access) to the underlying
    database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的`CitizenDataBase`包装器是适配器模式的一个非常简单但合理的用法。有趣的是，我们的`CitizenDataBase`也与**数据访问对象模式**有共同之处，因为这个包装器提供了一个干净的接口来访问数据存储机制，隐藏了对底层数据库的实现（访问）。
- en: We have now seen three implementations of the Adapter pattern. We have folded
    the concepts of Adapter, Adaptee, Target and Client into the framework of classes
    we are accustomed to seeing, namely `Person`, as well as into descendants of our
    Adapter (`Orkan`, `Romulan`, `Earthling`, as in our first two examples). Let us
    now briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了适配器模式的三种实现。我们已经将适配器、被适配者、目标和客户端的概念融入到我们习惯看到的类的框架中，即`Person`，以及我们适配器的后代（`Orkan`、`Romulan`、`Earthling`，就像我们前两个例子中的那样）。让我们现在简要地回顾一下我们在移动到下一章之前学到的与模式相关的知识。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have advanced our pursuit to become better C++ programmers
    through widening our knowledge of design patterns. We have explored the Adapter
    pattern in both concept and through multiple implementations. Our first implementation
    used private inheritance to derive the Adapter from the Adaptee class. We specified
    our Adapter as an abstract class and then used public inheritance to introduce
    several Target classes based on the interface provided by our Adapter class. Our
    second implementation instead modeled the relationship between the Adapter and
    Adaptee using association. We then looked at an example usage of an Adapter as
    a wrapper to simply add an OO interface to existing function-based application
    components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过扩展我们对设计模式的知识，进一步提高了成为更好的C++程序员的追求。我们已经在概念和多种实现中探讨了适配器模式。我们的第一个实现使用私有继承从被适配者类派生适配器。我们将适配器指定为抽象类，然后使用公共继承根据适配器类提供的接口引入了几个基于接口的目标类。我们的第二个实现则使用关联来建模适配器和被适配者之间的关系。然后我们看了一个适配器作为包装器的示例用法，简单地为现有基于函数的应用组件添加了面向对象的接口。
- en: Utilizing common design patterns, such as the Adapter pattern, will help you
    more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By utilizing core design patterns, you will be contributing
    to well understood and reusable solutions with more sophisticated programming
    techniques.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 利用常见的设计模式，比如适配器模式，将帮助你更容易地重用现有的经过充分测试的代码部分，以一种其他程序员能理解的方式。通过利用核心设计模式，你将为更复杂的编程技术做出贡献，提供了被理解和可重用的解决方案。
- en: We are now ready to continue forward with our next design pattern in [*Chapter
    19*](B15702_19_Final_NM_ePub.xhtml#_idTextAnchor718), *Using the Singleton Pattern*.
    Adding more patterns to our arsenal of programming skills makes us more versatile
    and valued programmers. Let's continue forward!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续前进，进入我们的下一个设计模式[*第19章*]，*使用单例模式*。增加更多的模式到我们的编程技能库中，使我们成为更多才多艺和有价值的程序员。让我们继续前进！
- en: Questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the Adapter examples found in this chapter:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章中找到的适配器示例：
- en: 'a. Implement a `CitizenDataBase` that stores various types of `Humanoid` instances
    (`Orkan`, `Romulan`, `Earthling`, and perhaps `Martian`). Decide whether you will
    use the private base class Adapter-Adaptee relationship or the association relationship
    between the Adapter and Adaptee (hint: the private inheritance version will be
    easier).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实现一个`CitizenDataBase`，用于存储各种类型的`Humanoid`实例（`Orkan`、`Romulan`、`Earthling`，也许还有`Martian`）。决定你是使用私有基类适配器-被适配者关系，还是适配器和被适配者之间的关联关系（提示：私有继承版本会更容易）。
- en: b. Noting that the `CitizenDataBase` handles `Person` instances, can this class
    be used *as-is* to store various types of `Humanoid` instances, or must it be
    adapted in some way? Recall, `Person` is a base class of `Humanoid` (if you chose
    this implementation), but also remember that we can never upcast past a non-public
    inheritance boundary.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: b. 注意`CitizenDataBase`处理`Person`实例，这个类是否可以原样用来存储各种类型的`Humanoid`实例，还是必须以某种方式进行适配？请记住，`Person`是`Humanoid`的基类（如果你选择了这种实现方式），但也要记住我们永远不能向上转型超出非公共继承边界。
- en: What other examples can you imagine which might easily incorporate the Adapter
    pattern?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象哪些其他例子可能很容易地应用适配器模式？
