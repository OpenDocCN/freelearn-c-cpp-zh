- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Setting Up Collision Objects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置碰撞对象
- en: In the previous chapter, we covered some of the basic concepts of collision,
    namely Line Traces and Sweep Traces. We learned how to execute different types
    of Line Traces, how to create custom Trace Channels, and how to change how an
    object responds to a specific channel. Many of the things you learned in the previous
    chapter will be used in this chapter, where we’ll learn about object collision.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们介绍了一些碰撞的基本概念，即线迹和扫描迹。我们学习了如何执行不同类型的线迹，如何创建自定义迹通道，以及如何改变对象对特定通道的响应。你在前一章中学到的许多内容将在本章中使用，我们将学习物体碰撞。
- en: Throughout this chapter, we will continue to build upon our top-down Dodgeball
    game by adding game mechanics that revolve around object collision. We will create
    the Dodgeball actor, which will act as a dodgeball that bounces off of the floor
    and walls; the Wall actor, which will block all objects; the Ghost Wall actor,
    which will only block the player, not the enemies’ lines of sight or the dodgeball;
    and the Victory Box actor, which will end the game when the player enters the
    Victory Box, representing the end of the level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建我们的自上而下的躲避球游戏，通过添加围绕物体碰撞的游戏机制来扩展游戏。我们将创建躲避球演员，它将作为在地板和墙上弹跳的躲避球；墙壁演员，它将阻挡所有物体；幽灵墙壁演员，它将只阻挡玩家，不阻挡敌人的视线或躲避球；以及胜利框演员，当玩家进入胜利框时，游戏结束，代表关卡结束。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding object collision in UE5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解UE5中的物体碰撞
- en: Understanding collision components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解碰撞组件
- en: Understanding collision events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解碰撞事件
- en: Understanding collision channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解碰撞通道
- en: Creating physical materials
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建物理材质
- en: Introducing timers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍计时器
- en: Understanding how to spawn actors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何生成演员
- en: Before we start creating our `Dodgeball` class, we will go over the basic concepts
    of object collision.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建我们的`Dodgeball`类之前，我们将回顾物体碰撞的基本概念。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter06 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的Chapter06文件夹中找到，可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Understanding object collision in UE5
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解UE5中的物体碰撞
- en: Every game development tool must have a physics engine that simulates collision
    between multiple objects, as explained in the previous chapter. Collision is the
    backbone of most games released nowadays, whether 2D or 3D. In many games, it’s
    the main way in which the player acts upon the environment, be it running, jumping,
    or shooting, and the environment acts accordingly by making the player land, get
    hit, and so on. It is no understatement to say that, without simulated collision,
    it wouldn’t be possible to make many games at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏开发工具都必须有一个物理引擎，它可以模拟多个物体之间的碰撞，如前一章所述。碰撞是当今大多数游戏的核心，无论是2D还是3D。在许多游戏中，它是玩家对环境的主要作用方式，无论是跑步、跳跃还是射击，环境会相应地让玩家落地、被击中等。没有模拟碰撞，根本不可能制作出许多游戏，这并不过分。
- en: So, let’s understand how object collision works in UE5 and how we can use it,
    starting with collision components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们了解UE5中物体碰撞的工作原理以及我们如何使用它，从碰撞组件开始。
- en: Understanding collision components
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解碰撞组件
- en: 'In UE5, two types of components can affect and be affected by collision; they
    are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中，有两种类型的组件可以影响并受到碰撞的影响；它们如下：
- en: Meshes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格
- en: Shape objects
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状对象
- en: '**Meshes** can be as simple as a cube, or as complex as a high-resolution character
    with tens of thousands of vertices. A mesh’s collision can be specified with a
    custom file imported alongside the mesh into UE5 (which is outside the scope of
    this book), or it can be calculated automatically by UE5 and customized by you.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**网格**可以像立方体一样简单，也可以像具有数万个顶点的高分辨率角色一样复杂。网格的碰撞可以通过将自定义文件与网格一起导入UE5（本书范围之外）来指定，或者可以由UE5自动计算并由您自定义。'
- en: 'It is generally a good practice to keep the collision mesh as simple (for example,
    a few triangles) as possible so that the physics engine can efficiently calculate
    collision at runtime. The types of meshes that can have collision are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，保持碰撞网格尽可能简单（例如，几个三角形）是一个好的做法，这样物理引擎就可以在运行时有效地计算碰撞。可以具有碰撞的网格类型如下：
- en: '**Static Meshes**: Meshes that are defined as static and do not change.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态网格**: 被定义为静态且不改变的网格。'
- en: '**Skeletal Meshes**: Meshes that can have a skeleton and change their poses,
    which allows them to be animated. Character meshes, for instance, are skeletal
    meshes.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼网格**: 可以有骨骼并改变其姿势的网格，这使得它们可以被动画化。例如，角色网格就是骨骼网格。'
- en: '**Procedural Meshes**: Meshes that can be generated automatically according
    to certain parameters.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程网格**: 可以根据某些参数自动生成的网格。'
- en: '**Shape objects**, which are simple meshes represented in wireframe mode, are
    used to behave as collision objects by causing and receiving collision events.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**形状对象**，在线框模式下表示的简单网格，通过引起和接收碰撞事件来作为碰撞对象使用。'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Wireframe mode is a commonly used visualization mode in game development, usually
    for debugging purposes, which allows you to see meshes without any faces or textures
    – they can only be seen through their edges, which are connected by their vertices.
    You will see what wireframe mode is when we add a **Shape** component to an actor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 线框模式是游戏开发中常用的一种可视化模式，通常用于调试目的，它允许你看到没有面或纹理的网格 – 你只能通过它们的边缘看到，这些边缘通过顶点连接。当你给我们添加一个
    **Shape** 组件到演员时，你将看到线框模式是什么样子。
- en: 'Please note that `Shape` objects are essentially invisible meshes and that
    their three types are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Shape` 对象本质上是无形的网格，并且它们的三种类型如下：
- en: Box Collision (Box Component in C++)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱体碰撞（C++ 中的箱体组件）
- en: Sphere Collision (Sphere Component in C++)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球形碰撞（C++ 中的球形组件）
- en: Capsule Collider (Capsule Component in C++)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆柱碰撞体（C++ 中的圆柱组件）
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There’s a class that all the components that provide geometry and collision
    inherit from, which is the `Primitive` component. This component is the basis
    for all components that contain any sort of geometry, which is the case for mesh
    components and shape components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提供几何形状和碰撞的组件都继承自一个类，即 `Primitive` 组件。这个组件是所有包含任何类型几何形状的组件的基础，这对于网格组件和形状组件来说都是适用的。
- en: So, how can these components collide, and what happens when they do? We shall
    have a look at this in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些组件如何碰撞，它们碰撞时会发生什么？我们将在下一节中探讨这个问题。
- en: Understanding collision events
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解碰撞事件
- en: 'Let’s say that two objects are colliding with one another. Two things can happen:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个对象正在相互碰撞。可能会发生以下两种情况：
- en: They overlap each other, as if the other object weren’t there, in which case
    the `Overlap` event is called.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们相互重叠，就像另一个对象不存在一样，在这种情况下会调用 `Overlap` 事件。
- en: They collide and prevent each other from continuing their course, in which case
    the `Block` event is called.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们相互碰撞并阻止对方继续前进，在这种情况下会调用 `Block` 事件。
- en: In the previous chapter, we learned how to change an object’s response to a
    specific `Trace` channel. During this process, we learned that an object’s response
    can be either `Block`, `Overlap`, or `Ignore`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何改变对象对特定 `Trace` 通道的响应。在这个过程中，我们了解到对象的响应可以是 `Block`、`Overlap` 或
    `Ignore`。
- en: 'Now, let’s see what happens in each of these responses during a collision:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在碰撞过程中这些响应各自会发生什么：
- en: '`Block`:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Block`:'
- en: Both objects will have their `OnHit` events called. This event is called whenever
    two objects block each other’s path at the moment they collide. If one of the
    objects is simulating physics, that object must have its `SimulationGeneratesHitEvents`
    property set to `true`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象都会调用它们的 `OnHit` 事件。这个事件在两个对象在碰撞时阻塞对方的路径时被调用。如果其中一个对象正在模拟物理，那么该对象必须将其 `SimulationGeneratesHitEvents`
    属性设置为 `true`。
- en: Both objects will physically stop each other from continuing with their course.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象都会在物理上阻止对方继续前进。
- en: 'The following diagram shows an example of when two objects are thrown and bounce
    off each other:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两个对象相互抛掷并相互弹开的示例：
- en: '![Figure 6.1 – Object A and object B blocking each other ](img/Figure_6.01_B18531.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 对象 A 和对象 B 相互阻塞](img/Figure_6.01_B18531.jpg)'
- en: Figure 6.1 – Object A and object B blocking each other
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 对象 A 和对象 B 相互阻塞
- en: '`GenerateOverlapEvents` property set to `true`, they will have their `OnBeginOverlap`
    and `OnEndOverlap` events called. These overlap events are called when an object
    starts and stops overlapping another object, respectively. If at least one of
    them doesn’t have this property set to `true`, neither of them will call these
    events.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `GenerateOverlapEvents` 属性设置为 `true`，它们将调用其 `OnBeginOverlap` 和 `OnEndOverlap`
    事件。这些重叠事件在对象开始和停止重叠另一个对象时分别调用。如果其中至少一个没有将此属性设置为 `true`，则它们都不会调用这些事件。
- en: The objects act as if the other object doesn’t exist and will overlap each other.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象表现得好像另一个对象不存在，并将重叠在一起。
- en: As an example, suppose the player’s character walks into a trigger box that
    marks the end of the level, which only reacts to the player’s character.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设玩家的角色走进一个标记关卡结束的触发框，这个触发框只对玩家的角色做出反应。
- en: 'The following diagram shows an example of two objects overlapping each other:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两个对象重叠的示例：
- en: '![Figure 6.2 – Object A and object B overlapping each other ](img/Figure_6.02_B18531.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 对象A和对象B重叠在一起](img/Figure_6.02_B18531.jpg)'
- en: Figure 6.2 – Object A and object B overlapping each other
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 对象A和对象B重叠在一起
- en: '`Overlap` response, the objects will act as if the other object doesn’t exist
    and will overlap each other.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠**响应，对象将表现得好像另一个对象不存在，并将重叠在一起。'
- en: An example of two objects ignoring each other would be when an object other
    than the player’s character goes into a trigger box that marks the end of the
    level, which only reacts to the player’s character.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象忽略彼此的一个例子是，当除了玩家的角色之外的对象进入标记关卡结束的触发框时，这个触发框只对玩家的角色做出反应。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can look at the previous diagram, where two objects overlap each other,
    to understand **Ignore**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看两个对象重叠的先前图表，以了解**忽略**。
- en: 'The following table will help you understand the necessary responses that two
    objects must have to trigger the previously described situations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将帮助您了解两个对象必须采取的必要响应，以触发之前描述的情况：
- en: '![Figure 6.3 – Resulting responses on objects based on Block, Overlap, and
    Ignore ](img/Figure_6.03_B18531.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 基于“阻止”、“重叠”和“忽略”的对象的响应结果](img/Figure_6.03_B18531.jpg)'
- en: Figure 6.3 – Resulting responses on objects based on Block, Overlap, and Ignore
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 基于“阻止”、“重叠”和“忽略”的对象的响应结果
- en: 'Following this table, consider that you have two objects – object A and object
    B:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据下表，假设你有两个对象——对象A和对象B：
- en: If object A has set its response to object B to **Block** and object B has set
    its response to object A to **Block**, they will **Block** each other.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象A将其对对象B的响应设置为**阻止**，而对象B将其对对象A的响应设置为**阻止**，它们将**阻止**彼此。
- en: If object A has set its response to object B to **Block** and object B has set
    its response to object A to **Overlap**, they will **Overlap** each other.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象A将其对对象B的响应设置为**阻止**，而对象B将其对对象A的响应设置为**重叠**，它们将**重叠**在一起。
- en: If object A has set its response to object B to **Ignore** and object B has
    set its response to object A to **Overlap**, they will **Ignore** each other.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象A将其对对象B的响应设置为**忽略**，而对象B将其对对象A的响应设置为**重叠**，它们将**忽略**彼此。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a full reference to UE5’s collision interactions at [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Overview)找到UE5的碰撞交互的完整参考。
- en: 'A collision between objects has two aspects to it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 物体之间的碰撞有两个方面：
- en: '**Physics**: All collisions related to physics simulation, such as a ball being
    affected by gravity and bouncing off the floors and walls.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**：所有与物理模拟相关的碰撞，例如球体受到重力影响并在地板和墙壁上弹跳。'
- en: 'The physically simulated response of the collision within the game can be either
    of the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中碰撞的物理模拟响应可以是以下两种情况之一：
- en: Both objects continue their trajectories as if the other object wasn’t there
    (no physical collision).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象继续它们的轨迹，就好像另一个对象不存在一样（没有物理碰撞）。
- en: Both objects collide and change their trajectories, usually with at least one
    of them continuing its movement – that is, they are blocking each other’s paths.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象发生碰撞并改变它们的轨迹，通常至少有一个对象会继续其运动——也就是说，它们正在阻挡彼此的路径。
- en: '`OnHit` event'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHit` 事件'
- en: The `OnBeginOverlap` event
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnBeginOverlap` 事件'
- en: The `OnEndOverlap` event
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEndOverlap` 事件'
- en: 'The physical response to the collision within the game, which can be either
    of the following:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中碰撞的物理反应，可以是以下两种情况之一：
- en: Both objects continued their movement as if the other object wasn’t there (no
    physical collision)
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象继续移动，就像另一个对象不存在一样（没有物理碰撞）
- en: Both objects collide and block each other’s path
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个对象发生碰撞并阻挡了彼此的路径
- en: The physical response from the physics aspect may sound similar to the physical
    response from the query aspect; however, although they are both physical responses,
    they will cause objects to behave differently.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 物理方面的物理反应可能听起来与查询方面的物理反应相似；然而，尽管它们都是物理反应，但它们会导致对象以不同的方式表现。
- en: The physical response from the physics aspect (physics simulation) only applies
    when an object is simulating physics (for example, being affected by gravity,
    bouncing off the walls and ground, and so on). Such an object, when hitting a
    wall, for instance, will bounce back and continue moving in another direction.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 物理方面的物理反应（物理模拟）仅适用于对象模拟物理时（例如，受到重力影响、从墙壁和地面上弹起等）。例如，当这样的对象撞到墙壁时，它会弹回并继续向另一个方向移动。
- en: On the other hand, the physical response from the query aspect applies to all
    objects that don’t simulate physics. An object can move without simulating physics
    when being controlled by code (for example, by using the `SetActorLocation` function
    or by using the **Character Movement** component). In this case, depending on
    which method you use to move the object and its properties, when an object hits
    a wall, it will simply stop moving instead of bouncing back. This is because you’re
    simply telling the object to move in a certain direction and something is blocking
    its path, so the physics engine doesn’t allow that object to continue moving.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，查询方面的物理反应适用于所有不模拟物理的对象。当对象由代码控制时（例如，使用`SetActorLocation`函数或使用**角色移动**组件），对象可以不模拟物理而移动。在这种情况下，根据你用来移动对象的方法及其属性，当对象撞到墙壁时，它将简单地停止移动而不是弹回。这是因为你只是告诉对象向某个方向移动，而某个东西阻挡了它的路径，因此物理引擎不允许该对象继续移动。
- en: Now that we’ve learned about collision events, let’s move on to the next section,
    where we will be looking at collision channels.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了碰撞事件，让我们继续到下一节，我们将探讨碰撞通道。
- en: Understanding collision channels
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解碰撞通道
- en: In the previous chapter, a looked at the existing Trace Channels (*Visibility*
    and *Camera*) and learned how to make a custom channel. Now that you know about
    Trace Channels, it’s time to talk about Object Channels, also known as Object
    Types.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了现有的追踪通道（*可见性*和*相机*）以及如何创建自定义通道。现在你已经了解了追踪通道，是时候讨论对象通道了，也称为对象类型。
- en: While Trace Channels are only used for Line Traces, Object Channels are used
    for object collision. You can specify a “purpose” for each `Object` channel, much
    like with Trace Channels, such as **Pawn**, **Static Object**, **Physics Object**,
    **Projectile**, and so on. Then, you can specify how you want each Object Type
    to respond to all the other Object Types by blocking, overlapping, or ignoring
    objects of that type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然追踪通道仅用于线迹追踪，但对象通道用于对象碰撞。你可以为每个`对象`通道指定一个“目的”，就像追踪通道一样，例如**Pawn**、**静态对象**、**物理对象**、**投射物**等。然后，你可以指定每个对象类型如何通过阻挡、重叠或忽略该类型对象来响应所有其他对象类型。
- en: Now that we’ve taken a look at how collision works, let’s go back to the collision
    settings of the cube we selected in the previous chapter, where we changed its
    response to the Visibility Channel.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了碰撞的工作原理，让我们回到上一章中我们选择的立方体的碰撞设置，在那里我们改变了其对可见性通道的反应。
- en: 'Follow these steps to learn more about collision channels:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解碰撞通道的更多信息：
- en: 'The cube can be seen in the following screenshot:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中可以看到立方体：
- en: '![Figure 6.4 – Cube blocking the SightSource of the enemy ](img/Figure_6.04_B18531.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 立方体阻挡了敌人的SightSource](img/Figure_6.04_B18531.jpg)'
- en: Figure 6.4 – Cube blocking the SightSource of the enemy
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 立方体阻挡了敌人的SightSource
- en: 'With the level open in the editor, select the cube and go to the **Collision**
    section of its **Details** panel:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开级别后，选择立方体并转到其**详情**面板的**碰撞**部分：
- en: '![Figure 6.5 – The changes in the level editor ](img/Figure_6.05_B18531.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 级别编辑器中的变化](img/Figure_6.05_B18531.jpg)'
- en: Figure 6.5 – The changes in the level editor
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 级别编辑器中的变化
- en: 'Here, we can see some options that are important to us:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一些对我们来说很重要的选项：
- en: '`OnHit` events to be called when an object is simulating physics (we’ll talk
    about this later in this chapter).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象模拟物理时将调用的 `OnHit` 事件（我们将在本章后面讨论这一点）。
- en: '`OnBeginOverlap` and `OnEndOverlap` events to be called.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用的 `OnBeginOverlap` 和 `OnEndOverlap` 事件。
- en: '**Can Character Step Up On**, which allows a character to easily step onto
    this object.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许角色踏上**，允许角色轻松踏上此对象。'
- en: '**Collision Presets**, which allows us to specify how this object responds
    to each Collision Channel.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞预设**，允许我们指定此对象对每个碰撞通道的响应。'
- en: 'Let’s change the `Default` to `Custom` and take a look at the new options that
    show up:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `默认` 更改为 `自定义` 并查看出现的新选项：
- en: '![Figure 6.6 – Changes in Collision Presets ](img/Figure_6.06_B18531.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 碰撞预设的变化](img/Figure_6.06_B18531.jpg)'
- en: Figure 6.6 – Changes in Collision Presets
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 碰撞预设的变化
- en: 'The first of these options is the **Collision Enabled** property. It allows
    you to specify which aspects of collision you want this object to be considered
    for: **Query**, **Physics**, **Both**, or **None**. Again, physics collision is
    related to physics simulation (whether this object will be considered by other
    objects that simulate physics), while query collision is related to collision
    events and whether objects will block each other’s movement:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的第一个是 **碰撞启用** 属性。它允许您指定您希望此对象考虑哪些碰撞方面：**查询**、**物理**、**两者**或 **无**。再次强调，物理碰撞与物理模拟相关（此对象是否会被其他模拟物理的对象考虑），而查询碰撞与碰撞事件以及对象是否会阻止彼此的运动相关：
- en: '![Figure 6.7 – Collision Enabled for Query and Physics ](img/Figure_6.07_B18531.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 查询和物理的碰撞启用](img/Figure_6.07_B18531.jpg)'
- en: Figure 6.7 – Collision Enabled for Query and Physics
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 查询和物理的碰撞启用
- en: 'The second option is the **Object Type** property. This is very similar to
    the Trace Channel concept but is specifically for object collision and, most importantly,
    dictates what type of collision object this is. The Object Type values that come
    with UE5 are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是 **对象类型** 属性。这与跟踪通道的概念非常相似，但专门用于对象碰撞，最重要的是，它决定了此碰撞对象的类型。UE5 伴随的对象类型值如下：
- en: '`WorldStatic`: An object that doesn’t move (structures, buildings, and so on)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldStatic`：不移动的对象（结构、建筑等）'
- en: '`WorldDynamic`: An object that may move (objects whose movement is triggered
    by code, objects the player can pick up and move, and so on)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldDynamic`：可能移动的对象（其运动由代码触发，玩家可以捡起并移动的对象等）'
- en: '`Pawn`: Used for Pawns that can be controlled and moved around the level'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pawn`：用于可以控制和在关卡中移动的 Pawns'
- en: '`PhysicsBody`: Used for objects that simulate physics'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PhysicsBody`：用于模拟物理的对象'
- en: '`Vehicle`: Used for Vehicle objects'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vehicle`：用于车辆对象'
- en: '`Destructible`: Used for destructible meshes'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destructible`：用于可破坏网格'
- en: As mentioned previously, you can create custom object types (which will be mentioned
    later in this chapter) as well, similar to how you can create Trace Channels (*which
    was covered in the previous chapter*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您还可以创建自定义对象类型（将在本章后面提到），类似于您如何创建跟踪通道（*这在上一章中已介绍过*）。
- en: The last option we have is related to `Cube` object has the default collision
    options, all the responses are set to `Block`, which means that this object will
    block all the Line Traces and all objects that block `WorldStatic` objects, given
    that that is this object’s type.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个选项与 `Cube` 对象的默认碰撞选项相关，所有响应都设置为 `Block`，这意味着此对象将阻止所有线迹和所有阻止 `WorldStatic`
    对象的对象，前提是这是此对象的类型。
- en: Because there are so many different combinations of collision properties, UE5
    allows you to group collision property values in the form of Collision Presets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多不同的碰撞属性组合，UE5 允许您将碰撞属性值分组为碰撞预设。
- en: 'Let’s go back to the **Collision Presets** property, which is currently set
    to **Custom**, and *click it* so that we can see all the possible options. Some
    of the existing **Collision Presets** are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 **碰撞预设** 属性，它目前设置为 **自定义**，并 *点击它*，这样我们就可以看到所有可能的选项。以下是一些现有的 **碰撞预设**：
- en: '`NoCollision`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoCollision`'
- en: '`WorldStatic`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorldStatic`'
- en: 'Responses: Irrelevant'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应：无关
- en: 'Example: Objects that are purely visual and distant, such as an object that
    the player will never reach'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：纯视觉且距离较远的对象，例如玩家永远无法触及的对象
- en: '`Query` and `Physics`*   `WorldStatic`*   Responses: `Block` all channels*   Example:
    Objects that are close to the player character and block their movement, such
    as the floor and walls, which will always be stationary*   `Query` only*   `WorldStatic`*   Responses:
    `Overlap` all channels*   Example: Trigger boxes placed in the level, which will
    always be stationary*   `Block All` preset, but for dynamic objects that may change
    their transform during gameplay (`Object Type`: `WorldDynamic`)*   `Overlap All`
    preset, but for dynamic objects that may change their transform during gameplay
    (`Object Type`: `WorldDynamic`)*   `Query` and `Physics`*   `Pawn`*   Responses:
    `Block` all channels, `Ignore` Visibility Channel*   Example: Player character
    and non-playable characters*   `Query` and `Physics`*   `PhysicsBody`*   Responses:
    `Block` all channels*   Example: Objects that are affected by physics, such as
    a ball that bounces off the floor and walls'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Query`和`Physics`*   `WorldStatic`*   响应：`阻挡`所有通道*   示例：靠近玩家角色的对象，如地板和墙壁，它们将始终是静止的*   `Query`仅*   `WorldStatic`*   响应：`重叠`所有通道*   示例：放置在关卡中的触发框，它们将始终是静止的*   `Block
    All`预设，但对于在游戏过程中可能改变其变换的动态对象（`对象类型`：`WorldDynamic`）*   `Overlap All`预设，但对于在游戏过程中可能改变其变换的动态对象（`对象类型`：`WorldDynamic`）*   `Query`和`Physics`*   `Pawn`*   响应：`阻挡`所有通道，`忽略`可见性通道*   示例：玩家角色和非玩家角色*   `Query`和`Physics`*   `PhysicsBody`*   响应：`阻挡`所有通道*   示例：受物理影响的对象，如从地板和墙壁弹跳的球'
- en: Just like the other collision properties, you can also create your own collision
    presets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他碰撞属性一样，你也可以创建自己的碰撞预设。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find a full reference to UE5’s collision responses here: [https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到UE5的碰撞响应的完整参考：[https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference](https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference)。
- en: Now that we know about the basic concepts of collision, let’s go ahead and start
    creating the `Dodgeball` class. The next exercise will guide you toward doing
    just that.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了碰撞的基本概念，让我们继续创建`躲避球`类。接下来的练习将指导你完成这一任务。
- en: Exercise 6.01 – creating the Dodgeball class
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.01 – 创建躲避球类
- en: In this exercise, we’ll be creating our `Dodgeball` class, which will be thrown
    by our enemies and bounce off the floor and walls, just like an actual dodgeball.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的`躲避球`类，它将被敌人投掷，并在地板和墙壁上弹跳，就像真正的躲避球一样。
- en: Before we start creating the `Dodgeball` C++ class and its logic, we should
    set up all the necessary collision settings for it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建`躲避球`的C++类及其逻辑之前，我们应该为它设置所有必要的碰撞设置。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: Open **Project Settings** and go to the **Collision** subsection within the
    **Engine** section. Currently, there are no Object Channels, so you need to create
    a new one.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**项目设置**，进入**引擎**部分下的**碰撞**子部分。目前，没有对象通道，因此你需要创建一个新的通道。
- en: Press the `Dodgeball`, and set its **Default Response** to **Block**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下`躲避球`，并将其**默认响应**设置为**阻挡**。
- en: Once you’ve done this, expand the **Preset** section. Here, you’ll find all
    the default presets available in UE5\. If you select one of them and press the
    **Edit** option, you can change that **Preset Collision** settings.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，展开**预设**部分。在这里，你可以找到UE5中所有可用的默认预设。如果你选择其中一个并按**编辑**选项，你可以更改该**预设碰撞**设置。
- en: Create your own `Dodgeball`
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你自己的`躲避球`
- en: '`Collision Enabled (Query and Physics)` (we want this to be considered for
    physics simulation as well as collision events)'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Collision Enabled (Query and Physics)`（我们希望它同时被考虑用于物理模拟和碰撞事件）'
- en: '`Dodgeball`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dodgeball`'
- en: '`EnemySight` (we don’t want the dodgeball to block the camera or the enemy’s
    line of sight)'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EnemySight`（我们不希望躲避球阻挡摄像头或敌人的视线）'
- en: Once you’ve selected the correct options, press **Accept**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你选择了正确的选项，请按**接受**。
- en: Now that the `Dodgeball` class’s collision settings have been set up, let’s
    create the `Dodgeball` C++ class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经设置了`躲避球`类的碰撞设置，让我们创建`躲避球`的C++类。
- en: Inside the **Content Browser** area, *right-click* and select **New C++ Class**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**区域中，*右键点击*并选择**新建C++类**。
- en: Choose **Actor** as the parent class.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Actor**作为父类。
- en: Choose `Dodgeball`, so we can’t name this new class that too).
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`躲避球`，因此我们不能给这个新类取一个太接近的名字）。
- en: 'Open the `DodgeballProjectile` class files in Visual Studio. The first thing
    we’ll want to do is add the collision component of the dodgeball, so we’ll add
    a `SphereComponent` to our class header (*actor component properties are usually
    private*):'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `DodgeballProjectile` 类文件。我们首先想要做的是添加躲避球的碰撞组件，所以我们将向我们的类头文件添加一个
    `SphereComponent`（*演员组件属性通常是私有的*）：
- en: '[PRE0]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, include the `SphereComponent` class at the top of our source file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的源文件顶部包含 `SphereComponent` 类：
- en: '[PRE1]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that all header file includes must be before the `.generated.h`
    include.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有头文件包含必须位于 `.generated.h` 包含之前。
- en: 'Now, head to the `DodgeballProjectile` class’s constructor, within its source
    file, and perform the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 `DodgeballProjectile` 类的构造函数，在其源文件中，执行以下步骤：
- en: 'Create the `SphereComponent` object:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `SphereComponent` 对象：
- en: '[PRE2]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set its `radius` to `35` units:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 `radius` 设置为 `35` 单位：
- en: '[PRE3]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Set its `Dodgeball` preset we created:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们创建的 `Dodgeball` 预设：
- en: '[PRE4]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want `Dodgeball` to simulate physics, so notify the component of this, as
    shown in the following code snippet:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `Dodgeball` 模拟物理，因此通知组件这一点，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We want `Dodgeball` to call the `OnHit` event while simulating physics, so
    call the `SetNotifyRigidBodyCollision` function to set that to `true` (this is
    the same as the `SimulationGeneratesHitEvents` property that we saw in the `Collision`
    section of an object’s properties):'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望 `Dodgeball` 在模拟物理时调用 `OnHit` 事件，因此调用 `SetNotifyRigidBodyCollision` 函数将其设置为
    `true`（这与我们在对象的 `Collision` 部分看到的 `SimulationGeneratesHitEvents` 属性相同）：
- en: '[PRE6]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will also want to listen to the `OnHit` event of `SphereComponent`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望监听 `SphereComponent` 的 `OnHit` 事件。
- en: 'Create a declaration for the function that will be called when the `OnHit`
    event is triggered, in the `DodgeballProjectile` class’s header file. This function
    should be called `OnHit`. It should be `public`, return nothing (`void`), have
    the `UFUNCTION` macro, and receive some parameters, in this order:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DodgeballProjectile` 类的头文件中创建一个当 `OnHit` 事件被触发时将被调用的函数声明。这个函数应该被命名为 `OnHit`。它应该是
    `public` 的，不返回任何内容（`void`），包含 `UFUNCTION` 宏，并接收一些参数，顺序如下：
- en: '`UPrimitiveComponent* HitComp`: The component that was hit and belongs to this
    actor. A primitive component is an actor component that has a `Transform` property
    and some sort of geometry (for example, a `Mesh` or `Shape` component).'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* HitComp`: 被击中的组件，属于此演员。原始组件是一个具有 `Transform` 属性和一些几何形状（例如
    `Mesh` 或 `Shape` 组件）的演员组件。'
- en: '`AActor* OtherActor`: The other actor involved in the collision.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AActor* OtherActor`: 参与碰撞的其他演员。'
- en: '`UPrimitiveComponent* OtherComp`: The component that was hit and belongs to
    the other actor.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* OtherComp`: 被击中的组件，属于其他演员。'
- en: '`FVector NormalImpulse`: The direction in which the object will be moving after
    it has been hit, and with how much force (by checking the size of the vector).
    This parameter will only be non-zero for objects that are simulating physics.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FVector NormalImpulse`: 击中后物体将移动的方向以及移动的力度（通过检查向量的尺寸）。此参数对于模拟物理的物体将不为零。'
- en: '`FHitResult& Hit`: The data of the hit resulting from the collision between
    this object and the other object. As we saw in the previous chapter, it contains
    properties such whether as the location of the hit is normal, which component
    and actor it hit, and so on. Most of the relevant information is already available
    to us through the other parameters, but if you need more detailed information,
    you can access this parameter:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FHitResult& Hit`: 由本对象与其他对象碰撞产生的击中数据。正如我们在上一章中看到的，它包含诸如击中位置是否为法线、击中哪个组件和演员等属性。大部分相关信息已经通过其他参数提供给我们，但如果需要更详细的信息，可以访问此参数：'
- en: '[PRE7]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add the `OnHit` function’s implementation to the class’s source file and within
    that function, at least for now, destroy the dodgeball when it hits the player.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `OnHit` 函数的实现添加到类的源文件中，并在该函数中，至少目前，当它击中玩家时销毁躲避球。
- en: 'Cast the `OtherActor` parameter to our `DodgeballCharacter` class and check
    if the value is not a `nullptr`. If it’s not, which means that the other actor
    we hit is a `DodgeballCharacter`, we’ll destroy this `DodgeballProjectile` actor:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `OtherActor` 参数转换为我们的 `DodgeballCharacter` 类，并检查其值是否不是 `nullptr`。如果不是，这意味着我们击中的其他演员是一个
    `DodgeballCharacter`，我们将销毁这个 `DodgeballProjectile` 演员：
- en: '[PRE8]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given that we’re referencing the `DodgebalCharacter` class, we’ll need to include
    it at the top of this class’s source file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在引用 `DodgebalCharacter` 类，我们需要在类源文件顶部包含它：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we’ll change this function so that we have the dodgeball
    damage the player before destroying itself. We’ll do this when we talk about `Actor`
    components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更改这个函数，以便在销毁自身之前让躲避球对玩家造成伤害。我们将在讨论 `Actor` 组件时这样做。
- en: 'Head back to the `DodgeballProjectile` class’s constructor and add the following
    line at the end to listen to the `OnHit` event of `SphereComponent`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `DodgeballProjectile` 类的构造函数，并在末尾添加以下行以监听 `SphereComponent` 的 `OnHit` 事件：
- en: '[PRE10]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will bind the `OnHit` function we created to this `SphereComponent` `OnHit`
    event (because this is an actor component, this event is called `OnComponentHit`),
    which means our function will be called alongside that event.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将绑定我们创建的 `OnHit` 函数到这个 `SphereComponent` 的 `OnHit` 事件（因为这是一个角色组件，这个事件被称为 `OnComponentHit`），这意味着我们的函数将与该事件一起调用。
- en: 'Lastly, make `SphereComponent` this actor’s `RootComponent`, as shown in the
    following code snippet:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `SphereComponent` 设置为该角色的 `RootComponent`，如下代码片段所示：
- en: '[PRE11]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a moving actor to behave correctly on collision, whether it’s simulating
    physics or not, it is usually necessary for the main collision component of the
    actor to be its `RootComponent`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个移动的角色，在碰撞时表现正确，无论是模拟物理还是不模拟物理，通常需要角色的主要碰撞组件是其 `RootComponent`。
- en: For example, the `RootComponent` component of the `Character` class is a Capsule
    Collider component, because that actor will be moving around and that component
    is the main way the character collides with the environment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Character` 类的 `RootComponent` 组件是一个胶囊碰撞组件，因为该角色将会移动，而这个组件是角色与环境碰撞的主要方式。
- en: Now that we’ve added the `DodgeballProjectile` C++ class’s logic, let’s go ahead
    and create our Blueprint class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 `DodgeballProjectile` C++ 类的逻辑，让我们继续创建我们的蓝图类。
- en: Compile your changes and open the editor.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的更改并打开编辑器。
- en: Go to **Content** | **ThirdPersonCPP** | **Blueprints** in the **Content Browser**
    area, right-click, and create a new Blueprint class.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容** | **ThirdPersonCPP** | **蓝图** 的 **内容浏览器** 区域中，右键单击，创建一个新的蓝图类。
- en: Expand the `DodgeballProjectile` class. Then, set it as the parent class.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 `DodgeballProjectile` 类。然后，将其设置为父类。
- en: Name the new Blueprint class `BP_DodgeballProjectile`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图类命名为 `BP_DodgeballProjectile`。
- en: Open this new Blueprint class.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的蓝图类。
- en: 'Notice the wireframe representation of the `HiddenInGame` property):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意 `HiddenInGame` 属性的线框表示：
- en: '![Figure 6.8 – Visual wireframe representation of the SphereCollision component](img/Figure_6.08_B18531.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – SphereCollision 组件的视觉线框表示](img/Figure_6.08_B18531.jpg)'
- en: Figure 6.8 – Visual wireframe representation of the SphereCollision component
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – SphereCollision 组件的视觉线框表示
- en: 'Now, add a new **Sphere** mesh as a child of the existing **Sphere Collision**
    component:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将一个新的 **Sphere** 网格作为现有 **Sphere Collision** 组件的子组件添加：
- en: '![Figure 6.9 – Adding a Sphere mesh ](img/Figure_6.09_B18531.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 添加 Sphere 网格](img/Figure_6.09_B18531.jpg)'
- en: Figure 6.9 – Adding a Sphere mesh
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 添加 Sphere 网格
- en: 'Change its scale to `0.65`, as shown in the following screenshot:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放更改为 `0.65`，如下截图所示：
- en: '![Figure 6.10 – Updating the scale ](img/Figure_6.10_B18531.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 更新缩放](img/Figure_6.10_B18531.jpg)'
- en: Figure 6.10 – Updating the scale
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 更新缩放
- en: 'Set its `NoCollision`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其 `NoCollision`：
- en: '![Figure 6.11 – Updating Collision Presets to NoCollision ](img/Figure_6.11_B18531.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 更新碰撞预设为无碰撞](img/Figure_6.11_B18531.jpg)'
- en: Figure 6.11 – Updating Collision Presets to NoCollision
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 更新碰撞预设为无碰撞
- en: 'Finally, open our level and place an instance of the `BP_DodgeballProjectile`
    class near the player (this one was placed at a height of 600 units):'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开我们的关卡，并在玩家附近放置 `BP_DodgeballProjectile` 类的一个实例（这个放置在 600 单位的高度）：
- en: '![Figure 6.12 – Dodgeball bouncing on the ground ](img/Figure_6.12_B18531.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 地面上的躲避球弹跳](img/Figure_6.12_B18531.jpg)'
- en: Figure 6.12 – Dodgeball bouncing on the ground
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 地面上的躲避球弹跳
- en: After you’ve done this, play the level. You’ll notice that the dodgeball will
    be affected by gravity and bounce off the ground a couple of times before coming
    to a standstill.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些操作后，播放关卡。你会注意到躲避球会受到重力影响，并在地面弹跳几次后停止。
- en: By completing this exercise, you’ve created an object that behaves like a physics
    object.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经创建了一个像物理对象一样的对象。
- en: You now know how to create collision object types, use the `OnHit` event, and
    change an object’s collision properties.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何创建碰撞对象类型，使用 `OnHit` 事件，以及更改对象的碰撞属性。
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the previous chapter, we briefly mentioned `LineTraceSingleByObjectType`.
    Now that we know how object collision works, we can briefly mention its use: when
    executing a Line Trace that checks for a Trace Channel, you should use the `LineTraceSingleByChannel`
    function; when executing a Line Trace that checks for an Object Channel (Object
    Type), you should use the `LineTraceSingleByObjectType` function. It should be
    made clear that this function, unlike the `LineTraceSingleByChannel` function,
    will not check for objects that block a specific Object Type, but those that are
    of a specific Object Type. Both those functions have the same parameters and both
    the Trace Channels and Object Channels are available through the `ECollisionChannel`
    enum.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要提到了 `LineTraceSingleByObjectType`。现在我们知道了对象碰撞的工作原理，我们可以简要地提到它的用途：当执行检查
    Trace Channel 的 Line Trace 时，您应该使用 `LineTraceSingleByChannel` 函数；当执行检查对象通道（对象类型）的
    Line Trace 时，您应该使用 `LineTraceSingleByObjectType` 函数。应该明确的是，这个函数与 `LineTraceSingleByChannel`
    函数不同，它不会检查阻止特定对象类型的对象，而是检查特定对象类型的对象。这两个函数都有相同的参数，并且 Trace Channels 和 Object Channels
    都可以通过 `ECollisionChannel` 枚举获得。
- en: But what if you wanted the ball to bounce off the floor more times? What if
    you wanted to make it bouncier? Well, that’s where Physical Materials come in.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想让球多次从地板上弹起呢？如果你想让它弹跳得更高呢？嗯，这就是物理材质发挥作用的地方。
- en: Creating Physical Materials
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物理材质
- en: 'In UE5, you can customize how an object behaves while simulating physics using
    Physical Materials. To get into this new type of asset, let’s create our own:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，您可以使用物理材质自定义在模拟物理时对象的行为。要进入这种新类型的资产，让我们创建自己的：
- en: Create a new folder inside the `Content` folder called `Physics`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Content` 文件夹内创建一个名为 `Physics` 的新文件夹。
- en: '*Right-click* on the **Content Browser** area while inside that folder and,
    under the **Create Advanced Asset** section, go to the **Physics** subsection
    and select **Physical Material**.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹内，右键单击 **Content Browser** 区域，然后在 **Create Advanced Asset** 部分下，转到 **Physics**
    子部分并选择 **Physical Material**。
- en: Name this new Physical Material **PM_Dodgeball**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的物理材质命名为 **PM_Dodgeball**。
- en: 'Open the asset and take a look at the available options:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开资产并查看可用的选项：
- en: '![Figure 6.13 – Asset options ](img/Figure_6.13_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 资产选项](img/Figure_6.13_B18531.jpg)'
- en: Figure 6.13 – Asset options
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 资产选项
- en: 'The main options we should note are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意的主要选项如下：
- en: '`0` to `1` and specifies how much friction will affect this object (`0` means
    this object will slide as if it was on ice, while `1` means this object will stick
    like a piece of gum).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 到 `1` 并指定摩擦将影响此对象多少（`0` 表示此对象将像在冰上一样滑动，而 `1` 表示此对象将像一块口香糖一样粘附）。'
- en: '`0` to `1` and specifies how much velocity will be kept after colliding with
    another object (`0` means this object will never bounce off of the ground, while
    `1` means this object will bounce for a long time).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 到 `1` 并指定在与其他对象碰撞后保留多少速度（`0` 表示此对象永远不会从地面上弹起，而 `1` 表示此对象会长时间弹跳）。'
- en: '**Density**: This property specifies how dense this object is (that is, how
    heavy it is relative to its mesh). Two objects can be of the same size, but if
    one is twice as dense as the other, that means it will be twice as heavy.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：此属性指定了该对象有多密集（即，相对于其网格有多重）。两个对象可以大小相同，但如果一个对象的密度是另一个的两倍，这意味着它将重两倍。'
- en: To have our `DodgeballProjectile` object behave closer to an actual dodgeball,
    it’ll have to suffer quite a bit of friction (the default value is `0.7`, which
    is high enough) and be quite bouncy. Let’s increase the `Restitution` property
    of this Physical Material to `0.95`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要让我们的 `DodgeballProjectile` 对象的行为更接近实际的躲避球，它将不得不承受相当大的摩擦（默认值是 `0.7`，已经足够高）并且非常弹跳。让我们将这个物理材质的
    `Restitution` 属性增加到 `0.95`。
- en: 'After you’ve done this, open the **BP_DodgeballProjectile** Blueprint class
    and change the **Sphere Collision** component’s Physical Material, inside its
    **Collision** section, to the one we just created, **PM_Dodgeball**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，打开 **BP_DodgeballProjectile** 蓝图类，并在其 **Collision** 部分的 **Sphere Collision**
    组件中更改物理材质，将其更改为我们刚刚创建的 **PM_Dodgeball**：
- en: '![Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class ](img/Figure_6.14_B18531.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – 更新 BP_DodgeballProjectile 蓝图类](img/Figure_6.14_B18531.jpg)'
- en: Figure 6.14 – Updating the BP_DodgeballProjectile Blueprint class
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 更新 BP_DodgeballProjectile 蓝图类
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Make sure the instance of the `Dodgeball` actor you added to your level also
    has this physical material.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您添加到关卡中的 `Dodgeball` 角色的实例也具有这种物理材质。
- en: If you play the level that we created in *Exercise 6.01 – creating the Dodgeball
    class*, again, you’ll notice that our `BP_DodgeballProjectile` will now bounce
    off the ground several times before coming to a standstill, behaving much more
    like an actual dodgeball.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次播放我们在 *练习 6.01 – 创建 Dodgeball 类* 中创建的水平，你会注意到我们的 `BP_DodgeballProjectile`
    现在会在地面弹跳几次后停下来，表现得更像一个真正的躲避球。
- en: With all that done, we’re just missing one thing to make our `Dodgeball` actor
    behave like an actual dodgeball. Right now, there is no way for us to be able
    to throw it. So, let’s address that by creating a Projectile Movement Component,
    which is what we’ll be doing in the next exercise.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们只缺少一个东西来让我们的 `Dodgeball` 角色表现得像真正的躲避球。目前，我们无法抛掷它。因此，让我们通过创建一个弹道运动组件来解决这一问题，这就是我们将在下一个练习中要做的。
- en: 'In the previous chapters, when we replicated the Third Person template project,
    we learned that the `Character` class that comes with UE5 has a `CharacterMovementComponent`.
    This actor component is what allows an actor to move around in the level in various
    ways, and has many properties that allow you to customize that to your preference.
    However, there is another movement component that is also frequently used: `ProjectileMovementComponent`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，当我们复制了第三人称模板项目时，我们了解到 UE5 中的 `Character` 类有一个 `CharacterMovementComponent`。这个角色组件允许角色以各种方式在关卡中移动，并且有许多属性允许你根据你的喜好进行自定义。然而，还有一个经常使用的运动组件：`ProjectileMovementComponent`。
- en: The `ProjectileMovementComponent` actor component is used to attribute the behavior
    of a projectile to an actor. It allows you to set an initial speed, gravity force,
    and even some physics simulation parameters such as `Bounciness` and `Friction`.
    However, given that our `Dodgeball Projectile` is already simulating physics,
    the only property that we’ll be using is `InitialSpeed`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProjectileMovementComponent` 角色组件用于将弹道行为赋予一个角色。它允许你设置初始速度、重力力和一些物理模拟参数，例如
    `Bounciness` 和 `Friction`。然而，鉴于我们的 `Dodgeball Projectile` 已经在模拟物理，我们将使用的唯一属性是
    `InitialSpeed`。'
- en: Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02 – 向 DodgeballProjectile 添加弹道运动组件
- en: In this exercise, we will be adding a `ProjectileMovementComponent` to our `DodgeballProjectile`
    so that it has an initial horizontal speed. We’re doing this so that it can be
    thrown by our enemies and doesn’t just fall vertically.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向我们的 `DodgeballProjectile` 添加一个 `ProjectileMovementComponent`，使其具有初始水平速度。我们这样做是为了让它可以被敌人抛掷，而不仅仅是垂直下落。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Add a `ProjectileMovementComponent` property to the `DodgeballProjectile` class’s
    header file:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `DodgeballProjectile` 类的头文件中添加 `ProjectileMovementComponent` 属性：
- en: '[PRE12]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Include the `ProjectileMovementComponent` class at the top of the class’s source
    file:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的源文件顶部包含 `ProjectileMovementComponent` 类：
- en: '[PRE13]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the end of the class’s constructor, create the `ProjectileMovementComponent`
    object:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的构造函数末尾创建 `ProjectileMovementComponent` 对象：
- en: '[PRE14]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, set its `InitialSpeed` to `1500` units:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其 `InitialSpeed` 设置为 `1500` 单位：
- en: '[PRE15]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you’ve done this, compile your project and open the editor. To demonstrate
    the dodgeball’s initial speed, lower its position on the *Z*-axis and place it
    behind the player (*this one was placed at a height of 200 units*):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，编译你的项目并打开编辑器。为了演示躲避球的初始速度，将其在 *Z*- 轴上的位置降低，并将其放置在玩家后面（这个放置在 200 单位的高度）：
- en: '![Figure 6.15 – Dodgeball moving along the X-axis ](img/Figure_6.15_B18531.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 躲避球沿 X 轴移动](img/Figure_6.15_B18531.jpg)'
- en: Figure 6.15 – Dodgeball moving along the X-axis
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 躲避球沿 X 轴移动
- en: When you play the level, you’ll notice that the dodgeball starts moving toward
    its *X*-axis (*red arrow*)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你播放水平时，你会注意到躲避球开始向其 *X*- 轴（红色箭头）移动
- en: And with that, we can conclude our exercise. Our `DodgeballProjectile` now behaves
    like an actual dodgeball. It falls, bounces, and gets thrown.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以得出结论。我们的 `DodgeballProjectile` 现在表现得像真正的躲避球。它会下落、弹跳并被抛掷。
- en: The next step in our project is going to be adding logic to our `EnemyCharacter`
    so that it throws these dodgeballs at the player. However, before we address that,
    we must address the concept of timers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步是向我们的 `EnemyCharacter` 添加逻辑，使其向玩家投掷这些躲避球。然而，在我们解决这个问题之前，我们必须解决计时器概念。
- en: Introducing timers
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器介绍
- en: Given the nature of video games and the fact that they’re strongly event-based,
    every game development tool must have a way for you to cause a delay, or a wait
    time, before something happens. For instance, when you’re playing an online deathmatch
    game, where your character can die and then respawn, usually, the respawn event
    doesn’t happen the instant your character dies but a few seconds later. There
    is a multitude of scenarios where you want something to happen, but only after
    a certain amount of time. This will be the case for our `EnemyCharacter`, which
    will be throwing dodgeballs every few seconds. This delay, or wait time, can be
    achieved through timers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于视频游戏具有强事件驱动性的特点，每个游戏开发工具都必须有一种方式让你在某个事件发生之前造成延迟或等待时间。例如，当你玩一个在线死亡匹配游戏时，你的角色可以死亡并重生，通常，重生事件不会在你角色死亡的那一刻立即发生，而是在几秒后。有许多场景你希望某些事情发生，但只有在一定时间后。这将是我们的
    `EnemyCharacter` 的情况，它将每隔几秒投掷一个躲避球。这种延迟或等待时间可以通过计时器实现。
- en: A **timer** allows you to call a function after a certain amount of time. You
    can choose to loop that function call with an interval and also set a delay before
    the loop starts. If you want the timer to stop, you can also do that.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**计时器**允许你在一定时间后调用一个函数。你可以选择以间隔循环该函数调用，也可以在循环开始前设置一个延迟。如果你想停止计时器，也可以这样做。'
- en: We will be using timers so that our enemy throws a dodgeball every `X` amount
    of time, indefinitely, so long as it can see the player character, and then stop
    that timer when the enemy can no longer see its target.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用计时器，以便我们的敌人每隔 `X` 段时间就投掷一个躲避球，只要它能看到玩家角色，就会无限期地继续这样做，当敌人不能再看到其目标时，停止那个计时器。
- en: Before we start adding logic to our `EnemyCharacter` class that will make it
    throw dodgeballs at the player, we should take a look at another topic, which
    is how to spawn actors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向 `EnemyCharacter` 类添加逻辑，使其向玩家投掷躲避球之前，我们应该看看另一个话题，那就是如何生成演员。
- en: Understanding how to spawn actors
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何生成演员
- en: In [*Chapter 1*](B18531_01.xhtml#_idTextAnchor016), *Introduction to Unreal
    Engine*, you learned how to place an actor that you created in the level through
    the editor, but what if you wanted to place that actor in the level as the game
    is being played? That’s what we’re going to be taking a look at now.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 1 章*](B18531_01.xhtml#_idTextAnchor016)，*Unreal Engine 简介* 中，你学习了如何通过编辑器将你创建的演员放置在关卡中，但如果你想在游戏进行时将那个演员放置在关卡中怎么办？这正是我们现在将要探讨的。
- en: 'UE5, much like most other game development tools, allows you to place an actor
    in the game while the game itself is running. This process is called `SpawnActor`
    function, available from the `World` object (which we can access using the `GetWorld`
    function, as mentioned previously). However, the `SpawnActor` function has a few
    parameters that need to be passed, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: UE5，就像大多数其他游戏开发工具一样，允许你在游戏运行时放置一个演员。这个过程称为 `SpawnActor` 函数，可以从 `World` 对象（如前所述，我们可以使用
    `GetWorld` 函数访问它）获取。然而，`SpawnActor` 函数有几个参数需要传递，如下所示：
- en: A `UClass*` property, which lets the function know the class of the object that
    will be spawned. This property can be a C++ class, available through the `NameOfC++Class::StaticClass()`
    function, or a Blueprint class, available through the `TSubclassOf` property.
    It is generally a good practice not to spawn actors from a C++ class directly,
    but to create a Blueprint class and spawn an instance of that instead.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UClass*` 属性，它让函数知道将要生成的对象的类。这个属性可以是 C++ 类，通过 `NameOfC++Class::StaticClass()`
    函数获取，或者蓝图类，通过 `TSubclassOf` 属性获取。通常，直接从 C++ 类生成演员不是一个好的做法，而是应该创建一个蓝图类，并生成该类的实例。'
- en: The `TSubclassOf` property is a way for you to reference a Blueprint class in
    C++. It’s used for referencing a class in C++ code, which might be a Blueprint
    class. You must declare a `TSubclassOf` property with a template parameter, which
    is the C++ class that the class must inherit from. We will be taking a look at
    how to use this property in practice in the next exercise.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TSubclassOf` 属性是你在 C++ 中引用蓝图类的一种方式。它用于在 C++ 代码中引用一个类，这可能是一个蓝图类。你必须使用模板参数声明一个
    `TSubclassOf` 属性，这个模板参数是类必须继承的 C++ 类。我们将在下一个练习中看看如何在实际中使用这个属性。'
- en: Either an `FTransform` property or the `FVector` and `FRotator` properties,
    which will indicate the location, rotation, and scale of the object we want to
    spawn.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么是一个 `FTransform` 属性，要么是 `FVector` 和 `FRotator` 属性，这将指示我们想要生成的对象的定位、旋转和缩放。
- en: An optional `FActorSpawnParameters` property, which allows you to specify more
    properties specific to the spawning process, such as who caused the actor to spawn
    (that is, `Instigator`), how to handle the object spawning if the location that
    it spawns at is being occupied by other objects, which may cause an overlap or
    a block event, and so on.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的`FActorSpawnParameters`属性，允许你指定更多特定于生成过程的属性，例如谁导致了演员的生成（即`Instigator`），如果它生成的位置被其他对象占用，如何处理对象生成，这可能会导致重叠或阻塞事件等等。
- en: 'The `SpawnActor` function will return an instance to the actor that was spawned
    from this function. Given that it is also a template function, you can call it
    in such a way that you receive a reference to the type of actor you spawned directly
    using a template parameter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnActor`函数将返回一个实例给从这个函数中生成的演员。鉴于它也是一个模板函数，你可以以这种方式调用它，直接使用模板参数接收你生成的演员类型的引用：'
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the `SpawnActor` function is being called, where we’re spawning
    an instance of the `NameOfC++Class` class. Here, we have provided a reference
    to the class with the `ClassReference` property and the location and rotation
    of the actor to be spawned using the `SpawnLocation` and `SpawnRotation` properties,
    respectively.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正在调用`SpawnActor`函数，我们正在生成`NameOfC++Class`类的实例。在这里，我们通过`ClassReference`属性提供了对类的引用，并通过`SpawnLocation`和`SpawnRotation`属性分别提供了要生成的演员的位置和旋转。
- en: You will learn how to apply these properties in *Exercise 6.03 – adding projectile-throwing
    logic to the EnemyCharacter class*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在*练习6.03 – 向EnemyCharacter类添加投掷弹道逻辑*中学习如何应用这些属性。
- en: 'Before we continue with the exercise, though, I’d like to briefly mention a
    variation of the `SpawnActor` function that may also come in handy: the `SpawnActorDeferred`
    function. While the `SpawnActor` function will create an instance of the object
    you specify and then place it in the world, this new `SpawnActorDeferred` function
    will create an instance of the object you want, and only place it in the world
    when you call the actor’s `FinishSpawning` function.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行练习之前，我想简要地提一下`SpawnActor`函数的一个变体，这个变体可能也会很有用：`SpawnActorDeferred`函数。虽然`SpawnActor`函数会创建你指定的对象实例并将其放置到世界中，但这个新的`SpawnActorDeferred`函数将创建你想要的对象实例，并且只有在你调用演员的`FinishSpawning`函数时，它才会将对象放置到世界中。
- en: For instance, let’s say we want to change the `InitialSpeed` of our dodgeball
    at the moment we spawn it. If we use the `SpawnActor` function, there’s a chance
    that the dodgeball will start moving before we set its `InitialSpeed` property.
    However, by using the `SpawnActorDeferred` function, we can create an instance
    of the dodgeball, then set its `InitialSpeed` to whatever we want, and only then
    place it in the world by calling the newly created dodgeball’s `FinishSpawning`
    function, whose instance is returned to us by the `SpawnActorDeferred` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在生成躲避球时改变它的`InitialSpeed`。如果我们使用`SpawnActor`函数，躲避球可能会在我们设置其`InitialSpeed`属性之前开始移动。然而，通过使用`SpawnActorDeferred`函数，我们可以创建躲避球的实例，然后将其`InitialSpeed`设置为所需的任何值，然后通过调用新创建的躲避球的`FinishSpawning`函数将其放置到世界中，该函数的实例由`SpawnActorDeferred`函数返回给我们。
- en: Now that we know how to spawn an actor in the world, and also about the concept
    of timers, we can add the logic that’s responsible for throwing dodgeballs to
    our `EnemyCharacter` class, which is what we’ll be doing in the next exercise.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在世界中生成演员，并且也了解了计时器的概念，我们可以将负责投掷躲避球的逻辑添加到`EnemyCharacter`类中，这就是我们将在下一个练习中做的事情。
- en: Exercise 6.03 – adding projectile-throwing logic to the EnemyCharacter class
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.03 – 向EnemyCharacter类添加投掷弹道逻辑
- en: In this exercise, we will be adding the logic that’s responsible for throwing
    the `EnemyCharacter` class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加负责投掷`EnemyCharacter`类的逻辑。
- en: Open the class’s files in Visual Studio to get started. We will begin by modifying
    our `LookAtActor` function so that we can save the value that tells us whether
    we can see the player and use it to manage our timer.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 打开类的文件以开始。我们将首先修改我们的`LookAtActor`函数，以便我们可以保存告诉我们是否可以看到玩家的值，并使用它来管理我们的计时器。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'In the `EnemyCharacter` class’s header file, change the `LookAtActor` function’s
    return type from `void` to `bool`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`类的头文件中，将`LookAtActor`函数的返回类型从`void`改为`bool`：
- en: '[PRE17]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Do the same in the function’s implementation, inside the class’s source file,
    while also returning `true` at the end of the `if` statement where we call the
    `CanSeeActor` function. Also, return `false` in the first `if` statement, where
    we check if `TargetActor` is a `nullptr`, and also at the end of the function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的实现中，在类的源文件内部做同样的事情，同时在调用 `CanSeeActor` 函数的 `if` 语句的末尾返回 `true`。同时，在检查 `TargetActor`
    是否为 `nullptr` 的第一个 `if` 语句中返回 `false`，以及在函数的末尾：
- en: '[PRE18]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add two `bool` properties, `bCanSeePlayer` and `bPreviousCanSeePlayer`,
    set to `protected` in your class’s header file, which will represent whether the
    player can be seen in this frame from the enemy character’s perspective and whether
    the player could be seen in the last frame, respectively:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加两个 `bool` 属性，`bCanSeePlayer` 和 `bPreviousCanSeePlayer`，在类的头文件中将它们设置为 `protected`，分别表示从敌人角色的视角是否可以看到玩家，以及玩家是否可以在上一帧中被看到：
- en: '[PRE19]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, go to your class’s `Tick` function implementation and set the value of
    `bCanSeePlayer` to the return value of the `LookAtActor` function. This will replace
    the previous call to the `LookAtActor` function:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到你的类的 `Tick` 函数实现，并将 `bCanSeePlayer` 的值设置为 `LookAtActor` 函数的返回值。这将替换之前的
    `LookAtActor` 函数调用：
- en: '[PRE20]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, set the value of `bPreviousCanSeePlayer` to the value of `bCanSeePlayer`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `bPreviousCanSeePlayer` 的值设置为 `bCanSeePlayer` 的值：
- en: '[PRE21]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In-between the previous two lines, add an `if` statement that checks whether
    the values of `bCanSeePlayer` and `bPreviousCanSeePlayer` are different. This
    will mean that either we couldn’t see the player in the last frame and now we
    can, or that we could see the player in the last frame and now we can’t:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前两行之间，添加一个 `if` 语句来检查 `bCanSeePlayer` 和 `bPreviousCanSeePlayer` 的值是否不同。这意味着我们可能在上一帧中看不到玩家，而现在可以看到，或者我们可能在上一帧中可以看到玩家，而现在看不到：
- en: '[PRE22]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Inside this `if` statement, we want to start a timer if we can see the player
    and stop that timer if we can no longer see the player:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `if` 语句内部，如果我们能看到玩家，我们想要启动一个计时器；如果我们不能再看到玩家，我们想要停止那个计时器：
- en: '[PRE23]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To start a timer, we’ll need to add the following properties to our class’s
    header file, which can all be `protected`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动一个计时器，我们需要在我们的类头文件中添加以下属性，所有这些都可以是 `protected`：
- en: 'An `FTimerHandle` property, which is responsible for identifying which timer
    we want to start. It works as the identifier of a specific timer:'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `FTimerHandle` 属性，它负责识别我们想要启动哪个计时器。它作为特定计时器的标识符：
- en: '[PRE24]'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A `float` property, which represents the amount of time to wait between throwing
    dodgeballs (the interval) so that we can loop the timer. We give this a default
    value of `2` seconds:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `float` 属性，它代表投掷躲避球之间的等待时间（间隔），以便我们可以循环计时器。我们给它一个默认值 `2` 秒：
- en: '[PRE25]'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another `float` property, which represents the initial delay before the timer
    starts looping. Let’s give it a default value of `0.5` seconds:'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个 `float` 属性，它代表计时器开始循环之前的初始延迟。让我们给它一个默认值 `0.5` 秒：
- en: '[PRE26]'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A function to be called every time the timer ends, which we will create and
    call `ThrowDodgeball`. This function doesn’t return anything and doesn’t receive
    any parameters:'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在计时器结束时每次都要调用的函数，我们将创建并调用 `ThrowDodgeball`。这个函数不返回任何内容，也不接收任何参数：
- en: '[PRE27]'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we can call the appropriate function to start the timer, we will need
    to add an `#include` to the object responsible for that, `FTimerManager`, in our
    source file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以调用适当的函数来启动计时器之前，我们需要在我们的源文件中添加一个 `#include`，指向负责该功能的对象 `FTimerManager`。
- en: 'Each `World` has one Timer Manager, which can start and stop timers and access
    relevant functions related to them, such as whether they’re still active, how
    long they will be running for, and so on:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `World` 都有一个计时器管理器，它可以启动和停止计时器，并访问与它们相关的相关函数，例如它们是否仍然活跃，它们将运行多长时间，等等：
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, access the current `World` Timer Manager by using the `GetWorldTimerManager`
    function:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用 `GetWorldTimerManager` 函数访问当前的 `World` 计时器管理器：
- en: '[PRE29]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, call the `SetTimer` function of the Timer Manager, if you can see the
    player character, to start the timer responsible for throwing dodgeballs. The
    `SetTimer` function receives the following parameters:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，如果可以看到玩家角色，调用计时器管理器的 `SetTimer` 函数来启动负责投掷躲避球的计时器。`SetTimer` 函数接收以下参数：
- en: 'An `FTimerHandle` that represents the desired timer: `ThrowTimerHandle`.'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表所需计时器的 `FTimerHandle`：`ThrowTimerHandle`。
- en: 'The object that the function to be called belongs to: `this`.'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被调用的函数所属的对象：`this`。
- en: The function to be called, which must be specified by prefixing its name with
    `&ClassName::`, resulting in `&AEnemyCharacter::ThrowDodgeball`.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要调用的函数，必须通过在其名称前加上`&ClassName::`前缀来指定，结果为`&AEnemyCharacter::ThrowDodgeball`。
- en: 'The timer’s rate, or interval: `ThrowingInterval`.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器的速率或间隔：`ThrowingInterval`。
- en: 'Whether this timer will loop: `true`.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个计时器是否会循环：`true`。
- en: 'The delay before this timer starts looping: `ThrowingDelay`.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个计时器开始循环前的延迟：`ThrowingDelay`。
- en: 'The following code snippet comprises these parameters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段包含了这些参数：
- en: '[PRE30]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we can no longer see the player and we want to stop the timer, we can do
    so using the `ClearTimer` function. This function only needs to receive an `FTimerHandle`
    property as a parameter:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们无法再看到玩家并且想要停止计时器，我们可以使用`ClearTimer`函数来实现。这个函数只需要接收一个`FTimerHandle`属性作为参数：
- en: '[PRE31]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The only thing left is to implement the `ThrowDodgeball` function. This function
    will be responsible for spawning a new `DodgeballProjectile` actor. To do this,
    we’ll need a reference to the class we want to spawn, which must inherit from
    `DodgeballProjectile`. So, the next thing we need to do is create the appropriate
    property using the `TSubclassOf` object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是实现`ThrowDodgeball`函数。这个函数将负责生成一个新的`DodgeballProjectile`演员。为了做到这一点，我们需要一个指向我们想要生成的类的引用，这个类必须继承自`DodgeballProjectile`。因此，接下来我们需要做的是使用`TSubclassOf`对象创建适当的属性。
- en: 'Create the `TSubclassOf` property in the `EnemyCharacter` header file, which
    can be `public`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`头文件中创建`TSubclassOf`属性，可以是`public`：
- en: '[PRE32]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Because we’ll be using the `DodgeballProjectile` class, we also need to include
    it in the `EnemyCharacter` source file:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将使用`DodgeballProjectile`类，所以我们也需要将其包含在`EnemyCharacter`源文件中：
- en: '[PRE33]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, within the `ThrowDodgeball` function’s implementation in the source file,
    start by checking if this property is a `nullptr`. If it is, we `return` immediately:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在源文件中`ThrowDodgeball`函数的实现中，首先检查这个属性是否为`nullptr`。如果是，我们立即`return`：
- en: '[PRE34]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we will be spawning a new actor from that class. Its location will be
    `40` units in front of the enemy and its rotation will be the same as the enemy.
    To spawn the dodgeball in front of the enemy character, we’ll need to access the
    enemy’s `ForwardVector` property, which is a unitary `FVector` (*meaning that
    its length is 1*) that indicates the direction an actor is facing, and multiply
    it by the distance at which we want to spawn our dodgeball, which is `40` units:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从这个类中生成一个新的演员。它的位置将在敌人前方`40`单位处，并且它的旋转将与敌人相同。为了在敌人角色前方生成躲避球，我们需要访问敌人的`ForwardVector`属性，它是一个单位`FVector`
    (*意味着其长度为1*)，指示演员面对的方向，并将其乘以我们要生成躲避球的距离，即`40`单位：
- en: '[PRE35]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This concludes the modifications we need to make to the `EnemyCharacter` class.
    Before we finish setting up the Blueprint of this logic, let’s make a quick modification
    to our `DodgeballProjectile` class.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们需要对`EnemyCharacter`类进行的修改。在我们完成设置这个逻辑的蓝图之前，让我们快速修改一下我们的`DodgeballProjectile`类。
- en: Open the `DodgeballProjectile` class’s source file in Visual Studio.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`DodgeballProjectile`类的源文件。
- en: 'Within its `LifeSpan` to `5` seconds. This property, which belongs to all actors,
    dictates how much longer they will remain in the game before being destroyed.
    By setting our dodgeball’s `LifeSpan` to `5` seconds on its `BeginPlay` event,
    we are telling UE5 to destroy that object 5 seconds after it’s spawned (*or if
    it’s already been placed in the level, 5 seconds after the game starts*). We will
    do this so that the floor isn’t filled with dodgeballs after a certain amount
    of time, which would make the game unintentionally difficult for the player:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`LifeSpan`设置为`5`秒内。这个属性属于所有演员，决定了它们在游戏中被销毁之前将保持多久。通过在`BeginPlay`事件中将我们的躲避球的`LifeSpan`设置为`5`秒，我们告诉UE5在生成该对象5秒后销毁它
    (*或者如果它已经被放置在关卡中，游戏开始后5秒*)。我们将这样做，以便在一段时间后地板上不会充满躲避球，这会使游戏对玩家来说无意中变得困难：
- en: '[PRE36]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we’ve finished our C++ logic related to the `EnemyCharacter` class’s
    dodgeball-throwing logic, let’s compile our changes, open the editor, and then
    open our `BP_EnemyCharacter` Blueprint. There, head to the `Dodgeball` `Class`
    property’s value to `BP_DodgeballProjectile`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了与`EnemyCharacter`类躲避球投掷逻辑相关的C++逻辑，让我们编译我们的更改，打开编辑器，然后打开我们的`BP_EnemyCharacter`蓝图。在那里，转到`Dodgeball`
    `Class`属性的值到`BP_DodgeballProjectile`：
- en: '![Figure 6.16 – Updating Dodgeball Class ](img/Figure_6.16_B18531.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 更新躲避球类](img/Figure_6.16_B18531.jpg)'
- en: Figure 6.16 – Updating Dodgeball Class
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 更新躲避球类
- en: After you’ve done this, you can remove the existing instance of the `BP_DodgeballProjectile`
    class we placed in our level if it’s still there.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这些后，如果你在我们的关卡中放置了`BP_DodgeballProjectile`类的现有实例，你可以将其删除。
- en: 'Now, we can play our level. You’ll notice that the enemy will almost immediately
    start throwing dodgeballs at the player and will continue to do so, so long as
    the player character is in view:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以玩我们的关卡了。你会注意到敌人几乎会立即开始向玩家投掷躲避球，并且只要玩家角色在视野中，就会继续这样做：
- en: '![Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight
    ](img/Figure_6.17_B18531.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 如果玩家在视线中，敌人角色投掷躲避球](img/Figure_6.17_B18531.jpg)'
- en: Figure 6.17 – Enemy character throwing dodgeballs if the player is in sight
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 如果玩家在视线中，敌人角色投掷躲避球
- en: With that, we have concluded our dodgeball-throwing logic for `EnemyCharacter`.
    You now know how to use timers, an essential tool for any game programmer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了对`EnemyCharacter`的躲避球投掷逻辑。你现在知道如何使用计时器，这对于任何游戏程序员来说都是一项基本工具。
- en: Now, let’s jump into the next section, where we’ll be creating walls that handle
    collision differently.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到下一节，我们将创建处理碰撞方式不同的墙壁。
- en: Creating the Wall classes
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建墙壁类
- en: 'The next step in our project is going to be creating the `Wall` classes. We
    will have two types of walls:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步是创建`Wall`类。我们将有两种类型的墙壁：
- en: A normal wall, which will block the enemy’s line of sight, the player character,
    and the dodgeball.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通墙壁，它将阻挡敌人的视线、玩家角色和躲避球。
- en: A ghost wall, which will only block the player character, and ignore the enemy’s
    line of sight and the dodgeball. You may find this type of collision setup in
    specific types of puzzle games.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个幽灵墙壁，它只会阻挡玩家角色，而忽略敌人的视线和躲避球。你可能会在特定类型的益智游戏中找到这种碰撞设置。
- en: We’ll create both these Wall classes in the next exercise.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一项练习中，我们将创建这两个墙壁类。
- en: Exercise 6.04 – creating Wall classes
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.04 – 创建墙壁类
- en: In this exercise, we will be creating the `Wall` classes that represent both
    a normal `Wall` and a `GhostWall`, which will only block the player character’s
    movement, but not the enemies’ lines of sight or the dodgeballs they throw.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建代表正常`Wall`和幽灵`Wall`的`Wall`类，它只会阻挡玩家角色的移动，但不会阻挡敌人的视线或他们投掷的躲避球。
- en: Let’s start with the normal `Wall` class. This C++ class will be empty because
    the only thing that it’ll need is a mesh to reflect the projectiles and block
    the enemies’ lines of sight, which will be added through its Blueprint class.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从正常的`Wall`类开始。这个C++类将是空的，因为它唯一需要的是网格来反射投射物并阻挡敌人的视线，这些将通过其蓝图类添加。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这项练习：
- en: Open the editor.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器。
- en: In the top-left corner of the **Content Browser** area, press the green **Add
    New** button.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**区域的左上角，按绿色**添加新**按钮。
- en: Select the first option at the top; that is, **Add Feature or Content Pack**.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择顶部第一个选项；即**添加功能或内容包**。
- en: A new window will appear. Select the **Content Packs** tab, select the **Starter
    Content** pack, and then press the **Add To Project** button. This will add some
    basic assets to the project, which we’ll use in this chapter and some of the following
    chapters.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的窗口将出现。选择**内容包**选项卡，选择**入门内容**包，然后按**添加到项目**按钮。这将向项目中添加一些基本资产，我们将在这章和接下来的几章中使用这些资产。
- en: Create a new C++ class, called `Wall`, with the `Actor` class as its parent.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，命名为`Wall`，将其作为`Actor`类的父类。
- en: 'Next, open the class’s files in Visual Studio and add a `SceneComponent` as
    our Wall’s `RootComponent`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Visual Studio中打开该类的文件，并添加一个`SceneComponent`作为我们墙壁的`RootComponent`：
- en: 'The `Header` file will be as follows:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`文件将如下所示：'
- en: '[PRE37]'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `Source` file will be as follows:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`文件将如下所示：'
- en: '[PRE38]'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile your code and open the editor.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并打开编辑器。
- en: Next, go to `Wall` class, name it `BP_Wall`, and open that asse:.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，进入`Wall`类，命名为`BP_Wall`，并打开该资产：.
- en: Add a `Wall_400x400`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Wall_400x400`。
- en: Set its `M_Metal_Steel`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`M_Metal_Steel`。
- en: 'Set the `–200` units (*so that the mesh is centered relative to our actor’s
    origin*):'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`-200`单位（*使网格相对于我们的演员原点居中*）：
- en: '![Figure 6.18 – Updating the Static Mesh component’s location ](img/Figure_6.18_B18531.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 更新静态网格组件的位置](img/Figure_6.18_B18531.jpg)'
- en: Figure 6.18 – Updating the Static Mesh component’s location
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 更新静态网格组件的位置
- en: 'This is what your Blueprint class’s Viewport should look like:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的蓝图类的视口应该看起来像的：
- en: '![Figure 6.19 – The Blueprint class’s Viewport Wall ](img/Figure_6.19_B18531.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – Blueprint类的视口墙](img/Figure_6.19_B18531.jpg)'
- en: Figure 6.19 – The Blueprint class’s Viewport Wall
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – Blueprint类的视口墙
- en: Note
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is generally good practice to add a `SceneComponent` as an object’s `RootComponent`,
    when a collision component isn’t necessary, to allow for more flexibility with
    its child components.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当不需要碰撞组件时，将`SceneComponent`作为对象的`RootComponent`是一个好的实践，这样可以使其子组件具有更大的灵活性。
- en: An actor’s `RootComponent` cannot have its location or rotation modified, which
    is why, in our case, if we had created a `Wall` C++ class and set that as its
    root component, instead of using a scene component, we’d have a hard time offsetting
    it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个演员的`RootComponent`不能修改其位置或旋转，这就是为什么在我们的情况下，如果我们创建了一个`Wall` C++类并将其设置为根组件，而不是使用场景组件，我们将很难偏移它。
- en: 'Now that we’ve set up the regular `Wall` class, let’s create our `GhostWall`
    class. Because these classes don’t have any logic set up, we’re just going to
    create the `GhostWall` class as a child of the `BP_Wall` Blueprint class and not
    our C++ class:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了常规的`Wall`类，让我们创建我们的`GhostWall`类。因为这些类没有设置任何逻辑，所以我们只是将`GhostWall`类作为`BP_Wall`蓝图类的子类创建，而不是我们的C++类：
- en: '*Right-click* the **BP_Wall** asset and select **Create Child Blueprint Class**.'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* **BP_Wall** 资产并选择**创建子蓝图类**。'
- en: Name the new Blueprint `BP_GhostWall`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图命名为`BP_GhostWall`。
- en: Open it.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: Change the `CollisionPreset` to `Custom`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CollisionPreset`更改为`Custom`。
- en: Change its response to both the `EnemySight` and `Dodgeball` channels to `Overlap`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其响应更改为`EnemySight`和`Dodgeball`通道的`Overlap`。
- en: Change the `Material` property to `M_Metal_Copper`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Material`属性更改为`M_Metal_Copper`。
- en: 'The `BP_GhostWall` Viewport should now look like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`BP_GhostWall`视口现在应该看起来像这样：'
- en: '![Figure 6.20 – Creating the GhostWall class ](img/Figure_6.20_B18531.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 – 创建GhostWall类](img/Figure_6.20_B18531.jpg)'
- en: Figure 6.20 – Creating the GhostWall class
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 创建GhostWall类
- en: 'Now that you’ve created both these `Wall` actors, place each in the level to
    test them. Set their transforms to the following transform values:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了这两个`Wall`演员，将它们分别放置在场景中以测试它们。将它们的变换设置为以下变换值：
- en: '`Location`: `(710, -1710, 0)`'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`：(710, -1710, 0)'
- en: '`Location`: `(720, 1720, 0)`; `Rotation`: `(0, 0, 90)`:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`：(720, 1720, 0)；`旋转`：(0, 0, 90)；'
- en: '![Figure 6.21 – Updating the GhostWall class’s locations and rotation  ](img/Figure_6.21_B18531.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21 – 更新GhostWall类的位置和旋转](img/Figure_6.21_B18531.jpg)'
- en: Figure 6.21 – Updating the GhostWall class’s locations and rotation
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – 更新GhostWall类的位置和旋转
- en: 'The outcome should look like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![Figure 6.22 – Outcome of the GhostWall and Wall classes ](img/Figure_6.22_B18531.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22 – GhostWall和Wall类的结果](img/Figure_6.22_B18531.jpg)'
- en: Figure 6.22 – Outcome of the GhostWall and Wall classes
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – GhostWall和Wall类的结果
- en: You’ll notice that when you hide your character behind the normal `Wall` (the
    one on the right), the enemy won’t throw dodgeballs at the player; however, when
    you try to hide your character behind `GhostWall` (the one on the left), even
    though the enemy can’t go through it, the enemy will throw dodgeballs at the character
    and they will pass through the wall as if it wasn’t there!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你将你的角色隐藏在正常的`Wall`（右侧的那个）后面时，敌人不会向玩家投掷躲避球；然而，当你尝试将你的角色隐藏在`GhostWall`（左侧的那个）后面时，即使敌人无法穿过它，敌人仍会向角色投掷躲避球，它们会穿过墙壁，就像墙壁不存在一样！
- en: And that concludes our exercise. We have made our `Wall` actors, which will
    either behave normally or ignore the enemies’ lines of sight and dodgeballs!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的练习就结束了。我们已经创建了`Wall`演员，它们将正常行为或忽略敌人的视线和躲避球！
- en: Creating the VictoryBox actor
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建VictoryBox演员
- en: The next step in our project is going to be creating the `VictoryBox` actor.
    This actor will be responsible for ending the game when the player character enters
    it, given that the player has beaten the level. To do this, we’ll be using the
    `Overlap` event. The following exercise will help us understand `VictoryBox`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的下一步将是创建`VictoryBox`演员。这个演员将在玩家角色进入它时结束游戏，前提是玩家已经通过了关卡。为此，我们将使用`Overlap`事件。以下练习将帮助我们理解`VictoryBox`。
- en: Exercise 6.05 – creating the VictoryBox class
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05 – 创建VictoryBox类
- en: In this exercise, we will be creating the `VictoryBox` class, which, when entered
    by the player character, will end the game.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建`VictoryBox`类，当玩家角色进入时，它将结束游戏。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Create a new C++ class that inherits from the actor and call it `VictoryBox`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的从actor继承的C++类，并将其命名为`VictoryBox`。
- en: Open that class’s files in Visual Studio.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开该类的文件。
- en: 'Create a new `SceneComponent` property, which will be used as a `RootComponent`,
    just like we did with our `Wall` C++ class:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`SceneComponent`属性，它将用作`RootComponent`，就像我们在我们的`Wall` C++类中所做的那样：
- en: '`Header` file:'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Header`文件：'
- en: '[PRE39]'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Source` file:'
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Source`文件：'
- en: '[PRE40]'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare a `BoxComponent` in the header file that will check for overlap events
    with the player character, which should also be `private`:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中声明一个`BoxComponent`，它将检查与玩家角色的重叠事件，它也应该被标记为`private`：
- en: '[PRE41]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Include the `BoxComponent` file in the class’s source file:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BoxComponent`文件包含在类的源文件中：
- en: '[PRE42]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After creating the `RootScene` component, create `BoxComponent`, which should
    also be `private`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`RootScene`组件后，创建`BoxComponent`，它也应该被标记为`private`：
- en: '[PRE43]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attach it to `RootComponent` using the `SetupAttachment` function:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetupAttachment`函数将其附加到`RootComponent`：
- en: '[PRE44]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Set its `BoxExtent` property to `60` units on all axes. This will cause `BoxComponent`
    to be double that size – that is, `(120 x 120 x 120)`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`BoxExtent`属性设置为所有轴上的`60`个单位。这将使`BoxComponent`的大小加倍——即`(120 x 120 x 120)`：
- en: '[PRE45]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Offset its relative position on the *Z*-axis by `120` units using the `SetRelativeLocation`
    function:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SetRelativeLocation`函数将相对位置沿*Z*轴偏移`120`个单位：
- en: '[PRE46]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, you will require a function that will listen to the BoxComponent’s `OnBeginOverlap`
    event. This event will be called whenever an object enters `BoxComponent`. This
    function must be preceded by the `UFUNCTION` macro, be `public`, return nothing,
    and have the following parameters:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要一个函数来监听BoxComponent的`OnBeginOverlap`事件。每当一个对象进入`BoxComponent`时，都会调用此事件。此函数必须以`UFUNCTION`宏开头，必须是`public`的，不返回任何内容，并具有以下参数：
- en: '[PRE47]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These parameters are as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数如下：
- en: '`UPrimitiveComponent* OverlappedComp`: The component that was overlapped and
    belongs to this actor.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* OverlappedComp`：被重叠的组件，属于此actor。'
- en: '`AActor* OtherActor`: The other actor involved in the overlap.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor* OtherActor`：参与重叠的另一个actor。'
- en: '`UPrimitiveComponent* OtherComp`: The component that was overlapped and belongs
    to the other actor.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPrimitiveComponent* OtherComp`：被重叠的组件，属于另一个actor。'
- en: '`int32 OtherBodyIndex`: The index of the item in the primitive that was hit
    (usually useful for Instanced Static Mesh components).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32 OtherBodyIndex`：被击中的原始项的索引（通常对Instanced Static Mesh组件很有用）。'
- en: '`bool bFromSweep`: Whether the overlap originated from a Sweep Trace.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool bFromSweep`：重叠是否来自Sweep Trace。'
- en: '`FHitResult& SweepResult`: The data of the Sweep Trace resulting from the collision
    between this object and the other object.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FHitResult& SweepResult`：由本对象与其他对象碰撞产生的Sweep Trace的结果数据。'
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although we won’t be using the `OnEndOverlap` event in this project, you will
    most likely need to use it sooner or later, so here’s the required function signature
    for that event, which looks very similar to the one we just learned about:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个项目中不会使用`OnEndOverlap`事件，但你迟早会需要使用它，所以这里提供了该事件的所需函数签名，它看起来与我们刚刚学到的非常相似：
- en: '`UFUNCTION()`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`UFUNCTION()`'
- en: '`void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`void OnEndOverlap(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`'
- en: 'Next, we need to bind this function to the BoxComponent’s `OnComponentBeginOverlap`
    event:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将此函数绑定到BoxComponent的`OnComponentBeginOverlap`事件：
- en: '[PRE48]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Within our `OnBeginOverlap` function implementation, we’re going to check whether
    the actor we overlapped is a `DodgeballCharacter`. Because we’ll be referencing
    this class, we also need to include it:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`OnBeginOverlap`函数实现中，我们将检查重叠的actor是否是`DodgeballCharacter`。因为我们将引用这个类，所以我们也需要包含它：
- en: '[PRE49]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If the actor we overlapped is a `DodgeballCharacter`, we want to quit the game.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重叠的actor是`DodgeballCharacter`，我们希望退出游戏。
- en: 'We will use `KismetSystemLibrary` for this purpose. The `KismetSystemLibrary`
    class contains useful functions for general use in your project:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`KismetSystemLibrary`来完成这个任务。`KismetSystemLibrary`类包含了一些在项目中一般使用的有用函数：
- en: '[PRE50]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To quit the game, we will call the `QuitGame` function of `KismetSystemLibrary`.
    This function receives the following:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了退出游戏，我们将调用`KismetSystemLibrary`的`QuitGame`函数。此函数接收以下内容：
- en: '[PRE51]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The important parameters from the preceding code snippet are as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 上一代码片段中的重要参数如下：
- en: A `World` object, which we can access with the `GetWorld` function.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`World`对象，我们可以通过`GetWorld`函数访问它。
- en: A `PlayerController` object, which we will set to `nullptr`. We’re doing this
    because this function will automatically find one this way.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `PlayerController` 对象，我们将将其设置为 `nullptr`。我们这样做是因为这个函数将自动以这种方式找到它。
- en: An `EQuitPreference` object, which means how we want to end the game, by either
    quitting or just putting it as a background process. We will want to quit the
    game, and not just put it as a background process.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `EQuitPreference` 对象，这意味着我们希望如何结束游戏，通过退出或只是将其作为后台进程。我们希望退出游戏，而不是将其作为后台进程。
- en: A `bool`, which indicates whether we want to ignore the platform’s restrictions
    when it comes to quitting the game, which we will set to `true`.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `bool`，表示我们是否希望在退出游戏时忽略平台的限制，我们将将其设置为 `true`。
- en: Next, we’re going to create our Blueprint class.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的蓝图类。
- en: 'Compile your changes, open the editor, go to `VictoryBox`, and name it `BP_VictoryBox`.
    Open that asset and make the following modifications:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的更改，打开编辑器，转到 `VictoryBox`，并将其命名为 `BP_VictoryBox`。打开该资产并做出以下修改：
- en: Add a new `Floor_400x400`
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的 `Floor_400x400`
- en: Set its `M_Metal_Gold`
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置其 `M_Metal_Gold`
- en: Set its scale to `0.75` units on all three axes
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其缩放设置为所有三个轴上的 `0.75` 单位
- en: Set its location to `(-150, -150, 20)`, on the *X*, *Y*, and *Z* axes, respectively.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其位置设置为 `(-150, -150, 20)`，分别在 *X*、*Y* 和 *Z* 轴上。
- en: 'Once you’ve made those changes, your Blueprint’s **Viewport** tab should look
    something like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做了这些更改，你的蓝图中的 **Viewport** 选项卡应该看起来像这样：
- en: '![Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab ](img/Figure_6.23_B18531.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.23 – 放置在蓝图视图中 `VictoryBox`](img/Figure_6.23_B18531.jpg)'
- en: Figure 6.23 – VictoryBox placed in the Blueprint’s Viewport tab
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 放置在蓝图视图中 `VictoryBox`
- en: 'Place that Blueprint inside your level to test its functionality:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个蓝图放入你的关卡中以测试其功能：
- en: '![Figure 6.24 – VictoryBox Blueprint in the level for testing ](img/Figure_6.24_B18531.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.24 – 在关卡中测试的 `VictoryBox` 蓝图](img/Figure_6.24_B18531.jpg)'
- en: Figure 6.24 – VictoryBox Blueprint in the level for testing
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – 在关卡中测试的 `VictoryBox` 蓝图
- en: If you play the level and step onto the golden plate (and overlap the collision
    box), you’ll notice that the game abruptly ends, as intended.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩这个关卡并踏上金色平台（并且与碰撞框重叠），你会注意到游戏会突然结束，正如预期的那样。
- en: And with that, we conclude our `VictoryBox` class! You now know how to use the
    overlap events in your projects. There’s a multitude of game mechanics that you
    can create using these events, so congratulations on completing this exercise.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了 `VictoryBox` 类！你现在知道如何在项目中使用重叠事件。你可以使用这些事件创建许多游戏机制，所以恭喜你完成了这个练习。
- en: We are now very close to reaching the end of this chapter, where we’ll be completing
    a new activity, but first, we’ll need to make some modifications to our `DodgeballProjectile`
    class, namely adding a getter function to its `ProjectileMovementComponent`. We’ll
    do this in the next exercise.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在非常接近本章的结尾，我们将完成一个新的活动，但首先，我们需要对我们的 `DodgeballProjectile` 类做一些修改，即为其 `ProjectileMovementComponent`
    添加一个获取函数。我们将在下一个练习中这样做。
- en: A getter function is a function that only returns a specific property and does
    nothing else. These functions are usually marked as inline, which means that when
    the code compiles, a call to that function will simply be replaced with its content.
    They are also usually marked as `const`, given that they don’t modify any of the
    class’s properties.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一个获取函数是一个只返回特定属性而不做其他事情的函数。这些函数通常被标记为内联，这意味着当代码编译时，对该函数的调用将简单地被其内容替换。它们通常也被标记为
    `const`，因为它们不会修改类的任何属性。
- en: Exercise 6.06 – adding the ProjectileMovementComponent getter function to DodgeballProjectile
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.06 – 向 `DodgeballProjectile` 添加 `ProjectileMovementComponent` 获取函数
- en: In this exercise, we will be adding a getter function to the `DodgeballProjectile`
    class’s `ProjectileMovement` property so that other classes can access it and
    modify its properties. We will be doing the same in this chapter’s activity.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将向 `DodgeballProjectile` 类的 `ProjectileMovement` 属性添加一个获取函数，以便其他类可以访问它并修改其属性。我们将在本章的活动中也这样做。
- en: 'To do this, you’ll need to follow these steps:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要遵循以下步骤：
- en: Open the `DodgeballProjectile` class’s header file in Visual Studio.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `DodgeballProjectile` 类的头文件。
- en: 'Add a new `public` function called `GetProjectileMovementComponent`. This function
    will be an inline function, which in UE5’s version of C++ is replaced with the
    `FORCEINLINE` macro. The function should also return a `UProjectileMovementComponent*`
    and be a `const` function:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `GetProjectileMovementComponent` 的新 `public` 函数。此函数将是一个内联函数，在 UE5 的 C++
    版本中，它被 `FORCEINLINE` 宏所替代。该函数还应返回一个 `UProjectileMovementComponent*` 并是一个 `const`
    函数：
- en: '[PRE52]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When using the `FORCEINLINE` macro for a specific function, you can’t add the
    declaration of that function to the header file and its implementation to the
    source file. Both must be done simultaneously in the header file, as shown previously.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当为特定函数使用 `FORCEINLINE` 宏时，你不能将该函数的声明添加到头文件中，并将其实现添加到源文件中。两者都必须像之前展示的那样在头文件中同时完成。
- en: With that, we have concluded this quick exercise. Here, we have added a simple
    `getter` function to our `DodgeballProjectile` class, which we will be using in
    this chapter’s activity, where we’ll replace the `SpawnActor` function within
    the `EnemyCharacter` class with the `SpawnActorDeferred` function. This will allow
    us to safely edit our `DodgeballProjectile` class’s properties before we spawn
    an instance of it.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了这个快速练习。在这里，我们向我们的 `DodgeballProjectile` 类添加了一个简单的 `getter` 函数，我们将在本章的活动中使用它，我们将用
    `SpawnActorDeferred` 函数替换 `EnemyCharacter` 类中的 `SpawnActor` 函数。这将允许我们在生成其实例之前安全地编辑
    `DodgeballProjectile` 类的属性。
- en: Activity 6.01 – replacing the SpawnActor function with SpawnActorDeferred in
    EnemyCharacter
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 6.01 – 在 EnemyCharacter 中用 SpawnActorDeferred 替换 SpawnActor 函数
- en: In this activity, you will be changing the EnemyCharacter’s `ThrowDodgeball`
    function to use the `SpawnActorDeferred` function instead of the `SpawnActor`
    function so that we can change the DodgeballProjectile’s `InitialSpeed` before
    spawning it.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将更改 `EnemyCharacter` 的 `ThrowDodgeball` 函数，使用 `SpawnActorDeferred` 函数而不是
    `SpawnActor` 函数，这样我们就可以在生成它之前更改 `DodgeballProjectile` 的 `InitialSpeed` 属性。
- en: 'The following steps will help you complete this activity:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: Open the `EnemyCharacter` class’s source file in Visual Studio.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `EnemyCharacter` 类的源文件。
- en: Go to the `ThrowDodgeball` function’s implementation.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ThrowDodgeball` 函数的实现。
- en: Because the `SpawnActorDeferred` function can’t just receive a spawn location
    and rotation properties and must receive an `FTransform` property instead, we’ll
    need to create one of those before we call that function. Let’s call it `SpawnTransform`
    and send the spawn rotation and location, in that order, as inputs for its constructor,
    which will be this enemy’s rotation and the `SpawnLocation` property, respectively.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为 `SpawnActorDeferred` 函数不能仅仅接收一个生成位置和旋转属性，而必须接收一个 `FTransform` 属性，所以我们调用该函数之前需要创建一个这样的属性。让我们称它为
    `SpawnTransform` 并将生成旋转和位置，按顺序，作为其构造函数的输入，这将分别是这个敌人的旋转和 `SpawnLocation` 属性。
- en: Then, update the `SpawnActor` function call in the `SpawnActorDeferred` function
    call. Instead of sending the spawn location and spawn rotation as its second and
    third parameters, replace those with the `SpawnTransform` properties we just created,
    as the second parameter.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新 `SpawnActor` 函数调用在 `SpawnActorDeferred` 函数调用中。而不是将其第二个和第三个参数作为其生成位置和旋转，用我们刚刚创建的
    `SpawnTransform` 属性替换，作为第二个参数。
- en: Make sure you save the return value of this function call inside an `ADodgeballProjectile*`
    property called `Projectile`.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将此函数调用的返回值保存在一个名为 `Projectile` 的 `ADodgeballProjectile*` 属性中。
- en: Once you’ve done this, you will have successfully created a new `DodgeballProjectile`
    object. However, we still need to change its `InitialSpeed` property and spawn
    it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你将成功创建一个新的 `DodgeballProjectile` 对象。然而，我们仍然需要更改它的 `InitialSpeed` 属性并生成它。
- en: Once you’ve called the `SpawnActorDeferred` function, call the `Projectile`
    property’s `GetProjectileMovementComponent` function, which returns its `ProjectileMovementComponent`,
    and change its `InitialSpeed` property to `2200` units.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你调用了 `SpawnActorDeferred` 函数，调用 `Projectile` 属性的 `GetProjectileMovementComponent`
    函数，它返回其 `ProjectileMovementComponent`，并将它的 `InitialSpeed` 属性更改为 `2200` 单位。
- en: Because we’ll be accessing properties that belong to `ProjectileMovementComponent`
    inside the `EnemyCharacter` class, we’ll need to include that component, just
    like we did in *Exercise 6.02 – adding a ProjectileMovementComponent to DodgeballProjectile*.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们将访问属于 `EnemyCharacter` 类中的 `ProjectileMovementComponent` 的属性，我们需要包含该组件，就像我们在
    *练习 6.02 – 将 ProjectileMovementComponent 添加到 DodgeballProjectile* 中所做的那样。
- en: Once you’ve changed the value of the `InitialSpeed` property, the only thing
    left to do is call the `Projectile` property’s `FinishSpawning` function, which
    will receive the `SpawnTransform` property we created as a parameter.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你改变了`InitialSpeed`属性的值，剩下的唯一事情就是调用`Projectile`属性的`FinishSpawning`函数，该函数将接收我们创建的`SpawnTransform`属性作为参数。
- en: Once you’ve done this, compile your changes and open the editor.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，编译你的更改并打开编辑器。
- en: '**Expected output**:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**：'
- en: '![Figure 6.25 – Dodgeball thrown at the player ](img/Figure_6.25_B18531.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![图6.25 – 向玩家投掷的躲避球](img/Figure_6.25_B18531.jpg)'
- en: Figure 6.25 – Dodgeball thrown at the player
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 向玩家投掷的躲避球
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)找到。
- en: By completing this activity, you’ve consolidated the use of the `SpawnActorDeferred`
    function and know how to use it in your future projects.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你已经巩固了`SpawnActorDeferred`函数的使用，并知道如何在未来的项目中使用它。
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to affect an object with physics simulations,
    create Object Types and Collision Presets, use the `OnHit`, `OnBeginOverlap`,
    and `OnEndOverlap` events, update an object’s Physical Material, and use timers.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用物理模拟影响对象，创建对象类型和碰撞预设，使用`OnHit`、`OnBeginOverlap`和`OnEndOverlap`事件，更新对象的物理材质，以及使用计时器。
- en: Now that you’ve learned about these fundamental collision topics, you’ll be
    able to come up with new and creative ways to use them when creating projects.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这些基本的碰撞主题，你将能够想出在创建项目时使用它们的新颖和创造性的方法。
- en: In the next chapter, we’ll be taking a look at actor components, interfaces,
    and Blueprint Function Libraries, which are very useful for keeping your project’s
    complexity manageable and highly modular, thereby allowing you to easily take
    parts of one project and add them to another.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨演员组件、接口和蓝图函数库，这些对于保持项目复杂度可管理且高度模块化非常有用，从而让你能够轻松地将一个项目的部分添加到另一个项目中。
