- en: 1\. Hello C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 你好，C#
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the basics of C#. You will start by learning
    about the basics of the .NET Command-Line Interface (CLI) and how to use Visual
    Studio Code (VS Code) as a basic Integrated Development Environment (IDE). You
    will then learn about the various C# data types and how to declare variables for
    these types, before moving on to a section about arithmetic and logical operators.
    By the end of the chapter, you will know how to handle exceptions and errors and
    be able to write simple programs in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C#的基础知识。您将首先学习.NET命令行界面（CLI）的基础知识以及如何使用Visual Studio Code（VS Code）作为基本集成开发环境（IDE）。然后，您将了解各种C#数据类型以及如何为这些类型声明变量，然后转到关于算术和逻辑运算符的部分。在本章结束时，您将知道如何处理异常和错误，并能够用C#编写简单的程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: C# is a programming language created in the early 2000s by a team at Microsoft
    led by Anders Hejlsberg, who is also among the creators of some other popular
    languages, such as Delphi and Turbo Pascal, both widely used in the 1990s. Over
    the last 20 years, C# has grown and evolved, and today it is one of the most widely
    used programming languages globally, according to Stack Overflow's 2020 insights.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种由微软团队在2000年代初创建的编程语言，由Anders Hejlsberg领导，他还是一些其他流行语言的创造者之一，如Delphi和Turbo
    Pascal，这两种语言在上世纪90年代被广泛使用。在过去的20年中，C#已经发展和演变，如今它是全球范围内最广泛使用的编程语言之一，根据Stack Overflow的2020年洞察。
- en: It has its reasons for holding such an honorable place in the tech community.
    C# allows you to write applications for a wide segment of markets and devices.
    From the banking industry, with its high-security standards, to e-commerce companies,
    which hold enormous volumes of transactions, it is a language trusted by companies
    that need both performance and reliability. Besides that, C# also makes it possible
    to write web, desktop, mobile, and even IoT applications, allowing you to develop
    for almost every kind of device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它有其在科技社区中占据如此崇高地位的原因。C#允许您为广泛的市场和设备编写应用程序。从具有高安全标准的银行业到拥有大量交易的电子商务公司，这是一种被需要性能和可靠性的公司信任的语言。此外，C#还可以编写Web、桌面、移动甚至物联网应用程序，使您能够为几乎每种设备进行开发。
- en: 'C# was initially limited to work only on Windows; however, there have been
    concerted efforts by the C# team over the past few years to make it cross-platform
    compatible. Today, it can be used with all major OS distributions, namely, Windows,
    Linux, and macOS. The goal is simple: to develop, build, and run C# anywhere,
    letting each developer and team choose their most productive or favorite environment.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，C#只能在Windows上运行；然而，在过去几年中，C#团队已经做出了努力，使其跨平台兼容。如今，它可以与所有主要操作系统分发版一起使用，即Windows、Linux和macOS。目标很简单：在任何地方开发、构建和运行C#，让每个开发人员和团队选择他们最有效或最喜欢的环境。
- en: Another remarkable characteristic of C# is that it is a strongly typed programming
    language. You will dive into this more deeply in the upcoming sections, and you
    will see that strong typing enables better data security while programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C#的另一个显著特点是它是一种强类型的编程语言。您将在接下来的部分中更深入地了解这一点，并且您将看到强类型使得在编程时能够更好地保护数据安全。
- en: Besides that, C# has become open source over the last few years, with Microsoft
    as its principal maintainer. This is highly advantageous, as it allows the language
    to receive continuous improvements from around the globe, with a solid backing
    company that both promotes and invests in it. C# is also a multi-paradigm language,
    meaning that you can use it to write software in many programming styles, in a
    beautiful, concise, and proper manner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C#在过去几年已成为开源项目，由微软作为主要维护者。这是非常有利的，因为它允许语言从全球范围内不断获得改进，同时有一个坚实的支持公司来推广和投资。C#也是一种多范式语言，这意味着您可以以美观、简洁和适当的方式使用它来编写多种编程风格的软件。
- en: Running and Developing C# with the .NET CLI
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET CLI运行和开发C#
- en: One term you'll hear a lot in the C# world is .NET. It is the foundation of
    C#, a framework that the language is built on top of. It has both a Software Development
    Kit (SDK) that allows the language to be developed and a runtime that allows the
    language to run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#世界中，您会经常听到一个术语，那就是.NET。它是C#的基础，是该语言构建在其上的框架。它既有一个允许开发语言的软件开发工具包（SDK），也有一个允许语言运行的运行时。
- en: That said, to start developing with C#, you only need to install the .NET SDK.
    This installation will provide both a compiler and the runtime on the development
    environment. In this section, you will cover the basic steps of preparing your
    environment for developing and running C# locally.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，要开始使用C#进行开发，您只需要安装.NET SDK。此安装将在开发环境中提供编译器和运行时。在本节中，您将学习准备开发和在本地运行C#的基本步骤。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to the *Preface* of this book for step-by-step instructions on
    how to download the .NET 6.0 SDK and install it on your machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何下载.NET 6.0 SDK并在您的计算机上安装的逐步说明，请参阅本书的*前言*。
- en: Once the installation of the .NET 6.0 SDK is completed, you will have something
    called the .NET CLI. This Command-Line Interface (CLI) allows you to create new
    projects, compile them, and run them with very simple commands that you can run
    directly from your terminal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成了.NET 6.0 SDK的安装，您将拥有一个称为.NET CLI的东西。这个命令行界面（CLI）允许您使用非常简单的命令创建新项目、编译它们并直接从终端运行它们。
- en: 'After the installation, run the following command on your favorite terminal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，在您喜欢的终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see an output like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到以下输出：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This output shows that you have the 6.0.100 version of the SDK installed on
    your computer. That means you are ready to start developing your applications.
    If you type `dotnet -–help`, you will notice that several commands will appear
    for you as options to run within the CLI. In this section, you will cover the
    most basic ones that you need to create and run applications: `new`, `build`,
    and `run`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示你的电脑上安装了SDK的6.0.100版本。这意味着你已经准备好开始开发你的应用程序了。如果你输入 `dotnet -–help`，你会注意到几个命令会出现在CLI中供你选择运行。在这一部分，你将学习到最基本的命令，用来创建和运行应用程序：`new`，`build`和`run`。
- en: 'The `dotnet new` command allows you to create a bootstrap project to start
    developing. The CLI has several built-in templates, which are nothing more than
    basic bootstraps for various types of applications: web apps, desktop apps, and
    so on. You must specify two things in the `dotnet new` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new`命令允许你创建一个引导项目来开始开发。CLI有几个内置模板，它们只是各种类型应用程序的基本引导：web应用程序，桌面应用程序等。在`dotnet
    new`命令中，你必须指定两件事：'
- en: The template name
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板名称
- en: The project name
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称
- en: 'The name is passed as an argument, which means you should specify it with a
    `-n` or `–name` flag. The command is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 名称作为参数传递，这意味着你应该用`-n`或`–name`标志来指定它。命令如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For instance, to create a new console application named `MyConsoleApp` you
    can simply type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个名为`MyConsoleApp`的新控制台应用程序，你可以简单地输入：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will generate a new folder with a file named `MyConsoleApp.csproj`, which
    is the C# project file that contains all the metadata needed by the compiler to
    build your project, and some files needed for the application to be built and
    run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新的文件夹，其中包含一个名为`MyConsoleApp.csproj`的文件，这是包含编译器构建项目所需的所有元数据的C#项目文件，以及一些应用程序构建和运行所需的文件。
- en: 'Next, the `dotnet build` command allows you to build an application and make
    it ready to run. This command should be placed only in two locations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`dotnet build`命令允许你构建一个应用程序并使其准备运行。这个命令应该只放在两个位置：
- en: A project folder, containing a `.csproj` file.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个`.csproj`文件的项目文件夹。
- en: A folder containing a `.sln` file.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个`.sln`文件的文件夹。
- en: Solution (`.sln`) files are files that contain the metadata of one or more project
    files. They are used to organize multiple project files into single builds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案（`.sln`）文件是包含一个或多个项目文件的元数据文件。它们用于将多个项目文件组织成单个构建。
- en: Finally, the third important command is dotnet `run`. This command allows you
    to properly run an application. It can be called without any arguments from the
    folder that contains the `.csproj` file of your .NET app, or without passing the
    project folder with the `-–project` flag on the CLI. The `run` command also automatically
    builds the application prior to the run.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个重要的命令是`dotnet run`。这个命令允许你正确地运行一个应用程序。它可以在包含你的.NET应用程序的`.csproj`文件的文件夹中不带任何参数调用，或者在CLI上使用`-–project`标志传递项目文件夹。`run`命令还会在运行之前自动构建应用程序。
- en: Creating Programs with the CLI and VS Code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CLI和VS Code创建程序
- en: While working through this book, you will use Visual Studio Code (VS Code) as
    your code editor. It works on all platforms, and you can download the version
    for your OS at https://code.visualstudio.com/. Although VS Code is not a complete
    Integrated Development Environment (IDE), it has a lot of extensions that make
    it a powerful tool to develop and do proper C# coding, regardless of the OS being
    used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书时，你将使用Visual Studio Code (VS Code)作为你的代码编辑器。它适用于所有平台，你可以在https://code.visualstudio.com/下载适合你操作系统的版本。虽然VS
    Code不是一个完整的集成开发环境（IDE），但它有很多扩展，使它成为一个强大的工具来开发和进行正确的C#编码，无论使用的是哪个操作系统。
- en: To properly develop C# code, you will primarily need to install the Microsoft
    C# extension. It equips VS Code with the ability to do code completion and identify
    errors and is available at [https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地开发C#代码，你主要需要安装Microsoft C#扩展。它使VS Code具备了代码补全和识别错误的能力，并且可以在[https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)上找到。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding, it is recommended that you install VS Code and the Microsoft
    C# extension. You can find a step-by-step breakdown of the installation process
    in the *Preface* of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，建议你安装VS Code和Microsoft C#扩展。你可以在本书的*前言*中找到安装过程的逐步说明。
- en: Basic Anatomy of a C# Program
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#程序的基本结构
- en: In order to run, every C# program needs something called an entry point. In
    C#, the standard entry point for a program is the `Main` method. Regardless of
    your program type, whether it is a web application, desktop application, or even
    a simple console one, the `Main` method will be the **entry point** for your C#
    program. This means that each time an application runs, the runtime searches for
    this method within your code and executes the code blocks inside it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行，每个C#程序都需要一个称为入口点的东西。在C#中，程序的标准入口点是`Main`方法。无论你的程序类型是什么，无论是web应用程序、桌面应用程序，甚至是一个简单的控制台应用程序，`Main`方法都将是你的C#程序的**入口点**。这意味着每次应用程序运行时，运行时都会在你的代码中搜索这个方法，并执行其中的代码块。
- en: This structure is created for you by the CLI, with the `new` command. A `Program.cs`
    file contains a class named `Program`, with a method named `Main`, which, in turn,
    contains a single instruction that will be executed after the program is built
    and running. You will learn more about methods and classes later, but for now,
    just know that a class is something that usually contains a set of data and that
    can perform actions on this data through these **methods**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构是由CLI用`new`命令为你创建的。一个`Program.cs`文件包含一个名为`Program`的类，一个名为`Main`的方法，这个方法又包含一个单一的指令，在程序构建和运行后将被执行。你以后会学到更多关于方法和类的知识，但现在只需要知道，一个类通常包含一组数据，并且可以通过这些**方法**对这些数据执行操作。
- en: Another important thing to note regarding basic C# concepts is `//`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基本C#概念的另一件重要的事情是`//`。
- en: 'Exercise 1.01: Creating a Console App that Says "Hello World"'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：创建一个打印“Hello World”的控制台应用程序
- en: In this exercise, you will see the CLI commands you learned about in the previous
    section, as you build your first ever C# program. It will be a simple console
    app that will print `Hello World` to the console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将看到在上一节学习的CLI命令，因为您将构建您的第一个C#程序。这将是一个简单的控制台应用程序，将在控制台上打印“Hello World”。
- en: 'Perform the following steps to do so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端，输入以下内容：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will create a new console application in the `Exercise1_01` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将在`Exercise1_01`文件夹中创建一个新的控制台应用程序。
- en: 'On the command line, type the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.1: "Hello World" output on the console'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：“Hello World”在控制台上的输出'
- en: '](img/B16835_01_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_01.jpg)'
- en: 'Figure 1.1: "Hello World" output on the console'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：“Hello World”在控制台上的输出
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/HErU6](https://packt.link/HErU6).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/HErU6](https://packt.link/HErU6)找到本练习使用的代码。
- en: In this exercise, you created the most basic program possible with C#, a console
    application that prints some text to the prompt. You also learned how to use .NET
    CLI, which is the mechanism built within the .NET SDK to create and manage .NET projects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了可能是最基本的C#程序，一个控制台应用程序，将一些文本打印到提示符上。您还学会了如何使用.NET CLI，这是内置在.NET SDK中用于创建和管理.NET项目的机制。
- en: Now proceed to the next section to grasp how top-level statements are written.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续下一节，了解如何编写顶级语句。
- en: Top-Level Statements
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶级语句
- en: 'You must have noticed in *Exercise 1.01* that, by default, when you create
    a console application, you have a `Program.cs` file that contains the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在*练习1.01*中，默认情况下，当您创建一个控制台应用程序时，会有一个包含以下内容的`Program.cs`文件：
- en: A class named `Program`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Program`的类。
- en: The static void `Main` keywords.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态void `Main`关键字。
- en: 'You will learn about classes and methods in detail later, but for now, for
    the sake of simplicity, you do not need these resources to create and execute
    programs with C#. The latest version (.NET 6) introduced a feature that makes
    writing simple programs much easier and less verbose. For instance, consider the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在以后详细了解类和方法，但现在，为了简单起见，您不需要这些资源来创建和执行C#程序。最新版本(.NET 6)引入了一个功能，使编写简单程序变得更加容易和简洁。例如，考虑以下内容：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can simply replace this snippet with two lines of code, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用以下两行代码简单地替换这段代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using such top-level statements, you can write concise programs. You can
    simply put the statements to be executed at the top of the program. This is also
    useful for speeding up the learning curve with C#, as you need not worry about
    advanced concepts upfront. The only thing to look out for here is that the project
    can have only one file with top-level statements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这样的顶级语句，您可以编写简洁的程序。您可以简单地将要执行的语句放在程序的顶部。这对于加快学习C#的速度也很有用，因为您不需要担心提前学习高级概念。唯一需要注意的是，项目只能有一个包含顶级语句的文件。
- en: That is why in this chapter, you will find that all exercises will use this
    format, to make things as clear as possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在本章中，您会发现所有练习都使用这种格式，以尽可能清晰地表达事物。
- en: Declaring Variables
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: You will now take your first steps in creating your own programs. This section
    will delve into the concept of variables—what they are and how to use them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将迈出创建自己程序的第一步。本节将深入探讨变量的概念——它们是什么以及如何使用它们。
- en: A variable is a name given to a computer memory location that holds some data
    that may vary. For a variable to exist, it first must be **declared** with a type
    and a name. It can also have a value assigned to it. The declaration of a variable
    can be achieved in a few different ways.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是给计算机内存位置的名称，用于保存可能变化的一些数据。要使变量存在，首先必须用类型和名称**声明**它。它也可以有一个赋给它的值。变量的声明可以通过几种不同的方式实现。
- en: 'There are some basic considerations regarding naming conventions for variables
    in C#:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#中变量命名约定的一些基本考虑：
- en: The names must be unique, starting with a letter, and should contain only letters,
    digits, and the underscore character (`_`). The names can also begin with an underscore
    character.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须是唯一的，以字母开头，只能包含字母、数字和下划线字符(`_`)。名称也可以以下划线字符开头。
- en: The names are case-sensitive; thus, `myVariable` and `MyVariable` are different
    names.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是区分大小写的；因此，`myVariable`和`MyVariable`是不同的名称。
- en: Reserved keywords, such as `int` or `string`, cannot be used as names (this
    is a compiler restriction) unless you put an `@` symbol in front of the name,
    such as `@int` or `@string`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留关键字，如`int`或`string`，不能作为名称使用(这是编译器的限制)，除非在名称前加上`@`符号，如`@int`或`@string`。
- en: 'Variables can be declared in two ways: explicitly and implicitly. Both styles
    of the declaration have their pros and cons, which you will explore in the next
    section.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以以显式和隐式两种方式声明。声明的两种风格各有利弊，您将在下一节中探讨。
- en: Declaring Variables Explicitly
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式声明变量
- en: 'A variable can be declared explicitly by writing both its type and value. Suppose
    you want to create two variables, `a` and `b`, both containing integers. Doing
    so explicitly would look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过同时写出其类型和值来显式声明。假设您想创建两个变量，`a`和`b`，都包含整数。显式声明如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before a variable is used, it must have a value assigned. Otherwise, the C#
    compiler will give an error while building your program. The following example
    illustrates that:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变量之前，必须为变量赋值。否则，C#编译器在构建程序时会报错。以下示例说明了这一点：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also possible to declare multiple variables in the same line, like in
    the following snippet, where you are declaring three variables; two hold the value
    `100` and one holds the value `10`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一行中声明多个变量也是可能的，就像在以下代码片段中一样，您在声明三个变量；两个保存值`100`，一个保存值`10`：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Declaring Variables Implicitly
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式声明变量
- en: Remember that C# is a strongly typed programming language; this means that a
    variable will always have a type associated with it. It does not matter whether
    the type is declared implicitly or explicitly. With the `var` keyword, the C#
    compiler will infer the variable type based on the value that has been assigned
    to it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，C#是一种强类型的编程语言；这意味着变量总是与一个类型相关联。无论类型是隐式声明还是显式声明，都无关紧要。使用`var`关键字，C#编译器将根据分配给它的值推断变量类型。
- en: 'Consider that you want to create a variable that holds some text using this
    method. This can be done with the following statement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你想要创建一个变量，使用这种方法来保存一些文本。可以通过以下语句来实现：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For storing text in a variable, you should start and end the text with double
    quotes (`"`). In the preceding example, by looking at the value that was assigned
    to `name`, C# knows that the type this variable holds is a string, even though
    the type is not mentioned in the statement.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本存储在变量中，你应该用双引号(`"`)开始和结束文本。在上面的例子中，通过查看被赋给`name`的值，C#知道这个变量所持有的类型是字符串，即使在语句中没有提到类型。
- en: Explicit versus Implicit Declaration
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式声明与隐式声明
- en: Explicit declarations enhance readability with the type declared, and this is
    one of the main advantages of this technique. On the other hand, they tend to
    let the code become more verbose, especially when working with some data types
    (that you will see further ahead), such as `Collections`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显式声明增强了类型声明的可读性，这是这种技术的主要优势之一。另一方面，它们往往会让代码变得更冗长，特别是在使用一些数据类型（稍后会看到）时，比如`Collections`。
- en: Essentially, deciding on the style of declaration depends on the personal preferences
    of the programmer, and may be influenced by the company's guidelines in some cases.
    In this journey of learning, it is recommended that you pick one that makes your
    learning path smoother, as there are few substantial differences from a purely
    technical standpoint.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，决定声明的风格取决于程序员的个人偏好，并且在某些情况下可能会受到公司指南的影响。在学习的过程中，建议你选择一种使你的学习路径更加顺畅的方式，因为从纯技术角度来看，几乎没有实质性的差异。
- en: 'In the next exercise, you will do this yourself by assigning variables to inputs
    that come from a user''s interaction with a console application, where the user
    will be asked to input their name. To complete this exercise, you will make use
    of the following built-in methods that C# provides, which you will be using frequently
    in your C# journey:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将通过为来自用户与控制台应用程序的交互的输入分配变量来自己完成这个任务，用户将被要求输入他们的名字。要完成这个练习，你将使用C#提供的以下内置方法，这些方法在你的C#之旅中经常会用到：
- en: '`Console.ReadLine()`: This allows you to retrieve a value that the user prompted
    on the console.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.ReadLine()`: 这允许你检索用户在控制台上提示的值。'
- en: '`Console.WriteLine()`: This writes the value passed as an argument as an output
    to the console.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.WriteLine()`: 这将传递作为参数的值作为输出写入到控制台。'
- en: 'Exercise 1.02: Assigning Variables to User Inputs'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：将变量分配给用户输入
- en: In this exercise, you will create an interactive console application. The app
    should ask you for your name, and once provided, it should display a greeting
    with your name in it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个交互式的控制台应用程序。该应用程序应该询问你的名字，一旦提供，它应该显示一个带有你的名字的问候语。
- en: 'To complete this exercise, perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，请执行以下步骤：
- en: 'Open Command Prompt and type the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，输入以下内容：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command creates a new console application in the `Exercise1_02` folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在`Exercise1_02`文件夹中创建一个新的控制台应用程序。
- en: 'Open the `Program.cs` file. Paste the following inside the `Main` method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件。将以下内容粘贴到`Main`方法中：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the file. On the command line, type the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。在命令行中，输入以下内容：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This outputs the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, type your name into the console and hit `Enter` on your keyboard. For
    example, if you type in `Mateus`, the following will be the output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在控制台中输入你的名字，然后按下键盘上的`Enter`。例如，如果你输入`Mateus`，输出将会是：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/1fbVH](https://packt.link/1fbVH).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/1fbVH](https://packt.link/1fbVH)找到用于这个练习的代码。
- en: You are more familiar with what variables are, how to declare them, and how
    to assign values to them. Now it is time to start talking about what data these
    variables can store and, more specifically, what types of data there are.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经更熟悉变量是什么，如何声明它们，以及如何给它们赋值。现在是时候开始讨论这些变量可以存储什么数据，更具体地说，有哪些数据类型。
- en: Data Types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: In this section, you will talk about the main data types within C# and their functionalities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将讨论C#中的主要数据类型及其功能。
- en: Strings
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'C# uses the `string` keyword to identify data that stores text as a sequence
    of characters. You can declare a string in several ways, as shown in the following
    snippet. However, when assigning some value to a string variable, you must place
    the content between a pair of double quotes, as you can see in the last two examples:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用`string`关键字来标识存储文本的数据，作为字符序列。你可以以几种方式声明字符串，如下面的代码片段所示。然而，当将一些值赋给字符串变量时，你必须将内容放在一对双引号之间，就像在最后两个例子中看到的那样：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One simple but effective technique (that you used in the preceding *Exercise
    1.02*) is one called string interpolation. With this technique, it is very simple
    to mix plain text values with variable values, so that the text is combined among
    these two. You can combine two or more strings by following these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单但有效的技术（你在前面的*练习1.02*中使用过）叫做字符串插值。通过这种技术，很容易将纯文本值与变量值混合在一起，使文本在这两者之间组合。你可以通过以下步骤来组合两个或更多个字符串：
- en: Before the initial quotes, insert a `$` symbol.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始引号之前，插入一个`$`符号。
- en: 'Now, inside the strings, place curly brackets and the name of the variable
    that you want to put into the string. In this case, this is done by putting `{name}`
    inside the initial string:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在字符串内部，放置花括号和你想要放入字符串中的变量的名称。在这种情况下，通过在初始字符串中放置`{name}`来实现：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another important fact to remember about strings is that they are immutable.
    This means that a string object cannot be changed after its creation. This happens
    because strings in C# are an array of characters. Arrays are data structures that
    gather objects of the same type and have a fixed length. You will cover arrays
    in detail in an upcoming section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串的另一个重要事实是它们是不可变的。这意味着字符串对象在创建后无法更改。这是因为C#中的字符串是字符数组。数组是一种数据结构，它们收集相同类型的对象并具有固定的长度。您将在接下来的部分详细介绍数组。
- en: In the next exercise, you will explore string immutability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将探索字符串的不可变性。
- en: 'Exercise 1.03: Checking String Immutability'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：检查字符串的不可变性
- en: 'In this exercise, you will use two strings to demonstrate that string references
    are always immutable. Perform the following steps to do so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用两个字符串来演示字符串引用始终是不可变的。执行以下步骤：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端，并输入以下内容：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the `Program.cs` file and create a method with the `void` return type,
    which replaces part of a string like so:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，并创建一个返回类型为`void`的方法，用于替换字符串的一部分，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, the `Replace` function is used to replace the first
    string (`World`, in this case) with the second one (`Mars`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，使用`Replace`函数将第一个字符串（在本例中为`World`）替换为第二个字符串（`Mars`）。
- en: 'Now, create a method that does the same thing but returns the result instead:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个方法，执行相同的操作，但返回结果：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now insert the following after the previous methods. Here, you create two string
    variables and observe their behavior after trying to modify them with the methods
    created previously:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在上述方法之后插入以下内容。在这里，您创建两个字符串变量，并在尝试使用先前创建的方法修改它们后观察它们的行为：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, call `dotnet run --project Exercise1_03` from the command line. You
    should see the following output on the console:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从命令行调用`dotnet run --project Exercise1_03`。您应该在控制台上看到以下输出：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/ZoNiw](https://packt.link/ZoNiw).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ZoNiw](https://packt.link/ZoNiw)找到此练习使用的代码。
- en: With this exercise, you saw the concept of string immutability in action. When
    you passed a string that was a reference type (`Hello World!`) as a method argument,
    it was not modified. That is what happens when you use the `FormatString` method,
    which returns `void`. Due to string immutability, a new string is created but
    not allocated to any variable, and the original string stays the same. With the
    second method, it returns a new string, and this string is then printed to the
    console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，您看到了字符串不可变性的概念。当您传递一个作为方法参数的引用类型字符串（`Hello World!`）时，它不会被修改。这就是当您使用返回`void`的`FormatString`方法时发生的情况。由于字符串不可变性，将创建一个新字符串，但不会分配给任何变量，原始字符串保持不变。而第二个方法返回一个新字符串，然后将该字符串打印到控制台。
- en: Comparing Strings
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字符串
- en: 'Even though strings are reference values, when you use the `.Equals()` method,
    the equality operator (`==`), and other operators (such as `!=`), you are actually
    comparing the values of the strings, as can be seen in the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符串是引用值，但当您使用`.Equals()`方法、相等运算符（`==`）和其他运算符（如`!=`）时，实际上是在比较字符串的值，如下例所示：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can compare these values and call `Console.WriteLine()` to output the
    result, like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以比较这些值，并调用`Console.WriteLine()`输出结果，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the preceding code results in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将产生以下输出：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You get this output because, even though strings are reference types, both the
    `==` and `.Equals` comparisons run against string values. Also, remember that
    strings are immutable. This means that when you assign `second` to `first` and
    set `first` as `null`, a new value is created for `first` and, therefore, the
    reference for `second` does not change.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您会得到这个输出，因为尽管字符串是引用类型，但`==`和`.Equals`比较都是针对字符串值的。还要记住字符串是不可变的。这意味着当您将`second`赋给`first`并将`first`设置为`null`时，将为`first`创建一个新值，因此`second`的引用不会改变。
- en: Numeric Types
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字类型
- en: 'C# has its numeric types subdivided into two main categories—integral and floating-point
    type numbers. The integral number types are as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: C#将其数字类型细分为两大类——整数和浮点类型数字。整数类型数字如下：
- en: '`sbyte`: Holds values from -128 to 127'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbyte`：保存从-128到127的值'
- en: '`short`: Holds values from -32,768 to 32,767'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：保存从-32,768到32,767的值'
- en: '`int`: Holds values from -2,147,483,648 to 2,147,483,647'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：保存从-2,147,483,648到2,147,483,647的值'
- en: '`long`: Holds values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：保存从-9,223,372,036,854,775,808到9,223,372,036,854,775,807的值'
- en: Deciding which type of integral type to use depends on the size of the values
    you want to store.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪种整数类型取决于您要存储的值的大小。
- en: All these types are called signed values. This means that they can store both
    negative and positive numbers. There is also another range of types called unsigned
    types. Unsigned types are `byte`, `ushort`, `uint`, and `ulong`. The main difference
    between them is that signed types can store negative numbers and unsigned types
    can store only numbers greater than or equal to zero. You will use signed types
    most of the time, so do not worry about remembering this all at once.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都被称为有符号值。这意味着它们可以存储负数和正数。还有另一系列称为无符号类型的类型。无符号类型包括`byte`、`ushort`、`uint`和`ulong`。它们之间的主要区别在于有符号类型可以存储负数，而无符号类型只能存储大于或等于零的数字。您将大部分时间使用有符号类型，所以不用担心一次记住所有这些。
- en: 'The other category, namely, floating-point types, refers to the types used
    to store numbers with one or more decimal points. There are three floating-point
    types in C#:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类别，即浮点类型，指的是用于存储一个或多个小数点的数字的类型。C#中有三种浮点类型：
- en: '`float`: This occupies four bytes and can store numbers from ± 1.5 x 10−45
    to ± 3.4 x 1038 with a precision range of six to nine digits. To declare a float
    number using `var`, you can simply append `f` to the end of the number, like so:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：占用4字节，可以存储从± 1.5 x 10−45到± 3.4 x 1038的数字，精度范围为6到9位。要使用`var`声明一个浮点数，您可以简单地在数字后面添加`f`，如下所示：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`double`: This occupies eight bytes and can store numbers from ± 5.0 × 10−324
    to ± 1.7 × 1030 with a precision range of 15 to 17 digits. To declare a double
    number using var, you can append d to the end of the number, like so:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：占用8字节，可以存储从± 5.0 × 10−324到± 1.7 × 1030的数字，精度范围为15到17位。要使用var声明一个双精度数，您可以在数字后面添加d，如下所示：'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`decimal`: This occupies 16 bytes and can store numbers from ± 1.0 x 10-28
    to ± 7.9228 x 1028 with a precision range from 28 to 29 digits. To declare a decimal
    number using var, you must simply append m to the end of the number, like so:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`：占用16字节，可以存储从± 1.0 x 10-28到± 7.9228 x 1028的数字，精度范围为28到29位。要使用var声明一个十进制数，您只需在数字后面添加m，如下所示：'
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Choosing the floating-point type depends mainly on the degree of precision required.
    For instance, `decimal` is mostly used for financial applications that need a
    very high degree of precision and cannot rely on rounding for accurate calculations.
    With GPS coordinates, `double` variables might be appropriate if you want to deal
    with sub-meter precisions that usually have 10 digits.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 选择浮点类型主要取决于所需的精度程度。例如，`decimal`主要用于需要非常高精度且不能依赖四舍五入进行精确计算的金融应用。对于GPS坐标，如果需要处理通常具有10位数字的亚米精度，`double`变量可能是合适的选择。
- en: Another relevant point to consider when choosing numeric types is performance.
    The larger the memory space allocated to a variable, the less performant the operations
    with these variables are. Therefore, if high precision is not a requirement, `float`
    variables will be better performers than `doubles`, which, in turn, will be better
    performers than decimals.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择数字类型时要考虑的另一个相关点是性能。分配给变量的内存空间越大，对这些变量的操作性能就越低。因此，如果不需要高精度，`float`变量的性能将优于`double`，而`double`的性能又将优于`decimal`。
- en: Here you grasped what variables are and their main types. Now you will perform
    some basic calculations with them, such as addition, subtraction, and multiplication.
    This can be done using the arithmetic operators available in C#, such as `+`,
    `-`, `/`, and `*`. So, move on to the next exercise where you will create a basic
    calculator using these operators.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您了解了变量及其主要类型。现在，您将使用它们执行一些基本的计算，如加法、减法和乘法。这可以通过C#中可用的算术运算符来实现，如`+`、`-`、`/`和`*`。因此，继续进行下一个练习，您将使用这些运算符创建一个基本的计算器。
- en: 'Exercise 1.04: Using the Basic Arithmetic Operators'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：使用基本算术运算符
- en: In this exercise, you will create a simple calculator that receives two inputs
    and shows the results between them, based on which arithmetic operation is selected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个简单的计算器，接收两个输入，并根据所选的算术运算显示它们之间的结果。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端，输入以下内容：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Navigate to the project folder, open the `Program.cs` file, and inside the
    `Main` method, declare two variables that read the user input, like so:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目文件夹，打开`Program.cs`文件，在`Main`方法中声明两个变量，读取用户输入，如下所示：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding snippet uses the `.ReadLine` method to read the input. This method,
    however, gives a `string`, and you need to evaluate a number. Therefore, the `Parse`
    method has been used here. All the numeric types have a method called Parse, which
    receives a string and converts it into a number.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用`.ReadLine`方法读取输入。但是，这个方法返回一个`string`，而您需要评估一个数字。因此，在这里使用了`Parse`方法。所有数字类型都有一个名为Parse的方法，它接收一个字符串并将其转换为数字。
- en: 'Next, you need to write the output of these basic operators to the console.
    Add the following code to the `Main` method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要将这些基本运算符的输出写入控制台。将以下代码添加到`Main`方法中：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the program using the `dotnet run` command, and you should see the following
    output, if you input `10` and `20`, for instance:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行程序，如果您输入`10`和`20`，您应该会看到以下输出：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/ldWVv](https://packt.link/ldWVv).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ldWVv](https://packt.link/ldWVv)找到此练习中使用的代码。
- en: Thus, you have built a simple calculator app in C# using the arithmetic operators.
    You also learned about the concept of parsing, which is used to convert strings
    to numbers. In the next section, you will briefly cover the topic of classes,
    one of the core concepts of programming in C#.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经使用算术运算符在C#中构建了一个简单的计算器应用程序。您还了解了解析的概念，用于将字符串转换为数字。在下一节中，您将简要介绍类的主题，这是C#编程的核心概念之一。
- en: Classes
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes are an integral part of coding in C# and will be covered comprehensively
    in *Chapter 2*, *Building Quality Object-Oriented Code*. This section touches
    upon the basics of classes so that you can begin using them in your programs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类是C#编码的一个重要部分，并将在*第2章*，*构建高质量面向对象的代码*中得到全面覆盖。本节简要介绍了类的基础知识，以便您可以开始在程序中使用它们。
- en: The reserved `class` keyword within C# is used when you want to define the type
    of an object. An object, which can also be called an instance, is nothing more
    than a block of memory that has been allocated to store information. Given this
    definition, what a class does is act as a blueprint for an object by having some
    properties to describe this object and specifying the actions that this object
    can perform through methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，保留的`class`关键字用于定义对象的类型。对象，也可以称为实例，实际上就是分配了存储信息的内存块。根据这个定义，类的作用是作为对象的蓝图，具有一些属性来描述这个对象，并通过方法指定这个对象可以执行的操作。
- en: 'For example, consider that you have a class named `Person`, with two properties,
    `Name` and `Age`, and a method that checks whether `Person` is a child. Methods
    are where logic can be placed to perform some action. They can return a value
    of a certain type or have the special `void` keyword, which indicates that they
    do not return anything but just execute some action. You can also have methods
    calling other methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为`Person`的类，有两个属性`Name`和`Age`，以及一个检查`Person`是否为孩子的方法。方法是可以放置逻辑以执行某些操作的地方。它们可以返回特定类型的值，也可以有特殊的`void`关键字，表示它们不返回任何东西，只是执行某些操作。你也可以有方法调用其他方法：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One question remains, though. Since classes act as blueprints (or definitions
    if you prefer), how do you actually allocate memory to store the information defined
    by a class? This is done through a process called instantiation. When you instantiate
    an object, you allocate some space in memory for it in a reserved area called
    the heap. When you assign a variable to an object, you are setting the variable
    to have the address of this memory space, so that each time you manipulate this
    variable, it points to and manipulates the data allocated at this memory space.
    The following is a simple example of instantiation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题。由于类充当蓝图（或者如果你喜欢的话，是定义），你如何实际分配内存来存储类定义的信息？这是通过一个称为实例化的过程完成的。当你实例化一个对象时，你在内存中为它分配一些空间，在一个称为堆的保留区域中。当你将一个变量分配给一个对象时，你正在设置该变量具有这个内存空间的地址，这样每次你操作这个变量时，它指向并操作分配在这个内存空间的数据。以下是一个实例化的简单示例：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that `Person` has properties that have two magic keywords—`get` and `set`.
    Getters define that a property value can be retrieved, and setters define that
    a property value can be set.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Person`有两个魔术关键字`get`和`set`的属性。Getter定义了可以检索属性值，setter定义了可以设置属性值。
- en: Another important concept here is the concept of a constructor. A constructor
    is a method with no return type, usually present at the top level of the class
    for better readability. It specifies what is needed for an object to be created.
    By default, a class will always have a parameter-less constructor. If another
    constructor with parameters is defined, the class will be constrained to only
    this one. In that case, if you still want to have a parameter-less constructor,
    you must specify one. This is quite useful, as classes can have multiple constructors.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个重要的概念是构造函数。构造函数是一个没有返回类型的方法，通常出现在类的顶层，以提高可读性。它指定了创建对象所需的内容。默认情况下，类将始终具有一个无参数的构造函数。如果定义了带参数的另一个构造函数，类将被限制为只有这一个。在这种情况下，如果你仍然想要一个无参数的构造函数，你必须指定一个。这是非常有用的，因为类可以有多个构造函数。
- en: 'That said, you can assign values to an object property that has a setter in
    the following ways:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你可以通过以下方式为具有setter的对象属性分配值：
- en: 'At the time of creation, via its constructor:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时，通过它的构造函数：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the time of creation, with direct variable assignment:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时，通过直接变量赋值：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the object is created, as follows:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建后，如下所示：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is a lot more to classes that you will see further on. For now, the main
    ideas are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类还有很多你将在后面看到的内容。现在，主要思想如下：
- en: Classes are blueprints of objects and can have both properties and methods that
    describe these objects.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象的蓝图，可以具有描述这些对象的属性和方法。
- en: Objects need to be instantiated so that you can perform operations with them.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象需要被实例化，这样你才能对它们进行操作。
- en: Classes have one parameter-less constructor by default, but can have many customized
    ones as required.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类默认有一个无参数的构造函数，但可以根据需要有许多自定义的构造函数。
- en: Object variables are references that contain the memory address of a special
    memory space allocated to the object inside a dedicated memory section named the
    heap.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象变量是包含对象在专用内存部分中分配的特殊内存空间的内存地址的引用。
- en: Dates
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期
- en: A date can be represented in C# using the `DateTime` value type. It is a struct
    with two static properties called `MinValue`, which is January 1, 0001 00:00:00,
    and `MaxValue`, which is December 31, 9999 11:59:59 P.M. As the names suggest,
    both these values represent the minimum and maximum dates according to the Gregorian
    calendar date format. The default value for `DateTime` objects is `MinValue`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，可以使用`DateTime`值类型来表示日期。它是一个具有两个静态属性的结构，称为`MinValue`，即公元0001年1月1日00:00:00，和`MaxValue`，即公元9999年12月31日23:59:59。正如名称所示，这两个值代表了根据公历日期格式的最小和最大日期。`DateTime`对象的默认值是`MinValue`。
- en: 'It is possible to construct a `DateTime` variable in various ways. Some of
    the most common ways are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以各种方式构造`DateTime`变量。其中一些最常见的方式如下：
- en: 'Assigning the current time as follows:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如下分配当前时间：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This sets the variable to the current date and time on the calling computer,
    expressed as the local time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量设置为调用计算机上的当前日期和时间，表示为本地时间。
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This sets the variable to the current date and time on this computer, expressed
    as the Coordinated Universal Time (UTC).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量设置为协调世界时（UTC）表示的当前日期和时间。
- en: You can also use constructors for passing days, months, years, hours, minutes,
    and even seconds and milliseconds.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以使用构造函数来传递天、月、年、小时、分钟，甚至秒和毫秒。
- en: There is also a special property available for `DateTime` objects called `Ticks`.
    It is a measure of the number of 100 nanoseconds elapsed since `DateTime.MinValue`.
    Every time you have an object of this type, you can call the `Ticks` property
    to get such a value.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTime`对象还有一个特殊属性叫做`Ticks`。它是自`DateTime.MinValue`以来经过的100纳秒的数量。每次你有这种类型的对象，你都可以调用`Ticks`属性来获得这样的值。'
- en: Another special type for dates is the `TimeSpan` struct. A `TimeSpan` object
    represents a time interval as days, hours, minutes, and seconds. It is useful
    when fetching intervals between dates. You will now see what this looks like in practice.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期的另一种特殊类型是`TimeSpan`结构。`TimeSpan`对象表示以天、小时、分钟和秒为单位的时间间隔。在获取日期之间的间隔时很有用。现在你将看到这在实践中是什么样子的。
- en: 'Exercise 1.05: Using Date Arithmetic'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：使用日期算术
- en: 'In this exercise, you will use the `TimeSpan` method/struct to calculate the
    difference between your local time and the UTC time. To complete this exercise,
    perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，您将使用`TimeSpan`方法/结构来计算本地时间和UTC时间之间的差异。要完成此练习，请执行以下步骤：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端并键入以下内容：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open the `Program.cs` file.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件。
- en: 'Paste the following inside the `Main` method and save the file:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容粘贴到`Main`方法中并保存文件：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding snippet, you first checked whether the current local date and
    UTC dates were equal. Then you checked for the interval between them, if any,
    using the `TimeSpan` method. Next, it printed the difference between the local
    and UTC time and printed the date two days ahead of the current one (`31/12/ 2020`,
    in this case).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您首先检查了当前本地日期和UTC日期是否相等。然后，您使用`TimeSpan`方法检查它们之间的间隔（如果有的话）。接下来，它打印了本地和UTC时间之间的差异，并打印了比当前日期提前两天的日期（在本例中为`31/12/2020`）。
- en: 'Save the file. On the command line, type the following:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。在命令行上，键入以下内容：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see an output like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下的输出：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/WIScZ](https://packt.link/WIScZ).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/WIScZ](https://packt.link/WIScZ)找到用于此练习的代码。
- en: Note that depending on your time zone, you will likely see different output.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据您所在的时区，您可能会看到不同的输出。
- en: Formatting Dates
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化日期
- en: 'It is also possible to format `DateTime` values to localized strings. That
    means formatting a `DateTime` instance according to a special concept within the
    C# language called a culture, which is a representation of your local time. For
    instance, dates are represented differently in different countries. Now take a
    look at the following examples, where dates are outputted in both the format used
    in France and the format used in the United States:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将`DateTime`值格式化为本地化字符串。这意味着根据C#语言中称为文化的特殊概念格式化`DateTime`实例，文化是您本地时间的表示。例如，不同国家的日期表示方式不同。现在看一下以下示例，在这些示例中，日期以法国和美国使用的格式输出：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is also possible to explicitly define the format you want the date to be
    output in, as in the following example, where you pass the `yyyyMMddTHH:mm:ss`
    value to say that you want the date to be output as year, then month, then day,
    then hour, then minutes preceded by a colon, and finally, seconds, also preceded
    by a colon:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以明确定义您希望日期输出的格式，就像以下示例中一样，您传递`yyyyMMddTHH:mm:ss`值以表示您希望日期按年、月、日、小时、以冒号开头的分钟，最后是以冒号开头的秒输出：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following output gets displayed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Logical Operators and Boolean Expressions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符和布尔表达式
- en: 'You are already familiar with these. Recall that in the preceding exercise,
    you did the following comparison:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉这些。回想一下，在前面的练习中，您进行了以下比较：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This output assigns the value `true` to `now` if the dates are equal. But as
    you know, they might not necessarily be the same. Therefore, if the dates are
    different, a `false` value will be assigned. These two values are the result of
    such Boolean expressions and are called Boolean values. That is why the `now`
    variable has the type of `bool`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出将在日期相等时将值`true`分配给`now`。但是如您所知，它们可能不一定相同。因此，如果日期不同，将分配一个`false`值。这两个值是这样的布尔表达式的结果，并称为布尔值。这就是为什么`now`变量的类型是`bool`的原因。
- en: 'Boolean expressions are the base for every logical comparison in every program.
    Based on these comparisons, a computer can execute a certain behavior in a program.
    Here are some other examples of Boolean expressions and variable assignments:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式是每个程序中每个逻辑比较的基础。基于这些比较，计算机可以在程序中执行某种行为。以下是一些布尔表达式和变量赋值的其他示例：
- en: 'Assigning the result of a comparison that checks whether `a` is greater than
    `b`:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配检查`a`是否大于`b`的比较结果：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Assigning the result of a comparison that checks whether `b` is greater than
    or equal to `a`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配检查`b`是否大于或等于`a`的比较结果：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Checking whether two strings are equal and assigning the result of this comparison
    to a variable:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个字符串是否相等，并将此比较的结果分配给一个变量：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Clearly, the result of the previous comparison would be `false` and this value
    will be assigned to the `areTheseAnimalsSame` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，先前比较的结果将是`false`，并且此值将分配给`areTheseAnimalsSame`变量。
- en: 'Now that you have learned what Booleans are and how they work, it is time to
    look at some logical operators you can use to compare Boolean variables and expressions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了布尔变量和它们的工作原理，是时候看一些逻辑运算符，您可以使用这些运算符来比较布尔变量和表达式了。
- en: 'The `&&` (AND) operator: This operator will perform an equality comparison.
    It will return `true` if both are equal and `false` if they are not. Consider
    the following example, where you check whether two strings have the length `0`:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`（AND）运算符：此运算符将执行相等比较。如果两者相等，则返回`true`，如果它们不相等，则返回`false`。考虑以下示例，在这个示例中，您检查两个字符串的长度是否为`0`：'
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `||` (OR) operator: This operator will check whether either of the values
    being compared is `true`. For example, here you are checking whether at least
    one of the strings has zero length:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`（OR）运算符：此运算符将检查要比较的值中是否有一个为`true`。例如，在这里，您正在检查至少一个字符串的长度是否为零：'
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `!` (NOT) operator: This operator takes a Boolean expression or value and
    negates it; that is, it returns the opposite value. For example, consider the
    following example, where you negate the result of a comparison that checks whether
    one of the strings has zero length:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`！`（NOT）运算符：此运算符获取布尔表达式或值并对其取反；也就是说，它返回相反的值。例如，考虑以下示例，在这个示例中，您对检查一个字符串是否为零长度的比较结果取反：'
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using if-else Statements
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用if-else语句
- en: Up till now, you have learned about types, variables, and operators. Now it
    is time to go into the mechanisms that help you to use these concepts in real-world
    problems—that is, decision-making statements.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了类型、变量和运算符。现在是时候进入帮助你在现实世界问题中使用这些概念的机制了，也就是决策语句。
- en: In C#, `if-else` statements are some of the most popular choices for implementing
    branching in code, which means telling the code to follow one path if a condition
    is satisfied, else follow another path. They are logical statements that evaluate
    a Boolean expression and continue the program's execution based on this evaluation result.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`if-else`语句是实现代码分支的最受欢迎的选择之一，这意味着告诉代码在满足条件时遵循一条路径，否则遵循另一条路径。它们是逻辑语句，根据布尔表达式的评估结果继续程序的执行。
- en: For example, you can use `if-else` statements to check whether the password
    entered satisfies certain criteria (such as having at least six characters and
    one digit). In the next exercise, you will do exactly that, in a simple console
    application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用`if-else`语句来检查密码是否满足某些条件（比如至少有六个字符和一个数字）。在下一个练习中，你将在一个简单的控制台应用程序中做到这一点。
- en: 'Exercise 1.06: Branching with if-else'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.06：使用if-else进行分支
- en: In this exercise, you will use `if-else` statements to write a simple credentials
    check program. The application should ask the user to enter their username; unless
    this value is at least six characters in length, the user cannot proceed. Once
    this condition is met, the user should be asked for a password. The password should
    also have a minimum of six characters containing at least one digit. Only after
    both these criteria are met should the program display a success message, such
    as `User successfully registered`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`if-else`语句编写一个简单的凭据检查程序。应用程序应该要求用户输入他们的用户名；除非这个值至少有六个字符的长度，否则用户无法继续。一旦满足这个条件，用户应该被要求输入一个密码。密码也应该至少有六个字符，包含至少一个数字。只有在满足这两个条件之后，程序才应该显示一个成功消息，比如`User
    successfully registered`。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_06`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_06`的新控制台项目：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside the `Main` method, add the following code to ask the user for a username,
    and assign the value to a variable:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码来询问用户用户名，并将值赋给一个变量：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, the program needs to check whether the username has more than six characters
    and if not, write an error message to the console:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，程序需要检查用户名是否有超过六个字符，如果没有，就在控制台上写一个错误消息：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, within an `else` clause, you will continue the verification and ask the
    user to type a password. Once the user has entered a password, three points need
    to be checked. The first condition to check is whether the password has at least
    six characters and then whether there is at least one number. Then, if either
    of these conditions fails, the console should display an error message; else,
    it should display a success message. Add the following code for this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一个`else`子句中，你将继续验证并要求用户输入一个密码。一旦用户输入了密码，需要检查三个点。第一个条件是检查密码是否至少有六个字符，然后检查是否至少有一个数字。然后，如果这些条件中的任何一个失败，控制台应该显示一个错误消息；否则，它应该显示一个成功消息。添加以下代码来实现这一点：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: From the preceding snippet, you can see that if the user enters fewer than six
    characters, an error message is displayed as `The password must have at least
    6 characters.`. If the password doesn't contain a single digit but satisfies the
    preceding condition, another error message is displayed as `The password must
    contain at least one number.`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的片段中，你可以看到如果用户输入少于六个字符，就会显示一个错误消息`The password must have at least 6 characters.`。如果密码不包含一个数字但满足前面的条件，就会显示另一个错误消息`The
    password must contain at least one number.`。
- en: Notice the logical condition used for this, which is `!password.Any(c => char.IsDi©(c))`.
    You will learn more about the `=>` notation in *Chapter 2*, *Building Quality
    Object-Oriented Code*, but for now, you just need to know that this line checks
    every character in the password and uses the `IsDigit` function to check whether
    the character is a digit. This is done for every character, and if no digit is
    found, the error message is displayed. If all the conditions are met, a success
    message is displayed as `User successfully registered.`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里使用的逻辑条件是`!password.Any(c => char.IsDi©(c))`。你将在*第2章*，*构建高质量面向对象的代码*中学到更多关于`=>`符号的知识，但现在你只需要知道这行代码检查密码中的每个字符，并使用`IsDigit`函数来检查字符是否是数字。这对每个字符都做了，如果没有找到数字，就显示错误消息。如果所有条件都满足，就显示成功消息`User
    successfully registered.`。
- en: 'Run the program using `dotnet run`. You should see an output like the following:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`运行程序。你应该会看到如下输出：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/3Q7oK](https://packt.link/3Q7oK).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/3Q7oK](https://packt.link/3Q7oK)找到本练习使用的代码。
- en: In this exercise, you worked with if-else branching statements to implement
    a simple user registration program.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了if-else分支语句来实现一个简单的用户注册程序。
- en: The Ternary Operator
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'Another simple-to-use, yet effective, decision-making operator is the ternary
    operator. It allows you to set the value of a variable based on a Boolean comparison.
    For example, consider the following example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单易用但有效的决策运算符是三元运算符。它允许你根据布尔比较来设置变量的值。例如，考虑以下例子：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you are using the `?` symbol to check whether the Boolean condition placed
    before it is valid. The compiler runs the `IsChild` function for the `person`
    object. If the method returns `true`, the first value (before the `:` symbol)
    will be assigned to the `gift` variable. If the method returns `false`, the second
    value (after the `:` symbol) will be assigned to the `gift` variable.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`?`符号来检查它之前放置的布尔条件是否有效。编译器为`person`对象运行`IsChild`函数。如果该方法返回`true`，则将第一个值（`:`符号之前）分配给`gift`变量。如果该方法返回`false`，则将第二个值（`:`符号之后）分配给`gift`变量。
- en: The ternary operator is simple and makes assignments based on simple Boolean
    verifications even more concise. You will be using this quite often in your C#
    journey.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符简单明了，可以根据简单的布尔验证进行赋值。在C#的学习过程中，您会经常使用它。
- en: Reference and Value Types
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型和值类型
- en: 'There are two types of variables in C#, namely, reference types and value types.
    Variables of value types, such as structs, contain the values themselves, as the
    name suggests. These values are stored in a memory space called the stack. When
    a variable of such a type is declared, specific memory space is allocated to store
    this value, as illustrated in the following figure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有两种类型的变量，即引用类型和值类型。值类型的变量，如结构体，包含值本身，正如其名称所示。这些值存储在称为堆栈的内存空间中。当声明此类类型的变量时，会分配特定的内存空间来存储该值，如下图所示：
- en: '![Figure 1.2: Memory allocation for a value type variable'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：值类型变量的内存分配'
- en: '](img/B16835_01_02.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_02.jpg)'
- en: 'Figure 1.2: Memory allocation for a value type variable'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：值类型变量的内存分配
- en: Here, the value of the variable, which is `5`, is stored in memory at the location
    `0x100` in the RAM. The built-in value types for C# are `bool`, `byte`, `char`,
    `decimal`, `double`, `enum`, `float`, `int`, `long`, `sbyte`, `short`, `struct`,
    `uint`, `ulong`, and `ushort`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量的值，即`5`，存储在RAM中的位置`0x100`的内存中。C#的内置值类型包括`bool`、`byte`、`char`、`decimal`、`double`、`enum`、`float`、`int`、`long`、`sbyte`、`short`、`struct`、`uint`、`ulong`和`ushort`。
- en: 'The scenario for reference type variables is different, though. The three main
    reference types you need to know about in this chapter are `string`, array, and
    `class`. When a new reference type variable is assigned, what is stored in memory
    is not the value itself, but instead a memory address where the value gets allocated.
    For example, consider the following diagram:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，引用类型变量的情况是不同的。在本章中，您需要了解的三种主要引用类型是`string`、数组和`class`。当分配新的引用类型变量时，存储在内存中的不是值本身，而是值被分配的内存地址。例如，考虑以下图表：
- en: '![Figure 1.3: Memory allocation for a reference type variable'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：引用类型变量的内存分配'
- en: '](img/B16835_01_03.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_03.jpg)'
- en: 'Figure 1.3: Memory allocation for a reference type variable'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：引用类型变量的内存分配
- en: 'Here, instead of the value of the string variable (`Hello`), the address where
    it is allocated (`0x100`) is stored in memory. For brevity, you will not dive
    deep into this topic, but it is important to know the following points:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内存中存储的是字符串变量（`Hello`）的地址，而不是其值。为简洁起见，您不会深入探讨这个话题，但重要的是要知道以下几点：
- en: When value type variables are passed as parameters or assigned as the value
    of another variable, the .NET runtime copies the value of the variable to the
    other object. This means that the original variable is not affected by any changes
    made in the newer and subsequent variables, as the values were literally copied
    from one place to another.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值类型变量作为参数传递或分配为另一个变量的值时，.NET运行时会将变量的值复制到另一个对象。这意味着原始变量不会受到在新的和后续变量中所做的任何更改的影响，因为这些值实际上是从一个地方复制到另一个地方的。
- en: When reference type variables are passed as parameters or assigned as the value
    of another variable, .NET passes the heap memory address instead of the value.
    This means that every subsequent change made in this variable inside a method
    will be reflected outside.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引用类型变量作为参数传递或分配为另一个变量的值时，.NET传递的是堆内存地址，而不是值。这意味着在方法内部对该变量进行的每次更改都会在外部反映出来。
- en: 'For instance, consider the following code, which deals with integers. Here,
    you declare an `int` variable named `a` and assign the value `100` to it. Later,
    you create another `int` variable named `b` and assign the value of `a` to it.
    Finally, you modify `b`, to be incremented by `100`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下处理整数的代码。在这里，您声明一个名为`a`的`int`变量，并将值`100`赋给它。稍后，您创建另一个名为`b`的`int`变量，并将`a`的值赋给它。最后，您修改`b`，使其增加`100`：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The values of `a` and `b` will be displayed in the following output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`的值将显示在以下输出中：'
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, the value from `a` was copied into `b`. From this point, any
    other modification you do on `b` will reflect changes only in `b` and `a` will
    continue to have its original value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，从`a`中复制的值被复制到了`b`中。从这一点开始，您对`b`所做的任何其他修改都只会反映在`b`中，而`a`将继续保持其原始值。
- en: 'Now, what if you pass reference types as method arguments? Consider the following
    program. Here, you have a class named `Car` with two properties—`Name` and `GearType`.
    Inside the program is a method called `UpgradeGearType` that receives an object
    of the `Car` type and changes its `GearType` to `Automatic`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您将引用类型作为方法参数传递会怎样呢？考虑以下程序。在这里，您有一个名为`Car`的类，具有两个属性—`Name`和`GearType`。程序内部有一个名为`UpgradeGearType`的方法，该方法接收`Car`类型的对象并将其`GearType`更改为`Automatic`：
- en: '[PRE63]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After you create a `Car` `UpgradeGearType()` method, the output will be as
    the follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Car` `UpgradeGearType()`方法后，输出将如下所示：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Thus, you see that if you pass an `car` in this case) as an argument to a method
    (`UpgradeGearType` in this example), every change made inside this **object**
    is reflected after and outside the method call. This is because reference types
    refer to a specific location in memory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您会发现，如果您将一个`car`（在这种情况下）作为参数传递给一个方法（在本例中为`UpgradeGearType`），则在方法调用之后，内部和外部都会反映出对**对象**所做的任何更改。这是因为引用类型指的是内存中的特定位置。
- en: 'Exercise 1.07: Grasping Value and Reference Equality'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.07：掌握值和引用相等性
- en: 'In this exercise, you will see how equality comparison is different for value
    types and reference types. Perform the following steps to do so:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将看到值类型和引用类型的相等性比较是不同的。执行以下步骤来完成：
- en: 'In VS Code, open the integrated terminal and type the following:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中，打开集成终端并输入以下内容：
- en: '[PRE65]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open the `Program.cs` file. In the same file, create a struct named `GoldenRetriever`
    with a `Name` property, as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件。在同一个文件中，创建一个名为`GoldenRetriever`的结构，具有一个`Name`属性，如下所示：
- en: '[PRE66]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Still in the same file, create one more class named `BorderCollie` with a similar
    `Name` property:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在同一个文件中，创建另一个名为`BorderCollie`的类，具有类似的`Name`属性：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'One final class must be created, a class named `Bernese`, also having the `Name`
    property, but with an extra override of the native `Equals` method:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还必须创建一个名为`Bernese`的类，也具有`Name`属性，但还有一个重写本地`Equals`方法：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, the `this` keyword is used to refer to the current `borderCollie` class.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this`关键字用于引用当前的`borderCollie`类。
- en: 'Finally, in the `Program.cs` file, you will create some objects for these types.
    Note that since you are using **top-level statements**, these declarations should
    be above the class and the struct declarations:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Program.cs`文件中，你将为这些类型创建一些对象。请注意，由于你使用了**顶级语句**，这些声明应该在类和结构声明之上：
- en: '[PRE69]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, right after the previous declarations, compare these values using the
    `Equals` method and assign the result to some variables:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在之前的声明之后，使用`Equals`方法比较这些值，并将结果分配给一些变量：
- en: '[PRE70]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, print the comparison results to the console with the following:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下内容将比较结果打印到控制台：
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the program from the command line using `dotnet run` and you will see the
    following output:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令行运行程序，你将看到以下输出：
- en: '[PRE72]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/xcWN9](https://packt.link/xcWN9).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/xcWN9](https://packt.link/xcWN9)找到用于这个练习的代码。
- en: As mentioned earlier, structs are value types. Therefore, when two objects of
    the same struct are compared with `Equals`, .NET internally checks all the struct
    properties. If those properties have equal values, then `true` is returned. With
    `Golden Retrievers`, for instance, if you had a `FamilyName` property and this
    property was different between the two objects, the result of the equality comparison
    would be `false`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，结构体是值类型。因此，当两个相同结构的对象使用`Equals`进行比较时，.NET内部检查所有结构属性。如果这些属性具有相等的值，那么将返回`true`。例如，对于`Golden
    Retrievers`，如果你有一个`FamilyName`属性，并且这个属性在两个对象之间是不同的，那么相等性比较的结果将是`false`。
- en: For classes and all other reference types, the equality comparison is quite
    different. By default, object reference is checked on equality comparison. If
    the references are different (and they will be, unless the two variables are assigned
    to the same object), the equality comparison will return `false`. This explains
    the result you see for `Border Collies` in the example that the references were
    different for the two instances.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类和所有其他引用类型，相等性比较是非常不同的。默认情况下，对象引用在相等性比较上被检查。如果引用不同（而且除非两个变量被分配给相同的对象，它们将是不同的），相等性比较将返回`false`。这解释了你在示例中看到的`Border
    Collies`的结果，即两个实例的引用是不同的。
- en: However, there is a method that can be implemented in reference types called
    Equals. Given two objects, the `Equals` method can be used for comparison following
    the logic placed inside the method. That is exactly what happened with the Bernese
    dogs example.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以在引用类型中实现，叫做Equals。给定两个对象，`Equals`方法可以用于比较，遵循方法内部的逻辑。这正是伯恩山犬示例中发生的事情。
- en: Default Value Types
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值类型
- en: 'Now that you have dealt with value and reference types, you will briefly explore
    the default value types. In C#, every type has a default value, as specified in
    the following table:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经处理了值和引用类型，你将简要探索默认值类型。在C#中，每种类型都有一个默认值，如下表所示：
- en: '![Figure 1.4: Default value types table'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：默认值类型表'
- en: '](img/B16835_01_04.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_04.jpg)'
- en: 'Figure 1.4: Default value types table'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：默认值类型表
- en: 'These default values can be assigned to a variable using the `default` keyword.
    To use this word in a variable declaration, you must explicitly declare the variable
    type before its name. For example, consider the following snippet, where you are
    assigning the `default` value to two `int` variables:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些默认值可以使用`default`关键字分配给变量。要在变量声明中使用这个词，你必须在变量名之前显式声明变量类型。例如，考虑以下代码片段，其中你将`default`值分配给两个`int`变量：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Both `a` and `b` will be assigned the value `0` in this case. Note that it
    is not possible to use `var` in this case. This is because, for implicitly declared
    variables, the compiler needs a value assigned to the variable in order to infer
    its type. So, the following snippet will lead to an error because no type was
    set, either through an explicit declaration or by variable assignment:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a`和`b`都将被赋值为`0`。请注意，这种情况下不能使用`var`。这是因为对于隐式声明的变量，编译器需要为变量分配一个值以推断其类型。因此，以下代码片段将导致错误，因为没有设置类型，要么通过显式声明，要么通过变量赋值：
- en: '[PRE74]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Enhancing Decision Making with the switch Statement
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用switch语句增强决策制定
- en: 'The `switch` statement is often used as an alternative to the if-else construct
    if a single expression is to be tested against three or more conditions, that
    is, when you want to select one of many code sections to be executed, such as
    the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句经常被用作if-else结构的替代方案，如果要对三个或更多条件进行测试，则可以选择一个要执行的代码部分，例如以下情况：'
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The matching expression should return a value that is of one of the following
    types: `char`, `string`, `bool`, `numbers`, `enum`, and `object`. This value will
    then be evaluated within one of the matching case clauses or within the default
    clause if it does not match any prior clause.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配表达式应返回以下类型之一的值：`char`、`string`、`bool`、`numbers`、`enum`和`object`。然后，将在匹配的`case`子句中或在默认子句中对该值进行评估，如果它不匹配任何先前的子句。
- en: It is important to say that only one `switch` section in a `switch` statement
    will be executed. C# doesn't allow execution to continue from one `switch` section
    to the next. However, a `switch` statement does not know how to stop by itself.
    You can either use the `break` keyword if you only wish to execute something without
    returning or return something if that is the case.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要说，`switch`语句中只有一个`switch`部分会被执行。C#不允许从一个`switch`部分继续执行到下一个。但是，`switch`语句本身不知道如何停止。您可以使用`break`关键字，如果只希望执行某些操作而不返回，或者如果是这种情况，返回某些内容。
- en: Also, the `default` keyword on a `switch` statement is where the execution goes
    if none of the other options are matched. In the next exercise, you will use a
    `switch` statement to create a restaurant menu app.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`switch`语句上的`default`关键字是在没有匹配到其他选项时执行的位置。在下一个练习中，您将使用`switch`语句创建一个餐厅菜单应用程序。
- en: 'Exercise 1.08: Using switch to Order Food'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.08：使用switch订购食物
- en: In this exercise, you will create a console app that lets the user select from
    a menu of food items available at a restaurant. The app should display an acknowledgment
    receipt for the order. You will use the `switch` statement to implement the logic.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个控制台应用程序，让用户从餐厅提供的食物菜单中选择。该应用程序应显示订单的确认收据。您将使用`switch`语句来实现逻辑。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new console project called `Exercise1_08`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exercise1_08`的新控制台项目。
- en: 'Now, create an `System.Text.StringBuilder`. This is a class that helps build
    strings in many ways. Here, you are building strings line by line so that they
    can be properly displayed on the console:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`System.Text.StringBuilder`。这是一个帮助以多种方式构建字符串的类。在这里，您正在逐行构建字符串，以便它们可以在控制台上正确显示：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Display the menu on the console and ask the user to choose one of the options:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台上显示菜单，并要求用户选择其中一个选项：
- en: '[PRE77]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Read the key that the user presses and assign it to a variable with the `Console.ReadKey()`
    method. This method works similarly to `ReadLine()`, which you have used before,
    with the difference that it reads the key that is immediately pressed after calling
    the method. Add the following code for this:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取用户按下的键，并使用`Console.ReadKey()`方法将其赋值给一个变量。此方法与之前使用的`ReadLine()`类似，不同之处在于它读取调用方法后立即按下的键。添加以下代码：
- en: '[PRE78]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now it is time to use the `switch` statement. Use `option.KeyChar.ToString()`
    as the matching expression of the `switch` clause here. Keys `1`, `2`, `3`, and
    `4` should result in orders accepted for `burgers`, `cheeseburgers`, `double cheeseburgers`,
    and `Coke`, respectively:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是使用`switch`语句的时候了。在这里，将`option.KeyChar.ToString()`用作`switch`子句的匹配表达式。按键`1`、`2`、`3`和`4`应该分别接受`汉堡`、`芝士汉堡`、`双层芝士汉堡`和`可乐`的订单：
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Any other input, however, should be considered invalid and a message gets displayed,
    letting you know you have selected an invalid option:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，任何其他输入都应被视为无效，并显示一条消息，让您知道您选择了一个无效的选项：
- en: '[PRE80]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, run the program with `dotnet run --project Exercise1_08` and interact
    with the console to see the possible outputs. For example, if you type `1`, you
    should see an output like the following:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`dotnet run --project Exercise1_08`运行程序，并与控制台交互以查看可能的输出。例如，如果您输入`1`，您应该看到以下输出：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/x1Mvn](https://packt.link/x1Mvn).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/x1Mvn](https://packt.link/x1Mvn)找到此练习中使用的代码。
- en: Similarly, you should get the output for the other options as well. You have
    learned about branching statements in C#. There is another type of statement that
    you will use often while programming using C#, called iteration statements. The
    next section covers this topic in detail.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您还应该获取其他选项的输出。您已经了解了C#中的分支语句。在使用C#编程时，还有另一种类型的语句经常使用，称为迭代语句。下一节将详细介绍这个主题。
- en: Iteration Statements
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: Iteration statements, also called loops, are types of statements that are useful
    in the real world, as you often need to continuously repeat some logical execution
    in your applications `while` or `until` some condition is met, such as operating
    with a number that must be incremented until a certain value. C# offers numerous
    ways of implementing such iterations, and in this section, you will examine each
    of these in detail.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句，也称为循环，是现实世界中有用的语句类型，因为您经常需要在应用程序中不断重复一些逻辑执行，直到满足某些条件，例如使用必须递增直到达到某个值的数字。C#提供了许多实现这种迭代的方法，在本节中，您将详细研究每种方法。
- en: while
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while
- en: 'The first iteration statement you will consider is the `while` statement. This
    statement allows a C# program to execute a set of instructions while a certain
    Boolean expression is evaluated to be `true`. It has one of the most basic structures.
    Consider the following snippet:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 您将考虑的第一个迭代语句是`while`语句。此语句允许C#程序在某个布尔表达式被评估为`true`时执行一组指令。它具有最基本的结构之一。考虑以下片段：
- en: '[PRE82]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding snippet shows how you can use the `while` statement. Note that
    the `while` keyword is followed by a pair of brackets enclosing a logical condition;
    in this case, the condition is that the value of `i` must be less than `10`. The
    code written inside the curly braces will be executed until this condition is
    `true`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段显示了如何使用`while`语句。请注意，`while`关键字后面跟着一对括号，括号中包含一个逻辑条件；在这种情况下，条件是`i`的值必须小于`10`。在大括号中编写的代码将在此条件为`true`时执行。
- en: Thus, the preceding code will print the value of `i`, starting with `0`, up
    to `10`. This is fairly simplistic code; in the next exercise, you will use the
    `while` statement for something a little more complex, such as checking whether
    a number entered by you is a prime number.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的代码将打印`i`的值，从`0`开始，直到`10`。这是相当简单的代码；在下一个练习中，你将使用`while`语句进行一些更复杂的操作，比如检查你输入的数字是否是质数。
- en: 'Exercise 1.09: Checking Whether a Number is Prime with a while Loop'
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.09：使用while循环检查一个数字是否是质数
- en: In this exercise, you will use a `while` loop to check whether a number you
    enter is prime. To do so, the `while` loop will check whether the counter is less
    than or equal to the integer result of the division of the number by `2`. When
    this condition is satisfied, you check whether the remainder of the division of
    the number by the counter is `0`. If not, you increment the counter and continue
    until the loop condition is not met. If it is met, it means the number is not
    `false` and the loop can stop.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`while`循环来检查你输入的数字是否是质数。为此，`while`循环将检查计数器是否小于或等于数字除以`2`的整数结果。当满足这个条件时，你检查数字除以计数器的余数是否为`0`。如果不是，你增加计数器并继续，直到循环条件不再满足。如果满足，这意味着数字不是`false`，循环可以停止。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_09`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_09`的新控制台项目。
- en: 'Inside the `Program.cs` file, create the following method, which will perform
    the logic you introduced at the beginning of the exercise:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中创建以下方法，该方法将执行你在练习开始时介绍的逻辑：
- en: '[PRE83]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, input a number, so you can check whether it is prime:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入一个数字，这样你就可以检查它是否是质数：
- en: '[PRE84]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, check whether the number is prime and print the result:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查数字是否是质数并打印结果：
- en: '[PRE85]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, on the VS Code integrated terminal, call `dotnet run --project Exercise1_09`
    and interact with the program. For example, try entering `29` as an input:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在VS Code集成终端中，调用`dotnet run --project Exercise1_09`并与程序交互。例如，尝试输入`29`作为输入：
- en: '[PRE86]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As expected, the result for `29` is `true` since it is a prime number.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`29`的结果是`true`，因为它是一个质数。
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5oNg5](https://packt.link/5oNg5).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/5oNg5](https://packt.link/5oNg5)找到这个练习中使用的代码。
- en: The preceding exercise aimed to show you the simple structure of a `while` loop
    with some more complex logic. It checks a number (named `input`) and prints whether
    it is a prime number. Here, you have seen the `break` keyword used again to stop
    program execution. Now proceed to learn about jump statements.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习旨在向你展示一个带有一些更复杂逻辑的`while`循环的简单结构。它检查一个名为`input`的数字，并打印出它是否是一个质数。在这里，你已经看到了再次使用`break`关键字来停止程序执行。现在继续学习跳转语句。
- en: Jump Statements
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转语句
- en: 'There are some other important keywords used within loops that are worth mentioning
    as well. These keywords are called jump statements and are used to transfer program
    executions to another part. For instance, you could rewrite the `IsPrime` method
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用的一些其他重要关键字也值得一提。这些关键字称为跳转语句，用于将程序执行转移到另一个部分。例如，你可以将`IsPrime`方法重写如下：
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, you have inverted the logical check. Instead of checking whether the remainder
    is zero and then breaking the program execution, you have checked that the remainder
    is not zero and, if so, have used the `continue` statement to pass the execution
    to the next iteration.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经颠倒了逻辑检查。不再检查余数是否为零然后中断程序执行，而是检查余数是否不为零，如果是，则使用`continue`语句将执行传递到下一个迭代。
- en: 'Now look at how you can rewrite this using another special keyword, `goto`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看如何使用另一个特殊关键字`goto`重写这个：
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `goto` keyword can be used to jump from one part of the code to another
    one defined by what is called a label. In this case, the label was named `isNotAPrime`.
    Finally, take a look at one last way of writing this logic:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`关键字可以用来从代码的一个部分跳转到另一个由所谓的标签定义的部分。在这种情况下，标签被命名为`isNotAPrime`。最后，看一下写这个逻辑的最后一种方法：'
- en: '[PRE89]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, instead of using `break` or `continue` to stop the program execution, you
    simply use `return` to break the loop execution since the result that you were
    looking for was already found.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用`break`或`continue`来停止程序执行，而是简单地使用`return`来中断循环执行，因为已经找到了你要找的结果。
- en: do-while
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do-while
- en: 'The `do-while` loop is like the previous one, but with one subtle difference:
    it executes the logic at least once, while a simple `while` statement may never
    be executed if the condition is not met at the first execution. It has the following structure:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while`循环与前一个循环类似，但有一个细微的区别：它至少执行一次逻辑，而简单的`while`语句如果条件在第一次执行时不满足可能永远不会执行。它有以下结构：'
- en: '[PRE90]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this example, you write the value of `t`, starting from `0`, and keep incrementing
    it while it is smaller than `5`. Before jumping into the next type of loop, learn
    about a new concept called arrays.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你从`0`开始写入`t`的值，并在它小于`5`时不断递增。在跳转到下一个循环类型之前，学习一个叫做数组的新概念。
- en: Arrays
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a data structure used to store many objects of the same type. For
    instance, the following example is a variable declared as an array of integer
    numbers:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种用于存储相同类型的许多对象的数据结构。例如，下面的例子是一个声明为整数数组的变量：
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The first important thing to note about arrays is that they have a fixed capacity.
    This means that an array will have the length defined at the time of its creation
    and this length cannot change. The length can be determined in various ways. In
    the preceding example, the length is inferred by counting the number of objects
    in the array. However, another way of creating an array is like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的第一要点是它们有一个固定的容量。这意味着数组的长度在创建时被定义，并且这个长度不能改变。长度可以通过各种方式确定。在前面的例子中，长度是通过计算数组中对象的数量来推断的。然而，创建数组的另一种方式是这样的：
- en: '[PRE92]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, you are creating an array that has the capacity of `5` integers, but
    you do not specify any value for the array elements. When an array of any data
    type is created without adding elements to it, the default values for that value
    type are set for each position of the array. For example, consider the following
    figure:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在创建一个具有5个整数容量的数组，但您没有为数组元素指定任何值。当创建任何数据类型的数组时，而没有向其添加元素时，将为数组的每个位置设置该值类型的默认值。例如，请考虑以下图：
- en: '![Figure 1.5: Value type array with no index assigned'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：未分配索引的值类型数组'
- en: '](img/B16835_01_05.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_05.jpg)'
- en: 'Figure 1.5: Value type array with no index assigned'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5：未分配索引的值类型数组
- en: 'The preceding figure shows that when you create an integer array of five elements,
    without assigning a value to any element, the array is automatically filled with
    the default value at every position. In this case, the default value is `0`. Now
    consider the following figure:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示，当您创建一个包含五个元素的整数数组时，而没有为任何元素分配值时，数组会自动填充每个位置的默认值。在这种情况下，默认值为0。现在考虑以下图表：
- en: '![Figure 1.6: Reference type array with fixed size and only one index assigned'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：具有固定大小和仅分配一个索引的引用类型数组'
- en: '](img/B16835_01_06.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_01_06.jpg)'
- en: 'Figure 1.6: Reference type array with fixed size and only one index assigned'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：具有固定大小和仅分配一个索引的引用类型数组
- en: In the preceding example, you have created an array of five objects and assigned
    the `"Hello"` string value to the element at index `1`. The other positions of
    the array are automatically assigned the default value for objects, which is `null`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您创建了一个包含五个对象的数组，并将“Hello”字符串值分配给索引1处的元素。数组的其他位置会自动分配对象的默认值，即null。
- en: Finally, it is worth noting that all arrays have indexes, which refers to the
    positions of the individual array elements. The first position will always have
    an index `0`. Thus, the positions in an array of size `n` can be specified from
    index `0` to `n-1`. Therefore, if you call `numbers[2]`, this means that you are
    trying to access the element in position `2` inside the numbers array.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得注意的是，所有数组都有索引，它指的是单个数组元素的位置。第一个位置将始终具有索引0。因此，大小为n的数组的位置可以从索引0到n-1指定。因此，如果调用numbers[2]，这意味着您正在尝试访问numbers数组中位置2的元素。
- en: for Loops
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for循环
- en: 'A `for` loop executes a set of instructions while a Boolean expression matches
    a specified condition. Just like `while` loops, jump statements can be used to
    stop a loop execution. It has the following structure:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: for循环执行一组指令，同时匹配指定条件的布尔表达式。就像while循环一样，跳转语句可以用于停止循环执行。它具有以下结构：
- en: '[PRE93]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The initializer statement is executed before the loop starts. It is used to
    declare and assign a local variable that will be used only inside the scope of
    the loop.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句在循环开始之前执行。它用于声明和分配一个只在循环范围内使用的局部变量。
- en: 'But in more complex scenarios, it can be used to combine other statement expressions
    as well. The condition specifies a Boolean condition that indicates when the loop
    should either continue or exit. The iterator is usually used to increment or decrement
    the variable created in the initializer section. Take the following example, where
    a `for` loop is used to print the elements of an integer array:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 但在更复杂的情况下，它也可以用于组合其他语句表达式。条件指定一个布尔条件，指示循环何时应继续或退出。迭代器通常用于增加或减少初始化部分中创建的变量。考虑以下示例，其中使用for循环打印整数数组的元素：
- en: '[PRE94]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, an initializer variable, `j`, has been created that is assigned
    `0` initially. The `for` loop will keep executing while `j` is smaller than the
    array length minus `1` (remember that indexes always start at `0`). After each
    iteration, the value of `j` is incremented by `1`. In this way, the `for` loop
    goes through the entire array and performs the given action, that is, printing
    the value of the current array element.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了一个初始化变量j，最初分配为0。当j小于数组长度减1时（请记住，索引始终从0开始），for循环将继续执行。每次迭代后，j的值增加1。通过这种方式，for循环遍历整个数组并执行给定的操作，即打印当前数组元素的值。
- en: C# also allows the usage of **nested loops**, that is, a **loop within a loop**,
    as you will see in the next exercise.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: C#还允许使用嵌套循环，即循环内的循环，正如您将在下一个练习中看到的。
- en: 'Exercise 1.10: Ordering an Array Using Bubble Sort'
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.10：使用冒泡排序对数组进行排序
- en: In this exercise, you will execute one of the simplest sorting algorithms. Bubble
    sort consists of going through every pair of elements inside an array and swapping
    them if they are unordered. In the end, the expectation is to have an array ordered
    in ascending order. You will use nested `for` loops to implement this algorithm.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将执行最简单的排序算法之一。冒泡排序包括遍历数组中的每一对元素，并在它们无序时交换它们。最终，期望是得到一个按升序排序的数组。您将使用嵌套的for循环来实现这个算法。
- en: To begin with, the array to be sorted should be passed as a parameter to this
    method. For each element of this array, if the current element is greater than
    the next, their positions should be swapped. This swap occurs by storing the value
    of the next element in a temporary variable, assigning the value of the current
    element to the next element, and finally, setting the value of the current element
    with the temporary value stored. Once the first element is compared to all others,
    a comparison starts for the second element and so on, till finally, the array
    is sorted.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要对其进行排序的数组应作为参数传递给此方法。对于该数组的每个元素，如果当前元素大于下一个元素，则它们的位置应该被交换。这种交换是通过将下一个元素的值存储在临时变量中，将当前元素的值分配给下一个元素，最后用临时存储的值设置当前元素的值来实现的。一旦第一个元素与所有其他元素进行比较，就会开始对第二个元素进行比较，依此类推，直到最终数组排序完成。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: 'Create a new console project using the following command:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的控制台项目：
- en: '[PRE95]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Inside the `Program.cs` file, create the method to implement the sorting algorithm.
    Add the following code:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，创建实现排序算法的方法。添加以下代码：
- en: '[PRE96]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now create an **array** with some numbers, as follows:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个带有一些数字的**数组**，如下所示：
- en: '[PRE97]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Call the `BubbleSort` method, passing the array as an argument, and assign
    the result to a variable, as follows:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`BubbleSort`方法，将数组作为参数传递，并将结果分配给一个变量，如下所示：
- en: '[PRE98]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, you need to print the message that the array was sorted. To do so,
    iterate over it, printing the array elements:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要打印数组已排序的消息。为此，遍历它，打印数组元素：
- en: '[PRE99]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Run the program with the `dotnet run --project Exercise1_10` command. You should
    see the following output on your screen:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run --project Exercise1_10`命令运行程序。您应该在屏幕上看到以下输出：
- en: '[PRE100]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cJs8y](https://packt.link/cJs8y).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cJs8y](https://packt.link/cJs8y)找到用于此练习的代码。
- en: 'In this exercise, you used the two concepts learned in the last two sections:
    arrays and for loops. You manipulated arrays, accessing their values through indexes,
    and used for loops to move through these indexes.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用了在最后两节中学到的两个概念：数组和for循环。您操作了数组，通过索引访问它们的值，并使用for循环来移动这些索引。
- en: There is another way to go through every element of an array or `foreach` statements.
    You will explore this in the following section.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种遍历数组或`foreach`语句的方法。您将在下一节中探讨这一点。
- en: foreach Statements
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach语句
- en: 'A `foreach` statement executes a set of instructions for each element of a
    collection. Just like a `for` loop, the `break`, `continue`, `goto`, and `return`
    keywords can also be used with `foreach` statements. Consider the following example,
    in which you iterate over every element of an array and write it to the console
    as the output:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句为集合的每个元素执行一组指令。就像`for`循环一样，`break`，`continue`，`goto`和`return`关键字也可以与`foreach`语句一起使用。考虑以下示例，在该示例中，您遍历数组的每个元素并将其写入控制台作为输出：'
- en: '[PRE101]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The preceding snippet prints the numbers from `1` to `5` to the console. You
    can use `foreach` statements with much more than arrays; they can also be used
    with lists, collections, and spans, which are other data structures that will
    be covered in later chapters.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码段将数字`1`到`5`打印到控制台。您可以使用`foreach`语句处理的不仅仅是数组；它们还可以与列表，集合和跨度一起使用，这些是稍后将在后面的章节中介绍的其他数据结构。
- en: File Handling
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件处理
- en: So far, you have been creating programs that interact mostly with CPU and memory.
    This section will focus on I/O operations, that is, input and output operations,
    on the physical disk. A great example of this type of operation is file handling.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在创建大部分与CPU和内存交互的程序。本节将重点放在I/O操作上，即物理磁盘上的输入和输出操作。这种操作的一个很好的例子是文件处理。
- en: 'C# has several classes that help you perform I/O operations. Some of these
    are as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: C#有几个类可帮助您执行I/O操作。其中一些如下：
- en: '`File`: This class provides methods for the manipulation of files, that is,
    reading, writing, creating, deleting, copying, and moving files on the disk.'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File`：此类提供了用于文件操作的方法，即在磁盘上读取，写入，创建，删除，复制和移动文件。'
- en: '`Directory`: Like the `File` class, this class includes methods to create,
    move, and enumerate directories and subdirectories on the disk.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directory`：与`File`类一样，此类包括用于在磁盘上创建，移动和枚举目录和子目录的方法。'
- en: '`Path`: This provides utilities to deal with absolute and relative paths of
    files and directories on the disk. A relative path is always related to some path
    inside the current directory where the application is being executed, and an absolute
    path refers to an absolute location inside the hard drive.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path`：这提供了处理文件和目录在磁盘上的绝对路径和相对路径的实用程序。相对路径始终与应用程序正在执行的当前目录内的某个路径相关联，而绝对路径是指硬盘内的绝对位置。'
- en: '`DriveInfo`: This provides information about a disk drive, such as `Name`,
    `DriveType`, `VolumeLabel`, and `DriveFormat`.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DriveInfo`：这提供有关磁盘驱动器的信息，例如`Name`，`DriveType`，`VolumeLabel`和`DriveFormat`。'
- en: 'You already know that files are mostly some sets of data located somewhere
    in a hard drive that can be opened for reading or writing by some program. When
    you open a file in a C# application, your program reads the file as a sequence
    of bytes through a communication channel. This communication channel is called
    a stream. Streams can be of two types:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道文件大多是位于硬盘某处的一些数据集，可以通过某个程序打开以进行读取或写入。当您在C#应用程序中打开文件时，您的程序通过通信通道将文件作为字节序列读取。这个通信通道称为流。流可以是两种类型：
- en: The input streams are used for reading operations.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入流用于读取操作。
- en: The output streams are used for writing operations.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出流用于写操作。
- en: 'The `Stream` class is an abstract class in C# that enables common operations
    regarding this byte flow. For file handling on a hard disk, you will use the `FileStream`
    class, designed specifically for this purpose. The following are two important
    properties of this class: `FileAccess` and `FileMode`.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类是C#中的一个抽象类，它使得关于这个字节流的常见操作成为可能。对于硬盘上的文件处理，您将使用`FileStream`类，专门设计用于此目的。这个类的两个重要属性是`FileAccess`和`FileMode`。'
- en: FileAccess
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FileAccess
- en: 'This is an `enum` that provides you with options to choose a level of access
    when opening a specified file:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`enum`，为您提供了在打开指定文件时选择访问级别的选项：
- en: '`Read`: This opens a file in read-only mode.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`：这以只读模式打开文件。'
- en: '`ReadWrite`: This opens a file in read and write mode.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWrite`：这以读写模式打开文件。'
- en: '`Write`: This opens a file in write-only mode. This is rarely used, as you
    usually do some reading along with the writing.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`：这以只写模式打开文件。这很少使用，因为通常您会在写入时进行一些读取。'
- en: FileMode
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FileMode
- en: 'This is an `enum` that specifies the operations that can be performed on a
    file. It should be used along with the access mode as some modes only work with
    some levels of access. Take a look at the options, as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`enum`，指定可以在文件上执行的操作。它应该与访问模式一起使用，因为某些模式只适用于某些访问级别。看一下选项，如下所示：
- en: '`Append`: Use this when you want to add content at the end of the file. If
    the file does not exist, a new one will be created. For this operation, the file
    must have write permission; otherwise, any attempt to read fails and throws a
    `NotSupportedException` exception. Exceptions are an important concept that will
    be covered later in this chapter.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Append`：当你想在文件末尾添加内容时使用。如果文件不存在，将创建一个新文件。对于这个操作，文件必须具有写入权限；否则，任何读取尝试都会失败并抛出`NotSupportedException`异常。异常是一个重要的概念，将在本章后面介绍。'
- en: '`Create`: Use this to create a new file or overwrite an existing one. For this
    option, too, write permission is required. In Windows, if the file exists but
    is hidden, an `UnauthorizedAccessException` exception is thrown.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Create`：用于创建新文件或覆盖现有文件。对于这个选项，也需要写入权限。在Windows中，如果文件存在但被隐藏，将抛出`UnauthorizedAccessException`异常。'
- en: '`CreateNew`: This is like `Create` but is used to create new files and also
    requires write permission. However, if the file already exists, an `IOException`
    exception is thrown.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateNew`：这类似于`Create`，但用于创建新文件，也需要写入权限。但是，如果文件已经存在，将抛出`IOException`异常。'
- en: '`Open`: As the name suggests, this mode is used to open a file. The file must
    have read or read and write permissions. If the file does not exist, a `FileNotFoundException`
    exception is thrown.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Open`：顾名思义，这种模式用于打开一个文件。文件必须具有读取或读取和写入权限。如果文件不存在，将抛出`FileNotFoundException`异常。'
- en: '`OpenOrCreate`: This is like `Open`, except it creates a new file if it does
    not already exist.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenOrCreate`：这类似于`Open`，除非文件不存在，否则会创建一个新文件。'
- en: 'Exercise 1.11: Reading Content from Text Files'
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.11：从文本文件中读取内容
- en: In this exercise, you will read text from a Comma-Separated Values (CSV) file.
    CSV files simply contain data represented by strings and separated either by colons
    or semicolons.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将从逗号分隔值（CSV）文件中读取文本。CSV文件简单地包含由字符串表示并由冒号或分号分隔的数据。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习，执行以下步骤：
- en: 'Open Command Prompt and type the following:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入以下内容：
- en: '[PRE102]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'At the `Exercise1_11` project folder location in your computer, create a file
    named `products.csv` and paste the following content inside it:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您计算机上的`Exercise1_11`项目文件夹位置，创建一个名为`products.csv`的文件，并将以下内容粘贴到其中：
- en: '[PRE103]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Open the `Program.cs` file and replace its contents with the following:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，并用以下内容替换它的内容：
- en: '[PRE104]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Call `dotnet run` in Command Prompt and you will get an output that is the same
    as the contents of the CSV file you have created.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中调用`dotnet run`，你将得到一个与你创建的CSV文件内容相同的输出。
- en: Note
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5flid](https://packt.link/5flid).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/5flid](https://packt.link/5flid)找到这个练习所使用的代码。
- en: This exercise has some pretty interesting outcomes, which you are going to learn
    step by step. First, you opened a file using the `FileStream` class. This allows
    you to start streaming bytes from a file with two special properties, namely,
    `FileMode` and `FileAccess`. It will return a `StreamReader` class. This class
    enables you to read these bytes as text characters.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习有一些非常有趣的结果，你将逐步学习。首先，你使用`FileStream`类打开了一个文件。这允许你从文件中流出字节，具有两个特殊属性，即`FileMode`和`FileAccess`。它将返回一个`StreamReader`类。这个类使你能够将这些字节读取为文本字符。
- en: Notice also that your `Main` method changed from `void` to `async` Task. Additionally,
    the `await` keyword has been used, which is used for asynchronous operations.
    You will learn more about these topics in upcoming chapters. For now, you only
    need to know that an async operation is something that does not block the program
    execution. This means that you can output lines as they are being read; that is,
    you do not have to wait for all of them to be read.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，你的`Main`方法从`void`变成了`async` Task。此外，使用了`await`关键字，用于异步操作。你将在接下来的章节中学到更多关于这些主题的知识。现在，你只需要知道异步操作是指不阻塞程序执行的操作。这意味着你可以在它们被读取时输出行；也就是说，你不必等待它们全部被读取。
- en: In the next section, learn about the special keyword that handles files, databases,
    and network connections.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，学习处理文件、数据库和网络连接的特殊关键字。
- en: Disposable Objects
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可释放对象
- en: Another special thing about the preceding exercise was the `using` keyword.
    It is a keyword used to clean up unmanaged resources from memory. These resources
    are special objects that handle some operational system resources, such as files,
    databases, and network connections. They are called **special** because they do
    what is called I/O operations; that is, they interact with the real resources
    of the machine, such as network and hard drives, not just with memory spaces.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 前面练习的另一个特殊之处是`using`关键字。它是一个用于清理内存中未管理资源的关键字。这些资源是处理一些操作系统资源的特殊对象，如文件、数据库和网络连接。它们被称为**特殊**，因为它们执行所谓的I/O操作；也就是说，它们与机器的真实资源进行交互，如网络和硬盘驱动器，而不仅仅是内存空间。
- en: The memory used by objects in C# is handled by something called the garbage
    collector. By default, C# handles the memory space in the stack and the heap. The
    only types of objects that do not perform this cleanup are called unmanaged objects.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: C#中对象使用的内存由一个叫做垃圾收集器的东西处理。默认情况下，C#处理堆栈和堆中的内存空间。唯一不执行此清理的对象类型被称为未管理对象。
- en: Cleaning these objects from memory means that the resources will be free to
    be used by another process in the computer. That means a file can be handled by
    another one, a database connection is free to be used again by a connection pool,
    and so on. Those types of resources are called disposable resources. Every time
    you deal with a disposable resource, you can use the `using` keyword when creating
    an object. Then, the compiler knows that when the `using` statement closes, it
    can automatically free these resources.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 清理这些对象从内存中意味着资源将被释放，以便被计算机中的另一个进程使用。这意味着一个文件可以被另一个文件处理，数据库连接可以再次被连接池使用，依此类推。这些类型的资源被称为可处置资源。每当你处理一个可处置资源时，你可以在创建对象时使用`using`关键字。然后，编译器知道当`using`语句关闭时，它可以自动释放这些资源。
- en: 'Exercise 1.12: Writing to a Text File'
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.12：写入文本文件
- en: In this exercise, you will write some text into a CSV file, again using the
    `FileStream` class.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将再次使用`FileStream`类将一些文本写入CSV文件中。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端，输入以下内容：
- en: '[PRE105]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: At a preferred location on your computer, copy the `products.csv` file from
    the previous exercise and paste it into this exercise's folder.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你电脑上的一个首选位置，从上一个练习中复制`products.csv`文件，并将其粘贴到这个练习的文件夹中。
- en: 'In `Program.cs`, create a method named `ReadFile` that will receive a `FileStream`
    file and iterate over the file lines to output the result to the console:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，创建一个名为`ReadFile`的方法，该方法将接收一个`FileStream`文件，并迭代文件行以将结果输出到控制台：
- en: '[PRE106]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, in your program, open the `products.csv` file with `StreamWriter` and
    add some more information to it, as follows:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的程序中，用`StreamWriter`打开`products.csv`文件，并添加一些更多的信息，如下所示：
- en: '[PRE107]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Finally, read the contents of the file after modification:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改文件后读取文件的内容：
- en: '[PRE108]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Call `dotnet run --project Exercise1_12` in the VS Code integrated terminal
    and you will be able to see the contents of the CSV file you just created, in
    addition to the line you just appended:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中调用`dotnet run --project Exercise1_12`，你将能够看到你刚刚创建的CSV文件的内容，以及你刚刚追加的行：
- en: '[PRE109]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note that for each run, the program will append a new line, so you will see
    more lines being added.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次运行，程序都会追加一行新的内容，所以你会看到添加了更多的行。
- en: Note
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/dUk2z](https://packt.link/dUk2z).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/dUk2z](https://packt.link/dUk2z)找到这个练习使用的代码。
- en: Sometimes your program will fail to execute at some point and may not provide
    an output. Such an instance is called an exception error. The next section details
    all about such an error.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的程序会在某个时候执行失败，并且可能不提供输出。这种情况被称为异常错误。下一节详细介绍了这种错误。
- en: Exceptions
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'Exceptions indicate that a program has failed to execute at some point for
    some reason and can be raised by either the code itself or the .NET runtime. Usually,
    an exception is a severe failure and can even terminate your program''s execution.
    Fortunately, C# provides a special way of handling exceptions, which is `try/catch` blocks:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 异常表示程序在某个时刻由于某种原因无法执行，并且可以由代码本身或.NET运行时引发。通常，异常是严重的失败，甚至可能终止程序的执行。幸运的是，C#提供了一种特殊的处理异常的方式，即`try/catch`块：
- en: '[PRE110]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Inside the `try` clause, you call the code that might throw an exception, and
    inside the `catch` clause, you can treat the exception that was raised. For instance,
    consider the following example:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`子句中，调用可能引发异常的代码，在`catch`子句中，你可以处理引发的异常。例如，考虑以下例子：
- en: '[PRE111]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This method takes two integers and returns the result of a division between
    them. However, what will happen if `b` is `0`? In such a case, the runtime will
    throw `System.DivideByZeroException`, indicating that it is not possible to execute
    the division. How could you handle this exception in a real-world program? You
    will explore this in the next exercise.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受两个整数，并返回它们之间的除法结果。然而，如果`b`是`0`会发生什么呢？在这种情况下，运行时会抛出`System.DivideByZeroException`，表示不可能执行除法。你如何在真实世界的程序中处理这个异常？你将在下一个练习中探讨这个问题。
- en: 'Exercise 1.13: Handling Invalid User Inputs with try/catch'
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.13：使用try/catch处理无效的用户输入
- en: In this exercise, you will create a console app that takes two inputs from you,
    divides the first number by the second one, and outputs the result. If you enter
    an invalid character, the app should throw an exception, and all of this should
    be handled inside the program logic.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个控制台应用程序，从你那里获取两个输入，将第一个数字除以第二个数字，并输出结果。如果你输入了一个无效的字符，应用程序应该抛出一个异常，并且所有这些都应该在程序逻辑内部处理。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: Inside the VS Code integrated terminal, create a new console app called `Exercise1_13`.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_13`的新控制台应用程序。
- en: 'Create the following method inside the `Program.cs` file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中创建以下方法：
- en: '[PRE112]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, create a Boolean variable to indicate whether the division was properly
    executed. Assign `false` to it as its initial value:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个布尔变量来指示除法是否被正确执行。将`false`赋给它作为初始值：
- en: '[PRE113]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Write a `while` loop that will check whether the division happened successfully.
    If it did, the program should terminate. If not, the program should prompt you
    to input valid data and perform the division again. Add the following code to
    do this:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`while`循环，检查除法是否成功进行。如果成功，程序应该终止。如果没有，程序应该提示你输入有效数据，并再次执行除法。添加以下代码来实现这一点：
- en: '[PRE114]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, execute the program using the `dotnet run` command and interact with
    the console. Try to insert strings instead of numbers and see what output you
    get. Look at the following output as an example:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`dotnet run`命令执行程序并与控制台交互。尝试插入字符串而不是数字，看看你得到什么输出。看下面的输出作为一个例子：
- en: '[PRE115]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EVsrJ](https://packt.link/EVsrJ).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/EVsrJ](https://packt.link/EVsrJ)找到这个练习使用的代码。
- en: 'In this exercise, you handled two types of exceptions that are as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你处理了两种异常，分别是：
- en: The `int.Parse(string str)` method throws `System.FormatException` if it is
    not possible to convert the `string` variable into an integer.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int.Parse(string str)`方法在无法将`string`变量转换为整数时抛出`System.FormatException`。'
- en: The `double Divide(int a, int b)` method throws `System.DivideByZeroException`
    if b is 0.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double Divide(int a, int b)`方法在b为0时抛出`System.DivideByZeroException`。'
- en: 'Now that you have seen how exceptions are handled, it is important to note
    a rule of thumb that will help you in your C# journey, which is that *you should
    only catch what you can or what you need to handle*. There are only a few situations
    where exception handling is really needed, as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了异常是如何处理的，重要的是要注意一个经验法则，这将帮助你在C#的旅程中，那就是*你应该只捕获你能够或者需要处理的异常*。只有在少数情况下真正需要异常处理，如下所示：
- en: When you want to **mask** an exception, that is, catch it and pretend that nothing
    happened. This is known as exception suppression. That should take place when
    the exception that is thrown does not impact the flow of your program.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要**掩盖**一个异常，也就是捕获它并假装什么都没发生。这被称为异常抑制。当抛出的异常不影响程序流程时，就应该发生这种情况。
- en: When you want to control your program's execution flow to perform some alternate
    actions, as you did in the preceding exercise
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要控制程序的执行流程以执行一些替代操作时，就像你在前面的练习中所做的那样。
- en: When you want to catch a type of exception to throw it as another type. For
    instance, when communicating with your web API, you might see an exception of
    type `HttpException` that indicates that the destination is unreachable. You could
    make use of a custom exception here, such as `IntegrationException`, to indicate
    more clearly that it happened in a part of your application that performs some
    integrations with external APIs.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要捕获一种异常并将其作为另一种类型抛出时。例如，当与你的Web API通信时，你可能会看到一个`HttpException`类型的异常，表示目标不可达。你可以在这里使用自定义异常，比如`IntegrationException`，以更清楚地指示它发生在你的应用程序的某个部分，该部分与外部API进行一些集成。
- en: 'The `throw` keyword can also be used to intentionally stop the program execution
    flow in certain cases. For example, consider that you are creating a `Person`
    object and that the `Name` property should not be `null` at the time of creation.
    You can enforce on this class a `System.ArgumentException` or `System.ArgumentNullException`,
    as in the following snippet, which uses `ArgumentNullException` to do so:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`关键字也可以用于有意地在某些情况下停止程序的执行流程。例如，假设你正在创建一个`Person`对象，并且`Name`属性在创建时不应为`null`。你可以在这个类上强制使用`System.ArgumentException`或`System.ArgumentNullException`，就像下面的代码片段中使用`ArgumentNullException`一样：'
- en: '[PRE116]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, if the value of the `name` argument is `null` or if you only enter space
    characters, `ArgumentNullException` is thrown, and the program does not execute
    successfully. The null/white space condition is checked with the help of the `IsNullOrWhiteSpace`
    function, which can be used for string variables.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`name`参数的值为`null`或者只输入空格字符，就会抛出`ArgumentNullException`，程序无法成功执行。空值/空格条件是通过`IsNullOrWhiteSpace`函数来检查的，该函数可以用于字符串变量。
- en: Now it's time to practice all that you learned in the previous sections through
    an activity.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过一个活动来练习你在之前章节学到的所有知识了。
- en: 'Activity 1.01: Creating a Guessing Game'
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：创建一个猜数字游戏
- en: To complete this activity, you need to create a guessing game using the concepts you
    have learned about and practiced so far in this chapter. In this game, first,
    a random number from one to 10 must be generated, not to be output to the console.
    The console should then prompt the user to input a number and then guess which
    random number has been generated, and the user should get a maximum of five chances.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，你需要使用你在本章中学到和练习过的概念来创建一个猜数字游戏。在这个游戏中，首先必须生成一个从1到10的随机数，不需要输出到控制台。然后控制台应提示用户输入一个数字，然后猜测生成的随机数是多少，用户最多有五次机会。
- en: Upon every incorrect input, a warning message should be displayed, letting the
    user know how many chances they have left, and if all five chances are exhausted
    with incorrect guesses, the program terminates. However, once the user guesses
    correctly, a success message should be displayed, before the program terminates.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次输入错误时，应显示一个警告消息，让用户知道他们还剩下多少次机会，如果所有五次机会都用于错误猜测，程序将终止。然而，一旦用户猜对了，程序将在终止之前显示一个成功消息。
- en: 'The following steps will help you complete this activity:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个活动：
- en: 'Create a variable called `numberToBeGuessed` that is assigned to a random number
    within C#. You can use the following snippet to do so:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`numberToBeGuessed`的变量，它被赋予C#中的一个随机数。你可以使用以下代码片段来实现：
- en: '[PRE117]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This generates a random number for you, between `0` and `10`. You could replace
    `10` with a higher number if you wanted to make the game a little more difficult,
    or with a smaller number to make it easier, but for this activity, you will use
    `10` as the maximum value.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为你生成一个在`0`和`10`之间的随机数。如果你想让游戏变得更难一些，你可以用一个更大的数字来替换`10`，或者用一个更小的数字来让它变得更容易，但是在这个活动中，你将使用`10`作为最大值。
- en: Create a variable called `remainingChances` that will store the remaining number
    of chances that the user has.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`remainingChances`的变量，用于存储用户剩余的机会数。
- en: Create a `numberFound` variable and assign a `false` value to it.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`numberFound`的变量，并将其赋值为`false`。
- en: Now, create a `while` loop that will execute while there are still some chances
    remaining. Within this loop, add code to output the number of chances remaining,
    until the correct guess is made. Then, create a variable called `number` that
    will receive the `number` variable is the correct guess, and assign the value
    `true` to the `numberFound` variable if so. If not, the number of remaining chances
    should be reduced by `1`.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`while`循环，当还有一些机会剩余时执行。在这个循环中，添加代码来输出剩余的机会次数，直到猜对为止。然后，创建一个名为`number`的变量，用于接收正确的猜测，并在`numberFound`变量中赋值`true`。如果没有猜对，剩余机会次数应减少1。
- en: Finally, add code to inform users whether they have guessed the number correctly.
    You can output something such as `Congrats! You've guessed the number with {remainingChanges}
    chances left!` if they guessed correctly. If they ran out of chances, output `You're
    out of chances. The number was {numberToBeGuessed}.`.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加代码来告知用户他们是否猜对了数字。如果他们猜对了，可以输出类似于`恭喜！你用{remainingChanges}次机会猜对了数字！`的内容。如果他们用完了机会，输出`你没有机会了。数字是{numberToBeGuessed}。`。
- en: Note
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: Summary
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter gave you an overview of the fundamentals of C# and what it looks
    like to write programs with it. You explored everything from the variable declaration,
    data types, and basic arithmetic and logical operators to file and exception handling.
    You also explored how C# allocates memory while dealing with value and reference
    types.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了C#的基础知识，以及使用它编写程序的样子。你探索了从变量声明、数据类型和基本算术和逻辑运算符到文件和异常处理的一切。你还探索了C#在处理值类型和引用类型时如何分配内存。
- en: In the exercises and activities in this chapter, you were able to solve some
    real-world problems and think of solutions that can be implemented with this language
    and its resources. You learned how to prompt for user inputs in console apps,
    how to handle files within a system, and finally, how to deal with unexpected
    inputs through exception handling.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习和活动中，你能够解决一些现实世界的问题，并想出可以用这种语言及其资源实现的解决方案。你学会了如何在控制台应用程序中提示用户输入，如何在系统中处理文件，最后，如何通过异常处理处理意外输入。
- en: The next chapter will cover the essentials of Object-oriented programming, diving
    deeper into the concept of classes and objects. You will also learn about the
    importance of writing clean, concise code that is easy to maintain, and the principles you
    can follow for writing such code.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖面向对象编程的基本知识，深入探讨类和对象的概念。你还将了解编写清晰、简洁、易于维护的代码的重要性，以及编写此类代码的原则。
