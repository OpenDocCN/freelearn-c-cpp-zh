- en: 8\. Need for Speed – Performance and Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 需要速度-性能和优化
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够：
- en: Time your code performance manually
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动计时代码性能
- en: Use source code instrumentation to measure code execution time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用源代码仪器来测量代码执行时间
- en: Use the perf tool to analyze program performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用perf工具分析程序性能
- en: Use the godbolt compiler explorer tool to analyze machine code generated by
    a compiler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用godbolt编译器资源管理器工具分析编译器生成的机器代码
- en: Use compiler flags to generate better code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编译器标志生成更好的代码
- en: Apply code idioms that result in performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用导致性能的代码习惯
- en: Write cache-friendly code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写缓存友好的代码
- en: Apply algorithm-level optimizations to real-world problems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将算法级优化应用于实际问题
- en: In this chapter, we will explore concepts that will allow us to write fast code
    in general and several practical techniques that apply to C++ in particular.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨允许我们在一般情况下编写快速代码以及适用于C++的几种实用技术的概念。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In today's world of extremely large and complicated software systems, `stability`
    and `maintainability` are usually considered the major goals for most software
    projects, whereas optimization has not been widely seen as a worthwhile goal since
    the 2000s. This is because of the rapid acceleration of hardware technology that
    overtook software demands on a regular schedule.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今极其庞大和复杂的软件系统中，`稳定性`和`可维护性`通常被认为是大多数软件项目的主要目标，而自2000年代以来，优化并未被广泛视为一个值得追求的目标。这是因为硬件技术的快速发展超过了软件对定期进步的需求。
- en: For many years, it seemed like the hardware improvements would continue to keep
    up with the performance demands of software, but applications continued to grow
    larger and more complex. Low-level native-compiled languages such as C and C++
    dropped in popularity compared to less performant but easier to use interpreted
    languages such as `Python` or `Ruby`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，硬件的改进似乎会继续跟上软件的性能需求，但应用程序继续变得更大更复杂。与C和C++等低级本地编译语言相比，易于使用但性能较差的解释语言（如`Python`或`Ruby`）的流行度下降。
- en: By the late 2000s, though, the trend of CPU transistor count (and performance)
    doubling every 18 months (a consequence of `Moore's Law`) had stopped, and performance
    improvements had flattened out. The expectation of 5 to 10 GHz processors being
    widely available by the 2010s never materialized due to limitations of physics
    and manufacturing costs. However, the rapid adoption of mobile devices and the
    rise of high-performance computing applications for data science and machine learning,
    suddenly resurrected the demand for fast and efficient code. Performance per watt
    has become the new metric to aim for as large data centers consume enormous amounts
    of power. For example, Google servers in the US used more power than the entire
    nation of the UK in 2017.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到了2000年代末，CPU晶体管数量（和性能）每18个月翻倍的趋势（`摩尔定律`的结果）停止了，性能改进趋于平稳。由于物理限制和制造成本的限制，人们对2010年代普遍可用的5到10
    GHz处理器的期望从未实现。然而，移动设备的快速采用和数据科学和机器学习的高性能计算应用的兴起，突然重新唤起了对快速和高效代码的需求。每瓦性能已成为新的衡量标准，因为大型数据中心消耗了大量电力。例如，2017年，谷歌在美国的服务器消耗的电力超过了整个英国国家的电力消耗。
- en: So far in this book, we've learned how the C++ language has evolved in terms
    of ease of use, without sacrificing any performance potential over a traditional
    language such as C. This means we can write fast code in C++ without necessarily
    sacrificing readability or stability. In the next section, we will learn about
    the concept of performance measurement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经了解了C++语言在易用性方面的发展，而不会牺牲传统语言（如C）的性能潜力。这意味着我们可以在C++中编写快速的代码，而不一定要牺牲可读性或稳定性。在下一节中，我们将学习性能测量的概念。
- en: Performance Measurement
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测量
- en: 'The most important aspect of optimization is the `measurement of code execution
    time`. Unless we measure our application''s performance with a wide range of input
    datasets, we will have no clue as to which part takes the most time and, our optimization
    efforts will be shot in the dark, with no guarantee of a result. There are several
    approaches for measurement, and some of them are listed here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 优化最重要的方面是`代码执行时间的测量`。除非我们使用各种输入数据集来测量应用程序的性能，否则我们将不知道哪一部分花费了最多的时间，我们的优化工作将是一场盲目的射击，没有任何结果的保证。有几种测量方法，其中一些列在这里：
- en: Runtime instrumentation or profiling
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时仪器或分析
- en: Source code instrumentation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码仪器
- en: Manual execution timing
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动执行计时
- en: Studying generated assembly code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究生成的汇编代码
- en: Manual estimation by studying the code and algorithms used
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过研究使用的代码和算法进行手动估计
- en: The preceding list is ordered in terms of how accurate the measurement is (with
    the most accurate one first). However, each of these methods has different advantages.
    The choice of which approach to adopt depends on the goals and scope of the optimization
    effort. In an all-out effort to get the fastest possible implementation, all of
    these may be required. We will examine each of these approaches in the following
    sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表按测量准确性排序（最准确的排在最前面）。然而，每种方法都有不同的优势。选择采用哪种方法取决于优化工作的目标和范围。在全力以赴地实现最快的可能实现的努力中，可能需要所有这些方法。我们将在以下各节中研究每种方法。
- en: Manual Estimation
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动估计
- en: 'The biggest possible improvement in performance occurs when we replace an algorithm
    with a superior one. For example, consider the two versions of a trivial function
    that sums the integers from `1` to `n`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用更好的算法替换算法时，性能的最大可能改进发生。例如，考虑一个简单函数的两个版本，该函数对从`1`到`n`的整数求和：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first function, `sum1`, uses a simple loop to calculate the sum and has
    a runtime complexity that is proportional to `n`, whereas the second function,
    `sum2`, uses the algebraic summation formula and takes constant time independent
    of `n`. In this quite contrived example, we have optimized a function simply by
    using the basic knowledge of algebra.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`sum1`使用简单的循环来计算总和，并且其运行时复杂度与`n`成正比，而第二个函数`sum2`使用代数求和公式，独立于`n`花费恒定的时间。在这个相当牵强的例子中，我们通过使用代数的基本知识来优化了一个函数。
- en: There are many well-known algorithms for every conceivable operation that have
    been proven to be the most optimal. The best way to make our code run as fast
    as possible is by using algorithms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个可想象的操作，都有许多众所周知的算法被证明是最优的。使我们的代码尽可能快地运行的最佳方法是使用算法。
- en: It is essential to have a vocabulary of algorithms. We do not need to be an
    algorithm expert, but we need to at least be aware of the existence of efficient
    algorithms in various domains, even if we are not capable of implementing them
    from scratch. A slightly deeper knowledge of algorithms will help us find parts
    of our program that perform similar, if not exactly the same, computations as
    well-known algorithms. Certain code features such as nested loops or linear scanning
    of data are often obvious candidates for improvement, provided we can verify that
    these constructs are within hotspots in the code. A **hotspot** is a section of
    code that runs very often and affects performance significantly. The C++ standard
    library includes a lot of basic algorithms that can be used as building blocks
    to improve the efficiency of many common operations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有算法词汇是至关重要的。我们不需要成为算法专家，但至少需要意识到各个领域存在高效算法的存在，即使我们无法从头开始实现它们。对算法的略微深入了解将有助于我们找到程序中执行类似的，即使不完全相同的计算的部分。某些代码特性，如嵌套循环或数据的线性扫描，通常是改进的明显候选，前提是我们可以验证这些结构是否在代码的热点内。**热点**是指运行非常频繁且显著影响性能的代码部分。C++标准库包含许多基本算法，可以用作改进许多常见操作的构建块。
- en: Studying Generated Assembly Code
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 研究生成的汇编代码
- en: '**Assembly language** is a human readable representiation of the binary machine
    code that actually executes on the processor. For any serious programmer of a
    compiled language such as C++, a basic understanding of assembly language is a
    great asset.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编语言**是二进制机器代码的人类可读表示，实际上在处理器上执行。对于像C++这样的编译语言的严肃程序员来说，对汇编语言的基本理解是一项重要的资产。'
- en: Studying the generated assembly code for a program can give us some good insights
    into how the compiler works and estimates of code efficiency. There are many cases
    where this is the only approach possible to determine efficiency bottlenecks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 研究程序生成的汇编代码可以让我们对编译器的工作方式和代码效率的估计有一些很好的见解。有许多情况下，这是确定效率瓶颈的唯一可能途径。
- en: Apart from this, a basic knowledge of assembly language is essential to be able
    to debug C++ code since some of the most difficult bugs to catch are those related
    to the low-level generated code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，对汇编语言的基本了解对于能够调试C++代码是至关重要的，因为一些最难以捕捉的错误与低级生成的代码有关。
- en: A very powerful and popular online tool that's used for analyzing compiler-generated
    code is the **Compiler Explorer** that we will be using in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分析编译器生成代码的一个非常强大和流行的在线工具是我们在本章中将要使用的**编译器探索者**。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The `Godbolt compiler explorer` can be found at [https://godbolt.org](https://godbolt.org).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Godbolt编译器探索者`可以在[https://godbolt.org](https://godbolt.org)找到。'
- en: 'The following is a screenshot of the Godbolt compiler explorer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Godbolt编译器探索者的屏幕截图：
- en: '![](img/C14583_08_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_08_01.jpg)'
- en: 'Figure 8.1: Godbolt compiler explorer'
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：Godbolt编译器探索者
- en: As you can see, the Godbolt compiler explorer consists of two panes. The one
    on the left is where we type the code in, while the one on the right displays
    the generated assembly code. The left-hand pane has a dropdown so that we can
    choose the desired language. For our purposes, we will use the C++ language with
    the gcc compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Godbolt编译器探索者由两个窗格组成。左侧是我们输入代码的地方，右侧显示生成的汇编代码。左侧窗格有一个下拉菜单，这样我们就可以选择所需的语言。为了我们的目的，我们将使用带有gcc编译器的C++语言。
- en: The right-hand pane has options that we can use to choose a compiler version.
    Almost all the versions of popular compilers such as `gcc`, `clang`, and `cl`
    (`Microsoft C++`) are present, including the ones for non-X86 architectures such
    as ARM.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧窗格有选项，我们可以使用它来选择编译器版本。几乎所有流行编译器的版本，如`gcc`、`clang`和`cl`（`Microsoft C++`）都有，包括非X86架构的版本，如ARM。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We will refer to the Intel processor architecture as `x86` for simplicity, even
    though the correct definition is `x86/64`. We will skip mentioning the "`64`"
    since almost all processors being manufactured today are `64-bit`. Even though
    `x86` was invented by Intel, now all PC processor manufacturers are licensed to
    use it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将把英特尔处理器架构称为`x86`，尽管正确的定义是`x86/64`。我们将跳过"`64`"，因为今天几乎所有的处理器都是`64位`的。尽管`x86`是由英特尔发明的，但现在所有的个人电脑处理器制造商都有使用许可。
- en: 'In order to get familiar with the basics of the `Compiler Explorer tool` and
    understand the `x86` assembly code at a basic level, let''s examine the assembly
    code generated by a compiler for a simple function that sums up the integers from
    `1` to `N`. Here is the sum function that needs to be written in the left-hand
    pane of the Compiler Explorer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉`编译器探索者工具`的基础知识，并在基本水平上理解`x86`汇编代码，让我们来检查编译器为一个简单的从`1`加到`N`的整数求和函数生成的汇编代码。下面是需要在编译器探索者的左侧窗格中编写的求和函数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the right-hand pane, the compiler must be set to **x86-64 gcc 8.3**, like
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧窗格中，编译器必须设置为**x86-64 gcc 8.3**，就像这样：
- en: '![Figure 8.2: C++ compiler'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：C++编译器'
- en: '](img/C14583_08_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_02.jpg)'
- en: 'Figure 8.2: C++ compiler'
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2：C++编译器
- en: 'Once this is done, the left-hand pane''s code is automatically recompiled and
    the assembly code is generated and displayed on the right-hand pane. Here, the
    output is color-coded to show which lines of assembly code is generated from which
    lines of C++ code. The following screenshot shows the assembly code that was generated:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，左侧窗格的代码将自动重新编译，并在右侧窗格生成和显示汇编代码。这里，输出以颜色编码显示，以显示汇编代码的哪些行是从C++代码的哪些行生成的。以下屏幕截图显示了生成的汇编代码：
- en: '![Figure 8.3: Assembly result'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：汇编结果'
- en: '](img/C14583_08_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_03.jpg)'
- en: 'Figure 8.3: Assembly result'
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：汇编结果
- en: 'Let''s analyze the preceding assembly code briefly. Each instruction in the
    assembly language consists of an **opcode** and one or more **operands**, which
    can be registers, constant values, or memory addresses. A **register** is a very
    fast storage location in the CPU. In the x86 architecture, there are eight main
    registers, namely **RAX**, **RBX**, **RCX**, **RDX**, **RSI**, **RDI**, **RSP**,
    and **RBP**. The Intel x86/x64 architecture uses a curious pattern of register
    naming:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要分析前面的汇编代码。汇编语言中的每条指令由一个**操作码**和一个或多个**操作数**组成，可以是寄存器、常量值或内存地址。**寄存器**是CPU中非常快速的存储位置。在x86架构中，有八个主要寄存器，即**RAX**，**RBX**，**RCX**，**RDX**，**RSI**，**RDI**，**RSP**和**RBP**。英特尔x86/x64架构使用一种奇特的寄存器命名模式：
- en: '**RAX** is a general-purpose 64-bit integer register.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAX**是一个通用的64位整数寄存器。'
- en: '`RAX`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RAX`。'
- en: '`EAX`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EAX`。'
- en: '`AX`, respectively.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AX`。'
- en: 'The same convention applies to other general-purpose registers such as `RBX`,
    `RCX`, and `RDX`. The `RSI`, `RDI`, and `RBP` registers have 16-bit and 32-bit
    versions but not the 8-bit sub-registers. The opcode of an instruction can be
    of several types including arithmetic, logical, bitwise, comparison or jump operations.
    It is common to refer to an opcode as an instruction. For example, "`opcode` is
    `sum` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的约定适用于其他通用寄存器，如`RBX`，`RCX`和`RDX`。`RSI`，`RDI`和`RBP`寄存器有16位和32位版本，但没有8位子寄存器。指令的操作码可以是多种类型，包括算术、逻辑、位运算、比较或跳转操作。通常将操作码称为指令。例如，“`opcode`是`sum`函数：
- en: '![Figure 8.4: Assembly code of the sum function'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：sum函数的汇编代码'
- en: '](img/C14583_08_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_04.jpg)'
- en: 'Figure 8.4: Assembly code of the sum function'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：sum函数的汇编代码
- en: In the preceding screenshot, the first few lines are called a `MOV RAX, RBX`
    assembly code means move the value in the `RBX` register to the `RAX` register.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，前几行称为`MOV RAX, RBX`汇编代码意味着将`RBX`寄存器中的值移动到`RAX`寄存器中。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Assembly language is usually not case-sensitive, so `EAX` and `eax` mean the
    same thing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言通常不区分大小写，因此`EAX`和`eax`意思相同。
- en: The `(*(DWORD*)(rbp - 8))` C expression. In other words, the memory address
    `4` byte `DWORD` (a double word of memory – 32 bits). The square brackets in assembly
    code represent dereferencing, much like the * operator in C/C++. The `rbp` register
    is the base pointer that always contains the address of the base of the currently
    executing functions stack. It is not essential to know how exactly this stack
    frame works but remember that since the stack starts at a higher address and moves
    down, function arguments and local variables have addresses as negative offsets
    from `rbp`. If you see some negative offset from `rbp`, it refers to a local variable
    or argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*(DWORD*)(rbp - 8))` C表达式。换句话说，内存地址`4`字节`DWORD`（内存的双字-32位）。汇编代码中的方括号表示解引用，就像C/C++中的*运算符一样。`rbp`寄存器是始终包含当前执行函数堆栈基址的地址的基址指针。不需要知道这个堆栈帧的工作原理，但请记住，由于堆栈从较高地址开始并向下移动，函数参数和局部变量的地址是从`rbp`的负偏移开始的。如果看到从`rbp`的负偏移，它指的是局部变量或参数。'
- en: In the preceding screenshot, the first `n` argument that was passed in. The
    last two `ret` variable and the `i` loop variable in our code to `0` and `1`,
    respectively.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，传递的第一个`n`参数。我们的代码中最后两个`ret`变量和`i`循环变量分别设置为`0`和`1`。
- en: 'Now, examine the snapshot of the assembly code that follows the prologue and
    initialization – this is our `for()` loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查跟随序言和初始化的汇编代码的快照-这是我们的`for()`循环：
- en: '![Figure 8.5: Assembly code of the for loop'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：for循环的汇编代码'
- en: '](img/C14583_08_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_05.jpg)'
- en: 'Figure 8.5: Assembly code of the for loop'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：for循环的汇编代码
- en: In the preceding screenshot, the lines that have a string followed by a colon
    are called `BASIC`, `C/C++`, or `Pascal` and are used as targets of `goto` statements).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，具有字符串后跟冒号的行称为`BASIC`，`C/C++`或`Pascal`，并且用作`goto`语句的目标)。
- en: Instructions starting with J on x86 assembly are all jump instructions, such
    as `i` variable from memory to the `n` value in memory with the **cmp** instruction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以J开头的x86汇编指令都是跳转指令，例如使用**cmp**指令将内存中的`i`变量与内存中的`n`值进行比较。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The **JG** instruction here means **jump if greater**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的**JG**指令意味着**如果大于则跳转**。
- en: 'If the comparison was greater, then the execution jumps to the **.L2** label
    (which is outside the loop). If not, the execution continues with the next instruction,
    like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果比较大，则执行跳转到**.L2**标签（在循环外）。如果不是，则执行继续下一条指令，如下所示：
- en: '![Figure 8.6: Assembly code of the next instruction'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6：下一条指令的汇编代码'
- en: '](img/C14583_08_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_06.jpg)'
- en: 'Figure 8.6: Assembly code of the next instruction'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：下一条指令的汇编代码
- en: 'Here, the value of `i` is reloaded again into `ret`, after which `1` is added
    to `i`. Finally, the execution jumps back to the`for` loop and sums up the sequence
    of integers up to `n`, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i`的值再次重新加载到`ret`中，然后`1`被加到`i`上。最后，执行跳回到`for`循环并求和整数序列直到`n`，如下所示：
- en: '![Figure 8.7: Assembly code of the for loop'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：for循环的汇编代码'
- en: '](img/C14583_08_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_07.jpg)'
- en: 'Figure 8.7: Assembly code of the for loop'
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：for循环的汇编代码
- en: This is called the `ret`, is moved into the `ret` returns from the `sum()` function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为`ret`，被移动到`ret`从`sum()`函数返回。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The "ret" in the above assembly listing is the mnemonic for the RETURN instruction
    and should not be confused with the "ret" variable in our C++ code example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上面汇编清单中的“ret”是RETURN指令的助记符，不应与我们C++代码示例中的“ret”变量混淆。
- en: 'It is not a simple job to figure out what a sequence of assembly instructions
    does, but a general idea of the mapping between the source code and instructions
    can be gained by observing the following points:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 弄清楚一系列汇编指令的作用并不是一件简单的工作，但是通过观察以下几点，可以对源代码和指令之间的映射有一个大致的了解：
- en: Constant values in code can be directly recognized in the assembly.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的常量值可以直接在汇编中识别。
- en: Arithmetic operations such as `add`, `sub`, `imul`, `idiv`, and many others
    can be recognized.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如`add`、`sub`、`imul`、`idiv`等算术运算可以被识别。
- en: Conditional jumps map to loops and conditionals.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件跳转映射到循环和条件。
- en: Function calls can be directly read (the function name appears in the assembly
    code).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用可以直接读取（函数名出现在汇编代码中）。
- en: 'Now, let''s observe the effect of the code if we add a compiler flag for optimization
    in the compiler options field at the top-right:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们观察一下，如果在顶部的编译器选项字段中为编译器添加优化标志，代码的效果会如何：
- en: '![Figure 8.8: Adding a compiler flag for optimization'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：为优化添加编译器标志'
- en: '](img/C14583_08_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_08.jpg)'
- en: 'Figure 8.8: Adding a compiler flag for optimization'
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：为优化添加编译器标志
- en: In the preceding screenshot, `0` in `0` from memory into the register. Since
    memory takes several clock cycles to access (anywhere from `5` to `100` clock
    cycles), using registers alone will itself produce a massive speedup.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，`0`从内存中加载到寄存器中。由于内存访问需要几个时钟周期（从`5`到`100`个时钟周期不等），仅使用寄存器本身就会产生巨大的加速。
- en: 'When the compiler in the dropdown is changed to **x86-64 clang 8.0.0**, the
    assembly code is changed, which can be seen in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当下拉菜单中的编译器更改为**x86-64 clang 8.0.0**时，汇编代码会发生变化，可以在以下截图中看到：
- en: '![Figure 8.9: Assembly code with the new compiler'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：带有新编译器的汇编代码'
- en: '](img/C14583_08_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_09.jpg)'
- en: 'Figure 8.9: Assembly code with the new compiler'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：带有新编译器的汇编代码
- en: 'In the preceding assembly listing, observe that there is no instruction starting
    with `J` (for jump). Thus, there is no looping construct at all! Let''s examine
    how the compiler is calculating the sum of `1` to `n`. If the value of `n` is
    `<= 0`, then it jumps to the`0`. Let''s analyze the following instructions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的汇编清单中，注意到没有以`J`（跳转）开头的指令。因此，根本没有循环结构！让我们来看看编译器是如何计算`1`到`n`的和的。如果`n`的值`<=
    0`，那么它跳转到`0`。让我们分析以下指令：
- en: '![Figure 8.10: Assembly code with the new compiler'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：带有新编译器的汇编代码'
- en: '](img/C14583_08_10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_10.jpg)'
- en: 'Figure 8.10: Assembly code with the new compiler'
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：带有新编译器的汇编代码
- en: 'The following code is the C equivalent of the previous instructions. Remember
    that `n` is in the `EDI` register (and hence also in the RDI register, since they
    overlap):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是前面指令的C等效代码。请记住，`n`在`EDI`寄存器中（因此也在RDI寄存器中，因为它们重叠）：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, if we were to write it in one line, it would look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们将其写成一行，它会是这样的：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we simplify this expression, we get the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简化这个表达式，我们得到以下结果：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, we can write it in the following format:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以用以下格式来写：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can be simplified to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下形式：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, we can write the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写成以下形式：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the closed form equation for the summation of numbers `1` to `n` inclusive,
    and the fastest way to compute it. The compiler was extremely clever—rather than
    just looking at our code line by line, it reasoned that the effect of our loop
    was to calculate the sum, and it figured out the algebra on its own. It did not
    figure out the simplest possible expression, but an equivalent one that took a
    few extra operations. Nevertheless, taking out the loop makes this function very
    much optimal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是求和公式的封闭形式，用于计算`1`到`n`的数，也是计算它的最快方式。编译器非常聪明——它不仅仅是逐行查看我们的代码，而是推理出我们的循环的效果是计算总和，并且自己找出了代数。它没有找出最简单的表达式，而是找出了一个等价的表达式，需要一些额外的操作。尽管如此，去掉循环使得这个函数非常优化。
- en: If we modify the initial or final values of the `i` variable in the `for` loop
    to create a different summation, the compiler is still able to perform the necessary
    algebraic manipulation to derive a closed form solution needing no loops.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改`for`循环中`i`变量的初始或最终值以创建不同的求和，编译器仍然能够执行必要的代数操作，得出不需要循环的封闭形式解决方案。
- en: This is just one example of how compilers have become extremely efficient and
    appear almost intelligent. However, we must understand that this particular optimization
    of summations has been specifically programmed into the `clang` compiler. It does
    not mean that the compiler can do this kind of trick for any possible loop computation
    — that would actually require the compiler to have general artificial intelligence,
    as well as all the mathematical knowledge in the world.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是编译器变得非常高效并且几乎智能化的一个例子。然而，我们必须明白，这种求和的特定优化已经被编程到了`clang`编译器中。这并不意味着编译器可以为任何可能的循环计算做出这种技巧——这实际上需要编译器具有通用人工智能，以及世界上所有的数学知识。
- en: 'Let''s explore another example of compiler optimization via generated assembly
    code. Look at the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过生成的汇编代码来探索编译器优化的另一个例子。看看以下代码：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the compiler options, if we select the **x86-64 clang 8.0.0** compiler and
    add **-O3 -stdlib=libc++**, the following assembly code is generated:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器选项中，如果我们选择**x86-64 clang 8.0.0**编译器并添加**-O3 -stdlib=libc++**，将生成以下汇编代码：
- en: '![Figure 8.11: Assembly code generated with the new compiler'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：使用新编译器生成的汇编代码'
- en: '](img/C14583_08_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_11.jpg)'
- en: 'Figure 8.11: Assembly code generated with the new compiler'
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：使用新编译器生成的汇编代码
- en: 'As you can see in the preceding screenshot, the compiler decided correctly
    that the vector was not relevant to the function and removed all the baggage.
    It also did the addition at compile time and directly used the result, `3`, as
    a constant. The main things to take forward from this section are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所看到的，编译器正确地决定向量与函数无关，并移除了所有的负担。它还在编译时进行了加法运算，并直接使用结果`3`作为常数。从本节中可以得出的主要观点如下：
- en: Compilers can be extremely clever when optimizing code, given the right options.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给予正确选项的情况下，编译器在优化代码时可以非常聪明。
- en: Studying generated assembly code is very useful to get a high-level estimate
    of execution complexity.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究生成的汇编代码对于获得执行复杂性的高级估计非常有用。
- en: A basic understanding of how machine code works is valuable for any C++ programmer.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对机器码工作原理的基本理解对于任何C++程序员都是有价值的。 '
- en: In the next section, we'll learn about manual execution timing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于手动执行计时的内容。
- en: Manual Execution Timing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动执行计时
- en: 'This is the easiest way to quickly time small programs. We can use a command-line
    tool to measure the time taken for a program to execute. On Windows 7 and above,
    the following PowerShell command can be used:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是快速计时小程序的最简单方法。我们可以使用命令行工具来测量程序执行所需的时间。在Windows 7及以上版本中，可以使用以下PowerShell命令：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On `Linux`, `MacOS`, and other `UNIX-like` systems, the `time` command can
    be used:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Linux`、`MacOS`和其他类`UNIX`系统上，可以使用`time`命令：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next section, we'll implement a small program and examine some caveats
    about timing a program's execution in general.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个小程序，并检查一般情况下计时程序执行的一些注意事项。
- en: 'Exercise 1: Timing a Program''s Execution'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：计时程序的执行
- en: In this exercise, we will write a program that performs a summation of an array.
    The idea here is to time the summation function. This method is useful when we
    wish to test a function written in isolation. Thus, the test program's only purpose
    is to execute one single function. Since the calculation is very simple, we will
    need to run the function thousands of times in order to get a measurable execution
    time. In this case, we'll just call the `sumVector()` function from the `main()`
    function, passing an `std::vector` of random integers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个程序来对数组进行求和。这里的想法是计时求和函数。当我们希望测试一个独立编写的函数时，这种方法是有用的。因此，测试程序的唯一目的是执行一个单一的函数。由于计算非常简单，我们需要运行函数数千次才能获得可测量的执行时间。在这种情况下，我们将从`main()`函数中调用`sumVector()`函数，传递一个随机整数的`std::vector`。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A program that's meant to test a single function is sometimes referred to as
    a **driver program** (not to be confused with a device driver).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一个旨在测试单个函数的程序有时被称为**驱动程序**（不要与设备驱动程序混淆）。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Create a file named **Snippet1.cpp**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet1.cpp**的文件。
- en: 'Define a function named `sumVector` that sums up each element in a loop:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`sumVector`的函数，它在循环中对每个元素求和：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the `main` function. Use the C++11 random number generation facilities
    to initialize a vector of `10,000` elements and then call the `sumVector` function
    `1,000` times. Write the following code to implement this:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数。使用C++11的随机数生成工具初始化一个包含`10,000`个元素的向量，然后调用`sumVector`函数`1,000`次。编写以下代码来实现这一点：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Compile, run, and time this program on a Linux Terminal using the following
    commands:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在Linux终端上编译、运行和计时此程序：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the previous command is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令的输出如下：
- en: '![Figure 8.12: Output of timing the Snippet1.cpp code'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：对Snippet1.cpp代码进行计时的输出'
- en: '](img/C14583_08_12.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_12.jpg)'
- en: 'Figure 8.12: Output of timing the Snippet1.cpp code'
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：对Snippet1.cpp代码进行计时的输出
- en: As you can see from the preceding output, for this system, the program executed
    in `0.122` seconds (note that the results will vary, depending on your system's
    configuration). If we run this timing command repeatedly, we may get slight variations
    in the results as the program will be loaded in the memory after the first run
    and will be marginally faster. It is best to run and time the program about `5`
    times and get an average value. We are usually not interested in the absolute
    value of the time taken, but rather how the value improves as we optimize our
    code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，对于这个系统，程序在`0.122`秒内执行（请注意，结果会根据您系统的配置而有所不同）。如果我们反复运行此计时命令，可能会得到结果略有不同，因为程序在第一次运行后将加载到内存中，并且速度会略有提高。最好运行并计时程序约`5`次，并获得平均值。我们通常对所花费的时间的绝对值不感兴趣，而是对我们优化代码后数值的改善感兴趣。
- en: 'Use the following commands to explore the effect of using compiler optimization
    flags:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令来探索使用编译器优化标志的效果：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.13: Output of timing the Snippet1.cpp code compiled with -O3'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13：使用-O3编译的Snippet1.cpp代码的计时输出'
- en: '](img/C14583_08_13.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_13.jpg)'
- en: 'Figure 8.13: Output of timing the Snippet1.cpp code compiled with -O3'
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：使用-O3编译的Snippet1.cpp代码的计时输出
- en: From the preceding output, it seems that the program has become about `60` times
    faster, which seems quite unbelievable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，似乎程序变快了约`60`倍，这似乎令人难以置信。
- en: 'Change the code to execute the loop `100,000` times rather than `1,000` times:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码更改为执行循环`100,000`次而不是`1,000`次：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Recompile and time again using the following commands:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译并使用以下命令再次计时：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output after executing previous command is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上一个命令后的输出如下：
- en: '![Figure 8.14: Output of timing the Snippet1.cpp code with 10,000 iterations'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：对Snippet1.cpp代码进行计时，迭代次数为10,000'
- en: '](img/C14583_08_14.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_14.jpg)'
- en: 'Figure 8.14: Output of timing the Snippet1.cpp code with 10,000 iterations'
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：对Snippet1.cpp代码进行计时，迭代次数为10,000
- en: From the preceding output, it still seems to take the exact same time. This
    seems impossibe, but actually what happens is that since we never caused any side
    effect in our program, such as printing the sum, the compiler is free to replace
    our code with an empty program. Functionally, according to the C++ standard, this
    program and an empty program are identical because there are no side effects of
    running it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，似乎仍然需要相同的时间。这似乎是不可能的，但实际上发生的是，由于我们从未在程序中引起任何副作用，比如打印总和，编译器可以自由地用空程序替换我们的代码。从功能上讲，根据C++标准，这个程序和一个空程序是相同的，因为它们都没有运行的副作用。
- en: 'Open the Compiler Explorer and paste in the entire code. Set the compiler options
    to `-O3` and observe the generated code:![Figure 8.15: Snippet1.cpp code in Compiler
    Explorer'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编译器资源管理器，粘贴整个代码。将编译器选项设置为`-O3`，并观察生成的代码：![图8.15：在编译器资源管理器中的Snippet1.cpp代码
- en: '](img/C14583_08_15.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_15.jpg)'
- en: 'Figure 8.15: Snippet1.cpp code in Compiler Explorer'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：在编译器资源管理器中的Snippet1.cpp代码
- en: As you can see from the preceding screenshot, the lines within the `for` loop
    are not color-coded and no assembly code was generated for them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看到，在`for`循环内部的行没有颜色编码，并且没有为它们生成任何汇编代码。
- en: 'Change the code to make sure that the sum must be performed by printing a value
    that depends on the computation with the following line:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码以确保求和必须通过打印依赖于计算的值来执行以下行：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are just summing the result of `sumVector()` to a dummy double value
    many time and printing it. After you make the changes in the code, open the Terminal
    and write the following commands:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只是将`sumVector()`的结果加到一个虚拟的双精度值中，并打印它。在更改代码后，打开终端并输入以下命令：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the previous commands is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出如下：
- en: '![Figure 8.16: Output of timing the Snippet1.cpp code with a side effect of
    printing the value'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：使用打印值的副作用计时Snippet1.cpp代码的输出'
- en: '](img/C14583_08_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_16.jpg)'
- en: 'Figure 8.16: Output of timing the Snippet1.cpp code with a side effect of printing
    the value'
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：使用打印值的副作用计时Snippet1.cpp代码的输出
- en: In the preceding output, we can see that the program actually performed the
    computation instead of just running as an empty program. Printing the total to
    `cout` is a side effect that causes the compiler not to elide the code. Causing
    a side effect (such as printing a result) that depends on the code's execution
    is one way to prevent the compiler optimizer from removing code. In the next section,
    we'll learn how to time programs without side effects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到程序实际上执行了计算，而不仅仅是作为一个空程序运行。将总数打印到`cout`是一个副作用，会导致编译器不会删除代码。引起副作用（比如打印结果）取决于代码的执行是防止编译器优化器删除代码的一种方法。在接下来的部分，我们将学习如何在没有副作用的情况下计时程序。
- en: Timing Programs without Side Effects
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在没有副作用的情况下计时程序
- en: 'As seen in the previous exercise, we needed to create a side effect (using
    `cout`) in our program so that the compiler did not ignore all the code we wrote.
    Another technique to make the compiler believe that a piece of code has a side
    effect is to assign its result to a **volatile** variable. The volatile qualifier
    tells the compiler: "This variable must always be read from memory and written
    to memory, and not from a register." The main purpose of a volatile variable is
    to access device memory, and such device memory access must follow the rule mentioned
    above. Effectively, volatile variables are considered by the compiler as if they
    could change from effects outside of the current program, and thus will never
    be optimized. We will use this technique in the upcoming sections.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的练习所示，我们需要在程序中创建一个副作用（使用`cout`）以便编译器不会忽略我们编写的所有代码。让编译器相信一段代码具有副作用的另一种技术是将其结果赋给一个**volatile**变量。volatile限定符告诉编译器：“这个变量必须始终从内存中读取并写入内存，而不是从寄存器中读取。”volatile变量的主要目的是访问设备内存，并且这种设备内存访问必须遵循上述规则。实际上，编译器将volatile变量视为可能受当前程序之外的影响而发生变化，因此永远不会被优化。我们将在接下来的部分中使用这种技术。
- en: There are more advanced ways to bypass this problem, that is, by specifying
    special assembly code directives to the compiler rather than using side effects.
    But they are outside the scope of this introductory material. For the examples
    that follow, we'll always add code that ensures that a function's result is used
    in a side effect or is assigned to a volatile variable. In future sections, we'll
    learn how to examine the compiler generated assembly code and detect instances
    when the compiler elides code for optimization purposes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有更高级的方法来规避这个问题，即通过向编译器指定特殊的汇编代码指令，而不是使用副作用。但它们超出了这个入门材料的范围。在接下来的示例中，我们将始终添加代码，以确保函数的结果在副作用中被使用，或者被赋给一个volatile变量。在以后的部分中，我们将学习如何检查编译器生成的汇编代码，并检测编译器为了优化目的而省略代码的情况。
- en: Source Code Instrumentation
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码插装
- en: '**Instrumentation** is a term that refers to the process of adding extra code
    to a program, without changing its behavior, and capturing the information as
    it executes. This may include performance timing (and possibly other measurements
    such as memory allocation, or disk usage patterns). In the case of source code
    instrumentation, we manually add code to time the execution of our program and
    log that data when the program ends, for analysis. The advantage of this approach
    is its portability and avoidance of any external tools. It also allows us to selectively
    add the timing to any part of the code we choose.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**插装**是一个术语，指的是在不改变程序行为的情况下向程序添加额外的代码，并在执行时捕获信息。这可能包括性能计时（可能还包括其他测量，如内存分配或磁盘使用模式）。在源代码插装的情况下，我们手动添加代码来计时程序的执行，并在程序结束时记录这些数据以进行分析。这种方法的优点是它的可移植性和避免使用任何外部工具。它还允许我们有选择地将计时添加到我们选择的代码的任何部分。'
- en: 'Exercise 2: Writing a Code Timer Class'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：编写一个代码计时器类
- en: 'In this exercise, we''ll create an `RAII` class that allows us to measure the
    execution time of individual blocks of code. We will use this as the primary timing
    mechanism for the code in the exercises that follow. It is not as sophisticated
    as other methods of performance measurement but is much easier to use and serves
    most purposes. The basic requirement of our class is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个`RAII`类，允许我们测量单个代码块的执行时间。我们将把这个作为后续练习中代码的主要计时机制。它不像其他性能测量方法那样复杂，但使用起来更加简单，并且可以满足大多数需求。我们类的基本要求如下：
- en: We need to be able to record the cumulative time taken by a block of code.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够记录代码块所花费的累积时间。
- en: We need to be able to record the number of times it is invoked.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够记录调用的次数。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: Create a file named **Snippet2.cpp**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet2.cpp**的文件。
- en: 'Include the following headers:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括以下头文件：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define the `Timer` class and the class member functions by writing the following
    code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码来定义`Timer`类和类成员函数：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see from the preceding code, the class members consist of a name,
    a starting timestamp, and two `static maps`. Every instance of this class is meant
    to time a certain block of code. The block can be a function scope or any other
    block delimited by curly braces. The usage pattern is to define an instance of
    the `Timer` class at the top of the block while passing in a name (can be a function
    name or some other convenient label). When instantiated, the current timestamp
    is recorded, and when the block exits, the destructor of this class records the
    cumulative time elapsed for this block, as well as the count of the number of
    times this block executed. The times and counts are stored in the static maps
    `ms_Times` and `ms_Counts`, respectively.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以看出，类成员包括名称、起始时间戳和两个`static map`。这个类的每个实例都用于计时某个代码块。该代码块可以是函数作用域或由花括号分隔的任何其他块。使用模式是在块的顶部定义一个`Timer`类的实例，同时传入一个名称（可以是函数名或其他方便的标签）。实例化时，记录当前时间戳，当块退出时，该类的析构函数记录了该块的累积经过时间，以及该块执行的次数。时间和次数分别存储在`ms_Times`和`ms_Counts`这两个`static
    map`中。
- en: 'Define the constructor of the `Timer` class by writing the following code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码来定义`Timer`类的构造函数：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the destructor of the `Timer` class by writing the following code:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Timer`类的析构函数，编写以下代码：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, the elapsed time is calculated in milliseconds. Then,
    we add that to the cumulative elapsed time for this block name and increment the
    count of how many times this block was executed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，经过时间以毫秒计算。然后，我们将其加到此块名称的累积经过时间中，并增加此块执行的次数。
- en: 'Define a `static` function named `dump()` that prints out the summary of the
    timed results:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`dump()`的`static`函数，打印出定时结果的摘要：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, the name, execution count, total time, and average time
    is printed in a tabular form. We use multiple tabs between the field names and
    field values to make them line up vertically on a console. This function can be
    modified as we wish. For example, we can modify this code to dump the output as
    a CSV file, so that it can be imported into a spreadsheet for further analysis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，以表格形式打印名称、执行次数、总时间和平均时间。我们在字段名称和字段值之间使用多个制表符，使它们在控制台上垂直对齐。这个函数可以根据我们的需要进行修改。例如，我们可以修改这段代码，将输出转储为CSV文件，以便可以将其导入电子表格进行进一步分析。
- en: 'Finally, define the `static` members to complete the class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义`static`成员以完成这个类：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we have defined the `Timer` class, define two simple functions that
    we will time as an example. One will add and the other will multiply. Since these
    operations are trivial, we will loop `1 billion times` so that we can have some
    measurable result.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`Timer`类，定义两个简单的函数作为示例进行计时。一个函数将进行加法，另一个函数将进行乘法。由于这些操作很简单，我们将循环`10亿次`，以便可以得到一些可测量的结果。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we used `unsigned int` for the variable that we repeatedly
    `add`/`multiply`. We used an unsigned type so that overflow during arithmetic
    does not result in undefined behavior. Had we used a signed type, the program
    would have undefined behavior and not be guaranteed to work in any way. Secondly,
    we return the calculated value from the `testAdd()` and `testMul()` functions
    so that we can ensure that the compiler does not remove the code (because of the
    lack of side effects). In order to time each of these functions, we need to simply
    declare an instance of a `Timer` class with a suitable label at the start of the
    function. The timing is started as soon as the `Timer` object is instantiated
    and stopped when that object goes out of scope.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`unsigned int`作为我们重复进行`add`/`multiply`的变量。我们使用无符号类型，以便在算术运算期间不会发生溢出导致未定义行为。如果我们使用了有符号类型，程序将具有未定义行为，并且不能保证以任何方式工作。其次，我们从`testAdd()`和`testMul()`函数返回计算的值，以便确保编译器不会删除代码（因为缺乏副作用）。为了计时这两个函数中的每一个，我们只需要在函数开始时声明一个带有合适标签的`Timer`类的实例。当`Timer`对象实例化时，计时开始，当该对象超出范围时，计时停止。
- en: 'Write the `main` function, where we will simply call both test functions `10`
    times each:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`main`函数，在其中我们将分别调用两个测试函数`10`次：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see in the preceding code, we're calling each function `10` times
    so that we can demonstrate the `Timer` class timing multiple runs of a function.
    Assigning the result of the functions to a volatile variable forces the compiler
    to assume that there is a global side effect. Hence, it will not elide the code
    in our test functions. Before exiting, we call the `Timer::dump` static function
    to display the results.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述代码所示，我们分别调用每个函数`10`次，以便演示`Timer`类计时函数的多次运行。将函数的结果赋给一个`volatile`变量会迫使编译器假定存在全局副作用。因此，它不会删除我们测试函数中的代码。在退出之前，调用`Timer::dump`静态函数显示结果。
- en: 'Save the program and open a terminal. Compile and run the program with different
    optimization levels – on the `gcc` and `clang` compilers, this is specified by
    the `-ON` compiler flag, where `N` is a number from `1` to `3`. Add the `-O1`
    compiler flag first:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。使用不同的优化级别编译和运行程序-在`gcc`和`clang`编译器上，这是通过`-ON`编译器标志指定的，其中`N`是从`1`到`3`的数字。首先添加`-O1`编译器标志：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code generates the following output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成以下输出：
- en: '![Figure 8.17: Snippet2.cpp code performance when compiled with the -O1 option'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：使用-O1选项编译时的Snippet2.cpp代码性能'
- en: '](img/C14583_08_17.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_17.jpg)'
- en: 'Figure 8.17: Snippet2.cpp code performance when compiled with the -O1 option'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.17：使用-O1选项编译时的Snippet2.cpp代码性能
- en: 'Now, add the `-O2` compiler flag in the terminal and execute the program:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端中添加`-O2`编译器标志并执行程序：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This generates the following output:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 8.18: Snippet2.cpp code performance when compiled with the -O2 option'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：使用-O2选项编译时的Snippet2.cpp代码性能'
- en: '](img/C14583_08_18.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_18.jpg)'
- en: 'Figure 8.18: Snippet2.cpp code performance when compiled with the -O2 option'
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.18：使用-O2选项编译时的Snippet2.cpp代码性能
- en: 'Add the `-O3` compiler flag in the terminal and execute the program:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中添加`-O3`编译器标志并执行程序：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This generates the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Figure 8.19: Snippet2.cpp code performance when compiled with the -O3 option'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：使用-O3选项编译时的Snippet2.cpp代码性能'
- en: '](img/C14583_08_19.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_19.jpg)'
- en: 'Figure 8.19: Snippet2.cpp code performance when compiled with the -O3 option'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.19：使用-O3选项编译时的Snippet2.cpp代码性能
- en: Notice that the `testMul` function became faster only at `O3`, but the `testAdd`
    function got faster at `O2` and much faster at `O3`. We can verify this by running
    the program multiple times and averaging the times. There are no obvious reasons
    why some functions speed up while others do not. We would have to exhaustively
    check the generated code to understand why. It is not guaranteed that this will
    happen on all the systems with different compilers or even compiler versions.
    The main point to take home is that we can never assume performance but have to
    always measure it, and always re-measure if we believe any change we made affects
    the performance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`testMul`函数只在`O3`时变得更快，但`testAdd`函数在`O2`时变得更快，而在`O3`时变得更快。我们可以通过多次运行程序并对时间进行平均来验证这一点。没有明显的原因说明为什么有些函数加速而其他函数没有。我们必须详尽地检查生成的代码才能理解原因。不能保证这将在所有不同编译器或甚至编译器版本的系统上发生。主要要点是我们永远不能假设性能，而必须始终测量它，并且如果我们认为我们所做的任何更改会影响性能，就必须重新测量。
- en: 'To make it easier to use our `Timer` class for timing individual functions,
    we can write a macro. C++ 11 and above support a special compiler built-in macro
    called `__func__` that always contains the currently executing function''s name
    as a `const char*`. Use this to define a macro so that we don''t need to specify
    a label for our `Timer` instances, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更容易使用我们的`Timer`类来计时单个函数，我们可以编写一个宏。C++ 11及以上版本支持一个特殊的编译器内置宏，称为`__func__`，它始终包含当前执行函数的名称作为`const
    char*`。使用这个来定义一个宏，这样我们就不需要为我们的`Timer`实例指定标签，如下所示：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the `TIME_IT` macro to the start of the two functions, changing the existing
    line that creates a Timer object:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TIME_IT`宏添加到两个函数的开头，更改创建Timer对象的现有行：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the program and open the terminal. Compile and run it again by using the
    following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。使用以下命令再次编译和运行它：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the previous command is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![Figure 8.20: Snippet2.cpp code output when using a macro for timing'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：使用宏计时时的Snippet2.cpp代码输出'
- en: '](img/C14583_08_20.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_20.jpg)'
- en: 'Figure 8.20: Snippet2.cpp code output when using a macro for timing'
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.20：使用宏计时时的Snippet2.cpp代码输出
- en: In the preceding output, notice that the actual function name is printed now.
    Another advantage of using this macro is that we can add this to all potentially
    time-consuming functions by default, and disable it for production builds by simply
    changing the definition to a no-op, which will cause the timing code to never
    run - avoiding the need to edit the code extensively. We will use this same Timer
    class for timing code in forthcoming exercises.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，注意现在打印了实际函数名。使用这个宏的另一个优点是，我们可以默认将其添加到所有可能耗时的函数中，并在生产构建中通过简单地更改定义为no-op来禁用它，这将导致计时代码永远不会运行-避免了需要大量编辑代码的需要。我们将在后续练习中使用相同的Timer类来计时代码。
- en: Runtime Profiling
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时性能分析
- en: '**Profiling** is a non-intrusive method of measuring the performance of the
    functions in a program. Profilers work by sampling a program''s current execution
    address at frequent intervals (hundreds of times in a second) and making a log
    of which functions happened to be executing at the time. This is a statistical
    sampling approach that has reasonable accuracy. Sometimes, though, the results
    can be confusing as a program may spend a lot of time on functions that are a
    part of the operating system kernel. The most popular runtime profiling tool on
    Linux is **perf**. In the next section, we''ll make use of perf to profile our
    program.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**是一种非侵入式的方法，用于测量程序中函数的性能。性能分析器通过在频繁的间隔（每秒数百次）对程序的当前执行地址进行采样，并记录在此时执行的函数。这是一种统计采样方法，具有合理的准确性。但有时，结果可能会令人困惑，因为程序可能会花费大量时间在操作系统内核的函数上。Linux上最流行的运行时性能分析工具是**perf**。在下一节中，我们将利用perf来对我们的程序进行性能分析。'
- en: 'Exercise 3: Using perf to Profile Programs'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：使用perf对程序进行性能分析
- en: '`perf` can be installed on `Ubuntu` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`perf`可以在`Ubuntu`上安装如下：'
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To get familiar with the basics of using `perf`, we''ll profile and analyze
    the program from the previous exercise with the help of the `perf` tool. Perform
    the following steps to complete this exercise:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉使用`perf`的基础知识，我们将使用`perf`工具对上一个练习中的程序进行性能分析。执行以下步骤完成此练习：
- en: Open the `TIME_IT` macros from the two functions.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开两个函数中的`TIME_IT`宏。
- en: 'Open the terminal, recompile the code again with the `-O3` flag, and then create
    a profile data sample with `perf` as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，使用`-O3`标志重新编译代码，然后使用`perf`创建一个配置文件数据样本，如下所示：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the previous command is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![](img/C14583_08_21.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_08_21.jpg)'
- en: 'Figure 8.21: Using the perf command to analyze the code in Snippet2.cpp'
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.21：使用perf命令分析Snippet2.cpp中的代码
- en: This creates a file called `perf.data` which can be analyzed or visualized.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`perf.data`的文件，可以进行分析或可视化。
- en: 'Now, use the following command to visualize the recorded data:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令可视化记录的数据：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A console-based GUI will show the following data after executing the previous
    command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前一个命令后，控制台基于GUI将显示以下数据：
- en: '![Figure 8.22: Using the perf command to analyze the code in Snippet2.cpp'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：使用perf命令分析Snippet2.cpp中的代码'
- en: '](img/C14583_08_22.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_22.jpg)'
- en: 'Figure 8.22: Using the perf command to analyze the code in Snippet2.cpp'
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.22：使用perf命令分析Snippet2.cpp中的代码
- en: You can move the cursor up and down to select a function and press *Enter* to
    get a list of options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以上下移动光标选择一个函数，然后按*Enter*获取选项列表。
- en: 'Highlight `testMul`, press *Enter*, and choose `Annotate testMul` in the resulting
    list. A list of assembly code is shown, with annotations describing the percentage
    of execution time for each line of code, as follows:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 突出显示`testMul`，按*Enter*，并在结果列表中选择`Annotate testMul`。显示一系列汇编代码，其中包含描述每行代码执行时间百分比的注释，如下所示：
- en: '![Figure 8.23: Viewing the timing statistics using the perf command for the
    Snippet2.cpp code'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23：使用perf命令查看Snippet2.cpp代码的时间统计信息'
- en: '](img/C14583_08_23.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_23.jpg)'
- en: 'Figure 8.23: Viewing the timing statistics using the perf command for the Snippet2.cpp
    code'
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.23：使用perf命令查看Snippet2.cpp代码的时间统计信息
- en: Notice that the `99%` of the time to execute. Traditionally, integer multiplications
    are always expensive on the `x86` architecture and this continues to be true,
    even in the latest generation of CPUs. This annotation view displays arrows next
    to each jump or branching instruction which, when highlighted, shows what comparison
    instruction it is associated with and what address it jumps to with line drawings.
    You can navigate to the previous view by pressing the left arrow key and exit
    the program using the *q* key.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`99%`的执行时间。传统上，在`x86`架构上，整数乘法始终很昂贵，即使在最新一代CPU中也是如此。此注释视图在每个跳转或分支指令旁显示箭头，突出显示时显示其关联的比较指令和跳转到的地址以线条绘制。您可以按左箭头键导航到上一个视图，并使用*q*键退出程序。
- en: Up until now, we've looked at several methods that are used to assess the performance
    of our programs. This is the most critical stage of optimization since it tells
    us where we need to direct our efforts. In the upcoming sections, we will explore
    various techniques that will help us optimize our code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看了几种用于评估程序性能的方法。这是优化的最关键阶段，因为它告诉我们需要将精力放在哪里。在接下来的章节中，我们将探索各种技术，帮助我们优化我们的代码。
- en: Optimization Strategies
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化策略
- en: 'Optimization of code can be done in several ways, such as the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 代码优化可以通过多种方式进行，例如：
- en: Compiler-based optimization
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于编译器的优化
- en: Source code micro-optimization
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码微优化
- en: Cache-friendly code
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存友好的代码
- en: Algorithmic optimization
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法优化
- en: Here, each technique has its pros and cons. We will examine each of these methods
    in detail in the upcoming sections. Roughly speaking, these are ordered in terms
    of effort required and also potential gains in performance. We'll look at compiler-based
    optimization in the next section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每种技术都有其优缺点。我们将在接下来的章节中详细研究这些方法。粗略地说，这些方法按照所需的工作量和性能潜力排序。我们将在下一节中研究基于编译器的优化。
- en: Compiler-Based Optimization
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于编译器的优化
- en: Passing the correct options to the compiler can net many performance benefits.
    A real-world example of this is the Clear Linux `gcc` and `clang` family of compilers,
    the most basic option for optimization is `-O<N>`, where `N` is one of the numbers
    `1`, `2`, or `3`. `-O3` enables almost every optimization in the compiler, but
    there are several others not enabled by that flag that can make a difference.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 向编译器传递正确的选项可以获得许多性能优势。这方面的一个现实例子是Clear Linux的`gcc`和`clang`系列编译器，优化的最基本选项是`-O<N>`，其中`N`是`1`、`2`或`3`中的一个数字。`-O3`几乎启用了编译器中的每个优化，但还有一些未通过该标志启用的其他优化可以产生差异。
- en: Loop Unrolling
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环展开
- en: '**Loop unrolling** is a technique that can be used by compilers to reduce the
    number of branches that are executed. Every time a branch is executed, there is
    a certain performance overhead. This can be reduced by repeating the loop body
    multiple times, and reducing the number of times the loop is executed. Loop unrolling
    can be done at the source level by the programmer, but modern compilers do a very
    good job automatically.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环展开**是编译器可以使用的一种技术，用于减少执行的分支数。每次执行分支时，都会有一定的性能开销。这可以通过多次重复循环体并减少循环执行次数来减少。循环展开可以由程序员在源级别上完成，但现代编译器会自动完成得很好。'
- en: Even though modern processors mitigate the overhead of branching by means of
    `gcc` and `clang` family of compilers with the `-funroll-loops` command-line flag.
    In the next section, we'll test the performance of a program with and without
    loop unrolling enabled.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现代处理器通过`gcc`和`clang`系列编译器的`-funroll-loops`命令行标志来减少分支开销。在下一节中，我们将测试启用和未启用循环展开的程序性能。
- en: 'Exercise 4: Using Loop Unrolling Optimizations'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：使用循环展开优化
- en: In this exercise, we'll write a simple program that uses nested loops and test
    its performance with and without loop unrolling enabled. We'll understand the
    way compilers implement the automatic unrolling of loops.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的程序，使用嵌套循环并测试其性能，启用和未启用循环展开。我们将了解编译器如何实现循环的自动展开。
- en: 'Perform these steps to complete this exercise:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Create a file named **Snippet3.cpp**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为**Snippet3.cpp**的文件。
- en: 'Write a program that takes the first `10,000` numbers and prints out how many
    of these are factors of each other (the full code can be found in **Snippet3.cpp**):'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，取前`10,000`个数字，并打印出这些数字中有多少个是彼此的因子（完整代码可以在**Snippet3.cpp**中找到）：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save the program and open the terminal. Compile the program with the `-O3`
    flag first and time it using the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。首先使用`-O3`标志编译程序，并使用以下命令计时：
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the previous command is as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![Figure 8.24: Output of the code in Snippet3.cpp'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：Snippet3.cpp代码的输出'
- en: '](img/C14583_08_24.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_24.jpg)'
- en: 'Figure 8.24: Output of the code in Snippet3.cpp'
  id: totrans-296
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.24：Snippet3.cpp代码的输出
- en: 'Now, compile the same code with the loop unrolling enabled and time it again:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启用循环展开编译相同的代码并再次计时：
- en: '[PRE38]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the previous command is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![Figure 8.25: Output of the code in Snippet3.cpp compiled with the loop unrolling
    option'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：使用循环展开选项编译的Snippet3.cpp代码的输出'
- en: '](img/C14583_08_25.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_25.jpg)'
- en: 'Figure 8.25: Output of the code in Snippet3.cpp compiled with the loop unrolling
    option'
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.25：使用循环展开选项编译的Snippet3.cpp代码的输出
- en: Open the `Godbolt compiler explorer` and paste the preceding complete code into
    the left-side.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Godbolt编译器资源管理器`，并将前面的完整代码粘贴到左侧。
- en: 'On the right-hand side, select `x86-64 gcc 8.3` from the compiler options and
    write the `-O3` flag in the options. Assembly code will be generated. For the
    for loop, you''ll see the following output:![Figure 8.26: Assembly code of the
    for loop'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，从编译器选项中选择`x86-64 gcc 8.3`，并在选项中写入`-O3`标志。将生成汇编代码。对于for循环，你会看到以下输出：![图8.26：for循环的汇编代码
- en: '](img/C14583_08_26.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_26.jpg)'
- en: 'Figure 8.26: Assembly code of the for loop'
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.26：for循环的汇编代码
- en: From the preceding screenshot, you can clearly see `RCX` being compared to `10,000`
    with the `CMP` instruction, followed by a conditional jump, `JNE` (Jump if Not
    Equal). Just after this code, the outer loop comparison is seen, with `RSI` being
    compared to `10,000`, followed by another conditional jump to the `L4` label.
    Overall, the inner conditional branch and jump executes `100,000,000` times.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，你可以清楚地看到`RCX`与`10,000`进行比较，使用`CMP`指令，然后是一个条件跳转，`JNE`（如果不相等则跳转）。就在这段代码之后，可以看到外部循环比较，`RSI`与`10,000`进行比较，然后是另一个条件跳转到`L4`标签。总的来说，内部条件分支和跳转执行了`100,000,000`次。
- en: 'Now, add the following options: `-O3 –funroll-loops`. Assembly code will be
    generated. In this code, you''ll notice this code pattern repeating eight times
    (except for the `LEA` instruction, whose offset value changes):'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下选项：`-O3 –funroll-loops`。将生成汇编代码。在这段代码中，你会注意到这段代码模式重复了八次（除了`LEA`指令，其偏移值会改变）：
- en: '![Figure 8.27: Assembly code of the for loop'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27：for循环的汇编代码'
- en: '](img/C14583_08_27.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_27.jpg)'
- en: 'Figure 8.27: Assembly code of the for loop'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.27：for循环的汇编代码
- en: The compiler decided to unroll the body of the loop eight times, reducing the
    number of conditional jump instructions executed by a factor of `87.5%` (about
    `8,300,000` times). This alone caused the execution time to improve by `10%`,
    which is a very significant speedup. In this exercise we have seen the benefits
    of loop unrolling - next, we'll learn about profile guided optimization.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器决定展开循环体八次，将条件跳转指令的执行次数减少了`87.5%`（约`8,300,000`次）。这单独就导致执行时间提高了`10%`，这是一个非常显著的加速。在这个练习中，我们已经看到了循环展开的好处
    - 接下来，我们将学习profile guided optimization。
- en: Profile Guided Optimization
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Profile Guided Optimization
- en: '**Profile Guided Optimization** (PGO) is a feature that most compilers support.
    When a program is compiled with PGO enabled, the compiler adds instrumentation
    code to the program. Running this PGO-enabled executable creates a log file that
    contains information about the execution statistics of the program. The term **profiling**
    refers to the process of running a program to gather performance metrics. Typically,
    this profiling stage should be run with a real-world dataset so that an accurate
    log is produced. After this profiling run, the program is recompiled with a special
    compiler flag. This flag enables the compiler to perform special optimizations
    based on the statistical execution data that was recorded. Significant performance
    gains can be achieved with this approach. Let''s solve an exercise based on profile
    guided optimization to get a better understanding of this.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**Profile Guided Optimization**（PGO）是大多数编译器支持的一个特性。当使用PGO编译程序时，编译器会向程序添加插装代码。运行这个启用了PGO的可执行文件会创建一个包含程序执行统计信息的日志文件。术语**profiling**指的是运行程序以收集性能指标的过程。通常，这个profiling阶段应该使用真实的数据集运行，以便产生准确的日志。在这个profiling运行之后，程序会使用特殊的编译器标志重新编译。这个标志使编译器能够根据记录的统计执行数据执行特殊的优化。采用这种方法可以实现显著的性能提升。让我们解决一个基于profile
    guided optimization的练习，以更好地理解这个过程。'
- en: 'Exercise 5: Using Profile Guided Optimization'
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：使用Profile Guided Optimization
- en: In this exercise, we will use profile guided optimization on the code from the
    previous exercise. We'll understand how to use profile guided optimization with
    the `gcc` compiler.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在前一个练习的代码上使用profile guided optimization。我们将了解如何在`gcc`编译器中使用profile
    guided optimization。
- en: 'Perform these steps to complete this exercise:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Open the terminal and compile the code from the previous exercise with profiling
    enabled. Include any other optimization flags that we need (in this case, `-O3`).
    Write the following code to implement this:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并使用启用了profiling的前一个练习的代码进行编译。包括我们需要的任何其他优化标志（在本例中为`-O3`）。编写以下代码来实现这一点：
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, run the profiled version of the code by writing the following command:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过编写以下命令运行代码的profiled版本：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The program runs normally and prints the result, and no other output is seen
    - but it generates a file containing data that will help the compiler in the following
    step. Note that with profiling enabled, the program executes several times slower
    than it would normally. This is something to keep in mind with large programs.
    After executing the previous command, a file called `Snippet3.gcda` will be generated,
    which contains profile data. When doing this with large, complex applications,
    it is important to run the program with the datasets and workflows that it will
    most commonly encounter in the production environment. By choosing the data correctly
    here, the eventual performance gain will be higher.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正常运行并打印结果，没有看到其他输出 - 但它生成了一个包含数据的文件，这将帮助编译器进行下一步。请注意，启用了性能分析后，程序的执行速度会比正常情况下慢几倍。这是在处理大型程序时需要牢记的事情。执行前一个命令后，将生成一个名为`Snippet3.gcda`的文件，其中包含性能分析数据。在处理大型、复杂的应用程序时，重要的是使用它在生产环境中最常遇到的数据集和工作流来运行程序。通过在这里正确选择数据，最终的性能提升将更高。
- en: 'Recompile with the PGO optimization flags, that is, `-fprofile-use` and `-fprofile-correction`,
    as illustrated in the following code:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译使用PGO优化标志，即`-fprofile-use`和`-fprofile-correction`，如下所示：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that other than the profile-related compiler options, the other options
    must be exactly the same as the ones in the previous compilation step.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了与之前编译步骤中的与性能相关的编译器选项外，其他选项必须完全相同。
- en: 'Now, if we time the executable, we will see a large performance improvement:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们计时可执行文件，我们将看到性能大幅提升：
- en: '[PRE42]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the previous command is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![Figure 8.28: Timing results of the code in Snippet3.cpp with PGO optimization'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28：使用PGO优化编译的Snippet3.cpp代码的时间结果'
- en: '](img/C14583_08_28.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_28.jpg)'
- en: 'Figure 8.28: Timing results of the code in Snippet3.cpp with PGO optimization'
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.28：使用PGO优化编译的Snippet3.cpp代码的时间结果
- en: In this exercise, we have seen the performance benefits gained by using profile
    guided optimizations provided by the compiler. For this code, the improvement
    in performance was about `2.7x` - on larger programs, this can be even higher.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们已经看到了使用编译器提供的基于性能指导的优化所获得的性能优势。对于这段代码，性能提升约为`2.7倍` - 在更大的程序中，这个提升甚至可能更高。
- en: Parallelization
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行化
- en: Most CPUs today have multiple cores, and even mobile phones have quad core processors.
    We can exploit this parallel processing power very simply with compiler flags
    that instruct it to generate parallelized code. One mechanism of parallelizing
    code is to use the `OpenMP` extensions of the C/C++ language. However, this means
    changing the source code and having detailed knowledge of how to use those extensions.
    The other simpler option is a feature specific to the `gcc` compiler – it provides
    an extended standard library that implements most algorithms to run as parallel
    ones.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如今大多数CPU都有多个核心，甚至手机也有四核处理器。我们可以通过简单地使用编译器标志来利用这种并行处理能力，让它生成并行化的代码。一种并行化代码的机制是使用C/C++语言的`OpenMP`扩展。然而，这意味着改变源代码并且需要详细了解如何使用这些扩展。另一个更简单的选择是`gcc`编译器特有的一个特性
    - 它提供了一个扩展标准库，实现了大多数算法作为并行算法运行。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This automatic parallelization is only available for STL algorithms on gcc and
    is not part of the C++ standard. The C++ 17 standard proposes extensions to the
    standard library for parallel versions of most algorithms but is not supported
    by all compilers yet. Also, in order to take advantage of this feature, the code
    would have to be rewritten extensively.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动并行化只适用于gcc上的STL算法，并不是C++标准的一部分。C++ 17标准提出了标准库的扩展，用于大多数算法的并行版本，但并不是所有编译器都支持。此外，为了利用这个特性，代码需要进行大量重写。
- en: 'Exercise 6: Using Compiler Parallelization'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：使用编译器并行化
- en: In this exercise, we will use the `gcc` parallel extensions feature to accelerate
    standard library functions. Our aim is to understand how to use `gcc` parallel
    extensions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`gcc`的并行扩展特性来加速标准库函数。我们的目标是了解如何使用`gcc`的并行扩展。
- en: 'Perform these steps to complete this exercise:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤来完成这个练习：
- en: Create a file named **Snippet4.cpp**.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet4.cpp**的文件。
- en: 'Write a simple program to sum up an initialized array with `std::accumulate.`
    Add the following code to implement this:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的程序，使用`std::accumulate`来对初始化的数组进行求和。添加以下代码来实现这一点：
- en: '[PRE43]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Save the program and open the terminal. Compile the program normally and time
    the execution using the following commands:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。正常编译程序并使用以下命令计时执行：
- en: '[PRE44]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the previous command is as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出如下：
- en: '![Figure 8.29: Output of the code in Snippet4.cpp'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29：Snippet4.cpp代码的输出'
- en: '](img/C14583_08_29.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_29.jpg)'
- en: 'Figure 8.29: Output of the code in Snippet4.cpp'
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.29：Snippet4.cpp代码的输出
- en: 'Now, compile the code with the parallelization options, that is, `-O3 -fopenmp`
    and `-D_GLIBCXX_PARALLEL`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用并行化选项编译代码，即`-O3 -fopenmp`和`-D_GLIBCXX_PARALLEL`：
- en: '[PRE45]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output is as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.30: Output of the code in Snippet4.cpp compiled with parallelization
    options'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30：使用并行化选项编译的Snippet4.cpp代码的输出'
- en: '](img/C14583_08_30.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_30.jpg)'
- en: 'Figure 8.30: Output of the code in Snippet4.cpp compiled with parallelization
    options'
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.30：使用并行化选项编译的Snippet4.cpp代码的输出
- en: In the previous output, the `user` field shows the cumulative CPU time and the
    `real` field shows the wall time. The ratio seen between the two is about `7x`.
    This ratio will vary, depending on how many CPU cores the system has (in this
    particular case, there were eight cores). For this system, the ratio could reach
    8x if the compiler was able to perform `100%` parallelization. Note that even
    though eight cores were used, the actual improvement in execution time was only
    about `1.3x`. This is probably because the allocation and initialization of the
    vector takes up most of the time. This is a case of `1.3x` speedup in our code,
    which is a very good optimization result.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的输出中，`user`字段显示了累积CPU时间，`real`字段显示了墙时间。两者之间的比率约为`7x`。这个比率会有所变化，取决于系统有多少个CPU核心（在这种情况下，有八个核心）。对于这个系统，如果编译器能够执行`100%`的并行化，这个比率可能会达到8倍。请注意，即使使用了八个核心，实际的执行时间改进只有大约`1.3x`。这可能是因为向量的分配和初始化占用了大部分时间。这是我们代码中`1.3x`加速的情况，这是一个非常好的优化结果。
- en: So far, we have covered some of the more impactful compiler optimization features
    available in modern compilers. Apart from these, there are several other optimization
    flags, but they may not produce very large improvements in performance. Two particular
    optimization flags that apply to large projects with many different source files
    is **Link time optimization** or **Link time code generation**. These are worth
    enabling for large projects. In the next section, we'll look into source code
    micro optimizations.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了一些现代编译器中可用的一些更有影响力的编译器优化特性。除了这些，还有几个其他优化标志，但它们可能不会产生非常大的性能改进。适用于具有许多不同源文件的大型项目的两个特定优化标志是**链接时优化**或**链接时代码生成**。这些对于大型项目来说是值得启用的。在下一节中，我们将研究源代码微优化。
- en: Source Code Micro Optimizations
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码微优化
- en: 'These are techniques that involve using certain idioms and patterns in the
    source code that are usually faster than their equivalents. In earlier times,
    these kinds of micro-optimizations were very fruitful, because compilers were
    not very clever. But today, compiler technology is very much advanced, and the
    effect of these micro-optimizations are not so marked. In spite of this, it is
    a very good habit to use these because they will make the code faster even if
    compiled without optimization. Even in development builds, code that is faster
    saves time when testing and debugging. We''ll look at the std::vector container
    in the next section:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是涉及在源代码中使用某些习语和模式的技术，通常比它们的等价物更快。在早期，这些微优化非常有成效，因为编译器不是很聪明。但是今天，编译器技术非常先进，这些微优化的效果并不那么明显。尽管如此，使用这些是一个非常好的习惯，因为即使在没有优化的情况下编译，它们也会使代码更快。即使在开发构建中，更快的代码也会在测试和调试时节省时间。我们将在下一节中看一下std::vector容器：
- en: Using the std::vector Container Efficiently
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效使用std::vector容器
- en: '`std::vector` is one of the most simple and useful containers in the standard
    library. It has no overhead over normal C style arrays, but has the ability to
    grow, as well as optional bounds checking. You should almost always use `std::vector`
    when the number of elements is not known at compile time.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`是标准库中最简单和最有用的容器之一。它与普通的C风格数组没有额外开销，但具有增长的能力，以及可选的边界检查。当元素的数量在编译时未知时，几乎总是应该使用`std::vector`。'
- en: A common idiom that's used with `std::vector` is to call `push_back` on it in
    a loop – as it grows, the vector reallocates a new buffer, which is larger than
    the existing one by a certain factor (the exact value of this growth factor depends
    on the standard library implementation). In theory, this reallocation has minimal
    costs because it occurs infrequently, but in practice, the operation of resizing
    in a vector involves copying the elements of its buffer to a newly allocated larger
    buffer, which can be very expensive.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::vector`一起使用的常见习语是在循环中调用`push_back` - 随着它的增长，向量重新分配一个新的缓冲区，该缓冲区比现有的缓冲区大一定因子（此增长因子的确切值取决于标准库的实现）。理论上，这种重新分配的成本很小，因为它不经常发生，但实际上，在向量中调整大小的操作涉及将其缓冲区的元素复制到新分配的更大缓冲区中，这可能非常昂贵。
- en: We can avoid these multiple allocations and copies by using the `reserve()`
    method. When we know how many elements a vector will contain, calling the `reserve()`
    method to pre-allocate the storage makes quite a difference. Let's implement an
    exercise in the next section to optimize vector growth.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`reserve()`方法来避免这些多次分配和复制。当我们知道一个向量将包含多少元素时，调用`reserve()`方法来预先分配存储空间会产生很大的差异。让我们在下一节中实现一个练习来优化向量增长。
- en: 'Exercise 7: Optimizing Vector Growth'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：优化向量增长
- en: 'In this exercise, we will time the effect of the `push_back` method in a loop,
    with and without calling the reserve method. First, we will extract the `Timer`
    class we used in the previous sections into a separate header and implementation
    file – this will allow us to use it as common code for all the succeeding code
    snippets. Perform these steps to complete this exercise:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将计时在循环中使用`push_back`方法的效果，有无调用reserve方法。首先，我们将把我们在前几节中使用的`Timer`类提取到一个单独的头文件和实现文件中
    - 这将允许我们将其用作所有后续代码片段的通用代码。执行以下步骤来完成这个练习：
- en: Create a header file named **Timer.h**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Timer.h**的头文件。
- en: 'Include the necessary header files:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括必要的头文件：
- en: '[PRE46]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a class named `Timer`. Within the `Timer` class, declare four variables,
    namely `ms_Counts`, `ms_Times`, `m_tmStart`, and `m_sName`. Declare a constructor,
    destructor, and the `dump()` method. Add the following code to implement this:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Timer`的类。在`Timer`类中，声明四个变量，分别是`ms_Counts`、`ms_Times`、`m_tmStart`和`m_sName`。声明一个构造函数、析构函数和`dump()`方法。添加以下代码来实现这一点：
- en: '[PRE47]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Define a helper macro named `TIME_IT` to time functions by writing the following
    code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`TIME_IT`的辅助宏，通过编写以下代码来计时函数：
- en: '[PRE48]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Once the header file has been created, create a new file named `dump()` method
    inside the **Timer.cpp** file. Write the following code to implement this:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了头文件，就在**Timer.cpp**文件中创建一个名为`dump()`的新文件。编写以下代码来实现这一点：
- en: '[PRE49]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, create a new file named `1,000,000` integers using the `push_back()` method.
    The second function calls the `reserve()` method beforehand, but the first one
    does not. Write the following code to implement this:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`push_back()`方法创建一个名为`1,000,000`的新文件。第二个函数在之前调用了`reserve()`方法，但第一个函数没有。编写以下代码来实现这一点：
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, write the `main` function. Note the use of redundant braces to ensure
    that the `v1` and `v2` vectors are destroyed after every iteration of the loop:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写`main`函数。请注意使用多余的大括号以确保在循环的每次迭代后销毁`v1`和`v2`向量：
- en: '[PRE51]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The reason we pass the vector by reference is to prevent the compiler from optimizing
    out the entire code in the two functions. If we passed the vectors by value, the
    functions would have no visible side effects and the compiler may just elide the
    functions totally.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过引用传递向量的原因是为了防止编译器优化掉两个函数中的整个代码。如果我们通过值传递向量，函数将没有可见的副作用，编译器可能会完全省略这些函数。
- en: 'Save the program and open the terminal. Compile the **Timer.cpp** and **Snippet5.cpp**
    files and run them as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。编译**Timer.cpp**和**Snippet5.cpp**文件，并按以下方式运行它们：
- en: '[PRE52]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.31: Output of the code in Snippet5.cpp showing the effect of vector::reserve()'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31：Snippet5.cpp中代码的输出，显示了vector::reserve()的效果'
- en: '](img/C14583_08_31.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_31.jpg)'
- en: 'Figure 8.31: Output of the code in Snippet5.cpp showing the effect of vector::reserve()'
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.31：Snippet5.cpp中代码的输出，显示了vector::reserve()的效果
- en: As we can see, the effect of calling `reserve()` has resulted in an improvement
    of about 4% in execution time. In a larger program that has run for a long time,
    the system memory often becomes very fragmented. In such cases, the improvement
    by pre-allocating memory with `reserve()` could be much better. In general, it
    is usually faster to reserve memory beforehand, rather than doing it incrementally
    on the fly. Even the Java Virtual Machine, for performance reasons, uses this
    technique of allocating a huge chunk of memory upfront when starting up.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，调用`reserve()`的效果导致执行时间提高了约4%。在运行时间较长的大型程序中，系统内存通常变得非常碎片化。在这种情况下，通过使用`reserve()`预先分配内存的改进可能会更好。通常情况下，预留内存通常比在运行时逐步增加内存更快。甚至为了性能原因，Java虚拟机在启动时使用这种预先分配大块内存的技术。
- en: Short-Circuit Logical Operators
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短路逻辑运算符
- en: 'The `&&` and `||` logical operators are **short-circuited**, which means that
    the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`逻辑运算符是**短路**的，这意味着以下内容：'
- en: If the left-hand side of the `||` operator is `true`, the right-hand side is
    not evaluated.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`||`运算符的左侧为`true`，则不会评估右侧。
- en: If the left-hand side of the `&&` operator is `false`, the right-hand side is
    not evaluated.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`&&`运算符的左侧为`false`，则不会评估右侧。
- en: By keeping the more unlikely (or less expensive) expression on the left-hand
    side, we can reduce the amount of work that needs to be done. In the next section,
    we'll solve an exercise and learn how to write logical expressions optimally.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将不太可能的（或者更便宜的）表达式放在左侧，我们可以减少需要执行的工作量。在下一节中，我们将解决一个练习，并学习如何最优地编写逻辑表达式。
- en: 'Exercise 8: Optimizing Logical Operators'
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习8：优化逻辑运算符
- en: 'In this exercise, we will examine the impact of ordering conditional expressions
    when used with logical operators. Perform these steps to complete this exercise:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究在逻辑运算符与条件表达式一起使用时的顺序对性能的影响。执行以下步骤完成这个练习：
- en: Create a new file named **Snippet6.cpp**.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet6.cpp**的新文件。
- en: 'Include the necessary libraries and the Timer.h file that we created in the
    previous exercise by writing the following code:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写以下代码，包括我们在上一个练习中创建的必要库和Timer.h文件：
- en: '[PRE53]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a function named `sum1()` that computes the sum of the integers between
    `0` and `N`. Each number is summed only if it meets either or of two specific
    criteria. The first condition is that the number must be less than `N/2`. The
    second condition is that the number, when divided by 3, must return 2 as a remainder.
    Here, we set `N` to `100,000,000` so we have some measurable time taken by the
    code. Write the following code to implement this:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`sum1()`的函数，计算介于`0`和`N`之间的整数的和。只有当满足两个特定条件中的一个时，才对每个数字求和。第一个条件是数字必须小于`N/2`。第二个条件是当数字除以3时，必须返回2作为余数。在这里，我们将`N`设置为`100,000,000`，以便代码花费一些可测量的时间。编写以下代码来实现这一点：
- en: '[PRE54]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, define another function named `sum2()`. It must contain the same logic
    that we wrote for the previous function, `sum1()`. The only change here is that
    we reverse the order of the conditional expression of the `if` statement. Write
    the following code to implement this:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义另一个名为`sum2()`的函数。它必须包含我们为上一个函数`sum1()`编写的相同逻辑。这里唯一的变化是我们颠倒了`if`语句的条件表达式的顺序。编写以下代码来实现这一点：
- en: '[PRE55]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that in the `sum2` function, the `b < N/2` condition will evaluate to true
    half of the time. Thus, the second condition, that is, `b % 3 == 2`, is only evaluated
    for half of the iterations. If we assume for simplicity that both conditionals
    take 1 unit of time, the total time taken for `sum2()` would be `N/2 + (2 * N/2)
    = N * 3/2`. In the case of the `sum1()` function, the condition on the left-hand
    side will evaluate to `true` only 33% of the time, and the remaining 66% of the
    time, both conditions will be evaluated. Thus, the estimated time taken would
    be `N/3 + (2 * N * 2/3) = N * 5/3`. We expect that the ratio between the times
    for the `sum1` and `sum2` function would be `5/3` to `3/2` – that is, `sum1` is
    `11%` slower.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`sum2`函数中，`b < N/2`条件将一半的时间评估为true。因此，第二个条件，即`b % 3 == 2`，只有一半的迭代会被评估。如果我们简单地假设两个条件都需要1个单位的时间，那么`sum2()`所需的总时间将是`N/2
    + (2 * N/2) = N * 3/2`。在`sum1()`函数的情况下，左侧的条件只有33%的时间评估为`true`，剩下的66%的时间，两个条件都会被评估。因此，预计所需的时间将是`N/3
    + (2 * N * 2/3) = N * 5/3`。我们预计`sum1`和`sum2`函数之间的时间比率将是`5/3`到`3/2` - 也就是说，`sum1`慢了`11%`。
- en: 'Add the following code in the main function:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中添加以下代码：
- en: '[PRE56]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the file and open the terminal. Compile and time the preceding program,
    as well as the **Timer.cpp** file, by writing the following commands:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并打开终端。通过编写以下命令，编译并计时前面的程序以及**Timer.cpp**文件：
- en: '[PRE57]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.32: Output of the code in Snippet6.cpp showing the effect of optimizing
    boolean conditions'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32：Snippet6.cpp中代码的输出，显示了优化布尔条件的效果'
- en: '](img/C14583_08_32.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_32.jpg)'
- en: 'Figure 8.32: Output of the code in Snippet6.cpp showing the effect of optimizing
    boolean conditions'
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.32：Snippet6.cpp中代码的输出
- en: As you can see from the preceding output, we ended up with about `38%` improvement
    in speed, which is much more than expected. Why would this happen? The answer
    is that the `%` operator performs an integer division, which is much more expensive
    than a comparison, but the compiler will not generate a division instruction for
    the `N/2` expression because it is a constant value.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，我们最终获得了约38%的速度提升，这远远超出了预期。为什么会发生这种情况？答案是`%`运算符执行整数除法，比比较要昂贵得多，但编译器不会为`N/2`表达式生成除法指令，因为它是一个常量值。
- en: The `sum1()` function code executes the modulus operation for every iteration
    of the loop and the overall execution time is dominated by the division. To summarize
    this, we must always consider short-circuit logical operators and calculate how
    each side of the expression is, and how many times it exectures in order to choose
    the optimal order in which they should appear in the expression. This is equivalent
    of doing an expected value calculation of probability theory. In the next section,
    we'll learn about branch prediction.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum1()`函数代码对循环的每次迭代执行模运算，整体执行时间由除法主导。总结一下，我们必须始终考虑短路逻辑运算符，并计算表达式的每一侧以及它们出现在表达式中的次数，以选择它们应该出现在表达式中的最佳顺序。这相当于对概率论进行期望值计算。在下一节中，我们将学习有关分支预测的内容。'
- en: Branch Prediction
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支预测
- en: Modern processors use a pipelined architecture, which is similar to a factory
    assembly line, where an instruction flows along a pipeline and is processed by
    various workers simultaneously. After each clock cycle, the instruction moves
    along the pipeline to the next stage. This means that although each instruction
    may take many cycles to go from start to finish, the overall throughput is one
    instruction completed per cycle.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器使用流水线架构，类似于工厂装配线，其中指令沿着流水线流动，并同时由各种工人处理。每个时钟周期后，指令沿着流水线移动到下一个阶段。这意味着虽然每个指令可能需要多个周期才能从开始到结束，但整体吞吐量是每个周期完成一个指令。
- en: The drawback here is that, if there is a conditional branch instruction, the
    CPU has no idea which set of instructions are to be loaded after that (since there
    are two possible alternatives). This condition is called a **pipeline stall**,
    and the processor must wait until the condition of the branch has been evaluated
    completely, wasting precious cycles.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的缺点是，如果有条件分支指令，CPU不知道在此之后要加载哪组指令（因为有两种可能的选择）。这种情况称为**流水线停顿**，处理器必须等到分支的条件完全评估完毕，浪费宝贵的周期。
- en: To mitigate this, modern processors use something called **branch prediction**
    – they try to predict which way the branch goes. As the branch is encountered
    a greater number of times, it gets more confident as to which way the branch is
    likely to take.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这一问题，现代处理器使用了所谓的**分支预测** - 它们试图预测分支的走向。随着分支遇到的次数增多，它对分支可能走向的方式变得更加自信。
- en: Despite this, the CPU is not omniscient, so if it starts loading the instructions
    of one predicted branch, and later the conditional branch turned out to go the
    other way, the entire pipeline after the branch has to be cleared and the actual
    branch needs to be loaded from scratch. All the work done on the "`assembly line`"
    downstream of the branch instruction has to be discarded and any changes need
    to be reversed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，CPU并不是无所不知的，所以如果它开始加载一个预测的分支的指令，后来条件分支结果是另一种方式，分支后的整个流水线必须被清除，并且实际分支需要从头开始加载。在分支指令之后的“装配线”上所做的所有工作都必须被丢弃，并且任何更改都必须被撤销。
- en: This is a major bottleneck for performance, and it can be avoided – the simplest
    way is to make sure a branch always goes one way as much as possible – like a
    loop.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是性能的一个主要瓶颈，可以避免 - 最简单的方法是尽可能确保分支总是朝着一种方式走 - 就像一个循环一样。
- en: 'Exercise 9: Optimization for Branch Prediction'
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习9：分支预测优化
- en: In this exercise, we will explore and demonstrate the effect of CPU branch prediction
    on performance. To explore this, we'll write two functions in a program – both
    perform the same computation using two nested loops which iterate `100` and `100,000,000`
    times, respectively. The difference between the two functions is that, in the
    first function, the outer loop is the bigger one, whereas in the second function,
    the outer loop is the smaller one.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探讨并展示CPU分支预测对性能的影响。为了探索这一点，我们将在一个程序中编写两个函数，两个函数都使用两个嵌套循环进行相同的计算，分别迭代`100`和`100,000,000`次。两个函数的区别在于，第一个函数中外部循环更大，而第二个函数中外部循环更小。
- en: 'For the first function, the outer loop fails branch prediction only once when
    it exits, but the inner loop fails branch prediction `100,000,000` times – each
    time it exits. For the second one, once again, the outer loop fails branch prediction
    only once when it exits, but the inner loop fails branch prediction only 100 times
    – each time it exits. The factor of `1,000,000` between these branch prediction
    failure counts will result in the first function being slower than the second.
    Perform these steps to complete this exercise:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个函数，外部循环在退出时只有一次分支预测失败，但内部循环在退出时有`100,000,000`次分支预测失败。对于第二个函数，外部循环在退出时也只有一次分支预测失败，但内部循环在退出时只有`100`次分支预测失败。这两个分支预测失败次数之间的因素为`1,000,000`，导致第一个函数比第二个函数慢。完成这个练习的步骤如下：
- en: 'Create a file named **Snippet7.cpp** and include the necessary libraries:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet7.cpp**的文件，并包含必要的库：
- en: '[PRE58]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Define a function named `sum1()` with a nested loop. The outer `for` loop should
    cycle `N` times, whereas the inner for loop should iterate `100` times. Set the
    value of `N` to `100000000`. Write the following code to implement this:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`sum1()`的函数，其中包含一个嵌套循环。外部的`for`循环应该循环`N`次，而内部的循环应该迭代`100`次。将`N`的值设置为`100000000`。编写以下代码来实现这一点：
- en: '[PRE59]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we assume that the processor predicts branches in loops (statistically, the
    branch instruction at the end of the loop is more likely to jump to the start
    of the loop than not), then it will end up mispredicting every time j reaches
    `100` – in other words, `N` times.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设处理器在循环中预测分支（统计上，循环末尾的分支指令更有可能跳转到循环的开头），那么当j达到`100`时，它将每次都预测错误，换句话说，预测错误了`N`次。
- en: 'Define a new function, `sum2()`, with a nested loop. The only change here is
    that we must set the inner loop count to `N` and the outer loop count to `100`.
    Add the following code to implement this:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`sum2()`的新函数，其中包含一个嵌套循环。唯一的变化是，我们必须将内部循环计数设置为`N`，外部循环计数设置为`100`。添加以下代码来实现这一点：
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, our reasoning is that the branch misprediction happens only `100` times.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的推理是分支预测只会发生`100`次。
- en: 'Add the following code in the main function:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中添加以下代码：
- en: '[PRE61]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Save the file and open the terminal. Compile the preceding program, along with
    the **Timer.cpp** file, and time them using the following commands. Remember that
    you need to have the Timer.cpp and Timer.h files you created earlier in the same
    directory:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并打开终端。使用以下命令编译前面的程序，以及**Timer.cpp**文件，并使用以下命令计时。请记住，您需要在同一个目录中拥有您之前创建的Timer.cpp和Timer.h文件：
- en: '[PRE62]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output of executing the previous command is as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令的输出如下：
- en: '![Figure 8.33: Output of the code in Snippet7.cpp showing the effect'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33：Snippet7.cpp中代码的输出显示了分支预测优化的效果'
- en: of branch prediction optimization
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 分支预测优化
- en: '](img/C14583_08_33.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_33.jpg)'
- en: 'Figure 8.33: Output of the code in Snippet7.cpp showing the effect of branch
    prediction optimization'
  id: totrans-436
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.33：Snippet7.cpp中代码的输出显示了分支预测优化的效果
- en: As you can see from the preceding output, there is a small but certainly significant
    speedup of about `2%` that can be attributed to the processor being able to predict
    branches better for the `sum2` function. In the next section, we'll explore more
    optimization techniques.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，由于处理器能够更好地预测`sum2`函数的分支，速度提高了约`2%`，虽然提升很小，但显然是显著的。在下一节中，我们将探讨更多的优化技术。
- en: Further Optimizations
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步优化
- en: 'Several other techniques exist that can be implemented as you code; some of
    them are not guaranteed to produce better code, but it takes very little effort
    to change your coding habits to do these reflexively. They cost nothing but may
    result in gains. A few of these techniques are as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的技术可以在编码时实现；其中一些并不能保证产生更好的代码，但改变编码习惯以自动进行这些改变所需的工作量很小。这些技术中的一些如下：
- en: Pass parameters that are not primitive types by `const` reference when possible.
    Even though `const` reference.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过`const`引用传递非原始类型的参数。即使`const`引用。
- en: Use pre-increment (`++i`) or pre-decrement (`--i`) operators rather than the
    postfix versions. This usually has no utility for simple types such as integers
    but may do so for complex types with a custom increment operator. Getting into
    a habit of writing `++i` rather than `i++` is good practice unless post-increment
    is actually the desired behavior. Apart from performance benefits, such code declares
    the intent more clearly by using the right operator.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过使用前置递增（`++i`）或前置递减（`--i`）运算符而不是后置版本。这通常对于整数等简单类型没有用处，但对于具有自定义递增运算符的复杂类型可能有用。养成使用`++i`而不是`i++`的习惯是一个好习惯，除非后置递增实际上是期望的行为。除了性能上的好处，这样的代码通过使用正确的运算符更清晰地声明了意图。
- en: Declare variables as late as possible – it is common in C to declare every variable
    at the top of a function, but in C++, since variables can have non-trivial constructors,
    it makes sense to only declare them in the actual block where they are used.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能晚地声明变量——在C语言中通常会在函数顶部声明每个变量，但在C++中，由于变量可能具有非平凡的构造函数，只在实际使用它们的块中声明它们是有意义的。
- en: In terms of **loop hoisting**, if there is any code or calculation in a loop
    that does not change with the loop iteration, it makes sense to move it outside
    the loop. This includes creating objects in a loop body. Often, it is more efficient
    to declare them once, outside the loop. Modern compilers do this automatically,
    but it doesn't take extra effort to do this yourself.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**循环提升**方面，如果在循环中有任何不随循环迭代而改变的代码或计算，将其移到循环外是有意义的。这包括在循环体中创建对象。通常情况下，更有效的做法是在循环外声明它们一次。现代编译器会自动执行这些操作，但自己这样做并不需要额外的努力。
- en: Use `const` wherever possible. It does not change the meaning of the code, but
    it lets the compiler make stronger assumptions about your code that may lead to
    better optimization. Apart from this, using `const` makes code more readable and
    reasonable.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用`const`。它不会改变代码的含义，但它让编译器对你的代码做出更强的假设，可能会导致更好的优化。除此之外，使用`const`会使代码更易读和合理。
- en: Integer division, modulus, and multiplication (especially by numbers that are
    not powers of 2) are some of the slowest operations possible on X86 hardware.
    If you need to perform such operations in a loop, perhaps you can do some algebraic
    manipulation to get rid of them.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数除法、模数和乘法（尤其是非2的幂次方的数）是X86硬件上可能最慢的操作之一。如果你需要在循环中执行这样的操作，也许你可以进行一些代数操作来摆脱它们。
- en: As we mentioned, several such optimizations may be done by the compiler itself,
    but doing them as a habit makes the code fast even in debug mode, which is a big
    advantage when debugging. We have examined a few techniques for micro-optimizing
    code already – the level of code change required to do these is relatively minor,
    and some of these can produce major improvements in efficiency. If you want to
    write faster code in general, you should aim to integrate these techniques as
    a default coding style over time. In the next section, we'll learn about cache-friendly
    code.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，编译器本身可能会进行一些这样的优化，但养成这样的习惯可以使代码在调试模式下也变得更快，这在调试时是一个很大的优势。我们已经研究了一些微优化代码的技巧
    - 要做到这一点所需的代码更改程度相对较小，其中一些可以大大提高效率。如果你想写出更快的代码，你应该在一段时间内将这些技巧作为默认的编码风格。在下一节中，我们将学习关于友好缓存的代码。
- en: Cache Friendly Code
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 友好缓存的代码
- en: Computer science was developed in the mid-20th century, when computers hardly
    existed, but nevertheless, by the 1980s, most of the useful data structures and
    algorithms had been discovered and refined. Algorithmic complexity analysis is
    a topic that anyone who learns computer science encounters – and there are well-accepted
    textbook definitions of the complexity of data structure operations. However,
    after 50 years since these things were analyzed, computers have evolved in a way
    that is quite different from what could have been envisaged. For example, a common
    "fact" is that the list data structures are faster for insertion operations than
    arrays. This seems like common sense because inserting an element into an array
    involves moving all the items after that point to new locations, whereas inserting
    into a list is merely a few pointer manipulations. We will test this hypothesis
    in the following exercise.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学是在20世纪中期发展起来的，当时计算机几乎不存在，但尽管如此，到了20世纪80年代，大部分有用的数据结构和算法都已经被发现和完善。算法复杂性分析是任何学习计算机科学的人都会遇到的一个话题
    - 有关数据结构操作复杂性的定义有着公认的教科书定义。然而，50年过去了，计算机的发展方式与当初的设想大不相同。例如，一个常见的“事实”是，列表数据结构对于插入操作比数组更快。这似乎是常识，因为将元素插入数组涉及将该点之后的所有项目移动到新位置，而将元素插入列表只是一些指针操作。我们将在下面的练习中测试这个假设。
- en: 'Exercise 10: Exploring the Effect of Caches on Data Structures'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习10：探索缓存对数据结构的影响
- en: 'In this exercise, we will examine the impact of the cache on arrays and lists
    in the C++ standard library. Perform these steps to complete this exercise:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究缓存对C++标准库中的数组和列表的影响。执行以下步骤来完成这个练习：
- en: Create a file named **Snippet8.cpp**.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet8.cpp**的文件。
- en: 'Include the necessary libraries, along with the **Timer.h** header file. Write
    the following code to implement this:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括必要的库，以及**Timer.h**头文件。编写以下代码来实现这一点：
- en: '[PRE63]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a constant integer variable, `N`, and set its value to `100000`:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`N`的常量整数变量，并将其值设置为`100000`：
- en: '[PRE64]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Initialize a random number generator and create a distribution range from `0`
    to `1000`. Add the following code to achieve this:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个随机数生成器，并创建一个范围从`0`到`1000`的分布。添加以下代码来实现这一点：
- en: '[PRE65]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create a method named `insertRandom()` and insert elements from `0` to `N`
    into a container at random positions. Add the following code to implement this:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`insertRandom()`的方法，并将从`0`到`N`的元素插入到容器的随机位置。添加以下代码来实现这一点：
- en: '[PRE66]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a method named `insertStart()` and insert elements from `0` to `N` into
    a container at the start. Add the following code to implement this:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`insertStart()`的方法，并将从`0`到`N`的元素插入到容器的开头。添加以下代码来实现这一点：
- en: '[PRE67]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a method named `insertEnd()` and insert elements from `0` to `N` into
    a container at the end. Add the following code to implement this:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`insertEnd()`的方法，并将从`0`到`N`的元素插入到容器的末尾。添加以下代码来实现这一点：
- en: '[PRE68]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Write the following code in the `main` method:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中编写以下代码：
- en: '[PRE69]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Save the file and open the terminal. Compile the preceding program, along with
    the **Timer.cpp** file, by writing the following commands:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并打开终端。通过编写以下命令，编译前面的程序以及**Timer.cpp**文件：
- en: '[PRE70]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding command generates the following output:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成以下输出：
- en: '![Figure 8.34: Output of the code in Snippet8.cpp contrasting the timing'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34：Snippet8.cpp中代码的输出对比std::list和std::vector插入的时间'
- en: of std::list and std::vector insertion
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: std::list和std::vector插入
- en: '](img/C14583_08_34.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_34.jpg)'
- en: 'Figure 8.34: Output of the code in Snippet8.cpp contrasting the timing of std::list
    and std::vector insertion'
  id: totrans-472
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.34：Snippet8.cpp中代码的输出对比std::list和std::vector插入的时间
- en: As you can see from the preceding output, the code measures the time taken to
    insert `100000` integers at the start, end, and random locations for `std::vector`
    and `std::list`. The vector clearly wins by a factor of 100 or more for the random
    case, and even the worst case for the vector is 10x faster than the random case
    for the list.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，代码测量了在`std::vector`和`std::list`中在开头、结尾和随机位置插入`100000`个整数所花费的时间。对于随机情况，向量明显胜出了100倍或更多，即使对于向量的最坏情况也比列表的随机情况快10倍。
- en: Why does this happen? The answer lies in the way modern computer architecture
    has evolved. CPU clock speeds have increased from about `1 Mhz` in the early 80s
    to `5 GHz` as of mid-2019 – a speedup of `5,000x` in clock frequency – and while
    the earliest CPUs used multiple cycles per instruction, modern ones execute several
    instructions per cycle on a single core (due to advanced techniques such as pipelining,
    which we described earlier).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会发生这种情况？答案在于现代计算机架构的演变方式。CPU时钟速度从80年代初的约`1 Mhz`增加到2019年中的`5 GHz` - 时钟频率提高了`5,000x`，而最早的CPU使用多个周期执行指令，现代CPU在单个核上每个周期执行多个指令（由于先进的技术，如流水线处理，我们之前描述过）。
- en: For example, the `IDIV` instruction on the original `Intel 8088` took over 100
    clock cycles to complete, whereas on modern processors, it can be completed in
    less than 5 cycles. On the other hand, RAM bandwidth (the time taken to read or
    write a byte of memory) has increased very slowly.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，原始的`Intel 8088`上的`IDIV`指令需要超过100个时钟周期才能完成，而在现代处理器上，它可以在不到5个周期内完成。另一方面，RAM带宽（读取或写入一个字节内存所需的时间）增长非常缓慢。
- en: Historically, processors have increased in speed by a factor of about `16,000x`
    between 1980 and 2010\. At the same time, the speed increase in RAM has been an
    order of magnitude smaller – less than 100x. Thus, it is possible that single
    access to RAM by an instruction causes the CPU to wait for a huge number of clock
    cycles. This would be an unacceptable degradation of performance, and there have
    been a lot of technologies to mitigate this issue. Before we explore this, let's
    measure the impact of memory access in the next exercise.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，处理器在1980年到2010年之间的速度增加了约`16,000x`。与此同时，RAM的速度增加幅度要小得多 - 不到100倍。因此，可能单个指令对RAM的访问导致CPU等待大量时钟周期。这将是性能下降无法接受的，因此已经有很多技术来缓解这个问题。在我们探讨这个问题之前，让我们来测量内存访问的影响。
- en: 'Exercise 11: Measuring the Impact of Memory Access'
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：测量内存访问的影响
- en: 'In this exercise, we will examine the performance impact of randomly accessing
    memory. Perform these steps to complete this exercise:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查随机访问内存的性能影响。执行以下步骤完成这个练习：
- en: Create a new file named **Snippet9.cpp**.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet9.cpp**的新文件。
- en: 'Include the necessary libraries, along with the `SIZE` and `N`, and set their
    values to `100000000`. Also, create a random number generator and a distribution
    range from `0` to `N-1`. Write the following code to implement this:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括必要的库，以及`SIZE`和`N`，并将它们的值设置为`100000000`。还要创建一个随机数生成器和一个范围分布从`0`到`N-1`。编写以下代码来实现这一点：
- en: '[PRE71]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create the `getPRIndex()` function, which returns a pseudo random index between
    `0` and `SIZE-1`, where `SIZE` is the number of elements in the array. Write the
    following code to implement this:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getPRIndex()`函数，返回一个在`0`和`SIZE-1`之间的伪随机索引，其中`SIZE`是数组中元素的数量。编写以下代码来实现这一点：
- en: Note
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE72]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Write a function named `sum1()` that accesses a large array of data randomly
    and sums those elements:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`sum1()`的函数，它随机访问大量数据的数组并对这些元素求和：
- en: '[PRE73]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Write a function named `sum2()` that sums random numbers without any memory
    access:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`sum2()`的函数，对随机数进行求和而不进行任何内存访问：
- en: '[PRE74]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the main function, initialize the vector so that `v[i] == i`, thus, the
    only difference between `sum1()` and `sum2()` is that `sum1()` accesses memory
    and `sum2()` only performs computations. As usual, we use volatile to prevent
    the compiler from removing all the code, since it has no side effects. Write the
    following code in the `main()` function:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，初始化向量，使得`v[i] == i`，因此，`sum1()`和`sum2()`之间唯一的区别是`sum1()`访问内存，而`sum2()`只进行计算。像往常一样，我们使用`volatile`来防止编译器删除所有代码，因为它没有副作用。在`main()`函数中编写以下代码：
- en: '[PRE75]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Save the program and open the terminal. Compile and run the program by writing
    the following commands:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。通过编写以下命令编译和运行程序：
- en: '[PRE76]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding code generates the following output:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了以下输出：
- en: '![Figure 8.35: Output of the code in Snippet9.cpp contrasting the timing'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.35：在Snippet9.cpp中对比代码的输出时间'
- en: of computation versus random memory access
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 计算与随机内存访问
- en: '](img/C14583_08_35.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_35.jpg)'
- en: 'Figure 8.35: Output of the code in Snippet9.cpp contrasting the timing of computation
    versus random memory access'
  id: totrans-497
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.35：在Snippet9.cpp中对比计算与随机内存访问的代码输出时间
- en: From the preceding output, we can clearly see a factor of about `14x` difference
    in performance.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以清楚地看到性能上大约有`14x`的差异。
- en: 'Create a new file named `sum3()` that accesses memory linearly instead of randomly.
    Also, edit the main function. The updated code is as follows:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sum3()`的新文件，它线性访问内存而不是随机访问。还要编辑主函数。更新后的代码如下：
- en: '[PRE77]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Save the file and open the Terminal. Compile and run the program:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并打开终端。编译并运行程序：
- en: '[PRE78]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The preceding commands generate the following output:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了以下输出：
- en: '![Figure 8.36: Output of the code in Snippet10.cpp contrasting the timing'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.36：在Snippet10.cpp中对比代码的输出时间'
- en: of computation versus random and linear memory access
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 计算与随机和线性内存访问
- en: '](img/C14583_08_36.jpg)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_36.jpg)'
- en: 'Figure 8.36: Output of the code in Snippet10.cpp contrasting the timing of
    computation versus random and linear memory access'
  id: totrans-507
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.36：在Snippet10.cpp中对比计算与随机和线性内存访问的代码输出时间
- en: In the preceding output, notice that the memory access is now more than `35`
    times faster than before, and `2.5` times faster than the calculation in `sum2()`.
    We used the random access pattern in `sum1()` to demonstrate the contrast between
    linear and random memory access. What makes linear memory access so much faster
    than random access? The answer lies in two mechanisms in modern processors that
    are used to mitigate the effects of slow memory – **caching** and **prefetch**
    – both of which we will discuss in the following sections.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，请注意，内存访问现在比以前快了`35`倍以上，比`sum2()`中的计算快了`2.5`倍。我们在`sum1()`中使用了随机访问模式，以展示线性和随机内存访问之间的对比。线性内存访问为什么比随机访问快得多？答案在于现代处理器中用于缓解缓慢内存效果的两种机制
    - **缓存**和**预取** - 我们将在以下部分讨论这两种机制。
- en: Caching
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Modern processors have multiple layers of cache memory between the processor
    registers and the RAM. These caches are labeled L1, L2, L3, L4, and so on, where
    L1 is closest to the processor and L4 is the furthest. Every cache layer is faster
    (and usually smaller) than the level below it. Here is an example of the cache/memory
    sizes and latencies for a `Haswell` family processor:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现代处理器在处理器寄存器和RAM之间有多层缓存内存。这些缓存被标记为L1、L2、L3、L4等，其中L1最靠近处理器，L4最远。每个缓存层比下面的级别更快（通常也更小）。以下是`Haswell`系列处理器的缓存/内存大小和延迟的示例：
- en: 'L1: 32 KB, 4 cycles'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L1：32 KB，4个周期
- en: 'L2: 256 KB, 12 cycles'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L2：256 KB，12个周期
- en: 'L3: 6 MB, 20 cycles'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: L3：6 MB，20个周期
- en: 'L4: 128 MB, 58 cycles'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'L4: 128 MB, 58个周期'
- en: 'RAM: many GB, 115 cycles'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM：多GB，115个周期
- en: 'A simple model of how caches work to help performance is as follows: when a
    memory address is accessed, it is looked up in the L1 cache – if found, it is
    retrieved from there. If not, it is looked up in the L2 cache, if not found, then
    the L3 cache and so on – if it wasn''t found in any of the caches, it is fetched
    from memory. When fetched from memory, it is stored in each of the caches for
    faster access later. This method in itself would be fairly useless because it
    would only improve performance if we accessed the same memory address again and
    again.The second aspect, called **prefetching**, is the mechanism that can make
    caches really pay off.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存如何提高性能的一个简单模型是：当访问内存地址时，首先在L1缓存中查找 - 如果找到，则从那里检索。如果没有找到，则在L2缓存中查找，如果没有找到，则在L3缓存中查找，依此类推
    - 如果在任何缓存中都找不到，则从内存中获取。从内存中获取时，它会存储在每个缓存中，以便以后更快地访问。这种方法本身将是相当无用的，因为只有在我们一遍又一遍地访问相同的内存地址时，它才会提高性能。第二个方面，称为**预取**，是可以使缓存真正得到回报的机制。
- en: Prefetching
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预取
- en: Prefetching is a process where, when memory access is performed, nearby data
    is also fetched into caches, even though it was not accessed directly. The first
    aspect of prefetching is related to memory bus granularity – it can be thought
    of as "What is the minimum amount of data that the RAM subsystem can send to the
    processor?". In most modern processors, this is 64 bits – in other words, whether
    you ask for a single byte or a 64-bit value from memory, the entire `machine word`
    of 64 bits that includes that address is read from RAM. This data is stored in
    each layer of cache for faster access later. Obviously, this would immediately
    improve memory performance – say we read a byte of memory at address `0x1000`;
    we also get the 7 other bytes after that address into the caches. If we then access
    the byte at address `0x1001`, it comes from the cache, avoiding expensive RAM
    access.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 预取是一个过程，当执行内存访问时，附近的数据也被提取到缓存中，即使它没有直接被访问。预取的第一个方面与内存总线粒度有关 - 它可以被认为是“RAM子系统可以发送给处理器的最小数据量是多少？”。在大多数现代处理器中，这是64位
    - 换句话说，无论您从内存请求单个字节还是64位值，都会从RAM中读取包含该地址的整个64位`机器字`。这些数据存储在每个缓存层中，以便以后更快地访问。显然，这将立即提高内存性能
    - 假设我们读取地址`0x1000`处的一个字节的内存；我们还将该地址之后的7个字节也放入缓存中。如果我们随后访问地址`0x1001`处的字节，它将来自缓存，避免了昂贵的RAM访问。
- en: The second aspect of prefetch takes this one step further – when the contents
    of the RAM at an address is read, the processor reads not only that memory word,
    but much more. On the x86 family of processors, this is between 32 and 128 bytes.
    This is called the **cache line** size – the processor always writes and reads
    memory in chunks of that size. When the CPU hardware detects that memory is being
    accessed in a linear fashion, it prefetches memory into one cache line, based
    on its prediction of what addresses are likely to be accessed subsequently.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 预取的第二个方面进一步推进了这一点 - 当读取地址处RAM的内容时，处理器不仅读取该内存字，还读取更多。在x86系列处理器上，这介于32到128字节之间。这被称为**缓存行**大小
    - 处理器总是以该大小的块写入和读取内存。当CPU硬件检测到内存以线性方式被访问时，它根据对随后可能被访问的地址的预测，将内存预取到一个缓存行中。
- en: CPUs are very clever in detecting regular access patterns both forwards and
    backwards, and will prefetch efficiently. You can also provide hints to the processor
    using special instructions to make it prefetch data according to the programmer's
    direction. These instructions are provided as intrinsic functions on most compilers
    in order to avoid the use of inline assembly language. When a memory address is
    read or written that is not in a cache, it is termed a **cache miss**, and is
    a very expensive event and to be avoided at all costs. The CPU hardware tries
    its best to mitigate cache misses, but the programmer can analyze and modify the
    data access patterns to reduce cache misses maximally. The description of caching
    here is a simplified model for instructional purposes – in reality, CPUs have
    L1 caches for instructions as well as data, multiple cache lines, and very complex
    mechanisms to make sure that multiple processors can keep their separate caches
    in synchronization.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: CPU非常聪明，可以检测到正向和反向的规律访问模式，并且会有效地进行预取。您还可以使用特殊指令向处理器提供提示，使其根据程序员的指示进行数据预取。这些指令在大多数编译器中提供为内部函数，以避免使用内联汇编语言。当读取或写入不在缓存中的内存地址时，称为**缓存未命中**，这是一个非常昂贵的事件，应尽量避免。CPU硬件会尽最大努力减少缓存未命中，但程序员可以分析和修改数据访问模式，以最大程度地减少缓存未命中。这里对缓存的描述是一个简化的模型，用于教学目的
    - 实际上，CPU具有用于指令和数据的L1缓存，多个缓存行，以及确保多个处理器可以保持其独立缓存同步的非常复杂的机制。
- en: Note
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'A comprehensive description of cache implementations (and lots of other information
    about memory subsystems) can be found in this famous online article: [https://lwn.net/Articles/250967/](https://lwn.net/Articles/250967/).'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 关于缓存实现（以及关于内存子系统的大量其他信息）的全面描述可以在这篇著名的在线文章中找到：[https://lwn.net/Articles/250967/](https://lwn.net/Articles/250967/)。
- en: Effects of Caching on Algorithms
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存对算法的影响
- en: 'Having learned about caches, we can now reason why our first example of vector
    versus list showed surprising results – from a computer science perspective, the
    following is true:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了缓存之后，我们现在可以理解为什么我们对向量与列表的第一个示例显示出了令人惊讶的结果 - 从计算机科学的角度来看，以下是真实的：
- en: '**For a list**:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于列表**：'
- en: Iterating to the Nth position is order N complexity.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代到第N个位置的复杂度为N阶。
- en: Inserting or deleting an element is an order 1 complexity.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入或删除元素的复杂度为1阶。
- en: '**For an array (or vector)**:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于数组（或向量）**：'
- en: Iterating to the Nth position is order 1 complexity.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代到第N个位置的复杂度为1阶。
- en: Inserting or deleting an element at location N has complexity proportional to
    (S - N), where S is the size of the array.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在位置N插入或删除元素的复杂度与（S-N）成正比，其中S是数组的大小。
- en: However, for modern architectures, the cost of a memory access is extremely
    high, but the cost of accessing an adjacent address subsequently is almost 0 because
    it would already be in the cache. This means that the iteration upon elements
    in a `std::list` that are located non-sequentially in memory are likely to always
    cause a cache miss, causing slow performance. On the other hand, since the elements
    of an array or `std::vector` are always adjacent, caching and prefetching would
    reduce the overall cost of copying (S-N) elements to a new location by a very
    large margin. Hence, the traditional analysis of the two data structures that
    declares that lists work better for random insertions, while technically correct,
    is not practically true, especially given the clearly sophisticated caching behavior
    of modern CPU hardware. When our programs are *data bound*, the analysis of algorithm
    complexity has to be augmented by understanding of what is known as **data locality**.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于现代架构，内存访问的成本非常高，但随后访问相邻地址的成本几乎为0，因为它已经在缓存中。这意味着在`std::list`中非顺序地定位的元素上进行迭代很可能总是导致缓存未命中，从而导致性能下降。另一方面，由于数组或`std::vector`的元素总是相邻的，缓存和预取将大大减少将（S-N）个元素复制到新位置的总成本。因此，传统的对两种数据结构的分析声明列表更适合随机插入，虽然在技术上是正确的，但在现代CPU硬件的明显复杂的缓存行为下，实际上并不正确。当我们的程序受到*数据约束*时，算法复杂度的分析必须通过对所谓的**数据局部性**的理解来加以补充。
- en: Data locality can be defined simply as the average distance from the memory
    address that was just accessed to the one that was accessed previously. In other
    words, making memory access across addresses that are far from each other is a
    severe slowdown, since data from closer addresses are likely to have been prefetched
    into the caches. When data is already present in the cache(s), it is termed "hot";
    otherwise, it is termed "cold". Code that takes advantage of the cache is termed
    **cache friendly**. Cache-unfriendly code, on the other hand would cause the cache
    lines to be wastefully reloaded (termed **cache invalidation**). In the remainder
    of this section, we will look at strategies regarding how to write cache-friendly
    code.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 数据局部性可以简单地定义为刚刚访问的内存地址与先前访问的内存地址之间的平均距离。换句话说，跨越彼此相距很远的内存地址进行内存访问会严重减慢速度，因为更接近的地址的数据很可能已经被预取到缓存中。当数据已经存在于缓存中时，称为“热”；否则称为“冷”。利用缓存的代码称为**缓存友好**。另一方面，不友好的缓存代码会导致缓存行被浪费重新加载（称为**缓存失效**）。在本节的其余部分，我们将探讨如何编写缓存友好代码的策略。
- en: Optimizing for Cache-Friendliness
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对缓存友好性进行优化
- en: In the old days, optimization of code involved trying to minimize the number
    of machine instructions in code, using more efficient instructions, and even reordering
    instructions to allow pipelines to remain full. As of this day and age, compilers
    perform all the aforementioned optimization to a level that most programmers would
    be unable to – especially considering that compilers can do it across entire programs
    of hundreds of millions of instructions. What remains firmly the responsibility
    of the programmer even now is the ability to optimize data access patterns to
    take advantage of caching.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，代码的优化涉及尝试最小化代码中的机器指令数量，使用更有效的指令，甚至重新排序指令以使流水线保持满状态。到目前为止，编译器执行了所有上述优化，大多数程序员无法做到这一点——尤其是考虑到编译器可以在数亿条指令的整个程序中执行这些优化。即使在今天，程序员的责任仍然是优化数据访问模式，以利用缓存。
- en: The task is very simple – make sure that memory is accessed close to the memory
    that was accessed before – but the methodology to achieve this can require lots
    of effort.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 任务非常简单——确保内存访问靠近之前访问的内存——但是实现这一点的方法可能需要大量的努力。
- en: Note
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The famous game programmer and code optimization guru Terje Mathisen, in the
    90s, is claimed to have said: "All programming is an exercise in caching." Today,
    in 2019, this statement applies more than ever in this sub-domain of trying to
    write fast code.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的游戏程序员和代码优化大师Terje Mathisen在90年代声称：“所有编程都是缓存的练习。”今天，在2019年，这种说法在尝试编写快速代码的子领域中更加适用。
- en: 'There are some basic rules of thumb for increasing cache-friendliness:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 增加缓存友好性有一些基本的经验法则：
- en: The stack is always "hot", and so we should use local variables as much as possible.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈始终是“热”的，因此我们应尽可能使用局部变量。
- en: Dynamically allocated objects rarely have data locality with each other – avoid
    them or use a preallocated pool of objects so they are in sequential in memory.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配的对象很少具有彼此的数据局部性——避免它们或使用预分配的对象池，使它们在内存中是连续的。
- en: Pointer-based data structures such as trees – and especially lists – consist
    of multiple nodes allocated on the heap, and are very cache unfriendly.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于指针的数据结构，如树——尤其是列表——由堆上分配的多个节点组成，非常不利于缓存。
- en: Runtime dispatch of virtual functions in OO code invalidates the instruction
    cache – avoid a dynamic dispatch in performance-critical code.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OO代码中虚函数的运行时分派会使指令缓存失效——在性能关键代码中避免动态分派。
- en: In the next section, we'll explore the cost of heap allocations.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨堆分配的成本。
- en: 'Exercise 12: Exploring the Cost of Heap Allocations'
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：探索堆分配的成本
- en: 'In this exercise, we will examine the performance impact of dynamically allocated
    memory and examine how heap memory affects the code''s performance. Perform these
    steps to complete this exercise:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将检查动态分配内存的性能影响，并检查堆内存如何影响代码的性能。执行以下步骤完成这个练习：
- en: Create a file named **Snippet11.cpp**.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet11.cpp**的文件。
- en: 'Add the following code to include the necessary libraries:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以包含必要的库：
- en: '[PRE79]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Declare a constant variable, N, and a character array called fruits. Assign
    values to them:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个常量变量N和一个名为fruits的字符数组。为它们赋值：
- en: '[PRE80]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a function named `fun1()` that just loops over each string in fruits,
    copies it to a string, and sums the characters of that string:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fun1()`的函数，只是循环遍历fruits中的每个字符串，将其复制到一个字符串中，并计算该字符串的字符总和：
- en: '[PRE81]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create another function named `sum2()` that uses a locally declared character
    array instead of a string and a loop to copy:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`sum2()`的函数，该函数使用本地声明的字符数组而不是字符串和循环进行复制：
- en: '[PRE82]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Write the following code inside the `main()` function:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数内写入以下代码：
- en: '[PRE83]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Save the file and open the terminal. Compile and run the program:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并打开终端。编译并运行程序：
- en: '[PRE84]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The preceding commands generate the following output:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成以下输出：
- en: '![Figure 8.37: Output of the code in Snippet11.cpp showing the effect of heap
    allocation on the timing'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.37：在Snippet11.cpp中显示堆分配对时间的影响的代码输出'
- en: '](img/C14583_08_37.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_37.jpg)'
- en: 'Figure 8.37: Output of the code in Snippet11.cpp showing the effect of heap
    allocation on the timing'
  id: totrans-562
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.37：在Snippet11.cpp中显示堆分配对时间的影响的代码输出
- en: From the preceding output, notice that `fun2()` is almost twice as fast as `fun1()`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中可以看出，`fun2()`几乎比`fun1()`快一倍。
- en: 'Now, use the `perf` command to profile:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`perf`命令进行性能分析：
- en: '[PRE85]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The preceding command generates the following output:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成以下输出：
- en: '![Figure 8.38: Output of the perf command profiling the code in Snippet11.cpp'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.38：使用perf命令对Snippet11.cpp中的代码进行性能分析的输出'
- en: '](img/C14583_08_38.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_38.jpg)'
- en: 'Figure 8.38: Output of the perf command profiling the code in Snippet11.cpp'
  id: totrans-569
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.38：使用perf命令对Snippet11.cpp中的代码进行性能分析的输出
- en: 'Now, we can check the performance report with the following code:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码检查性能报告：
- en: '[PRE86]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We receive the following output:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![](img/C14583_08_39.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14583_08_39.jpg)'
- en: 'Figure 8.39: Output of the perf command''s timing report for the code in Snippet11.cpp'
  id: totrans-574
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.39：Snippet11.cpp中的代码的perf命令的时间报告输出
- en: In the preceding output, notice that about `33%` of the execution time was taken
    by the `std::string` constructor, `strlen()`, and `memmove()`. All of these are
    associated with the `std::string` that was used in `fun1()`. The heap allocation
    in particular is the slowest operation.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，请注意约`33%`的执行时间被`std::string`构造函数，`strlen()`和`memmove()`占用。所有这些都与`fun1()`中使用的`std::string`相关。特别是堆分配是最慢的操作。
- en: Struct of Arrays Pattern
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组结构模式
- en: In many programs, we often use an array of objects of the same type – these
    could represent records from a database, entities in a game, and so on. A common
    pattern is to iterate through a large array of structures and perform an operation
    on some fields. Even though the structs are sequential in memory, if we access
    only a few of fields, a larger size structure will make caching less effective.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多程序中，我们经常使用相同类型的对象数组 - 这些可以表示数据库中的记录，游戏中的实体等。一个常见的模式是遍历一个大型结构数组并对一些字段执行操作。即使结构体在内存中是连续的，如果我们只访问少数字段，较大的结构体大小将使缓存效果不佳。
- en: The processor may prefetch several structs into cache, but the program only
    accesses a fraction of that cached data. Since it is not using every field of
    each struct, most of the cached data is discarded. To avoid this, another kind
    of data layout can be used – instead of using an **array of structs** (**AoS**)
    pattern, we use a **struct of arrays** (**SoA**) pattern. In the next section,
    we'll solve an exercise wherein we'll examine the performance benefit of using
    the SoA pattern versus the AoS pattern.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器可能会将多个结构预取到缓存中，但程序只访问其中的一小部分数据。由于它没有使用每个结构体的每个字段，大部分缓存数据被丢弃。为了避免这种情况，可以使用另一种数据布局方式
    - 不使用**结构体数组**（AoS）模式，而是使用**数组结构**（SoA）模式。在下一节中，我们将解决一个练习，其中我们将研究使用SoA模式与AoS模式的性能优势。
- en: 'Exercise 13: Using the Struct of Arrays Pattern'
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习13：使用结构数组模式
- en: 'In this exercise, we will examine the performance benefits of using the SoA
    versus AoS pattern. Perform these steps to complete this exercise:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究使用SoA与AoS模式的性能优势。执行以下步骤完成这个练习：
- en: Create a file named **Snippet12.cpp**.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Snippet12.cpp**的文件。
- en: 'Include the necessary libraries, along with the `Timer.h` header file. Initialize
    a random number generator and also create a distribution range from 1 to N-1\.
    Create a constant integer variable, N, and initialize it with a value of 100,000,000\.
    Add the following code to implement this:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括必要的库，以及`Timer.h`头文件。初始化一个随机数生成器，并创建一个从1到N-1的分布范围。创建一个名为N的常量整数变量，并将其初始化为100,000,000。添加以下代码来实现这一点：
- en: '[PRE87]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Write two different ways to represent data -– anarray of structs and a struct
    of arrays. Use six fields of `uint64_t` so that we can emulate a large-sized structure
    that would be more representative of a real- world program:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写两种不同的数据表示方式 - 结构体数组和数组结构。使用六个`uint64_t`字段，以便我们可以模拟一个更具代表性的大型结构，这更符合实际程序的情况：
- en: '[PRE88]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Define two functions, namely `sumAOS` and `sumSOA`, that sum the values in
    `field1`, `field2`, and `field3` for the two preceding data structures. Write
    the following code to implement this:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个函数，即`sumAOS`和`sumSOA`，对前面两种数据结构中的`field1`、`field2`和`field3`的值进行求和。编写以下代码来实现这一点：
- en: '[PRE89]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Write the following code inside the `main` function:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中编写以下代码：
- en: '[PRE90]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Save the program and open the Terminal. Run the program to time it by adding
    the following commands:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存程序并打开终端。运行程序以计时，添加以下命令：
- en: '[PRE91]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The preceding code generates the following output:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成以下输出：
- en: '![Figure 8.40: Output of the code in Snippet12.cpp contrasting the timing'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.40：Snippet12.cpp中代码的输出对比时间'
- en: of the AOS and SOA patterns
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: AOS和SOA模式
- en: '](img/C14583_08_40.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_40.jpg)'
- en: 'Figure 8.40: Output of the code in Snippet12.cpp contrasting the timing of
    the AOS and SOA patterns'
  id: totrans-596
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.40：Snippet12.cpp中代码的输出对比AOS和SOA模式的时间
- en: The struct of arrays approach is twice as fast as the array of structs approach.
    Considering that the addresses of the vectors in the struct would be quite far
    apart, we may wonder why the caching behavior is better in the SoA case. The reason
    is because of how caches are designed – rather than treating a cache as a single
    monolithic block, it is divided into multiple lines, as we discussed earlier.
    When a memory address is accessed, the 32- or 64-bit address is converted into
    a "tag" of a few bits and the cache line associated with that tag is used. Memory
    addresses that are very close together will get the same tag and reach the same
    cache line. If a highly differing address is accessed, it reaches a different
    cache line. The effect of this line-based cache design on our test program is
    that it is as if we have separate independent caches for each vector.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 数组结构的方法比结构数组的方法快两倍。考虑到结构体中向量的地址可能相距甚远，我们可能会想知道为什么在SoA情况下缓存行为更好。原因是缓存的设计方式 -
    而不是将缓存视为单个的单块，它被分成多个行，正如我们之前讨论过的。当访问内存地址时，32位或64位的地址被转换为几位的“标签”，并且与该标签相关联的缓存行被使用。非常接近的内存地址将获得相同的标签并达到相同的缓存行。如果访问高度不同的地址，它将达到不同的缓存行。这种基于行的缓存设计对我们的测试程序的影响是，就好像我们为每个向量有单独的独立缓存一样。
- en: The preceding explanation for cache lines is a very much simplified one, but
    the basic concept of cache lines applies. Code readability may seem slightly worse
    for this structure of array pattern, but considering the increase in performance,
    it is well worth it. This particular optimization becomes more effective as the
    size of the structure grows larger. Also, remember that padding structures can
    inflate their size by a big factor if the fields are of various sizes. We have
    explored the performance effects of memory latency and learned a few ways to help
    the processor's caches be effective. When writing a program that is performance-critical,
    we should keep caching effects in mind. Sometimes, it makes sense to start out
    with a more cache-friendly architecture in the first place. As always, we should
    always measure the performance of code before we attempt to make radical changes
    in data structures. Optimization should be focused on the most time-consuming
    areas of a program and not every part of it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 对于缓存行的前述解释是非常简化的，但缓存行的基本概念适用。对于这种数组模式的结构，代码可读性可能会稍微差一些，但考虑到性能的提高，这是非常值得的。当结构的大小变大时，这种特定的优化变得更加有效。此外，请记住，如果字段的大小不同，填充结构可能会使其大小大大增加。我们已经探讨了内存延迟的性能影响，并学习了一些帮助处理器缓存有效的方法。在编写性能关键的程序时，我们应该牢记缓存效果。有时，最好一开始就从更加缓存友好的架构开始。与往常一样，我们在尝试对数据结构进行根本性更改之前，应该先测量代码的性能。优化应该集中在程序中耗时最长的部分，而不是每个部分。
- en: Algorithmic Optimizations
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算法优化
- en: The simplest form of algorithmic optimization is to look for libraries that
    perform your task – the most popular libraries are highly optimized and well-written.
    For example, the `Boost` library provides many useful libraries that can come
    in handy in many projects, such as `Boost.Geometry`, `Boost.Graph`, `Boost.Interval`,
    and `Boost.Multiprecision`, to mention a few. It is far easier and wiser to use
    a professionally written library than to attempt to create them yourself. For
    example, `Boost.Graph` implements a dozen algorithms to process topological graphs,
    and each of them is highly optimized.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 算法优化的最简单形式是寻找执行您的任务的库-最受欢迎的库经过高度优化和良好编写。例如，`Boost`库提供了许多有用的库，可以在许多项目中派上用场，比如`Boost.Geometry`、`Boost.Graph`、`Boost.Interval`和`Boost.Multiprecision`等。使用专业编写的库比尝试自己创建它们要容易和明智得多。例如，`Boost.Graph`实现了十几种处理拓扑图的算法，每个算法都经过高度优化。
- en: 'Many computations can be reduced to a series of standard algorithms composed
    together – if done correctly, these can result in extremely efficient code – and
    often even be parallelized to take advantage of multiple cores or SIMD by the
    compiler. For the rest of this section, we will take one single program and attempt
    to optimize it in various ways – this will be a word count program with the following
    specifications:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算可以简化为一系列组合在一起的标准算法-如果正确完成，这些算法可以产生极其高效的代码-甚至可以由编译器并行化以利用多个核心或SIMD。在本节的其余部分，我们将采用一个单一程序，并尝试以各种方式对其进行优化-这将是一个具有以下规格的词频统计程序：
- en: To isolate the time taken by disk I/O, we will read the entire file to memory
    before processing.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了分离磁盘I/O所花费的时间，我们将在处理之前将整个文件读入内存。
- en: Unicode support will be ignored, and we will assume English text in ASCII.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将忽略Unicode支持，并假设ASCII中的英文文本。
- en: We will use a large public domain literary text available online as test data.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用在线提供的大型公共领域文学文本作为测试数据。
- en: 'Exercise 14: Optimizing a Word Count Program'
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习14：优化词频统计程序
- en: In this lengthy exercise, we'll optimize a program using various optimization
    techniques. We'll perform the incremental optimization of the practical program.
    The test data that we will be using consists of the book named "A Tale of Two
    Cities", which has been appended together 512 times.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个冗长的练习中，我们将使用各种优化技术来优化程序。我们将对实际程序进行渐进优化。我们将使用的测试数据包括书名为《双城记》的书，已经被合并在一起512次。
- en: Note
  id: totrans-607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The dataset that''s used in this exercise is available here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson8/Exercise14/data.7z](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson8/Exercise14/data.7z).
    You will need to extract this 7zip archive and copy the resulting file, called
    data.txt, into the folder where you work with this exercise.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习中使用的数据集在此处可用：[https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson8/Exercise14/data.7z](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson8/Exercise14/data.7z)。您需要提取此7zip存档，并将生成的名为data.txt的文件复制到您处理此练习的文件夹中。
- en: 'Perform these steps to complete this exercise:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: Write the basic boilerplate code that reads the file (the full code can be found
    in `main()` itself to get the overall execution time.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写读取文件的基本样板代码（完整代码可以在`main()`中找到，以获取整体执行时间。
- en: Note that `push_back` adds a space at the end – this makes sure that the data
    ends with a whitespace, simplifying the algorithms we use.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`push_back`在末尾添加了一个空格-这确保数据以空格结尾，简化了我们使用的算法。
- en: 'Write a basic word count function. The logic is very simple – for every character
    in the string, if the character is not whitespace and the following one is, then
    it is the end of a word and should be counted. Since our boilerplate code has
    added a space at the end, any final word will be counted. This function is defined
    in **Snippet13.cpp**:'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个基本的词频统计函数。逻辑非常简单-对于字符串中的每个字符，如果字符不是空格且后面是空格，则这是一个单词的结尾，应该计数。由于我们的样板代码在末尾添加了一个空格，任何最终单词都将被计数。此函数在**Snippet13.cpp**中定义：
- en: '[PRE92]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let''s compile, run, and get an idea of the performance. We will verify that
    it is working right by comparing the result of our code with the results provided
    by the standard `wc` program:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译、运行，并对性能有一个概念。我们将通过比较我们代码的结果与标准`wc`程序提供的结果来验证它是否正确：
- en: '[PRE93]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We receive the following output:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.41: Output of the code in Snippet13.cpp with a baseline wordcount
    implementation'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.41：Snippet13.cpp中代码的输出，带有基线单词计数实现'
- en: '](img/C14583_08_41.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_41.jpg)'
- en: 'Figure 8.41: Output of the code in Snippet13.cpp with a baseline wordcount
    implementation'
  id: totrans-619
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.41：Snippet13.cpp中代码的输出，带有基线单词计数实现
- en: 'Let''s time the wc program:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计时wc程序：
- en: '[PRE94]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We receive the following output:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.42: Output of timing the wc program'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.42：计时wc程序的输出'
- en: '](img/C14583_08_42.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_42.jpg)'
- en: 'Figure 8.42: Output of timing the wc program'
  id: totrans-625
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.42：计时wc程序的输出
- en: The *wc* program displays the same word count, that is, `71108096`, so we know
    our code is correct. Our code took about `3.6 seconds`, including reading the
    file, which is much slower than wc.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '*wc*程序显示相同的单词计数，即`71108096`，所以我们知道我们的代码是正确的。我们的代码大约花费了`3.6秒`，包括读取文件，比wc慢得多。'
- en: 'Our first strategy to optimize is to see if there is a better way to implement
    `isspace()`. Instead of a function, we can use a lookup table that can tell if
    a character is a space or not (the code for this can be found in **Snippet14.cpp**):'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们优化的第一个策略是看看是否有更好的方法来实现`isspace()`。我们可以使用一个查找表来判断一个字符是否为空格（可以在**Snippet14.cpp**中找到代码）：
- en: '[PRE95]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Remember that boolean variables in C/C++ take on integer values 0 or 1, and
    so we can directly write the following:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，C/C++中的布尔变量取整数值0或1，因此我们可以直接写如下内容：
- en: '[PRE96]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This means we don''t have to write this:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不必写这个：
- en: '[PRE97]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Using booleans directly as numbers can sometimes result in faster code because
    we avoid the conditional logic operators && and ||, which may result in a branch
    instruction.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用布尔值作为数字有时可能会导致更快的代码，因为我们避免了条件逻辑运算符&&和||，这可能会导致分支指令。
- en: 'Compile and test the performance now:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并测试性能：
- en: '[PRE98]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We receive the following output:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.43: Output of the code in Snippet14.cpp'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.43：Snippet14.cpp中代码的输出'
- en: '](img/C14583_08_43.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_43.jpg)'
- en: 'Figure 8.43: Output of the code in Snippet14.cpp'
  id: totrans-639
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.43：Snippet14.cpp中代码的输出
- en: 'We have achieved a speedup of 8x for the word counting code, with the simple
    principle of using a lookup table. Can we do even better than this? Yes – we can
    take the lookup table concept further – for every pair of characters, there are
    four possibilities, which should result in a corresponding action:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用查找表的简单原则，为单词计数代码实现了8倍的加速。我们能做得比这更好吗？是的 - 我们可以进一步应用查找表的概念 - 对于每一对字符，有四种可能性，应该导致相应的动作：
- en: '[Space Space]: No action, [Non-Space Space]: Add 1 to count, [Space Non-Space]:
    No action, [Non-Space, Non-Space]: No action'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[空格 空格]：无操作，[非空格 空格]：将计数加1，[空格 非空格]：无操作，[非空格 非空格]：无操作'
- en: So, we can manufacture a table of `65536` entries (`256 * 256`) to cover all
    possible pairs of characters.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以制作一个包含`65536`个条目（`256 * 256`）的表，以涵盖所有可能的字符对。
- en: 'Write the following code to create the table:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码创建表：
- en: '[PRE99]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The loop to count the words becomes the following (the full code can be found
    in `memcpy()`. The compiler is smart enough to use the CPU memory access instructions
    rather than actually call `memcpy()` for 2 bytes. We have ended up with the loop
    containing no conditional statement, which should make it much faster. Remember
    that X86 architecture is *little-endian* – so a 16-bit value read from a character
    array will have the first character as its LSB and the second as the MSB.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 计算单词的循环变成了以下形式（完整代码可以在`memcpy()`中找到。编译器足够聪明，可以使用CPU内存访问指令，而不是实际调用`memcpy()`来处理2个字节。我们最终得到的循环不包含条件语句，这应该会使它更快。请记住，X86架构是*小端*的
    - 因此从字符数组中读取的16位值将具有第一个字符作为其LSB，第二个字符作为MSB。
- en: 'Now, time the code we wrote:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，计时我们写的代码：
- en: '[PRE100]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![Figure 8.44: Output of the code in Snippet15.cpp'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.44：Snippet15.cpp中代码的输出'
- en: '](img/C14583_08_44.jpg)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_44.jpg)'
- en: 'Figure 8.44: Output of the code in Snippet15.cpp'
  id: totrans-650
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.44：Snippet15.cpp中代码的输出
- en: This larger lookup table resulted in a 1.8x speed improvement for `wordCount()`.
    Let's step back and look at this from another angle so that we can use existing
    the standard library effectively. The advantages of this are two-fold – firstly,
    the code is less prone to errors, and secondly, we could take advantage of the
    parallelization available with some compilers.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更大的查找表使`wordCount()`的速度提高了1.8倍。让我们退一步，从另一个角度来看待这个问题，这样我们就可以有效地使用现有的标准库。这样做的好处有两个
    - 首先，代码不太容易出错，其次，我们可以利用一些编译器提供的并行化功能。
- en: 'Let''s rewrite the version of the program that uses the lookup table for `isspace`
    using the standard algorithms. If we look at the main loop that counts the words,
    we are taking 2 characters, and depending on some logic, we are accumulating 1
    or 0 into the `count` variable. This is a common pattern seen in a lot of code:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写使用查找表来进行`isspace`的程序版本。如果我们看一下计算单词的主循环，我们正在取2个字符，并根据一些逻辑，将1或0累积到`count`变量中。这是许多代码中常见的模式：
- en: '[PRE101]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, `a` and `b` are arrays of size `N`, `X` is an initial value, and `OP`
    and `OP2` are operators. There is a standard algorithm that encapsulates this
    pattern called `std::inner_product` – it takes two sequences, applies an operator
    (OP2) between each pair of elements, and applies another operator (OP) across
    these, starting with an initial value X.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`a`和`b`是大小为`N`的数组，`X`是初始值，`OP`和`OP2`是运算符。有一个标准算法封装了这种模式，叫做`std::inner_product`
    - 它接受两个序列，在每对元素之间应用一个运算符（OP2），并在这些元素之间应用另一个运算符（OP），从初始值X开始。
- en: We can write the function as follows (the full code can be found in `inner_product()`
    call applies the `isWordEnd()` lambda on every `s[n]` and `s[n+1]` and applies
    the standard addition function between the results of these. In effect, we are
    adding 1 to the total when `s[n]` and `s[n+1]` are on a word ending.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将函数写成如下形式（完整代码可以在`inner_product()`调用中找到，它对每个`s[n]`和`s[n+1]`应用`isWordEnd()`
    lambda，并在这些结果之间应用标准的加法函数。实际上，当`s[n]`和`s[n+1]`在一个单词结束时，我们将总数加1。
- en: Note
  id: totrans-656
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Even though this looks like a number of nested function calls, the compiler
    inlines everything and there is no overhead.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像一系列嵌套的函数调用，编译器会将所有内容内联，没有开销。
- en: 'Compile and time the execution of this version:'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和计时执行这个版本：
- en: '[PRE102]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We receive the following output:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.45: Output of the code in Snippet16.cpp'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.45：Snippet16.cpp代码的输出'
- en: '](img/C14583_08_45.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_45.jpg)'
- en: 'Figure 8.45: Output of the code in Snippet16.cpp'
  id: totrans-663
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.45：Snippet16.cpp代码的输出
- en: Surprisingly, the code is slightly faster than our initial looped version in
    **Snippet14.cpp**.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这段代码比我们最初的循环版本**Snippet14.cpp**稍快。
- en: Can we adapt the same code to use the large lookup table? Indeed, we can – the
    new function looks like this (the full code can be found in `memcpy()` to convert
    two consecutive bytes into a word, we use a bitwise `OR` operator to combine them.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否使相同的代码适应大型查找表？的确，我们可以-新函数看起来像这样（完整代码可以在`memcpy()`中找到）将两个连续的字节转换为一个字，我们使用按位`OR`运算符将它们组合起来。
- en: 'Compile and time the code:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和计时代码：
- en: '[PRE103]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We receive the following output:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.46: Output of the code in Snippet17.cpp'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.46：Snippet17.cpp代码的输出'
- en: '](img/C14583_08_46.jpg)'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_46.jpg)'
- en: 'Figure 8.46: Output of the code in Snippet17.cpp'
  id: totrans-671
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.46：Snippet17.cpp代码的输出
- en: This code is not quite as fast as the loop0based version we had in `short` to
    get the index, which requires no computation, but here, we read 2 bytes into a
    `short` with a bitwise operation.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不像我们在`short`中的基于循环的版本那样快，以获取索引，它不需要计算，但在这里，我们使用按位操作将2个字节读入`short`。
- en: 'Now that we have the code where the bulk of the work is done by a standard
    library function, we can now get automatic parallelization for free – compile
    and test as follows:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了大部分工作由标准库函数完成的代码，我们现在可以免费获得自动并行化-编译和测试如下：
- en: '[PRE104]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We receive the following output:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.47: Output of the code in Snippet17.cpp with the parallelized standard
    library'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.47：使用并行化标准库的Snippet17.cpp代码的输出'
- en: '](img/C14583_08_47.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_47.jpg)'
- en: 'Figure 8.47: Output of the code in Snippet17.cpp with the parallelized standard
    library'
  id: totrans-678
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.47：使用并行化标准库的Snippet17.cpp代码的输出
- en: Clearly, it cannot be completely parallelized, so we only get about 2.5x improvement
    in terms of speed, but we got it without having to do anything to the code. Could
    we have made the loop-based code parallelizable in the same way? In theory, yes
    – we could manually use **OpenMP** directives to achieve this; however, it would
    require changes to the code and a knowledge of how to use OpenMP. What about the
    version in **Snippet16.cpp**?
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它不能完全并行化，所以我们在速度方面只获得了大约2.5倍的改进，但我们在不对代码做任何修改的情况下获得了这一点。我们是否可以以同样的方式使基于循环的代码可并行化？理论上是的-我们可以手动使用**OpenMP**指令来实现这一点；然而，这将需要对代码进行更改并且需要知道如何使用OpenMP。**Snippet16.cpp**中的版本呢？
- en: '[PRE105]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We receive the following output:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.48: Output of the code in Snippet16.cpp with the parallelized standard
    library'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.48：使用并行化标准库的Snippet16.cpp代码的输出'
- en: '](img/C14583_08_48.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_48.jpg)'
- en: 'Figure 8.48: Output of the code in Snippet16.cpp with the parallelized standard
    library'
  id: totrans-684
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.48：使用并行化标准库的Snippet16.cpp代码的输出
- en: Similar improvements can be seen for this version too. Are we finished or can
    this be even faster? **Michael Abrash**, a famous game programmer, coined the
    acronym **TANSTATFC** – it stands for "There ain't no such thing as the fastest
    code". What he meant is that, given enough effort, it was always possible to make
    code faster. This seems impossible, but time and again, people have found faster
    and faster ways of performing a computation – our code is no exception and we
    can still go a bit further. One of the tradeoffs we can make for optimization
    is to make the code less general – we already put some constraints on our code
    – for example, that we only handle **ASCII** English text. By adding some more
    constraints on the input data, we can do even better. Let's assume that there
    are no non-printable characters in the file. This is a reasonable assumption for
    our input data. If we assume this, then we can simplify the condition for detecting
    spaces – since all the whitespace characters are greater than or equal to ASCII
    32, we can avoid the lookup table itself.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本也有类似的改进。我们完成了还是可以更快？著名的游戏程序员**Michael Abrash**创造了缩写**TANSTATFC**-它代表“没有最快的代码”。他的意思是，经过足够的努力，总是可以使代码更快。这似乎是不可能的，但一次又一次，人们发现了更快和更快的执行计算的方法-我们的代码也不例外，我们还可以再走一点。我们可以进行优化的权衡之一是使代码不那么通用-我们已经对我们的代码加了一些限制-例如，我们只处理**ASCII**英文文本。通过对输入数据增加一些限制，我们可以做得更好。假设文件中没有不可打印的字符。这对我们的输入数据是一个合理的假设。如果我们假设这一点，那么我们可以简化检测空格的条件-因为所有的空白字符都大于或等于ASCII
    32，我们可以避免查找表本身。
- en: 'Let''s implement the code based on our previous idea (the full code can be
    found in **Snippet18.cpp**):'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们基于我们之前的想法实现代码（完整代码可以在**Snippet18.cpp**中找到）：
- en: '[PRE106]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Compile and run the program:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序：
- en: '[PRE107]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We receive the following output:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.49: Output of the code in Snippet18.cpp with simplified logic for
    detecting spaces'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.49：使用简化逻辑检测空格的Snippet18.cpp代码的输出'
- en: '](img/C14583_08_49.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_49.jpg)'
- en: 'Figure 8.49: Output of the code in Snippet18.cpp with simplified logic for
    detecting spaces'
  id: totrans-693
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.49：使用简化逻辑检测空格的Snippet18.cpp代码的输出
- en: This version is twice as fast as the one that was parallelized, and it is just
    a few lines of code. Will using parallelization improve it even more?
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本比并行化的版本快两倍，而且只是几行代码。使用并行化会使它变得更好吗？
- en: '[PRE108]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We receive the following output:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.50: Output of the code in Snippet18.cpp with the parallelized standard
    library'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.50：使用并行化标准库的Snippet18.cpp代码的输出'
- en: '](img/C14583_08_50.jpg)'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_50.jpg)'
- en: 'Figure 8.50: Output of the code in Snippet18.cpp with the parallelized standard
    library'
  id: totrans-699
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.50：使用并行化标准库的Snippet18.cpp代码的输出
- en: Unfortunately, this is not the case – it is actually slower. The overhead of
    managing multiple threads and thread contention is sometimes more expensive than
    the benefits of multithreaded code. At this point, we can see that the file-read
    code is taking up most of the time – can we do anything about this?
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，情况并非如此-实际上更慢了。管理多个线程和线程争用的开销有时比多线程代码的好处更昂贵。此时，我们可以看到文件读取代码占用了大部分时间-我们能对此做些什么吗？
- en: 'Let''s change the `main()` function to time the individual parts of it (the
    full code can be found in **SnippetWC2.cpp**):'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改`main()`函数以计时其各个部分（完整代码可以在**SnippetWC2.cpp**中找到）：
- en: '[PRE109]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Compile and run the preceding code:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行上述代码：
- en: '[PRE110]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We receive the following output:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.51: Output of the code in Snippet18.cpp with all operations timed'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.51：在Snippet18.cpp中对所有操作进行计时的输出'
- en: '](img/C14583_08_51.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_51.jpg)'
- en: 'Figure 8.51: Output of the code in Snippet18.cpp with all operations timed'
  id: totrans-708
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.51：在Snippet18.cpp中对所有操作进行计时的输出
- en: 'The majority of the time is taken by `push_back()` and copying the string.
    Since the string is exactly the size of the file, `push_back()` ends up allocating
    a new buffer for the string and copying the contents. How can we eliminate this
    `push_back()` call? We appended a space to the end to be able to consistently
    count the last word, if any, since our algorithm counts the ends of words. There
    are three ways to avoid this: count the start of a word, rather than the end;
    count the last word, if any, separately; and use the `c_str()` function so that
    we have a `NUL` character at the end. Let''s try each of these in turn now.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间都用在了`push_back()`和复制字符串上。由于字符串的大小正好等于文件的大小，`push_back()`最终会为字符串分配一个新的缓冲区并复制内容。我们如何消除这个`push_back()`调用呢？我们在末尾添加了一个空格，以便能够一致地计算最后一个单词（如果有的话），因为我们的算法计算的是单词的结尾。有三种方法可以避免这种情况：计算单词的开始而不是结尾；单独计算最后一个单词（如果有的话）；使用`c_str()`函数，这样我们就有了一个`NUL`字符在末尾。现在让我们依次尝试这些方法。
- en: 'First, write the main function without `push_back` (the full code can be found
    in **SnippetWC3.cpp**):'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编写不使用`push_back`的主函数（完整代码可以在**SnippetWC3.cpp**中找到）：
- en: '[PRE111]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Change the code in wordCount() by renaming `isWordEnd()` to `isWordStart()`
    and invert the logic. Consider a word as starting, if the current character is
    a space and the succeeding one is not. Also, count one extra word if the string
    starts with a non-space (the full code can be found in **Snippet19.cpp**):'
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将wordCount()中的代码更改为将`isWordEnd()`重命名为`isWordStart()`并反转逻辑来更改代码。如果当前字符是空格且后续字符不是空格，则将单词视为开始。此外，如果字符串以非空格开头，则额外计算一个单词（完整代码可以在**Snippet19.cpp**中找到）：
- en: '[PRE112]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, write the second alternative – to count the last word, if any. The code
    is almost same as the **Snippet18.cpp** version, except we check for the last
    word (the full code can be found in **Snippet20.cpp**):'
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写第二种替代方案-计算最后一个单词（如果有的话）。代码与**Snippet18.cpp**版本几乎相同，只是我们检查最后一个单词（完整代码可以在**Snippet20.cpp**中找到）：
- en: '[PRE113]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Write the third version that uses `c_str()` – all we need to do is change the
    parameters for `inner_product()` (the full code can be found in `c_str()` has
    a `NUL` at the end, it works as before.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用`c_str()`的第三个版本-我们只需要改变`inner_product()`的参数（完整代码可以在`c_str()`末尾有一个`NUL`，它的工作方式与以前相同。
- en: 'Compile and time all three versions:'
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和计时所有三个版本：
- en: '[PRE114]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We receive the following output:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.52: Output of the code in Snippet19.cpp, which counts the beginnings'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.52：在Snippet19.cpp中代码的输出，该代码计算的是单词的开头'
- en: of words rather than the ends
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是结尾
- en: '](img/C14583_08_52.jpg)'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_52.jpg)'
- en: 'Figure 8.52: Output of the code in Snippet19.cpp, which counts the beginnings
    of words rather than the ends'
  id: totrans-723
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.52：在Snippet19.cpp中代码的输出，该代码计算的是单词的开头而不是结尾
- en: 'Now enter the following command:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入以下命令：
- en: '[PRE115]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We receive the following output:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.53: Output of the code in Snippet20.cpp'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.53：在Snippet20.cpp中代码的输出'
- en: '](img/C14583_08_53.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_53.jpg)'
- en: 'Figure 8.53: Output of the code in Snippet20.cpp'
  id: totrans-729
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.53：在Snippet20.cpp中代码的输出
- en: 'Now enter the following command:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入以下命令：
- en: '[PRE116]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We receive the following output:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.54: Output of the code in Snippet21.cpp'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.54：在Snippet21.cpp中代码的输出'
- en: '](img/C14583_08_54.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_54.jpg)'
- en: 'Figure 8.54: Output of the code in Snippet21.cpp'
  id: totrans-735
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.54：在Snippet21.cpp中代码的输出
- en: All three run in approximately the same time – the minor difference of a few
    milliseconds can be ignored.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个运行时间大致相同-几毫秒的微小差异可以忽略不计。
- en: 'Now, we can tackle the time taken for string copying – instead of using `std::stringstream`,
    we will directly read the file into a string buffer (the full code can be found
    in **SnippetWC4.cpp**):'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以解决字符串复制所花费的时间-我们将直接将文件读入字符串缓冲区，而不是使用`std::stringstream`（完整代码可以在**SnippetWC4.cpp**中找到）：
- en: '[PRE117]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Compile and run this version:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行此版本：
- en: '[PRE118]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We receive the following output:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.55: Output of the code with changed file load code in SnippetWC4.cpp'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55：在SnippetWC4.cpp中更改文件加载代码后的输出'
- en: '](img/C14583_08_55.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_55.jpg)'
- en: 'Figure 8.55: Output of the code with changed file load code in SnippetWC4.cpp'
  id: totrans-744
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.55：在SnippetWC4.cpp中更改文件加载代码后的输出
- en: 'We have now reduced the time taken by our file read code from about 1,000 ms
    to 250 ms – a 4x improvement. The word count code started at about `2,500ms` and
    reduced to about 60 ms – a 40x improvement. The total performance improvement
    for the entire program is 3.6x. We can still ask if this is the limit – indeed,
    TANSTATFC still applies and there are a few more things that can be done: instead
    of reading data into a `std::string`, use `memory-mapped I/O` to get a buffer
    that directly points to the file. This could possibly be faster than allocation
    and reading – it will require changing the word count code to accept a `const
    char*` and a length, or an `std::string_view`. Use a different, faster allocator
    to allocate memory. Compile for the native CPU using the `-march=native` flag.
    However, it seems unlikely that we will be able to get very large performance
    gains from this, since these optimizations have nothing to do with the word counting
    algorithm itself. Another final attempt could be to forego the C++ constructs
    and write inline SIMD code using `compiler intrinsics` (these are the functions
    that the compiler translates directly into single assembly instructions). The
    knowledge that''s required to do this is beyond the scope of this introductory
    material.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将文件读取代码的时间从大约1000毫秒减少到250毫秒-提高了4倍。单词计数代码从大约`2500ms`开始减少到大约60毫秒-提高了40倍。整个程序的总体性能提高了3.6倍。我们仍然可以问这是否是极限-确实，TANSTATFC仍然适用，还有一些其他事情可以做：不要将数据读入`std::string`，而是使用`内存映射I/O`来获取直接指向文件的缓冲区。这可能比分配和读取更快-它将需要更改单词计数代码以接受`const
    char*`和长度，或者`std::string_view`。使用不同的、更快的分配器来分配内存。使用`-march=native`标志为本机CPU进行编译。然而，似乎我们不太可能从中获得非常大的性能提升，因为这些优化与单词计数算法本身无关。另一个最后的尝试可能是放弃C++构造，并使用`编译器内置函数`编写内联SIMD代码（这些函数是编译器直接转换为单个汇编指令的函数）。执行此操作所需的知识超出了本入门材料的范围。
- en: 'Nevertheless, for the curious student, an `AVX2` (256-bit SIMD) version of
    `wordCount()` is provided (Snippet23.cpp). This version needs the input string
    to have a length that is a multiple of 32 and a space at the end. This means that
    the main function has to be rewritten (SnippetWC5.cpp):'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过，对于好奇的学生，提供了`AVX2`（256位SIMD）版本的`wordCount()`（Snippet23.cpp）。这个版本需要输入字符串的长度是32的倍数，并且末尾有一个空格。这意味着主函数必须重新编写（SnippetWC5.cpp）：
- en: '[PRE119]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We receive the following output:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到以下输出：
- en: '![Figure 8.56: Output of the code in Snippet22.cpp that uses SIMD intrinsics'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.56：使用SIMD内置函数的Snippet22.cpp代码的输出'
- en: '](img/C14583_08_56.jpg)'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_56.jpg)'
- en: 'Figure 8.56: Output of the code in Snippet22.cpp that uses SIMD intrinsics'
  id: totrans-751
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.56：使用SIMD内置函数的Snippet22.cpp代码的输出
- en: Note that we need to use the `-march=native` flag so that the compiler uses
    the AVX SIMD instruction set. If the processor does not support it, a compile
    error will result. If this executable is compiled for an AVX target, and run on
    a system where the processor does not support those instructions, the program
    crashes with an "Illegal instruction" exception. There seems to be a very small
    improvement, but not significant – the effort and learning curve required to optimize
    with the assembler or SIMD is usually too high to be justified unless your application
    or industry has those demands. The SIMD version processes 32 bytes at a time –
    yet there is practically no performance improvement. In fact, if you check the
    generated assembly code for the regular C++ implementation in the other snippets
    with the compiler explorer, you will see that the compiler itself has used SIMD
    – this just goes to show how far compilers go in terms of making your code fast.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要使用`-march=native`标志，以便编译器使用AVX SIMD指令集。如果处理器不支持它，将导致编译错误。如果此可执行文件针对AVX目标进行编译，并在不支持这些指令的处理器上运行，则程序将以“非法指令”异常崩溃。似乎有一点小小的改进，但不显著-通常优化与汇编器或SIMD相关的工作量和学习曲线太高，无法证明其合理性，除非您的应用程序或行业有这些需求。SIMD版本一次处理32字节-然而实际上几乎没有性能提升。实际上，如果您检查编译器资源管理器中常规C++实现的生成的汇编代码，您将看到编译器本身已经使用了SIMD-这只是表明编译器在使您的代码快速方面所做的努力。
- en: Another point to note is that our file read and memory allocation is taking
    up most of the time now – leaving aside memory allocation, we can conclude that
    our code has become **I/O bound** as opposed to **CPU bound**. This means that
    no matter how fast we write the code, it will be limited by how fast the data
    can be fetched. We started with a very simple implementation of a word count algorithm,
    increased its complexity and speed, and finally were able to go back to a very
    simple implementation that ended up being the fastest. The overall speed improvement
    for the algorithm was a factor of 40x. We used a number of approaches that ranged
    from just rearranging code a bit, to reimagining the problem in different ways,
    to performing micro-optimizations. No single approach can work all the time, and
    optimization remains a creative endeavor that needs imagination and skill and
    often, lateral thinking. As compilers get smarter and smarter, it gets harder
    and harder to outdo them – yet, the programmer is the only one who actually understands
    the code's intent, and there is always scope to make the code faster.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是，我们的文件读取和内存分配现在占用了大部分时间-撇开内存分配不谈，我们可以得出结论，我们的代码已经变得**I/O限制**而不是**CPU限制**。这意味着无论我们如何快速编写代码，都将受到数据获取速度的限制。我们从一个非常简单的单词计数算法实现开始，增加了其复杂性和速度，最终能够回到一个非常简单的实现，最终成为最快的。算法的整体速度提高了40倍。我们使用了许多方法，从稍微重新排列代码到以不同方式重新构想问题，再到执行微优化。没有一种方法可以始终奏效，优化仍然是一种需要想象力和技巧，通常还需要横向思维的创造性努力。随着编译器变得越来越智能，要超越它变得越来越困难-然而，程序员是唯一真正理解代码意图的人，总是有提高代码速度的空间。
- en: 'Activity 1: Optimizing a Spell Check Algorithm'
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：优化拼写检查算法
- en: In this activity, we will attempt to optimize a program step by step. This activity
    is about a simple spell checker that takes a dictionary and a text file and prints
    out a list of the words in the text that are not present in the dictionary. A
    basic skeleton program is provided in `7zip archive`, that is, `activity1.7z`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将尝试逐步优化一个程序。这个活动是关于一个简单的拼写检查器，它接受一个字典和一个文本文件，并打印出文本中不在字典中的单词列表。在`7zip`存档中提供了一个基本的程序框架，即`activity1.7z`。
- en: The dictionary is taken from the Linux word list that is provided with many
    Linux distributions. The text file is like the one we used in the previous exercise
    – it is the same large file we used in the word count exercise, with all punctuation
    removed and converted into lower case.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 字典取自许多Linux发行版提供的Linux单词列表。文本文件与我们在上一个练习中使用的文件类似 - 它是我们在单词计数练习中使用的同一个大文件，去除了所有标点并转换为小写。
- en: Note that the dictionary is only an example, so do not assume that all valid
    words exist in it – many of the words in the output could well be correctly spelled
    words. The skeleton code reads the dictionary and text files and calls the spell
    check code (which you will write) on it. After that, it compares the resultant
    output with the contents of **out.txt** and prints whether the program worked
    as expected. The function that does the spell check returns a vector of indices
    of the words that were not in the dictionary. Since we are focusing on only the
    spellcheck algorithm, only that code is timed. The time taken for reading the
    files and comparing the output is not taken into consideration. You will develop
    successively faster versions of this program – reference implementations are provided
    in the reference folder as **Speller1.cpp**, **Speller2.cpp**, and so on.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字典只是一个示例，因此不要假设所有有效单词都存在其中 - 输出中的许多单词很可能是拼写正确的单词。框架代码读取字典和文本文件，并调用拼写检查代码（您将编写）进行检查。之后，它将比较结果输出与**out.txt**的内容，并打印程序是否按预期工作。执行拼写检查的函数返回一个不在字典中的单词的索引向量。由于我们只关注拼写检查算法，因此只计时该代码。不考虑读取文件和比较输出所花费的时间。您将开发这个程序的连续更快的版本
    - 参考实现在参考文件夹中提供为**Speller1.cpp**、**Speller2.cpp**等。
- en: At each step, you will be only given hints as to what to change to make it faster
    – only the code in the `getMisspelt()` function is to be modified, and not any
    other code. The student is free to implement the code however they wish, as long
    as it produces the correct results and the code within `main()` is not changed.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个步骤中，您只会得到一些提示，告诉您要做哪些更改以使其更快 - 只能修改`getMisspelt()`函数中的代码，而不是其他任何代码。学生可以自由地实现代码，只要它能产生正确的结果，并且`main()`中的代码没有改变。
- en: Note
  id: totrans-759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Optimization is a creative and non-deterministic process – it is not guaranteed
    nor always possible for the student to come up with the same code as the reference
    implementations. It should not be a surprise if the code that you write does not
    perform as well as the reference implementations. In fact, it may even be possible
    that your code is faster than the reference.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个创造性和非确定性的过程 - 不能保证学生能够编写与参考实现相同的代码，也不总是可能的。如果您编写的代码性能不如参考实现，这不应该让人感到惊讶。事实上，甚至可能您的代码比参考实现更快。
- en: 'Perform the following steps to implement this activity:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这个活动：
- en: Make a copy of Speller.cpp called Speller1.cpp and implement the code for the
    `getMisspelt()` function.Use `std::set` and its `count()` method to implement
    this.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 复制Speller.cpp并将其命名为Speller1.cpp，然后实现`getMisspelt()`函数的代码。使用`std::set`及其`count()`方法来实现。
- en: Write the next version of the program as Speller2.cpp, and then compile it and
    time it as before. Try using `std::unordered_set` rather than `std::set`. You
    should get about a 2x speedup with this implementation.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写程序的下一个版本，命名为Speller2.cpp，然后像以前一样编译并计时。尝试使用`std::unordered_set`而不是`std::set`。使用这种实现应该可以获得大约2倍的加速。
- en: In the final version, **Speller3.cpp**, use a **Bloom filter** data structure
    to implement the spell check algorithm. Experiment with different numbers of hash
    functions and sizes for the bloom filter to see what works best.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终版本**Speller3.cpp**中，使用**Bloom filter**数据结构来实现拼写检查算法。尝试不同数量的哈希函数和Bloom过滤器的大小，看看哪种效果最好。
- en: 'For each of the preceding steps, compile the program and run it as follows
    (change the input file name as required):'
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于前面的每个步骤，编译程序并按如下方式运行（根据需要更改输入文件名）：
- en: '[PRE120]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You should not expect the timings to be exactly as shown here, but if you implement
    the code correctly, the relative improvement in speed should be close to what
    we see here.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该期望计时与此处显示的完全相同，但如果您正确实现了代码，速度上的相对改进应该接近我们在这里看到的情况。
- en: 'After executing the preceding commands for each step, the following outputs
    will be generated. The outputs will show the timing for your code and an initial
    message if your output is correct. The following is the output for Step 1:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个步骤执行前面的命令后，将生成以下输出。输出将显示代码的时间和一个初始消息，如果您的输出是正确的。以下是第1步的输出：
- en: '![Figure 8.57: Example output of the code for Step 1'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.57：第1步代码的示例输出'
- en: '](img/C14583_08_57.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_57.jpg)'
- en: 'Figure 8.57: Example output of the code for Step 1'
  id: totrans-772
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.57：第1步代码的示例输出
- en: 'The following is the output for Step 2:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第2步的输出：
- en: '![Figure 8.58: Example output of the code for Step 2'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.58：第2步代码的示例输出'
- en: '](img/C14583_08_58.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_58.jpg)'
- en: 'Figure 8.58: Example output of the code for Step 2'
  id: totrans-776
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.58：第2步代码的示例输出
- en: 'The following is the output for Step 3:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第3步的输出：
- en: '![Figure 8.59: Example output of the code for Step 3'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.59：第3步代码的示例输出'
- en: '](img/C14583_08_59.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_08_59.jpg)'
- en: 'Figure 8.59: Example output of the code for Step 3'
  id: totrans-780
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.59：第3步代码的示例输出
- en: Note
  id: totrans-781
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 725.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第725页找到。
- en: Summary
  id: totrans-783
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot of complex material in this chapter. Optimizing code is
    a difficult but necessary skill for any modern C++ developer. The demands of machine
    learning, hyper-realistic games, big data analysis, and energy-efficient computing
    make this a very vital area to learn about for any C++ professional. We have learned
    that the process of performance optimization is divided into two stages.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章涵盖了许多复杂的内容。优化代码是任何现代C++开发人员都必须掌握的一项困难但必要的技能。机器学习、超逼真的游戏、大数据分析和节能计算的需求使得这是一个非常重要的领域，任何C++专业人士都需要了解。我们了解到性能优化的过程分为两个阶段。
- en: Firstly, optimization starts with a proper performance measurement strategy,
    with test conditions mirroring real-world data and usage patterns. We have learned
    how to measure performance by various methods – studying assembler code, manual
    timing, source code instrumentation, and using runtime profilers. Once we have
    accurate measurements, we can actually understand which portions of our programs
    are actually slow and focus our efforts there to get the maximum improvements.The
    second stage involves actually modifying the program – we learned about several
    strategies, starting with using the best compiler options for our code, using
    parallelization features, and also using profile data to help the compiler, followed
    by some simple code transformations that produce small but useful performance
    gains without major code changes. We then learned about how to improve performance
    by structuring our loops and conditionals in a way that makes the code more friendly
    to branch prediction.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，优化始于正确的性能测量策略，测试条件要反映真实世界的数据和使用模式。我们学会了如何通过各种方法来测量性能 - 研究汇编代码、手动计时、源代码插装和使用运行时分析器。一旦我们有了准确的测量数据，我们就可以真正理解我们程序中哪些部分实际上很慢，并集中精力在那里以获得最大的改进。第二阶段涉及实际修改程序
    - 我们学习了几种策略，从使用最佳的编译器选项，使用并行化特性，以及使用性能分析数据来帮助编译器，然后进行一些简单的代码转换，产生小但有用的性能提升而不需要进行重大的代码更改。然后，我们学习了如何通过构造循环和条件语句的方式来改善性能，使代码更友好地进行分支预测。
- en: Then, we learned about the dramatic and significant effects of caching on performance
    and looked at some techniques, such as the SOA pattern, to make our code take
    advantage of the caches in modern CPUs. Finally, we put all these things together
    for a real-world example of a word count program and simple spell checker to practice
    what we learned hands-on. There are a lot of other advanced techniques and theory
    that need to be studied over and above the material in this chapter, but what
    we have covered here should give any student a solid foundation for future learning.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解了缓存对性能的显著和重要影响，并研究了一些技术，比如SOA模式，以使我们的代码充分利用现代CPU中的缓存。最后，我们将所有这些东西结合起来，以一个实际的单词计数程序和简单的拼写检查器作为例子，来实践我们所学到的知识。本章涵盖了许多其他高级技术和理论，需要在本章材料之上进行学习，但我们在这里所涵盖的内容应该为任何学生打下坚实的未来学习基础。
- en: By the end of these chapters, you have explored a number of topics related to
    using advanced C++. In the first few chapters, you have learned how to write portable
    software, use the type system to your advantage with templates, and learned to
    use pointers and inheritance effectively. Then you have explored the C++ standard
    library, including streams and concurrency, which are essential tools for building
    large real world applications. In the final sections, you learned how to test
    and debug your programs, and optimize your code to run efficiently. Among the
    widely used programming languages C++ is perhaps the most complex, as well as
    being the most expressive. This book is only a beginning, and would have given
    you a solid platform to continue your further learning.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些章节的学习，你已经探索了许多与使用高级C++相关的主题。在最初的几章中，你学会了如何编写可移植的软件，利用模板来充分利用类型系统，并有效地使用指针和继承。然后你探索了C++标准库，包括流和并发性，这些是构建大型实际应用程序的必要工具。在最后的部分，你学会了如何测试和调试你的程序，并优化你的代码以实现高效运行。在广泛使用的编程语言中，C++也许是最复杂的，同时也是最具表现力的。这本书只是一个开始，它会为你提供一个坚实的平台，以便继续你的学习。
