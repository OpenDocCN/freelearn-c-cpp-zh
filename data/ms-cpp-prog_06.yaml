- en: Multithreaded Programming and Inter-Process Communication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程编程和进程间通信
- en: 'This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to POSIX pthreads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX pthreads简介
- en: Creating threads with the pthreads library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pthreads库创建线程
- en: Thread creation and self-identification
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建和自我识别
- en: Starting a thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动线程
- en: Stopping a thread
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止线程
- en: Using the C++ thread support library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++线程支持库
- en: Data racing and thread synchronization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争和线程同步
- en: Joining and detaching threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入和分离线程
- en: Sending signals from threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从线程发送信号
- en: Passing parameters to threads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: Deadlocks and solutions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁和解决方案
- en: Concurrency
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Future, promise, `packaged_task`, and so on
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Future、promise、`packaged_task`等
- en: Concurrency with the thread support library
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程支持库进行并发
- en: Exception handling in concurrent applications
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发应用程序中的异常处理
- en: Let's learn these topics with a few interesting, easy-to-understand examples
    discussed throughout this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过本章讨论的一些有趣且易于理解的示例来学习这些主题。
- en: Introduction to POSIX pthreads
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX pthreads简介
- en: Unix, Linux, and macOS are largely compliant with the POSIX standard. **Portable
    Operating System Interface for Unix** (**POSIX**) is an IEEE standard that helps
    all Unix and Unix-like operating systems, that is Linux and macOS, communicate
    with a single interface.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Unix、Linux和macOS在很大程度上符合POSIX标准。**Unix可移植操作系统接口**（**POSIX**）是一个IEEE标准，它帮助所有Unix和类Unix操作系统，即Linux和macOS，通过一个统一的接口进行通信。
- en: Interestingly, POSIX is also supported by POSIX-compliant tools--Cygwin, MinGW,
    and Windows subsystem for Linux--that provide a pseudo-Unix-like runtime and development
    environment on Windows platforms.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，POSIX也受到符合POSIX标准的工具的支持--Cygwin、MinGW和Windows子系统 for Linux--它们提供了在Windows平台上的伪Unix样运行时和开发环境。
- en: Note that pthread is a POSIX-compliant C library used in Unix, Linux, and macOS.
    Starting from C++11, C++ natively supports threads via the C++ thread support
    library and concurrent library. In this chapter, we will understand how to use
    pthreads, thread support, and concurrency library in an object-oriented fashion.
    Also, we will discuss the merits of using native C++ thread support and concurrency
    library as opposed to using POSIX pthreads or other third-party threading frameworks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pthread是一个在Unix、Linux和macOS中使用的符合POSIX标准的C库。从C++11开始，C++通过C++线程支持库和并发库本地支持线程。在本章中，我们将了解如何以面向对象的方式使用pthreads、线程支持和并发库。此外，我们将讨论使用本机C++线程支持和并发库与使用POSIX
    pthreads或其他第三方线程框架的优点。
- en: Creating threads with the pthreads library
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pthreads库创建线程
- en: 'Let''s get straight to business. You need to understand the pthread APIs we''ll
    discuss to get your hands dirty. To start with, this function is used to create
    a new thread:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直奔主题。你需要了解我们将讨论的pthread API，开始动手。首先，这个函数用于创建一个新线程：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following table briefly explains the arguments used in the preceding function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要解释了前面函数中使用的参数：
- en: '| **API arguments** | **Comments** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **API参数** | **注释** |'
- en: '| `pthread_t *thread` | Thread handle pointer |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `pthread_t *thread` | 线程句柄指针 |'
- en: '| `pthread_attr_t *attr` | Thread attribute |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `pthread_attr_t *attr` | 线程属性 |'
- en: '| `void *(*start_routine)(void*)` | Thread function pointer |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `void *(*start_routine)(void*)` | 线程函数指针 |'
- en: '| `void * arg` | Thread argument |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `void * arg` | 线程参数 |'
- en: 'This function blocks the caller thread until the thread passed in the first
    argument exits, as shown in the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数阻塞调用线程，直到第一个参数中传递的线程退出，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following table briefly describes the arguments in the preceding function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了前面函数中的参数：
- en: '| **API arguments** | **Comments** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **API参数** | **注释** |'
- en: '| `pthread_t thread` | Thread handle |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `pthread_t thread` | 线程句柄 |'
- en: '| `void **retval` | Output parameter that indicates the exit code of the thread
    procedure |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `void **retval` | 输出参数，指示线程过程的退出代码 |'
- en: 'The ensuing function should be used within the thread context. Here, `retval` is
    the exit code of the thread that indicates the exit code of the thread that invoked
    this function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的函数应该在线程上下文中使用。在这里，`retval`是调用此函数的线程的退出代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s the argument used in this function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中使用的参数如下：
- en: '| **API argument** | **Comment** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **API参数** | **注释** |'
- en: '| `void *retval` | The exit code of the thread procedure |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '`void *retval` | 线程过程的退出代码 |'
- en: 'The following function returns the thread ID:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数返回线程ID：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s write our first multithreaded application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们的第一个多线程应用程序：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to compile and run
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'The program can be compiled with the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令编译该程序：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we need to link the POSIX `pthread` library dynamically.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们需要动态链接POSIX `pthread`库。
- en: 'Check out the following screenshot and visualize the output of the multithreaded
    program:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图，可视化多线程程序的输出：
- en: '![](img/3a98ad57-5892-4cb5-bfaf-fe5e9a44fb81.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a98ad57-5892-4cb5-bfaf-fe5e9a44fb81.png)'
- en: The code that is written in ThreadProc runs within the thread context. The preceding
    program has a total of four threads, including the main thread. I had blocked
    the main thread with `pthread_join` to force it to wait for the other three threads
    to complete their tasks first, failing which the main thread would have exited before
    them. When the main thread exits, the application exits too, which ends up prematurely
    destroying newly created threads.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在ThreadProc中编写的代码在线程上下文中运行。前面的程序总共有四个线程，包括主线程。我使用`pthread_join`阻塞了主线程，强制它等待其他三个线程先完成任务，否则主线程会在它们之前退出。当主线程退出时，应用程序也会退出，这会过早地销毁新创建的线程。
- en: Though we created `thread1`, `thread2`, and `thread3` in the respective sequence,
    there is no guarantee that they will be started in the exact same sequence they
    were created in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们按照相应的顺序创建了`thread1`、`thread2`和`thread3`，但不能保证它们会按照创建的确切顺序启动。
- en: The operating system scheduler decides the sequence in which the threads must
    be started, based on the algorithm used by the operating system scheduler. Interestingly,
    the sequence in which the threads get started might vary at different runs in
    the same system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统调度程序根据操作系统调度程序使用的算法决定必须启动线程的顺序。有趣的是，线程启动的顺序可能在同一系统的不同运行中有所不同。
- en: Does C++ support threads natively?
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++是否原生支持线程？
- en: Starting from C++11, C++ does support threads natively, and it is generally
    referred to as the C++ thread support library. The C++ thread support library
    provides an abstraction over the POSIX pthreads C library. Over time, C++ native
    thread support has improved to a greater extent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++11开始，C++确实原生支持线程，并且通常被称为C++线程支持库。C++线程支持库提供了对POSIX pthreads C库的抽象。随着时间的推移，C++原生线程支持已经得到了很大的改进。
- en: I highly recommend you make use of the C++ native thread over pthreads. The
    C++ thread support library is supported on all platforms as it is officially part
    of standard C++ as opposed to the POSIX `pthread` library, which is only supported
    on Unix, Linux, and macOS but not directly on Windows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您使用C++原生线程而不是pthread。C++线程支持库在所有平台上都受支持，因为它是标准C++的正式部分，而不是仅在Unix、Linux和macOS上直接支持的POSIX
    `pthread`库。
- en: The best part is thread support has matured to a new level in C++17, and it
    is poised to reach the next level in C++20\. Hence, it is a good idea to consider
    using the C++ thread support library in your projects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是C++17中的线程支持已经成熟到了一个新的水平，并且准备在C++20中达到下一个水平。因此，考虑在项目中使用C++线程支持库是一个不错的主意。
- en: How to write a multithreaded application using the native C++ thread feature
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用本机C++线程功能编写多线程应用程序
- en: 'Interestingly, it is pretty simple to write a multithreaded application using
    the C++ thread support library:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，使用C++线程支持库编写多线程应用程序非常简单：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `thread` class was introduced in C++11\. This function can be used to create
    a thread. The equivalent of this function is `pthread_create` in the POSIX `pthread`
    library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`类是在C++11中引入的。此函数可用于创建线程。在POSIX `pthread`库中，此函数的等效函数是`pthread_create`。'
- en: '| **Argument** | **Comment** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **注释** |'
- en: '| `thread_procedure` | Thread function pointer |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `thread_procedure` | 线程函数指针 |'
- en: 'Now a bit about the argument that returns the thread ID in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在稍微了解一下以下代码中返回线程ID的参数：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function is equivalent to the `pthread_self()` function in the POSIX `pthread`
    library. Refer to the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数相当于POSIX `pthread`库中的`pthread_self()`函数。请参考以下代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `join()` function is used to block the caller thread or the main thread
    so it will wait until the thread that has joined completes its task. This is a
    non-static function, so it has to be invoked on a thread object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`函数用于阻塞调用线程或主线程，以便等待已加入的线程完成其任务。这是一个非静态函数，因此必须在线程对象上调用它。'
- en: 'Let''s see how to use the preceding functions to write a simple multithreaded
    program based on C++. Refer to the following program:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用上述函数来基于C++编写一个简单的多线程程序。请参考以下程序：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The C++ version of the multithreaded program looks a lot simpler and cleaner
    than the C version.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++版本的多线程程序看起来比C版本简单得多，更清晰。
- en: How to compile and run
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'The following command helps you compile the program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将帮助您编译程序：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous command, `-std=c++17` instructs the C++ compiler to enable the
    C++17 features; however, the program will compile on any C++ compiler that supports
    C++11, and you just need to replace `c++17` with `c++11`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，`-std=c++17`指示C++编译器启用C++17特性；但是，该程序将在支持C++11的任何C++编译器上编译，您只需要用`c++11`替换`c++17`。
- en: 'The output of the program will look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '![](img/9d2d2907-bab3-470d-aa7d-ba7e3398a604.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2d2907-bab3-470d-aa7d-ba7e3398a604.png)'
- en: 'All the numbers starting with `140` in the preceding screenshot are thread
    IDs. Since we created three threads, three unique thread IDs are assigned respectively
    by the `pthread` library. If you are really keen on finding the thread IDs assigned
    by the operating system, you will have to issue the following command in Linux
    while the application is running:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图中以`140`开头的所有数字都是线程ID。由于我们创建了三个线程，`pthread`库分别分配了三个唯一的线程ID。如果您真的很想找到操作系统分配的线程ID，您将需要在Linux中发出以下命令，同时应用程序正在运行：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Probably to your surprise, the thread ID assigned by the `pthread` library
    will be different from the one assigned by the operating systems. Hence, technically
    the thread ID assigned by the `pthread` library is just a thread handle ID that
    is different from the thread ID assigned by the OS. The other interesting tool
    that you may want to consider is the `top` command to explore the threads that
    are part of the process:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 也许会让你惊讶的是，`pthread`库分配的线程ID与操作系统分配的线程ID是不同的。因此，从技术上讲，`pthread`库分配的线程ID只是一个与操作系统分配的线程ID不同的线程句柄ID。您可能还想考虑的另一个有趣工具是`top`命令，用于探索进程中的线程：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Both the commands require the process ID of your multithreaded application.
    The following command will help you find this ID:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令都需要您多线程应用程序的进程ID。以下命令将帮助您找到此ID：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may also explore the `htop` utility in Linux.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Linux中使用`htop`实用程序。
- en: 'If you want to get the thread ID assigned by the OS programmatically, you can
    use the following function in Linux:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以编程方式获取操作系统分配的线程ID，您可以在Linux中使用以下函数：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, this isn't recommended if you want to write a portable application,
    as this is supported only in Unix and Linux.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想编写一个可移植的应用程序，这并不推荐，因为这仅在Unix和Linux中受支持。
- en: Using std::thread in an object-oriented fashion
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以面向对象的方式使用std::thread
- en: 'If you have been looking for the C++ thread class that looks similar to the
    `Thread` classes in Java or Qt threads, I''m sure you will find this interesting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在寻找类似于Java或Qt线程中的`Thread`类的C++线程类，我相信您会觉得这很有趣：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a wrapper class that works as a convenience class for the C++ thread
    support library in this book. The `Thread::run()` method is our user-defined thread
    procedure. As I don't want the client code to invoke the `Thread::run()` method
    directly, I have declared the run method `private`. In order to start the thread,
    the client code has to invoke the start method on the `thread` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包装类，作为本书中C++线程支持库的便利类。`Thread::run()`方法是我们自定义的线程过程。由于我不希望客户端代码直接调用`Thread::run()`方法，所以我将run方法声明为`private`。为了启动线程，客户端代码必须在`thread`对象上调用start方法。
- en: 'The corresponding `Thread.cpp` source file looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的`Thread.cpp`源文件如下：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From the previous `Thread.cpp` source file, you will have understood that the
    thread can be stopped when required by invoking the `stop` method. It is a simple
    yet decent implementation; however, there are many other corner cases that need
    to be handled before it can be used in production. Nevertheless, this implementation
    is good enough to understand the thread concepts in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的`Thread.cpp`源文件中，你会了解到可以通过调用`stop`方法在需要时停止线程。这是一个简单而体面的实现；然而，在投入生产之前，还有许多其他边缘情况需要处理。尽管如此，这个实现已经足够好，可以理解本书中的线程概念。
- en: 'Cool, let''s see how our `Thread` class can be used in `main.cpp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，让我们看看我们的`Thread`类在`main.cpp`中如何使用：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I have created three threads, and the way the `Thread` class is designed, the
    thread will only start when the `start` function is invoked. The detached threads
    run in the background; usually, you need to detach a thread if you would like
    to make the threads daemons. However, these threads are stopped safely before
    the application quits.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了三个线程，`Thread`类的设计方式是，只有在调用`start`函数时线程才会启动。分离的线程在后台运行；通常，如果要使线程成为守护进程，就需要将线程分离。然而，在应用程序退出之前，这些线程会被安全地停止。
- en: How to compile and run
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'The following command helps compile the program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助编译程序：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the program will be as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下截图所示：
- en: '![](img/18ee2225-4dde-48d5-b3de-6cd417e6424a.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18ee2225-4dde-48d5-b3de-6cd417e6424a.png)'
- en: Wow! We could start and stop the thread as designed and that too in an object-oriented
    fashion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们可以按设计启动和停止线程，而且还是面向对象的方式。
- en: What did you learn?
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么？
- en: 'Let''s try to recollect what we have discussed so far:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着回顾一下我们到目前为止讨论过的内容：
- en: You learned how to write a multithreaded application using the POSIX `pthread`
    C library
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学会了如何使用POSIX的`pthread` C库编写多线程应用程序
- en: C++ compilers support threads natively, starting from C++11
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编译器从C++11开始原生支持线程
- en: You learned the basic C++ thread support library APIs that are commonly used
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学会了常用的基本C++线程支持库API
- en: You learned how to write a multithreaded application using the C++ thread support
    library
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学会了如何使用C++线程支持库编写多线程应用程序
- en: You now know why you should consider using the C++ thread support library over
    the `pthread` C library
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在你知道为什么应该考虑使用C++线程支持库而不是`pthread` C库了
- en: The C++ thread support library is cross-platform, unlike the POSIX `pthread`
    library
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++线程支持库是跨平台的，不像POSIX的`pthread`库
- en: You know how to use the C++ thread support library in an object-oriented fashion
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道如何以面向对象的方式使用C++线程支持库
- en: You know how to write simple multithreaded applications that don't require synchronization
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道如何编写不需要同步的简单多线程应用程序
- en: Synchronizing threads
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步线程
- en: In an ideal world, threads would provide better application performance. But,
    at times, it isn't uncommon to notice that application performance degrades due
    to multiple threads. This performance issue may not be really tied to multiple
    threads; the real culprit could be the design. Too much use of synchronization
    leads to many thread-related issues that also lead to application performance
    degradation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，线程会提供更好的应用程序性能。但是，有时会发现应用程序性能因多个线程而下降并不罕见。这种性能问题可能并不真正与多个线程有关；真正的罪魁祸首可能是设计。过多地使用同步会导致许多与线程相关的问题，也会导致应用程序性能下降。
- en: Lock-free thread designs not only avoid thread-related issues, but also improve
    the overall application performance. However, in a practical world, more than
    one thread may have to share one or more common resources. Hence, there arises
    a need to synchronize the critical section of code that accesses or modifies the
    shared resources. There are a variety of synchronization mechanisms that can be
    used in specific scenarios. In the following sections, we will explore them one
    by one with some interesting and practical use cases.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁线程设计不仅可以避免与线程相关的问题，还可以提高整体应用程序的性能。然而，在实际世界中，可能会有多个线程需要共享一个或多个公共资源。因此，需要同步访问或修改共享资源的关键代码部分。在特定情况下可以使用各种同步机制。在接下来的章节中，我们将逐一探讨一些有趣和实用的使用案例。
- en: What would happen if threads weren't synchronized?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果线程没有同步会发生什么？
- en: When there are multiple threads that share a common resource within the process
    boundary, the critical section of the code can be synchronized with a mutex lock.
    A mutex is a mutually exclusive lock that allows only one thread to access the
    critical block of code that is secured by a mutex. Let's take a simple example
    to understand the need for the mutex lock application practically.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个线程在进程边界内共享一个公共资源时，可以使用互斥锁来同步代码的关键部分。互斥锁是一种互斥锁，只允许一个线程访问由互斥锁保护的关键代码块。让我们通过一个简单的例子来理解互斥锁应用的需求。
- en: 'Let''s take a `Bank Savings Account` class that allows three simple operations,
    that is, `getBalance`, `withdraw`, and `deposit`. The `Account` class can be implemented
    as shown in the following code. For demonstration purposes, the `Account` class
    is designed in a simple fashion neglecting corner cases and validations that are
    required in the real world. It is simplified to the extent that the `Account`
    class doesn''t even bother to capture the account number. I''m sure there are
    many such requirements that are quietly ignored for simplicity. No worries! Our
    focus is to learn mutex here with the shown example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个`Bank Savings Account`类，允许三个简单的操作，即`getBalance`、`withdraw`和`deposit`。`Account`类可以实现如下所示的代码。为了演示目的，`Account`类以简单的方式设计，忽略了现实世界中所需的边界情况和验证。它被简化到`Account`类甚至不需要捕获帐号号码的程度。我相信有许多这样的要求被悄悄地忽略了简单性。别担心！我们的重点是学习mutex，这里展示了一个例子：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Account.cpp` source file looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account.cpp`源文件如下：'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s create two threads, namely `DEPOSITOR` and `WITHDRAWER`. The `DEPOSITOR`
    thread is going to deposit INR 2000.00 while the `WITHDRAWER` thread is going
    to withdraw INR 1000.00 every alternate second. As per our design, the `main.cpp`
    source file can be implemented as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个线程，即`DEPOSITOR`和`WITHDRAWER`。`DEPOSITOR`线程将存入INR 2000.00，而`WITHDRAWER`线程将每隔一秒提取INR
    1000.00。根据我们的设计，`main.cpp`源文件可以实现如下：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you observe the `main` function, the thread constructor takes two arguments.
    The first argument is the thread procedure that you would be familiar with by
    now. The second argument is an optional argument that can be supplied if you would
    like to pass some arguments to the thread function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察`main`函数，线程构造函数接受两个参数。第一个参数是您现在应该熟悉的线程过程。第二个参数是一个可选参数，如果您想要向线程函数传递一些参数，可以提供该参数。
- en: How to compile and run
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'The program can be compiled with the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令编译该程序：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you have followed all the steps as instructed, your code should compile successfully.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照指示的所有步骤进行了操作，您的代码应该可以成功编译。
- en: It's time to execute and observe how our program works!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候执行并观察我们的程序如何工作了！
- en: Don't forget that the `WITHDRAWER` thread always withdraws INR 1000.00, while
    the `DEPOSITOR` thread always deposits INR 2000.00\. The following output conveys
    this at first. The `WITHDRAWER` thread started withdrawing, followed by the `DEPOSITOR`
    thread that seems to have deposited the money.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`WITHDRAWER`线程总是提取INR 1000.00，而`DEPOSITOR`线程总是存入INR 2000.00。以下输出首先传达了这一点。`WITHDRAWER`线程开始提取，然后是似乎已经存入了钱的`DEPOSITOR`线程。
- en: Though we started the `DEPOSITOR` thread first and the `WITHDRAWER` thread next,
    it looks like the OS scheduler seems to have scheduled the `WITHDRAWER` thread
    first. There is no guarantee that this will always happen this way.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们首先启动了`DEPOSITOR`线程，然后启动了`WITHDRAWER`线程，但看起来操作系统调度程序似乎首先安排了`WITHDRAWER`线程。不能保证这种情况总是会发生。
- en: 'Going by the output, by chance, the `WITHDRAWER` thread and the `DEPOSITOR`
    thread seem to do their work alternately. They would continue like this for some
    time. At some point, both the threads would seem to work simultaneously, and that''s
    when things would fall apart, as shown in the output ahead:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，`WITHDRAWER`线程和`DEPOSITOR`线程似乎偶然地交替进行工作。它们会继续这样一段时间。在某个时候，两个线程似乎会同时工作，这就是事情会崩溃的时候，如下所示：
- en: '![](img/92ea367f-1295-4dd9-bc8c-589659755cb9.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92ea367f-1295-4dd9-bc8c-589659755cb9.png)'
- en: It is very interesting to observe the last four lines of the output. It looks
    like both the `WITHDRAWER` and `DEPOSITOR` threads were checking the balance,
    and it was INR 9000.00\. You may notice that there is an inconsistency in the
    `DEPOSITOR` thread's print statements; as per the `DEPOSITOR` thread, the current
    balance is INR 9000.00\. Therefore, when it deposits INR 2000.00, the balance
    should total up to INR 11000.00\. But in reality, the balance after the deposit
    is INR 10000.00\. The reason for this inconsistency is that the `WITHDRAWER` thread
    withdrew INR 1000.00 before the `DEPOSITOR` thread could deposit money. Though
    technically the balance seems to total out correctly, things can go wrong shortly;
    this is when the need for thread synchronization arises.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 观察输出的最后四行非常有趣。看起来`WITHDRAWER`和`DEPOSITOR`线程都在检查余额，余额为INR 9000.00。您可能注意到`DEPOSITOR`线程的打印语句存在不一致；根据`DEPOSITOR`线程，当前余额为INR
    9000.00。因此，当它存入INR 2000.00时，余额应该总共为INR 11000.00。但实际上，存款后的余额为INR 10000.00。这种不一致的原因是`WITHDRAWER`线程在`DEPOSITOR`线程存钱之前提取了INR
    1000.00。尽管从技术上看，余额似乎总共正确，但很快就会出现问题；这就是需要线程同步的时候。
- en: Let's use mutex
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们使用mutex
- en: Now, let's refactor the `threadProc` function and synchronize the critical section
    that modifies and accesses the balance. We need a locking mechanism that will
    only allow one thread to either read or write the balance. The C++ thread support
    library offers an apt lock called `mutex`. The `mutex` lock is an exclusive lock
    that will only allow one thread to operate the critical section code within the
    same process boundary. Until the thread that has acquired the lock releases the
    `mutex` lock, all other threads will have to wait for their turn. Once a thread
    acquires the `mutex` lock, the thread can safely access the shared resource.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`threadProc`函数并同步修改和访问余额的关键部分。我们需要一个锁定机制，只允许一个线程读取或写入余额。C++线程支持库提供了一个称为`mutex`的适当锁。`mutex`锁是一个独占锁，只允许一个线程在同一进程边界内操作关键部分代码。直到获得锁的线程释放`mutex`锁，所有其他线程都必须等待他们的轮次。一旦线程获得`mutex`锁，线程就可以安全地访问共享资源。
- en: 'The `main.cpp` file can be refactored as follows; the changes are highlighted
    in bold:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`文件可以重构如下；更改部分已用粗体标出：'
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may have noticed that the mutex is declared in the global scope. Ideally,
    we could have declared the mutex inside a class as a static member as opposed
    to a global variable. As all the threads are supposed to be synchronized by the
    same mutex, ensure that you use either a global `mutex` lock or a static `mutex`
    lock as a class member.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到互斥锁是在全局范围内声明的。理想情况下，我们可以将互斥锁声明为类的静态成员，而不是全局变量。由于所有线程都应该由同一个互斥锁同步，确保您使用全局`mutex`锁或静态`mutex`锁作为类成员。
- en: 'The refactored `threadProc` in `main.cpp` source file looks as follows; the
    changes are highlighted in bold:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`源文件中重构后的`threadProc`如下所示；改动用粗体标出：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code that is wrapped between `lock()` and `unlock()` is the critical section
    that is synchronized by the mutex lock.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lock()`和`unlock()`之间包裹的代码是由互斥锁锁定的临界区。
- en: As you can see, there are two critical section blocks in the `threadProc` function,
    so it is important to understand that only one thread can enter the critical section.
    For instance, if the depositor thread has entered its critical section, then the
    withdrawal thread has to wait until the depositor thread releases the lock and
    vice versa.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`threadProc`函数中有两个临界区块，因此重要的是要理解只有一个线程可以进入临界区。例如，如果存款线程已经进入了其临界区，那么取款线程必须等到存款线程释放锁，反之亦然。
- en: Technically speaking, we could replace all the raw `lock()` and `unlock()` mutex methods
    with `lock_guard` as this ensures the mutex is always unlocked even if the critical
    section block of the code throws an exception. This will avoid starving and deadlock
    scenarios.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们可以用`lock_guard`替换所有原始的`lock()`和`unlock()`互斥锁方法，因为这样可以确保即使代码的临界区块抛出异常，互斥锁也总是被解锁。这将避免饥饿和死锁情况。
- en: 'It is time to check the output of our refactored program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候检查我们重构后程序的输出了：
- en: '![](img/072965fe-4845-4e62-981a-5fdb53dc2b4a.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/072965fe-4845-4e62-981a-5fdb53dc2b4a.png)'
- en: Great, did you check the balance reported by `DEPOSITOR` and `WITHDRAWER` threads?
    Yep, they are always consistent, aren't they? Yes, the output confirms that the
    code is synchronized and it is thread-safe now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，您检查了`DEPOSITOR`和`WITHDRAWER`线程报告的余额了吗？是的，它们总是一致的，不是吗？是的，输出证实了代码是同步的，现在是线程安全的。
- en: Though our code is functionally correct, there is room for improvement. Let's
    refactor the code to make it object-oriented and efficient.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码在功能上是正确的，但还有改进的空间。让我们重构代码，使其面向对象且高效。
- en: Let's reuse the `Thread` class and abstract all the thread-related stuff inside
    the `Thread` class and get rid of the global variables and `threadProc`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用`Thread`类，并将所有与线程相关的内容抽象到`Thread`类中，并摆脱全局变量和`threadProc`。
- en: 'To start with, let''s observe the refactored `Account.h` header, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们观察重构后的`Account.h`头文件，如下所示：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `Account.h` header hasn't changed as it already looks clean.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Account.h`头文件并没有改变，因为它已经看起来很整洁。
- en: 'The respective `Account.cpp` source file looks as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的`Account.cpp`源文件如下：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is better if the `Account` class is separated from the thread-related functionalities
    to keep things neat. Also, let''s understand how the `Thread` class that we wrote
    could be refactored to use the mutex synchronization mechanism as shown ahead:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将`Account`类与与线程相关的功能分开，以保持代码整洁。此外，让我们了解一下我们编写的`Thread`类如何重构以使用互斥同步机制，如下所示：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `Thread.h` header file shown previously, a couple of changes are done
    as part of refactoring. As we would like to synchronize the threads using a mutex,
    the `Thread` class includes the mutex header of the C++ thread support library.
    As all the threads are supposed to use the same `mutex` lock, the `mutex` instance
    is declared static. Since all the threads are going to share the same `Account`
    object, the `Thread` class has a pointer to the `Account` object as opposed to
    a stack object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前显示的`Thread.h`头文件中，作为重构的一部分进行了一些更改。由于我们希望使用互斥锁来同步线程，`Thread`类包括了C++线程支持库的互斥锁头文件。由于所有线程都应该使用相同的`mutex`锁，因此`mutex`实例被声明为静态。由于所有线程都将共享相同的`Account`对象，因此`Thread`类具有指向`Account`对象的指针，而不是堆栈对象。
- en: The `Thread::run()` method is the `Thread` function that we are going to supply
    to the `Thread` class constructor of the C++ thread support library. As no one
    is expected to invoke the `run` method directly, the `run` method is declared
    private. As per our `Thread` class design, which is similar to Java and Qt, the
    client code would just invoke the `start` method; when the OS scheduler gives
    a green signal to `run`, the `run` thread procedure will be called automatically.
    Actually, there is no magic here since the `run` method address is registered
    as a `Thread` function at the time of creating the thread.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread::run()`方法是我们将要提供给C++线程支持库`Thread`类构造函数的`Thread`函数。由于没有人预期会直接调用`run`方法，因此`run`方法被声明为私有。根据我们的`Thread`类设计，类似于Java和Qt，客户端代码只需调用`start`方法；当操作系统调度程序给予`run`绿灯时，`run`线程过程将自动调用。实际上，这里并没有什么魔术，因为在创建线程时，`run`方法地址被注册为`Thread`函数。'
- en: Generally, I prefer to include all the dependent headers in the user-defined
    header file, and the user-defined source file includes only its own header. This
    helps organize the headers in one place, and this discipline helps maintain the
    code cleaner and also improves the overall readability and code maintainability.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我更喜欢在用户定义的头文件中包含所有依赖的头文件，而用户定义的源文件只包含自己的头文件。这有助于将头文件组织在一个地方，这种纪律有助于保持代码更清晰，也提高了整体可读性和代码可维护性。
- en: 'The `Thread.cpp` source can be refactored as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.cpp`源代码可以重构如下：'
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `threadProc` function that was there in `main.cpp` has moved inside the `Thread`
    class's `run` method. After all, the `main` function or the `main.cpp` source
    file isn't supposed to have any kind of business logic, hence they are refactored
    to improve the code quality.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`threadProc`函数已经移动到`Thread`类的`run`方法中。毕竟，`main`函数或`main.cpp`源文件不应该有任何业务逻辑，因此它们经过重构以改进代码质量。'
- en: 'Now let''s see how clean is the `main.cpp` source file after refactoring:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看重构后的`main.cpp`源文件有多清晰：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previously shown `main()` function and the overall `main.cpp` source file
    looks short and simple without any nasty complex business logic hanging around.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的`main()`函数和整个`main.cpp`源文件看起来简短而简单，没有任何复杂的业务逻辑。
- en: C++ supports five types of mutexes, namely `mutex`, `timed_mutex`, `recursive_mutex`,
    `recursive_timed_mutex`, and `shared_timed_mutex`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持五种类型的互斥锁，即`mutex`、`timed_mutex`、`recursive_mutex`、`recursive_timed_mutex`和`shared_timed_mutex`。
- en: How to compile and run
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'The following command helps you compile the refactored program:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可帮助您编译重构后的程序：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Brilliant! If all goes well, the program should compile smoothly without making
    any noise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！如果一切顺利，程序应该可以顺利编译而不会发出任何噪音。
- en: 'Just take a quick look at the output shown here before we move on to the next
    topic:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个主题之前，快速查看一下这里显示的输出：
- en: '![](img/d415cdd7-497d-413e-93ec-853e66f7c162.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d415cdd7-497d-413e-93ec-853e66f7c162.png)'
- en: Great! It works fine. The `DEPOSITOR` and `WITHDRAWER` threads seem to work
    cooperatively without messing up the balance and print statements. After all,
    we have refactored the code to make the code cleaner without modifying the functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它运行良好。`DEPOSITOR`和`WITHDRAWER`线程似乎可以合作地工作，而不会搞乱余额和打印语句。毕竟，我们已经重构了代码，使代码更清晰，而不修改功能。
- en: What is a deadlock?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死锁是什么？
- en: In a multithreaded application, everything looks cool and interesting until
    we get struck with a deadlock. Assume there are two threads, namely `READER` and
    `WRITER`. Deadlocks might happen when the `READER` thread waits for a lock that
    is already acquired by `WRITER` and the `WRITER` thread waits for the reader to
    release a lock that is owned by `READER` and vice versa. Typically, in a deadlock
    scenario, both the threads will wait for each other endlessly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中，一切看起来都很酷和有趣，直到我们陷入死锁。假设有两个线程，即`READER`和`WRITER`。当`READER`线程等待已被`WRITER`获取的锁时，死锁可能发生，而`WRITER`线程等待读者释放已被`READER`拥有的锁，反之亦然。通常，在死锁场景中，两个线程将无休止地等待对方。
- en: Generally, deadlocks are design issues. At times, deadlocks could be detected
    quickly, but sometimes it might get very tricky to find the root cause. Hence,
    the bottom line is synchronization mechanisms must be used in the right sense
    thoughtfully.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，死锁是设计问题。有时，死锁可能会很快被检测出来，但有时可能会非常棘手，找到根本原因。因此，底线是必须谨慎地正确使用同步机制。
- en: Let's understand the concept of a deadlock with a simple yet practical example.
    I'm going to reuse our `Thread` class with some slight modifications to create
    a deadlock scenario.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单而实用的例子来理解死锁的概念。我将重用我们的`Thread`类，稍作修改以创建死锁场景。
- en: 'The modified `Thread.h` header looks as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`Thread.h`头文件如下所示：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `ThreadType` enumeration helps assign a particular task to a thread. The
    `Thread` class has two new methods: `Thread::getCount()` and `Thread::updateCount()`.
    Both the methods will be synchronized with a common `mutex` lock in such a way
    that it creates a deadlock scenario.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadType`枚举帮助将特定任务分配给线程。`Thread`类有两个新方法：`Thread::getCount()`和`Thread::updateCount()`。这两种方法将以一种共同的`mutex`锁同步，从而创建死锁场景。'
- en: 'Okay, let''s move on and review the `Thread.cpp` source file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们继续并审查`Thread.cpp`源文件：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By now, you will be quite familiar with the `Thread` class. Hence, let's focus
    our discussion on the `Thread::getCount()` and `Thread::updateCount()` methods.
    The `std::lock_guard<std::mutex>` is a template class that frees us from calling
    `mutex::unlock()`. During the stack unwinding process, the `lock_guard` destructor
    will be invoked; this will invoke `mutex::unlock()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该对`Thread`类非常熟悉。因此，让我们专注于`Thread::getCount()`和`Thread::updateCount()`方法的讨论。`std::lock_guard<std::mutex>`是一个模板类，它使我们不必调用`mutex::unlock()`。在堆栈展开过程中，将调用`lock_guard`析构函数；这将调用`mutex::unlock()`。
- en: The bottom line is that from the point the `std::lock_guard<std::mutex>` instance
    is created, all the statements that appear until the end of the method are secured
    by the mutex.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，从创建`std::lock_guard<std::mutex>`实例的那一刻起，直到方法结束的所有语句都受到互斥锁的保护。
- en: 'Okay, let''s plunge into the `main.cpp` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们深入研究`main.cpp`文件：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `main()` function is pretty self-explanatory. We have created two threads,
    namely `reader` and `writer`, and they are started after the respective threads
    are created. The main thread is forced to wait until the reader and writer threads exit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数相当不言自明。我们创建了两个线程，即`reader`和`writer`，它们在创建后启动。主线程被迫等待，直到读者和写者线程退出。'
- en: How to compile and run
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'You can use the following command to compile this program:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令编译此程序：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Observe the output of the program, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察程序的输出，如下所示：
- en: '![](img/8dd5ba71-5a2a-49d6-9f59-d33ddc10bd0a.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dd5ba71-5a2a-49d6-9f59-d33ddc10bd0a.png)'
- en: 'Refer to the code snippets of the `Thread::getCount()` and `Thread::updateCount()`
    methods:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 参考`Thread::getCount()`和`Thread::updateCount()`方法的代码片段：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the previous output screenshot image, we can understand the `WRITER` thread seems
    to have started first. As per our design, the `WRITER` thread will invoke the
    `Thread::updateCount()` method, which in turn will invoke the `Thread::getCount()` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的输出截图图像中，我们可以理解`WRITER`线程似乎已经首先启动。根据我们的设计，`WRITER`线程将调用`Thread::updateCount()`方法，这将调用`Thread::getCount()`方法。
- en: From the output's screenshot, it is evident from the print statements that the
    `Thread::updateCount()` method has acquired the lock first and has then invoked
    the `Thread::getCount()` method. But since the `Thread::updateCount()` method
    hasn't released the mutex lock, there is no way for the `Thread::getCount()` method
    invoked by the `WRITER` thread to proceed. Meanwhile, the OS scheduler has started
    the `READER` thread, which seems to wait for the `mutex` lock acquired by the
    `WRITER` thread. Hence, for the `READER` thread to complete its task, it has to
    acquire the lock on the `Thread::getCount()` method; however, this isn't possible
    until the `WRITER` thread releases the lock. To make things even worse, the `WRITER`
    thread can't complete its task until its own `Thread::getCount()` method call
    completes its task. This is what is called a **deadlock**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的截图中，从打印语句可以明显看出，`Thread::updateCount()`方法首先获取了锁，然后调用了`Thread::getCount()`方法。但由于`Thread::updateCount()`方法没有释放互斥锁，因此由`WRITER`线程调用的`Thread::getCount()`方法无法继续。同时，操作系统调度程序已启动了`READER`线程，似乎在等待`WRITER`线程获取的`mutex`锁。因此，为了完成其任务，`READER`线程必须获取`Thread::getCount()`方法的锁；然而，在`WRITER`线程释放锁之前，这是不可能的。更糟糕的是，`WRITER`线程无法完成其任务，直到其自己的`Thread::getCount()`方法调用完成其任务。这就是所谓的**死锁**。
- en: This is either a design or logical issue. In Unix or Linux, we can make use
    of the Helgrind tool to find deadlocks by racing similar synchronization issues.
    The Helgrind tool comes along with the Valgrind tool. The best part is that both
    Valgrind and Helgrind are open source tools.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这要么是设计问题，要么是逻辑问题。在Unix或Linux中，我们可以使用Helgrind工具通过竞争类似的同步问题来查找死锁。Helgrind工具与Valgrind工具一起提供。最好的部分是，Valgrind和Helgrind都是开源工具。
- en: 'In order to get the source line number that leads to a deadlock or race issue,
    we need to compile our code in debug mode, as shown now with `-g` flag:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得导致死锁或竞争问题的源代码行号，我们需要以调试模式编译我们的代码，如现在所示，使用`-g`标志：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Helgrind tool can be used to detect deadlock and similar issues, as shown
    here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind工具可用于检测死锁和类似问题，如下所示：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here''s a short extract of the Valgrind output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Valgrind输出的简短摘录：
- en: '![](img/aa1738f1-583f-40eb-a110-f6f5500e0adb.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa1738f1-583f-40eb-a110-f6f5500e0adb.png)'
- en: 'One simple fix to resolve the issue is to refactor the `Thread::updateCount()`
    method, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的一个简单方法是重构`Thread::updateCount()`方法，如下所示：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the refactored program is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后程序的输出如下：
- en: '![](img/3a47ef09-189e-4b82-8091-5f9f3b558951.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a47ef09-189e-4b82-8091-5f9f3b558951.png)'
- en: Interestingly, for most complex issues, the solution will be generally very
    simple. In other words, silly mistakes sometimes may lead to serious critical
    bugs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，对于大多数复杂的问题，解决方案通常非常简单。换句话说，有时愚蠢的错误可能导致严重的关键错误。
- en: Ideally, we should strive to prevent the deadlock issue during the design phase
    so that we wouldn't have to break our head doing complex debugging. The C++ thread
    support library mutex class offers `mutex::try_lock()` (since C++11 ), `std::timed_mutex`
    (since C++11), and `std::scoped_lock` ( since C++17 ) to avoid deadlocks and similar
    issues.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该在设计阶段努力防止死锁问题，这样我们就不必在进行复杂的调试时破费心机。C++线程支持库的互斥锁类提供了`mutex::try_lock()`（自C++11以来）、`std::timed_mutex`（自C++11以来）和`std::scoped_lock`（自C++17以来）以避免死锁和类似问题。
- en: What did you learn?
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么？
- en: 'Let''s summarize the takeaway points:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下要点：
- en: We should design lock-free threads when possible
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在可能的情况下设计无锁线程
- en: Lock-free threads tend to perform better compared to heavily synchronized/sequential
    threads
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与重度同步/顺序线程相比，无锁线程往往表现更好
- en: Mutex is a mutually exclusive synchronization primitive
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁是一种互斥同步原语
- en: Mutex helps synchronize the access of shared resources, one thread at a time
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁有助于同步访问共享资源，一次一个线程
- en: Deadlocks occur due to bad use of mutex, or in general, due to bad use of any
    synchronization primitives
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁是由于互斥锁的错误使用，或者一般来说，由于任何同步原语的错误使用而发生的
- en: Deadlocks are the outcome of logical or design issues
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁是逻辑或设计问题的结果
- en: Deadlocks can be detected with the Helgrind/Valgrind open source tools in Unix
    and Linux OS
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unix和Linux操作系统中，可以使用Helgrind/Valgrind开源工具检测死锁
- en: Shared mutex
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享互斥锁
- en: The shared mutex synchronization primitive supports two modes, namely shared
    and exclusive. In the shared mode, the shared mutex will allow many threads to
    share the resource at the same time, without any data race issues. And in the
    exclusive mode, it works just like regular mutex, that is, it will allow only
    one thread to access the resource. This is a suitable lock primitive if you have
    multiple readers that can access the resource safely and you allow only one thread
    to modify the shared resource. Refer to the chapter on C++17 for more details.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 共享互斥锁同步原语支持两种模式，即共享和独占。在共享模式下，共享互斥锁将允许许多线程同时共享资源，而不会出现任何数据竞争问题。在独占模式下，它的工作方式就像常规互斥锁一样，即只允许一个线程访问资源。如果您有多个读者可以安全地访问资源，并且只允许一个线程修改共享资源，这是一个合适的锁原语。有关更多详细信息，请参阅C++17章节。
- en: Conditional variable
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件变量
- en: The conditional variable synchronization primitive is used when two or more
    threads need to communicate with each other and proceed only when they receive
    a particular signal or event. The thread that waits for a particular signal or
    event has to acquire a mutex before it starts waiting for the signal or event.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 条件变量同步原语用于当两个或更多线程需要相互通信，并且只有在它们收到特定信号或事件时才能继续时。等待特定信号或事件的线程必须在开始等待信号或事件之前获取互斥锁。
- en: Let's try to understand the use case of a conditional variable with a producer/consumer
    problem. I'm going to create two threads, namely `PRODUCER` and `CONSUMER`. The
    `PRODUCER` thread will add a value to the queue and notify the `CONSUMER` thread.
    The `CONSUMER` thread will wait for the notification from `PRODUCER`. On receipt
    of the notification from the `PRODUCER` thread, the `CONSUMER` thread will remove
    the entry from the queue and print it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解生产者/消费者问题中条件变量的用例。我将创建两个线程，即`PRODUCER`和`CONSUMER`。`PRODUCER`线程将向队列添加一个值，并通知`CONSUMER`线程。`CONSUMER`线程将等待来自`PRODUCER`的通知。收到来自`PRODUCER`线程的通知后，`CONSUMER`线程将从队列中移除条目并打印它。
- en: 'Let''s understand how the `Thread.h` header shown here makes use of the conditional
    variable and mutex:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下这里显示的`Thread.h`头文件如何使用条件变量和互斥量：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As `PRODUCER` and `CONSUMER` threads are supposed to use the same mutex and
    `conditional_variable`, they are declared static. The conditional variable synchronization
    primitive expects a predicate function that is going to make use of the ready
    boolean flag. Hence, I have declared the ready flag as well in the static scope.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`PRODUCER`和`CONSUMER`线程应该使用相同的互斥量和`conditional_variable`，它们被声明为静态。条件变量同步原语需要一个谓词函数，该函数将使用就绪布尔标志。因此，我也在静态范围内声明了就绪标志。
- en: 'Let''s move on to the `Thread.cpp` source file, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看`Thread.cpp`源文件，如下所示：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding `Thread` class, I used `unique_lock<std::mutex>`. The `conditional_variable::wait()` method
    expects `unique_lock`, hence I'm using `unique_lock` here. Now, `unique_lock<std::mutex>` supports
    ownership transfer, recursive locking, deferred locking, manual locking, and unlocking
    without deleting `unique_lock`, unlike `lock_guard<std::mutex>`. The `lock_guard<std::mutex>` instance
    immediately locks the mutex, and the mutex gets unlocked automatically when the
    `lock_guard<std::mutex>` instance goes out of the scope. However, `lock_guard`
    doesn't support manual unlocking.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Thread`类中，我使用了`unique_lock<std::mutex>`。`conditional_variable::wait()`方法需要`unique_lock`，因此我在这里使用了`unique_lock`。现在，`unique_lock<std::mutex>`支持所有权转移、递归锁定、延迟锁定、手动锁定和解锁，而不像`lock_guard<std::mutex>`那样在删除`unique_lock`时自动解锁。`lock_guard<std::mutex>`实例会立即锁定互斥量，并且当`lock_guard<std::mutex>`实例超出作用域时，互斥量会自动解锁。但是，`lock_guard`不支持手动解锁。
- en: Because we haven't created the `unique_lock` instance with the deferred locking
    option, `unique_lock` will lock the mutex immediately, just like `lock_guard`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有使用延迟锁定选项创建`unique_lock`实例，所以`unique_lock`会立即锁定互斥量，就像`lock_guard`一样。
- en: The `Thread::run()` method is our thread function. Depending on `ThreadType`
    supplied to the `Thread` constructor, the thread instance will behave either as
    the `PRODUCER` or `CONSUMER` thread.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread::run()`方法是我们的线程函数。根据提供给`Thread`构造函数的`ThreadType`，线程实例将作为`PRODUCER`或`CONSUMER`线程来表现。'
- en: The `PRODUCER` thread first locks the mutex and appends an integer to the queue,
    which is shared among `PRODUCER` and `CONSUMER` threads. Once the queue is updated,
    `PRODUCER` will unlock the mutex before notifying `CONSUMER`; otherwise, `CONSUMER`
    will not be able to acquire the mutex and receive the conditional variable signal.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRODUCER`线程首先锁定互斥量，并将整数附加到队列中，该队列在`PRODUCER`和`CONSUMER`线程之间共享。一旦队列更新，`PRODUCER`会在通知`CONSUMER`之前解锁互斥量；否则，`CONSUMER`将无法获取互斥量并接收条件变量信号。'
- en: The `CONSUMER` thread first acquires the mutex and then waits for the conditional
    variable signal. On receipt of the conditional signal, the `CONSUMER` thread retrieves
    the value from the queue and prints the value and resets the ready flag so that
    the process can be repeated until the application is terminated.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONSUMER`线程首先获取互斥量，然后等待条件变量信号。收到条件信号后，`CONSUMER`线程从队列中检索值并打印该值，并重置就绪标志，以便该过程可以重复，直到应用程序终止。'
- en: It is recommended to make use of `unique_lock<std::mutex>`, `lock_guard<std::mutex>`,
    or `scoped_lock<std::mutex>` to avoid deadlocks. At times, it is possible we may
    not unlock the mutex that leads to deadlocks; hence, the use of mutex directly isn't recommended.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`unique_lock<std::mutex>`、`lock_guard<std::mutex>`或`scoped_lock<std::mutex>`来避免死锁。有时，我们可能不会解锁导致死锁；因此，直接使用互斥量不被推荐。
- en: 'Now lets look at the code in the `main.cpp` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`main.cpp`文件中的代码：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How to compile and run
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Compile the program with the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译程序：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following snapshot demonstrates the output of the program:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快照展示了程序的输出：
- en: '![](img/f945fc83-17c2-4831-95c6-21c0888fa75f.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f945fc83-17c2-4831-95c6-21c0888fa75f.png)'
- en: Great! Our condition variable demo works as expected. The producer and consumer
    threads are working together cooperatively with the help of a conditional variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的条件变量演示按预期工作。生产者和消费者线程在条件变量的帮助下合作工作。
- en: What did you learn?
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么？
- en: 'Let me summarize the takeaway points that you learned in this section:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我总结一下你在本节学到的要点：
- en: Multiple threads can work together by signaling each other using a conditional
    variable
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个线程可以通过使用条件变量相互发信号来共同工作
- en: A conditional variable requires the waiting thread to acquire a mutex before
    it can wait for a conditional signal
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件变量要求等待线程在等待条件信号之前获取互斥量。
- en: Every conditional variable requires `unique_lock` that accepts a mutex
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个条件变量都需要接受互斥量的`unique_lock`
- en: The `unique_lock<std::mutex>` method works exactly as `lock_guard<std::mutex>`
    with some additional useful functionalities, such as deferred locking, manual
    lock/unlock, ownership transfer, and so on
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_lock<std::mutex>`方法与`lock_guard<std::mutex>`的工作方式完全相同，还具有一些额外的有用功能，如延迟锁定、手动锁定/解锁、所有权转移等'
- en: '`Unique_lock` helps avoid deadlocks just like `lock_guard`, as the mutex wrapped
    by `unique_lock` gets unlocked automatically when the `unique_lock` instance goes
    out of scope'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unique_lock`像`lock_guard`一样帮助避免死锁，因为被`unique_lock`包装的互斥量在`unique_lock`实例超出作用域时会自动解锁'
- en: You learned how to write a multithreaded application that involves threads that
    signal each other for synchronization
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您学会了如何编写涉及相互信号以进行同步的多线程应用程序
- en: Semaphore
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: Semaphore is yet another useful thread synchronization mechanism. But unlike
    mutex, semaphore allows more than one thread to access similar shared resources
    at the same time. Its synchronization primitive supports two types, that is, binary
    semaphore and counting semaphore.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是另一种有用的线程同步机制。但与互斥锁不同，信号量允许多个线程同时访问相似的共享资源。它的同步原语支持两种类型，即二进制信号量和计数信号量。
- en: Binary semaphore works just like a mutex, that is, only one thread can access
    the shared resource at any point of time. However, the difference is that a mutex
    lock can only be released by the same thread that owns it; however, a semaphore
    lock can be released by any thread. The other notable difference is that generally,
    a mutex works within the process boundary whereas semaphores are used across the process
    boundary. This is because it is a heavyweight lock, unlike the mutex. However,
    a mutex can also be used across the process if created in the shared memory region.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制信号量的工作原理与互斥锁类似，也就是说，任何时候只有一个线程可以访问共享资源。然而，不同之处在于互斥锁只能由拥有它的同一个线程释放；而信号量锁可以被任何线程释放。另一个显著的区别是，一般来说，互斥锁在进程边界内工作，而信号量可以跨进程使用。这是因为它是一种重量级的锁，不像互斥锁。然而，如果在共享内存区域创建，互斥锁也可以跨进程使用。
- en: Counting semaphores let multiple threads share a limited number of shared resources.
    While mutex lets one thread access the shared resource at a time, counting semaphores
    allow multiple threads to share a limited number of resources, which is generally
    at least two or more. If a shared resource has to be accessed one thread at a
    time but the threads are across the process boundary, then a binary semaphore
    can be used. Though the use of a binary semaphore within the same process is a
    possibility as a binary semaphore is heavy, it isn't efficient, but it works within
    the same process as well.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计数信号量允许多个线程共享有限数量的共享资源。而互斥锁一次只允许一个线程访问共享资源，计数信号量允许多个线程共享有限数量的资源，通常至少是两个或更多。如果一个共享资源必须一次只能被一个线程访问，但线程跨越进程边界，那么可以使用二进制信号量。虽然在同一进程内使用二进制信号量是可能的，但它并不高效，但它也可以在同一进程内工作。
- en: Unfortunately, the C++ thread support library doesn't support semaphores and
    shared memory natively until C++17\. C++17 supports lock-free programming using
    atomic operations, which must ensure atomic operations are thread-safe. Semaphores
    and shared memory let threads from other processes modify the shared resources,
    which is quite challenging for the concurrency module to assure thread safety
    of atomic operations across the process boundary. C++20 seems to bet big on concurrency,
    hence we need to wait and watch the move.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++线程支持库直到C++17才原生支持信号量和共享内存。C++17支持使用原子操作进行无锁编程，必须确保原子操作是线程安全的。信号量和共享内存允许来自其他进程的线程修改共享资源，这对并发模块来说是相当具有挑战性的，以确保原子操作在进程边界上的线程安全。C++20似乎在并发方面有所突破，因此我们需要等待并观察其动向。
- en: 'However, it doesn''t stop you from implementing your own semaphore using the
    mutex and conditional variable offered by the thread support library. Developing
    a custom semaphore class that shares common resources within the process boundary
    is comparatively easy, but semaphores come in two flavors: named and unnamed.
    Named semaphore is used to synchronize common resources across the boundary, which
    is tricky.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不妨碍您使用线程支持库提供的互斥锁和条件变量来实现自己的信号量。开发一个在进程边界内共享公共资源的自定义信号量类相对容易，但信号量有两种类型：命名和未命名。命名信号量用于同步跨进程的公共资源，这有些棘手。
- en: Alternatively, you could write a wrapper class around the POSIX pthreads semaphore
    primitive, which supports both named and unnamed semaphores. If you are developing
    a cross-platform application, writing portable code that works across all platforms
    is a requirement. If you go down this road, you may end up writing platform-specific
    code for each platform--yes, I heard it; sounds weird, right?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以编写一个围绕POSIX pthreads信号量原语的包装类，支持命名和未命名信号量。如果您正在开发跨平台应用程序，编写能够在所有平台上运行的可移植代码是必需的。如果您选择这条路，您可能最终会为每个平台编写特定的代码-是的，我听到了，听起来很奇怪，对吧？
- en: The Qt application framework supports semaphores natively. The use of the Qt
    Framework is a good choice as it is cross-platform. The downside is that the Qt
    Framework is a third-party framework.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Qt应用程序框架原生支持信号量。使用Qt框架是一个不错的选择，因为它是跨平台的。缺点是Qt框架是第三方框架。
- en: The bottom line is you may have to choose between pthreads and the Qt Framework
    or refactor your design and try to solve things with native C++ features. Restricting
    your application development using only C++ native features is difficult but guarantees
    portability across all platforms.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，您可能需要在pthread和Qt框架之间做出选择，或者重新设计并尝试使用本机C++功能解决问题。仅使用C++本机功能限制应用程序开发是困难的，但可以保证在所有平台上的可移植性。
- en: Concurrency
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Every modern programming language supports concurrency, offering high-level
    APIs that allow the execution of many tasks simultaneously. C++ supports concurrency
    starting from C++11 and more sophisticated APIs got added further in C++14 and
    C++17\. Though the C++ thread support library allows multithreading, it requires
    writing lengthy code using complex synchronizations; however, concurrency lets
    us execute independent tasks--even loop iterations can run concurrently without
    writing complex code. The bottom line is parallelization is made more easy with
    concurrency.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每种现代编程语言都支持并发，提供高级API，允许同时执行许多任务。C++从C++11开始支持并发，并在C++14和C++17中进一步添加了更复杂的API。尽管C++线程支持库允许多线程，但需要编写复杂的同步代码；然而，并发让我们能够执行独立的任务-甚至循环迭代可以并发运行而无需编写复杂的代码。总之，并行化通过并发变得更加容易。
- en: The concurrency support library complements the C++ thread support library.
    The combined use of these two powerful libraries makes concurrent programming
    more easy in C++.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 并发支持库是C++线程支持库的补充。这两个强大库的结合使用使得在C++中进行并发编程更加容易。
- en: 'Let''s write a simple `Hello World` program using C++ concurrency in the following
    file named `main.cpp`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在名为`main.cpp`的以下文件中使用C++并发编写一个简单的`Hello World`程序：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let's try to understand the `main()` function. Future is an object of the concurrency
    module that helps the caller function retrieve the message passed by the thread
    in an asynchronous fashion. The void in `future<void>` represents the `sayHello()` thread
    function that is not expected to pass any message to the caller, that is, the
    `main` thread function. The `async` class lets us execute a function in two modes,
    namely `launch::async` or `launch::deferred` mode.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着理解`main()`函数。Future是并发模块的一个对象，它帮助调用函数以异步方式检索线程传递的消息。`future<void>`中的void表示`sayHello()`线程函数不会向调用者传递任何消息，也就是说，`main`线程函数。`async`类让我们以`launch::async`或`launch::deferred`模式执行函数。
- en: The `launch::async` mode lets the `async` object launch the `sayHello()` method
    in a separate thread, whereas the `launch::deferred` mode lets the `async` object
    invoke the `sayHello()` function without creating a separate thread. In `launch::deferred` mode,
    the `sayHello()` method invocation will be different until the caller thread invokes
    the `future::get()` method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch::async`模式让`async`对象在一个单独的线程中启动`sayHello()`方法，而`launch::deferred`模式让`async`对象在不创建单独线程的情况下调用`sayHello()`函数。在`launch::deferred`模式下，直到调用线程调用`future::get()`方法之前，`sayHello()`方法的调用将不同。'
- en: The `futureObj.wait()` voice is used to block the main thread to let the `sayHello()`
    function complete its task. The `future::wait()` function is similar to `thread::join()` in
    the thread support library.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`futureObj.wait()`方法用于阻塞主线程，让`sayHello()`函数完成其任务。`future::wait()`函数类似于线程支持库中的`thread::join()`。'
- en: How to compile and run
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s launch `concurrency.exe`, as shown ahead, and understand how it works:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动`concurrency.exe`，如下所示，并了解它是如何工作的：
- en: '![](img/8078a31d-2876-4248-87e8-4ff59fe0aa1c.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8078a31d-2876-4248-87e8-4ff59fe0aa1c.png)'
- en: Asynchronous message passing using the concurrency support library
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发支持库进行异步消息传递
- en: 'Let''s slightly modify `main.cpp`, the Hello World program we wrote in the previous
    section. Let''s understand how we could pass a message from a `Thread` function
    to the caller function asynchronously:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改`main.cpp`，我们在上一节中编写的Hello World程序。让我们了解如何可以从`Thread`函数异步地向调用函数传递消息：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the previous program, `promiseObj` is used by the `sayHello()` thread function
    to pass the message to the main thread asynchronously. Note that `promise<string>` implies
    that the `sayHello()` function is expected to pass a string message, hence the
    main thread retrieves `future<string>`. The `future::get()` function call will
    be blocked until the `sayHello()` thread function calls the `promise::set_value()`
    method.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`promiseObj`被`sayHello()`线程函数用来异步向主线程传递消息。请注意，`promise<string>`意味着`sayHello()`函数预期传递一个字符串消息，因此主线程检索`future<string>`。`future::get()`函数调用将被阻塞，直到`sayHello()`线程函数调用`promise::set_value()`方法。
- en: However, it is important to understand that `future::get()` must only be called
    once as the corresponding `promise` object will be destructed after the call to
    the `future::get()` method invocation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要理解`future::get()`只能被调用一次，因为在调用`future::get()`方法之后，相应的`promise`对象将被销毁。
- en: Did you notice the use of the `std::move()` function? The `std::move()` function
    basically transfers the ownership of `promiseObj` to the `sayHello()` thread function,
    hence `promiseObj` must not be accessed from the `main` thread after `std::move()`
    is invoked.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了`std::move()`函数的使用吗？`std::move()`函数基本上将`promiseObj`的所有权转移给了`sayHello()`线程函数，因此在调用`std::move()`后，`promiseObj`不能从`main`线程中访问。
- en: How to compile and run
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Observe how the `concurrency.exe` application works by launching `concurrency.exe`
    as shown ahead:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动`concurrency.exe`应用程序来观察`concurrency.exe`的工作方式。
- en: '![](img/7b7570b5-d92a-42c8-813d-02b2a66eb9f7.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b7570b5-d92a-42c8-813d-02b2a66eb9f7.png)'
- en: As you may have guessed, the output of this program is exactly the same as our
    previous version. But this version of our program makes use of promise and future
    objects, unlike the previous version that doesn't support message passing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这个程序的输出与我们之前的版本完全相同。但是我们的这个程序版本使用了promise和future对象，而之前的版本不支持消息传递。
- en: Concurrency tasks
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发任务
- en: The concurrency support module supports a concept called **task**. A task is
    work that happens concurrently across threads. A concurrent task can be created
    using the `packaged_task` class. The `packaged_task` class conveniently connects
    the `thread` function, the corresponding promise, and feature objects.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 并发支持模块支持一种称为**任务**的概念。任务是跨线程并发发生的工作。可以使用`packaged_task`类创建并发任务。`packaged_task`类方便地连接了`thread`函数、相应的promise和future对象。
- en: 'Let''s understand the use of `packaged_task` with a simple example. The following
    program gives us an opportunity to taste a bit of functional programming with
    lambda expressions and functions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来了解`packaged_task`的用法。以下程序为我们提供了一个机会，尝试一下使用lambda表达式和函数进行函数式编程：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the previously shown program, I created a `packaged_task` instance called
    `addTask`. The `packaged_task< int (int,int)>` instance implies that the add task
    will return an integer and take two integer arguments:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面展示的程序中，我创建了一个名为`addTask`的`packaged_task`实例。`packaged_task< int (int,int)>`实例意味着add任务将返回一个整数并接受两个整数参数：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code snippet indicates it is a lambda function that is defined
    anonymously.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段表明这是一个匿名定义的lambda函数。
- en: The interesting part is that the `addTask( )` call in `main.cpp` appears like
    a regular function call. The `future<int>` object is extracted from the `packaged_task`
    instance `addTask`, which is then used to retrieve the output of the `addTask`
    via the future object instance, that is, the `get()` method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在`main.cpp`中的`addTask()`调用看起来像是普通的函数调用。`future<int>`对象是从`packaged_task`实例`addTask`中提取出来的，然后用于通过`future`对象实例`get()`方法检索`addTask`的输出。
- en: How to compile and run
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序：
- en: '[PRE49]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s quickly launch `concurrency.exe` and observe the output shown next:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速启动`concurrency.exe`并观察下一个显示的输出：
- en: '![](img/4e6a6e22-2c5d-40c4-a47c-c1749a91adb3.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e6a6e22-2c5d-40c4-a47c-c1749a91adb3.png)'
- en: Cool! You learned how to use lambda functions with the concurrency support library.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您学会了如何在并发支持库中使用lambda函数。
- en: Using tasks with a thread support library
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程支持库的任务
- en: 'In the previous section, you learned how `packaged_task` can be used in an
    elegant way. I love lambda functions a lot. They look a lot like mathematics.
    But not everyone likes lambda functions as they degrade readability to some extent.
    Hence, it isn''t mandatory to use lambda functions with a concurrent task if you
    don''t prefer lambdas. In this section, you''ll understand how to use a concurrent
    task with the thread support library, as shown in the following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学会了如何以一种优雅的方式使用`packaged_task`。我非常喜欢lambda函数。它们看起来很像数学。但并不是每个人都喜欢lambda函数，因为它们在一定程度上降低了可读性。因此，如果您不喜欢lambda函数，就没有必要在并发任务中使用它们。在本节中，您将了解如何在线程支持库中使用并发任务，如下所示：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to compile and run
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s launch `concurrency.exe`, as shown in the following screenshot, and
    understand the difference between the previous program and the current version:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动`concurrency.exe`，如下截图所示，并了解先前程序和当前版本之间的区别：
- en: '![](img/fad1187b-ffbf-418d-9529-b0d791603f2e.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fad1187b-ffbf-418d-9529-b0d791603f2e.png)'
- en: Yes, the output is the same as the previous section because we just refactored
    the code.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，输出与上一节相同，因为我们只是重构了代码。
- en: Wonderful! You just learned how to integrate the C++ thread support library
    with concurrent components.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何将C++线程支持库与并发组件集成。
- en: Binding the thread procedure and its input to packaged_task
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将线程过程及其输入绑定到packaged_task
- en: In this section, you will learn how you can bind the `thread` function and its
    respective arguments with `packaged_task`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将`thread`函数及其相应的参数与`packaged_task`绑定。
- en: 'Let''s take the code from the previous section and modify it to understand
    the bind feature, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一节中获取代码并进行修改以了解绑定功能，如下所示：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `std::bind( )` function binds the `thread` function and its arguments with
    the respective task. Since the arguments are bound upfront, there is no need to
    supply the input arguments 15 or 10 once again. These are some of the convenient
    ways in which `packaged_task` can be used in C++.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::bind()`函数将`thread`函数及其参数与相应的任务绑定。由于参数是预先绑定的，因此无需再次提供输入参数15或10。这些都是`packaged_task`在C++中可以使用的便利方式之一。'
- en: How to compile and run
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s launch `concurrency.exe`, as shown in the following screenshot, and
    understand the difference between the previous program and the current version:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动`concurrency.exe`，如下截图所示，并了解先前程序和当前版本之间的区别：
- en: '![](img/a4c26e03-b1b4-4f6a-af4e-bab2578450e6.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c26e03-b1b4-4f6a-af4e-bab2578450e6.png)'
- en: Congrats! You have learned a lot about concurrency in C++ so far.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！到目前为止，您已经学到了很多关于C++中的并发知识。
- en: Exception handling with the concurrency library
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发库的异常处理
- en: The concurrency support library also supports passing exceptions via a future
    object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 并发支持库还支持通过`future`对象传递异常。
- en: 'Let''s understand the exception concurrency handling mechanism with a simple
    example, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来理解异常并发处理机制，如下所示：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Just like the way we passed the output messages to the caller function/thread,
    the concurrency support library also allows you to set the exception that occurred
    within the task or asynchronous function. When the caller thread invokes the `future::get()`
    method, the same exception will be thrown, hence communicating exceptions is made
    easy.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们将输出消息传递给调用者函数/线程一样，并发支持库还允许您设置任务或异步函数中发生的异常。当调用者线程调用`future::get()`方法时，将抛出相同的异常，因此异常通信变得更加容易。
- en: How to compile and run
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编译和运行
- en: 'Let''s go ahead and compile the program with the following command. Uncle fruits
    and yodas malte:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令编译程序。叔叔水果和尤达的麦芽：
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![](img/da2651ed-df82-434f-a8df-5ec946ac0a03.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da2651ed-df82-434f-a8df-5ec946ac0a03.png)'
- en: What did you learn?
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么？
- en: 'Let me summarize the takeaway points:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我总结一下要点：
- en: The concurrency support library offers high-level components that enable the
    execution of several tasks concurrently
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发支持库提供了高级组件，可以实现同时执行多个任务。
- en: Future objects let the caller thread retrieve the output of the asynchronous
    function
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`future`对象让调用者线程检索异步函数的输出'
- en: The promise object is used by the asynchronous function to set the output or
    exception
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承诺对象被异步函数用于设置输出或异常
- en: The type of `FUTURE` and `PROMISE` object must be the same as the type of the
    value set by the asynchronous function
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FUTURE`和`PROMISE`对象的类型必须与异步函数设置的值的类型相同'
- en: Concurrent components can be used in combination with the C++ thread support
    library seamlessly
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发组件可以与C++线程支持库无缝地结合使用
- en: The lambda function and expression can be used with the concurrency support
    library
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda函数和表达式可以与并发支持库一起使用
- en: Summary
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the differences between the C++ thread support
    library and the pthread C library, Mutex synchronization mechanism, deadlocks
    and strategies of preventing a deadlock. You further learned how to write synchronous
    functions using the concurrency library, and further studied lambda function and
    expression.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了C++线程支持库和pthread C库之间的区别，互斥同步机制，死锁以及预防死锁的策略。您还学习了如何使用并发库编写同步函数，并进一步研究了lambda函数和表达式。
- en: In the next chapter, you will learn about test-driven development as an extreme
    programming approach.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习作为一种极限编程方法的测试驱动开发。
