- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Every C++ Program Is Standard-Compliant
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个C++程序都符合标准
- en: '*Except when they are not*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非它们不是*'
- en: In the world of C++ programming, the concept of standard compliance is often
    held in high regard, with the latest iteration of the C++ standard perceived as
    the definitive guide for writing correct and efficient code. The C++ standard,
    meticulously crafted and periodically updated by the C++ committee and the **International
    Organization for Standardization** ( **ISO** ), serves as the ultimate guide for
    developers, providing a comprehensive set of rules and best practices to ensure
    code quality and interoperability. However, the reality of software development
    is more nuanced and complex than this ideal suggests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++编程的世界里，符合标准的概念通常受到高度重视，C++标准的最新版本被视为编写正确和高效代码的终极指南。C++标准是由C++委员会和国际标准化组织（**ISO**）精心制定并定期更新的，为开发者提供了全面的规则和最佳实践，以确保代码质量和互操作性。然而，软件开发的现实比这种理想状态更为复杂和微妙。
- en: In this chapter, we will delve into the myriad challenges faced by developers
    who, due to various constraints, cannot always adhere to these standards and carefully
    balance on the sharp, thin edge between ideal standards and the practical demands
    of their work. These constraints can include limitations in their development
    environment, such as outdated compilers, legacy systems, or specific project requirements
    that mandate the use of non-standard features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨由于各种限制，开发者无法始终遵守这些标准，并在理想标准与工作实际需求之间尖锐、微妙的边缘上谨慎平衡所面临的众多挑战。这些限制可能包括他们在开发环境中的限制，如过时的编译器、遗留系统，或要求使用非标准特性的特定项目需求。
- en: 'Complex situations can arise when we are forced to use a framework that uses
    C++ as a base and provides a set of extensions to satisfy a certain use case.
    As we will present at a later stage, these frameworks build on existing standard
    C++ and bring in features that are highly specific for a certain scope, but have
    nothing in common with the C++ standard. So, we might ask ourselves: should we
    use these frameworks or not? The answer to this question, as we will see, is not
    as straightforward as one might assume.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们被迫使用以C++为基础并提供一组扩展以满足特定用例的框架时，可能会出现复杂的情况。正如我们将在稍后阶段展示的，这些框架建立在现有的标准C++之上，并引入了针对特定范围的特定功能，但这些功能与C++标准没有任何共同之处。因此，我们可能会问自己：我们应该使用这些框架吗？正如我们将看到的，这个问题的答案并不像人们可能认为的那样简单。
- en: 'In this chapter, we will cover the following major topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Adherence to standards in various compilers, frameworks, and environments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵守各种编译器、框架和环境中的标准
- en: Why can’t everyone learn, use, or write standard C++?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不是每个人都能学习、使用或编写标准C++？
- en: Compiler extensions drifting away from the standard
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离开标准的编译器扩展
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We have to admit that reading this chapter will not be a straightforward process,
    but we will try to make it as easy as possible. Our minds will wander between
    platforms, compilers, and different dialects of the C++ language. However, at
    some point, we must draw the line and conclude that we should be able to transform
    all this theoretical transfer of information into the practicalities of life and
    produce some C++ code out of it. So, we kindly ask that at this stage of the book,
    you have access to the almighty internet, and the go-to place for experimental
    C++: Matt Godbolt’s site:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，阅读本章不会是一个简单的过程，但我们将尽力使其尽可能容易。我们的思绪将在平台、编译器和C++语言的多种方言之间徘徊。然而，在某个时候，我们必须划清界限，得出结论，我们应该能够将所有这些理论信息的传递转化为生活的实际，并从中产生一些C++代码。因此，我们在此恳请，在本书的这个阶段，您能够访问强大的互联网，以及实验C++的必去之地：Matt
    Godbolt的网站：
- en: '[https://gcc.godbolt.org/](https://gcc.godbolt.org/)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gcc.godbolt.org/](https://gcc.godbolt.org/)'
- en: That place should keep you covered since almost all the compilers we will discuss
    in this chapter are to be found there.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那个地方应该能为你提供保护，因为我们将在本章中讨论的所有编译器几乎都可以在那里找到。
- en: There is nothing else required for now. That’s because at this stage, we have
    not produced enough valuable code to be able to put anything meaningful into the
    GitHub repository of the book, and the code that we have produced should not go
    anywhere.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不需要其他任何东西。这是因为在这个阶段，我们还没有产生足够的有价值代码，能够将任何有意义的代码放入本书的GitHub仓库中，而我们产生的代码也不应该被用于其他地方。
- en: Somewhere in Ghana, far, far away
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在遥远的加纳某处
- en: 'When Richard Appiah Akoto posted a few images of himself drawing the user interface
    of Microsoft Word on a blackboard at his school in Ghana, he instantly became
    a social media phenomenon overnight [1](B22235_02.xhtml#footnote-007) . His school
    was poor and they had no working computers, just a standard blackboard from the
    turn of the century, but this did not stop him from performing his duties as a
    teacher. In a very creative manner, he did his best to convey life-altering knowledge
    to his pupils, hoping that one day, it would be useful for them in their quest
    for a better life. The rest is history, but the real question is: was this the
    standard way of teaching Microsoft Word?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当理查德·阿皮亚·阿科托在加纳的学校黑板上绘制了微软Word用户界面的几张图片后，他一夜之间成为了社交媒体现象 [1](B22235_02.xhtml#footnote-007)
    。他的学校很贫穷，没有工作的电脑，只有一块世纪之交的标准黑板，但这并没有阻止他履行教师的职责。他以非常富有创意的方式，尽其所能将改变生活的知识传授给学生，希望有一天，这些知识能对他们追求更好的生活有所帮助。其余的都是历史，但真正的问题是：这是教授微软Word的标准方式吗？
- en: '[1](B22235_02.xhtml#footnote-007-backlink) [https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/](https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_02.xhtml#footnote-007-backlink) [https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/](https://news.microsoft.com/apac/2018/03/17/teacher-who-used-a-chalkboard-in-computer-class-because-he-had-no-computer-stars-at-microsofts-education-exchange/)'
- en: Let’s not diverge too much from our initial objective. We want to find out about
    the standard compliance of C++ programs. For zealot C++ programmers, the latest
    iteration of the standard is perceived as holy scripture, the word, the collection
    of rules that they should obey, and any deviation from it should be punishable
    with an erasure and rewrite of the non-standard compliant code. Or one week in
    the detention center labeled *the maintainer of* *legacy code* .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要偏离我们的初始目标太远。我们想了解C++程序的标准合规性。对于狂热的C++程序员来说，标准的最新版本被视为神圣的经文，是话语，是他们应该遵守的规则的集合，任何偏离都应该受到擦除和重写非标准合规代码的惩罚。或者在一个被标记为*维护*
    *遗留代码* 的拘留中心度过一周。
- en: Facing the harsh reality, things couldn’t be further from an idealistic environment.
    Some developers do not have the possibility to use the latest version of the C++
    standard. This could be because their livelihood is bound to real-life projects
    that require a specific compiler, or because the environment they program for
    does not allow the use of specific features of the language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 面对残酷的现实，事情与理想主义的环境相去甚远。一些开发者没有可能使用C++标准的最新版本。这可能是因为他们的生计与需要特定编译器的现实生活项目紧密相连，或者是因为他们编程的环境不允许使用语言的特定功能。
- en: Or maybe they are paid to work on a platform that simply has not received updates
    for the last 20 years because the provider declared bankruptcy a decade ago, and
    there was no one to take up their business. However, since everything works and
    it still generates revenue, it is kept and maintained using tools that were available
    20 years ago.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可能是因为在一个过去20年没有更新过的平台上工作而获得报酬，因为这个提供商十年前宣布破产，没有人接手他们的业务。然而，由于一切正常并且仍在产生收入，它仍然使用20年前的工具来维护和保持。
- en: This definitely does not include compilers with support for the latest C++ standard.
    So, does this mean the C++ code the developers working on these platforms write
    is not standard-compliant?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定不包括支持最新C++标准的编译器。那么，这意味着在这些平台上工作的开发者所编写的C++代码不是标准合规的吗？
- en: At the turn of the century, the author of this chapter found himself in a classroom
    at his university, attending a course called *Introduction to C++ Programming*
    . It was the only C++ course offered at that place, and there was one book the
    teacher used to pass on knowledge to more than 30 students.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在世纪之交，本章的作者发现自己在一所大学的教室里，参加一门名为*C++程序设计入门* 的课程。这是那里唯一提供的C++课程，老师用一本书来传授知识给30多个学生。
- en: The small copy shop owner at the end of the road was very happy when, one day,
    the teacher decided to loan the book to one of the students. The book was a translated
    and heavily reduced version of Kris Jamsa’s *C/C++ programmers’ Bible* , the “book
    with the spotted dog,” as we called it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 路尽头的小复印店老板在有一天老师决定把书借给一个学生时非常高兴。这本书是 Kris Jamsa 的 *C/C++ 程序员圣经* 的翻译和大幅缩减版，我们称之为“有斑点的狗的书”。
- en: 'The local edition of the book contained only the C++ part, but it carried a
    very important inset: a Turbo C++ Lite IDE and accompanying compiler on a standard
    1.44 MB floppy disk. For those who are unfamiliar with the name, Turbo C++ Lite
    was a dumbed-down version of the popular (and very user-friendly) IDE and compiler
    Turbo C++ by Borland. The compiler was the same, however, a lot of features and
    tools were removed in order to fit the entire environment on a single 1.44 MB
    (megabytes, that is) floppy disk.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 书的本地版只包含了 C++ 部分，但它附带了一个非常重要的附录：一张标准的 1.44 MB 软盘，上面有 Turbo C++ Lite IDE 和相应的编译器。对于那些不熟悉这个名字的人来说，Turbo
    C++ Lite 是 Borland 公司流行的（并且非常用户友好）的 IDE 和编译器 Turbo C++ 的简化版。编译器本身是相同的，但是为了将整个环境放在单个
    1.44 MB（兆字节）的软盘上，移除了很多功能和工具。
- en: This was our first introduction to the complex world of compilers, linkers,
    and syntax. Some of us found it so fascinating that even now, some 20 years later,
    we still use it in our daily work. So, as you can imagine, our first C++ program
    looked like the one in the screenshot that follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触到编译器、链接器和语法的复杂世界。我们中的一些人发现它如此迷人，以至于现在，20 年后，我们仍然在日常工作中使用它。所以，正如你可以想象的那样，我们的第一个
    C++ 程序看起来就像下面截图中的那样。
- en: '![Figure 2.1 – The infamous blue screen of code, as seen in Life of a Programmer
    (1997)](img/B22235_02_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 程序员生活中的著名蓝色代码屏幕，如图 1997 年的《程序员生活》所示](img/B22235_02_01.jpg)'
- en: Figure 2.1 – The infamous screen of code, as seen in Life of a Programmer (1997)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 程序员生活中的著名代码屏幕，如图 1997 年的《程序员生活》所示
- en: 'Oh, the horror on your face! I can clearly imagine it, dear C++ acolyte. The
    sheer sight of:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你脸上的恐惧！我可以清楚地想象出来，亲爱的 C++ 学徒。仅仅是看到：
- en: '**iostream.h** : Well, hello, it’s 1999, and the C++98 standard came out last
    year. Why don’t you use it, you heretic? Its number is ISO/IEC 14882:1998, go
    fetch it for a mere 200 Swiss Francs. … Oh, that is your salary as a part-time
    dishwasher for three months while studying here?'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iostream.h**：嗯，你好，现在是 1999 年，C++98 标准去年才发布。你为什么不使用它，你这个异端？它的编号是 ISO/IEC 14882:1998，只需
    200 瑞士法郎就可以买到。…哦，那是你在这里学习期间三个月兼职洗碗工的工资？'
- en: '**void main(void)** : Oh dear, that was never even in any standard, whether
    C or C++. What sort of dark concoction did you just dig out? … Or is this the
    new thing they call… Java?'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**void main(void)**：哦，亲爱的，这从来就没有在任何标准中出现过，无论是 C 还是 C++。你刚刚挖出了什么样的黑暗混合物？…或者这是他们称之为…
    Java 的新东西？'
- en: '**cout** : Without ever encountering a using directive, how is this even possible?'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cout**：从未遇到过使用指令，这怎么可能呢？'
- en: Here, you can easily afford to give up on trying to understand the reasons for
    this, sighing with relief, but please bear with me.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你很容易放弃试图理解这一点的尝试，如释重负地叹气，但请再忍受我一下。
- en: Very much akin to the conditions faced by Richard Appiah Akoto, at that stage
    of our education, we also had access to a classroom with a blackboard, accompanied
    by one dedicated teacher and the book, as well as several copies of it, as mentioned
    earlier. Even so, we learned C++. Maybe, from the point of view of the standard,
    these were ideal circumstances, because the C++ standard is very relaxed, considering
    the environment, it requires nothing that you can find in a modern computer –
    no keyboard, no screen, and not even an operating system. Indeed, the only very
    strict environmental requirement is that **char** must be at least 8 bits in size.
    This is to ensure that a **char** can hold any member of the basic execution character
    set (which includes standard ASCII characters). And the fact that **sizeof(char)
    == 1** is also guaranteed by the C++ standard, together with the signed and unsigned
    versions of it. Everything else builds on these foundations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与理查德·阿皮亚·阿科托在那时所面临的情况非常相似，在我们接受教育的那个阶段，我们也拥有了一个带有黑板、一位专职教师以及几本书（正如之前提到的，有几本副本）的教室。即便如此，我们还是学习了C++。也许，从标准的角度来看，这些条件是理想的，因为C++标准非常宽松，考虑到环境因素，它不需要你能在现代计算机中找到的任何东西——没有键盘，没有屏幕，甚至没有操作系统。确实，唯一非常严格的环境要求是**char**的大小至少为8位。这是为了确保**char**可以容纳基本执行字符集中的任何成员（包括标准ASCII字符）。而且，**sizeof(char)
    == 1**这一事实也由C++标准保证，包括它的有符号和无符号版本。所有其他内容都是建立在这些基础之上的。
- en: So, we might say that until we were granted access to the computer lab, we had
    ideal circumstances for learning standard C++. No annoying system dependencies,
    no computer crashes, and no hardware to kick in case of frustration when your
    code does not compile. Since we had no compiler running on the blackboard, our
    teacher soon realized that compiling more complex C++ code on a blackboard is
    not quite feasible, so we were allocated an early Friday morning time slot at
    the computer lab. All the troubles began afterward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说，在我们获得进入计算机实验室的权限之前，我们学习标准C++的条件是理想的。没有令人烦恼的系统依赖，没有电脑崩溃，也没有硬件在代码无法编译时因沮丧而踢出。由于我们没有在黑板上运行编译器，我们的老师很快意识到在黑板上编译更复杂的C++代码并不太可行，所以我们被分配了周五早上早些时候的时间段在计算机实验室。所有的麻烦从此开始。
- en: 'The explanation is quite simple: you see, the computer lab that was allocated
    for teaching C++ at our university back in the day consisted of a bunch of 80286
    IBM AT clones.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 解释相当简单：你们知道，我们大学当时用于教授C++的计算机实验室由一帮80286 IBM AT克隆机组成。
- en: You read that correctly. 30 students were allocated eight computers (each with
    a glorious 80286 processors, possibly high-tech at the time of their conception,
    albeit quite outdated more than one and a half decades later), hand-me-downs from
    some aid organization that likely did an upgrade, and decided to donate their
    old equipment to the university for the tax benefit of the company students. Four
    and a half people were sitting at one machine, with one book (and several copies)
    for the class, trying to learn C++.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你们读得没错。当时有30名学生，分配了8台电脑（每台都配有当时可能算是高端的80286处理器，尽管在十多年后显得相当过时），这些电脑是从某个援助机构那里得到的，该机构可能进行了升级，并决定将旧设备捐赠给大学以获得公司的税收优惠。四个人一台机器，每人一本书（以及几本副本），试图学习C++。
- en: Although the situation was not as bleak as in Richard Appiah Akoto’s school
    two decades later, there were simply no better conditions. Those machines could
    never run anything else than pure DOS, and there was no better compiler available
    for them than Turbo C++ Lite, which came out 10 years earlier. Does this mean
    we intentionally learned to write non-standard C++ code? No, obviously not. We
    wrote code that we had the possibility to.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管情况并不像二十年后理查德·阿皮亚·阿科托的学校那样糟糕，但条件并没有更好。那些机器只能运行纯DOS，而且没有比Turbo C++ Lite更好的编译器可用，它是十年前发布的。这意味着我们有意学习编写非标准C++代码吗？显然不是。我们编写了我们能够编写的代码。
- en: However, let’s not jump that far back in time. As of 2024, the date of writing
    of this book, there are 46 questions on Stack Overflow ( [https://stackoverflow.com/](https://stackoverflow.com/)
    ), containing the dreaded **void main(void)** phrase. The latest one is surprisingly
    from 2023. A bit more with the **iostream.h** content but mostly with educational
    context, and we did not dare count the ones containing **cout** without encountering
    the using directive or a namespace qualifier because it would have been futile.
    Does this mean that even in 2024, there are programmers still writing code that
    relies on non-standard C++? Or are there students learning C++ in a non-standard
    way?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不要把时间倒退得太远。截至2024年，本书的写作日期，Stack Overflow上有46个问题（[https://stackoverflow.com/](https://stackoverflow.com/)），包含令人恐惧的**void
    main(void)**短语。最新的一条令人惊讶地来自2023年。其中一些与**iostream.h**的内容有关，但主要是教育背景，我们不敢计算那些包含**cout**但没有遇到使用指令或命名空间限定符的问题，因为那将是徒劳的。这难道意味着即使在2024年，仍然有程序员在编写依赖于非标准C++的代码？或者有学生在以非标准的方式学习C++？
- en: 'Digging a bit further on Stack Overflow, another interesting piece of an old
    dialect of C++ pops up: **conio.h** . This header was shipped with Turbo C (and
    C++) several years before the official standardization of the language, but considering
    that there are young padawans still asking questions about it in 2024, we might
    say that the answer to the previous question is highly likely *yes* .'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Stack Overflow上进一步挖掘，另一个关于旧版C++方言的有趣片段出现了：**conio.h**。这个头文件在语言官方标准化几年前就随Turbo
    C（和C++）一起发布了，但考虑到在2024年仍有年轻的新手对其提出问题，我们可以说，对于之前问题的答案很可能为*是*。
- en: Depending on their circumstances and possibilities, whether they have to learn
    using a blackboard, drawing with chalk, or by sharing a keyboard, tapping each
    other’s hands gently in the process, there are still programmers out there today
    who involuntarily have the process of learning and writing non-standard C++ imposed
    on them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 根据他们的环境和可能性，无论他们是否需要使用黑板学习，用粉笔绘图，或者通过共享键盘，在过程中轻轻拍打彼此的手，今天仍然有一些程序员不自觉地被强加了一个学习和编写非标准C++的过程。
- en: Microsoft’s tiny, squishy C++
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软的迷你、紧绷的C++
- en: That’s enough staring backward for now. Let’s look, for a moment, in a different
    direction and consider a compiler that once was the king of C++, but with time,
    its shine faded. OpenWatcom is an open source integrated development environment
    and suite of compilers for C and C++ (and Fortran too, but that language is not
    in focus in this book), originally developed by Watcom International Corporation
    and released as open source by Sybase in 2003.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向后看已经足够了。让我们暂时换个方向，考虑一下曾经是C++之王的编译器，但随着时间的推移，它的光芒已经消退。OpenWatcom是一个开源的集成开发环境，以及C和C++（以及Fortran，但在这本书中该语言不是重点）的编译器套件，最初由Watcom国际公司开发，并于2003年由Sybase开源发布。
- en: It supports multiple operating systems, including DOS, Windows, OS/2, and also
    Linux, and is the de-facto compiler for programmers who have an interest in creating
    fun, free-time projects for retro platforms.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持多个操作系统，包括DOS、Windows、OS/2，以及Linux，并且是那些对为复古平台创建有趣、休闲项目感兴趣的程序员的默认编译器。
- en: Not necessarily for the money, but instead for that joyful feeling of sweet
    nostalgia shivering through one’s spine when they are in front of an 80x25 screen.
    Maybe that’s the reason most senior programmers today use a grid of VI editors
    running in a terminal tiled to 6x4 windows, on huge WQUXGA (or larger) screens.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 并非一定是为了钱，而是因为当他们面对80x25屏幕时，那种甜蜜的怀旧感会让他们脊背发凉。也许这就是为什么今天大多数资深程序员都使用在终端中运行的VI编辑器网格，这些编辑器被拼接到6x4的窗口上，在巨大的WQUXGA（或更大）屏幕上。
- en: 'But let’s get back to the OpenWatcom compiler. While browsing the release notes
    of the project [2](B22235_02.xhtml#footnote-006) , we encountered the following,
    may I say so, quite intriguing phrase (in the *Major differences from version
    10.0* section, at item 29):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们回到OpenWatcom编译器。在浏览项目的发布说明[2](B22235_02.xhtml#footnote-006)时，我们遇到了以下，可以说相当引人入胜的短语（在*与版本10.0的主要差异*部分，第29项）：
- en: '[2](B22235_02.xhtml#footnote-006-backlink) [https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html](https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](B22235_02.xhtml#footnote-006-backlink) [https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html](https://open-watcom.github.io/open-watcom-v2-wikidocs/c_readme.html)'
- en: We have duplicated a Microsoft Visual C++ extension that was required to parse
    the Windows 95 SDK header files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经复制了一个必需的Microsoft Visual C++扩展，用于解析Windows 95 SDK头文件。
- en: 'Example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: typedef struct S {
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: typedef struct S {
- en: '} S, const *CSP;'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '} S, const *CSP;'
- en: ^^^^^- not allowed in ISO C or ISO C++
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^^^^^- 不允许在 ISO C 或 ISO C++ 中使用
- en: Ehm … what? Did I just read correctly that there is an extension for Visual
    C++ that allows non-standard code to be compiled?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀……我刚刚读得正确吗？Visual C++ 有一个扩展，允许编译非标准代码？
- en: 'Yes, we actually read that correctly. The following short sequence of demonstrative
    code should not compile with any major C++ compiler today, except for Visual C++
    (and OpenWatcom’s C++ compiler, as per their comments):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们确实正确地阅读了这一点。以下这段示例代码在今天的任何主流 C++ 编译器中都无法编译，除非是 Visual C++（以及根据他们的评论，OpenWatcom
    的 C++ 编译器）：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '...and due to some mystery, the author was not able to decipher, the code sequence
    is also accepted by several versions of ICC (Intel’s powerful, but sadly discontinued,
    C++ compiler). So, we can ask the following question again: since one major, and
    two relatively esoteric compilers accept this kind of code, does this mean that
    we should use it? Is it standard?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '...由于一些作者未能解密的神秘原因，这段代码序列也被几个版本的 ICC（英特尔强大的但遗憾的是已停产的 C++ 编译器）接受。因此，我们可以再次提出以下问题：既然一个主要编译器和两个相对晦涩的编译器接受这种代码，这意味着我们应该使用它吗？它是标准的吗？'
- en: The answer to the second question is a definitive *no* . However, for the first
    one, it is a bit more nuanced. This is because before answering, we must take
    the background, requirements, and other relevant factors that might influence
    the decisions concerning the development into consideration again.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题的答案是明确的 *不*。然而，对于第一个问题，情况要复杂一些。这是因为在我们回答之前，我们必须再次考虑背景、需求和其他可能影响开发决策的相关因素。
- en: Do we want to stick to the standard C++ as much as we can? Is it possible to
    deliver the required solution without extending ourselves to using vendor-specific
    extensions? Are we bound to a compiler or an operating system, and are we not
    worried about ever needing to visit foreign lands?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否尽可能坚持标准 C++？是否有可能在不使用供应商特定扩展的情况下提供所需的解决方案？我们是否绑定到编译器或操作系统，并且我们不担心将来可能需要访问外国土地？
- en: Would it save us a lot of trouble to use the managed extensions for C++, offered
    by adopting the Microsoft platform, or would we rather stick to the good old syntax
    (and types) that we know and are familiar with?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微软平台提供的针对 C++ 的托管扩展，能帮我们省去很多麻烦，还是我们更愿意坚持我们熟悉和了解的古老语法（以及类型）呢？
- en: Microsoft is famous for providing platform-specific extensions for the C and
    C++ languages, to the extent that there is an entire section dedicated to Microsoft-specific
    C++ keywords [3](B22235_02.xhtml#footnote-005) . This tells us that there is a
    market for non-standard C++, and with just cause, because some of these extensions
    are very handy, at the expense of binding ourselves to a platform, compiler, and
    toolchain.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 微软以其为 C 和 C++ 语言提供平台特定扩展而闻名，以至于有一个专门的部分用于微软特定的 C++ 关键字 [3](B22235_02.xhtml#footnote-005)。这告诉我们，非标准
    C++ 有一个市场，并且有充分的理由，因为其中一些扩展非常实用，尽管这需要我们绑定到平台、编译器和工具链。
- en: '[3](B22235_02.xhtml#footnote-005-backlink) [https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](B22235_02.xhtml#footnote-005-backlink) [https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170](https://learn.microsoft.com/en-us/cpp/cpp/keywords-cpp?view=msvc-170)'
- en: One of the Microsoft extensions manifests itself within the **__declspec** keyword.
    The **__declspec** keyword in C and C++ is part of Microsoft’s extended C++ syntax,
    which allows developers to specify Microsoft-specific storage-class attributes
    for certain C++ constructs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的一个扩展体现在 **__declspec** 关键字中。C 和 C++ 中的 **__declspec** 关键字是微软扩展 C++ 语法的一部分，它允许开发者为某些
    C++ 构造指定微软特定的存储类属性。
- en: 'This keyword provides additional control over behaviors such as DLL exporting
    and memory alignment, which are not covered by the standard ANSI keywords such
    as **static** and **extern** . By using **__declspec** , developers can easily
    and non-standard compliantly apply these features specific to Microsoft’s own
    compiler (behold: a surprise follows!) to their code, enhancing the capabilities
    and performance of their code, such as in the following code sequence:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字提供了对诸如 DLL 导出和内存对齐等行为的额外控制，这些行为在标准 ANSI 关键字（如 **static** 和 **extern**）中并未涵盖。通过使用
    **__declspec**，开发者可以轻松且不遵循标准地应用这些特定于微软自己编译器的特性（看吧：接下来会有惊喜！）到他们的代码中，从而增强代码的功能和性能，如下面的代码序列所示：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using Microsoft’s **__declspec(property(...))** syntax, the preceding code sequence
    creates an **age** property that allows indirect interaction with **m_** **age**
    through the methods provided, properly encapsulating the age data while providing
    a simplified interface for accessing and modifying it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微软的**__declspec(property(...))**语法，前面的代码序列创建了一个**age**属性，允许通过提供的方法间接与**m_**
    **age**进行交互，正确封装年龄数据，同时提供了一个简化的接口来访问和修改它。
- en: 'The list of attributes that one can harness with the **__declspec** extension
    is quite long and pragmatic, and **__declspec** also seems to be catchy in the
    compiler development world. In fact, it’s so catchy that **Clang** provides an
    argument dedicated to understanding this Microsoft-specific extension. This flag,
    **-fdeclspec** , makes it possible to use the **__declspec** keyword in code compiled
    by Clang too. So, the question naturally arises: is this a Microsoft-specific
    extension anymore, or are we witnessing the emergence of a cross-platform feature?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以利用**__declspec**扩展利用的属性列表相当长且实用，**__declspec**在编译器开发界似乎也很受欢迎。事实上，它如此受欢迎，以至于**Clang**提供了一个专门的参数来理解这个微软特定的扩展。这个标志**-fdeclspec**使得在Clang编译的代码中也能使用**__declspec**关键字。因此，自然而然地产生了这样的问题：这还是微软特定的扩展吗，或者我们正在见证跨平台功能的出现？
- en: A truth that is still considered to be taboo in hardcore C++ programmer circles
    is that in real life, rare are the situations, when one needs to write true cross-platform
    code. Most programmers work for a specific company, developing or supporting a
    particular product. They’ll mostly use one operating system, with one compiler
    toolchain, complying with the restrictions imposed by their employer and happily
    compiling their code using all the extensions their compiler supports.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心C++程序员圈子中仍然被视为禁忌的一个事实是，在现实生活中，真正需要编写真正的跨平台代码的情况是很少的。大多数程序员为特定的公司工作，开发或支持特定的产品。他们主要使用一个操作系统，一个编译器工具链，遵守雇主施加的限制，并愉快地使用编译器支持的扩展来编译他们的代码。
- en: 'This does not mean they don’t explicitly want to write standard compliant C++
    code. No, on the contrary, I believe they write the highest quality code they
    can come up with. This just means that they merely use the possibilities provided
    by a specific compiler: the one they have to work with. At their next company,
    there is a high chance that they will be using a different compiler that runs
    on a different OS, thus forgetting all about the advantages provided by their
    ex-compiler at their ex-place. This is because compiler-specific syntax and extensions
    are not bound to one compiler exclusively.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着他们不想编写符合标准的C++代码。不，恰恰相反，我相信他们能写出他们能想到的最高质量的代码。这仅仅意味着他们只是使用了特定编译器提供的可能性：他们必须与之工作的那个编译器。在他们下一家公司，有很大可能性他们会使用运行在不同操作系统上的不同编译器，从而忘记他们在前一个地方的前编译器提供的所有优势。这是因为特定编译器的语法和扩展并不局限于一个编译器。
- en: 'Let’s consider the following code sample, for example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码示例，例如：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other than hurting our eyes, this sequence is obviously as standard and non-conformant
    as possible. Who in their right mind would ever attempt to initialize an array
    of 6 chars like this? However, the Microsoft Visual C++ compiler happily digests
    it. Let’s start with a few normal characters, and when we get bored of typing
    in all the apostrophes and commas, we’ll just throw everything else in a constant
    string literal, because why not? And it is quite clever about it, detecting the
    size that was requested for the array and matching it to the accumulated length
    of the parts, signaling an error if there are any mismatches.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刺痛我们的眼睛，这个序列显然尽可能标准和非规范。谁会理智地尝试以这种方式初始化一个6个字符的数组呢？然而，Microsoft Visual C++编译器却乐于接受它。让我们从一些普通字符开始，当我们厌倦了输入所有的撇号和逗号时，我们就可以把其他所有东西都扔到一个常量字符串字面量中，因为为什么不呢？而且它在这方面相当聪明，检测到请求的数组大小，并将其与各部分的累积长度相匹配，如果存在任何不匹配，则发出错误信号。
- en: 'Microsoft’s C++ compiler is a very innovative one when it comes to adding features
    not found in the standard, or allowing code that would break a language lawyer’s
    tongue. Let’s look at the following piece of code, for example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到添加标准中找不到的功能或允许会打破语言律师舌头的代码时，微软的C++编译器是一个非常创新的编译器。让我们以以下代码为例：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code sequence is anything but standard C++. Its sheer existence even allows
    us to write code that looks like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码序列根本不是标准的C++。它的存在甚至让我们能够编写出如下所示的代码：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example compiles and runs without any issues when compiled using
    Microsoft’s own C++ compiler. Please carefully observe the anonymous class, which
    contains the **name** member, is an object that has a constructor.. This is an
    object that has a constructor, a destructor, and lots of other interesting features.
    This is another (very handy, if I may say so) Microsoft deviation from the standard
    because anonymous unions are a well-known beast of C++. However, anonymous structs
    only dwell in the C language (starting from C11) and no other compiler accepts
    the preceding code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用微软自己的C++编译器编译时，先前的示例编译和运行没有任何问题。请仔细观察匿名类，它包含一个**名称**成员，是一个具有构造函数的对象。这是一个具有构造函数、析构函数和许多其他有趣特性的对象。这是另一个（如果我可以这么说的话，非常实用的）微软对标准的偏离，因为匿名联合体是C++中众所周知的一种野兽。然而，匿名结构体仅存在于C语言中（从C11开始），其他编译器不接受上述代码。
- en: As a side note, if you’re not familiar with the notion of anonymous structs
    in the C language, they are a useful feature for simplifying nested structure
    declarations. They do not require the naming of inner structs when they are not
    needed elsewhere, and they make the code more concise and readable. While the
    members are enclosed in a structure, it is still possible to have direct access
    to them. By encapsulating related fields within anonymous structs, and introducing
    logical blocks within these members, the cluttering of the code with unnecessary
    type definitions becomes less overwhelming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，如果你不熟悉C语言中匿名结构体的概念，它们是简化嵌套结构声明的有用特性。当它们在其他地方不需要命名内部结构时，它们不需要命名内部结构，并且使代码更加简洁易读。尽管成员被包含在结构体中，但仍可以直接访问它们。通过在匿名结构体中封装相关字段，并在这些成员中引入逻辑块，可以减少代码中不必要的类型定义的杂乱。
- en: The realm of free compilers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 免费编译器的领域
- en: Two of the three major compilers today are developed and maintained in an open-source
    manner. This means that, in theory, anyone can contribute and provide useful new
    features to their compiler of choice. However, in practice, it means that there
    is a tiny core of professional programmers who have the necessary knowledge and
    dedication, and also the backing of a large corporation benefiting from the development
    of the aforementioned compiler working on it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前三大主要编译器中的两个是以开源方式开发和维护的。这意味着，从理论上讲，任何人都可以为其选择的编译器贡献并添加有用的新功能。然而，在实践中，这意味着只有一小部分具备必要知识和奉献精神的职业程序员，以及一个大型公司的支持，该公司从上述编译器的发展中获益，他们负责这项工作。
- en: In no particular order, GCC and Clang (and MSVC, which we discussed in the previous
    section) are the most standard-compliant compilers as of 2024. This standard compliance,
    however, does not mean that these compilers don’t come with their own perks that
    a developer once thought would be a great idea to incorporate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按照无特定顺序，截至2024年，GCC和Clang（以及我们在上一节中讨论的MSVC）是最符合标准的编译器。然而，这种标准兼容性并不意味着这些编译器没有自己的优点，这些优点曾经被认为是开发者想要整合的绝佳想法。
- en: 'Let’s take, for example, the **computed goto** feature of GCC (and Clang too,
    of course; those two tend to go hand in hand). We all have learned in school that
    **goto** is just plain evil, and should not be ever used. If you did not learn
    this in school, please do not learn it from this book. That’s because it is, again,
    not true. Instead, let’s focus on what we can think of the computed **goto** .
    If **goto** is evil, then is computed **goto** calculated evil? So is the following
    code sequence pure evil, or calculated evil? Let’s have a look:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以GCC（当然，Clang也是如此；这两个往往是一起使用的）的**计算goto**特性为例。我们都在学校学到，**goto**是纯粹的邪恶，永远不应该使用。如果你在学校没有学到这一点，请不要从这本书中学习。因为，这同样是不正确的。相反，让我们关注一下我们可以想到的计算**goto**。如果**goto**是邪恶的，那么计算**goto**是计算出来的邪恶吗？那么以下代码序列是纯粹的邪恶，还是计算出来的邪恶？让我们看看：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is nothing wrong with the first line. The problems start after that. This
    very handy feature can be used for implementing interpreters or state machines
    efficiently and in a non-standard manner by allowing jumps to labels based on
    the value of a pointer, initialized from the address of the label itself. Since
    we are dealing with pointers, it is entirely possible to use the dreaded pointer
    arithmetic and do some calculations on the addresses.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行没有问题。问题从那以后开始。这个非常实用的特性可以通过允许根据指针的值跳转到标签来有效地以非标准方式实现解释器或状态机。这个指针是从标签本身的地址初始化的。由于我们正在处理指针，完全可能使用可怕的指针算术并在地址上进行一些计算。
- en: Also, this can be a dangerous feature if not used properly. Unlike in the case
    of the standard **goto** , the calculated one does not take into calculation the
    objects whose lifetime ends upon leaving a specific scope. So, no destructors
    are called. Consider yourself warned!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果不正确使用，这可能会是一个危险特性。与标准**goto**的情况不同，计算出的goto不会考虑在离开特定作用域时生命周期结束的对象。因此，不会调用析构函数。请务必注意这一点！
- en: 'Another pretty useful deviation from the standard C++ syntax comes from GCC
    (and again, it’s implemented by Clang too, what a surprise), which makes the following
    code sequence compilable with these two compilers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当有用的与标准C++语法的偏差来自GCC（而且，Clang也实现了它，真是个惊喜），这使得以下代码序列可以用这两个编译器编译：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Neat, ain’t it? This feature is called *Statements and Declarations in Expressions*
    and has all the benefits that you can think of: nice encapsulation of the objects
    declared inside, and somewhat safer macros if used properly. It’s too bad it is
    not standard C++.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 真是整洁，不是吗？这个特性被称为**表达式中的声明和定义**，它拥有你所能想到的所有好处：声明内部对象的良好封装，如果使用得当，则宏更为安全。遗憾的是，它并不是标准C++。
- en: 'Clang, the new kid on the block (well, if we can call a 15-year-old compiler
    the “new” kid, although compared to GCC, with a birth date dating back to 1987,
    Clang is still a very young, albeit skilled, player in the field) takes the feature
    fight a bit further. The following piece of code only compiles with Clang, with
    the benefit of a very special library and a new command line switch to the compiler:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Clang，这个新加入的成员（好吧，如果我们能称一个15岁的编译器为“新”，尽管与1987年出生的GCC相比，Clang在领域中仍然是一个非常年轻但技艺高超的玩家）在特性竞争中更进一步。以下代码片段仅能在Clang中编译，得益于一个特殊的库和一个新的编译器命令行选项：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This feature is called **Blocks** in Clang. In order to get it right, you will
    need to install the **BlocksRuntime** [4](B22235_02.xhtml#footnote-004) library,
    then specify a special **-fblocks** flag to Clang, and, after all this blocking
    has been done, we can finally compile the preceding code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在Clang中被称为**块**。为了正确使用它，你需要安装**BlocksRuntime** [4](B22235_02.xhtml#footnote-004)库，然后指定一个特殊的**-fblocks**标志给Clang，完成所有这些阻塞操作后，我们最终可以编译前面的代码。
- en: '[4](B22235_02.xhtml#footnote-004-backlink) [https://github.com/mackyle/blocksruntime](https://github.com/mackyle/blocksruntime)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](B22235_02.xhtml#footnote-004-backlink) [https://github.com/mackyle/blocksruntime](https://github.com/mackyle/blocksruntime)'
- en: 'This pretty much resembles the behavior of a standard C++11 lambda, but considering
    that this feature was created and introduced in Clang in 2008, we might call this
    the father of the standard C++ lambda. In case you’re curious, the standard C++
    lambda providing the same functionality is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上类似于标准C++11 lambda的行为，但考虑到这个特性是在2008年由Clang创建并引入的，我们或许可以称其为标准C++ lambda之父。如果你对此好奇，提供相同功能的标准C++
    lambda如下：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That’s not black magic, unlike the following piece of code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是黑魔法，与以下代码片段不同：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, in case you are wondering what is happening there, here’s just a small
    refresher of your C++ freshman memories: under no circumstances is **int array[n]
    = {0};** standard C++. The **variable length array** is a feature present in C,
    but the C++ standard does not include it due to various safety considerations.
    Regardless, the preceding code is accepted by the GCC compiler, but Clang complains
    about it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想知道那里发生了什么，这里只是对你C++大一记忆的小提醒：在没有任何情况下，**int array[n] = {0};**是标准C++。**变量长度数组**是C语言中存在的一个特性，但由于各种安全考虑，C++标准不包括它。无论如何，前面的代码被GCC编译器接受，但Clang会对此提出抱怨：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'According to the error message, the fix is easy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误信息，修复方法很简单：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, even Clang (and several other compilers, such as ICC) accept it, regardless
    of the state of standardness of the code… or rather, the lack of it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使是Clang（以及一些其他编译器，如ICC）也接受它，无论代码的标准性状态如何……或者更确切地说，是缺乏标准性。
- en: A tribute to attributes
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对属性的致敬
- en: 'Both GCC and Clang (and also Microsoft Visual C++) can, however, agree on the
    usefulness of one very specific extension to the C++ language: we need a way to
    attach metadata to some of the language constructs (such as types, functions,
    variables, etc.). This metadata can then be used by the compiler and other tools
    to generate optimized code, perform checks, or provide other features.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GCC和Clang（以及微软的Visual C++）可以在一个非常具体的C++语言扩展上达成共识：我们需要一种方法来将元数据附加到某些语言构造（如类型、函数、变量等）。这些元数据随后可以被编译器和其他工具用来生成优化代码、执行检查或提供其他功能。
- en: 'Before modern C++ (i.e., C++11) introduced the standardized way to specify
    attributes using the double square bracket syntax **[[attribute]]** , each compiler
    had their own way of specifying these so required attributes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 C++（即 C++11）引入使用双方括号语法 **[[attribute]]** 指定属性的标准方法之前，每个编译器都有自己的方式来指定这些属性，因此需要这些属性：
- en: GCC and Clang used **__attribute__((attribute-name))**
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 和 Clang 使用 **__attribute__((attribute-name))**
- en: Microsoft Visual C++ used **__declspec(attribute-name)**
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Visual C++ 使用 **__declspec(attribute-name)**
- en: 'With the release of C++11, however, the standardization committee realized
    the usefulness of these, and lifted the most applicable attributes into the language
    (such as **[[noreturn]]** ) while later improvements to the standard added even
    more attributes (such as **[[fallthrough]]** , **[[nodiscard]]** , etc.). However,
    a lot of these attributes remained confined to the compilers that have introduced
    them. The following code snippet showcases some of these:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着 C++11 的发布，标准化委员会意识到了这些特性的有用性，并将最适用的属性提升到语言中（例如 **[[noreturn]]**），而标准的后续改进又添加了更多属性（例如
    **[[fallthrough]]**，**[[nodiscard]]** 等）。然而，许多这些属性仍然局限于引入它们的编译器。以下代码片段展示了其中的一些：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code sequence above contains a few attributes shared by GCC and Clang,
    such as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码序列包含了一些 GCC 和 Clang 共享的属性，例如以下内容：
- en: '**__attribute__((deprecated))** marks **old_function** as deprecated'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__attribute__((deprecated))** 将**旧函数**标记为已弃用'
- en: '**__attribute__((noreturn))** is used to indicate that **fatal_error** does
    not return'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__attribute__((noreturn))** 用于指示 **fatal_error** 不会返回'
- en: '**__attribute__((pure))** is used to indicate that **pure_function** has no
    side effects except for its return value'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__attribute__((pure))** 用于指示**纯函数**除了返回值外没有副作用'
- en: '**__attribute__((aligned(16)))** is used to align the **x** variable to a 16-byte
    boundary'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**__attribute__((aligned(16)))** 用于将 **x** 变量对齐到 16 字节边界'
- en: The list of attributes these compilers [5](B22235_02.xhtml#footnote-003) provide
    is huge [6](B22235_02.xhtml#footnote-002) , and we can highly recommend that if
    you are in a situation where you are working with one of these compilers on a
    very specific platform, and your main concern is not code portability, platform
    independence, and standard compliance, then you should go and check them out.
    That’s because a lot of power can be harnessed by properly using the tools your
    compiler provides you with.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译器提供的属性列表非常庞大 [5](B22235_02.xhtml#footnote-003)，我们强烈建议，如果您处于在特定平台上使用这些编译器，并且您的主要关注点不是代码的可移植性、平台独立性和标准兼容性的情况，那么您应该去查看它们。这是因为通过正确使用编译器提供的工具，您可以充分利用许多功能。
- en: '[5](B22235_02.xhtml#footnote-003-backlink) [https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html](https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](B22235_02.xhtml#footnote-003-backlink) [https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html](https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html)'
- en: '[6](B22235_02.xhtml#footnote-002-backlink) [https://clang.llvm.org/docs/AttributeReference.html](https://clang.llvm.org/docs/AttributeReference.html)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](B22235_02.xhtml#footnote-002-backlink) [https://clang.llvm.org/docs/AttributeReference.html](https://clang.llvm.org/docs/AttributeReference.html)'
- en: When the header is not even C++
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当头文件甚至不是 C++ 时
- en: The long list of standard-non-compliant-but-still-working-and-useful features
    does not end with the preceding examples. However, if we had only focused our
    attention on those, we could still have filled several books with them. Sadly,
    for the moment, we have only dedicated one chapter to this topic, so let’s move
    our attention to somewhat more exotic features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 标准不兼容但仍然可用且有用的特性列表并不止于前面的例子。然而，如果我们只关注那些，我们仍然可以用它们填满几本书。遗憾的是，目前我们只为此主题奉献了一章，所以让我们将注意力转移到一些更为奇特的功能上。
- en: 'Qt has been the de-facto cross-platform programming framework for GUI applications
    (but not only) for quite some time. Throughout its fateful history, while exchanging
    owners several times since its inception in 1994, the Qt framework has evolved
    significantly, with each release giving a new set of features to the C++ (but
    not only) programming community. However, one feature has remained more or less
    the same: the signal/slot implementation and the **Meta Object Compiler** ( **MOC**
    ). The pillar of the framework, the MOC makes it possible to connect events from
    components (i.e., signals) to receivers (i.e., slots) for proper handling.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 已经成为 GUI 应用程序（但不仅限于此）的事实上的跨平台编程框架有一段时间了。在其命运多舛的历史中，自从 1994 年成立以来，Qt 框架已经发生了显著的变化，每个版本都为
    C++（但不仅限于此）编程社区带来了新的功能集。然而，有一个功能基本上保持不变：信号/槽实现和 **元对象编译器**（ **MOC**）。框架的支柱，MOC
    使得将组件（即，信号）的事件连接到接收器（即，槽）以进行适当处理成为可能。
- en: However, this very handy feature comes at the expense of having to support several
    non-C++ constructs, which makes the connection between seemingly unrelated elements
    of the application possible. For example, the class declaration of objects that
    must respond to an event is extended by several non-standard “access modifiers”,
    such as **signals:** , **private slots:** , and so on. Also, there is a new **keyword**
    called **emit** , which makes it possible to, well, emit signals.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个非常实用的功能是以必须支持几个非 C++ 构造为代价的，这使得将应用程序中看似无关的元素连接起来成为可能。例如，必须响应事件的对象的类声明通过几个非标准的“访问修饰符”扩展，例如
    **signals:**，**private slots:** 等。此外，还有一个新的 **关键字** 叫做 **emit**，这使得发出信号成为可能。
- en: 'Long story short, the following is an excerpt from a header file, making the
    compilation of the following code possible:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下是从一个头文件中摘录的内容，使得以下代码的编译成为可能：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Should we adopt the luxury provided to us by Qt and use the very convenient
    signal/slot mechanism with the drawback that we have to write non-standard C++
    code? Or would we rather stick to tradition and create every little button and
    connection by writing pure C++ code, as we would do in GTK?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否应该采用 Qt 提供的奢侈功能，使用非常方便的信号/槽机制，尽管我们必须编写非标准的 C++ 代码？或者我们宁愿坚持传统，像在 GTK 中那样通过编写纯
    C++ 代码来创建每一个小按钮和连接？
- en: 'This chapter cannot answer this question because, in the end, it is up to every
    project’s specific requirements. Those include what is imposed by the environment,
    what the project stakeholders expect from it, and how the development team decides
    the path forward. However, despair not: even if this does not feel like standard
    C++, it solves a very real-life problem. Behind the scenes, there hides a cutting-edge
    implementation, which has been tested, approved, improved, and used in several
    small- and large-scale projects. It has stood the test of time.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节无法回答这个问题，因为最终，这取决于每个项目的具体要求。这些要求包括环境强加的、项目利益相关者期望的，以及开发团队决定前进道路的方式。然而，不要绝望：即使这看起来并不像标准的
    C++，它解决了非常现实的问题。幕后隐藏着一个尖端实现，它已经经过测试、批准、改进，并在几个小型和大型项目中使用。它经受了时间的考验。
- en: 'Microsoft’s own large-scale extension to the C++ language comes from a different
    approach. While not being a specific tool such as Qt’s MOC, C++/CLI extends C++
    with .NET-specific syntax. The Visual Studio compiler for C++/ **CLI** (as in,
    **Common Language Infrastructure** , not Command Line Interface) can parse this
    extended syntax and generate valid Common Intermediate Language (which is a low-level,
    platform-independent instruction set used by the .NET framework) and native code.
    The following code sequence is an example of this managed C++. It does nothing
    special; it just concatenates the elements of an array of strings and prints the
    result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对 C++ 语言的自身大规模扩展采用了一种不同的方法。虽然它不是一个像 Qt 的 MOC 这样的特定工具，但 C++/CLI 通过 .NET 特定的语法扩展了
    C++。C++/ **CLI**（即，**通用语言基础设施**，而非命令行界面）的 Visual Studio 编译器可以解析这种扩展语法，并生成有效的通用中间语言（这是一个由
    .NET 框架使用的低级、平台无关的指令集）和本地代码。以下代码序列是这种托管 C++ 的一个示例。它并没有做任何特别的事情；它只是将字符串数组的元素连接起来并打印结果：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I totally agree; it is anything but standard C++. It does not look like standard
    C++, it does not feel like standard C++, and it doesn’t even quack like standard
    C++. So, it must not be that. The standard-compliant C++ code having the same
    functionality would look like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我完全同意；这根本不是标准C++。它看起来不像标准C++，感觉也不像标准C++，甚至听起来也不像标准C++。所以，它肯定不是那个。具有相同功能的符合标准的C++代码看起来如下：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Isn’t it nicer, shorter, and more concise than the previous one? Not to mention
    the fact that it is also standard-conformant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是比之前的一个更简洁、更短、更简洁吗？更不用说它也是符合标准的了。
- en: It will be interesting to observe the evolution of the managed extensions of
    C++ in the future.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 观察C++管理扩展在未来如何演变将会很有趣。
- en: Right now, it serves as a bridge between native and managed code, which is a
    very niche field for the moment. However, in the long term, its survival is heavily
    dependent on how the developer communities will embrace it (or not), whether the
    ecosystem it has created will be of enough use to keep it alive, or whether other
    technologies, such as P/Invoke or COM Interop, will take over the specific uses
    cases that C++/CLI handles right now.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，它充当原生代码和管理代码之间的桥梁，目前这是一个非常狭窄的领域。然而，从长远来看，它的生存高度依赖于开发者社区是否接受它（或者不接受），它所创建的生态系统是否足够有用以维持其活力，或者是否其他技术，如P/Invoke或COM
    Interop，将接管C++/CLI目前处理的特定用例。
- en: There are interesting times ahead, indeed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，前方有有趣的时光在等待。
- en: The curious case of C++ locked in a box
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++被锁在盒子里的奇特案例
- en: Up until now, we have observed cases where the standard compliance was at the
    developers’ own discretion. They had the option to choose their platform, use
    the extensions provided by their favorite compiler, or go for pure standard C++.
    However, out there in the wild wide world, there are certain circumstances wherein
    we cannot fully comply with the standard due to some restrictions imposed upon
    us by the environment that disallows the usage of certain features found in the
    C++ standard.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们已经观察到一些情况，其中标准符合性是由开发者自行决定的。他们可以选择他们的平台，使用他们最喜欢的编译器提供的扩展，或者选择纯标准C++。然而，在这个广阔的世界中，有一些情况下，由于环境对我们施加的限制，我们无法完全遵守标准，因为某些C++标准中发现的特性被禁止使用。
- en: Not considering obscene scenarios, when we must maintain decades-old legacy
    code written in the golden age of C++ (i.e., before the standardization committee
    took over and ruined all the fun by demanding standard compliance, in order to
    avert the uncontrollable spread of C++ dialects as happened with **BASIC** ),
    there are situations outside of our control that make the usage of the full C++
    standard features impossible. For example, there might be certain requirements
    that disallow the usage of exceptions. Other environments may lack the proper
    support for memory allocation, while others still simply force us to write to
    direct hardware addresses in order for something to happen. However, this last
    one can happen in a standard-compliant way too.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑低俗场景，当我们必须维护那些在C++的黄金时代编写的几十年老代码（即，在标准化委员会接管并因要求符合标准而破坏了所有乐趣之前，为了防止C++方言如**BASIC**那样无法控制的扩散），我们可能会遇到一些超出我们控制的情况，使得无法使用完整的C++标准特性。例如，可能会有某些要求禁止使用异常。其他环境可能缺乏适当的内存分配支持，而其他环境则可能强制我们直接写入硬件地址以使某些事情发生。然而，这最后一种情况也可以以符合标准的方式发生。
- en: Some embedded systems, for example, actively encourage the usage of their platform-specific
    assembly instructions. As we know, there is no such thing as a platform-independent
    assembly language because that is the lowest level one can go to in today’s C++.
    Below that is pure hexadecimal machine code, but long gone are the times when
    we had to use that in C++ code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些嵌入式系统积极鼓励使用它们平台特定的汇编指令。众所周知，没有平台无关的汇编语言，因为那是今天C++可以到达的最低级别。在其下方是纯十六进制机器代码，但那些在C++代码中必须使用那种代码的时代已经一去不复返了。
- en: There might also be scenarios wherein the requirements formulated for our code
    by the hardware require deterministic behavior. This, by definition, excludes
    exceptions (because who would like to be unable to follow the code flow at every
    nanosecond during its execution?) and memory allocations (because of allocation
    latency, memory fragmentation, and a myriad of other issues your code is again
    not behaving in a deterministic manner). Thus, a large chunk of the C++ standard
    falls out of our grace.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在这样的情况，我们代码的硬件要求需要确定性行为。根据定义，这排除了异常（因为谁愿意在执行过程中每纳秒都无法跟踪代码流程呢？）和内存分配（因为分配延迟、内存碎片化以及代码再次不按确定性方式行为的一系列其他问题）。因此，大量C++标准的内容都不在我们的考虑范围内。
- en: There are certain solutions tackling the problem of memory allocation in embedded
    systems, such as the usage of memory pools, object pools, compile time memory
    allocation, and various other resources, which may be even platform-specific in
    turn. Then there are the exceptions. In his excellent paper [7](B22235_02.xhtml#footnote-001)
    , Bjarne Stroustrup discusses the challenges, costs, and risks involved in replacing
    C++ exceptions with alternatives such as deterministic exceptions. However, as
    the paper concludes, at this moment, there are no clear advantages to replacing
    the current exception-handling mechanisms with something else. That would include
    another fragmentation in the C++ developer community, as if there aren’t enough
    of those already. Instead, the paper argues for the importance of focusing on
    enhancing the current exception-handling system rather than complicating the language
    with additional mechanisms, emphasizing that exceptions, despite their imperfections,
    have effectively served a vast number of developers for decades.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统中的内存分配问题，有一些解决方案，例如使用内存池、对象池、编译时内存分配以及各种其他资源，这些资源可能甚至是平台特定的。然后还有异常。在Bjarne
    Stroustrup的出色论文[7](B22235_02.xhtml#footnote-001)中，他讨论了用确定性异常等替代方案替换C++异常所涉及到的挑战、成本和风险。然而，正如论文的结论所述，目前没有明确的理由用其他机制替换当前的异常处理机制。这可能会在C++开发者社区中造成进一步的碎片化，就像现在已经有足够的碎片化一样。相反，论文主张重视增强当前的异常处理系统，而不是通过额外的机制使语言复杂化，强调尽管异常存在不完美之处，但它们已经有效地为数十年的大量开发者服务。
- en: '[7](B22235_02.xhtml#footnote-001-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[7](B22235_02.xhtml#footnote-001-backlink) [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf)'
- en: Past days of future C++
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过去和未来的C++
- en: 'The last scenario that we will explore concerning the standard compliance of
    the code you write relates to the most fundamental item in the C++ ecosystem:
    the compiler itself.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一个关于你编写的代码标准合规性的场景，与C++生态系统中最基本的项目有关：编译器本身。
- en: You see, compilers are also programs, consisting of millions and millions of
    lines of code. There are several contributors spread out on the globe working
    on them, adding new features, fixing bugs, making them more standard compliant,
    releasing the latest versions, and generally making sure that your compiler just
    works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，编译器也是程序，由数百万行代码组成。全球有多个贡献者正在从事这项工作，添加新功能、修复错误、提高其标准合规性、发布最新版本，并确保你的编译器能够正常工作。
- en: These compilers also have a development timeline. The implementation of features
    does not happen overnight, and there simply might be situations wherein, at a
    certain point in time, some compiler does not support some feature of the standard
    because there was not enough manpower to implement it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译器也有一个开发时间表。功能的实现并非一蹴而就，可能存在某些情况下，在某个时间点，某些编译器可能不支持标准中的某些功能，因为缺乏足够的人力来实现它。
- en: There is a very handy document available at the source of all C++ knowledge
    [8](B22235_02.xhtml#footnote-000) , which details the support of various C++ standard
    features and which compilers have support for a specific feature.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有C++知识来源处有一个非常实用的文档[8](B22235_02.xhtml#footnote-000)，它详细说明了各种C++标准特性的支持情况以及哪些编译器支持特定的功能。
- en: '[8](B22235_02.xhtml#footnote-000-backlink) [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[8](B22235_02.xhtml#footnote-000-backlink) [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)'
- en: At the turn of standards (or when forced to use outdated compilers that have
    not implemented some of the features yet), there have been several tricks employed
    by the C++ developer community to compensate for the lack of features in upcoming
    versions of various compilers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准转折点（或者当被迫使用尚未实现某些功能的过时编译器时），C++开发者社区已经采用了几个技巧来弥补即将到来的各种编译器版本中功能缺失的问题。
- en: When the **mutable** keyword was introduced in C++98, its implementation in
    certain compilers took a bit longer than in others. For programmers using these
    compilers, it was challenging to modify member variables in **const** member functions
    (a feature introduced in the same standard).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当在C++98中引入**mutable**关键字时，某些编译器的实现比其他编译器的实现要慢一些。对于使用这些编译器的程序员来说，在**const**成员函数中修改成员变量（该功能是在同一标准中引入的）是一项挑战。
- en: 'In situations like this, the following (quite ugly) hack had to be used to
    counteract the missing keyword:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，必须使用以下（相当丑陋）的技巧来应对缺失的关键字：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming that your computer supports **const_cast** , there is nothing wrong
    with the preceding code. However, if **const_cast** is not in the list of supported
    keywords, then you are pretty much back to a standard C style cast, such as **((Counter*)(this))->viewCount++;**
    . This should fix all your problems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的计算机支持**const_cast**，前面的代码没有问题。然而，如果**const_cast**不在支持的关键字列表中，那么你基本上回到了标准的C风格转换，例如**((Counter*)(this))->viewCount++;**。这应该可以解决你的所有问题。
- en: The **mutable** keyword was not the first one whose lack of support in compilers
    caused trouble for developers. Before C++11 introduced **constexpr** (and a few
    years after that too, for Microsoft Visual C++ programmers), compile-time constant
    expressions had to be evaluated using various template tricks (or just macros,
    but as we all know, they are evil, so let’s avoid them for as long as we can).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**mutable**关键字并不是第一个在编译器中不支持导致开发者遇到麻烦的关键字。在C++11引入**constexpr**（以及在那之后几年，对于Microsoft
    Visual C++程序员来说也是如此），编译时常量表达式必须使用各种模板技巧（或者只是宏，但众所周知，它们是邪恶的，所以让我们尽可能地避免它们）来评估。'
- en: 'For example, the following piece of code calculated the famous factorial of
    some number, before **constexpr** (but still at compile time):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段在**constexpr**之前（但仍然是在编译时）计算了某个数的著名阶乘：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The current standard implementation using a compiler that supports **constexpr**
    of the same function is certainly shorter and much easier to understand:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用支持相同函数**constexpr**的编译器的标准实现当然更短，更容易理解：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Certainly, a huge jump in the readability of the code, if I may say so.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我可以这么说的话，代码的可读性有了巨大的提升。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As this chapter has demonstrated, writing standard C++ ensures code portability,
    compatibility, and maintainability across different platforms and compilers. We
    learned that by adhering to the ISO/IEC C++ standard, we can create code that
    behaves predictably and is less prone to bugs and platform-specific issues. Standard-compliant
    C++ code also benefits from generic compiler optimizations and future language
    enhancements, while ensuring long-term relevance and performance, as we learned
    in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所展示的，编写标准C++确保代码在不同平台和编译器之间的可移植性、兼容性和可维护性。我们了解到，通过遵循ISO/IEC C++标准，我们可以创建行为可预测且不太容易出现错误和平台特定问题的代码。符合标准的C++代码还受益于通用的编译器优化和未来的语言增强，同时确保长期的相关性和性能，正如我们在本章所学到的。
- en: On the other hand, using C++ compiler-specific extensions can provide performance
    optimizations specific to a platform and compiler, access to advanced features
    that are not yet standardized, and integration with vendor-specific tools. However,
    the extension may introduce portability issues, dependencies on specific compiler
    versions, as well as divergence from standard C++ practices, which can impact
    code maintenance and interoperability across different platforms and compilers.
    We also covered this in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用C++编译器特定的扩展可以提供针对特定平台和编译器的性能优化，访问尚未标准化的高级功能，以及与供应商特定工具的集成。然而，扩展可能会引入可移植性问题，对特定编译器版本的依赖，以及与标准C++实践的偏差，这可能会影响代码在不同平台和编译器之间的维护和互操作性。我们也在本章中讨论了这一点。
- en: Therefore, we learned that adoption should be carefully considered based on
    project needs, balancing the benefits of enhanced functionality with potential
    drawbacks related to compatibility and long-term support. At this stage, we trust
    that you can make the right decision that has the best impact on your project
    and code base while allowing you to deliver the required product. Even if it’s
    your pet project that you coded in your free time on a 30-year-old machine. Compiled
    with a 30-year-old compiler.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到采纳（adoption）应该基于项目需求仔细考虑，在增强功能的好处与兼容性和长期支持相关的潜在缺点之间取得平衡。在这一阶段，我们相信您能够做出最佳决策，这对您的项目和代码库产生最佳影响，同时让您能够交付所需的产品。即使它是在您业余时间用一台30年前的机器编写的个人项目。使用30年前的编译器编译。
- en: Our next chapter, courtesy of Alex, will go on a deep exploration and try to
    uncover the basic truth of whether C++ is indeed just another object-oriented
    language, or whether there is something more lurking below the surface...
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一章，由Alex提供，将进行深入探索，试图揭示C++是否真的是另一种面向对象的语言的基本真相，或者是否在表面之下隐藏着更多的东西...
