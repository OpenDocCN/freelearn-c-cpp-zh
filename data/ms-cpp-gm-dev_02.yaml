- en: Understanding Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解库
- en: 'Understanding how libraries work is extremely important to mastering C++ game
    development. Gaining knowledge of how libraries work in C++ will allow you to
    build more robust games and tools. Often the most fundamental ingredients to create
    the core of game engines can be found in easy-to-use, *Redistributable* libraries.
    In this chapter, we will explore the key differences between library types and
    how you can create, build, and consume them. For this chapter, I am going to assume
    you have read through [Chapter 1](89c6ce5a-45ed-4161-aa86-1bc309f69102.xhtml),
    *C++ for Game Development*, and you have a general understanding of the compiling
    and linking process. This chapter consists of the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解库的工作原理对于掌握C++游戏开发非常重要。了解C++库的工作方式将使您能够构建更健壮的游戏和工具。通常，创建游戏引擎核心的最基本要素可以在易于使用的*可再分发*库中找到。在本章中，我们将探讨库类型之间的关键差异，以及如何创建、构建和使用它们。在本章中，我假设您已经阅读了[第1章](89c6ce5a-45ed-4161-aa86-1bc309f69102.xhtml)，*C++游戏开发*，并且对编译和链接过程有一般的了解。本章包括以下部分：
- en: Library build types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库构建类型
- en: Building a custom shareable library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义可共享库
- en: Why do we use libraries?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么使用库？
- en: Libraries are a key concept in C++ and they are the mechanism that allows the
    language to build modular designs and portable code. By using libraries, we are
    able to create reusable code that we can easily share among multiple programs,
    and with other developers. It allows developers to save time by not having to
    constantly rewrite a particular code chunk over and over again. It also saves
    the developers time by allowing the use of other developers solutions for commonly
    occurring problems. The **Standard Template Library** (**STL**) is a great example
    of this. STL has solutions for a large amount of problems commonly found in C++.
    These solutions include the implementation of data types such as string, containers
    such as vector, and algorithms such as sort. These standard implementations come
    from years of refinement and development. As such they tend to be incredibly performant
    and highly optimized, I would suggest defaulting to using an STD implementation
    over a handwritten implementation where applicable as a general rule. There are
    literally thousands and thousands of libraries available for C++ development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 库是C++中的一个关键概念，它是使语言能够构建模块化设计和可移植代码的机制。通过使用库，我们能够创建可重用的代码，可以轻松地在多个程序之间共享，并与其他开发人员共享。它允许开发人员节省时间，不必一遍又一遍地重写特定的代码块。它还通过允许使用其他开发人员针对常见问题的解决方案来节省开发人员的时间。**标准模板库**（**STL**）就是一个很好的例子。STL提供了大量在C++中常见的问题的解决方案。这些解决方案包括数据类型的实现，如字符串，容器，如向量，以及排序等算法。这些标准实现经过多年的改进和开发。因此，它们往往非常高效和高度优化，我建议在适用的情况下默认使用STD实现而不是手写实现。对于C++开发，有成千上万的库可供使用。
- en: Library build types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库构建类型
- en: There are a few different ways to create library files. You can use the different
    tools such as an **Integrated Development Environment** (**IDE**). Development
    environment tools such as Visual Studio and XCode, often have templates or starter
    projects included to create library files for various platforms and situations.
    Another somewhat simpler way and the way we will use here is via the command line.
    More specifically the Developer Command Prompt that comes with Visual Studio 2015
    and the terminal program that comes with macOS X. You can obtain a copy of Visual
    Studio 2015 Community edition, a free version for teams of five or fewer developers,
    at the Visual Studio website.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建库文件有几种不同的方法。您可以使用不同的工具，如**集成开发环境**（**IDE**）。开发环境工具，如Visual Studio和XCode，通常包含了用于创建各种平台和情况下的库文件的模板或起始项目。另一种更简单的方法，也是我们将在这里使用的方法，是通过命令行。更具体地说，是与Visual
    Studio 2015一起提供的开发人员命令提示符和macOS X提供的终端程序。您可以在Visual Studio网站上获取Visual Studio 2015社区版的副本，这是一个免费版本，适用于五名或更少开发人员的团队。
- en: 'To open the Developer Command Prompt on Windows 8 or higher, hit the windows
    key and start typing `developer command prompt`, and select Developer Command
    Prompt for VS2105 when it appears:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows 8或更高版本上打开开发人员命令提示符，请按Windows键，然后开始输入`developer command prompt`，并在出现时选择VS2105的Developer
    Command Prompt：
- en: '![](img/6814c5c2-614a-4c50-b03c-5462303e892f.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6814c5c2-614a-4c50-b03c-5462303e892f.png)'
- en: 'To open the Terminal on OS X, open the application launcher and type `Terminal`
    in the search bar at the top of the screen:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要在OS X上打开终端，请打开应用程序启动器，然后在屏幕顶部的搜索栏中键入`Terminal`：
- en: '![](img/41b115fc-0c1a-4e85-a412-07398b30ca62.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41b115fc-0c1a-4e85-a412-07398b30ca62.png)'
- en: To start with, let's create a basic library that we will then be able to consume
    from other programs. In this example, we will just write a simple function that
    will print out the time-honored line `Hello World`. It wouldn't be a book on programming
    without at least one hello world program. Here is the file we will use, I saved
    mine as `hello.cpp`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个基本库，然后我们将能够从其他程序中使用它。在这个例子中，我们将只编写一个简单的函数，它将打印出经典的一行`Hello World`。没有至少一个hello
    world程序的编程书籍就不完整了。这是我们将使用的文件，我将我的保存为`hello.cpp`。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Statically linked libraries
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态链接库
- en: A static library is a library that is compiled as part of the application itself.
    What this means is that all the code relating to the library is contained in a
    single file, `.lib` on Windows and `.a` on Linux/OS X systems, and it is directly
    linked into the program. A program that incorporates a static library creates
    copies of the code that it requires from the library and places that copy in the
    program where the library implementation was called. It does this for every call
    to the library. This leads to one of the larger drawbacks of using a static library,
    it increases the overall size of the executable. On the other hand, the advantage
    of using a static library is that there are no external dependencies that the
    user requires to run the program. This helps to avoid the issue of the libraries
    on the user's system being the wrong version or having to distribute it with the
    program, which can create a whole pile of problems. You will often hear this common
    issue referred to *Dll Hell*. Another advantage to static libraries are since
    they are linked as part of the build process, this will allow compilers and build
    tools more opportunities to optimize the implementations. A good rule of thumb
    to follow is, for common or standard libraries, ones that most users will have
    (OpenGL or DirectX) use dynamic or shared libraries. For less common libraries
    (GLFW or SDL) you are more likely to use a static library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库是作为应用程序的一部分编译的库。这意味着与库相关的所有代码都包含在一个单独的文件中，Windows上是`.lib`，Linux/OS X系统上是`.a`，并且直接链接到程序中。包含静态库的程序会从库中创建所需的代码副本，并将该副本放在调用库实现的程序中。对于每次调用库，都会这样做。这导致使用静态库的一个较大的缺点，即增加了可执行文件的总体大小。另一方面，使用静态库的优点是没有用户运行程序所需的外部依赖项。这有助于避免用户系统上的库版本错误或必须将其与程序一起分发的问题，这可能会产生一堆问题。您经常会听到这个常见问题被称为*Dll
    Hell*。静态库的另一个优点是，由于它们作为构建过程的一部分进行链接，这将使编译器和构建工具有更多机会优化实现。一个很好的经验法则是，对于大多数用户都会有的常见或标准库（如OpenGL或DirectX），使用动态或共享库。对于较不常见的库（如GLFW或SDL），您更有可能使用静态库。
- en: 'To turn our `hello.cpp` file into a static library from the Developer Command
    Prompt, we follow the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`hello.cpp`文件转换为静态库，我们可以在开发人员命令提示符中按照以下步骤进行操作：
- en: On Windows
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上
- en: 'Follow these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: 'For Windows, you need to type the following command:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Windows，您需要输入以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`cl` is the command to compile and link. The `/c` tells the compiler we only
    want to compile and not link our file. Finally, we pass in the file we want to
    compile. This will create an object file, `hello.obj`, that we can then use to
    create our static library file.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`cl`是编译和链接的命令。`/c`告诉编译器我们只想编译而不链接我们的文件。最后，我们传入要编译的文件。这将创建一个对象文件`hello.obj`，然后我们可以使用它来创建我们的静态库文件。'
- en: 'Now that we have our object file created, we can use a library building tool
    to create our static library. We use the following command to generate a `.lib`
    file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了对象文件，我们可以使用库构建工具创建静态库。我们使用以下命令生成`.lib`文件：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`lib` is the command to launch the build tool. The `/out:MyLib.lib` tells the
    compiler to name the library build `MyLib.lib`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`是启动构建工具的命令。`/out:MyLib.lib`告诉编译器将库构建命名为`MyLib.lib`。'
- en: 'If we list the contents of the directory, you will see we now have our static
    library `MyLib.lib`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果列出目录的内容，您会看到我们现在有了静态库`MyLib.lib`：
- en: '![](img/f897d059-c8f4-44d0-a468-0b6cb07d8f84.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f897d059-c8f4-44d0-a468-0b6cb07d8f84.png)'
- en: 'We can now consume our newly created library in other projects. Let''s create
    a very simple program that will use our library:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在其他项目中使用我们新创建的库。让我们创建一个非常简单的程序来使用我们的库：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I saved the file as `main.cpp`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我将文件保存为`main.cpp`。
- en: This program will call the `Hello` function which the compiler we then look
    for an implementation in our linked libraries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将调用`Hello`函数，编译器将在我们的链接库中寻找实现。
- en: 'To compile this program and link our static library, we can use the following
    command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译此程序并链接我们的静态库，可以使用以下命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the compile has finished, we will now have a `main.exe` on Windows in
    our directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，我们现在在Windows目录中有一个`main.exe`：
- en: '![](img/55a06c90-9d02-48d8-88c0-d59f56b3f557.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55a06c90-9d02-48d8-88c0-d59f56b3f557.png)'
- en: On macOS X
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS X上
- en: 'Follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行操作：
- en: 'For macOS X, you need to type the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于macOS X，您需要输入以下命令：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`g++` is the open source compiler we are using. The flag `-c` tells `g++` to
    output an object file. After the flag, we state which cpp file to use when building
    the object file. This command will produce the file `hello.o`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`g++`是我们使用的开源编译器。标志`-c`告诉`g++`输出一个对象文件。在标志之后，我们指定了构建对象文件时要使用的cpp文件。此命令将生成文件`hello.o`。'
- en: 'On the macOS X platform, we use the following command to generate an `.a` file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS X平台上，我们使用以下命令生成`.a`文件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ar`, short for archiver, is the library building tool that we use to create
    our static library. First we set a few flags, `rvs`, which tell the `ar` tool
    how to set up the library archive. We then tell the tool the name of the library
    we are creating, followed by the object file(s) that make up the library.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ar`是我们用来创建静态库的库构建工具。首先我们设置了一些标志，`rvs`，告诉`ar`工具如何设置库存档。然后我们告诉工具我们正在创建的库的名称，然后是组成库的对象文件。'
- en: 'If we list the contents of the directory, you will see we now have our static
    library `Mylib.a`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出目录的内容，您会看到我们现在有了静态库`Mylib.a`：
- en: '![](img/eae70479-600b-483e-8dd3-14d18cd1b56a.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eae70479-600b-483e-8dd3-14d18cd1b56a.png)'
- en: 'We can now consume our newly created library in other projects. Let''s create
    a very simple program that will use our library:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在其他项目中使用我们新创建的库。让我们创建一个非常简单的程序来使用我们的库：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I saved the file as `main.cpp`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我将文件保存为`main.cpp`。
- en: This program will call the `Hello` function which the compiler we then look
    for an implementation in our linked libraries.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将调用`Hello`函数，编译器将在我们的链接库中寻找实现。
- en: 'We compile the program and link our static library with the following command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令编译程序并链接我们的静态库：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once the compile has finished, we will now have a `main.exe` on Windows, or
    a main executable file on macOS X, in our directory.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，我们现在将在我们的目录中有一个`main.exe`（在Windows上）或一个主可执行文件（在macOS X上）。
- en: '![](img/42e2d0c3-520e-4c5b-8ab2-100dc2587ece.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42e2d0c3-520e-4c5b-8ab2-100dc2587ece.png)'
- en: Notice the size of this executable file for Windows and macOS X. Again, since
    we are statically linking our library, we actually include the necessary parts
    of the library in the executable itself. This eliminates the need to package the
    library with the program separately, which stops the library mismatches. In fact,
    now that the library, `.lib` file, has been compiled into the executable we no
    longer need it and can delete it. Our program will still run, but if we want to
    make any changes to the library, we would have to repeat the preceding steps to
    recompile the library, link it, and add it to our program's build.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Windows和macOS X上这个可执行文件的大小。再次，因为我们在静态链接我们的库，实际上我们将库的必要部分包含在可执行文件中。这消除了需要单独打包库与程序的需求，从而阻止了库的不匹配。事实上，现在库（.lib文件）已经编译到可执行文件中，我们不再需要它，可以删除它。我们的程序仍然可以运行，但是如果我们想对库进行任何更改，我们将不得不重复前面的步骤来重新编译库，链接它，并将其添加到我们程序的构建中。
- en: Dynamically linked libraries
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态链接库
- en: Dynamic or shared libraries are libraries that have their code implementations
    linked at runtime. What this means is that a dynamic library, `.dll` on Windows,
    `.so` on Linux, and `.dylib` on OS X, are the libraries that can be referenced
    in the source code of a program. When a compiler sees these references it looks
    for links in the library implementation. The referenced code is included through
    these created links when the program is launched. When a program uses a dynamic
    library, it only creates references to the code, not any copies of the code. This
    is one of the biggest advantages of using dynamic libraries, since they are only
    referenced hence they do not add to the overall size of the executable like a
    static library does. Another big advantage of using a dynamic library is maintainable
    or modification. Since the library is included at runtime, you can make updates
    or modifications without having to recompile the whole program. This is great
    for *patch* style updates and for allowing the modifications by the user themselves.
    The biggest disadvantage, is the one I mentioned earlier. Using dynamic libraries
    usually requires you to include the library with the program in some sort of package
    or installer. This of course could lead to mismatches and the dreaded Dll Hell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 动态或共享库是在运行时链接其代码实现的库。这意味着动态库在程序源代码中可以被引用。当编译器看到这些引用时，它会在库实现中查找链接。当程序启动时，通过这些创建的链接包含了引用的代码。当程序使用动态库时，它只会创建对代码的引用，而不是代码的任何副本。这是使用动态库的最大优势之一，因为它们只是被引用，因此不像静态库那样增加可执行文件的总体大小。使用动态库的另一个重要优势是可维护性或修改。由于库是在运行时包含的，您可以进行更新或修改，而无需重新编译整个程序。这对于*补丁*样式的更新以及允许用户自己进行修改非常有用。最大的缺点是我之前提到的。通常需要将动态库与程序一起打包或安装。当然，这可能导致不匹配和可怕的Dll
    Hell。
- en: For dynamic or shared libraries, we have to make a few modifications and follow
    slightly different steps for compilation and linking. To begin with, we will have
    to change our library file to let the compiler know that we would like to share
    certain parts with other programs. We do this, on the Microsoft platform, with
    `__declspec` or declaration specification. Passing the `dllexport` parameter to
    `__declspec` lets the compiler know that this function or even classes should
    be exported as part of the dynamic linked library. On the OS X platform, we also
    use a type of declaration to let the compiler know that the classes or functions
    are to be exported. Here we use `__attribute__((visibility("default")))` in place
    of `__declspec`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态或共享库，我们必须进行一些修改并遵循略有不同的编译和链接步骤。首先，我们必须更改我们的库文件，让编译器知道我们希望与其他程序共享某些部分。在Microsoft平台上，我们使用`__declspec`或声明规范来实现这一点。将`dllexport`参数传递给`__declspec`让编译器知道这个函数甚至类应该作为动态链接库的一部分导出。在OS
    X平台上，我们还使用一种声明类型来让编译器知道这些类或函数要导出。在这里，我们使用`__attribute__((visibility("default")))`代替`__declspec`。
- en: Compiling and linking dynamic libraries on Windows
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上编译和链接动态库
- en: 'Following are the step for compiling and linking dynamic libraries on Windows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Windows上编译和链接动态库的步骤：
- en: 'The `hello.cpp` file would now look like:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello.cpp`文件现在看起来是这样的：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have the function specified for export, we can compile the file
    into a dynamically shared library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了要导出的函数，我们可以将文件编译成一个动态共享库。
- en: 'On Windows, we can create a `.dll` from the developer console prompt with the
    following command:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以使用以下命令从开发者控制台提示符创建一个`.dll`。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again `cl` is the command to launch the compiler and linker. The `/LD` tells
    the compiler that we want to create a dynamically linked library. The `/FeMyDynamicLib.dll`
    sets the name of the library `/Fe` being the compiler option and `MyDynamicLib.dll`
    being the name. Finally, again, we pass in the file(s) we want to use to create
    the library.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`cl`是启动编译器和链接器的命令。`/LD`告诉编译器我们要创建一个动态链接库。`/FeMyDynamicLib.dll`设置库的名称，`/Fe`是编译器选项，`MyDynamicLib.dll`是名称。最后，再次传入我们要使用的文件。
- en: 'When the compiler is finished, and we list the directory, we will now have
    both `MyDynamicLib.lib` and `MyDynamicLib.dll`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编译器完成后，我们列出目录，现在将有`MyDynamicLib.lib`和`MyDynamicLib.dll`两个文件：
- en: '![](img/ce4c0d05-71c5-48e9-97ba-0eef07fb6301.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce4c0d05-71c5-48e9-97ba-0eef07fb6301.png)'
- en: The first thing you may have noticed is that this version of the `.lib` file
    is much smaller than in the previous static library example. This is because the
    implementation is not stored in this file. Instead, it acts as a pointer to the
    actual implementation in the `.dll` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到的第一件事是，这个版本的`.lib`文件比之前的静态库示例要小得多。这是因为实现不存储在这个文件中。相反，它充当指向`.dll`文件中实际实现的指针。
- en: 'Next, we can link and build our program with our newly created library exactly
    like the previous example with the following commands (on Windows):'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下命令（在Windows上）链接和构建我们的程序与我们新创建的库，就像前面的例子一样：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So now if we run the program and will see the line `Hello World Dynamically!`
    displayed:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以现在如果我们运行程序，会看到显示`Hello World Dynamically!`这一行：
- en: '![](img/5e5c8886-ccfd-4b55-8826-5927d003cda7.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e5c8886-ccfd-4b55-8826-5927d003cda7.png)'
- en: 'If we do a listing of the directory now, we will notice that the new main executable,
    like the `.lib` file from this example, is much smaller than the previous version
    that used the static library. This, again, is because we do not include the needed
    parts from the library at build time. Instead, we are loading them as needed at
    runtime, dynamically:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在列出目录，会注意到新的主可执行文件，就像这个例子中的`.lib`文件一样，比使用静态库的上一个版本要小得多。这是因为我们在构建时没有包含库的所需部分。相反，我们在运行时按需加载它们，动态地：
- en: '![](img/7e50cd47-2b0c-4d89-b481-e475d34959d9.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e50cd47-2b0c-4d89-b481-e475d34959d9.png)'
- en: 'One of the bonuses I mentioned earlier is the fact that when you make changes
    to a dynamically linked library, you do not have to recompile the entire program;
    we only have to recompile the library. To see this in action, let''s make a small
    change to the `hello.cpp` file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我之前提到的一个好处是，当您对动态链接库进行更改时，您不必重新编译整个程序；我们只需要重新编译库。为了看到这一点，让我们对`hello.cpp`文件进行一些小改动：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we can recompile our library with the same command as before:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用与之前相同的命令重新编译我们的库：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will add our new changes, and we can see them take effect without recompiling
    `main.exe`, and simply running it instead. The output will now be the two lines:
    `Hello World Dynamically!` and `Version 2`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将添加我们的新更改，我们可以看到它们在不重新编译`main.exe`的情况下生效，只需运行它。输出现在将是两行：`Hello World Dynamically!`和`Version
    2`：
- en: '![](img/9f57f7e6-bf83-4448-94b4-8978166b2bb4.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f57f7e6-bf83-4448-94b4-8978166b2bb4.png)'
- en: This makes upgrading very easy, but can also quickly lead Dll mismatching on
    machines without the updated library, often referred to as Dll Hell.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得升级非常容易，但也很容易在没有更新的库的机器上迅速导致Dll不匹配，通常被称为Dll地狱。
- en: Compiling and linking dynamic libraries On macOS X
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS X上编译和链接动态库
- en: 'The `hello.cpp` file would now look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`hello.cpp`文件看起来会是这样：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can create a `.dylib` from the terminal shell with the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从终端shell创建`.dylib`文件：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we use the `g++` compiler and set a flag to create a dynamic library file,
    `-dynamiclib`. The next flag `-o MyDynamicLib.dylib`, tells the compiler what
    to name the outputted file. Finally, we specify the file(s) to use when creating
    the library. If you list the directory now, you will see the newly created `MyDynamicLib.dylib`
    file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`g++`编译器，并设置一个标志来创建一个动态库文件，`-dynamiclib`。接下来的标志`-o MyDynamicLib.dylib`告诉编译器输出文件的名称。最后，我们指定创建库时要使用的文件。如果你现在列出目录，你会看到新创建的`MyDynamicLib.dylib`文件：
- en: '![](img/b1018c29-10de-473a-ada8-8ca306a3afea.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1018c29-10de-473a-ada8-8ca306a3afea.png)'
- en: 'Next, we can link and build our program with our newly created library exactly
    like the previous example with the following commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用以下命令链接和构建我们的程序与我们新创建的库，就像前面的例子一样：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So now if we run the program and will see the line `Hello World Dynamically!`
    displayed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在如果我们运行程序，会看到显示`Hello World Dynamically!`这一行：
- en: '![](img/fb956f82-2de2-49f2-8bad-f813baa73d30.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb956f82-2de2-49f2-8bad-f813baa73d30.png)'
- en: 'If we do a listing of the directory now, you will notice that the new main
    executable, like the `.lib` file from this example, is much smaller than the previous
    version that used the static library. This, again, is because we do not include
    the needed parts from the library at build time. Instead, we are loading them
    as needed at runtime, dynamically:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在列出目录，你会注意到新的主可执行文件，就像这个例子中的`.lib`文件一样，比使用静态库的上一个版本要小得多。这是因为我们在构建时没有包含库的所需部分。相反，我们在运行时按需加载它们，动态地：
- en: '![](img/41fa7209-5a9f-4fc2-8560-4b2f1d32b8be.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41fa7209-5a9f-4fc2-8560-4b2f1d32b8be.png)'
- en: 'One of the bonuses I mentioned earlier is the fact that when you make changes
    to a dynamically linked library, you do not have to recompile the entire program;
    we only have to recompile the library. To see this in action, let''s make a small
    change to the `hello.cpp` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的一个好处是，当您对动态链接库进行更改时，您不必重新编译整个程序；我们只需要重新编译库。为了看到这一点，让我们对`hello.cpp`文件进行一些小改动：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we can recompile our library with the same command as before:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用与之前相同的命令重新编译我们的库：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output from the preceding command will be like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的输出将会是这样：
- en: '![](img/43abc55f-b279-4085-bf3b-8067abe90703.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43abc55f-b279-4085-bf3b-8067abe90703.png)'
- en: This makes upgrading very easy, but can also quickly lead Dll mismatching on
    machines without the updated library, often referred to as Dll Hell.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得升级非常容易，但也很容易在没有更新的库的机器上迅速导致Dll不匹配，通常被称为Dll地狱。
- en: Header only or source libraries
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅有头文件或源文件的库
- en: There is one last way to share libraries that I want to mention, and that is
    simply sharing the source or header implementation. This is an entirely legitimate
    way to share libraries and is very common among open source and smaller projects.
    It has the clear bonus of providing the source for modification and can easily
    allow the consuming developer to pick and choose which parts they would like to
    implement in their project. This can also be seen as a drawback, though, as now
    your source code is available publicly. By offering your code openly and freely,
    you give up a lot of control over its use and depending on the licensing could
    have little or no proprietary claims to the solution it implements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到的最后一种共享库的方式是简单地共享源代码或头文件实现。这是一种完全合法的共享库方式，在开源和较小的项目中非常常见。它的明显优点是提供修改的源代码，并且可以让使用的开发人员轻松选择他们想要在项目中实现的部分。不过，这也可以被视为一个缺点，因为现在您的源代码是公开可用的。通过公开和自由地提供您的代码，您放弃了对其使用的控制，并且根据许可可能对其实现的解决方案几乎没有专有权主张。
- en: 'To change our little example to a header only implementation, we would simply
    change the `hello.cpp` file into a header file, `hello.h`, and do all the function''s
    implementation inside. Our new `hello.h` file will now look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的小例子更改为仅包含头文件的实现，我们只需将`hello.cpp`文件更改为头文件`hello.h`，并在其中执行所有函数的实现。我们的新`hello.h`文件现在将如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then to consume the header library, we will include it in the `main.cpp` file
    just like any other header file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了使用头文件库，我们将在`main.cpp`文件中包含它，就像包含任何其他头文件一样：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since we are using the header only implementation, we don't have the worry of
    linking the library during the build process. We can compile the program from
    the developer console prompt with the following command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是仅包含头文件的实现，我们不必担心在构建过程中链接库。我们可以使用以下命令从开发人员控制台提示符编译程序。
- en: 'On Windows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once compiled, you can run the main executable and see similar a hello world
    message, `Hello World Header!`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，您可以运行主可执行文件并看到类似的hello world消息，“Hello World Header!”：
- en: '![](img/ea937f03-5695-4bb1-8c9b-99b53d29a764.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea937f03-5695-4bb1-8c9b-99b53d29a764.png)'
- en: 'On macOS X:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS X上：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once compiled, you can run the main executable and see similar a hello world
    message, `Hello World Header!`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，您可以运行主可执行文件并看到类似的hello world消息，“Hello World Header!”：
- en: '![](img/2f6cfc05-c84b-42f4-aacf-35f27b59af36.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f6cfc05-c84b-42f4-aacf-35f27b59af36.png)'
- en: Building a custom shareable library
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义可共享库
- en: Having the ability to create your own custom library is an extremely valuable
    skill. Building a strong understanding of the steps needed to create, build, and
    consume libraries will allow you to create more capable systems and solutions.
    In the next section, we dive a little deeper and take a look at how you can create
    then build and consume a shareable library project in a managed development environment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有创建自定义库的能力是一项非常有价值的技能。建立对创建、构建和使用库所需步骤的深入了解，将使您能够创建更有能力的系统和解决方案。在下一节中，我们将深入探讨如何在受控开发环境中创建、构建和使用可共享库项目。
- en: Setup and structure
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和结构
- en: For this example, I am going to stick with using Visual Studio for Windows,
    and XCode for macOS X. While some of the exact details will be different in each
    development environment, it should not be too difficult to extrapolate the steps.
    You can find the full source for this example in the `Chapter02` folder of the
    code repository.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我将继续在Windows上使用Visual Studio，并在macOS X上使用XCode。虽然在每个开发环境中一些确切的细节会有所不同，但推断这些步骤应该不会太困难。您可以在代码存储库的`Chapter02`文件夹中找到此示例的完整源代码。
- en: To start we will create a new project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新项目。
- en: Creating a new project on Windows
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上创建新项目
- en: 'On Windows, we can do this by going to File|New|Project, then expanding the
    Visual C++ drop down and finally selecting Win32 Console Application. I named
    my new project `MemoryMgr`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们可以通过转到文件|新建|项目，然后展开Visual C++下拉菜单，最后选择Win32控制台应用程序来完成这个操作。我将我的新项目命名为`MemoryMgr`：
- en: '![](img/9cfc23a9-839d-4a3f-a4ee-33bf3e4c5572.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cfc23a9-839d-4a3f-a4ee-33bf3e4c5572.png)'
- en: 'Once you select OK, the Win32 Application Wizard dialog will pop up. Click
    on Next to move the dialog to the next page:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择了“确定”，Win32应用程序向导对话框将弹出。单击“下一步”将对话框移动到下一页：
- en: '![](img/88990b87-f00e-4255-a007-ff58e426161e.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88990b87-f00e-4255-a007-ff58e426161e.png)'
- en: On this dialog page, we are presented a few different application settings.
    For our Application type, we are going to select DLL. This will create a `.dll`
    and accompanying `.lib` file that we can then share and consume. The reason we
    are picking a dynamic or shared library as opposed to a static library is because
    I can demonstrate how to build and compile a shareable library. This is a simplistic
    memory manager library that in most cases would be included in a suite of other
    utility libraries. We could easily modify this library to be static, see the previous
    section for an explanation on how.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框页面上，我们提供了一些不同的应用程序设置。对于我们的应用程序类型，我们将选择DLL。这将创建一个`.dll`和相应的`.lib`文件，然后我们可以共享和使用。我们选择动态或共享库而不是静态库的原因是因为我可以演示如何构建和编译可共享库。这是一个简单的内存管理器库，在大多数情况下，它将包含在一套其他实用程序库中。我们可以很容易地修改此库为静态库，有关说明，请参见上一节。
- en: 'Select the option for Empty project, this will give us a completely blank project
    from which we can build our library. This will also gray out most of the other
    options, such as the Precompiled header in the Additional options. This is a commonly
    used option to help speed up the compilation of large projects by calling all
    or most needed header files in a single header file, which you then add as a single
    header to other implementation files. You can leave Security Development Lifecycle
    (SDL) checks selected as it will not cause any issues. Click on Finish to exit
    the dialog and open the new project:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 选择空项目选项，这将为我们提供一个完全空白的项目，我们可以从中构建我们的库。这也会使大多数其他选项变灰，例如附加选项中的预编译头。这是一个常用的选项，通过在单个头文件中调用所有或大多数需要的头文件，然后将其作为单个头文件添加到其他实现文件中，来帮助加快大型项目的编译速度。您可以将安全开发生命周期（SDL）检查保留为选定状态，因为它不会引起任何问题。单击完成退出对话框并打开新项目：
- en: '![](img/2024de63-431e-4619-b6b7-4229a5f99c87.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2024de63-431e-4619-b6b7-4229a5f99c87.png)'
- en: Once the project is loaded, we are greeted with a blank editor window and empty
    solution explorer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 项目加载后，我们将看到一个空白的编辑器窗口和空的解决方案资源管理器。
- en: Creating a new project on macOS X
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS X上创建一个新项目
- en: 'We create a new project by going to File|New|Project, then selecting OS X from
    the platform list, and then Library from the template choices:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过转到文件|新建|项目来创建一个新项目，然后从模板选择中选择OS X，然后选择库：
- en: '![](img/b0dad365-da6e-4ee8-a462-52a233b808d1.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0dad365-da6e-4ee8-a462-52a233b808d1.png)'
- en: 'Once you click on Next, a dialog with project setting options will appear.
    These options include the Product Name, which I chose `MemoryMgr` for, Organization
    Name and Organization Identifier, which I left as the default choices. In a production
    setting, you would want to adjust these to match your project. The last two options
    are Framework and Type. For the Framework, select STL (C++ Library) this is the
    template used when working with a library that will include access to the STL.
    For Type select Dynamic, there is also the option for a static library project:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单击下一步后，将出现一个包含项目设置选项的对话框。这些选项包括产品名称，我选择了`MemoryMgr`，组织名称和组织标识符，我将其保留为默认选择。在生产环境中，您需要调整这些选项以匹配您的项目。最后两个选项是框架和类型。对于框架，选择STL（C++库），这是在使用将包括对STL的访问权限的库时使用的模板。对于类型，选择动态，还有一个静态库项目的选项：
- en: '![](img/d982505a-7bde-41da-a7e1-b3ae121f3cc4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d982505a-7bde-41da-a7e1-b3ae121f3cc4.png)'
- en: Our next step is to create the source files that we will need for the library.
    In this example, we will only be creating one class consisting of a single header,
    `.h`, and implementation file, `.cpp`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是创建库所需的源文件。在这个例子中，我们只会创建一个类，包括一个单独的头文件`.h`和实现文件`.cpp`。
- en: Creating source files on Windows
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上创建源文件
- en: We can add this class quickly in Visual Studio using the Add | Class... dialog.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用添加|类...对话框在Visual Studio中快速添加此类。
- en: 'Right-click on the MemoryMgr project in the Solution Explorer; navigate to
    Add|Class from the menu list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击MemoryMgr项目，导航到添加|类：
- en: '![](img/a9af827e-b124-4e51-9211-9244e4078f8a.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9af827e-b124-4e51-9211-9244e4078f8a.png)'
- en: A new screen will pop up with a few options for creating new classes; we are
    just going to use the default generic C++ Class option.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的屏幕将弹出，其中有一些选项用于创建新的类；我们只会使用默认的通用C++类选项。
- en: Select Add to advance to the next dialog screen. We are now on the Generic C++
    Class Wizard screen. In the Class name section, add the name of the new class
    you are creating, in my case I called it `MemoryMgr`. When you enter the class
    name, the wizard will auto populate the .h file and .cpp file for you. Since this
    is not a class that is inheriting, we can leave the Base class section empty.
    We will leave Access at the default setting of public, and finally we will leave
    the Virtual destructor and Inline options unchecked.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选择添加以进入下一个对话框屏幕。现在我们在通用C++类向导屏幕上。在类名部分添加您要创建的新类的名称，在我的例子中我称之为`MemoryMgr`。当您输入类名时，向导将自动为您填充.h文件和.cpp文件。由于这不是一个继承的类，我们可以将基类部分留空。我们将访问保留在公共的默认设置，并且最后我们将保持虚析构函数和内联选项未选中。
- en: 'Click on Finish to add the class to our project:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 单击完成以将类添加到我们的项目中：
- en: '![](img/61f33ca0-b7bd-4717-ac25-ba639fb1815c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61f33ca0-b7bd-4717-ac25-ba639fb1815c.png)'
- en: 'Of course, this would be the exact same as if we simply typed out the full
    export specifier like so:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这与我们简单地键入完整的导出说明符是一样的：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating source files on macOS X
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS X上创建源文件
- en: 'This step is already done for us by default. The project creation wizard automatically
    includes an implementation file, `.cpp` and a Header File, but in this case the
    header file''s extension is `.hpp`. The automatically created files also have
    a bunch of stubbed code to help get things started. In our example case, to make
    things more coherent, we are going to delete this stubbed code and remove both
    `.hpp` files. Instead we are going to create a new `.h` file and insert our own
    code. To create a new `.h` file is quite simple, navigate to File|New|File. In
    the new file dialog, select OS X from the platform list on the left and Header
    File from the type selection window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步已经默认为我们完成。项目创建向导会自动包含一个实现文件`.cpp`和一个头文件，但在这种情况下，头文件的扩展名是`.hpp`。自动生成的文件还包含一堆存根代码，以帮助启动项目。在我们的示例中，为了使事情更连贯，我们将删除这些存根代码并删除两个`.hpp`文件。而是我们将创建一个新的`.h`文件并插入我们自己的代码。创建一个新的`.h`文件非常简单，导航到文件|新建|文件。在新文件对话框中，从左侧的平台列表中选择OS
    X，然后从类型选择窗口中选择头文件：
- en: '![](img/e433128c-2c31-4a14-8277-9ab9bab8eaec.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e433128c-2c31-4a14-8277-9ab9bab8eaec.png)'
- en: Clicking on the Next button will bring up the file save dialog. Save the file
    as `MemoryMgr.h`, notice I specified `.h` as the extension. If you do not specify
    the extension, the wizard will default to `.hpp`. Also of note, make sure the
    target project is selected at the bottom of the dialog, this will make sure it
    is counted as part of the XCode project solution.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下一步”按钮将弹出文件保存对话框。将文件保存为`MemoryMgr.h`，请注意我指定了`.h`作为扩展名。如果您不指定扩展名，向导将默认为`.hpp`。还要注意的是，确保在对话框底部选择了目标项目，这将确保它被视为XCode项目解决方案的一部分。
- en: '![](img/f48dc14e-33c7-458b-a7ef-a0aa29452e86.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f48dc14e-33c7-458b-a7ef-a0aa29452e86.png)'
- en: 'You project layout should now look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目布局现在应该如下所示：
- en: '![](img/a3ee73e6-8992-42f3-bec3-939aaf32eb7a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3ee73e6-8992-42f3-bec3-939aaf32eb7a.png)'
- en: 'Now it''s time for the code. We will start with the `MemoryMgr` header file,
    `MemoryMgr.h`. In this file, we will declare all the functions and variables we
    will be using along with the definitions that will provide access to our dynamic
    library. Here is `MemoryMgr.h` with the comments removed for brevity:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编写代码的时候了。我们将从`MemoryMgr`头文件`MemoryMgr.h`开始。在这个文件中，我们将声明所有我们将使用的函数和变量，以及将提供对我们动态库访问的定义。这是`MemoryMgr.h`，已经删除了注释以保持简洁：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full file contents are available in the code repository in the `Chapter02` folder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文件内容可以在`Chapter02`文件夹中的代码库中找到。
- en: The first step we take when creating the new dynamic library is a helpful shortcut
    that allows us to save a few keystrokes and simply the creation of exported classes,
    functions, or variables. Using `ifdef` directives, we can first create an identifier
    for our memory manager, `MEMORYMGR_EXPORTS`, then for the target platforms, `_WIN32`
    for Windows and `__APPLE__` for macOS X. Inside the `ifdef` directives for each
    platform, we can then add defines for the macro `EXPORT`, on Windows these are
    for `dllexport` and `dllimport`. This is a standard way of using macros to make
    the process of exporting and importing easier. With these macros in place, any
    project that includes this file will see the exposed functions as being imported
    whereas the dynamic library will see anything defined with this macro as being
    exported. This means we can now simply use `EXPORT` in place of `_declspec(dllexport)`
    or `__attribute__((visibility("default")))` when specifying what should be made
    available to others in the dynamic library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新动态库时的第一步是一个有用的快捷方式，它允许我们节省一些按键和简化导出类、函数或变量的创建。使用`ifdef`指令，我们首先可以为我们的内存管理器创建一个标识符`MEMORYMGR_EXPORTS`，然后为目标平台创建标识符，`_WIN32`表示Windows，`__APPLE__`表示macOS
    X。在每个平台的`ifdef`指令内，我们可以为宏`EXPORT`添加定义，对于Windows，这些是`dllexport`和`dllimport`。这是使用宏的标准方式，使得导出和导入的过程更加简单。有了这些宏，包含此文件的任何项目将看到暴露的函数被导入，而动态库将看到使用此宏定义的任何内容被导出。这意味着我们现在可以简单地使用`EXPORT`来代替在动态库中指定应该提供给其他人的内容时使用的`_declspec(dllexport)`或`__attribute__((visibility("default")))`。
- en: 'The next step for creating our memory manager is to create a couple of `struct`
    for our `Block` and `Heap` objects. A block is a slice or block of memory where
    we will store individual objects. The `Heap` is a collection of these `Block`
    contained in a contiguous container of the memory. The `Block` struct simply holds
    a pointer to the next `Block` pointer; this creates a single linked list for the
    `Block` objects in each `Heap`. The `Heap` struct also holds a pointer to the
    next `Heap` in memory, which again creates a single linked list for the `Heap`
    objects. The `Heap` struct also contains a little helper function that returns
    the next block in the `Heap`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内存管理器的下一步是创建一对`struct`，用于我们的`Block`和`Heap`对象。一个块是我们将存储单个对象的内存切片或块。`Heap`是这些`Block`的集合，包含在内存的连续容器中。`Block`结构简单地保存指向下一个`Block`指针；这为每个`Heap`中的`Block`对象创建了一个单链表。`Heap`结构还保存指向内存中下一个`Heap`的指针，这再次为`Heap`对象创建了一个单链表。`Heap`结构还包含一个小的辅助函数，返回`Heap`中的下一个块：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now that we have our `Heap` and `Block` structs in place, we can move on to
    defining the actual memory manager class, `CMemoryMgr`. This is where the define
    we created earlier comes in handy. In this case, we use `EXPORT` to specify that
    we want the entire class to be exported in our dynamic library. When we export
    the class this way, the class access is exactly like any other class. That means
    that all the `private`, `protected`, and `public` objects continue to have the
    same access.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`Heap`和`Block`结构，我们可以继续定义实际的内存管理器类`CMemoryMgr`。这就是我们之前创建的定义派上用场的地方。在这种情况下，我们使用`EXPORT`来指定我们希望整个类在动态库中被导出。当我们以这种方式导出类时，类的访问方式与任何其他类完全相同。这意味着所有的`private`、`protected`和`public`对象继续具有相同的访问权限。
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'While in our simple example, it makes sense to export the entire class, that
    might not always be the case. If we want to export just a function or variable,
    we could do that with our created `EXPORT` macro like so:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，导出整个类是有意义的，但并不总是如此。如果我们只想导出一个函数或变量，我们可以使用我们创建的`EXPORT`宏来实现：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Of course, this would be the exact same as if we simply typed out the full
    export specifier like so (on macOS X):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这与我们简单地输入完整的导出说明符是完全相同的（在macOS X上）：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'More about the `MemoryMgr` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`MemoryMgr`文件的更多信息：
- en: Now that we know how to export class, functions, and variables, let's continue
    on with a quick look at the rest of the `MemoryMgr` header file. To begin with,
    we define our public methods that will be available when calling our library.
    These include the constructor, which takes three parameters; `dataSize`, the size
    of the objects for each block, `heapSize`, the size of each memory heap, and `memoryAlignmentSize`,
    this is the variable we use to shift the objects in memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何导出类、函数和变量，让我们继续快速查看`MemoryMgr`头文件的其余部分。首先，我们定义了我们的公共方法，在调用我们的库时将可用。这些包括构造函数，它接受三个参数；`dataSize`，每个块对象的大小，`heapSize`，每个内存堆的大小，以及`memoryAlignmentSize`，这是我们用来在内存中移动对象的变量。
- en: Shifting the objects in memory means that we will always use a set amount memory
    to hold an object no matter the size. We do this so that the objects are aligned
    in such a way that we can reduce the amount of calls to the actual memory hardware
    which of course will increase performance. This is often the main reason developers
    will use a custom memory manager.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中移动对象意味着我们将始终使用一定量的内存来保存对象，无论大小如何。我们这样做是为了使对象以这样的方式对齐，以便我们可以减少对实际内存硬件的调用次数，这当然会提高性能。这通常是开发人员使用自定义内存管理器的主要原因。
- en: 'Next, we have the destructor which takes no parameters, followed by the `Allocate`,
    `Deallocate`, and `DeallocateAll`, which do exactly what their names imply. The
    only function that takes a parameter is the `Deallocate` function, which takes
    a pointer to the memory that you wish to delete:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个不带参数的析构函数，然后是`Allocate`，`Deallocate`和`DeallocateAll`，它们确切地执行它们的名字所暗示的操作。唯一带有参数的函数是`Deallocate`函数，它接受一个指向要删除的内存的指针：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These functions are the only ones exposed through our library, and, in this
    simple example, can be considered a basic implementation interface for this library.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数是我们的库中唯一公开的函数，在这个简单的例子中，可以被视为这个库的基本实现接口。
- en: 'After the public declarations come, of course, the private declarations are
    needed for our library. They begin with three static constants that hold simple
    hexadecimal patterns we will use. This will help us identify each memory segment
    while debugging and provide a simple mechanism to check that we are working on
    the right segment at the right time:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 公共声明之后，当然需要私有声明来完成我们的库。它们以三个静态常量开始，这些常量保存了我们将使用的简单十六进制模式。这将帮助我们在调试时识别每个内存段，并提供一个简单的机制来检查我们是否在正确的时间段上工作：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then we have the `private` methods we use to do the heavy lifting in our library.
    The helper function `GetNextBlock` will return the next linked `block` in the
    `Heap`. The `OverWriteHeap` function takes a pointer to heap that will write to
    that specific `Heap`. An `OverWriteBlock` takes a pointer to a block to write
    to, and an `OverWriteAllocated` again takes a `Block` pointer that is allocated
    to write over:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有用于在我们的库中进行繁重工作的`private`方法。辅助函数`GetNextBlock`将返回`Heap`中下一个链接的`block`。`OverWriteHeap`函数接受一个指向将写入特定`Heap`的堆的指针。`OverWriteBlock`接受一个指向要写入的块的指针，`OverWriteAllocated`再次接受一个分配给写入的`Block`指针：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the `private` methods, we have the member variables that will store the
    various types of data needed for our memory manager library. The first two are
    lists of pointers that we use to hold the heaps we have created and the free blocks
    available:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`private`方法之后，我们有将存储我们内存管理器库所需的各种类型数据的成员变量。前两个是指针列表，我们用它们来保存我们创建的堆和可用的空闲块：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we have a group of unsigned integers that hold various pieces of data.
    Since the names of the variables are pretty self-explanatory, I won''t go through
    each one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一组无符号整数，保存各种数据。由于变量的名称相当不言自明，我不会逐个解释：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, in our implementation file (`MemoryMgr.cpp`), since in this example we
    are exporting the entire class we do not have to include anything special, all
    of the publicly access contents will be available to any projects using our library.
    If we instead decided to export only selected functions and variables, instead
    of the whole class, we would have to use the `EXPORT` macro we created to specify
    that they should be exported in our library. To do that, you would simply add
    `EXPORT` in front of the implementation like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的实现文件（`MemoryMgr.cpp`）中，由于在这个例子中我们正在导出整个类，我们不必包含任何特殊的内容，所有公开访问的内容将对使用我们的库的任何项目可用。如果我们决定只导出选定的函数和变量，而不是整个类，我们将不得不使用我们创建的`EXPORT`宏来指定它们应该在我们的库中导出。为此，您只需在实现前面添加`EXPORT`：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To save time and space here, I am not going to go through each line of the `MemoryMgr.cpp`
    implementation. The file is well documented and should explain the simple mechanics
    of the memory manager well enough. Although it is simple, this library is a great
    starting point for building a more robust memory manager system to suit any project's
    particular needs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间和空间，我不打算逐行讨论`MemoryMgr.cpp`的实现。该文件有很好的文档，应该足够清楚地解释内存管理器的简单机制。尽管它很简单，但这个库是构建更健壮的内存管理器系统的绝佳起点，以满足任何项目的特定需求。
- en: Building a custom library
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义库
- en: Before you or anyone else can use your custom library, you need to build it.
    There are a few different ways we can accomplish this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在您或其他人可以使用您的自定义库之前，您需要构建它。我们可以通过几种不同的方式来实现这一点。
- en: On Windows
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows
- en: 'In our example from the preceding section, we used Visual Studio 2015, and
    in this case building the library is quite simple. For example, to build the `MemoryMgr`
    library, you can right-click on the Solution ''MemoryMgr'' in Solution Explorer
    and select Build Solution, or use the keyboard shortcut *Ctrl *+ *Shift *+ *B*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前部分的例子中，我们使用了Visual Studio 2015，在这种情况下构建库非常简单。例如，要构建`MemoryMgr`库，您可以在“解决方案资源管理器”中右键单击解决方案'MemoryMgr'，然后选择“生成解决方案”，或者使用键盘快捷键*Ctrl*+*Shift*+*B*：
- en: '![](img/c180a9a9-4847-445b-a612-389e9621c9a2.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c180a9a9-4847-445b-a612-389e9621c9a2.png)'
- en: 'This will create the needed `MemoryMgr.dll` and `MemoryMgr.lib` files in the
    project''s output folder under either Debug or Release, depending on the build
    setting selected. Another way we can build our library is with the developer command-line
    tools that we discussed in the first part of this chapter. In this case, we could
    simply change directories to the project file and run the `cl` command with the
    library name and input files included:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目的输出文件夹中创建所需的`MemoryMgr.dll`和`MemoryMgr.lib`文件，分别位于Debug或Release下，具体取决于所选的构建设置。我们构建库的另一种方法是使用我们在本章第一部分讨论的开发人员命令行工具。在这种情况下，我们可以简单地更改目录到项目文件并使用`cl`命令以包括库名称和输入文件：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again this will create the `MemoryMgr.dll` and `MemoryMgr.lib` files that are
    needed to use our library in other projects.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这将创建`MemoryMgr.dll`和`MemoryMgr.lib`文件，这些文件在其他项目中使用我们的库时是需要的。
- en: On macOS X
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS X上
- en: 'To build an XCode library project is quite easy. You can simply select Product
    from the toolbar and the click on Build or use the keyboard shortcut Command +
    *B*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 构建XCode库项目非常容易。您可以简单地从工具栏中选择产品，然后单击构建，或者使用键盘快捷键Command + *B*：
- en: '![](img/47c237e7-bf12-4a29-a504-48ee49020189.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47c237e7-bf12-4a29-a504-48ee49020189.png)'
- en: 'This will create the `MemoryMgr.dylib` file that we will need when including
    the library in other projects. Another way we can build the library is with the
    terminal shell the we looked at earlier in the chapter. In this case, we could
    simply change directories to the project file and run `g++` with the library name
    and input files included:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`MemoryMgr.dylib`文件，这是我们在其他项目中包含库时需要的。我们构建库的另一种方法是使用我们在本章前面看到的终端shell。在这种情况下，我们只需切换到项目文件的目录并运行`g++`，并包括库名称和输入文件：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Building dynamic library on Windows using .def file
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上使用.def文件构建动态库
- en: We will explore the options of building the dynamic library using either only
    `.def` file or by using linker options as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用仅`.def`文件或同时使用链接器选项构建动态库的选项。
- en: Using only .def file
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用.def文件
- en: 'There is one more way that I want to mention that we can use to build our dynamic
    library, and that is with the use of a `.def` file. A module-definition or `.def`
    file is a text file that contains module statements that describe the exported
    attributes of the dynamic library. With a `.def` file, you do not need to create
    any macros or use the `__declspec(dllexport)` specifier to export the DLL''s functions.
    For our `MemoryMgr` example, we can create a `.def` file by opening a text editor
    and adding the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想提一下我们可以用来构建动态库的另一种方法，那就是使用`.def`文件。模块定义或`.def`文件是一个文本文件，其中包含描述动态库导出属性的模块语句。使用`.def`文件，您无需创建任何宏或使用`__declspec(dllexport)`指定符来导出DLL的函数。对于我们的`MemoryMgr`示例，我们可以通过打开文本编辑器并添加以下内容来创建一个`.def`文件：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This will tell the compiler that we wish to export these three functions: `Allocate`,
    `Deallocate`, and `DeallocateAll`. Save the file as a `.def` file; I called mine
    `MemoryMgr.def`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉编译器我们希望导出这三个函数：`Allocate`，`Deallocate`和`DeallocateAll`。将文件保存为`.def`文件；我把我的叫做`MemoryMgr.def`。
- en: Before we can recompile the library using the module definition file, we have
    to make a few changes to the source code of `MemoryMgr`. First, we can remove
    the macros we created and remove the `EXPORT` before the `CMemoryMgr` class definition.
    Instead of needing the macro or `_declspec(dllexport)` specifier, the `.def` file
    we created earlier will handle telling the compiler what should be exported.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用模块定义文件重新编译库之前，我们必须对`MemoryMgr`的源代码进行一些更改。首先，我们可以删除我们创建的宏，并在`CMemoryMgr`类定义之前删除`EXPORT`。与需要宏或`_declspec(dllexport)`指定符不同，我们之前创建的`.def`文件将处理告诉编译器应该导出什么的工作。
- en: 'To compile a dynamic library using a module definition file on the Windows
    platform, we have a couple of options. We could compile the library using the
    developer console, much like we did earlier, but with an extra option to specify
    the `.def` file. The command to compile the `MemoryMgr` library from the console
    would look something like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows平台上使用模块定义文件编译动态库，我们有几个选项。我们可以像之前一样使用开发者控制台编译库，但是需要额外的选项来指定`.def`文件。从控制台编译`MemoryMgr`库的命令看起来可能是这样的：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `/DEF:filename` is the flag that tells the compiler to use the specified
    module definition file to build the library. This command will produce a dynamic
    library called `MemoryMgr2.dll`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`/DEF:filename`是告诉编译器使用指定的模块定义文件来构建库的标志。这个命令将产生一个名为`MemoryMgr2.dll`的动态库。'
- en: Setting linker options
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置链接器选项
- en: The second option we have to build the dynamic library using a `.def` file is
    by setting linker options in the Visual Studio development environment. It's fairly
    straightforward to do this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建动态库使用`.def`文件的第二个选项是在Visual Studio开发环境中设置链接器选项。这样做非常简单。
- en: 'First, we open the Property Pages dialog box by right-clicking on the project''s
    name in Solution Explorer or by using the keyboard shortcut *Alt* + *Enter* with
    the project highlighted. With the Property Pages dialog open, select Linker, click
    on the Input property page, and finally, enter the name of the `.def` file in
    the Module Definition File property. The end result should look something like
    the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过右键单击解决方案资源管理器中项目的名称或使用键盘快捷键*Alt* + *Enter*来打开属性页对话框。打开属性页对话框后，选择链接器，点击输入属性页，最后在模块定义文件属性中输入`.def`文件的名称。最终结果应该看起来像以下内容：
- en: '![](img/0b7448bd-48ac-4dd6-baef-0e3faa530d7e.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b7448bd-48ac-4dd6-baef-0e3faa530d7e.png)'
- en: Now when you build your dynamic library project, the compiler will use the `MemoryMgr.def`
    file to determine which attributes should be exported.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您构建动态库项目时，编译器将使用`MemoryMgr.def`文件来确定应该导出哪些属性。
- en: Next, we will look at how we can consume this and other libraries when working
    with Visual Studio and XCode projects.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看在使用Visual Studio和XCode项目时如何使用和消耗这个和其他库。
- en: Sharing and consuming libraries
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享和使用库
- en: 'Now that we have our custom library built, we can start to use it in other
    projects. As we saw earlier in the chapter, we can link the dynamic and static
    libraries using the command-line compiler tools. This is OK if you have just a
    few libraries or have maybe created a custom build script, but in most cases when
    working with an IDE like Visual Studio, there are simpler ways to manage. In fact,
    adding libraries to a project in Visual Studio can be quite easy. To add the library
    first, we open the Property Pages dialog again, right-click and go to Properties
    or *Alt* + *Enter* with the project selected in the Solution Explorer. Next, expand
    Linker and select Input. At the top of the dialog on the Additional Dependencies
    property, click on the drop down and select Edit. This will bring up a dialog
    like the one shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了自定义库，我们可以开始在其他项目中使用它。正如我们在本章前面看到的，我们可以使用命令行编译器工具链接动态和静态库。如果您只有几个库或者可能创建了一个自定义的构建脚本，那么这是可以的，但是在大多数情况下，当使用像Visual
    Studio这样的集成开发环境时，有更简单的方法来管理。实际上，在Visual Studio中向项目添加库可以非常简单。首先添加库，我们再次打开“属性页”对话框，右键单击并转到“属性”或在“解决方案资源管理器”中选择项目后按*Alt*
    + *Enter*。接下来，展开链接器并选择输入。在对话框顶部的“附加依赖项”属性上，单击下拉菜单并选择“编辑”。这将打开一个类似于此处所示的对话框：
- en: '![](img/c3702c26-2d32-464b-be0f-974942428511.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3702c26-2d32-464b-be0f-974942428511.png)'
- en: 'In this dialog''s property window, we can specify the libraries we wish to
    include at compile time. We include the `.lib` file regardless of whether it is
    a dynamic library or a static library. If you have set up your library directories
    in the VC++ Directories folder under Configuration Properties, you can simply
    use the library name like this: `MemoryMgr.lib`. You can also include the libraries
    by specifying the path to the library such as `C:\project\lib\MemoryMgr.lib`.
    This property also accepts macros, which are important to use since moving the
    project to another directory would break the include otherwise. Some of the macros
    you can use are:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框的属性窗口中，我们可以在编译时指定要包含的库。无论是动态库还是静态库，我们都包括`.lib`文件。如果您已经在“配置属性”下的VC++目录文件夹中设置了库目录，您可以简单地使用库名称，如`MemoryMgr.lib`。您还可以通过指定库的路径来包含库，例如`C:\project\lib\MemoryMgr.lib`。此属性还接受宏，使用宏很重要，因为否则将项目移动到另一个目录会破坏包含。您可以使用的一些宏包括：
- en: '`$(SolutionDir)`: This is the top solution directory'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(SolutionDir)`: 这是顶层解决方案目录'
- en: '`$(SourceDir)`: This is the directory of the source for the project'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(SourceDir)`: 这是项目源代码的目录'
- en: '`$(Platform)`: This is the platform that is selected (Win32, x64, or ARM)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(Platform)`: 这是所选的平台（Win32、x64或ARM）'
- en: '`$(Configuration)`: This is the configuration that is selected (Debug or Release)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(Configuration)`: 这是所选的配置（调试或发布）'
- en: 'This means if I have a few libraries for each platform and configuration in
    a folder called `lib` located in the solution directory, I can save myself a bunch
    of work by using a macro like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我在解决方案目录中的一个名为`lib`的文件夹中为每个平台和配置都有一些库，我可以通过使用这样的宏来节省大量工作：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now if I switch platforms or configurations, I don't have to go back into the
    property pages and make changes each time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我切换平台或配置，我就不必每次都返回属性页面进行更改。
- en: That takes care of linking the library, but there is one more piece needed when
    consuming or sharing a library. In the first set of examples of this chapter,
    you must have noticed that when creating the little console program to demonstrate
    the use of the library, I used a forward declaration to specify the implementation
    of the `Hello` function from the library.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了链接库的问题，但在使用或共享库时还需要另一个部分。在本章的第一组示例中，您一定已经注意到，在创建用于演示库使用的小控制台程序时，我使用了前向声明来指定库中`Hello`函数的实现。
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While this works in small examples like this one, if you are using libraries
    with multiple attributes, forward declarations will become quite tedious. In order
    to make use of libraries in your project, you will often have to include the definition
    files, the headers. This is why when you see libraries shared they will usually
    have an `Include` folder that has all the header files needed to work with that
    library. In the case of our `MemoryMgr` library, that would mean if I wanted to
    use it in a new project or share it with another developer I would include three
    files. The `MemoryMgr.dll` library, is actually a dynamic library. The `MemoryMgr.lib`
    library, is the library file used for linking. Lastly, I would also need to include
    the `MemoryMgr.h` file, the file that includes all the attribute definitions for
    my library.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在像这样的小例子中可以工作，但是如果您使用具有多个属性的库，前向声明将变得非常繁琐。为了在项目中使用库，您通常需要包含定义文件，即头文件。这就是为什么当您看到共享库时，它们通常会有一个`Include`文件夹，其中包含与该库一起使用所需的所有头文件。对于我们的`MemoryMgr`库来说，这意味着如果我想在新项目中使用它或与其他开发人员共享它，我需要包含三个文件。`MemoryMgr.dll`库实际上是一个动态库。`MemoryMgr.lib`库是用于链接的库文件。最后，我还需要包含`MemoryMgr.h`文件，该文件包含了我的库的所有属性定义。
- en: Since most libraries you will work with have more than one header file, simply
    copying them into your project can get messy. The good news is, like most IDEs,
    Visual Studio has configuration settings that allow you to specify which folders
    house the files you wish to include in your project. Setting these configuration
    options is again quite simple. First, open the Property Page dialog, *Alt *+ *Enter*
    with the project highlighted in the Solution Explorer.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数库都有多个头文件，简单地将它们复制到项目中可能会变得混乱。好消息是，像大多数集成开发环境一样，Visual Studio具有配置设置，允许您指定哪些文件夹包含您希望包含在项目中的文件。设置这些配置选项也非常简单。首先，在“解决方案资源管理器”中突出显示项目后，打开“属性页”对话框，*Alt *+ *Enter*。
- en: 'Next, click on the C/C++ folder to expand it. Then select the General section.
    In this property window at the top, you will see Additional Include Directories,
    select the drop down from this property and click on Edit. This will bring up
    a dialog like the one shown here:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，单击C/C++文件夹以展开它。然后选择“常规”部分。在此属性窗口的顶部，您将看到“附加包含目录”，选择此属性的下拉菜单，然后单击“编辑”。这将带来一个类似于这里所示的对话框：
- en: '![](img/a5f043fa-4637-46db-8bed-5141be2c15d7.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5f043fa-4637-46db-8bed-5141be2c15d7.png)'
- en: 'In this dialog window, we can add a new line by clicking on the add folder
    icon, or by using the keyboard shortcut *Ctrl* + *Insert*. You can use the folder
    explorer dialog to find and select the folders you need to include, but this property
    also supports macros, so a much better way to specify the needed include folders
    would be by using macros. If we had a folder in the main solution directory called
    Include that had a folder inside it called `MemoryMgr`, we could include that
    folder using the following macro:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在此对话框中，我们可以通过单击添加文件夹图标或使用键盘快捷键*Ctrl* + *Insert*来添加新行。您可以使用文件夹资源管理器对话框来查找和选择所需的包含文件夹，但此属性还支持宏，因此指定所需的包含文件夹的更好方法是使用宏。如果我们在主解决方案目录中有一个名为Include的文件夹，其中包含一个名为`MemoryMgr`的文件夹，我们可以使用以下宏来包含该文件夹：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you select OK and Apply to close the Property Pages dialog, you can include
    the header files just like any other header file in your project. In the case
    of our `MemoryMgr` folder we would use the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您选择“确定”并应用以关闭“属性页”对话框，您可以像在项目中的任何其他头文件一样包含头文件。在我们的`MemoryMgr`文件夹的情况下，我们将使用以下代码：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that the filesystem hierarchy is respected.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，文件系统层次结构得到了尊重。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the advanced topic of shareable libraries. We looked
    at the different types of libraries available. We walked through the various ways
    you can create your own sharable libraries.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了可共享库的高级主题。我们看了看可用的不同类型的库。我们介绍了创建自己的可共享库的各种方法。
- en: In the next chapter, we are going to use this advanced library knowledge to
    build an asset management pipeline.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用这些高级库知识来构建资产管理流水线。
