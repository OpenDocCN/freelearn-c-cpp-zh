- en: Algorithms and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法和数据结构
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的问题解决部分。
- en: 45\. Priority queue
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45\. 优先队列
- en: 'Write a data structure that represents a priority queue that provides constant
    time lookup for the largest element, but has logarithmic time complexity for adding
    and removing elements. A queue inserts new elements at the end and removes elements
    from the top. By default, the queue should use `operator<` to compare elements,
    but it should be possible for the user to provide a comparison function object
    that returns `true` if the first argument is less than the second. The implementation
    must provide at least the following operations:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示优先队列的数据结构，该队列提供最大元素的常数时间查找，但在添加和删除元素时具有对数时间复杂度。队列在末尾插入新元素，并从顶部删除元素。默认情况下，队列应该使用`operator<`来比较元素，但用户应该能够提供一个比较函数对象，如果第一个参数小于第二个参数，则返回`true`。实现必须提供至少以下操作：
- en: '`push()` to add a new element'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()` 用于添加新元素'
- en: '`pop()` to remove the top element'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()` 用于移除顶部元素'
- en: '`top()` to provide access to the top element'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top()` 提供对顶部元素的访问'
- en: '`size()` to indicate the number of elements in the queue'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()` 指示队列中元素的数量'
- en: '`empty()` to indicate whether the queue is empty'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`empty()` 指示队列是否为空'
- en: 46\. Circular buffer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 46\. 循环缓冲区
- en: 'Create a data structure that represents a circular buffer of a fixed size.
    A circular buffer overwrites existing elements when the buffer is being filled
    beyond its fixed size. The class you must write should:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示固定大小的循环缓冲区的数据结构。当缓冲区填满超出其固定大小时，循环缓冲区会覆盖现有元素。您必须编写的类应该：
- en: Prohibit default construction
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止默认构造
- en: Support the creation of objects with a specified size
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持创建指定大小的对象
- en: Allow checking of the buffer capacity and status (`empty()`, `full()`, `size()`, `capacity()`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许检查缓冲区容量和状态（`empty()`、`full()`、`size()`、`capacity()`）
- en: Add a new element, an operation that could potentially overwrite the oldest
    element in the buffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新元素，这个操作可能会覆盖缓冲区中最旧的元素
- en: Remove the oldest element from the buffer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区中删除最旧的元素
- en: Support iteration through its elements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持遍历其元素
- en: 47\. Double buffer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 47\. 双缓冲区
- en: Write a class that represents a buffer that could be written and read at the
    same time without the two operations colliding. A read operation must provide
    access to the old data while a write operation is in progress. Newly written data
    must be available for reading upon completion of the write operation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个表示可以同时写入和读取的缓冲区的类，而不会发生两个操作的冲突。读取操作必须在进行写入操作时提供对旧数据的访问。新写入的数据必须在写入操作完成后可供读取。
- en: 48\. The most frequent element in a range
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 48\. 范围内最频繁的元素
- en: Write a function that, given a range, returns the most frequent element and
    the number of times it appears in the range. If more than one element appears
    the same maximum number of times then the function should return all the elements.
    For instance, for the range `{1,1,3,5,8,13,3,5,8,8,5}`, it should return `{5,
    3}` and `{8, 3}`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个范围，返回出现最频繁的元素以及它在范围内出现的次数。如果有多个元素出现相同的最大次数，则函数应返回所有这些元素。例如，对于范围`{1,1,3,5,8,13,3,5,8,8,5}`，它应该返回`{5,
    3}`和`{8, 3}`。
- en: 49\. Text histogram
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 49\. 文本直方图
- en: Write a program that, given a text, determines and prints a histogram with the
    frequency of each letter of the alphabet. The frequency is the percentage of the
    number of appearances of each letter from the total count of letters. The program
    should count only the appearances of letters and ignore digits, signs, and other
    possible characters. The frequency must be determined based on the count of letters
    and not the text size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定一个文本，确定并打印每个字母的频率直方图。频率是每个字母出现次数与字母总数的百分比。程序应该只计算字母的出现次数，忽略数字、符号和其他可能的字符。频率必须基于字母计数而不是文本大小来确定。
- en: 50\. Filtering a list of phone numbers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 50\. 过滤电话号码列表
- en: Write a function that, given a list of phone numbers, returns only the numbers
    that are from a specified country. The country is indicated by its phone country
    code, such as 44 for Great Britain. Phone numbers may start with the country code,
    a `+` followed by the country code, or have no country code. The ones from this
    last category must be ignored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个电话号码列表，仅返回来自指定国家的号码。国家由其电话国家代码表示，例如44代表英国。电话号码可能以国家代码开头，后跟`+`和国家代码，或者没有国家代码。最后一类必须被忽略。
- en: 51\. Transforming a list of phone numbers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 51\. 转换电话号码列表
- en: 'Write a function that, given a list of phone numbers, transforms them so they
    all start with a specified phone country code, preceded by the `+` sign. Any whitespaces
    from a phone number should also be removed. The following is a list of input and
    output examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一个电话号码列表，将它们转换为都以指定电话国家代码开头，前面加上`+`号。还应该删除电话号码中的任何空格。以下是输入和输出示例列表：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 52\. Generating all the permutations of a string
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52\. 生成字符串的所有排列
- en: 'Write a function that, prints on the console all the possible permutations
    of a given string. You should provide two versions of this function: one that
    uses recursion, and one that does not.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，在控制台上打印给定字符串的所有可能的排列。您应该提供这个函数的两个版本：一个使用递归，一个不使用递归。
- en: 53\. Average rating of movies
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 53\. 电影的平均评分
- en: Write a program that calculates and prints the average rating of a list of movies.
    Each movie has a list of ratings from 1 to 10 (where 1 is the lowest and 10 is
    the highest rating). In order to compute the rating, you must remove 5% of the
    highest and lowest ratings before computing their average. The result must be
    displayed with a single decimal point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算并打印电影列表的平均评分的程序。每部电影都有一个从1到10的评分列表（其中1是最低分，10是最高分）。为了计算评分，您必须在计算平均值之前删除最高和最低评分的5%。结果必须以一个小数点显示。
- en: 54\. Pairwise algorithm
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 54\. 两两算法
- en: Write a general-purpose function that, given a range, returns a new range with
    pairs of consecutive elements from the input range. Should the input range have
    an odd number of elements, the last one must be ignored. For example, if the input
    range was `{1, 1, 3, 5, 8, 13, 21}`, the result must be `{ {1, 1}, {3, 5}, {8,
    13}}`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个通用函数，给定一个范围，返回一个新的范围，其中包含输入范围的连续元素对。如果输入范围的元素数是奇数，则必须忽略最后一个元素。例如，如果输入范围是`{1,
    1, 3, 5, 8, 13, 21}`，结果必须是`{{1, 1}, {3, 5}, {8, 13}}`。
- en: 55\. Zip algorithm
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 55\. 压缩算法
- en: Write a function that, given two ranges, returns a new range with pairs of elements
    from the two ranges. Should the two ranges have different sizes, the result must
    contain as many elements as the smallest of the input ranges. For example, if
    the input ranges were `{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }` and `{ 1, 1, 3, 5, 8,
    13, 21 }`, the result should be `{{1,1}, {2,1}, {3,3}, {4,5}, {5,8}, {6,13}, {7,21}}`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定两个范围，返回一个新的范围，其中包含来自两个范围的元素对。如果两个范围的大小不同，结果必须包含输入范围中最小的元素数量。例如，如果输入范围是`{
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }`和`{ 1, 1, 3, 5, 8, 13, 21 }`，结果应该是`{{1,1}, {2,1},
    {3,3}, {4,5}, {5,8}, {6,13}, {7,21}}`。
- en: 56\. Select algorithm
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 56\. 选择算法
- en: 'Write a function that, given a range of values and a projection function, transforms
    each value into a new one and returns a new range with the selected values. For
    instance, if you have a type book that has an `id`, `title`, and `author`, and
    have a range of such book values, it should be possible for the function to select
    only the title of the books. Here is an example of how the function should be
    used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一系列值和一个投影函数，将每个值转换为一个新值，并返回一个选择的值的新范围。例如，如果你有一个类型为book的值，它有`id`、`title`和`author`，并且有一系列这样的书值，函数应该能够选择书的标题。下面是函数应该如何使用的一个例子：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 57\. Sort algorithm
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 57\. 排序算法
- en: 'Write a function that, given a pair of random-access iterators to define its
    lower and upper bounds, sorts the elements of the range using the quicksort algorithm.
    There should be two overloads of the sort function: one that uses `operator<` to
    compare the elements of the range and put them in ascending order, and one that
    uses a user-defined binary comparison function for comparing the elements.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，给定一对随机访问迭代器来定义其下限和上限，使用快速排序算法对范围的元素进行排序。排序函数应该有两个重载：一个使用`operator<`来比较范围的元素并按升序放置它们，另一个使用用户定义的二进制比较函数来比较元素。
- en: 58\. The shortest path between nodes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 58\. 节点之间的最短路径
- en: 'Write a program that, given a network of nodes and the distances between them,
    computes and displays the shortest distance from a specified node to all the others,
    as well as the path between the start and end node. As input, consider the following
    undirected graph:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，给定节点网络和它们之间的距离，计算并显示从指定节点到其他所有节点的最短距离，以及起点和终点节点之间的路径。作为输入，考虑以下无向图：
- en: '![](img/2fe0878c-3372-40bf-a988-81c9d47ab199.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fe0878c-3372-40bf-a988-81c9d47ab199.png)'
- en: 'The program output for this graph should be the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图的程序输出应该是以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 59\. The Weasel program
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 59\. 鼬程序
- en: 'Write a program that implements Richard Dawkins'' weasel computer simulation,
    described in Dawkins'' words as follows (*The Blind Watchmaker*, chapter 3):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，实现理查德·道金斯的鼬计算机模拟，道金斯在《盲眼的看守者》第3章中描述如下：
- en: We again use our computer monkey, but with a crucial difference in its program.
    It again begins by choosing a random sequence of 28 letters, just as before ...
    it duplicates it repeatedly, but with a certain chance of random error – 'mutation'
    – in the copying. The computer examines the mutant nonsense phrases, the 'progeny'
    of the original phrase, and chooses the one which, however slightly, most resembles
    the target phrase, METHINKS IT IS LIKE A WEASEL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用我们的计算机猴子，但是它的程序有一个关键的不同。它再次开始选择一个随机序列的28个字母，就像以前一样...它重复复制它，但有一定的随机错误的机会
    - '突变' - 在复制中。计算机检查原始短语的突变无意义短语，选择其中最像目标短语“METHINKS IT IS LIKE A WEASEL”的那个，即使只是稍微地。
- en: 60\. The Game of Life
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 60\. 生命游戏
- en: 'Write a program that implements the *Game of Life* cellular automaton proposed
    by *John Horton Conway*. The universe of this game is a grid of square cells that
    could have one of two states: dead or alive. Every cell interacts with its adjacent
    neighbors, with the following transactions occurring on every step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，实现约翰·霍顿·康威提出的生命游戏细胞自动机。这个游戏的宇宙是一个正方形单元格的网格，可以有两种状态之一：死或活。每个细胞与其相邻的邻居进行交互，每一步都会发生以下交易：
- en: Any live cell with fewer than two live neighbors dies, as if caused by under-population
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何活细胞如果少于两个活邻居，则死亡，就像是由于人口不足引起的
- en: Any live cell with two or three live neighbors lives on to the next generation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有两个或三个活邻居的活细胞将继续到下一代
- en: Any live cell with more than three live neighbors dies, as if by overpopulation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有超过三个活邻居的活细胞将死亡，就像是由于过度生育引起的
- en: Any dead cell with exactly three live neighbors becomes a live cell, as if by
    reproduction
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有三个活邻居的死细胞将成为活细胞，就像是通过繁殖一样
- en: The status of the game on each iteration should be displayed on the console,
    and for convenience, you should pick a reasonable size, such as 20 rows x 50 columns.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏在每次迭代中的状态应该显示在控制台上，为了方便起见，你应该选择一个合理的大小，比如20行x50列。
- en: Solutions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述问题解决部分的解决方案。
- en: 45\. Priority queue
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 45\. 优先队列
- en: A priority queue is an abstract data type whose elements have a priority attached
    to them. Instead of working as a first-in-first-out container, a priority queue
    makes elements available in the order of their priority. This data structure is
    used in algorithms such as Dijkstra's shortest path, Prim's algorithm, heap sort,
    the A* search algorithm, in Huffman codes used for data compression, and others.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列是一个抽象数据类型，其元素附有优先级。优先队列不像先进先出容器那样工作，而是按照它们的优先级顺序提供元素。这种数据结构在算法中被用于迪杰斯特拉最短路径、普林姆算法、堆排序、A*搜索算法、用于数据压缩的哈夫曼编码等。
- en: A very simple approach to implement a priority queue would be to use an `std::vector` as
    the underlying container of elements and always maintain it sorted. That means
    the maximum and minimum elements are always at the two ends. However, this approach
    does not provide the most efficient operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实现优先队列的一个非常简单的方法是使用`std::vector`作为元素的基础容器，并始终保持其排序。这意味着最大和最小元素总是在两端。然而，这种方法并不提供最有效的操作。
- en: 'The most suitable data structure that can be used to implement a priority queue
    is a heap. This is a tree-based data structure that satisfies the following property:
    if *P* is a parent node of *C*, then the key (the value) of *P* is either greater
    than or equal to (in a max heap) or less than or equal to (in a min heap) the
    key of *C*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用来实现优先队列的最合适的数据结构是堆。这是一种基于树的数据结构，满足以下属性：如果*P*是*C*的父节点，则*P*的键（值）要么大于或等于（在最大堆中），要么小于或等于（在最小堆中）*C*的键。
- en: 'The standard library provides several operations for working with heaps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个用于处理堆的操作：
- en: '`std::make_heap()`: This creates a max heap for the given range, using either `operator<` or
    a user-provided comparison function to order the elements'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::make_heap()`: 这为给定范围创建一个最大堆，使用`operator<`或用户提供的比较函数来排序元素'
- en: '`std::push_heap()`: This inserts a new element at the end of the max heap'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::push_heap()`: 这在最大堆的末尾插入一个新元素'
- en: '`std::pop_heap()`: This removes the first element of the heap (by swapping
    the values in the first and last position and making the sub-range `[first, last-1)` a
    max heap)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::pop_heap()`: 这会移除堆的第一个元素（通过交换第一个和最后一个位置的值，并使子范围`[first, last-1)`成为最大堆）'
- en: 'A priority queue implementation, that uses `std::vector` to hold data and the
    standard functions for heaps, can look as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::vector`保存数据和堆的标准函数的优先队列实现可以如下所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class can be used as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以如下使用这个类：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 46\. Circular buffer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 46\. 循环缓冲区
- en: A circular buffer is a fixed-size container that behaves as if its two ends
    were connected to form a virtual circular memory layout. Its main benefit is that
    you don't need a large amount of memory to retain data, as older entries are overwritten
    by newer ones. Circular buffers are used in I/O buffering, bounded logging (when
    you only want to retain the last messages), buffers for asynchronous processing,
    and others.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 循环缓冲区是一个固定大小的容器，其行为就好像它的两端连接在一起形成一个虚拟的循环内存布局。它的主要好处是你不需要大量的内存来保留数据，因为旧条目会被新条目覆盖。循环缓冲区用于I/O缓冲，有界日志（当您只想保留最后的消息时），异步处理的缓冲区等。
- en: 'We can differentiate between two situations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种情况：
- en: The number of elements added to the buffer has not reached its capacity (its
    user-defined fixed size). In this case, it behaves likes a regular container,
    such as a vector.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到缓冲区的元素数量尚未达到其容量（其用户定义的固定大小）。在这种情况下，它的行为类似于一个常规容器，如向量。
- en: The number of elements added to the buffer has reached and exceeded its capacity.
    In this case, the buffer's memory is reused and older elements are being overwritten.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加到缓冲区的元素数量已经达到并超过了其容量。在这种情况下，缓冲区的内存被重用，并且旧元素被覆盖。
- en: 'We could represent such a structure using:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下方式表示这样的结构：
- en: A regular container with a pre-allocated number of elements
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个预先分配了一定数量元素的常规容器
- en: A head pointer to indicate the position of the last inserted element
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个头指针，用于指示最后插入元素的位置
- en: A size counter to indicate the number of elements in the container, which cannot
    exceed its capacity (since elements are being overwritten in this case)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大小计数器，用于指示容器中的元素数量，不能超过其容量（因为在这种情况下元素被覆盖）
- en: 'The two main operations with a circular buffer are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 循环缓冲区的两个主要操作是：
- en: Adding a new element to the buffer. We always insert at the next position of
    the head pointer (or index). This is the `push()` method shown below.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向缓冲区添加一个新元素。我们总是在头指针（或索引）的下一个位置插入。这是下面显示的`push()`方法。
- en: Removing an existing element from the buffer. We always remove the oldest element.
    That element is at position `head - size` (this must account for the circular
    nature of the index). This is the `pop()` method shown below.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从缓冲区中移除一个现有元素。我们总是移除最旧的元素。该元素位于`head - size`的位置（这必须考虑索引的循环特性）。这是下面显示的`pop()`方法。
- en: 'The implementation of such a data structure is shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数据结构的实现如下所示：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because of the circular nature of the indexes mapped on a contiguous memory
    layout, the iterator type for this class cannot be a pointer type. The iterators
    must be able to point elements by applying modulo operations on the index. Here
    is a possible implementation for such an iterator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于索引在连续内存布局上的循环特性，这个类的迭代器类型不能是指针类型。迭代器必须能够通过在索引上应用模运算来指向元素。以下是这样一个迭代器的可能实现：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With all these implemented, we could write code such as the following. Notice
    that in the comments, the first range shows the actual content of the internal
    vector, and the second range shows the logical content as exposed with iterator
    access:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些实现，我们可以编写如下的代码。请注意，在注释中，第一个范围显示内部向量的实际内容，第二个范围显示通过迭代器访问时的逻辑内容：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 47\. Double buffer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 47\. 双缓冲
- en: The problem described here is a typical double buffering situation. Double buffering
    is the most common case of multiple buffering, which is a technique that allows
    a reader to see a complete version of the data and not a partially updated version
    produced by a writer. This is a common technique – especially in computer graphics
    – for avoiding flickering.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的问题是典型的双缓冲情况。双缓冲是多重缓冲的最常见情况，这是一种允许读者看到数据的完整版本而不是写入者产生的部分更新版本的技术。这是一种常见的技术
    - 尤其是在计算机图形学中 - 用于避免闪烁。
- en: 'In order to implement the requested functionality, the buffer class that we
    should write must have two internal buffers: one that contains temporary data
    being written, and another one that contains completed (or committed) data. Upon
    the completion of a write operation, the content of the temporary buffer is written
    in the primary buffer. For the internal buffers, the implementation below uses `std::vector`.
    When the write operation completes, instead of copying data from one buffer to
    the other, we just swap the content of the two, which is a much faster operation.
    Access to the completed data is provided with either the `read()` function, which
    copies the content of the read buffer into a designated output, or with direct
    element access (overloaded `operator[]`). Access to the read buffer is synchronized
    with an `std::mutex` to make it safe to read from one thread while another is
    writing to the buffer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现所请求的功能，我们应该编写的缓冲类必须有两个内部缓冲区：一个包含正在写入的临时数据，另一个包含已完成（或提交）的数据。在写操作完成时，临时缓冲区的内容将写入主缓冲区。对于内部缓冲区，下面的实现使用`std::vector`。当写操作完成时，我们不是从一个缓冲区复制数据到另一个缓冲区，而是交换两者的内容，这是一个更快的操作。通过`read()`函数提供对已完成数据的访问，该函数将读取缓冲区的内容复制到指定的输出，或者通过直接元素访问（重载的`operator[]`）。对读缓冲区的访问与`std::mutex`同步，以确保在一个线程从缓冲区读取时另一个线程正在向缓冲区写入是安全的：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example of how this double buffer class can be used for
    both writing and reading by two different entities:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个双缓冲类如何被两个不同实体用于写入和读取的示例：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 48\. The most frequent element in a range
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 48. 范围内最频繁的元素
- en: 'In order to determine and return the most frequent element in a range you should
    do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定并返回范围内最频繁的元素，你应该这样做：
- en: Count the appearances of each element in an `std::map`. The key is the element
    and the value is its number of appearances.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`std::map`中计算每个元素的出现次数。键是元素，值是它的出现次数。
- en: Determine the maximum element of the map using `std::max_element()`. The result
    is a map element, that is, a pair containing the element and its number of appearances.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::max_element()`确定映射的最大元素。结果是一个映射元素，即包含元素及其出现次数的一对。
- en: Copy all map elements that have the value (appearance count) equal to the maximum
    element's value and return that as the final result.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制所有映射元素，其值（出现次数）等于最大元素的值，并将其作为最终结果返回。
- en: 'An implementation of the steps described previously is shown in the following
    listing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 先前描述的步骤的实现如下所示：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `find_most_frequent()` function can be used as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_most_frequent()`函数可以如下使用：'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 49\. Text histogram
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 49. 文本直方图
- en: 'A histogram is a representation of the distribution of numerical data. Widely
    known histograms are the color and image histograms that are used in photography
    and image processing. A text histogram, as described here, is a representation
    of the frequency of letters in a given text. This problem is partially similar
    to the previous one, except that the range elements are characters now and we
    must determine the frequency of them all. To solve this problem you should:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图是数值数据分布的表示。广为人知的直方图是摄影和图像处理中使用的颜色和图像直方图。如此描述的文本直方图是给定文本中字母频率的表示。这个问题在某种程度上与之前的问题类似，只是现在范围的元素是字符，我们必须确定它们的频率。要解决这个问题，你应该：
- en: Count the appearances of each letter using a map. The key is the letter and
    the value is its appearance count.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射计算每个字母的出现次数。键是字母，值是它的出现次数。
- en: When counting, ignore all characters that are not letters. Uppercase and lowercase
    characters must be treated as identical, as they represent the same letter.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计数时，忽略所有不是字母的字符。大写和小写字符必须被视为相同，因为它们代表相同的字母。
- en: Use `std::accumulate()` to count the total number of appearances of all the
    letters in the given text.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::accumulate()`来计算给定文本中所有字母出现次数的总数。
- en: Use `std::for_each()` or a range-based `for` loop to go through all the elements
    of the map and transform the appearance count into a frequency.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::for_each()`或基于范围的`for`循环遍历映射的所有元素，并将出现次数转换为频率。
- en: 'The following is a possible implementation of the problem:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该问题的一个可能实现：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following program prints the frequency of the letters from a text on the
    console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序在控制台上打印文本中字母的频率：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 50\. Filtering a list of phone numbers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 50. 过滤电话号码列表
- en: 'The solution to this problem is relatively simple: you have to iterate through
    all the phone numbers and copy to a separate container (such as an `std::vector`)
    the phone numbers that start with the country code. If the specified country code
    is, for instance, 44, then you must check for both 44 and +44\. Filtering the
    input range in this manner is possible using the `std::copy_if()` function. A
    solution to this problem is shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题相对简单：你必须遍历所有电话号码，并将以国家代码开头的电话号码复制到一个单独的容器（如`std::vector`）中。如果指定的国家代码是，例如，44，那么你必须同时检查44和+44。使用`std::copy_if()`函数可以以这种方式过滤输入范围。这个问题的解决方案如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how this function can be used:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用这个函数的：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 51\. Transforming a list of phone numbers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 51. 转换电话号码列表
- en: 'This problem is somewhat similar in some aspects to the previous one. However,
    instead of selecting phone numbers that start with a specified country code, we
    must transform each number so that they all start with that country code preceded
    by a `+`. There are several cases that must be considered:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在某些方面与之前的问题有些相似。但是，我们不是选择以指定国家代码开头的电话号码，而是要转换每个号码，使它们都以该国家代码前面加上`+`。有几种情况必须考虑：
- en: The phone number starts with a 0\. That indicates a number without a country
    code. To modify the number to include the country code we must replace the 0 with
    the actual country code, preceded by `+`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以0开头。这表示没有国家代码的号码。要修改号码以包括国家代码，必须用实际国家代码替换0，前面加上`+`。
- en: The phone number starts with the country code. In this case, we just prepend
    `+` sign to the beginning.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以国家代码开头。在这种情况下，我们只需在开头添加`+`号。
- en: The phone number starts with `+` followed by the country code. In this case,
    the number is already in the expected format.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码以`+`开头，后面跟着国家代码。在这种情况下，号码已经是预期格式。
- en: None of these cases applies, therefore the result is obtained by concatenating
    the country code preceded by `+` and the phone number.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有这些情况适用，因此结果是通过将以`+`为前缀的国家代码和电话号码连接在一起获得的。
- en: For simplicity, we will ignore the possibility that the number is actually prefixed
    with another country code. You can take it as a further exercise to modify the
    implementation so that it can handle phone numbers with a different country prefix.
    These numbers should be removed from the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将忽略号码实际上可能带有另一个国家代码前缀的可能性。您可以将其作为进一步的练习，修改实现以处理带有不同国家前缀的电话号码。这些号码应该从列表中删除。
- en: In all of the preceding cases, it is possible that the number could contain
    spaces. According to the requirements, these must be removed. The `std::remove_if()`
    and `isspace()` functions are used for this purpose.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述情况中，可能存在号码包含空格的情况。根据要求，这些必须被移除。`std::remove_if()`和`isspace()`函数用于此目的。
- en: 'The following is an implementation of the described solution:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所描述解决方案的实现：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following program normalizes a given list of phone numbers according to
    the requirement and prints them on the console:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序根据要求规范化给定的电话号码列表，并将它们打印在控制台上：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 52\. Generating all the permutations of a string
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 52. 生成字符串的所有排列
- en: 'You can solve this problem by taking advantage of some general-purpose algorithms
    from the standard library. The simplest of the two required versions is the non-recursive
    one, at least when you use `std::next_permutation()`. This function transforms
    the input range (that is required to be sorted) into the next permutation from
    the set of all possible permutations, ordered lexicographically with `operator<`
    or the specified comparison function object. If such a permutation exists then
    it returns `true`, otherwise, it transforms the range into the first permutation
    and returns `false`. Therefore, a non-recursive implementation based on `std::next_permuation()`
    looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过利用标准库中的一些通用算法来解决这个问题。所需版本中最简单的是非递归版本，至少在使用`std::next_permutation()`时是这样。该函数将输入范围（需要排序）转换为从所有可能的排列中的下一个排列，按字典顺序排序，使用`operator<`或指定的比较函数对象。如果存在这样的排列，则返回`true`，否则，它将范围转换为第一个排列并返回`false`。因此，基于`std::next_permuation()`的非递归实现如下所示：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The recursive alternative is a little bit more complex. One way to implement
    it is to have an input and output string; initially, the input string is the string
    for which we want to generate permutations and the output string is empty. We
    take one character at a time from the input string and put it in the output string.
    When the input string becomes empty, the output string represents the next permutation.
    The recursive algorithm for doing this is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的替代方法稍微复杂一些。实现它的一种方法是有一个输入和输出字符串；最初，输入字符串是我们想要生成排列的字符串，输出字符串为空。我们从输入字符串中一次取一个字符并将其放入输出字符串。当输入字符串变为空时，输出字符串表示下一个排列。执行此操作的递归算法如下：
- en: If the input string is empty, then print the output string and return
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入字符串为空，则打印输出字符串并返回
- en: 'Otherwise iterate through all the characters in the input string, and for each
    element:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则遍历输入字符串中的所有字符，并对每个元素执行以下操作：
- en: Call the method recursively by removing the first character from the input string
    and concatenating it at the end of the output string
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从输入字符串中删除第一个字符并将其连接到输出字符串的末尾来递归调用该方法
- en: Rotate the input string so that the first character becomes the last, the second
    becomes the first, and so on
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转输入字符串，使第一个字符成为最后一个字符，第二个字符成为第一个字符，依此类推
- en: 'This algorithm is visually explained in the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法在以下图表中得到了可视化解释：
- en: '![](img/bbcdafcd-a3e0-4a0c-9b79-9f465a5a4602.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbcdafcd-a3e0-4a0c-9b79-9f465a5a4602.png)'
- en: 'For rotating the input string, we could use the standard library function `std::rotate()`,
    which performs a left rotation on a range of elements. An implementation of the
    described recursive algorithm looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于旋转输入字符串，我们可以使用标准库函数`std::rotate()`，它对一系列元素执行左旋转。实现所描述的递归算法如下：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how both of these implementations can be used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这两种实现的用法：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 53\. Average rating of movies
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 53. 电影的平均评分
- en: The problem requires the computing of a movie rating using a truncated mean.
    This is a statistical measure of a central tendency where the mean is calculated
    after discarding parts of a probability distribution or sample at the high and
    low ends. Typically, this is done by removing an equal amount of points at the
    two ends. For this problem, you are required to remove 5% of both the highest
    and lowest user ratings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题需要使用截断均值来计算电影评分。这是一种统计测度，用于计算平均值，计算后丢弃概率分布或样本的高端和低端的部分。通常，这是通过在两端删除相等数量的点来完成的。对于这个问题，您需要删除最高和最低用户评分的5%。
- en: 'A function that calculates a truncated mean for a given range should do the
    following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算给定范围的截断均值的函数应该执行以下操作：
- en: Sort the range so that elements are ordered (either ascending or descending)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对范围进行排序，使元素按升序或降序排序
- en: Remove the required percentage of elements at both ends
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除两端所需百分比的元素
- en: Count the sum of all remaining elements
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算所有剩余元素的总和
- en: Compute the average by dividing the sum to the remaining count of elements
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将总和除以剩余元素的数量来计算平均值
- en: 'The `truncated_mean()` function shown here implements the described algorithm:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`truncated_mean()`函数实现了所描述的算法：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A program that uses this function in order to calculate and print movie average
    ratings may look like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数来计算并打印电影平均评分的程序可能如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 54\. Pairwise algorithm
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 54\. 两两配对算法
- en: 'The pairwise function proposed for this problem must pair adjacent elements
    of an input range and produce `std::pair` elements that are added to an output
    range. The following code listing provides two implementations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题提出的两两函数必须将输入范围的相邻元素配对，并产生添加到输出范围的`std::pair`元素。以下代码清单提供了两种实现：
- en: 'A general function template that takes iterators as arguments: a begin and
    end iterator define the input range, and an output iterator defines the position
    in the output range where the results are to be inserted'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以迭代器作为参数的通用函数模板：一个起始和结束迭代器定义了输入范围，一个输出迭代器定义了结果要插入的输出范围的位置
- en: 'An overload that takes an `std::vector<T>` as the input argument and returns
    an `std::vector<std::pair<T, T>>` as the result; this one simply calls the first
    overload:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个重载，它以`std::vector<T>`作为输入参数，并以`std::vector<std::pair<T, T>>`作为结果返回；这个只是调用第一个重载：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following program pairs the elements of a vector of integers and prints
    the pairs on the console:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序将整数向量的元素配对，并在控制台上打印出这些配对：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 55\. Zip algorithm
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 55\. 压缩算法
- en: 'This problem is relatively similar to the previous one, although there are
    two input ranges instead of just one. The result is again a range of `std::pair`.
    However, the two input ranges may hold elements of different types. Again, the
    implementation shown here contains two overloads:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题与之前的问题相对类似，尽管有两个输入范围而不只是一个。结果再次是一个`std::pair`范围。然而，两个输入范围可能包含不同类型的元素。同样，这里显示的实现包含两个重载：
- en: A general-purpose function with iterators as arguments. A begin and end iterator
    for each input range define its bounds, and an output iterator defines the position
    in the output range where the result must be written.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以迭代器作为参数的通用函数。每个输入范围都有一个起始和结束迭代器定义其边界，一个输出迭代器定义了结果必须写入的输出范围的位置。
- en: 'A function that takes two `std::vector` arguments, one that holds elements
    of type `T` and one that holds elements of type `U` and returns an `std::vector<std::pair<T,
    U>>`. This overload simply calls the previous one:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数，它接受两个`std::vector`参数，一个包含类型`T`的元素，另一个包含类型`U`的元素，并返回一个`std::vector<std::pair<T,
    U>>`。这个重载只是调用前一个：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following listing, you can see two vectors of integers zipped together
    and the result printed on the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的清单中，您可以看到两个整数向量被压缩在一起，并且结果打印在控制台上：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 56\. Select algorithm
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 56\. 选择算法
- en: The `select()` function that you have to implement takes an `std::vector<T>`
    as an input argument and a function of type `F` and returns a `std::vector<R>`
    as the result, where `R` is the result of applying `F` to `T`. We could use `std::result_of()`
    to deduce the return type of an invoke expression at compile time. Internally,
    the `select()` function should use `std::transform()` to iterate over the elements
    of the input vector, apply function `f` to each element, and insert the result
    in an output vector.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须实现的`select()`函数以`std::vector<T>`作为输入参数，并以`F`类型的函数返回`std::vector<R>`作为结果，其中`R`是将`F`应用于`T`的结果。我们可以使用`std::result_of()`在编译时推断调用表达式的返回类型。在内部，`select()`函数应该使用`std::transform()`来迭代输入向量的元素，对每个元素应用函数`f`，并将结果插入输出向量。
- en: 'The following listing shows the implementation for this function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了该函数的实现：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function can be used as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以这样使用：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 57\. Sort algorithm
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 57\. 排序算法
- en: '**Quicksort** is a comparison sorting algorithm for elements of an array for
    which a total order is defined. When implemented well, it is significantly faster
    than *merge sort* or *heap sort*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速排序**是一个比较排序算法，用于定义了全序的数组元素。当实现良好时，它比*归并排序*或*堆排序*要快得多。'
- en: 'Although in worst-case scenarios the algorithm makes ![](img/66508cd7-1912-4285-bee6-c31db3d8d58c.png)
    comparisons (when the range is already sorted), on average the complexity is only
    ![](img/0ce17681-465d-4ac5-9b80-114f13fa5f2c.png). Quicksort is a divide and conquer
    algorithm; it partitions (divides) a large range into smaller ones and sorts them
    recursively. There are several partitioning schemes. In the implementation shown
    here, we use the original one developed by *Tony Hoare*. The algorithm for this
    scheme is described in pseudocode as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在最坏情况下，该算法进行了![](img/66508cd7-1912-4285-bee6-c31db3d8d58c.png)次比较（当范围已经排序），但平均复杂度仅为![](img/0ce17681-465d-4ac5-9b80-114f13fa5f2c.png)。快速排序是一种分治算法；它将一个大范围分成较小的范围并递归地对它们进行排序。有几种分区方案。在这里显示的实现中，我们使用了*Tony
    Hoare*开发的原始方案。该方案的算法如下伪代码所示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A general-purpose implementation of the algorithm should use iterators and
    not arrays and indexes. The requirement for the following implementation is that
    the iterators are random-access (so they could be moved to any element in constant
    time):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的通用实现应该使用迭代器而不是数组和索引。以下实现的要求是迭代器是随机访问的（因此可以在常数时间内移动到任何元素）：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `quicksort()` function, shown as follows, can be used to sort various types
    of containers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示的`quicksort()`函数可用于对各种类型的容器进行排序：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The requirement was that the sorting algorithm must allow the specifying of
    a user-defined comparison function. The only change, in this case, is the partitioning
    function, where instead of using `operator <` and `>` to compare the current element
    with the pivot, we use the user-defined comparison function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要求排序算法必须允许指定用户定义的比较函数。在这种情况下，唯一的变化是分区函数，其中我们使用用户定义的比较函数来比较当前元素与枢轴：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this overload we could sort a range in descending order, as shown in the
    following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个重载，我们可以按降序对范围进行排序，如下例所示：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is possible to implement an iterative version of the quicksort algorithm
    also. The performance of the iterative version is the same as for the recursive
    version ![](img/816b6538-e697-4a62-ac80-04b85d52d611.png) for most cases, but
    degrading to ![](img/b96ce493-f107-43e9-b495-222dc77e2530.png) in the worst case
    when the range is already sorted). Converting from the recursive version of the
    algorithm to an iterative one is relatively simple; it is done by using a stack
    to emulate the recursive calls and to store the bounds of the partitions. The
    following is an iterative implementation of the version that uses `operator<`
    to compare elements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以实现快速排序算法的迭代版本。迭代版本的性能在大多数情况下与递归版本相同（但在范围已经排序的最坏情况下会降级）。从递归版本的算法转换为迭代版本相对简单；通过使用堆栈来模拟递归调用并存储分区的边界来实现。以下是使用`operator<`比较元素的迭代实现版本：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This iterative implementation can be used just like its recursive counterpart:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代实现可以像它的递归版本一样使用：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 58\. The shortest path between nodes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 58\. 节点之间的最短路径
- en: To solve the proposed problem you must use the Dijkstra algorithm for finding
    the shortest path in a graph. Although the original algorithm finds the shortest
    path between two given nodes, the requirement here is to find the shortest path
    between one specified node and all the others in the graph, which is another version
    of the algorithm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决提出的问题，必须使用Dijkstra算法来找到图中的最短路径。尽管原始算法找到两个给定节点之间的最短路径，但这里的要求是找到指定节点与图中所有其他节点之间的最短路径，这是算法的另一个版本。
- en: 'An efficient way to implement the algorithm is using a priority queue. The
    pseudocode for the algorithm (see [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm))
    is the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现算法的有效方法是使用优先队列。算法的伪代码如下（参见[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)）：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To represent the graph we could use the following data structure, which can
    be used for both directional or unidirectional graphs. The class provides support
    for adding new vertices and edges, and can return the list of vertices and the
    neighbors of a specified vertex (that is, both the nodes and the distance to them):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示图，我们可以使用以下数据结构，该数据结构可用于定向或单向图。该类支持添加新顶点和边，并可以返回顶点列表和指定顶点的邻居（即节点和到它们的距离）：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the shortest path algorithm as described in the preceding
    pseudocode could look like the following. An `std::set` (that is, a self-balancing
    binary search tree) is used instead of the priority queue. `std::set` has the
    same ![](img/aeeb1f10-1443-45f7-83fb-94ec84dfcbc1.png) complexity for adding and
    removing the top element as a binary heap (used for a priority queue). On the
    other hand, `std::set` also allows finding and removing any other element in ![](img/22931c36-91c7-4cb4-912a-7a88cf095103.png), which
    is helpful in order to implement the decrease-key step in logarithmic time by
    removing and inserting again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面伪代码中描述的最短路径算法的实现可能如下所示。使用`std::set`（即自平衡二叉搜索树）而不是优先队列。`std::set`对于添加和删除顶部元素具有与二叉堆（用于优先队列）相同的复杂度。另一方面，`std::set`还允许在`log(n)`时间内找到和删除任何其他元素，这有助于通过删除和再次插入来实现减小键步骤：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following helper functions print the results in the specified format:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下辅助函数以指定的格式打印结果：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following program solves the given task:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序解决了给定的任务：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 59\. The Weasel program
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 59\. 鼬程序
- en: 'The Weasel program is a thought experiment proposed by Richard Dawkins, intended
    to demonstrate how the accumulated small improvements (mutations that bring a
    benefit to the individual so that it is chosen by natural selection) produce fast
    results as opposed to the mainstream misinterpretation that evolution happens
    in big leaps. The algorithm for the Weasel simulation, as described on Wikipedia
    (see [https://en.wikipedia.org/wiki/Weasel_program](https://en.wikipedia.org/wiki/Weasel_program)),
    is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 鼬程序是理查德·道金斯提出的一个思想实验，旨在演示积累的小改进（通过自然选择选择的带来好处的突变）产生快速结果，与主流误解相反，即进化是以大的飞跃发生的。鼬模拟的算法，如维基百科所述（参见[https://en.wikipedia.org/wiki/Weasel_program](https://en.wikipedia.org/wiki/Weasel_program)），如下所示：
- en: Start with a random string of 28 characters.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个随机字符串开始，长度为28个字符。
- en: Make 100 copies of this string, with a 5% chance per character of that character
    being replaced with a random character.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作此字符串的100个副本，每个字符有5%的机会被替换为随机字符。
- en: Compare each new string with the target METHINKS IT IS LIKE A WEASEL, and give
    each a score (the number of letters in the string that are correct and in the
    correct position).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个新字符串与目标METHINKS IT IS LIKE A WEASEL进行比较，并为每个字符串打分（字符串中正确位置的字母数）。
- en: If any of the new strings has a perfect score (28), then stop.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何新字符串得分完美（28），则停止。
- en: Otherwise, take the highest-scoring string and go to step 2.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，取得分最高的字符串并转到步骤2。
- en: 'A possible implementation is as follows. The `make_random()` function creates
    a random starting sequence of the same length as the target; the `fitness()` function
    computes the score of each mutated string (that is, resemblance with the target);
    the `mutate()` function produces a new string from a parent with a given chance
    for each character to mutate:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '可能的实现如下。`make_random()`函数创建与目标相同长度的随机起始序列；`fitness()`函数计算每个突变字符串的得分（即与目标的相似度）；`mutate()`函数从父字符串产生一个新字符串，并为每个字符变异给出一定的机会： '
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is how the class can be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用该类的：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 60\. The Game of Life
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 60\. 生命游戏
- en: 'The class `universe` presented below implements the game as described. There
    are several functions of interest:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面介绍的`universe`类实现了如上所述的游戏。有几个有趣的功能：
- en: '`initialize()` generates a starting layout; although the code accompanying
    the book contains more options, only two are listed here: `random`, which generates
    a random layout, and `ten_cell_row`, which represents a line of 10 cells in the
    middle of the grid.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 生成一个起始布局；尽管书中的代码包含更多选项，但这里只列出了两个：`random`，生成一个随机布局，和 `ten_cell_row`，表示网格中间的
    10 个细胞的一行。'
- en: '`reset()` sets all the cells as `dead`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()` 将所有细胞设置为 `dead`。'
- en: '`count_neighbors()` returns the number of alive neighbors. It uses a helper
    variadic function template `count_alive()`. Although this could be implemented
    with fold expressions, this is not yet supported in Visual C++ and therefore I
    have opted not to use it here.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_neighbors()` 返回活着的邻居数量。它使用一个辅助的可变函数模板 `count_alive()`。虽然这可以用折叠表达式实现，但在
    Visual C++ 中尚不支持，因此我选择不在这里使用它。'
- en: '`next_generation()` produces a new state of the game based on the transition
    rules.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next_generation()` 根据过渡规则产生游戏的新状态。'
- en: '`display()` shows the game status on the console; this uses a system call to
    erase the console, although you could use other means to do so, such as specific
    operating system APIs.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display()` 在控制台上显示游戏状态；这使用系统调用来擦除控制台，尽管您可以使用其他方法来做到这一点，比如特定的操作系统 API。'
- en: '`run()` initializes the starting layout and then produces a new generation
    at a user-specified interval, for a user-specified number of iterations, or indefinitely
    (if the number of iterations was set to 0).'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()` 初始化起始布局，然后以用户指定的间隔产生新的一代，进行用户指定次数的迭代，或者无限期地进行（如果迭代次数设置为 0）。'
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is how the game can be run for 100 iterations starting from a random state:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从随机状态开始运行 100 次迭代的游戏：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is an example of the program output (the screenshot represents a single
    iteration in the Game of Life''s universe):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序输出的一个示例（屏幕截图表示生命游戏宇宙中的单次迭代）：
- en: '![](img/9f48c4ae-d266-4151-b814-33bf8473953b.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f48c4ae-d266-4151-b814-33bf8473953b.png)'
