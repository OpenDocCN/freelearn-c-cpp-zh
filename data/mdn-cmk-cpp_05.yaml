- en: '*Chapter 6*: Linking with CMake'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*6*章：使用CMake进行链接
- en: You might think that after we have successfully compiled the source code into
    a binary file, our job as build engineers is done. That's almost the case – binary
    files contain all the code for a CPU to execute, but the code is scattered across
    multiple files in a very complex way. Linking is a process that simplifies things
    and makes machine code neat and quick to consume.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，在我们成功将源代码编译成二进制文件之后，作为构建工程师我们的工作就完成了。事实几乎如此——二进制文件包含了CPU执行的所有代码，但代码分散在多个文件中，方式非常复杂。链接是一个简化事物并使机器代码整洁、易于消费的过程。
- en: A quick glance at the list of commands will tell you that CMake doesn't provide
    that many related to linking. Admittedly, `target_link_libraries()` is the only
    one that actually configures this step. Why dedicate a whole chapter to a single
    command then? Unfortunately, almost nothing is ever easy in computer science,
    and linking is no exception.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看命令列表会让你知道CMake并没有提供很多与链接相关的命令。承认，`target_link_libraries()`是唯一一个实际配置这一步骤的命令。那么为什么要用一整章来讲述一个命令呢？不幸的是，在计算机科学中，几乎没有什么事情是容易的，链接也不例外。
- en: To achieve the correct results, we need to follow the whole story – understand
    how exactly a linker works and get the basics right. We'll talk about the internal
    structure of *object files*, how the relocation and reference resolution works,
    and what it is for. We'll discuss how the final executable differs from its components
    and how the process image is built by the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得正确的结果，我们需要跟随整个故事——了解链接器究竟如何工作，并正确掌握基础知识。我们将讨论*对象文件*的内部结构，如何进行重定位和引用解析，以及它们的用途。我们将讨论最终可执行文件与其组件的区别以及系统如何构建进程映像。
- en: Then, we'll introduce you to all kinds of libraries – static, shared, and shared
    modules. They all are called libraries, but in reality, they are almost nothing
    alike. Building a correctly linked executable heavily depends on a valid configuration
    (and taking care of such minute details as **position-independent code** (**PIC**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将向您介绍各种库——静态库、共享库和共享模块。它们都被称为库，但实际上它们几乎没有任何共同之处。构建正确链接的可执行文件严重依赖于有效的配置（以及关注如**位置无关代码**（**PIC**）这样的微小细节。
- en: We'll learn about another nuisance of linking – the **One Definition Rule**
    (**ODR**). We need to get the amount of definitions exactly right. Dealing with
    duplicated symbols can sometimes be very tricky, especially when shared libraries
    come into play. Then, we'll learn why linkers sometimes can't find external symbols,
    even when the executable is linked with the appropriate library.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习链接过程中的另一个麻烦——**一定义规则**（**ODR**）。我们需要正好得到定义的数量。处理重复的符号有时可能非常棘手，特别是当共享库涉及其中时。然后，我们将了解为什么有时链接器找不到外部符号，即使可执行文件与适当的库链接在一起。
- en: Finally, we'll discover how we can save time and use a linker to prepare our
    solution for testing with dedicated frameworks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将了解到如何节省时间并使用链接器为我们的解决方案准备测试，专用框架。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Getting the basics of linking right
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确掌握链接的基础知识
- en: Building different library types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建不同类型的库
- en: Solving problems with the One Definition Rule
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决一定义规则的问题
- en: The order of linking and unresolved symbols
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接的顺序和未解析的符号
- en: Separating `main()` for testing
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试分离`main()`
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter06](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter06).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter06](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter06)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用建议的命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree**是指向目标/输出目录的路径，**source
    tree**是指你的源代码所在的路径。
- en: Getting the basics of linking right
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确掌握链接的基础知识
- en: We discussed the life cycle of a C++ program in [*Chapter 5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126),
    *Compiling C++ Sources with CMake*. It consists of five main stages – writing,
    compiling, linking, loading, and execution. After correctly compiling all the
    sources, we need to put them together into an executable. *Object files* produced
    in a compilation can't be executed by a processor directly. But why?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第 5 章*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)中讨论了 C++ 程序的生命周期，*使用
    CMake 编译 C++ 源代码*。它包括五个主要阶段——编写、编译、链接、加载和执行。在正确编译所有源代码后，我们需要将它们组合成一个可执行文件。编译过程中产生的
    *对象文件* 不能直接被处理器执行。但为什么不能呢？
- en: 'To answer this, let''s take a look at how a compiler structures an *object
    file* in the popular ELF format (used by Unix-like systems and many others):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，让我们来看看编译器是如何构建流行 ELF 格式的（Unix-like 系统和许多其他系统使用）*对象文件*的：
- en: '![Figure 6.1 – The structure of an object file'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – *对象文件*的结构'
- en: '](img/Figure_6.1_B17205.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B17205.jpg)'
- en: Figure 6.1 – The structure of an object file
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – *对象文件*的结构
- en: 'The compiler will prepare an *object file* for every unit of translation (for
    every `.cpp` file). These files will be used to build an in-memory image of our
    program. *Object files* contain the following elements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将为每个翻译单元（每个 `.cpp` 文件）准备一个 *对象文件*。这些文件将用于构建我们程序的内存映像。*对象文件*包含以下元素：
- en: An ELF header identifying the target operating system, ELF file type, target
    instruction set architecture, and information on the position and size of two
    header tables found in ELF files – the program headers table (not present in *object
    files*) and the section headers table.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 ELF 头，用于标识目标操作系统、ELF 文件类型、目标指令集架构以及 ELF 文件中找到的两个头表的位置和大小信息——程序头表（不在*对象文件*中）和段头表。
- en: Sections containing information grouped by type (described next).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类型分组的信息段。
- en: A section headers table, containing information about the name, the type, flags,
    the destination address in memory, the offset in the file, and other miscellaneous
    information. It is used to understand what sections are in this file and where
    they are, just like a table of contents.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个段头表，包含关于名称、类型、标志、内存中的目标地址、文件中的偏移量以及其他杂项信息。它用于理解这个文件中有哪些段以及它们的位置，就像目录一样。
- en: 'As the compiler processes your source code, it groups the collected information
    into a few separate bins, which will be put in their own separate section. Some
    of them are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在处理你的源代码时，会将收集的信息分组到几个不同的容器中，这些容器将被放在它们自己的独立部分。其中一些如下：
- en: '`.text` section: Machine code, with all the instructions to be executed by
    the processor'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text` 段：机器代码，包含处理器要执行的所有指令'
- en: '`.data` section: All values of the initialized global and static objects (variables)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data` 段：所有初始化全局和静态对象（变量）的值'
- en: '`.bss` section: All values of the uninitialized global and static objects (variables),
    which will be initialized to zero on program start'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.bss` 段：所有未初始化全局和静态对象（变量）的值，将在程序启动时初始化为零'
- en: '`.rodata` section: All values of the constants (read-only data)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.rodata` 段：所有常量（只读数据）的值'
- en: '`.strtab` section: A string table containing all constant strings such as *Hello
    World* that we put in our basic `hello.cpp` example'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.strtab` 段：包含所有常量字符串的字符串表，如我们在基本 `hello.cpp` 示例中放入的 *Hello World*'
- en: '`.shstrtab` section: A string table containing the names of all the sections'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shstrtab` 段：包含所有段名称的字符串表'
- en: These groups very closely resemble the final version of the executable, which
    will be put in the RAM to run our application. However, we can't just load this
    file to memory as it is. This is because every *object file* has its own set of
    sections. If we were to just concatenate them together, we'd run into all sorts
    of issues. We'd be wasting a lot of space and time, as we'd need many more pages
    of RAM. Instructions and data would be much harder to copy to a CPU cache. An
    entire system would have to be much more complex and would waste precious cycles
    jumping around many (possibly tens of thousands) of `.text`, `.data`, and other
    sections during runtime.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组非常类似于最终的可执行版本，它们将被放入 RAM 中以运行我们的应用程序。然而，我们并不能像这样直接将这个文件加载到内存中。这是因为每个 *对象文件*
    都有自己的段集合。如果我们只是将它们连接在一起，我们就会遇到各种问题。我们将浪费大量的空间和时间，因为我们需要更多的内存页面。指令和数据将更难复制到 CPU
    缓存中。整个系统将不得不更加复杂，并且会在运行时浪费宝贵的周期在许多（可能达到数万）`.text`、`.data` 和其他段之间跳转。
- en: So, what we'll do instead is take each section of the *object file* and put
    it together with the same type of section from all other *object files*. This
    process is called `Relocatable` for *object files*). Apart from just bringing
    appropriate sections together, it has to update internal associations in the file
    – that is, addresses of variables, functions, symbol table indexes, or string
    table indexes. All of these values are local to the *object file*, and their numbering
    starts from zero. When we bundle files together, we need to offset these values
    so that they are pointing at the correct addresses in the combined file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将要做的 instead is take each section of the *object file* and put it together
    with the same type of section from all other *object files*. 这个过程称为`Relocatable`对于*对象文件*).
    除了只是将相应的段放在一起，它还必须更新文件内的内部关联——即，变量的地址、函数的地址、符号表索引或字符串表索引。所有这些值都是针对*对象文件*的局部值，它们的编号从零开始。当我们捆绑文件在一起时，我们需要偏移这些值，以便它们指向捆绑文件中的正确地址。
- en: '*Figure 6.2* shows relocation in action – the `.text` section is relocated,
    `.data` is being built from all linked files, and `.rodata` and `.strtab` will
    follow (for simplicity, the figure doesn''t contain headers):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 显示了移动 in action – *.text* 段被移动，*.data* 正在从所有链接的文件中构建，*.rodata* 和 *.strtab*
    将紧随其后（为了简化，图不包括头）：
- en: '![Figure 6.2 – The relocation of the .data section'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – .data段的移动'
- en: '](img/Figure_6.2_B17205.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B17205.jpg)'
- en: Figure 6.2 – The relocation of the .data section
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – .data段的移动
- en: 'Secondly, a linker needs to `extern` keyword), the compiler reads the declaration
    and *trusts* that the definition is somewhere out there and will be provided at
    a later time. A linker is responsible for collecting such *unresolved references*
    to external symbols, finding and filling the addresses at which they reside after
    merging into the executable. *Figure 6.3* shows a simple example of reference
    resolution:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，链接器需要`extern`关键字)，编译器读取声明并*信任*定义在外面某个地方，稍后再提供。链接器负责收集此类*未解决的外部符号引用*，在合并到可执行文件后找到并填充它们所在的地址。图
    6.3 显示了一个简单的引用解析示例：
- en: '![Figure 6.3 – A reference resolution'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 引用解析'
- en: '](img/Figure_6.3_B17205.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B17205.jpg)'
- en: Figure 6.3 – A reference resolution
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 引用解析
- en: This part of the linking can be a source of problems if a programmer is unaware
    of how it works. We may end up with unresolved references that won't find their
    external symbols, or the opposite – we provided too many definitions and the linker
    doesn't know which one to pick.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员不知道它是如何工作的，链接的这部分可能会成为问题之源。我们可能会最终得到未解决的引用，它们找不到它们的外部符号，或者相反——我们提供了太多的定义，链接器不知道选择哪一个。
- en: The final *executable file* looks very similar to the *object file*; it contains
    relocated sections with resolved references, a section headers table, and of course,
    the ELF Header describing the whole file. The main difference is the presence
    of the Program Header (as pictured in *Figure 6.4*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的*可执行文件*与*对象文件*非常相似；它包含已移动的段和已解决的引用、段头表，当然还有描述整个文件的ELF头。主要区别在于存在程序头（如图*6.4*所示）。
- en: '![Figure 6.4 – The structure of the executable file in ELF'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – ELF中可执行文件的结构'
- en: '](img/Figure_6.4_B17205.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B17205.jpg)'
- en: Figure 6.4 – The structure of the executable file in ELF
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – ELF中可执行文件的结构
- en: The Program Header is placed right after the ELF Header. A system loader will
    read this header to create a process image. The header contains some general information
    and a description of the memory layout. Each entry in the layout represents one
    fragment of memory called a **segment**. Entries specify which sections will be
    read, in what order, to which addresses in the virtual memory, what their flags
    are (read, write, or execute), and a few other useful details.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 程序头位于ELF头之后。系统加载器将读取此头以创建进程映像。该头包含一些通用信息和内存布局的描述。布局中的每个条目代表一个称为**段**的内存片段。条目指定要读取哪些段，以什么顺序，以及虚拟内存中的哪些地址，它们的标志是什么（读、写或执行），还有一些其他有用的细节。
- en: '*Object files* may also be bundled in a library, which is an intermediate product
    that can be used in a final executable or another library. In the next section,
    we''ll discuss three types of libraries.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文件*也可能被打包进库中，这是一种中间产品，可以被用于最终的执行文件或其他库中。在下一节中，我们将讨论三种库的类型。
- en: Building different library types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建不同类型的库
- en: 'After source code is compiled, we might want to avoid compiling it again for
    the same platform or even share it with external projects wherever possible. Of
    course, you could just simply provide all of your *object files* as they were
    originally created, but that has a few downsides. It is harder to distribute multiple
    files and add them individually to a buildsystem. It can be a hassle, especially
    if they are numerous. Instead, we could simply bring all *object files* into a
    single object and share that. CMake helps greatly with this process. We can create
    these libraries with a simple `add_library()` command (which is consumed with
    the `target_link_libraries()` command). By convention, all libraries have a common
    prefix, `lib`, and use system-specific extensions that denote what kind of library
    they are:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码编译后，我们可能希望避免在同一平台上一再编译，甚至尽可能与外部项目共享。当然，你也可以简单地提供所有的*目标文件*，就像它们最初被创建的那样，但这有几个缺点。分发多个文件并分别添加到构建系统中更加困难。如果它们很多，这可能会很麻烦。相反，我们可以简单地将所有的*目标文件*合并到一个单一的目标中并共享它。CMake在这个过程中极大地帮助我们。我们可以使用简单的`add_library()`命令（与`target_link_libraries()`命令一起使用）创建这些库。按惯例，所有库都有一个公共前缀`lib`，并使用特定于系统的扩展名表示它们是哪种类型的库：
- en: A static library has a `.a` extension on Unix-like systems and `.lib` on Windows.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类Unix系统上，静态库有一个`.a`扩展名，在Windows上则是`.lib`。
- en: Shared libraries have a `.so` extension on Unix-like systems and `.dll` on Windows.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库在类Unix系统上有`.so`扩展名，在Windows上有`.dll`。
- en: 'When building libraries (static, shared, or shared modules), you''ll often
    encounter the name *linking* for this process. Even CMake calls it that in the
    build output of the `chapter06/01-libraries` project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建库（静态、共享或共享模块）时，你经常会遇到这个名字*链接*来表示这个过程。即使CMake在`chapter06/01-libraries`项目的构建输出中也这样称呼它：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Contrary to how it may seem, a linker isn't used to create all of the preceding
    libraries. There are exceptions to performing relocation and reference resolution.
    Let's take a look at each library type to understand how each works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与可能看起来相反，链接器并不用于创建所有上述库。执行重定位和引用解析有例外。让我们来看看每种库类型，了解它们是如何工作的。
- en: Static libraries
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态库
- en: 'To build a static library, we can simply use the command we already saw in
    previous chapters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个静态库，我们可以简单地使用我们在前面章节中已经看到的命令：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will produce a static library if the `BUILD_SHARED_LIBS`
    variable isn''t set to `ON`. If we want to build a static library regardless,
    we can provide an explicit keyword:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`BUILD_SHARED_LIBS`变量没有设置为`ON`，上述代码将生成一个静态库。如果我们想无论如何都构建一个静态库，我们可以提供一个显式的关键字：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What are static libraries? They are essentially a collection of raw *object
    files* stored in an archive. On Unix-like systems, such archives can be created
    by the `ar` tool. Static libraries are the oldest and most basic mechanism to
    provide a compiled version of code. Use them if you want to avoid separating your
    dependencies from the executable, at the price of the executable increasing in
    size and used memory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库是什么？它们本质上是一组存储在归档中的原始*目标文件*。在类Unix系统上，这样的归档可以通过`ar`工具创建。静态库是最古老、最基本的提供编译代码的方法。如果你想避免将你的依赖项与可执行文件分离，那么你可以使用它们，但代价是可执行文件的大小和占用内存会增加。
- en: The archive may contain some additional indexes to speed up the final linking
    process. Each platform uses its own methods to generate those. Unix-like systems
    use a tool called `ranlib` for this purpose.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 归档可能包含一些额外的索引，以加快最终的链接过程。每个平台都使用自己的方法来生成这些索引。类Unix系统使用一个名为`ranlib`的工具来完成这项工作。
- en: Shared libraries
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库
- en: 'It''s not surprising to learn that we can build shared libraries with the `SHARED`
    keyword:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 了解到我们可以使用`SHARED`关键字来构建共享库，这并不令人惊讶：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also do it by setting the `BUILD_SHARED_LIBS` variable to `ON` and using
    the short version:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将`BUILD_SHARED_LIBS`变量设置为`ON`并使用简短版本来实现：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The difference from static libraries is significant. Shared libraries are built
    using a linker, and they will perform both stages of linking. This means that
    we'll receive a file with proper section headers, sections, and a section header
    table (*Figure 6.1*).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态库相比，这种差异是显著的。共享库使用链接器构建，并将执行链接的两个阶段。这意味着我们将收到带有正确段头、段和段头表的文件(*图6.1*)。
- en: Shared libraries (also known as shared objects) can be shared between multiple
    different applications. An operating system will load a single instance of such
    a library into memory with the first program that uses it, and all subsequently
    started programs will be provided with the same address (thanks to the complex
    mechanisms of virtual memory). Only the `.data` and `.bss` segments will be created
    separately for every process consuming the library (so that each process can modify
    its own variables without affecting other consumers).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库（也称为共享对象）可以在多个不同的应用程序之间共享。操作系统将在第一个使用它的程序中将这样的库加载到内存中的一个实例，并且所有随后启动的程序都将提供相同的地址（感谢复杂的虚拟内存机制）。只有`.data`和`.bss`段将为每个消耗库的进程创建单独的实例（这样每个进程就可以修改自己的变量，而不会影响其他消费者）。
- en: Thanks to this approach, the overall memory usage in the system is better. And
    if we're using a very popular library, we might not need to ship it with our program.
    Chances are that it's already available on the target machine. However, if that's
    not the case, a user is expected to explicitly install it before running the application.
    This opens up the possibility of some issues when an installed version of a library
    is different from expected (this type of problem is called *dependency hell*;
    more information can be found in the *Further reading* section).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于这种方法，系统中的整体内存使用情况得到了改善。如果我们使用一个非常受欢迎的库，我们可能不需要将其与我们的程序一起分发。很可能目标机器上已经提供了这个库。然而，如果情况不是这样，用户在运行应用程序之前需要明确地安装它。这可能会导致一些问题，当安装的库版本与预期不符时（这类问题被称为*依赖地狱*；更多信息可以在*进阶阅读*部分找到）。
- en: Shared modules
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享模块
- en: 'To build shared modules, we need to use the `MODULE` keyword:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建共享模块，我们需要使用`MODULE`关键字：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a version of a shared library that is intended to be used as a plugin
    loaded during runtime, rather than something that is linked with an executable
    during compilation. A shared module isn't loaded automatically with the start
    of the program (like regular shared libraries). This only happens when a program
    explicitly requests it by making a system call such as `LoadLibrary` (Windows)
    or `dlopen()/dlsym()` (Linux/macOS).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个旨在作为插件在运行时加载的共享库版本，而不是在编译时与可执行文件链接的东西。共享模块不会随着程序的启动自动加载（像常规共享库那样）。只有在程序通过进行系统调用（如Windows上的`LoadLibrary`或Linux/macOS上的`dlopen()/dlsym()`）明确请求时，才会发生这种情况。
- en: You shouldn't try to link your executable with a module, as this isn't guaranteed
    to work on all platforms. If you need to do that, use regular shared libraries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该尝试将你的可执行文件与模块链接，因为这在所有平台上都不能保证有效。如果你需要这样做，请使用常规共享库。
- en: Position-independent code
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置无关代码
- en: All sources for shared libraries and modules should be compiled with a *position-independent
    code* flag enabled. CMake checks the `POSITION_INDEPENDENT_CODE` property of targets
    and appropriately adds compiler-specific compilation flags such as `-fPIC` for
    `gcc` or `clang`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有共享库和模块的源代码都应该使用*位置无关代码*标志编译。CMake检查目标的`POSITION_INDEPENDENT_CODE`属性，并适当地添加编译器特定的编译标志，如`gcc`或`clang`的`-fPIC`。
- en: PIC is a bit of a confusing term. Nowadays, programs are already *position-independent*
    in a sense, in that they use virtual memory to abstract away actual physical addresses.
    When calling a function, a CPU uses a `0` for every process) to a physical address
    that was available at the time of allocation. These mappings don't have to point
    to consecutive physical addresses or follow any other specific order.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PIC这个词有点让人困惑。现在，程序已经在某种意义上*位置无关*，因为它们使用虚拟内存来抽象实际的物理地址。在调用函数时，CPU使用对每个进程来说都是`0`的物理地址，该物理地址在分配时可用。这些映射不必指向连续的物理地址或遵循任何特定的顺序。
- en: PIC is about mapping symbols (references to functions and global variables)
    to their runtime addresses. During compilation of a library, it is not known which
    processes might use it. It's not possible to predetermine where in the virtual
    memory the library will be loaded or in what order. This, in turn, means that
    the addresses of the symbols are unknown, as is their relative position to the
    library's machine code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PIC是关于将符号（对函数和全局变量的引用）映射到它们的运行时地址。在库的编译过程中，不知道哪些进程可能会使用它。无法预先确定库将在虚拟内存中的哪个位置加载，或者将以什么顺序加载。这反过来意味着符号的地址是未知的，以及它们相对于库机器代码的位置也是未知的。
- en: To deal with that, we need another level of indirection. PIC will add a new
    section to our output – the `.text` section is known during linking; therefore,
    all symbol references can be pointed (through an offset) to a placeholder GOT
    at that time. The actual values pointing to symbols in memory will only be filled
    when an instruction accessing a referenced symbol is first executed. At that time,
    a loader will set up that particular entry in the GOT (this is where the term
    *lazy loading* comes from).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要增加一个间接层。PIC将为我们添加一个新节到输出中——`.text`节在链接时是已知的；因此，所有符号引用可以在那时指向占位符GOT。指向内存中符号的实际值将在首次执行访问引用符号的指令时填充。那时，加载器将设置GOT中特定条目的值（这就是*懒加载*这个术语的由来）。
- en: 'Shared libraries and modules will have the `POSITION_INDEPENDENT_CODE` property
    automatically set to `ON` by CMake. However, it is important to remember that
    if your shared library is linked against another target, such as a static or object
    library, you need to set this property on that target too. Here''s how:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库和模块将自动将`POSITION_INDEPENDENT_CODE`属性设置为`ON`。然而，重要的是要记住，如果你的共享库被链接到另一个目标，比如静态库或对象库，你也需要在这个目标上设置这个属性。这是如何做到的：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Failing to do so will get you into trouble with CMake, as this property is by
    default checked for conflicts in a manner described in the *Dealing with conflicting
    propagated properties* section of [*Chapter 4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106),
    *Working With Targets*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不这样做会在CMake上遇到麻烦，因为默认情况下，此属性会以描述*处理传播属性冲突*一节中的方式进行检查[*第四章*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106)，*与目标一起工作*。
- en: Speaking of symbols, there's another problem to discuss. The next section is
    about name collisions leading to ambiguity and inconsistency in definitions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 说到符号，还有一个问题需要讨论。下一节将讨论名称冲突导致定义不明确和不一致的问题。
- en: Solving problems with the One Definition Rule
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单一定义规则解决问题的方法
- en: 'Phil Karlton was right on point when he said the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 菲尔·卡尔顿说得一点也没错，他说如下的话：
- en: '"There are two hard things in computer science: cache invalidation and naming
    things."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “计算机科学中有两件困难的事情：缓存失效和命名事物。”
- en: Names are difficult for a few reasons – they have to be precise, simple, short,
    and expressive at the same time. That makes them meaningful and allows programmers
    to understand the concepts behind the raw implementation. C++ and many other languages
    impose one more requirement – many names have to be unique.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 名称之所以难以处理，有几个原因——它们必须精确、简单、短小且富有表现力。这使得它们具有意义，并允许程序员理解背后的概念。C++和许多其他语言提出了一个额外的要求——许多名称必须是唯一的。
- en: This is manifested in a few different ways. A programmer is required to follow
    the ODR. This says that in the scope of a single translation unit (a single `.cpp`
    file), you are required to *define* it exactly once, even if you *declare* the
    same name (of a variable, function, class type, enumeration, concept, or template)
    multiple times.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这以几种不同的方式表现出来。程序员需要遵循ODR。这表明，在单个翻译单元（单个`.cpp`文件）的作用域内，您需要精确一次地*定义*它，即使您多次*声明*相同的名称（变量、函数、类类型、枚举、概念或模板）。
- en: 'This rule is extended to the scope of an entire program for all variables you
    effectively use in your code and non-inlined functions. Consider the following
    example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则将扩展到整个程序的作用域，适用于您在代码中实际使用的所有变量和非内联函数。考虑以下示例：
- en: chapter06/02-odr-fail/shared.h
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章/02-odr-fail/shared.h
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: chapter06/02-odr-fail/one.cpp
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章/02-odr-fail/one.cpp
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: chapter06/02-odr-fail/two.cpp
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章/02-odr-fail/two.cpp
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: chapter06/02-odr-fail/two.cpp
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第六章/02-odr-fail/two.cpp
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, it''s very straightforward – we created a `shared.h` header
    file used in two separate translation units:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这是非常直接的——我们创建了一个`shared.h`头文件，它在两个单独的翻译单元中使用：
- en: '`one.cpp`, which simply prints `i` to the screen'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`one.cpp`文件，它简单地将`i`打印到屏幕上'
- en: '`two.cpp`, which does nothing except include the header'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`two.cpp`文件，它除了包含头文件外什么也不做'
- en: 'We then link the two into a single executable and receive the following error:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将这两个文件链接成一个可执行文件，并收到以下错误：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can''t define these things twice. However, there''s a notable exception
    – types, templates, and extern inline functions can repeat their definitions in
    multiple translation units if they are exactly the same (that is, they have the
    same sequence of tokens). We can prove that by replacing a simple definition,
    `int i;`, with a definition of a class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能定义这些事情两次。然而，有一个值得注意的例外——类型、模板和外部内联函数可以在多个翻译单元中重复定义，如果它们完全相同（即，它们的标记序列相同）。我们可以通过将简单的定义`int
    i;`替换为类定义来证明这一点：
- en: chapter06/03-odr-success/shared.h
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/03-odr-success/shared.h
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we use it like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像这样使用它：
- en: chapter06/03-odr-success/one.cpp
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/03-odr-success/one.cpp
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The other two files, `two.cpp` and `CMakeLists.txt`, remain the same, as in
    the `02odrfail` example. Such a change will allow the linking to succeed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个文件`two.cpp`和`CMakeLists.txt`保持不变，与`02odrfail`示例中的一样。这样的更改将允许链接成功：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, we can mark the variable as local to a translation unit (it
    won''t be exported outside of the *object file*). To do so, we''ll use the `static`
    keyword, like so:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将变量标记为翻译单元局部（它不会被导出到*对象文件*之外）。为此，我们将使用`static`关键字，如下所示：
- en: chapter06/04-odr-success/shared.h
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/04-odr-success/shared.h
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All other files will remain the same, as in the original example, and linking
    will still succeed. This, of course, means that the variable in the preceding
    code is stored in separate memory for each translation unit, and changes to one
    won't affect the other.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他文件都将保持不变，与原始示例一样，链接仍然成功。这当然意味着前面的代码中的变量为每个翻译单元存储在单独的内存中，一个翻译单元的更改不会影响另一个。
- en: Dynamically linked duplicated symbols
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态链接的重复符号
- en: 'The ODR rule works exactly the same for static libraries as it does for *object
    files*, but things aren''t so clear when we build our code with `SHARED` libraries.
    A linker will allow duplicated symbols here. In the following example, we''ll
    create two shared libraries, `A` and `B`, with one `duplicated()` function and
    two unique `a()` and `b()` functions:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 名称解析规则（ODR）对静态库和*对象文件*的作用完全一样，但当我们使用`SHARED`库构建代码时，情况就不那么明确了。链接器将允许在此处重复符号。在以下示例中，我们将创建两个共享库`A`和`B`，其中一个`duplicated()`函数和两个独特的`a()`和`b()`函数：
- en: chapter06/05-dynamic/a.cpp
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/05-dynamic/a.cpp
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second implementation file is almost an exact copy of the first:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个实现文件几乎是第一个的完全副本：
- en: chapter06/05-dynamic/b.cpp
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/05-dynamic/b.cpp
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s use each function to see what happens (we''ll declare them locally
    with `extern` for simplicity):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用每个函数来看看会发生什么（为了简单起见，我们将用`extern`局部声明它们）：
- en: chapter06/05-dynamic/main.cpp
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/05-dynamic/main.cpp
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will run unique functions from each library and then call
    a function defined with the same signature in both dynamic libraries. What do
    you think will happen? Would the linking order matter in this case? Let''s test
    it for two cases:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将运行每个库的独特函数，然后调用在两个动态库中都定义有相同签名的函数。你认为会发生什么？在这种情况下链接顺序重要吗？让我们为两种情况测试一下：
- en: '`main_1` linked with the `a` library first'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_1`首先与`a`库链接。'
- en: '`main_2` linked with the `b` library first'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main_2`首先与`b`库链接。'
- en: 'Here''s the code for such a project:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个此类项目的代码：
- en: chapter06/05-dynamic/CMakeLists.txt
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/05-dynamic/CMakeLists.txt
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After building and running both executables, we''ll see the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行两个可执行文件后，我们将看到以下输出：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Aha! So, a linker does care about the order of the linked libraries. This may
    create some confusion if we aren't careful. In practice, naming collisions aren't
    as rare as they seem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！所以，链接器确实关心链接库的顺序。如果我们不小心，这可能会造成一些混淆。实际上，名称冲突并不像看起来那么罕见。
- en: 'There are some exceptions to this behavior; if we define locally visible symbols,
    they will take precedence over those available from dynamically linked libraries.
    Adding the following function to `main.cpp` will change the last line of output
    of both binaries to **duplicated MAIN**, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为有一些例外；如果我们定义本地可见符号，它们将优先于从动态链接库中可用的那些。在`main.cpp`中添加以下函数将使两个二进制的输出最后一行都变为**重复的MAIN**，如下所示：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Always take great care when exporting names from libraries, as you're bound
    to encounter name collisions sooner or later.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当导出库中的名称时，总是要非常小心，因为迟早会遇到名称冲突。
- en: Use namespaces – don't count on a linker
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间——不要依赖链接器
- en: The concept of namespaces was invented to avoid such weird problems and deal
    with the ODR in a manageable way. It comes as no surprise that it is recommended
    to wrap your library code in a namespace named after the library. This way, we
    can escape all the problems of duplicated symbols.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的概念是为了避免这种奇怪的问题，并以一种可管理的方式处理ODR（唯一公共引用规则）。难怪建议用与库同名的命名空间包裹你的库代码。这样，我们可以摆脱所有重复符号的问题。
- en: In our projects, we might experience situations where one shared library is
    linking another and then another in a lengthy chain. These aren't that rare, especially
    in more complex setups. It is important to remember that simply linking one library
    to another doesn't imply any kind of namespace inheritance. Symbols in each link
    of this chain remain unprotected, kept in the namespaces in which they were originally
    compiled.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们可能会遇到一种情况，其中一个共享库会链接另一个，然后又链接另一个，形成一个漫长的链。这并不罕见，尤其是在更复杂的设置中。重要的是要记住，简单地将一个库链接到另一个库并不意味着有任何命名空间继承。这个链中的每个符号都保持未保护状态，保存在它们最初编译的命名空间中。
- en: The quirks of a linker are interesting and useful to know on a couple of occasions,
    but let's talk about a not-so-uncommon problem – what to do when correctly defined
    symbols go missing without an explanation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器的怪癖在某些场合很有趣且有用，但让我们谈谈一个并不那么罕见的问题——当正确定义的符号无缘无故失踪时该怎么办。
- en: The order of linking and unresolved symbols
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接顺序和未解决符号
- en: A linker can often seem whimsical and start complaining about things for no
    apparent reason. This is an especially difficult ordeal for programmers starting
    out who don't know their way around this tool. It's no wonder, since they usually
    try to avoid touching build configuration for as long as they possibly can. Eventually,
    they're forced to change something (perhaps add a library they worked on) in the
    executable, and all hell breaks loose.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器往往看起来有些古怪，经常会无缘无故地抱怨一些事情。这对刚开始接触的程序员来说是一个尤其艰难的考验，因为他们还不太熟悉这个工具。难怪他们会尽可能长时间地避免接触构建配置。最终，他们不得不修改一些东西（也许是在可执行文件中添加一个他们工作的库），然后一切就乱套了。
- en: 'Let''s consider a fairly simple dependency chain – the `main` executable depends
    on the `outer` library, which depends on the `nested` library (containing the
    necessary `int b` variable). Suddenly, an inconspicuous message appears on the
    programmer''s screen:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个相当简单的依赖链——主可执行文件依赖于`outer`库，而`outer`库又依赖于`nested`库（包含必要的`int b`变量）。突然间，程序员的屏幕上出现了一个不起眼的提示信息：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This isn''t such a rare diagnostic – usually, it means that we forgot to add
    a necessary library to the linker. But in this case, the library is actually added
    correctly to the `target_link_libraries()` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个罕见的诊断——通常，这意味着我们忘记向链接器添加一个必要的库。但在这种情况下，库实际上已经被正确地添加到了`target_link_libraries()`命令中：
- en: chapter06/06-order/CMakeLists.txt
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章/06-order/CMakeLists.txt
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What then!? Very few errors can be as infuriating to debug and understand.
    What we''re seeing here is an incorrect order of linking. Let''s dive into the
    source code to figure out the reason:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那接下来怎么办！？很少有错误会让人如此抓狂地去调试和理解。我们在这里看到的是链接顺序的不正确。让我们深入源代码找出原因：
- en: chapter06/06-order/main.cpp
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章/06-order/main.cpp
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code seems easy enough – we''ll print an `a` external variable,
    which can be found in the `outer` library. We''re declaring it ahead of time with
    the `extern` keyword. Here is the source for that library:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来简单 enough —— 我们将打印一个名为`a`的外部变量，可以在`outer`库中找到。我们提前用`extern`关键词声明它。以下是该库的源代码：
- en: chapter06/06-order/outer.cpp
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章/06-order/outer.cpp
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is quite simple too – `outer` is depending on the `nested` library to
    provide the `b` external variable, which gets assigned to the `a` exported variable.
    Let''s see the source of `nested` to confirm that we''re not missing the definition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这也相当简单——`outer`依赖于`nested`库来提供`b`外部变量，该变量被分配给`a`导出变量。让我们查看`nested`的源代码，以确认我们没有错过定义：
- en: chapter06/06-order/nested.cpp
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第6章/06-order/nested.cpp
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So indeed, we have provided the definition for `b`, and since it''s not marked
    as local with the `static` keyword, it''s correctly exported from the `nested`
    target. As we saw previously, this target is linked with the `main` executable
    in `CMakeLists.txt`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们已经为`b`提供了定义，而且因为没用`static`关键词标记为局部，所以它正确地从`nested`目标导出。正如我们之前看到的，这个目标在`CMakeLists.txt`中与`main`可执行文件链接：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: So where does the `undefined reference to 'b'` error come from?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`undefined reference to 'b'`错误是从哪里来的呢？
- en: 'Resolving undefined symbols works like this – a linker processes the binaries
    from left to right. As the linker iterates through the binaries, it will do the
    following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 解决未定义符号的方式是这样的——链接器从左到右处理二进制文件。当链接器遍历二进制文件时，它将执行以下操作：
- en: Collect all undefined symbols exported from this binary and store them for later
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集此二进制文件导出的所有未定义符号并将它们存储以供以后使用
- en: Try to resolve undefined symbols (collected from all binaries processed so far)
    with symbols defined in this binary
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用此二进制文件中定义的符号解决未定义符号（从迄今为止处理的所有二进制文件中收集）
- en: Repeat this process for the next binary
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对下一个二进制文件重复此过程
- en: If any symbols remain undefined after the whole operation is completed, the
    linking fails.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在整个操作完成后还有任何符号未定义，链接失败。
- en: 'This is the case in our example (CMake puts the *object files* of the executable
    target before the libraries):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例中的情况（CMake将在可执行目标的对象文件之前放置库）：
- en: We processed `main.o`, got an undefined reference to `a`, and collected it for
    future resolution.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理了`main.o`，发现了一个对`a`的未定义引用，并将其收集以供以后解决。
- en: We processed `libnested.a`, no undefined references were found, so there was
    nothing to resolve.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理了`libnested.a`，没有发现未定义的引用，所以没有什么需要解决的。
- en: We processed `libouter.a`, got an undefined reference to `b`, and resolved a
    reference to `a`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理了`libouter.a`，发现了一个对`b`的未定义引用，并解决了`a`的引用。
- en: 'We did correctly resolve the reference to the `a` variable, but not for `b`.
    All we need to do is reverse the order of linking so that `nested` comes after
    `outer`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正确地解决了`a`变量的引用，但不是`b`。我们只需要将链接顺序颠倒，以便`nested`在`outer`之后：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another less elegant option is to repeat the library (which is useful for cyclic
    references):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不太优雅的选项是重复库（这对于循环引用很有用）：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we can try using linker-specific flags such as `--start-group` or `--end-group`.
    Go to the documentation of your linker for details, as these specifics are outside
    of the scope of this book.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以尝试使用链接器特定的标志，如`--start-group`或`--end-group`。查看您链接器的文档，因为这些具体内容超出了本书的范围。
- en: Now that we know how to solve common problems, let's talk about how we could
    use the linker to our advantage.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何解决常见问题，那么让我们谈谈如何利用链接器的好处。
- en: Separating main() for testing
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为测试分离main()
- en: As we established so far, a linker enforces the ODR and makes sure that all
    external symbols provide their definitions in the process of linking. One interesting
    problem that we might encounter is the correct testing of the build.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们迄今为止所建立的，链接器强制执行ODR，并确保在链接过程中所有外部符号提供它们的定义。我们可能会遇到的一个有趣的问题是正确地进行构建测试。
- en: Ideally, we should test exactly the same source code that is being run in production.
    An exhaustive testing pipeline should build the source code, run its tests on
    produced binary, and only then package and distribute the executable (without
    the tests themselves).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该测试与生产中运行的完全相同的源代码。一个彻底的测试管道应该构建源代码，在生成的二进制文件上运行其测试，然后才打包和分发可执行文件（不包括测试本身）。
- en: But how do we actually make this happen? Executables have a very specific flow
    of execution, which often requires reading command-line arguments. C++'s compiled
    nature doesn't really support pluggable units that can be temporarily injected
    into the binary for test purposes only. It seems like we'll need a very complex
    approach to solve this.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们实际上是如何实现这一点的呢？可执行文件有非常具体的执行流程，这通常需要阅读命令行参数。C++的编译性质实际上并不支持可以仅用于测试目的而临时注入到二进制文件中的可插拔单元。这似乎需要一个相当复杂的解决方案。
- en: 'Luckily, we can use a linker to help us deal with this in an elegant manner.
    Consider extracting all logic from your program''s `main()` to an external function,
    `start_program()`, like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用链接器以优雅的方式帮助我们处理这个问题。考虑将您程序的`main()`中的所有逻辑提取到一个外部函数`start_program()`中，如下所示：
- en: chapter06/07-testing/main.cpp
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/07-testing/main.cpp
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s reasonable to skip testing this new `main()` function now; it is only
    forwarding arguments to a function defined elsewhere (in another file). We can
    then create a library containing the original source from `main()` wrapped in
    a new function – `start_program()`. In this example, I''m going to use a simple
    program to check whether the command-line argument count is higher than `1`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在跳过测试这个新的`main()`函数是合理的；它只是将参数传递给定义在其他地方（在另一个文件中）的函数。然后我们可以创建一个库，其中包含从`main()`原始源代码包装在一个新函数中的内容——`start_program()`。在这个示例中，我将使用一个简单的程序来检查命令行参数的数量是否大于`1`：
- en: chapter06/07-testing/program.cpp
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/07-testing/program.cpp
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can now prepare a project that builds this application and links together
    those two translation units:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以准备一个项目，用于构建这个应用程序并将这两个翻译单元链接在一起：
- en: chapter06/07-testing/CMakeLists.cpp
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/07-testing/CMakeLists.cpp
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `main` target is just providing the required `main()` function. It's the
    `program` target that contains all the logic. We can now test it by creating another
    executable with its own `main()` containing the test logic.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`目标只是提供了所需的`main()`函数。`program`目标包含了所有的逻辑。现在我们可以通过创建另一个包含其自己的`main()`和测试逻辑的可执行文件来测试它。'
- en: 'In a real-world scenario, frameworks such as `main()` method that can be used
    to replace your program''s entry point and run all the defined tests. We''ll dive
    deep into the subject of actual testing in [*Chapter 8*](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179),
    *Testing Frameworks*. For now, let''s focus on the general principle and write
    our own tests in another `main()` function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，像`main()`方法这样的框架可以用来替换程序的入口点并运行所有定义的测试。我们将在[第8章](B17205_08_Final_JC_ePub.xhtml#_idTextAnchor179)深入研究实际的测试主题，*测试框架*。现在，让我们关注通用原则，并在另一个`main()`函数中编写我们自己的测试：
- en: chapter06/07-testing/test.cpp
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: chapter06/07-testing/test.cpp
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code will call `start_program` twice, with and without arguments,
    and check whether the returned exit codes are correct. This unit test leaves much
    to be desired in terms of clean code and elegant testing practices, but at least
    it''s a start. The important thing is that we have now defined `main()` twice:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将两次调用`start_program`，带参数和不带参数，并检查返回的退出码是否正确。这个单元测试在代码整洁和优雅的测试实践方面还有很多不足，但至少它是一个开始。重要的是，我们现在定义了两次`main()`：
- en: In `main.cpp` for production use
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生产环境的`main.cpp`
- en: In `test.cpp` for test purposes
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测试目的的`test.cpp`
- en: 'We''ll add the second executable to the bottom of our `CMakeLists.txt` now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`CMakeLists.txt`的底部添加第二个可执行文件：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This creates another target, which is linked against the exact same binary code
    as the production, but it grants us the freedom to call all exported functions
    however we like. Thanks to this, we can run all code paths automatically and check
    whether they work as expected. Great!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了另一个目标，它与生产中的完全相同的二进制代码链接，但它允许我们以任何喜欢的方式调用所有导出的函数。得益于这一点，我们可以自动运行所有代码路径，并检查它们是否如预期般工作。太好了！
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Linking in CMake does seem simple and insignificant, but in reality, there's
    much more to it than meets the eye. After all, linking executables isn't as simple
    as putting puzzle pieces together. As we learned about the structure of *object
    files* and libraries, we discovered that things need to move around a bit before
    a program is runnable. These things are called sections and they have distinct
    roles in the life cycle of the program – store different kinds of data, instructions,
    symbol names, and so on. A linker needs to combine them together in the final
    binary accordingly. This process is called relocation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中的链接似乎很简单，微不足道，但实际上，它的内容远比表面上看到的要多。毕竟，链接可执行文件并不是像拼图一样简单地组合在一起。正如我们学习了关于*对象文件*和库的结构，我们发现程序在运行前需要移动一些东西。这些被称为节，它们在程序的生命周期中扮演着不同的角色——存储不同类型的数据、指令、符号名等。链接器需要根据最终二进制文件的要求将它们组合在一起。这个过程被称为重定位。
- en: We also need to take care of symbols – resolve references across all the translation
    units and make sure that nothing's missing. Then, a linker can create the program
    header and add it to the final executable. It will contain instructions for the
    system loader, describing how to turn consolidated sections into segments that
    make up the runtime memory image of the process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要注意符号的处理——在所有翻译单元之间解决引用，确保不遗漏任何内容。然后，链接器可以创建程序头部并将其添加到最终的可执行文件中。它将包含系统加载器的指令，描述如何将合并的段转换为组成进程运行时内存映像的段。
- en: We also discussed three different kinds of libraries (static, shared, and shared
    modules), and we explained how they differ and which scenarios fit some better
    than others. We also touched on the subject of PIC – a powerful concept that allows
    for the lazy binding of symbols.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了三种不同类型的库（静态库、共享库和共享模块），并解释了它们之间的区别以及哪些场景适合某些库。我们还涉及了PIC的概念——一个允许延迟绑定符号的强大概念。
- en: The ODR is a C++ concept, but as we already know, it's heavily enforced by linkers.
    After introducing this subject, we briefly explored how to deal with the most
    basic symbol duplication, in both static and dynamic libraries. This was followed
    by some short advice to use namespaces wherever possible and not to rely on a
    linker too much when it comes to preventing symbol collisions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ODR是一个C++概念，但我们已经知道，链接器对其进行了严格的实施。在介绍了这个主题之后，我们简要探讨了如何在静态和动态库中处理最基本的符号重复。这之后是一些建议，尽可能使用命名空间，并不要过分依赖链接器来防止符号冲突。
- en: For such a seemingly straightforward step (CMake offers only a few commands
    dedicated to a linker), it sure has a lot of quirks! One tricky thing to get right
    is the order of linking, especially when libraries have nested dependencies. We
    now know how to handle some basic situations and what other methods we could research
    to deal with more complex ones.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个看似简单的步骤（CMake只提供了一些与链接器相关的命令），确实有很多古怪之处！其中一个难以掌握的是链接顺序，尤其是在库有嵌套依赖时。我们现在知道如何处理一些基本情况，以及我们可以研究哪些其他方法来处理更复杂的情况。
- en: Lastly, we investigated how to take advantage of a linker to prepare our program
    for testing – by separating the `main()` function into another translation unit.
    This enabled us to introduce another executable, which ran tests against the exact
    same machine code that will be run in production.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何利用链接器为我们的程序准备测试——将`main()`函数分离到另一个翻译单元中。这使我们能够引入另一个可执行文件，它运行的测试针对的是将在生产中运行的完全相同的机器代码。
- en: Now that we know how to link, we can retrieve external libraries and use them
    in our CMake projects. In the next chapter, we'll study how to manage dependencies
    in CMake.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何链接，我们可以检索外部库并将其用于我们的CMake项目中。在下一章中，我们将学习如何在CMake中管理依赖关系。
- en: Further reading
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题，你可以参考以下内容：
- en: '*The structure of ELF files:*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ELF文件的结构：**'
- en: '[https://en.wikipedia.org/wiki/Executable_and_Linkable_Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format
    )'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[可执行文件与链接格式](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)'
- en: '*The CMake manual for* `add_library()`:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`add_library()`的CMake手册：
- en: '[https://cmake.org/cmake/help/latest/command/add_library.html](https://cmake.org/cmake/help/latest/command/add_library.html)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[CMake的add_library命令](https://cmake.org/cmake/help/latest/command/add_library.html)'
- en: '*Dependency hell:*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖地狱：**'
- en: '[https://en.wikipedia.org/wiki/Dependency_hell](https://en.wikipedia.org/wiki/Dependency_hell
    )'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[依赖地狱](https://en.wikipedia.org/wiki/Dependency_hell)'
- en: '*The differences between modules and shared libraries:*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块与共享库的区别：**'
- en: '[https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries](https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[模块与共享库的区别](https://stackoverflow.com/questions/4845984/difference-between-modules-and-shared-libraries)'
