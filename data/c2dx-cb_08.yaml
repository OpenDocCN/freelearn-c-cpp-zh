- en: Chapter 8. Working with Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 与硬件协同工作
- en: 'The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using native code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生代码
- en: Change the processing using the platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台更改处理
- en: Using the acceleration sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度传感器
- en: Keeping the screen on
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持屏幕开启
- en: Getting dpi
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 dpi
- en: Getting the maximum texture size
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取最大纹理大小
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Cocos2d-x has a lot of APIs. However, there are no APIs that we need, for example,
    In-App purchase, push notification, and so on. In this case, we have to create
    original APIs and need to write Objective-C code for iOS or Java code for Android.
    In addition, we want to get the device information that it is running on. When
    we want to adjust for each device, we have to get the device information such
    as the running application version, device name, dpi on device, and so on. However,
    doing so is very difficult and confusing. In this chapter, you can write the native
    code for iOS or Android and get the device information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有很多 API。然而，我们没有需要的 API，例如，内购、推送通知等。在这种情况下，我们必须创建原始 API，并且需要为 iOS 编写
    Objective-C 代码或为 Android 编写 Java 代码。此外，我们希望获取正在运行的设备信息。当我们想要为每个设备进行调整时，我们必须获取设备信息，例如运行的应用程序版本、设备名称、设备上的
    dpi 等。然而，这样做非常困难且令人困惑。在本章中，你可以为 iOS 或 Android 编写原生代码并获取设备信息。
- en: Using native code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原生代码
- en: In Cocos2d-x, you can write one source for the cross platform. However, you
    have to write an Objective-C function or a Java function for the dependency process
    such as a purchase or push notification. If you want to call Java for Android
    from C++, you have to use **JNI** (**Java Native Interface**). In particular,
    JNI is very confusing. To call Java from C++, you have to use JNI. In this recipe,
    we will explain how to call an Objective-C function or a Java function from C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 中，你可以为跨平台编写一个源文件。然而，你必须为依赖过程（如购买或推送通知）编写 Objective-C 函数或 Java 函数。如果你想从
    C++ 调用 Java（Android），你必须使用 **JNI**（**Java 原生接口**）。特别是，JNI 非常复杂。要从 C++ 调用 Java，你必须使用
    JNI。在本食谱中，我们将解释如何从 C++ 调用 Objective-C 函数或 Java 函数。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this case, we will make a new class called `Platform`. You can get the application
    version by using this class. Before writing code, you will make three files called
    **Platform.h**, **Platform.mm**, and **Platform.cpp** in your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建一个新的类，名为 `Platform`。你可以通过这个类来获取应用程序的版本。在编写代码之前，你需要在你的项目中创建三个文件，分别命名为
    **Platform.h**、**Platform.mm** 和 **Platform.cpp**。
- en: '![Getting ready](img/B0561_08_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B0561_08_01.jpg)'
- en: It is important that you don't add `Platform.cpp` to **Compile Sources** in
    Xcode. That's why `Platform.cpp` is for an Android target and doesn't need to
    be built for iOS. If you added it to **Compile Sources**, you have to remove it
    from there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，你很重要的一点是不要将 `Platform.cpp` 添加到 **编译源文件** 中。这就是为什么 `Platform.cpp` 是为
    Android 目标而设计的，并且不需要为 iOS 构建的原因。如果你将其添加到 **编译源文件** 中，你必须从那里将其删除。
- en: '![Getting ready](img/B0561_08_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/B0561_08_02.jpg)'
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Firstly, you have to make a header file called `Platform.h` by using the following
    code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须使用以下代码创建一个头文件，名为 `Platform.h`：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You have to make an execution file called `Platform.mm` for iOS. This code is
    in Objective-C.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须为 iOS 创建一个名为 `Platform.mm` 的执行文件。此代码是用 Objective-C 编写的。
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You have to make an execution file called `Platform.cpp` for Android. The following
    code is in C++ and uses Java through JNI:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须为 Android 创建一个名为 `Platform.cpp` 的执行文件。以下代码是用 C++ 编写的，并通过 JNI 使用 Java：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You have to edit `proj.android/jni/Android.mk` to build for Android when you
    added a new class file in your project.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在项目中添加新的类文件时，你必须编辑 `proj.android/jni/Android.mk` 以构建 Android。
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, you have to write Java code in `AppActivity.java`. This file is named
    `pro.android/src/org/cocos2dx/cpp/AppActivity.java`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你必须编写 `AppActivity.java` 中的 Java 代码。此文件名为 `pro.android/src/org/cocos2dx/cpp/AppActivity.java`。
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, you can get a version of your game by using the following code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以通过以下代码获取你游戏的版本：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, we will look at it for iOS. You will be able to get a version of your
    game by using Objective-C in `Platform.mm`. You can write C++ and Objective-C
    in the `.mm` files.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从 iOS 开始。你将能够通过在 `Platform.mm` 中使用 Objective-C 来获取你游戏的版本。你可以在 `.mm` 文件中编写
    C++ 和 Objective-C。
- en: Next, we will look for Android. When you call `Platform::getAppversion` on Android
    devices, the method in `Platform.cpp` is executed. In this method, you can call
    the `getAppVersionInJava` method in `AppActivity.java`. by using JNI. C++ can
    connect Java via JNI. That's why you can only get the application version by using
    Java.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将寻找 Android。当您在 Android 设备上调用 `Platform::getAppversion` 时，将执行 `Platform.cpp`
    中的方法。在这个方法中，您可以通过 JNI 调用 `AppActivity.java` 中的 `getAppVersionInJava` 方法。C++ 可以通过
    JNI 连接到 Java。这就是为什么您只能通过 Java 来获取应用程序版本的原因。
- en: In Java, you can get the version of your application by using the `onCreate`
    method. You can set it to a static variable and then, get it from the `getAppVersionInJava`
    method in Java.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 中，您可以通过使用 `onCreate` 方法来获取您应用程序的版本。您可以将其设置为静态变量，然后从 Java 中的 `getAppVersionInJava`
    方法中获取它。
- en: There's more…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can use JNI easily by using the `JniHelper` class in Cocos2d-x. How this
    class manages typos from C++ and creates a bridge between C++ and Java has already
    been explained. You can use the `JniHelper` class by using the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 Cocos2d-x 中使用 `JniHelper` 类轻松地使用 JNI。这个类如何从 C++ 中管理错误并创建 C++ 和 Java 之间的桥梁已经解释过了。您可以通过以下代码使用
    `JniHelper` 类：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can get the information about the Java method by using `JniHelper::getStaticMethodInfo`.
    The first argument is a variable of `JniMethodInfo`. The second argument is the
    name of the class that has the method you want to call. The third argument is
    the method name. The last argument is the parameter of this method. This parameter
    is decided by the return value and the arguments. The characters in the bracket
    are the parameters for the Java method. In this case, this method has no parameters.
    The characters after the bracket are the return value. `Ljava/lang/String` means
    that the return value is a string. If you get this parameter easily, you should
    use the command called `javap`. As the following result will be generated by using
    this command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `JniHelper::getStaticMethodInfo` 来获取 Java 方法的信息。第一个参数是 `JniMethodInfo`
    类型的变量。第二个参数是包含您要调用的方法的类的名称。第三个参数是方法名称。最后一个参数是此方法的参数。此参数由返回值和参数决定。括号中的字符是 Java
    方法的参数。在这种情况下，此方法没有参数。括号后面的字符是返回值。`Ljava/lang/String` 表示返回值是一个字符串。如果您可以轻松地获取此参数，则应使用名为
    `javap` 的命令。使用此命令将生成以下结果。
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From the above result, you can see that the parameter for the `getAppVersionInJava`
    method is `()Ljava/lang/String`;
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述结果中，您可以看到 `getAppVersionInJava` 方法的参数为 `()Ljava/lang/String`;
- en: 'As mentioned earlier, you can get the information of the Java method as a `t`
    variable. So, you can call the Java method by using this variable and the following
    code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以将 Java 方法的信息作为 `t` 变量获取。因此，您可以通过这个变量和以下代码来调用 Java 方法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changing the processing using the platform
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台更改处理方式
- en: You can make the program run on specific parts of the source code for each OS.
    For example, you will change the file name, the file path, or the image scale
    by the platform. In this recipe, we will introduce the branching code based on
    the platform of choice in the case of a complication.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使程序在每种操作系统的源代码的特定部分运行。例如，您将根据平台更改文件名、文件路径或图像缩放。在这个菜谱中，我们将介绍在出现问题时根据所选平台进行分支代码的情况。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can change the processing by using the preprocessor as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式使用预处理器来更改处理方式：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cocos2d-x defined the `CC_TARGET_PLATFORM` value in `CCPlatformConfig.h`. If
    your game is compiled for Android devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_ANDROID`.
    If it is compiled for iOS devices, `CC_TARGET_PLATFORM` is equal to `CC_PLATFORM_IOS`.
    Needless to say, there are other values besides Android and iOS. Please check
    `CCPlatformConfig.h`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 在 `CCPlatformConfig.h` 中定义了 `CC_TARGET_PLATFORM` 值。如果您的游戏是为 Android
    设备编译的，则 `CC_TARGET_PLATFORM` 等于 `CC_PLATFORM_ANDROID`。如果它是为 iOS 设备编译的，则 `CC_TARGET_PLATFORM`
    等于 `CC_PLATFORM_IOS`。不用说，除了 Android 和 iOS 之外，还有其他值。请检查 `CCPlatformConfig.h`。
- en: There's more…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The code that was used in the preprocessor is difficult to read on an editor.
    Further, you cannot notice the error before compiling your code. You should define
    a constant value that can be changed by the preprocessor, but you should change
    the processing by using code as much as possible. You can check the platform by
    using the `Application` class in Cocos2d-x as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理器中使用的代码在编辑器上难以阅读。此外，在编译您的代码之前，您可能无法注意到错误。您应该定义一个可以由预处理器更改的常量值，但您应该尽可能多地使用代码来更改处理方式。您可以使用
    Cocos2d-x 中的 `Application` 类来检查平台，如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can get the value of the platform by using the `Application::getTargetPlatform`
    method. You will be able to check, not just for iPhone or iPad, but also IOS by
    using this method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Application::getTargetPlatform`方法获取平台值。你将能够检查，不仅仅是iPhone或iPad，还可以通过此方法检查IOS。
- en: Using the acceleration sensor
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度传感器
- en: By using an acceleration sensor on the device, we can make the game more engrossing,
    by using operations such as shaking and tilting the device. For example, move
    the ball by tilting the screen, the maze game that aims at the goal, and the skinny
    panda trying to go on a diet, wherein the players shake the device to play the
    game. You can get the tilt value and the moving speed of the device by using the
    accelerometer. If you can use it, your game becomes more unique. In this recipe,
    we learn how to use the acceleration sensor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设备上使用加速度传感器，我们可以通过使用摇动和倾斜设备等操作使游戏更加吸引人。例如，通过倾斜屏幕移动球，瞄准目标的迷宫游戏，以及试图减肥的瘦熊猫，在这些游戏中玩家需要摇动设备来玩游戏。你可以通过加速度传感器获取设备的倾斜值和移动速度。如果你能使用它，你的游戏就会更加独特。在这个菜谱中，我们学习如何使用加速度传感器。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can get the x, y, and z axis values from the acceleration sensor by using
    the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下代码从加速度传感器获取x、y和z轴的值：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, you enable the acceleration sensor by using the `Device::setAccelerometerEnable`
    method. The methods in the `Device` class are static methods. So, you can directly
    call a method without an instance like this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你通过使用`Device::setAccelerometerEnable`方法启用加速度传感器。`Device`类中的方法是静态方法。因此，你可以直接调用方法，而不需要实例，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You set the event listener for getting the value from the acceleration sensor.
    In this case, you can get these values by using the lambda function.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你为获取加速度传感器的值设置事件监听器。在这种情况下，你可以通过lambda函数获取这些值。
- en: Finally, you set the event listener in the event dispatcher.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你在事件分发器中设置事件监听器。
- en: You can get the value of the x, y, and z axes from the acceleration sensor,
    if you run this code on the real device. The x axis is the left and the right
    of the slope. The y axis is before and after of the slope. The z axis is the vertical
    motion.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在这台真实设备上运行此代码，你可以从加速度传感器获取x、y和z轴的值。x轴是斜坡的左右。y轴是斜坡的前后。z轴是垂直运动。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The acceleration sensor uses more battery power. When you use it, you set an
    appropriate interval for when the event occurred. The following code sets the
    interval as one second.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度传感器会消耗更多的电量。当你使用它时，你为事件发生设置一个适当的间隔。以下代码将间隔设置为1秒。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the interval is higher, we might miss some tilt inputs. However, if we use
    a low interval, we will drain a lot of battery.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果间隔较高，我们可能会错过一些倾斜输入。然而，如果我们使用较低的间隔，我们会消耗大量的电量。
- en: Keeping the screen on
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持屏幕开启
- en: You have to keep the device from entering into the sleep mode while playing
    your game. For example, in your game, the player can control the game and keep
    the game going by using the accelerometer. The problem is that if the player does
    not touch the screen while playing with the accelerometer, the device goes to
    sleep and enters background mode. In this recipe, you can keep the screen on easily.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，你必须确保设备不会进入睡眠模式。例如，在你的游戏中，玩家可以通过使用加速度传感器来控制游戏并保持游戏进行。问题是，如果玩家在用加速度传感器玩游戏时不触摸屏幕，设备就会进入睡眠模式并进入后台模式。在这个菜谱中，你可以轻松地保持屏幕开启。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can keep the screen on if you set it to `true` by using the `Device::setKeepScreenOn`
    method as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`Device::setKeepScreenOn`方法将其设置为`true`，你可以保持屏幕开启：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There is a different way for each platform to prevent a device from entering
    the sleep mode. However, Cocos2d-x can do it for every platform. You can use this
    method without executing a platform. In the iOS platform, the `setKeepScreenOn`
    method is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有不同的方法来防止设备进入睡眠模式。然而，Cocos2d-x可以为每个平台做到这一点。你可以使用这种方法而不需要执行平台。在iOS平台上，`setKeepScreenOn`方法如下：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the Android platform, the method is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上，方法如下：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Getting dpi
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取dpi
- en: There are a lot of **dpi** (**dots per inch**) variations for each device. You
    can prepare several kinds of images by resolution. You might want to change an
    image by the dpi running on the device. In this recipe, if you would like to get
    the dpi that your game is running on, you need to use the Cocos2d-x function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都有许多**dpi**（每英寸点数）的变化。您可以通过分辨率准备几种不同类型的图像。您可能想要根据设备上的dpi更改图像。在这个菜谱中，如果您想获取游戏正在运行的dpi，您需要使用Cocos2d-x函数。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can get dpi of the device game is executing on, by using the `Device::getDPI`
    method as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`Device::getDPI`方法来获取设备正在执行游戏时的dpi（每英寸点数），如下所示：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In fact, we checked the dpi of some devices. To use the dpi information, you
    can further adjust the multiscreen resolution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们检查了一些设备的dpi。为了使用dpi信息，您可以进一步调整多屏幕分辨率。
- en: '| Device | Dpi |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | Dpi |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| iPhone 6 Plus | 489 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 6 Plus | 489 |'
- en: '| iPhone 6 | 326 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 6 | 326 |'
- en: '| iPhone 5s | 326 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 5s | 326 |'
- en: '| iPhone 4s | 326 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 4s | 326 |'
- en: '| iPad Air | 264 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| iPad Air | 264 |'
- en: '| iPad 2 | 132 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| iPad 2 | 132 |'
- en: '| Nexus 5 | 480 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| Nexus 5 | 480 |'
- en: Getting the maximum texture size
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取最大纹理大小
- en: The maximum texture size that can be used is different for each device. In particular,
    when you use the texture atlas, you should be careful. That's why a texture atlas
    that has a lot of images is too large in size. You can't use a texture that is
    over the maximum size. If you use it, your game will crash. In this recipe, you
    can get the maximum texture size.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可使用的最大纹理大小因设备而异。特别是，当您使用纹理图集时，应该小心。这就是为什么包含大量图像的纹理图集体积会变得很大。您不能使用超过最大尺寸的纹理。如果您使用它，您的游戏将会崩溃。在这个菜谱中，您可以获取最大纹理大小。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can get the max texture size easily by using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下代码轻松获取最大纹理大小：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Configuration class is a singleton class. This class has some OpenGL variables.
    OpenGL is a multiplatform API for rendering 2D and 3D vector graphics. It is pretty
    difficult to use. Cocos2d-x wraps it and makes it easy to use. OpenGL has a lot
    of information for graphics. The max texture size is one of the variables providing
    this information. You can get the max texture size of the device that your application
    is running on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configuration`类是一个单例类。这个类有一些OpenGL变量。OpenGL是一个用于渲染2D和3D矢量图形的多平台API。它使用起来相当困难。Cocos2d-x将其封装起来，使其易于使用。OpenGL有很多关于图形的信息。最大纹理大小是提供这些信息的一个变量。您可以得到您应用程序正在运行的设备的最大纹理大小。'
- en: There's more…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can get other OpenGL variables. If you want to check the variables that
    `Configuration` has, you will use the `Configuration::getInfo` method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取其他OpenGL变量。如果您想检查`Configuration`拥有的变量，您将使用`Configuration::getInfo`方法。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result of the log on iPhone 6 Plus:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 6 Plus上的日志结果：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you get each variable, and you check the source code of the `Configuration`
    class, you can understand them easily.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您获取每个变量，并检查`Configuration`类的源代码，您可以轻松理解它们。
