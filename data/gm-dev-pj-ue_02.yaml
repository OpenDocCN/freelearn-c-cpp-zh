- en: 2\. Working with Unreal Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 使用虚幻引擎
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will focus on many of the basic concepts and features within Unreal
    Engine. You will be shown how to create a C++ project, how to perform some basic
    debugging, and how to work with character-specific animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍虚幻引擎中许多基本概念和特性。您将学习如何创建C++项目，如何进行一些基本调试，以及如何处理特定角色的动画。
- en: By the end of this chapter, you'll be able to create C++ template projects,
    be able to debug code within Visual Studio, understand the folder structure and
    the best practices involved, and finally, be able to set up character animations
    based on their states.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够创建C++模板项目，能够在Visual Studio中调试代码，了解文件夹结构和相关的最佳实践，并最终能够根据状态设置角色动画。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we went through the basics of the Epic Games Launcher,
    along with Unreal Editor fundamentals. We saw how to work with Objects and what
    Blueprints are on a basic level, in addition to exploring the First Person Template.
    In this chapter, we'll be building upon those fundamentals by exploring the Third
    Person Template and working with Input and Animations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Epic Games Launcher的基础知识，以及虚幻编辑器的基本原理。我们了解了如何处理对象以及基本级别上的蓝图，还探索了第一人称模板。在本章中，我们将通过探索第三人称模板和处理输入和动画来进一步建立这些基础知识。
- en: Game development can be done in a wide variety of languages, such as C, C++,
    Java, C#, and even Python. While each language has pros and cons, we will be using
    C++ throughout this book as it is the primary programming language used within
    the Unreal Engine.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发可以使用多种语言，如C、C++、Java、C#，甚至Python。虽然每种语言都有优缺点，但在本书中我们将使用C++，因为它是虚幻引擎中主要使用的编程语言。
- en: In this chapter, we will get you up to speed on how to create a C++ project
    and basic level debugging in UE4\. It is very important to be able to debug code
    as it helps the developer while dealing with bugs. The tools provided come in
    very handy and are essential for any Unreal Engine developer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带您快速了解如何在UE4中创建C++项目和基本级别的调试。调试代码非常重要，因为它有助于开发人员处理错误。提供的工具非常方便，对于任何虚幻引擎开发人员都是必不可少的。
- en: Following this, we will get up close and personal with the core classes involved
    in creating games and experiences in Unreal Engine. You will explore Game Mode
    and the relevant class concepts, followed by an exercise to gain a hands-on understanding
    of this.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解在虚幻引擎中创建游戏和体验所涉及的核心类。您将探索游戏模式和相关的类概念，然后进行一项练习，以获得对此的实际理解。
- en: The final section in this chapter is all about animations. Almost every single
    game features animations, some to a very basic extent, but some to a very high
    level that includes captivating details which are key to the gameplaying experience.
    Unreal Engine offers several tools you can use to create and deal with animations,
    including the Animation Blueprint, which has complex graphs and a State Machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分是关于动画的。几乎每个游戏都包含动画，有些只是非常基本的，但有些则达到了非常高的水平，包括引人入胜的细节，这些细节对游戏体验至关重要。虚幻引擎提供了几种工具，您可以使用这些工具来创建和处理动画，包括具有复杂图表和状态机的动画蓝图。
- en: Creating and Setting Up a Blank C++ Project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和设置空白C++项目
- en: At the start of every project, you might want to start with any of the templates
    provided by Epic (which contain ready-to-execute basic code) and build on top
    of that. Most/some of the time, you might need to set up a blank or an empty project
    that you can mold and sculpt to your requirements. We'll learn how to do that
    in the following exercise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个项目开始时，您可能希望从Epic提供的模板中选择任何一个（其中包含准备执行的基本代码）并在此基础上进行开发。大部分/有时候，您可能需要设置一个空白项目，以便根据自己的需求进行开发。我们将在接下来的练习中学习如何做到这一点。
- en: 'Exercise 2.01: Creating an Empty C++ Project'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建一个空白的C++项目
- en: In this exercise, you will learn how to create an empty C++ project from the
    template provided by Epic. This will serve as the foundation for many of your
    future C++ projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将学习如何从Epic提供的模板中创建一个空白的C++项目。这将成为您未来许多C++项目的基础。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Launch Unreal Engine 4.24 from the Epic Games Launcher.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Epic Games Launcher启动虚幻引擎4.24。
- en: Click on the `Games` section and click `Next`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“游戏”部分，然后点击“下一步”。
- en: Make sure the `Blank` project template is selected and click `Next`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择“空白”项目模板，然后点击“下一步”。
- en: Click the `Blueprint` section dropdown and select `C++`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“蓝图”部分下拉菜单，选择“C++”。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure the project folder and project name are specified with an appropriate
    directory and name, respectively.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 确保项目文件夹和项目名称分别指定了适当的目录和名称。
- en: When everything is set up, click on the `Create Project` button. In this case,
    our project directory is inside a folder called `UnrealProjects`, which is inside
    the `E` drive. The project name is set to `MyBlankProj` (it is recommended that
    you follow these names and project directories, but you can use your own if you
    wish to do so).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好一切后，点击“创建项目”按钮。在本例中，我们的项目目录位于一个名为“UnrealProjects”的文件夹中，该文件夹位于E驱动器内。项目名称设置为“MyBlankProj”（建议您遵循这些名称和项目目录，但如果您愿意，也可以使用自己的名称）。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The project name cannot have any spaces in it. It is preferable to have an Unreal
    directory as close to the root of a drive as possible (to avoid running into issues
    such as the 256-character path limit when creating or importing assets into your
    project's working directory; for small projects, it may be fine, but for more
    large-scale projects, where the folder hierarchy may become too complex, this
    step is important).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称不能包含任何空格。最好将虚幻目录放在驱动器的根目录附近（以避免在创建或导入资产到项目工作目录时遇到256字符路径限制等问题；对于小型项目，可能没问题，但对于更大规模的项目，文件夹层次可能会变得过于复杂，这一步很重要）。
- en: You will notice that after it's done generating code and creating the project
    files, the project will be opened, along with its Visual Studio solution (`.sln`)
    file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在生成代码并创建项目文件后，项目将被打开，并附带其Visual Studio解决方案（.sln）文件。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Make sure the Visual Studio solution configuration is set to Development Editor
    and that the solution platform is set to Win64 for Desktop development:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Visual Studio解决方案配置设置为Development Editor，并且解决方案平台设置为Win64以进行桌面开发：
- en: '![Figure 2.1: Visual Studio deployment settings'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：Visual Studio部署设置'
- en: '](img/B16183_02_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_01.jpg)'
- en: 'Figure 2.1: Visual Studio deployment settings'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：Visual Studio部署设置
- en: By completing this exercise, we now know how to create an empty C++ project
    on UE4, along with its considerations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们现在知道如何在UE4上创建一个空的C++项目，以及其中的注意事项。
- en: In the next section, we'll be talking a bit about the folder structure, along
    with the most basic and most used folder structure format that's used by Unreal
    developers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要讨论文件夹结构，以及虚幻开发人员使用的最基本和最常用的文件夹结构格式。
- en: Content Folder Structure in Unreal Engine
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻引擎中的内容文件夹结构
- en: In your project directory (`E:/UnrealProjects/MyBlankProj` *in our case*), you
    will observe a `Content` folder. This is the primary folder that your project
    uses for different types of assets and project-relevant data (including Blueprints).
    The C++ code goes into the `Source` folder in your project. Please note that the
    best practice is to create new C++ code files directly through the Unreal Editor
    as this simplifies the process and results in fewer errors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目目录（`E:/UnrealProjects/MyBlankProj` *在我们的案例中*）中，您会看到一个`Content`文件夹。这是您的项目用于不同类型资产和项目相关数据（包括蓝图）的主要文件夹。C++代码放入项目的`Source`文件夹中。请注意，最佳做法是通过虚幻编辑器直接创建新的C++代码文件，因为这简化了流程并减少了错误。
- en: There are many different strategies you can use to organize the data inside
    your `Content` folder. The most basic and easy-to-understand is using folder names
    to depict the type of content inside. Therefore, a `Content` folder directory
    structure may resemble the example at [https://packt.live/3lCVFkR](https://packt.live/3lCVFkR).
    In this example, you can see that each file is categorically placed under the
    name of the folder representing its type on the first level, with the following
    levels further grouping it into meaningful folders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多不同的策略来组织`Content`文件夹中的数据。最基本和易于理解的是使用文件夹名称来表示其中的内容类型。因此，`Content`文件夹目录结构可能类似于[https://packt.live/3lCVFkR](https://packt.live/3lCVFkR)中的示例。在这个示例中，您可以看到每个文件都被分类地放在表示其类型的文件夹名称下的第一级，随后的级别进一步将其分组到有意义的文件夹中。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All blueprints should prefix `BP` in their name (to differentiate them from
    the default blueprints used by Unreal Engine). The rest of the prefixes are optional
    (however, it is best practice to format them with the prefixes shown earlier).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有蓝图的名称应以“BP”为前缀（以区分它们与虚幻引擎使用的默认蓝图）。其余前缀是可选的（但最好的做法是使用前面显示的前缀格式）。
- en: In the next section, we will be looking at the Visual Studio solution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下Visual Studio解决方案。
- en: Working with the Visual Studio Solution
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio解决方案
- en: Every C++ project in Unreal Engine has a Visual Studio solution. This, in turn,
    drives all the code and provides developers with the ability to set up execution
    logic and debug code in its running state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎中的每个C++项目都有一个Visual Studio解决方案。这反过来驱动了所有的代码，并为开发人员提供了在运行状态下设置执行逻辑和调试代码的能力。
- en: Solution Analysis
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案分析
- en: The Visual Studio solution (.`sln`) file that's produced inside the project
    directory contains the entire project and any associated code that's been added
    to it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 项目目录中生成的Visual Studio解决方案（.sln）文件包含了整个项目和任何添加到其中的相关代码。
- en: Let's have a look at the files present in Visual Studio. *Double-click* the
    .`sln` file to open it within Visual Studio.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Visual Studio中存在的文件。*双击* .sln文件在Visual Studio中打开它。
- en: In `Solution Explorer`, you will see two projects called `Engine` and `Games`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Solution Explorer`中，您将看到两个名为`Engine`和`Games`的项目。
- en: The Engine Project
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引擎项目
- en: At the base level, Unreal Engine itself is a Visual Studio project and has its
    own solution file. This contains all the code and third-party integrations that
    work together in Unreal Engine. All the code within this project is called the
    "source" code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，虚幻引擎本身就是一个Visual Studio项目，并有自己的解决方案文件。这包含了在虚幻引擎中共同工作的所有代码和第三方集成。该项目中的所有代码称为“源”代码。
- en: The Engine project consists of the external dependencies, configurations, plugins,
    shaders, and source code of Unreal Engine that are currently being used for this
    project. You can, at any time, browse the `UE4 -> Source` folder to view any of
    the engine code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎项目由当前用于该项目的虚幻引擎的外部依赖项、配置、插件、着色器和源代码组成。您可以随时浏览`UE4 -> Source`文件夹，查看任何引擎代码。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As Unreal Engine is open source, Epic allows developers to both view and edit
    source code to suit their needs and requirements. However, you cannot edit the
    source code in the version of Unreal Engine that''s installed via the Epic Games
    Launcher. To be able to make and build changes in source code, you need to download
    the source version of Unreal Engine, which can be found via GitHub. You can use
    the following guide to download the Source Version of the Unreal Engine: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚幻引擎是开源的，Epic允许开发人员查看和编辑源代码以满足其需求和要求。但是，您不能编辑通过Epic Games Launcher安装的虚幻引擎版本的源代码。要能够对源代码进行更改和构建，您需要下载虚幻引擎的源代码版本，可以在GitHub上找到。您可以使用以下指南下载虚幻引擎的源代码版本：[https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html)
- en: 'After downloading, you can also refer to the following guide for compiling/building
    the newly downloaded engine: [https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，您还可以参考以下指南来编译/构建新下载的引擎：[https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/Programming/Development/BuildingUnrealEngine/index.html)
- en: Game Project
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏项目
- en: 'Under the `Games` directory is the solution folder with the name of your project.
    Upon expansion, you''ll find a set of folders. You will be concerned with the
    following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Games`目录下是解决方案文件夹，名称为您的项目。展开后，您会找到一组文件夹。您将关注以下内容：
- en: '**Config Folder**: Carries all the configurations that have been set up for
    the project and the build (these can optionally have platform-specific (such as
    Windows, Android, iOS, Xbox, or PS) settings as well).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件夹**：包含为项目和构建设置的所有配置（这些可以选择性地具有特定平台（如Windows、Android、iOS、Xbox或PS）的设置）。'
- en: '**Plugins Folder**: This is an optional folder that''s created when you add
    any third-party plugin (downloaded from the Epic Marketplace or obtained through
    the internet). This folder will contain all of the source code of the plugins
    associated with this project.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件文件夹**：这是一个可选文件夹，当您添加任何第三方插件（从Epic Marketplace下载或通过互联网获取）时会创建。该文件夹将包含与该项目相关的所有插件的源代码。'
- en: '**Source Folder**: This is the primary folder we''re going to be working with.
    It will contain the Build Target files, as well as all the source code for the
    project. The following is a description of the default files in the source folder:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源文件夹**：这是我们将要使用的主要文件夹。它将包含构建目标文件，以及项目的所有源代码。以下是源文件夹中默认文件的描述：'
- en: '`.Target.cs` extension, and one build file that ends with `Build.cs`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Target.cs`扩展名，以及以`Build.cs`结尾的一个构建文件。'
- en: '**ProjectName code files (.cpp & .h)**: By default, these files are created
    for each project and contain the code that''s used to run the default game module
    code.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectName代码文件（.cpp和.h）**：默认情况下，为每个项目创建这些文件，并包含用于运行默认游戏模块代码的代码。'
- en: '**ProjectNameGameModeBase code files (.cpp & .h)**: By default, an empty Project
    Game Mode Base is created. It''s not usually used in most cases.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectNameGameModeBase代码文件（.cpp和.h）**：默认情况下，会创建一个空的项目游戏模式基类。在大多数情况下通常不会使用。'
- en: '**ProjectName.uproject file**: Contains the descriptors used to provide basic
    information about the project and the list of plugins associated with it.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProjectName.uproject文件**：包含用于提供有关项目的基本信息以及与之关联的插件列表的描述符。'
- en: Debugging Code in Visual Studio
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试代码
- en: Visual Studio provides powerful debugging features with the help of breakpoints
    in code. It enables users to pause the game at a particular line of code so that
    the developer can see the current values of variables and step through the code
    and game in a controlled fashion (can proceed line by line, function by function,
    or so on).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio提供了强大的调试功能，通过在代码中设置断点。它使用户能够在特定代码行暂停游戏，以便开发人员可以查看变量的当前值，并以受控的方式逐步执行代码和游戏（可以逐行进行，逐个函数进行等）。
- en: This is useful when you have a lot of variables and code files in your game
    project, and you want to see the values of the variables being updated and used
    in a step-by-step fashion to debug the code, find out what issues there are, and
    solve them. Debugging is a fundamental process of any developer's work, and only
    after many continuous debugging, profiling, and optimization cycles does a project
    get polished enough for deployment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的游戏项目中有大量变量和代码文件，并且希望以逐步方式查看变量的值被更新和使用以调试代码、找出问题并解决问题时，这将非常有用。调试是任何开发人员工作的基本过程，只有经过许多连续的调试、分析和优化周期，项目才能足够完善以进行部署。
- en: Now that you've got the basic idea of the Visual Studio solution, we'll move
    on and cover a practical exercise on it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对Visual Studio解决方案有了基本的了解，我们将继续并进行一个实际的练习。
- en: 'Exercise 2.02: Debugging the Third Person Template Code'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：调试第三人称模板代码
- en: In this exercise, you'll be creating a project using the Third Person Template
    of Unreal Engine and will debug the code from within Visual Studio. We'll be investigating
    the value of a variable called `BaseTurnRate` in the `Character` class of this
    template project. We'll see how the value updates as we move through the code,
    line by line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用虚幻引擎的第三人称模板创建一个项目，并将在Visual Studio中调试代码。我们将调查模板项目的`Character`类中名为`BaseTurnRate`的变量的值。我们将看到随着我们逐行移动代码，该值如何更新。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Launch Unreal Engine from the Epic Games Launcher.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Epic Games Launcher启动虚幻引擎。
- en: Click on the `Games` section and click `Next`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Games`部分，然后点击`下一步`。
- en: Select `Third Person` and click `Next`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Third Person`，然后点击`下一步`。
- en: Select C++, set the project name to `ThirdPersonDebug`, and click the `Create
    Project` button.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择C++，将项目名称设置为`ThirdPersonDebug`，然后点击`创建项目`按钮。
- en: 'Now, close Unreal Editor, go to the Visual Studio solution, and open the `ThirdPersonDebugCharacter.cpp`
    file:![Figure 2.2: ThirdPersonDebugCharacter.cpp file location'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭虚幻编辑器，转到Visual Studio解决方案，并打开`ThirdPersonDebugCharacter.cpp`文件：![图2.2：ThirdPersonDebugCharacter.cpp文件位置
- en: '](img/B16183_02_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_02.jpg)'
- en: 'Figure 2.2: ThirdPersonDebugCharacter.cpp file location'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：ThirdPersonDebugCharacter.cpp文件位置
- en: '*Left-click* on the bar on the left-hand side of line `18`. A red dot icon
    should appear on it (*you can toggle it off by clicking on it again*):![Figure
    2.3: Collision capsule init code'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*在第`18`行左侧的栏上。应该会出现一个红色的圆点图标（*您可以再次单击它将其关闭*）：![图2.3：碰撞胶囊初始化代码'
- en: '](img/B16183_02_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_03.jpg)'
- en: 'Figure 2.3: Collision capsule init code'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：碰撞胶囊初始化代码
- en: 'Here, we are getting the `capsule` component (explained further in *Chapter
    3*, *Character Class Components and Blueprint Setup*) of the character, which,
    by default, is the root component. Then, we are calling its `InitCapsuleSize`
    method, which takes in two parameters: the `InRadius` float and `InHalfHeight`
    float, respectively.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在获取角色的`capsule`组件（在*第3章*，*角色类组件和蓝图设置*中进一步解释），默认情况下是根组件。然后，我们调用它的`InitCapsuleSize`方法，该方法接受两个参数：`InRadius`浮点数和`InHalfHeight`浮点数。
- en: 'Make sure the solution configuration setting in VS is set to `Development Editor`
    and click on the `Local Windows Debugger` button:![Figure 2.4: Visual Studio build
    settings'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保VS中的解决方案配置设置为`开发编辑器`，然后点击`本地Windows调试器`按钮：![图2.4：Visual Studio构建设置
- en: '](img/B16183_02_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_04.jpg)'
- en: 'Figure 2.4: Visual Studio build settings'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：Visual Studio构建设置
- en: 'Wait until you''re able to see the following window in the bottom-left corner:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等到您能在左下角看到以下窗口为止：
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the window doesn't pop-up, you can open the window manually by opening `Autos`
    under `Debug` > `Windows` > `Autos`. Additionally, you may also use `locals`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果窗口没有弹出，您可以通过在`调试` > `窗口` > `自动`下手动打开窗口。此外，您也可以使用`本地`。
- en: '![Figure 2.5: Visual Studio variable watch window'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：Visual Studio变量监视窗口'
- en: '](img/B16183_02_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_05.jpg)'
- en: 'Figure 2.5: Visual Studio variable watch window'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Visual Studio变量监视窗口
- en: '`this` shows the object itself. The object contains variables and methods that
    it stores, and by expanding it, we''re able to see the state of the entire object
    and its variables at the current line of code execution.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`显示了对象本身。对象包含它存储的变量和方法，通过展开它，我们能够看到整个对象及其变量在当前代码执行行的状态。'
- en: Expand `this`, then `ACharacter`, and then `CapsuleComponent`. Here, you can
    see the values for the `CapsuleHalfHeight = 88.0` and `CapsuleRadius = 34.0` variables.
    Next to line `18`, where the red dot initially was, you will see an arrow. This
    means that the code is at the end of line `17` and has not executed line `18`
    yet.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`this`，然后展开`ACharacter`，然后展开`CapsuleComponent`。在这里，您可以看到`CapsuleHalfHeight
    = 88.0`和`CapsuleRadius = 34.0`变量的值。在初始的红点所在的第`18`行旁边，您会看到一个箭头。这意味着代码已经到达第`17`行的末尾，尚未执行第`18`行。
- en: 'Click the `Step Into` button to go to the next line of code (*Shortcut: F11*).
    `Step Into` will move into code inside the function (if present) on the line.
    On the other hand, `Step Over` will just execute the current code and move to
    the next line. Since there is no function on the current line, `Step Into` will
    mimic the `Step Over` functionality.![Figure 2.6: Debug step into'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`步进`按钮进入下一行代码（*快捷键：F11*）。`步进`将进入到该行内部的代码（如果存在）。另一方面，`步过`将只执行当前代码并移动到下一行。由于当前行上没有函数，`步进`将模仿`步过`功能。![图2.6：调试步进
- en: '](img/B16183_02_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_06.jpg)'
- en: 'Figure 2.6: Debug step into'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：调试步进
- en: 'Notice that the arrow has moved to line `21` and that the variables have been
    updated. `CapsuleHalfHeight = 96.0` and `CapsuleRadius = 42.0` are highlighted
    in red. Also, notice that the `BaseTurnRate` variable is initialized to  `0.0`:![Figure
    2.7: BaseTurnRate initial value'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，箭头已移动到第`21`行，并且变量已经更新。`CapsuleHalfHeight = 96.0`和`CapsuleRadius = 42.0`以红色突出显示。还要注意，`BaseTurnRate`变量初始化为`0.0`：![图2.7：BaseTurnRate初始值
- en: '](img/B16183_02_07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_07.jpg)'
- en: 'Figure 2.7: BaseTurnRate initial value'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：BaseTurnRate初始值
- en: 'Step in (*F11*) once again to go to line `22`. Now, the `BaseTurnRate` variable
    has a value of `45.0` and `BaseLookUpRate` is initialized to `0.0`, as shown in
    the following screenshot:![Figure 2.8: BaseTurnRate updated value'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下(*F11*)进入到第`22`行。现在，`BaseTurnRate`变量的值为`45.0`，`BaseLookUpRate`初始化为`0.0`，如下截图所示：![图2.8：BaseTurnRate更新的值
- en: '](img/B16183_02_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_08.jpg)'
- en: 'Figure 2.8: BaseTurnRate updated value'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：BaseTurnRate更新的值
- en: Step in (*F11*) once again to go to line `27`. Now, the `BaseLookUpRate` variable
    has a value of `45.0`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按下(*F11*)进入到第`27`行。现在，`BaseLookUpRate`变量的值为`45.0`。
- en: Similarly, you are encouraged to step in and debug other sections of the code
    to not only familiarize yourself with the debugger but also to understand how
    the code works behind the scenes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您被鼓励进入并调试代码的其他部分，不仅要熟悉调试器，还要了解代码在幕后是如何工作的。
- en: By completing this exercise, you've learned how to set up debug points in Visual
    Studio, as well as stop debugging at a point, and then continue line by line while
    watching an object and its variable's values. This is an important aspect for
    any developer, and many often use this tool to get rid of pesky bugs within code,
    especially when there's a lot of code flows and the number of variables is quite
    large.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经学会了如何在Visual Studio中设置调试点，以及在某一点停止调试，然后逐行继续观察对象及其变量的值。这对于任何开发人员来说都是一个重要的方面，许多人经常使用这个工具来消除代码中的烦人错误，特别是当代码流量很大，变量的数量相当多时。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'At any point, you can stop debugging, restart debugging, or continue with the
    rest of the code by using the following buttons on the top menu bar:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，您都可以通过顶部菜单栏上的以下按钮停止调试、重新开始调试或继续执行其余代码：
- en: '![Figure 2.9: Debugging tools in Visual Studio'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：Visual Studio中的调试工具'
- en: '](img/B16183_02_09.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_09.jpg)'
- en: 'Figure 2.9: Debugging tools in Visual Studio'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：Visual Studio中的调试工具
- en: Now, we'll look at importing assets into an Unreal project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下如何将资产导入到虚幻项目中。
- en: Importing the Required Assets
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入所需资产
- en: Unreal Engine gives users the ability to import a wide range of file types for
    users to customize their projects. There are several import options that developers
    can tweak and play around with to match their required settings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎为用户提供了导入各种文件类型的能力，以便用户自定义其项目。开发人员可以调整和玩弄几种导入选项，以匹配其所需的设置。
- en: Some common file types that game developers often import are FBX for scenes,
    meshes, animations (exported from Maya and other similar software), movie files,
    images (mostly for the user interface), textures, sounds, data in CSV files, and
    fonts. These files may be obtained from the Epic Marketplace or any other means
    (such as the internet) and used within the project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者经常导入的一些常见文件类型包括场景、网格、动画（从Maya和其他类似软件导出）、电影文件、图像（主要用于用户界面）、纹理、声音、CSV文件中的数据和字体。这些文件可以从Epic
    Marketplace或其他途径（如互联网）获得，并在项目中使用。
- en: Assets can be imported by dragging and dropping them into the `Content` folder,
    or by clicking the `Import` button in the `Content Browser`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 资产可以通过将它们拖放到`内容`文件夹中来导入，也可以通过在`内容浏览器`中点击`导入`按钮来导入。
- en: Now let's tackle an exercise where we'll learn how to import FBX files and see
    how this is done.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来进行一个练习，学习如何导入FBX文件以及如何完成这个操作。
- en: 'Exercise 2.03: Importing a Character FBX File'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03：导入角色FBX文件
- en: This exercise will focus on importing a 3D model from an FBX file. FBX files
    are widely used to export and import 3D models, along with their materials, animations,
    and textures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将专注于从FBX文件中导入3D模型。FBX文件被广泛用于导出和导入3D模型，以及它们的材质、动画和纹理。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Download the `SK_Mannequin.FBX`, `ThirdPersonIdle.FBX`, `ThirdPersonRun.FBX`
    and `ThirdPersonWalk.FBX` files from the `Chapter02` -> `Exercise2.03` -> `ExerciseFiles`
    directory, which can be found on GitHub.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub的`Chapter02` -> `Exercise2.03` -> `ExerciseFiles`目录中下载`SK_Mannequin.FBX`，`ThirdPersonIdle.FBX`，`ThirdPersonRun.FBX`和`ThirdPersonWalk.FBX`文件。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://packt.live/2IiqTzq](https://packt.live/2IiqTzq).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseFiles`目录可以在GitHub的以下链接找到：[https://packt.live/2IiqTzq](https://packt.live/2IiqTzq)。'
- en: Open the blank project we created in *Exercise 2.01*, *Creating an Empty C++
    Project*.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在*练习2.01*中创建的空白项目，*创建一个空的C++项目*。
- en: 'In the `Content Browser` interface of the project, click `Import`:![Figure
    2.10: Content Browser Import button'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`内容浏览器`界面中，点击`导入`：![图2.10：内容浏览器导入按钮
- en: '](img/B16183_02_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_10.jpg)'
- en: 'Figure 2.10: Content Browser Import button'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：内容浏览器导入按钮
- en: Browse to the directory of the files we downloaded in *Step 1*, select `SK_Mannequin.FBX`,
    and click on the `Open` button.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到我们在*步骤1*中下载的文件目录，选择`SK_Mannequin.FBX`，然后点击`打开`按钮。
- en: Make sure the `Import Animations` button is `Import All` button. You may get
    a warning here stating that `There are no smoothing groups`. You can ignore this
    for now. With that, you have successfully imported a skeletal mesh from an FBX
    file. Now, we need to import its animations.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`导入动画`按钮是`全部导入`按钮。您可能会收到一个警告，指出`没有平滑组`。您现在可以忽略这个警告。这样，您就成功地从FBX文件中导入了一个骨骼网格。现在，我们需要导入它的动画。
- en: Click the `Import` button again, browse to the folder we created in *Step 1*,
    and select `ThirdPersonIdle.fbx`, `ThirdPersonRun.fbx`, and `ThirdPersonWalk.fbx`.
    Then click on the `Open` button.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击`导入`按钮，浏览到我们在*步骤1*中创建的文件夹，并选择`ThirdPersonIdle.fbx`，`ThirdPersonRun.fbx`和`ThirdPersonWalk.fbx`。然后点击`打开`按钮。
- en: 'Make sure the skeleton is set to the one you imported in *Step 5* and click
    `Import All`:![Figure 2.11: Animation FBX Import Options'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保骨架设置为您在*步骤5*中导入的骨架，然后点击`全部导入`：![图2.11：动画FBX导入选项
- en: '](img/B16183_02_11.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_11.jpg)'
- en: 'Figure 2.11: Animation FBX Import Options'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：动画FBX导入选项
- en: Now, you can see the three animations (`ThirdPersonIdle`, `ThirdPersonRun`,
    and `ThirdPersonWalk`) inside the `Content Browser`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在`内容浏览器`中看到三个动画（`ThirdPersonIdle`，`ThirdPersonRun`和`ThirdPersonWalk`）。
- en: 'If you *double-click* on `ThirdPersonIdle`, you''ll notice that the left arm
    is hanging down. This means that there''s a retargeting issue. When the animations
    are imported separately from the skeleton, the Unreal Engine internally maps all
    the bones from the animation to the skeleton but sometimes that results in a glitch.
    We''re now going to resolve this glitch.![Figure 2.12: ThirdPersonIdle UE4 mannequin
    animation glitch'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您*双击*`ThirdPersonIdle`，您会注意到左臂下垂。这意味着存在重定向问题。当动画与骨架分开导入时，虚幻引擎会将所有骨骼从动画映射到骨架，但有时会导致故障。我们现在要解决这个故障。![图2.12：ThirdPersonIdle
    UE4人体模型动画故障
- en: '](img/B16183_02_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_12.jpg)'
- en: 'Figure 2.12: ThirdPersonIdle UE4 mannequin animation glitch'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：ThirdPersonIdle UE4人体模型动画故障
- en: 'Open the `SK_Mannequin` Skeletal Mesh and open the `Skeleton Tree` tab if not
    open previously.![Figure 2.13: SK_Mannequin Skeleton Tree tab select'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SK_Mannequin`骨骼网格，并打开`骨架树`选项卡（如果之前没有打开）。![图2.13：SK_Mannequin骨架树选项卡选择
- en: '](img/B16183_02_13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_13.jpg)'
- en: 'Figure 2.13: SK_Mannequin Skeleton Tree tab select'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：SK_Mannequin骨架树选项卡选择
- en: 'Under `Options` enable the `Show Retargeting Options` checkbox.![Figure 2.14:
    Enabling retargeting options'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`选项`下启用`显示重定向选项`复选框。![图2.14：启用重定向选项
- en: '](img/B16183_02_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_14.jpg)'
- en: 'Figure 2.14: Enabling retargeting options'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：启用重定向选项
- en: Now inside the skeleton tree, reduce the `spine_01`, `thigh_l` and `thigh_r`
    bones to enable better visibility.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在骨架树中，减少`spine_01`，`thigh_l`和`thigh_r`骨骼，以便更好地可见。
- en: Now select the `spine_01`, `thigh_l` and `thigh_r` bones. *Right click* on them,
    and in the menu, click the `Recursively Set Translation Retargeting Skeleton`
    button. This will fix the bone translation issues we encountered before.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择`spine_01`，`thigh_l`和`thigh_r`骨骼。在它们上面*右键单击*，然后在菜单中点击`递归设置平移重定向骨架`按钮。这将修复我们之前遇到的骨骼平移问题。
- en: 'Re-open the `ThirdPersonIdle` `Animation` to verify the hanging arm has been
    fixed.![Figure 2.15: Fixed ThirdPersonIdle Animation'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新打开`ThirdPersonIdle` `动画`，以验证悬臂是否已经修复。![图2.15：修复的ThirdPersonIdle动画
- en: '](img/B16183_02_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_15.jpg)'
- en: 'Figure 2.15: Fixed ThirdPersonIdle Animation'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：修复的ThirdPersonIdle动画
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can locate the complete exercise code files on GitHub in the `Chapter02`
    -> `Exercise2.03` -> `Ex2.03-Completed.rar` directory by going to the following
    link: [https://packt.live/2U8AScR](https://packt.live/2U8AScR)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub的`Chapter02` -> `Exercise2.03` -> `Ex2.03-Completed.rar`目录中找到完整的练习代码文件，链接如下：[https://packt.live/2U8AScR](https://packt.live/2U8AScR)
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解压`.rar`文件后，*双击*`.uproject`文件。您会看到一个提示，询问`是否要立即重建？`。点击该提示上的`是`，这样它就可以构建必要的中间文件，然后应该自动在虚幻编辑器中打开项目。
- en: By completing this exercise, you've understood how to import assets and, more
    specifically, imported an FBX skeletal mesh and animation data into your project.
    This is crucial for the workflows of many game developers as assets are the building
    blocks of the entire game.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经了解了如何导入资产，更具体地说，导入了一个FBX骨骼网格和动画数据到您的项目中。对于许多游戏开发者的工作流程来说，这是至关重要的，因为资产是整个游戏的构建模块。
- en: In the next section, we'll be looking at the Unreal core classes for creating
    a game, how important they are for creating a game or experience, and how to use
    them inside a project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下用于创建游戏的虚幻核心类，它们对于创建游戏或体验有多重要，以及如何在项目中使用它们。
- en: The Unreal Game Mode Class
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻游戏模式类
- en: Consider a situation where you want to be able to pause your game. All the logic
    and implementation required to be able to pause the game will be placed inside
    a single class. This class will be responsible for handling the game flow when
    a player enters the game. The game flow can be any action or a set of actions
    occurring in the game. For example, game pause, play, and restart are considered
    simple game flow actions. Similarly, in the case of a multiplayer game, we require
    all the network-related gameplay logic to be placed together. This is exactly
    what the Game Mode class is there for.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，您希望能够暂停游戏。所有必要的逻辑和实现，以便能够暂停游戏的类将被放置在一个单独的类中。这个类将负责处理玩家进入游戏时的游戏流程。游戏流程可以是游戏中发生的任何动作或一系列动作。例如，游戏暂停、播放和重新开始被认为是简单的游戏流程动作。同样，在多人游戏的情况下，我们需要将所有与网络相关的游戏逻辑放在一起。这正是游戏模式类的作用。
- en: Game Mode is a class that drives the game logic and imposes game-related rules
    on players. It essentially contains information about the current game being played,
    including gameplay variables and events, which are mentioned later on in this
    chapter. Game Mode can hold all the managers of the gameplay objects, it's a singleton
    class, and is directly accessible by any object or abstract class present in the game.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式是一个驱动游戏逻辑并对玩家施加游戏相关规则的类。它基本上包含有关当前正在进行的游戏的信息，包括游戏变量和事件，这些将在本章后面提到。游戏模式可以容纳所有游戏对象的管理器，它是一个单例类，并且可以被游戏中的任何对象或抽象类直接访问。
- en: As with all the other classes, the Game Mode class can be extended in Blueprints
    or C++. This can be done to include extra functionality and logic that may be
    required to keep players updated about what's happening inside the game.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他类一样，游戏模式类可以在蓝图或C++中进行扩展。这可以用来包括可能需要的额外功能和逻辑，以便让玩家了解游戏内发生的情况。
- en: 'Let''s go over some example game logic that goes inside the Game Mode class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些放在游戏模式类中的示例游戏逻辑：
- en: Limiting the number of players that are allowed to enter the game
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制允许进入游戏的玩家数量
- en: Controlling the Spawn location and Player Controller logic of newly connected players
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制新连接玩家的生成位置和玩家控制器逻辑
- en: Keeping track of the Game Score
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游戏得分
- en: Keeping track of the Game Win/Lose condition
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪游戏胜利/失败条件。
- en: Implementing the Game Over/Restart Game scenario
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现游戏结束/重新开始游戏场景
- en: In the next section, we will look at the default classes provided by Game Mode.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看游戏模式提供的默认类。
- en: Game Mode Default Classes
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏模式默认类
- en: 'In addition to itself, Game Mode uses several classes to implement game logic.
    It allows you to specify classes for its following defaults:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自身之外，游戏模式使用了几个类来实现游戏逻辑。它允许您为其以下默认值指定类：
- en: '**Game Session Class**: Handles admin-level game flow such as login approval.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏会话类**：处理管理员级别的游戏流程，如登录批准。'
- en: '**Game State Class**: Handles the state of the game so that clients can see
    what''s going on inside the game.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态类**：处理游戏状态，以便客户端可以看到游戏内发生的情况。'
- en: '**Player Controller Class**: The main class used to possess and control a pawn.
    Can be thought of as a brain that decides what to do.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器类**：用于控制和操纵角色的主要类。可以被视为决定要做什么的大脑。'
- en: '**Player State Class**: Holds the current state of a player inside the game.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家状态类**：保存玩家在游戏中的当前状态。'
- en: '**HUD Class**: Handles the user interface shown to the player.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD类**：处理显示给玩家的用户界面。'
- en: '**Default Pawn Class**: The main actor that the player controls. This is essentially
    the player character.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认Pawn类**：玩家控制的主要角色。这本质上是玩家角色。'
- en: '`DefaultPawn` class, the Spectator Pawn Class specifies the pawn responsible
    for spectating the game.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultPawn`类，旁观者Pawn类指定了负责旁观游戏的Pawn。'
- en: '**Replay Spectator Player Controller**: The Player Controller responsible for
    manipulating replay during playback, within the game.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重播旁观玩家控制器**：负责在游戏内回放期间操纵回放的玩家控制器。'
- en: '**Server Stat Replicator Class**: Responsible for replicating server stat net
    data.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器状态复制器类**：负责复制服务器状态网络数据。'
- en: You can either use the default classes as is, or you can specify your own for
    custom implementation and behavior. These classes will work in conjunction with
    Game Mode and will automatically run without being placed inside the world.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用默认类，也可以为自定义实现和行为指定自己的类。这些类将与游戏模式一起工作，并且将自动运行，而无需放置在世界中。
- en: Gameplay Events
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏事件
- en: In terms of a multiplayer game, when many players enter the game, it becomes
    essential to handle logic to allow their entry into the game, maintain their state,
    as well as to allow them to view other players' states and handle their interactions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏方面，当许多玩家进入游戏时，处理逻辑以允许他们进入游戏，维护其状态，并允许他们查看其他玩家的状态并处理其交互变得至关重要。
- en: 'Game Mode provides you with several events that can be overridden to handle
    such multiplayer gameplay logic. The following events are especially useful for
    networking features and abilities (which they are mostly used for):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式为您提供了几个可以重写以处理多人游戏逻辑的事件。以下事件对于网络功能和能力（它们主要用于此目的）特别有用：
- en: '`On Post Log In`: This event is called after the player is logged into the
    game successfully. From this point onward, it is safe to call replicated logic
    (used for networking in multiplayer games) on the Player Controller class.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在登录后”：此事件在玩家成功登录游戏后调用。从这一点开始，可以在玩家控制器类上调用复制逻辑（用于多人游戏中的网络）。
- en: '`Handle Starting New Player`: This event is called after the `On Post Log In`
    event and can be used to define what happens to the newly entered player. By default,
    it creates a pawn for the newly connected player.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “处理新玩家的开始”：此事件在“在登录后”事件之后调用，可用于定义新进入玩家的情况。默认情况下，它为新连接的玩家创建一个角色。
- en: '`SpawnDefaultPawnAtTransform`: This event triggers the actual pawn spawning
    within the game. Newly connected players can be spawned at particular transforms
    or at preset player start positions placed within the level (which can be added
    by Dragging and Dropping the Player Start from the Models Window into the World).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在指定位置生成默认角色”：此事件触发游戏中实际的角色生成。新连接的玩家可以在特定的变换位置或放置在关卡中的预设玩家起始位置生成（可以通过将玩家起始位置从模型窗口拖放到世界中来添加）。
- en: '`On Logout`: This event is called when a player leaves the game or is destroyed.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在注销时”：当玩家离开游戏或被销毁时调用此事件。
- en: '`On Restart Player`: This event is called to respawn the player. Similar to
    `SpawnDefaultPawnAtTransform`, the player can be respawned at specific transforms
    or pre-specified locations (using the player start position).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重新开始玩家时：调用此事件以重新生成玩家。与“在指定位置生成默认角色”类似，玩家可以在特定的变换位置或预先指定的位置（使用玩家起始位置）重新生成。
- en: Networking
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: The Game Mode class is not replicated to any clients or joined players. Its
    scope is only limited to the server where it is spawned. Essentially, the client-server
    model dictates that the clients only act as inputs within the game that is being
    played on the server. Therefore, the gameplay logic should not exist for the clients,
    but only for the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式类不会被复制到任何客户端或加入的玩家。它的范围仅限于生成它的服务器。本质上，客户端-服务器模型规定客户端只能作为服务器上进行游戏的输入。因此，游戏逻辑不应存在于客户端，而应仅存在于服务器。
- en: GameModeBase versus GameMode
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameModeBase与GameMode
- en: From version 4.14 onward, Epic introduced the `AGameModeBase` class, which acts
    as the parent class for all Game Mode classes. It is essentially a simplified
    version of the `AGameMode` class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.14版本开始，Epic引入了“AGameModeBase”类，它充当所有游戏模式类的父类。它本质上是“AGameMode”类的简化版本。
- en: However, the Game Mode class contains some additional functionality that is
    better suited for Multiplayer Shooter type games as it implements the Match State
    concept. By default, the Game Mode Base is included in new template-based projects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，游戏模式类包含一些更适合多人射击类型游戏的附加功能，因为它实现了比赛状态的概念。默认情况下，“游戏模式基类”包含在基于模板的新项目中。
- en: Game Mode also contains a State Machine that handles and keeps track of the
    player's state.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式还包含一个状态机，用于处理并跟踪玩家的状态。
- en: Levels
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡
- en: Levels, in gaming, are a section or a part of a game. Since many games are quite
    large, they are broken down into different levels. A level of interest is loaded
    into the game for the player to play, and then when they are done with that, another
    level may be loaded in (while the current one will be loaded out) so that the
    player can proceed. To complete a game, a player usually needs to complete a set
    of specific tasks to move on to the next level, eventually completing the game.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，关卡是游戏的一个部分或部分。由于许多游戏非常庞大，它们被分解为不同的关卡。加载感兴趣的关卡供玩家玩耍，然后当他们完成后，可能会加载另一个关卡（同时当前的关卡将被加载出）以便玩家可以继续。要完成游戏，玩家通常需要完成一组特定任务以进入下一关，最终完成游戏。
- en: A Game Mode can be directly applied to the level. The level, upon loading, will
    use the assigned Game Mode class to handle all logic and gameplay for that particular
    level and override the game mode of the project for this level. This can be applied
    using the `World Settings` tab after opening a level.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式可以直接应用于关卡。加载关卡时，将使用分配的游戏模式类来处理该特定关卡的所有逻辑和游戏玩法，并覆盖项目的游戏模式。可以在打开关卡后使用“世界设置”选项卡进行应用。
- en: A Level Blueprint is a blueprint that runs with the level, but cannot be accessed
    outside the scope of the level. Game Mode can be accessed in any blueprint (including
    the level blueprint) by the `Get Game Mode` node. This can later be cast to your
    Game Mode class, to obtain a reference to it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡蓝图是一个与关卡一起运行的蓝图，但不能在关卡范围之外访问。游戏模式可以在任何蓝图（包括关卡蓝图）中通过“获取游戏模式”节点访问。稍后可以将其转换为您的游戏模式类，以获取对其的引用。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A level can only have one Game Mode class assigned to it. However, a single
    Game Mode class can be assigned to multiple levels to imitate similar functionality
    and logic.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关卡只能分配一个游戏模式类。但是，可以将单个游戏模式类分配给多个关卡，以模仿类似的功能和逻辑。
- en: The Unreal Pawn Class
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚幻角色类
- en: The `Pawn` class, in Unreal, is the most basic class of actors that can be possessed
    (either by a player or AI). It also graphically represents the player/bot in the
    game. Code inside this class should have everything to do with the game entities,
    including interaction, movement, and ability logic. The player can still only
    possess a single pawn at any time in the game. Also, the player can *unpossess*
    one pawn and *possess* another pawn during gameplay.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pawn`类，在虚幻引擎中，是可以被玩家或AI控制的最基本的角色类。它也在游戏中图形化地代表玩家/机器人。这个类中的代码应该涉及游戏实体的所有内容，包括交互、移动和能力逻辑。玩家在游戏中仍然只能控制一个角色。此外，玩家可以在游戏过程中*取消控制*一个角色并*控制*另一个角色。'
- en: The Default Pawn
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认角色
- en: Unreal Engine gives developers a `DefaultPawn` class (which inherits from the
    base `Pawn` class). On top of the `Pawn` class, this class contains additional
    code that allows it to move within the world, as you would in the editor version
    of the game.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎提供了一个`DefaultPawn`类（继承自基本的`Pawn`类）。在`Pawn`类的基础上，这个类包含了额外的代码，使其能够在世界中移动，就像在游戏的编辑版本中一样。
- en: The Spectator Pawn
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观战角色
- en: Some games offer features to spectate games. Let's say you're waiting for a
    friend to finish their game before joining you, so you go ahead and spectate their
    game. This gives you the ability to observe the game the player is playing, through
    a camera that you can move around to get a view of the players or the game. Some
    games also offer spectate modes that can travel back in time, to show a particular
    action of the game that happened in the past or at any point in the game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏提供了观战游戏的功能。比如说，你正在等待朋友完成他们的游戏，然后加入你，所以你可以先观战他们的游戏。这使你能够观察玩家正在玩的游戏，通过一个可以移动的摄像头来观察玩家或游戏。一些游戏还提供了观战模式，可以回到过去，展示游戏中发生的特定动作或游戏中的任何时间点。
- en: As the name suggests, this is a special type of pawn that provides sample functionality
    to spectate a game. It contains all the basic tools (such as the Spectator Pawn
    Movement component) required to do so.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这是一种特殊类型的角色，提供了观战游戏的示例功能。它包含了所有基本工具（如观战角色移动组件）来实现这一点。
- en: The Unreal Player Controller Class
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚幻引擎玩家控制器类
- en: 'The Player Controller class can be thought of as the player. It is essentially
    the *soul* of a pawn. A Player Controller takes input from the user and feeds
    it to the pawn and other classes for the player to interact with the game. However,
    you must take note of the following points while dealing with this class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家控制器类可以被视为玩家。它本质上是角色的*灵魂*。玩家控制器接收用户输入，并将其传递给角色和其他类，以便玩家与游戏进行交互。然而，在处理这个类时，您必须注意以下几点：
- en: Unlike the pawn, there can only be one Player Controller that the player represents
    in a level. (Just like when you travel in an elevator. While inside one, you can
    only control that elevator, but you can then exit it and enter another elevator
    in order to control that one.)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与角色不同，一个关卡中只能有一个玩家控制器代表玩家。（就像当你乘坐电梯时。在电梯内，你只能控制那部电梯，但你可以离开它并进入另一部电梯来控制它。）
- en: The Player Controller persists throughout the game, but the pawn may not (for
    example, in a battle game, the player character may die and respawn, but the Player
    Controller would remain the same).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器在整个游戏中持续存在，但角色可能不会（例如，在战斗游戏中，玩家角色可能会死亡并重生，但玩家控制器仍然保持不变）。
- en: Due to the temporary nature of the pawn and the permanent nature of the Player
    Controller, developers need to keep in mind which code should be added to which
    class.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于角色的临时性和玩家控制器的永久性，开发人员需要考虑应该将哪些代码添加到哪个类中。
- en: Let's understand this better through the next exercise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过下一个练习更好地理解这一点。
- en: 'Exercise 2.04: Setting Up the Game Mode, Player Controller, and Pawn'
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：设置游戏模式、玩家控制器和角色
- en: This exercise will use the blank project we created in *Exercise 2.01*, *Creating
    an Empty C++ Project*. We'll be adding our Game Mode, Player Controller, and `Pawn`
    class to the game and will be testing to see if our code works in Blueprints.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将使用我们在*练习2.01*中创建的空项目。我们将向游戏中添加我们的游戏模式、玩家控制器和`Pawn`类，并测试我们的代码是否在蓝图中工作。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Open the project we created in *Exercise 2.01*, *Creating an Empty C++ Project*.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们在*练习2.01*中创建的项目，*创建一个空的C++项目*。
- en: '*Right-click* inside the `Content Browser` and select `Blueprint Class`.'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`内容浏览器`中*右键单击*，然后选择`蓝图类`。
- en: 'Under the `All Classes` section, find and select the `Game Mode` class:![Figure
    2.16: Selecting the Game Mode class'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`所有类`部分，找到并选择`游戏模式`类：![图2.16：选择游戏模式类
- en: '](img/B16183_02_16.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_16.jpg)'
- en: 'Figure 2.16: Selecting the Game Mode class'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：选择游戏模式类
- en: Set its name to `BP_MyGameMode`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`BP_MyGameMode`。
- en: Repeat *Steps 2-4* and select the `Pawn` class from under the `Common Classes`
    section, as shown in the preceding screenshot. Set the name of this class to `BP_MyPawn`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2-4*，并在`常见类`部分选择`Pawn`类，如前面的屏幕截图所示。将此类的名称设置为`BP_MyPawn`。
- en: 'Repeat *Steps 2-4* and select the `Player Controller` class under the `Common
    Classes` section, as shown in the preceding screenshot. Set the name of this class
    to `BP_MyPC`:![Figure 2.17: Game Mode, Pawn, and Player Controller names'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2-4*，并在`常见类`部分选择`玩家控制器`类，如前面的屏幕截图所示。将此类的名称设置为`BP_MyPC`：![图2.17：游戏模式、角色和玩家控制器名称
- en: '](img/B16183_02_17.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_17.jpg)'
- en: 'Figure 2.17: Game Mode, Pawn, and Player Controller names'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：游戏模式、角色和玩家控制器名称
- en: 'Open `BP_MyGameMode` and open the `Event Graph` tab:![Figure 2.18: Event Graph
    tab in Blueprint'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_MyGameMode`，并打开`事件图`标签：![图2.18：蓝图中的事件图标签
- en: '](img/B16183_02_18.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_18.jpg)'
- en: 'Figure 2.18: Event Graph tab in Blueprint'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：蓝图中的事件图标签
- en: '*Left-click* and drag from the white pin in the `Event BeginPlay` node and
    then release the *left mouse button* to gain an `Options` menu. Type `print` and
    select the `print` node highlighted in the list:![Figure 2.19: Print String node
    (Blueprint)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*并从`Event BeginPlay`节点中的白色引脚拖动，然后释放*左鼠标按钮*以获得`选项`菜单。键入`print`并在列表中选择突出显示的`print`节点：![图2.19：打印字符串节点（蓝图）'
- en: '](img/B16183_02_19.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_19.jpg)'
- en: 'Figure 2.19: Print String node (Blueprint)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19：打印字符串节点（蓝图）
- en: In the resultant `Print String` node that gets placed under the `In String`
    parameter, type `My Game Mode has started!`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`In String`参数下放置的结果`Print String`节点中，键入`My Game Mode has started!`。
- en: Now, press the `Compile` and `Save` buttons on the top menu bar.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按顶部菜单栏上的`编译`和`保存`按钮。
- en: Repeat *Steps 7-10* for both the `BP_MyPawn` and `BP_MyPC` classes, setting
    the `In String` parameter to `My Pawn has started!` and `My PC has started!`,
    respectively.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤7-10*，分别为`BP_MyPawn`和`BP_MyPC`类设置`In String`参数为`My Pawn has started!`和`My
    PC has started!`。
- en: 'Finally, open the `World Settings` tab, and under the `Game Mode` section,
    use the dropdown to set the `GameMode Override`, `Default Pawn Class`, and `Player
    Controller Class` options to our respective classes:![Figure 2.20: World Settings
    and Game Mode setup'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`World Settings`选项卡，在`Game Mode`部分，使用下拉菜单将`GameMode Override`，`Default
    Pawn Class`和`Player Controller Class`选项设置为我们各自的类：![图2.20：世界设置和游戏模式设置
- en: '](img/B16183_02_20.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_20.jpg)'
- en: 'Figure 2.20: World Settings and Game Mode setup'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20：世界设置和游戏模式设置
- en: 'Click `Play` to play your game and see the three print statements on the top.
    This means that the current `GameMode Override`, `Default Pawn Class`, and `Player
    Controller Class` options have been set to your specified classes and are running
    their code:![Figure 2.21: Output prints'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`播放`以播放游戏，并在顶部看到三个打印语句。这意味着当前的`GameMode Override`，`Default Pawn Class`和`Player
    Controller Class`选项已设置为您指定的类，并正在运行它们的代码：![图2.21：输出打印
- en: '](img/B16183_02_21.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_21.jpg)'
- en: 'Figure 2.21: Output prints'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：输出打印
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can locate the completed exercise code files on GitHub, in the `Chapter02`
    -> `Exercise2.04` -> `Ex2.04-Completed.rar` directory, at the following link:
    [https://packt.live/3k7nS1K](https://packt.live/3k7nS1K)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub的`Chapter02` -> `Exercise2.04` -> `Ex2.04-Completed.rar`目录中找到已完成的练习代码文件，链接如下：[https://packt.live/3k7nS1K](https://packt.live/3k7nS1K)
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 提取`.rar`文件后，*双击*`.uproject`文件。您将看到一个提示，询问`是否要立即重建？`。点击该提示上的`是`，以便它可以构建必要的中间文件，之后应该会自动在虚幻编辑器中打开项目。
- en: Now that you know the basic classes and how they work in Unreal, in the next
    section, we will be looking at animations, what processes are involved, and how
    they complete them. We'll follow this with an exercise.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了虚幻中的基本类以及它们的工作原理，在下一节中，我们将看一下动画，涉及到哪些过程，以及它们是如何完成的。接下来我们将进行一次练习。
- en: Animations
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: Animation is essential for adding life and richness to a game. Superb animations
    are one of the major factors that differentiate average games from the good and
    the great from the best. Visual fidelity is what keeps gamers excited and immersed
    in games, and hence animations are a core part of all games and experiences created
    in Unreal Engine.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 动画对于为游戏增添生动和丰富是至关重要的。出色的动画是区分普通游戏和优秀游戏的主要因素之一。视觉保真度是保持玩家对游戏兴奋和沉浸的关键，因此动画是虚幻引擎中创建的所有游戏和体验的核心部分。
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter seeks to cover animation basics. A more in-depth approach to animation
    will be taken in *Chapter 13*, *Blend Spaces 1D, Key Bindings, and State Machines*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在介绍动画基础知识。对动画的更深入探讨将在*第13章*，*混合空间1D，按键绑定和状态机*中进行。
- en: Animation Blueprints
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画蓝图
- en: An Animation Blueprint is a specific kind of blueprint that allows you to control
    the animation of a Skeletal Mesh. It provides users with a graph specifically
    for animation-related tasks. Here, you can define the logic for computing the
    poses of a skeleton.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图是一种特定类型的蓝图，允许您控制骨骼网格的动画。它为用户提供了一个专门用于动画相关任务的图表。在这里，您可以定义计算骨架姿势的逻辑。
- en: Note
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Skeletal Mesh is a skeleton-based mesh that has bones, all of which come together
    to give form to the mesh, whereas a Static Mesh (as the name suggests) is an un-animatable
    mesh. Skeletal Meshes are normally used for characters and life-like objects (for
    example, a player hero), whereas Static Meshes are used for basic or lifeless
    objects (for example, a wall).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼网格是一种基于骨骼的网格，具有骨骼，所有这些骨骼汇集在一起形成网格，而静态网格（顾名思义）是一种不可动画的网格。骨骼网格通常用于角色和逼真的对象（例如玩家英雄），而静态网格用于基本或无生命的对象（例如墙壁）。
- en: 'Animation Blueprints provide two kinds of graphs: `EventGraph` and `AnimGraph`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图提供两种类型的图表：`EventGraph`和`AnimGraph`。
- en: Event Graph
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件图
- en: 'The Event Graph within an Animation Blueprint provides setup events related
    to animations, as we learned in *Chapter 1*, *Unreal Engine Introduction*, that
    can be used for variable manipulation and logic. Event graphs are mostly used
    within Animation Blueprints to update Blend Space values, which, in turn, drive
    the animations within `AnimGraph`. The most common events that are used here are
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 动画蓝图中的事件图提供了与动画相关的设置事件，正如我们在*第1章*，*虚幻引擎介绍*中学到的，可以用于变量操作和逻辑。事件图主要用于在动画蓝图中更新混合空间值，从而驱动`AnimGraph`中的动画。这里主要使用的常见事件如下：
- en: '**Blueprint Initialize Animation:** Used to initialize the animation.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图初始化动画：**用于初始化动画。'
- en: '**Blueprint Update Animation:** This event is executed every frame, giving
    developers the ability to perform calculations and update its values as required:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图更新动画：**此事件在每一帧执行，使开发人员能够根据需要执行计算并更新其值：'
- en: '![Figure 2.22: Animation Event Graph'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.22：动画事件图'
- en: '](img/B16183_02_22.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_22.jpg)'
- en: 'Figure 2.22: Animation Event Graph'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：动画事件图
- en: In the preceding screenshot, you can see the default Event Graph. There are
    `Event Blueprint Update Animation` and `Try Get Pawn Owner` nodes here. You created
    new nodes and appended them to a graph to complete some meaningful tasks in *Exercise
    2.04*, *Setting Up the Game Mode, Player Controller, and Pawn*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可以看到默认的事件图。这里有`事件蓝图更新动画`和`尝试获取所有者`节点。您创建了新节点并将它们附加到图中，以完成*练习2.04*中的一些有意义的任务，*设置游戏模式、玩家控制器和模型*。
- en: The Anim Graph
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画图
- en: The Anim Graph is dedicated to and responsible for playing animations and outputting
    the final pose of the skeleton, on a per-frame basis. It provides developers with
    special nodes to execute different logic. For example, the Blend node takes in
    multiple inputs and is used to decide which input is currently being used in the
    execution. This decision is usually dependent on some external input (such as
    an alpha value).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图专门负责播放动画，并在每帧基础上输出骨架的最终姿势。它为开发人员提供了执行不同逻辑的特殊节点。例如，混合节点接受多个输入，并用于决定当前在执行中使用哪个输入。这个决定通常取决于一些外部输入（如alpha值）。
- en: The Anim Graph works by evaluating nodes by following the flow of execution
    between the exec pins on the nodes being used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图通过评估节点，按照节点上的执行引脚之间的执行流程来工作。
- en: 'In the following screenshot, you can see a single `Output Pose` node on the
    graph. This is the final pose output of the animation that will be visible on
    the relevant Skeletal Mesh within the game. We will be using this in *Exercise
    2.05*, *Creating a Mannequin Animation*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到图上有一个单独的`输出姿势`节点。这是动画的最终姿势输出，将在游戏中的相关骨骼网格上可见。我们将在*练习2.05*中使用这个：
- en: '![Figure 2.23: Animation AnimGraph'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23：动画AnimGraph'
- en: '](img/B16183_02_23.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_23.jpg)'
- en: 'Figure 2.23: Animation AnimGraph'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：动画AnimGraph
- en: State Machines
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: You have already learned how animation nodes and logic can be set up, but one
    essential component is missing. Who decides when a particular animation or piece
    of logic should play or execute? This is where State Machines come into the picture.
    For example, a player may need to shift from crouching to a standing pose, so
    the animation needs to be updated. The code will call the Animation Blueprint,
    access the State Machine, and let it know that the state of the animation needs
    to be changed, resulting in a smooth animation transition.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何设置动画节点和逻辑，但缺少一个重要组件。谁决定何时播放或执行特定的动画或逻辑？这就是状态机的作用。例如，玩家可能需要从蹲姿转换到站立姿势，因此需要更新动画。代码将调用动画蓝图，访问状态机，并让它知道动画的状态需要改变，从而实现平滑的动画过渡。
- en: A State Machine consists of states and rules that can be thought of as depicting
    the state of an animation. A State Machine can always be in one state at a particular
    time. A transition from one state to another is carried out when certain conditions
    (which are defined by rules) are met.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机由状态和规则组成，可以被认为是描述动画状态的状态。状态机在特定时间总是处于一个状态。当满足某些条件（由规则定义）时，就会从一个状态转换到另一个状态。
- en: Transition Rules
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡规则
- en: 'Each Transition Rule contains a Boolean node by the name of `Result`. If the
    Boolean is true, the transition can occur and vice versa:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个过渡规则都包含一个名为`Result`的布尔节点。如果布尔值为true，则可以发生过渡，反之亦然：
- en: '![Figure 2.24: Transition Rules'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24：过渡规则'
- en: '](img/B16183_02_24.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_24.jpg)'
- en: 'Figure 2.24: Transition Rules'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：过渡规则
- en: Blend Spaces
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合空间
- en: When you're provided with a bunch of animations, you can create a State Machine
    and run those animations. However, a problem is presented when you need to transition
    from one animation to another. If you simply switch the animation, it will glitch
    since the new animation's starting pose might be different from the old animation's
    ending pose.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提供一堆动画时，您可以创建一个状态机并运行这些动画。然而，当您需要从一个动画过渡到另一个动画时，会出现问题。如果您简单地切换动画，它会出现故障，因为新动画的起始姿势可能与旧动画的结束姿势不同。
- en: Blend Spaces are special assets used to interpolate between different animations
    based on their alpha values. This, in turn, removes the glitch issue and interpolates
    between the two animations, causing a swift and smooth change in animation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间是用于根据它们的alpha值在不同动画之间进行插值的特殊资产。这反过来消除了故障问题，并在两个动画之间进行插值，导致动画的快速和平滑变化。
- en: Blend Spaces are created either in one dimension, known as a Blend Space 1D,
    or two dimensions, known as a Blend Space. These blend any number of animations
    based on one or two input(s), respectively.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 混合空间可以在一维中创建，称为混合空间1D，或者在二维中创建，称为混合空间。这些根据一个或两个输入混合任意数量的动画。
- en: 'Exercise 2.05: Creating a Mannequin Animation'
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：创建模特动画
- en: Now that you've gone through most of the concepts related to animations, we'll
    be diving in hands-on by adding some animation logic to the default mannequin.
    We'll be creating a Blend Space 1D, a State Machine, and Animation logic.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了大部分与动画相关的概念，我们将通过为默认模特添加一些动画逻辑来进行实际操作。我们将创建一个混合空间1D、一个状态机和动画逻辑。
- en: Our goal here is to create a running animation of our characters and thus gain
    insight into how animations work, as well as the way they are bound to the actual
    character in a 3D world.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建角色的奔跑动画，从而深入了解动画的工作原理，以及它们如何与3D世界中的实际角色绑定。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Download and extract all the contents of the `Chapter02` -> `Exercise2.05` ->
    `ExerciseFiles` directory, which can be found on GitHub. You can extract this
    to any directory you're comfortable with using on your machine.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并提取`Chapter02`->`Exercise2.05`->`ExerciseFiles`目录中的所有内容，这些内容可以在GitHub上找到。您可以将其提取到您在计算机上使用的任何目录中。
- en: Note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `ExerciseFiles` directory can be found on GitHub at the following link:
    [https://packt.live/32tIFGJ](https://packt.live/32tIFGJ).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: “ExerciseFiles”目录可以在GitHub上找到，链接如下：[https://packt.live/32tIFGJ](https://packt.live/32tIFGJ)。
- en: '*Double-click* the `CharAnim.uproject` file to start the project.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“CharAnim.uproject”文件以启动项目。'
- en: Press `Play`. Use the keyboard's *W*, *A*, *S*, *D* keys to move and the *Spacebar*
    to jump. Notice that, currently, there are no animations on the mannequin.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按“播放”。使用键盘的*W*、*A*、*S*、*D*键进行移动，使用*空格键*进行跳跃。请注意，目前模特身上没有动画。
- en: In the `Content` folder, browse to `Content` -> `Mannequin` -> `Animations`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容”文件夹中，浏览到“内容” -> “模特” -> “动画”。
- en: '*Right-click* the `Content` folder, and from the `Animation` section, select
    `Blend Space 1D`.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“内容”文件夹，从“动画”部分选择“混合空间1D”。'
- en: Select `UE4_Mannequin_Skeleton`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“UE4_Mannequin_Skeleton”。
- en: Rename the newly created file to `BS_IdleRun`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新创建的文件重命名为“BS_IdleRun”。
- en: '*Double-click* `BS_IdleRun` to open it.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“BS_IdleRun”以打开它。'
- en: 'Under the `Asset Details` tab, inside the `Axis Settings` section, expand the
    `Horizontal Axis` section and set `Name` to `Speed` and `Maximum Axis Value` to
    `375.0`:![Figure 2.25: Blend Space 1D Axis Settings'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“资产详细信息”选项卡中，在“轴设置”部分，展开“水平轴”部分，将“名称”设置为“速度”，将“最大轴值”设置为“375.0”：![图2.25：混合空间1D轴设置
- en: '](img/B16183_02_25.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_25.jpg)'
- en: 'Figure 2.25: Blend Space 1D Axis Settings'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：混合空间1D轴设置
- en: Head down to the `Sample Interpolation` section and set `Target Weight Interpolation
    Speed Per Sec` to `5.0`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“样本插值”部分，并将“每秒目标权重插值速度”设置为“5.0”。
- en: 'Drag and drop the `ThirdPersonIdle`, `ThirdPersonWalk`, and `ThirdPersonRun`
    animations into the graph separately:![Figure 2.26: Blend Space previewer'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“ThirdPersonIdle”、“ThirdPersonWalk”和“ThirdPersonRun”动画分别拖放到图表中：![图2.26：混合空间预览器
- en: '](img/B16183_02_26.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_26.jpg)'
- en: 'Figure 2.26: Blend Space previewer'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：混合空间预览器
- en: 'Under the `Asset Details` tab, in `Blend Samples`, set the following variable values:![Figure
    2.27: Blend Samples'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“资产详细信息”选项卡中，在“混合样本”中，设置以下变量值：![图2.27：混合样本
- en: '](img/B16183_02_27.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_27.jpg)'
- en: 'Figure 2.27: Blend Samples'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：混合样本
- en: Click `Save` and close this `Asset`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“保存”并关闭此“资产”。
- en: '*Right-click* inside the `Content` folder, and from the `Animation` section,
    select `Animation Blueprint`.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容”文件夹内*右键单击*，从“动画”部分选择“动画蓝图”。
- en: 'In the `Target Skeleton` section, select `UE4_Mannequin_Skeleton` and then
    click the `OK` button:![Figure 2.28: Creating the Animation Blueprint asset'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“目标骨骼”部分，选择“UE4_Mannequin_Skeleton”，然后单击“确定”按钮：![图2.28：创建动画蓝图资产
- en: '](img/B16183_02_28.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_28.jpg)'
- en: 'Figure 2.28: Creating the Animation Blueprint asset'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28：创建动画蓝图资产
- en: Name the file `Anim_Mannequin` and press *Enter*.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件命名为“Anim_Mannequin”，然后按*Enter*。
- en: '*Double-click* the newly created `Anim_Mannequin` file.'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*新创建的“Anim_Mannequin”文件。'
- en: Next, go to the `Event Graph` tab.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到“事件图”选项卡。
- en: 'Create a `boolean` variable called `IsInAir?` by clicking the `+` icon in the
    variable section on the bottom left side. Be sure to assign the proper type:![Figure
    2.29: Adding variables'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在左下角的变量部分单击“+”图标创建一个名为“IsInAir?”的布尔变量。确保分配正确的类型：![图2.29：添加变量
- en: '](img/B16183_02_29.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_29.jpg)'
- en: 'Figure 2.29: Adding variables'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29：添加变量
- en: Create a float variable called `Speed`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“Speed”的浮点变量。
- en: 'Drag off the `Try Get Pawn Owner` return value node and type in `Is Valid`.
    Select the bottom one:![Figure 2.30: Event Graph Is Valid node'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动“尝试获取所有者”返回值节点，并输入“IsValid”。选择底部的一个：![图2.30：事件图IsValid节点
- en: '](img/B16183_02_30.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_30.jpg)'
- en: 'Figure 2.30: Event Graph Is Valid node'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30：事件图IsValid节点
- en: 'Connect the `Exec` pin from the `Event Blueprint Update Animation` node to
    the `Is Valid` node:![Figure 2.31: Connecting nodes'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“事件蓝图更新动画”节点的“Exec”引脚连接到“IsValid”节点：![图2.31：连接节点
- en: '](img/B16183_02_31.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_31.jpg)'
- en: 'Figure 2.31: Connecting nodes'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31：连接节点
- en: From the `Try Get Pawn Owner` node, use the `Get Movement Component` node.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“尝试获取所有者”节点，使用“获取移动组件”节点。
- en: 'From the node obtained in *Step 22*, get the `Is Falling` node and connect
    the Boolean return value to a set node for the `Is in Air?` Boolean. Connect the
    `SET` node exec pin with the `Is Valid` exec pin:![Figure 2.32: Is in Air Boolean
    setup'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤22*中获得的节点中，获取“Is Falling”节点，并将布尔返回值连接到“Is in Air?”布尔的“设置”节点。将“SET”节点的执行引脚与“IsValid”执行引脚连接：![图2.32：Is
    in Air布尔设置
- en: '](img/B16183_02_32.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_32.jpg)'
- en: 'Figure 2.32: Is in Air Boolean setup'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.32：Is in Air布尔设置
- en: 'From the `Try Get Pawn Owner` node, use the `Get Velocity` node, get its `VectorLength`,
    and connect the output to the `A Variable Set` node of `Speed`:![Figure 2.33:
    Speed Boolean setup'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“尝试获取所有者”节点，使用“获取速度”节点，获取其“VectorLength”，并将输出连接到“Speed”的“变量设置”节点：![图2.33：速度布尔设置
- en: '](img/B16183_02_33.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_33.jpg)'
- en: 'Figure 2.33: Speed Boolean setup'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.33：速度布尔设置
- en: Next, head to the `Anim Graph` tab.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到“动画图”选项卡。
- en: '*Right-click* anywhere inside `AnimGraph`, type `state machine`, and click
    on `Add New State Machine`:![Figure 2.34: The Add New State Machine option'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在AnimGraph*内的任何位置*右键单击*，输入“状态机”，然后单击“添加新状态机”：![图2.34：添加新状态机选项'
- en: '](img/B16183_02_34.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_34.jpg)'
- en: 'Figure 2.34: The Add New State Machine option'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34：添加新状态机选项
- en: Make sure the node is selected and then press *F2* to rename it `MannequinStateMachine`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择节点，然后按*F2*进行重命名为“MannequinStateMachine”。
- en: 'Connect the output pin of `MannequinStateMachine` to the input pin for the
    `Output Pose` node and click the compile button on the top bar:![Figure 2.35:
    Configuring the State Machine result in the Output Pose node'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“MannequinStateMachine”的输出引脚连接到“输出姿势”节点的输入引脚，并单击顶部栏上的编译按钮：![图2.35：配置状态机结果输出姿势节点
- en: '](img/B16183_02_35.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_35.jpg)'
- en: 'Figure 2.35: Configuring the State Machine result in the Output Pose node'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35：配置状态机结果输出姿势节点
- en: '*Double-click* the `MannequinstateMachine` node to enter the State Machine.
    You will see an `Entry` node. The state that will be connected to it will become
    the default state of the mannequin. In this exercise, this will be our `Idle Animation`.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“MannequinstateMachine”节点以进入状态机。您将看到一个“Entry”节点。将连接到它的状态将成为模特的默认状态。在本练习中，这将是我们的“Idle动画”。'
- en: '*Right-click* on an empty area inside the State Machine, and from the menu,
    select `Add State`. Press *F2* to rename it `Idle/Run`.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在状态机内的空白区域上*右键单击*，然后从菜单中选择“添加状态”。按下*F2*将其重命名为“Idle/Run”。
- en: 'Drag from the icon next to the `Entry` text, point it inside the `Idle/Run`
    node, and then release it to connect it:![Figure 2.36: Connecting Added State
    to Entry'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Entry”文本旁边的图标拖动，将其指向“Idle/Run”节点内部，然后释放以连接它：![图2.36：将添加的状态连接到Entry
- en: '](img/B16183_02_36.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_36.jpg)'
- en: 'Figure 2.36: Connecting Added State to Entry'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.36：将添加的状态连接到Entry
- en: '*Double-click* on the `Idle/Run` state to open it.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“Idle/Run”状态以打开它。'
- en: 'From the `Asset Browser` menu in the bottom-right corner, select and drag the
    `BS_IdleRun` Animation onto the graph. Get the `Speed` variable from the `Variable`
    section on the left and connect it, as shown here:![Figure 2.37: Idle/Run state
    setup'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右下角的“资产浏览器”菜单中，选择并拖动“BS_IdleRun”动画到图表中。从左侧的“变量”部分获取“Speed”变量并连接它，如图所示：![图2.37：Idle/Run状态设置
- en: '](img/B16183_02_37.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_37.jpg)'
- en: 'Figure 2.37: Idle/Run state setup'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.37：Idle/Run状态设置
- en: 'Head back to `MannequinStateMachine` by clicking on its breadcrumb in the top
    banner:![Figure 2.38: State Machine navigation breadcrumb'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击顶部横幅中的面包屑“MannequinStateMachine”返回到“MannequinStateMachine”：![图2.38：状态机导航面包屑
- en: '](img/B16183_02_38.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_38.jpg)'
- en: 'Figure 2.38: State Machine navigation breadcrumb'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.38：状态机导航面包屑
- en: From the `Asset Browser` menu, drag and drop the `ThirdPersonJump_Start` Animation
    into the graph. Rename it `Jump_Start`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“资产浏览器”菜单中，将“ThirdPersonJump_Start”动画拖放到图表中。将其重命名为“Jump_Start”。
- en: 'Repeat *Step 35* for `ThirdPersonJump_Loop` and `ThirdPerson_Jump` and rename
    them `Jump_Loop` and `Jump_End`, respectively:![Figure 2.39: State setup'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对“ThirdPersonJump_Loop”和“ThirdPerson_Jump”重复*步骤35*，并将它们分别重命名为“Jump_Loop”和“Jump_End”：![图2.39：状态设置
- en: '](img/B16183_02_39.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_39.jpg)'
- en: 'Figure 2.39: State setup'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.39：状态设置
- en: Open the `Jump_Start` state. Click on the `Play ThirdPersonJump_Start` node.
    *Uncheck* `Loop Animation` in the `Settings` section.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_Start”状态。单击“Play ThirdPersonJump_Start”节点。在“设置”部分*取消选中*“循环动画”。
- en: Open the `Jump_Loop` state and click on the `Play ThirdPersonJump_Loop` node.
    Set `Play Rate` to `0.75`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_Loop”状态，单击“Play ThirdPersonJump_Loop”节点。将“Play Rate”设置为“0.75”。
- en: Open the `Jump_End` state and click on the `Play ThirdPerson_Jump` node. *Uncheck*
    the `Loop Animation` Boolean.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_End”状态，单击“Play ThirdPerson_Jump”节点。*取消选中*“循环动画”布尔值。
- en: Since we can shift from `Idle/Run` to `Jump_Start`, drag from the `Idle/Run`
    state and drop it to the `Jump_Start` state. Similarly, `Jump_Start` leads to
    `Jump_Loop`, then to `Jump_End`, and finally back to `Idle/Run`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以从“Idle/Run”转换到“Jump_Start”，因此从“Idle/Run”状态拖动并将其放到“Jump_Start”状态。同样，“Jump_Start”导致“Jump_Loop”，然后到“Jump_End”，最后回到“Idle/Run”。
- en: 'Drag and drop the arrows to set up the State Machine, as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 拖放箭头以设置状态机，如下所示：
- en: '![Figure 2.40: State connections'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.40：状态连接'
- en: '](img/B16183_02_40.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_40.jpg)'
- en: 'Figure 2.40: State connections'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.40：状态连接
- en: '*Double-click* the `Idle/Run` to `Jump_Start` transition rule icon and connect
    the output of the `Is in Air?` variable to the result:![Figure 2.41: Idle/Run
    to Jump_Start transition rule setup'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*“Idle/Run”到“Jump_Start”转换规则图标，并将“Is in Air?”变量的输出连接到结果：![图2.41：Idle/Run到Jump_Start转换规则设置'
- en: '](img/B16183_02_41.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_41.jpg)'
- en: 'Figure 2.41: Idle/Run to Jump_Start transition rule setup'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.41：Idle/Run到Jump_Start转换规则设置
- en: 'Open the `Jump_Start` to `Jump_Loop` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPersonJump_Start` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:![Figure 2.42: Jump_Start to Jump_End
    transition rule setup'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_Start”到“Jump_Loop”转换规则。获取“ThirdPersonJump_Start”的“剩余时间（比率）”节点，并检查其是否小于“0.1”。将结果布尔值连接到结果：![图2.42：Jump_Start到Jump_End转换规则设置
- en: '](img/B16183_02_42.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_42.jpg)'
- en: 'Figure 2.42: Jump_Start to Jump_End transition rule setup'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.42：Jump_Start到Jump_End转换规则设置
- en: 'Open the `Jump_Loop` to `Jump_End` transition rule. Connect the output of the
    inverse of the `Is in Air?` variable to the result:![Figure 2.43: Jump_Loop to
    Jump_End transition rule setup'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_Loop”到“Jump_End”转换规则。将“Is in Air?”的反向输出连接到结果：![图2.43：Jump_Loop到Jump_End转换规则设置
- en: '](img/B16183_02_43.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_43.jpg)'
- en: 'Figure 2.43: Jump_Loop to Jump_End transition rule setup'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.43：Jump_Loop到Jump_End转换规则设置
- en: 'Open the `Jump_End` to `Idle/Run` transition rule. Get the `Time Remaining
    (ratio)` node for `ThirdPerson_Jump` and check whether it is less than `0.1`.
    Connect the resulting bool to the result:![Figure 2.44: Jump_End to Idle/Run transition
    rule setup'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Jump_End”到“Idle/Run”转换规则。获取“ThirdPerson_Jump”的“剩余时间（比率）”节点，并检查其是否小于“0.1”。将结果布尔值连接到结果：![图2.44：Jump_End到Idle/Run转换规则设置
- en: '](img/B16183_02_44.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_44.jpg)'
- en: 'Figure 2.44: Jump_End to Idle/Run transition rule setup'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.44：Jump_End到Idle/Run转换规则设置
- en: Close the Animation Blueprint.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭动画蓝图。
- en: In the `Content` folder, browse to `Content` -> `ThirdPersonBP` -> `Blueprints
    folder` and open the `ThirdPersonCharacter` Blueprint.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容”文件夹中，浏览到“内容”->“ThirdPersonBP”->“蓝图文件夹”，并打开“ThirdPersonCharacter”蓝图。
- en: 'Select `Mesh` in the `Components` tab:![Figure 2.45: Mesh component'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“组件”选项卡中选择“Mesh”：![图2.45：网格组件
- en: '](img/B16183_02_45.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_45.jpg)'
- en: 'Figure 2.45: Mesh component'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.45：网格组件
- en: 'In the `Details` tab, set `Anim Class` to the `Animation Blueprint` class that
    you created:![Figure 2.46: Specifying the Animation Blueprint in the Skeletal
    Mesh component'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“详细信息”选项卡中，将“Anim Class”设置为您创建的“Animation Blueprint”类：![图2.46：在骨骼网格组件中指定动画蓝图
- en: '](img/B16183_02_46.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_46.jpg)'
- en: 'Figure 2.46: Specifying the Animation Blueprint in the Skeletal Mesh component'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.46：在骨骼网格组件中指定动画蓝图
- en: Close the Blueprint.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭蓝图。
- en: Play the game again and notice the animations.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次玩游戏，注意动画。
- en: 'The following should be the output you achieve. As you can see, our character
    is running, and the running animation is being shown:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应该是你实现的输出。正如你所看到的，我们的角色正在奔跑，奔跑动画正在显示：
- en: '![Figure 2.47: Character running animation'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.47：角色奔跑动画'
- en: '](img/B16183_02_47.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_47.jpg)'
- en: 'Figure 2.47: Character running animation'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.47：角色奔跑动画
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the complete exercise code files on GitHub, in the `Chapter02`
    -> `Exercise2.05` -> `Ex2.05-Completed.rar` directory, at the following link:
    [https://packt.live/3kdIlSL](https://packt.live/3kdIlSL)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的练习代码文件，在“Chapter02”->“Exercise2.05”->“Ex2.05-Completed.rar”目录下，链接如下：[https://packt.live/3kdIlSL](https://packt.live/3kdIlSL)
- en: After extracting the `.rar` file, *double-click* the `.uproject` file. You will
    see a prompt asking `Would you like to rebuild now?`. Click `Yes` on that prompt
    so that it can build the necessary intermediate files, after which it should open
    the project in Unreal Editor automatically.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩`.rar`文件后，*双击*`.uproject`文件。你会看到一个提示，询问“是否要立即重建？”。点击该提示上的“是”，这样它就可以构建必要的中间文件，然后自动在虚幻编辑器中打开项目。
- en: By completing this exercise, you've understood how to create State Machines,
    a Blend Space 1D, the Animation Blueprint, and how to tie it all together with
    the Skeletal Mesh of a character. You've also worked on play rates, transitional
    speed and the transitional states, helping you understand how the world of animation
    intricately ties in together.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你已经了解了如何创建状态机、Blend Space 1D、动画蓝图，以及如何将它们与角色的骨骼网格结合起来。你还处理了播放速率、过渡速度和过渡状态，帮助你理解动画世界是如何紧密联系在一起的。
- en: We kicked off this section by understanding how State Machines are used to represent
    and transition in-between Animation States. Next, we got to know how a Blend Space
    1D gives us blending in-between those transitions. All this is used by the Animation
    Blueprint to decide what the current animation of the character is. Now, let's
    combine all these concepts together in an activity.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过理解状态机如何表示和过渡动画状态来开始这一部分。接下来，我们了解了Blend Space 1D如何在这些过渡中进行混合。所有这些都由动画蓝图使用，以决定角色当前的动画是什么。现在，让我们在一个活动中将所有这些概念结合起来。
- en: 'Activity 2.01: Linking Animations to a Character'
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：将动画链接到角色
- en: Let's say, as an Unreal games developer, you've been provided with a character
    skeletal mesh and its animations, and you've been tasked with integrating them
    inside a project. In order to do that, in this activity, you'll be creating an
    Animation Blueprint, State Machines, and a Blend Space 1D of a new character.
    By completing this activity, you should be able to work with animations in Unreal
    Engine and link them to skeletal meshes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 假设作为虚幻游戏开发者，你已经获得了一个角色骨骼网格和它的动画，并且被要求将它们整合到一个项目中。为了做到这一点，在这个活动中，你将创建一个新角色的动画蓝图、状态机和Blend
    Space 1D。通过完成这个活动，你应该能够在虚幻引擎中处理动画，并将它们链接到骨骼网格。
- en: The activity project folder contains a Third Person Template project, along
    with a new character, `Ganfault`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 活动项目文件夹包含一个第三人称模板项目，以及一个新角色“Ganfault”。
- en: Note
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This character and its animations were downloaded from [mixamo.com](http://mixamo.com).
    These have been placed in the `Content` -> `Ganfault` folder on our GitHub repository:
    [https://packt.live/35eCGrk](https://packt.live/35eCGrk)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这个角色及其动画是从[mixamo.com](http://mixamo.com)下载的。这些已经放在我们的GitHub存储库的“内容”->“Ganfault”文件夹中：[https://packt.live/35eCGrk](https://packt.live/35eCGrk)
- en: '*Mixamo.com* is a website that sells 3D characters with animations and is sort
    of an asset marketplace only for 3D models. It also contains a library of free
    models, alongside the paid ones.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*Mixamo.com*是一个销售带有动画的3D角色的网站，类似于一个专门用于3D模型的资产市场。它还包含一个免费模型库，以及付费模型。'
- en: 'The following steps will help you complete this activity:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个活动：
- en: Create a Blend Space 1D for the Walking/Running animation and to set up the
    Animation Blueprint.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于行走/奔跑动画的Blend Space 1D，并设置动画蓝图。
- en: Next, go to `Content` -> `ThirdPersonBP` -> `Blueprints` and open the `ThirdPersonCharacter`
    Blueprint.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到“内容”->“ThirdPersonBP”->“蓝图”，打开“ThirdPersonCharacter”蓝图。
- en: Click the Skeletal Mesh component on the left, and inside the `Details` tab
    on the right, replace the `SkeletalMesh` reference with `Ganfault`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的骨骼网格组件，在右侧的“详细信息”选项卡中，用“Ganfault”替换“SkeletalMesh”引用。
- en: Similarly, update the `Animations Blueprint` section of the skeletal mesh component
    with the Animation Blueprint you created for `Ganfault`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，更新骨骼网格组件的“动画蓝图”部分，使用你为“Ganfault”创建的动画蓝图。
- en: Note
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the State Machine, implement only Idle/Run and Jump State.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于状态机，只实现空闲/奔跑和跳跃状态。
- en: 'Once you''ve completed this activity, the Walk/Run and Jump animations should
    be working properly, as shown in the following output:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，行走/奔跑和跳跃动画应该正常工作，如下所示：
- en: '![Figure 2.48: Activity 2.01 expected output (Left: Run; Right: Jump)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.48：活动2.01预期输出（左：奔跑；右：跳跃）'
- en: '](img/B16183_02_48.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_02_48.jpg)'
- en: 'Figure 2.48: Activity 2.01 expected output (Left: Run; Right: Jump)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.48：活动2.01预期输出（左：奔跑；右：跳跃）
- en: Note
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下链接找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: By completing this activity, you now know how to navigate your way around Unreal
    Engine with regard to the project, debugging code, and working with Animations.
    You also understand State Machines, which represent transitions between the Animation
    States and the Blend Spaces 1D used in that transition. You are now able to add
    animation to 3D models based on gameplay events and inputs.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你现在知道如何在虚幻引擎中导航项目、调试代码和处理动画。你还了解了状态机，它代表了动画状态和过渡之间的转换，以及在该过渡中使用的Blend
    Spaces 1D。你现在能够根据游戏事件和输入为3D模型添加动画。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize this chapter, we first learned how to create an empty project.
    Then, we learned about the folder structure and how to organize files in the project
    directory. After that, we looked at template-based projects. We also learned how
    to set breakpoints in code so that we can watch variable values and debug entire
    objects while the game is running, which would help us find and eradicate bugs
    in our code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章，我们首先学习了如何创建一个空项目。然后，我们了解了文件夹结构以及如何在项目目录中组织文件。之后，我们看了基于模板的项目。我们还学会了如何在代码中设置断点，以便在游戏运行时观察变量值并调试整个对象，这将帮助我们找到并消除代码中的错误。
- en: Thereafter, we saw how Game Mode, Player Pawn, and Player Controller are relevant
    classes used in Unreal Engine for setting up game flows (the execution order of
    code), as well as how they are set up inside a project.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还了解了游戏模式、玩家角色和玩家控制器是虚幻引擎中用于设置游戏流程（代码执行顺序）的相关类，以及它们在项目中的设置方式。
- en: Finally, we transitioned toward animation basics and worked with State Machines,
    Blend Spaces 1D, and Animation Blueprints to make our character animate (walk/run
    and jump) within the game according to the keyboard input.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向动画基础知识，并使用状态机、混合空间1D和动画蓝图，根据键盘输入使我们的角色在游戏中执行动画（行走/奔跑和跳跃）。
- en: Throughout this chapter, we became more familiar with the powerful tools in
    Unreal Engine that are essential to game development. Unreal's Game Mode and its
    default classes are required for making any kind of game or experience in Unreal
    Engine. Additionally, animations bring life to your character and help add layers
    of immersiveness inside your games. All game studios have animations, characters,
    and game logic since these are the core components that drive any game. These
    skills will help you numerous times throughout your game development journey.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，我们更加熟悉了虚幻引擎中强大的工具，这些工具对游戏开发至关重要。虚幻的游戏模式及其默认类对于在虚幻引擎中制作任何类型的游戏或体验都是必需的。此外，动画为角色赋予生命，并帮助增加游戏内的沉浸感。所有游戏工作室都有动画、角色和游戏逻辑，因为这些是推动任何游戏的核心组件。这些技能将在你的游戏开发之旅中帮助你很多次。
- en: In the next chapter, we will talk about the `Character` class in Unreal Engine,
    its components, and how to extend the class for additional setup. You'll be working
    on various exercises, followed by an activity.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论虚幻引擎中的“Character”类，它的组件以及如何扩展该类进行额外的设置。你将进行各种练习，然后进行一项活动。
