- en: Working with the System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与系统一起工作
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Listing files in a directory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录中列出文件
- en: Erasing and creating files and directories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除和创建文件和目录
- en: Writing and using plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和使用插件
- en: Getting backtrace – current call sequence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取回溯-当前调用序列
- en: Passing data quickly from one process to another
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速从一个进程传递数据到另一个进程
- en: Syncing interprocess communications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步进程间通信
- en: Using pointers in shared memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在共享内存中使用指针
- en: The fastest way to read files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件的最快方式
- en: Coroutines - saving the state and postponing the execution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程-保存状态和推迟执行
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Each operating system has many system calls. These calls differ from one operating
    system to another, while doing very close things. Boost provides portable and
    safe wrappers around those calls. Knowledge of wrappers is essential for writing
    good programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有许多系统调用。这些调用在一个操作系统和另一个操作系统之间有所不同，但执行的功能非常接近。Boost提供了对这些调用的可移植和安全的包装器。了解包装器对于编写良好的程序至关重要。
- en: This chapter is devoted to working with the operating system. We already saw
    how to deal with network communications and signals in [Chapter 6](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Manipulating Tasks*. In this chapter, we'll take a closer look at the filesystem,
    creating, and deleting files. We'll see how data can be passed between different
    system processes, how to read files at maximum speed, and how to perform other
    tricks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论与操作系统的工作。我们已经看到如何处理网络通信和信号[第6章](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd)中的*操作任务*。在本章中，我们将更仔细地研究文件系统，创建和删除文件。我们将看到如何在不同系统进程之间传递数据，如何以最大速度读取文件，以及如何执行其他技巧。
- en: Listing files in a directory
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在目录中列出文件
- en: There are standard library functions and classes to read and write data to files.
    But before C++17, there were no functions to list files in a directory, get the
    type of a file, or get access rights for a file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有标准库函数和类来读取和写入文件数据。但在C++17之前，没有函数来列出目录中的文件，获取文件类型或获取文件的访问权限。
- en: Let's see how such iniquities can be fixed using Boost. We'll be doing a program
    that lists names, write accesses, and types of files in the current directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost来修复这些不平等。我们将编写一个程序，列出当前目录中的文件名、写入访问权限和文件类型。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basics of C++ would be more than enough for using this recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对C++的一些基础知识就足够使用这个示例了。
- en: This recipe requires linking against the `boost_system` and `boost_filesystem`
    libraries.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要链接`boost_system`和`boost_filesystem`库。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This recipe and the next one are about portable wrappers for working with a
    filesystem:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和下一个示例是关于使用文件系统的可移植包装器：
- en: 'We need to include the following two headers:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包括以下两个头文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to specify a directory:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要指定一个目录：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After specifying the directory, loop through its content:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定目录之后，循环遍历其内容：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is getting the file info:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是获取文件信息：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, output the file info:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输出文件信息：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final step would be to output the filename:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是输出文件名：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s it; now if we run the program, it will output something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；现在如果我们运行程序，它将输出类似这样的内容：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functions and classes of `Boost.Filesystem` just wrap around system-specific
    functions to work with files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Filesystem`的函数和类只是包装了特定于系统的函数，以便处理文件。'
- en: Note the usage of `/` in *step 2*. POSIX systems use a slash to specify paths;
    Windows, by default, uses backslashes. However, Windows understands forward slashes
    too, so `./` will work on all the popular operating systems, and it means the
    current directory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*步骤2*中`/`的使用。 POSIX系统使用斜杠来指定路径； Windows默认使用反斜杠。 但是，Windows也理解正斜杠，因此`./`将在所有流行的操作系统上工作，并且表示当前目录。
- en: Take a look at *step 3*, where we are default constructing the `boost::filesystem::directory_iterator`
    class. It works just like a `std::istream_iterator` class, which acts as an `end`
    iterator when default constructed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*步骤3*，在那里我们正在默认构造`boost::filesystem::directory_iterator`类。它的工作方式就像`std::istream_iterator`类，当默认构造时充当`end`迭代器。
- en: '*Step 4* is a tricky one, not because this function is hard to understand,
    but because lots of conversions are happening. Dereferencing the `begin` iterator
    returns `boost::filesystem::directory_entry`, which is implicitly converted to
    `boost::filesystem::path`, which is used as a parameter for the `boost::filesystem::status`
    function. Actually, we may do much better:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*是一个棘手的步骤，不是因为这个函数很难理解，而是因为发生了许多转换。解引用`begin`迭代器返回`boost::filesystem::directory_entry`，它隐式转换为`boost::filesystem::path`，然后用作`boost::filesystem::status`函数的参数。实际上，我们可以做得更好：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Read the reference documentation carefully to avoid unrequired implicit conversions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读参考文档，以避免不必要的隐式转换。
- en: '*Step 5* is obvious, so we are moving to *step 6* where implicit conversion
    to the path happens again. A better solution would be the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤5*是显而易见的，所以我们转到*步骤6*，在那里再次发生对路径的隐式转换。更好的解决方案是：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `begin->path()` returns a const reference to the `boost::filesystem::path`
    variable that is contained inside `boost::filesystem::directory_entry`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`begin->path()`返回`boost::filesystem::directory_entry`内包含的`boost::filesystem::path`变量的常量引用。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The ;`Boost.Filesystem` is a part of C++17\. All the stuff in C++17 is located
    in a single header file `<filesystem>` in namespace `std::filesystem`. The standard
    library version of filesystem differs slightly from the Boost version, mostly
    by using scoped enumerations (`enum class`) where `Boost.Filesystem` was using
    just unscoped `enum`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ;`Boost.Filesystem`是C++17的一部分。C++17中的所有内容都位于单个头文件`<filesystem>`中，位于`std::filesystem`命名空间中。标准库版本的文件系统与Boost版本略有不同，主要是通过使用作用域枚举（`enum
    class`）来区分，而`Boost.Filesystem`使用的是非作用域`enum`。
- en: There is a class ; `directory_entry`. That class provides caching of filesystem
    information, so if you work a lot with filesystem and query different information,
    try using `directory_entry` for a better performance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类；`directory_entry`。该类提供了文件系统信息的缓存，因此如果您经常使用文件系统并查询不同的信息，请尝试使用`directory_entry`以获得更好的性能。
- en: Just like in the case of other Boost libraries, `Boost.Filesystem` works on
    pre-C++17 compilers and even on a pre-C++11 compilers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他Boost库一样，`Boost.Filesystem`可以在C++17编译器之前甚至在C++11编译器之前工作。
- en: See also
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Erasing and creating files and directories* recipe will show another example
    of the usage of `Boost.Filesystem`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*擦除和创建文件和目录*教程将展示`Boost.Filesystem`的另一个用法示例'
- en: 'Read Boost''s official documentation of `Boost.Filesystem` to get more info
    about its abilities; it is available at the following link: [http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读Boost关于`Boost.Filesystem`的官方文档，以获取有关其功能的更多信息；可以在以下链接找到：[http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)
- en: You can find the C++17 draft at [http://www.open- std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf)找到C++17草案
- en: Erasing and creating files and directories
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 擦除和创建文件和目录
- en: 'Let''s consider the following lines of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码行：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In these lines, we attempt to write something to `file.txt` in the `dir/subdir`
    directory. This attempt will fail if there is no such directory. The ability to
    work with filesystems is necessary for writing a good working code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们尝试向`dir/subdir`目录中的`file.txt`写入一些内容。如果没有这样的目录，这个尝试将失败。与文件系统的工作能力对于编写良好的工作代码是必要的。
- en: In this recipe, we'll construct a directory and a subdirectory, write some data
    to a file, and try to create `symlink`. If the symbolic link's creation fails,
    erase the created entities. We should also avoid using exceptions as a mechanism
    of error reporting, preferring some kind of return codes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将构建一个目录和一个子目录，向文件写入一些数据，并尝试创建`symlink`。如果符号链接的创建失败，则擦除已创建的实体。我们还应该避免使用异常作为错误报告的机制，而更倾向于某种返回代码。
- en: Let's see how that can be done in an elegant way using Boost.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost以优雅的方式完成这个任务。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and the `std::ofstream` class is required for this recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要对C++和`std::ofstream`类有基本了解。
- en: The ;`Boost.Filesystem` is not a header-only library, so code in this recipe
    requires linking against the `boost_system` and `boost_filesystem` libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Filesystem`不是一个仅头文件的库，因此本教程中的代码需要链接到`boost_system`和`boost_filesystem`库。'
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We continue to deal with portable wrappers for a filesystem, and, in this recipe,
    we''ll see how to modify the directory content:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续处理文件系统的可移植包装器，在本教程中，我们将看到如何修改目录内容：
- en: 'As always, we need to include some headers:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他Boost库一样，我们需要包含一些头文件：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need a variable to store errors (if any):'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个变量来存储错误（如果有的话）：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also create directories, if required, as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们还将创建目录，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we will write data to the file:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将数据写入文件：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to attempt to create `symlink`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要尝试创建`symlink`：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we need to check that the file is accessible through `symlink`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要检查通过`symlink`是否可以访问文件：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll remove the created file, if the `symlink` creation fails:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`symlink`创建失败，我们将删除创建的文件：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We saw `boost::system::error_code` in action in almost all the recipes in [Chapter
    6](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd), *Manipulating Tasks*.
    It can store information about errors and is widely used all around Boost libraries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](part0324.html#9KVM80-712b4ba1126a4c7c89e1d44de61b4bdd)的几乎所有教程中都看到了`boost::system::error_code`的实际应用，*操作任务*。它可以存储有关错误的信息，并且在整个Boost库中广泛使用。
- en: If you do not provide an instance of `boost::system::error_code` to the `Boost.Filesystem`
    functions, the code will compile well. In that case, when an error occurs, a `boost::filesystem::filesystem_error`
    exception is thrown.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为`Boost.Filesystem`函数提供`boost::system::error_code`的实例，代码将编译成功。在这种情况下，当发生错误时，会抛出`boost::filesystem::filesystem_error`异常。
- en: Take a careful look at *step 3*. We used the `boost::filesystem::create_directories`
    function, not `boost::filesystem::create_directory`, because the latter one cannot
    create sub-directories. It is the same story with `boost::filesystem::remove_all`
    and `boost::filesystem::remove`. The first can remove non empty directories, that
    contain files and sub-directories. The second one removes a single file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看*步骤3*。我们使用了`boost::filesystem::create_directories`函数，而不是`boost::filesystem::create_directory`，因为后者无法创建子目录。`boost::filesystem::remove_all`和`boost::filesystem::remove`也是同样的情况。前者可以删除包含文件和子目录的非空目录。后者删除单个文件。
- en: The remaining steps are simple to understand and should not cause any trouble.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其余步骤很容易理解，不应该引起任何麻烦。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::system::error_code` class is a part of C++11 and can be found in
    the `<system_error>` header in the `std::` namespace. The classes of `Boost.Filesystem`
    are part of C++17.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::system::error_code`类是C++11的一部分，可以在`std::`命名空间的`<system_error>`头文件中找到。`Boost.Filesystem`的类是C++17的一部分。'
- en: Finally, here is a small recommendation for those who are going to use `Boost.Filesystem`.
    When the errors occur during filesystem, operations are routine or application
    require high responsibility/performance, for this, use `boost::system::error_codes`.
    Otherwise, catching exceptions are more preferable and reliable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一个对于那些打算使用`Boost.Filesystem`的小建议。当文件系统操作中发生错误时，如果是例行操作或应用程序需要高度的责任/性能，使用`boost::system::error_codes`。否则，捕获异常更可取且更可靠。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Listing files in a directory* recipe also contains information about `Boost.Filesystem`.
    Read Boost's official documentation at [http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)
    to get more information and examples.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*在目录中列出文件*的配方还包含有关`Boost.Filesystem`的信息。阅读Boost的官方文档[http://boost.org/libs/filesystem](http://boost.org/libs/filesystem)以获取更多信息和示例。'
- en: Writing and using plugins
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和使用插件
- en: 'Here''s a tricky question: we want to allow users to write extensions to the
    functionality of our program, but we do not want to give them the source codes.
    In other words we''d like to say, "*Write a function X and pack it into a shared
    library. We may use your function along with functions of some other users!"*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个棘手的问题：我们希望允许用户编写扩展我们程序功能的功能，但我们不想给他们源代码。换句话说，我们想说，“*编写一个函数X并将其打包到共享库中。我们可以使用您的函数以及其他一些用户的函数！*”
- en: 'You meet this technique in everyday life: your browser uses it to allow third-party
    plugins, your text editor may use it for syntax highlighting, games use **dynamic
    library loading** for **downloadable content** (**DLC**s) and for adding gamer''s
    content, web pages are returned by servers that use modules/plugins for encryption/authentication
    and so forth.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您在日常生活中会遇到这种技术：您的浏览器使用它来允许第三方插件，您的文本编辑器可能使用它进行语法高亮显示，游戏使用**动态库加载**进行**可下载内容**（**DLC**）和添加游戏玩家内容，服务器返回的网页使用模块/插件进行加密/身份验证等。
- en: What are the requirements for a user's function and how can we use that function
    at some point without linking it to the shared library?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户功能的要求是什么，我们如何在某个时刻使用该功能，而不将其链接到共享库？
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Basic knowledge of C++ is required for this recipe. Reading the *The portable
    way to export and import functions and classes* from [Chapter 10](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd)
    is a requirement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要基本的C++知识。阅读[第10章](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*导出和导入函数和类的便携式方法*是必需的。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First of all, you have to make an agreement with your users:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须与用户达成协议：
- en: Document the requirement for the plugin interface. For example, you may say
    that all the plugins must export a function with name `greet` and that the function
    must accept `const std::string&` and return `std::string`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录插件接口的要求。例如，您可以说所有插件必须导出一个名为`greet`的函数，并且该函数必须接受`const std::string&`并返回`std::string`。
- en: 'After that, users may start writing plugins/shared library in the following
    way:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，用户可以按以下方式编写插件/共享库：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Your program code for loading a shared library must include the header from
    `Boost.DLL`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载共享库的程序代码必须包括来自`Boost.DLL`的头文件：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code for loading a library must be the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载库的代码必须如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Getting the user''s function must look like this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户功能必须如下所示：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Done. Now, you can use that function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成。现在，您可以使用该功能：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Depending on the loaded plugin, you''ll have different results:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据加载的插件，您将获得不同的结果：
- en: '`plugin_hello`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugin_hello`:'
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`plugin_do_not`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugin_do_not`:'
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is a small trick in *step 2*. When you declare a function as `extern "C"`,
    it means that the compiler must not **mangle** (change) the function name. In
    other words, in *step 2* we just create a function that has a name `greet` and
    is exported with that exact name from the shared library.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*中有一个小技巧。当您将函数声明为`extern "C"`时，这意味着编译器不得**操纵**（更改）函数名称。换句话说，在*步骤2*中，我们只是创建一个名为`greet`的函数，并且以该确切名称从共享库中导出。'
- en: In *step 4,* we create a `boost::dll::shared_library` variable with name `plugin`.
    The constructor of that variable loads the shared library by a specified path
    into the address space of the current executable. In *step 5,* we search for the
    function with name `greet` in the `plugin`. We also specify that the function
    has the signature `std::string(const std::string&)` and store a pointer to that
    function in the variable `greet`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们创建一个名为`plugin`的`boost::dll::shared_library`变量。该变量的构造函数将共享库加载到当前可执行文件的地址空间中。在*步骤5*中，我们在`plugin`中搜索名为`greet`的函数。我们还指定该函数具有`std::string(const
    std::string&)`的签名，并将该函数的指针存储在变量`greet`中。
- en: That's it! From now on, we can use the `greet` variable as a function, as long
    as the `plugin` variable and all its copies are not destroyed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！从现在开始，我们可以将`greet`变量用作函数，只要`plugin`变量及其所有副本未被销毁。
- en: You can export multiple functions from shared library; you can even export variables.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从共享库中导出多个函数；甚至可以导出变量。
- en: Be careful! Always link C and C++ libraries dynamically to the plugin and your
    main executable, because otherwise your application will crash. Always use the
    same or ABI compatible versions of C and C++ libraries in your plugins and in
    your application. Otherwise your application will crash. Read the docs for typical
    missuses!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！始终将C和C++库动态链接到插件和主可执行文件中，否则您的应用程序将崩溃。始终在插件和应用程序中使用相同或ABI兼容的C和C++库版本。否则您的应用程序将崩溃。阅读典型误用的文档！
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.DLL` is a new library; it appeared in Boost 1.61\. My favorite part
    of the library is an ability to add platform-specific decorations to the shared
    library name. For example, the following code, depending on the platform, will
    try to load `"./some/path/libplugin_name.so"`, `"./some/path/plugin_name.dll"`,
    or `"./some/path/libplugin_name.dll"`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.DLL`是一个新库；它出现在Boost 1.61中。我最喜欢的部分是该库具有向共享库名称添加特定于平台的装饰的能力。例如，根据平台，以下代码将尝试加载`"./some/path/libplugin_name.so"`、`"./some/path/plugin_name.dll"`或`"./some/path/libplugin_name.dll"`：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: C++17 has no `boost::dll::shared_library`-like classes. But, work is ongoing
    and some day we may see it in the C++ standard.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有类似`boost::dll::shared_library`的类。但是，工作正在进行中，总有一天我们可能会在C++标准中看到它。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation contains multiple examples and, what is more important,
    typical problems/missuses of the library [http://boost.org/libs/dll](http://boost.org/libs/dll)
    site.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档包含多个示例，更重要的是，库的典型问题/误用[http://boost.org/libs/dll](http://boost.org/libs/dll)网站。
- en: Getting backtrace – current call sequence
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取回溯 - 当前调用序列
- en: 'When reporting errors or failures, it is more important to report the steps
    that lead to the error rather than the error itself. Consider the naive trading
    simulator:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告错误或失败时，更重要的是报告导致错误的步骤，而不是错误本身。考虑一个简单的交易模拟器：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All it reports is a line:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它只报告一行：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's a no go. We want to know how did it happened, what were the steps that
    led to bankruptcy!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是行不通的。我们想知道是怎么发生的，导致破产的步骤是什么！
- en: 'Okay. Let''s fix the following function and make it report the steps that led
    to bankruptcy:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们修复以下函数，并让它报告导致破产的步骤：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Getting started
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need a Boost 1.65 or newer for this recipe. Basic knowledge of C++
    is also a requirement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要Boost 1.65或更新版本。还需要基本的C++知识。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this recipe, we will need only to construct a single class and output it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要构造一个单独的类并输出它：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Done. Now the `report_bankruptcy()` outputs something close to the following
    (read it from the bottom up):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。现在`report_bankruptcy()`输出的内容与以下内容接近（从下往上读）：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the magic is within the `boost::stacktrace::stacktrace` class. On construction,
    it quickly stores the current call stack in itself. `boost::stacktrace::stacktrace`
    is copyable and movable, so a stored a call sequence can be passed to other functions,
    copied into the exception classes, and even stored in some file. Do whatever you
    like with it!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的魔法都在`boost::stacktrace::stacktrace`类中。在构造时，它会快速将当前调用堆栈存储在自身中。`boost::stacktrace::stacktrace`是可复制和可移动的，因此存储的调用序列可以传递给其他函数，复制到异常类中，甚至存储在某个文件中。随心所欲地使用它吧！
- en: 'Instances of `boost::stacktrace::stacktrace` on the output, decode the stored
    call sequence and attempt to get human readable function names. That''s what you''ve
    seen in the example from earlier: call sequence that leads to the `report_bankruptcy()`
    function call.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出的`boost::stacktrace::stacktrace`实例上，解码存储的调用序列并尝试获取人类可读的函数名称。这就是您在之前的示例中看到的：导致`report_bankruptcy()`函数调用的调用序列。
- en: The `boost::stacktrace::stacktrace` you to iterate over stored addresses, decode
    individual addresses into human readable names. If you do not like the default
    output format of the trace, you can write your own function that does the output
    in a way you prefer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::stacktrace::stacktrace`允许您迭代存储的地址，将单个地址解码为人类可读的名称。如果您不喜欢跟踪的默认输出格式，可以编写自己喜欢的输出方式的函数。'
- en: 'Note that backtrace usefulness depends on multiple factors. Release builds
    of your program may contain inline functions, resulting in less readable traces:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，回溯的有用性取决于多个因素。程序的发布版本可能包含内联函数，导致跟踪不太可读：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Building your executable without debug symbols may produce a trace without many
    function names.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有调试符号的情况下构建可执行文件可能会产生没有许多函数名称的跟踪。
- en: Read the *Configuration and Build* section of the official documentation for
    more information about different compilation flags and macros that may affect
    trace readability.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读官方文档的*配置和构建*部分，了解有关可能影响跟踪可读性的不同编译标志和宏的更多信息。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A `Boost.Stacktrace` library has a very neat feature for big projects. You can
    disable all the tracing while linking your program. It means that you do not need
    to rebuild all your source files. Just define `BOOST_STACKTRACE_LINK` macro for
    a whole project. Now, if you link with the `boost_stacktrace_noop` library, empty
    traces will be collected. Link with `boost_stacktrace_windbg`/`boost_stacktrace_windbg_cached`/`boost_stacktrace_backtrace`/
    `... libraries` to get traces of different readability.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Stacktrace`库对于大型项目有一个非常好的功能。您可以在链接程序时禁用所有跟踪。这意味着您不需要重新构建所有源文件。只需为整个项目定义`BOOST_STACKTRACE_LINK`宏。现在，如果您链接`boost_stacktrace_noop`库，将收集空跟踪。链接`boost_stacktrace_windbg`/`boost_stacktrace_windbg_cached`/`boost_stacktrace_backtrace`/`...库`以获得不同可读性的跟踪。'
- en: '`Boost.Stacktrace` is a new library; it appeared in Boost in 1.65.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Stacktrace`是一个新库；它出现在Boost 1.65中。'
- en: '`boost::stacktrace::stacktrace` collects current call sequences pretty fast;
    it just dynamically allocates a chunk of memory and copies a bunch of addresses
    into it. Decoding addresses is much slower; it uses multiple platform-specific
    calls, may fork processes, and may initialize and use **COM**.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::stacktrace::stacktrace`相当快地收集当前的调用序列；它只是动态分配一块内存并将一堆地址复制到其中。解码地址要慢得多；它使用多个特定于平台的调用，可能会分叉进程，并且可能会初始化和使用**COM**。'
- en: C++17 does not have `Boost.Stacktrace` functionality. Work is going on to add
    it to one of the next C++ standards.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有`Boost.Stacktrace`功能。正在进行工作，将其添加到下一个C++标准中。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation at [http://boost.org/libs/stacktrace/](http://boost.org/libs/stacktrace/)
    has some examples on async signal safe stack tracing and detailed description
    of all the `Boost.Stacktrace` abilities[.](http://boost.org/libs/stacktrace)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档[http://boost.org/libs/stacktrace/](http://boost.org/libs/stacktrace)中有一些关于异步信号安全的堆栈跟踪的示例，以及有关所有`Boost.Stacktrace`功能的详细描述。
- en: Passing data quickly from one process to another
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速将数据从一个进程传递到另一个进程
- en: Sometimes, we write programs that communicate with each other a lot. When programs
    are run on different machines, using sockets is the most common technique for
    communication. But if multiple processes run on a single machine, we can do much
    better!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们编写大量相互通信的程序。当程序在不同的机器上运行时，使用套接字是最常见的通信技术。但是，如果多个进程在单台机器上运行，我们可以做得更好！
- en: Let's take a look at how to make a single memory fragment available from different
    processes using the `Boost.Interprocess` library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Boost.Interprocess`库使单个内存片段可在不同进程中使用。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Basic knowledge of C++ is required for this recipe. Knowledge of atomic variables
    is also required (take a look at the *See also* section for more information about
    atomics). Some platforms require linking against the runtime library `rt`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方需要对C++有基本的了解。还需要了解原子变量（查看*另请参阅*部分，了解有关原子的更多信息）。一些平台需要链接到运行时库`rt`。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this example, we will be sharing a single atomic variable between processes,
    making it increment when a new process starts and decrement when the process terminates:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在进程之间共享一个原子变量，使其在新进程启动时递增，在进程终止时递减：
- en: 'We need to include the following header for interprocess communications:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下头文件进行跨进程通信：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Following the header, `typedef`, and a check will help us make sure that atomics
    are usable for this example:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件、`typedef`和检查之后，将帮助我们确保原子对于这个例子是可用的：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create, or get, a shared segment of memory:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取共享内存段：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Get, or construct, an `atomic` variable:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取或构造`atomic`变量：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Work with the `atomic` variable in a usual way:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式处理`atomic`变量：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Destroy the `atomic` variable:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁`atomic`变量：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That''s all! Now if we run multiple instances of this program simultaneously,
    we''ll see that each new instance increments its index value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，如果我们同时运行这个程序的多个实例，我们会看到每个新实例都会递增其索引值：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main idea of this recipe is to get a segment of memory that is visible to
    all processes and place some data in it. Let's take a look at *step 3*, where
    we retrieve such a segment of memory. Here, `shm1- cache` is the name of the segment
    (different segments differ in names). You may give any names to the segments.
    The first parameter is `boost::interprocess::open_or_create`, which tells that
    `boost::interprocess::managed_shared_memory` must open an existing segment with
    the name `shm1- cache` or construct it. The last parameter is the size of the
    segment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的主要思想是获得一个对所有进程可见的内存段，并在其中放置一些数据。让我们看看*步骤3*，在那里我们检索这样一个内存段。在这里，`shm1-cache`是段的名称（不同的段有不同的名称）。您可以为段指定任何名称。第一个参数是`boost::interprocess::open_or_create`，它告诉`boost::interprocess::managed_shared_memory`必须打开一个具有名称`shm1-cache`的现有段或构造它。最后一个参数是段的大小。
- en: The size of the segment must be big enough to fit the `Boost.Interprocess` library-specific
    data in it. That's why we used `1024` and not `sizeof(atomic_t)`. But actually,
    the operating system rounds this value to the nearest bigger supported value,
    which is usually equal to or bigger than 4 kilobytes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 段的大小必顺应足够大，以适应`Boost.Interprocess`库特定的数据。这就是为什么我们使用`1024`而不是`sizeof(atomic_t)`。但实际上，操作系统会将这个值舍入到最接近的更大的支持值，通常等于或大于4千字节。
- en: '*Step 4* is a tricky one, as we are performing multiple tasks at the same time
    here. In part `2` of this step, we find or construct a variable with the name
    `shm1-counter` in the segment. In part `3` of *step 4*, we provide a parameter,
    which is used for the initialization of a variable, if it has not been found in
    *step 2*. This parameter is used only if the variable is not found and must be
    constructed, otherwise it is ignored. Take a closer look at the second line (part
    `1`). See the call to the dereference operator `*`. We are doing it because `segment.find_or_construct<atomic_t>`
    returns a pointer to `atomic_t`, and working with bare pointers in C++ is a bad
    style.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*是一个棘手的步骤，因为我们在这里同时执行多个任务。在这一步的第2部分，我们在段中找到或构造一个名为`shm1-counter`的变量。在*步骤4*的第3部分，我们提供一个参数，用于初始化变量，如果在*步骤2*中没有找到。只有在找不到变量并且必须构造变量时，才会使用此参数，否则将被忽略。仔细看第二行（第1部分）。看到解引用运算符`*`的调用。我们这样做是因为`segment.find_or_construct<atomic_t>`返回一个指向`atomic_t`的指针，在C++中使用裸指针是一种不好的风格。'
- en: We are using atomic variables in shared memory! This is required, because two
    or more processes may simultaneously work with the same `shm1-counter` atomic
    variable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在共享内存中使用原子变量！这是必需的，因为两个或更多进程可能同时使用相同的`shm1-counter`原子变量。
- en: You must be very careful when working with objects in shared memory; do not
    forget to destroy them! In *step 6*, we are destroying the object and segment
    using their names.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理共享内存中的对象时，您必须非常小心；不要忘记销毁它们！在*步骤6*中，我们使用它们的名称销毁对象和段。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a closer look at *step 2,* where we are checking for `BOOST_ATOMIC_INT_LOCK_FREE
    != 2`. We are checking that `atomic_t` does not use mutexes. This is very important,
    because the usual mutexes do not work in shared memory. So if `BOOST_ATOMIC_INT_LOCK_FREE`
    is not equal to `2`, we get an undefined behavior.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看*步骤2*，我们在那里检查`BOOST_ATOMIC_INT_LOCK_FREE != 2`。我们正在检查`atomic_t`是否不使用互斥锁。这非常重要，因为通常的互斥锁在共享内存中不起作用。因此，如果`BOOST_ATOMIC_INT_LOCK_FREE`不等于`2`，我们会得到未定义的行为。
- en: Unfortunately, C++11 has no interprocess classes, and, as far as I know, `Boost.Interprocess`
    is not proposed for inclusion in C++20.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++11没有跨进程类，据我所知，`Boost.Interprocess`也没有被提议纳入C++20。
- en: Once a managed segment is created, it cannot increase in size automatically!
    Make sure that you are creating segments big enough for your needs, or take a
    look at the *See also* section for information about increasing managed segments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了托管段，它就不能自动增加大小！确保您创建的段足够大以满足您的需求，或者查看*另请参阅*部分，了解有关增加托管段的信息。
- en: Shared memory is the fastest way for processes to communicate, but works for
    processes that may share memory. That usually means that processes must run on
    the same host or on a **symmetric multiprocessing** (**SMP**) cluster.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存是进程进行通信的最快方式，但适用于可能共享内存的进程。这通常意味着进程必须在同一主机上运行，或者在**对称多处理**（**SMP**）集群上运行。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Syncing interprocess communications* recipe will tell you more about shared
    memory, interprocess communications, and syncing access to resources in shred
    memory
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步跨进程通信*配方将告诉您更多关于共享内存、跨进程通信和同步访问共享内存资源的信息。'
- en: The *Quick access to a common resource using atomics* recipe for more information
    about atomics
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关原子操作的更多信息，请参阅*使用原子快速访问共享资源*示例
- en: Boost's official documentation of `Boost.Interprocess` may also help; it is
    available at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档`Boost.Interprocess`也可能会有所帮助；可以在[http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)找到。
- en: How to increase managed segments is described in *Growing managed segments*
    at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增加托管段的方法在[http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)的*增长托管段*中有描述
- en: Syncing interprocess communications
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步进程间通信
- en: In the previous recipe, we saw how to create shared memory and how to place
    some objects in it. Now, it's time to do something useful. Let's take an example
    from the *Making a work_queue* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, and make it work for multiple processes. At the end of this
    example, we'll get a class that may store different tasks and pass them between
    processes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何创建共享内存以及如何在其中放置一些对象。现在，是时候做一些有用的事情了。让我们从[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的*多线程*中的*制作工作队列*示例中获取一个例子，并使其适用于多个进程。在这个示例结束时，我们将得到一个可以存储不同任务并在进程之间传递它们的类。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses techniques from the previous one. You will also need to read
    the *Making a work_queue* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, and get its main idea. The example requires linking against
    the runtime library `rt` on some platforms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了前一个示例中的技术。你还需要阅读[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的*多线程*中的*制作工作队列*示例，并理解它的主要思想。该示例需要在某些平台上链接运行时库`rt`。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: It is considered that spawning separate sub-processes instead of threads makes
    a program more reliable, because termination of a sub-process does not terminate
    the main process. We won't argue with that assumption here, and just see how data
    sharing between processes can be implemented.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 认为将独立的子进程代替线程使程序更可靠，因为子进程的终止不会终止主进程。我们不会在这里对这个假设进行争论，只是看看如何实现进程之间的数据共享。
- en: 'A lot of headers are required for this recipe:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例需要很多头文件：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we need to define our structure, `task_structure`, which will be used
    to store tasks:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们的结构`task_structure`，它将用于存储任务：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s start writing the `work_queue` class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始编写`work_queue`类：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Write the members of `work_queue` as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`work_queue`的成员写成以下形式：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Initialization of members must look like the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员的初始化必须如下所示：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We need to do some minor changes to the member functions of `work_queue`, such
    as using `scoped_lock_t`, instead of the original unique locks:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对`work_queue`的成员函数进行一些微小的更改，比如使用`scoped_lock_t`，而不是原始的unique locks：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Do not forget about the resources cleanup:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记清理资源：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we are doing almost exactly the same things as in the *Making
    a work_queue* *class* recipe in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, but we allocate the data in shared memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们几乎做了和[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)的*多线程*中的*制作工作队列*
    *类*示例中完全相同的事情，但我们是在共享内存中分配数据。
- en: Take additional care when storing the shared memory objects that have pointers
    or references as member fields. We'll see how to cope with pointers in the next
    recipe.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储具有指针或引用作为成员字段的共享内存对象时需要额外小心。我们将在下一个示例中看到如何处理指针。
- en: Take a look at *step 2*. We did not use `boost::function` as a task type because
    it has pointers in it, so it does not work in shared memory.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下*步骤2*。我们没有使用`boost::function`作为任务类型，因为它里面有指针，所以它在共享内存中无法工作。
- en: '*Step 3* is interesting because of `allocator_t`. If memory is not allocated
    from the shared memory segment, it is available to other processes; that''s why
    a specific allocator for containers is required. An `allocator_t` is a stateful
    allocator, which means that it is copied along with the container. Also, it cannot
    be default constructed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*很有趣，因为涉及`allocator_t`。如果内存不是从共享内存段分配的，它就可以被其他进程使用；这就是为什么需要为容器使用特定的分配器。`allocator_t`是一个有状态的分配器，这意味着它会随着容器一起被复制。此外，它不能被默认构造。'
- en: '*Step 4* is pretty simple, except that we have only references to `tasks_`,
    `mutex_`, and `cond_`. This is done because objects themselves are constructed
    in the shared memory. So, `work_queue` may only store references in them.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*非常简单，只是`tasks_`、`mutex_`和`cond_`只有引用。这是因为对象本身是在共享内存中构造的。所以，`work_queue`只能在其中存储引用。'
- en: In *step 5,* we are initializing members. This code must be familiar to you.
    We were doing exactly the same things in the previous recipe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们正在初始化成员。这段代码对你来说一定很熟悉。在上一个示例中，我们做了完全相同的事情。
- en: We are providing an instance of the allocator to `tasks_` while constructing
    it. That's because `allocator_t` cannot be constructed by the container itself.
    Shared memory is not destructed at the exit event of a process, so we may run
    the program once, post the tasks to a work queue, stop the program, start some
    other program, and get tasks stored by the first instance of the program. Shared
    memory is destroyed only at restart, or if you explicitly call `segment.deallocate("work-queue");`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造`tasks_`时，我们提供了一个分配器的实例。这是因为`allocator_t`不能由容器本身构造。共享内存在进程退出事件时不会被销毁，所以我们可以运行程序一次，将任务发布到工作队列，停止程序，启动其他程序，并获取由第一个程序实例存储的任务。共享内存只有在重新启动时才会被销毁，或者如果你显式调用`segment.deallocate("work-queue");`。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As was already mentioned in the previous recipe, C++17 has no classes from `Boost.Interprocess`.
    Moreover, you must not use C++17 or C++03 containers in shared memory segments.
    Some of those containers may work, but that behavior is not portable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的内容中已经提到的，C++17 没有 `Boost.Interprocess` 中的类。此外，不得在共享内存段中使用 C++17 或 C++03
    容器。其中一些容器可能有效，但这种行为不具有可移植性。
- en: 'If you look inside some of the `<boost/interprocess/containers/*.hpp>` headers,
    you''ll find that they just use containers from the `Boost.Containers` library:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一些 `<boost/interprocess/containers/*.hpp>` 头文件，你会发现它们只是使用了 `Boost.Containers`
    库中的容器：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Containers of `Boost.Interprocess` have all the benefits of the `Boost.Containers`
    library, including rvalue references and their emulation on older compilers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Interprocess` 的容器具有 `Boost.Containers` 库的所有优点，包括右值引用及其在旧编译器上的模拟。'
- en: A `Boost.Interprocess` is the fastest solution for communication of processes
    that are running on the same machine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Interprocess` 是在同一台机器上运行的进程之间进行通信的最快解决方案。'
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using pointers in shared memory* recipe
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在共享内存中使用指针* 的方法'
- en: Read [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*,* *Multithreading*,
    for more information about synchronization primitives and multithreading
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读 [第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)*,* *多线程*，了解更多关于同步原语和多线程的信息
- en: 'Refer to Boost''s official documentation of the `Boost.Interprocess` library
    for more examples and information; it is available at the following link: [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `Boost.Interprocess` 库的更多示例和信息，请参考 Boost 官方文档；可在以下链接找到：[http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
- en: Using pointers in a shared memory
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在共享内存中使用指针
- en: 'It is hard to imagine writing some low-level C++ core classes without pointers.
    Pointers and references are everywhere in C++, and they do not work in shared
    memory! So, if we have a structure like this in shared memory and assign the address
    of some integer variable in shared memory to `pointer_`, the `pointer_` would
    be invalid in other process:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象在没有指针的情况下编写一些低级别的 C++ 核心类。指针和引用在 C++ 中随处可见，但它们在共享内存中无法使用！因此，如果我们在共享内存中有这样的结构，并将共享内存中某个整数变量的地址分配给
    `pointer_`，那么 `pointer_` 在其他进程中将无效：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How can we fix that?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何修复这个问题？
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous recipe is required for understanding this one. The example requires
    linking against the runtime system library `rt` on some platforms.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 理解前面的内容是理解这个的前提。在某些平台上，示例需要链接运行时系统库 `rt`。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Fixing it is very simple; we need only to replace the pointer with `offset_ptr<>`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 修复很简单；我们只需要用 `offset_ptr<>` 替换指针：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we are free to use it like a usual pointer:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像使用普通指针一样自由使用它：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We cannot use pointers in shared memory because, when a piece of shared memory
    is mapped into the address space of a process, its address is valid only for that
    process. When we are getting the address of a variable, it is just a local address
    for that process. Other processes will map shared memory to a different base address,
    and as a result, the variable address differs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在共享内存中使用指针，因为当共享内存的一部分映射到进程的地址空间时，其地址仅对该进程有效。当我们获取变量的地址时，它只是该进程的本地地址。其他进程将共享内存映射到不同的基地址，因此变量地址会有所不同。
- en: '![](img/00019.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: So, how can we work with an address that is always changing? There is a trick!
    As the pointer and structure are in the same shared memory segment, the distance
    between them does not change. The idea behind `boost::interprocess::offset_ptr`
    is to remember that distance between `offset_ptr` and the pointed value. On deference,
    `offset_ptr` adds the distance value to the process-dependent address of the `offset_ptr`
    variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理始终在变化的地址？有一个技巧！由于指针和结构位于同一共享内存段中，它们之间的距离不会改变。`boost::interprocess::offset_ptr`
    的想法是记住 `offset_ptr` 和指向值之间的距离。在解引用时，`offset_ptr` 将距离值添加到 `offset_ptr` 变量的进程相关地址上。
- en: The offset pointer imitates the behavior of pointers, so it is a drop-in replacement
    that can be applied quickly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移指针模拟了指针的行为，因此可以快速应用替换。
- en: Do not place the classes that may have pointers or references into shared memory!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将可能包含指针或引用的类放入共享内存中！
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An offset pointer works slightly slower than the usual pointer because, on each
    dereference, it is required to compute the address. But, this difference is not
    usually what should bother you.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移指针的工作速度略慢于通常的指针，因为每次解引用都需要计算地址。但是，这种差异通常不应该让你担心。
- en: C++17 has no offset pointers.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 没有偏移指针。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation contains many examples and more advanced `Boost.Interprocess`
    features; it is available at [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 官方文档包含许多示例和更高级的 `Boost.Interprocess` 功能；可在 [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)
    找到
- en: The *Fastest way to read files* recipe contains information about some nontraditional
    usage of the `Boost.Interprocess` library
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最快的文件读取方法* 的方法包含了 `Boost.Interprocess` 库的一些非传统用法的信息'
- en: The fastest way to read files
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件的最快方法
- en: 'All around the Internet, people are asking *"What is the fastest way to read
    files?"*. Let''s make our task for this recipe even harder: what is the fastest
    and portable way to read binary files?'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，人们一直在问“读取文件的最快方法是什么？”让我们让这个问题更加困难：读取二进制文件的最快和可移植的方法是什么？
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and the `std::fstream` is required for this recipe.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法需要基本的 C++ 知识和 `std::fstream`。
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The technique from this recipe is widely used by applications critical to input
    and output performance. It''s the fastest way to read files:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法广泛用于对输入和输出性能要求严格的应用程序。这是读取文件的最快方法：
- en: 'We need to include two headers from the `Boost.Interprocess` library:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包括 `Boost.Interprocess` 库中的两个头文件：
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we need to open a file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要打开一个文件：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The main part of this recipe is mapping all the files to memory:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个食谱的主要部分是将所有文件映射到内存中：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Getting a pointer to the data in the file:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件中数据的指针：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'That''s it! Now, we may work with a file just like with a usual memory:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，我们可以像处理常规内存一样处理文件：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All popular operating systems have the ability to map a file to processes' address
    space. After such mapping is done, the process may work with those addresses just
    like with a usual memory. The operating system takes care of all the file operations,
    such as caching and read ahead.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流行的操作系统都具有将文件映射到进程地址空间的能力。在这样的映射完成后，进程可以像处理常规内存一样处理这些地址。操作系统会处理所有文件操作，如缓存和预读。
- en: Why is it faster than traditional read/writes? That's because in most cases
    read/write is implemented as memory mapping and copying data to a user-specified
    buffer. So, read usually does a little bit more than memory map.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它比传统的读/写更快？这是因为在大多数情况下，读/写是作为内存映射和将数据复制到用户指定的缓冲区来实现的。因此，读取通常比内存映射多做一点。
- en: Just like in the case of standard library's `std::fstream`, we must provide
    an open mode when opening a file. See *step 2* where we provided the `boost::interprocess::read_only`
    mode.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标准库的`std::fstream`一样，在打开文件时必须提供打开模式。请参阅*步骤2*，我们在那里提供了`boost::interprocess::read_only`模式。
- en: See *step 3* where we mapped a whole file at once. This operation is actually
    really fast, because OS does not read data from the disk, but waits for requests
    to a part of the mapped region. After a part of the mapped region was requested,
    the OS loads that part of the file from the disk into the memory. As we may see,
    memory mapping operations are lazy, and the size of the mapped region does not
    affect performance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*步骤3*，我们在那里一次映射了整个文件。这个操作实际上非常快，因为操作系统不会从磁盘读取数据，而是等待对映射区域的请求。在请求了映射区域的一部分后，操作系统将该文件的那部分加载到内存中。正如我们所看到的，内存映射操作是懒惰的，并且映射区域的大小不会影响性能。
- en: However, a 32-bit OS cannot memory-map big files, so you have to map them by
    pieces. POSIX (Linux) operating systems require the `_FILE_OFFSET_BITS=64` macro
    to be defined for the whole project to work with big files on a 32-bit platform.
    Otherwise, the OS won't be able to map parts of the file that are beyond 4 GB.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，32位操作系统无法内存映射大文件，因此您必须按部就班地映射它们。POSIX（Linux）操作系统要求在32位平台上处理大文件时定义`_FILE_OFFSET_BITS=64`宏。否则，操作系统将无法映射超过4GB的文件部分。
- en: 'Now, it''s time to measure the performance:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测量性能了：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Just as it was expected, memory-mapped files are slightly faster than traditional
    reads. We may also see that pure C methods have the same performance as the C++
    `std::ifstream` class, so do not use functions related to `FILE*` in C++. They
    are just for C, not for C++!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，内存映射文件比传统读取稍快。我们还可以看到纯C方法与C++的`std::ifstream`类具有相同的性能，因此不要在C++中使用与`FILE*`相关的函数。它们只适用于C，而不适用于C++！
- en: 'For optimal performance of `std::ifstream`, do not forget to open files in
    binary mode and read data by blocks:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得`std::ifstream`的最佳性能，请不要忘记以二进制模式打开文件并按块读取数据：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, classes for memory mapping files are not a part of C++17 and
    looks like they won't be in C++20 either.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，用于内存映射文件的类不是C++17的一部分，看起来它们在C++20中也不会是。
- en: Writing to memory-mapped regions is also a very fast operation. The OS caches
    the writes and does not flush modifications to the disc immediately. There is
    a difference between OS and the `std::ofstream` data caching. In case the `std::ofstream`
    data is cached by an application and if it terminates, the cached data can be
    lost. When data is cached by the OS, termination of the application does not lead
    to data loss. Power failures and OS crashes lead to data loss in both cases.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 写入内存映射区域也是一个非常快的操作。操作系统会缓存写入操作，并不会立即将修改刷新到磁盘。操作系统和`std::ofstream`数据缓存之间存在差异。如果`std::ofstream`数据由应用程序缓存，并且应用程序终止，则缓存的数据可能会丢失。当数据由操作系统缓存时，应用程序的终止不会导致数据丢失。断电和操作系统崩溃都会导致数据丢失。
- en: If multiple processes map a single file, and one of the processes modifies the
    mapped region, changes are immediately visible to other processes (even without
    actually writing the data to disk! Modern OS are very clever!).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个进程映射单个文件，并且其中一个进程修改了映射区域，则其他进程立即看到更改（甚至无需实际将数据写入磁盘！现代操作系统非常聪明！）。
- en: See also
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The `Boost.Interprocess` library contains a lot of useful features to work
    with the system; not all of them are covered in this book. You may read more about
    this great library at the official site: [http://boost.org/libs/interprocess](http://boost.org/libs/interprocess).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Interprocess`库包含许多有用的功能，用于与系统一起工作；并非所有功能都在本书中涵盖。您可以在官方网站上阅读有关这个伟大库的更多信息：[http://boost.org/libs/interprocess](http://boost.org/libs/interprocess)。'
- en: Coroutines - saving the state and postponing the execution
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程-保存状态和推迟执行
- en: Nowadays, plenty of embedded devices still have only a single core. Developers
    write for those devices, trying to squeeze maximum performance out of them.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多嵌入式设备仍然只有一个核心。开发人员为这些设备编写代码，试图从中挤取最大的性能。
- en: Using `Boost.Threads` or some other thread library for such devices is not effective.
    The OS will be forced to schedule threads for execution, manage resources, and
    so on, as the hardware cannot run them in parallel.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些设备使用`Boost.Threads`或其他线程库并不有效。操作系统将被迫调度线程进行执行，管理资源等，因为硬件无法并行运行它们。
- en: So, how can we force a program to switch to the execution of a subprogram while
    waiting for some resource in the main part? Moreover, how can we control the time
    of the subprogram's execution?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何强制程序在等待主程序的某些资源时切换到子程序的执行？此外，我们如何控制子程序的执行时间？
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and templates is required for this recipe. Reading some
    recipes about `Boost.Function` may also help.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱需要基本的C++和模板知识。阅读一些关于`Boost.Function`的食谱也可能有所帮助。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: This recipe is about **coroutines** or **subroutines** that allow multiple entry
    points. Multiple entry points give us an ability to suspend and resume the execution
    of a program at certain locations, switching to/from other subprograms.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程是关于**协程**或**子程序**，允许多个入口点。多个入口点使我们能够在特定位置暂停和恢复程序的执行，切换到/从其他子程序。
- en: 'The `Boost.Coroutine2` library takes care of almost everything. We just need
    to include its header:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Coroutine2`库几乎负责一切。我们只需要包含它的头文件：'
- en: '[PRE56]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Make a coroutine type with the required input parameter type:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有所需输入参数类型的协程类型：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Make a class, representing a subprogram:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示子程序的类：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s create the coroutine itself:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建协程本身：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we may execute the subprogram while waiting for some event in the main
    program:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在主程序中等待某个事件的同时执行子程序：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The coroutine method may look like this:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程方法可能如下所示：
- en: '[PRE61]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `tick()` function could be implemented like this:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tick()`函数可以这样实现：'
- en: '[PRE62]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At *step 2*, we are describing the input parameter of our subprogram using the
    `std::size_t` as a template parameter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们使用`std::size_t`作为模板参数描述了子程序的输入参数。
- en: '*Step 3* is pretty simple, except for the `corout_t::pull_type& yield` parameters.
    We''ll see it in action in a few seconds.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*相当简单，除了`corout_t::pull_type& yield`参数。我们马上就会看到它的作用。'
- en: When we call `coroutine(10)` in *step 5*, we are making a coroutine program
    to execute. Execution jumps to `coroutine_task::operator()`, where a call to `yield.get()`
    returns the input parameter `10`. The execution continues and the `coroutine_task::tick`
    function measures elapsed ticks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*步骤5*中调用`coroutine(10)`时，我们正在执行一个协程程序。执行跳转到`coroutine_task::operator()`，在那里调用`yield.get()`返回输入参数`10`。执行继续进行，`coroutine_task::tick`函数测量经过的滴答声。
- en: Here comes the most interesting part!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分来了！
- en: In *step 7,* if in function `coroutine_task::tick` the `ticks_to_work` variable
    becomes equal to `0`, the execution of the coroutine suspends at `yield()` and
    `main()` continues execution. On the next call to `coroutine(some_value)`, the
    execution of the coroutine continues from the middle of the `tick` function, right
    at the line next to `yield()`. In that line, `ticks_to_work = yield.get();` is
    executed and the `ticks_to_work` variable starts to hold a new input value `some_value`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，如果在函数`coroutine_task::tick`中`ticks_to_work`变量变为`0`，协程的执行将在`yield()`处暂停，而`main()`继续执行。在下一次调用`coroutine(some_value)`时，协程的执行将从`tick`函数的中间位置继续，就在`yield()`旁边的行。在那一行，`ticks_to_work
    = yield.get();`被执行，`ticks_to_work`变量开始保存一个新的输入值`some_value`。
- en: 'It means that we can suspend/continue the coroutine in multiple places of the
    function. All the function state and variables are restored:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在函数的多个位置暂停/继续协程。所有函数状态和变量都会被恢复：
- en: '![](img/00020.jpeg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: Let me describe the main difference between coroutines and threads. When a coroutine
    is executed, the main task does nothing. When the main task is executed, the coroutine
    task does nothing. You have no such guarantee with threads. With coroutines, you
    explicitly specify when to start a subtask and when to suspend it. In a single
    core environment, threads may switch at any moment; you cannot control that behavior.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我描述一下协程和线程之间的主要区别。当执行协程时，主任务什么也不做。当执行主任务时，协程任务什么也不做。使用线程时，您没有这样的保证。使用协程，您明确指定何时启动子任务以及何时暂停它。在单核环境中，线程可能随时切换；您无法控制这种行为。
- en: There's more...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While switching threads, the OS does a lot of work, so it is not a very fast
    operation. However, with coroutines, you have full control over switching tasks;
    moreover, you do not need to do some OS-specific internal kernel work. Switching
    coroutines is much faster than switching threads, although, not as fast as calling
    `boost::function`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换线程时，操作系统会做很多工作，因此这不是一个非常快的操作。然而，使用协程，您可以完全控制切换任务；此外，您不需要执行一些特定于操作系统的内部内核工作。切换协程比切换线程快得多，尽管不像调用`boost::function`那样快。
- en: The `Boost.Coroutine2` library takes care about calling a destructor for variables
    in a coroutine task, so there's no need to worry about leaks.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Coroutine2`库负责调用协程任务中变量的析构函数，因此无需担心泄漏。'
- en: Coroutines use the `boost::coroutines2::detail::forced_unwind` exception to
    free resources that are not derived from `std::exception`. You must take care
    to not catch that exception in coroutine tasks.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 协程使用`boost::coroutines2::detail::forced_unwind`异常来释放不是从`std::exception`派生的资源。您必须小心不要在协程任务中捕获该异常。
- en: You cannot copy `Boost.Coroutine2` coroutines, but you can `std::move` them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能复制`Boost.Coroutine2`协程，但可以`std::move`它们。
- en: There is a `Boost.Coroutine` library (without `2` at the end!), that does not
    require a C++11 compatible compiler. But that library is deprecated and has some
    differences (for example it does not propagate exceptions from coroutines). Beware
    of the differences! `Boost.Coroutine` also changed its interface significantly
    in Boost 1.56.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`Boost.Coroutine`库（末尾没有`2`！），它不需要C++11兼容的编译器。但是该库已经被弃用，并且有一些区别（例如它不会从协程中传播异常）。注意区别！`Boost.Coroutine`在Boost
    1.56中也显著改变了其接口。
- en: C++17 has no coroutines. But **Coroutines TS** is almost ready, so the chances
    are high that next C++ standard will have them out of the box.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有协程。但**协程TS**几乎准备就绪，所以很有可能下一个C++标准将直接包含它们。
- en: Coroutines TS differs from `Boost.Coroutine2`! Boost provides **stackful** coroutines,
    which means that you do not need to specially decorate your code with macro/keywords
    to use them. But it also means that Boost coroutines are harder to optimize by
    the compiler and that they may allocate more memory. Coroutines TS provides **stackless**
    coroutines, which means that compiler could precisely compute the required memory
    for a coroutine and even optimize out the whole coroutine. However, this approach
    requires code changes and may be slightly harder to adopt.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 协程 TS 与 `Boost.Coroutine2` 不同！Boost 提供了 **有栈** 协程，这意味着您不需要特别使用宏/关键字来使用它们。但这也意味着
    Boost 协程更难被编译器优化，并且可能分配更多内存。协程 TS 提供了 **无栈** 协程，这意味着编译器可以精确计算协程所需的内存，甚至可以优化整个协程。然而，这种方法需要代码更改，可能稍微难以采用。
- en: See also
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost's official documentation contains more examples, performance notes, restrictions,
    and use cases for the `Boost.Coroutines2` library; it is available at the following
    link [http://boost.org/libs/coroutine2](http://boost.org/libs/coroutine2)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost 的官方文档包含了更多关于 `Boost.Coroutines2` 库的示例、性能说明、限制和用例；请访问以下链接 [http://boost.org/libs/coroutine2](http://boost.org/libs/coroutine2)
- en: Take a look at recipes from [Chapter 2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Managing Resources*, and [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, to get the difference between the `Boost.Coroutine`, `Boost.Thread`,
    and `Boost.Function` libraries
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[第2章](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd)的示例，*资源管理*，以及[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)，*多线程*，了解
    `Boost.Coroutine`、`Boost.Thread` 和 `Boost.Function` 库之间的区别
- en: 'Interested in Coroutines TS? Here''s an interesting talk on their implementation
    from the author *CppCon 2016: Gor Nishanov. C++ Coroutines: Under the covers*
    at [https://www.youtube.com/watch?v=8C8NnE1Dg4A](https://www.youtube.com/watch?v=8C8NnE1Dg4A)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对 Coroutines TS 感兴趣吗？这里有一场有趣的关于作者 Gor Nishanov 的实现讨论 *CppCon 2016: Gor Nishanov.
    C++ Coroutines: Under the covers*，链接在 [https://www.youtube.com/watch?v=8C8NnE1Dg4A](https://www.youtube.com/watch?v=8C8NnE1Dg4A)'
