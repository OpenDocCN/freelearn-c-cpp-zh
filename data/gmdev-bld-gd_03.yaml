- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Adding and Creating Textures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和创建纹理
- en: In a typical 3D workflow, one of the most common properties you would add to
    a material is texture. A **texture** is an image file that is responsible for
    the textured look of a model so surfaces don’t show just flat colors. Although
    objects you come across in real life have a perceived color, they also have a
    characteristic look that is defined by this property in 3D applications. For example,
    both a flower and a sandy surface may have a yellow color, but you know a flower’s
    petal would look smoother, whereas grains of sand would look gritty.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的3D工作流程中，你可能会添加到材质中最常见的属性之一就是纹理。**纹理**是一个图像文件，它负责模型的纹理外观，使得表面不会只显示单色。尽管你在现实生活中遇到的物体有感知到的颜色，但它们也有由3D应用程序中此属性定义的特征外观。例如，一朵花和沙质表面可能都有黄色，但你都知道花朵的花瓣看起来会更光滑，而沙粒则会显得粗糙。
- en: Most day-to-day objects have wear and tear. Look around and you’ll see that
    most surfaces will either have chipped paint, a slight deformation, or some scratches.
    Imagine the barrel you designed in the first two chapters has been in use for
    some time. It’d naturally have a few scratches on the metal rings. You can only
    go so far by applying colors to your materials and altering the roughness values.
    If you want to achieve a more realistic look, you’ve got to apply textures to
    your models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数日常物品都有磨损和损坏。看看四周，你会发现大多数表面要么有剥落的油漆，轻微的变形，或者一些划痕。想象一下你在前两章中设计的桶已经使用了一段时间。它自然会在金属环上有一些划痕。你只能通过为你的材质应用颜色和改变粗糙度值来做到这一点。如果你想达到更逼真的效果，你必须为你的模型应用纹理。
- en: Some 3D professionals only focus and gain expertise on certain domains. Texturing
    is one of these domains besides modeling, lighting, and animation. Typically,
    a texturing specialist will employ the help of classic image editing applications
    such as *Adobe Photoshop*, *GIMP*, and so on to create textures. Then, the artist
    will bring these textures into Blender so that they can be applied to surfaces.
    If you are not skilled in creating textures from scratch, you will learn in this
    chapter how you can still rely on existing textures out there created by other
    artists.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一些3D专业人士只专注于某些领域并在此领域获得专业知识。纹理化就是这些领域之一，除了建模、照明和动画之外。通常，纹理化专家会使用经典图像编辑应用程序，如
    *Adobe Photoshop*、*GIMP* 等，来创建纹理。然后，艺术家会将这些纹理带入Blender，以便它们可以应用于表面。如果你不擅长从头开始创建纹理，你将在本章中学习如何仍然依赖其他艺术家创建的现有纹理。
- en: Preparing and using textures with the aforementioned workflow often sounds static
    because you need access to the source file of these textures. Luckily, there is
    a dynamic way to create your own textures within Blender, so you don’t have to
    go back and forth between Blender and other software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述工作流程准备和使用纹理通常听起来很静态，因为你需要访问这些纹理的源文件。幸运的是，在Blender中有一个动态的方式来创建你自己的纹理，这样你就不必在Blender和其他软件之间来回切换。
- en: 'This is not a “one is better than the other” situation because each method
    has its own place and merits. You’ll get to know new parts of Blender to facilitate
    both methods so you can make an informed decision about which texturing method
    to use. To that end, we are going to cover the following list of topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是“一个比另一个更好”的情况，因为每种方法都有其自己的位置和优点。你将了解Blender的新部分，以促进这两种方法，这样你可以就使用哪种纹理方法做出明智的决定。为此，我们将涵盖以下主题列表：
- en: Understanding UVs and texture coordinates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解UV和纹理坐标
- en: Using the UV Editor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UV编辑器
- en: Importing and applying a texture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和应用纹理
- en: Creating textures procedurally
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以程序方式创建纹理
- en: Exporting your textures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出你的纹理
- en: By the end of this chapter, you’ll have learned how to prepare your models for
    texturing, apply available textures, and create your own textures dynamically.
    The practice you’ll gain in this chapter will give you insight into choosing the
    right method of texturing for your projects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何为纹理准备你的模型，应用可用的纹理，并动态地创建自己的纹理。你在本章中获得的经验将帮助你了解为你的项目选择正确的纹理方法。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book’s GitHub repo ([https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot))
    will have a `Chapter 3` folder with `Start` and `Finish` folders in it for you
    to compare your work with as you go. These folders also contain other dependencies
    such as the texture files necessary to follow and complete the exercises.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库([https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot](https://github.com/PacktPublishing/Game-Development-with-Blender-and-Godot))将有一个包含`Start`和`Finish`文件夹的`Chapter
    3`文件夹，你可以用来在过程中比较你的工作。这些文件夹还包含其他依赖项，例如必要的纹理文件，以便跟随和完成练习。
- en: Although you worked on a barrel in the previous chapters, we’ll only use the
    standard Blender objects, such as a cube and a plane, to keep things simple so
    you can focus on the texturing workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你在前面的章节中工作过桶，但我们将只使用标准的Blender对象，如立方体和平面，以保持事情简单，这样你可以专注于纹理流程。
- en: Understanding UVs and texture coordinates
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解UV和纹理坐标
- en: While you are modeling, you are altering the coordinates of the vertices of
    a model. Thus, you are working with spatial coordinates. To apply a texture over
    your model, you need to work in a different kind of coordinate system that is
    called **texture coordinates** or **UVs**. Let’s see how these two terms relate
    to each other.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在建模时，你正在改变模型顶点的坐标。因此，你正在使用空间坐标。要给你的模型应用纹理，你需要在一个不同的坐标系中工作，这个坐标系被称为**纹理坐标**或**UVs**。让我们看看这两个术语是如何相互关联的。
- en: The spatial coordinate system is often described with the **XYZ** acronym since
    we often use X, Y, and Z axes to define the position of 3D objects. Similarly,
    **UV** is another acronym but it is used in the texturing workflow; the letters
    U and V were picked to describe the texture coordinate system. So, UV doesn’t
    really stand for ultraviolet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 空间坐标系通常用**XYZ**这个缩写来描述，因为我们经常使用X、Y和Z轴来定义3D对象的位置。同样，**UV**也是一个缩写，但它用于纹理流程中；字母U和V被选中来描述纹理坐标系。所以，UV并不真正代表紫外线。
- en: 'The process that maps UV coordinates to XYZ coordinates is called **UV unwrapping**.
    Via this method, you tell Blender how a graphic file is mapped to XYZ coordinates.
    If unwrapping sounds counterintuitive, you could try to reverse the process in
    your mind. What kind of texture would you need so that if you wrapped it around
    your 3D model, it would fit perfectly? Let’s analyze the following figure where
    a graphic file that is painted with a checkerboard texture is applied to a standard
    cube:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将UV坐标映射到XYZ坐标的过程被称为**UV展开**。通过这种方法，你告诉Blender如何将图形文件映射到XYZ坐标。如果你觉得展开过程不太直观，你可以在心里尝试逆转这个过程。你需要什么样的纹理，如果把它包裹在你的3D模型周围，它能够完美地贴合？让我们分析以下图例，其中有一个用棋盘纹理画出的图形文件被应用到标准立方体上：
- en: '![Figure 3.1 – A 2D checkerboard texture wrapping a 3D object ](img/Figure_3.01_B17473.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 一个2D棋盘纹理包裹3D对象](img/Figure_3.01_B17473.jpg)'
- en: Figure 3.1 – A 2D checkerboard texture wrapping a 3D object
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 一个2D棋盘纹理包裹3D对象
- en: In *Figure 3.1*, you see a cube with a checkerboard texture on the left. In
    the middle part, you see the cube as if gift wrap is being peeled off. Finally,
    the cube is fully unwrapped on the right side; its texture is laid flat. The texture
    file is actually all of the checkerboard parts, and it exists as a 2D graphic
    file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.1*中，你看到左边的立方体有一个棋盘纹理。在中间部分，你看到立方体就像礼物包装被剥去一样。最后，立方体在右侧完全展开；其纹理被平铺。纹理文件实际上是所有的棋盘部分，它作为一个2D图形文件存在。
- en: The reason we are using words such as unwrapping and 2D graphic files is because
    we are simulating a real-life 3D object on a flat screen. In reality, that cube
    would occupy a space, have a volume, and it would be full of the material it was
    made of. For example, a cube that might be a child’s toy made of wood. Or, it
    might be a six-sided die, most likely made of acrylic. If you cut into it, you’d
    see the material.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用诸如展开和2D图形文件之类的词语，是因为我们在一个平面上模拟现实生活中的3D对象。实际上，那个立方体会占据空间，有体积，并且会充满它所制成的材料。例如，一个可能是由木头制成的儿童玩具立方体。或者，它可能是一个六面骰子，很可能是用亚克力制成的。如果你切开它，你会看到材料。
- en: To change the nature of the problem from a 3D volume problem to a 2D graphics
    problem, you need a new tool. You’ve been working with Blender’s default interface,
    which is conveniently set up to edit XYZ coordinates. For editing UVs, you need
    the **UV Editor**, which you will discover in the following section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要将问题从三维体积问题转换为二维图形问题，你需要一个新的工具。你一直在使用Blender的默认界面，该界面方便地设置为编辑XYZ坐标。对于编辑UV，你需要**UV编辑器**，你将在下一节中找到它。
- en: Using the UV Editor
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UV编辑器
- en: Blender comes with preset workspaces so you can focus on a particular workflow.
    So far, you’ve been in the **Layout** workspace. You can see it as the active
    tab just under the header of the application, next to the **Help** menu. You should
    create a new file and switch to the **UV Editing** workspace by clicking the appropriate
    tab. *Figure 3.2* is what you’ll see when you are in the **UV Editing** workspace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Blender自带预设的工作区，这样你可以专注于特定的工作流程。到目前为止，你一直处于**布局**工作区。你可以将其视为位于应用程序标题下方、紧邻**帮助**菜单的激活标签。你应该创建一个新文件，并通过点击相应的标签切换到**UV编辑**工作区。*图3.2*是你处于**UV编辑**工作区时看到的。
- en: '![Figure 3.2 – UV Editing is one of many default workspaces in Blender ](img/Figure_3.02_B17473.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – UV编辑是Blender中许多默认工作区之一](img/Figure_3.02_B17473.jpg)'
- en: Figure 3.2 – UV Editing is one of many default workspaces in Blender
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – UV编辑是Blender中许多默认工作区之一
- en: 'In the **UV Editing** workspace, the application will mainly be divided into
    two sections: the left side, which is called **UV Editor**, shows a bunch of squares
    laid out on a flat surface, and the right side shows the default cube. The black
    dots you see in **UV Editor** are actually the vertices of the cube in **3D Viewport**.
    You might notice that if you counted the dots in **UV Editor**, they don’t add
    up to the number of vertices the cube has. There are more points in **UV Editor**
    because some of those points will eventually merge once those squares in **UV
    Editor** are folded around the edges and wrapped around your 3D object.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在**UV编辑**工作区中，应用程序将主要分为两个部分：左侧被称为**UV编辑器**，显示在平坦表面上排列的一组正方形，右侧显示默认的立方体。你在**UV编辑器**中看到的黑色点实际上是**3D视图**中立方体的顶点。你可能注意到，如果你在**UV编辑器**中计数点，它们并不等于立方体的顶点数。在**UV编辑器**中有更多的点，因为其中一些点最终会在**UV编辑器**中的正方形折叠到边缘并围绕你的3D对象包裹时合并。
- en: At this point, all of the vertices of the cube should be selected for you by
    Blender. However, if you happen to select a vertex of the cube, you’ll see that
    the squares in **UV Editor** will disappear. That’s because we haven’t turned
    on the **sync** mode yet. At the top-left corner of **UV Editor**, you’ll see
    a button with an icon that looks like two diagonal arrows going in opposite directions.
    If you have that button pressed, you’ll notice that selecting the vertices in
    either view will synchronize.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Blender应该已经为你选择了立方体的所有顶点。然而，如果你不小心选中了立方体的一个顶点，你会看到**UV编辑器**中的正方形会消失。这是因为我们还没有打开**同步**模式。在**UV编辑器**的左上角，你会看到一个图标看起来像两个对角箭头朝相反方向移动的按钮。如果你按下了这个按钮，你会注意到在任一视图中选择顶点都会同步。
- en: When you add a new cube, Blender unwraps that cube by default. The general layout
    of the vertices in **UV Editor** resembles a T shape, like what you saw in *Figure
    3.1*. Similar to **3D Viewport**, the vertices in **UV Editor** will form edges
    and faces, but it’s all 2D in **UV Editor**. As mentioned earlier, we have converted
    the 3D-ness of the model to a 2D representation so we can work with graphics files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加一个新的立方体时，Blender默认会展开该立方体。在**UV编辑器**中顶点的一般布局类似于一个T形，就像你在*图3.1*中看到的那样。类似于**3D视图**，**UV编辑器**中的顶点将形成边和面，但在**UV编辑器**中都是二维的。如前所述，我们已经将模型的3D特性转换为二维表示，这样我们就可以处理图形文件。
- en: '**UV Editor** is where you can see how the points in the editor map or correlate
    to a texture file. To do that, we need to bring a texture file as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**UV编辑器**是你可以看到编辑器中的点如何映射或关联到纹理文件的地方。为了做到这一点，我们需要按照以下方式引入一个纹理文件：'
- en: Open the `Chapter 3` folder.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`第3章`文件夹。
- en: Open the `Start` folder.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`开始`文件夹。
- en: Drag and drop `pips.png` into the **UV Editor** area.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`pips.png`拖放到**UV编辑器**区域。
- en: If you open that PNG file in your computer’s default image viewing application,
    you’ll notice that it has transparent parts. Its dimensions of 1024x1024 are not
    fully painted. It just happens that the file’s non-transparent areas come right
    under the faces in **UV Editor**, therefore the faces in **3D Viewport**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在计算机的默认图像查看应用程序中打开那个PNG文件，您会注意到它有透明部分。它的1024x1024的尺寸并没有完全上色。恰好文件的非透明区域正好位于**UV编辑器**中的面上，因此**3D视图**中的面。
- en: Powers of two
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 2的幂次方
- en: Sooner or later, you’ll notice that most texture files come in certain standard
    dimensions such as 512, 1024, 2048, and so on. Although these files don’t have
    to be square, which means you could actually have 256x512 as dimensions, it’d
    still pay off to keep either dimension in powers of two. This is due to algorithms
    that are employed by GPUs so that they run more efficiently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是早是晚，您都会注意到大多数纹理文件都采用某些标准尺寸，如512、1024、2048等。尽管这些文件不必是正方形，这意味着您实际上可以有256x512的尺寸，但仍然值得将任一维度保持在2的幂次方。这是由于GPU使用的算法，以便它们运行得更有效率。
- en: So far, we have taken advantage of Blender’s default UV layout for a cube and
    have seen how UV faces can overlap with the texture file we have been previewing
    in **UV Editor**. However, if you enable **Material Preview** in **3D Viewport**,
    you won’t see the die texture applied to the cube. That’s because we haven’t yet
    told Blender to use the die texture in the material assigned to the cube. Let’s
    do that in the following section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经利用了Blender为立方体提供的默认UV布局，并看到了UV面如何与我们在**UV编辑器**中预览的纹理文件重叠。然而，如果您在**3D视图**中启用**材质预览**，您将看不到应用于立方体的骰子纹理。这是因为我们还没有告诉Blender在分配给立方体的材质中使用骰子纹理。让我们在下一节中这样做。
- en: Importing and applying a texture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入和应用纹理
- en: When you've dragged the texture file into **UV Editor**, you have effectively
    imported it, but, in reality, the material for the cube doesn’t know how to use
    that texture yet. That being said, the material has all of the information it
    needs to map 3D vertices to 2D texture coordinates thanks to **UV Editor**. It
    just needs to be told which texture to apply to the cube.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将纹理文件拖动到**UV编辑器**中时，您实际上已经导入了它，但事实上，立方体的材质还不知道如何使用那个纹理。也就是说，由于**UV编辑器**，材质已经拥有了将3D顶点映射到2D纹理坐标所需的所有信息。它只需要被告知要将哪个纹理应用于立方体。
- en: To accomplish this, we’ll switch to a new workspace so we can connect textures
    with materials. Also, we’ll import another texture using a different method and
    assign it to the cube’s material to showcase how you can use the same UV information
    with different texture files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，我们将切换到一个新的工作空间，这样我们就可以将纹理与材质连接起来。此外，我们还将使用不同的方法导入另一个纹理，并将其分配给立方体的材质，以展示您如何使用相同的UV信息与不同的纹理文件。
- en: Just like when you switched to the **UV Editing** workspace, it’s now time to
    switch to a different workspace for convenience. The sixth workspace, labeled
    as **Shading**, is the one you are looking for. We’ll do our work in the lower
    half of the new workspace, which looks like a grid; it’s called the **Shader Editor**.
    The upper part is still the same old **3D Viewport**, but **Material Preview**
    is automatically turned on so you can see your changes reflect immediately. So,
    the **Shading** workspace should look similar to what you see in *Figure 3.3*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您切换到**UV编辑**工作空间一样，现在是时候切换到不同的工作空间以方便操作了。第六个工作空间，标记为**着色器**，就是您要找的。我们将在新工作空间的下半部分进行工作，它看起来像是一个网格；它被称为**着色器编辑器**。上半部分仍然是那个熟悉的**3D视图**，但**材质预览**已自动开启，这样您可以看到您的更改立即反映出来。因此，**着色器**工作空间应该看起来与您在*图3.3*中看到的大致相同。
- en: '![Figure 3.3 – Shading is one of many convenient workspaces set up for you
    ](img/Figure_3.03_B17473.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 着色器是为您设置的多个工作空间之一](img/Figure_3.03_B17473.jpg)'
- en: Figure 3.3 – Shading is one of many convenient workspaces set up for you
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 着色器是为您设置的多个工作空间之一
- en: 'As you discovered in [*Chapter 2*](B17473_02.xhtml#_idTextAnchor032), *Building
    Materials and Shaders*, Blender files come with a default material. We’ll modify
    that default material to understand the texture workflow. The **Shader Editor**
    area is already populated with two entities that make up the material as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第二章*](B17473_02.xhtml#_idTextAnchor032)“建筑材料和着色器”中发现的，Blender文件自带一个默认材质。我们将修改这个默认材质来了解纹理工作流程。**着色器编辑器**区域已经包含了两个实体，它们组成了以下材质：
- en: '**Principled BSDF** (**Principled** in short form)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原理BSDF**（简称**Principled**）'
- en: '**Material Output**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材质输出**'
- en: These are called nodes. The node on the left, **Principled**, holds the properties
    you already saw in the previous chapter. A lot of these properties have little
    circles on the left side. These circles, which are called sockets, can connect
    to other nodes’ sockets. We don’t have enough nodes to create meaningful connections
    yet but we will soon.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为节点。左侧的**Principled**节点包含你在上一章中已经看到的属性。许多这些属性在左侧都有小圆圈。这些被称为插座的圆圈可以连接到其他节点的插座。我们目前没有足够的节点来创建有意义的连接，但很快就会做到。
- en: Speaking of connectivity, **Principled** has an output that is connected to
    the **Material Output** node. If you hold your mouse down on the **Surface** input
    of **Material Output** and drag the connection away, you’ll eventually break the
    connection between those two nodes. Then, the cube will look black since there
    is no surface information. Try to reconnect those nodes by dragging the **BSDF**
    output to the **Surface** input. The default gray color will be reestablished.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 说到连接性，**Principled**有一个连接到**材质输出**节点的输出。如果你按住鼠标在**材质输出**的**表面**输入上并拖动连接，你最终会断开这两个节点之间的连接。然后，立方体将看起来是黑色的，因为没有表面信息。尝试通过将**BSDF**输出拖动到**表面**输入来重新连接这些节点。默认的灰色颜色将被重新建立。
- en: Nodes vs code
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 节点与代码
- en: In the previous chapter, you were told that shaders are lines of code that instruct
    the GPU what to display. When you use nodes in **Shader Editor**, you are actually
    writing code, but you are coding visually. As the order of lines is important
    in conventional programming, the nodes and the connections coming in and out of
    the nodes are also important. However, visual programming is easier to conceptualize.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你被告知着色器是指导 GPU 显示什么的代码行。当你使用**Shader 编辑器**中的节点时，你实际上是在编写代码，但你是以可视化的方式编码。由于在传统编程中行顺序很重要，因此节点以及进出节点的连接也很重要。然而，可视化编程更容易理解。
- en: When we were modeling the barrel in [*Chapter 1*](B17473_01.xhtml#_idTextAnchor013),
    *Creating Low-Poly Models*, we needed to add 3D objects to the scene. We did that
    by pressing *Shift + A*. We’ll do something similar. In this case, we’ll add new
    nodes to **Shader Editor**. Blender is context-sensitive, which means the same
    shortcuts will yield similar results if your mouse is over different workspaces,
    areas, and interfaces. If you press *Shift + A* over **Shader Editor**, you’ll
    see a list come up and show entities that are relevant to **Shader Editor**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第 1 章*](B17473_01.xhtml#_idTextAnchor013)中建模桶时，*创建低多边形模型*，我们需要在场景中添加 3D
    对象。我们通过按*Shift + A*来实现这一点。我们将做类似的事情。在这种情况下，我们将向**Shader 编辑器**添加新的节点。Blender 是上下文相关的，这意味着如果鼠标在不同的工作区、区域和界面上方，相同的快捷键会产生类似的结果。如果你在**Shader
    编辑器**上按*Shift + A*，你会看到一个列表出现并显示与**Shader 编辑器**相关的实体。
- en: 'When this pop-up menu opens, it’s positioned exactly so that the mouse cursor
    is right over the **Search** button. To add a texture node, perform the following
    steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个弹出菜单打开时，它正好位于鼠标光标正上方**搜索**按钮的位置。要添加纹理节点，请执行以下步骤：
- en: Click **Search** in the **Add** menu.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加**菜单中点击**搜索**。
- en: Type `Image` with your keyboard.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键盘输入`Image`。
- en: Select **Image Texture** in the filtered results.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在过滤结果中选择**图像纹理**。
- en: Click anywhere near the other nodes.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他节点附近点击任意位置。
- en: 'This will introduce an **Image Texture** node to **Shader Editor**, just as
    you see in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**Shader 编辑器**中引入一个**图像纹理**节点，就像你在以下图中看到的那样：
- en: '![Figure 3.4 – An Image Texture node in Shader Editor ](img/Figure_3.04_B17473.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Shader 编辑器中的图像纹理节点](img/Figure_3.04_B17473.jpg)'
- en: Figure 3.4 – An Image Texture node in Shader Editor
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Shader 编辑器中的图像纹理节点
- en: 'You have already imported the `pips.png` file when you were working with **UV
    Editor**, so there is no need to import that file again. We’ll just recall it.
    As usual, the button to the left of the **New** button in the **Image Texture**
    node will bring up a list; select **pips.png** from that list. Then, attach the
    **Color** output of **Image Texture** to the **Base Color** input of **Principled**.
    This will apply the texture to the cube’s faces. Voilà, the default cube now looks
    like a six-sided die as seen in *Figure 3.5*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在**UV 编辑器**中工作时，已经导入了`pips.png`文件，因此无需再次导入该文件。我们只需将其调出。通常，**图像纹理**节点左侧的**新建**按钮旁边的按钮会弹出一个列表；从该列表中选择**pips.png**。然后，将**图像纹理**的**颜色**输出连接到**Principled**的**基础颜色**输入。这将纹理应用到立方体的面上。哇，默认的立方体现在看起来像*图
    3.5*中看到的六面骰子：
- en: '![Figure 3.5 – The texture file is applied to the model via its material ](img/Figure_3.05_B17473.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 纹理文件通过材质应用于模型](img/Figure_3.05_B17473.jpg)'
- en: Figure 3.5 – The texture file is applied to the model via its material
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 纹理文件通过材质应用于模型
- en: 'A six-sided die has pips, usually marked with a variable number of circles
    on each side. What if you wanted to have a different looking six-sided die, with
    the numbers represented by Roman numerals? To import and apply a new texture,
    perform the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 六面骰子有点数，通常在每面用不同数量的圆圈标记。如果你想要一个看起来不同的六面骰子，用罗马数字表示数字，会怎样？要导入并应用新的纹理，请执行以下步骤：
- en: Create a new **Image Texture** node with the help of *Shift+A*.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Shift+A*的帮助创建一个新的**图像纹理**节点。
- en: Click the **Open** button.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**按钮。
- en: Select `roman.png` in this chapter’s `Start` folder.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的`Start`文件夹中选择`roman.png`。
- en: Connect this **Image Texture** node's **Color** to the **Principled** node’s
    **Base Color**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此**图像纹理**节点的**颜色**连接到**原理**节点的**基础颜色**。
- en: Since the texture coordinates are already mapped in **UV Editor**, you can easily
    swap textures that have similar shapes with different designs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理坐标已经映射在**UV编辑器**中，你可以轻松地交换形状相似但设计不同的纹理。
- en: When you work with more complex models, you’ve got more work to do in adjusting
    the UVs; as long as the UV coordinates are aligned with the right parts of the
    texture, you’re good. However, imagine a different scenario. How would you go
    about modeling surfaces that look like they are showing a repeating pattern with
    slight deviations? In the following section, we’ll look into a different texture
    workflow.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理更复杂的模型时，你需要调整UVs的工作量就更多了；只要UV坐标与纹理的正确部分对齐，你就没问题。然而，想象一个不同的场景。你会如何建模看起来像是有轻微偏差的重复图案的表面？在下一节中，我们将探讨不同的纹理工作流程。
- en: Creating textures procedurally
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以程序方式创建纹理
- en: The word “**procedural**” has been used a lot in recent years, especially in
    the video game industry, to describe different things. Although one might say
    everything we have done so far is following a certain procedure, the word means
    something else in our context. When we imported the texture file in the preceding
    section, it was already designed for us. In other terms, it was a static file.
    The word “procedural,” on the other hand, is a fancy word that means dynamic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，“**程序化**”一词被广泛使用，尤其是在视频游戏行业中，用来描述不同的事物。尽管有人可能会说我们迄今为止所做的一切都是遵循某种程序，但在我们的语境中，这个词意味着其他含义。当我们在前一节中导入纹理文件时，它已经为我们设计好了。换句话说，它是一个静态文件。另一方面，“程序化”这个词是一个华丽的词，意味着动态。
- en: In a dynamic or procedural texturing workflow, the goal is to expose certain
    parameters of the texture so that the texture can be changed on the fly, instead
    of going back to a graphic editing application. Since it’s all dynamic, you won’t
    have to import graphic files, and you’ll be able to change aspects of the final
    texture. For example, if the six-sided die was using a procedural texture, it’d
    be like changing the color and/or the size of the pips.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态或程序化纹理工作流程中，目标是暴露纹理的某些参数，以便可以即时更改纹理，而不是返回图形编辑应用程序。由于一切都是动态的，你不需要导入图形文件，并且可以更改最终纹理的各个方面。例如，如果六面骰子使用的是程序化纹理，那么就像改变点数颜色和/或大小一样。
- en: Procedural textures have another benefit besides their dynamism. Static texture
    files would need you to do the prior UV work so that the vertices would be aligned
    with the parts of the texture. In a procedural workflow, the pattern in the texture
    might be seamless, so you don’t need to worry about the UVs. Seamless, in our
    context, means that the pattern repeats in a perfect way to wrap around the model.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序化纹理除了其动态性之外还有另一个好处。静态纹理文件需要你做之前的UV工作，以便顶点与纹理的部分对齐。在程序化工作流程中，纹理中的图案可能是无缝的，因此你不必担心UVs。在我们的语境中，“无缝”意味着图案以完美的方式重复，以包裹模型。
- en: We’ll create a procedural lava texture as you see in *Figure 3.6* in Blender
    so you can change its parameters to have a different looking texture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Blender中创建一个程序化熔岩纹理，就像你在*图3.6*中看到的那样，这样你可以更改其参数以获得不同的纹理外观。
- en: '![Figure 3.6 – Hot lava flowing through solidified crust ](img/Figure_3.06_B17473.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 热熔岩流过凝固的地壳](img/Figure_3.06_B17473.jpg)'
- en: Figure 3.6 – Hot lava flowing through solidified crust
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 热熔岩流过凝固的地壳
- en: 'In a new Blender scene, after deleting the default cube, perform the following
    steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的Blender场景中，删除默认的立方体后，执行以下步骤：
- en: Add a **Plane**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**平面**。
- en: Switch to the **Shading** workspace.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**着色**工作区。
- en: Bring up the default **Material** or create a new one.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调出默认的**材质**或创建一个新的。
- en: Rename the material if you desire.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，重命名材质。
- en: 'Nothing new or exciting so far, but we’ll utilize the following five new nodes
    very soon:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有什么新奇的，但我们很快就会利用以下五个新节点：
- en: '**Noise Texture**: Perlin noise is a mix of black and white values that are
    mixed together in a gradual way, so the result looks like a soup of grayscale
    values. Blender’s noise texture is similar to Perlin, but the values are not grayscale;
    they come with random colors.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声纹理**：Perlin噪声是黑白值的混合，这些值以渐进的方式混合在一起，因此结果看起来像灰度值的汤。Blender的噪声纹理与Perlin类似，但值不是灰度值；它们带有随机颜色。'
- en: '**Bump**: It is used to simulate height fluctuations so surfaces could look
    bumpy.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bump**：它用于模拟高度波动，使表面看起来凹凸不平。'
- en: '**Color Ramp**: Another name for this node would have been color mapper, but
    since it’s using a gradient, the word “ramp” implies that the transition is smooth.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色渐变**：这个节点的另一个名字可能是颜色映射器，但由于它使用渐变，所以“渐变”这个词意味着过渡是平滑的。'
- en: '**Emission**: Under normal light, hot objects have a glowing effect. This shader
    would help you simulate a hot piece of steel coming out of an oven or a bright
    lightbulb.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射**：在正常光照下，热物体有发光效果。这个着色器可以帮助你模拟从烤箱中出来的热钢块或明亮的灯泡。'
- en: '**Mix Shader**: It’s a shader that mixes two shaders to create a combined shader.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合着色器**：这是一个混合两个着色器以创建组合着色器的着色器。'
- en: Before we move on to how to mix and match the preceding list of nodes, which
    kind of look like a recipe’s ingredients, here is a little bit of explanation
    as to why they were chosen. When you want to create your own procedural textures,
    a similar process might help you pick the nodes that are helpful instead of making
    wild guesses about which nodes to select. Also, after the explanation, try to
    imagine which one will connect to which. So, here we go.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍如何混合和匹配前面列出的节点，这些节点看起来像食谱的成分之前，这里有一些解释说明为什么选择了它们。当你想创建自己的程序纹理时，一个类似的过程可能有助于你选择有用的节点，而不是对选择哪些节点进行盲目的猜测。此外，在解释之后，试着想象哪个会连接到哪个。所以，我们开始吧。
- en: '**Noise Texture** is quite literally a texture that comes with some noise;
    the color variation in this noise texture is used in the **Bump** node to simulate
    different heights. So, **Noise Texture** is like the data and the **Bump** node
    is its visual representation in a sense. Then comes **Color Ramp**, shown as **ColorRamp**,
    which assigns color information to different height values. If you''ve ever seen
    a miniature landscape, it’s like painting hilltops white because of snow and the
    lower areas with different shades of green depending on the elevation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**噪声纹理**字面上是一种带有噪声的纹理；这种噪声纹理中的颜色变化在**Bump**节点中用于模拟不同的高度。因此，**噪声纹理**就像是数据，而**Bump**节点则是其视觉表示，从某种意义上说。接下来是**颜色渐变**，显示为**ColorRamp**，它将颜色信息分配给不同的高度值。如果你曾经见过微型景观，它就像是画白色的山顶因为雪，以及根据海拔的不同，低地区域有不同的绿色阴影。'
- en: Hence, the first three nodes are taking care of most of the work for simulating
    elevation. Let’s assume this lava texture is portraying a recent formation, so
    we are not after just displaying cooled-down lava. We would like to see steaming
    hot, glowing lava in between the blackened and dried-out lava. So, we’ll need
    an **Emission** shader for that. Finally, since the elevation is its own thing
    and we are adding the emission part, we’ll need **Mix Shader** to combine both.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前三个节点负责模拟高度的大部分工作。假设这个熔岩纹理描绘的是最近的形成，所以我们不仅仅是为了显示冷却后的熔岩。我们希望看到蒸汽腾腾、发光的熔岩在变黑和干燥的熔岩之间。因此，我们需要一个**发射**着色器。最后，由于高度是其自身的事情，我们正在添加发射部分，所以我们需要**混合着色器**来结合两者。
- en: While working with nodes, you can drag and drop the nodes to arrange a cleaner
    layout for yourself to make sense of what’s going on. Without further ado, let’s
    continue.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理节点时，你可以拖放节点来为自己安排一个更整洁的布局，以便理解正在发生的事情。无需多言，让我们继续。
- en: Add the aforementioned five nodes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加上述五个节点。
- en: 'Connect as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式连接：
- en: '**Noise Texture**’s **Color** to **Bump**’s **Height**'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声纹理**的**颜色**到**Bump**的**高度**'
- en: '**Noise Texture**’s **Fac** to **ColorRamp**’s **Fac**'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**噪声纹理**的**Fac**到**颜色渐变**的**Fac**'
- en: '**Bump**’s **Normal** to **Principled BSDF**’s **Normal**'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bump**节点的**Normal**到**Principled BSDF**的**Normal**'
- en: '**ColorRamp**’s **Color** to **Mix Shader**’s **Fac**'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色渐变**的**颜色**到**混合着色器**的**Fac**'
- en: '**Principled BSDF**’s **BSDF** to **Mix Shader**’s first input **Shader**'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Principled BSDF**的**BSDF**到**混合着色器**的第一个输入**着色器**'
- en: '**Emission Shader**’s **Emission** to **Mix Shader**’s second input **Shader**'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射着色器**的**发射**到**混合着色器**的第二输入**着色器**'
- en: '**Mix Shader**’s **Shader** output to **Material Output**’s **Surface**'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合着色器**的**着色器**输出到**材质输出**的**表面**'
- en: There is no left or right direction when it comes to connecting nodes. Some
    people consider a group of nodes as a unit and arrange them close to each other.
    So, sometimes, the last output node from that group connects almost vertically
    to another group of nodes. That being said, having a general flow of left to right
    would fit the preceding instructions. Whichever way you arrange your nodes, the
    layout might resemble what you see in *Figure 3.7*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接节点时，没有左右方向。有些人将一组节点视为一个单元，并将它们彼此靠近排列。因此，有时，该组最后一个输出节点几乎垂直地连接到另一组节点。话虽如此，从左到右的一般流向符合前面的说明。无论你如何排列你的节点，布局可能类似于你在*图3.7*中看到的。
- en: '![Figure 3.7 – Lava texture’s node arrangement ](img/Figure_3.07_B17473.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 火山纹理的节点排列](img/Figure_3.07_B17473.jpg)'
- en: Figure 3.7 – Lava texture’s node arrangement
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 火山纹理的节点排列
- en: Let’s look at the values these nodes will have by following the original order
    of the node list as much as possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照节点列表的原有顺序尽可能多地查看这些节点的值。
- en: Noise Texture
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 噪声纹理
- en: 'For **Noise Texture**, the following values were used:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**噪声纹理**，使用了以下值：
- en: '**Type** defines the dimensions that are used in the creation of the noise,
    which involves complex operations. It’s used in more advanced cases, so we’ll
    leave the default **3D** value.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**定义了在噪声创建中使用的维度，这涉及到复杂的操作。它在更高级的案例中使用，所以我们保留默认的**3D**值。'
- en: The **Scale** property works more like a zoom factor. Too low, and you are closer
    to the noisy surface. Too high, and you are seeing a larger portion of the noisy
    landscape as if you are climbing up in an airplane. In this case, we set **Scale**
    to **3.0**.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**属性更像是缩放因子。太低，你更接近于噪声表面。太高，你看到的是更大的噪声景观，就像你在飞机上爬升一样。在这种情况下，我们将**缩放**设置为**3.0**。'
- en: The **Detail** property is self-explanatory. Although having a lower value will
    certainly result in a muddy look, having a higher number beyond a certain value
    won’t add much to the quality. It will simply increase the calculation time. A
    value of **8.0** is chosen in our case.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细节**属性是显而易见的。尽管较低的值肯定会造成模糊的外观，但超过一定值的高数值并不会对质量有很大提升。它只会增加计算时间。在我们的案例中，选择了**8.0**的值。'
- en: '**Roughness** is not the same concept you saw in [*Chapter 2*](B17473_02.xhtml#_idTextAnchor032),
    *Building Materials and Shaders*. That one affected the reflective properties
    of a surface. This one is about how rough the edges are, in a sense. In other
    words, how roughly the noise values are blending into each other, and a value
    of **0.5** is enough.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗糙度**与你在[*第二章*](B17473_02.xhtml#_idTextAnchor032)，“建筑材料和着色器”中看到的概念不同。那一个影响的是表面的反射特性。这个概念是关于边缘的粗糙程度，从某种意义上说。换句话说，噪声值是如何相互混合的，而**0.5**的值就足够了。'
- en: The **Distortion** property creates swirls and wavy patterns. Perhaps a little
    might be necessary for a flowing lava look. You could experiment with it, but
    beyond a certain value when there is too much distortion, things will look too
    fragmented. So, **0.2** is good enough.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扭曲**属性创建漩涡和波浪图案。可能对于流动的火山外观，一点是必要的。你可以尝试一下，但超过一定值时，过多的扭曲会使事物看起来过于破碎。所以，**0.2**就足够了。'
- en: Bump
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凸起
- en: This node will use the data provided by **Noise Texture** so it can represent
    different color values as different height values. This is why the **Height**
    input was connected to the **Color** output since there can’t be just one height
    value for the whole surface, so we had to feed it a set of colors.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点将使用**噪声纹理**提供的数据，因此它可以以不同的高度值表示不同的颜色值。这就是为什么将**高度**输入连接到**颜色**输出，因为整个表面不可能只有一个高度值，所以我们不得不提供一组颜色。
- en: 'Leaving the **Invert** setting unchecked, the following are the other values
    used:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在不勾选**反转**设置的情况下，使用了以下其他值：
- en: The **Strength** value determines the effect of the mapping between color values
    and the final bumps. It works like a percentage since the values can be anywhere
    between *0.0* and *1.0*. We’ll leave it at **1.0**.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强度**值决定了颜色值与最终凸起之间的映射效果。它像百分比一样工作，因为值可以在*0.0*到*1.0*之间。我们将它保留在**1.0**。'
- en: The **Distance** property is a multiplier of some sort. It works in conjunction
    with the **Strength** property. Setting either one of them to *0* will result
    in a totally flat surface. Perhaps the best way to describe this property is that
    it keeps the details set in **Noise Texture**. Any value closer to *1.0* will
    show a washed-out surface, whereas higher values will fill in more details. Thus,
    a value of **3.0** will yield a detailed enough result.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Distance**属性是一种乘数。它与**Strength**属性一起工作。将其中任何一个设置为*0*将导致表面完全平坦。也许描述这个属性最好的方式是它保留了**Noise
    Texture**中设置的所有细节。任何接近*1.0*的值将显示一个褪色的表面，而更高的值将填充更多细节。因此，**3.0**的值将产生足够详细的成果。'
- en: Emission
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Emission
- en: This is a very simple node and it’s responsible for making surfaces look glowing.
    We’ll discover lights in [*Chapter 4*](B17473_04.xhtml#_idTextAnchor060), *Adjusting
    Cameras and Lights*, but if you want your objects to act like they are emitting
    or radiating light, then you can use this node. Examples might be a piece of hot
    iron or fluorescent lightbulbs; in our case, lava.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的节点，它负责使表面看起来发光。我们将在[*第4章*](B17473_04.xhtml#_idTextAnchor060)中了解到灯光，*调整相机和灯光*，但如果你想让你的物体看起来像是在发射或辐射光线，那么你可以使用这个节点。例如，一块热的铁或荧光灯泡；在我们的案例中，熔岩。
- en: 'Since this is such a simple node, we have only the following two properties:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常简单的节点，我们只有以下两个属性：
- en: The self-explanatory **Color** property is for picking which color the surface
    will emit. For hot lava, you can switch to the **Hex** values on the interface
    and choose **FF8400**.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自解释的**Color**属性用于选择表面将发出哪种颜色。对于热熔岩，你可以在界面上切换到**Hex**值并选择**FF8400**。
- en: The **Strength** value, which is **100.0** in our case, defines the intensity
    of the emission. This is a unit measured in Watts so you can be scientific about
    it, but picking arbitrary values for visual fidelity works most of the time too.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Strength**值，在我们的案例中为**100.0**，定义了发射的强度。这是一个以瓦特为单位的单位，你可以科学地对待它，但选择任意值以获得视觉真实感通常也行得通。'
- en: ColorRamp
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ColorRamp
- en: The **ColorRamp** node is used for mapping input values to colors with the help
    of a gradient that works like a threshold. The description is deceptively simple,
    but there is a lot going on under the hood. So, let’s unpack it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**ColorRamp**节点用于通过类似于阈值的梯度将输入值映射到颜色。描述看似简单，但实际上内部有很多内容。所以，让我们来分解它。'
- en: Most of the time, you’ll be connecting both the input and output sockets of
    a node to other nodes. However, there are times when it is totally acceptable
    to use only one type of socket. For example, in the **Emission** shader, you didn’t
    have to use the input sockets to define the **Color** and **Strength** values.
    Instead, you handpicked their values. So, the node acts like a source of information.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你将连接节点的输入和输出插孔到其他节点。然而，有时只使用一种类型的插孔是完全可接受的。例如，在**Emission**着色器中，你不必使用输入插孔来定义**Color**和**Strength**值。相反，你可以手动选择它们的值。因此，节点就像是一个信息源。
- en: Then, there are some nodes where it makes much more sense to connect the input
    socket to another node’s output socket. **ColorRamp** is one of those nodes, and
    it works like a modifier by factoring in incoming values. **Noise Texture**’s
    data will be a factor (Fac for short) in creating a lava surface, so we connect
    the two **Fac** sockets.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有一些节点，将输入插孔连接到另一个节点的输出插孔会更有意义。**ColorRamp**就是这样的节点之一，它通过考虑传入的值来充当修饰符。**Noise
    Texture**的数据将是创建熔岩表面的一个因素（简称Fac），因此我们连接了两个**Fac**插孔。
- en: Once the data is factored in, we need a system to process it. This is done via
    the gradient in the **ColorRamp** node. The concept of a gradient might sound
    weird at first. If you were to connect the **Color** of **Noise Texture** directly
    to **Material Output**, you’d see that there are smaller and larger zones of colors.
    If you do that, remember to undo it so that the nodes are connected correctly
    once again. We need a way to turn these flat but colored zones to elevation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被考虑在内，我们需要一个系统来处理它。这是通过**ColorRamp**节点中的梯度来完成的。梯度这个概念一开始可能听起来有些奇怪。如果你直接将**Noise
    Texture**的**Color**连接到**Material Output**，你会看到颜色有大小不同的区域。如果你这样做，记得撤销操作，以确保节点再次正确连接。我们需要一种方法将这些平坦但着色的区域转换为高度。
- en: The gradient is going to help us define which zones are higher or lower so we
    can assign the appropriate color to different elevations later. In essence, the
    gradient is a tool to define and blend in those zones with the help of color stops.
    By default, there are two color stops, but you can use the plus and minus buttons
    above the gradient to add and remove more color stops. These stops have a square
    shape with a little triangle right above them. It is possible to drag these stops,
    which will change the zone transitions we mentioned earlier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 渐变将帮助我们定义哪些区域较高或较低，这样我们可以在稍后为不同的海拔分配适当的颜色。本质上，渐变是一个工具，通过颜色停止点来定义和混合这些区域。默认情况下，有两个颜色停止点，但你可以在渐变上方的加号和减号按钮中添加和删除更多的颜色停止点。这些停止点具有方形，上面有一个小三角形。你可以拖动这些停止点，这将改变我们之前提到的区域过渡。
- en: When you have a lot of stops, it’s sometimes difficult to click and drag them,
    so use **active color stop** to step between them. When you add a fresh **ColorRamp**
    node, the active stop is marked as **0** and it is to the left of the label that
    says **Pos**, which indicates the position of the active stop. Both the active
    stop and the position fields show necessary UI elements for you to change the
    values once you hover; also, you can click and enter a value. So, by using the
    active color stop and **Pos**, you can mark exactly where the color stops are
    going to be if you don’t want to drag them around.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有许多停止点时，有时很难点击和拖动它们，所以使用**活动颜色停止点**在它们之间进行切换。当你添加一个新的**ColorRamp**节点时，活动停止点被标记为**0**，并且它位于标有**Pos**的标签的左侧，这表示活动停止点的位置。活动停止点和位置字段都显示了必要的UI元素，以便你在悬停时更改值；你也可以点击并输入一个值。因此，通过使用活动颜色停止点和**Pos**，你可以精确标记颜色停止点将要放置的位置，如果你不想拖动它们的话。
- en: Last but not least, there is a color picker right above the **Fac** socket.
    You can use that to set the color for the active stop.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有一个颜色选择器位于**Fac**插孔上方。你可以使用它来设置活动停止点的颜色。
- en: Since this is not a straightforward node, we could benefit from some visual
    aid. *Figure 3.8* is a zoomed-in look at the **ColorRamp** node.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一个简单的节点，我们可以从一些视觉辅助中受益。*图3.8*是对**ColorRamp**节点的放大查看。
- en: '![Figure 3.8 – A close-up look at the ColorRamp node ](img/Figure_3.8_B17473.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – ColorRamp节点的近距离观察](img/Figure_3.8_B17473.jpg)'
- en: Figure 3.8 – A close-up look at the ColorRamp node
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – ColorRamp节点的近距离观察
- en: The preceding figure should help you see what we have talked about so far. Also,
    just like you are able to zoom in and out with your mouse’s scroll functionality
    in the 3D view, you can do so in **Shader Editor**. It will help you see some
    of the properties’ names and values more clearly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图应该帮助你看到我们到目前为止所讨论的内容。同样，就像你在3D视图中使用鼠标的滚动功能可以放大和缩小一样，你可以在**Shader Editor**中这样做。这将帮助你更清楚地看到一些属性名称和值。
- en: 'Now, it’s time to use all of this information and mark our transitions; you’ll
    be interacting with all of the elements just presented. To that end, perform the
    following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用所有这些信息并标记我们的过渡；你将交互所有刚刚展示的元素。为此，执行以下步骤：
- en: Use the plus/minus buttons to have four color stops.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用加减按钮来拥有四个颜色停止点。
- en: 'Set `0`, then do as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0`，然后按照以下步骤操作：
- en: Set `0.45`.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0.45`。
- en: Set color in the `000000`.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`000000`中设置颜色。
- en: 'Set `1`, then do as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`1`，然后按照以下步骤操作：
- en: Set `0.53`.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0.53`。
- en: Set color in the `FFFFFF`.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FFFFFF`中设置颜色。
- en: 'Set `2`, then do as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`2`，然后按照以下步骤操作：
- en: Set `0.94`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`0.94`。
- en: Set color in the `FFFFFF`.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FFFFFF`中设置颜色。
- en: 'Set `3`, then do as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`3`，然后按照以下步骤操作：
- en: Set `1.00`.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`1.00`。
- en: Set color in the `636363`.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`636363`中设置颜色。
- en: Notice that we are only picking grayscale values. In a real landscape, higher
    areas will be cooler lava, and the lower areas will be hot pools of lava. So,
    to represent that idea, we are picking dark and white colors. Usually, the whiter
    something is, the hotter it is. The proximity of the stops to each other determines
    how smooth or sharp the transitions are.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只选择灰度值。在真实景观中，较高的区域将是较冷的熔岩，而较低的区域将是炽热的熔岩池。因此，为了表示这个想法，我们选择深色和浅色。通常，某物越白，它就越热。停止点之间的接近程度决定了过渡是平滑还是尖锐。
- en: Although we have been working with the **ColorRamp** node, the colors for our
    lava texture will be defined in the **Principled BSDF** and **Emission** shaders
    and will be combined in **Mix Shader**. For the time being, we have utilized the
    data from **Noise Texture** and transformed that data with the help of a gradient
    and its carefully chosen values. We’ll revisit the factor concept again in the
    *Mix Shader* section, but before that, let’s visit our trusty friend **Principled
    BSDF**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们一直在使用**ColorRamp**节点，但我们的熔岩纹理的颜色将在**Principled BSDF**和**Emission**着色器中定义，并在**Mix
    Shader**中组合。目前，我们已经利用了**Noise Texture**的数据，并在梯度及其精心选择的值的帮助下转换了这些数据。我们将在**Mix Shader**部分再次回顾因子概念，但在那之前，让我们访问我们忠实的朋友**Principled
    BSDF**。
- en: Principled BSDF
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Principled BSDF
- en: We actually saw this node in [*Chapter 2*](B17473_02.xhtml#_idTextAnchor032),
    *Building Materials and Shaders*, but it was displayed as part of the **Material
    Properties** interface. When you create a new material, it uses this shader by
    default. It combines a great deal of other shaders in its body. For example, it
    has an emission socket, but since we can’t do both the hot and cool part of the
    lava formation in one go, we are using a separate **Emission** shader.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在[*第2章*](B17473_02.xhtml#_idTextAnchor032)中看到了这个节点，*建筑材料和着色器*，但它作为**Material
    Properties**界面的一部分显示。当您创建一个新的材质时，它默认使用这个着色器。它在体内结合了许多其他着色器。例如，它有一个发射插座，但由于我们无法一次完成熔岩形成的冷热部分，我们正在使用一个单独的**Emission**着色器。
- en: 'We’ll leave most options unchanged, but the following are the non-default values
    chosen for this exercise:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留大多数选项不变，但以下是非默认值，为这次练习所选：
- en: '`4A4A4A` as the value in the **Hex** section of the color interface.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在颜色界面的**Hex**部分中，值为`4A4A4A`。
- en: The `0.2`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.2`。'
- en: '`0.2` in this exercise.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本练习中的`0.2`。
- en: You can refer to *Figure 2.5* in [*Chapter 2*](B17473_02.xhtml#_idTextAnchor032),
    *Building Materials and Shaders*, and read the explanation in the *Discovering
    Shaders* section for a refresher in understanding how multiple properties work
    together and affect the final look.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[*第2章*](B17473_02.xhtml#_idTextAnchor032)中的*图2.5*，*建筑材料和着色器*，并在*发现着色器*部分阅读解释，以刷新理解多个属性如何协同工作并影响最终外观。
- en: Mix Shader
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mix Shader
- en: It blends one shader into another determined by the value in **Factor**. For
    the **Factor** socket’s value, if you pick **0.0**, the first shader will be used
    entirely. If you choose **1.0**, it means that the second shader will be utilized.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据**Factor**中的值将一个着色器混合到另一个着色器中。对于**Factor**插座的值，如果您选择**0.0**，则将完全使用第一个着色器。如果您选择**1.0**，则表示将使用第二个着色器。
- en: The range of decimal values is between 0 and 1 but it’s hard to know what to
    choose since we can’t just arbitrarily determine how much of which shader to use.
    This is why we connected the **Color** output from **ColorRamp** as a factor so
    that the fluctuation in **Noise Texture** would trickle down and affect this node.
    The effect is cascading. In other words, every single pixel that’s going to be
    painted either dark (for dried lava) or orange (for hot lava) should be decided
    based on where **ColorRamp** thinks it belongs in **Noise Texture**. Thus, the
    color stops act like thresholds and this is all factored in, in **Mix Shader**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制值的范围在0到1之间，但由于我们无法随意确定使用多少个着色器，因此很难知道选择什么。这就是为什么我们将**ColorRamp**的**Color**输出连接为因子，以便**Noise
    Texture**的波动会逐渐影响此节点。效果是级联的。换句话说，每个将要被涂上（对于干涸的熔岩）或橙色（对于热熔岩）的像素，都应该基于**ColorRamp**认为它在**Noise
    Texture**中的位置来决定。因此，颜色停止点充当阈值，所有这些都在**Mix Shader**中考虑在内。
- en: Once all of the nodes have been set and attached, feel free to play with the
    values in all of them, especially **ColorRamp**. You’ll notice that the hot lava
    parts are sort of cooler at the shore, and denser and brighter in the middle.
    Try to approach the color stops close to each other and see how these hot zones
    in the lava pools change.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有节点都已设置并连接，您可以随意调整它们的所有值，特别是**ColorRamp**。您会注意到，热熔岩部分在岸边似乎更凉爽，而在中间更密集、更明亮。尝试将颜色停止点靠近彼此，看看这些熔岩池中的热点区域如何变化。
- en: Creating this kind of texture using conventional image editing applications
    such as *Adobe Photoshop* might have been possible, but those applications are
    layer-based and it’s not always easy to keep things non-destructive. The power
    you have with a node-based approach is quick iterations. One thing for sure is
    you don’t have to reimport your texture to see the changes. It’s all happening
    live in front of your eyes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的图像编辑应用程序，如*Adobe Photoshop*创建这种纹理可能是可能的，但这些应用程序基于图层，并且保持非破坏性并不总是容易。基于节点的处理方式带来的优势是快速迭代。有一点可以肯定的是，你不需要重新导入纹理来查看更改。所有这些都在你的眼前实时发生。
- en: However, at the end of the day, since you are developing a game, you’ll have
    to export your texture so the game engine of your choice can use it. In the following
    and final section, we’ll see how we can export our lava texture to the file system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，由于你正在开发游戏，你必须导出你的纹理，以便你选择的游戏引擎可以使用它。在以下和最终的章节中，我们将看到如何将我们的熔岩纹理导出到文件系统。
- en: Exporting your textures
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出你的纹理
- en: In later chapters, when we get close to working with Godot Engine, we’ll look
    into asset and project management in more detail. However, after all the hard
    work we have done with the lava material, it’s now time to learn how to export
    the texture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，当我们接近与Godot引擎一起工作时，我们将更详细地探讨资产和项目管理。然而，在我们对熔岩材质所做的所有艰苦工作之后，现在是时候学习如何导出纹理了。
- en: We’ll do a few interesting but necessary things in this section to export our
    texture. First, we’ll change Blender’s rendering engine. Then, we’ll add an **Image
    Texture** node in the middle of our material without connecting it to anything.
    Weird, right? Blender works mysteriously sometimes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行一些有趣但必要的操作来导出我们的纹理。首先，我们将更改Blender的渲染引擎。然后，我们将在材质的中间添加一个**图像纹理**节点，而不将其连接到任何东西。奇怪吧？Blender有时工作得很神秘。
- en: Changing the rendering engine
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改渲染引擎
- en: We have been using the default **Eevee** rendering engine so far. **Eevee**
    is a real-time rendering engine that gives you really fast results. Most game
    engines have their own internal real-time rendering engines that are responsible
    for calculating lights and shadows. So, **Eevee** is a good way to simulate in
    Blender what you’ll most likely experience when you export your assets to a game
    engine. However, the speed and convenience come with a few penalties.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用默认的**Eevee**渲染引擎。**Eevee**是一个实时渲染引擎，可以提供非常快速的结果。大多数游戏引擎都有自己的内部实时渲染引擎，负责计算光线和阴影。因此，**Eevee**是模拟Blender中你将最有可能在导出资产到游戏引擎时体验到的效果的好方法。然而，速度和便利性也带来了一些代价。
- en: 'Blender has another engine that is called **Cycles**. **Cycles** is a very
    accurate but slow rendering engine compared to **Eevee**. **Cycles**’ accuracy
    is due to the fact that it tackles advanced lighting calculations, which leads
    to quality results such as showing reflective and transparent surfaces much better,
    displaying more accurate shadows, and even creating volumetric effects such as
    haze and fog. The following is a link to an article that demonstrates both engines’
    capabilities and differences with use cases: [https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering](https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Blender还有一个名为**Cycles**的引擎。与**Eevee**相比，**Cycles**是一个非常精确但速度较慢的渲染引擎。**Cycles**的精确性归因于它处理高级光照计算，这导致了高质量的结果，例如更好地显示反射和透明表面，显示更精确的阴影，甚至创建体积效果，如雾霾。以下是一个链接，展示了这两个引擎的功能和差异，以及使用案例：[https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering](https://cgcookie.com/articles/blender-cycles-vs-eevee-15-limitations-of-real-time-rendering)。
- en: In this book, we are not covering advanced enough topics that would require
    us to make a hard decision between **Eevee** and **Cycles**. So, **Eevee** has
    been fine for our purposes. However, when you work with procedural textures, there
    is no way, at least with the version of Blender we’re using, for **Eevee** to
    export the lava texture. We’ll have to switch to the **Cycles** engine. Luckily,
    it’s done just with the click of a button.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会涵盖足够高级的主题，这些主题需要我们在**Eevee**和**Cycles**之间做出艰难的决定。因此，**Eevee**对我们来说已经足够好了。然而，当你与程序纹理一起工作时，至少在我们使用的Blender版本中，**Eevee**无法导出熔岩纹理。我们将不得不切换到**Cycles**引擎。幸运的是，这只需点击一下按钮即可完成。
- en: In the **Properties** panel on the right, the second tab from the top, which
    looks like the preview display of a DSLR camera, is going to open **Render Properties**.
    The drop-down list at the top will show **Eevee**; let’s change that to **Cycles**.
    Also, if you have a decent graphics card, you might want to change the third dropdown,
    **Device**, value to **GPU compute** so that your graphic card can do the heavy
    lifting instead of your good old CPU.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的**属性**面板中，从顶部开始的第二个标签，看起来像数码单反相机的预览显示，将会打开**渲染属性**。顶部的下拉列表将显示**Eevee**；让我们将其更改为**Cycles**。此外，如果你有一块不错的显卡，你可能还想将第三个下拉列表的**设备**值更改为**GPU计算**，这样你的显卡就可以代替你那老式的CPU来处理繁重的工作。
- en: Looking down in that long list of properties, you’ll see a panel with the header
    **Bake**. If you expand the header, you’ll see a **Bake** button. We’ll click
    that button soon, but we need to prepare what we’ll bake first.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在那长长的属性列表中向下看，你会看到一个标题为**烘焙**的面板。如果你展开标题，你会看到一个**烘焙**按钮。我们很快就会点击那个按钮，但我们需要先准备好我们将要烘焙的内容。
- en: Baking a texture File
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙纹理文件
- en: 'When we worked with the cube and die textures, we used an **Image Texture**
    node to bind an existing image from the file system. Our situation is different
    when the texture is procedural since this has been happening live in the memory.
    We need to figure out a way to bake this information into a file. Since there
    is no such file, we need to pretend that we have one, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与立方体和骰子纹理一起工作时，我们使用了一个**图像纹理**节点来绑定文件系统中的一个现有图像。当纹理是程序性的时，我们的情况就不同了，因为这一切都是在内存中实时发生的。我们需要找出一种方法将此信息烘焙到一个文件中。由于没有这样的文件，我们需要假装我们有一个，如下所示：
- en: Add an **Image Texture** node.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个**图像纹理**节点。
- en: Click the **New** button.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建**按钮。
- en: Type `lava` in the name section.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称部分输入`lava`。
- en: Click the **OK** button.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮。
- en: We won’t be connecting `lava` will be packaged with the material. Blender will
    make an educated guess and will bake the procedural texture parts into this image.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将`lava`连接到材质中。Blender会做出一个合理的猜测，并将程序化纹理部分烘焙到这张图像中。
- en: Now is the time to hit that **Bake** button in **Render Properties**. A progress
    bar at the bottom will indicate that Blender is doing its thing. Once the process
    is finished, the bottom-left corner of the **Shading** workspace will fill with
    the lava texture. That little section that displays the baked texture is called
    **Image Editor**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在**渲染属性**中点击那个**烘焙**按钮了。底部的进度条将指示Blender正在执行其操作。一旦过程完成，**着色**工作区的左下角将充满熔岩纹理。那个显示烘焙纹理的小部分被称为**图像编辑器**。
- en: If you look at the baked image, you’ll notice that some details are lost. The
    pool of hot lava has warmer and cooler spots in `1.0`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看烘焙后的图像，你会注意到一些细节丢失了。在1.0中，热熔岩池有温暖和凉爽的区域。
- en: In the `lava.png` in your file system. This file can now be imported into a
    new Blender file and used in an `pips.png` to a cube.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的文件系统中的`lava.png`。现在这个文件可以被导入到一个新的Blender文件中，并用于一个`pips.png`到立方体的纹理。
- en: Mission accomplished. If you chose the same values as those written in this
    chapter, you should have the procedural lava texture you see in *Figure 3.6*.
    Additionally, you have created a static version of it. Let’s summarize what else
    has been accomplished in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成。如果你选择了本章中写下的相同值，你应该已经有了*图3.6*中看到的程序化熔岩纹理。此外，你还创建了一个静态版本。让我们总结一下本章还完成了什么。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter started off with a brief discussion about what textures are and
    why they might be needed. To recap, if you are fine with models that have just
    the color info on their surface, you are done as soon as the modeling and material
    application process is finished. If you think you need to show distinctive qualities
    on your models’ surfaces, you need to utilize textures.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章一开始简要讨论了纹理是什么以及为什么可能需要它们。为了回顾，如果你对模型表面只有颜色信息就满意，那么一旦建模和材质应用过程完成，你就可以结束了。如果你认为你需要在你模型的表面上展示独特的特性，你需要利用纹理。
- en: To that end, you discovered how a new coordinate system—one that involves mapping
    spatial coordinates to texture coordinates via a method called UV unwrapping—might
    be necessary. Once the UV unwrapping is done, you can apply and swap different
    textures to your 3D models since the mapping from 2D to 3D is established.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目的，你发现了如何创建一个新的坐标系——通过一种称为UV展开的方法将空间坐标映射到纹理坐标——可能是必要的。一旦完成UV展开，你就可以将不同的纹理应用到你的3D模型上，因为2D到3D的映射已经建立。
- en: Although creating textures with image editing applications is quite possible,
    you also know how to create textures procedurally in Blender. This is a powerful
    method, especially when it comes to surfaces that are hard to UV unwrap, such
    as landscapes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用图像编辑应用程序创建纹理是完全可能的，但你同样知道如何在Blender中通过程序创建纹理。这是一个强大的方法，尤其是在处理难以进行UV展开的表面时，例如景观。
- en: Last but not least, you learned how to change the rendering engine to be able
    to export your procedural texture to your file system. Although this file is static
    and can no longer be updated automatically (unless you overwrite it with a new
    export, of course), you have the benefit of sharing the file easily.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，你学会了如何更改渲染引擎，以便将你的程序纹理导出到文件系统中。尽管这个文件是静态的，并且无法自动更新（当然，除非你用新的导出覆盖它），但你有一个好处，那就是可以轻松地分享文件。
- en: You’ve been using Blender’s interface and your mouse to move around the scene
    and rotate the view to have a better look at your models, materials, and so on.
    In the following chapter, you’ll learn how to work with Camera and Light objects
    to create a composition where you can arrange objects in your scene under the
    best light conditions possible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用Blender的界面和鼠标在场景中移动，旋转视图以更好地查看你的模型、材质等。在下一章中，你将学习如何与相机和灯光对象一起工作，以创建一个可以在最佳光照条件下排列场景中物体的构图。
- en: Further reading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read more about what each shader node does, you can refer to the official
    documentation at the following link: [https://docs.blender.org/manual/en/2.93/render/shader_nodes/](https://docs.blender.org/manual/en/2.93/render/shader_nodes/).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每个着色器节点的作用，你可以参考以下链接中的官方文档：[https://docs.blender.org/manual/en/2.93/render/shader_nodes/](https://docs.blender.org/manual/en/2.93/render/shader_nodes/)。
- en: For further practice, imagine where else the method for the lava texture could
    be used. Perhaps, with carefully planned values and more color variations, the
    hot lava might be rust, and the cool lava might be paint?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步练习，想象一下火山纹理的方法还可以用在哪些地方。也许，通过精心策划的值和更多的颜色变化，炽热的岩浆可能是铁锈，而冷却的岩浆可能是油漆？
- en: If you are curious and would like to investigate different software out there
    capable of producing procedural textures, you can give *Adobe Substance Designer*
    a try. It’s a powerful program dedicated solely to creating textures. Not all
    of the nodes are labeled the same, but there are a lot of similar nodes to Blender’s.
    In fact, if you practice your skills there and look at other people’s creations,
    you might gain insight into creating such textures in Blender.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇并想调查其他能够生成程序纹理的软件，你可以尝试使用*Adobe Substance Designer*。这是一个仅专注于创建纹理的强大程序。并非所有节点都标有相同的标签，但有很多与Blender相似的节点。实际上，如果你在那里练习技能并查看他人的创作，你可能会对在Blender中创建此类纹理有所启发。
