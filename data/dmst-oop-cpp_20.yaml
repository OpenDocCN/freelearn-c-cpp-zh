- en: '*Chapter 16*: Using the Observer Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：使用观察者模式'
- en: This chapter will begin our quest to expand your C++ programming repertoire
    beyond OOP concepts, with the goal of enabling you to solve recurring types of
    coding problems by utilizing common design patterns. Design patterns will also
    enhance code maintenance and provide avenues for potential code reuse. The goal
    of the fourth section of the book, beginning with this chapter, is to demonstrate
    and explain popular design patterns and idioms and learn how to implement them
    effectively in C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将开始我们的探索，将您的C++编程技能库扩展到OOP概念之外，目标是使您能够通过利用常见的设计模式来解决重复出现的编码问题。设计模式还将增强代码维护，并为潜在的代码重用提供途径。本书的第四部分，从本章开始，旨在演示和解释流行的设计模式和习语，并学习如何在C++中有效实现它们。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the advantage of utilizing design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解利用设计模式的优势
- en: Understanding the Observer pattern and how it contributes to OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解观察者模式及其对面向对象编程的贡献
- en: Understanding how to implement the Observer pattern in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何在C++中实现观察者模式
- en: By the end of this chapter, you will understand the utility of employing design
    patterns in your code, as well as understanding the popular **Observer pattern**.
    We will see an example implementation of this pattern in C++. Utilizing common
    design patterns will help you become a more beneficial and valuable programmer
    by enabling you to embrace more sophisticated programming techniques.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束，您将了解在您的代码中使用设计模式的效用，以及了解流行的**观察者模式**。我们将在C++中看到这种模式的示例实现。利用常见的设计模式将帮助您成为一个更有益和有价值的程序员，使您能够接纳更复杂的编程技术。
- en: Let's increase our programming skills set by examining various design patterns,
    starting in this chapter with the Observer pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究各种设计模式来增强我们的编程技能，从本章开始使用观察者模式。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter16` in a file named `Chp16-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，该文件与所在章节编号对应，后跟破折号，再跟所在章节中示例编号。例如，本章的第一个完整程序可以在子目录`Chapter16`中的名为`Chp16-Ex1.cpp`的文件中找到，该文件位于上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3vYprq2](https://bit.ly/3vYprq2).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接观看：[https://bit.ly/3vYprq2](https://bit.ly/3vYprq2)。
- en: Utilizing design patterns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用设计模式
- en: '**Design patterns** represent a grouping of well-tested programming solutions
    for recurring types of programming conundrums. Design patterns represent the high-level
    concept of a design issue and how a generalized collaboration between classes
    can provide a solution that can be implemented in a variety of ways.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计模式**代表了针对重复出现的编程难题的一组经过充分测试的编程解决方案。设计模式代表了设计问题的高级概念，以及类之间的通用协作如何提供解决方案，可以以多种方式实现。'
- en: There are many well-identified design patterns that have been recognized and
    described in the past 25+ years of software development. We will look at some
    popular patterns in the remaining chapters of this book to give you a feel as
    to how we can incorporate popular software design solutions into our coding arsenal
    of techniques.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去25年多的软件开发中，已经识别和描述了许多设计模式。我们将在本书的剩余章节中查看一些流行的模式，以便让您了解如何将流行的软件设计解决方案纳入我们的编码技术库中。
- en: Why might we choose to utilize a design pattern? To start, once we have identified
    a type of programming problem, we can make use of a *tried and true* solution
    that other programmers have tested comprehensively. Additionally, once we employ
    a design pattern, other programmers immersing themselves in our code (for maintenance
    or future enhancements) will have a basic understanding of the techniques we have
    chosen, as core design patterns have become an industry standard.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们选择使用设计模式？首先，一旦我们确定了一种编程问题类型，我们可以利用其他程序员充分测试过的*经过验证的*解决方案。此外，一旦我们使用了设计模式，其他程序员在沉浸于我们的代码（用于维护或未来增强）时，将对我们选择的技术有基本的了解，因为核心设计模式已成为行业标准。
- en: Some of the earliest design patterns came about nearly 50 years ago, with the
    advent of the **Model-View-Controller** paradigm, later simplified at times as
    **Subject-View**. For example, Subject-View is a rudimentary pattern in which
    an object of interest (the **Subject**) will be loosely coupled from its method
    of display (its **View**). The Subject and its View communicate with a one-to-one
    association. Sometimes Subjects can have multiple Views, in which case the Subject
    is associated with many View objects. If one View changes, a state update can
    be sent to the Subject, who can then send necessary messages to the other Views
    so that they, too, can be updated to reflect how the new state may have modified
    their particular View.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最早的设计模式大约50年前出现，随着**模型-视图-控制器**范式的出现，后来有时简化为**主题-视图**。例如，主题-视图是一个基本的模式，其中一个感兴趣的对象（**主题**）将与其显示方法（**视图**）松散耦合。主题及其视图之间有一对一的关联。有时主题可以有多个视图，这种情况下，主题与许多视图对象相关联。如果一个视图发生变化，状态更新可以发送到主题，然后主题可以向其他视图发送必要的消息，以便它们也可以更新以反映新状态可能如何修改它们的特定视图。
- en: The original **Model-View-Controller** (**MVC**) pattern, emanating from early
    OOP languages such as Smalltalk, has a similar premise, except that a Controller
    object delegates events between the Model (that is, the Subject) and its View
    (or Views). These preliminary paradigms influenced early design patterns; the
    elements of Subject-View or MVC can be seen conceptually as a rudimentary basis
    for core design patterns today.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的**模型-视图-控制器**（**MVC**）模式，源自早期的面向对象编程语言，如Smalltalk，具有类似的前提，只是控制器对象在模型（即主题）和其视图（或视图）之间委托事件。这些初步范例影响了早期的设计模式；主题-视图或MVC的元素在概念上可以被视为今天核心设计模式的基础。
- en: Many of the design patterns we will review in the remainder of this book will
    be adaptations of patterns originally described by the *Gang of Four* (Erich Gamma,
    Richard Helm, Ralph Johnson, and John Vlissides) in *Design Patterns, Elements
    of Reusable Object-Oriented Software*. We will apply and adapt these patterns
    to solve problems stemming from applications we have introduced in earlier chapters
    in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分中审查的许多设计模式都是由*四人组*（Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides）在*设计模式，可重用面向对象软件的元素*中最初描述的模式的改编。我们将应用和调整这些模式来解决我们在本书早期章节中介绍的应用程序所引发的问题。
- en: Let's begin our pursuit in understanding and utilizing popular design patterns
    by investigating a pattern in action. We will start with a behavioral pattern
    known as the **Observer pattern**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们对理解和利用流行设计模式的追求，通过调查一个正在实施的模式。我们将从一个被称为**观察者模式**的行为模式开始。
- en: Understanding the Observer pattern
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解观察者模式
- en: In the **Observer pattern**, an object of interest will maintain a list of observers
    who are interested in state updates of the main object. The observers will maintain
    a link to their object of interest. We will refer to the main object of interest
    as the **Subject**. The list of interested objects are known collectively as the
    **Observers**. The Subject will inform any Observer of relevant state changes.
    The Observers, once notified of any state changes of the Subject, will take any
    appropriate next action themselves (usually through a virtual function invoked
    on each Observer by the Subject).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在**观察者模式**中，一个感兴趣的对象将维护一个对主要对象状态更新感兴趣的观察者列表。观察者将维护与他们感兴趣的对象的链接。我们将主要感兴趣的对象称为**主题**。感兴趣的对象列表统称为**观察者**。主题将通知任何观察者相关状态的变化。一旦观察者被通知主题的任何状态变化，它们将自行采取任何适当的下一步行动（通常通过主题在每个观察者上调用的虚函数来执行）。
- en: Already, we can imagine how an Observer pattern may be implemented using associations.
    In fact, the Observer represents a one-to-many association. The Subject, for example,
    may use an STL `list` (or `vector`) to collect a set of Observers. Each Observer
    will contain an association to the Subject. We can imagine an important operation
    on the Subject, corresponding to a state change in the Subject, issuing an update
    to its list of Observers to *notify* them of the state change. The `Notify()`
    method is, in fact, invoked when a Subject's state changes and uniformly applies
    polymorphic Observer `Update()` methods on each of the Subject's list of Observers.
    Before we get swept up in implementation, let's consider the key components comprising
    the Observer pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以想象如何使用关联来实现观察者模式。事实上，观察者代表了一对多的关联。例如，主题可以使用STL的`list`（或`vector`）来收集一组观察者。每个观察者将包含与主题的关联。我们可以想象主题上的一个重要操作，对应于主题中的状态改变，发出对其观察者列表的更新，以*通知*它们状态的改变。`Notify()`方法实际上是在主题的状态改变时被调用，并统一地应用于主题的观察者列表上的多态观察者`Update()`方法。在我们陷入实现之前，让我们考虑构成观察者模式的关键组件。
- en: 'The Observer pattern will include:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将包括：
- en: A Subject, or object of interest. The Subject will maintain a list of Observer
    objects (many-sided association).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题，或感兴趣的对象。主题将维护一个观察者对象的列表（多边关联）。
- en: A Subject will provide an interface to `Register()` or `Remove()` an Observer.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题将提供一个接口来`Register()`或`Remove()`一个观察者。
- en: A Subject will include a `Notify()` interface, which will update its Observers
    when the Subject's state has changed. The Subject will `Notify()` Observers by
    calling a polymorphic `Update()` method on each Observer in its collection.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题将包括一个`Notify()`接口，当主题的状态发生变化时，将更新其观察者。主题将通过在其集合中的每个观察者上调用多态的`Update()`方法来`Notify()`观察者。
- en: An Observer class will be modeled as an abstract class (or interface).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者类将被建模为一个抽象类（或接口）。
- en: An Observer interface will provide an abstract, polymorphic `Update()` method
    to be called when its associated Subject has changed its state.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者接口将提供一个抽象的、多态的`Update()`方法，当其关联的主题改变其状态时将被调用。
- en: An association from each Observer to its Subject will be maintained in a concrete
    class, derived from the Observer. Doing so will alleviate awkward casting (compared
    to maintaining the Subject link in the abstract Observer class).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从每个Observer到其Subject的关联将在一个具体类中维护，该类派生自Observer。这样做将减轻尴尬的转换（与在抽象Observer类中维护Subject链接相比）。
- en: Both classes will be able to maintain their current state.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个类将能够维护它们的当前状态。
- en: The aforementioned Subject and Observer classes are specified generically so
    that they may be combined with a variety of concrete classes (mostly through inheritance)
    that desire to use the Observer pattern. A generic Subject and Observer provides
    a great opportunity for reuse. With a design pattern, many core elements of a
    pattern can often be set up more generically to allow for greater reuse of the
    code itself, not only the reuse in the concept of the solution (pattern).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的Subject和Observer类是通用指定的，以便它们可以与各种具体类（主要通过继承）结合使用观察者模式。通用的Subject和Observer提供了很好的重用机会。通过设计模式，模式的许多核心元素通常可以更通用地设置，以允许代码本身更大程度的重用，不仅是解决方案概念的重用。
- en: Let's move forward to see a sample implementation of the Observer pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看观察者模式的一个示例实现。
- en: Implementing the Observer pattern
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现观察者模式
- en: To implement the Observer pattern, we will first need to define our `Subject`
    and `Observer` classes. We will then need to derive concrete classes from these
    classes to incorporate our application specifics and to put our pattern in motion.
    Let's get started!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现观察者模式，我们首先需要定义我们的“Subject”和“Observer”类。然后，我们需要从这些类派生具体类，以合并我们的应用程序特定内容并启动我们的模式。让我们开始吧！
- en: Creating Observer, Subject, and domain-specific derived classes
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Observer、Subject和特定领域的派生类
- en: In our example, we will create `Subject` and `Observer` classes to establish
    the framework for *registering* an `Observer` with a `Subject` and for the `Subject`
    to `Notify()` its set of observers of a state change it may have. We will then
    derive from these base classes descendent classes we are accustomed to seeing
    – `Course` and `Student`, where `Course` will be our concrete `Subject` and `Student`
    will become our concrete `Observer`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建“Subject”和“Observer”类来建立*注册*“Observer”与“Subject”以及“Subject”通知其一组观察者可能存在的状态更改的框架。然后，我们将从这些基类派生出我们习惯看到的派生类
    - “Course”和“Student”，其中“Course”将是我们的具体“Subject”，而“Student”将成为我们的具体“Observer”。
- en: The application we will model will involve a course registration system and
    the concept of a wait-list. As we have seen before in *Question 2* of [*Chapter
    10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386), *Implementing Association,
    Aggregation, and Composition*, we will model a `Student` having an association
    to many `Course` instances, and a `Course` having an association to many `Student`
    instances. The Observer pattern will come into play when we model our wait-list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建模的应用程序涉及课程注册系统和等待列表的概念。正如我们之前在[*第10章*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386)的*问题2*中所看到的，*实现关联、聚合和组合*，我们将对“Student”进行建模，将其与许多“Course”实例关联，并且“Course”与许多“Student”实例关联。当我们建模我们的等待列表时，观察者模式将发挥作用。
- en: Our `Course` class will be derived from `Subject`. The list of observers that
    our `Course` will inherit will represent the `Student` instances on this `Course`'s
    wait-list. The `Course` will also have a list of `Student` instances, representing
    students who have been successfully enrolled in the course at hand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Course”类将派生自“Subject”。我们的“Course”将继承的观察者列表将代表这个“Course”等待列表上的“Student”实例。
    “Course”还将有一个“Student”实例列表，代表已成功注册该课程的学生。
- en: Our `Student` class will be derived from both `Person` and `Observer`. The `Student`
    will include a list of `Course` instances in which that `Student` is currently
    enrolled. The `Student` will also have a member, `waitList`, which will correspond
    to an association to a `Course` that `Student` is waiting for. This *wait-list*
    `Course` represents the `Subject` from which we will receive notifications. A
    notification will correspond to a state change indicating that the `Course` now
    has room for a `Student` to add the `Course`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Student”类将派生自“Person”和“Observer”。 “Student”将包括“Student”当前注册的“Course”实例列表。
    “Student”还将有一个成员，“waitList”，它将对应于“Student”正在等待的“Course”的关联。这个*等待列表*“Course”代表我们将收到通知的“Subject”。通知将对应于状态更改，指示“Course”现在有空间让“Student”添加“Course”。
- en: It is from `Observer` that `Student` will inherit the polymorphic operation
    `Update()`, which will correspond to the `Student` being notified that a spot
    is now open in the `Course`. Here, in `Student::Update()`, we will add the mechanics
    to move a `Student` from the wait-list (there's a `waitList` data member) to the
    actual current student list in the `Course` (and to that student's current course
    list).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正是从“Observer”那里，“Student”将继承多态操作“Update()”，这将对应于“Student”被通知现在“Course”中有一个空位。在这里，在“Student::Update()”中，我们将添加机制，将“Student”从等待列表（有一个“waitList”数据成员）移动到“Course”中的实际当前学生列表（以及该学生的当前课程列表）。
- en: Specifying the Observer and the Subject
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定Observer和Subject
- en: 'Let''s break down our example into components, starting with the pair of classes
    to specify our `Observer` and `Subject`. This complete program can be found in
    our GitHub:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的示例分解成组件，从指定我们的“Observer”和“Subject”类开始。完整的程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16/Chp16-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16/Chp16-Ex1.cpp)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16/Chp16-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter16/Chp16-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous class definition, we introduce our abstract `Observer` class.
    Here, we include an `observerState` and protected constructors to initialize this
    state. We include a protected `SetState()` method to update this state from the
    scope of a derived class. We also include a public `GetState()` method. The addition
    of `GetState()` will facilitate implementation within our Subject's `Notify()`
    method by allowing us to easily check if the state of our `Observer` has changed.
    Though state information has historically been added to derived classes of both
    `Observer` and `Subject`, we will instead generalize state information in these
    base classes. This will allow our derived classes to remain more pattern-independent
    and instead focused on the essence of the application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们介绍了我们的抽象`Observer`类。在这里，我们包括一个`observerState`和受保护的构造函数来初始化这个状态。我们包括一个受保护的`SetState()`方法，以便从派生类的范围更新这个状态。我们还包括一个公共的`GetState()`方法。`GetState()`的添加将通过允许我们轻松检查`Observer`的状态是否已更改，有助于在我们的`Subject`的`Notify()`方法中实现。尽管状态信息历来是添加到`Observer`和`Subject`的派生类中，但我们将在这些基类中通用化状态信息。这将使我们的派生类保持更加独立于模式，并集中于应用程序的本质。
- en: Notice that our destructor is virtual, and we introduce an abstract method `virtual
    void Update() = 0;` to specify the interface our `Subject` will invoke on its
    list of observers to delegate updates to these `Observer` instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的析构函数是虚拟的，并且我们引入了一个抽象方法`virtual void Update() = 0;`来指定我们的`Subject`将在其观察者列表上调用的接口，以将更新委托给这些`Observer`实例。
- en: 'Now, let''s take a look at our `Subject` base class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的`Subject`基类：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned `Subject` class definition, we see that our `Subject`
    includes an STL `list` to collect its `Observer` instances. It also includes the
    `subjectState` and a counter to reflect the number of observers. Also, we include
    a data member to keep track of an uncorrupted iterator. We'll see this will be
    handy once we erase an element (`list::erase()` is an operation that will invalidate
    a current iterator).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Subject`类定义中，我们看到我们的`Subject`包括一个STL`list`来收集它的`Observer`实例。它还包括`subjectState`和一个计数器来反映观察者的数量。此外，我们还包括一个数据成员来跟踪一个未损坏的迭代器。一旦我们擦除一个元素（`list::erase()`是一个会使当前迭代器失效的操作），我们将看到这将会很方便。
- en: Our `Subject` class will also have protected constructors and a `SetState()`
    method, which initializes or sets the `Subject`'s state. Though this class is
    not technically abstract (it does not contain a pure virtual function), its constructors
    are protected to simulate an abstract class; this class is only intended to be
    constructed as a sub-object within a derived class instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Subject`类还将具有受保护的构造函数和一个`SetState()`方法，该方法初始化或设置`Subject`的状态。虽然这个类在技术上不是抽象的（它不包含纯虚函数），但它的构造函数是受保护的，以模拟抽象类；这个类只打算作为派生类实例中的子对象来构造。
- en: In the public interface, we have some access functions to get the current state
    or number of observers. We also have a virtual destructor, and virtual functions
    for `Register()`, `Release()`, and `Notify()`. We will provide implementations
    for the latter three methods at this base class level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共接口中，我们有一些访问函数来获取当前状态或观察者的数量。我们还有一个虚析构函数，以及`Register()`、`Release()`和`Notify()`的虚函数。我们将在这个基类级别为后三个方法提供实现。
- en: 'Let''s next take a look at the default implementations of `Register()`, `Release()`,
    and `Notify()` in our `Subject` base class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看在我们的`Subject`基类中`Register()`、`Release()`和`Notify()`的默认实现。
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned `Subject` member functions, let's begin by examining the
    `void Subject::Register(Observer *)` method. Here, we simply add the `Observer
    *` specified as a parameter to our STL `list` of observers (and increase the counter
    for the number of observers).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Subject`成员函数中，让我们从检查`void Subject::Register(Observer *)`方法开始。在这里，我们只是将指定的`Observer
    *`添加到我们的STL观察者列表中（并增加观察者数量的计数）。
- en: Next, let's consider the inverse of `Register()` by reviewing `void Subject::Release(Observer
    *)`. Here, we iterate through our list of observers until we find the one we are
    seeking. We then call `list::erase()` on that current item, set our `found` flag
    to `true` (to leave the loop), and decrement the number of observers. Also notice
    that we save the return value of `list::erase()`, which is an updated (and valid)
    iterator to the list of observers. The iterator `iter` in the loop has been invalidated
    with our call to `list::erase()`. We save this revised iterator in a data member
    `newIter` so that we can access it shortly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过审查`void Subject::Release(Observer *)`来考虑`Register()`的反向操作。在这里，我们遍历观察者列表，直到找到我们正在寻找的观察者。然后我们在当前项目上调用`list::erase()`，将我们的`found`标志设置为`true`（以退出循环），并减少观察者的数量。还要注意，我们保存了`list::erase()`的返回值，这是更新的（有效的）观察者列表的迭代器。循环中的迭代器`iter`在我们调用`list::erase()`时已经失效。我们将这个修改后的迭代器保存在一个数据成员`newIter`中，以便稍后访问它。
- en: Finally, let's take a look at the `Notify()` method in `Subject`. This method
    will be called once there is a state change in the `Subject`. The goal will be
    to `Update()` all observers on the `Subject`'s observer list. To do just that,
    we look through our list. One by one, we grab an `Observer` with the list iterator
    using `Observer *temp = *iter;`. We call `Update()` on the current `Observer`
    with `temp->Update();`. We can tell if the update has been a success for a given
    `Observer` by checking the observer's state using `if (temp->GetState() == 1)`.
    With a state of `1`, we know the observer's actions will have caused the `Release()`
    function we just reviewed to be called on itself. Because the `list::erase()`
    used in `Release()` has invalidated the iterator, we now get the correct and revised
    iterator using `iter = newIter;`. Finally, outside of the loop, we call `Update()`
    on the last item in the list of observers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`Subject`中的`Notify()`方法。一旦`Subject`中有状态变化，就会调用这个方法。目标是`Update()`所有`Subject`观察者列表上的观察者。为了做到这一点，我们逐个查看我们的列表。我们使用`Observer
    *temp = *iter;`使用列表迭代器逐个获取`Observer`。我们使用`temp->Update();`在当前`Observer`上调用`Update()`。我们可以通过检查观察者的状态`if
    (temp->GetState() == 1)`来判断给定`Observer`的更新是否成功。状态为`1`时，我们知道观察者的操作将导致我们刚刚审查的`Release()`函数被调用。因为`Release()`中使用的`list::erase()`已经使迭代器无效，所以我们现在使用`iter
    = newIter;`获取正确和修订后的迭代器。最后，在循环外，我们在观察者列表中的最后一项上调用`Update()`。
- en: Deriving concrete classes from Subject and Observer
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Subject和Observer派生具体类
- en: 'Let''s continue moving forward with this example by taking a look at our concrete
    classes derived from `Subject` or `Observer`. Let''s start with `Course`, derived
    from `Subject`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向前推进这个例子，看看我们从`Subject`或`Observer`派生的具体类。让我们从`Course`开始：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our aforementioned `Course` class, we include data members for the course
    title and number as well as for the total number of students currently enrolled.
    We also have our list of students currently enrolled, indicated by `Student *students[MAXNUMBERSTUDENTS];`.
    Additionally, keep in mind that we inherit the STL `list` of observers from our
    `Subject` base class. This list of `Observer` instances will represent the `Student`
    instances comprising our wait-list for the `Course`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`Course`类中，我们包括了课程标题和编号的数据成员，以及当前已注册学生的总数。我们还有我们当前已注册学生的列表，用`Student *students[MAXNUMBERSTUDENTS];`表示。此外，请记住我们从基类`Subject`继承了`Observer`的STL`list`。这个`Observer`实例列表将代表`Course`的等待列表中的`Student`实例。
- en: The `Course` class additionally includes a constructor, a virtual destructor,
    and simple access functions. Note that the virtual destructor has more work to
    do than shown – if a `Course` destructs, we must remember to first remove (but
    not delete) `Student` instances from the `Course`. Our `bool Course::AddStudent(Student
    *)` interface will allow us to add a `Student` to a `Course`. Of course, we should
    ensure that the `Student` has not already added to the `Course` in the body of
    this method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Course`类另外包括一个构造函数，一个虚析构函数和简单的访问函数。请注意，虚析构函数的工作比所示的更多 - 如果一个`Course`被销毁，我们必须首先记住从`Course`中删除（但不删除）`Student`实例。我们的`bool
    Course::AddStudent(Student *)`接口将允许我们向`Course`添加一个`Student`。当然，我们应该确保在这个方法的主体中`Student`尚未添加到`Course`中。'
- en: Our `void Course::Open();` method will be invoked on a `Course` to indicate
    that the course is now available to add students. Here, we will first set the
    state to `1` (indicating *Open for Enrollment*) and then call `Notify()`. Our
    `Notify()` method in the base class `Subject` loops through each `Observer`, calling
    polymorphic `Update()` on each observer. Each `Observer` is a `Student`; `Student::Update()`
    will allow each `Student` on the wait-list to try to add the `Course`, which now
    is open to receive students. With a successful addition to the course's current
    student list, a `Student` will then request `Release()` of its position on the
    wait-list (as an `Observer`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`void Course::Open();`方法将在`Course`上调用，表示该课程现在可以添加学生。在这里，我们首先将状态设置为`1`（表示*开放招生*），然后调用`Notify()`。我们基类`Subject`中的`Notify()`方法循环遍历每个`Observer`，对每个观察者调用多态的`Update()`。每个观察者都是一个`Student`；`Student::Update()`将允许等待列表上的每个`Student`尝试添加现在可以接收学生的`Course`。成功添加到课程的当前学生列表后，`Student`将请求在等待列表上释放其位置（作为`Observer`）。
- en: 'Next, let''s take a look at our class definition for `Student`, our concrete
    class derived from both `Person` and `Observer`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看我们从`Person`和`Observer`派生的具体类`Student`的类定义：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Briefly reviewing the aforementioned class definition for `Student`, we can
    see that this class is derived from both `Person` and `Observer` using multiple
    inheritance. Let's assume our `Person` class is as we have used it the past many
    times.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回顾上述`Student`类的类定义，我们可以看到这个类是通过多重继承从`Person`和`Observer`派生的。让我们假设我们的`Person`类就像我们过去多次使用的那样。
- en: In addition to the usual components of our `Student` class, we add the data
    member `Course *waitList;`, which will model the association to our `Subject`.
    This data member will model the idea of a `Course` that we would very much like
    to add, yet currently cannot, that is, a *wait-listed* course. Notice that this
    link is declared in the form of the derived type, `Course`, not the base type,
    `Subject`. This is typical in the Observer pattern and will help us avoid dreaded
    down-casting as we override our `Update()` method in `Student`. It is through
    this link that we will conduct our interaction with our `Subject` and the means
    by which we will receive updates from our `Subject` as it changes states.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们`Student`类的通常组件之外，我们还添加了数据成员`Course *waitList;`，它将模拟与我们的`Subject`的关联。这个数据成员将模拟我们非常希望添加的`Course`，但目前无法添加的*等待列表*课程的概念。请注意，这个链接是以派生类型`Course`而不是基本类型`Subject`声明的。这在观察者模式中很典型，并将帮助我们避免在`Student`中覆盖`Update()`方法时可怕的向下转换。通过这个链接，我们将与我们的`Subject`进行交互，并通过这种方式接收我们的`Subject`状态的更新。
- en: We also notice that we have `virtual void Update() override;` prototyped in
    `Student`. This method will allow us to override the pure virtual `Update()` method
    specified by `Observer`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到在`Student`中有`virtual void Update() override;`的原型。这个方法将允许我们覆盖`Observer`指定的纯虚拟`Update()`方法。
- en: 'Next, let''s review a selection of the various new member functions for `Student`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们审查`Student`的各种新成员函数的选择：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's review the previously listed member functions. Since we are accustomed
    to most of the necessary components and mechanics in the `Student` class, we will
    focus on the newly added `Student` methods, starting with an alternate constructor.
    Here, let us assume that we set most of the data members as usual. The key additional
    lines of code here are `waitList = c;` to set our wait-list entry to the desired
    `Course` (`Subject`) as well as `c->Register(this);`, where we add the `Student`
    (`Observer`) to the `Subject`'s list (the formal wait-list for the course).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾之前列出的成员函数。由于我们已经习惯了`Student`类中大部分必要的组件和机制，我们将专注于新添加的`Student`方法，从一个替代构造函数开始。在这里，让我们假设我们像往常一样设置了大部分数据成员。这里的关键额外代码行是`waitList
    = c;`将我们的等待列表条目设置为所需的`Course`（`Subject`），以及`c->Register(this);`，其中我们将`Student`（`Observer`）添加到`Subject`的列表（课程的正式等待列表）。
- en: Next, in our `bool Student::AddCourse(Course *)` method, we first check if we
    haven't exceeded our maximum allowed courses. If not, we go through the mechanics
    to add the association to link a `Student` and `Course` in both directions. That
    is, `courses[currentNumCourses++] = c;` to have the student's current course list
    to contain an association to the new `Course` as well as `c->AddStudent(this);`
    to ask the current `Course` to add the `Student` (`this`) to its enrolled student
    list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`bool Student::AddCourse(Course *)`方法中，我们首先检查是否已超过最大允许的课程数。如果没有，我们将通过机制来添加关联，以在两个方向上链接`Student`和`Course`。也就是说，`courses[currentNumCourses++]
    = c;`将学生当前的课程列表包含到新的`Course`的关联中，以及`c->AddStudent(this);`要求当前的`Course`将`Student`（`this`）添加到其已注册学生列表中。
- en: 'Let''s continue by reviewing the remainder of the new member functions for
    `Student`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续审查`Student`的其余新成员函数：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Continuing with the remainder of our previously mentioned Student member functions,
    next, in our polymorphic `void Student::Update()` method, we conduct the desired
    adding of a wait-list course. Recall, `Notify()` will be called when there is
    a state change on our `Subject` (`Course`). One such state change may be when
    a `Course` is *Open for Enrollment*, or perhaps a state of *New Space Available*
    now exists following a `Student` dropping the `Course`. `Notify()` then calls
    `Update()` on each `Observer`. Our `Update()` has been overridden in `Student`
    to get the state of the `Course` (`Subject`). If the state indicates the `Course`
    is now *Open for Enrollment*, we try `AddCourse(waitList);`. If this is a success,
    we set the state of the `Student` (`Observer`) to `1` (*Add Success*) to indicate
    that we have been successful in our `Update()`, which means we've added the `Course`.
    Next, since we have added the desired course to our current course list, we can
    now remove ourselves from the `Course`'s wait-list. That is, we will want to remove
    ourselves (`Student`) as an `Observer` from the `Subject` (the `Course`'s wait-list)
    using `waitList->Release(this);`. Now that we have added our desired wait-list
    course, we can also remove our link to the `Subject` using `waitList = 0;`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前提到的`Student`成员函数的其余部分，接下来，在我们的多态`void Student::Update()`方法中，我们进行了所需的等待列表课程添加。回想一下，当我们的`Subject`（`Course`）上有状态变化时，`Notify()`将被调用。这样的状态变化可能是当一个`Course`*开放注册*，或者可能是在`Student`退出`Course`后现在存在*新的空位可用*的状态。`Notify()`然后在每个`Observer`上调用`Update()`。我们在`Student`中重写了`Update()`来获取`Course`（`Subject`）的状态。如果状态表明`Course`现在*开放注册*，我们尝试`AddCourse(waitList);`。如果成功，我们将`Student`（`Observer`）的状态设置为`1`（*添加成功*），以表明我们在我们的`Update()`中取得了成功，这意味着我们已经添加了`Course`。接下来，因为我们已经将所需的课程添加到了我们当前的课程列表中，我们现在可以从`Course`的等待列表中移除自己。也就是说，我们将使用`waitList->Release(this);`将自己（`Student`）从`Subject`（`Course`的等待列表）中移除。现在我们已经添加了我们想要的等待列表课程，我们还可以使用`waitList
    = 0;`来移除我们与`Subject`的链接。
- en: Lastly, our aforementioned `Student` code includes a method to print the currently
    enrolled courses of the `Student` with `void Student::PrintCourses();`. This method
    is pretty straightforward.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们上述的`Student`代码包括一个方法来打印`Student`当前注册的课程，即`void Student::PrintCourses();`。这个方法非常简单。
- en: Bringing the pattern components together
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Let us now bring all of our various components together by taking a look at
    our `main()` function to see how our Observer pattern is orchestrated:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过查看我们的`main()`函数来将所有各种组件组合在一起，看看我们的观察者模式是如何被编排的：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reviewing our aforementioned `main()` function, we first instantiate three `Course`
    instances. We next instantiate five `Student` instances, utilizing a constructor
    that allows us to provide an initial `Course` that each `Student` would like to
    add when course registration commences. Note that these `Students` (`Observers`)
    will be added to the wait-list for their desired courses (`Subject`). Here, a
    `Subject` (`Course`) will have a list of `Observers` (`Students`) who wish to
    add the course when registration opens.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们之前提到的`main()`函数，我们首先实例化了三个`Course`实例。接下来，我们实例化了五个`Student`实例，利用一个构造函数，允许我们在课程注册开始时提供每个`Student`想要添加的初始`Course`。请注意，这些`Students`（`Observers`）将被添加到他们所需课程的等待列表（`Subject`）。在这里，一个`Subject`（`Course`）将有一个希望在注册开放时添加课程的`Observers`（`Students`）列表。
- en: Next, we see that a `Course` that many `Student` instances desire becomes *Open
    for Enrollment* for registration with `c1->Open();`. `Course::Open()` sets the
    state of the `Subject` to `1`, meaning the course is *Open for Enrollment* and
    then calls `Notify()`. As we know, `Subject::Notify()` will call `Update()` on
    the `Subject`'s list of observers. It is here that an initial wait-list `Course`
    instance will be added to a student's schedule and be subsequently removed as
    an `Observer` from the `Subject`'s wait-list.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到许多“Student”实例都希望的“Course”变为*开放注册*，使用“c1->Open();”进行注册。 “Course::Open()”将“Subject”的状态设置为“1”，表示课程*开放注册*，然后调用“Notify()”。正如我们所知，“Subject::Notify()”将在“Subject”的观察者列表上调用“Update()”。在这里，初始等待列表的“Course”实例将被添加到学生的日程表中，并随后从“Subject”的等待列表中作为“Observer”被移除。
- en: Now that registration is open, each `Student` will try to add more courses in
    the usual manner using `bool Student::AddCourse(Course *)`, such as with `s1.AddCourse(c2);`.
    Should a `Course` be full, the `Student` will be added to the `Course`'s wait-list
    (modeled as the inherited `Subject`'s list of observers). Recall, `Course` inherits
    from `Subject`, which keeps a list of students interested in adding a particular
    course (the wait-list of observers). When the `Course` state changes to *New Space
    Available*, students on the waitlist (observers) will be notified, and the `Update()`
    method on each `Student` will subsequently call `AddCourse()` for that `Student`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注册已经开放，每个“Student”将尝试以通常的方式添加更多课程，比如使用“bool Student::AddCourse(Course *)”，比如“s1.AddCourse(c2);”。如果一个“Course”已满，该“Student”将被添加到“Course”的等待列表（作为继承的“Subject”的观察者列表）。记住，“Course”继承自“Subject”，它保留了对特定课程感兴趣的学生的列表（观察者的等待列表）。当“Course”状态变为*新空间可用*时，等待列表上的学生（观察者）将收到通知，并且每个“Student”的“Update()”方法随后将为该“Student”调用“AddCourse()”。
- en: Once we have added various courses, we will then see each `Course` print its
    roster of students, such as `c2->PrintStudents()`. Likewise, we will then see
    each `Student` print the respective courses in which they are enrolled, such as
    with `s5.PrintCourses();`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了各种课程，我们将看到每个“Course”打印其学生名单，比如“c2->PrintStudents()”。同样，我们将看到每个“Student”打印他们所注册的课程，比如“s5.PrintCourses();”。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个程序的输出：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have now seen an implementation of the Observer pattern. We have folded the
    more generic `Subject` and `Observer` classes into the framework of classes we
    are accustomed to seeing, namely `Course`, `Person`, and `Student`. Let us now
    briefly recap what we have learned relating to patterns before moving forward
    to our next chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了观察者模式的实现。我们已经将更通用的“Subject”和“Observer”类折叠到了我们习惯看到的类的框架中，即“Course”、“Person”和“Student”。让我们现在简要回顾一下我们在模式方面学到的东西，然后继续下一章。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have begun our pursuit to become better C++ programmers
    by expanding our repertoire beyond OOP concepts to include the utilization of
    design patterns. Our primary goal is to enable you to solve recurring types of
    coding problems using *tried and true* solutions by applying common design patterns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始通过将我们的技能范围扩展到包括设计模式的利用，来使自己成为更好的C++程序员。我们的主要目标是通过应用常见的设计模式来解决重复类型的编程问题，从而使您能够使用*经过验证的*解决方案。
- en: We have first understood the purpose of design patterns and the advantage of
    employing them in our code. We have then specifically understood the premise behind
    the Observer pattern and how it contributes to OOP. Finally, we have taken a look
    at how we may implement the Observer pattern in C++.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先理解了设计模式的目的，以及在我们的代码中使用它们的优势。然后，我们具体理解了观察者模式的前提以及它对面向对象编程的贡献。最后，我们看了一下如何在C++中实现观察者模式。
- en: Utilizing common design patterns, such as the Observer pattern, will help you
    more easily solve recurring types of programming problems in a manner understood
    by other programmers. A key tenant in OOP is to strive for the reuse of components
    whenever possible. By utilizing design patterns, you will be contributing to reusable
    solutions with more sophisticated programming techniques.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 利用常见的设计模式，比如观察者模式，将帮助您更轻松地解决其他程序员理解的重复类型的编程问题。面向对象编程的一个关键原则是尽可能地重用组件。通过利用设计模式，您将为更复杂的编程技术做出可重用的解决方案。
- en: We are now ready to continue forward with our next design pattern in [*Chapter
    17*](B15702_17_Final_NM_ePub.xhtml#_idTextAnchor649), *Implementing the Factory
    Pattern*. Adding more patterns to our collection of skills makes us more versatile
    and valued programmers. Let's continue forward!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续前进，进入我们下一个设计模式[*第17章*]（B15702_17_Final_NM_ePub.xhtml#_idTextAnchor649），*实现工厂模式*。向我们的技能集合中添加更多的模式将使我们成为更多才多艺和受人重视的程序员。让我们继续前进！
- en: Questions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Using the online code for the example in this chapter as a starting point and
    the solution from a previous exercise (*Question 3*, [*Chapter 10*](B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386),
    *Implementing Association, Aggregation, and Composition*):'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章示例中的在线代码作为起点，并使用之前练习的解决方案（*问题3*，[*第10章*]（B15702_10_Final_NM_ePub.xhtml#_idTextAnchor386），*实现关联、聚合和组合*）：
- en: a. Implement (or modify your previous) `Student::DropCourse()`. When a `Student`
    drops a `Course`, this event will cause the `Course` state to become state `2`,
    *New Space Available*. With the state change, `Notify()` will then be called on
    the `Course` (`Subject`), which will then `Update()` the list of observers (students
    on the wait-list). `Update()` will indirectly allow wait-listed `Student` instances,
    if any, to now add the `Course`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: a. 实现（或修改之前的）“Student::DropCourse()”。当一个“Student”退课时，这个事件将导致“Course”的状态变为状态“2”，*新空间可用*。状态改变后，“Course”（“Subject”）上的“Notify()”将被调用，然后“Update()”将更新观察者列表（等待列表上的学生）。间接地，“Update()”将允许等待列表上的“Student”实例，如果有的话，现在添加这门“Course”。
- en: b. Lastly, in `DropCourse()`, remember to remove the dropped course from the
    student's current course list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: b. 最后，在“DropCourse()”中，记得从学生当前的课程列表中移除已经退课的课程。
- en: What other examples can you imagine that might easily incorporate the Observer
    pattern?
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能想象其他容易融入观察者模式的例子吗？
