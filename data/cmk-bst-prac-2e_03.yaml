- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Accessing CMake in the Best Ways
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以最佳方式访问 CMake
- en: In the previous chapter, we got acquainted with CMake and learned about its
    fundamental concepts. Now, we are going to learn how to interact with it. Learning
    how to interact with CMake is essential. Before you dive into structuring your
    software project with CMake, you must first learn how to configure, build, and
    install the existing ones. This will enable you to interact with CMake projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经了解了 CMake 并学习了它的基本概念。现在，我们将学习如何与它交互。学习如何与 CMake 交互非常重要。在开始使用 CMake
    构建你的软件项目之前，你必须先学会如何配置、构建和安装现有项目。这将使你能够与 CMake 项目进行交互。
- en: 'This chapter will look into what CMake has to offer as an interface and inspect
    some of the popular IDE and editor integrations. This chapter will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨 CMake 作为一个界面所提供的功能，并检查一些流行的 IDE 和编辑器集成。本章将涵盖以下内容：
- en: Using CMake via a command-line interface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过命令行界面使用 CMake
- en: Using `cmake-gui` and `ccmake` interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cmake-gui` 和 `ccmake` 界面
- en: IDE and editor integrations (Visual Studio, **Visual Studio Code** (**VSCode**),
    and Qt Creator)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE 和编辑器集成（Visual Studio、**Visual Studio Code**（**VSCode**）和 Qt Creator）
- en: Since we have a lot to cover, let’s not waste any time and get started with
    the technical requirements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有很多内容要讲解，因此不要浪费时间，直接开始技术要求。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before going further into detail, there are some requirements that need to
    be satisfied to follow the examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入详细内容之前，有一些要求需要满足，才能跟上示例的步伐：
- en: '**The CMake Best Practices repository**: This is the main repository that contains
    all the exemplary content for the book. It is accessible online at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake 最佳实践库**：这是包含本书所有示例内容的主要库。可以在线访问：[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/)。'
- en: 'Some examples in later chapters on packaging and dependency management use
    OpenSSL to illustrate how to work with third-party libraries. To install it, either
    use the package manager supplied by your operating system, such as `apt-get`,
    `chocolatey`, or `brew`, or download it from any of the links supplied in the
    OpenSSL wiki: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).
    OpenSSL was chosen because it is freely available for a wide variety of platforms
    and is easy to install.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续章节中关于打包和依赖管理的一些示例使用了 OpenSSL 来说明如何与第三方库一起工作。要安装它，可以使用操作系统提供的包管理器，例如 `apt-get`、`chocolatey`
    或 `brew`，或者从 OpenSSL wiki 中提供的任何链接下载：[https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)。选择
    OpenSSL 是因为它可以在多种平台上免费使用，并且易于安装。
- en: Using CMake via a command-line interface
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过命令行界面使用 CMake
- en: Although CMake is quite well integrated into many IDEs and editors, it is essentially
    a **command-line** tool, so learning how to use CMake in the **command-line interface**
    (**CLI**) is essential to use it to its full potential. Using CMake through the
    command line also helps to understand the inner workings and concepts of CMake.
    In this section, we are going to learn how to perform the most basic CMake operations
    using the CLI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CMake 已经很好地集成到许多 IDE 和编辑器中，但它本质上是一个 **命令行** 工具，因此学习如何在 **命令行界面** (**CLI**)
    中使用 CMake 是充分发挥其潜力的关键。通过命令行使用 CMake 还可以帮助理解 CMake 的内部工作原理和概念。在本节中，我们将学习如何使用 CLI
    执行最基本的 CMake 操作。
- en: 'Interactions with the CMake CLI can be done by issuing the `cmake` command
    in your operating system’s terminal, assuming that CMake is installed and the
    `cmake` executable is included in your system’s `PATH` variable (or equivalent).
    You can verify that by issuing `cmake` in your terminal without any parameters,
    as shown in the following figure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CMake CLI 的交互可以通过在操作系统终端中输入 `cmake` 命令来完成，前提是已安装 CMake 且 `cmake` 可执行文件已包含在系统的
    `PATH` 变量（或等效项）中。你可以通过在终端中输入 `cmake` 而不带任何参数来验证这一点，如下图所示：
- en: '![Figure 2.1 – Invoking the cmake command](img/B30947_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 调用 cmake 命令](img/B30947_02_01.jpg)'
- en: Figure 2.1 – Invoking the cmake command
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 调用 cmake 命令
- en: If your terminal is complaining about a missing command, then you should either
    install CMake (explained in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*) or make it discoverable by adding it to your system’s `PATH` variable.
    Consult your operating system’s guide about how to add a path to the system’s
    `PATH` variable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端提示缺少命令，您应该安装 CMake（在 [*第 1 章*](B30947_01.xhtml#_idTextAnchor015)，*启动 CMake*
    中有详细说明），或通过将其添加到系统的 `PATH` 变量中使其可被发现。请参考您的操作系统指南，了解如何将路径添加到系统的 `PATH` 变量。
- en: 'After installing CMake and adding it to the `PATH` variable (if required),
    you should test whether CMake is usable. The most basic command you can execute
    in the command line is `cmake --version`, which allows you to check CMake’s version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CMake 并将其添加到 `PATH` 变量中（如果需要），之后您应该测试 CMake 是否可用。您可以在命令行中执行的最基本命令是 `cmake
    --version`，该命令可以让您检查 CMake 的版本：
- en: '![Figure 2.2 – Checking for the CMake version in the terminal](img/B30947_02_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 在终端中检查 CMake 版本](img/B30947_02_02.jpg)'
- en: Figure 2.2 – Checking for the CMake version in the terminal
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 在终端中检查 CMake 版本
- en: CMake will output a version string in the form of `cmake version <maj.min.rev>`.
    You should see an output that contains the version number of the CMake you’ve
    installed on your system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 将以 `cmake version <maj.min.rev>` 的形式输出版本字符串。您应该看到一个包含您安装的 CMake 版本号的输出。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the version does not match the installed one, then you probably have multiple
    installations of CMake on your system. Since this book contains examples written
    for CMake version 3.23 and above, it is recommended to have that issue fixed before
    going any further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果版本与已安装的版本不匹配，可能是您的系统上安装了多个 CMake 版本。由于本书中的示例是为 CMake 版本 3.23 及以上编写的，建议在继续之前先解决该问题。
- en: After installing CMake, you should install your build system and compiler as
    well. For Debian-like operating systems (for example, Debian and Ubuntu), this
    can be easily done by issuing the `sudo apt install build-essential` command.
    This package essentially contains `gcc`, `g++`, and `make`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CMake 后，您还应该安装构建系统和编译器。对于 Debian 类操作系统（例如 Debian 和 Ubuntu），可以通过执行 `sudo apt
    install build-essential` 命令轻松完成。此软件包本质上包含 `gcc`、`g++` 和 `make`。
- en: The CLI usage will be illustrated in the Ubuntu 22.04 environment. Apart from
    the minor edge cases, the usage is the same in other environments as well. Those
    edge cases will be mentioned as we go on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 的使用将在 Ubuntu 22.04 环境中进行演示。除了少数边缘情况外，其他环境中的使用方法相同。那些边缘情况将在后续中提到。
- en: Learning the basics of the CMake CLI
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习 CMake CLI 基础知识
- en: 'The three basic things you should learn about using the CMake CLI are listed
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该学习的关于使用 CMake CLI 的三个基本知识点如下：
- en: Configuring a CMake project
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 CMake 项目
- en: Building a CMake project
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 CMake 项目
- en: Installing a CMake project
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 CMake 项目
- en: After learning the basics, you will be able to build and install any CMake project
    of your choice. Let’s get started with configuring.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 学习基础知识后，您将能够构建并安装任何您选择的 CMake 项目。让我们从配置开始。
- en: Configuring a project via the CLI
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 CLI 配置项目
- en: To configure a CMake project via the command line, you can use the `cmake -G
    "Unix Makefiles" -S <project_root> -B <output_directory>` construct. The `-S`
    argument is used to specify the CMake project to be configured, whereas `-B` specifies
    the *configure* output directory. Lastly, the `-G` argument allows us to specify
    the generator that will be used for the build system generation. The result of
    the configuration process will be written to `<output_directory>`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过命令行配置 CMake 项目，您可以使用 `cmake -G "Unix Makefiles" -S <project_root> -B <output_directory>`
    结构。`-S` 参数用于指定要配置的 CMake 项目，而 `-B` 指定 *配置* 输出目录。最后，`-G` 参数允许我们指定用于生成构建系统的生成器。配置过程的结果将写入
    `<output_directory>`。
- en: 'As an illustration, let’s configure our book’s example project into the project
    root `build` directory:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们将本书的示例项目配置到项目根目录 `build` 目录中：
- en: '![Figure 2.3 – Cloning the example code repository](img/B30947_02_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 克隆示例代码库](img/B30947_02_03.jpg)'
- en: Figure 2.3 – Cloning the example code repository
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 克隆示例代码库
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The project must already be present in your environment. If not, clone it via
    Git by issuing `git clone` `https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition.git`
    in your terminal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 项目必须已经存在于您的环境中。如果没有，请在终端中执行 `git clone` `https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition.git`
    通过 Git 克隆该项目。
- en: 'Now go into the `CMake-Best-Practices---2nd-Edition/chapter02/simple_example`
    directory and issue `cmake -G "Unix Makefiles" -S . -B ./build`, as shown in the
    following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入 `CMake-Best-Practices---2nd-Edition/chapter02/simple_example` 目录并执行 `cmake
    -G "Unix Makefiles" -S . -B ./build`，如以下截图所示：
- en: '![Figure 2.4 – Configuring the example code with CMake](img/B30947_02_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 使用 CMake 配置示例代码](img/B30947_02_04.jpg)'
- en: Figure 2.4 – Configuring the example code with CMake
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 使用 CMake 配置示例代码
- en: This command is like saying to CMake, *use the “Unix Makefiles” (-G “Unix Makefiles”)
    generator to generate a build system for the CMake project in the current directory
    (-S .) to the build (-B ./**build) directory*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令就像是对 CMake 说，*使用“Unix Makefiles”(-G "Unix Makefiles") 生成器在当前目录(-S .)为 CMake
    项目生成构建系统，并将其输出到构建(-B ./build)目录*。
- en: CMake will configure the project located in the current folder into the `build`
    folder. As we omitted the build type, CMake used the `Debug` build type (the default
    `CMAKE_BUILD_TYPE` value for the project).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 将把当前文件夹中的项目配置到 `build` 文件夹中。由于我们省略了构建类型，CMake 使用了 `Debug` 构建类型（这是项目的默认
    `CMAKE_BUILD_TYPE` 值）。
- en: In subsequent sections, we are going to learn about the fundamental settings
    that are used in the configure step.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将了解在配置步骤中使用的基本设置。
- en: Changing the build type
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改构建类型
- en: CMake does not assume any build type by default. To set the build type, an additional
    variable named `CMAKE_BUILD_TYPE` must be supplied to the `configure` command.
    To supply additional variables, the variable must be prefixed with `-D`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 默认情况下不会假定任何构建类型。要设置构建类型，必须向 `configure` 命令提供一个名为 `CMAKE_BUILD_TYPE` 的额外变量。要提供额外的变量，变量必须以
    `-D` 为前缀。
- en: 'To get the `Release` build instead of `Debug`, add the `CMAKE_BUILD_TYPE` variable
    in the `configure` command, as mentioned previously: `cmake -G "Unix Makefiles"
    -` `-S . -``B ./build`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `Release` 构建而不是 `Debug`，请在 `configure` 命令中添加 `CMAKE_BUILD_TYPE` 变量，如前所述：`cmake
    -G "Unix Makefiles" -S . -B ./build`。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `CMAKE_BUILD_TYPE` variable only makes sense for single-configuration generators,
    such as Unix Makefiles and Ninja. In multiple-configuration generators, such as
    Visual Studio, build type is a build-time parameter instead of a configuration-time
    parameter. Thus, it cannot be configured by using the `CMAKE_BUILD_TYPE` parameter.
    See the *Installing a specific configuration (for multiple-configuration generators
    only)* section for how to change the build type in such generators.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_BUILD_TYPE` 变量仅适用于单配置生成器，例如 Unix Makefiles 和 Ninja。在多配置生成器中，如 Visual
    Studio，构建类型是一个构建时参数，而不是配置时参数。因此，不能通过使用 `CMAKE_BUILD_TYPE` 参数来配置。请参见 *为多配置生成器安装特定配置*
    部分，了解如何在这些生成器中更改构建类型。'
- en: Changing the generator type
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改生成器类型
- en: 'Depending on the environment, CMake attempts to select an appropriate generator
    by default. To specify a generator explicitly, the `-G` argument must be supplied
    with a valid generator name. For example, if you want to use Ninja as a build
    system instead of make, you can change it as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境，CMake 默认尝试选择合适的生成器。要显式指定生成器，必须提供 `-G` 参数，并指定一个有效的生成器名称。例如，如果您想使用 Ninja
    作为构建系统而不是 make，可以按如下方式更改：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be similar to the command output shown in the following figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应与以下图中所示的命令输出相似：
- en: '![Figure 2.5 – Checking the CMake’s Ninja generator output](img/B30947_02_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 检查 CMake 的 Ninja 生成器输出](img/B30947_02_05.jpg)'
- en: Figure 2.5 – Checking the CMake’s Ninja generator output
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 检查 CMake 的 Ninja 生成器输出
- en: This will cause CMake to generate Ninja build files instead of Makefiles.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 CMake 生成 Ninja 构建文件，而不是 Makefiles。
- en: 'In order to see all available generator types for your environment, issue the
    `cmake --help` command. Available generators will be listed at the end of the
    **Help text generators** section, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看您环境中所有可用的生成器类型，可以执行 `cmake --help` 命令。可用的生成器将在 **Help text generators**
    部分的末尾列出，如下所示：
- en: '![Figure 2.6 – List of available generators in help](img/B30947_02_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 帮助中可用生成器的列表](img/B30947_02_06.jpg)'
- en: Figure 2.6 – List of available generators in help
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 帮助中可用生成器的列表
- en: The generator with an asterisk next to it is the default for the environment
    you’re currently in.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 带有星号的生成器是您当前环境的默认生成器。
- en: Changing the compiler
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改编译器
- en: In CMake, the compilers to be used are specified on a per-language basis via
    the `CMAKE_<LANG>_COMPILER` variables. In order to change the compiler for a language,
    `CMAKE_<LANG>_COMPILER` must be supplied to the `Configure` command. For a C/C++
    project, the variables usually overridden are `CMAKE_C_COMPILER` (C compiler)
    and `CMAKE_CXX_COMPILER` (C++ compiler). Compiler flags are similarly controlled
    by the `CMAKE_<LANG>_FLAGS` variable. This variable can be used to hold configuration-independent
    compiler flags.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，要使用的编译器是通过每种语言的 `CMAKE_<LANG>_COMPILER` 变量来指定的。为了更改某种语言的编译器，必须将 `CMAKE_<LANG>_COMPILER`
    参数传递给 `Configure` 命令。对于 C/C++ 项目，通常被覆盖的变量是 `CMAKE_C_COMPILER`（C 编译器）和 `CMAKE_CXX_COMPILER`（C++
    编译器）。编译器标志同样由 `CMAKE_<LANG>_FLAGS` 变量控制。此变量可用于存储与配置无关的编译器标志。
- en: 'As an example, let’s try to use `g++-12` as a C++ compiler in an environment
    where it is not the default compiler:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们尝试在一个 `g++-12` 不是默认编译器的环境中使用它作为 C++ 编译器：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we can see `g++-12` is used instead of the system’s default compiler,
    `g++-11`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到使用的是 `g++-12`，而不是系统默认的编译器 `g++-11`：
- en: '![Figure 2.7 – Configuring the project using a different compiler (g++-10)](img/B30947_02_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 使用不同编译器（g++-10）配置项目](img/B30947_02_07.jpg)'
- en: Figure 2.7 – Configuring the project using a different compiler (g++-10)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用不同编译器（g++-10）配置项目
- en: 'Without the compiler specification, CMake prefers to use `g++-9` in this environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定编译器，CMake 会优先在此环境中使用 `g++-9`：
- en: '![Figure 2.8 – Configuring behavior without a compiler preference](img/B30947_02_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 无编译器偏好配置行为](img/B30947_02_08.jpg)'
- en: Figure 2.8 – Configuring behavior without a compiler preference
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 无编译器偏好配置行为
- en: Passing flags to the compiler
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将标志传递给编译器
- en: 'To illustrate how to specify compiler flags, suppose that you want to enable
    all warnings and treat them as an error. These behaviors are controlled with the
    `-Wall` and `-Werror` compiler flags, respectively, in the `gcc` toolchain; thus,
    we need to pass these flags to the C++ compiler. The following code specifies
    how to do it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何指定编译器标志，假设你想启用所有警告并将其视为错误。这些行为分别通过 `gcc` 工具链中的 `-Wall` 和 `-Werror` 编译器标志进行控制；因此，我们需要将这些标志传递给
    C++ 编译器。以下代码说明了如何实现：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see the flags specified in the command (`-Wall` and `-Werror`) are passed
    into the compiler in the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在下面的示例中，命令中指定的标志（`-Wall` 和 `-Werror`）被传递给了编译器：
- en: '![Figure 2.9 – Passing flags to the C++ compiler](img/B30947_02_09.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 将标志传递给 C++ 编译器](img/B30947_02_09.jpg)'
- en: Figure 2.9 – Passing flags to the C++ compiler
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 将标志传递给 C++ 编译器
- en: 'Build flags can be customized for a per-build type by suffixing them with the
    capitalized build type string. There are four variables for four different build
    types, as listed next. They are useful for specifying build types depending on
    compiler flags. Flags specified in such variables are only valid when the configuration
    build type matches:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标志可以通过在其后添加大写的构建类型字符串来为每种构建类型定制。以下列出了四个不同构建类型的四个变量。它们在根据编译器标志指定构建类型时非常有用。仅当配置的构建类型匹配时，指定在这些变量中的标志才有效：
- en: '`CMAKE_<LANG>_FLAGS_DEBUG`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_FLAGS_DEBUG`'
- en: '`CMAKE_<LANG>_FLAGS_RELEASE`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_FLAGS_RELEASE`'
- en: '`CMAKE_<LANG>_FLAGS_RELWITHDEBINFO`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_FLAGS_RELWITHDEBINFO`'
- en: '`CMAKE_<LANG>_FLAGS_MINSIZEREL`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_FLAGS_MINSIZEREL`'
- en: In addition to the previous example, if you want to treat warnings as errors
    only in the `Release` builds, build-type-specific compiler flags allow you to
    do so.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的示例，如果你只想在 `Release` 构建中将警告视为错误，构建类型特定的编译器标志可以让你做到这一点。
- en: 'Here is an example that illustrates the usage of the build-type-specific compiler
    flags:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明如何使用构建类型特定编译器标志的示例：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that an additional `CMAKE_CXX_FLAGS_RELEASE` parameter is present in
    the preceding command. The contents in this variable will only be passed to the
    compiler when the build type is `Release`. Since the build type is specified as
    `Debug`, we can see the `-fpermissive` flag is not present in the flags passed
    to the compiler, as shown in the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的命令中存在一个额外的 `CMAKE_CXX_FLAGS_RELEASE` 参数。只有在构建类型为 `Release` 时，这个变量中的内容才会被传递给编译器。由于构建类型被指定为
    `Debug`，我们可以看到传递给编译器的标志中没有 `-fpermissive` 标志，如下图所示：
- en: '![Figure 2.10 – Specifying flags based on build type; the –fpermissive flag
    is missing in the Debug build](img/B30947_02_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 根据构建类型指定标志；在 Debug 构建中缺少 –fpermissive 标志](img/B30947_02_10.jpg)'
- en: Figure 2.10 – Specifying flags based on build type; the –fpermissive flag is
    missing in the Debug build
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 基于构建类型指定标志；在 Debug 构建中缺少 -fpermissive 标志
- en: 'In *Figure 2**.10*, notice that the `-fpermissive` flag does not appear in
    the build command and the results of grep are empty. This confirms that the `CMAKE_CXX_FLAGS_RELEASE`
    variable is not used in the `Debug` build type. When the build type is specified
    as `Release`, we can see that the `-O3` flag is present:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2.10* 中，注意到 `-fpermissive` 标志在构建命令中没有出现，而且 grep 的结果为空。这证实了 `CMAKE_CXX_FLAGS_RELEASE`
    变量在 `Debug` 构建类型中没有被使用。当构建类型指定为 `Release` 时，我们可以看到 `-O3` 标志存在：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this line, you are saying to CMake, configure the CMake project located in
    the current directory to the build/ folder using the “*Unix Makefiles*” generator.
    For all build types, pass the -*Wall and –Werror* flags to the compiler unconditionally.
    If the build type is Release, pass the -fpermissive flag as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，你告诉 CMake，在当前目录中配置 CMake 项目并将其构建到 build/ 文件夹，使用 “*Unix Makefiles*” 生成器。对于所有构建类型，毫不犹豫地将
    -*Wall 和 –Werror* 标志传递给编译器。如果构建类型是 Release，还需要传递 -fpermissive 标志。
- en: 'Here is the output of the command when the build type is set to `Release`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当构建类型设置为 `Release` 时命令的输出：
- en: '![Figure 2.11 – Specifying flags based on build type; the -fpermissive flag
    is present in the Release build](img/B30947_02_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 基于构建类型指定标志；在 Release 构建中存在 -fpermissive 标志](img/B30947_02_11.jpg)'
- en: Figure 2.11 – Specifying flags based on build type; the -fpermissive flag is
    present in the Release build
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 基于构建类型指定标志；在 Release 构建中存在 -fpermissive 标志
- en: In *Figure 2**.11*, we can confirm that the `-fpermissive` flag is passed to
    the compiler as well. Be aware that even though `RelWithDebInfo` and `MinSizeRel`
    are also release builds, they are separate from the `Release` build type, and
    so flags specified in the `CMAKE_<LANG>_FLAGS_RELEASE` variable will not apply
    to them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2.11* 中，我们可以确认 `-fpermissive` 标志也传递给了编译器。请注意，尽管 `RelWithDebInfo` 和 `MinSizeRel`
    也是 Release 构建，但它们与 `Release` 构建类型是不同的，因此在 `CMAKE_<LANG>_FLAGS_RELEASE` 变量中指定的标志不会应用到它们。
- en: The shortcut – using CMake presets
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快捷方式 – 使用 CMake 预设
- en: Using CMake over the command line offers quite a lot of configuration options,
    which gives a lot of control over the build process. However, it can also become
    quite hard to track all the different combinations of flags and arguments needed
    for the various configurations of a project. Before the introduction of *CMake
    presets* in CMake 3.21, keeping track of all the different flags needed to build
    a project could be quite a challenge. But luckily, CMake presets take away a lot
    of the tedious work here because almost all options that are passed to CMake over
    the command line can be represented in the presets as well. This is why they are
    a great way to preconfigure various combinations of CMake options. We will dive
    deeper into CMake presets in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*, but nowadays more and more projects
    come with presets pre-delivered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中使用 CMake 提供了大量的配置选项，这给予了对构建过程的很多控制。然而，它也可能变得相当困难，因为需要跟踪项目的各种配置所需的标志和参数组合。在
    CMake 3.21 引入 *CMake 预设* 之前，跟踪构建项目所需的所有不同标志可能是一个相当大的挑战。但幸运的是，CMake 预设简化了很多繁琐的工作，因为几乎所有通过命令行传递给
    CMake 的选项都可以在预设中表示。这就是为什么它们成为预先配置各种 CMake 选项组合的好方法。我们将在 [*第 9 章*](B30947_09.xhtml#_idTextAnchor146)
    中深入探讨 CMake 预设，*创建可复现的构建环境*，但如今越来越多的项目已经预先提供了预设。
- en: 'To list all available presets, use the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的预设，请使用以下命令：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To configure a project with a preset call, use the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预设调用来配置项目，请使用以下命令：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Once you are familiar with the basic options on how to configure CMake, we highly
    recommend using CMake presets to easily manage all different build configurations,
    compiler flags, and similar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了如何配置 CMake 的基本选项，我们强烈建议使用 CMake 预设，以便轻松管理所有不同的构建配置、编译器标志等。
- en: Listing cached variables
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出缓存变量
- en: You can list all cached variables by issuing the `cmake -L ./build/` command
    (see *Figure 2**.12*). This, by default, does not show the advanced variables
    and help strings associated with each variable. To show them as well, use the
    `cmake -LAH ./build/` command instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行 `cmake -L ./build/` 命令列出所有缓存变量（见 *图 2.12*）。默认情况下，这不会显示与每个变量相关的高级变量和帮助字符串。如果你想同时显示它们，请改用
    `cmake -LAH ./build/` 命令。
- en: '![Figure 2.12 – List of cached variables dumped by CMake](img/B30947_02_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – CMake 导出的缓存变量列表](img/B30947_02_12.jpg)'
- en: Figure 2.12 – List of cached variables dumped by CMake
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – CMake 导出的缓存变量列表
- en: Building a configured project via the CLI
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 CLI 构建配置好的项目
- en: To build the configured project, issue the `cmake --build ./``build` command.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建配置好的项目，执行 `cmake --build ./build` 命令。
- en: This command tells CMake to *build the CMake project already configured in the*
    *build folder*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 CMake *构建已经在* *构建文件夹中配置好的 CMake 项目*。
- en: You can also equivalently issue `cd build && make`. The benefit of using `cmake
    --build` is that it saves you from invoking build-system-specific commands. It
    is especially helpful when building CI pipelines or build scripts. In this way,
    you can change your build system generator without changing your build command.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以等效地执行 `cd build && make`。使用 `cmake --build` 的好处是它使您无需调用特定于构建系统的命令。当构建 CI
    流水线或构建脚本时，它尤其有用。通过这种方式，您可以更改构建系统生成器，而不必更改构建命令。
- en: 'You can see an example output for the `cmake --build ./build` command in the
    following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下示例中看到 `cmake --build ./build` 命令的输出示例：
- en: '![Figure 2.13 – Building a configured project](img/B30947_02_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 构建配置好的项目](img/B30947_02_13.jpg)'
- en: Figure 2.13 – Building a configured project
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 构建配置好的项目
- en: Building in parallel
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 并行构建
- en: You can also customize build-time details while issuing the build command. The
    most prominent build-time configuration is the number of jobs that will be used
    to build the project. To specify the job count, append `--parallel <job_count>`
    to your `cmake --``build` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行构建命令时，您还可以自定义构建时间的细节。最显著的构建时间配置是用于构建项目的作业数量。要指定作业数，可以将 `--parallel <job_count>`
    添加到您的 `cmake --build` 命令中。
- en: To build in parallel, issue `cmake --build ./build --parallel 2`, where the
    number `2` specifies the job count. The recommended number of jobs for a build
    system is, at most, *one job per hardware thread*. In multi-core systems, it is
    also recommended to use at least one less than the available hardware thread count
    to not affect the system’s responsivity during the build process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行并行构建，执行 `cmake --build ./build --parallel 2`，其中数字 `2` 表示作业数。构建系统推荐的作业数量是最多*每个硬件线程一个作业*。在多核系统中，还建议使用比可用硬件线程数少至少一个作业数，以避免在构建过程中影响系统的响应能力。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can usually use more than one job per hardware thread and get faster build
    times since the build process is mostly I/O bound, but your mileage may vary.
    Experiment and observe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以在每个硬件线程上使用多个作业并获得更快的构建时间，因为构建过程大多数是 I/O 限制的，但效果可能因人而异。请进行实验并观察。
- en: Also, some build systems, such as Ninja, will try to utilize as many hardware
    threads as are available in the system, so it is redundant to specify the job
    count for such build systems if your target is to use all hardware threads in
    your system. You can retrieve the hardware thread count by issuing the `nproc`
    command in Linux environments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些构建系统，如 Ninja，将尽量利用系统中可用的所有硬件线程，因此，如果您的目标是使用系统中的所有硬件线程，则为这些构建系统指定作业数是多余的。您可以通过在
    Linux 环境中执行 `nproc` 命令来获取硬件线程数。
- en: 'It is a good practice not to use fixed values for environment-dependent variables
    in the commands that are expected to be invoked in different environments, such
    as CI/CD scripts and build scripts. Here is an example `build` command that utilizes
    `nproc` to determine the number of parallel jobs dynamically:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在期望在不同环境中调用的命令中，最好不要为依赖环境的变量使用固定值，例如 CI/CD 脚本和构建脚本。下面是一个示例 `build` 命令，利用 `nproc`
    动态确定并行作业的数量：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s observe how different job counts affect the build time. We will use the
    `time` tool to measure how long each command invocation is. The environment details
    are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们观察不同的作业数量如何影响构建时间。我们将使用 `time` 工具来测量每次命令执行的时间。环境详情如下：
- en: '**Operating system**: Ubuntu 22.04'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**: Ubuntu 22.04'
- en: '**CPU**: 11th Gen Intel i19-11900H @2.5GHz'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**: 第11代 Intel i9-11900H @2.5GHz'
- en: '**RAM**: 32 GB'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**: 32 GB'
- en: 'With one job (`--parallel 1`), the build time result would be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个作业（`--parallel 1`），构建时间结果如下：
- en: '![Figure 2.14 – Parallelized build time result with one job](img/B30947_02_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 使用一个作业的并行构建时间结果](img/B30947_02_14.jpg)'
- en: Figure 2.14 – Parallelized build time result with one job
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 使用一个作业的并行构建时间结果
- en: 'The build time result with two jobs (`--parallel 4`) would be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个作业（`--parallel 4`）的构建时间结果如下：
- en: '![Figure 2.15 – Parallelized build time result with two jobs](img/B30947_02_15.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 使用两个任务的并行构建时间结果](img/B30947_02_15.jpg)'
- en: Figure 2.15 – Parallelized build time result with two jobs
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 使用两个任务的并行构建时间结果
- en: Even though invoked on a very simple project, we can clearly see how extra jobs
    help get faster build times.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在一个非常简单的项目中，我们也能清楚地看到额外的任务如何帮助加快构建时间。
- en: Building specific targets only
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅构建特定目标
- en: 'By default, CMake will build all available targets that are configured. Since
    building all the targets is not always desirable, CMake allows building a subset
    of targets via the `--target` sub-option. This sub-option may be specified multiple
    times, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake 会构建所有已配置的可用目标。由于构建所有目标并不总是理想的，CMake 允许通过 `--target` 子选项来构建目标的子集。该子选项可以多次指定，如下所示：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command will limit the build scope to just the `ch2_framework_component1`
    and `ch2_framework_component2` targets. If these targets also depend on other
    targets, they will be built as well.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将构建范围限制为仅包括 `ch2_framework_component1` 和 `ch2_framework_component2` 目标。如果这些目标还依赖于其他目标，它们也将被构建。
- en: Removing previous build artifacts before the build
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在构建之前删除之前的构建产物
- en: If you want to run a clean build, you may want to remove the artifacts from
    the previous run first. To do that, the `--clean-first` sub-option can be used.
    This sub-option will invoke a special target that cleans all the artifacts generated
    by the build process (makes clean).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想执行一次干净的构建，可能需要先删除之前运行时生成的产物。为此，可以使用 `--clean-first` 子选项。这个子选项会调用一个特殊的目标，清除构建过程中生成的所有产物（执行
    make clean）。
- en: 'Here is an example of how you can do it for a build folder named `build`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何为名为 `build` 的构建文件夹执行此操作的示例：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Debugging your build process
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试你的构建过程
- en: As we did in the *Passing flags to the compiler* section previously, you may
    want to inspect which commands are invoked with which arguments in the build process.
    The `--verbose` sub-command instructs CMake to invoke all build commands with
    verbose mode given that verbose mode is supported by the command. This enables
    us to investigate nasty compilation and linkage errors with ease.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面 *传递标志给编译器* 部分所做的那样，你可能希望检查在构建过程中哪些命令被调用，以及它们使用了哪些参数。`--verbose` 子命令指示
    CMake 在支持详细模式的命令下，以详细模式调用所有构建命令。这使我们能够轻松调查棘手的编译和链接错误。
- en: 'To build a folder named `build` in verbose mode, invoke `--build` as shown
    in the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要以详细模式构建名为 `build` 的文件夹，请按如下示例调用 `--build`：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Passing command-line arguments to the build tool
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向构建工具传递命令行参数
- en: 'If you ever need to pass arguments to the underlying build tool, you can append
    `--` at the end of the command and write the arguments that will be given:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将参数传递给底层构建工具，可以在命令末尾添加 `--` 并写下将要传递的参数：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding case, `--trace` will be directly forwarded to the build tool,
    which is `make` in our case. This will cause `make` to print tracing information
    for each recipe built.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的情况下，`--trace` 将直接传递给构建工具，在我们例子中是 `make`。这将使 `make` 打印每个构建配方的追踪信息。
- en: Installing a project via the CLI
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过命令行接口安装项目
- en: CMake natively allows the installation of artifacts to the environment, if desired.
    In order to do that, CMake code must be already using CMake `install()` instructions
    to specify what to install when `cmake --install` (or the build system equivalent)
    is invoked. The content of `chapter_2` is already configured in such a way as
    to illustrate the command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，CMake 本身允许将产物安装到环境中。为了做到这一点，CMake 代码必须已经使用 CMake `install()` 指令指定在调用 `cmake
    --install`（或构建系统等效命令）时要安装的内容。`chapter_2` 的内容已经以这种方式配置，以展示该命令。
- en: We’ll learn how to make CMake targets installable later in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a* *CMake Project*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 4 章*](B30947_04.xhtml#_idTextAnchor071)中学习如何使 CMake 目标可安装，*打包、部署和安装
    CMake 项目*。
- en: The `cmake --install` command requires an already configured and built project.
    Configure and build the CMake project if you haven’t done it yet. Afterward, issue
    the `cmake --install <project_binary_dir>` command to install the CMake project.
    Since in our examples `build` is used as a project binary directory, `<project_binary_dir>`
    will be replaced with `build`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake --install` 命令需要一个已经配置并构建过的项目。如果你还没有配置并构建 CMake 项目，请先配置并构建它。然后，发出 `cmake
    --install <project_binary_dir>` 命令来安装 CMake 项目。由于在我们的示例中 `build` 用作项目的二进制目录，`<project_binary_dir>`
    将被替换为 `build`。'
- en: 'The following figure shows an example of the `install` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了 `install` 命令的示例：
- en: '![Figure 2.16 – Installing a project](img/B30947_02_16.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 安装项目](img/B30947_02_16.jpg)'
- en: Figure 2.16 – Installing a project
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 安装项目
- en: The default installation directory varies between environments. For Unix-like
    environments, it defaults to `/usr/local`, whereas in a Windows environment, it
    defaults to `C:/Program Files`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认安装目录在不同环境之间有所不同。在类 Unix 环境中，默认安装目录为 `/usr/local`，而在 Windows 环境中，默认安装目录为 `C:/Program
    Files`。
- en: Tip
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that the project must already be built before trying to install
    the project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在尝试安装项目之前，项目必须已经构建完成。
- en: To be able to install the project successfully, you must have the appropriate
    rights/permissions to write to the installation target directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够成功安装项目，您必须具有适当的权限/许可，以便写入安装目标目录。
- en: Changing the default installation path
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改默认安装路径
- en: 'To change the default installation directory, you may specify the additional
    `--prefix` parameter, as shown here, to change the installation directory:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改默认安装目录，您可以指定额外的 `--prefix` 参数，如此处所示，以更改安装目录：
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following figure shows the contents of the `/tmp/example` folder after
    invoking `cmake --install` with the `/``tmp/example` prefix:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了在调用 `cmake --install` 并使用 `/tmp/example` 前缀后，`/tmp/example` 文件夹的内容：
- en: '![Figure 2.17 – Installing a project to a different path](img/B30947_02_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 将项目安装到不同路径](img/B30947_02_17.jpg)'
- en: Figure 2.17 – Installing a project to a different path
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 将项目安装到不同路径
- en: As can be seen here, the installation root is successfully changed to `/tmp/example`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如此处所示，安装根目录已成功更改为 `/tmp/example`。
- en: Stripping binaries while installing
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装时剥离二进制文件
- en: In the software world, build artifacts are usually bundled with some extra information,
    for example, a symbol table required for debugging. This information may not be
    necessary for executing the end product and may drastically increase binary sizes.
    If you’re looking to reduce your end product’s storage footprint, stripping binaries
    may be a good option. One additional benefit of stripping is that it makes it
    harder to reverse engineer binaries since essential symbol information is stripped
    away from the binaries.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件世界中，构建工件通常会捆绑一些额外的信息，例如调试所需的符号表。这些信息对于执行最终产品可能并不必要，并且可能大幅增加二进制文件的大小。如果您希望减少最终产品的存储占用，剥离二进制文件可能是一个不错的选择。剥离的另一个额外好处是，它使得逆向工程二进制文件变得更加困难，因为二进制文件中的关键信息符号被剥离掉了。
- en: 'CMake’s `--install` command allows the stripping of binaries while installing
    the operation. It can be enabled by specifying an additional `--strip` option
    to the `--install` command, as shown next:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 的 `--install` 命令允许在安装操作时剥离二进制文件。可以通过在 `--install` 命令中指定额外的 `--strip` 选项来启用此功能，如下所示：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following example, you can observe the size difference between unstripped
    and stripped binaries. Note that stripping static libraries has its own limitations
    and CMake does not perform it by default. You can see the size of the unstripped
    binaries in this figure:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您可以观察到未剥离和剥离二进制文件之间的大小差异。请注意，剥离静态库有其自身的限制，并且 CMake 默认情况下不会执行此操作。您可以在此图中看到未剥离二进制文件的大小：
- en: '![Figure 2.18 – Artifact size (unstripped)](img/B30947_02_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 工件大小（未剥离）](img/B30947_02_18.jpg)'
- en: Figure 2.18 – Artifact size (unstripped)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 工件大小（未剥离）
- en: 'With a stripped (`cmake –install build --strip`) binary, the size difference
    looks as shown in the following figure:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用剥离过的 (`cmake –install build --strip`) 二进制文件，大小差异如下图所示：
- en: '![Figure 2.19 – Artifact size (stripped)](img/B30947_02_19.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 工件大小（剥离）](img/B30947_02_19.jpg)'
- en: Figure 2.19 – Artifact size (stripped)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 工件大小（剥离）
- en: Installing specific components only (component-based install)
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅安装特定组件（基于组件的安装）
- en: If the project is using CMake’s `COMPONENT` feature in the `install()` commands,
    you may install specific components by specifying their component names. The `COMPONENT`
    feature allows separating installation into sub-parts. To illustrate this functionality,
    the `chapter_2` example is structured into two components named `libraries` and
    `executables`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目在 `install()` 命令中使用了 CMake 的 `COMPONENT` 功能，您可以通过指定组件名称来安装特定组件。`COMPONENT`
    功能允许将安装过程分为多个子部分。为了说明这个功能，`chapter_2` 示例被结构化为两个组件，分别命名为 `libraries` 和 `executables`。
- en: 'To install a specific component, an additional `--component` argument is needed
    along with the `cmake --``install` command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装特定组件，需要在 `cmake --install` 命令中添加一个额外的 `--component` 参数：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is an example invocation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例调用：
- en: '![Figure 2.20 – Installing a specific component only](img/B30947_02_20.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 仅安装特定组件](img/B30947_02_20.jpg)'
- en: Figure 2.20 – Installing a specific component only
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 仅安装特定组件
- en: Installing a specific configuration (for multiple-configuration generators only)
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装特定配置（仅适用于多配置生成器）
- en: Some of the generators support multiple configurations for the same build configuration
    (for example, Visual Studio). For that kind of generator, the `--install` option
    provides an additional `--config` argument to specify which configuration of binaries
    is intended to be installed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器支持相同构建配置的多种配置（例如，Visual Studio）。对于这种生成器，`--install` 选项提供了一个额外的 `--config`
    参数，用于指定要安装的二进制文件的配置。
- en: 'Here’s an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you may have noticed, the command parameters used in the examples are pretty
    long and explicit. This is intentional. Explicitly specifying arguments allows
    us to get consistent results in each run, no matter which environment we’re running
    our commands in. For example, without the `-G` argument, CMake will default to
    the environment’s preferred build system generator, which may not be our intention.
    Our motto here is, *being explicit is almost always better than being implicit*.
    The former makes our intention clearer and naturally enables more future-proof
    and maintainable CMake code in CI systems/scripts as well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，示例中使用的命令参数非常长且明确。这是故意的。明确指定参数可以确保我们每次执行时都能得到一致的结果，无论在哪个环境下运行我们的命令。例如，如果没有
    `-G` 参数，CMake 会默认使用环境中的首选构建系统生成器，这可能不是我们想要的结果。我们的座右铭是，*明确总比隐含好*。明确指定参数可以使我们的意图更清晰，并自然地使得在
    CI 系统/脚本中编写更具未来兼容性和可维护性的 CMake 代码。
- en: We have covered the fundamentals of CMake command-line usage. Let’s continue
    to learn about the other available interface form – the graphical interface of
    CMake.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了 CMake 命令行用法的基础知识。接下来让我们继续学习 CMake 的另一种可用界面形式——CMake 的图形界面。
- en: Advanced configuration using CMake-GUI and ccmake
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake-GUI 和 ccmake 进行高级配置
- en: Even though they look different, most interfaces tend to do the same thing;
    thus, most of the things we have already covered in the previous section are also
    valid here. Remember, we are going to change our form of interaction, not the
    tool we’re actually interacting with.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们看起来不同，但大多数界面做的事情基本相同；因此，我们在上一部分已经覆盖的内容在这里同样有效。记住，我们将改变的是交互的形式，而不是我们实际交互的工具。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before going any further, check whether the `ccmake` command is available in
    your terminal. If not, verify your `PATH` variable is set correctly and check
    your installation as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请检查你的终端中是否可以使用 `ccmake` 命令。如果不能，请确认你的 `PATH` 变量是否设置正确，并检查你的安装情况。
- en: Learning how to use ccmake (CMake curses GUI)
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何使用 ccmake（CMake curses GUI）
- en: '`ccmake` is a terminal-based `ncurses`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccmake` 是基于终端的 `ncurses`。'
- en: Since `ccmake` is not a part of the default CMake installation, it needs to
    be installed separately either over the package manager of your operating system
    or by downloading it from the CMake home page. Using `ccmake` is exactly the same
    as using CMake in a CLI, except it lacks the ability to invoke build and install
    steps. The main difference is that `ccmake` will show a terminal-based graphical
    interface for editing cached CMake variables interactively. This is a handy tool
    when you are experimenting with the settings. The status bar of `ccmake` will
    display a description for each setting and its possible values.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ccmake` 并不是默认安装的 CMake 包的一部分，它需要单独安装，可以通过操作系统的包管理器安装，或者从 CMake 官方网站下载并安装。使用
    `ccmake` 和在 CLI 中使用 CMake 完全相同，只是它无法调用构建和安装步骤。主要的区别是，`ccmake` 会显示一个基于终端的图形界面，便于交互式地编辑缓存的
    CMake 变量。当你在尝试设置时，这是一个非常方便的工具。`ccmake` 的状态栏会显示每个设置项的描述及其可能的值。
- en: 'To start using `ccmake`, use `ccmake` instead of `cmake` in the project configuration
    step. In our example, we will exactly replicate the CLI example we worked through
    previously in the *Configuring a project via the* *CLI* section:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 `ccmake`，在项目配置步骤中使用 `ccmake` 代替 `cmake`。在我们的示例中，我们将完全复制之前在 *通过 CLI 配置项目*
    部分中讲解的命令行示例：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following shows an example output for the preceding command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面命令的示例输出：
- en: '![Figure 2.21 – ccmake main screen](img/B30947_02_21.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – ccmake主屏幕](img/B30947_02_21.jpg)'
- en: Figure 2.21 – ccmake main screen
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – ccmake主屏幕
- en: After running the command, a terminal-based UI will appear. The initial page
    is the main page where CMake variables can be edited. `EMPTY CACHE` means no prior
    configuration has been made and the CMake cache file (`CmakeCache.txt`) is currently
    empty. To start editing variables, the project must be configured first. To configure,
    press the *C* key on the keyboard, as indicated in the `Keys:` section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，将出现基于终端的UI。初始页面是主页面，可以在其中编辑CMake变量。`EMPTY CACHE`表示没有进行过先前的配置，CMake缓存文件（`CMakeCache.txt`）目前为空。要开始编辑变量，必须首先进行项目配置。按键盘上的*C*键即可进行配置，如`Keys:`部分所示。
- en: 'After pressing the *C* key, the CMake configure step will be executed and the
    log output screen will be displayed with the configuration output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*C*键后，将执行CMake配置步骤，并显示带有配置输出的日志输出屏幕：
- en: '![Figure 2.22 – ccmake log screen after configuration](img/B30947_02_22.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 配置后ccmake日志屏幕](img/B30947_02_22.jpg)'
- en: Figure 2.22 – ccmake log screen after configuration
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 配置后ccmake日志屏幕
- en: 'To close the log output screen and return to the main screen, press *E*. Upon
    return, you will notice that `EMPTY CACHE` is replaced with variable names in
    the `CMakeCache.txt` file. To select a variable, use the up and down arrow keys
    on your keyboard. The currently selected variable will be highlighted in white,
    as seen in the next figure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭日志输出屏幕并返回主屏幕，请按*E*键。返回后，你会发现`EMPTY CACHE`已被`CMakeCache.txt`文件中的变量名替换。要选择一个变量，使用键盘上的上下箭头键。当前选中的变量会以白色高亮显示，如下图所示：
- en: '![Figure 2.23 – ccmake main screen after configuration](img/B30947_02_23.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 配置后ccmake主屏幕](img/B30947_02_23.jpg)'
- en: Figure 2.23 – ccmake main screen after configuration
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 配置后ccmake主屏幕
- en: 'In the preceding screenshot, the `CMAKE_BUILD_TYPE` variable is selected. On
    the right-hand side, the current value of the CMake variable is displayed. For
    `CMAKE_BUILD_TYPE`, it is empty right now. An asterisk next to the value of a
    variable means that the variable’s value has just changed with the prior configuration.
    You can either edit it by pressing the *Enter* key or delete it by pressing the
    *D* key on the keyboard. The following figure shows what the `ccmake` main screen
    looks like after changing the variable:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，选择了`CMAKE_BUILD_TYPE`变量。在右侧，显示了CMake变量的当前值。对于`CMAKE_BUILD_TYPE`，目前它是空的。变量值旁边的星号表示该变量的值在先前的配置中刚刚发生了变化。你可以按*Enter*键编辑它，或者按键盘上的*D*键删除它。下图展示了更改变量后的`ccmake`主屏幕：
- en: '![Figure 2.24 – ccmake main screen after variable change](img/B30947_02_24.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24 – 变量更改后的ccmake主屏幕](img/B30947_02_24.jpg)'
- en: Figure 2.24 – ccmake main screen after variable change
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 变量更改后的ccmake主屏幕
- en: 'Let’s set `CMAKE_BUILD_TYPE` to `Release` and configure again:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`CMAKE_BUILD_TYPE`设置为`Release`并重新配置：
- en: '![Figure 2.25 – ccmake configuration output (Release)](img/B30947_02_25.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25 – ccmake配置输出（Release）](img/B30947_02_25.jpg)'
- en: Figure 2.25 – ccmake configuration output (Release)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25 – ccmake配置输出（Release）
- en: We can observe that the build type is now set to `Release`. Return to the previous
    screen and save the changes by pressing the `g` (generate) button. The changes
    can be discarded by pressing the `q` (quit without generating) button.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到，构建类型现在已设置为`Release`。返回上一屏幕，按下`g`（生成）按钮以保存更改。按下`q`（不生成，退出）按钮可以丢弃更改。
- en: 'To edit other variables, such as `CMAKE_CXX_COMPILER` and `CMAKE_CXX_FLAGS`,
    advanced mode should be turned on. These variables are by default marked as advanced
    flags by calling the `mark_as_advanced()` CMake function; thus, they are hidden
    on graphical interfaces by default. On the main screen, press `t` to toggle to
    advanced mode:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑其他变量，例如`CMAKE_CXX_COMPILER`和`CMAKE_CXX_FLAGS`，需要启用高级模式。通过调用`mark_as_advanced()`
    CMake函数，这些变量默认被标记为高级标志，因此它们在图形界面中默认是隐藏的。在主屏幕上，按`t`键切换到高级模式：
- en: '![Figure 2.26 – ccmake in advanced mode](img/B30947_02_26.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.26 – 高级模式下的ccmake](img/B30947_02_26.jpg)'
- en: Figure 2.26 – ccmake in advanced mode
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 – 高级模式下的ccmake
- en: 'After activating advanced mode, a whole new set of options becomes visible.
    You can observe and alter their values, just as normal variables. You may have
    noticed that a previously hidden variable named `CHAPTER2_BUILD_DRIVER_APPLICATION`
    is now present. This is a user-defined CMake variable. This variable is defined
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 启用高级模式后，一整套新选项会变得可见。你可以像普通变量一样观察和修改它们的值。你可能已经注意到，之前隐藏的变量`CHAPTER2_BUILD_DRIVER_APPLICATION`现在出现了。这是一个用户定义的CMake变量。该变量定义如下：
- en: '[PRE17]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `CHAPTER2_BUILD_DRIVER_APPLICATION` variable is defined as a cache variable
    with the Boolean type, having a default value of `true`. It is marked as advanced,
    which is why it was not present in non-advanced mode.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAPTER2_BUILD_DRIVER_APPLICATION`变量被定义为布尔类型的缓存变量，默认值为`true`。它被标记为高级选项，因此在非高级模式下不会显示。'
- en: Using CMake via cmake-gui
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过cmake-gui使用CMake
- en: If you are the type of person who finds CLIs counter-intuitive, or you prefer
    the GUI over the CLI, CMake has a cross-platform GUI too. In contrast to `ccmake`,
    `cmake-gui` has more to offer, such as **Environment Editor** and **Regular**
    **Expression Explorer**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是那种觉得命令行界面（CLI）不直观，或者你更喜欢GUI而不是CLI的人，CMake也提供了一个跨平台的GUI。与`ccmake`相比，`cmake-gui`提供了更多功能，如**环境编辑器**和**正则表达式资源管理器**。
- en: The CMake GUI is not always part of the default CMake installation; depending
    on the operating system being used, it might need to be installed separately.
    Its main purpose is to allow a user to configure a CMake project. To launch `cmake-gui`,
    issue the `cmake-gui` command in your terminal. For Windows, it can also be located
    from the Start menu. If none of these methods work, go into your CMake installation
    path and it should be present in the `bin\` directory.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI并不总是默认包含在CMake安装中；根据使用的操作系统，它可能需要单独安装。它的主要目的是允许用户配置CMake项目。要启动`cmake-gui`，可以在终端中输入`cmake-gui`命令。在Windows上，它也可以从开始菜单找到。如果这些方法都无法工作，请进入CMake安装路径，它应该位于`bin\`目录中。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are launching `cmake-gui` in a Windows environment and you intend to
    use the toolchain provided by Visual Studio, launch `cmake-gui` from the appropriate
    Native Tools Command Prompt of your IDE. If you have multiple versions of IDE,
    ensure that you are using the correct Native Tools Command Prompt. Otherwise,
    CMake may fail to discover the required tools, such as a compiler, or may find
    incorrect ones. Refer to [https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019)
    for further information.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows环境下启动`cmake-gui`，并打算使用Visual Studio提供的工具链，请从IDE的相应“本地工具命令提示符”启动`cmake-gui`。如果你有多个版本的IDE，请确保使用正确的本地工具命令提示符。否则，CMake可能无法找到所需的工具（如编译器），或者可能会找到错误的工具。有关详细信息，请参考[https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/ide/reference/command-prompt-powershell?view=vs-2019)。
- en: 'Here is the main window of the CMake GUI:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CMake GUI的主窗口：
- en: '![Figure 2.27 – CMake GUI main window](img/B30947_02_27.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27 – CMake GUI主窗口](img/B30947_02_27.jpg)'
- en: Figure 2.27 – CMake GUI main window
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – CMake GUI主窗口
- en: 'The main screen of the CMake GUI essentially contains the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI的主屏幕基本包含以下内容：
- en: Source code path field
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码路径字段
- en: Output path field
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出路径字段
- en: Preset selection list
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预设选择列表
- en: '**Configure** and **Generate** buttons'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**和**生成**按钮'
- en: Cache variable list
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存变量列表
- en: These are the four essential things we are going to interact with. To start
    configuring a project, select the project’s root directory by clicking the **Browse
    Source…** button. Consequently, select an output directory for the project by
    clicking the **Browse Build…** button. This path will be the path for the generated
    output files by the selected generator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将要交互的四个基本内容。要开始配置项目，请通过点击**浏览源代码...**按钮选择项目的根目录。然后，通过点击**浏览构建...**按钮选择项目的输出目录。此路径将是通过所选生成器生成的输出文件的路径。
- en: 'If the project contains CMake presets, the presets can be selected from the
    presets list. Any cache variables modified by the preset will then be shown in
    the cache variables list. In the following example, a preset that configures Clang
    13 as the compiler and **Debug** as the build type is selected:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目包含CMake预设，可以从预设列表中选择预设。任何由预设修改的缓存变量将显示在缓存变量列表中。在以下示例中，选择了一个配置Clang 13作为编译器，并将**调试**作为构建类型的预设：
- en: '![Figure 2.28 – Selecting a preset from the CMake GUI](img/B30947_02_28.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28 – 从 CMake GUI 选择预设](img/B30947_02_28.jpg)'
- en: Figure 2.28 – Selecting a preset from the CMake GUI
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – 从 CMake GUI 选择预设
- en: 'After setting source and output paths, click **Configure** to start configuring
    the selected project. The CMake GUI will let you choose details such as the generator
    to be used, platform selection (if supported by the generator), toolset, and compiler,
    as shown in the following figure:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 设置源路径和输出路径后，点击**配置**以开始配置选定的项目。CMake GUI将允许你选择生成器、平台选择（如果生成器支持）、工具集和编译器等详细信息，如下图所示：
- en: '![Figure 2.29 – CMake GUI generator selection screen](img/B30947_02_29.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29 – CMake GUI 生成器选择界面](img/B30947_02_29.jpg)'
- en: Figure 2.29 – CMake GUI generator selection screen
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – CMake GUI 生成器选择界面
- en: 'After filling in these details according to your environment, click **Finish**
    to continue. The CMake GUI will start configuring your project with the given
    details and report the output in the log section. Upon successful configuration,
    you should also see the cache variables in the cache variable list section as
    well:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的环境填写这些详细信息后，点击**完成**继续。CMake GUI将开始使用给定的详细信息配置你的项目，并在日志区域报告输出。成功配置后，你还应该能在缓存变量列表区域看到缓存变量：
- en: '![Figure 2.30 – CMake GUI after configuration](img/B30947_02_30.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30 – 配置后的 CMake GUI](img/B30947_02_30.jpg)'
- en: Figure 2.30 – CMake GUI after configuration
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – 配置后的 CMake GUI
- en: If everything seems to be in order, press the `.sln` and `.cxxproj` along with
    other stuff. After generating the project, the `makefiles`), then generated files
    will be displayed instead. After that, you can use your IDE to build the project.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，点击`.sln`和`.cxxproj`以及其他文件。生成项目后，`makefiles`），然后会显示生成的文件。之后，你可以使用IDE来构建项目。
- en: Important note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Be aware that the generated project is just the generator’s artifact, and changes
    to the generated project files (`.sln`, `.cxxproj`) will not be saved and will
    be lost on the next generation. Don’t forget to re-generate project files when
    you make a change to the `CMakeLists.txt` files or edit a `CMakeCache.txt` file
    (either directly or indirectly). For the version-control aspect, you should treat
    generated project files as build artifacts and should not add them to version
    control. You can always obtain them from scratch by generating the project with
    an appropriate generator via CMake.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成的项目只是生成器的产物，对生成的项目文件（`.sln`，`.cxxproj`）所做的更改不会被保存，并将在下次生成时丢失。修改`CMakeLists.txt`文件或编辑`CMakeCache.txt`文件（无论是直接还是间接）时，别忘了重新生成项目文件。对于版本控制，应该将生成的项目文件视为构建产物，不应将其添加到版本控制中。你可以通过适当的生成器在CMake中重新生成项目，随时从头开始获取它们。
- en: 'Sometimes, a project may require tweaking some cache variables, or you may
    decide to use a different build type, for example. To change any cache variables,
    click on the value of the desired cache variable; it should become editable. Depending
    on the variable type, a checkbox may be displayed instead of a string. If the
    desired variable is not visible on the list, it may be an *advanced* variable,
    which can only be visible when the `cmake-gui` in advanced mode:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，项目可能需要调整某些缓存变量，或者你可能决定使用不同的构建类型。例如，要更改任何缓存变量，点击所需缓存变量的值；它应变为可编辑。根据变量类型，可能会显示复选框而不是字符串。如果所需变量未在列表中显示，它可能是*高级*变量，只有在`cmake-gui`处于高级模式时才能看到。
- en: '![Figure 2.31 – cmake-gui in advanced mode](img/B30947_02_31.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – cmake-gui 高级模式](img/B30947_02_31.jpg)'
- en: Figure 2.31 – cmake-gui in advanced mode
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – cmake-gui 高级模式
- en: After tweaking any cache values, click **Configure** and then **Generate** to
    apply the changes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 调整任何缓存值后，点击**配置**，然后点击**生成**以应用更改。
- en: Tip
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Another useful feature is the grouping feature, which allows the grouping of
    cache variables into their common prefix if there is one. Group names are determined
    by the first part of the variable name, up to the first underscore.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是分组功能，它允许将缓存变量根据其公共前缀进行分组（如果存在）。组名由变量名的第一部分决定，直到第一个下划线为止。
- en: We have covered the most essential features of `cmake-gui`. Before moving on
    to other miscellaneous stuff, if you ever need to reload cache values or delete
    the cache and start from scratch, you can find the **Reload Cache** and **Delete
    Cache** menu items in the **File** menu.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 `cmake-gui` 的最基本功能。在继续学习其他杂项内容之前，如果你需要重新加载缓存值或删除缓存并从头开始，你可以在**文件**菜单中找到**重新加载缓存**和**删除缓存**菜单项。
- en: Tweaking environment variables
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整环境变量
- en: 'The CMake GUI comes with a handy environment variable editor that allows CRUD
    operations to be carried out on environment variables. To access it, simply click
    the **Environment…** button on the main screen. After clicking it, the **Environment
    Editor** window will pop up, as can be seen in the following figure:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: CMake GUI 提供了一个便捷的环境变量编辑器，允许对环境变量执行增、删、改、查操作。要访问它，只需点击主屏幕上的**环境变量…**按钮。点击后，**环境变量编辑器**窗口将弹出，如下图所示：
- en: '![Figure 2.32 – CMake GUI environment variable editor](img/B30947_02_32.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.32 – CMake GUI 环境变量编辑器](img/B30947_02_32.jpg)'
- en: Figure 2.32 – CMake GUI environment variable editor
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – CMake GUI 环境变量编辑器
- en: The **Environment Editor** window contains a list of the environment variables
    present in the current environment. To edit an environment variable, double-click
    on the value field of the desired environment variable in the table. The window
    also allows adding and deleting information with the **Add Entry** and **Remove**
    **Entry** buttons.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境变量编辑器**窗口包含当前环境中存在的环境变量列表。要编辑环境变量，只需双击表格中所需环境变量的值字段。该窗口还允许使用**添加条目**和**删除条目**按钮来添加和删除信息。'
- en: Evaluating regular expressions with CMake
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 评估正则表达式
- en: 'Have you ever wondered how a regular expression would be evaluated by CMake
    and what results it would give exactly? If so, you may have previously debugged
    it manually by printing out the regex match result variables with `message()`.
    What if I say there is a better way to do it? Let me introduce you to the **Regular
    Expression Explorer** tool of the CMake GUI:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过，CMake 是如何评估正则表达式的，它到底会给出什么结果？如果是的话，你可能以前通过 `message()` 手动调试它，打印正则表达式匹配结果变量。那如果我告诉你有一种更好的方法呢？让我向你介绍
    CMake GUI 中的**正则表达式浏览器**工具：
- en: '![Figure 2.33 – CMake GUI Regular Expression Explorer](img/B30947_02_33.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33 – CMake GUI 正则表达式浏览器](img/B30947_02_33.jpg)'
- en: Figure 2.33 – CMake GUI Regular Expression Explorer
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 – CMake GUI 正则表达式浏览器
- en: 'This hidden gem allows you to debug regular expressions using CMake’s regex
    engine. It is located in the **Tools** menu with the name **Regular Expressions
    Explorer…**. Using it is pretty straightforward:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐藏的宝藏让你可以使用 CMake 的正则表达式引擎调试正则表达式。它位于**工具**菜单中，名称为**正则表达式浏览器…**。使用起来非常简单：
- en: Enter the expression into the **Regular** **Expression** field.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表达式输入到**正则表达式**字段中。
- en: The tool will check whether the expression is valid. If so, the **Valid** text
    on the screen will be green. It will turn red if CMake’s regex engine does not
    like the expression you’ve given.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该工具将检查表达式是否有效。如果有效，屏幕上的**有效**文本将显示为绿色。如果 CMake 的正则表达式引擎不喜欢你给出的表达式，它将变为红色。
- en: Enter the test string into the **Input Text** field. The regular expression
    will be matched against this text.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试字符串输入到**输入文本**字段中。正则表达式将与此文本进行匹配。
- en: If there is any match, the **Match** word on the window will turn from red to
    green. The matching string will be printed in the **Complete** **Match** field.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有任何匹配，窗口上的**匹配**字样将从红色变为绿色。匹配的字符串将显示在**完全匹配**字段中。
- en: On match, capture groups will be assigned to **Match 1**, **Match 2**, … **Match
    N**, respectively, if any.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配时，捕获组将分别分配给**匹配 1**、**匹配 2**、… **匹配 N**，如果有的话。
- en: In this section, we’ve learned how to use CMake’s native graphical interfaces.
    We will continue learning about using CMake by taking a look into a selection
    of CMake’s IDE and editor integrations next.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 CMake 的本地图形界面。接下来，我们将继续通过了解一些 CMake 的 IDE 和编辑器集成来学习如何使用 CMake。
- en: Using CMake in Visual Studio, VSCode, and Qt Creator
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Visual Studio、VSCode 和 Qt Creator 中使用 CMake
- en: Being a common tool in software development, CMake has integrations with a wide
    variety of IDEs and source code editors. Using such integrations while using an
    IDE or editor is perhaps more convenient for the user. In this section, we will
    cover how CMake integrates with some popular IDEs and editors.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发中的常用工具，CMake与各种IDE和源代码编辑器都有集成。在使用IDE或编辑器时，利用这些集成可能对用户来说更加方便。本节将介绍CMake如何与一些流行的IDE和编辑器集成。
- en: If you are expecting a guide about how to use an IDE or editor, this section
    is not going to be about that. The focus of this section is to investigate and
    learn about CMake integrations with such tools. This section assumes that you
    have existing experience with the IDE/editor you are going to interact with.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期待的是如何使用IDE或编辑器的指南，那么这一部分不涉及这方面的内容。本节的重点是探索并了解CMake与这些工具的集成。假设你已经具备与将要交互的IDE/编辑器的使用经验。
- en: Let’s start with Visual Studio.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Visual Studio开始。
- en: Visual Studio
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio
- en: '**Visual Studio** was one of the latecomers to the party when supporting CMake.
    Unlike other popular IDEs, Visual Studio had no native support for CMake until
    the year 2017\. In that year, Microsoft decided to make a move and introduced
    built-in support for handling CMake projects, which was shipped with Visual Studio
    2017\. Since then, it has been a solid feature of the Visual Studio IDE.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio**是支持CMake的后来的参与者之一。与其他流行的IDE不同，Visual Studio直到2017年才开始原生支持CMake。在那一年，微软决定行动，推出了内置支持CMake项目的功能，并随Visual
    Studio 2017一起发布。从那时起，这成为了Visual Studio IDE的一个重要功能。'
- en: To get started, obtain a copy of Visual Studio 2017 or later. For older versions
    of Visual Studio, the feature is completely absent. In our examples, we’ll be
    using Visual Studio 2022 Community Edition.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，请获取Visual Studio 2017或更高版本的副本。对于旧版本的Visual Studio，这个功能完全不可用。在我们的示例中，我们将使用Visual
    Studio 2022社区版。
- en: Starting a CMake project from scratch
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始创建CMake项目
- en: The Visual Studio project creation feature is based on project templates. With
    Visual Studio 2017 and upward, project templates contain a CMake project template
    as well. We are going to learn how to use this template to create new CMake projects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio的项目创建功能基于项目模板。从Visual Studio 2017及以后版本，项目模板中也包含了CMake项目模板。我们将学习如何使用这个模板来创建新的CMake项目。
- en: 'To create a new CMake project with Visual Studio, click the **Create a new
    project** button on the welcome page. Alternatively, you can access it by clicking
    on **File** | **New** | **Project** on the main IDE window, or using the *Ctrl*
    + *Shift* + *N* (**New Project**) keyboard shortcut. The Visual Studio 2022 welcome
    screen looks like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Visual Studio创建一个新的CMake项目，请点击欢迎页面上的**创建新项目**按钮。或者，你也可以通过点击**文件** | **新建**
    | **项目**来访问，或者使用*Ctrl* + *Shift* + *N*（**新建项目**）快捷键。Visual Studio 2022的欢迎屏幕如下所示：
- en: '![Figure 2.34 – Visual Studio 2022 welcome screen](img/B30947_02_34.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.34 – Visual Studio 2022 欢迎屏幕](img/B30947_02_34.jpg)'
- en: Figure 2.34 – Visual Studio 2022 welcome screen
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.34 – Visual Studio 2022 欢迎屏幕
- en: 'On the **Create a new project** screen, double-click on **CMake Project** in
    the project template list. You can filter project templates by using the search
    bar located at the top of the list:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在**创建新项目**屏幕上，双击项目模板列表中的**CMake项目**。你可以通过使用位于列表顶部的搜索栏来筛选项目模板：
- en: '![Figure 2.35 – Visual Studio 2022 Create a new project screen](img/B30947_02_35.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.35 – Visual Studio 2022 创建新项目屏幕](img/B30947_02_35.jpg)'
- en: Figure 2.35 – Visual Studio 2022 Create a new project screen
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.35 – Visual Studio 2022 创建新项目屏幕
- en: After clicking `CMakeProject1`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`CMakeProject1`之后。
- en: '![Figure 2.36 – Visual Studio 2022 new project configuration screen](img/B30947_02_36.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.36 – Visual Studio 2022 新项目配置屏幕](img/B30947_02_36.jpg)'
- en: Figure 2.36 – Visual Studio 2022 new project configuration screen
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.36 – Visual Studio 2022 新项目配置屏幕
- en: 'After filling in the details, click `CMakeLists.txt` file, a C++ source file,
    and a C++ header file, named after the chosen project name. The newly created
    project’s layout can be seen in the following figure:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 填写完详细信息后，点击`CMakeLists.txt`文件、C++源文件和一个C++头文件，文件名与选择的项目名称相同。新创建的项目布局如下图所示：
- en: '![Figure 2.37 – First glance after creating a new CMake project with Visual
    Studio](img/B30947_02_37.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.37 – 使用Visual Studio创建新CMake项目后的第一印象](img/B30947_02_37.jpg)'
- en: Figure 2.37 – First glance after creating a new CMake project with Visual Studio
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37 – 使用Visual Studio创建新CMake项目后的第一印象
- en: Opening an existing CMake project
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开现有CMake项目
- en: 'To open an existing CMake project, go to `CMakeLists.txt` file of the project
    to be opened. The following figure shows what the **Open** menu looks like:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个现有的 CMake 项目，请转到项目的 `CMakeLists.txt` 文件。下图显示了 **Open** 菜单的样子：
- en: '![Figure 2.38 – CMake project Open menu](img/B30947_02_38.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.38 – CMake 项目打开菜单](img/B30947_02_38.jpg)'
- en: Figure 2.38 – CMake project Open menu
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.38 – CMake 项目打开菜单
- en: Next, let’s see how a CMake project can be configured and built.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何配置和构建 CMake 项目。
- en: Configuring and building a CMake project
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置和构建 CMake 项目
- en: To build a CMake project in Visual Studio, go to `configure` step and generate
    the required build system files. After configuration, click **Build** | **Build
    All** to build the project. You can also trigger **Build All** by using the *F7*
    keyboard shortcut.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Visual Studio 中构建 CMake 项目，请进入 `configure` 步骤并生成所需的构建系统文件。配置完成后，点击 **Build**
    | **Build All** 来构建项目。你也可以通过使用 *F7* 快捷键来触发 **Build All**。
- en: Note that Visual Studio will automatically invoke `configure` whenever you save
    a `CMakeLists.txt` file, which is a part of the project.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当你保存 `CMakeLists.txt` 文件时，Visual Studio 会自动调用 `configure`，该文件是项目的一部分。
- en: Executing common actions on a CMake target
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行 CMake 目标上的常见操作
- en: 'Visual Studio uses the *startup target* concept for target-requiring actions,
    such as build, debug, and launch. To set a CMake target as a startup target, use
    the **Select Startup Target** drop-down box located on the toolbar. Visual Studio
    will automatically populate this drop-down box with CMake targets on configuration:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 使用 *启动目标* 概念来进行需要目标的操作，如构建、调试和启动。要将 CMake 目标设置为启动目标，请使用工具栏上的 **Select
    Startup Target** 下拉框。Visual Studio 会在配置时自动将 CMake 目标填充到这个下拉框中：
- en: '![Figure 2.39 – Startup target selection drop-down menu](img/B30947_02_39.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.39 – 启动目标选择下拉菜单](img/B30947_02_39.jpg)'
- en: Figure 2.39 – Startup target selection drop-down menu
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.39 – 启动目标选择下拉菜单
- en: 'After setting a startup target, you can invoke actions such as debug, build,
    or launch just as always you do in Visual Studio:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 设置启动目标后，你可以像在 Visual Studio 中一样调用调试、构建或启动等操作：
- en: To debug, first, click on **Debug** | **Startup Target**, then click **Debug**
    | **Start Debugging** or use the *F5* keyboard shortcut.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行调试，首先点击 **Debug** | **Startup Target**，然后点击 **Debug** | **Start Debugging**
    或使用 *F5* 快捷键。
- en: To start without debugging, click on **Start without debug** or use the *Ctrl*
    + *F5* keyboard shortcut.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在不调试的情况下启动，请点击 **Start without debug** 或使用 *Ctrl* + *F5* 快捷键。
- en: To build, click on **Build**, click on **Build** | **Build <target>**, or use
    the *Ctrl* + *B*keyboard shortcut.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行构建，点击 **Build**，点击 **Build** | **Build <target>**，或使用 *Ctrl* + *B* 快捷键。
- en: 'Button locations are shown in the following figure:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按钮位置如下面的图所示：
- en: '![Figure 2.40 – Toolbar button locations](img/B30947_02_40.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.40 – 工具栏按钮位置](img/B30947_02_40.jpg)'
- en: Figure 2.40 – Toolbar button locations
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.40 – 工具栏按钮位置
- en: In this section, we’ve covered the basics of the Visual Studio CMake integration.
    In the next section, we’ll continue to learn with another Microsoft product, VSCode.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们已经介绍了 Visual Studio CMake 集成的基础知识。在下一节中，我们将继续学习另一个 Microsoft 产品——VSCode。
- en: Visual Studio Code
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: VSCode is an open source code editor developed by Microsoft. It is not an IDE
    but can become powerful and have IDE-like features via extensions. The extensions
    market has a wide variety of additional content, from themes to language servers.
    You can find an extension for pretty much anything, which makes VSCode both powerful
    and liked by a wide audience. Unsurprisingly, VSCode has an official CMake extension
    too. This extension was originally developed by Colby Pike (also known as *vector-of-bool*)
    but it is now officially maintained by Microsoft.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: VSCode 是微软开发的开源代码编辑器。它不是一个 IDE，但通过扩展可以变得强大并拥有类似 IDE 的功能。扩展市场有各种各样的附加内容，从主题到语言服务器。你几乎可以找到任何东西的扩展，这使得
    VSCode 既强大又受到广泛用户的喜爱。毫不奇怪，VSCode 也有官方的 CMake 扩展。该扩展最初由 Colby Pike（也被称为 *vector-of-bool*）开发，但现在由
    Microsoft 官方维护。
- en: In this section, we are going to learn how to install the extension and perform
    basic CMake tasks using it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将学习如何安装扩展并使用它执行基本的 CMake 任务。
- en: Before going any further, VSCode must already be installed in your environment.
    If not, visit [https://code.visualstudio.com/learn/get-started/basics](https://code.visualstudio.com/learn/get-started/basics)
    for details on downloading and installing it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，VSCode 必须已经安装在你的环境中。如果没有，请访问 [https://code.visualstudio.com/learn/get-started/basics](https://code.visualstudio.com/learn/get-started/basics)
    获取下载和安装的详细信息。
- en: 'Also, we will frequently access the Command Palette. It is strongly recommended
    to use it often to gain familiarity. For those asking *What the heck is the Command
    Palette?*, here is a screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们将频繁访问命令面板。强烈建议经常使用它，以便熟悉它。对于那些问*“命令面板到底是什么？”*的人，下面是一个截图：
- en: '![Figure 2.41 – VSCode Command Palette](img/B30947_02_41.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图2.41 – VSCode命令面板](img/B30947_02_41.jpg)'
- en: Figure 2.41 – VSCode Command Palette
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.41 – VSCode命令面板
- en: Yeah, it is *that* thing. To be honest, I did not know it had a name until now.
    Shortcuts for accessing the Command Palette are *F1* and *Ctrl* + *Shift* + *P*.
    The Command Palette is the bread and butter of VSCode; it speeds up the VSCode
    workflow.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，*就是*那个东西。说实话，直到现在我才知道它有个名字。访问命令面板的快捷键是*F1*和*Ctrl* + *Shift* + *P*。命令面板是VSCode的核心，它能加速VSCode的工作流程。
- en: Installing the extension
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装扩展
- en: 'Installing the extension is pretty straightforward. To install it by using
    a CLI, invoke the following command (replace `code` with `code-insiders` if you’re
    using the Insiders edition):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展是相当简单的。你可以通过CLI安装，使用以下命令（如果你使用的是Insiders版本，请将`code`替换为`code-insiders`）：
- en: '[PRE18]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, you can do the same in the VSCode GUI as well. Open VSCode and
    navigate to the `CMake Tools` into the extension search box and select **CMake
    Tools** from **Microsoft**. Be careful not to confuse it with the CMake extension.
    Press the **Install** button to install it:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以通过VSCode的图形界面做同样的操作。打开VSCode并在扩展搜索框中输入`CMake Tools`，然后选择**CMake Tools**（由**Microsoft**提供）。要小心不要与CMake扩展混淆。点击**安装**按钮来安装：
- en: '![Figure 2.42 – VSCode extensions marketplace](img/B30947_02_42.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图2.42 – VSCode扩展市场](img/B30947_02_42.jpg)'
- en: Figure 2.42 – VSCode extensions marketplace
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.42 – VSCode扩展市场
- en: After the installation is complete, the extension is ready to use.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，扩展就可以使用了。
- en: Quick Start project
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速开始项目
- en: 'The VSCode CMake Tools extension offers a `cmake quick start`. Select **CMake:
    Quick Start** and press *Enter* on the keyboard.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'VSCode CMake Tools扩展提供了一个`cmake quick start`。选择**CMake: Quick Start**并按下键盘上的*Enter*键。'
- en: '![Figure 2.43 – Command Palette – Locating CMake: Quick Start](img/B30947_02_43.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图2.43 – 命令面板 – 定位CMake: Quick Start](img/B30947_02_43.jpg)'
- en: 'Figure 2.43 – Command Palette – Locating CMake: Quick Start'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '图2.43 – 命令面板 – 定位CMake: Quick Start'
- en: Firstly, the extension will ask which kit to use. Select the one that is appropriate
    for your new project. Kits will be further discussed in the *Dealing with* *kits*
    section.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，扩展会询问使用哪个工具链。选择适合你新项目的工具链。关于工具链的更多信息将在*处理工具链*部分中讨论。
- en: After selecting a kit, you will be asked to input a project name. This will
    be the name of your top-level CMake project. Enter a name of your choice.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择好工具链后，系统会提示你输入项目名称。这将是你顶级CMake项目的名称。输入你选择的名称。
- en: Lastly, a choice for example application code will be shown. In this choice,
    you will be asked to create an executable application project or a library project.
    Select one, and voilà! You’ve got yourself a working CMake project. Upon selection,
    the `CMakeLists.txt` and `main.cpp` files will be generated. The content of these
    files slightly varies between executable and library choices.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将显示一个示例应用程序代码的选择。在此选择中，你将被要求创建一个可执行应用程序项目或一个库项目。选择其中之一，瞧！你就拥有了一个工作中的CMake项目。选择后，`CMakeLists.txt`和`main.cpp`文件将被生成。这些文件的内容在可执行文件和库的选择之间稍有不同。
- en: Opening an existing project
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开现有项目
- en: There is nothing special about opening a CMake project in VSCode. Open the folder
    that contains the top-level `CMakeLists.txt` file of your project. The CMake Tools
    extension will automatically recognize this folder as a CMake project, and all
    CMake-related commands will become available on the VSCode Command Palette. Upon
    opening an existing project, you will be asked whether the project should be configured.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中打开CMake项目并没有什么特别的。只需打开包含项目顶级`CMakeLists.txt`文件的文件夹。CMake Tools扩展将自动识别该文件夹为CMake项目，所有与CMake相关的命令将会在VSCode的命令面板上可用。打开现有项目时，系统会询问是否配置该项目。
- en: '![Figure 2.44 – VSCode asking whether an existing project should be configured](img/B30947_02_44.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图2.44 – VSCode询问是否配置现有项目](img/B30947_02_44.jpg)'
- en: Figure 2.44 – VSCode asking whether an existing project should be configured
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.44 – VSCode询问是否配置现有项目
- en: If the project supports CMake presets, you will be automatically asked which
    preset to select. If the project does not support presets, then you will be asked
    to select a compiler toolchain, as explained in the *Dealing with kits* section
    later in this chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目支持 CMake 预设，你将自动被询问选择哪个预设。如果项目不支持预设，那么你将被要求选择一个编译器工具链，稍后在本章的*处理 kits* 部分将对此进行解释。
- en: '![Figure 2.45 – Selecting a CMake preset in VSCode](img/B30947_02_45.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.45 – 在 VSCode 中选择 CMake 预设](img/B30947_02_45.jpg)'
- en: Figure 2.45 – Selecting a CMake preset in VSCode
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.45 – 在 VSCode 中选择 CMake 预设
- en: And with that, we are ready to configure the project.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经准备好配置项目。
- en: Configuring, building, and cleaning a project
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置、构建和清理项目
- en: 'To configure a CMake project, select the **CMake: Configure** menu item from
    the Command Palette. To build the project, choose a build target by selecting
    the **CMake: Set Build Target** menu item from the Command Palette. This will
    let you choose what will be built when a build is invoked. Lastly, select **CMake:
    Build** to build the selected build target. To build a specific target without
    setting it as a build target, use the **CMake: Build Target** menu item.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '要配置一个 CMake 项目，从命令面板中选择**CMake: Configure**菜单项。要构建项目，选择构建目标，点击**CMake: Set
    Build Target**菜单项。这将让你选择在触发构建时将构建哪个目标。最后，选择**CMake: Build**以构建选定的构建目标。如果要在不将其设置为构建目标的情况下构建特定目标，可以使用**CMake:
    Build Target**菜单项。'
- en: To clean build artifacts, use the `clean` target and remove any build artifacts.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理构建产物，请使用`clean`目标并删除所有构建产物。
- en: Debugging a target
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试目标
- en: 'To debug a target, choose a debug target by selecting the **CMake: Set Debug
    Target** menu item from the Command Palette. You’ll see the debuggable targets
    listed:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '要调试一个目标，选择**CMake: Set Debug Target**菜单项，从命令面板中选择调试目标。你将看到列出所有可调试的目标：'
- en: '![Figure 2.46 – Debug target selection](img/B30947_02_46.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.46 – 调试目标选择](img/B30947_02_46.jpg)'
- en: Figure 2.46 – Debug target selection
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.46 – 调试目标选择
- en: 'Select the target and select **CMake: Debug** (*Ctrl* + *F5*) from the Command
    Palette. The selected target will be started under the debugger.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '选择目标并从命令面板中选择**CMake: Debug**（*Ctrl* + *F5*）。选定的目标将在调试器下启动。'
- en: 'If you want to run the selected target without the debugger, select **CMake:
    Run Without Debugging** (*Shift* + *F5*) instead.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想在不使用调试器的情况下运行选定的目标，请选择**CMake: Run Without Debugging**（*Shift* + *F5*）。'
- en: '![Figure 2.47 – Executable Chapter1 target being debugged](img/B30947_02_47.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.47 – 正在调试的可执行 Chapter1 目标](img/B30947_02_47.jpg)'
- en: Figure 2.47 – Executable Chapter1 target being debugged
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.47 – 正在调试的可执行 Chapter1 目标
- en: In the next section, we will look at how we can provide arguments to the debugged
    target.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何为调试目标提供参数。
- en: Passing arguments to the debugged target
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向调试目标传递参数
- en: 'The target you’re trying to debug might need command-line arguments. To pass
    command-line arguments to the debug target, open VSCode `settings.json` and append
    the following lines:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你要调试的目标可能需要命令行参数。要向调试目标传递命令行参数，请打开 VSCode 的 `settings.json` 并追加以下行：
- en: '[PRE19]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `args` JSON array, you can place any number of arguments your target
    requires. These arguments will be passed to all future debug targets unconditionally.
    If you want to have fine-grained control over the arguments, it is better to define
    a `launch.json` file instead.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `args` JSON 数组中，你可以放置目标所需的任何数量的参数。这些参数将无条件地传递给所有未来的调试目标。如果你想对参数进行精细控制，最好还是定义一个
    `launch.json` 文件。
- en: Dealing with kits
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理 kits
- en: A kit in the CMake Tools extension represents a combination of tools that can
    be used to build the project; hence, the term *kit* is pretty much a synonym for
    the toolchain. Kits make it easier to work in a multi-compiler environment, allowing
    the user to choose which exact compiler to work with. Kits can be discovered automatically
    by the extension, read from toolchain files, or defined by the user manually.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: CMake Tools 扩展中的 kit 代表了一组可用于构建项目的工具组合；因此，*kit* 这个术语几乎可以视为工具链的同义词。Kit 使得在多编译器环境中工作变得更加简便，允许用户选择使用哪种编译器。Kit
    可以通过扩展自动发现，或者通过工具链文件读取，或由用户手动定义。
- en: 'To see available kits for a project, select the **CMake: Select a Kit** menu
    item from the Command Palette (*F1* or *Ctrl* + *Shift* + *P*).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '要查看项目的可用 kits，请从命令面板中选择**CMake: Select a Kit**菜单项（*F1* 或 *Ctrl* + *Shift* +
    *P*）。'
- en: '![Figure 2.48 – Kit selection list](img/B30947_02_48.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.48 – Kit 选择列表](img/B30947_02_48.jpg)'
- en: Figure 2.48 – Kit selection list
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.48 – Kit 选择列表
- en: The selected kit will be used to configure the CMake project, which means the
    tools that are defined in the kit will be used to compile the project. Kit selection
    will automatically trigger a CMake configuration.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的工具包将用于配置 CMake 项目，这意味着工具包中定义的工具将用于编译该项目。选择工具包将自动触发 CMake 配置。
- en: By default, kits are scanned by the extension automatically. As a result, discovered
    toolchains are listed as options in the kit selection menu. If your toolchain
    is not displayed here, this means CMake Tools failed to discover it. In such a
    scenario, try to re-scan for kits first. If it is still missing, you can always
    define additional kits by adding them to the user-local `cmake-tools-kits.json
    (1)` file manually.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，扩展会自动扫描工具包。因此，发现的工具链会作为选项列在工具包选择菜单中。如果您的工具链没有显示在这里，这意味着 CMake Tools 未能发现它。在这种情况下，首先尝试重新扫描工具包。如果仍然没有显示，您可以手动将其添加到用户本地的
    `cmake-tools-kits.json (1)` 文件中来定义额外的工具包。
- en: 'Adding a new kit is not usually necessary since the extension does a good job
    of discovering the toolchains. In the odd case of failure, there is a kit template
    here, which you can customize and append to the user-local `cmake-tools-kits.json`
    file to define a new kit. To open the user-local kits file, select the **CMake:
    Edit User-Local CMake Kits** menu item from the Command Palette:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '通常不需要添加新的工具包，因为扩展可以很好地自动发现工具链。如果遇到异常情况失败，这里有一个工具包模板，您可以自定义并将其附加到用户本地的 `cmake-tools-kits.json`
    文件中，以定义一个新的工具包。要打开用户本地的工具包文件，请从命令面板中选择 **CMake: 编辑用户本地 CMake 工具包** 菜单项：'
- en: '[PRE20]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In older versions of the CMake Tools extension, the `cmake-tools-kits.json`
    file may be named `cmake-kits.json` instead.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的 CMake Tools 扩展中，`cmake-tools-kits.json` 文件可能被命名为 `cmake-kits.json`。
- en: Keep in mind that if your kit name collides with an auto-generated name from
    CMake Tools, CMake Tools will override your entry on a scan. Thus, always give
    unique names to your kit definitions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您的工具包名称与 CMake Tools 自动生成的名称冲突，CMake Tools 在扫描时会覆盖您的条目。因此，请始终为您的工具包定义提供唯一的名称。
- en: For further information about kits, refer to [https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md](https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有关工具包的更多信息，请参阅 [https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md](https://github.com/microsoft/vscode-cmake-tools/blob/dev/gcampbell/KitCmakePath/docs/kits.md)。
- en: Qt Creator
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt Creator
- en: Qt Creator is another IDE that supports CMake projects. CMake support is decent,
    and the support comes out of the box without the need for any extra plugins. In
    this section, we are going to take a quick glance at Qt Creator’s CMake support.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 是另一个支持 CMake 项目的 IDE。CMake 支持相当不错，并且默认提供，无需额外的插件。在本节中，我们将快速了解 Qt
    Creator 对 CMake 的支持。
- en: As always, ensure that you have the IDE installed and configured properly in
    your environment first.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，确保您的 IDE 已正确安装并在环境中配置好。
- en: Qt Creator version 5.0.1 is used in the examples.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用的是 Qt Creator 版本 5.0.1。
- en: Adding your CMake installation
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加您的 CMake 安装
- en: In order to use CMake with Qt Creator, the path to CMake must be defined in
    Qt Creator. To view and define CMake paths, navigate to **Edit** | **Preferences**
    | **CMake**.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Qt Creator 中使用 CMake，必须在 Qt Creator 中定义 CMake 的路径。要查看和定义 CMake 路径，请导航至 **编辑**
    | **首选项** | **CMake**。
- en: '![Figure 2.49 – Qt Creator CMake path settings](img/B30947_02_49.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.49 – Qt Creator CMake 路径设置](img/B30947_02_49.jpg)'
- en: Figure 2.49 – Qt Creator CMake path settings
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.49 – Qt Creator CMake 路径设置
- en: Depending on how CMake was installed, Qt Creator might be able to detect the
    correct version automatically. If this is not the case, it can be configured manually.
    To select which CMake executable to run in Qt Creator, select the desired entry
    and click the **Make** **Default** button.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 CMake 的安装方式，Qt Creator 可能能够自动检测到正确的版本。如果没有，您可以手动配置它。要选择在 Qt Creator 中运行的
    CMake 可执行文件，请选择所需的条目并点击 **设置为默认** 按钮。
- en: 'To add a new CMake executable, click **Add**. This will append a new entry
    into the **Manual** section and bring up a window to fill in the details for the
    new entry:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的 CMake 可执行文件，点击 **添加**。这将把一个新的条目添加到 **手动** 部分，并弹出一个窗口，您可以在其中填写新条目的详细信息：
- en: '![Figure 2.50 – Adding a new CMake executable](img/B30947_02_50.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.50 – 添加新的 CMake 可执行文件](img/B30947_02_50.jpg)'
- en: Figure 2.50 – Adding a new CMake executable
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.50 – 添加新的 CMake 可执行文件
- en: 'The fields on this window are described in detail here:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 该窗口中的字段在这里有详细描述：
- en: '**Name**: A unique name to distinguish a new CMake executable entry.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：用于区分新 CMake 可执行文件条目的唯一名称。'
- en: '`cmake`/`cmake.exe`).'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`/`cmake.exe`。'
- en: '**Version**: The version of CMake (deduced by Qt Creator).'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：CMake 的版本（由 Qt Creator 推测）。'
- en: '**Help file**: An optional Qt Creator help file for the executable. This will
    allow CMake Help to appear upon pressing *F1*.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帮助文件**：可选的 Qt Creator 帮助文件，用于该可执行文件。这样在按下 *F1* 时，CMake 帮助文件会显示出来。'
- en: '`CMakeLists.txt` file changes.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt` 文件的更改。'
- en: After filling in the details, click **Apply** to add the new CMake executable
    into Qt Creator. Don’t forget to set it as default if you intend Qt Creator to
    use it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 填写完详细信息后，点击 **应用** 将新的 CMake 可执行文件添加到 Qt Creator 中。如果你希望 Qt Creator 使用它，别忘了将其设置为默认。
- en: Creating a CMake project
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 CMake 项目
- en: Creating a CMake project in Qt Creator follows the exact same steps as for regular
    project creation. Qt Creator does not treat CMake as an external build system
    generator. Instead, it lets its users choose between three build system generators,
    which are *qmake*, *cmake*, and *qbs*. Any type of Qt project can be started by
    any of these build system generators from scratch.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 中创建 CMake 项目遵循与创建常规项目相同的步骤。Qt Creator 不将 CMake 视为外部构建系统生成器。相反，它允许用户在三种构建系统生成器之间进行选择，分别是
    *qmake*、*cmake* 和 *qbs*。任何类型的 Qt 项目都可以通过这些构建系统生成器中的任意一种从头开始创建。
- en: To create a CMake project in Qt Creator, click **File** | **New File or Project...**
    (*Ctrl* + *N*) and choose the type of project from the **New File or Project**
    window. We’ll go with **Qt Widgets Application** for our example.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Qt Creator 中创建 CMake 项目，请点击 **文件** | **新建文件或项目...** (*Ctrl* + *N*)，然后在 **新建文件或项目**
    窗口中选择项目类型。我们以 **Qt Widgets 应用程序** 作为示例。
- en: '![Figure 2.51 – Qt Creator New File or Project window](img/B30947_02_51.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.51 – Qt Creator 新建文件或项目窗口](img/B30947_02_51.jpg)'
- en: Figure 2.51 – Qt Creator New File or Project window
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.51 – Qt Creator 新建文件或项目窗口
- en: 'Upon selection, the project creation wizard will appear. Fill in the details
    as desired. Select **CMake** in the **Define Build System** step, as shown in
    the following screenshot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后，项目创建向导将出现。根据需要填写详细信息。在 **定义构建系统** 步骤中选择 **CMake**，如以下截图所示：
- en: '![Figure 2.52 – Qt Creator new project wizard build system selection](img/B30947_02_52.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.52 – Qt Creator 新建项目向导中的构建系统选择](img/B30947_02_52.jpg)'
- en: Figure 2.52 – Qt Creator new project wizard build system selection
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.52 – Qt Creator 新建项目向导中的构建系统选择
- en: That’s it! You’ve got yourself a Qt application with the CMake build system.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你已经创建了一个带有 CMake 构建系统的 Qt 应用程序。
- en: 'The following figure shows a newly created CMake project:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个新创建的 CMake 项目：
- en: '![Figure 2.53 – Generated CMake-based Qt widgets application project](img/B30947_02_53.jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.53 – 生成的基于 CMake 的 Qt 小部件应用程序项目](img/B30947_02_53.jpg)'
- en: Figure 2.53 – Generated CMake-based Qt widgets application project
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.53 – 生成的基于 CMake 的 Qt 小部件应用程序项目
- en: Opening an existing CMake project
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开现有的 CMake 项目
- en: To open an existing CMake project with Qt Creator, go to the **File** | **Open
    File or Project...** (*Ctrl* + *O*) menu item. Select the top-level **CMakeLists.txt**
    file of the project, then click **Open**. Qt Creator will prompt you to choose
    a kit for your project. Select your preferred kits and then click on the **Configure
    Project** button. The project will be open and the CMake configure step will be
    run with the selected kits.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Qt Creator 中打开现有的 CMake 项目，请点击 **文件** | **打开文件或项目...** (*Ctrl* + *O*) 菜单项。选择项目的顶层
    **CMakeLists.txt** 文件，然后点击 **打开**。Qt Creator 会提示你选择一个工具链（kit）来构建项目。选择你首选的工具链后，点击
    **配置项目** 按钮。项目将被打开，并且 CMake 配置步骤会使用所选工具链执行。
- en: 'As an example, the *CMake Best Practices* project opened with Qt Creator is
    shown in this figure:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图所示的是使用 Qt Creator 打开的 *CMake Best Practices* 项目：
- en: '![Figure 2.54 – A glance at the CMake Best Practices example project in Qt
    Creator](img/B30947_02_54.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.54 – 在 Qt Creator 中查看 CMake Best Practices 示例项目](img/B30947_02_54.jpg)'
- en: Figure 2.54 – A glance at the CMake Best Practices example project in Qt Creator
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.54 – 在 Qt Creator 中查看 CMake Best Practices 示例项目
- en: After opening a CMake project for the first time, Qt Creator will create a file
    named `CMakeLists.txt.user` in the project’s root directory. This file contains
    Qt-specific details that cannot be stored in the `CMakeLists.txt` file, such as
    kit information and editor settings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次打开 CMake 项目时，Qt Creator 会在项目的根目录中创建一个名为 `CMakeLists.txt.user` 的文件。该文件包含一些
    Qt 特有的细节，这些细节不能存储在 `CMakeLists.txt` 文件中，例如工具链信息和编辑器设置。
- en: Configuring and building
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置和构建
- en: In most scenarios (for example, project opening and saving changes to `CMakeLists.txt`),
    Qt Creator will run the CMake configuration automatically without having to run
    it manually. To run the CMake configuration manually, click on the **Build** |
    **Run CMake** menu item.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下（例如，打开项目并保存对 `CMakeLists.txt` 的更改），Qt Creator 会自动运行 CMake 配置，而无需手动执行。若要手动运行
    CMake 配置，请点击 **Build** | **Run CMake** 菜单项。
- en: After configuration, press the hammer icon in the leftmost corner to build the
    project. Alternatively, the *Ctrl* + *B* keyboard shortcut can be used. This will
    build the whole CMake project. To build a specific CMake target only, use the
    locator next to the `cm` and then press the spacebar on your keyboard.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，点击最左侧的锤子图标以构建项目。或者，可以使用 *Ctrl* + *B* 快捷键。这将构建整个 CMake 项目。若要仅构建特定的 CMake
    目标，请使用位于 `cm` 旁边的定位器，然后按下空格键。
- en: '![Figure 2.55 – Qt Creator locator suggestions](img/B30947_02_55.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.55 – Qt Creator 定位器建议](img/B30947_02_55.jpg)'
- en: Figure 2.55 – Qt Creator locator suggestions
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.55 – Qt Creator 定位器建议
- en: The locator will display CMake targets available to build. Select the desired
    target either by highlighting it and pressing *Enter* or clicking on it directly
    using the mouse.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器将显示可构建的 CMake 目标。可以通过高亮选择目标并按 *Enter* 键，或直接用鼠标点击目标来选择。
- en: '![Figure 2.56 – Available CMake targets to build displayed on the locator](img/B30947_02_56.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.56 – 定位器中显示的可用 CMake 构建目标](img/B30947_02_56.jpg)'
- en: Figure 2.56 – Available CMake targets to build displayed on the locator
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.56 – 定位器中显示的可用 CMake 构建目标
- en: The selected CMake target (and, naturally, its dependencies) will be built.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的 CMake 目标（以及其依赖项）将被构建。
- en: Running and debugging
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行和调试
- en: To run or debug a CMake target, press the kit selector button (the computer
    icon on the left navigation bar) and select the CMake target. Then, click either
    the run button (the *play icon* under the kit selector) to run or the debug button
    (the *play icon with a bug*) to debug.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行或调试一个 CMake 目标，请按 Kit 选择器按钮（左侧导航栏中的计算机图标），并选择 CMake 目标。然后，点击运行按钮（Kit 选择器下方的
    *播放图标*）来运行，或者点击调试按钮（带有错误的 *播放图标*）来调试。
- en: 'The following figure shows the kit selector menu content:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 Kit 选择器菜单的内容：
- en: '![Figure 2.57 – Kit selector displaying CMake targets](img/B30947_02_57.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.57 – 显示 CMake 目标的 Kit 选择器](img/B30947_02_57.jpg)'
- en: Figure 2.57 – Kit selector displaying CMake targets
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.57 – 显示 CMake 目标的 Kit 选择器
- en: Here, we conclude the basics of using CMake with Qt Creator. For more advanced
    topics, you can consult the resources given in the *Further* *reading* section.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们结束了使用 CMake 和 Qt Creator 的基础内容。有关更高级的主题，您可以参考 *进一步阅读* 部分提供的资源。
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the fundamental methods of interacting with CMake,
    which are the CLI and the GUI. We also covered various IDE and editor integrations
    that are essential for a daily workflow. Using any kind of tool requires knowledge
    of how to interact with it. Learning ways of interaction allows us to better utilize
    the tool itself, and allows us to reach our goals easier.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了与 CMake 交互的基本方法，包括 CLI 和 GUI。我们还讨论了各种 IDE 和编辑器的集成，它们对于日常工作流程至关重要。使用任何工具都需要了解如何与其交互。学习交互方式使我们能够更好地利用工具本身，也能帮助我们更轻松地达成目标。
- en: In the next chapter, we will be talking about the building blocks of a CMake
    project, which will enable you to create a well-structured, production-ready CMake
    project from scratch.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 CMake 项目的构建块，这将使你能够从零开始创建一个结构良好、适合生产的 CMake 项目。
- en: Questions
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To reinforce what you have learned in this chapter, try to answer the following
    questions. If you are having a hard time answering them, go back to the relevant
    section and re-visit the topic:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固你在本章学到的内容，试着回答以下问题。如果你在回答时遇到困难，请返回相关章节并重新阅读该主题：
- en: 'Describe how a CMake project can be configured from the CLI into the build
    folder in the project’s root directory with each of the following:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何通过命令行接口（CLI）将 CMake 项目配置到项目根目录下的构建文件夹，涉及以下各项：
- en: A different C++ compiler, located at `/usr/bin/clang++`
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个 C++ 编译器，位于 `/usr/bin/clang++`
- en: A Ninja generator
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ninja 生成器
- en: A `-Wall` compiler flag for the `Debug` build type
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-Wall` 编译器标志，用于 `Debug` 构建类型'
- en: 'Describe how the project previously configured in *Q1* can be built using CMake
    using the command line with each of the following:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何使用命令行和 CMake 构建之前在 *Q1* 中配置的项目，涉及以下各项：
- en: Eight parallel jobs
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 八个并行任务
- en: The `--trace` option in the Unix Makefiles generator
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix Makefiles 生成器中的 `--trace` 选项
- en: Describe how the project previously built in *Q1* can be installed using CMake
    using the `directory/opt/project` command line?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何使用 `directory/opt/project` 命令行通过 CMake 安装之前在 *Q1* 中构建的项目？
- en: Assuming the `CMake-Best-Practices` project is already configured and built,
    which command must be invoked to only install the `ch2.libraries` component?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设 `CMake-Best-Practices` 项目已经配置并构建完成，必须执行哪个命令来仅安装 `ch2.libraries` 组件？
- en: What is an advanced variable in CMake?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 中的高级变量是什么？
- en: Answers
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是答案：
- en: '`cmake –S . -B ./build -DCMAKE_CXX_COMPILER:STRING= "/``usr/bin/clang++ "`'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake –S . -B ./build -DCMAKE_CXX_COMPILER:STRING= "/``usr/bin/clang++ "`'
- en: '`cmake –S . -B ./build -``G "Ninja"`'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake –S . -B ./build -``G "Ninja"`'
- en: '`cmake –S . -B ./build -``DCMAKE_BUILD_FLAGS_DEBUG:STRING= "-Wall"`'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake –S . -B ./build -``DCMAKE_BUILD_FLAGS_DEBUG:STRING= "-Wall"`'
- en: 'The project previously configured in Q1 can be built using CMake via the command
    line as follows:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Q1 中之前配置的项目可以通过以下命令使用 CMake 在命令行中构建：
- en: '`cmake --build ./build --``parallel 8`'
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake --build ./build --``parallel 8`'
- en: '`cmake --build ./build --` `VERBOSE=1`'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake --build ./build --` `VERBOSE=1`'
- en: '`cmake --install ./``build --prefix=/opt/project`'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake --install ./``build --prefix=/opt/project`'
- en: '`cmake --install ./build --``component ch2.libraries`'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cmake --install ./build --``component ch2.libraries`'
- en: It is a CMake cache variable that is marked as *advanced* to make it hidden
    in GUIs via the `mark_as_advanced()` function.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个 CMake 缓存变量，标记为 *高级*，通过 `mark_as_advanced()` 函数使其在图形界面中隐藏。
- en: Further reading
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are a lot of guides and documents regarding the topics we have discussed
    in this chapter. You can find a non-exhaustive list of recommended material to
    read here:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题有很多相关的指南和文档。你可以在这里找到一份不完全的推荐阅读材料清单：
- en: 'CMake CLI documentation: [https://cmake.org/cmake/help/latest/manual/cmake.1.html](https://cmake.org/cmake/help/latest/manual/cmake.1.html).'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake CLI 文档：[https://cmake.org/cmake/help/latest/manual/cmake.1.html](https://cmake.org/cmake/help/latest/manual/cmake.1.html)。
- en: 'CMake projects in Visual Studio: [https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160](https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160).'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 中的 CMake 项目：[https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160](https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160)。
- en: 'CMake support in Visual Studio: [https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/](https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/).'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 中的 CMake 支持：[https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/](https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/)。
- en: 'CMake Tools extension for VSCode: [https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/](https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/).'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VSCode 的 CMake Tools 扩展：[https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/](https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code/)。
- en: 'VSCode CMake Tools documentation: [https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation](https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VSCode CMake Tools 文档：[https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation](https://github.com/microsoft/vscode-cmake-tools/tree/main/docs#cmake-tools-for-visual-studio-code-documentation)
- en: 'Debugging in VSCode: [https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging).'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 VSCode 中调试：[https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging)。
- en: 'Qt Creator locator guide: [https://doc.qt.io/qtcreator/creator-editor-locator.html](https://doc.qt.io/qtcreator/creator-editor-locator.html).'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Creator 定位器指南：[https://doc.qt.io/qtcreator/creator-editor-locator.html](https://doc.qt.io/qtcreator/creator-editor-locator.html)。
- en: 'Qt Creator UI: [https://doc.qt.io/qtcreator/creator-quick-tour.html](https://doc.qt.io/qtcreator/creator-quick-tour.html).'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Creator 用户界面：[https://doc.qt.io/qtcreator/creator-quick-tour.html](https://doc.qt.io/qtcreator/creator-quick-tour.html)。
