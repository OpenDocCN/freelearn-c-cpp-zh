- en: Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: Memory efficiency is one of the major requirements for embedded applications.
    Since target embedded platforms often have limited performance and memory capabilities,
    developers need to know how to use available memory in the most efficient way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存效率是嵌入式应用的主要要求之一。由于目标嵌入式平台通常具有有限的性能和内存能力，开发人员需要知道如何以最有效的方式使用可用内存。
- en: Surprisingly, the most efficient way does not necessarily mean that the least
    amount of memory is used. Since embedded systems are specialized, developers know
    in advance which applications or components will be executed on the system. Saving
    memory in one application does not result in any gain unless another application
    running in the same system can use the extra memory. That is why the most important
    characteristic of memory management in embedded systems is determinism, or predictability.
    It is much more important to know that an application can use two megabytes of
    memory under any load than knowing an application can use one megabyte of memory
    most of the time, but can occasionally require three megabytes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，最有效的方式并不一定意味着使用最少的内存。由于嵌入式系统是专用的，开发人员预先知道将在系统上执行哪些应用程序或组件。在一个应用程序中节省内存并不会带来任何收益，除非同一系统中运行的另一个应用程序可以使用额外的内存。这就是嵌入式系统中内存管理最重要的特征是确定性或可预测性的原因。知道一个应用程序在任何负载下可以使用两兆字节的内存比知道一个应用程序大部分时间可以使用一兆字节的内存，但偶尔可能需要三兆字节更重要得多。
- en: Similarly, predictability also applies to memory allocation and deallocation
    time. In many situations, embedded applications favor spending more memory to
    achieve deterministic timing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可预测性也适用于内存分配和释放时间。在许多情况下，嵌入式应用更倾向于花费更多内存以实现确定性定时。
- en: 'In this chapter, we will learn several of memory management techniques  that
    are widely used in embedded applications. The recipes covered in this chapter
    are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习嵌入式应用中广泛使用的几种内存管理技术。本章涵盖的技术如下：
- en: Using dynamic memory allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态内存分配
- en: Exploring object pools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索对象池
- en: Using ring buffers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环形缓冲区
- en: Using shared memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享内存
- en: Using specialized memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用内存
- en: These recipes will help you understand memory management best practices and
    can be used as building blocks when working with memory allocation in your applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术将帮助您了解内存管理的最佳实践，并可在处理应用程序中的内存分配时用作构建块。
- en: Using dynamic memory allocation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态内存分配
- en: Dynamic memory allocation is a common practice among C++ developers, and it
    is widely utilized in the C++ standard library; however, in the context of embedded
    systems, it often becomes a source of issues that are hard to discover and hard
    to avoid.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分配是C++开发人员常见的做法，在C++标准库中被广泛使用；然而，在嵌入式系统的环境中，它经常成为难以发现和难以避免的问题的根源。
- en: The most notable issue is timing. The worst-case time for memory allocation
    is not-bound; however, embedded systems, especially those controlling real-world
    processes or equipment, are often required to respond within a specific amount
    of time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的问题是时间。内存分配的最坏情况时间是不受限制的；然而，嵌入式系统，特别是那些控制真实世界进程或设备的系统，通常需要在特定时间内做出响应。
- en: Another problem is fragmentation. When memory blocks of different sizes are
    allocated and deallocated, memory regions appear that are technically free but
    cannot be allotted because they are too small to fulfill an application request.
    Memory fragmentation grows over time and can lead to the situation where a memory
    allocation request fails despite a substantial total amount of free memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是碎片化。当分配和释放不同大小的内存块时，会出现技术上是空闲的内存区域，但由于太小而无法分配给应用程序请求。内存碎片随着时间的推移而增加，可能导致内存分配请求失败，尽管总的空闲内存量相当大。
- en: A simple yet powerful strategy to avoid these types of issue is to allocate
    all the memory that an application might need in advance at compile time or at
    startup time. Then the application uses this memory as needed. This memory, once
    allocated, is never freed until the application terminates.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这类问题的一个简单而强大的策略是在编译时或启动时预先分配应用程序可能需要的所有内存。然后应用程序根据需要使用这些内存。一旦分配了这些内存，直到应用程序终止，就不会释放这些内存。
- en: A disadvantage of this approach is that the application allocates more memory
    than it really uses at this point in time instead of letting other applications
    use it. In practice, this is not an issue for embedded applications, since they
    are running within a controlled environment, where all applications and their
    memory needs are known in advance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是应用程序分配的内存比实际使用的内存多，而不是让其他应用程序使用它。在实践中，这对于嵌入式应用来说并不是问题，因为它们在受控环境中运行，所有应用程序及其内存需求都是预先知道的。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this recipe, we will learn how to preallocate memory and use it later in
    your application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本技术中，我们将学习如何预先分配内存并在应用程序中使用它：
- en: In your working `~/test` directory, create a subdirectory called `prealloc`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`〜/test`目录中，创建一个名为`prealloc`的子目录。
- en: 'Use your favorite text editor to create a file called `prealloc.cpp` in the
    `prealloc` subdirectory. Copy the following code snippet into the `prealloc.cpp` file
    to define a `SerialDevice` class:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`prealloc`子目录中创建一个名为`prealloc.cpp`的文件。将以下代码片段复制到`prealloc.cpp`文件中以定义`SerialDevice`类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the `main` function that uses the `SerialDevice` class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加使用`SerialDevice`类的`main`函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now build and run the application. It does not output any data since
    its purpose is to demonstrate how we preallocate memory in advance without knowing
    the number of devices and the size of the messages we exchange with devices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序。它不会输出任何数据，因为它的目的是演示我们如何预先分配内存，而不知道设备的数量和我们与设备交换的消息的大小。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we define objects that encapsulate data exchange with serial
    devices. A device is identified by a device file name string of variable length.
    We can send and receive messages of variable length to and from devices.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们定义了封装与串行设备进行数据交换的对象。设备由可变长度的设备文件名字符串标识。我们可以向设备发送和接收可变长度的消息。
- en: Since we can only discover the number of devices connected to the system at
    runtime, we might be tempted to create a device object when it is discovered.
    Similarly, since we do not know the sizes of the messages we send and receive,
    it is natural to allocate memory for message dynamically.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只能在运行时发现连接到系统的设备数量，我们可能会在发现时创建设备对象。同样，由于我们不知道发送和接收的消息大小，因此自然而然地要动态分配消息的内存。
- en: 'Instead, we preallocate arrays of uninitialized device objects:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们预分配未初始化设备对象的数组：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In turn, each object preallocates a sufficient amount of memory to store messages
    and the device filename:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，每个对象都预分配了足够的内存来存储消息和设备文件名：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use local variables to track the actual size of data in the input and output
    buffers. There is no need to track the size of the file name since it is expected
    to be zero-terminated:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用局部变量来跟踪输入和输出缓冲区中数据的实际大小。无需跟踪文件名的大小，因为预期它是以零结尾的：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, we track the actual amount of devices discovered:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们跟踪实际发现的设备数量：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This way, we avoid dynamic memory allocation. It has its costs, though: we
    artificially limit the maximum number of devices and the maximum size of messages
    we support. Secondly, a substantial amount of allocated memory is never used.
    For example, if we support up to 16 devices and only 1 is present in the system,
    we actually use only 1/16 of allocated memory. As mentioned before, this is not
    a problem for embedded systems, since all applications and their requirements
    are predefined. There is no application that can benefit from the extra memory
    it can allocate.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们避免了动态内存分配。尽管这样做有成本：我们人为地限制了支持的最大设备数量和消息的最大大小。其次，大量分配的内存从未被使用。例如，如果我们支持最多16个设备，而系统中只有1个设备，那么实际上我们只使用了分配内存的1/16。如前所述，这对于嵌入式系统来说并不是问题，因为所有应用程序及其要求都是预定义的。没有应用程序可以从它可以分配的额外内存中受益。
- en: Exploring object pools
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索对象池
- en: As we discussed in the first recipe in this chapter, preallocation of all memory
    used by the application is an efficient strategy that helps embedded applications
    avoid various pitfalls related to memory fragmentation and allocation time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一个配方中讨论的那样，预分配应用程序使用的所有内存是一种有效的策略，有助于嵌入式应用程序避免与内存碎片化和分配时间相关的各种问题。
- en: One disadvantage of ad-hoc memory preallocation is that the application is now
    responsible for the tracking of preallocated object usage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 临时内存预分配的一个缺点是，应用程序现在负责跟踪预分配对象的使用情况。
- en: Object pools aim to hide the burden of object tracking by providing a generalized
    and convenient interface, similar to dynamic memory allocation but working with
    objects in the preallocated arrays.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池旨在通过提供类似于动态内存分配但使用预分配数组中的对象的泛化和便利接口来隐藏对象跟踪的负担。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will create a simple implementation of an object pool and
    learn how to use it in your applications:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个对象池的简单实现，并学习如何在应用程序中使用它：
- en: In your working `~/test` directory, create a subdirectory called `objpool`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`~/test`目录中，创建一个名为`objpool`的子目录。
- en: 'Use your favorite text editor to create a  `objpool.cpp` file in the `objpool` subdirectory.
    Let''s define a templated `ObjectPool` class. We start with the private data members
    and a constructor:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`objpool`子目录中创建一个`objpool.cpp`文件。让我们定义一个模板化的`ObjectPool`类。我们从私有数据成员和构造函数开始：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s add a method to get elements from the pool:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个从池中获取元素的方法：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we add a method that returns an element to the pool:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个将元素返回到池中的方法：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, wrap up the class definition with a small function that returns the number
    of elements that are requested from the pool:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，用一个小函数包装类定义，该函数返回从池中请求的元素数量：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define a data type to be stored in the object pool as shown in the following
    code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码所示定义要存储在对象池中的数据类型：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then add code that works with the object pool:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加与对象池一起工作的代码：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml),*Setting
    Up the Environment*, to do it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的配方，*设置环境*来完成。
- en: Switch to the target system terminal. Log in using user credentials, if needed.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统终端。如果需要，使用用户凭据登录。
- en: Run the binary.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this application, we use the same idea  (static arrays of preallocated objects)
    that we used in the first recipe; however, we wrap it into a templated `ObjectPool` class to
    provide a generic interface for handling objects of different types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用了与第一个配方中相同的想法（预分配对象的静态数组），但是我们将其封装到一个模板化的`ObjectPool`类中，以提供处理不同类型对象的通用接口。
- en: 'Our template has two parameters—a class or a data type of objects stored in
    an instance of the `ObjectPool` class, and the pool size. These parameters are
    used to define two private data fields of the class—an array of objects and an
    array of free indices:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板有两个参数——存储在`ObjectPool`类实例中的对象的类或数据类型，以及池的大小。这些参数用于定义类的两个私有数据字段——对象数组和空闲索引数组：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since template parameters are being resolved at compile time, these arrays are
    allocated statically. Additionally, the class has a private data member called
    `top` that acts as an index in the `available` array and points to the next available
    object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板参数在编译时被解析，这些数组是静态分配的。此外，该类有一个名为`top`的私有数据成员，它充当`available`数组中的索引，并指向下一个可用对象。
- en: 'The available array contains indices of all objects in the `objects` array
    that are currently available for use. At the very beginning, all objects are free,
    and the available array is populated with indices of all elements in the objects
    array:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可用数组包含当前可用于使用的`objects`数组中所有对象的索引。在最开始，所有对象都是空闲的，并且可用数组中填充了对象数组中所有元素的索引：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the application needs to get an element from the pool, it invokes the
    `get` method. This method uses the top variable to get the index of the next available
    element in the pool:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序需要从池中获取元素时，它调用`get`方法。该方法使用顶部变量来获取池中下一个可用元素的索引：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the `top` index reaches the size of the array, it means that no more elements
    can be allocated, and so the method throws an exception to indicate the error
    condition:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当`top`索引达到数组大小时，意味着不能再分配更多元素，因此该方法会抛出异常以指示错误条件：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Objects can be returned into the pool using  `free` . First, it detects an
    index of the element based on its address. The index is calculated as a difference
    between the object address and the pool start address. Since  pool objects are
    stored in memory contiguously, we can easily filter out objects of the same type,
    but not those that originate from this pool:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`free`将对象返回到池中。首先，它根据其地址检测元素的索引。索引被计算为对象地址与池起始地址的差异。由于池对象在内存中是连续存储的，我们可以轻松地过滤出相同类型的对象，但不能过滤出来自该池的对象：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that, since the `size_t` type is unsigned, we do not need to check that
    the resulting index is less than zero—it is not possible. If we try to return an
    object to the pool that does not belong to it and has an address less than the
    pool's start address, it will be treated as a positive index anyway.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`size_t`类型是无符号的，我们不需要检查结果索引是否小于零——这是不可能的。如果我们尝试将不属于池的对象返回到池中，并且其地址小于池的起始地址，它将被视为正索引。
- en: 'If the object we return belongs to the pool, we update the top counter and
    put the resulting index into the available array for further use:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们返回的对象属于池，我们会更新顶部计数器，并将结果索引放入可用数组以供进一步使用：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Otherwise, we throw an exception indicating that we tried to return an object
    that was not taken from this pool:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们会抛出异常，指示我们试图返回一个不属于该池的对象：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The method requested is used to track pool object usage. It returns the top
    variable, which efficiently tracks the number of objects that were claimed but
    have not yet been returned to the pool.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所请求的方法用于跟踪池对象的使用情况。它返回顶部变量，该变量有效地跟踪已经被索取但尚未返回到池中的对象数量。
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s define a data type and try to work with objects from the pool. We declare
    a struct called `Point` that holds two `int` fields, as shown in the following
    code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个数据类型并尝试使用来自池的对象。我们声明一个名为`Point`的结构体，其中包含两个`int`字段，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we create a pool of `Point` objects of size `10`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个大小为`10`的`Point`对象池：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We get one object from the pool and populate its data fields:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从池中获取一个对象并填充其数据字段：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The program produces the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序产生了以下输出：
- en: '![](img/aac88c6f-a95e-44b3-8e8c-3173dac428a9.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aac88c6f-a95e-44b3-8e8c-3173dac428a9.png)'
- en: The first line of the output reports one object as requested.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行报告了一个请求的对象。
- en: We request one more object and print its data fields as-is, without any initialization.
    The pool reports that two objects were requested, as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求了一个额外的对象并打印其数据字段，而不进行任何初始化。池报告说已经请求了两个对象，这是预期的。
- en: Now we return our first object back to the pool and make sure that the count
    of requested objects decreases. We can also note that, even after returning the
    object to the pool, we can read data from it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将第一个对象返回到池中，并确保请求的对象数量减少。我们还可以注意到，即使将对象返回到池中，我们仍然可以从中读取数据。
- en: Let's claim one more object from the pool. The requested count increases, but
    the requested object is the same as the one we returned on the preceding step.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从池中再索取一个对象。请求的数量增加，但请求的对象与我们在上一步中返回的对象相同。
- en: We can see that `Point c` was not initialized after it was taken from the pool,
    but its fields contain the same values as `Point a`. In fact, now `a` and `c`
    are references to the same object in the pool, and so the modification of variable
    `a` will affect variable `c`. This is one of the limitations of our implementation
    of the object pool.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Point c`在从池中取出后没有被初始化，但其字段包含与`Point a`相同的值。实际上，现在`a`和`c`是对池中相同对象的引用，因此对变量`a`的修改将影响变量`c`。这是我们对象池实现的一个限制。
- en: 'Finally, we create a local `Point` object and try to return it into the pool:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个本地的`Point`对象并尝试将其返回到池中：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is expected to fail with an exception, and it does. In the program output,
    you can see an `Exception caught: Freeing object that does not belong to the pool` message.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '预计会出现异常，并且确实如此。在程序输出中，您可以看到一个`Exception caught: Freeing object that does not
    belong to the pool`的消息。'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Even though the implementation of the object pool simplifies working with preallocated
    objects, it has a number of limitations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对象池的实现简化了与预分配对象的工作，但它有许多限制。
- en: Firstly, all objects are created at the very beginning. As a result, calling
    the `get` method of our pool does not trigger an object constructor, and calling
    the `free` method does not call a destructor. Developers need to use various workarounds
    for the initialization and deinitialization of objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有对象都是在最开始创建的。因此，调用我们的池的`get`方法不会触发对象构造函数，调用`free`方法也不会调用析构函数。开发人员需要使用各种变通方法来初始化和去初始化对象。
- en: One possible workaround is to define special methods of the target object, such
    as `initialize` and `deinitialize`, which will be invoked respectively by the
    `get` and `free` methods of the `ObjectPool` class. This approach, however, couples
    the implementation of the classes to the `ObjectPool` implementation. Later in
    the chapter, we will look at more advanced techniques to overcome this limitation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方法是定义目标对象的特殊方法，比如`initialize`和`deinitialize`，分别由`ObjectPool`类的`get`和`free`方法调用。然而，这种方法将类的实现与`ObjectPool`的实现耦合在一起。在本章的后面，我们将看到更高级的技术来克服这个限制。
- en: Our implementation of the pool does not detect whether the `free` method was
    called more than once for an object. It is a mistake, but it is common and leads
    to issues that are hard to debug.  While technically feasible, it adds extra complexity
    to the implementation that is not necessary for this example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的池的实现没有检测`free`方法是否对一个对象调用了多次。这是一个错误，但是很常见，并导致难以调试的问题。虽然在技术上是可行的，但它给实现增加了不必要的额外复杂性。
- en: Using ring buffers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环形缓冲区
- en: A ring buffer, or circular buffer, is a widely used data structure in the embedded
    world. It works as a queue placed on top of a fixed-size memory array. The buffer
    can contain a fixed number of elements. A function that generates these elements
    puts them into the buffer sequentially, one by one. When the end of the buffer
    is reached, it switches to the start of the buffer, as if its first element follows
    the last element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 环形缓冲区，或循环缓冲区，在嵌入式世界中是一个广泛使用的数据结构。它作为一个队列放置在固定大小的内存数组之上。缓冲区可以包含固定数量的元素。生成这些元素的函数将它们顺序放入缓冲区中。当达到缓冲区的末尾时，它会切换到缓冲区的开头，就好像它的第一个元素跟在最后一个元素后面。
- en: This design has proven to be remarkably efficient when it comes  to organizing
    data exchange between data producers and consumers that are independent and cannot
    wait for each other, which is a common scenario in embedded development. For example,
    an interrupt service routine should quickly queue data coming from a device for
    further processing, while interrupts are disabled. It cannot wait for the function
    that processes the data if it lags behind. At the same time, the processing function
    does not need to be completely in sync with the **Interrupt Service Routine** (**ISR**);
    it can process several elements at once and catch up with the ISR later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到组织数据生产者和消费者之间的数据交换时，这种设计被证明是非常高效的，因为它们是独立的，不能等待对方，这在嵌入式开发中是常见的情况。例如，中断服务例程应该快速地将来自设备的数据排队等待进一步处理，而中断被禁用。如果处理数据的函数落后，它不能等待中断服务例程。同时，处理函数不需要完全与**中断服务例程**（**ISR**）同步；它可以一次处理多个元素，并在稍后赶上ISR。
- en: This, along with the fact that ring they can be preallocated statically, makes
    ring buffers the best choice in many cases.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性，以及它们可以在静态情况下预先分配，使得环形缓冲区在许多情况下成为最佳选择。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will learn how to create and use a ring buffer on top of
    a C++ array:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在C++数组之上创建和使用环形缓冲区：
- en: In your working `~/test` directory, create a subdirectory called `ringbuf`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`~/test`目录中，创建一个名为`ringbuf`的子目录。
- en: Use your favorite text editor to create a `ringbuf.cpp` file in the `ringbuf` subdirectory.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`ringbuf`子目录中创建一个`ringbuf.cpp`文件。
- en: 'Define the `RingBuffer` class, starting from the `private` data fields:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`private`数据字段开始定义`RingBuffer`类。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we add a method to push data to the buffer:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个将数据推送到缓冲区的方法：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we add a method to pull data from the buffer:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个从缓冲区中拉取数据的方法：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s add a small method to check whether the buffer contains any data and
    wrap up the class definition:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个小方法来检查缓冲区是否包含任何数据，并完成类的定义：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With `RingBuffer` defined, we can now add code that uses it. Firstly, let''s
    define the data type we are going to use:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了`RingBuffer`的定义，我们现在可以添加使用它的代码了。首先，让我们定义我们将要使用的数据类型：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Secondly, add the `main` function and define an instance of `RingBuffer` as
    its variable, along with code that tries to work with an empty buffer:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，添加`main`函数，并定义`RingBuffer`的一个实例作为其变量，以及尝试使用空缓冲区的代码：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, add code that works with five elements in the buffer:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加使用缓冲区中五个元素的代码：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, add similar code that deals with a larger number of elements that
    can be added:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加类似的代码，处理可以添加的更多元素的情况：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*, to do it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序，并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的示例，*设置环境*。
- en: Switch to the target system terminal. Log in using user credentials, if needed.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统终端。如果需要，使用用户凭据登录。
- en: Run the binary.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We implement our ring buffer as a templated C++ class that has three private
    data fields:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的环形缓冲区实现为一个模板化的C++类，它有三个私有数据字段：
- en: '`objects`: A static array of `N` elements of type `T`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objects`: 类型为`T`的`N`个元素的静态数组'
- en: '`read`: An index to read elements from'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`: 一个用于读取元素的索引'
- en: '`write`: An index to write elements to'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`: 用于写入元素的索引'
- en: 'The `RingBuffer` class exposes three public methods:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`RingBuffer`类公开了三个公共方法：'
- en: '`push()`: To write data into the buffer'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push()`: 将数据写入缓冲区'
- en: '`pull()`: To read data from the buffer'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull()`: 从缓冲区中读取数据'
- en: '`has_data()`: To check whether the buffer contains data'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`has_data()`: 检查缓冲区是否包含数据'
- en: Let's take a close look at how they work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看它们是如何工作的。
- en: The `push()` method is intended to be used by a function to store data in the
    buffer. Unlike the similar `push()` method for a dynamic queue or dynamic stack,
    which accepts a value to store as a parameter, our implementation does not accept
    any parameters. Since all elements are preallocated at compile time,  it returns
    a reference to a value in the buffer to be updated.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`方法旨在被函数用于将数据存储在缓冲区中。与动态队列或动态栈的类似`push()`方法不同，后者接受一个要存储的值作为参数，我们的实现不接受任何参数。由于所有元素在编译时都是预分配的，它返回对要更新的缓冲区中的值的引用。'
- en: 'The implementation of the `push()` method is straightforward; it gets a pointer
    to the element via the `write` index, then advances the `write` index and increments
    the number of elements stored in the buffer. Note how the division remainder operator
    is used to wrap the `write` index to the beginning of the array once it reaches
    the size limit:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`方法的实现很简单；它通过`write`索引获取对元素的指针，然后推进`write`索引并增加存储在缓冲区中的元素数量。请注意，取模运算符用于在`write`索引达到大小限制时将其包装到数组的开头：'
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What happens if we try to push more elements than the capacity of the `objects`
    array can handle? That depends on the nature of the data we plan to store in the
    buffer. In our implementation, we assume that the receiver is interested in the
    most recent data and can tolerate the loss of intermediate data if it cannot catch
    up with the sender. If the receiver is too slow, it does not matter how many laps
    the sender runs before the receiver `read` data: all data more than `N` steps
    behind is overwritten at this point. That is why, as soon as the number of stored
    elements exceeds `N`, we start advancing the `read` index along with the `write`
    index to keep them exactly `N` steps apart:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试推送的元素数量超过`objects`数组的容量处理能力会发生什么？这取决于我们计划存储在缓冲区中的数据的性质。在我们的实现中，我们假设接收方对最近的数据感兴趣，并且如果它无法赶上发送方，则可以容忍中间数据的丢失。如果接收方太慢，那么在接收方`read`数据之前发送方运行了多少圈都无所谓：在这一点上超过`N`步的所有数据都被覆盖。这就是为什么一旦存储的元素数量超过`N`，我们开始推进`read`索引以及`write`索引，使它们确切地相隔`N`步：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `pull()` method is used by functions that read data from the buffer. Similarly
    to the `push()` method, it does not accept any parameters and returns a reference
    to an element in the buffer. Unlike the `push()` method, though, it returns a
    constant reference (as shown in the following code)  to indicate the fact that
    it is not supposed to modify data in the buffer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull()`方法由从缓冲区读取数据的函数使用。与`push()`方法类似，它不接受任何参数，并返回对缓冲区中元素的引用。不过，与`push()`方法不同的是，它返回一个常量引用（如下面的代码所示），以表明它不应该修改缓冲区中的数据：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Firstly, it checks whether there is data in the buffer and throws an exception
    if the buffer does not contain elements:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查缓冲区中是否有数据，并且如果缓冲区不包含元素，则抛出异常：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It gets a reference to an element by the read index, then advances the `read`
    index, applying the same division remainder operator that the `push()` method
    does for the `write` index:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过读取索引获取对元素的引用，然后推进`read`索引，应用与`push()`方法为`write`索引所做的相同的取模运算符：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The implementation of the `has_data()` method is trivial. It returns `false`
    if the object counter is zero and `true` otherwise:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_data()`方法的实现是微不足道的。如果对象计数为零，则返回`false`，否则返回`true`：'
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s try it in action. We declare a simple data structure, `Frame`,
    that mimics data generated by a device. It contains a frame index and an opaque
    data buffer:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试实际操作。我们声明一个简单的数据结构`Frame`，模拟设备生成的数据。它包含一个帧索引和一个不透明的数据缓冲区：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We define a ring buffer with a capacity of `10` elements of the `frame `type:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个容量为`10`个`frame`类型元素的环形缓冲区：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s take a look at the program output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看程序的输出：
- en: '![](img/45ab92d8-96c5-42ce-aee0-b49bd991217a.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45ab92d8-96c5-42ce-aee0-b49bd991217a.png)'
- en: Firstly, we try to read from the empty buffer and get an exception, as expected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试从空缓冲区中读取并得到一个异常，这是预期的。
- en: 'Then, we write five elements to the buffer, using characters of the Latin alphabet
    as the data payload:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将五个元素写入缓冲区，使用拉丁字母表的字符作为数据载荷：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note how we get the reference to an element and then update it in-place rather
    than push a local copy of `frame` into the ring buffer. Then we read all the data
    in the buffer and print it on the screen:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何获取对元素的引用，然后在原地更新它，而不是将`frame`的本地副本推入环形缓冲区。然后我们读取缓冲区中的所有数据并将其打印在屏幕上：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The program output indicates that we can successfully read all five elements.
    Now we try to write all 26 letters of the Latin alphabet to the array, way more
    than its capacity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出表明我们可以成功读取所有五个元素。现在我们尝试将拉丁字母表的所有26个字母写入数组，远远超过其容量。
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Then we read the data in the same way that we did for the five elements. The
    read is successful, but we receive only the last 10 elements written; all other
    frames were lost and overwritten by this point. It is not critical for our sample
    application, but maybe this isn't acceptable for many other applications. The
    best way to ensure that data is not being lost is to guarantee that the receiver
    is activated more frequently than the sender. Sometimes the receiver will be activated
    if no data is available in the buffer, but this is an acceptable price to pay
    to avoid data loss.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们以与五个元素相同的方式读取数据。读取是成功的，但我们只收到了最后写入的10个元素；所有其他帧都已丢失并被覆盖。对于我们的示例应用程序来说这并不重要，但对于许多其他应用程序来说可能是不可接受的。确保数据不会丢失的最佳方法是保证接收方的激活频率高于发送方。有时，如果缓冲区中没有可用数据，接收方将被激活，但这是为了避免数据丢失而可以接受的代价。
- en: Using shared memory
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存
- en: In modern operating systems running on hardware that supports an **MMU** (short
    for **memory management unit**), each application runs as a process and has its
    memory isolated from other applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行在支持**MMU**（内存管理单元）的硬件上的现代操作系统中，每个应用程序作为一个进程运行，并且其内存与其他应用程序隔离。
- en: Such isolation brings important reliability benefits. An application cannot
    accidentally corrupt the memory of another application. Similarly, an application
    that accidentally corrupts its own memory and crashes can be shut down by the
    operating system without affecting other applications in the system. Decoupling
    the functionality of the embedded system into several isolated applications that
    communicate with each other over a well-defined API significantly decreases the
    complexity of the implementation, resulting in improved stability.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隔离带来了重要的可靠性优势。一个应用程序不能意外地破坏另一个应用程序的内存。同样，一个意外破坏自己内存并崩溃的应用程序可以被操作系统关闭，而不会影响系统中的其他应用程序。将嵌入式系统的功能解耦为几个相互通信的隔离应用程序，通过一个明确定义的API显著减少了实现的复杂性，从而提高了稳定性。
- en: The isolation, however, incurs costs. Since each process has its own isolated
    address space, data exchange between two applications implies data copying, context
    switching, and the use of operating system kernel synchronization mechanisms that
    can be relatively expensive.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，隔离会产生成本。由于每个进程都有自己独立的地址空间，两个应用程序之间的数据交换意味着数据复制、上下文切换和使用操作系统内核同步机制，这可能是相对昂贵的。
- en: Shared memory is a mechanism provided by many operating systems to declare certain
    memory regions as shared. This way,  applications can exchange data without copying.
    This is especially important for the exchange of large data objects, such as video
    frames or audio samples.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存是许多操作系统提供的一种机制，用于声明某些内存区域为共享。这样，应用程序可以在不复制数据的情况下交换数据。这对于交换大型数据对象（如视频帧或音频样本）尤为重要。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will learn how to use a Linux shared memory API for data
    exchange between two or more applications:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用Linux共享内存API在两个或多个应用程序之间进行数据交换。
- en: In your working `~/test` directory, create a subdirectory called `shmem`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`~/test`目录中，创建一个名为`shmem`的子目录。
- en: 'Use your favorite text editor to create a `shmem.cpp` file in the `shmem` subdirectory.
    Define the `SharedMem` class, starting with common headers and constants:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`shmem`子目录中创建一个`shmem.cpp`文件。从常见的头文件和常量开始定义`SharedMem`类：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, define a constructor that does most of the work:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个大部分工作的构造函数：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the definition of the destructor:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加析构函数的定义：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finalize the class definition with a small method that returns a reference
    to the shared object:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个小方法来完成类定义，返回一个对共享对象的引用：
- en: '[PRE49]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our `SharedMem` class can work with different data types. Let''s declare a
    custom data structure that we want to use:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`SharedMem`类可以处理不同的数据类型。让我们声明一个自定义数据结构，我们想要使用：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now add code that writes data to the shared memory:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加代码，将数据写入共享内存：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Also, add code that reads data from the shared memory:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要添加从共享内存中读取数据的代码：
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add the `main` function to tie everything together, as shown in the following
    code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main`函数，将所有内容联系在一起，如下面的代码所示：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loop`子目录中创建一个名为`CMakeLists.txt`的文件，内容如下：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Build the application and copy the resulting executable binary to the target system.
    Use recipes from [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml),*Setting
    Up the Environment*, to do it.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序，并将生成的可执行二进制文件复制到目标系统。使用[第2章](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml)中的设置环境的方法来完成。
- en: Switch to the target system terminal. Log in using user credentials, if needed.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到目标系统终端。如果需要，使用用户凭据登录。
- en: Run the binary.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行二进制文件。
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we use the **POSIX** (short for **Portable Operating System
    Interface**) API to work with shared memory. This is a flexible and fine-grained
    C API, with lots of parameters that can be tuned or configured. Our goal is to
    hide the complexity of this low-level API by implementing a more convenient and
    type-safe C++ wrapper on top of it. We are going to use the **RAII **(short for **resource
    acquisition is initialization**) idiom to make sure all allocated resources are
    properly deallocated and we do not have memory or file descriptor leaks in our
    application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用**POSIX**（**可移植操作系统接口**的缩写）API来处理共享内存。这是一个灵活和细粒度的C API，有很多可以调整或配置的参数。我们的目标是通过在其上实现一个更方便和类型安全的C++包装器来隐藏这个低级API的复杂性。我们将使用**RAII**（**资源获取即初始化**的缩写）习惯，以确保所有分配的资源都得到适当的释放，我们的应用程序中没有内存或文件描述符泄漏。
- en: 'We define a templated `SharedMem` class. The template argument defines a data
    type that is stored in our shared memory instance. This way, we make instances
    of the `SharedMem` class type safe. Instead of our working with void pointers
    and casting types in the application code, the C++ compiler does it for us automatically:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个模板化的`SharedMem`类。模板参数定义了存储在我们的共享内存实例中的数据类型。这样，我们使`SharedMem`类的实例类型安全。我们不再需要在应用程序代码中使用void指针和类型转换，C++编译器会自动为我们完成：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'All shared memory allocation and initialization is implemented in the `SharedMem`
    constructor. It accepts two parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有共享内存分配和初始化都在`SharedMem`构造函数中实现。它接受两个参数：
- en: A shared memory object name
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个共享内存对象名称
- en: An ownership flag
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个所有权标志
- en: POSIX defines a `shm_open` API, where shared memory objects are identified by
    names, similar to filenames. This way, two independent processes that use the
    same name can reference the same shared memory object. What is the lifetime of
    the shared object? The shared object is destroyed when the `shm_unlink` function
    is invoked for the same object name. If the object is used by multiple processes,
    the first one that calls `shm_open` will create it, and the others will reuse
    the same object. But which of them is responsible for its deletion? This is what
    the ownership flag is used for. When set to `true`, it indicates that the `SharedMem`
    instance is responsible for the shared object cleanup when it is destroyed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX定义了一个`shm_open`API，其中共享内存对象由名称标识，类似于文件名。这样，使用相同名称的两个独立进程可以引用相同的共享内存对象。共享对象的生命周期是什么？当为相同的对象名称调用`shm_unlink`函数时，共享对象被销毁。如果对象被多个进程使用，第一个调用`shm_open`的进程将创建它，其他进程将重用相同的对象。但是它们中的哪一个负责删除它？这就是所有权标志的用途。当设置为`true`时，它表示`SharedMem`实例在销毁时负责共享对象的清理。
- en: 'The constructor sequentially calls three POSIX API functions. Firstly, it creates
    a shared object using `shm_open`. Though the function accepts access flags and
    file permissions as its parameters, we always use the read–write access mode and
    read and write access for the current user:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数依次调用三个POSIX API函数。首先，它使用`shm_open`创建一个共享对象。虽然该函数接受访问标志和文件权限作为参数，但我们总是使用读写访问模式和当前用户的读写访问权限：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we define the size of the shared region using the `ftruncate` call. We
    use the size of the template data type for this purpose:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`ftruncate`调用定义共享区域的大小。我们使用模板数据类型的大小来实现这个目的：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we map the shared region into our process memory address space using
    the `mmap` function. It returns a pointer that we can use to reference our data
    instance:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`mmap`函数将共享区域映射到我们的进程内存地址空间。它返回一个指针，我们可以用来引用我们的数据实例：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The object holds the file descriptor for the shared memory block and the pointer
    to the memory region as its private members. The destructor deallocates them when
    the object is being destroyed. If the owner flag is set, we also keep the object
    name so that we can remove it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象将文件描述符和内存区域的指针保存为其私有成员。析构函数在对象被销毁时对它们进行释放。如果设置了所有者标志，我们还保留对象名称，以便我们可以删除它：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `SharedMem` destructor unmaps the shared memory object from the address
    space:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedMem`析构函数将共享内存对象从地址空间中取消映射：'
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the event that the object is the owner, we can remove it using a `shm_unlink`
    call. Note that we do not need the owner flag anymore since the name is set to
    `nullptr`, unless the object is the owner:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是所有者，我们可以使用`shm_unlink`调用来删除它。请注意，自从名称设置为`nullptr`后，我们不再需要所有者标志，除非对象是所有者：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To access shared data, the class provides a simple `get` method. It returns
    a reference to the object stored in the shared memory:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问共享数据，该类提供了一个简单的`get`方法。它返回存储在共享内存中的对象的引用：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s create two independent processes that use the shared memory API we created.
    We use a POSIX `fork` function to spawn a child process. The child process will
    be a data producer and the parent process will be a data consumer:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个使用我们创建的共享内存API的独立进程。我们使用POSIX的`fork`函数来生成一个子进程。子进程将是数据生产者，父进程将是数据消费者：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We define a `Payload` data type, used by both the producer and the consumer
    for data exchange:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`Payload`数据类型，生产者和消费者都用于数据交换：
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The data producer creates a `SharedMem` instance:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 数据生产者创建一个`SharedMem`实例：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It updates the shared object every 150 milliseconds using the reference it received
    using the `get` method. Each time, it increments the index field of the payload
    and fills its data with letters of the Latin alphabet that match the index.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`get`方法接收的引用每150毫秒更新一次共享对象。每次，它增加有效载荷的索引字段，并用与索引匹配的拉丁字母填充其数据。
- en: 'The consumer is as simple as the producer. It creates a `SharedMem` instance
    with the same name as the producer, but it claims the ownership of the object.
    This means that it will be responsible for its deletion, as shown in the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者和生产者一样简单。它创建一个与生产者同名的`SharedMem`实例，但它声明了对该对象的所有权。这意味着它将负责删除它，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the application and observe the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并观察以下输出：
- en: '![](img/714b3428-c62d-4794-b090-b8a3bd2a72ee.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/714b3428-c62d-4794-b090-b8a3bd2a72ee.png)'
- en: Every 100 milliseconds, the application reads data from the shared object and
    prints it to the screen. In the consumer output, we can see that it receives data
    written by the producer. Since the duration of the consumer and the producer cycles
    does not match, we can see that sometimes the same data is being read twice
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每100毫秒，应用程序从共享对象中读取数据并将其打印到屏幕上。在消费者输出中，我们可以看到它接收到了生产者写入的数据。由于消费者和生产者周期的持续时间不匹配，我们可以看到有时相同的数据被读取两次
- en: 'An important part of the logic that was intentionally omitted in this example
    is the synchronization of the producer and the consumer. Since they run as independent
    projects, there is no guarantee that the producer has updated any data by the
    time the consumer tries to read it. The following is what we see in the resulting
    output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中故意省略的逻辑的一个重要部分是生产者和消费者的同步。由于它们作为独立的项目运行，不能保证生产者在消费者尝试读取数据时已经更新了任何数据。以下是我们在结果输出中看到的内容：
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can see that the consumer opened the shared memory object and read some data
    before the producer opened the same object.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在生产者打开相同的对象之前，消费者打开了共享内存对象并读取了一些数据。
- en: Similarly, there is no guarantee that data fields are updated completely by
    the producer when the consumer tries to read them. We will discuss this topic
    in more detail in the next chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当消费者尝试读取数据时，无法保证生产者是否完全更新数据字段。我们将在下一章中更详细地讨论这个话题。
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Shared memory is a fast and efficient mechanism for inter-process communication
    by itself, but it really shines when combined with ring buffers. By placing a
    ring buffer into shared memory, developers allow independent data producers and
    data consumers to exchange data asynchronously, and with minimal overhead for
    synchronization.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存本身是一种快速高效的进程间通信机制，但当与环形缓冲区结合时，它真正发挥作用。通过将环形缓冲区放入共享内存中，开发人员可以允许独立的数据生产者和数据消费者异步交换数据，并且同步的开销很小。
- en: Using specialized memory
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专用内存
- en: Embedded systems often provide access to their peripheral devices over specific
    ranges of memory addresses. When a program accesses an address in such a region,
    it does not read or write a value in memory. Instead, data is sent to a device
    or read from a device mapped to this address.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常通过特定的内存地址范围提供对其外围设备的访问。当程序访问这个区域中的地址时，它不会读取或写入内存中的值。相反，数据被发送到该地址映射的设备或从该设备读取。
- en: This technique is commonly named **MMIO** (short for **memory-mapped input**/**output**).
    In this recipe, we will learn how to access peripheral devices of the Raspberry
    PI using MMIO from userspace Linux applications.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常被称为**MMIO**（内存映射输入/输出）。在这个教程中，我们将学习如何从用户空间的Linux应用程序中使用MMIO访问Raspberry
    PI的外围设备。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The Raspberry PI has a number of peripheral devices that are accessible over
    MMIO. To demonstrate how MMIO works, our application will access the system timer:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry PI有许多外围设备可以通过MMIO访问。为了演示MMIO的工作原理，我们的应用程序将访问系统定时器：
- en: In your working `~/test` directory, create a subdirectory called `timer`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作`~/test`目录中，创建一个名为`timer`的子目录。
- en: Use your favorite text editor to create a file named `timer.cpp` in the `timer` subdirectory.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您最喜欢的文本编辑器在`timer`子目录中创建名为`timer.cpp`的文件。
- en: 'Put the required headers, constants, and declarations of types into `timer.cpp`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的头文件、常量和类型声明放入`timer.cpp`中：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Add the `main` function, which contains all the logic of the program:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`main`函数，其中包含程序的所有逻辑：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a file called `CMakeLists.txt` in the `timer` subdirectory with the
    following content:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`timer`子目录中创建一个名为`CMakeLists.txt`的文件，并包含以下内容：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can now build and run the application.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: Please note that it should be run under `root` on a real Raspberry PI 3 device.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它应该在真正的Raspberry PI 3设备上以`root`身份运行。
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The system timer is a peripheral device that is connected to the processor using
    an MMIO interface. This means it has a dedicated range of physical addresses,
    each of them with a specific format and purpose.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 系统定时器是一个外围设备，通过MMIO接口连接到处理器。这意味着它有一系列专用的物理地址，每个地址都有特定的格式和用途。
- en: Our application works with a timer counter represented as two 32-bit values.
    Combined, they form a 64-bit read-only counter always incrementing when the system
    is running.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用两个32位值表示的计时器计数器。组合在一起，它们形成一个64位的只读计数器，在系统运行时始终递增。
- en: For the Raspberry PI 3, a physical memory address range allocated for the system
    timer has offset the following —`0x3F003000` (it may be different depending on
    the Raspberry PI hardware revision). We define it as a constant.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Raspberry PI 3，为系统定时器分配的物理内存地址范围的偏移量为`0x3F003000`（根据Raspberry PI硬件版本的不同可能会有所不同）。我们将其定义为一个常量。
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To access individual fields within the region, we define a `SystemTimer` struct:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问区域内的各个字段，我们定义了一个`SystemTimer`结构：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, we need to get the pointer to the timer address range and convert it to
    a pointer to  `SystemTimer`. This way, we can access the addresses of the counter
    by reading the `SystemTimer` data fields.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要获取指向定时器地址范围的指针，并将其转换为指向`SystemTimer`的指针。这样，我们就可以通过读取`SystemTimer`的数据字段来访问计数器的地址。
- en: There is, however, a problem we need to solve. We know the offset in the physical
    address space, but our Linux application works within the virtual address space.
    We need to find a way to map physical addresses to virtual addresses.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要解决一个问题。我们知道物理地址空间中的偏移量，但我们的Linux应用程序在虚拟地址空间中运行。我们需要找到一种将物理地址映射到虚拟地址的方法。
- en: Linux provides access to physical memory addresses using the special `/proc/mem` file.
    Since it contains a snapshot of all physical memory, it is accessible only by `root`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过特殊的`/proc/mem`文件提供对物理内存地址的访问。由于它包含所有物理内存的快照，因此只能由`root`访问。
- en: 'We open it as a regular file using the `open` function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`open`函数将其作为常规文件打开：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once the file is open and we know its descriptor, we can map it into our virtual
    address space. We do not need to map the whole physical memory. A region related
    to the timer is sufficient; that is why we pass the system timer range start as
    an offset parameter and the size of the `SystemTimer` structure as the size parameter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件打开并且我们知道它的描述符，我们就可以将其映射到我们的虚拟地址空间中。我们不需要映射整个物理内存。与定时器相关的区域就足够了，这就是为什么我们将系统定时器范围的起始位置作为偏移参数传递，将`SystemTimer`结构的大小作为大小参数传递：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can access the timer fields. We read the timer counter in the loop and
    display its current value and its variance from the preceding value. When we run
    our application as `root`, we get the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问定时器字段了。我们在循环中读取定时器计数器，并显示其当前值及其与前一个值的差异。当我们以`root`身份运行我们的应用程序时，我们会得到以下输出：
- en: '![](img/aa941e90-c2ed-49d6-a79c-c813bc3b95aa.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa941e90-c2ed-49d6-a79c-c813bc3b95aa.png)'
- en: As we can see, reading from this memory address returns increasing values. The
    value of the difference is around 10,000 and pretty constant. Since we added a
    10-millisecond delay into the counter read loop,  we can infer that the memory
    address is associated with the timer, not regular memory, and the timer counter
    granularity is 1 microsecond.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，从这个内存地址读取返回递增的值。差值的值大约为10,000，而且非常恒定。由于我们在计数器读取循环中添加了10毫秒的延迟，我们可以推断这个内存地址与定时器相关，而不是常规内存，定时器计数器的粒度为1微秒。
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Raspberry Pi has a number of peripheral devices that are accessible over
    MMIO. You can find detailed information about their address ranges and access
    semantics in the *BCM2835 ARM Peripherals manual*, available at [https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派有许多外围设备可以通过MMIO访问。您可以在*BCM2835 ARM外围设备手册*中找到关于它们的地址范围和访问语义的详细信息，该手册可在[https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf](https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf)上找到。
- en: Please note that developers have to be extremely careful when working with memory
    that can be accessed by multiple devices simultaneously. When memory is accessible
    by multiple processors or multiple cores of the same processor, you may need to
    use advanced synchronization techniques such as memory barriers to avoid synchronization
    issues. We will discuss some of them in the next chapter. Things become even more
    complicated if you use **direct memory access** (**DMA**), or MMIO. Since the
    CPU may be unaware that memory is changed by external hardware, its cache may
    be out of sync, leading to data-coherency issues.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开发人员在处理可以同时被多个设备访问的内存时必须非常小心。当内存可以被多个处理器或同一处理器的多个核心访问时，您可能需要使用高级同步技术，如内存屏障，以避免同步问题。我们将在下一章讨论其中一些技术。如果您使用直接内存访问（DMA）或MMIO，情况会变得更加复杂。由于CPU可能不知道内存被外部硬件更改，其缓存可能不同步，导致数据一致性问题。
