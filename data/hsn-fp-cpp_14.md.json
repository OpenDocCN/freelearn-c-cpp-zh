["```cpp\nfunction<int(int, int)> power = [](auto first, auto second){\n    return pow(first, second);\n};\n```", "```cpp\nTEST_CASE(\"Power\"){\n    int maxInt = numeric_limits<int>::max();\n    CHECK_EQ(1, power(0, 0));\n    CHECK_EQ(0, power(0, 1));\n    CHECK_EQ(0, power(0, maxInt));\n    CHECK_EQ(1, power(1, 1));\n    CHECK_EQ(1, power(1, 2));\n    CHECK_EQ(1, power(1, maxInt));\n    CHECK_EQ(1, power(2, 0));\n    CHECK_EQ(2, power(2, 1));\n    CHECK_EQ(4, power(2, 2));\n    CHECK_EQ(maxInt, power(2, 31) - 1);\n    CHECK_EQ(1, power(3, 0));\n    CHECK_EQ(3, power(3, 1));\n    CHECK_EQ(9, power(3, 2));\n    CHECK_EQ(1, power(maxInt, 0));\n    CHECK_EQ(maxInt, power(maxInt, 1));\n}\n```", "```cpp\n// pseudocode\nvector<int> values = generate(1, maxInt, [](){/*generatorCode*/}).pick(100)\n```", "```cpp\nauto generate_ints = [](const int min, const int max){\n    random_device rd; // use for generating the seed\n    mt19937 generator(rd()); // used for generating pseudo-random \n        numbers\n    uniform_int_distribution<int> distribution(min, max); // used to \n        generate uniformly distributed numbers between min and max\n    auto values = transformAll<vector<int>>(range(0, 98), // generates \n        the range [0..98]\n            [&distribution, &generator](auto){\n                return distribution(generator); // generate the random \n                    numbers\n            });\n    values.push_back(min); // ensure that min and max values are \n        included\n    values.push_back(max);\n    return values;\n};\n```", "```cpp\nauto range = [](const int minValue, const int maxValue){\n    vector<int> range(maxValue - minValue + 1);\n    iota(range.begin(), range.end(), minValue);\n    return range;\n};\n```", "```cpp\nauto generate_ints_greater_than_1 = bind(generate_ints, 1, numeric_limits<int>::max());\n```", "```cpp\nauto property_0_to_power_0_is_1 = [](){\n    return power(0, 0) == 1;\n};\n```", "```cpp\nTEST_CASE(\"Properties\"){\n    cout << \"Property: 0 to power 0 is 1\" << endl;\n    CHECK(property_0_to_power_0_is_1);\n }\n```", "```cpp\ng++ -std=c++17 propertyBasedTests.cpp -o out/propertyBasedTests\n./out/propertyBasedTests\n[doctest] doctest version is \"2.0.1\"\n[doctest] run with \"--help\" for options\nProperty: 0 to power 0 is 1\n===============================================================================\n[doctest] test cases:      1 |      1 passed |      0 failed |      0 skipped\n[doctest] assertions:      1 |      1 passed |      0 failed |\n[doctest] Status: SUCCESS!\n```", "```cpp\nauto prop_0_to_any_nonzero_int_is_0= [](const int exponent){\n    CHECK(exponent > 0); // checking the contract just to be sure\n    return power(0, exponent) == 0;\n};\n```", "```cpp\nauto printGeneratedValues = [](const string& generatorName, const auto& \n    values){\n        cout << \"Check generator \" << generatorName << endl;\n        for_each(values.begin(), values.end(), [](auto value) { cout << \n            value << \", \";});\n        cout << endl;\n };\n\nauto check_property = [](const auto& generator, const auto& property, const string& generatorName){\n    auto values = generator();\n    printGeneratedValues(generatorName, values);\n    CHECK(all_of_collection(values, property));\n};\n```", "```cpp\nTEST_CASE(\"Properties\"){\n    cout << \"Property: 0 to power 0 is 1\" << endl;\n    CHECK(property_0_to_power_0_is_1);\n\n    cout << \"Property: 0 to [1..maxInt] is 0\" << endl;\n    check_property(generate_ints_greater_than_1,  \n        prop_0_to_any_nonzero_int_is_0, \"generate ints\");\n}\n```", "```cpp\nProperty: 0 to power 0 is 1\nProperty: 0 to [1..maxInt] is 0\nCheck generator generate ints\n1073496375, 263661517, 1090774655, 590994005, 168796979, 1988143371, 1411998804, 1276384966, 252406124, 111200955, 775255151, 1669887756, 1426286501, 1264685577, 1409478643, 944131269, 1688339800, 192256171, 1406363728, 1624573054, 2654328, 1025851283, 1113062216, 1099035394, 624703362, 1523770105, 1243308926, 104279226, 1330992269, 1964576789, 789398651, 453897783, 1041935696, 561917028, 1379973023, 643316376, 1983422999, 1559294692, 2097139875, 384327588, 867142643, 1394240860, 2137873266, 2103542389, 1385608621, 2058924659, 1092474161, 1071910908, 1041001035, 582615293, 1911217125, 1383545491, 410712068, 1161330888, 1939114509, 1395243657, 427165959, 28574042, 1391025789, 224683120, 1222884936, 523039771, 1539230457, 2114587312, 2069325876, 166181790, 1504124934, 1817094271, 328329837, 442231460, 2123558414, 411757963, 1883062671, 1529993763, 1645210705, 866071861, 305821973, 1015936684, 2081548159, 1216448456, 2032167679, 351064479, 1818390045, 858994762, 2073835547, 755252854, 2010595753, 1882881401, 741339006, 1080861523, 1845108795, 362033992, 680848942, 728181713, 1252227588, 125901168, 1212171311, 2110298117, 946911655, 1, 2147483647, \n===============================================================================\n[doctest] test cases:      1 |      1 passed |      0 failed |      0 skipped\n[doctest] assertions:    103 |    103 passed |      0 failed |\n[doctest] Status: SUCCESS!\n```", "```cpp\nauto prop_anyIntToPower0Is1 = [](const int base){\n    CHECK(base > 0);\n    return power(base, 0) == 1;\n};\n```", "```cpp\nTEST_CASE(\"Properties\"){\n    cout << \"Property: 0 to power 0 is 1\" << endl;\n    CHECK(property_0_to_power_0_is_1);\n\n    cout << \"Property: 0 to [1..maxInt] is 0\" << endl;\n    check_property(generate_ints_greater_than_1, \n        prop_0_to_any_nonzero_int_is_0, \"generate ints\");\n\n    cout << \"Property: any int to power 0 is 1\" << endl;\n    check_property(generate_ints_greater_than_1, \n        prop_anyIntToPower0Is1, \"generate ints\");\n}\n```", "```cpp\nProperty: 0 to power 0 is 1\nCheck generator generate ints\n1673741664, 1132665648, 342304077, 936735303, 917238554, 1081591838, 743969276, 1981329112, 127389617, \n...\n 1, 2147483647, \nProperty: any int to power 0 is 1\nCheck generator generate ints\n736268029, 1304281720, 416541658, 2060514167, 1695305196, 1479818034, 699224013, 1309218505, 302388654, 765083344, 430385474, 648548788, 1986457895, 794974983, 1797109305, 1131764785, 1221836230, 802640954,\n...\n1543181200, 1, 2147483647, \n===============================================================================\n[doctest] test cases:      1 |      1 passed |      0 failed |      0 skipped\n[doctest] assertions:    205 |    205 passed |      0 failed |\n[doctest] Status: SUCCESS!\n```", "```cpp\nauto generate_ints_greater_than_0 = bind(generate_ints, 0, numeric_limits<int>::max());\n```", "```cpp\nauto prop_any_int_to_power_1_is_the_value = [](const int base){\n    return power(base, 1) == base;\n};\n```", "```cpp\nTEST_CASE(\"Properties\"){\n    cout << \"Property: 0 to power 0 is 1\" << endl;\n    CHECK(property_0_to_power_0_is_1);\n\n    cout << \"Property: 0 to any non-zero power is 0\" << endl;\n    check_property(generate_ints_greater_than_1, \n        prop_0_to_any_nonzero_int_is_0, \"generate ints\");\n\n    cout << \"Property: any int to power 0 is 1\" << endl;\n    check_property(generate_ints_greater_than_1, \n        prop_anyIntToPower0Is1, \"generate ints\");\n\n    cout << \"Property: any int to power 1 is the value\" << endl;\n    check_property(generate_ints_greater_than_0, \n        prop_any_int_to_power_1_is_the_value, \"generate ints\");\n}\n```", "```cpp\nauto generate_ints_greater_than_2_less_sqrt_maxInt = bind(generate_ints, 2, sqrt(numeric_limits<int>::max()));\n```", "```cpp\ncout << \"Property: next power of x is previous power of x multiplied by  \n    x\" << endl;\ncheck_property(generate_ints_greater_than_2_less_sqrt_maxInt, \n    prop_nextPowerOfXIsPreviousPowerOfXMultipliedByX, \"generate greater \n        than 2 and less than sqrt of maxInt\");\n```", "```cpp\nauto prop_nextPowerOfXIsPreviousPowerOfXMultipliedByX = [](const int x){\n    auto exponents = bind(generate_exponent_less_than_log_maxInt, x);\n    return check_property(exponents, [x](auto y){ return power(x, y) ==  \n      power(x, y - 1) * x;}, \"generate exponents for \" + to_string(x));\n};\n```", "```cpp\nauto logMaxIntBaseX = [](const int x) -> int{\n    auto maxInt = numeric_limits<int>::max() ;\n    return floor(log(maxInt) / log(x));\n};\n```", "```cpp\nauto generate_exponent_less_than_log_maxInt = [](const int x){\n    return generate_ints(1, logMaxIntBaseX(x));\n};\n```", "```cpp\nCheck generator generate exponents for 43740\n1, 2, \nCheck generator generate exponents for 9320\n1, 2, \nCheck generator generate exponents for 2\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, \nCheck generator generate exponents for 46340\n1, 2,\n```", "```cpp\ncheck_property(generate_ints_greater_than_sqrt_maxInt,  \n    prop_nextPowerOfXIsPreviousPowerOfXMultipliedByX, \"generate greater    \n    than sqrt of maxInt\");\n```", "```cpp\nauto generate_ints = [](const int min, const int max){\n    if(min > max) { // when lower range is larger than upper range, \n        just return empty vector\n            return vector<int>();\n    }\n    if(min == max){ // if min and max are equal, just return {min}\n        return range(min, min);\n    }\n\n    if(max - min <= 100){ // if there not enough int values in the \n        range, just return it fully\n            return range(min, max);\n    }\n    ...\n}\n```", "```cpp\nTEST_CASE(\"Power\"){\n    int maxInt = numeric_limits<int>::max();\n    CHECK_EQ(1, power(0, 0));\n    CHECK_EQ(0, power(0, 1));\n    CHECK_EQ(0, power(0, maxInt));\n    CHECK_EQ(1, power(1, 1));\n    CHECK_EQ(1, power(1, 2));\n    CHECK_EQ(1, power(1, maxInt));\n    CHECK_EQ(1, power(2, 0));\n    CHECK_EQ(2, power(2, 1));\n    CHECK_EQ(4, power(2, 2));\n    CHECK_EQ(maxInt, power(2, 31) - 1);\n    CHECK_EQ(1, power(3, 0));\n    CHECK_EQ(3, power(3, 1));\n    CHECK_EQ(9, power(3, 2));\n    CHECK_EQ(1, power(maxInt, 0));\n    CHECK_EQ(maxInt, power(maxInt, 1));\n}\n```", "```cpp\nTEST_CASE(\"1 raised to a power is 1\"){\n    int exponent;\n\n    SUBCASE(\"0\"){\n        exponent = 0;\n    }\n    SUBCASE(\"1\"){\n        exponent = 1;\n    }\n    SUBCASE(\"2\"){\n        exponent = 1;\n    }\n    SUBCASE(\"maxInt\"){\n        exponent = maxInt;\n    }\n\n    CAPTURE(exponent);\n    CHECK_EQ(1, power(1, exponent));\n}\n```", "```cpp\ncout << \"Property: any int to power 1 is the value\" << endl;\ncheck_property(generate_ints_greater_than_0, \n    prop_any_int_to_power_1_is_the_value, \"generate ints\");\n```"]