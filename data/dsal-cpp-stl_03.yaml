- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mastering Memory and Allocators with std::vector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `std::vector` 掌握内存和分配器
- en: This chapter dives into the critical memory management concepts in modern C++
    programming. We begin by distinguishing between the capacity and size of `std::vector`,
    which is fundamental to writing efficient code. As we progress, we’ll understand
    the mechanics of memory reservation and optimization, and why these actions matter
    in real-world applications. The chapter culminates with thoroughly exploring custom
    allocators, including when to use them and their impact on container performance.
    It equips us with the expertise to fine-tune memory usage for their programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了现代 C++ 编程中的关键内存管理概念。我们首先区分了 `std::vector` 的容量和大小，这对于编写高效代码至关重要。随着我们的进展，我们将了解内存预留和优化的机制，以及为什么这些操作在现实世界的应用中很重要。本章以彻底探讨自定义分配器结束，包括何时使用它们及其对容器性能的影响。它为我们提供了调整程序内存使用的专业知识。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding capacity versus size
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容量与大小
- en: Resizing and reserving memory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整和预留内存
- en: Custom allocator basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义分配器基础知识
- en: Creating a custom allocator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义分配器
- en: Allocators and container performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配器和容器性能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Understanding capacity versus size
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容量与大小
- en: As you venture deeper into the art of C++ programming with `std::vector`, it
    becomes crucial to grasp the distinctions between a vector’s size and capacity.
    While closely related, these terms serve different roles in managing and optimizing
    dynamic arrays, and understanding them will dramatically enhance both the efficiency
    and clarity of your code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你深入到 C++ 编程艺术的殿堂，使用 `std::vector`，掌握向量的大小和容量的区别变得至关重要。虽然这两个术语密切相关，但在管理和优化动态数组时，它们扮演着不同的角色。理解它们将显著提高你代码的效率和清晰度。
- en: Revisiting the basics
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾基础知识
- en: Recall from the previous chapter that the size of a vector denotes the number
    of elements it currently holds. When you add or remove elements, this size adjusts
    accordingly. So, if you have a vector containing five integers, its size is `5`.
    Remove an integer, and the size becomes `4`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上一章的内容，向量的大小表示它当前包含的元素数量。当你添加或删除元素时，这个大小会相应调整。所以，如果你有一个包含五个整数的向量，其大小是 `5`。删除一个整数，大小变为
    `4`。
- en: 'But herein lies a compelling facet of `std::vector`: while its size changes
    based on its elements, the memory it allocates doesn’t always follow suit immediately.
    To understand this thoroughly, we need to explore the concept of capacity. Let
    us do that in the next section.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `std::vector` 的一个引人注目的方面在于：虽然其大小根据其元素而变化，但它分配的内存并不总是立即跟随。为了彻底理解这一点，我们需要探索容量的概念。让我们在下一节中探讨它。
- en: What exactly is capacity?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容量究竟是什么？
- en: '`std::vector`, pertains to the amount of memory the vector has reserved for
    itself – the number of elements it can hold before reallocating memory. This doesn’t
    always equal the number of elements it currently holds (its size). `std::vector`
    often allocates more memory than is required, a preemptive strategy to accommodate
    future elements. This is where the genius of `std::vector` shines; over-allocating
    reduces the need for frequent and, potentially, computationally costly reallocations.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 指的是向量为自己预留的内存量——在重新分配内存之前它可以容纳的元素数量。这并不总是等于它当前持有的元素数量（即大小）。`std::vector`
    通常分配比所需更多的内存，这是一种预防策略，以适应未来的元素。这就是 `std::vector` 的天才之处；过度分配减少了频繁的，可能还有计算成本高昂的重新分配的需求。'
- en: Let’s use an analogy to make this more straightforward. Think of a vector as
    a train with compartments (memory blocks). When the train (vector) starts its
    journey, it might only have a few passengers (elements). However, anticipating
    more passengers at upcoming stations, the train starts with some empty compartments.
    The train’s capacity is the total number of compartments, while its size is the
    number of compartments with passengers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个类比来使这个问题更直观。想象一下向量就像一列有隔间（内存块）的火车。当火车（向量）开始旅程时，它可能只有几个乘客（元素）。然而，预计在未来的车站会有更多的乘客，火车开始时有一些空隔间。火车的容量是隔间的总数，而大小是有乘客的隔间数量。
- en: Why this distinction matters
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这种区别很重要
- en: You might wonder why we don’t just expand the memory each time a new element
    is added. The answer lies in computational efficiency. Memory operations, especially
    reallocations, can be time-consuming. The vector minimizes these operations by
    allocating more memory than is immediately needed, ensuring that adding elements
    remains a fast operation in most scenarios. This optimization is one reason why
    `std::vector` has become a staple in C++ programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不在每次添加新元素时仅仅扩展内存。答案在于计算效率。内存操作，尤其是重新分配，可能很耗时。向量通过分配比立即需要的更多内存来最小化这些操作，确保在大多数情况下添加元素仍然是一个快速操作。这种优化是
    `std::vector` 成为 C++ 编程中必备工具的一个原因。
- en: However, there’s a flip side. Over-allocation means that some memory might go
    unused, at least temporarily. Understanding and managing capacity becomes paramount
    if memory usage is a critical concern. In some extreme cases, a vector might have
    a size of `10` but a capacity of `1000`!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在另一面。过度分配意味着一些内存可能暂时未被使用。如果内存使用是一个关键问题，那么理解和管理容量变得至关重要。在某些极端情况下，一个向量可能有
    `10` 的大小，但容量为 `1000`！
- en: Looking under the hood
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看内部结构
- en: 'One must occasionally peek under the hood to appreciate the nuances of size
    and capacity. Consider a newly initiated `std::vector<int> numbers;`. If you push
    10 integers into it one by one and periodically check its capacity, you might
    notice something interesting: the capacity doesn’t increase by one for each integer!
    Instead, it might jump from `1` to `2`, then to `4`, then to `8`, and so on. This
    exponential growth strategy is a typical implementation approach, ensuring that
    the vector’s capacity doubles whenever it runs out of space.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时必须查看内部结构，以欣赏大小和容量的细微差别。考虑一个新初始化的 `std::vector<int> numbers;`。如果你逐个将 10 个整数推入它，并定期检查其容量，你可能会注意到一些有趣的事情：容量不会为每个整数增加一个！相反，它可能从
    `1` 跳到 `2`，然后到 `4`，然后到 `8`，依此类推。这种指数增长策略是典型的实现方法，确保向量在用完空间时容量加倍。
- en: 'Let’s look at a code example that showcases the difference between size and
    capacity in `std::vector`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个展示 `std::vector` 中大小和容量差异的代码示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the example output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the explanation of this code block:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个代码块的解释：
- en: We start by creating an empty `std::vector<int>` named `myVec`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个空的 `std::vector<int>` 命名为 `myVec`。
- en: We then print out the initial `size` and `capacity`. Since it is empty, the
    `size` value will be `0`. The initial `capacity` value might vary depending on
    the C++ `0` as well.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后打印出初始的 `size` 和 `capacity`。由于它是空的，`size` 值将是 `0`。初始的 `capacity` 值可能因 C++
    的 `0` 而有所不同。
- en: We can see how size and capacity change as we push integers into the vector
    individually. The `size` value will always increase by one for each added element.
    However, the `capacity` value might remain unchanged or increase, often doubling,
    depending on when the underlying memory needs reallocation.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们逐个将整数推入向量时，我们可以看到大小和容量是如何变化的。对于每个添加的元素，`size` 值将始终增加一个。然而，`capacity` 值可能保持不变或增加，通常加倍，这取决于底层内存何时需要重新分配。
- en: Resizing the vector down to five elements demonstrates that while `size` decreases,
    `capacity` remains unchanged. This ensures that previously allocated memory remains
    reserved for potential future elements.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量的大小调整到五个元素表明，虽然 `size` 减少了，但 `capacity` 保持不变。这确保了之前分配的内存仍然为潜在的将来元素保留。
- en: '`shrink_to_fit()` reduces the vector’s `capacity` to match its `size`, thus
    releasing unused memory.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shrink_to_fit()` 函数将向量的 `capacity` 减少以匹配其 `size`，从而释放未使用的内存。'
- en: We can observe how the capacity behaves again by adding one more element after
    the shrink.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过在缩小后添加一个元素来再次观察容量是如何表现的。
- en: When you run this example, you’ll see firsthand the differences between size
    and capacity and how `std::vector` manages memory in the background.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，你将亲身体验大小和容量之间的差异以及 `std::vector` 在后台如何管理内存。
- en: By understanding the relationship between size and capacity, you optimize memory
    usage and preempt potential performance pitfalls. It lays the foundation for the
    upcoming sections, where we’ll discuss manual memory management with vectors and
    understand how to iterate over them efficiently.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解大小和容量之间的关系，你可以优化内存使用并预防潜在的性能陷阱。这为即将到来的章节奠定了基础，我们将讨论如何使用向量进行手动内存管理以及如何有效地遍历它们。
- en: This section deepened our understanding of `std::vector`’s size and capacity.
    We compared these concepts to a train’s compartments, emphasizing how capacity
    planning can prevent frequent, costly reallocations and lead to more memory-efficient
    programs. Grasping this is crucial for performance-sensitive and memory-constrained
    environments.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节加深了我们对于 `std::vector` 的大小和容量的理解。我们将这些概念与火车的车厢进行了比较，强调了容量规划如何防止频繁、昂贵的重新分配，并导致更高效的内存使用程序。掌握这一点对于性能敏感和内存受限的环境至关重要。
- en: Building on this, we’ll next look at `resize()`, `reserve()`, and `shrink_to_fit()`,
    learning to manage `std::vector`’s memory footprint proactively for optimal performance
    and memory usage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们将接下来查看 `resize()`、`reserve()` 和 `shrink_to_fit()`，学习如何主动管理 `std::vector`
    的内存占用以实现最佳性能和内存使用。
- en: Resizing and reserving memory
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整大小和预留内存
- en: 'In our exploration of `std::vector`, understanding how to manage its memory
    effectively is essential. A vector’s beauty is in its dynamism; it can grow and
    shrink, adapting to the ever-changing requirements of our applications. Yet, with
    this flexibility comes the responsibility to ensure efficient memory utilization.
    This section digs into the operations that let us manipulate vector sizes and
    their preallocated memory: `resize`, `reserve`, and `shrink_to_fit`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 `std::vector` 的探索中，理解如何有效地管理其内存是至关重要的。向量的美在于其动态性；它可以增长和缩小，适应我们应用程序不断变化的需求。然而，这种灵活性也带来了确保高效内存利用的责任。本节深入探讨了让我们可以操作向量大小及其预分配内存的操作：`resize`、`reserve`
    和 `shrink_to_fit`。
- en: When working with vectors, we’ve seen how their capacity (preallocated memory)
    might differ from their actual size (number of elements). The methods to manage
    these aspects can significantly affect your programs’ performance and memory footprint.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理向量时，我们已经看到它们的容量（预分配内存）可能与其实际大小（元素数量）不同。管理这些方面的方法可能会显著影响你程序的性能和内存占用。
- en: The power of resize()
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`resize()` 的力量'
- en: Imagine you have `std::vector` holding five elements. If you suddenly need it
    to keep eight elements, or perhaps only three, how would you make this adjustment?
    The `resize()` function is your answer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含五个元素的 `std::vector`。如果你突然需要它来保持八个元素，或者可能只需要三个元素，你将如何进行这种调整？`resize()`
    函数就是你的答案。
- en: '`resize()` is used to change the size of a vector. If you increase its size,
    the new elements will be default-initialized. For instance, for `std::vector<int>`,
    the new elements will have a value of `0`. Conversely, the extra elements will
    be discarded if you reduce its size.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`resize()` 用于改变向量的大小。如果你增加其大小，新元素将被默认初始化。例如，对于 `std::vector<int>`，新元素将具有值 `0`。相反，如果你减少其大小，额外的元素将被丢弃。'
- en: But remember, resizing doesn’t always influence the capacity. If you expand
    a vector beyond its current capacity, the capacity will grow (often more than
    the size to accommodate future growth). However, shrinking a vector’s size doesn’t
    reduce its capacity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，调整大小并不总是影响容量。如果你将向量扩展到其当前容量之外，容量将会增长（通常比大小增长更多，以适应未来的增长）。然而，缩小向量的大小并不会减少其容量。
- en: 'Let’s look at an example that demonstrates manually resizing the capacity of
    a `std::vector` instance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，该示例演示了如何手动调整 `std::vector` 实例的容量：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we saw the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了以下情况：
- en: We start with `std::vector<int>` containing five elements.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一个包含五个元素的 `std::vector<int>` 开始。
- en: A print utility `printVectorDetails` lambda function displays the vector’s elements,
    size, and capacity.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印实用工具 `printVectorDetails` lambda 函数显示向量的元素、大小和容量。
- en: We resize the vector to hold eight elements and observe the changes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将向量的大小调整为容纳八个元素，并观察这些变化。
- en: We then resize the vector to hold only three elements and see how the size decreases,
    but the capacity remains unchanged.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将向量的大小调整为仅包含三个元素，并观察大小如何减少，但容量保持不变。
- en: This demonstrates the power of the `resize()` function and how it affects the
    size but not always the capacity of `std::vector`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了 `resize()` 函数的力量以及它如何影响大小但并不总是影响 `std::vector` 的容量。
- en: Enter reserve()
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入 `reserve()`
- en: Sometimes, we have foreknowledge about the data. Say you know you’ll insert
    100 elements into a vector. Letting the vector adjust its capacity incrementally
    as elements are added would be inefficient. Here’s where `reserve()` comes into
    play.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们对数据有所了解。比如说你知道你将向向量中插入100个元素。让向量随着元素的添加逐步调整其容量将是不高效的。这时 `reserve()` 函数就派上用场了。
- en: By calling `reserve()`, you can set aside a specific amount of memory for the
    vector upfront. It’s like booking seats in advance. The size remains unchanged,
    but the capacity is adjusted to at least the specified value. If you reserve less
    memory than the current capacity, the call has no effect; you cannot decrease
    capacity with `reserve()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `reserve()`，你可以预先为向量预留一定量的内存。这就像提前订票一样。大小保持不变，但容量调整为至少指定的值。如果你预留的内存少于当前容量，调用将没有效果；你不能使用
    `reserve()` 减少容量。
- en: 'Let’s look at an example that demonstrates the utility of the `reserve()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来演示 `reserve()` 函数的实用性：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We learn the following from the preceding example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们了解到以下内容：
- en: We intend to insert many elements (`numberOfElements`) into two vectors.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打算向两个向量中插入许多元素（`numberOfElements`）。
- en: In the first vector (`numbers1`), we directly insert the elements without reserving
    any memory upfront.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个向量（`numbers1`）中，我们直接插入元素，而没有预先保留任何内存。
- en: In the second vector (`numbers2`), we use the `reserve()` function to preallocate
    memory for the elements before inserting them.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个向量（`numbers2`）中，我们在插入元素之前使用 `reserve()` 函数预先分配内存。
- en: We measure and compare the time taken to insert elements in both scenarios.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测量并比较了两种情况下插入元素所需的时间。
- en: When you run the code, you’ll likely notice that the insertion time is shorter
    (often significantly) with `reserve()` since it reduces the number of memory reallocations.
    This example effectively demonstrates the performance benefit of using `reserve()`
    judiciously. In this example, using `reserve()` was more than 3x faster than not
    calling `reserve()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你可能会注意到使用 `reserve()` 的插入时间更短（通常显著），因为它减少了内存重新分配的次数。这个例子有效地展示了合理使用 `reserve()`
    的性能优势。在这个例子中，使用 `reserve()` 比不调用 `reserve()` 快了3倍以上。
- en: Using `reserve()` judiciously can significantly boost performance, especially
    when dealing with large datasets. Preallocating memory means fewer memory reallocations,
    leading to faster insertions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 合理使用 `reserve()` 可以显著提高性能，尤其是在处理大数据集时。预分配内存意味着更少的内存重新分配，从而加快插入速度。
- en: Optimizing with shrink_to_fit()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `shrink_to_fit()`
- en: While `reserve()` lets you expand the preallocated memory, what if you want
    to do the opposite? What if, after numerous operations, you find a vector with
    a size of `10` but a capacity of `1000`? Holding onto that extra memory can be
    wasteful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `reserve()` 允许你扩展预分配的内存，但如果你想要做相反的事情怎么办？如果你在多次操作后发现一个向量的尺寸为 `10` 但容量为 `1000`，保留额外的内存可能是浪费的。
- en: The `shrink_to_fit()` function allows you to request the vector to reduce its
    capacity to match its size. Notice the word *request*. Implementations might not
    always guarantee the reduction, but in most cases, they’ll comply. Reclaiming
    memory after bulk deletions or when a vector’s growth phase has ended is an excellent
    way to reduce a vector’s capacity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`shrink_to_fit()` 函数允许你请求向量减少其容量以匹配其大小。注意这个词 *request*。实现可能并不总是保证减少容量，但在大多数情况下，它们会遵守。在大量删除后或向量增长阶段结束时回收内存是减少向量容量的绝佳方式。'
- en: 'Let’s illustrate the usage of `shrink_to_fit()` with the following simple code
    example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下简单的代码示例来说明 `shrink_to_fit()` 的用法：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the example output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the key takeaways from the preceding example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面示例的关键要点：
- en: We start with `std::vector<int>` and reserve memory for 1000 elements.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从 `std::vector<int>` 开始，并为1000个元素预留内存。
- en: We only add 10 elements to the vector.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只向向量中添加了10个元素。
- en: At this point, the size of the vector is 10, but its capacity is 1000.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，向量的尺寸是10，但其容量是1000。
- en: We then call `shrink_to_fit()` to reduce the vector’s capacity to match its
    size perfectly.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们调用 `shrink_to_fit()` 来将向量的容量减少到与大小完全匹配。
- en: We display the size and capacity after calling `shrink_to_fit()`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在调用 `shrink_to_fit()` 后显示了大小和容量。
- en: Upon running the code, you should observe that the vector’s capacity has been
    reduced closer to its size, illustrating the function’s utility in reclaiming
    memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码后，你应该观察到向量的容量已经减少到接近其大小，这说明了该函数在回收内存方面的实用性。
- en: Real-world relevance
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的相关性
- en: Understanding the distinction between size and capacity and knowing how to manipulate
    them has profound implications. Managing memory effectively is critical for applications
    where performance is paramount, such as real-time systems or high-frequency trading
    platforms. Similarly, ensuring that every byte is efficiently used in embedded
    systems or devices with limited memory is crucial.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 理解大小和容量之间的区别以及如何操作它们具有深远的意义。对于性能至关重要的应用程序，如实时系统或高频交易平台，有效地管理内存至关重要。同样，确保在嵌入式系统或内存有限的设备中每个字节都得到有效使用也是至关重要的。
- en: While `std::vector` provides a dynamic and efficient approach to handling arrays,
    wielding it with mastery requires a deep understanding of its memory behavior.
    By effectively using `resize`, `reserve`, and `shrink_to_fit`, developers can
    tailor memory usage to the exact requirements of their applications, achieving
    an optimal balance between performance and resource consumption.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::vector`提供了处理数组的动态和高效方法，但要熟练运用它需要深入了解其内存行为。通过有效地使用`resize`、`reserve`和`shrink_to_fit`，开发者可以调整内存使用以满足应用程序的精确需求，在性能和资源消耗之间实现最佳平衡。
- en: To master the art of C++, one must be more than just a coder; one must think
    like an architect, understanding the materials at hand and building structures
    that stand the test of time and load. As we move forward, we will dive deeper
    into iteration methods, bringing us closer to mastery of `std::vector`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要精通C++，必须不仅仅是一个程序员；必须像建筑师一样思考，理解手头的材料，并构建经得起时间和负载考验的结构。随着我们继续前进，我们将深入研究迭代方法，使我们更接近于掌握`std::vector`。
- en: This section has honed our understanding of `std::vector`’s memory allocation
    techniques. We learned how `reserve()` strategically allocates memory to optimize
    performance, while `shrink_to_fit()` can minimize memory footprint by releasing
    unneeded space. These strategies are pivotal for developers to enhance application
    efficiency and manage resources wisely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节加深了我们对于`std::vector`内存分配技术的理解。我们学习了如何通过`reserve()`策略性地分配内存以优化性能，而`shrink_to_fit()`可以通过释放未使用的空间来最小化内存占用。这些策略对于开发者提高应用程序效率和明智地管理资源至关重要。
- en: Next, we’ll examine allocators’ integral role in memory management. We’ll dissect
    the allocator interface and the scenarios that may necessitate custom allocators,
    evaluating their impact on performance and memory usage compared to standard practices.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨分配器在内存管理中的核心作用。我们将剖析分配器接口和可能需要自定义分配器的场景，评估它们与标准实践相比对性能和内存使用的影响。
- en: Custom allocator basics
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义分配器基础
- en: 'The magic behind dynamic memory management in `std::vector` (and many other
    STL containers) lies in a component that might not immediately catch your attention:
    the allocator. At its core, an `std::vector`, can function without being tethered
    to a specific memory source or allocation strategy.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`（以及许多其他STL容器）中动态内存管理的奥秘在于一个可能不会立即引起你注意的组件：分配器。在核心上，一个`std::vector`可以在不绑定到特定内存源或分配策略的情况下运行。'
- en: The role and responsibility of an allocator
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配器的角色和责任
- en: Allocators are the unsung heroes of memory management. They handle allocating
    and deallocating memory chunks, thus ensuring that our data structures grow and
    shrink gracefully. Beyond these tasks, allocators can also construct and destroy
    objects. They bridge the gap between raw memory operations and higher-level object
    management.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器是内存管理的无名英雄。它们处理内存块的分配和释放，从而确保我们的数据结构能够优雅地增长和收缩。在这些任务之外，分配器还可以构建和销毁对象。它们在原始内存操作和高级对象管理之间架起桥梁。
- en: But why do we need such an abstraction? Why not simply use the `new` and `delete`
    operations? The answer lies in flexibility. The STL empowers developers to implement
    custom memory strategies by decoupling the container from specific memory operations.
    For performance-critical applications, this flexibility is a godsend.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们需要这样的抽象？为什么不直接使用`new`和`delete`操作呢？答案在于灵活性。STL赋予开发者通过解耦容器与特定内存操作来实现自定义内存策略的能力。对于性能关键的应用，这种灵活性是一种福音。
- en: Under the hood – the allocator interface
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部机制——分配器接口
- en: 'A default `std::allocator` provides member functions that align closely with
    its responsibilities. Let us take a brief look at the member functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 `std::allocator` 提供了与其职责紧密相关的成员函数。让我们简要地看看这些成员函数：
- en: '`allocate()`: Allocates a memory block suitable for holding a specified number
    of objects'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allocate()`: 分配一个适合容纳指定数量对象的内存块'
- en: '`deallocate()`: Returns a block of memory previously allocated by the allocator
    to the system'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deallocate()`: 将分配器之前分配给系统的内存块返回给系统'
- en: '`construct()`: Constructs an object in a given memory location'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`construct()`: 在给定的内存位置构造一个对象'
- en: '`destroy()`: Calls the destructor on an object at a given memory location'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy()`: 在给定的内存位置调用对象的析构函数'
- en: Remember, while `std::allocator` uses the heap for memory operations by default,
    the true power of the allocator interface shines when custom allocators are in
    play.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然 `std::allocator` 默认使用堆进行内存操作，但分配器接口的真正威力在于自定义分配器发挥作用时。
- en: To demonstrate the benefits of `std::allocator`, let’s first illustrate how
    a simple custom allocator might look. This custom allocator will track and print
    its operations, allowing us to visualize its interactions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `std::allocator` 的好处，让我们首先说明一个简单的自定义分配器可能的样子。这个自定义分配器将跟踪并打印其操作，使我们能够可视化其交互。
- en: 'We’ll then use this custom allocator with `std::vector` in the following code
    block:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在这个代码块中使用 `std::vector` 和这个自定义分配器：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the example output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the key takeaways from the preceding example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的例子中得出的关键要点：
- en: We’ve created a simple `CustomAllocator` that prints messages when it performs
    specific operations such as allocation, deallocation, construction, and destruction.
    It uses global `new` and `delete` operators for memory operations.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的 `CustomAllocator`，当它执行特定的操作，如分配、释放、构造和销毁时，会打印消息。它使用全局的 `new` 和 `delete`
    操作符进行内存操作。
- en: '`std::vector` in the `main()` function uses our `CustomAllocator`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数中的 `std::vector` 使用我们的 `CustomAllocator`。'
- en: When we push elements into the vector, you’ll notice the messages indicating
    memory allocation and object construction.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们将元素推入向量时，你会注意到指示内存分配和对象构造的消息。
- en: Clearing the vector will trigger object destruction and memory deallocation
    messages.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除向量将触发对象销毁和内存释放消息。
- en: Using our custom allocator, we’ve added custom behavior (printing in this case)
    to the memory management operations of `std::vector`. This showcases the flexibility
    allocators provide in STL and how they can be tailored for specific needs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的自定义分配器，我们为 `std::vector` 的内存管理操作添加了自定义行为（在这种情况下是打印）。这展示了分配器在 STL 中提供的灵活性以及它们如何针对特定需求进行定制。
- en: Trade-offs and the need for custom allocators
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权衡和自定义分配器的需求
- en: You might be wondering, if `std::allocator` works out of the box, why bother
    with custom allocators? As with many things in software development, the answer
    boils down to trade-offs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，如果 `std::allocator` 可以直接使用，为什么还要费心使用自定义分配器？就像软件开发中的许多事情一样，答案归结为权衡。
- en: The general-purpose nature of the default allocator ensures broad applicability.
    However, this jack-of-all-trades approach might not be optimal for specific scenarios.
    For instance, applications that frequently allocate and deallocate small chunks
    of memory might suffer from fragmentation if the default allocator is used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认分配器的一般性质确保了广泛的适用性。然而，这种万能的解决方案可能不是特定场景的最佳选择。例如，频繁分配和释放小块内存的应用程序如果使用默认分配器可能会遭受碎片化。
- en: Additionally, some contexts might have unique memory constraints, such as embedded
    systems with limited memory or real-time systems with stringent performance requirements.
    In these situations, the control and optimization offered by custom allocators
    become invaluable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些上下文可能具有独特的内存约束，例如内存有限的嵌入式系统或对性能要求严格的实时系统。在这些情况下，自定义分配器提供的控制和优化变得非常有价值。
- en: Choosing std::allocator over new, delete, and managed pointers
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择 `std::allocator` 而不是 `new`、`delete` 和托管指针
- en: Regarding memory management in C++, several mechanisms are at a developer’s
    disposal. While using raw pointers with `new` and `delete` or even smart pointers
    such as `std::shared_ptr` and `std::unique_ptr` might seem intuitive, there’s
    a compelling case for relying on `std::allocator` when working with STL containers.
    Let’s explore these advantages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++中的内存管理，开发者有多种机制可供选择。虽然使用`new`和`delete`或甚至智能指针如`std::shared_ptr`和`std::unique_ptr`可能看起来直观，但当与STL容器一起工作时，依赖`std::allocator`有很强的理由。让我们来探讨这些优势。
- en: Consistency with STL containers
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与STL容器的一致性
- en: Containers in the STL have been designed with allocators in mind. Using `std::allocator`
    ensures a level of compatibility and consistency across the library. It ensures
    that your customization or optimization can be applied uniformly across various
    containers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: STL中的容器设计时考虑了分配器。使用`std::allocator`确保了库中的一致性和兼容性。它确保你的定制或优化可以统一地应用于各种容器。
- en: Memory abstraction and customization
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存抽象和定制
- en: Raw memory operations and even managed pointers do not provide an immediate
    path to customizing memory allocation strategies. On the other hand, `std::allocator`
    (and its customizable brethren) offers an abstraction layer, paving the way for
    tailored memory management approaches. This means you can implement strategies
    that combat fragmentation, use **memory pools**, or tap into specialized hardware.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原始内存操作甚至管理指针并不能直接提供定制内存分配策略的途径。另一方面，`std::allocator`（及其可定制的兄弟）提供了一个抽象层，为定制内存管理方法铺平了道路。这意味着你可以实施对抗碎片化、使用**内存池**或利用专用硬件的策略。
- en: Centralized memory operations
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集中化内存操作
- en: With raw pointers and manual memory management, allocation and deallocation
    operations are scattered throughout the code. This decentralization can lead to
    errors and inconsistencies. `std::allocator` encapsulates these operations, ensuring
    that memory management remains consistent and traceable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始指针和手动内存管理时，分配和释放操作散布在代码中。这种分散化可能导致错误和不一致性。`std::allocator`封装了这些操作，确保内存管理保持一致和可追踪。
- en: Safety against common pitfalls
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止常见陷阱的安全措施
- en: Manual memory management with `new` and `delete` is prone to issues such as
    memory leaks, double deletions, and undefined behaviors. Even with smart pointers,
    cyclic references can become a headache. When used with containers, allocators
    mitigate many of these concerns by automating the underlying memory processes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`和`delete`进行手动内存管理容易产生内存泄漏、重复删除和未定义行为等问题。即使使用智能指针，循环引用也可能成为头疼的问题。当与容器一起使用时，分配器通过自动化底层内存过程来减轻许多这些担忧。
- en: Better synergy with advanced STL features
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与高级STL功能的更好协同
- en: Certain advanced features and optimizations in the STL, such as allocator-aware
    containers, directly leverage the capabilities of allocators. Using `std::allocator`
    (or a custom allocator) ensures you’re better positioned to harness these enhancements.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: STL中某些高级功能和优化，如分配器感知容器，直接利用了分配器的功能。使用`std::allocator`（或自定义分配器）确保你更好地利用这些增强功能。
- en: While `new`, `delete`, and managed pointers have their places in C++ programming,
    when it comes to container-based memory management, `std::allocator` stands out
    as a clear choice. It offers a blend of customization, safety, and efficiency
    that’s hard to achieve with manual or semi-manual memory management techniques.
    As you navigate the rich landscape of C++ development, let the allocator be your
    steadfast companion in dynamic memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`new`、`delete`和管理指针在C++编程中有其位置，但在基于容器的内存管理方面，`std::allocator`是一个明显的选择。它提供了一种定制、安全和效率的混合体，这是手动或半手动内存管理技术难以实现的。在你探索C++开发的丰富领域时，让分配器成为你在动态内存中的忠实伴侣。
- en: This section examined allocators and their role in managing memory for `std::vector`.
    We uncovered how allocators provide an abstraction for memory operations in STL
    containers and examined the allocator interface’s workings. This understanding
    is essential for crafting memory management strategies that enhance application
    performance in various environments.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了分配器及其在管理`std::vector`内存中的作用。我们揭示了分配器如何为STL容器中的内存操作提供抽象，并考察了分配器接口的工作原理。这种理解对于制定能够提升各种环境下应用程序性能的内存管理策略至关重要。
- en: Next, we will explore implementing custom allocators, investigating memory pools,
    and guiding you through creating a custom allocator for `std::vector`, showcasing
    the benefits of personalized memory management.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨实现自定义分配器，研究内存池，并指导您创建一个用于`std::vector`的自定义分配器，展示个性化内存管理的优势。
- en: Creating a custom allocator
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义分配器
- en: Creating a custom allocator is a strategic decision to enhance memory management.
    This approach becomes particularly valuable when the default memory allocation
    strategies do not align with a specific application’s unique performance requirements
    or memory usage patterns. By designing a custom allocator, developers can fine-tune
    memory allocation and deallocation processes, potentially improving efficiency,
    reducing overhead, and ensuring better control over how resources are managed
    within their applications. This level of customization is crucial for applications
    where standard allocation schemes may fall short in addressing specialized needs
    or optimizing performance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义分配器是增强内存管理的战略决策。当默认的内存分配策略与特定应用程序的独特性能要求或内存使用模式不一致时，这种方法尤其有价值。通过设计自定义分配器，开发者可以微调内存分配和释放过程，可能提高效率，减少开销，并确保更好地控制其应用程序中资源的管理。这种程度的定制对于标准分配方案可能无法满足特定需求或优化性能的应用程序至关重要。
- en: Custom allocators – the heart of memory flexibility
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义分配器——内存灵活性的核心
- en: When you think about how STL containers handle memory, there’s a hidden power
    beneath the surface. Containers such as `std::vector` have memory needs that are
    met through allocators. By default, they use `std::allocator`, a general-purpose
    allocator suitable for most tasks. However, in some scenarios, you might need
    more control over memory allocation and deallocation strategies. That’s where
    custom allocators come into play.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当您考虑STL容器如何处理内存时，表面之下隐藏着一种潜在的力量。例如，`std::vector`这样的容器通过分配器来满足内存需求。默认情况下，它们使用`std::allocator`，这是一个适用于大多数任务的通用分配器。然而，在某些情况下，您可能需要更多控制内存分配和释放策略。这就是自定义分配器发挥作用的地方。
- en: Understanding the motivation behind custom allocators
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解自定义分配器的动机
- en: 'At first glance, one might wonder why there’s a need for anything beyond the
    default allocator. After all, isn’t that sufficient? While `std::allocator` is
    versatile, it is designed to cater to a broad range of use cases. Specific situations
    call for particular memory strategies. Here are a few motivators:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，人们可能会 wonder 为什么需要比默认分配器更多的东西。毕竟，那不是足够了吗？虽然`std::allocator`很灵活，但它旨在满足广泛的用例。特定情况需要特定的内存策略。以下是一些动机：
- en: '**Performance optimizations**: Different applications have different memory
    access patterns. For instance, a graphics application might frequently allocate
    and deallocate small chunks of memory. A custom allocator can be optimized for
    such patterns.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能优化**：不同的应用程序有不同的内存访问模式。例如，图形应用程序可能会频繁地分配和释放小块内存。自定义分配器可以针对这种模式进行优化。'
- en: '**Memory fragmentation mitigation**: Fragmentation can lead to inefficient
    memory usage, especially in long-running applications. Custom allocators can employ
    strategies to reduce or even prevent fragmentation.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓解内存碎片**：碎片化可能导致内存使用效率低下，尤其是在长时间运行的应用程序中。自定义分配器可以采用策略来减少或甚至防止碎片化。'
- en: '**Specialized hardware or memory regions**: Sometimes, applications might need
    to allocate memory from specific regions or even specialized hardware, such as
    **graphics processing unit** (**GPU**) memory. Custom allocators grant this flexibility.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用硬件或内存区域**：有时，应用程序可能需要从特定区域或甚至专用硬件（如**图形处理单元**（**GPU**）内存）分配内存。自定义分配器提供了这种灵活性。'
- en: Memory pools – a popular custom allocator strategy
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存池——一种流行的自定义分配器策略
- en: 'One widely appreciated strategy in custom memory allocation is the concept
    of memory pools. Memory pools preallocate a chunk of memory and then distribute
    it in smaller blocks as needed by the application. The brilliance of memory pools
    lies in their simplicity and efficiency. Here’s why they’re beneficial:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义内存分配中，一个广受欢迎的策略是内存池的概念。内存池预先分配一大块内存，然后根据应用程序的需求以较小的块形式分配。内存池的卓越之处在于其简单性和效率。以下是它们有益的原因：
- en: '**Faster allocations and deallocation**: Handing out smaller blocks is quick
    since a large chunk is already preallocated.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的分配和释放**：由于已经预先分配了一大块内存，因此分配较小的内存块是快速的。'
- en: '**Reduced fragmentation**: Memory pools naturally reduce fragmentation by controlling
    the memory layout and ensuring continuous blocks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少碎片化**：内存池通过控制内存布局并确保连续块自然地减少了碎片化。'
- en: '**Predictable behavior**: Memory pools can offer a level of predictability,
    especially beneficial in real-time systems where consistent performance is paramount.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测的行为**：内存池可以提供一定程度的可预测性，这在性能至关重要的实时系统中特别有益。'
- en: Unlocking the potential of custom allocators
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解锁自定义分配器的潜力
- en: While diving into custom allocators can seem daunting, their benefits are tangible.
    Whether for performance enhancements, memory optimization, or specific application
    needs, understanding the potential of custom allocators is a valuable asset in
    a C++ developer’s toolkit. As you continue your journey with `std::vector`, remember
    that an allocator works diligently to manage memory efficiently beneath every
    element. With custom allocators, you can tailor this management to suit your application’s
    needs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然深入研究自定义分配器可能看起来令人畏惧，但它们的益处是实实在在的。无论是为了性能提升、内存优化还是特定应用需求，理解自定义分配器的潜力是 C++ 开发者工具箱中的一个宝贵资产。随着你继续使用
    `std::vector` 的旅程，请记住，分配器在每一个元素之下勤奋地管理内存，以实现高效的内存管理。通过自定义分配器，你可以根据应用需求定制这种管理。
- en: This section introduced the design and use of custom allocators in `std::vector`,
    emphasizing how they allow for specialized memory management, which is crucial
    for optimizing applications with unique memory usage patterns. With this insight,
    developers can surpass STL’s default mechanisms, enhancing performance through
    tailored allocation strategies such as memory pools.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 `std::vector` 中自定义分配器的设计和使用，强调了它们如何允许专门的内存管理，这对于优化具有独特内存使用模式的程序至关重要。有了这个见解，开发者可以超越
    STL 的默认机制，通过定制的分配策略（如内存池）来提高性能。
- en: We’ll next examine allocators’ effects on STL container performance, scrutinize
    `std::allocator`’s traits, identify scenarios for custom alternatives, and underline
    the role of **profiling** in informed allocator selection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将检查分配器对 STL 容器性能的影响，仔细审查 `std::allocator` 的特性，确定自定义替代方案的场景，并强调 **性能分析**
    在明智地选择分配器中的作用。
- en: Allocators and container performance
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配器和容器性能
- en: At the heart of every container’s efficiency lies its memory management strategy,
    and for `std::vector`, allocators play a crucial role. While memory allocation
    might seem straightforward, the nuances in allocator design can bring various
    performance implications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器的效率都源于其内存管理策略，对于 `std::vector` 来说，分配器扮演着至关重要的角色。虽然内存分配可能看起来很简单，但分配器设计中的细微差别可以带来各种性能影响。
- en: Why allocators matter in performance
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么分配器在性能中很重要
- en: Before we can harness the potential of allocators, we need to understand why
    they matter. Memory allocation isn’t a one-size-fits-all operation. Depending
    on the application’s specific needs, the frequency of allocations, the size of
    memory blocks, and the lifetime of these allocations can vary drastically.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够利用分配器的潜力之前，我们需要了解为什么它们很重要。内存分配不是一个一刀切的操作。根据应用程序的具体需求，分配的频率、内存块的大小以及这些分配的生存期可能会有很大的差异。
- en: '**Speed of allocation and deallocation**: The time it takes to allocate and
    deallocate memory can be a significant factor. Some allocators might optimize
    for speed at the expense of memory overhead, while others might do the opposite.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配和释放的速度**：分配和释放内存所需的时间可以是一个重要的因素。一些分配器可能会为了速度而牺牲内存开销，而另一些分配器可能会做相反的事情。'
- en: '**Memory overhead**: The overhead involves the allocator’s extra memory for
    bookkeeping or fragmentation. A low overhead might mean a faster allocator but
    could lead to higher fragmentation. Conversely, a higher overhead allocator might
    be slower but could result in lower fragmentation.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存开销**：开销包括分配器用于簿记或碎片化的额外内存。低开销可能意味着更快的分配器，但可能导致更高的碎片化。相反，高开销的分配器可能较慢，但可能导致较低的碎片化。'
- en: '**Memory access patterns**: How memory is accessed can influence cache performance.
    Allocators that ensure contiguous memory allocations can lead to better cache
    locality, boosting performance.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存访问模式**：内存的访问方式可以影响缓存性能。确保连续内存分配的分配器可以导致更好的缓存局部性，从而提高性能。'
- en: The performance characteristics of std::allocator
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::allocator 的性能特性
- en: 'The default `std::allocator` aims to provide a balanced performance for the
    general case. It’s a jack of all trades, but it might not always be the master
    for specific use cases. Here’s what you can expect:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`std::allocator`旨在为通用情况提供平衡的性能。它是一个多面手，但可能不是特定用例的专家。以下是你可以期待的内容：
- en: '**General purpose efficiency**: It performs decently across various scenarios,
    making it a reliable choice for many applications'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用效率**：它在各种场景中表现良好，使其成为许多应用的可靠选择'
- en: '**Low overhead**: While the overhead is minimal, memory fragmentation is risky,
    especially in scenarios with frequent allocations and deallocations of varying
    sizes'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低开销**：虽然开销最小，但内存碎片化风险较大，尤其是在频繁分配和释放不同大小的内存的场景中'
- en: '**Consistent behavior:** Since it is part of the standard library, its behavior
    and performance are consistent across different platforms and compilers'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的行为**：由于它是标准库的一部分，其行为和性能在不同平台和编译器之间是一致的'
- en: When to consider alternative allocators
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑替代分配器的时机
- en: 'Given that `std::allocator` is a solid general-purpose choice, when should
    one consider alternatives? A few scenarios stand out:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::allocator`是一个可靠的通用选择，那么在什么情况下应该考虑替代方案？以下是一些突出的场景：
- en: '**Specialized workloads**: If you know your application predominantly allocates
    small chunks of memory frequently, a memory-pool-based allocator might be more
    efficient'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定工作负载**：如果你知道你的应用程序主要频繁分配小块内存，基于内存池的分配器可能更有效率'
- en: '**Real-time systems**: For systems with predictable performance, custom allocators
    tailored to the application’s needs can make a difference'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时系统**：对于具有可预测性能的系统，针对应用程序需求定制的自定义分配器可以产生影响'
- en: '**Hardware constraints**: Custom allocators can be designed to fit those constraints
    if you’re working in an environment with limited or specialized memory'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件限制**：如果你在一个具有有限或专用内存的环境中工作，可以设计定制的分配器来适应这些限制'
- en: Profiling – the key to making informed decisions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析——做出明智决策的关键
- en: While understanding the theoretical aspects of allocator performance is beneficial,
    there’s no substitute for actual profiling. Measuring the performance of your
    application using different allocators is the most reliable way to determine the
    best fit. Tools such as Valgrind or platform-specific profilers can offer insights
    into memory usage patterns, allocation times, and fragmentation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理解分配器性能的理论方面是有益的，但没有实际性能分析是无法替代的。使用不同的分配器测量应用程序的性能是最可靠的方法来确定最佳匹配。例如，Valgrind或平台特定的分析工具可以提供有关内存使用模式、分配时间和碎片化的见解。
- en: Though often behind the scenes, memory management is a cornerstone of efficient
    C++ programming. Allocators, serving as the unsung heroes, offer a means to tune
    this aspect finely. While `std::vector` provides incredible versatility and performance
    out of the box, understanding the role and potential of allocators allows developers
    to push their applications to new performance heights. As we wrap up this chapter,
    remember that while theory provides direction, profiling delivers clarity.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内存管理通常在幕后，但它是高效C++编程的基石。分配器作为默默无闻的英雄，提供了一种精细调整这一方面的方法。虽然`std::vector`提供了出色的通用性和性能，但了解分配器的角色和潜力使开发者能够将他们的应用程序提升到新的性能高度。随着我们结束这一章节，请记住，虽然理论提供方向，但性能分析提供清晰度。
- en: In this section, we examined how allocators influence `std::vector`’s performance.
    We discovered the significant impact of allocator choice on container efficiency
    and learned about the default `std::allocator` in the C++ STL, including scenarios
    where an alternative might be preferable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了分配器如何影响`std::vector`的性能。我们发现分配器选择对容器效率有显著影响，并了解了C++ STL中的默认`std::allocator`，包括在某些情况下替代分配器可能更可取的场景。
- en: This knowledge equips us to customize our container’s memory management to specific
    performance needs, ensuring our applications run more efficiently.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种知识使我们能够根据特定的性能需求定制容器的内存管理，确保我们的应用程序运行得更高效。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have thoroughly examined the relationship between memory
    management and the use of `std::vector`. We began by revisiting the fundamental
    concepts of capacity versus size, emphasizing their distinct roles and the importance
    of this distinction for efficient memory use. The mechanics underlying the `std::vector`
    container’s memory allocation were then explored, clarifying what happens internally
    when vectors grow or shrink.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们彻底考察了内存管理与`std::vector`使用之间的关系。我们首先回顾了容量与大小的基本概念，强调了它们各自的作用以及这种区别对于高效内存使用的重要性。然后探讨了`std::vector`容器内存分配的机制，阐明了当向量增长或缩小时内部发生的情况。
- en: We discussed the nuances of resizing and reserving memory, where functions such
    as `reserve()` and `shrink_to_fit()` were introduced as tools for optimizing memory
    usage. The real-world relevance of these methods was underscored, highlighting
    their utility in high-performance applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了调整大小和预留内存的细微差别，介绍了`reserve()`和`shrink_to_fit()`等函数作为优化内存使用的工具。这些方法在实际应用中的相关性得到了强调，突出了它们在高性能应用中的实用性。
- en: The chapter introduced the basics of custom allocators, elaborating on their
    role and delving into the allocator interface. We addressed the trade-offs and
    illustrated why custom allocators can be preferable to directly using `new`, `delete`,
    and managed pointers. Creating and implementing a custom memory pool allocator
    for `std::vector` demonstrated how custom allocators unlock the potential for
    greater memory flexibility.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了自定义分配器的基础知识，详细阐述了它们的作用并深入探讨了分配器接口。我们讨论了权衡利弊，并说明了为什么自定义分配器可能比直接使用`new`、`delete`和托管指针更可取。为`std::vector`创建和实现自定义内存池分配器演示了自定义分配器如何释放更大的内存灵活性。
- en: Finally, we analyzed the impact of allocators on container performance, detailing
    why allocators are a significant consideration for performance tuning. We covered
    the performance characteristics of `std::allocator` and discussed when alternative
    allocators should be considered. Profiling was presented as the key to making
    informed decisions about allocator use.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了分配器对容器性能的影响，详细说明了为什么分配器是性能调优的重要考虑因素。我们涵盖了`std::allocator`的性能特性，并讨论了何时应考虑使用替代分配器。性能分析被提出作为做出关于分配器使用的明智决策的关键。
- en: The insights from this chapter are invaluable, equipping us with sophisticated
    techniques for mastering memory management with `std::vector`. This knowledge
    enables us to write high-performance C++ applications as it allows for granular
    control over memory allocation, which is especially important in environments
    with tight memory constraints or those requiring quick allocation and deallocation
    cycles.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的见解是无价的，为我们提供了掌握`std::vector`内存管理的复杂技术。这种知识使我们能够编写高性能的C++应用程序，因为它允许对内存分配进行细粒度控制，这在内存约束严格或需要快速分配和释放周期的环境中尤为重要。
- en: Next, we will focus on the algorithms operating on vectors. We will explore
    sorting techniques, search operations, and the manipulation of vector contents,
    emphasizing the importance of understanding the efficiency and versatility of
    these algorithms. We will discuss using custom comparators and predicates and
    how they can be leveraged to perform complex operations on user-defined data types.
    The next chapter will also provide guidance on maintaining container invariants
    and managing iterator invalidation, which is essential for ensuring robustness
    and correctness in multi-threaded scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注在向量上操作的计算算法。我们将探索排序技术、搜索操作以及向量内容的操作，强调理解这些算法的效率和多功能性的重要性。我们将讨论使用自定义比较器和谓词以及它们如何被利用来对用户定义的数据类型执行复杂操作。下一章还将提供有关维护容器不变性和管理迭代器失效的指导，这对于确保在多线程场景中的健壮性和正确性至关重要。
