- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Installing LLVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 LLVM
- en: 'In order to learn how to work with LLVM, it is best to begin by compiling LLVM
    from source. LLVM is an umbrella project and the GitHub repository contains the
    source of all projects belonging to LLVM. Each LLVM project is in a top-level
    directory of the repository. Besides cloning the repository, your system must
    also have all tools installed that are required by the build system. In this chapter,
    you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何与 LLVM 一起工作，最好从源代码编译 LLVM 开始。LLVM 是一个伞形项目，GitHub 存储库包含 LLVM 所属所有项目的源代码。每个
    LLVM 项目都在存储库的顶级目录中。除了克隆存储库外，您的系统还必须安装构建系统所需的全部工具。在本章中，您将学习以下主题：
- en: Getting the prerequisites ready, which will show you how to set up your build
    system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备先决条件，这将向您展示如何设置您的构建系统
- en: Cloning the repository and building from source, which will cover how to get
    the LLVM source code, and how to compile and install the LLVM core libraries and
    clang with CMake and Ninja
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆存储库并从源代码构建，这将涵盖如何获取 LLVM 源代码，以及如何使用 CMake 和 Ninja 编译和安装 LLVM 核心库和 clang
- en: Customizing the build process, which will talk about the various possibilities
    for influencing the build process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义构建过程，这将讨论影响构建过程的多种可能性
- en: Compiling LLVM versus installing binaries
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 LLVM 与安装二进制文件
- en: You can install LLVM binaries from various sources. If you are using Linux,
    then your distribution contains the LLVM libraries. Why bother compiling LLVM
    yourself?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从各种来源安装 LLVM 二进制文件。如果您使用 Linux，那么您的发行版包含 LLVM 库。为什么还要自己编译 LLVM 呢？
- en: First, not all install packages contain all the files required for developing
    with LLVM. Compiling and installing LLVM yourself prevents this problem. Another
    reason stems from the fact that LLVM is highly customizable. With building LLVM,
    you learn how you can customize LLVM, and this will enable you to diagnose problems
    that may arise if you bring your LLVM application to another platform. And last,
    in the third part of this book, you will extend LLVM itself, and for this, you
    need the skill of building LLVM yourself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，并非所有安装包都包含开发 LLVM 所需的所有文件。自己编译和安装 LLVM 可以防止这个问题。另一个原因源于 LLVM 的高度可定制性。通过构建
    LLVM，您将学习如何自定义 LLVM，这将使您能够诊断在将您的 LLVM 应用程序带到另一个平台时可能出现的任何问题。最后，在本书的第三部分，您将扩展 LLVM
    本身，为此，您需要自己构建 LLVM 的技能。
- en: However, it is perfectly fine to avoid compiling LLVM for the first steps. If
    you want to go on this route, then you only need to install the prerequisites
    as described in the next section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第一步避免编译 LLVM 是完全可以接受的。如果您想走这条路，那么您只需要安装下一节中描述的先决条件。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many Linux distributions split LLVM into several packages. Please make sure
    that you install the development package. For example, on Ubuntu, you need to
    install the `llvm-dev` package. Please also make sure that you install LLVM 17\.
    For other versions, the examples in this book may require changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Linux 发行版将 LLVM 分割成几个包。请确保您安装了开发包。例如，在 Ubuntu 上，您需要安装 `llvm-dev` 包。请确保您安装了
    LLVM 17。对于其他版本，本书中的示例可能需要更改。
- en: Getting the prerequisites ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备先决条件
- en: To work with LLVM, your development system should run a common operating system
    such as Linux, FreeBSD, macOS, or Windows. You can build LLVM and clang in different
    modes. A build with debug symbols enabled can take up to 30 GB of space. The required
    disk space depends heavily on the chosen build options. For example, building
    only the LLVM core libraries in release mode, targeting only one platform, requires
    about 2 GB of free disk space, which is the bare minimum needed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 LLVM，您的开发系统应运行常见的操作系统，例如 Linux、FreeBSD、macOS 或 Windows。您可以在不同的模式下构建 LLVM
    和 clang。启用调试符号的构建可能需要高达 30 GB 的空间。所需的磁盘空间很大程度上取决于选择的构建选项。例如，仅以发布模式构建 LLVM 核心库，针对单一平台，需要大约
    2 GB 的空闲磁盘空间，这是最低需求。
- en: To reduce compile times, a fast CPU (such as a quad-core CPU with a 2.5 GHz
    clock speed) and a fast SSD are also helpful. It is even possible to build LLVM
    on a small device such as a Raspberry Pi – it only takes a lot of time. The examples
    within this book were developed on a laptop with an Intel quad-core CPU running
    at a 2.7 GHz clock speed, with 40 GB RAM and 2.5 TB SSD disk space. This system
    is well suited for the development task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少编译时间，一个快速的 CPU（例如，2.5 GHz 时钟速度的四核 CPU）和快速的 SSD 也是很有帮助的。甚至可以在像 Raspberry
    Pi 这样的小型设备上构建 LLVM – 它只需要很多时间。本书中的示例是在一个配备英特尔四核 CPU，运行在 2.7 GHz 时钟速度，40 GB RAM
    和 2.5 TB SSD 磁盘空间的笔记本电脑上开发的。这个系统非常适合开发任务。
- en: Your development system must have some prerequisite software installed. Let’s
    review the minimal required version of these software packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您的开发系统必须安装一些先决软件。让我们回顾这些软件包的最小所需版本。
- en: To check out the source from GitHub, you need **Git** ([https://git-scm.com/](https://git-scm.com/)).
    There is no requirement for a specific version. The GitHub help pages recommend
    using at least version 1.17.10\. Due to known security issues found in the past,
    it is recommended to use the latest available version, which is 2.39.1 at the
    time of writing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 GitHub 检出源代码，你需要 **Git** ([https://git-scm.com/](https://git-scm.com/))。没有特定版本的要求。GitHub
    帮助页面建议使用至少版本 1.17.10。由于过去发现的安全问题，建议使用最新的可用版本，即写作时的 2.39.1。
- en: The LLVM project uses **CMake** ([https://cmake.org/](https://cmake.org/)) as
    the build file generator. At least the 3.20.0 version is required. CMake can generate
    build files for various build systems. In this book, **Ninja** ([https://ninja-build.org/](https://ninja-build.org/))
    is used because it is fast and available on all platforms. The latest version,
    1.11.1, is recommended.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 项目使用 **CMake** ([https://cmake.org/](https://cmake.org/)) 作为构建文件生成器。至少需要
    3.20.0 版本。CMake 可以为各种构建系统生成构建文件。本书中使用 **Ninja** ([https://ninja-build.org/](https://ninja-build.org/))，因为它速度快且适用于所有平台。建议使用最新版本，1.11.1。
- en: 'Obviously, you also need a **C/C++ compiler**. The LLVM projects are written
    in modern C++, based on the C++17 standard. A conforming compiler and standard
    library are required. The following compilers are known to work with LLVM 17:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你还需要一个 **C/C++ 编译器**。LLVM 项目是用现代 C++ 编写的，基于 C++17 标准。需要一个符合标准的编译器和标准库。以下编译器已知与
    LLVM 17 兼容：
- en: gcc 7.1.0 or later
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gcc 7.1.0 或更高版本
- en: clang 5.0 or later
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: clang 5.0 或更高版本
- en: Apple clang 10.0 or later
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple clang 10.0 或更高版本
- en: Visual Studio 2019 16.7 or later
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019 16.7 或更高版本
- en: Tip
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please be aware that with further development of the LLVM project, the requirements
    for the compiler are most likely to change. In general, you should use the latest
    compiler version available for your system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随着 LLVM 项目的进一步发展，编译器的需求很可能会发生变化。一般来说，你应该使用适用于您系统的最新编译器版本。
- en: '**Python** ([https://python.org/](https://python.org/)) is used during the
    generation of the build files and for running the test suite. It should be at
    least the 3.8 version.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python** ([https://python.org/](https://python.org/)) 在生成构建文件和运行测试套件时使用。它至少应该是
    3.8 版本。'
- en: Although not covered in this book, there can be reasons that you need to use
    Make instead of Ninja. In this case, you need to use `ninja` in each command with
    `make` for the scenarios described below.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书没有涉及，但可能有原因需要使用 Make 而不是 Ninja。在这种情况下，对于以下描述的场景，需要在每个命令中使用 `make` 和 `ninja`。
- en: LLVM also depends on the `zlib` library ([https://www.zlib.net/](https://www.zlib.net/)).
    You should have at least version 1.2.3.4 installed. As usual, we recommend using
    the latest version, 1.2.13.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 还依赖于 `zlib` 库 ([https://www.zlib.net/](https://www.zlib.net/))。你应该至少安装了
    1.2.3.4 版本。像往常一样，我们建议使用最新版本，1.2.13。
- en: To install the prerequisite software, the easiest way is to use the package
    manager from your operating system. In the following sections, the commands required
    to install the software are shown for the most popular operating systems.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装先决软件，最简单的方法是使用操作系统的包管理器。在以下章节中，将展示为最流行的操作系统安装软件所需的命令。
- en: Ubuntu
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ubuntu
- en: 'Ubuntu 22.04 uses the `apt` package manager. Most of the basic utilities are
    already installed; only the development tools are missing. To install all packages
    at once, you type the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 22.04 使用 `apt` 包管理器。大多数基本实用工具已经安装；只有开发工具缺失。要一次性安装所有包，请输入以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fedora and RedHat
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fedora 和 RedHat
- en: 'The package manager of Fedora 37 and RedHat Enterprise Linux 9 is called `dnf`.
    Like Ubuntu, most of the basic utilities are already installed. To install all
    packages at once, you type the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora 37 和 RedHat Enterprise Linux 9 的包管理器称为 `dnf`。和 Ubuntu 一样，大多数基本工具已经安装。要一次性安装所有包，你可以输入以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: FreeBSD
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreeBSD
- en: 'On FreeBSD 13 or later, you have to use the `pkg` package manager. FreeBSD
    differs from Linux-based systems in that the clang compiler is already installed.
    To install all other packages at once, you type the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 13 或更高版本上，你必须使用 `pkg` 包管理器。FreeBSD 与基于 Linux 的系统不同，因为 clang 编译器已经安装。要一次性安装所有其他包，你可以输入以下命令：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: OS X
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OS X
- en: 'For development on OS X, it is best to install **Xcode** from the Apple store.
    While the Xcode IDE is not used in this book, it comes with the required C/C++
    compilers and supporting utilities. For installation of the other tools, the package
    manager **Homebrew** ([https://brew.sh/](https://brew.sh/)) can be used. To install
    all packages at once, you type the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OS X 上的开发，最好从 Apple Store 安装 **Xcode**。虽然本书中没有使用 Xcode IDE，但它包含了所需的 C/C++
    编译器和支持工具。对于其他工具的安装，可以使用包管理器 **Homebrew** ([https://brew.sh/](https://brew.sh/))。要一次性安装所有包，你可以输入以下命令：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Windows
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: 'Like OS X, Windows does not come with a package manager. For the C/C++ compiler,
    you need to download **Visual Studio Community 2022** ([https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/)),
    which is free for personal use. Please make sure that you install the workload
    named **Desktop Development with C++**. You can use the package manager **Scoop**
    ([https://scoop.sh/](https://scoop.sh/)) to install the other packages. After
    installing Scoop as described on the website, you open **x64 Native Tools Command
    Prompt for VS 2022** from your Windows menu. To install the required packages,
    you type the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 和 OS X 一样，Windows 没有自带包管理器。对于 C/C++ 编译器，你需要下载 **Visual Studio Community 2022**
    ([https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/))，这是个人使用的免费软件。请确保你安装了名为
    **Desktop Development with C++** 的工作负载。你可以使用包管理器 **Scoop** ([https://scoop.sh/](https://scoop.sh/))
    来安装其他包。按照网站上的说明安装 Scoop 后，从你的 Windows 菜单中打开 **x64 Native Tools 命令提示符 for VS 2022**。要安装所需的包，你可以输入以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Please watch the output from Scoop closely. For the Python and `zlib` packages,
    it advises adding some registry keys. These entries are needed so that other software
    can find these packages. To add the registry keys, you’d best copy and paste the
    output from Scoop, which looks like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切关注 Scoop 的输出。对于 Python 和 `zlib` 包，它会建议添加一些注册表键。这些条目是必需的，以便其他软件可以找到这些包。要添加注册表键，你最好复制并粘贴
    Scoop 的输出，如下所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After each command, a message window from the registry editor will pop up asking
    whether you really want to import those registry keys. You need to click on **Yes**
    to finish the import. Now all prerequisites are installed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令之后，注册表编辑器会弹出一个消息窗口询问你是否真的想要导入那些注册表键。你需要点击 **是** 来完成导入。现在所有先决条件都已安装。
- en: For all examples in this book, you must use the **x64 Native Tools Command Prompt**
    for VS 2022\. Using this command prompt, the compiler is automatically added to
    the search path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的所有示例，你必须使用 VS 2022 的 **x64 Native Tools 命令提示符**。使用此命令提示符，编译器会自动添加到搜索路径。
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The LLVM code base is very large. To comfortably navigate the source, we recommend
    using an IDE that allows you to jump to the definition of classes and search through
    the source. We find **Visual Studio Code** ([https://code.visualstudio.com/download](https://code.visualstudio.com/download)),
    which is an extensible cross-platform IDE, very comfortable to use. However, this
    is no requirement for following the examples in this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 代码库非常大。为了舒适地导航源代码，我们建议使用一个允许你跳转到类定义并搜索源代码的 IDE。我们发现 **Visual Studio Code**
    ([https://code.visualstudio.com/download](https://code.visualstudio.com/download))，这是一个可扩展的跨平台
    IDE，非常易于使用。然而，这并不是遵循本书中示例的必要条件。
- en: Cloning the repository and building from source
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆仓库并从源代码构建。
- en: 'With the build tools ready, you can now check out all LLVM projects from GitHub
    and build LLVM. This process is essentially the same on all platforms:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好构建工具后，你现在可以从 GitHub 检出所有 LLVM 项目并构建 LLVM。这个过程在所有平台上基本上是相同的：
- en: Configure Git.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 Git。
- en: Clone the repository.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库。
- en: Create the build directory.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建构建目录。
- en: Generate the build system files.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成构建系统文件。
- en: Finally, build and install LLVM.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建并安装 LLVM。
- en: Let’s begin with configuring Git.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从配置 Git 开始。
- en: Configuring Git
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Git
- en: 'The LLVM project uses Git for version control. If you have not used Git before,
    then you should do some basic configuration of Git first before continuing: to
    set the username and email address. Both pieces of information are used if you
    commit changes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM项目使用Git进行版本控制。如果您之前没有使用过Git，那么在继续之前，您应该先进行一些基本的Git配置：设置用户名和电子邮件地址。这两项信息在提交更改时都会使用。
- en: 'One can check whether they previously had an email and username already configured
    in Git with the following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令检查是否已经在Git中配置了之前的电子邮件和用户名：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding commands will output the respective email and username that you
    already have set when using Git. However, in the event that you are setting the
    username and email for the first time, the following commands can be entered for
    first-time configuration. In the following commands, you can simply replace `Jane`
    with your name and `jane@email.org` with your email:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将输出您在使用Git时已经设置的相应电子邮件和用户名。然而，如果您是第一次设置用户名和电子邮件，可以输入以下命令进行首次配置。在以下命令中，您可以将`Jane`替换为您自己的名字，将`jane@email.org`替换为您自己的电子邮件：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These commands change the global Git configuration. Inside a Git repository,
    you can locally overwrite those values by not specifying the `--``global` option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令会更改全局Git配置。在Git仓库内部，您可以通过不指定`--global`选项来本地覆盖这些值。
- en: 'By default, Git uses the **vi** editor for commit messages. If you prefer another
    editor, then you can change the configuration in a similar way. To use the **nano**
    editor, you type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git使用**vi**编辑器来编辑提交信息。如果您更喜欢其他编辑器，那么您可以通过类似的方式更改配置。要使用**nano**编辑器，您需要输入以下命令：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For more information about Git, please see the *Git Version Control* *Cookbook*
    ([https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545](https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Git的更多信息，请参阅*Git版本控制* *食谱* ([https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545](https://www.packtpub.com/product/git-version-control-cookbook-second-edition/9781789137545))。
- en: Now you are ready to clone the LLVM repository from GitHub.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好从GitHub克隆LLVM仓库了。
- en: Cloning the repository
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆仓库
- en: The command to clone the repository is essentially the same on all platforms.
    Only on Windows, it is recommended to turn off the auto-translation of line endings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆仓库的命令在所有平台上基本上是相同的。只有在Windows上，建议关闭自动转换行结束符的功能。
- en: 'On all non-Windows platforms, you type the following command to clone the repository:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有非Windows平台上，您需要输入以下命令来克隆仓库：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only on Windows, add the option to disable auto-translation of line endings.
    Here, you type the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在Windows上，才需要添加禁用自动转换行结束符的选项。这里，您需要输入以下命令：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This Git command clones the latest source code from GitHub into a local directory
    named `llvm-project`. Now change the current directory into the new `llvm-project`
    directory with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Git命令将最新的源代码从GitHub克隆到名为`llvm-project`的本地目录中。现在使用以下命令将当前目录切换到新的`llvm-project`目录：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the directory are all LLVM projects, each one in its own directory.
    Most notably, the LLVM core libraries are in the `llvm` subdirectory. The LLVM
    project uses branches for subsequent release development (“release/17.x”) and
    tags (“llvmorg-17.0.1”) to mark a certain release. With the preceding clone command,
    you get the current development state. This book uses LLVM 17\. To check out the
    first release of LLVM 17 into a branch called `llvm-17`, you type the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目录内部包含所有LLVM项目，每个项目都在自己的目录中。最值得注意的是，LLVM核心库位于`llvm`子目录中。LLVM项目使用分支进行后续的发布开发（“release/17.x”）和标签（“llvmorg-17.0.1”）来标记特定的发布。使用前面的克隆命令，您将获得当前的开发状态。本书使用LLVM
    17。要将LLVM 17的第一个发布版本检出到一个名为`llvm-17`的分支，您需要输入以下命令：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the previous steps, you cloned the whole repository and created a branch
    from a tag. This is the most flexible approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，您已经克隆了整个仓库并从标签创建了一个分支。这是最灵活的方法。
- en: Git also allows you to clone only a branch or a tag (including history). With
    `git clone --branch release/17.x https://github.com/llvm/llvm-project`, you only
    clone the `release/17.x` branch and its history. You then have the latest state
    of the LLVM 17 release branch, so you only need to create a branch from the release
    tag like before if you need the exact release version. With the additional `–-depth=1`
    option, which is known as a **shallow clone with Git**, you prevent the cloning
    of the history, too. This saves time and space but obviously limits what you can
    do locally, including checking out a branch based on the release tags.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Git 还允许你仅克隆一个分支或一个标签（包括历史记录）。使用 `git clone --branch release/17.x https://github.com/llvm/llvm-project`，你只克隆
    `release/17.x` 分支及其历史记录。这样，你就拥有了 LLVM 17 发布分支的最新状态，因此如果你需要确切的发布版本，你只需像以前一样从发布标签创建一个分支即可。使用额外的
    `–-depth=1` 选项，这被称为 Git 的**浅克隆**，你还可以防止克隆历史记录。这节省了时间和空间，但显然限制了你在本地可以做的事情，包括基于发布标签检出分支。
- en: Creating a build directory
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建目录
- en: 'Unlike many other projects, LLVM does not support inline builds and requires
    a separate build directory. Most easily, this is created inside the `llvm-project`
    directory, which is your current directory. Let us name the build directory, `build`,
    for simplicity. Here, the commands for Unix and Windows systems differ. On a Unix-like
    system, you use the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他项目不同，LLVM 不支持内联构建并需要一个单独的构建目录。最简单的方法是在 `llvm-project` 目录内创建，这是你的当前目录。为了简单起见，让我们将构建目录命名为
    `build`。在这里，Unix 和 Windows 系统的命令不同。在类 Unix 系统上，你使用以下命令：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And on Windows, use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用以下命令：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you are ready to create the build system files with the CMake tool inside
    this directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好在这个目录内使用 CMake 工具创建构建系统文件。
- en: Generating the build system files
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成构建系统文件
- en: 'In order to generate build system files to compile LLVM and clang using Ninja,
    you run the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成使用 Ninja 编译 LLVM 和 clang 的构建系统文件，你运行以下命令：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `-G` option tells CMake for which system to generate build files. Often-used
    values for that option are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`-G` 选项告诉 CMake 为哪个系统生成构建文件。该选项常用的值如下：'
- en: '`Ninja` – for the Ninja build system'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ninja` – 用于 Ninja 构建系统'
- en: '`Unix Makefiles` – for GNU Make'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unix Makefiles` – 用于 GNU Make'
- en: '`Visual Studio 17 VS2022` – for Visual Studio and MS Build'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Visual Studio 17 VS2022` – 用于 Visual Studio 和 MS Build'
- en: '`Xcode` – for Xcode projects'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xcode` – 用于 Xcode 项目'
- en: With the `–B` option, you tell CMake the path of the build directory. Similarly,
    you specify the source directory with the `–S` option. The generation process
    can be influenced by setting various variables with the `–D` option. Usually,
    they are prefixed with `CMAKE_` (if defined by CMake) or `LLVM_` (if defined by
    LLVM).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `–B` 选项，你告诉 CMake 构建目录的路径。同样，使用 `–S` 选项指定源目录。生成过程可以通过设置 `–D` 选项中的各种变量来影响。通常，它们以
    `CMAKE_`（如果由 CMake 定义）或 `LLVM_`（如果由 LLVM 定义）为前缀。
- en: As mentioned previously, we are also interested in compiling clang alongside
    LLVM. With the `LLVM_ENABLE_PROJECTS=clang` variable setting, this allows CMake
    to generate the build files for clang in addition to LLVM. Furthermore, the `CMAKE_BUILD_TYPE=Release`
    variable tells CMake that it should generate build files for a release build.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还对在 LLVM 旁边编译 clang 感兴趣。通过设置 `LLVM_ENABLE_PROJECTS=clang` 变量，这允许 CMake
    生成 clang 的构建文件，除了 LLVM。此外，`CMAKE_BUILD_TYPE=Release` 变量告诉 CMake 应该生成发布构建的构建文件。
- en: 'The default value for the `–G` option depends on your platform, and the default
    value for the build type depends on the toolchain. However, you can define your
    own preference with environment variables. The `CMAKE_GENERATOR` variable controls
    the generator, and the `CMAKE_BUILD_TYPE` variable specifies the build type. If
    you use **bash** or a similar shell, then you can set the variables with the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`–G` 选项的默认值取决于你的平台，构建类型的默认值取决于工具链。然而，你可以使用环境变量定义自己的偏好。`CMAKE_GENERATOR` 变量控制生成器，而
    `CMAKE_BUILD_TYPE` 变量指定构建类型。如果你使用 **bash** 或类似的 shell，那么你可以使用以下方式设置变量：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you are using the Windows command prompt instead, then you set the variables
    with the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Windows 命令提示符，那么你可以使用以下方式设置变量：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With these settings, the command to create the build system files becomes the
    following, which is easier to type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，创建构建系统文件的命令变为以下内容，这更容易输入：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will find more about CMake variables in the *Customizing the build* *process*
    section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *自定义构建过程* 部分找到更多关于 CMake 变量的信息。
- en: Compiling and installing LLVM
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和安装 LLVM
- en: 'After the build files are generated, LLVM and clang can be compiled with the
    following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成构建文件后，可以使用以下方式编译 LLVM 和 clang：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command runs Ninja under the hood because we told CMake to generate Ninja
    files in the configuration step. However, if you generate build files for a system
    such as Visual Studio, which supports multiple build configurations, then you
    need to specify the configuration to use for the build with the `--config` option.
    Depending on the hardware resources, this command runs for between 15 minutes
    (server with lots of CPU cores, memory, and fast storage) and several hours (dual-core
    Windows notebook with limited memory).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在底层运行 Ninja，因为我们告诉 CMake 在配置步骤中生成 Ninja 文件。然而，如果您为支持多个构建配置的系统（如 Visual Studio）生成构建文件，则需要使用
    `--config` 选项指定用于构建的配置。根据硬件资源，此命令的运行时间在 15 分钟（具有大量 CPU 核心、内存和快速存储的服务器）到数小时（双核
    Windows 笔记本，内存有限）之间。
- en: By default, Ninja utilizes all available CPU cores. This is good for the speed
    of compilation but may prevent other tasks from running; for example, on a Windows-based
    notebook, it is almost impossible to surf the internet while Ninja is running.
    Fortunately, you can limit the resource usage with the `–``j` option.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ninja 会利用所有可用的 CPU 核心。这对于编译速度是有好处的，但可能会阻止其他任务运行；例如，在基于 Windows 的笔记本电脑上，当
    Ninja 运行时几乎无法上网。幸运的是，您可以使用 `--j` 选项限制资源使用。
- en: 'Let’s assume you have four CPU cores available and Ninja should only use two
    (because you have parallel tasks to run); you then use this command for compilation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有四个 CPU 核心可用，而 Ninja 应仅使用两个（因为您有并行任务要运行）；然后您使用此命令进行编译：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After compilation is finished, a best practice is to run the test suite to
    check whether everything works as expected:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，一个最佳实践是运行测试套件以检查是否一切按预期工作：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, the runtime of this command varies widely with the available hardware
    resources. The `check-all` Ninja target runs all test cases. Targets are generated
    for each directory containing test cases. Using `check-llvm` instead of `check-all`
    runs the LLVM tests but not the clang tests; `check-llvm-codegen` runs only the
    tests in the `CodeGen` directory from LLVM (that is, the `llvm/test/CodeGen` directory).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此命令的运行时间会因可用硬件资源而大不相同。`check-all` Ninja 目标会运行所有测试用例。为包含测试用例的每个目录生成目标。使用
    `check-llvm` 而不是 `check-all` 将运行 LLVM 测试但不运行 clang 测试；`check-llvm-codegen` 仅运行
    LLVM 的 `CodeGen` 目录中的测试（即 `llvm/test/CodeGen` 目录）。
- en: 'You can also do a quick manual check. One of the LLVM applications is `-version`
    option, it shows the LLVM version, the host CPU, and all supported architectures:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以进行快速的手动检查。LLVM 应用程序中的一个选项是 `-version`，它显示 LLVM 版本、主机 CPU 和所有支持的架构：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you have trouble getting LLVM compiled, then you should consult the *Common
    Problems* section of the *Getting Started with the LLVM System* documentation
    https://releases.llvm.org/17.0.1/docs/GettingStarted.html#common-problems) for
    solutions to typical problems.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在编译 LLVM 时遇到问题，那么您应该查阅 *Getting Started with the LLVM System* 文档中的 *常见问题*
    部分 https://releases.llvm.org/17.0.1/docs/GettingStarted.html#common-problems)
    以获取典型问题的解决方案。
- en: 'As the last step, you can install the binaries:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，您可以安装二进制文件：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On a Unix-like system, the install directory is `/usr/local`. On Windows, `C:\Program
    Files\LLVM` is used. This can be changed, of course. The next section explains
    how.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上，安装目录是 `/usr/local`。在 Windows 上，使用 `C:\Program Files\LLVM`。当然，这也可以更改。下一节将解释如何更改。
- en: Customizing the build process
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义构建过程
- en: The CMake system uses a project description in the `CMakeLists.txt` file. The
    top-level file is in the `llvm` directory, `llvm/CMakeLists.txt`. Other directories
    also have `CMakeLists.txt` files, which are recursively included during the generation
    process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 系统使用 `CMakeLists.txt` 文件中的项目描述。顶级文件位于 `llvm` 目录中，`llvm/CMakeLists.txt`。其他目录也有
    `CMakeLists.txt` 文件，在生成过程中递归包含。
- en: Based on the information provided in the project description, CMake checks which
    compilers are installed, detects libraries and symbols, and creates the build
    system files, for example, `build.ninja` or `Makefile` (depending on the chosen
    generator). It is also possible to define reusable modules, for example, a function
    to detect whether LLVM is installed. These scripts are placed in the special `cmake`
    directory (`llvm/cmake`), which is searched automatically during the generation
    process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目描述中提供的信息，CMake会检查已安装的编译器，检测库和符号，并创建构建系统文件，例如`build.ninja`或`Makefile`（取决于选择的生成器）。还可能定义可重用的模块，例如检测LLVM是否已安装的函数。这些脚本放置在特殊的`cmake`目录（`llvm/cmake`）中，在生成过程中会自动搜索。
- en: The build process can be customized with the definition of CMake variables.
    The command-line option `–D` is used to set a variable to a value. The variables
    are used in the CMake scripts. Variables defined by CMake itself are almost always
    prefixed with `CMAKE_` and these variables can be used in all projects. Variables
    defined by LLVM are prefixed with `LLVM_` but they can only be used if the project
    definition includes the use of LLVM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程可以通过CMake变量的定义进行自定义。命令行选项`–D`用于将变量设置为一个值。变量在CMake脚本中使用。由CMake本身定义的变量几乎总是以`CMAKE_`为前缀，并且这些变量可以在所有项目中使用。由LLVM定义的变量以`LLVM_`为前缀，但只有在项目定义中包含了对LLVM的使用时才能使用。
- en: Variables defined by CMake
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 由CMake定义的变量
- en: Some variables are initialized with the value of environment variables. Most
    notable are `CC` and `CXX`, which define the C and C++ compilers to be used for
    building. CMake tries to locate a C and a C++ compiler automatically, using the
    current shell search path. It picks the first compiler found. If you have several
    compilers installed, for example, gcc and clang or different versions of clang,
    then this might not be the compiler you want for building LLVM.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些变量使用环境变量的值进行初始化。最显著的是`CC`和`CXX`，它们定义了用于构建的C和C++编译器。CMake会尝试自动定位C和C++编译器，使用当前shell搜索路径。它会选择找到的第一个编译器。如果你安装了多个编译器，例如gcc和clang或不同版本的clang，那么这可能不是你用于构建LLVM的编译器。
- en: 'Suppose you like to use clang17 as a C compiler and clang++17 as a C++ compiler.
    Then, you can invoke CMake in a Unix shell in the following way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望使用clang17作为C编译器，clang++17作为C++编译器。那么，你可以在Unix shell中以以下方式调用CMake：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This sets the value of the environment variables only for the invocation of
    `cmake`. If necessary, you can specify an absolute path for the compiler executables.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这只为`cmake`的调用设置环境变量的值。如果需要，你可以指定编译器可执行文件的绝对路径。
- en: '`CC` is the default value of the `CMAKE_C_COMPILER` CMake variable, and `CXX`
    is the default value of the `CMAKE_CXX_COMPILER` CMake variable. Instead of using
    the environment variables, you can set the CMake variables directly. This is equivalent
    to the preceding call:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`CC`是`CMAKE_C_COMPILER` CMake变量的默认值，`CXX`是`CMAKE_CXX_COMPILER` CMake变量的默认值。而不是使用环境变量，你可以直接设置CMake变量。这相当于前面的调用：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Other useful variables defined by CMake are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CMake定义的其他有用变量如下：
- en: '| **Variable name** | **Purpose** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **变量名** | **用途** |'
- en: '| --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CMAKE_INSTALL_PREFIX` | This is a path prefix that is prepended to every
    path during installation. The default is `/usr/local` on Unix and `C:\Program
    Files\<Project>` on Windows. To install LLVM in the `/opt/llvm` directory, you
    specify `-DCMAKE_INSTALL_PREFIX=/opt/llvm`. The binaries are copied to `/opt/llvm/bin`,
    library files to `/opt/llvm/lib`, and so on. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `CMAKE_INSTALL_PREFIX` | 这是一个路径前缀，在安装过程中会添加到每个路径之前。在Unix上默认为`/usr/local`，在Windows上默认为`C:\Program
    Files\<Project>`。要在`/opt/llvm`目录中安装LLVM，你指定`-DCMAKE_INSTALL_PREFIX=/opt/llvm`。二进制文件会复制到`/opt/llvm/bin`，库文件到`/opt/llvm/lib`，等等。|'
- en: '| `CMAKE_BUILD_TYPE` | Different types of build require different settings.
    For example, a debug build needs to specify options to generate debug symbols
    and usually link against debug versions of system libraries. In contrast, a release
    build uses optimization flags and links against production versions of libraries.
    This variable is only used for build systems that can only handle one build type,
    for example, Ninja or Make. For IDE build systems, all variants are generated
    and you have to use the mechanism of the IDE to switch between build types. Possible
    values are as follows:`DEBUG`: build with debug symbols`RELEASE`: build with optimization
    for speed`RELWITHDEBINFO`: release build with debug symbols`MINSIZEREL`: build
    with optimization for sizeThe default build type is taken from the `CMAKE_BUILD_TYPE`
    environment variable. If this variable is not set, then the default depends on
    the used toolchain and is often empty. In order to generate build files for a
    release build, you specify `-DCMAKE_BUILD_TYPE=RELEASE`. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `CMAKE_BUILD_TYPE` | 不同的构建类型需要不同的设置。例如，调试构建需要指定生成调试符号的选项，通常链接到系统库的调试版本。相比之下，发布构建使用优化标志并链接到库的生产版本。此变量仅用于只能处理一种构建类型的构建系统，例如
    Ninja 或 Make。对于 IDE 构建系统，所有变体都会生成，您必须使用 IDE 的机制在构建类型之间切换。可能的值如下：`DEBUG`：带有调试符号的构建`RELEASE`：优化速度的构建`RELWITHDEBINFO`：带有调试符号的发布构建`MINSIZEREL`：优化大小的构建默认的构建类型是从
    `CMAKE_BUILD_TYPE` 环境变量中获取的。如果此变量未设置，则默认值取决于使用的工具链，通常为空。为了生成发布构建的构建文件，您指定 `-DCMAKE_BUILD_TYPE=RELEASE`。|'
- en: '| `CMAKE_C_FLAGS``CMAKE_CXX_FLAGS` | These are extra flags used when compiling
    C and C++ source files. The initial values are taken from the `CFLAGS` and `CXXFLAGS`
    environment variables, which can be used as an alternative. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `CMAKE_C_FLAGS` | `CMAKE_CXX_FLAGS` | 这些是在编译 C 和 C++ 源文件时使用的额外标志。初始值是从 `CFLAGS`
    和 `CXXFLAGS` 环境变量中获取的，也可以用作替代。|'
- en: '| `CMAKE_MODULE_PATH` | This specifies additional directories that are searched
    for CMake modules. The specified directories are searched before the default ones.
    The value is a semicolon-separated list of directories. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `CMAKE_MODULE_PATH` | 这指定了搜索 CMake 模块的附加目录。指定的目录在默认目录之前被搜索。该值是一个以分号分隔的目录列表。|'
- en: '| `PYTHON_EXECUTABLE` | If the Python interpreter is not found or if the wrong
    one is picked in case you have installed multiple versions, you can set this variable
    to the path of the Python binary. This variable only has an effect if the Python
    module of CMake is included (which is the case for LLVM). |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `PYTHON_EXECUTABLE` | 如果未找到 Python 解释器或您安装了多个版本而选择了错误的版本，您可以设置此变量为 Python
    二进制的路径。此变量仅在包含 CMake Python 模块（对于 LLVM 是这种情况）时才有效。|'
- en: Table 1.1 - Additional useful variables provided by CMake
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 - CMake 提供的附加有用变量
- en: 'CMake provides built-in help for variables. The `--help-variable var` option
    prints help for the `var` variable. For instance, you can type the following to
    get help for `CMAKE_BUILD_TYPE`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 为变量提供了内置的帮助。`--help-variable var` 选项打印 `var` 变量的帮助。例如，您可以输入以下内容以获取 `CMAKE_BUILD_TYPE`
    的帮助：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also list all variables with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令列出所有变量：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This list is very long. You may want to pipe the output to `more` or a similar
    program.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表非常长。您可能希望将输出通过 `more` 或类似程序管道输出。
- en: Using LLVM-defined build configuration variables
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用由 LLVM 定义的构建配置变量
- en: The build configuration variables defined by LLVM work in the same way as those
    defined by CMake except that there is no built-in help. The most useful variables
    are found in the following tables, where they are divided into variables that
    are useful for first-time users installing LLVM, and also variables for more advanced
    LLVM users.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由 LLVM 定义的构建配置变量与由 CMake 定义的变量工作方式相同，只是没有内置的帮助。最有用的变量可以在以下表中找到，其中它们被分为对首次安装
    LLVM 的用户有用的变量，以及更高级的 LLVM 用户使用的变量。
- en: Variables useful for first-time users installing LLVM
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对首次安装 LLVM 的用户有用的变量
- en: '| **Variable name** | **Purpose** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **变量名称** | **用途** |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LLVM_TARGETS_TO_BUILD` | LLVM supports code generation for different CPU
    architectures. By default, all these targets are built. Use this variable to specify
    the list of targets to build, separated by semicolons. The current targets are
    `AArch64`, `AMDGPU`, `ARM`, `AVR,` `BPF`, `Hexagon`, `Lanai`, `LoongArch`, `Mips`,
    `MSP430`, `NVPTX`, `PowerPC`, `RISCV`, `Sparc`, `SystemZ`, `VE`, `WebAssembly`,
    `X86`, and `XCore`. `all` can be used as shorthand for all targets. The names
    are case-sensitive. To only enable the PowerPC and the System Z target, you specify
    `-DLLVM_TARGETS_TO_BUILD="PowerPC;SystemZ"`. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_TARGETS_TO_BUILD` | LLVM支持为不同的CPU架构生成代码。默认情况下，构建所有这些目标。使用此变量来指定要构建的目标列表，由分号分隔。当前的目标包括
    `AArch64`、`AMDGPU`、`ARM`、`AVR`、`BPF`、`Hexagon`、`Lanai`、`LoongArch`、`Mips`、`MSP430`、`NVPTX`、`PowerPC`、`RISCV`、`Sparc`、`SystemZ`、`VE`、`WebAssembly`、`X86`
    和 `XCore`。`all` 可以用作所有目标的简称。名称是区分大小写的。要仅启用PowerPC和System Z目标，你指定 `-DLLVM_TARGETS_TO_BUILD="PowerPC;SystemZ"`。
    |'
- en: '| `LLVM_EXPERIMENTAL_TARGETS_TO_BUILD` | In addition to the official targets,
    the LLVM source tree also contains experimental targets. These targets are under
    development and often do not yet support the full functionality of a backend.
    The current list of experimental targets is `ARC`, `CSKY`, `DirectX`, `M68k`,
    `SPIRV`, and `Xtensa`. To build the `M68k` target, you specify `-``D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M68k`.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_EXPERIMENTAL_TARGETS_TO_BUILD` | 除了官方的目标之外，LLVM源代码树还包含实验性目标。这些目标处于开发中，通常还不支持后端的所有功能。当前实验性目标的列表包括
    `ARC`、`CSKY`、`DirectX`、`M68k`、`SPIRV` 和 `Xtensa`。要构建 `M68k` 目标，你指定 `-D LLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M68k`。
    |'
- en: '| `LLVM_ENABLE_PROJECTS` | This is a list of the projects you want to build,
    separated by semicolons. The source for the projects must be on the same level
    as the `llvm` directory (side-by-side layout). The current list is `bolt`, `clang`,
    `clang-tools-extra`, `compiler-rt`, `cross-project-tests`, `libc`, `libclc`, `lld`,
    `lldb`, `mlir`, `openmp`, `polly`, and `pstl`. `all` can be used as shorthand
    for all projects in this list. Additionally, you can specify the `flang` project
    here. Due to some special build requirements, it is not yet part of the `all`
    list.To build clang and bolt together with LLVM, you specify `-DLLVM_ENABLE_PROJECT="clang;bolt"`.
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_PROJECTS` | 这是你要构建的项目列表，由分号分隔。项目的源必须在 `llvm` 目录同一级别（并排布局）。当前的列表包括
    `bolt`、`clang`、`clang-tools-extra`、`compiler-rt`、`cross-project-tests`、`libc`、`libclc`、`lld`、`lldb`、`mlir`、`openmp`、`polly`
    和 `pstl`。`all` 可以用作此列表中所有项目的简称。此外，你还可以在此处指定 `flang` 项目。由于一些特殊的构建要求，它目前还不是 `all`
    列表的一部分。要一起构建clang和bolt与LLVM，你指定 `-DLLVM_ENABLE_PROJECT="clang;bolt"`。 |'
- en: Table 1.2 - Useful variables for first-time LLVM users
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2 - 首次使用LLVM用户的有用变量
- en: Variables for advanced users of LLVM
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LLVM的高级用户变量
- en: '| `LLVM_ENABLE_ASSERTIONS` | If set to `ON`, then assertion checks are enabled.
    These checks help to find errors and are very useful during development. The default
    value is `ON` for a `DEBUG` build and otherwise `OFF`. To turn assertion checks
    on (e.g. for a `RELEASE` build), you specify `–DLLVM_ENABLE_ASSERTIONS=ON`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_ASSERTIONS` | 如果设置为 `ON`，则启用断言检查。这些检查有助于查找错误，在开发期间非常有用。对于 `DEBUG`
    构建默认值为 `ON`，否则为 `OFF`。要启用断言检查（例如，对于 `RELEASE` 构建），你指定 `–DLLVM_ENABLE_ASSERTIONS=ON`。
    |'
- en: '| `LLVM_ENABLE_EXPENSIVE_CHECKS` | This enables some expensive checks that
    can really slow down compilation speed or consume large amounts of memory. The
    default value is `OFF`. To turn these checks on, you specify `-DLLVM_ENABLE_EXPENSIVE_CHECKS=ON`.
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_EXPENSIVE_CHECKS` | 这将启用一些昂贵的检查，这些检查可能会真正减慢编译速度或消耗大量内存。默认值是
    `OFF`。要启用这些检查，你指定 `-DLLVM_ENABLE_EXPENSIVE_CHECKS=ON`。 |'
- en: '| `LLVM_APPEND_VC_REV` | LLVM tools such as `llc` display the LLVM version
    they are based on besides other information if the `–version` command-line option
    is given. This version information is based on the `LLVM_REVISION` C macro. By
    default, not only the LLVM version but also the current Git hash is part of the
    version information. This is handy in case you are following the development of
    the master branch because it makes clear on which Git commit the tool is based.
    If not needed, then this can be turned off with `–DLLVM_APPEND_VC_REV=OFF`. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_APPEND_VC_REV` | 如果提供了 `-version` 命令行选项，LLVM工具（如 `llc`）除了显示其他信息外，还会显示它们基于的LLVM版本。这个版本信息基于
    `LLVM_REVISION` C宏。默认情况下，LLVM版本以及当前的Git哈希值都是版本信息的一部分。如果你正在跟踪master分支的开发，这很有用，因为它清楚地表明工具基于哪个Git提交。如果不需要，则可以使用
    `–DLLVM_APPEND_VC_REV=OFF` 来关闭它。 |'
- en: '| `LLVM_ENABLE_THREADS` | LLVM automatically includes thread support if a threading
    library is detected (usually the `pthreads` library). Further, LLVM assumes in
    this case that the compiler supports `-DLLVM_ENABLE_THREADS=OFF`. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_THREADS` | 如果检测到线程库（通常是`pthreads`库），LLVM会自动包含线程支持。此外，在这种情况下，LLVM假设编译器支持`-DLLVM_ENABLE_THREADS=OFF`。|'
- en: '| `LLVM_ENABLE_EH` | The LLVM projects do not use C++ exception handling and
    therefore turn exception support off by default. This setting can be incompatible
    with other libraries your project is linking with. If needed, you can enable exception
    support by specifying `–DLLVM_ENABLE_EH=ON`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_EH` | LLVM项目不使用C++异常处理，因此默认关闭异常支持。此设置可能与项目链接的其他库不兼容。如果需要，可以通过指定`–DLLVM_ENABLE_EH=ON`来启用异常支持。|'
- en: '| `LLVM_ENABLE_RTTI` | LLVM uses a lightweight, self-build system for runtime
    type information. The generation of C++ RTTI is turned off by default. Like the
    exception handling support, this may be incompatible with other libraries. To
    turn generation of C++ RTTI on, you specify `–DLLVM_ENABLE_RTTI=ON`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_RTTI` | LLVM使用一个轻量级、自建的运行时类型信息系统。默认情况下关闭C++ RTTI的生成。与异常处理支持一样，这可能与其他库不兼容。要启用C++
    RTTI的生成，请指定`–DLLVM_ENABLE_RTTI=ON`。|'
- en: '| `LLVM_ENABLE_WARNINGS` | Compiling LLVM should generate no warning messages
    if possible. The option to print warning messages is therefore turned on by default.
    To turn it off, you specify `–DLLVM_ENABLE_WARNINGS=OFF`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_WARNINGS` | 如果可能，编译LLVM不应生成警告消息。因此，默认情况下启用了打印警告消息的选项。要关闭它，请指定`–DLLVM_ENABLE_WARNINGS=OFF`。|'
- en: '| `LLVM_ENABLE_PEDANTIC` | The LLVM source should be C/C++ language standard-conforming;
    hence, pedantic checking of the source is enabled by default. If possible, compiler-specific
    extensions are also disabled. To reverse this setting, you specify `–DLLVM_ENABLE_PEDANTIC=OFF`.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_PEDANTIC` | LLVM源代码应遵循C/C++语言标准；因此，默认情况下启用了源代码的严格检查。如果可能，也会禁用特定编译器的扩展。要反转此设置，请指定`–DLLVM_ENABLE_PEDANTIC=OFF`。|'
- en: '| `LLVM_ENABLE_WERROR` | If set to `ON`, then all warnings are treated as errors
    – the compilation aborts as soon as warnings are found. It helps to find all remaining
    warnings in the source. By default, it is turned off. To turn it on, you specify
    `–DLLVM_ENABLE_WERROR=ON`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_ENABLE_WERROR` | 如果设置为`ON`，则所有警告都视为错误——一旦发现警告，编译就会终止。这有助于在源代码中找到所有剩余的警告。默认情况下是关闭的。要启用它，请指定`–DLLVM_ENABLE_WERROR=ON`。|'
- en: '| `LLVM_OPTIMIZED_TABLEGEN` | Usually, the tablegen tool is built with the
    same options as all other parts of LLVM. At the same time, tablegen is used to
    generate large parts of the code generator. As a result, tablegen is much slower
    in a debug build, increasing the compile time noticeably. If this option is set
    to `ON`, then tablegen is compiled with optimization turned on even for a debug
    build, possibly reducing compile time. The default is `OFF`. To turn it on, you
    specify `–DLLVM_OPTIMIZED_TABLEGEN=ON`. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_OPTIMIZED_TABLEGEN` | 通常，tablegen工具会使用与LLVM其他部分相同的选项进行构建。同时，tablegen用于生成代码生成器的大部分代码。因此，在调试构建中，tablegen的速度会明显减慢，从而增加编译时间。如果此选项设置为`ON`，则即使在调试构建中，tablegen也会启用优化进行编译，这可能会减少编译时间。默认是`OFF`。要启用它，请指定`–DLLVM_OPTIMIZED_TABLEGEN=ON`。|'
- en: '| `LLVM_USE_SPLIT_DWARF` | If the build compiler is gcc or clang, then turning
    on this option will instruct the compiler to generate the DWARF debug information
    in a separate file. The reduced size of the object files reduces the link time
    of debug builds significantly. The default is `OFF`. To turn it on, you specify
    `-LLVM_USE_SPLIT_DWARF=ON`. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `LLVM_USE_SPLIT_DWARF` | 如果构建编译器是gcc或clang，则启用此选项将指示编译器在单独的文件中生成DWARF调试信息。对象文件大小的减少可以显著减少调试构建的链接时间。默认是`OFF`。要启用它，请指定`-LLVM_USE_SPLIT_DWARF=ON`。|'
- en: Table 1.3 - Useful variables for advanced LLVM users
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3 - 高级LLVM用户的有用变量
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: LLVM defines many more CMake variables. You can find the complete list in the
    LLVM documentation about CMake [https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables](https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables).
    The preceding list contains only the ones you are most likely to need.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM定义了许多其他CMake变量。您可以在LLVM关于CMake的文档中找到完整的列表[https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables](https://releases.llvm.org/17.0.1/docs/CMake.html#llvm-specific-variables)。上述列表仅包含您最可能需要的变量。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you prepared your development machine to compile LLVM. You
    cloned the GitHub repository and compiled your own version of LLVM and clang.
    The build process can be customized with CMake variables. You learned about useful
    variables and how to change them. Equipped with this knowledge, you can tweak
    LLVM to your needs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已准备好你的开发机器以编译 LLVM。你已克隆了 GitHub 仓库并编译了你自己的 LLVM 和 clang 版本。构建过程可以通过 CMake
    变量进行自定义。你了解了有用的变量以及如何更改它们。掌握了这些知识，你可以根据需要调整 LLVM。
- en: In the next section, we will be taking a closer look at the structure of a compiler.
    We will be exploring the different components found inside the compiler, as well
    as different types of analyses that occur in it – specifically, the lexical, syntactical,
    and semantic analyses. Finally, we will also briefly touch on interfacing with
    an LLVM backend for code generation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨编译器的结构。我们将探讨编译器内部的不同组件，以及在其中发生的不同类型的分析——特别是词法、语法和语义分析。最后，我们还将简要介绍与用于代码生成的
    LLVM 后端进行接口连接。
