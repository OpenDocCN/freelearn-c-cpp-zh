- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: States and Animations with Qt and QML
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt 和 QML 的状态和动画
- en: Qt provides an easy way to animate widgets or any other objects that inherit
    the `QObject` class through its powerful animation framework. The animation can
    be used either on its own or together with the **state machine framework**, which
    allows different animations to be played based on the current active state of
    the widget. Qt’s animation framework also supports grouped animation, which allows
    you to move more than one graphics item simultaneously or move them in sequence,
    one after the other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 通过其强大的动画框架提供了一个简单的方法来动画化小部件或任何继承自 `QObject` 类的其他对象。动画可以单独使用，也可以与 **状态机框架**
    一起使用，这允许根据小部件的当前活动状态播放不同的动画。Qt 的动画框架还支持分组动画，允许您同时移动多个图形项或按顺序依次移动它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Property animation in Qt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 中的属性动画
- en: Using easing curves to control property animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓动曲线控制属性动画
- en: Creating an animation group
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画组
- en: Creating a nested animation group
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建嵌套动画组
- en: State machines in Qt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 中的状态机
- en: States, transitions, and animations in QML
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML 中的状态、转换和动画
- en: Animating widget properties using animators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画器动画化小部件属性
- en: Sprite animation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵动画
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include **Qt 6.6.1 MinGW 64-bit**,
    **Qt Creator 12.0.2**, and Windows 11\. All the code used in this chapter can
    be downloaded from the following GitHub repository at [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括 **Qt 6.6.1 MinGW 64-bit**、**Qt Creator 12.0.2** 和 Windows 11。本章中使用的所有代码都可以从以下
    GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03)。
- en: Property animation in Qt
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 中的属性动画
- en: In this example, we will learn how to animate our `property animation` class,
    a part of its powerful animation framework that allows us to create fluid-looking
    animations with minimal effort.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何动画化我们的 `属性动画` 类，这是其强大的动画框架的一部分，允许我们以最小的努力创建流畅的动画。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following example, we will create a new widget project and animate the
    push button by changing its properties:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个新的小部件项目，并通过更改其属性来动画化按钮：
- en: 'Let’s create a new `mainwindow.ui` with Qt Designer and place a button on the
    main window, as shown here:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 Qt Designer 创建一个新的 `mainwindow.ui`，并在主窗口上放置一个按钮，如图所示：
- en: '![Figure 3.1 – Dragging and dropping a push button to the UI canvas](img/B20976_03_001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 将按钮拖放到 UI 画布上](img/B20976_03_001.jpg)'
- en: Figure 3.1 – Dragging and dropping a push button to the UI canvas
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 将按钮拖放到 UI 画布上
- en: 'Open up `mainwindow.cpp` and add the following line of code at the beginning
    of the source code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `mainwindow.cpp` 并在源代码开头添加以下代码行：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, open up `mainwindow.cpp` and add the following code to the constructor:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `mainwindow.cpp` 并在构造函数中添加以下代码：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One of the more common methods of animating a GUI element is through the property
    animation class provided by Qt, known as the `QPropertyAnimation` class. This
    class is part of the animation framework and it makes use of the timer system
    in Qt to change the properties of a GUI element over a given duration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 动画化 GUI 元素的一种更常见的方法是通过 Qt 提供的属性动画类，称为 `QPropertyAnimation` 类。这个类是动画框架的一部分，它利用
    Qt 中的计时器系统来改变 GUI 元素的属性。
- en: What we are trying to accomplish here is animating the button from one position
    to another while, at the same time, enlarging the button size along the way. By
    including the `QPropertyAnimation` header in our source code in *step 2*, we will
    be able to access the `QPropertyAnimation` class provided by Qt and make use of
    its functionalities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里试图实现的是在动画按钮从一个位置移动到另一个位置的同时，沿着路径扩大按钮的大小。通过在 *步骤 2* 中的源代码中包含 `QPropertyAnimation`
    头文件，我们将能够访问 Qt 提供的 `QPropertyAnimation` 类并利用其功能。
- en: The code in *step 3* basically creates a new *property animation* and applies
    it to the `property animation` class changes the geometry properties of the *push
    button* and sets its duration to 3,000 milliseconds (3 seconds).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 中的代码基本上创建了一个新的 *属性动画* 并将其应用于 `属性动画` 类，它更改了 *按钮* 的几何属性，并将其持续时间设置为 3,000
    毫秒（3 秒）。'
- en: 'Then, the start value of the animation is set to the initial geometry of the
    *push button* because, obviously, we want it to start from where we initially
    placed the button in Qt Designer. The `end` value is then set to what we want
    it to become; in this case, we will move the button to a new position at `x: 200`
    and `y: 200` while changing its size to `width: 100` and `height: 50` along the
    way.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，动画的起始值被设置为*按钮*的初始几何形状，因为显然我们希望它从我们在Qt Designer中最初放置按钮的位置开始。然后，`end`值被设置为我们希望它变成的样子；在这种情况下，我们将按钮移动到新的位置`x:
    200`和`y: 200`，并在移动过程中改变其大小为`width: 100`和`height: 50`。'
- en: After that, call `animation` | `start()` to start the animation. Compile and
    run the project. You should see the button start to move slowly across the main
    window while expanding in size a bit at a time until it reaches its destination.
    You can change the animation duration and the target position and scale by altering
    the values in the preceding code. It is really that simple to animate a GUI element
    using Qt’s property animation system!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，调用`animation` | `start()`来开始动画。编译并运行项目。你应该看到按钮开始缓慢地在主窗口中移动，同时每次稍微扩大一点，直到到达目的地。你可以通过更改前面代码中的值来改变动画持续时间、目标位置和缩放。使用Qt的属性动画系统来动画化GUI元素真的非常简单！
- en: There’s more…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Qt provides us with several different sub-systems to create animations for
    our GUI, including the timer, timeline, animation framework, state machine framework,
    and graphics view framework:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了几个不同的子系统来为我们的GUI创建动画，包括计时器、时间线、动画框架、状态机框架和图形视图框架：
- en: '`event callback` function will be triggered through Qt’s *signal-and-slot*
    mechanism. You can make use of a timer to change the properties (color, position,
    scale, and so on) of your GUI element within a given interval to create an animation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`事件回调`函数将通过Qt的*信号-槽*机制被触发。你可以使用计时器在给定的时间间隔内改变GUI元素的属性（颜色、位置、缩放等）以创建动画。'
- en: '**Timeline**: The *Timeline* calls a slot periodically to animate a GUI element.
    It is quite similar to a *repetitive timer*, but instead of doing the same thing
    all of the time when the slot is triggered, the timeline provides a value to the
    slot to indicate its current frame index so that you can do different things (such
    as offset to a different space of the sprite sheet) based on the given value.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：*时间线*定期调用槽来动画化一个GUI元素。它与*重复计时器*非常相似，但当槽被触发时，它不会一直做同样的事情，而是向槽提供一个值来指示其当前帧索引，这样你就可以根据给定的值做不同的事情（例如，偏移到精灵图的另一个空间）。'
- en: '**Animation framework**: The *animation framework* makes animating a GUI element
    easy by allowing its properties to be animated. The animations are controlled
    by using *easing curves*. Easing curves describe a function that controls what
    the speed of the animation should be, resulting in different acceleration and
    deceleration patterns. The types of easing curves supported by Qt include linear,
    quadratic, cubic, quartic, sine, exponential, circular, and elastic.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画框架**：*动画框架*通过允许其属性动画化，使动画化GUI元素变得简单。动画是通过使用*缓动曲线*来控制的。缓动曲线描述了一个函数，它控制动画的速度应该是什么，从而产生不同的加速和减速模式。Qt支持的缓动曲线类型包括线性、二次、三次、四次、正弦、指数、圆形和弹性。'
- en: '**State machine framework**: Qt provides us with classes for creating and executing
    state graphs, which allow each GUI element to move from one state to another when
    triggered by signals. The *state graph* in the *state machine framework* is hierarchical,
    which means every state can also be nested inside of other states.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态机框架**：Qt为我们提供了创建和执行状态图的类，允许每个GUI元素在由信号触发时从一个状态移动到另一个状态。*状态机框架*中的*状态图*是分层的，这意味着每个状态也可以嵌套在其他状态内部。'
- en: '**Graphics view framework**: The *graphics view framework* is a powerful graphics
    engine for visualizing and interacting with a large number of custom-made 2D graphical
    items. You can use the graphics view framework to draw your GUI and have them
    animated in a totally manual way if you are an experienced programmer.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形视图框架**：*图形视图框架*是一个强大的图形引擎，用于可视化与大量自定义的2D图形元素交互。如果你是一个经验丰富的程序员，你可以使用图形视图框架来绘制你的GUI，并以完全手动的方式使它们动画化。'
- en: By making use of all of the powerful features we’ve mentioned here, we’re able
    to create an intuitive and modern GUI with ease. In this chapter, we will look
    into the practical approaches to animating GUI elements using Qt.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用我们在这里提到的所有强大功能，我们可以轻松地创建直观且现代的GUI。在本章中，我们将探讨使用Qt动画化GUI元素的实际方法。
- en: Using easing curves to control property animation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓动曲线控制属性动画
- en: In this example, we will learn how to make our animation more interesting by
    utilizing *easing curves*. We will still use the previous source code, which uses
    the property animation to animate a push button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何通过利用**缓动曲线**使我们的动画更有趣。我们仍然会使用之前的源代码，该代码使用属性动画来动画化一个按钮。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In the following example, we will learn how to add an *easing curve* to our
    animation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将学习如何将一个**缓动曲线**添加到我们的动画中：
- en: 'Define an easing curve and add it to the property animation before calling
    the `start()` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`start()`函数之前，定义一个缓动曲线并将其添加到属性动画中：
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Call the `setLoopCount()` function to set how many loops you want it to repeat
    for:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`setLoopCount()`函数来设置它重复的次数：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Call `setAmplitude()`, `setOvershoot()`, and `setPeriod()` before applying
    the easing curve to the animation:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用缓动曲线到动画之前，调用`setAmplitude()`、`setOvershoot()`和`setPeriod()`：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s really that easy to animate a widget or any object in Qt 6 using the built-in
    easing curves.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt 6中使用内置的缓动曲线来动画化小部件或任何对象真的非常简单。
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To let an easing curve control the animation, all you need to do is define
    an easing curve and add it to the property animation before calling the `start()`
    function. You can also try several other types of easing curves and see which
    one suits you best. Here is an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要让缓动曲线控制动画，你只需要定义一个缓动曲线并将其添加到属性动画中，在调用`start()`函数之前。你也可以尝试几种其他类型的缓动曲线，看看哪一种最适合你。以下是一个示例：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want the animation to loop after it has finished playing, you can call
    the `setLoopCount()` function to set how many loops you want it to repeat for
    or set the value to `-1` for an infinite loop:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望动画在播放完毕后循环，你可以调用`setLoopCount()`函数来设置它重复的次数，或者将值设置为`-1`以实现无限循环：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several parameters that you can set to refine the easing curve before
    applying it to the property animation. These parameters include **amplitude**,
    **overshoot**, and **period**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用属性动画之前，你可以设置几个参数来细化缓动曲线。这些参数包括**振幅**、**超调**和**周期**：
- en: '**Amplitude**: The higher the *amplitude*, the higher the bounce or elastic
    spring effect that will be applied to the animation.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**振幅**：振幅越高，动画中应用的弹跳或弹性弹簧效果就越明显。'
- en: '**Overshoot**: Some curve functions will produce an *overshoot* (exceeding
    its final value) curve due to a damping effect. By adjusting the overshoot value,
    we are able to increase or decrease this effect.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超调**：由于阻尼效应，某些曲线函数会产生**超调**（超过其最终值）曲线。通过调整超调值，我们可以增加或减少这种效果。'
- en: '**Period**: Setting a small period value will give a high frequency to the
    curve. A large *period* will give it a small frequency.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期**：设置较小的周期值会给曲线带来高频率。较大的**周期**会给它带来低频率。'
- en: These parameters, however, are not applicable to all curve types. Please refer
    to the Qt documentation to see which parameter is applicable to which curve type.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些参数并不适用于所有曲线类型。请参阅Qt文档以了解哪些参数适用于哪些曲线类型。
- en: There’s more...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'While the property animation works perfectly fine, sometimes it feels a little
    boring to look at a GUI element being animated at a constant speed. We can make
    the animation look more interesting by adding an **easing curve** to control the
    motion. There are many types of easing curves that you can use in Qt, and here
    are some of them:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然属性动画工作得很好，但有时看着一个GUI元素以恒定速度动画化会显得有点无聊。我们可以通过添加一个**缓动曲线**来控制运动，使动画看起来更有趣。Qt中有许多类型的缓动曲线可供使用，以下是一些：
- en: '![Figure 3.2 – Different types of easing curves supported by Qt 6](img/B20976_03_002.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – Qt 6支持的缓动曲线类型](img/B20976_03_002.jpg)'
- en: Figure 3.2 – Different types of easing curves supported by Qt 6
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – Qt 6支持的缓动曲线类型
- en: As you can see from the preceding diagram, each easing curve produces a different
    *ease-in and* *ease-out* effect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，每种缓动曲线都会产生不同的**加速**和**减速**效果。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the full list of easing curves available in Qt, please refer to the Qt documentation
    at [http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum](http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Qt中可用的完整缓动曲线列表，请参阅Qt文档中的[http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum](http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum)。
- en: Creating an animation group
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画组
- en: In this example, we will learn how to use an *animation group* to manage the
    states of the animations contained in the group.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何使用**动画组**来管理组内包含的动画的状态。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s create an *animation group* by following these steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个**动画组**：
- en: 'We will use the previous example but, this time, we will add two more push
    buttons to the main window, as shown in the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用之前的示例，但这次，我们将向主窗口添加两个更多的推送按钮，如下面的截图所示：
- en: '![Figure 3.3 – Adding three push buttons to the main window](img/B20976_03_003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 向主窗口添加三个推送按钮](img/B20976_03_003.jpg)'
- en: Figure 3.3 – Adding three push buttons to the main window
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 向主窗口添加三个推送按钮
- en: 'Define the *animation* for each of the push buttons in the main window’s constructor:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主窗口的构造函数中为每个推送按钮定义**动画**：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create an *easing curve* and apply the same curve to all three animations:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**缓动曲线**并将相同的曲线应用于所有三个动画：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you have applied the easing curve to all three animations, we will then
    create an *animation group* and add all three animations to the group:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将缓动曲线应用于所有三个动画后，我们将创建一个**动画组**并将所有三个动画添加到组中：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the `start()` function from the animation group we just created:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们刚刚创建的动画组中调用`start()`函数：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Qt allows us to create multiple animations and group them into an animation
    group. A group is usually responsible for managing the state of its animations
    (that is, it decides when to start, stop, resume, and pause them). Currently,
    Qt provides two types of classes for animation groups: `QParallelAnimationGroup`
    and `QSequentialAnimationGroup`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Qt允许我们创建多个动画并将它们组合成一个动画组。组通常负责管理其动画的状态（即，它决定何时开始、停止、恢复和暂停它们）。目前，Qt为动画组提供了两种类型的类：`QParallelAnimationGroup`和`QSequentialAnimationGroup`：
- en: '`QParallelAnimationGroup`: As its name implies, a *parallel animation group*
    runs all of the animations in its group at the same time. The group is deemed
    finished when the longest-lasting animation has finished running.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QParallelAnimationGroup`：正如其名称所暗示的，一个**并行动画组**同时运行其组中的所有动画。当持续时间最长的动画完成后，组被认为是完成的。'
- en: '`QSequentialAnimationGroup`: A *sequential animation group* runs its animations
    in sequence, meaning it will only run a single animation at a time and only play
    the next animation when the current one has finished.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QSequentialAnimationGroup`：一个**顺序动画组**按顺序运行其动画，这意味着它一次只运行一个动画，并且只有当前动画完成后才会播放下一个动画。'
- en: There’s more…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Since we are using an animation group now, we no longer call the `start()`
    function from the individual animation. Instead, we will be calling the `start()`
    function from the animation group we just created. If you compile and run the
    example now, you will see all three buttons being played at the same time. This
    is because we are using the **parallel** **animation group**. You can replace
    it with a **sequential animation group** and run the example again:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在正在使用动画组，我们不再从单个动画中调用`start()`函数。相反，我们将从我们刚刚创建的动画组中调用`start()`函数。如果您现在编译并运行示例，您将看到所有三个按钮同时播放。这是因为我们正在使用**并行**动画组。您可以用**顺序**动画组替换它，并再次运行示例：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This time, only a single button will play its animation at a time, while the
    other buttons will wait patiently for their turn to come. The priority is set
    based on which animation is added to the animation group first. You can change
    the animation sequence by simply rearranging the sequence of an animation that’s
    being added to the group. For example, if we want button `3` to start the animation
    first, followed by button `2`, and then button `1`, the code will look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，只有单个按钮会播放其动画，而其他按钮将耐心等待它们的轮到。优先级是根据哪个动画首先添加到动画组中而设置的。您可以通过简单地重新排列要添加到组中的动画的顺序来更改动画顺序。例如，如果我们想按钮`3`首先开始动画，然后是按钮`2`，最后是按钮`1`，代码将如下所示：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since property animations and animation groups are both inherited from the `QAbstractAnimator`
    class, it means that you can also add an animation group to another animation
    group to form a more complex, nested animation group.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性动画和动画组都继承自`QAbstractAnimator`类，这意味着你还可以将一个动画组添加到另一个动画组中，以形成一个更复杂、嵌套的动画组。
- en: Creating a nested animation group
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建嵌套动画组
- en: One good example of using a **nested animation group** is when you have several
    **parallel** animation groups and you want to play the groups in sequential order.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**嵌套动画组**的一个好例子是当你有几个**并行**动画组，并且你想按顺序播放这些组时。
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s follow these steps to create a **nested animation group** to play different
    animation groups in a sequential order:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建一个**嵌套动画组**，以顺序播放不同的动画组：
- en: 'We will use the UI from the previous example and add a few more buttons to
    the main window, like so:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用前一个示例中的UI，并在主窗口中添加更多按钮，如下所示：
- en: '![Figure 3.4 – We need even more buttons this time around](img/B20976_03_004.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 这次我们需要更多的按钮](img/B20976_03_004.jpg)'
- en: Figure 3.4 – We need even more buttons this time around
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 这次我们需要更多的按钮
- en: 'Create all of the animations for the buttons and then create an easing curve
    and apply it to all of the animations:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮创建所有动画，然后创建一个缓动曲线并将其应用于所有动画：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, apply the following code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，应用以下代码：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, apply the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，应用以下代码：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create two **animation groups**, one for the buttons in the upper column and
    another one for the lower column:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个**动画组**，一个用于上列的按钮，另一个用于下列：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will create yet another **animation group**, which will be used to store
    the two animation groups we created previously:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建另一个**动画组**，它将用于存储我们之前创建的两个动画组：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A Nested animation group allows you to set up a more complex widget animation
    by combining different types of animations and executing them at your desired
    orders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套动画组允许你通过组合不同类型的动画并按你希望的顺序执行它们来设置更复杂的窗口小部件动画。
- en: How it works…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What we are trying to do here is play the animation of the buttons in the upper
    column first, followed by the buttons in the lower column. Since both of the animation
    groups are `start()` function is called.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里试图做的是首先播放上列按钮的动画，然后是下列按钮。由于两个动画组都是`start()`函数被调用。
- en: This time, however, the group is a **sequential animation group**, which means
    only a single parallel animation group will be played at a time, followed by the
    other when the first one is finished. Animation groups are a very handy system
    that allows us to create very complex GUI animations with simple coding. Qt will
    handle the difficult part for us so that we don’t have to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，然而，这个组是一个**顺序动画组**，这意味着一次只能播放一个并行动画组，当第一个完成时再播放其他。动画组是一个非常方便的系统，它允许我们通过简单的编码创建非常复杂的GUI动画。Qt会为我们处理困难的部分，所以我们不需要。
- en: State machines in Qt 6
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt 6中的状态机
- en: A **state machine** can be used for many purposes but, in this chapter, we will
    only cover topics related to animation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机**可以用于许多目的，但在这个章节中，我们只会涵盖与动画相关的主题。'
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'A **State machine** is not that hard to achieve in Qt at all. Let’s get started
    by following these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中实现**状态机**并不困难。让我们按照以下步骤开始：
- en: 'We will set up a new user interface for our example program, which looks like
    this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们的示例程序设置一个新的用户界面，看起来像这样：
- en: '![Figure 3.5 – Setting up the GUI for our state machine experiment](img/B20976_03_005.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 为我们的状态机实验设置GUI](img/B20976_03_005.jpg)'
- en: Figure 3.5 – Setting up the GUI for our state machine experiment
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 为我们的状态机实验设置GUI
- en: 'We will include some headers in our source code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的源代码中包含一些头文件：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our main window’s constructor, add the following code to create a *new state
    machine* and two *states*, which we will be using later:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主窗口构造函数中，添加以下代码以创建一个新的**状态机**和两个**状态**，我们将在以后使用：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will define what we should do within each state, which, in this case, will
    be to change the label’s *text* and the button’s *position* and *size*:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义在每种状态下我们应该做什么，在这种情况下，这将是通过更改标签的**文本**和按钮的**位置**和**大小**：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you are done with that, let’s proceed by adding `event transition` classes
    to our source code:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，让我们继续通过向源代码中添加`事件转换`类来操作：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add all of the states we have just created to the state machine and define
    state 1 as the `machine->start()` to run the state machine:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚创建的所有状态添加到状态机中，并将状态1定义为`machine->start()`以运行状态机：
- en: '[PRE22]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you run the example program now, you will notice that everything works fine,
    except the button is not going through a smooth transition and it simply jumps
    instantly to the position and size we set previously. This is because we have
    not used a **property animation** to create a smooth transition.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行示例程序，您会注意到一切正常，除了按钮没有经过平滑的转换，它只是瞬间跳到了我们之前设置的位子和大小。这是因为我们没有使用**属性动画**来创建平滑的转换。
- en: 'Go back to the event transition step and add the following lines of code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回事件转换步骤并添加以下代码行：
- en: '[PRE23]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also add an easing curve to the animation to make it look more interesting:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以向动画添加一个缓动曲线，使其看起来更有趣：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are two push buttons and a label on the main window layout. The button
    in the top-left corner will trigger the state change when pressed, while the label
    in the top-right corner will change its text to show which state we are currently
    in. the button below will animate according to the current state. The `QEventTransition`
    classes define what will trigger the transition between one state and another.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口布局中有两个按钮和一个标签。左上角的按钮在被按下时会触发状态转换，而右上角的标签会更改其文本以显示我们当前处于哪个状态。下面的按钮将根据当前状态进行动画处理。《QEventTransition》类定义了从一个状态到另一个状态的转换将触发什么。
- en: In our case, we want the state to change from state 1 to state 2 when the `assignProperty()`
    function, which has automatically assigned the end value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望当`assignProperty()`函数自动分配了结束值时，状态从状态1转换为状态2。
- en: There’s more…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The **state machine framework** in Qt provides classes for creating and executing
    state graphs. Qt’s event system is used to drive the state machines, where transitions
    between states can be triggered by using *signals*, and then the *slots* on the
    other end will be invoked by the signals to perform an action, such as playing
    an animation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的**状态机框架**提供了用于创建和执行状态图的类。Qt的事件系统用于驱动状态机，状态之间的转换可以通过使用*信号*来触发，然后另一端的*槽*将被信号调用以执行动作，例如播放动画。
- en: 'Once you understand the basics of state machines, you can use them to do other
    things as well. The state graph in the state machine framework is hierarchical.
    Just like the animation group in the previous section, states can also be nested
    inside of other states:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您理解了状态机的基础知识，您也可以用它们做其他事情。状态机框架中的状态图是分层的。就像上一节中的动画组一样，状态也可以嵌套在其他状态内部：
- en: '![Figure 3.6 – Nested state machines explained visually](img/B20976_03_006.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 以视觉方式解释嵌套状态机](img/B20976_03_006.jpg)'
- en: Figure 3.6 – Nested state machines explained visually
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 以视觉方式解释嵌套状态机
- en: You can combine nested state machines and animations to create a very sophisticated
    GUI for your application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将嵌套状态机和动画结合起来，为您的应用程序创建一个非常复杂的GUI。
- en: States, transitions, and animations in QML
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的状态、转换和动画
- en: If you prefer to work with QML instead of C++, Qt also provides similar features
    in Qt Quick that allow you to easily animate a GUI element with minimal lines
    of code. In this example, we will learn how to achieve this with QML.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用QML而不是C++，Qt还提供了Qt Quick中的类似功能，允许您使用最少的代码轻松地对GUI元素进行动画处理。在本例中，我们将学习如何使用QML实现这一点。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s get started by following these steps to create a window that continuously
    changes its background color:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始创建一个不断改变其背景颜色的窗口：
- en: 'We will create a new **Qt Quick Application** project and set up our user interface,
    like so:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的**Qt Quick应用程序**项目并设置我们的用户界面，如下所示：
- en: '![Figure 3.7 – A joyful application that constantly changes its background
    color](img/B20976_03_007.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 一个不断改变其背景颜色的快乐应用程序](img/B20976_03_007.jpg)'
- en: Figure 3.7 – A joyful application that constantly changes its background color
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 一个不断改变其背景颜色的快乐应用程序
- en: 'Here is what my `main.qml` file looks like:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我的`main.qml`文件看起来像：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the *color animation* to the `Rectangle` object:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Rectangle`对象添加*颜色动画*：
- en: '[PRE26]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a *number animation* to the `text` object:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`text`对象添加一个*数字动画*：
- en: '[PRE27]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add another *number animation* to it:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加另一个*数字动画*：
- en: '[PRE28]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define two *states*, one called the `PRESSED` state and another called the
    `RELEASED` state. Then, set the default state to `RELEASED`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个*状态*，一个称为`PRESSED`状态，另一个称为`RELEASED`状态。然后，将默认状态设置为`RELEASED`：
- en: '[PRE29]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, create a mouse area within the `Rectangle` object so that we can
    click on it:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在`Rectangle`对象内部创建一个鼠标区域，以便我们可以点击它：
- en: '[PRE30]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add some transitions to the `Rectangle` object:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Rectangle`对象添加一些过渡效果：
- en: '[PRE31]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The main window consists of a blue rectangle and static text that says `Rectangle`
    object, then creating three different *color animations* within the group, which
    will change the color of the object every 1,000 milliseconds (1 second). We also
    set the animations to loop infinitely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口由一个蓝色矩形和显示`Rectangle`对象的静态文本组成，然后在组内创建三个不同的*颜色动画*，每1000毫秒（1秒）改变一次对象的颜色。我们还设置了动画为无限循环。
- en: In *step 4*, we want to use the *number animation* to animate the alpha value
    of the static text. We created another *sequential animation group* within the
    `Text` object and created two *number animations* to animate the alpha value from
    `0` to `1` and back. Then, we set the animations to loop infinitely.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们想要使用*数字动画*来动画化静态文本的alpha值。我们在`Text`对象内部创建了一个另一个*顺序动画组*，并创建了两个*数字动画*来动画化alpha值从`0`到`1`再返回。然后，我们将动画设置为无限循环。
- en: Then, in *step 5*, we rotate the `Hello World` text by adding another `Rectangle`
    object change from one color to another when we clicked on it. When the mouse
    is released, the `Rectangle` object will change back to its initial color. To
    achieve that, we first need to define the two states, one called the `PRESSED`
    state and another called the `RELEASED` state. Then, we set the default state
    to `RELEASED`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤5*中，我们通过添加另一个`Rectangle`对象来旋转`Hello World`文本，当点击时从一种颜色变为另一种颜色。当鼠标释放时，`Rectangle`对象将变回其初始颜色。为了实现这一点，我们首先需要定义两个状态，一个称为`PRESSED`状态，另一个称为`RELEASED`状态。然后，我们将默认状态设置为`RELEASED`。
- en: Now, when you compile and run the example, the background will instantly change
    color to blue when pressed and change back to red when the mouse is released.
    That works great, and we can further enhance it by giving it a little transition
    when switching color. This can be easily achieved by adding transitions to the
    `Rectangle` object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你编译并运行示例时，按下时背景会立即变为蓝色，当鼠标释放时变回红色。这效果很好，我们可以通过在切换颜色时添加一些过渡效果来进一步增强它。这可以通过向`Rectangle`对象添加过渡来实现。
- en: There’s more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'In QML, there are eight different types of property animation you can use,
    and these are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中，你可以使用八种不同的属性动画类型，具体如下：
- en: '**Anchor animation**: Animates changes in anchor values'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锚点动画**：动画化锚点值的变化'
- en: '**Color animation**: Animates changes in color values'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色动画**：动画化颜色值的变化'
- en: '**Number animation**: Animates changes in qreal-type values'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字动画**：动画化qreal类型值的变化'
- en: '**Parent animation**: Animates changes in parent values'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父级动画**：动画化父级值的变化'
- en: '**Path animation**: Animates an item along a path'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径动画**：动画化一个项目沿着路径'
- en: '**Property animation**: Animates changes in property values'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性动画**：动画化属性值的变化'
- en: '**Rotation animation**: Animates changes in rotation values'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转动画**：动画化旋转值的变化'
- en: '**Vector3d animation**: Animates changes in QVector3D values'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三维向量动画**：动画化QVector3D值的变化'
- en: Just like the C++ version, these animations can also be grouped together in
    an animation group to play the animations in sequence or parallel. You can also
    control the animations using easing curves and determine when to play these animations
    using state machines, just like we did in the previous section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像C++版本一样，这些动画也可以在动画组中分组在一起，以顺序或并行播放动画。你还可以使用缓动曲线来控制动画，并使用状态机来确定何时播放这些动画，就像我们在前面的部分中所做的那样。
- en: Animating widget properties using animators
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画器动画化小部件属性
- en: In this recipe, we will learn how to animate the properties of our GUI widgets
    using the animator feature that’s provided by QML.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用QML提供的动画器功能来动画化我们的GUI小部件的属性。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Animating QML objects is really easy if you perform the following steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行以下步骤，动画化QML对象将变得非常简单：
- en: 'Create a `Rectangle` object and add a *scale animator* to it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Rectangle`对象并将其添加一个*缩放动画器*：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a *rotation animator* and set the `running` value in the parallel animation
    group, but not in any of the individual animators:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个*旋转动画器*并设置并行动画组中的`running`值，但不在任何单个动画器中：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add an *easing curve* to the *scale animator*:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**缩放动画师**添加一个*缓动曲线*：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The *animator* type can be used just like any other *animation* type. We want
    to scale a rectangle from a size of `5` to a size of `1` within 2,000 milliseconds
    (2 seconds). We created a blue `Rectangle` object and added a *scale animator*
    to it. We set the `initial` value to `5` and the `final` value to `1`. Then, we
    set the animation `duration` to `2000` and set the `running` value to `true` so
    that it will be played when the program starts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画师*类型可以像任何其他*动画*类型一样使用。我们想要在2,000毫秒（2秒）内将一个矩形的尺寸从`5`缩放到`1`。我们创建了一个蓝色的`Rectangle`对象，并向它添加了一个*缩放动画师*。我们将`initial`值设置为`5`，将`final`值设置为`1`。然后，我们将动画的`duration`设置为`2000`，并将`running`值设置为`true`，以便它在程序启动时播放。'
- en: Just like the animation types, animators can also be put into groups (that is,
    **parallel** **animation groups** or **sequential animation groups**). An animation
    group will also be treated as an animator by QtQuick and be run on the scene graph’s
    rendering thread whenever possible. In step 2, we want to group two different
    animators into a **parallel animation group** so that they run together at the
    same time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就像动画类型一样，动画师也可以被放入组中（即**并行动画组**或**顺序动画组**）。动画组也将被QtQuick视为动画师，并在尽可能的情况下在场景图的渲染线程上运行。在步骤2中，我们想要将两个不同的动画师组合成一个**并行动画组**，以便它们同时运行。
- en: We will keep the `running` value in the parallel animation group, but not in
    any of the individual animators.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在并行动画组中保留`running`值，但不会在任何单个动画师中保留。
- en: Just like the C++ version, QML also supports **easing curves**, and they can
    be easily applied to any of the animations or animator types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像C++版本一样，QML也支持**缓动曲线**，并且可以轻松地应用于任何动画或动画师类型。
- en: There’s more…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is something called an *animator* in QML, which is different from the
    usual *animation* type, even though there is some similarity between them. Unlike
    regular animation types, animator types are directly operated on Qt Quick’s **scene
    graph**, rather than the QML objects and their properties. The value of the QML
    property will not be changed while the animation is running, as it will only change
    once the animation is finished. The benefit of using the animator type is that
    it operates directly on the scene graph’s rendering thread, which means its performance
    will be slightly better than running on the **UI thread**.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中有一个叫做*动画师*的东西，它与通常的*动画*类型不同，尽管它们之间有一些相似之处。与常规动画类型不同，动画师类型直接在Qt Quick的**场景图**上操作，而不是在QML对象及其属性上。在动画运行期间，QML属性的值不会改变，因为它只会在动画完成后改变。使用动画师类型的优点是它直接在场景图的渲染线程上操作，这意味着它的性能将略好于在**UI线程**上运行。
- en: Sprite animation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵动画
- en: In this example, we will learn how to create a **sprite animation** in QML.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何在QML中创建一个**精灵动画**。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s make a horse run across our application window by following these steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤让一匹马在我们的应用程序窗口中奔跑：
- en: We will need to add our sprite sheet to Qt’s *resource system* so that it can
    be used in the program. Open up `qml.qrc` and click the **Add** | **Add Files**
    buttons. Select your sprite sheet image and save the resource file by pressing
    *Ctrl* + *S*.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将我们的精灵图集添加到Qt的*资源系统*中，以便它可以在程序中使用。打开`qml.qrc`并点击**添加** | **添加文件**按钮。选择你的精灵图集图像，然后按*Ctrl*
    + *S*保存资源文件。
- en: 'Create a new empty window in `main.qml`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.qml`中创建一个新的空窗口：
- en: '[PRE35]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you are done with that, we will start creating an `AnimatedSprite` object
    in QML:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成之后，我们将在QML中开始创建一个`AnimatedSprite`对象：
- en: '[PRE36]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, set the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置以下内容：
- en: '[PRE37]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add a *mouse area* to the window and check for the `onClicked` event:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向窗口添加一个*鼠标区域*并检查`onClicked`事件：
- en: '[PRE38]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you compile and run the example program now, you will see a little pony
    running in the middle of the window. How fun:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行示例程序，你将看到一个小马在窗口中间奔跑。多么有趣：
- en: '![Figure 3.8 – A horse running across the application window](img/B20976_03_008.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 一匹马在应用程序窗口中奔跑](img/B20976_03_008.jpg)'
- en: Figure 3.8 – A horse running across the application window
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 一匹马在应用程序窗口中奔跑
- en: 'Next, we want to try and do something cool. We will make the horse run across
    the window and loop infinitely while playing its running animation! First, we
    need to remove `anchors.centerIn: parent` from QML and replace it with `x` and
    `y` values:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，我们想要尝试做一些酷的事情。我们将让马在窗口中奔跑，并无限循环播放其奔跑动画！首先，我们需要从QML中移除`anchors.centerIn:
    parent`并将其替换为`x`和`y`值：'
- en: '[PRE39]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a *number animation* to the sprite object and set its properties, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向精灵对象添加一个*数字动画*并设置其属性，如下所示：
- en: '[PRE40]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you compile and run the example program now, you will see the pony go crazy
    and start running across the window!
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行示例程序，你会看到小马变得疯狂，开始在窗口上奔跑！
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we place the animated sprite object in the middle of the window
    and set its image source to the sprite sheet that we have just added to the project
    resource. Then, we count how many frames there are in the sprite sheet that belong
    to the running animation, which in this case is 11 frames. We also inform Qt of
    the dimensions of each frame of the animation, which in this case are `128 x 128`.
    After that, we set the frame rate to `25` to get a decent speed and then set it
    to loop infinitely. We then set the `running` value to `true` so that the animation
    will play by default when the program starts running.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将动画精灵对象放置在窗口中间，并将其图像源设置为刚刚添加到项目资源中的精灵图集。然后，我们计算精灵图集中属于奔跑动画的帧数，在这个例子中是11帧。我们还通知Qt动画每一帧的尺寸，在这个例子中是`128
    x 128`。之后，我们将帧率设置为`25`以获得合理的速度，然后将其设置为无限循环。然后，我们将`running`值设置为`true`，以便程序启动时默认播放动画。
- en: Then, in *step 4*, we want to be able to pause the animation and resume it by
    clicking on the window. We simply check whether the sprite is currently paused
    when clicking on the mouse area. If the sprite animation is paused, then the animation
    resumes; otherwise, the animation is paused.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤4*中，我们希望能够通过点击窗口来暂停动画并恢复播放。我们简单地检查在鼠标区域点击时精灵是否处于暂停状态。如果精灵动画被暂停，则动画恢复；否则，动画被暂停。
- en: In *step 6*, we replace `anchors.centerIn` with `x` and `y` values so that the
    animated sprite object is not anchored to the center of the window, which would
    make it impossible to move around. Then, we create a *number animation* within
    the animated sprite to animate its `x` property. We set the `start` value to somewhere
    outside the window on the left side, and we set the `end` value to somewhere outside
    the window on the right side. After that, we set the `duration` to 3,000 milliseconds
    (3 seconds) and make it loop infinitely.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们将`anchors.centerIn`替换为`x`和`y`值，这样动画精灵对象就不会锚定在窗口的中心，这将使其无法移动。然后，我们在动画精灵内部创建一个*数字动画*来动画化其`x`属性。我们将`start`值设置为窗口左侧的外部某个位置，并将`end`值设置为窗口右侧的外部某个位置。之后，我们将`duration`设置为3,000毫秒（3秒）并使其无限循环。
- en: Lastly, we also set the `running` value to `true` so that it plays the animation
    by default when the program starts running.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们也将`running`值设置为`true`，以便程序启动时默认播放动画。
- en: There’s more…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sprite animation is used extensively, especially in game development. Sprites
    are used for character animation, particle animation, and even GUI animation.
    A sprite sheet consists of many images combined into one, which can then be chopped
    down and displayed on the screen, one at a time. The transitions between different
    images (or sprites) from the sprite sheet creates the illusion of animation, which
    we usually refer to as a sprite animation. A Sprite animation can be easily achieved
    in QML using the `AnimatedSprite` type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵动画被广泛使用，尤其是在游戏开发中。精灵用于角色动画、粒子动画，甚至GUI动画。精灵图集由许多图像组合成一张，然后可以切割并逐个显示在屏幕上。从精灵图集中不同图像（或精灵）之间的转换产生了动画的错觉，我们通常称之为精灵动画。在QML中使用`AnimatedSprite`类型可以轻松实现精灵动画。
- en: Note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this example program, I am using a free and open source image that was created
    by **bluecarrot16** under the *CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0* license.
    The image can be obtained legally at [http://opengameart.org/content/lpc-horse](http://opengameart.org/content/lpc-horse).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例程序中，我使用了一个由**bluecarrot16**创建的免费开源图像，该图像遵循*CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY
    3.0*许可协议。该图像可以在[http://opengameart.org/content/lpc-horse](http://opengameart.org/content/lpc-horse)合法获取。
