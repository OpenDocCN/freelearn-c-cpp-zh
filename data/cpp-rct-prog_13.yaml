- en: Advanced Streams and Handling Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级数据流和错误处理
- en: In this book, we have covered quite a bit of ground in explaining modern C++
    techniques and the `RxCpp` library. We started with a set of prerequisites for
    undertaking reactive programming using C++. The first six chapters were mostly
    about prerequisites and getting acclimatized with the features that are embodied
    in functional reactive programming in general, and in the `RxCpp` library in particular.
    We have used the term functional reactive programming in a loose sense—we are
    leveraging functional programming techniques to write reactive programs. Some
    purists differ from us on this. They do not consider the Rx family of libraries
    to be a complete implementation of functional reactive programming. The biggest
    shift a programmer has to undergo is the mindset change to adopt a declarative
    programming paradigm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经涵盖了现代C++技术和`RxCpp`库的许多内容。我们从使用C++进行反应式编程的先决条件开始。前六章主要是关于先决条件和适应一般函数式反应式编程特征以及`RxCpp`库的特性。我们在宽泛的意义上使用了函数式反应式编程这个术语——我们正在利用函数式编程技术来编写反应式程序。一些纯粹主义者与我们意见不同。他们不认为Rx系列库是函数式反应式编程的完整实现。程序员必须经历的最大转变是接受声明式编程范式的心态转变。
- en: Traditionally, we design elaborate data structures, and write algorithms upon
    those data structures, to write our programs. This is appropriate for programs
    that manipulate data that exists in space. When time comes into the picture, asynchrony
    is a natural consequence. In reactive programming, we reduce complicated data
    structures into Streams of data and place Operators in the Streams, before getting
    notified to perform some action, based on the notification. We have seen how this
    can simplify programming in the case of GUI programs, web programs, and console
    applications, using the C++ programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，我们设计复杂的数据结构，并在这些数据结构上编写算法来编写我们的程序。这适用于操作存在于空间中的数据的程序。当时间成为一个因素时，异步性是一个自然的结果。在反应式编程中，我们将复杂的数据结构简化为数据流，并在数据流中放置操作符，然后根据通知执行某些操作。我们已经看到了这如何简化了使用C++编程语言的GUI程序、Web程序和控制台应用程序的编程。
- en: In our examples, we have omitted exception handling (and error handling) logic
    in reactive programs. This was on purpose, so as to focus on the core reactive
    elements and their interactions. Now that we have covered all of the essentials,
    and beyond, we will focus on exception handling in a reactive program. Before
    getting into error and exception handling, we will cover the characteristics of
    reactive systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们故意省略了反应式程序中的异常处理（和错误处理）逻辑。这是为了专注于核心反应式元素及其交互。现在我们已经涵盖了所有必要的内容，甚至更多，我们将专注于反应式程序中的异常处理。在讨论错误和异常处理之前，我们将介绍反应式系统的特征。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A short recap of the characteristics of a reactive system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式系统特征的简要回顾
- en: '`RxCpp`—error handling Operators'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RxCpp`—错误处理操作符'
- en: Scheduling and error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度和错误处理
- en: Event-based Stream handling—some examples
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的数据流处理—一些例子
- en: A short recap of the characteristics of a reactive system
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式系统特征的简要回顾
- en: 'We now live in a world that warrants increased scalability and rapid response.
    The concept of reactive programming is a need that has arisen to meet the demands
    of high availability, scalability, and quick response. As per the reactive manifesto
    ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)), reactive
    systems are:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在生活在一个需要更高可扩展性和快速响应的世界。反应式编程的概念是为了满足高可用性、可扩展性和快速响应的需求而产生的。根据反应式宣言（[https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/)），反应式系统具有以下特点：
- en: '**Responsive**: The ability (of a system) to complete assigned tasks within
    a timeframe. Responsiveness also means that the problems are detected quickly,
    and dealt with effectively. The key point is the consistent behavior of a system.
    Consistency helps the users to build confidence in the system.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：系统在规定时间内完成分配的任务的能力。响应性也意味着问题能够被快速检测并有效处理。关键点在于系统的一致行为。一致性有助于用户对系统建立信心。'
- en: '**Resilient**: In the context of changes in behavior, the ability of a system
    to defend itself from failure is resilience. It is correlated to the responsiveness,
    as the consistency guarantees error handling as well. Resilience is achieved by
    the isolation and containment of components subject to error situation and protecting
    the system from failures.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：在行为变化的情况下，系统抵御失败的能力就是弹性。它与响应性相关，因为一致性也保证了错误处理。弹性是通过隔离和容错组件来实现的，以保护系统免受故障影响。'
- en: '**Elastic**: Elasticity is the ability of a system to adapt to workload changes
    by reallocating the resources required in an automated manner. In turn, at each
    instance of time, the resources in use match the demand as closely as possible.
    reactive systems achieve elasticity by providing relevant live performance measures.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：弹性是系统根据工作负载的变化自动重新分配所需资源的能力。反过来，每个时间点上使用的资源尽可能地匹配需求。反应式系统通过提供相关的实时性能指标来实现弹性。'
- en: '**Message-driven**: Reactive systems achieve isolation and the loose coupling
    of systems through the ability to communicate through the asynchronous message-passing
    mechanism. With the use of a message queue, the interdependent processing of different
    modules and commands is made possible in reactive systems. Non-blocking communication
    through message-driven architecture allows the recipients to consume resources
    only when active:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：通过异步消息传递机制，反应式系统实现了系统的隔离和松耦合。通过使用消息队列，反应式系统可以实现不同模块和命令的相互依赖处理。通过消息驱动架构的非阻塞通信，接收者只在活动时消耗资源：'
- en: 'The following diagram from the Reactive Manifesto demonstrates how all the
    pillars of a reactive system are inter-related:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 来自响应式宣言的以下图表展示了响应式系统的所有支柱是如何相互关联的：
- en: '![](img/007efdbe-d0c0-4004-a4dc-a228e3667bc0.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/007efdbe-d0c0-4004-a4dc-a228e3667bc0.jpg)'
- en: The reactive systems are made composable by applying these principles at all
    levels of their construction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在其所有构建层次上应用这些原则，响应式系统变得可组合。
- en: The focus of this chapter will be the resilient properties of the reactive systems,
    through explaining advanced Streams and error handling.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是通过解释高级流和错误处理来解释响应式系统的弹性特性。
- en: RxCpp error and exception handling Operators
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxCpp错误和异常处理操作符
- en: In a real-world scenario, no system is perfect. As we discussed in the previous
    section, resilience is one of the qualities of a reactive system. How a system
    handles errors and exceptions decides the future of that system. Early detection
    and the seamless handling of errors makes a system consistent and responsive.
    Compared to imperative programming approaches, the reactive programming model
    helps the user to handle errors separately, as and when the system detects an
    error or throws an exception.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，没有一个系统是完美的。正如我们在前一节中讨论的那样，弹性是响应式系统的特质之一。系统如何处理错误和异常决定了该系统的未来。早期检测和无缝处理错误使系统一致和响应。与命令式编程方法相比，响应式编程模型帮助用户单独处理错误，当系统检测到错误或抛出异常时。
- en: 'In this section, we will take a look at how to handle exceptions and errors
    by using the `RxCpp` library. There are a variety of `RxCpp` Operators that can
    be used to react to `on_error` notifications from Observables. For instance, we
    might:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何使用`RxCpp`库处理异常和错误。有各种`RxCpp`操作符可用于对来自Observables的`on_error`通知做出反应。例如，我们可能会：
- en: Handle the error by exiting from the sequence gracefully
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过优雅地退出序列来处理错误
- en: Ignore the error and switch over to a backup Observable to continue the sequence
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略错误并切换到备用Observable以继续序列
- en: Ignore the error and emit a default value
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略错误并发出默认值
- en: Ignore the error and immediately try to restart the failed Observable
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略错误并立即尝试重新启动失败的Observable
- en: Ignore the error and try to restart the failed Observable, after some back-off
    interval
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略错误并在一段退避间隔后尝试重新启动失败的Observable
- en: 'The exception handling is possible because the `observer<>` contains three
    methods:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是可能的，因为`observer<>`包含三种方法：
- en: '`on_next`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_next`'
- en: '`on_completed`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_completed`'
- en: '`on_error`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_error`'
- en: 'The `on_error` method is meant to handle exceptions when they occur, or when
    they are thrown by `observable<>` or any Operators in the composition chain. The
    examples so far have ignored the error handling aspects of the system. The prototypes
    for the observer methods are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_error`方法用于处理异常发生时，或者由`observable<>`或组合链中的任何操作符抛出异常。到目前为止，示例忽略了系统的错误处理方面。观察者方法的原型如下：'
- en: '`void observer::on_next(T);`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void observer::on_next(T);`'
- en: '`void observer::on_error(std::exception_ptr);`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void observer::on_error(std::exception_ptr);`'
- en: '`void observer::on_completed();`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void observer::on_completed();`'
- en: Executing an action on an error
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在发生错误时执行操作
- en: 'When an error occurs, we need to handle it in a graceful manner. So far, in
    the `RxCpp` programs discussed in this book, the programs were written to only
    handle the `on_next` and `on_completed` scenarios in the `subscribe` method. The
    `subscribe` function has one more method, where it can accept a Lambda function
    for `on_error` scenarios as well. Let''s look at a simple example to understand
    how to use the error handler inside the `subscribe` function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，我们需要以一种优雅的方式处理它。到目前为止，在本书讨论的`RxCpp`程序中，程序只处理了`subscribe`方法中的`on_next`和`on_completed`情况。`subscribe`函数还有一个方法，它也可以接受一个Lambda函数来处理`on_error`情况。让我们看一个简单的例子来理解如何在`subscribe`函数中使用错误处理程序：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the second Lambda, the function passed into the `subscribe` function invokes
    the action that is needed when there is an error. The output of the code will
    look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第二个Lambda，传递给`subscribe`函数的函数调用在发生错误时调用所需的操作。代码的输出将如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous code, the error is appended to the Observable Stream to kick-start
    the discussion on exception/error handling at the subscriber end. Let''s see how
    an exception can be propagated to the subscriber level, through the Observable
    Streams:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，错误被附加到Observable流中，以启动订阅者端的异常/错误处理讨论。让我们看看异常如何通过Observable流传播到订阅者级别：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous code creates an instance of a `subject<T>` class, which we covered
    in chapter-10, Creating Custom Operators in RxCpp. We subscribe to the Observable
    part of the `subject<T>`. We also retrieve the subscriber handle to emit the value
    or exception into the Stream:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了一个`subject<T>`类的实例，我们在第10章《在RxCpp中创建自定义操作符》中介绍过。我们订阅`subject<T>`的Observable部分。我们还检索订阅者句柄以将值或异常发射到流中：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `on_next()` function emits a new value to the subscriber, and the function
    will be called multiple times. The `on_next()` function won't be called once `on_completed()`
    or `on_error()` is being invoked on the Stream. The `on_completed()` function
    notifies the subscriber that the Observable has finished sending **push-based
    notifications**. The Observable will not call this function if it has already
    invoked the `on_error()` function. Finally, the `on_error()` function notifies
    the subscriber that the Observable has experienced an error condition, and if
    the Observable calls this function, it will not call `on_next()` or `on_completed()`
    thereafter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_next()`函数向订阅者发出新值，并且该函数将被多次调用。一旦在流上调用了`on_completed()`或`on_error()`，`on_next()`函数将不会被调用。`on_completed()`函数通知订阅者Observable已经完成发送**推送式通知**。如果Observable已经调用了`on_error()`函数，它将不会调用此函数。最后，`on_error()`函数通知订阅者Observable遇到了错误条件，如果Observable调用了此函数，它将不会在此后调用`on_next()`或`on_completed()`。'
- en: Resuming when an error occurs
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当发生错误时恢复
- en: 'An error occurrence breaks the sequence flow of a standard reactive Stream.
    The `RxCpp` library provides mechanisms to invoke actions on an error occurrence,
    also. Sometimes, however, users want to resume the sequence with a default option;
    that''s what `on_error_resume_next()` does:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生会打破标准响应式流的序列流程。`RxCpp`库还提供了在发生错误时调用操作的机制。然而，有时用户希望使用默认选项恢复序列；这就是`on_error_resume_next()`的作用：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Observable Operator `on_error_resume_next()` gets executed if there is
    an error in the Stream. In this code, a new Stream is returned from the Lambda
    given as a parameter, to resume the sequence with this new Stream. This way, the
    error propagation can be prevented, by continuing with a meaningful sequence.
    The output of the previous program will look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果流中出现错误，可观察操作符`on_error_resume_next()`将被执行。在这段代码中，从作为参数给定的Lambda返回一个新的流，以使用这个新的流恢复序列。这样，可以通过继续有意义的序列来防止错误传播。上一个程序的输出将如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As well as resuming with another sequence, the sequence can be resumed with
    a default single item. In the previous example, replace the invocation of the
    Operator `on_error_resume_next()` with the following lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用另一个序列进行恢复，还可以使用默认的单个项目进行恢复。在前面的例子中，用以下行替换对`on_error_resume_next()`操作符的调用：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output, after replacing the code, will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 替换代码后，输出将如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s look at the marble diagram that depicts the `on_error_resume_next()`
    Operator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下描述`on_error_resume_next()`操作符的弹珠图：
- en: '![](img/7123ec6c-c8c7-49c9-84f3-7f38fc0d0c9e.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7123ec6c-c8c7-49c9-84f3-7f38fc0d0c9e.jpg)'
- en: In short, the `on_error_resume_next()` function returns an Observable instance
    when it encounters an error from a particular Observable. The Stream switches
    to the new Observable and resumes the execution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`on_error_resume_next()`函数在遇到特定可观察对象的错误时返回一个可观察实例。流切换到新的可观察对象并恢复执行。
- en: 'The `on_error_resume_next()` Operator comes in handy in many places, where
    the user needs to continue the propagation of an error. For instance, between
    the creation and subscription of the Streams, there is a chance that the Streams
    may undergo different transformations and reductions. Also, as explained in [Chapter
    9](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml), *Reactive GUI Programming Using
    Qt/C++*, the user-defined Operators can be constructed by composing existing `RxCpp`
    Operators. In such cases, it is intended to use the `on_error_resume_next()` Operator
    at every single stage of aggregation and transformations to translate the exceptions/errors
    till the subscription phase. Similar to the default value or a sequence emitted
    from this Operator, the error itself can be retransmitted, to resume the flow
    of the error until the `subscribe()` Operator''s error handler:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_error_resume_next()`操作符在许多地方非常方便，用户需要继续传播错误。例如，在流的创建和订阅之间，流可能会经历不同的转换和减少。此外，正如[第9章](b59c2b7c-703d-4c1d-8c31-db01506c57db.xhtml)中所解释的那样，*使用Qt/C++进行响应式GUI编程*，用户定义的操作符可以通过组合现有的`RxCpp`操作符来构建。在这种情况下，打算在每个聚合和转换阶段使用`on_error_resume_next()`操作符来转换异常/错误直到订阅阶段。与此操作符发出的默认值或序列类似，错误本身也可以被重新传输，以恢复错误的流动直到`subscribe()`操作符的错误处理程序：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous fragment of code explains how the `on_error_resume_next()` Operator
    can be used to translate the error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段解释了如何使用`on_error_resume_next()`操作符来转换错误。
- en: Retry when an error occurs
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生错误时重试
- en: In many situations, the normal sequence may be broken by a temporary failure
    on the producer end. In such scenarios, it is worthwhile to have an option to
    wait until the anomalies are fixed at the producer end, to continue the normal
    execution flow. `RxCpp` gives the users a very similar option to retry when an
    error occurs. The retry option is best suited to when you are expecting the sequence
    to encounter predictable issues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，正常的顺序可能会因为生产者端的暂时故障而被打破。在这种情况下，值得考虑的是有一个选项，可以等待直到生产者端的异常被修复，以继续正常的执行流程。`RxCpp`为用户提供了一个非常类似的选项，当发生错误时重试。重试选项最适合当您预期序列会遇到可预测的问题时。
- en: 'The retry Operator responds to an `on_error` notification from the source Observable
    by resubscribing to the source Observable, instead of passing that call through
    to its Observers. This gives the source another opportunity to complete its sequence
    without an error. The retry always passes `on_next` notifications through to its
    Observers, even from sequences that terminate with an error; this can cause duplicate
    emissions. The following marble diagram will explain this further:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重试操作符对来自源Observable的`on_error`通知做出响应，通过重新订阅源Observable，而不是将该调用传递给其观察者。这给了源另一个机会来完成其序列而不出现错误。重试总是将`on_next`通知传递给其观察者，即使是从以错误终止的序列中；这可能会导致重复的发射。下面的弹珠图将进一步解释这一点：
- en: '![](img/fd2af045-7ce4-4ec5-b231-048b028fc152.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd2af045-7ce4-4ec5-b231-048b028fc152.jpg)'
- en: 'Here is an example that uses the `retry()` Operator:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`retry()`操作符的示例：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, as the error is appended to the Stream using the `concat()`
    Operator, we are using the `take()` Operator to avoid the infinite wait. Because
    of the infinite wait on the retry Operator in error scenarios, the subscriber
    can omit error handler used in the subscription.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于错误被添加到流中使用`concat()`操作符，我们使用`take()`操作符来避免无限等待。由于在错误情况下重试操作符的无限等待，订阅者可以省略订阅中使用的错误处理程序。
- en: 'The output of this code will be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出将是：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Most of the time, it is better to use a fixed number of retries for error situations.
    This can be achieved by another overload of `retry()`, which accepts the number
    of retries:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，最好对错误情况使用固定数量的重试。这可以通过`retry()`的另一个重载来实现，该重载接受重试次数：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output for the code will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出将如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Cleanup with the finally() Operator
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用finally()操作符进行清理
- en: 'So far, in this chapter, we have seen that the source sequence in `RxCpp` can
    terminate gracefully after throwing exceptions. The `finally()` Operator is useful
    when we are using external resources, or when there''s a need to free up some
    resources allocated in some other parts of the program. As we know, there are
    millions of lines of code that are already written for building various systems
    in C++, and it is highly likely that we need to handle resource management when
    using legacy external dependencies. This is a place where `finally()` comes in
    handy in `RxCpp`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到`RxCpp`中的源序列可以在抛出异常后正常终止。当我们使用外部资源时，或者在程序的其他部分分配了一些资源需要释放时，`finally()`
    Operator是非常有用的。正如我们所知，在C++中已经编写了数百万行代码来构建各种系统，很可能我们需要在使用传统外部依赖时处理资源管理。这就是`RxCpp`中`finally()`派上用场的地方：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `finally()` Operator adds a new action at the end of the newly created
    Observables. The output of the previous program is as shown:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally()` Operator在新创建的Observables的末尾添加了一个新的动作。前一个程序的输出如下所示：'
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It can be seen, in the previous output, that if the source generates an error,
    the final action is still called.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，在先前的输出中，如果源生成错误，最终动作仍然会被调用。
- en: 'If we remove the error concatenated to the source Observable, the output of
    the program will look as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从源Observable中移除连接的错误，程序的输出将如下所示：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Schedulers and error handling
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序和错误处理
- en: 'We already covered the topic of scheduling in Chapter 8, *RxCpp – the Key Elements*.
    The schedulers in `RxCpp` queue up the values and deliver the queued up value using
    the supplied coordination. The coordination could be the current execution thread,
    the `RxCpp` run loop, the `RxCpp` event loop, or a new thread. The execution of
    scheduler operations can be achieved by using the `RxCpp` Operators, such as `observe_on()`
    or `subscribe_on()`. These Operators accept the chosen coordination as an argument.
    By default, the `RxCpp` library is single-threaded, so it does the scheduler operations.
    The user has to explicitly choose the thread in which execution happens:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在第8章“RxCpp - 关键元素”中涵盖了调度的主题。`RxCpp`中的调度程序排队并传递排队的值，使用提供的协调。协调可以是当前执行线程、`RxCpp`运行循环、`RxCpp`事件循环或一个新线程。通过使用`RxCpp`的Operators，如`observe_on()`或`subscribe_on()`，可以实现调度程序操作。这些Operators接受所选择的协调作为参数。默认情况下，`RxCpp`库是单线程的，因此它执行调度程序操作。用户必须显式选择执行发生的线程：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have created an Observable Stream using the range Operator, and have concatenated
    an error, to demonstrate how basic error handling works with schedulers in `RxCpp`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用range Operator创建了一个Observable Stream，并连接了一个错误，以演示在`RxCpp`中如何使用调度程序进行基本错误处理：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using `observe_on()` Operator, the Observable stream is subscribed into a new
    thread as its coordination. Similar to the previous examples that we discussed
    in this chapter, the error handler is provided with the `subscribe()` function.
    The output of the code may look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`observe_on()` Operator，Observable Stream被订阅到一个新线程中作为其协调。与本章讨论的先前例子类似，错误处理程序是通过`subscribe()`函数提供的。代码的输出可能如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s take a look at another example, with two subscribers from the same
    source. The subscribers are supposed to be notified in two different threads:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看另一个例子，从同一源中有两个订阅者。这些订阅者应该在两个不同的线程中被通知：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A `subject` instance is created to add data to the source Stream; from the
    subject instance, one subscriber and two Observables are created, to be scheduled
    in two distinct threads:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个`subject`实例来向源Stream添加数据；从subject实例中，创建了一个订阅者和两个Observables，以在两个不同的线程中进行调度：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Two Lambda functions are declared for use with the `subscribe` method, with
    mutex synchronization applied on the usage of the `std::ostream` Operator to get
    an organized output. Placing a mutex around `std::ostream` will avoid interleaved
    output if the thread switch happens during a write to the Stream:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与`subscribe`方法一起使用，声明了两个Lambda函数，并在使用`std::ostream` Operator时应用了互斥同步，以获得有组织的输出。在`std::ostream`周围放置一个互斥锁将避免在写入Stream时发生线程切换导致的交错输出：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Two Observables are retrieved from the source Stream, and they are scheduled
    to observe from separate threads. For the `observable1` function object, a separate
    C++ thread is specified as the coordinator by passing `rxcpp::synchronize_new_thread()`
    as the argument in the `observe_on()` Operator. For the `observable2` object,
    an event loop is specified as the coordinator by passing `rxcpp::observe_on_event_loop()`
    into `observe_on()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从源Stream中检索到了两个Observables，并安排它们从不同的线程中进行观察。对于`observable1`函数对象，通过在`observe_on()`
    Operator中传递`rxcpp::synchronize_new_thread()`作为参数来指定一个单独的C++线程作为协调者。对于`observable2`对象，通过将`rxcpp::observe_on_event_loop()`传递给`observe_on()`来指定一个事件循环作为协调者：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, the values are added to the Observable Stream by using a subject instance,
    and an exception is passed into the Stream explicitly, to understand the behavior
    of the schedulers and error handlers together. The output of this code will be
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用一个subject实例将值添加到Observable Stream中，并显式地向Stream传递一个异常，以了解调度程序和错误处理程序的行为。这段代码的输出将如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This example demonstrates how the propagation of data happens through two separate
    Observables that are subscribed to a common source. The error generated in the
    source is received and handled by both of the Observables at the corresponding
    `subscribe` functions. Now, let''s look at an example that demonstrates how error
    handling can be done in scheduling by using the `subscribe_on()` Operator:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了数据是如何通过两个订阅了共同源的独立Observables进行传播的。源中生成的错误被两个Observables在相应的`subscribe`函数中接收和处理。现在，让我们看一个例子，演示了如何使用`subscribe_on()`
    Operator在调度中进行错误处理：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Two random Observable Streams on integers are created using the `rxcpp::observable<>::range()`
    Operator and one Stream is concatenated with an error, to explain error handling
    in scheduled sequences:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rxcpp::observable<>::range()`操作符创建了两个随机整数Observable Streams，并且一个流与一个错误连接，以解释在计划序列中的错误处理：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Observable Streams are queued up in different threads using the `subscribe_on()`
    Operator. The first Stream is scheduled with an event loop as its coordination
    thread, and the second Stream is scheduled on another C++ thread:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`subscribe_on()`操作符将Observable Streams排队到不同的线程中。第一个流使用事件循环作为其协调线程进行调度，第二个流在另一个C++线程上进行调度：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding Lambda functions are defined to be passed as parameters in place
    of the `on_next` and `on_error` functions of the `subscribe` method. These Lambda
    functions are protected with mutex, to synchronize the calls to the `std::ostream`
    Operator:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Lambda函数被定义为传递给`subscribe`方法的`on_next`和`on_error`函数的参数。这些Lambda函数受到互斥锁的保护，以同步对`std::ostream`操作符的调用：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the code will look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Event-based Stream handling – some examples
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于事件的流处理-一些示例
- en: Before we conclude this chapter, let's discuss a few examples, to work with
    an event-based system using the `RxCpp` library. In this section, we'll discuss
    two examples to understand how effective the `RxCpp` library can be in meeting
    real-world scenarios. We will discuss an example that demonstrates the aggregation
    of data in a Stream and application event handling, using the `RxCpp` library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们讨论一些示例，使用`RxCpp`库处理基于事件的系统。在本节中，我们将讨论两个示例，以了解`RxCpp`库在满足现实场景中的有效性。我们将讨论一个示例，演示如何使用`RxCpp`库进行流数据聚合和应用程序事件处理。
- en: Aggregation based on Stream data
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于流数据的聚合
- en: 'In this section, the Stream item is a user-defined type to represent an employee,
    and the code is intended to group the input Stream based on the roles and salaries
    of employees:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，流项是一个用户定义的类型，用于表示员工，并且代码旨在根据员工的角色和薪水对输入流进行分组：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The libraries and namespaces required in the code are included, and the data
    structure to represent an `Employee` is declared. The `Employee` type is a simple
    structure, with data items such as `name`, `role`, and `salary`. We have treated
    the salary field as an integer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中包含了所需的库和命名空间，并声明了表示`Employee`的数据结构。`Employee`类型是一个简单的结构，具有数据项，如`name`、`role`和`salary`。我们将薪水字段视为整数：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `main()` function, a subject is created with the `Employee` type, to
    create a **hot Observable**. The grouping based on the role is performed and salary attribute
    is extracted out of it to form the resultant Grouped Observable. The `RxCpp` Operator, `group_by()`,
    returns an Observable that emits `grouped_observables`, each of which corresponds
    to a unique key/value pair from the source Observable:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，使用`Employee`类型创建了一个主题，以创建一个**热Observable**。基于角色的分组被执行，并且工资属性被提取出来形成结果分组Observable。`RxCpp`操作符`group_by()`返回一个发出`grouped_observables`的Observable，每个`grouped_observables`对应于源Observable的唯一键/值对：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, the resultant Observable combines the Observable based on the role, and
    the reduction, based on the salary, is performed by appending the minimum salary,
    maximum salary, and average salary per role. The Lambda inside of the `zip()`
    will be called when all of the arguments have a value. In this case, when a particular
    group completes, all of the values inside of the Streams corresponding to the
    group are reduced to single tuples. Therefore, the Lambda is called only once
    per role, with the final value of each iteration. Here, the map applied on the
    `group` returns an Observable of the type `observable<tuple<string, int, int,
    int, double>>`, and the `merge()` Operator returns an Observable of the type `tuple<string,
    int, int, int, double>`. The merge is applied to prevent the data loss, as the
    grouped Observable is hot, and the data will be lost if it is not subscribed to
    immediately:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，结果Observable结合了基于角色的Observable，并且通过附加最低工资、最高工资和每个角色的平均工资来执行基于工资的减少。`zip()`内部的Lambda将在所有参数都有值时被调用。在这种情况下，当特定组完成时，与该组对应的流中的所有值都将被减少为单个元组。因此，Lambda仅在每个角色中调用一次，每次迭代的最终值。在这里，应用于`group`的map返回了类型为`observable<tuple<string,
    int, int, int, double>>`的Observable，而`merge()`操作符返回了类型为`tuple<string, int, int,
    int, double>`的Observable。合并是为了防止数据丢失，因为分组的Observable是热的，如果不立即订阅，数据将丢失：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The resultant Observable is then subscribed, in order to display the aggregated
    result of input data. The data items are supplied to the subscriber from the `employees`
    subject, created with the `Employees` type. In the previous code, the source can
    be anything, such as data retrieved from the network or from another thread. Since
    the Observable created here is a hot Observable, aggregation is performed based
    on the latest data supplied.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后订阅了结果Observable，以显示输入数据的聚合结果。数据项从使用`Employees`类型创建的`employees`主题中提供给订阅者。在前面的代码中，源可以是任何东西，例如从网络或另一个线程检索的数据。由于此处创建的Observable是热Observable，因此基于提供的最新数据执行聚合。
- en: 'The output of this code is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Application event handling example
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序事件处理示例
- en: 'The following example is a command-line program, with events to represent the
    primitive operations of a user interface application. We will be handling the
    flow of these events by using `RxCpp` in this program. This has been done for
    brevity in the code listing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是一个命令行程序，其中的事件表示用户界面应用程序的原始操作。我们将使用`RxCpp`来处理这些事件的流程。这是为了简洁起见在代码清单中完成的：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The libraries and namespaces that we will be using in the programs are included
    (declared) here. Also, an enum `AppEvent` is declared, to represent some of the
    basic event states that can be emitted from a generic system:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中将使用的库和命名空间在这里包含（声明）。此外，声明了一个枚举`AppEvent`，用于表示可以从通用系统发出的一些基本事件状态：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the previous code, we created an Observable Stream of the `AppEvent` type
    by mapping some of the keyboard entries to defined event types. The infinite loop
    inside the Lambda of the `create` function represents the `event_loop/message_loop`
    in GUI applications. To convert the cold Observable into a hot Observable and
    to get the connections to the source independent of following subscriptions, the
    `publish()` Operator is used. It also helps to send the most recent value in the
    Stream to new subscribers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过将一些键盘输入映射到已定义的事件类型，创建了`AppEvent`类型的Observable流。`create`函数中Lambda内部的无限循环代表GUI应用程序中的`event_loop/message_loop`。为了将冷Observable转换为热Observable，并使得与源的连接独立于后续订阅，使用了`publish()`操作符。它还有助于将流中的最新值发送给新的订阅者：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Some filtered Observables are defined, to handle the use cases of the reactive
    system. The `appActive` is an Observable contains `AppEvent::Active` event filtered
    from source Observable whenever it is available in the source stream. Similarly, `appInactive` Observable
    contains `AppEvent::Inactive ` events, `appData` Observable contains `AppEvent::Data` events,
    and `appClose` Observable extracts `AppEvent::Close` events out of the source
    Observable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一些经过筛选的Observables，以处理响应式系统的用例。`appActive`是一个Observable，其中包含从源Observable中筛选出的`AppEvent::Active`事件，每当它在源流中可用时。同样，`appInactive`
    Observable包含`AppEvent::Inactive`事件，`appData` Observable包含`AppEvent::Data`事件，而`appClose`
    Observable从源Observable中提取`AppEvent::Close`事件：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The program will start accepting the data Streams from the events Observable
    only if the `AppEvent::Active` event is received. Then, the application will accept
    the data until `AppEvent::Inactive` is received. The event flow will resume only
    when the next `AppEvent::Active` is emitted. When `AppEvent::Close` or `AppEvent::Finish`
    is emitted, the application will exit gracefully, similar to a **Close** or **Apply**
    event/message in a GUI application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在接收到`AppEvent::Active`事件时，程序才会开始接受来自事件Observable的数据流。然后，应用程序将接受数据，直到接收到`AppEvent::Inactive`。只有在发出下一个`AppEvent::Active`时，事件流才会恢复。当发出`AppEvent::Close`或`AppEvent::Finish`时，应用程序将以优雅的方式退出，类似于GUI应用程序中的**Close**或**Apply**事件/消息。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed error handling in `RxCpp`, along with some of
    the advanced constructs and Operators to handle Streams in the `RxCpp` library.
    We visited the basic principles of a reactive system, and gave more emphasis to
    one of the key pillars of a reactive system, resilience, when we discussed error
    handling mechanisms. We discussed features such as error handlers (`on_error`),
    which need to be used with subscription. Also, we discussed `RxCpp` Operators,
    such as `on_error_resume_next()`, `retry()`, and `finally()`, to discuss how to
    continue Streams when an error comes, how to wait for the producer of the Stream
    to correct the error and continue the sequence, and how to perform common operations
    that are applicable to both success and error paths. Finally, we discussed two
    sample programs, to understand more about Stream processing. These programs illustrated
    how the `RxCpp` library can be used to process a Stream of UX events (simulated
    using a console program) and aggregate data Streams.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了`RxCpp`中的错误处理，以及一些高级构造和操作符，以处理`RxCpp`库中的流。我们讨论了响应式系统的基本原则，并在讨论错误处理机制时更加强调了响应式系统的一个关键支柱，即弹性。我们讨论了错误处理程序（`on_error`）等功能，需要与订阅一起使用。此外，我们还讨论了`RxCpp`操作符，如`on_error_resume_next()`、`retry()`和`finally()`，讨论了在出现错误时如何继续流，如何等待流的生产者纠正错误并继续序列，以及如何执行适用于成功和错误路径的常见操作。最后，我们讨论了两个示例程序，以更多地了解流处理。这些程序说明了`RxCpp`库如何用于处理UX事件流（使用控制台程序模拟）和聚合数据流。
