- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Network and Managing Large Documents
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络和管理大型文档
- en: In this chapter, we will learn how to create a networking server program and
    a client program using Qt 6’s networking module. We will also learn how to create
    a program that uses **File Transfer Protocol** (**FTP**) to upload and download
    files from the server. Lastly, we will learn how to send HTTP requests to a specific
    web service using Qt 6 and C++ language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Qt 6 的网络模块创建网络服务器程序和客户端程序。我们还将学习如何创建一个使用**文件传输协议**（**FTP**）从服务器上传和下载文件的程序。最后，我们将学习如何使用
    Qt 6 和 C++ 语言向特定的网络服务发送 HTTP 请求。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Creating a TCP server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TCP 服务器
- en: Creating a TCP client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 TCP 客户端
- en: Uploading and downloading files using FTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 FTP 上传和下载文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are Qt 6.6.1, Qt Creator 12.0.2,
    and FileZilla. All the code used in this chapter can be downloaded from the following
    GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求是 Qt 6.6.1、Qt Creator 12.0.2 和 FileZilla。本章中使用的所有代码都可以从以下 GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07)。
- en: Creating a TCP server
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 TCP 服务器
- en: In this recipe, we will learn how to create a **Transmission Control Protocol**
    (**TCP**) server in Qt 6\. Before we’re able to create a server that lets us upload
    and download files, let’s scale it down a bit and learn how to create a networking
    server that receives and delivers texts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在 Qt 6 中创建一个**传输控制协议**（**TCP**）服务器。在我们能够创建一个允许我们上传和下载文件的服务器之前，让我们先缩小范围，学习如何创建一个接收和发送文本的网络服务器。
- en: How to do it…
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a TCP server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 TCP 服务器：
- en: 'First, let’s create a **Qt Console Application** project from **File** | **New
    File or Project**, as shown in the following screenshot:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从 **文件** | **新建文件或项目** 创建一个 **Qt 控制台应用程序** 项目，如下面的截图所示：
- en: '![Figure 7.1 – Creating a new Qt Console Application project](img/B20976_07_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 创建新的 Qt 控制台应用程序项目](img/B20976_07_001.jpg)'
- en: Figure 7.1 – Creating a new Qt Console Application project
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 创建新的 Qt 控制台应用程序项目
- en: 'After that, go to **File** | **New File or Project** again but this time, select
    **C++ Class** under the **C/C++** category, as shown in the following screenshot:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，再次转到 **文件** | **新建文件或项目**，但这次在 **C/C++** 类别下选择 **C++ 类**，如下面的截图所示：
- en: '![Figure 7.2 – Creating a new C++ class](img/B20976_07_002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 创建新的 C++ 类](img/B20976_07_002.jpg)'
- en: Figure 7.2 – Creating a new C++ class
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 创建新的 C++ 类
- en: 'Then, name your class `server`. Set its base class to `server.h` and `server.cpp`,
    as shown in the following screenshot:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将你的类命名为 `server`。将其基类设置为 `server.h` 和 `server.cpp`，如下面的截图所示：
- en: '![Figure 7.3 – Defining the server class](img/B20976_07_003.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 定义服务器类](img/B20976_07_003.jpg)'
- en: Figure 7.3 – Defining the server class
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 定义服务器类
- en: 'After that, open up your project file (`.pro`) and add the `network` module,
    as shown in the following code. Then, run `qmake` again to reload the modules:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开你的项目文件（`.pro`）并添加 `network` 模块，如下面的代码所示。然后，再次运行 `qmake` 以重新加载模块：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#include <QTcpServer>'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QTcpServer>`'
- en: '#include <QTcpSocket>'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QTcpSocket>`'
- en: '#include <QVector>'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QVector>`'
- en: '#include <QDebug>'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`#include <QDebug>`'
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Right after that, declare the `startServer()` and `sendMessageToClients()`
    functions, as shown in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，声明 `startServer()` 和 `sendMessageToClients()` 函数，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'public slots:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 公共槽：
- en: void newClientConnection();
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void newClientConnection();`'
- en: void socketDisconnected();
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void socketDisconnected();`'
- en: void socketReadReady();
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void socketReadReady();`'
- en: void socketStateChanged(QAbstractSocket::SocketState state);
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`void socketStateChanged(QAbstractSocket::SocketState state);`'
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, declare two private variables, as shown in the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，声明两个私有变量，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’re done with the preceding step, open up `server.cpp` and define the
    `startServer()` function. Here, we create a `QVector` container to store all the
    clients that are connected to the server and use it to send out messages in later
    steps. This is shown in the following example:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成前面的步骤后，打开 `server.cpp` 并定义 `startServer()` 函数。在这里，我们创建一个 `QVector` 容器来存储所有连接到服务器的客户端，并在后续步骤中使用它发送消息。以下是一个示例：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we implement the `sendMessageToClients()` function, where we iterate
    through the `allClients` container we just created in the previous step, and send
    the message to each client, as shown in the following example:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们实现 `sendMessageToClients()` 函数，在这个函数中，我们将遍历我们在上一步中创建的 `allClients` 容器，并将消息发送给每个客户端，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, we will start implementing the slot functions. Let’s start with
    the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将开始实现槽函数。让我们从以下代码开始：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we’ll proceed with the `socketDisconnected()` function. This slot function
    will be called when a client has been disconnected from the server, as shown in
    the following example:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理 `socketDisconnected()` 函数。当客户端从服务器断开连接时，将调用此槽函数，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we’ll define the `socketReadReady()` function, which will be triggered
    when a client sends a text message to the server, as shown in the following example:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `socketReadReady()` 函数，当客户端向服务器发送文本消息时，将触发此函数，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, let’s implement the `socketStateChanged()` function, which will
    be called when the networking state of a client has changed, as shown in the following
    example:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，让我们实现 `socketStateChanged()` 函数，当客户端的网络状态发生变化时，将调用此函数，如下面的示例所示：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to add the following code into `socketStateChanged()` to print
    out the status of the client:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在 `socketStateChanged()` 中添加以下代码以打印客户端的状态：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lastly, let’s open up `main.cpp` and add the highlighted code in the following
    example in order to initiate the server:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们打开 `main.cpp` 并在下面的示例中添加高亮显示的代码以启动服务器：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can try and run the server program now but you won’t be able to test it
    as we have not created the client program yet, as the following screenshot shows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以尝试运行服务器程序，但你无法测试它，因为我们还没有创建客户端程序，如下面的截图所示：
- en: '![Figure 7.4 – Server is now listening to port 8001](img/B20976_07_004.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 服务器现在正在监听端口 8001](img/B20976_07_004.jpg)'
- en: Figure 7.4 – Server is now listening to port 8001
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 服务器现在正在监听端口 8001
- en: Let’s proceed to the next example project and learn how to create the client
    program. We will come back to test this program again later on.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续下一个示例项目，学习如何创建客户端程序。我们稍后还会回来测试这个程序。
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are mainly two types of network connections—the TCP connection and the
    **User Datagram Protocol** (**UDP**) connection. TCP is a reliable networking
    connection, while UDP is unreliable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种类型的网络连接——TCP 连接和 **用户数据报协议** (**UDP**) 连接。TCP 是一种可靠的网络连接，而 UDP 则是不可靠的。
- en: 'These two connections are designed for very different purposes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种连接是为非常不同的目的设计的：
- en: TCP networking is usually for programs that require every single piece of data
    to be sent and received in order. It also makes sure that the client receives
    the data and that the server gets notified of that. Programs such as messaging
    software, web servers, and databases use TCP networking.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 网络通常用于需要按顺序发送和接收每一份数据的程序。它还确保客户端接收数据，并且服务器会得到通知。像消息软件、Web 服务器和数据库这样的程序使用
    TCP 网络。
- en: UDP networking, on the other hand, does not require constant handholding between
    the server and client. Since the connection is unreliable, there is also no feedback
    on whether the data has been successfully received. The dropping of packets is
    tolerated, and data may not even come in the same order as it was sent. UDP connections
    are usually used by applications that stream huge amounts of data to their clients
    without strict requirements on its packet delivery, such as video games, video
    conferencing software, and domain name systems.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，UDP 网络不需要服务器和客户端之间的持续监控。由于连接不可靠，也没有关于数据是否成功接收的反馈。数据包的丢失是可以容忍的，数据可能甚至不会按照发送的顺序到达。UDP
    连接通常用于不需要对数据包投递有严格要求的程序，例如视频游戏、视频会议软件和域名系统。
- en: Creating networking software using Qt 6 is a lot easier through its signals
    and slots mechanism. All we need to do is connect the signals emitted by the `QTcpServer`
    class and `QTcpSocket` class to our slot functions. We will then implement these
    slot functions and define what to do within those functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 6 创建网络软件要容易得多，这得益于其信号和槽机制。我们所需做的只是将 `QTcpServer` 类和 `QTcpSocket` 类发出的信号连接到我们的槽函数。然后我们将实现这些槽函数并定义这些函数中的操作。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We used a `QVector` container to store the pointers to all the clients that
    have connected to the server so that we can use it to deliver the messages later
    on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `QVector` 容器来存储连接到服务器的所有客户端的指针，以便我们可以使用它来稍后传递消息。
- en: To keep this example project simple, we simply send text messages to all the
    clients, sort of like a group chat. You are free to explore other possibilities
    and make your own changes to improve the program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例项目简单，我们只是向所有客户端发送文本消息，有点像群聊。您可以自由探索其他可能性并自行修改以改进程序。
- en: Creating a TCP client
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 TCP 客户端
- en: Since we created a TCP server in the previous recipe, we now need a client program
    to complete the project. Therefore, in this recipe, we will learn how to create
    a TCP client program using Qt 6 and its network module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的菜谱中创建了一个 TCP 服务器，我们现在需要一个客户端程序来完成项目。因此，在本菜谱中，我们将学习如何使用 Qt 6 和其网络模块创建一个
    TCP 客户端程序。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a TCP client in Qt 6, let’s do the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt 6 中创建 TCP 客户端，让我们按照以下步骤进行：
- en: First off, let’s create a new **Qt Widgets Application** project from **Files**
    | **New File** **or Project**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们从 **Files** | **New File** **or Project** 创建一个新的 **Qt Widgets Application**
    项目。
- en: 'Once the project has been created, let’s open up `mainwindow.ui` and set up
    the GUI as shown in the following diagram. Please note that the layout direction
    of the central widget has to be vertical:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，让我们打开 `mainwindow.ui` 并设置如图所示的 GUI。请注意，中央小部件的布局方向必须是垂直的：
- en: '![Figure 7.5 – The layout of our client program](img/B20976_07_005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 我们客户端程序的布局](img/B20976_07_005.jpg)'
- en: Figure 7.5 – The layout of our client program
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 我们客户端程序的布局
- en: 'Then, right-click on the push button that says `clicked()` slot function from
    the menu. Then, repeat the same step on the **Send** button as well. As a result,
    two slot functions will be created for you in the source code, which may or may
    not look like what we see in the following code, depending on your widget’s name:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击菜单中的 `clicked()` 按钮槽函数。然后，在 **Send** 按钮上也重复相同的步骤。结果，在源代码中为您创建了两个槽函数，这些函数可能或可能不会像以下代码中我们看到的那样，这取决于您的小部件名称：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, open up `mainwindow.h` and add the following headers:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `mainwindow.h` 并添加以下头文件：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, declare the `printMessage()` function and three slot functions: `socketConnected()`,
    `socketDisconnected()`, and `socketReadyRead()`, as shown in the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明 `printMessage()` 函数和三个槽函数：`socketConnected()`、`socketDisconnected()` 和
    `socketReadyRead()`，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After that, declare the following variables as well:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，声明以下变量：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: void MainWindow::printMessage(QString message) {
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: void MainWindow::printMessage(QString message) {
- en: ui->chatDisplay->append(message);
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ui->chatDisplay->append(message);
- en: '}'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we’ll implement the `on_connectButton_clicked()` function, which will
    be triggered when the **Connect** button is clicked, as shown in the following
    code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现 `on_connectButton_clicked()` 函数，该函数将在 **Connect** 按钮被点击时触发，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also define the `on_sendButton_clicked()` function, which will be called
    when the **Send** button is clicked, as shown in the following example:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了 `on_sendButton_clicked()` 函数，该函数将在 **Send** 按钮被点击时被调用，如下面的示例所示：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Right after that, we implement the `socketConnected()` function, which will
    be called when the client program has been successfully connected to the server,
    as shown in the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们实现 `socketConnected()` 函数，该函数将在客户端程序成功连接到服务器时被调用，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are not yet done at this point. We also need to implement the `socketDisconnected()`
    function, which will be triggered whenever the client has been disconnected from
    the server, as shown in the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有完成。我们还需要实现 `socketDisconnected()` 函数，该函数将在客户端从服务器断开连接时触发，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lastly, we also need to define the `socketReadyRead()` function, which prints
    out the message sent from the server, as shown in the following example:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要定义 `socketReadyRead()` 函数，该函数将打印出从服务器发送的消息，如下面的示例所示：
- en: '[PRE22]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we run the client program, we must first turn on the server program
    that we created in the previous recipe. Then, build and run the client program.
    Once the program has been opened, go and click the **Connect** button. After you
    have successfully connected to the server, type something in the line edit widget
    located at the bottom and press the **Send** button. You should see something
    similar to the following screenshot:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行客户端程序之前，我们必须首先打开我们在前面的菜谱中创建的服务器程序。然后，构建并运行客户端程序。一旦程序打开，就去点击 **连接** 按钮。成功连接到服务器后，在位于底部的行编辑小部件中输入一些内容，并按
    **发送** 按钮。你应该会看到以下类似的截图：
- en: '![Figure 7.6 – Our chat program is now working](img/B20976_07_006.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 我们的聊天程序现在正在运行](img/B20976_07_006.jpg)'
- en: Figure 7.6 – Our chat program is now working
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 我们的聊天程序现在正在运行
- en: 'Let’s go to the server program, shown in the following screenshot, and see
    whether there is anything printed on the terminal window:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到下面的服务器程序截图，看看终端窗口上是否有什么打印出来的内容：
- en: '![Figure 7.7 – Client activities are also shown on the server output](img/B20976_07_007.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 客户端活动也显示在服务器输出中](img/B20976_07_007.jpg)'
- en: Figure 7.7 – Client activities are also shown on the server output
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 客户端活动也显示在服务器输出中
- en: Congratulations, you have successfully created a program that looks a bit like
    an **Internet Relay Chat** (**IRC**) chat room!
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜你，你已经成功创建了一个看起来有点像 **互联网中继聊天**（**IRC**）聊天室的程序！
- en: How it works…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In order for this to work, we need two programs: a server program that connects
    all the clients and delivers their messages, and a client program used by the
    users to send and receive messages from other users.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，我们需要两个程序：一个连接所有客户端并传递他们消息的服务器程序，以及一个用户使用的客户端程序，用于发送和接收其他用户的消息。
- en: Since the server program just sits behind the scenes and works out everything
    in silence, it doesn’t need any user interface, and thus we only need it as a
    Qt Console application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器程序只是幕后默默工作，处理所有事情，它不需要任何用户界面，因此我们只需要它作为一个 Qt 控制台应用程序。
- en: The client program, however, requires a visually pleasant yet easy-to-use GUI
    for the users to read and write their messages. Therefore, we created the client
    program as a Qt Widgets application instead.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端程序需要用户友好的图形用户界面，以便用户可以阅读和发送他们的消息。因此，我们将客户端程序创建为一个 Qt 小部件应用程序。
- en: The client program is relatively simple when compared to the server program.
    All it does is connect to the server, send out the message input by the user,
    and print out everything the server sends to it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器程序相比，客户端程序相对简单。它所做的只是连接到服务器，发送用户输入的消息，并打印出服务器发送给它的所有内容。
- en: Uploading and downloading files using FTP
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FTP 上传和下载文件
- en: We have learned how to create simple chat software that distributes text messages
    among the users. Next, we will learn how to create a program that uploads and
    downloads files using FTP.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何创建简单的聊天软件，该软件可以在用户之间分发文本消息。接下来，我们将学习如何创建一个使用 FTP 上传和下载文件的程序。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s get started by observing the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从观察以下步骤开始：
- en: 'For this project, we need to install software called **FileZilla Server**,
    which we will use as the FTP server. FileZilla Server can be downloaded from [https://filezilla-project.org](https://filezilla-project.org)
    by clicking on the **Download FileZilla Server** button, as shown in the following
    screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要安装一个名为 **FileZilla 服务器** 的软件，我们将将其用作 FTP 服务器。FileZilla 服务器可以通过点击以下截图所示的
    **下载 FileZilla 服务器** 按钮从 [https://filezilla-project.org](https://filezilla-project.org)
    下载：
- en: '![Figure 7.8 – Downloading FileZilla Server from the official website](img/B20976_07_008.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 从官方网站下载 FileZilla 服务器](img/B20976_07_008.jpg)'
- en: Figure 7.8 – Downloading FileZilla Server from the official website
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 从官方网站下载 FileZilla 服务器
- en: 'Once you have downloaded the installer, run it and install **FileZilla Server**
    by agreeing to all the default options, as shown in the following screenshot:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载安装程序后，运行它，并同意所有默认选项来安装 **FileZilla 服务器**，如下面的截图所示：
- en: '![Figure 7.9 – Default installation options will do](img/B20976_07_009.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 默认安装选项](img/B20976_07_009.jpg)'
- en: Figure 7.9 – Default installation options will do
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 默认安装选项
- en: 'When it has completed, open up **FileZilla Server** and press the **Connect
    to Server…** button, and the **Connection** window will pop up, as shown in the
    following screenshot:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当它完成时，打开 **FileZilla Server** 并按下 **连接到服务器…** 按钮，将弹出 **连接** 窗口，如下截图所示：
- en: '![Figure 7.10 – Setting the host, port, and password in the Connection window](img/B20976_07_010.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 在连接窗口中设置主机、端口和密码](img/B20976_07_010.jpg)'
- en: Figure 7.10 – Setting the host, port, and password in the Connection window
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 在连接窗口中设置主机、端口和密码
- en: 'After the server has been started, go to **Server** | **Configure…** from the
    top menu, as highlighted in the following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器启动后，从顶部菜单中选择 **服务器** | **配置…**，如下截图所示：
- en: '![Figure 7.11 – Opening up the Settings window from the top menu](img/B20976_07_011.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 从顶部菜单打开设置窗口](img/B20976_07_011.jpg)'
- en: Figure 7.11 – Opening up the Settings window from the top menu
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 从顶部菜单打开设置窗口
- en: 'Once the **Settings** window has been opened, click on the **Add** button located
    under the **Available users** list to add a new user. Then, add a shared folder
    under the **Shared** folders list, where your users will be uploading and downloading
    files to and from, as shown in the following screenshot:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开 **设置** 窗口，点击位于 **可用用户** 列表下的 **添加** 按钮，以添加新用户。然后，在 **共享文件夹** 列表下添加一个共享文件夹，用户将在此上传和下载文件，如下截图所示：
- en: '![Figure 7.12 – Clicking the Add button to add a new user](img/B20976_07_012.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 点击添加按钮添加新用户](img/B20976_07_012.jpg)'
- en: Figure 7.12 – Clicking the Add button to add a new user
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 点击添加按钮添加新用户
- en: 'We have now finished setting up FileZilla Server. Let’s move on to Qt Creator
    and create a new `mainwindow.ui` and set up the GUI, as shown in the following
    diagram:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经完成了 FileZilla Server 的设置。让我们继续使用 Qt Creator 创建一个新的 `mainwindow.ui` 并设置
    GUI，如下所示：
- en: '![Figure 7.13 – Layout of our FPT program](img/B20976_07_013.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 我们 FTP 程序的布局](img/B20976_07_013.jpg)'
- en: Figure 7.13 – Layout of our FPT program
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 我们 FTP 程序的布局
- en: 'Next, right-click on the `clicked()` slot functions, as shown in the following
    code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着，在 `clicked()` 插槽函数上右键单击，如下所示：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 7.14 – Selecting the itemDoubleClicked option](img/B20976_07_014.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 选择 itemDoubleClicked 选项](img/B20976_07_014.jpg)'
- en: Figure 7.14 – Selecting the itemDoubleClicked option
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 选择 itemDoubleClicked 选项
- en: 'Then, declare additional slot functions such as `serverConnected()`, `serverReply()`,
    and `dataReceived()`, which we will implement later in this chapter:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明其他槽函数，如 `serverConnected()`、`serverReply()` 和 `dataReceived()`，我们将在本章后面实现它们：
- en: '[PRE24]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, open up `ftpdatachannel.h` and add the following code to it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `ftpdatachannel.h` 并向其中添加以下代码：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Right after that, open the `ftpdatachannel.cpp` source file and write the following
    code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，打开 `ftpdatachannel.cpp` 源文件并写入以下代码：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we continue to implement functions for the `FtpDataChannel` class, such
    as `listen()`, `sendData()`, and `close()`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续实现 `FtpDataChannel` 类的函数，例如 `listen()`、`sendData()` 和 `close()`：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, we implement the `postspec()` function, which composes the FTP server’s
    information in a special format that can be sent back to the FTP server for verification
    purposes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们实现 `postspec()` 函数，该函数以特殊格式组合 FTP 服务器的信息，以便发送回 FTP 服务器进行验证：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once we’re done with the `FtpDataChannel` class, go to `FtpControlChannel`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了 `FtpDataChannel` 类，转到 `FtpControlChannel`。
- en: 'Open up the newly created `ftpcontrolchannel.h` and add the following code
    to the header file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的 `ftpcontrolchannel.h` 并将以下代码添加到头文件中：
- en: '[PRE29]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, let’s open up `ftpcontrolchannel.cpp` and write the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们打开 `ftpcontrolchannel.cpp` 并写入以下代码：
- en: '[PRE30]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we continue to implement other functions of the class, such as `connectToServer()`
    and `command()`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们继续实现类的其他函数，例如 `connectToServer()` 和 `command()`：
- en: '[PRE31]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Right after that, we continue to write the code for its slot functions—namely,
    `onReadyRead()` and `error()`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，我们继续为其槽函数编写代码——即 `onReadyRead()` 和 `error()`：
- en: '[PRE32]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, open up `mainwindow.h` and add the following headers:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开 `mainwindow.h` 并添加以下头文件：
- en: '[PRE33]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, declare the `getFileList()` function, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，声明 `getFileList()` 函数，如下所示：
- en: '[PRE34]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Right after that, declare the following variables:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随后，声明以下变量：
- en: '[PRE35]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, open up `mainwindow.cpp` and add the following code to the class constructor:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开 `mainwindow.cpp` 并将以下代码添加到类构造函数中：
- en: '[PRE36]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, implement the `getFileList()` function, as shown in the following
    code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，实现 `getFileList()` 函数，如下所示：
- en: '[PRE37]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, define the `on_openButton_clicked()` slot function, which gets triggered
    when the **Open** button is clicked, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义`on_openButton_clicked()`槽函数，该函数在点击**打开**按钮时被触发，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once you’re done with that, implement the slot function that gets called when
    the **Upload** button is clicked, as shown in the following example:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，实现当**上传**按钮被点击时调用的槽函数，如下面的示例所示：
- en: '[PRE39]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code shows what the `on_setFolderButton_clicked()` slot function
    looks like:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了`on_setFolderButton_clicked()`槽函数的样子：
- en: '[PRE40]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, define the slot function that will be triggered when one of the list
    widget’s items gets double-clicked, as shown in the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个槽函数，当列表小部件的某个项目被双击时将触发该函数，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We’re not quite done yet. Next, we will implement the `serverConnected()` function,
    which will be called automatically when the program has successfully connected
    to the FTP server, as shown in the following code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有完成。接下来，我们将实现`serverConnected()`函数，当程序成功连接到FTP服务器时，该函数将自动被调用，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We also need to implement the function that will be called when the FTP server
    replies to our request, as shown in the following example:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要实现当FTP服务器回复我们的请求时将被调用的函数，如下面的示例所示：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `dataReceived()` function is used to obtain the data received from the
    FTP server, and it looks something like the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dataReceived()`函数用于获取从FTP服务器接收到的数据，其代码如下所示：'
- en: '[PRE44]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Lastly, build and run the program. Try and upload some files to the FTP server.
    If it works, the file list should be updated and displayed on the **List** widget.
    Then, try and double-click on the filename on the list widget and download the
    file to your computer, as shown in the following screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，构建并运行程序。尝试上传一些文件到FTP服务器。如果成功，文件列表应该会更新并显示在**列表**小部件上。然后，尝试双击列表小部件上的文件名，将文件下载到您的计算机上，如下面的屏幕截图所示：
- en: '![Figure 7.15 – Downloading a file from the FTP server by double-clicking on
    it](img/B20976_07_015.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图7.15 – 通过双击从FTP服务器下载文件](img/B20976_07_015.jpg)'
- en: Figure 7.15 – Downloading a file from the FTP server by double-clicking on it
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 通过双击从FTP服务器下载文件
- en: 'You can also try to upload a file by clicking on the **Open** button, selecting
    the desired file, and pressing the **Upload** button, as shown in the following
    screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以尝试通过点击**打开**按钮，选择所需的文件，然后按下**上传**按钮来上传文件，如下面的屏幕截图所示：
- en: '![Figure 7.16 – Uploading a file to the FTP server](img/B20976_07_016.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图7.16 – 将文件上传到FTP服务器](img/B20976_07_016.jpg)'
- en: Figure 7.16 – Uploading a file to the FTP server
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – 将文件上传到FTP服务器
- en: Congratulations, you have now successfully created a working FTP program!
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恭喜您，您现在已经成功创建了一个可工作的FTP程序！
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do note that this example program is only meant to show you the most basic implementation
    of an FTP program and is not a fully featured program. It’s not guaranteed to
    work if you try to upload/download files that are not in text format. It may also
    not upload correctly if a file already exists on the FTP server. You must implement
    these features by yourself if you wish to expand on top of this project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个示例程序仅用于展示FTP程序最基本实现，并不是一个功能齐全的程序。如果您尝试上传/下载非文本格式的文件，则可能无法保证其正常工作。如果FTP服务器上已存在同名文件，也可能无法正确上传。如果您希望在此基础上扩展项目，必须自行实现这些功能。
- en: How it works…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: Although this project is much larger and with longer code, it is actually pretty
    similar to the TCP networking projects we have done in previous recipes. We have
    also made use of the signals and slots mechanism provided by Qt 6 to make our
    lives easier.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个项目规模更大，代码也更长，但实际上它与我们在之前菜谱中完成的TCP网络项目非常相似。我们还利用了Qt 6提供的信号和槽机制来简化我们的工作。
- en: In the past, Qt used to support FTP in the `QNetworkAccessManager` class. However,
    FTP has since been deprecated in Qt 6 so we have to implement it on our own.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，Qt曾经支持`QNetworkAccessManager`类中的FTP。然而，自Qt 6以来，FTP已被弃用，因此我们必须自己实现它。
- en: We must understand some of the most common FTP commands and utilize them in
    our program. For more information, check out [https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command](https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须了解一些最常见的 FTP 命令，并在我们的程序中利用它们。更多信息，请查看[https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command](https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command)。
- en: 'The `FtpControlChannel` and `FtpDataChannel` classes were taken from Qt’s official
    Git repository with some tiny modifications: [https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient](https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`FtpControlChannel` 和 `FtpDataChannel` 类是从 Qt 的官方 Git 仓库中提取的，并进行了一些微小的修改：[https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient](https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient)。'
