- en: Using Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Applying a 2D texture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用2D纹理
- en: Applying multiple textures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用多个纹理
- en: Using alpha maps to discard pixels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用alpha贴图丢弃像素
- en: Using normal maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用法线贴图
- en: Parallax mapping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差贴图
- en: Steep parallax mapping with self shadowing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带自阴影的陡峭视差贴图
- en: Simulating reflection with cube maps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用立方体贴图模拟反射
- en: Simulating refraction with cube maps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用立方体贴图模拟折射
- en: Applying a projected texture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用投影纹理
- en: Rendering to a texture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将渲染输出到纹理
- en: Using sampler objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用采样器对象
- en: Diffuse image-based lighting
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于漫反射图像的照明
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Textures are an important and fundamental aspect of real-time rendering in general,
    and OpenGL in particular. The use of textures within a shader opens up a huge
    range of possibilities. Beyond just using textures as sources of color information,
    they can be used for things like depth information, shading parameters, displacement
    maps, normal vectors, and other vertex data. The list is virtually endless. Textures
    are among the most widely used tools for advanced effects in OpenGL programs,
    and that isn't likely to change any time soon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理是实时渲染，尤其是OpenGL中一个重要且基本的部分。在着色器中使用纹理可以打开一个巨大的可能性范围。除了将纹理用作颜色信息源之外，它们还可以用于深度信息、着色参数、位移贴图、法线向量和其他顶点数据等。这个列表几乎是无穷无尽的。纹理是OpenGL程序中用于高级效果的最广泛使用的工具之一，这种情况在不久的将来不太可能改变。
- en: In OpenGL 4, we now have the ability to read and write to memory via buffer
    textures, shader storage buffer objects, and image textures (image load/store).
    This further muddies the waters of what exactly defines a texture. In general,
    we might just think of it as a buffer of data that may or may not contain an image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL 4中，我们现在可以通过缓冲区纹理、着色器存储缓冲区对象和图像纹理（图像加载/存储）来读取和写入内存。这进一步模糊了纹理的确切定义。一般来说，我们可能只是将其视为一个可能包含图像的数据缓冲区。
- en: OpenGL 4.2 introduced **immutable storage textures**. Despite what the term
    may imply, immutable storage textures are not textures that can't change. Instead,
    the term *immutable* refers to the fact that, once the texture is allocated, the
    *storage* cannot be changed. That is, the size, format, and number of layers are
    fixed, but the texture content itself can be modified. The word immutable refers
    to the allocation of the memory, not the content of the memory. Immutable storage
    textures are preferable in the vast majority of cases because of the fact that
    many runtime (draw-time) consistency checks can be avoided, and you include a
    certain degree of "type safety" since we can't accidentally change the allocation
    of a texture. Throughout this book, we'll use immutable storage textures exclusively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 4.2引入了**不可变存储纹理**。尽管这个术语可能意味着什么，但不可变存储纹理并不是不能改变的纹理。相反，术语*不可变*指的是一旦纹理被分配，*存储*就不能改变。也就是说，大小、格式和层数是固定的，但纹理内容本身可以修改。不可变一词指的是内存的分配，而不是内存的内容。在绝大多数情况下，不可变存储纹理更可取，因为可以避免许多运行时（绘制时）的一致性检查，并且我们可以包含一定程度的“类型安全”，因为我们不能意外地改变纹理的分配。在这本书的整个过程中，我们将专门使用不可变存储纹理。
- en: Immutable storage textures are allocated using the `glTexStorage*` functions.
    If you're experienced with textures, you might be accustomed to using `glTexImage*`
    functions, which are still supported but create mutable storage textures.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变存储纹理是通过`glTexStorage*`函数分配的。如果你对纹理有经验，你可能习惯于使用`glTexImage*`函数，这些函数仍然受支持，但创建可变存储纹理。
- en: In this chapter, we'll look at some basic and advanced texturing techniques.
    We'll start with the basics by just applying color textures and move on to using
    textures as normal maps and environment maps. With environment maps, we can simulate
    things such as reflection and refraction. We'll see an example of projecting a
    texture onto objects in a scene similar to the way that a slide projector projects
    an image. Finally, we'll wrap up with an example of rendering directly to a texture
    using **framebuffer objects** (**FBOs**) and then applying that texture to an
    object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些基本的和高级的纹理技术。我们将从基本的颜色纹理应用开始，然后过渡到使用纹理作为法线贴图和环境贴图。通过环境贴图，我们可以模拟反射和折射等现象。我们将看到一个将纹理投影到场景中物体上的例子，这类似于幻灯片投影仪投影图像的方式。最后，我们将通过一个使用**帧缓冲对象**（**FBOs**）直接渲染到纹理的例子来结束本章。
- en: Applying a 2D texture
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用2D纹理
- en: In GLSL, applying a texture to a surface involves accessing texture memory to
    retrieve a color associated with a texture coordinate, and then applying that
    color to the output fragment. The application of the color to the output fragment
    could involve mixing the color with the color produced by a shading model, simply
    applying the color directly, using the color in the reflection model, or some
    other mixing process. In GLSL, textures are accessed via **sampler** variables.
    A sampler variable is a *handle* to a texture unit. It is typically declared as
    a uniform variable within the shader and initialized within the main OpenGL application
    to point to the appropriate texture unit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在GLSL中，将纹理应用于表面涉及访问纹理内存以检索与纹理坐标相关联的颜色，然后将该颜色应用于输出片段。将颜色应用于输出片段可能涉及将颜色与着色模型产生的颜色混合，直接应用颜色，使用反射模型中的颜色，或某些其他混合过程。在GLSL中，通过**sampler**变量访问纹理。sampler变量是纹理单元的**句柄**。它通常在着色器内声明为uniform变量，并在主OpenGL应用程序中初始化，以指向适当的纹理单元。
- en: 'In this recipe, we''ll look at a simple example involving the application of
    a 2D texture to a surface, as shown in the following image. We''ll use the texture
    color as the diffuse (and ambient) reflectivity term in the Blinn-Phong reflection
    model. The following image shows the results of a brick texture applied to a cube.
    The texture is shown on the right and the rendered result is on the left:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将查看一个简单示例，涉及将2D纹理应用于表面，如图所示。我们将使用纹理颜色作为Blinn-Phong反射模型中的漫反射（和环境）反射率项。以下图像显示了将砖纹纹理应用于立方体的结果。纹理显示在右侧，渲染结果显示在左侧：
- en: '![](img/761984c0-af73-483a-b181-ca6d611f8e98.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/761984c0-af73-483a-b181-ca6d611f8e98.png)'
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL application to provide the vertex position in attribute location
    0, the vertex normal in attribute location 1, and the texture coordinate in attribute
    location 2\. The parameters for the Blinn-Phong reflection model are declared
    again as uniform variables within the shader, and must be initialized from the
    OpenGL program. Make the handle to the shader available in a variable named `programHandle`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL应用程序以提供顶点位置在属性位置0，顶点法线在属性位置1，以及纹理坐标在属性位置2。Blinn-Phong反射模型的参数再次在着色器内声明为uniform变量，并且必须从OpenGL程序中初始化。将着色器的句柄通过名为`programHandle`的变量使其可用。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To render a simple shape with a 2D texture, use the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用2D纹理渲染简单形状，请按照以下步骤操作：
- en: 'We''ll define a simple (static) function for loading and initializing textures:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个简单的（静态）函数用于加载和初始化纹理：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the initialization of the OpenGL application, use the following code to
    load the texture, bind it to texture unit `0`, and set the uniform variable `Tex1`
    to that texture unit:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序的初始化中，使用以下代码加载纹理，将其绑定到纹理单元`0`，并将uniform变量`Tex1`设置为该纹理单元：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The vertex shader passes the texture coordinate to the fragment shader:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器将纹理坐标传递给片段着色器：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The fragment shader looks up the texture value and applies it to the diffuse
    reflectivity in the Blinn-Phong model:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器查找纹理值并将其应用于Blinn-Phong模型中的漫反射反射率：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first code segment defines a simple function that loads the texture from
    a file, copies the texture data to OpenGL memory, and sets up the `mag` and `min`
    filters. It returns the texture ID. The first step, loading the texture image
    file, is accomplished by calling another method (`Texture::loadPixels`), which
    uses an image loader that is provided along with the example code. The loader
    comes from a header file `stb_image.h`, available on GitHub ([https://github.com/nothings/stb](https://github.com/nothings/stb)).
    It reads the image and stores the pixel data into an array of unsigned bytes in
    RGBA order. The width and height of the image are returned via the last two parameters.
    We keep a pointer to the image data, simply named `data`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码定义了一个简单的函数，该函数从文件中加载纹理，将纹理数据复制到OpenGL内存中，并设置`mag`和`min`过滤器。它返回纹理ID。第一步，加载纹理图像文件，是通过调用另一个方法（`Texture::loadPixels`）完成的，该方法使用与示例代码一起提供的图像加载器。加载器来自头文件`stb_image.h`，可在GitHub上找到（[https://github.com/nothings/stb](https://github.com/nothings/stb)）。它读取图像并将像素数据存储在一个无符号字节的数组中，顺序为RGBA。图像的宽度和高度通过最后两个参数返回。我们保留对图像数据的指针，简单地命名为`data`。
- en: The next two lines involve creating a new texture object by calling `glGenTextures`.
    The handle for the new texture object is stored in the `tex` variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行涉及通过调用 `glGenTextures` 创建一个新的纹理对象。新纹理对象的句柄存储在 `tex` 变量中。
- en: To load and configure the texture object, we do the following.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载和配置纹理对象，我们执行以下操作。
- en: We call `glBindTexture` to bind the new texture object to the `GL_TEXTURE_2D`
    target.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 `glBindTexture` 将新纹理对象绑定到 `GL_TEXTURE_2D` 目标。
- en: Once the texture is bound to that target, we allocate immutable storage for
    the texture with `glTexStorage2D`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦纹理绑定到该目标，我们使用 `glTexStorage2D` 为纹理分配不可变存储。
- en: After that, we copy the data for that texture into the texture object using
    `glTexSubImage2D`. The last argument to this function is a pointer to the raw
    data for the image.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用 `glTexSubImage2D` 将该纹理的数据复制到纹理对象中。此函数的最后一个参数是图像原始数据的指针。
- en: The next steps involve setting the magnification and minification filters for
    the texture object using `glTexParameteri`.  For this example, we'll use `GL_LINEAR`
    for the former and `GL_NEAREST` for the latter.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步涉及使用 `glTexParameteri` 为纹理对象设置放大和缩小过滤器。对于这个例子，我们将使用 `GL_LINEAR` 作为前者，`GL_NEAREST`
    作为后者。
- en: The texture filter setting determines whether any interpolation will be done
    prior to returning the color from the texture. This setting can have a strong
    effect on the quality of the results. In this example, `GL_LINEAR` indicates that
    it will return a weighted average of the four texels that are nearest to the texture
    coordinates. For details on the other filtering options, see the OpenGL documentation
    for `glTexParameteri`: [http://www.opengl.org/wiki/GLAPI/glTexParameter](http://www.opengl.org/wiki/GLAPI/glTexParameter).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理过滤器设置确定在从纹理返回颜色之前是否进行插值。此设置可以强烈影响结果的质量。在这个例子中，`GL_LINEAR` 表示它将返回最接近纹理坐标的四个纹素的平均加权值。有关其他过滤选项的详细信息，请参阅
    OpenGL 文档中的 `glTexParameter`：[http://www.opengl.org/wiki/GLAPI/glTexParameter](http://www.opengl.org/wiki/GLAPI/glTexParameter)。
- en: Next, we delete the texture data pointed to by `data`. There's no need to hang
    on to this because it was copied into texture memory via `glTexSubImage2D`. To
    do so, we call the `Texture::deletePixels` function.  (Internally, that calls
    the function provided by the `stb_image` library `stbi_image_free`.) Then, we
    return the ID of the new texture object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们删除由 `data` 指向的纹理数据。没有必要保留它，因为它已经通过 `glTexSubImage2D` 复制到纹理内存中。为此，我们调用
    `Texture::deletePixels` 函数。（内部调用 `stb_image` 库提供的函数 `stbi_image_free`。）然后，我们返回新纹理对象的
    ID。
- en: In the next code segment, we call our `Texture::loadTexture` function to load
    the texture, then we bind the texture to texture unit `0`. To do so, first we
    call `glActiveTexture` to set the current active texture unit to `GL_TEXTURE0` (the
    first texture unit, also called a **texture ****channel**). The subsequent texture
    state calls will be effective on texture unit zero. Then, we bind the new texture
    to that unit using `glBindTexture`. Finally, we set the uniform variable `Tex1`
    in the GLSL program to zero. This is our sampler variable. Note that it is declared
    within the fragment shader with type `sampler2D`. Setting its value to zero indicates
    to the OpenGL system that the variable should refer to texture unit zero (the
    same one selected previously with `glActiveTexture`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码段中，我们调用 `Texture::loadTexture` 函数来加载纹理，然后将其绑定到纹理单元 `0`。为此，首先我们调用 `glActiveTexture`
    将当前活动纹理单元设置为 `GL_TEXTURE0`（第一个纹理单元，也称为 **纹理 **通道）。随后的纹理状态调用将作用于纹理单元零。然后，我们使用 `glBindTexture`
    将新纹理绑定到该单元。最后，我们将 GLSL 程序中的统一变量 `Tex1` 设置为零。这是我们采样变量。注意，它在片段着色器中声明，类型为 `sampler2D`。将其值设置为零表示OpenGL系统该变量应引用纹理单元零（与之前使用
    `glActiveTexture` 选择的是同一个）。
- en: The vertex shader is very similar to the one used in the previous examples except
    for the addition of the texture coordinate input variable `VertexTexCoord`, which
    is bound to attribute location `2`. Its value is simply passed along to the fragment
    shader by assigning it to the shader output variable `TexCoord`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器与前面例子中使用的非常相似，除了增加了纹理坐标输入变量 `VertexTexCoord`，它绑定到属性位置 `2`。它的值简单地通过将其分配给着色器输出变量
    `TexCoord` 传递给片段着色器。
- en: The fragment shader is also very similar to those used in the recipes of previous
    chapters.  The primary changes are the `Tex1` uniform variable and the `blinnPhong`
    function.  `Tex1` is a `sampler2D` variable that was assigned by the OpenGL program
    to refer to texture unit zero. In the `blinnPhong` function, we use that variable
    along with the texture coordinate (`TexCoord`) to access the texture. We do so
    by calling the built-in function `texture`. This is a general purpose function,
    which is used to access a variety of different textures. The first parameter is
    a sampler variable indicating which texture unit is to be accessed, and the second
    parameter is the texture coordinate used to access the texture. The return value
    is a `vec4` containing the color obtained by the texture access. We select only
    the first three components (`.rgb`) and store them in `texColor`. Then, we use
    `texColor` as the ambient and diffuse reflectivity terms in the Blinn-Phong model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器与之前章节中使用的着色器也非常相似。主要的变化是`Tex1`统一变量和`blinnPhong`函数。`Tex1`是一个`sampler2D`变量，由OpenGL程序分配以引用纹理单元零。在`blinnPhong`函数中，我们使用该变量以及纹理坐标（`TexCoord`）来访问纹理。我们通过调用内置函数`texture`来实现这一点。这是一个通用函数，用于访问各种不同的纹理。第一个参数是一个采样变量，指示要访问哪个纹理单元，第二个参数是用于访问纹理的纹理坐标。返回值是一个包含通过纹理访问得到的颜色的`vec4`。我们只选择前三个组件（`.rgb`）并将它们存储在`texColor`中。然后，我们将`texColor`用作Blinn-Phong模型中的环境光和漫反射反射率项。
- en: When using a texture for both ambient and diffuse reflectivity, it is important
    to set the ambient light intensity to a small value, in order to avoid *wash-out*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用纹理同时进行环境光和漫反射反射率时，设置环境光强度为小值很重要，以避免*过度曝光*。
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several choices that could be made when deciding how to combine the
    texture color with other colors associated with the fragment. In this example,
    we used the texture color as the ambient and diffuse reflectivity, but one could
    have chosen to use the texture color directly or to mix it with the reflection
    model in some way. There are endless options—the choice is up to you!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何将纹理颜色与其他与片段相关的颜色组合时，有几种选择。在这个例子中，我们使用了纹理颜色作为环境光和漫反射反射率，但可以选择直接使用纹理颜色，或者以某种方式将其与反射模型混合。选项无穷无尽——选择权在你！
- en: Specifying the sampler binding within GLSL
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GLSL中指定采样器绑定
- en: 'As of OpenGL 4.2, we now have the ability to specify the default value of the
    sampler''s binding (the value of the sampler uniform) within GLSL. In the previous
    example, we set the value of the uniform variable from the OpenGL side using the
    following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 截至OpenGL 4.2，我们现在能够在GLSL中指定采样器绑定的默认值（采样器统一变量的值）。在之前的示例中，我们使用以下代码从OpenGL端设置统一变量的值：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead, if we''re using OpenGL 4.2, we can specify the default value within
    the shader using the layout qualifier, as shown in the following statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们使用OpenGL 4.2，我们可以在着色器中使用layout限定符来指定默认值，如下面的语句所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This simplifies the code on the OpenGL side and makes this one less thing we
    need to worry about. The example code that accompanies this book uses this technique
    to specify the value of `Tex1`, so take a look there for a more complete example.
    We'll also use this layout qualifier in the following recipes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了OpenGL端的代码，并使我们需要担心的事情减少了一项。本书附带示例代码使用此技术来指定`Tex1`的值，因此请查看那里以获取更完整的示例。我们还将在此后的食谱中使用此layout限定符。
- en: See also
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenetexture.cpp` file in the example code
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenetexture.cpp`文件
- en: For more information about sending data to a shader via vertex attributes refer
    to the *Sending data to a shader using vertex attributes and vertex buffer objects*
    recipe in [Chapter 2](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml), *Working with
    GLSL Programs*
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关通过顶点属性将数据发送到着色器的更多信息，请参阅[第2章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)中的*使用顶点属性和顶点缓冲对象发送数据到着色器*食谱，*与GLSL程序一起工作*
- en: The *Using per-fragment shading for improved realism* recipe in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml),
    *Lighting and Shading*
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](343fbd70-0012-4449-afe6-a724b330b441.xhtml)的*使用每片段着色提高真实感*食谱中，*光照和着色*
- en: Applying multiple textures
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用多个纹理
- en: The application of multiple textures to a surface can be used to create a wide
    variety of effects. The base layer texture might represent the *clean* surface
    and the second layer could provide additional detail such as shadow, blemishes,
    roughness, or damage. In many games, so-called light maps are applied as an additional
    texture layer to provide information about light exposure, effectively producing
    shadows, and shading without the need to explicitly calculate the reflection model.
    These kinds of textures are sometimes referred to as *pre-baked* lighting. In
    this recipe, we'll demonstrate this multiple texture technique by applying two
    layers of texture. The base layer will be a fully opaque brick image, and the
    second layer will be one that is partially transparent. The non-transparent parts
    look like moss that has grown on the bricks beneath.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个纹理应用于表面可以用来创建各种效果。基础层纹理可能代表*干净*的表面，而第二层可以提供额外的细节，如阴影、瑕疵、粗糙度或损坏。在许多游戏中，所谓的光照图作为额外的纹理层应用，以提供关于光照暴露的信息，从而有效地产生阴影和着色，而无需显式计算反射模型。这类纹理有时被称为*预烘焙*光照。在这个菜谱中，我们将通过应用两层纹理来展示这种多纹理技术。基础层将是一个完全不透明的砖图像，而第二层将是部分透明的。不透明部分看起来像是长在砖块上的苔藓。
- en: 'The following image shows an example of multiple textures. The textures on
    the left are applied to the cube on the right. The base layer is the brick texture,
    and the moss texture is applied on top. The transparent parts of the moss texture
    reveal the brick texture underneath:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了多个纹理的示例。左侧的纹理应用于右侧的立方体。基础层是砖纹理，而苔藓纹理则覆盖在其上。苔藓纹理的透明部分揭示了下面的砖纹理：
- en: '![](img/a518e8fc-d6e5-4a3a-ade8-be9b8988e259.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a518e8fc-d6e5-4a3a-ade8-be9b8988e259.png)'
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll start with the shaders developed in the previous recipe, *Applying a 2D
    texture*, as well as the `Texture::loadTexture` function described there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一道菜谱中开发的着色器开始，即*应用2D纹理*，以及那里描述的`Texture::loadTexture`函数。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In the initialization section of your OpenGL program, load the two images into
    texture memory in the same way as indicated in the previous recipe, *Applying
    a 2D texture*. Make sure that the brick texture is loaded into texture unit 0
    and the moss texture in texture unit 1:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的OpenGL程序初始化部分，以与上一道菜谱*应用2D纹理*中指示的相同方式，将两个图像加载到纹理内存中。确保砖纹理被加载到纹理单元0，而苔藓纹理加载到纹理单元1：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Starting with the fragment shader from the recipe *Applying a 2D texture*,
    replace the declaration of the sampler variable `Tex1` with the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜谱*应用2D纹理*中的片段着色器开始，将采样变量`Tex1`的声明替换为以下代码：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the  `blinnPhong` function, get samples from both textures and mix them
    together. Then, apply the mixed color to both the ambient and diffuse reflectivity:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blinnPhong`函数中，从两个纹理中获取样本并将它们混合在一起。然后，将混合后的颜色应用到环境光和漫反射反射率上：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The preceding code that loads the two textures into the OpenGL program is very
    similar to the code from the previous recipe, *Applying a 2D texture*. The main
    difference is that we load each texture into a different texture unit. When loading
    the brick texture, we set the OpenGL state such that the active texture unit is
    unit zero:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个纹理加载到OpenGL程序中的前述代码与上一道菜谱*应用2D纹理*中的代码非常相似。主要区别在于我们将每个纹理加载到不同的纹理单元。当加载砖纹理时，我们设置OpenGL状态，使得活动纹理单元为单元零：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And when loading the second texture, we set the OpenGL state to texture unit
    one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载第二个纹理时，我们将OpenGL状态设置为纹理单元1：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the fragment shader, we specify the texture binding for each sampler variable
    using the layout qualifier corresponding to the appropriate texture unit. We access
    the two textures using the corresponding uniform variables, and store the results
    in `brickTexColor` and `mossTexColor`. The two colors are blended together using
    the built-in function `mix`. The third parameter to the `mix` function is the
    percentage used when mixing the two colors. We use the alpha value of the moss
    texture for that parameter. This causes the result to be a linear interpolation
    of the two colors based on the value of the alpha in the moss texture. For those
    familiar with OpenGL blending functions, this is the same as the following blending
    function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们使用与适当纹理单元对应的布局限定符来指定每个采样器变量的纹理绑定。我们使用相应的统一变量访问两个纹理，并将结果存储在`brickTexColor`和`mossTexColor`中。这两个颜色通过内置函数`mix`混合在一起。`mix`函数的第三个参数是混合两种颜色时使用的百分比。我们使用苔藓纹理的alpha值作为该参数。这导致结果基于苔藓纹理中alpha的值进行线性插值。对于那些熟悉OpenGL混合函数的人来说，这等同于以下混合函数：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, the color of the moss would be the source color, and the color
    of the brick would be the destination color. Finally, we use the result of the
    `mix` function as the ambient and diffuse reflectivities in the Blinn-Phong reflection
    model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，苔藓的颜色将是源颜色，砖的颜色将是目标颜色。最后，我们将`mix`函数的结果用作Blinn-Phong反射模型中的环境光和漫反射反射率。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this example, we mixed the two texture colors together using the alpha value
    of the second texture. This is just one of many options for mixing the texture
    colors. There are a number of different choices here, and your choice will be
    dependent on the kind of texture data available and the desired effect. A popular
    technique is to use an additional vertex attribute to augment the amount of blending
    between the textures. This additional vertex attribute would allow us to vary
    the blending factor throughout a model. For example, we could vary the amount
    of moss that grows on a surface by defining another vertex attribute that would
    control the amount of blending between the moss texture and the base texture.
    A value of zero might correspond to zero moss, up to a value of one, which would
    enable blending based on the texture's alpha value alone.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用第二个纹理的alpha值混合了两种纹理颜色。这只是混合纹理颜色众多选项之一。这里有许多不同的选择，你的选择将取决于可用的纹理数据和期望的效果。一种流行的技术是使用额外的顶点属性来增强纹理之间的混合量。这个额外的顶点属性将允许我们在整个模型中改变混合因子。例如，我们可以通过定义另一个顶点属性来控制苔藓纹理和基础纹理之间的混合量，从而改变表面上苔藓的生长量。零值可能对应于没有苔藓，而一值将仅基于纹理的alpha值进行混合。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenemultitex.cpp` file in the example code
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenemultitex.cpp`文件
- en: The *Applying a 2D texture* recipe
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用2D纹理的配方
- en: Using alpha maps to discard pixels
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用alpha图丢弃像素
- en: To create the effect of an object that has holes, we could use a texture with
    an appropriate alpha channel that contains information about the transparent parts
    of the object. However, that requires us to make the depth buffer read-only and
    render all of our polygons from back to front in order to avoid blending problems.
    We would need to sort our polygons based on the camera position and then render
    them in the correct order. What a pain! With GLSL shaders, we can avoid all of
    this by using the `discard` keyword to completely discard fragments when the alpha
    value of the texture map is below a certain value. By completely discarding the
    fragments, there's no need to modify the depth buffer because when discarded,
    they aren't evaluated against the depth buffer at all. We don't need to depth-sort
    our polygons because there is no blending.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有孔洞的物体效果，我们可以使用包含有关物体透明部分信息的适当alpha通道的纹理。然而，这要求我们将深度缓冲区设置为只读，并从后向前渲染所有多边形以避免混合问题。我们需要根据相机位置对多边形进行排序，然后按正确顺序渲染它们。多么痛苦！使用GLSL着色器，我们可以通过使用`discard`关键字在纹理贴图的alpha值低于某个值时完全丢弃片段来避免所有这些问题。通过完全丢弃片段，我们不需要修改深度缓冲区，因为当丢弃时，它们根本不会与深度缓冲区进行评估。我们不需要对多边形进行深度排序，因为没有混合。
- en: 'The following image on the right shows a teapot with fragments discarded based
    upon the texture on the left. The fragment shader discards fragments that correspond
    to texels that have an alpha value below a certain threshold:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的以下图像显示了一个茶壶，其碎片基于左侧的纹理被丢弃。片段着色器丢弃与具有低于一定阈值alpha值的texels对应的碎片：
- en: '![](img/ca5ff33e-71b9-4248-a964-0ecb834d24eb.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca5ff33e-71b9-4248-a964-0ecb834d24eb.png)'
- en: If we create a texture map that has an alpha channel, we can use the value of
    the alpha channel to determine whether or not the fragment should be discarded.
    If the alpha value is below a certain value, then the pixel is discarded.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个具有alpha通道的纹理图，我们可以使用alpha通道的值来确定是否应该丢弃碎片。如果alpha值低于某个值，则丢弃该像素。
- en: As this will allow the viewer to see within the object, possibly making some
    back faces visible, we'll need to use two-sided lighting when rendering the object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将允许观众看到物体内部，可能使一些背面可见，因此我们在渲染物体时需要使用双面光照。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with the same shader pair and setup from the previous recipe, *Applying
    a 2D texture*. Load the base texture for the object into texture unit 0, and your
    alpha map into texture unit 1.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个配方*应用2D纹理*开始，使用相同的着色器对和设置。将物体的基础纹理加载到纹理单元0，并将你的alpha贴图加载到纹理单元1。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To discard fragments based on alpha data from a texture, use the following
    steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据纹理的alpha数据丢弃碎片，请按照以下步骤操作：
- en: Use the same vertex and fragment shaders from the *Applying a 2D texture *recipe.
    However, make the following modifications to the fragment shader.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与*应用2D纹理*配方相同的顶点和片段着色器。然而，对片段着色器进行以下修改。
- en: 'Replace the `sampler2D` uniform variable with the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sampler2D`统一变量替换为以下内容：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `blinnPhong` function, use `BaseTex` to look up the value of the ambient
    and diffuse reflectivity.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`blinnPhong`函数中，使用`BaseTex`查找环境光和漫反射反射率的值。
- en: 'Replace the contents of the `main` function with the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`main`函数的内容替换为以下代码：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Within the `main` function of the fragment shader, we access the alpha map texture
    and store the result in `alphaMap`. If the alpha component of `alphaMap` is less
    than a certain value (`0.15`, in this example), then we discard the fragment using
    the `discard` keyword.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器的`main`函数中，我们访问alpha贴图纹理并将结果存储在`alphaMap`中。如果`alphaMap`的alpha分量小于某个值（在这个示例中为`0.15`），则使用`discard`关键字丢弃该碎片。
- en: Otherwise, we compute the Blinn-Phong lighting model using the normal vector
    oriented appropriately, depending on whether or not the fragment is a front facing
    fragment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们使用适当方向化的法线向量计算Blinn-Phong光照模型，具体取决于碎片是否为正面碎片。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This technique is fairly simple and straightforward, and is a nice alternative
    to traditional blending techniques. It is a great way to make holes in objects
    or to present the appearance of decay. If your alpha map has a gradual change
    in the alpha throughout the map (for example, an alpha map where the alpha values
    make a smoothly varying height field), then it can be used to animate the decay
    of an object. We could vary the alpha threshold (`0.15`, in the preceding example)
    from 0.0 to 1.0 to create an animated effect of the object gradually decaying
    away to nothing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术相当简单直接，是传统混合技术的良好替代方案。这是一种在物体上制造孔洞或呈现衰变外观的绝佳方法。如果你的alpha贴图在整个贴图中alpha值有逐渐变化（例如，alpha值平滑变化的alpha贴图），则可以用来动画化物体的衰变。我们可以将alpha阈值（前一个示例中的`0.15`）从0.0变到1.0，以创建物体逐渐衰变至无的动画效果。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/sceneaphatest.cpp` file in the example code
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/sceneaphatest.cpp`文件
- en: The *Applying multiple textures* recipe
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用多个纹理*配方'
- en: Using normal maps
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用法线贴图
- en: '**Normal ****mapping** is a technique for "faking" variations in a surface
    that doesn''t really exist in the geometry of the surface. It is useful for producing
    surfaces that have bumps, dents, roughness, or wrinkles without actually providing
    enough position information (vertices) to fully define those deformations. The
    underlying surface is actually smooth, but is made to appear rough by varying
    the normal vectors using a texture (the normal map). The technique is closely
    related to bump mapping or displacement mapping. With normal maps, we modify the
    normal vectors based on information that is stored in a texture. This creates
    the appearance of a bumpy surface without actually providing the geometry of the
    bumps.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**正常映射**是一种“伪造”表面中实际在表面几何形状中不存在的变异的技术。它对于生成具有凹凸、凹痕、粗糙度或皱纹的表面非常有用，而实际上并没有提供足够的位置信息（顶点）来完全定义这些变形。底层表面实际上是平滑的，但通过使用纹理（正常贴图）来改变法向量，使其看起来粗糙。这项技术与凹凸贴图或位移贴图密切相关。使用正常贴图，我们根据存储在纹理中的信息修改法向量。这创建了一个凹凸表面的外观，而没有实际上提供凹凸的几何形状。'
- en: A normal map is a texture in which the data stored within the texture is interpreted
    as normal vectors instead of colors. The normal vectors are typically encoded
    into the RGB information of the normal map so that the red channel contains the
    *x* coordinate, the green channel contains the *y* coordinate, and the blue channel
    contains the *z* coordinate. The normal map can then be used as a *texture* in
    the sense that the texture values affect the normal vector used in the reflection
    model rather than the color of the surface. This can be used to make a surface
    look like it contains variations (bumps or wrinkles) that do not actually exist
    in the geometry of the mesh.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图是一种纹理，其中纹理中存储的数据被解释为法向量而不是颜色。法向量通常编码到正常贴图的RGB信息中，这样红色通道包含*x*坐标，绿色通道包含*y*坐标，蓝色通道包含*z*坐标。然后可以将正常贴图用作*纹理*，在这种情况下，纹理值影响反射模型中使用的法向量，而不是表面的颜色。这可以用来使表面看起来包含实际在网格几何形状中不存在的变异（凹凸或皱纹）。
- en: 'The following images show an ogre mesh (courtesy of Keenan Crane) with and
    without a normal map. The upper-left corner shows the base color texture for the
    ogre. In this example, we use this texture as the diffuse reflectivity in the
    Phong reflection model. The upper right shows the ogre with the color texture
    and default normal vectors. The bottom left is the normal map texture. The bottom
    right shows the ogre with the color texture and normal map. Note the additional
    detail in the wrinkles provided by the normal map:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了带有和不带有正常贴图的ogre网格（由Keenan Crane提供）。左上角显示了ogre的基本颜色纹理。在这个例子中，我们使用这个纹理作为Phong反射模型中的漫反射反射率。右上角显示了带有颜色纹理和默认法向量的ogre。左下角是正常贴图纹理。右下角显示了带有颜色纹理和正常贴图的ogre。注意正常贴图提供的皱纹中的额外细节：
- en: '![](img/3b4c094a-b157-40f8-899d-3a1f4e8a0d6f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b4c094a-b157-40f8-899d-3a1f4e8a0d6f.png)'
- en: A normal map can be produced in a number of ways. Many 3D modeling programs
    such as Maya, Blender, or 3D Studio Max can generate normal maps. Normal maps
    can also be generated directly from grayscale hightmap textures. There is a NVIDIA
    plugin for Adobe Photoshop that provides this functionality (see [http://developer.nvidia.com/object/photoshop_dds_plugins.html](http://developer.nvidia.com/object/photoshop_dds_plugins.html)).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图可以通过多种方式生成。许多3D建模程序，如Maya、Blender或3D Studio Max，都可以生成正常贴图。正常贴图也可以直接从灰度高度图纹理生成。NVIDIA为Adobe
    Photoshop提供了一个插件，提供了这项功能（见[http://developer.nvidia.com/object/photoshop_dds_plugins.html](http://developer.nvidia.com/object/photoshop_dds_plugins.html)）。
- en: 'Normal maps are interpreted as vectors in a **tangent ****space** (also called
    the **object ****local ****coordinate ****system**). In the tangent coordinate
    system, the origin is located at the surface point and the normal to the surface
    is aligned with the *z* axis (0, 0, 1). Therefore, the *x* and *y* axes are at
    a tangent to the surface. The following image shows an example of the tangent
    frames at two different positions on a surface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图被解释为**切线空间**（也称为**对象局部坐标系**）中的向量。在切线坐标系中，原点位于表面点，表面法线与*z*轴（0, 0, 1）对齐。因此，*x*和*y*轴与表面相切。以下图像显示了表面两个不同位置上的切线框架的示例：
- en: '![](img/3d332f28-53f1-4b13-9abe-9dde26f44581.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d332f28-53f1-4b13-9abe-9dde26f44581.png)'
- en: The advantage of using such a coordinate system lies in the fact that the normal
    vectors stored within the normal map can be treated as perturbations to the true
    normal, and are independent of the object coordinate system. This avoids the need
    to transform the normals, add the perturbed normal, and renormalize. Instead,
    we can use the value in the normal map directly in the reflection model without
    any modification.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种坐标系统的优点在于，存储在法线图中的法线向量可以被视为对真实法线的扰动，并且与对象坐标系无关。这避免了需要转换法线、添加扰动法线以及重新归一化的需求。相反，我们可以在反射模型中直接使用法线图中的值，而不需要进行任何修改。
- en: 'To make all of this work, we need to evaluate the reflection model in tangent
    space. In order to do so, we transform the vectors used in our reflection model
    into tangent space in the vertex shader, and then pass them along to the fragment
    shader where the reflection model will be evaluated. To define a transformation
    from the camera (eye) coordinate system to the tangent space coordinate system,
    we need three normalized, co-orthogonal vectors (defined in eye coordinates) that
    define the tangent space system. The *z* axis is defined by the normal vector
    (*n*), the *x* axis is defined by a vector called the *tangent vector* (*t*),
    and the *y* axis is often called the *binormal vector* (*b*). A point, *P*, defined
    in camera coordinates, could then be transformed into tangent space in the following
    way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些工作正常，我们需要在切线空间中评估反射模型。为此，我们在顶点着色器中将反射模型中使用的向量转换为切线空间，然后将它们传递到片段着色器中，在那里将评估反射模型。为了定义从相机（眼睛）坐标系到切线空间坐标系的变换，我们需要三个归一化、共正交的向量（在眼睛坐标系中定义），它们定义了切线空间系统。*z*
    轴由法线向量 (*n*) 定义，*x* 轴由称为切线向量 (*t*) 的向量定义，而 *y* 轴通常称为法线向量 (*b*)。一个在相机坐标系中定义的点，*P*，可以以下述方式转换为切线空间：
- en: '![](img/05d564ec-48a3-4773-aaa1-8145d8b9cd20.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05d564ec-48a3-4773-aaa1-8145d8b9cd20.png)'
- en: In the preceding equation, *S* is the point in tangent space and *P* is the
    point in camera coordinates. In order to apply this transformation within the
    vertex shader, the OpenGL program must provide at least two of the three vectors
    that define the object local system along with the vertex position. The usual
    situation is to provide the normal vector (*n*) and the tangent vector (*t*).
    If the tangent vector is provided, the binormal vector can be computed as the
    cross product of the tangent and normal vectors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，*S* 是切线空间中的点，而 *P* 是相机坐标中的点。为了在顶点着色器中应用这种变换，OpenGL 程序必须提供定义对象局部系统的至少三个向量，以及顶点位置。通常情况下，提供法线向量
    (*n*) 和切线向量 (*t*)。如果提供了切线向量，可以通过切线向量和法线向量的叉积来计算法线向量。
- en: Tangent vectors are sometimes included as additional data in mesh data structures.
    If the tangent data is not available, we can approximate the tangent vectors by
    deriving them from the variation of the texture coordinates across the surface
    (see *Computing Tangent Space Basis Vectors for an Arbitrary Mesh*, Eric Lengyel,
    Terathon Software 3D Graphics Library, 2001, at [http://www.terathon.com/code/tangent.html](http://www.terathon.com/code/tangent.html)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 切线向量有时会被包含在网格数据结构中的附加数据中。如果切线数据不可用，我们可以通过从表面纹理坐标的变化中推导出切线向量来近似切线向量（参见*任意网格的切线空间基向量计算*，Eric
    Lengyel，Terathon Software 3D 图形库，2001，在[http://www.terathon.com/code/tangent.html](http://www.terathon.com/code/tangent.html)）。
- en: One must take care that the tangent vectors are consistently defined across
    the surface. In other words, the direction of the tangent vectors should not vary
    greatly from one vertex to its neighboring vertex. Otherwise, it can lead to ugly
    shading artifacts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，切线向量在表面上应该是一致定义的。换句话说，切线向量的方向不应该从一个顶点到其相邻顶点有太大的变化。否则，可能会导致难看的着色伪影。
- en: In the following example, we'll read the vertex position, normal vector, tangent
    vector, and texture coordinate in the vertex shader. We'll transform the position,
    normal, and tangent to camera space, and then compute the binormal vector (in
    camera space). Next, we'll compute the viewing direction (*v*) and the direction
    toward the light source (*s*) and then transform them to tangent space. We'll
    pass the tangent space *v* and *s* vectors and the (unchanged) texture coordinate
    to the fragment shader, where we'll evaluate the Blinn-Phong reflection model
    using the tangent space vectors and the normal vector retrieved from the normal
    map.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将在顶点着色器中读取顶点位置、法线向量、切线向量和纹理坐标。我们将转换位置、法线和切线到相机空间，然后计算副法线向量（在相机空间中）。接下来，我们将计算观察方向（*v*）和指向光源的方向（*s*），然后将它们转换到切线空间。我们将传递切线空间*v*和*s*向量以及（未更改的）纹理坐标到片段着色器，在那里我们将使用切线空间向量和从法线贴图中检索到的法线向量评估Blinn-Phong反射模型。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL program to provide the position in attribute location `0`,
    the normal in attribute location `1`, the texture coordinate in location `2`,
    and the tangent vector in location `3`. For this example, the fourth coordinate
    of the tangent vector should contain the *handedness* of the tangent coordinate
    system (either `-1` or `+1`). This value will be multiplied by the result of the
    cross product.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL程序以提供位置在属性位置`0`，法线在属性位置`1`，纹理坐标在位置`2`，以及切线向量在位置`3`。在此示例中，切线向量的第四个坐标应包含切线坐标系的**手性**（`-1`或`+1`）。此值将乘以叉积的结果。
- en: Load the normal map into texture unit one and the color texture into texture
    unit zero.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将法线贴图加载到纹理单元一，并将颜色纹理加载到纹理单元零。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To render an image using normal mapping, use the following shaders:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用法线贴图渲染图像时，请使用以下着色器：
- en: 'In the vertex shader, find the object local coordinate system (tangent space)
    and transform everything into that space. Pass the tangent space light direction
    and view direction to the fragment shader:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中，找到对象局部坐标系（切线空间）并将所有内容转换到该空间。将切线空间光方向和视方向传递给片段着色器：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the fragment shader, update the `blinnPhong` function to use the normal
    from the texture and to use the input variables for the light and view directions:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，更新`blinnPhong`函数以使用从纹理中获取的法线，并使用光和视方向输入变量：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader starts by transforming the vertex normal and the tangent vectors
    into eye coordinates by multiplying by the normal matrix (and renormalizing).
    The binormal vector is then computed as the cross product of the normal and tangent
    vectors. The result is multiplied by the `w` coordinate of the vertex tangent
    vector, which determines the handedness of the tangent space coordinate system.
    Its value will be either `-1` or `+1`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器首先通过乘以法线矩阵（并重新归一化）将顶点法线和切线向量转换为眼坐标。然后计算法线和切线向量的叉积作为副法线向量。结果乘以顶点切线向量的`w`坐标，这决定了切线空间坐标系统的手性。其值将是`-1`或`+1`。
- en: Next, we create the transformation matrix used to convert from eye coordinates
    to tangent space and store the matrix in `toObjectLocal`. The position is converted
    to eye space and stored in `pos`, and we compute the light direction by subtracting
    `pos` from the light position. The result is multiplied by `toObjectLocal` to
    convert it into tangent space, and the final result is stored in the output variable
    `LightDir`. This value is the direction to the light source in tangent space and
    will be used by the fragment shader in the reflection model.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个转换矩阵，用于将眼坐标转换为切线空间，并将矩阵存储在`toObjectLocal`中。位置被转换为眼空间并存储在`pos`中，我们通过从光位置减去`pos`来计算光方向。结果乘以`toObjectLocal`以将其转换为切线空间，并将最终结果存储在输出变量`LightDir`中。此值是切线空间中光源的方向，并将由反射模型中的片段着色器使用。
- en: Similarly, the view direction is computed and converted to tangent space by
    normalizing `pos` and multiplying by `toObjectLocal`. The result is stored in
    the output variable `ViewDir`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，计算视方向并将其转换为切线空间，通过归一化`pos`并乘以`toObjectLocal`。结果存储在输出变量`ViewDir`中。
- en: The texture coordinate is passed to the fragment shader unchanged by just assigning
    it to the output variable `TexCoord`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标通过仅将其分配给输出变量`TexCoord`而未更改地传递给片段着色器。
- en: In the fragment shader, the tangent space values for the light direction and
    view direction are received in the variables `LightDir` and `ViewDir`. The `blinnPhong`
    function is slightly modified from what has been used in previous recipes. The
    only parameter is the normal vector. The function computes the Blinn-Phong reflection
    model, taking the value for the diffuse reflectivity from the texture `ColorTex`, and
    uses `LightDir` and `ViewDir` for the light and view directions rather than computing
    them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，光方向和视图方向的切线空间值通过变量`LightDir`和`ViewDir`接收。`blinnPhong`函数与之前配方中使用的方法略有不同。唯一的参数是法线向量。该函数计算Blinn-Phong反射模型，从纹理`ColorTex`中获取漫反射率值，并使用`LightDir`和`ViewDir`作为光和视图方向，而不是计算它们。
- en: In the main function, the normal vector is retrieved from the normal map texture
    and stored in the variable `normal`. Since textures store values that range from
    zero to one and normal vectors have components that range from -1 to +1, we need
    to re-scale the value to that range. We do so by multiplying by `2.0` and then
    subtracting `1.0`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，从正常贴图纹理中检索法线向量并将其存储在变量`normal`中。由于纹理存储的值范围从零到一，而法线向量的分量范围从-1到+1，我们需要将值重新缩放到该范围。我们通过乘以`2.0`然后减去`1.0`来实现这一点。
- en: For some normal maps, the *z* coordinate is never negative because in tangent
    space that would correspond to a normal that points into the surface. In which
    case, we could assume that *z* ranges from 0 to 1, and use the full resolution
    of the channel for that range. However, there is no standard convention for the
    *z* coordinate.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些正常贴图，**z**坐标永远不会是负数，因为在切线空间中，这会对应于指向表面的法线。在这种情况下，我们可以假设**z**的范围从0到1，并使用该范围的完整通道分辨率。然而，对于**z**坐标没有标准约定。
- en: Finally, the `blinnPhong` function is called and is passed the `normal`. The
    `blinnPhong` function evaluates the reflection model using `LightDir`, `ViewDir`,
    and `n`, all of which are defined in tangent space. The result is applied to the
    output fragment by assigning it to `FragColor`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`blinnPhong`函数，并传递`normal`参数。`blinnPhong`函数使用`LightDir`、`ViewDir`和`n`评估反射模型，所有这些都在切线空间中定义。结果通过将其分配给`FragColor`应用于输出片段。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenenormalmap.cpp` file in the example code
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenenormalmap.cpp`文件
- en: The *Applying multiple textures* recipe
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用多个纹理**配方'
- en: Parallax mapping
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差贴图
- en: Normal maps are a great way to introduce surface detail without adding additional
    geometry.  However, they have some limitations. For example, normal maps do not
    provide parallax effects as the viewer's position changes and they don't support
    self-occlusion.  **Parallax mapping** is a technique, originally introduced in
    2001, that uses modification of texture coordinates based on a height map to simulate
    parallax and self-occlusion effects.  It requires both a **normal map** and a
    **height map**.  A height map (also called a **bump map**) is a grayscale image
    where each texel has a single scalar value representing the height of the surface
    at the texel. We can consider any height between 0 and 1 as the *true surface*,
    and then use the value in the height map as an offset from there. In this recipe,
    we'll use a value of `1.0` as the true surface, so a height map value of `0.0`
    is a distance of `1.0` *below* the true surface (see the following images).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正常贴图是一种在不增加额外几何形状的情况下引入表面细节的绝佳方法。然而，它们也有一些局限性。例如，当观察者的位置改变时，正常贴图不会提供视差效果，并且不支持自遮挡。**视差贴图**是一种技术，最初于2001年提出，它通过基于高度图修改纹理坐标来模拟视差和自遮挡效果。它需要**正常贴图**和**高度图**。高度图（也称为**凹凸贴图**）是一种灰度图像，其中每个纹理单元有一个代表该纹理单元表面高度的单一标量值。我们可以将0到1之间的任何高度视为**真实表面**，然后使用高度图中的值作为从该点开始的偏移量。在这个配方中，我们将`1.0`作为真实表面，因此高度图值为`0.0`表示距离真实表面**下方**`1.0`的距离（见以下图像）。
- en: To simulate parallax, we want to offset the texture coordinates by an amount
    that depends on the direction toward the viewer (camera). A parallax effect is
    stronger at steeper angles, so we want the offset amount to be stronger when the
    angle between the normal and the view vector (vector pointing toward the camera)
    is larger. In addition, we want to offset the texture coordinates in the same
    direction as the view vector. Similar to the normal mapping recipe, we'll work
    with tangent space.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟视差，我们希望偏移纹理坐标的量取决于指向观察者（摄像机）的方向。在更陡的角度处，视差效果更强，因此我们希望在法线和视向量（指向摄像机的向量）之间的角度较大时，偏移量更强。此外，我们希望将纹理坐标偏移到与视向量相同的方向。与法线贴图配方类似，我们将使用切线空间。
- en: 'As we discussed earlier, in tangent space, the normal vector is the same as
    the *z* axis. If *e* is the vector toward the camera in tangent space, we''ll
    use the vector pointing in the opposite direction (*v = -e*). First, let''s consider
    the case of standard normal mapping. The viewer perceives the color and normal
    at point **P**, but they should see the color and normal at point **Q**:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，在切线空间中，法向量与 *z* 轴相同。如果 *e* 是切线空间中指向摄像机的向量，我们将使用指向相反方向的向量（*v = -e*）。首先，让我们考虑标准法线贴图的情况。观察者感知到点
    **P** 处的颜色和法线，但他们应该看到点 **Q** 处的颜色和法线：
- en: '![](img/6fe28cbc-166c-46c2-ae0b-c0a8c38d9196.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fe28cbc-166c-46c2-ae0b-c0a8c38d9196.png)'
- en: Therefore, we want to offset the texture coordinates by an amount that is proportional
    to **Δx** in the preceding diagram so that the viewer sees the shading for point
    **Q**, not point **P**. You could draw a similar picture for the y-z cross-section
    as well, the results would be nearly the same.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望偏移纹理坐标的量与前面图中 **Δx** 成正比，以便观察者看到点 **Q** 的阴影，而不是点 **P** 的阴影。您也可以为 y-z
    截面绘制类似的图，结果几乎相同。
- en: 'So, what we need to do is approximate **Δx** somehow. Consider the right triangles,
    as shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要以某种方式近似 **Δx**。考虑右三角形，如图所示：
- en: '![](img/5320f83e-6bb0-42d5-8dee-15cc684af6ad.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5320f83e-6bb0-42d5-8dee-15cc684af6ad.png)'
- en: 'The value of **d** is the depth of point **Q** (below the true surface), or
    in other words: *d = 1 - h[q]*, where *h[q]* is the height of the bump map at
    point *Q*. By the rule of similar triangles, we can write the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**d** 的值是点 **Q**（在真实表面下方）的深度，换句话说：*d = 1 - h[q]*，其中 *h[q]* 是点 *Q* 处的凹凸贴图的高度。根据相似三角形的规则，我们可以写出以下公式：'
- en: '![](img/b906fae2-2c75-4929-878b-36f7eb329ca4.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b906fae2-2c75-4929-878b-36f7eb329ca4.png)'
- en: 'Applying the same analysis for *y*, we get the following pair of offsets:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *y* 应用相同的分析，我们得到以下一对偏移量：
- en: '![](img/95722ae0-94ef-47b7-b300-f346ec34a4af.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95722ae0-94ef-47b7-b300-f346ec34a4af.png)'
- en: Unfortunately, we don't have a value for *d* in the preceding equations, because
    we don't know the value for *Q*. There's no way of quickly finding it either;
    we'd need to trace a ray through the height map (which is what we'll do in the
    next recipe). So for now, we'll just approximate *d* by using the height (depth)
    at *P (1 - h[p])*. It is a rough estimate, but if we assume the height map doesn't
    have a lot of really high frequency variation, it works fairly well in practice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们前面方程中没有 *d* 的值，因为我们不知道 *Q* 的值。也没有快速找到它的方法；我们需要通过高度图（我们将在下一个菜谱中这样做）追踪一条射线。因此，现在我们只是通过使用
    *P* 处的高度（深度）（1 - h[p]）来近似 *d*。这是一个粗略的估计，但如果假设高度图没有很多真正的高频变化，在实践中它工作得相当好。
- en: 'Therefore, we have the following equation for offsetting a texture coordinate
    (*P*) at a given surface point:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于给定表面点偏移纹理坐标（*P*），我们有以下方程：
- en: '![](img/2bbfd56e-7731-49c6-b0b3-2eab96d7928f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bbfd56e-7731-49c6-b0b3-2eab96d7928f.png)'
- en: In the preceding equation, *S* is a scale factor that can be used to restrict
    the magnitude of the effect and to scale it to texture space. It is usually a
    very small value (between 0 and 0.05), and may need to be tuned to a particular
    surface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方程中，*S* 是一个缩放因子，可以用来限制效果的幅度并将其缩放到纹理空间。它通常是一个非常小的值（介于 0 和 0.05 之间），可能需要针对特定表面进行调整。
- en: 'The following images show the effect compared to basic normal mapping. On the
    left, a single quad rendered with simple normal mapping, and on the right is the
    same geometry using normal mapping, along with parallax mapping:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了与基本法线贴图相比的效果。在左侧，使用简单法线贴图渲染的单个四边形，在右侧是使用法线贴图和视差贴图的相同几何形状：
- en: '![](img/41225a36-26c2-4e0a-b1ac-2696d450d366.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41225a36-26c2-4e0a-b1ac-2696d450d366.png)'
- en: The effect is admittedly quite subtle, and there are some undesirable artifacts
    in this example, but the overall effect is clear. Note that both images use the
    same geometry, camera position, and texture maps. If you focus on the bricks in
    the distance (furthest from the viewer), you can see some simulation of occlusion,
    and overall the effect is more realistic on the right.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果确实相当微妙，这个例子中也有一些不希望出现的伪影，但整体效果是清晰的。注意，这两张图片使用了相同的几何形状、相机位置和纹理图。如果你专注于远处的砖块（离观察者最远），你可以看到一些遮挡的模拟，并且整体效果在右边更真实。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For parallax mapping, we need three textures: a height map texture, a normal
    map texture, and a color texture. We could combine the height map and normal map
    into a single texture, storing the height values in the alpha channel and the
    normal in the R, G, and B. This is a common technique and saves a significant
    amount of disk and memory space. In this recipe, we''ll treat them as separate
    textures.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视差映射，我们需要三个纹理：一个高度图纹理、一个法线图纹理和一个颜色纹理。我们可以将高度图和法线图合并到一个纹理中，将高度值存储在alpha通道中，将法线存储在R、G和B中。这是一个常见的技巧，可以显著节省磁盘和内存空间。在这个配方中，我们将它们视为单独的纹理。
- en: We also need a mesh with tangent vectors as well so that we can transform into
    tangent space. For more information on tangent space, see the previous recipe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个具有切线向量的网格，这样我们就可以转换到切线空间。有关切线空间更多信息，请参阅之前的配方。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We can use the same vertex shader as was used in the previous recipe, *Using
    normal maps*.  The vertex shader transforms the view direction and the light direction
    and passes them to the fragment shader. It also passes along the texture coordinate.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与之前配方中相同的顶点着色器，即*使用法线图*。顶点着色器变换视图方向和光方向，并将它们传递给片段着色器。它还传递纹理坐标。
- en: 'The fragment shader uses the tangent space view direction and the height map
    value at the current texture coordinate to offset the texture coordinates. It
    then uses the new texture coordinate value to do shading as usual:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器使用切线空间视图方向和当前纹理坐标处的高度图值来偏移纹理坐标。然后它使用新的纹理坐标值像往常一样进行着色：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `blinnPhong` method within the fragment shader, we start by computing
    the offset for the texture coordinate (the `delta` variable ). The `bumpFactor` constant
    is generally somewhere between 0 and 0.05.  In this case, we use `0.015`, but
    you'll need to tune this for your particular normal/height map. We offset the
    texture coordinate by the value of delta. We subtract rather than add here because
    `ViewDir` is actually pointing toward the viewer, so we need to offset in the
    opposite direction. Note that we also invert the height value, as discussed in
    the preceding analysis. Using the offset texture coordinate (`tc`), we compute
    the shading using the Blinn-Phong model with data from the normal map and color
    texture.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中的`blinnPhong`方法中，我们首先计算纹理坐标的偏移量（`delta`变量）。`bumpFactor`常量通常在0和0.05之间。在这种情况下，我们使用`0.015`，但你需要根据你特定的法线/高度图调整这个值。我们通过delta的值偏移纹理坐标。我们在这里减去而不是加上，因为`ViewDir`实际上是指向观察者的，所以我们需要朝相反的方向偏移。注意，我们还在前面分析中讨论了反转高度值。使用偏移的纹理坐标（`tc`），我们使用Blinn-Phong模型和法线图以及颜色纹理的数据来计算着色。
- en: There's more...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Parallax mapping produces subtle but pleasing effects. However, it does suffer
    from some undesirable artifacts such as so-called **texture swim** and performs
    poorly with bump maps that have steep bumps or high frequency bumps. An improvement
    to parallax mapping that performs better is called steep parallax mapping, which
    is discussed in the next recipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 视差映射产生微妙但令人愉悦的效果。然而，它确实存在一些不希望出现的伪影，例如所谓的**纹理游动**，并且在与具有陡峭的凹凸或高频凹凸的凹凸图一起使用时表现不佳。一种性能更好的视差映射改进称为倾斜视差映射，将在下一个配方中讨论。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/sceneparallax.cpp` file in the example code
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/sceneparallax.cpp`文件
- en: Steep parallax mapping with self shadowing
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倾斜视差映射与自阴影
- en: This recipe builds on the previous one, parallax mapping, so if you haven't
    already done so, you may want to review that recipe prior to reading this one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于之前的配方，即视差映射，所以如果你还没有这样做，你可能想在阅读这个配方之前回顾一下那个配方。
- en: '**Steep parallax mapping** is a technique, first published by Morgan McGuire
    and Max McGuire in 2005\. It improves upon parallax mapping, producing much better
    results at the cost of more fragment shader work. Despite the additional cost,
    the algorithm is still well suited to real-time rendering on modern GPUs.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**陡峭的视差映射**是一种技术，首次由 Morgan McGuire 和 Max McGuire 在 2005 年发表。它改进了视差映射，以更高的片段着色器工作量为代价，产生了更好的结果。尽管有额外的成本，但该算法仍然非常适合现代
    GPU 的实时渲染。'
- en: 'The technique involves tracing the eye ray through the height map in discrete
    steps until a collision is found in order to more precisely determine the appropriate
    offset for the texture coordinate. Let''s revisit the diagram from the previous
    recipe, but this time, we''ll break up the height map into **n** discrete levels
    (indicated by the dashed lines):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术涉及通过高度图进行离散步骤追踪视线光线，直到找到碰撞，以便更精确地确定纹理坐标的适当偏移。让我们回顾一下之前食谱中的图表，但这次，我们将高度图分解为
    **n** 个离散级别（由虚线表示）：
- en: '![](img/3a5892c0-3ea7-43e8-95d3-64e5f001efa2.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a5892c0-3ea7-43e8-95d3-64e5f001efa2.png)'
- en: As before, our goal is to offset the texture coordinates so that the surface
    is shaded based on the bump surface, not the true surface. The point **P** is
    the surface point on the polygon being rendered. We trace the view vector from
    point **P** to each level consecutively until we find a point that lies on or
    below the bump surface. In the following image, we'll find the point **Q** after
    three iterations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们的目标是偏移纹理坐标，以便根据凹凸表面而不是真实表面进行着色。点 **P** 是正在渲染的多边形上的表面点。我们从点 **P** 开始，依次追踪视图向量到每个级别，直到找到一个位于或低于凹凸表面的点。在以下图像中，我们将经过三次迭代找到点
    **Q**。
- en: 'As in the previous recipe, we can derive the change in **x** and **y** for
    a single iteration using similar triangles (see the *Parallax mapping* recipe):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的食谱一样，我们可以使用相似三角形推导出单次迭代的 **x** 和 **y** 的变化（参见 *视差映射* 食谱）。
- en: '![](img/ea7dcad2-e8b6-405f-942d-1d2b69297d36.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea7dcad2-e8b6-405f-942d-1d2b69297d36.png)'
- en: As before, the scale factor (*S*) is used to vary the influence of the effect
    and to scale it to texture space. *n* is the number of height levels.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，使用相似三角形（参见 *视差映射* 食谱）我们可以推导出单次迭代的 **x** 和 **y** 的变化。
- en: Using this equation, we can step through the height levels, starting at *P*
    and following the view vector away from the camera. We continue until we find
    a point that lies on or below the surface of the height map. We then use the texture
    coordinate at that point for shading.  Essentially, we're implementing a very
    simple ray marcher in the fragment shader.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方程，我们可以逐步通过高度级别，从 *P* 点开始，沿着视图向量远离相机。我们继续直到找到一个位于或低于高度图表面的点。然后我们使用该点的纹理坐标进行着色。本质上，我们正在片段着色器中实现一个非常简单的光线追踪器。
- en: 'The results are impressive. The following image shows three versions of the
    same surface for comparison. On the left is the surface with normal map applied.
    The middle image is the same surface rendered with parallax mapping. The right-hand
    image is generated using steep parallax mapping. All three images use the same
    normal map, height map, geometry, and camera position. They are all rendered as
    a single quad (two triangles). Note how the steep parallax shows the varying height
    of each brick. The height of each brick was always included in the height map,
    but the parallax mapping technique didn''t make it noticeable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人印象深刻。以下图像显示了同一表面的三个版本，以进行比较。左侧是应用了法线图的表面。中间图像是使用视差映射渲染的同一表面。右手边的图像是使用陡峭的视差映射生成的。所有三幅图像都使用了相同的法线图、高度图、几何形状和相机位置。它们都被渲染为一个四边形（两个三角形）。注意陡峭的视差如何显示每个砖块的变高。每个砖块的高度始终包含在高度图中，但视差映射技术并没有使其明显：
- en: '![](img/73ed96f0-c548-4311-a705-340a1f23d363.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73ed96f0-c548-4311-a705-340a1f23d363.png)'
- en: 'You may have noticed that the image on the right also includes shadows. Some
    bricks cast shadows onto other bricks. This is accomplished with a simple addition
    to the preceding technique. Once we find point **Q**, we march another ray in
    the direction of the light source.  If that ray collides with the surface, the
    point is in shadow and we shade with ambient lighting only. Otherwise, we shade
    the point normally. The following diagram illustrates this idea:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到右边的图像也包括了阴影。一些砖块投射阴影到其他砖块上。这是通过在先前的技术基础上简单添加实现的。一旦我们找到点 **Q**，我们就向光源方向发射另一条光线。如果那条光线与表面碰撞，那么该点处于阴影中，我们只使用环境光照进行着色。否则，我们正常着色该点。以下图表说明了这个想法：
- en: '![](img/1daaac37-edbd-4811-8a3d-e826c40b9779.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1daaac37-edbd-4811-8a3d-e826c40b9779.png)'
- en: In the preceding diagram, point **Q** is in shadow and point **T** is not. In
    each case, we march the ray along the direction toward the light source (**s**).
    We evaluate the height map at each discrete height level. In the case of point
    **Q**, we find a point that lies below the bump surface, but for point **T**,
    all points lie above it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，点 **Q** 处于阴影中，而点 **T** 则不是。在每种情况下，我们沿着指向光源的方向（**s**）追踪光线。我们在每个离散高度级别上评估高度图。在点
    **Q** 的情况下，我们找到一个位于凹凸表面的点下方，但对于点 **T**，所有点都位于其上方。
- en: The ray marchine process is nearly identical to that described before for the
    view vector. We start at point **Q** and move along the ray toward the light.
    If we find a point that is below the surface, then the point is occluded from
    the light source. Otherwise, the point is shaded normally. We can use the same
    equation we used for marching the view vector, replacing the view vector with
    the vector toward the light source.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪过程几乎与之前描述的用于视图向量的过程相同。我们从点 **Q** 开始，沿着光线向光源移动。如果我们找到一个位于表面的点，那么该点被光源遮挡。否则，该点将正常着色。我们可以使用用于追踪视图向量的相同方程，将视图向量替换为指向光源的向量。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this algorithm, we need a height map, a normal map, and a color map. We
    also need tangent vectors in our mesh so that we can transform into tangent space.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此算法，我们需要一个高度图、一个法线图和一个颜色图。我们还需要在网格中具有切线向量，以便我们可以转换到切线空间。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The vertex shader is the same as the one used in the *Parallax mapping* recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器与 *Parallax mapping* 菜单中使用的相同。
- en: 'In the fragment shader, we break the process into two functions: `findOffset`
    and `isOccluded`.  The first traces the view vector to determine the texture coordinate
    offset.  The second traces the light vector to determine whether or not the point
    is in shadow:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们将过程分为两个函数：`findOffset` 和 `isOccluded`。第一个函数追踪视图向量以确定纹理坐标偏移。第二个函数追踪光线向量以确定该点是否处于阴影中：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `findOffset` function determines the texture coordinate to use when shading.
    We pass in the vector *toward* the viewer (we negate the direction to move away
    from the eye), and the function returns the texture coordinate. It also returns
    the value of the height at that location via the output parameter `height`. The
    first line determines the number of discrete height levels (`nSteps`). We pick
    a number between 10 and 60 by interpolating using the value of the *z* coordinate
    of the view vector. If the *z* coordinate is small, then the view vector is close
    to vertical with respect to the height levels. When the view vector is close to
    vertical, we can use fewer steps because the ray travels a shorter relative horizontal
    distance between levels. However, when the vector is closer to horizontal, we
    need more steps as the ray travels a larger horizontal distance when moving from
    one level to the next.  The `deltaT` variable is the amount that we move through
    texture space when moving from one height level to the next. This is the second
    term in the equation listed previously.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOffset` 函数用于确定在着色时使用的纹理坐标。我们传入指向观察者的向量 *toward*（我们取反方向以远离眼睛），函数返回纹理坐标。它还通过输出参数
    `height` 返回该位置的高度值。第一行确定离散高度级别数 (`nSteps`)。我们通过插值使用视图向量的 *z* 坐标值来选择一个介于 10 和 60
    之间的数字。如果 *z* 坐标值较小，那么视图向量相对于高度级别几乎是垂直的。当视图向量接近垂直时，我们可以使用较少的步数，因为光线在级别之间的相对水平距离较短。然而，当向量接近水平时，我们需要更多的步数，因为光线在从一个级别移动到下一个级别时需要穿越更大的水平距离。`deltaT`
    变量是我们从一个高度级别移动到下一个高度级别时在纹理空间中移动的量。这是之前列出的方程中的第二个项。'
- en: The ray marching proceeds with the following loop. The `ht` variable tracks
    the height level. We start it at `1.0`. The `height` variable will be the value
    of the height map at the current position. The `tc` variable will track our movement
    through texture space, initially at the texture coordinate of the fragment (`TexCoord`).
    We look up the value in the height map at `tc`, and then enter the loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 光线追踪过程通过以下循环进行。`ht` 变量跟踪高度级别。我们将其初始化为 `1.0`。`height` 变量将是当前位置的高度图值。`tc` 变量将跟踪我们在纹理空间中的移动，最初位于片段的纹理坐标
    (`TexCoord`)。我们在 `tc` 处查找高度图中的值，然后进入循环。
- en: The loop continues until the value in the height map (`height`) is less than
    the value of the discrete height level (`ht`). Within the loop, we change `ht`
    to move down one level and update the texture coordinate by `deltaT`. Note that
    we subtract `deltaT` because we are moving away from the viewer. Then, we look
    up the value of the height map (`height`) at the new texture coordinate and repeat.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会一直持续到高度图中的值（`height`）小于离散高度级别（`ht`）的值。在循环内部，我们改变`ht`以向下移动一个级别，并通过`deltaT`更新纹理坐标。请注意，我们减去`deltaT`是因为我们正在远离观察者。然后，我们在新的纹理坐标处查找高度图（`height`）的值并重复。
- en: When the loop terminates, `tc` should have the value of the offset texture coordinate,
    and `height` is the value in the height map at that location. We return `tc`,
    and the value of `height` at the end of the loop is also returned to the caller
    via the output parameter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，`tc`应该有偏移纹理坐标的值，而`height`是高度图中该位置的值。我们返回`tc`，循环结束时`height`的值也通过输出参数返回给调用者。
- en: Note that this loop isn't correct when we are viewing the back side of the face.
    However, the loop will still terminate at some point because we always decrease
    `ht` and the height map texture is assumed to be between 0 and 1\. If back faces
    are visible, we need to modify this to properly follow the ray or invert the normal.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们查看面的背面时，这个循环是不正确的。然而，循环最终会在某个点上终止，因为我们总是减少`ht`，并且假设高度图纹理在0和1之间。如果背面可见，我们需要修改这一点以正确地跟随射线或反转法线。
- en: The `isOccluded` function returns whether or not the light source is occluded
    by the height map at that point. It is quite similar to the `findOffset` function.
    We pass in `height` previously determined by `findOffset`, the corresponding texture
    coordinate (`tc`), and the direction toward the light source (`s`). Similar to
    `findOffset`, we march the ray in the direction of `s`, beginning at the height
    and texture coordinate provided. Note that we begin the loop with a value for
    `ht` that is slightly offset from the value of the bump map there (`ht= height
    + htStep * 0.1`).  This is to avoid the so-called **shadow acne** effect. If we
    don't offset it, we can sometimes get *false positives* when the ray collides
    with the surface that it starts on, producing speckled shadows.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOccluded`函数返回光源是否在该点被高度图遮挡。它与`findOffset`函数非常相似。我们传递由`findOffset`先前确定的`height`，相应的纹理坐标（`tc`）以及指向光源的方向（`s`）。类似于`findOffset`，我们在提供的高度和纹理坐标处沿着`s`的方向行进射线。请注意，我们开始循环时`ht`的值稍微偏离了那里的凹凸图值（`ht=
    height + htStep * 0.1`）。这是为了避免所谓的**阴影痤疮**效应。如果我们不偏移它，有时当射线与它开始的表面碰撞时，我们可能会得到*假阳性*，产生斑驳的阴影。'
- en: The rest of the function contains a loop that is quite similar to the loop in
    `findOffset`.  However, we move upward through the height levels, and we are careful
    to stop when the value of `ht` reaches or exceeds 1.0.  At the end of the loop,
    we don't need the values of `height` or `tc`; we only need to know whether or
    not the loop stopped due to the first of the two conditions.  If `ht < 1.0`, then
    we exit the loop before exceeding the range of the height map, indicating that
    we found a point along the ray that had a larger height.  Therefore, the point
    must be in shadow, so we return true. Otherwise, the light source is unoccluded,
    so we return false.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的其余部分包含一个与`findOffset`中的循环非常相似的循环。然而，我们向上通过高度级别，并且我们小心地停止当`ht`的值达到或超过1.0时。循环结束时，我们不需要`height`或`tc`的值；我们只需要知道循环是否由于第一个条件而停止。如果`ht
    < 1.0`，那么我们在超过高度图范围之前退出循环，这表明我们在射线上找到了一个高度更大的点。因此，该点必须在阴影中，所以我们返回true。否则，光源没有被遮挡，所以我们返回false。
- en: The `blinnPhong` function calls `findOffset` to determine the appropriate texture
    coordinates to use.  It then looks up the values in the normal map and color map
    at that location.  Next, it evaluates the Blinn-Phong reflection model using those
    values. However, it uses the `isOccluded` function to determine whether or not
    we should include diffuse and specular components. We also won't evaluate those
    components if the value of `sDotN` is less than or equal to zero, meaning that
    the light is behind (or tangent to) the face, as determined by the shading normal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`blinnPhong`函数调用`findOffset`来确定适当的纹理坐标。然后，它在那个位置的法线贴图和颜色贴图中查找值。接下来，它使用这些值评估Blinn-Phong反射模型。然而，它使用`isOccluded`函数来确定是否应该包含漫反射和镜面反射成分。如果`sDotN`的值小于或等于零，我们也不会评估这些成分，这意味着光线在（或与）面成切线，这是由着色法线确定的。'
- en: See also
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/sceneparallax.cpp` file in the example code
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/sceneparallax.cpp`文件
- en: Simulating reflection with cube maps
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立方体贴图模拟反射
- en: Textures can be used to simulate a surface that has a component that is purely
    reflective (a mirror-like surface such as chrome). In order to do so, we need
    a texture that is representative of the environment surrounding the reflective
    object. This texture could then be mapped onto the surface of the object in a
    way that represents how it would look when reflected off the surface. This general
    technique is known as **environment ****mapping**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理可以用来模拟具有纯反射成分的表面（如铬一样的镜面）。为了做到这一点，我们需要一个代表反射物体周围环境的纹理。然后，这个纹理可以以代表其反射外观的方式映射到物体的表面上。这种通用技术被称为**环境映射**。
- en: In general, environment mapping involves creating a texture that is representative
    of the environment and mapping it onto the surface of an object. It is typically
    used to simulate the effects of reflection or refraction.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，环境映射涉及创建一个代表环境的纹理，并将其映射到物体的表面上。它通常用于模拟反射或折射的效果。
- en: 'A **cube ****map** is one of the more common varieties of textures used in
    environment mapping. A cube map is a set of six separate images that represent
    the environment projected onto each of the six faces of a cube. The six images
    represent a view of the environment from the point of view of a viewer located
    at the center of the cube. An example of a cube map is shown in the following
    image. The images are laid out as if the cube was *unfolded* and laid flat. The
    four images across the middle would make up the sides of the cube, and the top
    and bottom images correspond to the top and bottom of the cube:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**立方体贴图**是环境映射中使用的纹理的更常见类型之一。立方体贴图是一组六个单独的图像，代表环境投影到立方体的六个面上。这六个图像代表从位于立方体中心的观察者视角看环境。以下图像显示了立方体贴图的一个示例。图像被排列成好像立方体被*展开*并平铺开来。中间的四张图像将组成立方体的侧面，顶部和底部的图像对应于立方体的顶部和底部：'
- en: '![](img/f5ed0318-06f2-4960-a0ac-df9ed3bf79bb.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ed0318-06f2-4960-a0ac-df9ed3bf79bb.png)'
- en: OpenGL provides built-in support for cube map textures (using the `GL_TEXTURE_CUBE_MAP`
    target). The texture is accessed using a three-dimensional texture coordinate
    (s, t, r). The texture coordinate is interpreted as a direction vector from the
    center of the cube. The line defined by the vector and the center of the cube
    is extended to intersect one of the faces of the cube. The image that corresponds
    to that face is then accessed at the location of the intersection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL提供了对立方体贴图纹理的内置支持（使用`GL_TEXTURE_CUBE_MAP`目标）。纹理通过三维纹理坐标（s, t, r）访问。纹理坐标被解释为从立方体中心出发的方向向量。由该向量与立方体中心定义的线被延伸以与立方体的一个面相交。然后，在交点位置访问对应于该面的图像。
- en: Truth be told, the conversion between the three-dimensional texture coordinate
    used to access the cube map and the two-dimensional texture coordinate used to
    access the individual face image is somewhat complicated. It can be non-intuitive
    and confusing. A very accessible explanation can be found in the OpenGL specification
    document ( [https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php)
    ).  However, the good news is that if you are careful to orient your textures
    correctly within the cube map, the details of the conversion can be ignored and
    the texture coordinate can be visualized as a three-dimensional vector as described
    previously.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，用于访问立方体贴图的三维纹理坐标和用于访问单个面图像的两个维纹理坐标之间的转换有些复杂。它可能不太直观，令人困惑。OpenGL规范文档中可以找到一个非常易于理解的解释（[https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php)）。然而，好消息是，如果你小心地在立方体贴图中定位纹理，可以忽略转换的细节，并将纹理坐标可视化为前面描述的三维向量。
- en: In this example, we'll demonstrate using a cube map to simulate a reflective
    surface. We'll also use the cube map to draw the environment around the reflective
    object (sometimes called a **skybox**).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将演示使用立方体贴图来模拟反射表面。我们还将使用立方体贴图来绘制反射对象周围的环境（有时称为**天空盒**）。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, prepare the six images of the cube map. In this example, the images will
    have the following naming convention. There is a base name (stored in the `baseFileName` variable)
    followed by an underscore, followed by one of the six possible suffixes (`posx`,
    `negx`, `posy`, `negy`, `posz`, or `negz`), followed by the file extension. The
    suffixes `posx`, `posy`, and so on, indicate the axis that goes through the center
    of the face (positive *x*, positive *y*, and so on).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，准备六个立方体贴图图像。在这个例子中，图像将遵循以下命名约定。有一个基本名称（存储在`baseFileName`变量中），后面跟着一个下划线，然后是六个可能的后缀之一（`posx`、`negx`、`posy`、`negy`、`posz`或`negz`），最后是文件扩展名。后缀`posx`、`posy`等表示通过面中心的轴（正*x*、正*y*等）。
- en: Make sure that they are all square images (preferably with dimensions that are
    a power of two), and that they are all the same size.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它们都是正方形图像（最好是边长为二的幂的尺寸），并且它们都是相同的大小。
- en: Set up your OpenGL program to provide the vertex position in attribute location
    0, and the vertex normal in attribute location 1.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL程序，以便在属性位置0提供顶点位置，在属性位置1提供顶点法线。
- en: This vertex shader requires the model matrix (the matrix that converts from
    object coordinates to world coordinates) to be separated from the model-view matrix
    and provided to the shader as a separate uniform. Your OpenGL program should provide
    the model matrix in the uniform variable `ModelMatrix`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此顶点着色器需要将模型矩阵（将对象坐标转换为世界坐标的矩阵）与视图矩阵分开，并作为单独的统一变量提供给着色器。你的OpenGL程序应在统一变量`ModelMatrix`中提供模型矩阵。
- en: The vertex shader also requires the location of the camera in world coordinates.
    Make sure that your OpenGL program sets the uniform `WorldCameraPosition` to the
    appropriate value.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器还需要世界坐标中摄像机的位置。确保你的OpenGL程序将统一变量`WorldCameraPosition`设置为适当的值。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To render an image with reflection based on a cube map, and also render the
    cube map itself, carry out the following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据立方体贴图渲染具有反射效果的图像，并渲染立方体贴图本身，执行以下步骤：
- en: 'We''ll start by defining a function that will load the six images of the cube
    map into a single texture target:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个函数，该函数将六个立方体贴图图像加载到单个纹理目标中：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the following code for the vertex shader:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行顶点着色器：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行片段着色器：
- en: '[PRE20]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the render portion of the OpenGL program, draw a cube centered at the origin
    and apply the cube map to the cube. You can use the normalized position as the
    texture coordinate. Use a separate shader for this sky box. See the example code
    for details.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL程序的渲染部分，绘制一个以原点为中心的立方体，并将立方体贴图应用于立方体。你可以使用归一化位置作为纹理坐标。为此天空盒使用单独的着色器。请参阅示例代码以获取详细信息。
- en: Switch to the preceding shaders and draw the object(s) within the scene.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到前面的着色器，并在场景中绘制对象（们）。
- en: How it works...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In OpenGL, a cube map texture consists of six separate images. To fully initialize
    a cube map texture, we need to bind to the cube map texture and then load each
    image individually into the six "slots" within that texture. In the preceding
    code (within the `Texture::loadCubeMap` function), we start by binding to texture
    unit zero with `glActiveTexture`. Then, we create a new texture object by calling
    `glGenTextures`, store its handle within the variable `texID`, and then bind that
    texture object to the `GL_TEXTURE_CUBE_MAP` target using `glBindTexture`. We load
    the first image to determine the dimensions of the image, and then load the others
    in a loop. The following loop loads each texture file and copies the texture data
    into OpenGL memory using `glTexSubImage2D`. Note that the first argument to this
    function is the texture target, which corresponds to `GL_TEXTURE_CUBE_MAP_POSITIVE_X
    + i`. OpenGL defines consecutive constants that correspond to the six faces of
    the cube, so we can just add an integer to the value of the constant for the first
    face. After the loop is finished, the cube map texture should be fully initialized
    with the six images.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，立方体贴图纹理由六个单独的图像组成。为了完全初始化立方体贴图纹理，我们需要绑定到立方体贴图纹理，然后将每个图像单独加载到该纹理中的六个“槽位”中。在前面的代码（在`Texture::loadCubeMap`函数中），我们首先使用`glActiveTexture`绑定到纹理单元零。然后，通过调用`glGenTextures`创建一个新的纹理对象，将其句柄存储在变量`texID`中，并使用`glBindTexture`将该纹理对象绑定到`GL_TEXTURE_CUBE_MAP`目标。我们首先加载第一个图像以确定图像的尺寸，然后在一个循环中加载其他图像。下面的循环加载每个纹理文件，并使用`glTexSubImage2D`将纹理数据复制到OpenGL内存中。请注意，该函数的第一个参数是纹理目标，对应于`GL_TEXTURE_CUBE_MAP_POSITIVE_X
    + i`。OpenGL定义了一系列连续的常量，对应于立方体的六个面，因此我们可以只需将一个整数加到第一个面的常量值上。循环完成后，立方体贴图纹理应该已经完全初始化，包含六个图像。
- en: Following this, we set up the cube map texture environment. We use linear filtering,
    and we also set the texture wrap mode to `GL_CLAMP_TO_EDGE` for all three of the
    texture coordinate's components. This tends to work well, avoiding the possibility
    of a border color appearing between the cube edges.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们设置立方体贴图纹理环境。我们使用线性过滤，并将纹理包裹模式设置为所有三个纹理坐标分量的`GL_CLAMP_TO_EDGE`。这通常效果很好，避免了在立方体边缘之间出现边界颜色的可能性。
- en: Even better would be to use seamless cube map textures (available since OpenGL
    3.2).  It is a simple matter to enable them, just call:` glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS)`
    .
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是使用无缝立方体贴图纹理（自OpenGL 3.2以来可用）。启用它们很简单，只需调用：`glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS)`。
- en: Within the vertex shader, the main goal is to compute the direction of reflection
    and pass that to the fragment shader to be used to access the cube map. The output
    variable `ReflectDir` will store this result. We can compute the reflected direction
    (in world coordinates) by reflecting the vector toward the viewer about the normal
    vector.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，主要目标是计算反射方向，并将其传递到片段着色器中用于访问立方体贴图。输出变量`ReflectDir`将存储此结果。我们可以通过在法线向量周围反射指向观察者的向量来计算反射方向（在世界坐标中）。
- en: We choose to compute the reflection direction in world coordinates because,
    if we were to use eye coordinates, the reflection would not change as the camera
    moved within the scene.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择在世界坐标中计算反射方向，因为如果我们使用眼睛坐标，那么当相机在场景内移动时，反射不会改变。
- en: In the `else` branch within the main function, we start by converting the position
    to world coordinates and storing them in `worldPos`. We then do the same for the
    normal, storing the result in `worldNorm`. Note that the `ModelMatrix` is used
    to transform the vertex normal. It is important when doing this to use a value
    of `0.0` for the fourth coordinate of the normal to avoid the translation component
    of the model matrix affecting the normal. Also, the model matrix must not contain
    any non-uniform scaling component; otherwise the normal vector will be transformed
    incorrectly.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数的`else`分支中，我们首先将位置转换为世界坐标，并将它们存储在`worldPos`中。然后，我们对法线做同样的处理，将结果存储在`worldNorm`中。请注意，`ModelMatrix`用于转换顶点法线。在进行这一操作时，为了防止模型矩阵的平移分量影响法线，法线的第四个坐标必须使用`0.0`的值。此外，模型矩阵不得包含任何非均匀缩放分量；否则，法线向量将被错误地转换。
- en: The direction toward the viewer is computed in world coordinates and stored
    in `worldView`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者的方向在世界坐标中计算并存储在`worldView`中。
- en: Finally, we reflect `worldView` about the normal and store the result in the
    output variable `ReflectDir`. The fragment shader will use this direction to access
    the cube map texture and apply the corresponding color to the fragment. One can
    think of this as a light ray that begins at the viewer's eye, strikes the surface,
    reflects off the surface, and hits the cube map. The color that the ray *sees*
    when it strikes the cube map is the color that we need for the object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`worldView`关于法线进行反射，并将结果存储在输出变量`ReflectDir`中。片段着色器将使用这个方向来访问立方体贴图纹理，并将相应的颜色应用到片段上。可以将其想象为从观察者的眼睛开始，击中表面，从表面反射，并击中立方体贴图的光线。光线击中立方体贴图时看到的颜色就是我们需要的物体颜色。
- en: When drawing the sky box, we use the vertex position as the reflection direction.
    Why? Well, when the sky box is rendered, we want the location on the sky box to
    correspond to the equivalent location in the cube map (the sky box is really just
    a rendering of the cube map).  Therefore, if we want to access a position on the
    cube map corresponding to a location on a cube centered at the origin, we need
    a vector that points at that location. The vector we need is the position of that
    point minus the origin (which is (0,0,0)). Hence, we just need the position of
    the vertex.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制天空盒时，我们使用顶点位置作为反射方向。为什么？好吧，当渲染天空盒时，我们希望天空盒上的位置与立方体贴图中的等效位置相对应（天空盒实际上只是立方体贴图的一种渲染）。因此，如果我们想访问与原点为中心的立方体上的位置相对应的立方体贴图上的位置，我们需要一个指向该位置的向量。我们需要的是该点的位置减去原点（即(0,0,0)）。因此，我们只需要顶点的位置。
- en: Sky boxes can be rendered with the viewer at the center of the sky box and the
    sky box moving along with the viewer (so the viewer is always at the center of
    the sky box). We have not done so in this example; however, we could do so by
    transforming the sky box using the rotational component of the view matrix (not
    the translational).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒可以以观察者位于天空盒中心，天空盒随着观察者移动的方式进行渲染（因此观察者始终位于天空盒中心）。在这个例子中我们没有这样做；然而，我们可以通过使用视图矩阵的旋转分量（而不是平移分量）来变换天空盒来实现这一点。
- en: 'Within the fragment shader, we simply use the value of `ReflectDir` to access
    the cube map texture:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们直接使用`ReflectDir`的值来访问立方体贴图纹理：
- en: '[PRE21]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll mix the sky box color with some material color. This allows us to provide
    some slight *tint* to the object. The amount of tint is adjusted by the variable
    `ReflectFactor`. A value of 1.0 would correspond to zero tint (all reflection),
    and a value of 0.0 corresponds to no reflection. The following images show a teapot
    rendered with different values of `ReflectFactor`. The teapot on the left uses
    a reflection factor of 0.5, and the one on the right uses a value of 0.85\. The
    base material color is grey (the cube map used is an image of St. Peter''s Basilica,
    Rome. ©Paul Debevec):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将天空盒颜色与一些材质颜色混合。这允许我们对物体提供一些轻微的*色调*。色调的量由变量`ReflectFactor`调整。1.0的值对应于零色调（全部反射），而0.0的值对应于无反射。以下图像显示了使用不同`ReflectFactor`值渲染的茶壶。左边的茶壶使用反射系数为0.5，而右边的茶壶使用值为0.85。基本材质颜色为灰色（使用的立方体贴图是罗马圣彼得大教堂的图像。©Paul
    Debevec）：
- en: '![](img/9d226a80-2d22-4b93-bbd7-71654f499ff8.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d226a80-2d22-4b93-bbd7-71654f499ff8.png)'
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two important points to keep in mind about this technique. First,
    the objects will only reflect the environment map. They will not reflect the image
    of any other objects within the scene. In order to do so, we would need to generate
    an environment map from the point of view of each object by rendering the scene
    six times with the view point located at the center of the object and the view
    direction in each of the six coordinate directions. Then, we could use the appropriate
    environment map for the appropriate object's reflections. Of course, if any of
    the objects were to move relative to one another, we'd need to regenerate the
    environment maps. All of this effort may be prohibitive in an interactive application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种技术有两个重要点需要注意。首先，物体只会反射环境贴图。它们不会反射场景中任何其他物体的图像。为了做到这一点，我们需要从每个物体的视角生成环境贴图，通过在物体中心以六个坐标方向中的每个方向渲染场景六次来实现。然后，我们可以为适当的物体的反射使用适当的环境贴图。当然，如果任何物体相对于彼此移动，我们需要重新生成环境贴图。所有这些努力可能在一个交互式应用程序中是过于限制性的。
- en: The second point involves the reflections that appear on moving objects. In
    these shaders, we compute the reflection direction and treat it as a vector emanating
    from the center of the environment map. This means that regardless of where the
    object is located, the reflections will appear as if the object is in the center
    of the environment. In other words, the environment is treated as if it were *infinitely* far
    away. *Chapter 19* of the book *GPU Gems*, by Randima Fernando, Addison-Wesley
    Professional, 2009, has an excellent discussion of this issue and provides some
    possible solutions for localizing the reflections.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点涉及移动物体上出现的反射。在这些着色器中，我们计算反射方向并将其视为从环境贴图中心发出的向量。这意味着无论物体位于何处，反射都会看起来像物体位于环境的中心。换句话说，环境被处理成仿佛它距离无限远。*GPU
    Gems*一书的第19章，由Randima Fernando所著，Addison-Wesley Professional，2009年出版，对此问题有很好的讨论，并提供了一些可能的解决方案来定位反射。
- en: See also
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenereflectcube.cpp` file in the example code
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenereflectcube.cpp`文件
- en: The *Applying a 2D texture* recipe
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用2D纹理*配方'
- en: Chapter 19 of the book *GPU Gems*, by Randima Fernando, Addison-Wesley Professional,
    2009
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Randima Fernando所著，Addison-Wesley Professional，2009年出版的《GPU Gems》一书的第19章
- en: Simulating refraction with cube maps
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用立方体贴图模拟折射
- en: Objects that are transparent cause the light rays that pass through them to
    bend slightly at the interface between the object and the surrounding environment.
    This effect is called **refraction**. When rendering transparent objects, we simulate
    that effect by using an environment map and mapping the environment onto the object
    is such a way as to mimic the way that light would pass through the object. In
    other words, we can trace the rays from the viewer, through the object (bending
    in the process), and along to the environment. Then, we can use that ray intersection
    as the color for the object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 透明物体会导致光线在物体与其周围环境之间的界面处略微弯曲。这种现象称为**折射**。在渲染透明物体时，我们通过使用环境贴图并将环境映射到物体上来模拟这种效果。换句话说，我们可以追踪从观察者到物体（过程中弯曲）再到环境的射线。然后，我们可以使用这个射线交点作为物体的颜色。
- en: As in the previous recipe, we'll do this using a cube map for the environment.
    We'll trace rays from the viewer position, through the object, and finally intersect
    with the cube map.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方一样，我们将使用立方体贴图来模拟环境。我们将从观察者的位置追踪光线，穿过物体，并最终与立方体贴图相交。
- en: 'The process of refraction is described by **Snell''s ****law**, which defines
    the relationship between the angle of incidence and the angle of refraction:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 折射过程由**斯涅尔定律**描述，它定义了入射角和折射角之间的关系：
- en: '![](img/303ff9cd-8343-4d4a-805d-97796da2acfe.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303ff9cd-8343-4d4a-805d-97796da2acfe.png)'
- en: Snell's law describes the angle of incidence (**a[i]**) as the angle between
    the incoming light ray and the normal to the surface, and the angle of refraction
    (**a[t]**) as the angle between the transmitted ray and the extended normal. The
    material through which the incident light ray travels and the material containing
    the transmitted light ray are each described by an index of refraction (**n[1]**
    and **n[2]** in the diagram). The ratio between the two indices of refraction
    defines the amount that the light ray will be bent at the interface.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 斯涅尔定律描述了入射角（**a[i]**）为入射光线与表面法线之间的角度，折射角（**a[t]**）为透射光线与延长法线之间的角度。入射光线通过的介质和包含透射光线的介质分别由折射率（图中**n[1]**和**n[2]**）描述。两个折射率之间的比率定义了光线在界面处弯曲的程度。
- en: 'Starting with Snell''s law, and with a bit of mathematical effort, we can derive
    a formula for the transmitted vector, given the ratio of the indices of refraction,
    the normal vector, and the incoming vector:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从斯涅尔定律出发，经过一些数学努力，我们可以推导出一个透射向量的公式，给定折射率的比率、法线向量和入射向量：
- en: '![](img/f1421506-660d-4086-af88-fb58a5ee3177.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1421506-660d-4086-af88-fb58a5ee3177.png)'
- en: However, there's no real need to do so because GLSL provides a built-in function
    for computing this transmitted vector called `refract`. We'll make use of that
    function within this example.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上并没有必要这样做，因为GLSL提供了一个内置函数来计算这个透射向量，称为`refract`。我们将在本例中使用这个函数。
- en: It is usually the case that for transparent objects, not all of the light is
    transmitted through the surface. Some of the light is reflected. In this example,
    we'll model that in a very simple way, and at the end of this recipe, we'll discuss
    a more accurate representation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于透明物体，通常不是所有光线都通过表面透射。一些光线会被反射。在这个例子中，我们将以非常简单的方式模拟这一点，并在本配方末尾讨论更精确的表示。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your OpenGL program to provide the vertex position in attribute location
    0 and the vertex normal in attribute location 1\. As with the previous recipe,
    we'll need to provide the model matrix in the uniform variable `ModelMatrix`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL程序以在属性位置0提供顶点位置，在属性位置1提供顶点法线。与前面的配方一样，我们需要在统一变量 `ModelMatrix` 中提供模型矩阵。
- en: Load the cube map using the technique shown in the previous recipe. Place it
    in texture unit zero.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面配方中所示的技术加载立方体贴图。将其放置在纹理单元零。
- en: Set the uniform variable `WorldCameraPosition` to the location of your viewer
    in world coordinates. Set the value of the uniform variable `Material.Eta` to
    the ratio between the index of refraction of the environment *n[1]* and the index
    of refraction of the material *n[2]* (*n[1]/n[2]*). Set the value of the uniform
    `Material.ReflectionFactor` to the fraction of light that is reflected at the
    interface (a small value is probably what you want).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将统一变量 `WorldCameraPosition` 设置为观察者在世界坐标中的位置。将统一变量 `Material.Eta` 的值设置为环境折射率
    *n[1]* 与材料折射率 *n[2]* 之间的比率 (*n[1]/n[2]*)。将统一变量 `Material.ReflectionFactor` 的值设置为在界面处反射的光线比例（可能是一个小值）。
- en: As with the preceding example, if you want to draw the environment, draw a large
    cube surrounding the scene and use a separate shader to apply the texture to the
    cube. See the example code for details.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，如果你想要绘制环境，绘制一个围绕场景的大立方体，并使用一个单独的着色器将纹理应用到立方体上。请参阅示例代码以获取详细信息。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To render an object with reflection and refraction, carry out the following
    steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染具有反射和折射的对象，执行以下步骤：
- en: 'Use the following code within the vertex shader:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中使用以下代码：
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the following code within the fragment shader:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中使用以下代码：
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 的工作原理...
- en: Both shaders are quite similar to the shaders in the previous recipe.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个着色器与前面配方中的着色器非常相似。
- en: The vertex shader computes the position, normal, and view direction in world
    coordinates (`worldPos`, `worldNorm`, and `worldView`). They are then used to
    compute the reflected direction using the `reflect` function, and the result is
    stored in the output variable `ReflectDir`. The transmitted direction is computed
    using the built-in function `refract` (which requires the ratio of the indices
    of refraction `Material.Eta`). This function makes use of Snell's law to compute
    the direction of the transmitted vector, which is then stored in the output variable
    `RefractDir`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器计算世界坐标中的位置、法线和视图方向 (`worldPos`、`worldNorm` 和 `worldView`)。然后使用 `reflect`
    函数计算反射方向，并将结果存储在输出变量 `ReflectDir` 中。使用内置函数 `refract`（需要折射率比率 `Material.Eta`）计算透射方向。此函数利用斯涅尔定律计算透射向量的方向，然后将其存储在输出变量
    `RefractDir` 中。
- en: In the fragment shader, we use the two vectors `ReflectDir` and `RefractDir`
    to access the cube map texture. The color retrieved by the reflected ray is stored
    in `reflectColor` and the color retrieved by the transmitted ray is stored in
    `refractColor`. We then mix those two colors together based on the value of `Material.ReflectionFactor`.
    The result is a mixture between the color of the reflected ray and the color of
    the transmitted ray.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们使用两个向量 `ReflectDir` 和 `RefractDir` 来访问立方体贴图纹理。通过反射光线检索到的颜色存储在 `reflectColor`
    中，通过透射光线检索到的颜色存储在 `refractColor` 中。然后根据 `Material.ReflectionFactor` 的值将这两种颜色混合在一起。结果是反射光线的颜色和透射光线的颜色的混合。
- en: 'The following image shows the teapot rendered with 10 percent reflection and
    90 percent refraction (Cubemap © Paul Debevec):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了使用10%反射和90%折射（立方体贴图 © Paul Debevec）渲染的茶壶：
- en: '![](img/3e815c65-8d5a-42b2-b537-c053df53a79e.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e815c65-8d5a-42b2-b537-c053df53a79e.png)'
- en: There's more...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This technique has the same drawbacks that were discussed in the *There's more...*
    section of the preceding recipe, *Simulating reflection with cube maps*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与前面配方中“更多...”部分讨论的缺点相同，*使用立方体贴图模拟反射*。
- en: Like most real-time techniques, this is a simplification of the real physics
    of the situation. There are a number of things about the technique that could
    be improved to provide more realistic-looking results.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数实时技术一样，这只是一个对实际情况中物理现象的简化。关于这项技术，有许多方面可以改进以提供更逼真的结果。
- en: The Fresnel equations
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菲涅耳方程
- en: The amount of reflected light actually depends on the angle of incidence of
    the incoming light. For example, when looking at the surface of a lake from the
    shore, much of the light is reflected and it is easy to see reflections of the
    surrounding environment on the surface. However, when floating on a boat on the
    surface of the lake and looking straight down, there is less reflection and it
    is easier to see what lies below the surface. This effect is described by the
    Fresnel equations (after Augustin-Jean Fresnel).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，反射光量的多少取决于入射光的入射角度。例如，当我们从岸边观察湖面时，大部分光线被反射，因此很容易在湖面上看到周围环境的倒影。然而，当我们在湖面上漂浮并直接向下看时，反射较少，更容易看到水面以下的东西。这种现象由菲涅耳方程（Augustin-Jean
    Fresnel之后）描述。
- en: The Fresnel equations describe the amount of light that is reflected as a function
    of the angle of incidence, the polarization of the light, and the ratio of the
    indices of refraction. If we ignore the polarization, it is easy to incorporate
    the Fresnel equations into the preceding shaders. A very good explanation of this
    can be found in Chapter 14 of the book *The OpenGL Shading Language*, *3rd Edition*,
    Randi J Rost, Addison-Wesley Professional, 2009.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 菲涅耳方程描述了反射光量作为入射角度、光的偏振和折射率比函数。如果我们忽略偏振，很容易将菲涅耳方程纳入前面的着色器中。在Randi J Rost的《OpenGL着色语言》第三版第14章中可以找到非常好的解释，该书由Addison-Wesley
    Professional于2009年出版。
- en: Chromatic aberration
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 色差
- en: White light is of course composed of many different individual wavelengths (or
    colors). The amount that a light ray is refracted is actually wavelength dependent.
    This causes an effect where a spectrum of colors can be observed at the interface
    between materials. The most well-known example of this is the rainbow that is
    produced by a prism.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 白光当然由许多不同的单个波长（或颜色）组成。光线的折射程度实际上是波长依赖的。这导致在材料界面处可以观察到颜色光谱。最著名的例子是由棱镜产生的彩虹。
- en: We can model this effect by using slightly different values of `Eta` for the
    red, green, and blue components of the light ray. We would store three different
    values for `Eta`, compute three different reflection directions (red, green, and
    blue), and use those three directions to look up colors in the cube map. We take
    the red component from the first color, the green component from the second, and
    the blue component for the third, and combine the three components together to
    create the final color for the fragment.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为光线的红色、绿色和蓝色分量使用不同的 `Eta` 值来模拟这种效果。我们会存储三个不同的 `Eta` 值，计算三个不同的反射方向（红色、绿色和蓝色），并使用这三个方向在立方体贴图中查找颜色。我们从第一个颜色中提取红色分量，从第二个颜色中提取绿色分量，从第三个颜色中提取蓝色分量，并将这三个分量组合在一起以创建片段的最终颜色。
- en: Refracting through both sides of the object
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过物体的两侧折射
- en: It is important to note that we have simplified things by only modeling the
    interaction of the light with one of the boundaries of the object. In reality,
    the light would be bent once when entering the transparent object, and again when
    leaving the other side. However, this simplification generally does not result
    in unrealistic-looking results. As is often the case in real-time graphics, we
    are more interested in a result that looks good than one that models the physics
    accurately.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们通过仅模拟光与物体一个边界的相互作用来简化了问题。在现实中，光在进入透明物体时会弯曲一次，在离开另一侧时再次弯曲。然而，这种简化通常不会导致看起来不真实的结果。在实时图形中，我们通常更关注结果看起来是否美观，而不是物理模型是否准确。
- en: See also
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenerefractcube.cpp` file in the example code
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter05/scenerefractcube.cpp` 文件
- en: The *Simulating reflection with cube maps* recipe
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用立方体贴图模拟反射* 的配方'
- en: Applying a projected texture
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用投影纹理
- en: We can apply a texture to the objects in a scene as if the texture was a projection
    from an imaginary "slide projector" located somewhere within the scene. This technique
    is often called **projective ****texture ****mapping** and produces a very nice
    effect.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将纹理应用到场景中的对象上，就像纹理是从场景内部某个地方的想象中的“幻灯片投影仪”投影出来的。这种技术通常被称为**投影纹理映射**，并产生非常棒的效果。
- en: 'The following images show an example of projective texture mapping. The flower
    texture on the left (Stan Shebs via Wikimedia Commons) is projected onto the teapot
    and plane beneath:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了投影纹理映射的一个示例。左侧的花纹纹理（由Stan Shebs通过维基共享）被投影到茶壶和平面下：
- en: '![](img/c4015828-2ebb-47d4-8a77-c9596a594fe3.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4015828-2ebb-47d4-8a77-c9596a594fe3.png)'
- en: 'To project a texture onto a surface, all we need do is determine the texture
    coordinates based on the relative position of the surface location and the source
    of the projection (the slide projector). An easy way to do this is to think of
    the projector as a camera located somewhere within the scene. In the same way
    that we would define an OpenGL camera, we define a coordinate system centered
    at the projector''s location, and a **view matrix** (**V**) that converts coordinates
    to the projector''s coordinate system. Next, we''ll define a perspective **projection
    matrix** (**P**) that converts the view frustum (in the projector''s coordinate
    system) into a cubic volume of size two, centered at the origin. Putting these
    two things together, and adding an additional matrix for re-scaling and translating
    the volume to a volume of size one shifted so that the volume is centered at (0.5,
    0.5, 0.5), we have the following transformation matrix:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要将纹理投影到表面上，我们只需要确定基于表面位置和投影源（幻灯片投影仪）的相对位置的纹理坐标。一个简单的方法是将投影仪想象成一个位于场景内部的相机。就像我们定义OpenGL相机一样，我们定义一个以投影仪位置为中心的坐标系和一个**视图矩阵**（**V**），它将坐标转换为投影仪的坐标系。接下来，我们将定义一个**透视投影矩阵**（**P**），它将投影仪坐标系中的视锥体转换为大小为二的立方体，中心位于原点。将这两者结合起来，并添加一个用于重新缩放和将体积平移到大小为1且中心位于（0.5,
    0.5, 0.5）的额外矩阵，我们得到以下变换矩阵：
- en: '![](img/dcff488d-fe98-4a2d-b25e-24b6d01fa66f.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcff488d-fe98-4a2d-b25e-24b6d01fa66f.png)'
- en: The goal here is basically to convert the view frustum to a range between 0
    and 1 in *x* and *y*. The preceding matrix can be used to do just that! It will
    convert world coordinates that lie within the view frustum of the projector to
    a range between 0 and 1 (homogeneous), which can then be used to access the texture.
    Note that the coordinates are homogeneous and need to be divided by the w coordinate
    before they can be used as a real position.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标基本上是将视锥体转换为0到1之间的范围，在*x*和*y*方向上。前面的矩阵可以做到这一点！它将位于投影仪视锥体内的世界坐标转换为0到1的范围（齐次），然后可以用来访问纹理。请注意，坐标是齐次的，在使用之前需要除以w坐标。
- en: For more details on the mathematics of this technique, take a look at the following
    white paper, written by Cass Everitt from NVIDIA: [https://www.nvidia.com/object/Projective_Texture_Mapping.html](https://www.nvidia.com/object/Projective_Texture_Mapping.html)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于这种技术数学原理的细节，请查看以下由NVIDIA的Cass Everitt撰写的白皮书：[https://www.nvidia.com/object/Projective_Texture_Mapping.html](https://www.nvidia.com/object/Projective_Texture_Mapping.html)
- en: In this example, we'll apply a single texture to a scene using projective texture
    mapping.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用投影纹理映射将单个纹理应用到场景中。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Set up your OpenGL application to provide the vertex position in attribute location
    0 and the normal in attribute location 1\. The OpenGL application must also provide
    the material and lighting properties for the Phong reflection model (see the fragment
    shader given in the following section). Make sure to provide the model matrix
    (for converting to world coordinates) in the uniform variable `ModelMatrix`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL应用程序，以在属性位置0提供顶点位置，在属性位置1提供法线。OpenGL应用程序还必须为Phong反射模型提供材质和光照属性（参见以下章节中给出的片段着色器）。确保在统一变量`ModelMatrix`中提供模型矩阵（用于转换为世界坐标）。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To apply a projected texture to a scene, use the following steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要将投影纹理应用到场景中，请按照以下步骤操作：
- en: 'In the OpenGL application, load the texture into texture unit zero. While the
    texture object is bound to the `GL_TEXTURE_2D` target, use the following code
    to set the texture''s settings:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中，将纹理加载到纹理单元零。当纹理对象绑定到`GL_TEXTURE_2D`目标时，使用以下代码设置纹理的设置：
- en: '[PRE24]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also within the OpenGL application, set up your transformation matrix for the
    slide projector and assign it to the uniform `ProjectorMatrix`. Use the following
    code to do this. Note that this code makes use of the GLM libraries discussed
    in [Chapter 1](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml), *Getting Started with
    GLSL*:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中，设置幻灯片投影机的变换矩阵，并将其分配给统一变量`ProjectorMatrix`。使用以下代码来完成此操作。请注意，此代码使用了在[第1章](3b817a9a-28a1-4be7-936c-b982b4dfacdf.xhtml)，*开始使用GLSL*中讨论的GLM库：
- en: '[PRE25]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the following code for the vertex shader:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行顶点着色器：
- en: '[PRE27]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行片段着色器：
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When loading the texture into the OpenGL application, we make sure to set the
    wrap mode for the *s* and *t* directions to `GL_CLAMP_TO_BORDER`. We do this because
    if the texture coordinates are outside of the range of zero to one, we do not
    want any contribution from the projected texture. With this mode, using the default
    border color, the texture will return (0,0,0,0) when the texture coordinates are
    outside of the range between 0 and 1 inclusive.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当将纹理加载到OpenGL应用程序中时，我们确保将*s*和*t*方向的包裹模式设置为`GL_CLAMP_TO_BORDER`。我们这样做是因为如果纹理坐标超出了零到一的范围内，我们不希望投影纹理有任何贡献。使用这种模式，使用默认的边框颜色，当纹理坐标超出0到1（包括0和1）的范围时，纹理将返回(0,0,0,0)。
- en: The transformation matrix for the slide projector is set up in the OpenGL application.
    We start by using the GLM function `glm::lookAt` to produce a view matrix for
    the projector. In this example, we locate the projector at (5, 5, 5), looking
    toward the point (-2, -4,0), with an *up vector* of (0, 1, 0). This function works
    in a similar way to the `gluLookAt` function. It returns a matrix for converting
    to the coordinate system located at (5, 5, 5), and oriented based on the second
    and third arguments.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中设置幻灯片投影机的变换矩阵。我们首先使用GLM函数`glm::lookAt`为投影机生成一个视图矩阵。在这个例子中，我们将投影机定位在(5,
    5, 5)，朝向点(-2, -4,0)，使用*向上向量*为(0, 1, 0)。此函数与`gluLookAt`函数类似。它返回一个矩阵，用于将坐标系统转换为(5,
    5, 5)，并根据第二个和第三个参数进行定位。
- en: Next, we create the projection matrix using `glm::perspective`, and the scale/translate
    matrix *M* (shown in the introduction to this recipe). These two matrices are
    stored in `projProj` and `projScaleTrans`, respectively. The final matrix is the
    product of `projScaleTrans`, `projProj`, and `projView`, which is stored in `m`
    and assigned to the uniform variable `ProjectorTex`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`glm::perspective`创建投影矩阵，以及缩放/平移矩阵*M*（如本食谱的介绍中所示）。这两个矩阵分别存储在`projProj`和`projScaleTrans`中。最终的矩阵是`projScaleTrans`、`projProj`和`projView`的乘积，存储在`m`中，并分配给统一变量`ProjectorTex`。
- en: In the vertex shader, we have three output variables: `EyeNormal`, `EyePosition`,
    and `ProjTexCoord`. The first two are the vertex normal and vertex position in
    eye coordinates. We transform the input variables appropriately, and assign the
    results to the output variables within the `main` function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，我们有三个输出变量：`EyeNormal`、`EyePosition`和`ProjTexCoord`。前两个是眼坐标中的顶点法线和顶点位置。我们适当地变换输入变量，并在`main`函数中将结果分配给输出变量。
- en: We compute `ProjTexCoord` by first transforming the position to world coordinates
    (by multiplying by `ModelMatrix`), and then applying the projector's transformation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先将位置变换到世界坐标（通过乘以`ModelMatrix`）来计算`ProjTexCoord`，然后应用投影机的变换。
- en: In the fragment shader, within the `main` function, we start by computing the
    reflection model and storing the result in the variable `color`. The next step
    is to look up the color from the texture. First, however, we check the *z* coordinate
    of `ProjTexCoord`. If this is negative, then the location is behind the projector,
    so we avoid doing the texture lookup. Otherwise, we use `textureProj` to look
    up the texture value and store it in `projTexColor`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，在`main`函数中，我们首先计算反射模型，并将结果存储在变量`color`中。下一步是从纹理中查找颜色。然而，首先检查`ProjTexCoord`的*z*坐标。如果这是负数，则该位置在投影机后面，因此我们避免进行纹理查找。否则，我们使用`textureProj`查找纹理值，并将其存储在`projTexColor`中。
- en: The function `textureProj` is designed for accessing textures with coordinates
    that have been projected. It will divide the coordinates of the second argument
    by its last coordinate before accessing the texture. In our case, that is exactly
    what we want. We mentioned earlier that after transforming by the projector's
    matrix, we will be left with homogeneous coordinates, so we need to divide by
    the w coordinate before accessing the texture. The `textureProj` function will
    do exactly that for us.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`textureProj` 函数是为了访问经过投影的坐标纹理而设计的。在访问纹理之前，它会将第二个参数的坐标除以其最后一个坐标。在我们的例子中，这正是我们想要的。我们之前提到，经过投影仪矩阵变换后，我们将剩下齐次坐标，因此我们需要在访问纹理之前除以
    w 坐标。`textureProj` 函数将为我们完成这一点。'
- en: Finally, we add the projected texture's color to the base color from the Phong
    model. We scale the projected texture color slightly so that it is not overwhelming.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将投影纹理的颜色添加到 Phong 模型的基础颜色中。我们将投影纹理颜色稍微缩放，以便它不会过于强烈。
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's one big drawback to the technique presented here. There is no support
    for shadows yet, so the projected texture will shine right through any objects
    in the scene and appear on objects that are behind them (with respect to the projector).
    In later recipes, we will look at some examples of techniques for handling shadows
    that could help solve this problem.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的技术有一个很大的缺点。目前还没有阴影支持，因此投影的纹理会直接穿透场景中的任何物体，并出现在它们后面的物体上（相对于投影仪而言）。在后面的食谱中，我们将探讨一些处理阴影的技术示例，这有助于解决这个问题。
- en: See also
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/sceneprojtex.cpp` file in the example code
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter05/sceneprojtex.cpp` 文件
- en: '*The Blinn-Phong reflection model* recipe in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)中的 *Blinn-Phong 反射模型* 食谱，*GLSL
    着色器基础*'
- en: The *Applying a 2D texture* recipe
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用 2D 纹理* 食谱'
- en: Rendering to a texture
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将渲染输出到纹理
- en: Sometimes, it makes sense to generate textures *on the fly* during the execution
    of the program. The texture could be a pattern that is generated from some internal
    algorithm (a so-called **procedural texture**), or it could be that the texture
    is meant to represent another portion of the scene.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在程序执行过程中实时生成纹理是有意义的。这个纹理可能是由某些内部算法（所谓的 **过程纹理**）生成的图案，或者它可能代表场景的另一个部分。
- en: An example of the latter case might be a video screen where one can see another
    part of the *world*, perhaps via a security camera in another room. The video
    screen could be constantly updated as objects move around in the other room, by
    re-rendering the view from the security camera to the texture that is applied
    to the video screen!
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 后者案例的一个例子可能是一个视频屏幕，人们可以看到 *世界* 的另一部分，也许是通过另一个房间的安全摄像头。视频屏幕可以随着另一个房间中物体的移动而不断更新，通过重新渲染安全摄像头视图到应用于视频屏幕的纹理中！
- en: 'In the following image, the texture appearing on the cube was generated by
    rendering the cow to an internal texture and then applying that texture to the
    faces of the cube:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，出现在立方体上的纹理是通过将牛渲染到内部纹理中，然后将其应用于立方体的面来生成的：
- en: '![](img/4fa3ad96-38bb-4c39-b3e4-465820aa4f00.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fa3ad96-38bb-4c39-b3e4-465820aa4f00.png)'
- en: In OpenGL, rendering directly to textures has been greatly simplified by the
    introduction of **framebuffer objects** (**FBOs**). We can create a separate rendering
    target buffer (the FBO), attach our texture to that FBO, and render to the FBO
    in exactly the same way that we would render to the default framebuffer. All that
    is required is to swap in the FBO, and swap it out when we are done.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 中，通过引入 **帧缓冲区对象**（**FBO**）大大简化了直接将渲染输出到纹理的过程。我们可以创建一个单独的渲染目标缓冲区（FBO），将我们的纹理附加到该
    FBO 上，并以与渲染到默认帧缓冲区相同的方式渲染到 FBO 上。所需的所有操作只是交换 FBO，完成后再将其交换出来。
- en: 'Basically, the process involves the following steps when rendering:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，渲染过程涉及以下步骤：
- en: Bind to the FBO
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定到 FBO
- en: Render the texture
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染纹理
- en: Unbind from the FBO (back to the default framebuffer)
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 FBO（返回默认帧缓冲区）解绑
- en: Render the scene using the texture
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用纹理渲染场景
- en: There's actually not much that we need to do on the GLSL side in order to use
    this kind of texture. In fact, the shaders will see it as any other texture. However,
    there are some important points that we'll talk about regarding fragment output
    variables.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 GLSL 着色器方面，为了使用这种纹理，我们不需要做太多工作。实际上，着色器会将其视为任何其他纹理。然而，我们将讨论一些关于片段输出变量的重要点。
- en: In this example, we'll cover the steps needed to create the FBO and its backing
    texture, and how to set up a shader to work with the texture.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将介绍创建FBO及其后备纹理所需的步骤，以及如何设置一个与纹理一起工作的着色器。
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, we'll use the shaders from the previous recipe, *Applying
    a 2D texture*, with some minor changes. Set up your OpenGL program as described
    in that recipe. The only change that we'll make to the shaders is changing the
    name of the `sampler2D` variable from `Tex1` to `Texture`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用之前配方中的着色器，即*应用2D纹理*，进行一些小的修改。按照该配方中的描述设置你的OpenGL程序。我们将对着色器做的唯一修改是将`sampler2D`变量的名称从`Tex1`改为`Texture`。
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To render to a texture and then apply that texture to a scene in a second pass,
    use the following steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要在纹理上渲染并应用该纹理到第二个渲染通道的场景中，请按照以下步骤操作：
- en: 'Within the main OpenGL program, use the following code to set up the framebuffer
    object:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主OpenGL程序中，使用以下代码设置帧缓冲区对象：
- en: '[PRE29]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In your render function within the OpenGL program, bind to the framebuffer,
    draw the scene that is to be rendered to the texture, then unbind from that framebuffer
    and draw the cube:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL程序中的渲染函数内，绑定到帧缓冲区，绘制要渲染到纹理中的场景，然后从该帧缓冲区解绑，并绘制立方体：
- en: '[PRE30]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start by looking at the code for creating the framebuffer object (step
    1). Our FBO will be 512 pixels square because we intend to use it as a texture.
    We begin by generating the FBO using `glGenFramebuffers` and binding the framebuffer
    to the `GL_FRAMEBUFFER` target with `glBindFramebuffer`. Next, we create the texture
    object to which we will be rendering, and use `glActiveTexture` to select texture
    unit zero. The rest is very similar to creating any other texture. We allocate
    space for the texture using `glTexStorage2D`. We don't need to copy any data into
    that space (using `glTexSubImage2D`) because we'll be writing to that memory later
    when rendering to the FBO.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看创建帧缓冲区对象的代码（步骤1）。我们的FBO将是512像素的平方，因为我们打算将其用作纹理。我们首先使用`glGenFramebuffers`生成FBO，并使用`glBindFramebuffer`将其绑定到`GL_FRAMEBUFFER`目标。接下来，我们创建一个将要渲染的纹理对象，并使用`glActiveTexture`选择纹理单元零。其余部分与创建任何其他纹理非常相似。我们使用`glTexStorage2D`为纹理分配空间。我们不需要将任何数据复制到该空间（使用`glTexSubImage2D`），因为我们将在渲染到FBO时稍后写入该内存。
- en: Next, we link the texture to the FBO by calling the function `glFramebufferTexture2D`.
    This function attaches a texture object to an attachment point in the currently
    bound framebuffer object. The first argument (`GL_FRAMEBUFFER`) indicates that
    the texture is to be attached to the FBO currently bound to the `GL_FRAMEBUFFER`
    target. The second argument is the attachment point. Framebuffer objects have
    several attachment points for color buffers, one for the depth buffer, and a few
    others. This allows us to have several color buffers to target from our fragment
    shaders. We'll see more about this later. We use `GL_COLOR_ATTACHMENT0` to indicate
    that this texture is linked to color attachment 0 of the FBO. The third argument
    (`GL_TEXTURE_2D`) is the texture target, and the fourth (`renderTex`) is the handle
    to our texture. The last argument (`0`) is the mip-map level of the texture that
    is being attached to the FBO. In this case, we only have a single level, so we
    use a value of zero.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用函数`glFramebufferTexture2D`将纹理链接到FBO。此函数将一个纹理对象附加到当前绑定的帧缓冲区对象的附件点上。第一个参数（`GL_FRAMEBUFFER`）表示纹理将被附加到当前绑定到`GL_FRAMEBUFFER`目标的FBO。第二个参数是附件点。帧缓冲区对象有几个颜色缓冲区的附件点，一个用于深度缓冲区，还有一些其他附件点。这使我们能够从我们的片段着色器中针对多个颜色缓冲区。我们将在稍后了解更多关于这一点。我们使用`GL_COLOR_ATTACHMENT0`来表示此纹理链接到FBO的颜色附件0。第三个参数（`GL_TEXTURE_2D`）是纹理目标，第四个（`renderTex`）是我们纹理的句柄。最后一个参数（`0`）是要附加到FBO的纹理的mip级别。在这种情况下，我们只有一个级别，所以我们使用零值。
- en: As we want to render to the FBO with depth testing, we need to also attach a
    depth buffer. The next few lines of code create the depth buffer. The `glGenRenderbuffer`
    function creates a `renderbuffer` object, and `glRenderbufferStorage` allocates
    space for the `renderbuffer` object. The second argument to `glRenderbufferStorage`
    indicates the internal format for the buffer, and as we are using this as a depth
    buffer, we use the special format `GL_DEPTH_COMPONENT`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要在FBO上渲染并使用深度测试，我们还需要附加一个深度缓冲区。接下来的几行代码创建了深度缓冲区。`glGenRenderbuffer`函数创建了一个`renderbuffer`对象，而`glRenderbufferStorage`为`renderbuffer`对象分配空间。`glRenderbufferStorage`的第二个参数表示缓冲区的内部格式，由于我们将其用作深度缓冲区，我们使用特殊的格式`GL_DEPTH_COMPONENT`。
- en: Next, the depth buffer is attached to the `GL_DEPTH_ATTACHMENT` attachment point
    of the FBO using `glFramebufferRenderbuffer`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`glFramebufferRenderbuffer`将深度缓冲区附加到FBO的`GL_DEPTH_ATTACHMENT`附加点。
- en: The shader's output variables are assigned to the attachments of the FBO using
    `glDrawBuffers`. The second argument to `glDrawBuffers` is an array indicating
    the FBO buffers to be associated with the output variables. The *i*^(th) element
    of the array corresponds to the fragment shader output variable at location `i`.
    In our case, we only have one shader output variable (`FragColor`) at location
    zero. This statement associates that output variable with `GL_COLOR_ATTACHMENT0`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glDrawBuffers`将着色器的输出变量分配给FBO的附加点。`glDrawBuffers`的第二个参数是一个数组，指示要关联到输出变量的FBO缓冲区。数组的第*i*个元素对应于位置*i*的片段着色器输出变量。在我们的例子中，我们只有一个着色器输出变量（`FragColor`）在位置零。此语句将该输出变量与`GL_COLOR_ATTACHMENT0`关联。
- en: The last statement in step 1 unbinds the FBO to revert back to the default framebuffer.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步的最后一条语句解除了FBO的绑定，使其恢复到默认帧缓冲区。
- en: In the last step (within the render function), we bind to the FBO, use the texture
    in unit one, and render the texture. Note that we need to be careful to set up
    the viewport (`glViewport`) and the view and projection matrices appropriately
    for our FBO. As our FBO is 512 x 512, we use `glViewport(0,0,512,512)`. Similar
    changes should be made to the view and projection matrices to match the aspect
    ratio of the viewport and set up the scene to be rendered to the FBO.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步（在渲染函数内），我们绑定到FBO，使用单元一的纹理，并渲染纹理。请注意，我们需要小心地设置视口（`glViewport`）以及视图和投影矩阵，以适应我们的FBO。由于我们的FBO是512
    x 512，我们使用`glViewport(0,0,512,512)`。类似的更改也应应用于视图和投影矩阵，以匹配视口的纵横比，并设置要渲染到FBO的场景。
- en: Once we've rendered to the texture, we unbind from the FBO, reset the viewport,
    and the view and projection matrices, use the FBO's texture (texture unit 0),
    and draw the cube!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将渲染到纹理上，我们就从FBO解绑，重置视口、视图和投影矩阵，使用FBO的纹理（纹理单元0），然后绘制立方体！
- en: There's more...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As FBOs have multiple color attachment points, we can have several output targets
    from our fragment shaders. Note that so far, all of our fragment shaders have
    only had a single output variable assigned to location zero. Hence, we set up
    our FBO so that its texture corresponds to color attachment zero. In later chapters,
    we'll look at examples where we use more than one of these attachments for things
    like deferred shading.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FBO有多个颜色附加点，我们可以从我们的片段着色器中获得多个输出目标。请注意，到目前为止，我们所有的片段着色器都只有一个输出变量分配到位置零。因此，我们设置了我们的FBO，使其纹理对应于颜色附加点零。在后面的章节中，我们将查看使用多个这些附加点作为延迟着色等事物的示例。
- en: See also
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenerendertotex.cpp` file in the example code
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenerendertotex.cpp`文件
- en: The *Applying a 2D texture* recipe
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用2D纹理的配方
- en: Using sampler objects
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用采样对象
- en: Sampler objects were introduced in OpenGL 3.3 and provide a convenient way to
    specify the sampling parameters for a GLSL sampler variable. The traditional way
    to specify the parameters for a texture is to specify them using `glTexParameter`,
    typically at the time that the texture is defined. The parameters define the sampling
    state (sampling mode, wrapping and clamping rules, and so on) for the associated
    texture. This essentially combines the texture and its sampling state into a single
    object. If we wanted to sample from a single texture in more than one way (with
    and without linear filtering for example), we'd have two choices. We would either
    need to modify the texture's sampling state, or use two copies of the same texture.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器对象是在OpenGL 3.3中引入的，并提供了一种方便的方式来指定GLSL采样器变量的采样参数。指定纹理参数的传统方法是通过`glTexParameter`来指定，通常在定义纹理时进行。这些参数定义了相关纹理的采样状态（采样模式、环绕和钳位规则等）。这实际上将纹理及其采样状态合并为一个单一对象。如果我们想要以多种方式（例如，带有和没有线性过滤）从单个纹理中进行采样，我们有两个选择。我们可能需要修改纹理的采样状态，或者使用相同纹理的两个副本。
- en: In addition, we might want to use the same set of texture sampling parameters
    for multiple textures. With what we've seen up until now, there's no easy way
    to do that. With sampler objects, we can specify the parameters once and share
    them among several texture objects.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能希望为多个纹理使用相同的纹理采样参数集。根据我们到目前为止所看到的，没有简单的方法来实现这一点。使用采样器对象，我们可以一次性指定参数，并在多个纹理对象之间共享它们。
- en: Sampler objects separate the sampling state from the texture object. We can
    create sampler objects that define a particular sampling state and apply that
    to multiple textures or bind different sampler objects to the same texture. A
    single sampler object can be bound to multiple textures, which allows us to define
    a particular sampling state once and share it among several texture objects.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器对象将采样状态与纹理对象分离。我们可以创建定义特定采样状态的采样器对象，并将其应用于多个纹理，或者将不同的采样器对象绑定到同一纹理。单个采样器对象可以绑定到多个纹理，这允许我们一次性定义特定的采样状态，并在多个纹理对象之间共享。
- en: Sampler objects are defined on the OpenGL side (not in GLSL), which makes it
    effectively transparent to the GLSL.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 采样器对象是在OpenGL端定义的（而不是在GLSL中），这使得它对GLSL来说实际上是透明的。
- en: 'In this recipe, we''ll define two sampler objects and apply them to a single
    texture. The following image shows the result. The same texture is applied to
    the two planes. On the left, we use a sampler object set up for nearest-neighbor
    filtering, and on the right we use the same texture with a sampler object set
    up for linear filtering:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将定义两个采样器对象，并将它们应用于单个纹理。以下图像显示了结果。相同的纹理被应用于两个平面。在左侧，我们使用为最近邻过滤设置的采样器对象，而在右侧，我们使用相同的纹理，并使用为线性过滤设置的采样器对象：
- en: '![](img/c598a1c5-fc5c-4d19-a043-291744270ee5.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c598a1c5-fc5c-4d19-a043-291744270ee5.png)'
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the same shaders used in the recipe *Applying a 2D texture*.
    The shader code will not change at all, but we'll use sampler objects to change
    the state of the sampler variable `Tex1`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与配方*应用2D纹理*中相同的着色器。着色器代码将完全不变，但我们将使用采样器对象来改变采样变量`Tex1`的状态。
- en: How to do it...
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To set up the texture object and the sampler objects, perform the following
    steps:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置纹理对象和采样器对象，执行以下步骤：
- en: 'Create and fill the texture object in the usual way, but this time, we won''t
    set any sampling state using `glTexParameter`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照常规方式创建并填充纹理对象，但这次我们不会使用`glTexParameter`设置任何采样状态：
- en: '[PRE31]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Bind the texture to texture unit 0, which is the unit that is used by the shader:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理绑定到纹理单元0，这是着色器使用的单元：
- en: '[PRE32]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, we create two sampler objects and assign their IDs to separate variables
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个采样器对象，并将它们的ID分配给不同的变量
- en: 'for clarity:'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了清晰起见：
- en: '[PRE33]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set up `linearSampler` for linear interpolation:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为线性插值设置`linearSampler`：
- en: '[PRE34]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up `nearestSampler` for nearest-neighbor sampling:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为最近邻采样设置`nearestSampler`：
- en: '[PRE35]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When rendering, we bind to each sampler object when needed:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染时，当需要时绑定到每个采样器对象：
- en: '[PRE36]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Sampler objects are simple to use and make it easy to switch between different
    sampling parameters for the same texture or use the same sampling parameters for
    different textures. In steps 1 and 2, we create a texture and bind it to texture
    unit 0\. Normally, we would set the sampling parameters here using `glTexParameteri`,
    but in this case, we'll set them in the sampler objects using `glSamplerParameter`.
    In step 3, we create the sampler objects and assign their IDs to some variables.
    In steps 4 and 5, we set up the appropriate sampling parameters using `glSamplerParameter`.
    This function is almost exactly the same as `glTexParameter` except the first
    argument is the ID of the sampler object instead of the texture target. This defines
    the sampling state for each of the two sampler objects (linear for `linearSampler`
    and nearest for `nearestSampler`).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 样本对象易于使用，并使得在相同的纹理之间切换不同的采样参数或为不同的纹理使用相同的采样参数变得简单。在步骤1和2中，我们创建了一个纹理并将其绑定到纹理单元0。通常，我们会在这里使用`glTexParameteri`设置采样参数，但在这个例子中，我们将使用`glSamplerParameter`在样本对象中设置它们。在步骤3中，我们创建了样本对象并将它们的ID分配给一些变量。在步骤4和5中，我们使用`glSamplerParameter`设置适当的采样参数。这个函数几乎与`glTexParameter`完全相同，只是第一个参数是样本对象的ID而不是纹理目标。这为两个样本对象（`linearSampler`为线性，`nearestSampler`为最近）定义了采样状态。
- en: Finally, we use the sampler objects by binding them to the appropriate texture
    unit using `glBindSampler` just prior to rendering. In step 6 we bind `nearestSampler`
    to texture unit 0 first, render some objects, bind `linearSampler` to texture
    unit 0, and render some more objects. The result here is that the same texture
    uses different sampling parameters by binding different sampler objects to the
    texture unit during rendering.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在渲染之前通过使用`glBindSampler`将样本对象绑定到适当的纹理单元来使用样本对象。在步骤6中，我们首先将`nearestSampler`绑定到纹理单元0，渲染一些对象，然后将`linearSampler`绑定到纹理单元0，并再次渲染一些对象。这里的结果是，通过在渲染过程中将不同的样本对象绑定到纹理单元，相同的纹理使用了不同的采样参数。
- en: See also
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter05/scenesamplerobj.cpp` file in the example code
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter05/scenesamplerobj.cpp`文件
- en: The *Applying a 2D texture* recipe
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用2D纹理的配方
- en: Diffuse image-based lighting
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫反射基于图像的照明
- en: '** Image-based lighting** is a technique that involves using an image as a
    light source.  The image represents an omni-directional view of the environment
    of the scene. With image-based lighting, the image itself is treated as a highly
    detailed light source that surrounds the scene completely. Objects in the scene
    are illuminated by the content of the image, making it possible to have a very
    complex lighting environment and/or to simulate a real world setting. Often, these
    images are produced using a special camera or special photographic techniques,
    and are recorded in high dynamic range. An example of one such image is shown
    here (image courtesy of USC Institute for Creative Technologies and Paul Debevec):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于图像的照明**是一种涉及使用图像作为光源的技术。该图像表示场景环境的全方位视图。使用基于图像的照明，图像本身被处理为一个完全环绕场景的高度详细的光源。场景中的物体通过图像的内容被照亮，这使得拥有一个非常复杂的照明环境或模拟真实世界场景成为可能。通常，这些图像是通过特殊的相机或特殊的摄影技术制作的，并记录在高动态范围内。这里展示了一个这样的图像示例（图像由南加州大学创意技术研究所和保罗·德贝韦克提供）：'
- en: '![](img/87eaa865-5317-4ceb-aabf-734add52613f.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87eaa865-5317-4ceb-aabf-734add52613f.png)'
- en: These images may be provided as a cube map (set of six images), or some other
    type of environment map such as a **equirectangular** panoramic map (the type
    shown previously). Conversion between the two is straightforward.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像可以提供为立方图（六个图像的集合），或者某些其他类型的环境图，如**等角**全景图（之前展示的类型）。两者之间的转换是直接的。
- en: Since each texel in the equirectangular map represents a direction, the same
    is true for a cube map. To convert from one to the other, we just need to convert
    directions in one map to directions in the other.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 由于等角图中的每个texel代表一个方向，立方图也是如此。要从一个转换到另一个，我们只需要将一个图中的方向转换为另一个图中的方向。
- en: 'In this recipe, we''ll go through the process of using an image as a light
    source for diffuse reflection. Most of the effort here is involved in the creation
    of the **diffuse convolution** map. The diffuse convolution is a transformation
    of the environment map into a form that can be used directly when computing the
    diffuse reflection. In the following images, the original environment map is shown
    on the left, and the right side is the diffuse convolution (image courtesy of
    USC Institute for Creative Technologies and Paul Debevec):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过使用图像作为漫反射的光源的过程。这里的大部分工作都涉及创建**漫反射卷积**图。漫反射卷积是将环境图转换成可以直接用于计算漫反射的形式的转换。在以下图像中，左侧显示原始环境图，右侧是漫反射卷积（图片由南加州大学创意技术研究所和保罗·德贝维ック提供）：
- en: '![](img/4e67920f-d80d-4a5d-b8ea-40159bb107a6.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e67920f-d80d-4a5d-b8ea-40159bb107a6.png)'
- en: 'To understand the diffuse convolution map, lets review the reflectance equation
    (presented in *A Physically-based reflection model* in [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解漫反射卷积图，让我们回顾一下反射方程（在[第 3 章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)“基于物理的反射模型”中，*GLSL
    着色器的基础*中提出）：
- en: '![](img/1fc383d0-4ec6-4eef-aaa1-1aee84b6cbde.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fc383d0-4ec6-4eef-aaa1-1aee84b6cbde.png)'
- en: 'This equation represents the integral over all directions of incoming light
    (*l*) on the hemisphere above the surface. The *f* term in the preceding equation
    is the **Bidirectional Reflectance Distribution Functio**n (**BRDF**). It represents
    the fraction of light that is reflected from a surface point given the incoming
    (*l*) and outgoing (*v*) directions. If we only consider diffuse reflection (Lambertian),
    we can use the following constant term for the BRDF:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程表示在表面上方半球面上所有入射光 (*l*) 的积分。前一个方程中的 *f* 项是**双向反射分布函数**（**BRDF**）。它表示在给定的入射
    (*l*) 和出射 (*v*) 方向条件下，从表面点反射的光的分数。如果我们只考虑漫反射（朗伯），我们可以使用以下常数项作为 BRDF：
- en: '![](img/f04266cb-5ecd-4019-a504-e3ded97109eb.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f04266cb-5ecd-4019-a504-e3ded97109eb.png)'
- en: 'Which gives us the following for the reflectance equation:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了反射方程的以下内容：
- en: '![](img/f13a30d4-420a-4f27-9dec-711844532685.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f13a30d4-420a-4f27-9dec-711844532685.png)'
- en: 'Since the BRDF is just a constant, it can be factored outside of the integral.
    Note that there is nothing in this equation that depends upon the outgoing direction
    (*v*). That leads us to the following insight. The environment map that we discussed
    previously represents the amount of incoming radiance for a given direction, which
    is the *L[i](l)* term in the preceding equation. We could estimate the value of
    this integral for a given value of *n* using the **Monte Carlo estimator**:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 BRDF 只是一个常数，它可以被因式分解到积分外面。注意，这个方程中没有依赖于出射方向 (*v*) 的东西。这导致我们得到以下见解。我们之前讨论的环境图表示了给定方向的入射辐射量，这是前一个方程中的
    *L[i](l)* 项。我们可以使用**蒙特卡洛估计器**来估计给定 *n* 值的该积分的值：
- en: '![](img/c6ea15d8-ff10-4fd0-b733-52bc8567b47f.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c6ea15d8-ff10-4fd0-b733-52bc8567b47f.png)'
- en: In the preceding equation, *l[j]* represents a pseudo-random direction sampled
    *uniformly* from the hemisphere above the surface (around *n*), and *N* is the
    number of samples. The constant factor of *2π* comes from the probability density
    function for uniform samples as a function of solid angle.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个方程中，*l[j]* 代表从表面上方半球面（围绕 *n*）均匀采样的伪随机方向，*N* 是样本数量。*2π* 的常数因子来自均匀样本的概率密度函数作为立体角函数。
- en: 'Sampling the directions uniformly over the hemisphere is not quite as straightforward
    as you might think. Common practice is to sample directions in a system where
    the *z* axis is aligned with the vector *n*, and then transform the sample into
    world coordinates. However, we have to be careful to pick directions uniformly.
    For example, suppose we just pick random values between -1 and 1 for *x* and *y*,
    and 0 and 1 for *z* and then normalize. That would give us directions that are
    biased or "clumped" around the *z* axis and are not uniform over the hemisphere.
    To get uniform directions, we can use the following formulae:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在半球面上均匀采样方向并不像你想象的那样简单。常见的做法是在一个系统中采样方向，其中 *z* 轴与向量 *n* 对齐，然后将样本转换成世界坐标。然而，我们必须小心地均匀选择方向。例如，如果我们只是为
    *x* 和 *y* 选取介于 -1 和 1 之间的随机值，为 *z* 和 0 选取 1 和 0，然后进行归一化，那么这将给出有偏或“聚集”在 *z* 轴周围的定向，并且在半球面上不是均匀的。为了得到均匀的定向，我们可以使用以下公式：
- en: '![](img/0f695731-89b1-447a-a6e5-5852ccd0cd67.png)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f695731-89b1-447a-a6e5-5852ccd0cd67.png)'
- en: The values *ξ[1]* and *ξ[2]* are uniform pseudo-random values in the range [0,
    1]. For a derivation of this, see *Physically Based Rendering*, third edition,
    Chapter 13, *Monte Carlo Integration*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 值 *ξ[1]* 和 *ξ[2]* 是范围 [0, 1] 内的均匀伪随机值。关于这一点的推导，请参阅 *基于物理的渲染* 第三版，第 13 章，*蒙特卡洛积分*。
- en: Now that we have a way to estimate the integral for a given value of *n*, we
    can convolve the original environment map in the following way. We'll create a
    new environment map (the diffuse convolution map), where each texel represents
    a direction of *n* in world coordinates.  The value of the texel will be the estimated
    value of the preceding integral (except for the *c[diff]* term) by taking a number
    of random samples (*l[j]*) from the original environment map. We can do this *offline* and
    pre-compute this diffuse convolution. It is a somewhat slow process, but we don't
    need a lot of detail. The diffuse convolution is usually fairly smoothly varying,
    so we can use a small resolution without sacrificing much quality.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了估计给定 *n* 值的积分的方法，我们可以以下述方式卷积原始环境图。我们将创建一个新的环境图（漫反射卷积图），其中每个纹理像素代表世界坐标中
    *n* 的一个方向。纹理像素的值将是先前积分的估计值（除了 *c[diff]* 项），通过从原始环境图中取多个随机样本（*l[j]*) 来获得。我们可以 *离线*
    进行此操作并预计算这个漫反射卷积。这是一个相对较慢的过程，但我们不需要很多细节。漫反射卷积通常变化相当平滑，因此我们可以使用较小的分辨率而不会牺牲太多质量。
- en: I've admittedly glossed over some of the math here. For a very good introduction
    to Monte Carlo integration for graphics, please see *Physically Based Rendering*,
    third Edition by Pharr, Jakob, and Humphreys, Chapter 13, *Monte Carlo Integration*.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认在这里省略了一些数学内容。关于图形中蒙特卡洛积分的非常好的介绍，请参阅 Pharr、Jakob 和 Humphreys 编著的 *基于物理的渲染*
    第三版，第 13 章，*蒙特卡洛积分*。
- en: Once we have the pre-computed diffuse convolution, we can use that as a *lookup
    table* to give us the value of our diffuse integral (again, without *c[diff]*)
    using the normal vector. We can multiply the value retrieved by our material's
    diffuse color *c*[*dif*f] to get the outgoing radiance. In other words, the diffuse
    convolution represents the *outgoing* radiance for a given value of *n*, rather
    than the incoming radiance.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了预计算的漫反射卷积，我们就可以将其用作 *查找表* 来给出我们的漫反射积分（再次，没有 *c[diff]*) 的值，使用法线向量。我们可以将检索到的值乘以我们的材料的漫反射颜色
    *c*[*dif*f]，以获得出射辐射度。换句话说，漫反射卷积表示给定 *n* 值的 *出射* 辐射度，而不是入射辐射度。
- en: Getting ready
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Most of the preparation here is involved in convolving the environment map.
    The following pseudocode outlines this process:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的准备工作大部分涉及环境图的卷积。以下伪代码概述了这一过程：
- en: '[PRE37]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How to do it...
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To render a scene with diffuse image-based lighting, the process is fairly simple.
    We simply need to read from our diffuse map using the normal vector.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染具有漫反射图像光照的场景，过程相当简单。我们只需使用法线向量从我们的漫反射贴图中读取。
- en: 'The vertex shader just converts the position and normal to world coordinates
    and passes them along:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器只是将位置和法线转换为世界坐标，并将它们传递下去：
- en: '[PRE38]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The fragment shader then uses the diffuse convolution map to determine the
    value of the integral, multiplies it by a color taken from a texture map, and
    applies gamma correction:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器随后使用漫反射卷积图来确定积分的值，将其乘以从纹理图中取出的颜色，并应用伽玛校正：
- en: '[PRE39]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Results for the environment shown in the introduction to this recipe are shown
    in the following screenshot:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱引言中展示的环境图的结果如下截图所示：
- en: '![](img/964e0e63-4936-4320-924c-3be121850676.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/964e0e63-4936-4320-924c-3be121850676.png)'
- en: How it works...
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Once we've created the diffuse convolution, there's not much to this technique.
    We just simply look up the value in the convolved map `DiffConvTex` and multiply
    it with the base color of the surface. In this example, the base color for the
    surface is taken from a second texture map (`ColorTex`). We apply gamma decoding
    to the base color texture to move it into linear color space before multiplying
    with the environment map. This assumes that the texture is stored in sRGB or has
    already been gamma encoded. The final value is then gamma encoded before display.
    The values in the environment map are in linear color space, so we need to move
    everything to linear space before combining. For some details about gamma encoding/decoding,
    please see the *Using gamma correction* *to improve image quality *recipe in [Chapter
    6](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Image Processing and Screen Space
    Techniques*.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了扩散卷积，这项技术就没有太多内容了。我们只需简单地查找卷积映射 `DiffConvTex` 中的值，并将其与表面的基础颜色相乘。在这个例子中，表面的基础颜色是从第二个纹理映射
    (`ColorTex`) 中获取的。我们在将基础颜色纹理与环境映射相乘之前，对其应用伽玛解码，将其移动到线性颜色空间。这假设纹理存储在 sRGB 或已经过伽玛编码。最终值在显示前进行伽玛编码。环境映射中的值位于线性颜色空间，因此我们需要在组合之前将所有内容移动到线性空间。有关伽玛编码/解码的更多细节，请参阅[第
    6 章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中的*使用伽玛校正来提高图像质量*配方，*图像处理和屏幕空间技术*。
- en: There's more...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It would also be nice to include a specular/glossy component to this model.
    We didn't cover that here. In addition, it would be nice to include proper Fresnel
    reflection. Including the specular component is a bit harder because it also depends
    on the direction of the viewer.  There are techniques for creating specular convolutions
    and I'll refer you to the following sources. These usually involve several simplifying
    assumptions to make things achievable in real time.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 还很乐意将镜面/光泽组件包含在这个模型中。这里没有涉及这一点。此外，还应该包括适当的光滑反射。包括镜面组件有点困难，因为它还取决于观察者的方向。有创建镜面卷积的技术，我将参考以下来源。这些通常涉及几个简化假设，以便在实时中实现。
- en: See also
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: The `chapter05/scenediffibl.cpp` file in the example code
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter05/scenediffibl.cpp` 文件
- en: '*Physically Based Rendering*, Third Edition, by Pharr, Jakob, and Humphreys'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《基于物理的渲染》，第三版，作者 Pharr, Jakob, 和 Humphreys
- en: The *Using gamma correction to improve image quality* recipe in [Chapter 6](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Image Processing and Screen Space Techniques*
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 6 章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)中的*使用伽玛校正来提高图像质量*配方，*图像处理和屏幕空间技术*'
- en: For lots of details about the specular contribution with image-based lighting,
    see [http://blog.selfshadow.com/publications/s2013-shading-course/](http://blog.selfshadow.com/publications/s2013-shading-course/)
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关基于图像照明的镜面贡献的详细信息，请参阅[http://blog.selfshadow.com/publications/s2013-shading-course/](http://blog.selfshadow.com/publications/s2013-shading-course/)
