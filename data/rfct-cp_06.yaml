- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Utilizing a Rich Static Type System in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中利用丰富的静态类型系统
- en: In modern software development, the notion of “type” has transcended its primitive
    definition, evolving into a rich and expressive language feature that encapsulates
    more than just data representation. In C++, a language renowned for its performance
    and flexibility, the static type system serves as a powerful tool, enabling developers
    to write code that’s not only robust and efficient but also self-documenting and
    maintainable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，“类型”的概念已经超越了其原始定义，演变成一种丰富且富有表现力的语言特性，它不仅封装了数据表示，还包含了更多内容。在以性能和灵活性著称的
    C++ 语言中，静态类型系统是一个强大的工具，它使开发者能够编写不仅健壮且高效的代码，而且具有自文档化和可维护性的代码。
- en: The significance of types in C++ extends beyond the mere categorization of data.
    By enforcing strict compile-time checks, the language’s type system reduces runtime
    errors, improves readability, and fosters a more intuitive understanding of code.
    With the advent of modern C++ standards, the opportunities to leverage types have
    further expanded, bringing forth elegant solutions to common programming challenges.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类型在 C++ 中的重要性不仅限于对数据的分类。通过强制执行严格的编译时检查，语言的类型系统减少了运行时错误，提高了可读性，并促进了代码的直观理解。随着现代
    C++ 标准的出现，利用类型的机会进一步扩大，为常见的编程挑战提供了优雅的解决方案。
- en: However, these powerful features can often be underutilized. Primitive data
    types such as integers are frequently misused to represent concepts such as time
    durations, leading to code that lacks expressiveness and can be prone to errors.
    Pointers, although flexible, can lead to null dereferencing issues, making the
    code base fragile.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些强大的功能往往没有得到充分利用。原始数据类型，如整数，经常被错误地用来表示时间长度等概念，导致代码缺乏表现力且容易出错。指针虽然灵活，但可能导致空指针解引用问题，使代码库变得脆弱。
- en: In this chapter, we’ll explore the rich landscape of C++’s static type system,
    focusing on advanced and modern techniques that help to mitigate these problems.
    From using the `<chrono>` library to represent time durations to employing `not_null`
    wrappers and `std::optional` for safer pointer handling, we’ll delve into practices
    that embody the essence of strong typing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 C++ 静态类型系统的丰富景观，重点关注帮助减轻这些问题的先进和现代技术。从使用 `<chrono>` 库来表示时间长度到使用 `not_null`
    包装器和 `std::optional` 进行更安全的指针处理，我们将深入研究体现强类型本质的实践。
- en: We’ll also look at external libraries such as Boost, which offer additional
    utilities to enhance type safety. Throughout the chapter, real-world examples
    will illustrate how these tools and techniques can be seamlessly integrated into
    your code, empowering you to harness the full potential of C++’s type system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如 Boost 这样的外部库，它们提供了额外的实用工具来增强类型安全性。在整个章节中，现实世界的例子将说明这些工具和技术如何无缝集成到你的代码中，赋予你充分利用
    C++ 类型系统的全部潜力。
- en: By the end of this chapter, you’ll gain a deep understanding of how to utilize
    types to write more robust, readable, and expressive code, tapping into the true
    power of C++.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深入理解如何利用类型来编写更健壮、可读性和表现力更强的代码，挖掘 C++ 真正的潜力。
- en: Utilizing Chrono for time duration
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Chrono 进行时间长度
- en: One of the best examples of how C++’s type system can be leveraged to write
    more robust code is the `<chrono>` library. Introduced in C++11, this header provides
    a set of utilities to represent time durations and points in time, as well as
    perform time-related operations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 类型系统如何被利用来编写更健壮的代码的最好例子之一是 `<chrono>` 库。自 C++11 引入以来，这个头文件提供了一套表示时间长度和时间点的实用工具，以及执行时间相关操作。
- en: 'Managing time-related functions using plain integers or structures such as
    `timespec` can be a bug-prone approach, especially when dealing with different
    units of time. Imagine a function that takes an integer representing a timeout
    in seconds:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通整数或如 `timespec` 这样的结构来管理时间相关函数可能是一种容易出错的途径，尤其是在处理不同时间单位时。想象一个接受表示秒数的整数的函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach lacks flexibility and can lead to confusion when handling various
    time units. For example, if a caller mistakenly passes milliseconds instead of
    seconds, it can cause unexpected behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法缺乏灵活性，在处理各种时间单位时可能会导致混淆。例如，如果调用者错误地传递了毫秒而不是秒，可能会导致意外的行为。
- en: 'By contrast, using `<chrono>` to define the same function makes the code more
    robust and expressive:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用 `<chrono>` 定义相同的函数使代码更加健壮和具有表现力：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The caller can now pass the timeout using a strongly-typed duration, such as
    `std::chrono::seconds(5)`, and the compiler ensures that the correct unit is used.
    Moreover, `<chrono>` provides seamless conversion between different time units,
    allowing the caller to specify the timeout in seconds, milliseconds, or any other
    unit, without ambiguity. The following snippet illustrates the usage with different
    units:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者现在可以使用强类型持续时间传递超时，例如 `std::chrono::seconds(5)`，编译器确保使用正确的单位。此外，`<chrono>`
    提供了不同时间单位之间的无缝转换，允许调用者以秒、毫秒或其他任何单位指定超时，而不存在歧义。以下代码片段展示了使用不同单位的用法：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By embracing the strong typing offered by `<chrono>`, the code becomes clearer,
    more maintainable, and less susceptible to common bugs related to time representation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用 `<chrono>` 提供的强类型，代码变得更加清晰、易于维护，并且不太可能受到与时间表示相关的常见错误的影响。
- en: Improving Pointer Safety with not_null and std::optional
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `not_null` 和 `std::optional` 提高指针安全性
- en: In C++, pointers are a fundamental part of the language, allowing direct memory
    access and manipulation. However, the flexibility that pointers offer comes with
    certain risks and challenges. Here, we’ll explore how modern C++ techniques can
    enhance pointer safety.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，指针是语言的基本组成部分，允许直接访问和操作内存。然而，指针提供的灵活性也伴随着一定的风险和挑战。在这里，我们将探讨现代 C++ 技术如何增强指针安全性。
- en: The pitfalls of raw pointers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始指针的陷阱
- en: Raw pointers, while powerful, can be a double-edged sword. They provide no information
    about the ownership of the object they point to, and they can easily become “dangling”
    pointers, pointing to memory that has been deallocated. Dereferencing a null or
    dangling pointer leads to undefined behavior, which can result in hard-to-diagnose
    bugs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原始指针虽然强大，但可能是一把双刃剑。它们不会提供关于它们指向的对象所有权的任何信息，并且它们很容易成为“悬空”指针，指向已经被释放的内存。取消引用空指针或悬空指针会导致未定义的行为，这可能导致难以诊断的错误。
- en: Using not_null from the Guidelines Support Library
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指南支持库中的 `not_null`
- en: 'The `not_null` wrapper provided by the `not_null`, you can clearly signal that
    a pointer should never be null:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `not_null` 提供的包装器可以清楚地表明指针不应为空：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If a user passes a null pointer to this function as follows, the application
    will be terminated:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户以如下方式将空指针传递给此函数，应用程序将被终止：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, if the pointer is passed as `process_data(nullptr)`, the application
    will fail in compile time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果指针作为 `process_data(nullptr)` 传递，应用程序将在编译时失败：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This promotes robust code by catching potential null pointer errors early, thus
    reducing runtime errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过在早期捕获潜在的空指针错误来促进代码的健壮性，从而减少运行时错误。
- en: Extending not_null to smart pointers
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 `not_null` 扩展到智能指针
- en: '`gsl::not_null` is not limited to raw pointers; it can also be used with smart
    pointers such as `std::unique_ptr` and `std::shared_ptr`. This allows you to combine
    the benefits of modern memory management with the additional safety guarantees
    that `not_null` provides.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`gsl::not_null` 不仅限于原始指针；它还可以与智能指针如 `std::unique_ptr` 和 `std::shared_ptr` 结合使用。这允许你结合现代内存管理的优点以及
    `not_null` 提供的额外安全保证。'
- en: With std::unique_ptr
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `std::unique_ptr`
- en: '`std::unique_ptr` ensures that the ownership of a dynamically allocated object
    is unique, and it automatically deletes the object when it is no longer needed.
    By using `not_null` with `unique_ptr`, you can also ensure that the pointer is
    never null:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 确保动态分配的对象的所有权是唯一的，并且当不再需要对象时，它会自动删除该对象。通过使用 `not_null` 与
    `unique_ptr` 结合，你也可以确保指针永远不会为空：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With std::shared_ptr
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `std::shared_ptr`
- en: 'Similarly, `gsl::not_null` can be used with `std::shared_ptr`, which enables
    shared ownership of an object. This allows you to write functions that accept
    shared pointers without having to worry about nullity:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`gsl::not_null` 可以与 `std::shared_ptr` 结合使用，这使对象具有共享所有权。这允许你编写接受共享指针的函数，而无需担心空指针：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These examples demonstrate how `not_null` can seamlessly integrate with modern
    C++ memory management techniques. By enforcing that a pointer (whether raw or
    smart) cannot be null, you further reduce the potential for runtime errors and
    make code more robust and expressive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了 `not_null` 如何无缝地与现代 C++ 内存管理技术集成。通过强制指针（无论是原始指针还是智能指针）不能为空，你进一步减少了运行时错误的可能性，并使代码更加健壮和易于表达。
- en: Utilizing std::optional for optional values
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 `std::optional` 处理可选值
- en: 'Sometimes, a pointer is used to indicate an optional value, where `nullptr`
    signifies the absence of a value. C++17 introduced `std::optional`, which provides
    a type-safe way to represent optional values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，指针用于表示可选值，其中`nullptr`表示值的缺失。C++17引入了`std::optional`，它提供了一种类型安全地表示可选值的方法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using `std::optional` provides clear semantics and avoids the pitfalls associated
    with using pointers for this purpose.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::optional`提供清晰的语义并避免使用指针进行此目的时的陷阱。
- en: A comparison between raw pointers and nullptr
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始指针与nullptr的比较
- en: Both `not_null` and `std::optional` offer advantages over raw pointers. While
    raw pointers can be null or dangling, leading to undefined behavior, `not_null`
    prevents null pointer errors at compile time, and `std::optional` provides a clear
    way to represent optional values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_null`和`std::optional`都优于原始指针。虽然原始指针可以是null或悬空，导致未定义行为，但`not_null`在编译时防止null指针错误，而`std::optional`提供了一种清晰地表示可选值的方法。'
- en: 'Consider the following example using raw pointers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用原始指针的示例：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code might lead to confusion and bugs, especially if the caller forgets
    to check for `nullptr`. By using `not_null` and `std::optional`, you can make
    the code more expressive and less error-prone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能会导致混淆和错误，尤其是如果调用者忘记检查`nullptr`。通过使用`not_null`和`std::optional`，可以使代码更具表达性且更不易出错。
- en: Leveraging std::expected for expected results and errors
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用std::expected获取预期结果和错误
- en: While `std::optional` elegantly represents an optional value, sometimes you
    need to convey more information about why a value might be missing. In such cases,
    `std::expected` provides a way to return either a value or an error code, making
    code more expressive and the error handling more robust.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::optional`优雅地表示了可选值，但有时你需要传达更多关于值可能缺失的原因的信息。在这种情况下，`std::expected`提供了一种返回值或错误代码的方法，使代码更具表达性，错误处理更健壮。
- en: 'Consider a scenario where you have a function that retrieves a value from a
    network, and you want to handle network errors. You might define an enumeration
    for the various network errors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你有一个从网络获取值的函数，并且你想处理网络错误。你可能为各种网络错误定义一个枚举：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can then use `std::expected` to define a function that returns either an
    `int` value or `NetworkError`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`std::expected`定义一个返回`int`值或`NetworkError`的函数：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `std::expected` captures both the successful case and various error scenarios,
    allowing for clear and type-safe error handling. This example illustrates how
    modern C++ types such as `std::expected` enhance expressiveness and safety, allowing
    you to write code that more accurately models complex operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`std::expected`同时捕获了成功情况和各种错误场景，允许进行清晰且类型安全的错误处理。这个例子说明了现代C++类型如`std::expected`如何增强表达性和安全性，使你能够编写更精确地模拟复杂操作的代码。
- en: By embracing these modern C++ tools, you can enhance pointer safety in your
    code, reducing bugs and making your intentions clear.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这些现代C++工具，你可以增强代码中的指针安全性，减少错误并使你的意图更清晰。
- en: Strong typing with enum class and scoped enumerations
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用enum class和范围枚举的强类型
- en: Strong typing is a cornerstone of robust, maintainable software, and C++ provides
    several mechanisms to facilitate it. Among these, `enum class`, introduced in
    C++11, is a particularly effective tool for creating strongly typed enumerations
    that can make your programs both more robust and easier to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型是健壮、可维护的软件的基石，C++提供了多种机制来促进其实现。在这些机制中，C++11中引入的`enum class`是一个特别有效的工具，用于创建强类型枚举，可以使你的程序更健壮且更容易理解。
- en: A review of enum class
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对enum class的回顾
- en: 'Traditional enumerations in C++ suffer from a few limitations – they can implicitly
    convert to integers, potentially causing errors if misused, and their enumerators
    are introduced into the enclosing scope, leading to name clashes. `enum class`,
    also known as scoped enumerations, addresses these limitations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的传统枚举存在一些限制——它们可以隐式转换为整数，如果误用可能会导致错误，并且它们的枚举符被引入到封装作用域中，导致名称冲突。`enum class`，也称为范围枚举，解决了这些限制：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The benefits over traditional enums
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相比传统枚举的优势
- en: 'Scoped enumerations offer several advantages:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 范围枚举提供了一些优势：
- en: '`enum class` type and integers, ensuring that you can’t accidentally misuse
    an enumerator as an integer'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum class`类型和整数，确保你不会意外地将枚举符用作整数'
- en: '`enum class`, reducing the likelihood of name collisions'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum class`，减少了名称冲突的可能性'
- en: '`enum class` allows you to explicitly specify the underlying type, giving you
    precise control over the data representation:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum class` 允许你显式指定底层类型，从而让你对数据表示有精确的控制：'
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The ability to specify the underlying type is particularly useful for serializing
    data to binary formats. It ensures that you have fine-grained control over how
    the data is represented at the byte level, facilitating easier data interchange
    with systems that may have specific binary format requirements.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 能够指定底层类型对于将数据序列化为二进制格式特别有用。它确保你可以在字节级别对数据的表示有精细的控制，从而便于与可能具有特定二进制格式要求的系统进行数据交换。
- en: Real-world scenarios
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际应用场景
- en: 'The advantages of `enum class` make it a powerful tool for various scenarios:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum class` 的优点使其成为各种场景中的强大工具：'
- en: '`enum class` provides a type-safe, expressive way to represent various possible
    states'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum class` 提供了一种类型安全、具有表现力的方式来表示各种可能的状态'
- en: '**Option sets**: Many functions have multiple behavior options, which can be
    neatly and safely encapsulated using scoped enumerations'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项集**：许多函数有多种行为选项，可以使用范围枚举清晰地和安全地封装'
- en: '`enum class`:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum class`：'
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using `enum class` to create strongly typed, scoped enumerations, you can
    write code that is not only easier to understand but also less prone to errors.
    This feature represents another step forward in C++’s ongoing evolution toward
    a language that combines high performance with modern programming conveniences.
    Whether you’re defining a complex state machine or simply trying to represent
    multiple options or statuses, `enum class` offers a robust, type-safe solution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `enum class` 创建强类型、范围枚举，你可以编写不仅更容易理解而且更不容易出错的代码。这一特性代表了C++持续向结合高性能与现代编程便利性的语言发展的又一步。无论你是定义复杂的有限状态机还是仅仅尝试表示多个选项或状态，`enum
    class` 都提供了一个健壮、类型安全的解决方案。
- en: Leveraging the standard library’s type utilities
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用标准库的类型实用工具
- en: Modern C++ offers a rich set of type utilities within the Standard library that
    enables developers to write more expressive, type-safe, and maintainable code.
    Two prominent examples are `std::variant` and `std::any`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++在标准库中提供了一套丰富的类型实用工具，使开发者能够编写更具有表现力、类型安全和可维护的代码。两个突出的例子是 `std::variant`
    和 `std::any`。
- en: std::variant – a type-safe union
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::variant – 一个类型安全的联合体
- en: '`std::variant` provides a type-safe way to represent a value that can be one
    of several possible types. Unlike a traditional `union`, which allows the programmer
    to treat the stored value as any of its member types, leading to potential undefined
    behavior, `std::variant` tracks the currently held type and ensures proper handling:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant` 提供了一种类型安全的方式来表示一个值，它可以属于几种可能类型中的一种。与允许程序员将存储的值视为其成员类型之一的传统 `union`
    不同，这可能导致潜在的不确定行为，`std::variant` 跟踪当前持有的类型并确保适当的处理：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The benefits over traditional unions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相比传统联合体的优势
- en: '`std::variant`, conversely, keeps track of the current type and provides safe
    access through functions such as `std::get` and `std::holds_alternative`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant` 相反，跟踪当前类型并通过如 `std::get` 和 `std::holds_alternative` 等函数提供安全访问。'
- en: '`std::variant` automatically constructs and destroys the held object when you
    assign a new value, managing the object’s lifetime correctly.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant` 在你分配新值时自动构造和销毁所持有的对象，正确地管理对象的生命周期。'
- en: '`std::get`, a `std::bad_variant_access` exception is thrown, making error handling
    more transparent and easier to manage.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::get`，如果抛出 `std::bad_variant_access` 异常，使得错误处理更加透明且易于管理。'
- en: '`std::variant` can be used with standard library functions such as `std::visit`,
    providing elegant ways to handle various types.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::variant` 可以与标准库函数如 `std::visit` 一起使用，提供优雅地处理各种类型的方法。'
- en: std::any – type-safe containers for any type
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::any – 任何类型的类型安全容器
- en: '`std::any` is a container that can hold any type but maintains type safety
    by requiring explicit casting to the correct type. This allows for flexible handling
    of data without sacrificing type integrity:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::any` 是一个可以容纳任何类型的容器，但通过要求显式转换为正确的类型来保持类型安全。这允许灵活地处理数据，同时不牺牲类型完整性：'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The advantages of using `std::any` include the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `std::any` 的优点包括以下：
- en: '**Flexibility**: It can store any type, making it suitable for heterogeneous
    collections or flexible APIs'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：它可以存储任何类型，使其适合异构集合或灵活的API'
- en: '**Type safety**: Requires explicit casting, preventing accidental misinterpretation
    of the contained value'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：需要显式转换，防止意外误解包含的值'
- en: '**Encapsulation**: Allows you to pass around values without exposing their
    concrete types, supporting more modular and maintainable code'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：允许你传递值而不暴露它们的具体类型，支持更模块化和可维护的代码'
- en: Advanced type techniques
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级类型技术
- en: As you delve deeper into C++, you’ll find that the language offers an array
    of advanced techniques for enhancing type safety, readability, and maintainability.
    In this section, we’ll explore a few of these advanced concepts, providing practical
    examples for each.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 C++ 的深入研究，你会发现该语言提供了一系列高级技术来增强类型安全、可读性和可维护性。在本节中，我们将探讨这些高级概念中的几个，并为每个提供实际示例。
- en: Templates – specializing for type safety
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板 – 为类型安全而特化
- en: Templates are a powerful feature in C++, but you may want to impose certain
    constraints or specializations based on types. One way to do this is via template
    specialization, which allows you to define custom behavior for certain types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是 C++ 中的一个强大功能，但你可能希望根据类型施加某些约束或特化。一种方法是通过模板特化来实现，这允许你为某些类型定义自定义行为。
- en: 'For example, let’s say you have a generic function to find the maximum element
    in an array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个用于在数组中查找最大元素的泛型函数：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s say you want to provide a specialized implementation for `std::string`
    that is case-insensitive:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想为 `std::string` 提供一个不区分大小写的专用实现：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this specialized version, calls to `find_max` with `std::string` will use
    a case-insensitive comparison.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个专用版本，调用 `find_max` 并使用 `std::string` 将进行不区分大小写的比较。
- en: Creating custom type traits
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义类型特性
- en: 'Sometimes, the standard type traits may not be sufficient for your needs. You
    can create your own custom type traits to encapsulate type-based logic. For instance,
    you might want a type trait to identify whether a class has a specific member
    function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，标准类型特性可能不足以满足你的需求。你可以创建自己的自定义类型特性来封装基于类型的逻辑。例如，你可能需要一个类型特性来识别一个类是否具有特定的成员函数：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can use this custom trait like any other type trait:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用任何其他类型特性一样使用这个自定义特性：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type aliases for readability and maintainability
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型别名以提高可读性和可维护性
- en: 'Type aliases can improve the readability and maintainability of your code by
    providing meaningful names for complex types. For example, instead of writing
    out `std::unordered_map<std::string, std::vector<int>>` repeatedly, you could
    create a type alias:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名可以通过为复杂类型提供有意义的名称来提高你代码的可读性和可维护性。例如，你不必反复写出 `std::unordered_map<std::string,
    std::vector<int>>`，你可以创建一个类型别名：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, you can use `StringToIntVectorMap` in your code, making it more readable
    and easier to maintain:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在你的代码中使用 `StringToIntVectorMap`，这使得代码更易于阅读和维护：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Type aliases can also be templated, allowing for even more flexibility:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以是模板化的，这提供了更大的灵活性：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By employing these advanced type techniques, you add another layer of safety,
    readability, and maintainability to your C++ code. These methods give you more
    control over how types behave in templates, how they’re checked, and how they’re
    represented, ensuring that you can write code that’s as robust as it is efficient.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些高级类型技术，你为你的 C++ 代码增加了另一层安全性、可读性和可维护性。这些方法让你能够更好地控制模板中类型的行为、检查方式和表示方式，确保你可以编写既健壮又高效的代码。
- en: Avoiding common pitfalls in advanced type usage
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免高级类型使用中的常见陷阱
- en: Writing robust code with type checks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过类型检查编写健壮的代码
- en: Type-checking is one of the pillars that contributes to the robustness and safety
    of a program. While C++ is strongly typed, it does allow for some flexibility
    (or leniency, depending on your perspective) that can lead to errors if not carefully
    managed. Here are some techniques and best practices to write robust C++ code
    by leveraging type checks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查是构成程序健壮性和安全性的支柱之一。虽然 C++ 是强类型语言，但它确实允许一些灵活性（或宽容性，取决于你的观点），如果不小心管理，可能会导致错误。以下是一些技术和最佳实践，通过利用类型检查来编写健壮的
    C++ 代码。
- en: Using type traits for compile-time checks
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型特性进行编译时检查
- en: 'The C++ Standard library offers a set of type traits in the `<type_traits>`
    header, which allows you to inspect and make decisions based on types at compile
    time. For example, if you have a generic function that should only accept unsigned
    integral types, you can enforce this using `static_assert`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库在 `<type_traits>` 头文件中提供了一套类型特性，它允许你在编译时根据类型进行检查和做出决策。例如，如果你有一个只应接受无符号整型类型的泛型函数，你可以使用
    `static_assert` 来强制执行这一点：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Leveraging constexpr if
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用 constexpr if
- en: 'C++17 introduced `constexpr if`, enabling you to write conditional code that’s
    evaluated at compile time. This can be very useful for type-specific operations
    in template code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C++17 引入了 `constexpr if`，这使得您能够编写在编译时评估的条件代码。这在模板代码中的类型特定操作中非常有用：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Strong types for function arguments
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数的强类型
- en: 'C++ allows type aliases, which can sometimes make it difficult to understand
    the purpose of a function argument. For example, a function declared as `void
    process(int, int);` is not very informative. Is the first integer a length? Is
    the second one an index? One way to mitigate this is by using strong type definitions,
    such as the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 允许类型别名，这有时会使理解函数参数的目的变得困难。例如，声明为 `void process(int, int);` 的函数并不很有信息量。第一个整数是长度吗？第二个是索引吗？减轻这种困难的一种方法是通过使用强类型定义，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, the function signature provides semantic meaning, making it less likely
    for the developer to swap the arguments accidentally.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，函数签名提供了语义意义，使得开发者更不可能意外地交换参数。
- en: Implicit conversions and type coercion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式转换和类型强制
- en: A case of accidental file creation
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 意外创建文件的情况
- en: 'In C++ development, it’s common to define classes with constructors that accept
    various argument types for flexibility. However, this comes with the risk of unintentional
    implicit conversions. To illustrate this point, consider the following code snippet
    involving a `File` class and a `clean` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 开发中，定义接受各种参数类型的构造函数的类是常见的，这样做可以提供灵活性。然而，这也伴随着无意中发生隐式转换的风险。为了说明这一点，考虑以下涉及
    `File` 类和 `clean` 函数的代码片段：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output demonstrates the issue clearly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地展示了问题：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The compiler automatically converts `std::string` to a `File` object due to
    the absence of the `explicit` keyword in the constructor, thereby triggering an
    unintended side-effect – the creation of a new file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数中缺少 `explicit` 关键字，编译器会自动将 `std::string` 转换为 `File` 对象，从而触发一个意外的副作用——创建一个新的文件。
- en: The utility of explicit
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明确性的效用
- en: 'To mitigate such risks, the `explicit` keyword can be employed. By marking
    a constructor as `explicit`, you instruct the compiler to disallow implicit conversions
    for that constructor. Here’s how the corrected `File` class would look:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这些风险，可以使用 `explicit` 关键字。通过将构造函数标记为 `explicit`，您指示编译器不允许对该构造函数进行隐式转换。以下是修正后的
    `File` 类的示例：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With this change, the `clean(random_string);` line would result in a compilation
    error, effectively preventing accidental file creation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，`clean(random_string);` 这一行将导致编译错误，从而有效地防止意外创建文件。
- en: A light-hearted caveat
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个轻松的注意事项
- en: While our example might be somewhat simplified for educational purposes (yes,
    there’s no need to roll your own `File` class – we have libraries for that!),
    it serves to underline a critical aspect of type safety in C++. A seemingly innocuous
    constructor can lead to unexpected behavior if not explicitly guarded against
    implicit conversions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例可能为了教育目的而有所简化（是的，您不需要自己编写 `File` 类——我们有库可以做到这一点！），但它有助于强调 C++ 中类型安全的一个关键方面。一个看似无害的构造函数，如果没有明确防范隐式转换，可能会导致意外的行为。
- en: So, remember, when you’re defining constructors, it pays to be explicit about
    your intentions. You never know when you might accidentally start a “file party”
    you never intended to host.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请记住，当您定义构造函数时，明确您的意图是值得的。您永远不知道何时可能会意外地开始一个您从未打算举办的“文件派对”。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we’ve traversed the vast landscape of C++’s rich static type system, it’s
    worth taking a moment to reflect on how far we’ve come. From the earliest days
    of C++, where raw pointers and loosely typed arrays reigned supreme, to the modern
    era of `std::optional`, `std::variant`, and `enum class`, the language has evolved
    substantially in its approach to type safety.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们穿越了 C++ 丰富的静态类型系统广阔的领域后，值得花点时间反思我们已经走了多远。从 C++ 最早的那些日子里，原始指针和松散类型数组占据主导地位，到现代的
    `std::optional`、`std::variant` 和 `enum class` 时代，语言在处理类型安全的方法上已经发生了显著的变化。
- en: The real power of these advances shines through when we consider how they improve
    not just individual code snippets but also entire software systems. Embracing
    C++’s robust type constructs can help us write safer, more readable, and ultimately,
    more maintainable code. Features such as the `std::optional` and `not_null` wrappers
    reduce the chance of null pointer errors. Advanced techniques such as template
    specialization and custom type traits offer unprecedented control over type behavior.
    These are not just academic exercises; they are practical tools for the everyday
    C++ programmer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑这些进步如何不仅改进单个代码片段，而且改进整个软件系统时，这些进步的真实力量才会显现出来。拥抱 C++ 的强大类型结构可以帮助我们编写更安全、更易读、最终更易于维护的代码。例如，`std::optional`
    和 `not_null` 包装器可以减少空指针错误的可能性。高级技术，如模板特化和自定义类型特性，提供了对类型行为的无与伦比的控制。这些不仅仅是学术练习；它们是日常
    C++ 程序员的实际工具。
- en: Looking ahead, the trajectory of C++ suggests an increasingly nuanced and powerful
    type system. As the language continues to evolve, who knows what innovative type-related
    features may lie on the horizon? Perhaps future versions of C++ will offer even
    more dynamic type checking, or maybe they’ll introduce new constructs that we
    can’t yet imagine.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，C++ 的轨迹表明类型系统将变得更加精细和强大。随着语言不断发展，谁知道未来版本的 C++ 将会带来哪些创新类型相关的特性？也许未来的 C++
    将提供更动态的类型检查，或者它们可能会引入我们目前还无法想象的新的结构。
- en: In the next chapter, we’ll pivot from the nitty-gritty of types to the grand
    architecture of classes, objects, and object-oriented programming in C++. While
    types give us the building blocks, it’s these larger constructs that help us assemble
    those blocks into towering structures of sustainable software design. Until then,
    may your types be strong, your pointers never null, and your code forever robust.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从类型的基础知识转向 C++ 中类、对象和面向对象编程的宏伟架构。虽然类型为我们提供了构建块，但正是这些更大的结构帮助我们将这些块组装成可持续的软件设计的摩天大楼。在此之前，愿你的类型强大，指针永不空，代码永远稳健。
