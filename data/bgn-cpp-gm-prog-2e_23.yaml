- en: '*Chapter 22*: Using Game Objects and Building a Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 22 章*：使用游戏对象和构建游戏'
- en: This chapter is the final stage of the Space Invaders ++ project. We will learn
    how to receive input from a gamepad using SFML to do all the hard work and we
    will also code a class that will handle communication between the invaders and
    the `GameScreen` class, as well as the player and the `GameScreen` class. The
    class will allow the player and the invaders to spawn bullets, but the exact same
    technique could be used for any kind of communication that you need between different
    parts of your own game, so it is useful to know. The final part of the game (as
    usual) will be the collision detection and the logic of the game itself. Once
    Space Invaders ++ is up and running, we will learn how to use the Visual Studio
    debugger, which will be invaluable when you are designing your own logic because
    it allows you to step through your code a line at a time and see the value of
    variables. It is also a useful tool for studying the execution flow of the patterns
    we have assembled over the course of this project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 Space Invaders ++ 项目的最终阶段。我们将学习如何使用 SFML 从游戏手柄接收输入以完成所有困难的工作，我们还将编写一个类，该类将处理入侵者与
    `GameScreen` 类以及玩家与 `GameScreen` 类之间的通信。该类将允许玩家和入侵者生成子弹，但同样的技术也可以用于你游戏中不同部分之间所需的任何类型的通信，因此了解它是很有用的。游戏的最后一部分（就像往常一样）将是碰撞检测和游戏本身的逻辑。一旦
    Space Invaders ++ 运行起来，我们将学习如何使用 Visual Studio 调试器，这在设计你自己的逻辑时将非常有价值，因为它允许你逐行执行代码并查看变量的值。它也是研究我们在整个项目过程中构建的模式执行流程的有用工具。
- en: 'Here is what we will do in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Code a solution for spawning bullets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写生成子弹的解决方案
- en: Handle the player's input, including with a gamepad
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家的输入，包括使用游戏手柄
- en: Detect collisions between all the necessary objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测所有必要对象之间的碰撞
- en: Code the main logic of the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏的主要逻辑
- en: Learn about debugging and understand the execution flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解调试并理解执行流程
- en: Let's start by spawning bullets.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从生成子弹开始。
- en: Spawning bullets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成子弹
- en: We need a way to spawn bullets from both the player and each of the invaders.
    The solutions to both are very similar but not identical. We need a way to allow
    `GameInputHandler` to spawn bullets when a keyboard key or gamepad button is pressed,
    and we need `InvaderUpdateComponent` to use its already existing logic to spawn
    bullets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法，从玩家和每个入侵者那里生成子弹。这两个解决方案非常相似，但并不完全相同。我们需要一种方法，允许 `GameInputHandler`
    在按下键盘键或游戏手柄按钮时生成子弹，并且我们需要 `InvaderUpdateComponent` 使用其现有的逻辑来生成子弹。
- en: The `GameScreen` class has a `vector` holding all the `GameObject` instances,
    so `GameScreen` is the ideal candidate to move a bullet into position and set
    it moving up or down the screen, depending on who or what triggered the shot.
    We need a way for the `GameInputHandler` class and `InvaderUpdateComponenet` to
    communicate with the `GameScreen` class, but we also need to restrict the communication
    to just spawning bullets; we don't want them to be able to take control of any
    other part of the `GameScreen` class.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameScreen` 类有一个 `vector`，其中包含所有 `GameObject` 实例，因此 `GameScreen` 是将子弹移动到位置并设置其向上或向下移动屏幕的理想候选者，这取决于谁或什么触发了射击。我们需要一种方法，让
    `GameInputHandler` 类和 `InvaderUpdateComponenet` 与 `GameScreen` 类通信，但我们还需要将通信限制在仅生成子弹；我们不希望它们能够控制
    `GameScreen` 类的任何其他部分。'
- en: Let's code an abstract class that `GameScreen` can inherit from.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个抽象类，`GameScreen` 可以从中继承。
- en: Coding the BulletSpawner class
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 BulletSpawner 类
- en: 'Create a new header file in the `Header Files/GameObjects` filter called `BulletSpawner.h`
    and add the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Header Files/GameObjects` 过滤器中创建一个新的头文件，命名为 `BulletSpawner.h`，并添加以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code creates a new class called `BulletSpawner` with a single
    pure virtual function called `spawnBullet`. The `spawnBullet` function has two
    parameters. The first is a `Vector2f` instance that will determine the spawn location.
    Actually, as we will see soon, when the bullet is spawned, this position will
    be tweaked slightly, depending on whether the bullet is going up the screen (as
    a player bullet) or down the screen (as an invader bullet). The second parameter
    is a Boolean that will be true if the bullet belongs to the player or false if
    it belongs to an invader.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为 `BulletSpawner` 的新类，它有一个名为 `spawnBullet` 的单一纯虚函数。`spawnBullet` 函数有两个参数。第一个参数是一个
    `Vector2f` 实例，它将确定生成位置。实际上，正如我们很快将看到的，当子弹生成时，这个位置将根据子弹是向上屏幕移动（作为玩家子弹）还是向下屏幕移动（作为入侵者子弹）而略有调整。第二个参数是一个布尔值，如果子弹属于玩家则为真，如果属于入侵者则为假。
- en: 'Create a new source file in the `Source Files/GameObjects` filter called `BulletSpawner.cpp`
    and add the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Source Files/GameObjects` 过滤器中创建一个新的源文件，名为 `BulletSpawner.cpp`，并添加以下代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: As usual, this`.cpp` file is optional. I just wanted to bring balance to the
    source.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，这个 `.cpp` 文件是可选的。我只是想平衡一下源代码。
- en: Now, go to `GameScreen.h`, since this is where we will implement the function
    of this class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 `GameScreen.h` 文件，因为这里是我们将实现这个类功能的地方。
- en: Updating GameScreen.h
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 GameScreen.h
- en: 'First, update the include directives and the class declaration, as highlighted
    in the following code, to make the `GameScreen` class inherit from `BulletSpawner`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新以下代码中的包含指令和类声明，以使 `GameScreen` 类继承自 `BulletSpawner`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, add some extra functions and variable declarations, as highlighted in
    the following code, to `GameScreen.h`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一些额外的函数和变量声明，如以下代码所示，到 `GameScreen.h` 中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The new variables include a `vector` of `int` values that will hold the locations
    of all the bullets in the `vector`, which holds all the game objects. It also
    has a few control variables so that we can keep track of the next bullet to use,
    whether the bullet is for the player or an invader, and the position to spawn
    the bullet in. We have also declared a new `sf::Clock` instance because we want
    to limit the fire rate of the player. Finally, we have the `getBulletSpawner`
    function, which will return a pointer to this class in the form of a `BulletSpawner`.
    This will give the recipient access to the `spawnBullet` function, but nothing
    else.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 新变量包括一个 `int` 值的 `vector`，它将保存所有子弹的位置，这些子弹位于包含所有游戏对象的 `vector` 中。它还有一些控制变量，以便我们可以跟踪下一个要使用的子弹，子弹是针对玩家还是入侵者，以及生成子弹的位置。我们还声明了一个新的
    `sf::Clock` 实例，因为我们想限制玩家的射击速率。最后，我们有 `getBulletSpawner` 函数，它将以 `BulletSpawner`
    的形式返回对这个类的指针。这将使接收者能够访问 `spawnBullet` 函数，但无法访问其他内容。
- en: 'Now, we can add the implementation of the `spawnBullet` function. Add the following
    code to `GameScreen.h` at the end of all the other code, but inside the closing
    curly brace of the `GameScreen` class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加 `spawnBullet` 函数的实现。将以下代码添加到 `GameScreen.h` 文件的末尾，所有其他代码之后，但位于 `GameScreen`
    类的闭合花括号内：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The implementation of the `spawnBullet` function is a simple `if` – `else` structure.
    The `if` block executes if a bullet is requested for the player and the `else`
    block executes if a bullet is requested for an invader.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawnBullet` 函数的实现是一个简单的 `if` – `else` 结构。如果请求为玩家生成子弹，则执行 `if` 块；如果请求为入侵者生成子弹，则执行
    `else` 块。'
- en: The `if` block checks that at least half a second has passed since the last
    bullet was requested and, if it has, the `m_WaitingToSpawnBulletForPlayer` variable
    is set to true, the location to spawn the bullet at is copied, and the clock is
    restarted, ready to test the player's next request.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 块检查自上次请求子弹以来是否至少过去了半秒钟，如果是，则将 `m_WaitingToSpawnBulletForPlayer` 变量设置为
    `true`，复制生成子弹的位置，并重新启动时钟，准备测试玩家的下一个请求。'
- en: The `else` block records the spawn location for an invader's bullet and sets
    `m_WaitingToSpawnBulletForInvader` to `true`. No interaction with the `Clock`
    instance is necessary as the rate of fire for the invaders is controlled in the
    `InvaderUpdateComponent` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 块记录了入侵者子弹的生成位置，并将 `m_WaitingToSpawnBulletForInvader` 设置为 `true`。不需要与
    `Clock` 实例交互，因为入侵者的射击速率在 `InvaderUpdateComponent` 类中控制。'
- en: 'The last part of the `BulletSpawner` puzzle, before we get to actually spawning
    the bullets, is to add the definition of `getBulletSpawner` to the end of `GameScreen.cpp`.
    Here is the code to add:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生成子弹之前，`BulletSpawner` 问题的最后一部分是向 `GameScreen.cpp` 的末尾添加 `getBulletSpawner`
    的定义。以下是需要添加的代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This returns a pointer to `GameScreen`, which gives us access to the `spawnBullet`
    function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个指向 `GameScreen` 的指针，它使我们能够访问 `spawnBullet` 函数。
- en: Handling the player's input
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理玩家的输入
- en: 'Add some more declarations to the `GameInputHandler.h` file so that your code
    matches what follows. I have highlighted the new code to add:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `GameInputHandler.h` 文件中添加更多声明，以便您的代码与以下内容匹配。我已经高亮显示需要添加的新代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `GameInputHandler` class now has access to the player's update component
    and the player's transform component. This is very useful because it means we
    can tell the `PlayerUpdateComponent` instance and the player's `TransformComponent`
    instance what keyboard keys and gamepad controls the player is manipulating. What
    we haven't seen yet is how exactly these two shared pointers will be initialized
    – after all, aren't the `GameObject` instances and all their components packed
    away in a `vector`? You can probably guess the solution has something to do with
    `GameObjectSharer`. Let's keep coding to find out more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameInputHandler` 类现在可以访问玩家的更新组件和玩家的变换组件。这非常有用，因为它意味着我们可以告诉 `PlayerUpdateComponent`
    实例和玩家的 `TransformComponent` 实例玩家正在操作哪些键盘键和游戏手柄控制。我们还没有看到这两个共享指针是如何初始化的——毕竟，`GameObject`
    实例及其所有组件不都是打包在 `vector` 中吗？你可能猜到解决方案与 `GameObjectSharer` 有关。让我们继续编码以了解更多信息。'
- en: 'In the `GameInputHanldler.cpp` file, add a forward declaration of the `BulletSpawner`
    class after the include directives but before the initialize function, as highlighted
    in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameInputHanldler.cpp` 文件中，在包含指令之后但在初始化函数之前添加 `BulletSpawner` 类的前向声明，如下代码所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `GameInputHandler.cpp` file, add the following highlighted code to the
    `handleKeyPressed` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameInputHandler.cpp` 文件中，将以下高亮代码添加到 `handleKeyPressed` 函数中：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we are responding to keyboard presses just like we have been doing
    throughout this book. Here, however, we are calling the functions from the `PlayerUpdateComponent`
    class that we coded in [*Chapter 20*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414),
    *Game Objects and Components*, in order to take the required actions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在响应键盘按键，就像我们在本书中一直做的那样。然而，在这里，我们正在调用我们在 [*第20章*](B14278_20_Final_AG_ePub.xhtml#_idTextAnchor414)
    中编写的 `PlayerUpdateComponent` 类中的函数，*游戏对象和组件*，以执行所需的操作。
- en: 'In the `GameInputHandler.cpp` file, add the following highlighted code to the
    `handleKeyReleased` function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameInputHandler.cpp` 文件中，将以下高亮代码添加到 `handleKeyReleased` 函数中：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code also relies on calling functions from the `PlayerUpdateComponent`
    class to handle what happens when the player releases a keyboard key. The `PlayerUpdateComponent`
    class can then stop movement in the appropriate direction, depending on which
    keyboard key has just been released. When the *space* key is released, the `getParentScreen`
    function is chained with the `spawnBullet` function to trigger a bullet being
    spawned. Notice that the spawn coordinates (`spawnLocation`) are calculated using
    the shared pointer to the `PlayerTransformComponent` instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还依赖于调用 `PlayerUpdateComponent` 类中的函数来处理玩家释放键盘键时发生的情况。`PlayerUpdateComponent`
    类可以停止适当的移动方向，具体取决于刚刚释放的哪个键盘键。当 *空格* 键释放时，`getParentScreen` 函数与 `spawnBullet` 函数链接起来以触发子弹的生成。请注意，生成坐标（`spawnLocation`）是使用指向
    `PlayerTransformComponent` 实例的共享指针计算的。
- en: Let's learn about how SFML helps us interact with a gamepad and then we can
    return to the `PlayerInputHandler` class to add some more functionality.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解SFML如何帮助我们与游戏手柄交互，然后我们可以回到 `PlayerInputHandler` 类以添加更多功能。
- en: Using a gamepad
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用游戏手柄
- en: Handling gamepad input is made exceptionally easy by SFML. Gamepad (or joystick)
    input is handled by the `sf::Joystick` class. SFML can handle input from up to
    eight gamepads, but this tutorial will stick to just one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SFML使处理游戏手柄输入变得异常简单。游戏手柄（或操纵杆）输入由 `sf::Joystick` 类处理。SFML可以处理多达八个游戏手柄的输入，但本教程将仅关注一个。
- en: 'You can think of the position of a thumbstick/joystick as a 2D graph that starts
    at -100, -100 at the top left corner and goes to 100, 100 at the bottom right
    corner. The position of the thumbstick can, therefore, be represented by a 2D
    coordinate. The following diagram illustrates this with a few example coordinates:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将摇杆/操纵杆的位置想象成一个以左上角-100, -100开始，右下角100, 100结束的2D图。因此，摇杆的位置可以用一个2D坐标来表示。以下图表通过几个示例坐标说明了这一点：
- en: '![](img/B14278_22_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_22_01.jpg)'
- en: 'All we need to do is grab the value and report it to the `PlayerUpdateComponent`
    class for each frame of the game loop. Capturing the position is as simple as
    the following two lines of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是获取值，并在游戏循环的每一帧报告给`PlayerUpdateComponent`类。捕获位置就像以下两行代码一样简单：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The zero parameter requests data from the primary gamepad. You can use values
     0 through 7 to get input from eight gamepads.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 零参数请求主要游戏手柄的数据。您可以使用0到7之间的值从八个游戏手柄获取输入。
- en: There is something else we need to consider as well. Most gamepads, especially
    thumbsticks, are mechanically imperfect and will register small values even when
    they are not being touched. If we send these values to the `PlayerUpdateComponent`
    class, then the ship will aimlessly drift around the screen. For this reason,
    we will create a `getAxisPosition` function are between -10 and 10 on either axis,
    we will ignore them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑其他一些因素。大多数游戏手柄，尤其是摇杆，在机械上并不完美，即使没有被触摸，也会注册到小的数值。如果我们将这些数值发送到`PlayerUpdateComponent`类，那么飞船就会在屏幕上无目的地漂移。因此，我们将创建一个`getAxisPosition`函数，如果任何一个轴上的值在-10到10之间，我们将忽略它们。
- en: 'To get input from the B button of the gamepad, we use the following line of
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要从游戏手柄的B按钮获取输入，我们使用以下行代码：
- en: // Has the player pressed the B button?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: // 玩家是否按下了B按钮？
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code detects when the B button on an Xbox One gamepad is pressed.
    Other controllers will vary. The 0, 1 parameters refer to the primary gamepad
    and button number 1\. To detect when a button is released, we will need to code
    a bit of our own logic. As we want to shoot a bullet on release and not when it
    is pressed, we will use a simple Boolean to track this. Let's code the rest of
    the `GameInputHandler` class and see how we can put what we have just learned
    into action.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检测当Xbox One游戏手柄上的B按钮被按下时。其他控制器会有所不同。0, 1参数指的是主要游戏手柄和按钮编号1。为了检测按钮何时被释放，我们需要编写一些自己的逻辑。因为我们希望在释放时而不是按下时射击子弹，我们将使用一个简单的布尔值来跟踪这个状态。让我们编写`GameInputHandler`类的其余部分，看看我们如何将刚刚学到的知识付诸实践。
- en: 'In the `GameInputHandler.cpp` file, add the following highlighted code to the
    `handleGamepad` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameInputHandler.cpp`文件中，将以下高亮代码添加到`handleGamepad`函数中：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We begin by defining a dead zone of 10 and then proceed to capture the position
    of the thumbstick. The next two `if` blocks test whether the thumbstick position
    is within the dead zone. If it is, then the appropriate value is set to zero to
    avoid the ship drifting. Then, we can call the `updateShipTravelWithController`
    function on the `PlayerUpdateComponent` instance. That is the thumbstick dealt
    with.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个死区为10，然后继续捕捉摇杆的位置。接下来的两个`if`块检查摇杆位置是否在死区内。如果是，则将适当的值设置为0以避免飞船漂移。然后，我们可以在`PlayerUpdateComponent`实例上调用`updateShipTravelWithController`函数。这就是处理过的摇杆。
- en: The next `if` statement sets a Boolean to `true` if the B button on the gamepad
    is pressed. The next `if` statement detects when the B button is not pressed,
    and the Boolean is set to `true`. This indicates that the B button has just been
    released.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`语句将布尔值设置为`true`，如果游戏手柄上的B按钮被按下。下一个`if`语句检测B按钮未被按下，并且布尔值被设置为`true`。这表明B按钮刚刚被释放。
- en: Inside the `if` block, we set the Boolean to `false`, ready to handle the next
    button release, play a shooting sound, get the location to spawn the bullet, and
    call the `spawnBullet` function by chaining the `getmParentScreen` and `getBulletSpawner`
    functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内部，我们将布尔值设置为`false`，准备处理下一个按钮释放，播放射击声音，获取生成子弹的位置，并通过链式调用`getmParentScreen`和`getBulletSpawner`函数来调用`spawnBullet`函数。
- en: Coding the PhysicsEnginePlayMode class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写PhysicsEnginePlayMode类
- en: 'This is the class that will do all the collision detection. In this game, there
    are several collision events we want to watch out for:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将执行所有碰撞检测的类。在这个游戏中，我们有几个碰撞事件需要关注：
- en: Has an invader reached the left- or right-hand side of the screen? If so, all
    the invaders need to drop down one row and head back in the other direction.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入侵者是否到达了屏幕的左侧或右侧？如果是这样，所有入侵者都需要向下移动一行，并朝相反方向前进。
- en: Has an invader collided with the player? As the invaders get lower, we want
    them to be able to bump into the player and cause a life to be lost.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入侵者是否与玩家相撞？随着入侵者向下移动，我们希望它们能够撞到玩家并导致玩家失去一条生命。
- en: Has an invader bullet hit the player? Each time an invader bullet hits the player,
    we need to hide the bullet, ready for reuse, and deduct a life from the player.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有入侵者的子弹击中了玩家？每次入侵者的子弹击中玩家时，我们需要隐藏子弹，准备重新使用，并从玩家那里扣除一条生命。
- en: Has a player bullet hit an invader? Each time the player hits an invader, the
    invader should be destroyed, the bullet hidden (ready for reuse), and the player's
    score increased.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的子弹是否击中了入侵者？每次玩家击中入侵者时，入侵者应该被摧毁，子弹隐藏（准备重新使用），并且玩家的分数增加。
- en: This class will have an `initialize` function that the `GameScreen` class will
    call to prepare for detecting collisions, a `detectCollisions` function that the
    `GameScreen` class will call once for each frame after all the game objects have
    updated themselves, and three more functions which will be called from the `detectCollisions`
    function to separate out the work of detecting the different collisions I have
    just listed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将有一个`initialize`函数，`GameScreen`类将调用它来准备检测碰撞，一个`detectCollisions`函数，`GameScreen`类将在所有游戏对象更新后对每个帧调用一次，以及三个更多函数，这些函数将从`detectCollisions`函数中调用，以分离出检测不同碰撞的工作。
- en: Those three functions are `detectInvaderCollisions`, `detectPlayerCollisionsAndInvaderDirection`,
    and `handleInvaderDirection`. Hopefully, the names of these functions make it
    clear what will happen in each function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数是`detectInvaderCollisions`、`detectPlayerCollisionsAndInvaderDirection`和`handleInvaderDirection`。希望这些函数的名称能清楚地说明每个函数将发生什么。
- en: 'Create a new source file in the `Header Files/Engine` filter called `PhysicsEnginePlayMode.h`
    and add the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Header Files/Engine`筛选器中创建一个新的源文件，命名为`PhysicsEnginePlayMode.h`，并添加以下代码：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Study the preceding code to make a note of the parameters that are passed to
    each of the functions. Also take note of the four member Boolean variables that
    will be used throughout the class. Furthermore, notice that there is a pointer
    to a `GameObject` type being declared which will be a permanent reference to the
    player ship, so we don't need to keep finding the `GameObject` that represents
    the player for each frame of the game loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 研究前面的代码，注意传递给每个函数的参数。还要注意在整个类中使用的四个成员布尔变量。此外，请注意声明了一个指向`GameObject`类型的指针，这将是一个指向玩家飞船的永久引用，因此我们不需要在游戏循环的每一帧都找到代表玩家的`GameObject`。
- en: 'Create a new source file in the `Source Files/Engine` filter called `PhysicsEnginePlayMode.cpp`
    and add the following include directives and the `detectInvaderCollisions` function.
    Study the code and then we will discuss it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Source Files/Engine`筛选器中创建一个新的源文件，命名为`PhysicsEnginePlayMode.cpp`，并添加以下包含指令和`detectInvaderCollisions`函数。研究代码，然后我们将讨论它：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code loops through all the game objects. The first `if` statement
    checks whether the current game object is both active and an invader:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码遍历了所有游戏对象。第一个`if`语句检查当前游戏对象是否既活跃又是入侵者：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If it is an active invader, another loop is entered and each of the game objects
    that represents a bullet is looped through:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是活跃的入侵者，则进入另一个循环，遍历代表子弹的每个游戏对象：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next `if` statement checks whether the current invader has collided with
    the current bullet and whether that bullet was fired by the player (we don''t
    want invaders shooting themselves):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`语句检查当前入侵者是否与当前子弹相撞，以及该子弹是否是由玩家发射的（我们不希望入侵者射击自己）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When this test is true, a sound is played, the bullet is moved off-screen, the
    number of invaders is decremented, the player's score is increased, and the invader
    is set to inactive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试为真时，会播放声音，子弹被移出屏幕，入侵者数量减少，玩家的分数增加，入侵者被设置为非活动状态。
- en: Now, we will detect player collisions and the invader's direction of travel.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检测玩家碰撞和入侵者的移动方向。
- en: 'Add the `detectPlayerCollisionsAndInvaderDirection` function, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`detectPlayerCollisionsAndInvaderDirection`函数，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code is longer than the previous function because we are checking
    for more conditions. Before the code loops through all the game objects, it gets
    a reference to all the relevant player data. This is so we don''t have to do this
    for every check:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码比之前的函数更长，因为我们正在检查更多的条件。在代码遍历所有游戏对象之前，它获取所有相关玩家数据的引用。这样做是为了我们不必为每个检查都这样做：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, the loop goes through every game object. The first `if` test checks whether
    the current object is active, has a collider, and is not the player. We don''t
    want to test the player colliding with themselves:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，循环遍历每个游戏对象。第一个`if`测试检查当前对象是否处于活动状态，具有碰撞器，并且不是玩家。我们不希望测试玩家与自己碰撞：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next `if` test does the actual collision detection to see if the current
    game object intersects with the player:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`测试执行实际的碰撞检测，以查看当前游戏对象是否与玩家相交：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, there are two nested `if` statements: one that handles collisions with
    a bullet belonging to an invader and one that handles collisions with an invader.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有两个嵌套的`if`语句：一个处理与属于入侵者的子弹的碰撞，另一个处理与入侵者的碰撞。
- en: Next, the code checks each and every game object that is an invader to see whether
    it has hit the left- or right-hand side of the screen. Note that the `m_NeedToDropDownAndReverse`
    and `m_InvaderHitWallLastFrame` Boolean variables are used because it will not
    always be the first invader in the vector that hits the side of the screen. Therefore,
    detecting the collision and triggering dropdown and reversal are handled in consecutive
    frames to guarantee that all the invaders drop down and reverse, regardless of
    which one of them triggers it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码检查每个游戏对象，看它是否击中了屏幕的左侧或右侧。请注意，使用`m_NeedToDropDownAndReverse`和`m_InvaderHitWallLastFrame`布尔变量，因为并不总是向量中的第一个入侵者会击中屏幕的侧面。因此，检测碰撞并触发下落和反转是在连续的帧中处理的，以确保所有入侵者都会下落并反转，无论哪个触发它。
- en: Finally, when both conditions are `true`, `handleInvaderDirection` is called.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当两个条件都为`true`时，调用`handleInvaderDirection`。
- en: 'Add the `handleInvaderDirection` function, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`handleInvaderDirection`函数，如下所示：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function just sets and unsets Booleans accordingly so that the next pass
    through the `detectPlayerCollisionAndDirection` function will actually drop-down
    the invaders and change their direction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只是相应地设置和取消设置布尔值，以便在`detectPlayerCollisionAndDirection`函数的下一次遍历中实际上使入侵者下落并改变方向。
- en: 'Add the `initialize` function to prepare the class for action:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将`initialize`函数添加到准备类以进行操作：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, the pointer to `PlayerUpdateComponent` is initialized,
    as well as the pointer to the player `GameObject`. This will avoid calling these
    relatively slow functions during the game loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，初始化了`PlayerUpdateComponent`的指针，以及玩家`GameObject`的指针。这将避免在游戏循环中调用这些相对较慢的函数。
- en: 'Add the `detectCollisions` function, which will be called from the `GameScreen`
    class once each frame:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`detectCollisions`函数，该函数将在`GameScreen`类中每帧调用一次：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `detectCollisions` function calls the three functions that handle the different
    phases of collision detection. You could have lumped all the code into this single
    function, but then it would be quite unwieldy. Alternatively, you could separate
    the three big functions into their own `.cpp` files, just like we did with the
    `update` and `draw` functions in the Thomas Was Late game.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`detectCollisions`函数调用处理碰撞检测不同阶段的三个函数。您可以将所有代码合并到这个单一函数中，但这会使代码相当难以管理。或者，您可以将这三个大函数分离到它们自己的`.cpp`文件中，就像我们在《托马斯迟到了》游戏中处理`update`和`draw`函数一样。'
- en: In the next section, we will create an instance of the `PhysicsEngineGameMode`
    class and use it in the `GameScreen` class as we bring the game to life.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建`PhysicsEngineGameMode`类的实例，并在`GameScreen`类中使用它，以使游戏变得生动起来。
- en: Making the game
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作游戏
- en: 'By the end of this section, we will have a playable game. In this section,
    we will add code to the `GameScreen` class to bring together everything we have
    been coding over the last three chapters. To get started, add an instance of `PhysicsEngineGameMode`
    to `GameScreen.h` by adding an extra include directive, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，我们将有一个可玩的游戏。在本节中，我们将向`GameScreen`类添加代码，以整合我们在过去三章中编写的所有代码。要开始，通过添加一个额外的包含指令，将`PhysicsEngineGameMode`的实例添加到`GameScreen.h`中，如下所示：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, declare an instance, as highlighted in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明一个实例，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, open the `GameScreen.cpp` file, add some extra include directives, and
    forward-declare the `BulletSpawner` class, as highlighted in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`GameScreen.cpp`文件，添加一些额外的包含指令，并提前声明`BulletSpawner`类，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, in the `GameScreen.cpp` file, update the `initialize` function by adding
    the following highlighted code inside the existing code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GameScreen.cpp`文件中，通过在现有代码中添加以下突出显示的代码来更新`initialize`函数：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code in the `initialize` function initializes the physics engine
    that will handle all the collision detection. Next, it loops through all the game
    objects and performs two tasks: one task in each of the `if` blocks.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initialize`函数中的前一段代码初始化了将处理所有碰撞检测的物理引擎。接下来，它遍历所有游戏对象并执行两个任务：每个`if`块中一个任务。
- en: The first `if` block tests whether the current game object is a bullet. If it
    is, then its integer location in the vector of game objects is stored in the `m_BulletObjectLocations
    vector`. Remember from when we coded the physics engine that this `vector` is
    useful when doing collision detection. The vector will also be used in this class
    to keep track of the next bullet to use when the player or an invader wants to
    take a shot.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`块测试当前游戏对象是否是子弹。如果是，则将其在游戏对象向量中的整数位置存储在`m_BulletObjectLocations`向量中。记得在我们编写物理引擎时，这个`vector`在碰撞检测时很有用。这个向量也将在这个类中使用，以跟踪玩家或入侵者想要射击时下一次使用的子弹。
- en: The second `if` block detects whether the current game object is an invader
    and, if it is, calls the `initializeBulletSpawner` function on its update component
    and passes in a pointer to a `BulletSpawner` by calling the `getBulletSpawner`
    function. The invaders are now capable of spawning bullets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`if`块检测当前游戏对象是否是入侵者，如果是，则在它的更新组件上调用`initializeBulletSpawner`函数，并通过调用`getBulletSpawner`函数传递一个指向`BulletSpawner`的指针。现在，入侵者能够生成子弹了。
- en: 'Now, we need to add some code to the `update` function to handle what happens
    in each frame of the game during the updating phase. This is highlighted in the
    following code. All the new code goes inside the already existing `if(!m_GameOver)`
    block:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向`update`函数中添加一些代码来处理游戏更新阶段每帧发生的事情。以下代码中突出显示了这一点。所有新代码都放在已经存在的`if(!m_GameOver)`块内：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding new code, the first `if` block checks whether a new bullet
    is required for the player. If it is the next available bullet, the `GameObject`
    instance, has its `BulletUpdateComponent` instance's `spawnForPlayer` function
    called. The specific `GameObject` instance to use is identified using the `m_NextBulletObject`
    variable with the `m_BulletObjectLocations` vector. The remaining code in the
    first `if` block prepares for the next bullet to be fired.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面新代码中，第一个`if`块检查是否需要为玩家生成新的子弹。如果是下一个可用的子弹，则调用`GameObject`实例的`BulletUpdateComponent`实例的`spawnForPlayer`函数。使用`m_NextBulletObject`变量和`m_BulletObjectLocations`向量来识别要使用的特定`GameObject`实例。第一个`if`块中的剩余代码为下一次发射子弹做准备。
- en: The second `if` block executes if an invader is waiting for a bullet to be fired.
    Exactly the same technique is used to activate a bullet, except the `spawnForInvader`
    function is used, which sets it moving downward.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果入侵者正在等待发射子弹，第二个`if`块将执行。激活子弹的技术完全相同，只是使用`spawnForInvader`函数，将其设置为向下移动。
- en: Next, there is a loop which loops through every game object. This is key to
    everything because, inside the loop, the `update` function is called on every
    `GameObject` instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有一个循环，遍历每个游戏对象。这是关键，因为在循环内部，对每个`GameObject`实例调用`update`函数。
- en: The final line of code in the preceding new code calls the `detectCollisions`
    function to see if any of the `GameObject` instances (in their just-updated positions)
    have collided.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面新代码的最后一行，调用`detectCollisions`函数以查看是否有任何`GameObject`实例（在其刚刚更新的位置）发生了碰撞。
- en: 'Finally, we will add some code to the `draw` function in `GameScreen.cpp`.
    The new code is highlighted inside the existing code in the following listing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向`GameScreen.cpp`中的`draw`函数添加一些代码。以下列表中突出显示了现有代码中的新代码：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code simply calls the `draw` function on each of the `GameObject`
    instances in turn. Now, you have completed the Space Invaders ++ project and can
    run the game. Congratulations!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，简单地依次调用每个`GameObject`实例上的`draw`函数。现在，你已经完成了Space Invaders ++项目，可以运行游戏了。恭喜你！
- en: Understanding the flow of execution and debugging
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解执行流程和调试
- en: Much of the last four chapters has been about the code structure. It is very
    possible that you still have doubts and uncertainties about which class instantiates
    which instance or in what order the various functions are called. Wouldn't it
    be useful if there was a way to execute the project and follow the path of execution
    from `int main()` right through to `return 0;` in the `Space Invaders ++.cpp`
    file? It turns out we can, and the following is how to do it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章的大部分内容都是关于代码结构。你仍然可能对哪个类实例化了哪个实例或各种函数调用的顺序有疑问和不确定性。如果有一种方法可以执行项目并从`int main()`跟踪到`Space
    Invaders ++.cpp`文件中的`return 0;`的执行路径，那岂不是很有用？实际上我们可以，以下是如何做到这一点的方法。
- en: We will now explore the debugging facilities in Visual Studio while simultaneously
    trying to understand the structure of the project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在探索Visual Studio的调试功能的同时，试图理解项目的结构。
- en: 'Open the `Space Invaders ++.cpp` file and find the first line of code, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Space Invaders ++.cpp`文件，找到第一行代码，如下所示：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is the first line of code that gets executed. It declares
    an instance of the `GameEngine` class and sets all our hard work in motion.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是首先执行的代码行。它声明了`GameEngine`类的一个实例，并启动了我们所有的努力。
- en: 'Right-click the preceding line of code and select **Breakpoint** | **Insert
    Breakpoint**. The following is what the screen should look like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击前面的代码行并选择**断点**|**插入断点**。以下应该是屏幕的样子：
- en: '![](img/B14278_22_02.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_02.jpg)'
- en: Notice that there is a red circle next to the line of code. This is a breakpoint.
    When you run the code, execution will pause at this point and we will have some
    interesting options available to us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到代码行旁边有一个红色圆圈。这是一个断点。当你运行代码时，执行将在这一点暂停，我们将有一些有趣的选择可供选择。
- en: 'Run the game in the usual way. When execution pauses, an arrow indicates the
    current line of execution, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式运行游戏。当执行暂停时，一个箭头指示当前执行的行，如下所示：
- en: '![](img/B14278_22_03.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_03.jpg)'
- en: 'If you hover the mouse over the `m_GameEngine` text and then click the arrow
    (the top-left corner in the following screenshot), you will get a preview of all
    the member variables and their values in the `m_GameEngine` instance:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在`m_GameEngine`文本上，然后点击箭头（以下截图的左上角），你将看到`m_GameEngine`实例中所有成员变量及其值的预览：
- en: '![](img/B14278_22_04.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_04.jpg)'
- en: 'Let''s progress through the code. In the main menu, look for the following
    set of icons:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步通过代码。在主菜单中，寻找以下图标组：
- en: '![](img/B14278_22_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_05.jpg)'
- en: If you click the arrow icon highlighted in the previous screenshot, it will
    move to the next line of code. This arrow icon is the `GameEngine` constructor
    function. You can keep clicking the **Step into** button and examine the value
    of any of the variables at any stage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击之前截图中的高亮箭头图标，它将移动到下一行代码。这个箭头图标是`GameEngine`构造函数。你可以继续点击**进入**按钮，并在任何阶段检查任何变量的值。
- en: If you click into the initialization of `m_Resolution`, then you will see the
    code jumps into the `Vector2i` class provided by SFML. Keep clicking to see the
    code flow progress through all the steps that make up our game.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击`m_Resolution`的初始化，那么你会看到代码跳转到由SFML提供的`Vector2i`类。继续点击以查看代码流通过构成我们游戏的全部步骤。
- en: 'If you want to skip to the next function, you can click the **Step out** button,
    as shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跳到下一个函数，你可以点击以下截图所示的**跳出**按钮：
- en: '![](img/B14278_22_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_06.jpg)'
- en: 'Follow the flow of execution for as long as it interests you. When you are
    done, simply click the **Stop** button, as shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的兴趣跟踪执行流。当你完成时，只需点击以下截图所示的**停止**按钮：
- en: '![](img/B14278_22_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_07.jpg)'
- en: 'Alternatively, if you want to run the game without stepping through the code,
    you can click the **Continue** button shown in the following screenshot. Note,
    however, that if the breakpoint is placed inside a loop, it will stop each time
    the flow of execution reaches the breakpoint:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想在不逐行执行代码的情况下运行游戏，你可以点击以下截图所示的**继续**按钮。然而，请注意，如果断点放置在循环内部，它将在每次执行流达到断点时停止：
- en: '![](img/B14278_22_08.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_22_08.jpg)'
- en: If you want to examine the flow of code from a different starting point and
    don't want to have to click through every line or function from the start, then
    all you need to do is set a different breakpoint.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从不同的起点检查代码的流程，而又不想从第一行或第一个函数开始逐行或逐个函数地点击，那么你只需要设置一个不同的断点。
- en: You can delete a breakpoint by stopping debugging (with the **Stop** button),
    right-clicking the red circle, and selecting **Delete Breakpoint**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过停止调试（使用**停止**按钮），右键单击红色圆圈，并选择**删除断点**来删除断点。
- en: You could then begin stepping through the game loop by setting a breakpoint
    at the first line of code in the `update` function of `GameEngine.cpp`. You can
    put a breakpoint anywhere, so feel free to explore the flow of execution in individual
    components or anywhere else. One of the key parts of the code that is worth examining
    is the flow of execution in the *update* function of the `GameScreen` class. Why
    not try it?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`GameEngine.cpp`的`update`函数的第一行代码处设置断点来开始逐步执行游戏循环。你可以将断点设置在任何地方，所以请随意探索单个组件或任何其他地方的执行流程。值得检查的关键代码部分之一是`GameScreen`类的`update`函数中的执行流程。为什么不试试看呢？
- en: While what we have just explored is useful and instructive, the real purpose
    of these facilities provided by Visual Studio is to debug our games. Whenever
    you get behavior that is not as you expect, just add a breakpoint to any likely
    lines that might be causing the problem, step through the execution, and observe
    the variable values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们刚刚探索的内容是有用且富有教育意义的，但Visual Studio提供的这些设施的真实目的是为了调试我们的游戏。每当你的行为不符合预期时，只需在可能引起问题的任何可能行处添加断点，逐步执行，并观察变量值。
- en: Reusing the code to make a different game and building a design mode
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用代码制作不同的游戏和构建设计模式
- en: On a few occasions, we have already discussed  the possibility that this system
    we have coded can be reused to make a totally different game. I just thought it
    was worth giving this fact a full hearing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次场合中，我们已经讨论了这种可能性，即我们编写的这个系统可以被重用来制作一个完全不同的游戏。我只是觉得这个事实值得充分听取。
- en: The way that you would make a different game is as follows. I have already mentioned
    that you could code the appearance of game objects into new components that derive
    from the `GraphicsComponent` class and that you could code new behaviors into
    classes that derive from the `UpdateComponent` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 制作不同游戏的方法如下。我已经提到，你可以将游戏对象的外观编码到从`GraphicsComponent`类派生的新的组件中，你还可以将新的行为编码到从`UpdateComponent`类派生的类中。
- en: Suppose you wanted a set of game objects that had overlapping behaviors; consider
    perhaps a 2D game where the enemy hunted the player and then shot at the player
    at a certain distance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一组具有重叠行为的游戏对象；考虑可能是一个2D游戏，其中敌人追捕玩家，然后在一定距离处射击玩家。
- en: Maybe you could have an enemy type that got close to the player and fired a
    pistol at the player and an enemy type that took long distance shots at the player,
    like a sniper might.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你可以有一个敌人类型，它会接近玩家并向玩家开枪，还有一个敌人类型会像狙击手一样从远处射击玩家。
- en: You could code an `EnemyShooterUpdateComponent` class and an `EnemySniperUpdateComponent`
    class. You could get a shared pointer to the player transform component during
    the `start` function and code an abstract class (such as  `BulletSpawner`) to
    trigger spawning shots at the player, and you would be done.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一个`EnemyShooterUpdateComponent`类和一个`EnemySniperUpdateComponent`类。你可以在`start`函数期间获取玩家变换组件的共享指针，并编写一个抽象类（例如`BulletSpawner`）来触发向玩家发射子弹，这样你就完成了。
- en: Consider, however, that both of these game objects would have code to take a
    shot and code to close in on the player. Then consider that, at some stage, you
    might want a "brawler" enemy who tries to punch the player.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑到这两个游戏对象都会有射击和靠近玩家的代码。然后考虑，在某个阶段，你可能想要一个“格斗”敌人，它会尝试击打玩家。
- en: The current system can also have multiple update components. You could then
    have a `ChasePlayerUpdateComponent` class which closes in on the player and separate
    update components to punch, shoot, or snipe the player. The punching/shooting/sniping
    component would enforce some values on the chasing component regarding when to
    stop and start chasing, and then the more specific component (punch, shoot, or
    snipe) would attack the player when prompted that the time was right.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当前系统也可以有多个更新组件。这样，你可以拥有一个`ChasePlayerUpdateComponent`类，它会靠近玩家，以及独立的更新组件来打击、射击或狙击玩家。打击/射击/狙击组件将对追逐组件施加一些值，关于何时停止和开始追逐，然后更具体的组件（打击、射击或狙击）会在提示时间合适时攻击玩家。
- en: 'As we''ve already mentioned, the ability to call the `update` function on multiple
    different update components is already built into the code, although it has never
    been tested. If you take a look at the `update` function in `GameObject.cpp`,
    you will see this code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，在代码中已经内置了在多个不同的更新组件上调用`update`函数的能力，尽管它从未被测试过。如果你查看`GameObject.cpp`中的`update`函数，你会看到以下代码：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, the `update` function would be called on as many update
    components that are present. You just need to code them and add them to specific
    game objects in the `level1.txt` file. Using this system, a game object can have
    as many update components as it needs, allowing you to encapsulate very specific
    behaviors and share them as needed around the required game objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`update`函数将在所有存在的更新组件上被调用。你只需要编写它们并将它们添加到`level1.txt`文件中的特定游戏对象中。使用这个系统，一个游戏对象可以有它需要的任何数量的更新组件，允许你封装非常具体的行为，并在需要时在所需的游戏对象周围共享它们。
- en: 'When you want to create a pool of objects, like we did for the invaders and
    the bullets, you can be more efficient than we were in the Space Invaders ++ project.
    For the purposes of showing you how to position objects in the game world, we
    added all the invaders and bullets individually. In a real project, you would
    simply design a type that represents a pool of bullets, perhaps a magazine of
    bullets, like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想创建一个对象池，就像我们在Space Invaders ++项目中为入侵者和子弹所做的那样，你可以比我们更有效率。为了展示如何在游戏世界中定位对象，我们为所有入侵者和子弹单独添加了它们。在一个真实的项目中，你只需设计一个代表子弹池的类型，可能是一个子弹杂志，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You could do the same for a fleet of invaders:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为一群入侵者做同样的事情：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, you would code the factory to handle a magazine or a fleet, probably with
    a `for` loop, and the slightly cumbersome text file would be improved upon. And,
    of course, there is no limit to the number of different levels you can design
    across multiple text files. More likely names for these text files are `beach_level.txt`
    or `urban_level.txt`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会编写工厂来处理一个杂志或一个舰队，可能使用一个`for`循环，并且那个稍微繁琐的文本文件将得到改进。当然，你可以在多个文本文件中设计不同数量的不同关卡，这些文本文件更有可能被命名为`beach_level.txt`或`urban_level.txt`。
- en: You might have wondered about the names of some of the classes, such as  `PhysicsEnginePlayMode`
    or `GameObjectFactoryPlayMode`. This implies that `…PlayMode` is just one option
    for these classes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对一些类的名称感到好奇，比如`PhysicsEnginePlayMode`或`GameObjectFactoryPlayMode`。这表明`…PlayMode`只是这些类的一个选项。
- en: The suggestion I am making here is that, even if you use the fleet/magazine
    strategy in your level design files, they could still become cumbersome and unwieldy
    as they grow. It would be much better if you could view the levels and edit them
    on-screen and then save changes back to the file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里提出的建议是，即使你在关卡设计文件中使用舰队/杂志策略，随着它们的增长，它们也可能变得繁琐和难以控制。如果你能够在屏幕上查看和编辑关卡，然后将更改保存回文件，那就更好了。
- en: You would certainly need new physics engine rules (detecting clicks and drags
    on objects), a new screen type (that didn't update each frame), and probably new
    classes for interpreting and building the objects from the text files. The point
    is, however, that the Entity-Component/screen/UI panel/input handling systems
    could remain unchanged.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然需要新的物理引擎规则（检测对象的点击和拖动），一个新的屏幕类型（它不会在每一帧更新），以及可能需要新的类来解释和从文本文件中构建对象。然而，重点是，实体-组件/屏幕/UI面板/输入处理系统可以保持不变。
- en: There isn't even anything stopping you from devising some completely new component
    types, for example, a scrolling background object that detects which direction
    the player is moving and moves accordingly, or perhaps an interactive lift object
    that detects when the player is standing on it and then accepts input to move
    up and down. We could even have a door that opens and closes, or a teleport object
    that detects input when the player is touching it and loads a new level from another
    text file. The point here is that these are all game mechanics that can be easily
    integrated into the same system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至没有任何东西阻止你设计一些全新的组件类型，例如，一个可以检测玩家移动方向的滚动背景对象，或者一个可以检测玩家站在其上并接受上下移动输入的交互式电梯对象。我们甚至可以有一个可以开关的门，或者一个当玩家触摸时检测输入并从另一个文本文件加载新级别的传送对象。这里的重点是，这些都是可以轻松集成到同一系统中的游戏机制。
- en: I could go on about these possibilities for much longer, but you would probably
    rather make your own game.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续讨论这些可能性很长时间，但你可能更愿意自己制作游戏。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we finally completed the Space Invaders ++ game. We coded a
    way for game objects to request bullets to be spawned, learned how to receive
    input from a gamepad, and we put in the final logic of the game to bring it to
    life.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于完成了 Space Invaders ++ 游戏。我们编写了一种让游戏对象请求生成子弹的方法，学习了如何从游戏手柄接收输入，并且我们加入了游戏的最终逻辑，使其变得生动起来。
- en: Perhaps the most important thing to take from this chapter, however, is how
    the toil of the last four chapters will help you get started on your next project.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从这个章节中汲取的最重要的一点可能是，前四章的辛勤工作将帮助你开始你的下一个项目。
- en: There is one final chapter in this slightly chunky book, and it is a short and
    simple one, I promise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本略显厚重的书中，还有一个最后的章节，它简短而简单，我保证。
