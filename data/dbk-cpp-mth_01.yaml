- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: C++ Is Very Difficult to Learn
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 非常难学
- en: '*If you want to channel all* *its power*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想要发挥其全部力量*'
- en: A prevalent belief between both C++ programmers and those who only hear about
    the language is that it’s very difficult to learn it. But what is this based upon?
    We will see that part of this belief is historical; not only has C++ been around
    for almost 30 years, but the initial standard was both unforgiving to programmers
    and required a lot of knowledge of memory management. Modern C++, after consequent
    improvements brought by the new standards C++11, C++ 14, C++ 17, C++ 20, and C++
    23, allows programmers to write code that is very similar to Java or C#. However,
    C++ has its specific niche in systems programming, which makes it necessary for
    programmers to learn more topics than necessary for other modern languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的难点及其掌握方法
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why is C++ perceived as difficult to learn?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 C++ 被认为很难学？
- en: The hard parts of C++ and how to grasp them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 的难点及其掌握方法
- en: The Stroustrup method for learning C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斯特劳斯特拉斯学习 C++ 的方法
- en: The test-driven method for learning C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 C++ 的测试驱动方法
- en: With great power…
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权力越大……
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter can be found in the GitHub repository [https://github.com/PacktPublishing/Debunking-CPP-Myths](https://github.com/PacktPublishing/Debunking-CPP-Myths)
    in the **ch1** folder. The code uses **doctest** ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ) as a testing library, **g++** and **make** for compilation, and targets C++
    20. You will also need **valgrind** ( [https://valgrind.org/](https://valgrind.org/)
    ) to check for memory leaks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以在 GitHub 仓库 [https://github.com/PacktPublishing/Debunking-CPP-Myths](https://github.com/PacktPublishing/Debunking-CPP-Myths)
    的 **ch1** 文件夹中找到。代码使用 **doctest**（[https://github.com/doctest/doctest](https://github.com/doctest/doctest)）作为测试库，**g++**
    和 **make** 进行编译，并针对 C++ 20。你还需要 **valgrind**（[https://valgrind.org/](https://valgrind.org/)）来检查内存泄漏。
- en: Why is C++ perceived as difficult to learn?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 C++ 被认为很难学？
- en: The beginnings of C++ saw it as an extension to C, only using the new paradigm,
    **object-oriented programming** ( **OOP** ), thus promising to solve the many
    problems of growing code bases. This initial version of C++ is unforgiving; you,
    the programmer, had to deeply understand how memory allocation and release works
    and how pointer arithmetic works, as well as guard against a myriad of subtleties
    that you’d be likely to miss and that usually ended up in an unhelpful error message.
    It didn’t help that the prevalent cultural zeitgeist of programmers back then
    was that a real programmer had to know all the intricacies of CPUs, RAM, various
    assembly languages, OS workings, and compilers. It also didn’t help that the standardization
    committee did almost nothing to reduce the possibility of such errors for decades.
    No wonder the fame of the language is following it almost 40 years later. My experience
    learning it only helps to understand the struggles to learn the language back
    then.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的早期被视为 C 的扩展，仅使用新的范式，**面向对象编程**（**OOP**），因此承诺解决不断增长的代码库中的许多问题。这个初始版本的 C++
    非常严格；你，程序员，必须深入理解内存分配和释放的工作原理以及指针算术的工作原理，同时要防范你可能会错过的一系列细微差别，这些差别通常会导致无用的错误信息。当时程序员普遍的文化氛围是，真正的程序员必须了解
    CPU、RAM、各种汇编语言、操作系统的工作原理和编译器。标准化委员会几十年来几乎什么也没做来减少这种错误的可能性，这也不无帮助。难怪这种语言的声誉在几乎
    40 年后仍然伴随着它。我学习它的经验仅有助于理解当时学习这种语言的困难。
- en: I had my first touches with C++ during my polytechnics studies, in the 90s.
    They had left me both intrigued and puzzled. I understood the power of the language,
    while it was actively fighting against me – or that’s how I perceived it. I had
    to struggle to write code that worked. I was not yet familiar with STL, which
    was yet to gain notoriety as part of the standard, so most of my first C++ programs
    dealt with pointer usage. A common question at C++ exams was about differentiating
    between an array of pointers and a pointer to an array. I can only imagine how
    helpful the complexities of the language were for building exam questions!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，我在理工学院学习期间第一次接触到了C++。它既让我着迷又让我困惑。我理解了这种语言的力量，尽管它正在与我作对——或者至少我是这样认为的。我必须努力编写出能工作的代码。我还不熟悉STL，那时它还没有成为标准的一部分，所以我的大多数第一个C++程序都涉及指针的使用。C++考试中常见的问题之一就是区分指针数组与数组指针。我只能想象这种语言的复杂性对于构建考试问题是多么有帮助！
- en: 'For the record, see here the difference between pointer to array and array
    of pointers, a common exam question for C++:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为记录在案，请参阅以下指针到数组和指针数组之间的区别，这是C++考试中常见的问题：
- en: '**int(*pointerToArrayOf10Numbers)[10];**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**int(*pointerToArrayOf10Numbers)[10];**'
- en: '**int *arrayOfTenPointers[10]**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**int *arrayOfTenPointers[10]**'
- en: 'I continued learning C++ through practice and from books I could find before
    the internet would make the knowledge available to everyone. But the biggest jump
    in my understanding of the language was a project I worked on around the 2000s.
    The project lead, a very technical Belgian man, set for us very clear guidelines
    and a process we had to follow to get the best C++ code possible. This need for
    excellence did not come simply from his desires but from the project needs: we
    were building a NoSQL database engine many years before they would be given this
    label.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过实践和在网上知识对每个人开放之前能找到的书籍继续学习C++。但对我对这种语言理解的最大的飞跃是在2000年左右的一个项目。项目负责人，一位非常技术性的比利时人，为我们设定了非常明确的指导方针和必须遵循的过程，以获得最佳的C++代码。这种对卓越的需求并不仅仅来自他的愿望，而是来自项目的需求：我们在多年前就构建了一个NoSQL数据库引擎，而那时它们还没有被赋予这个标签。
- en: 'For this project, I had to study and know all the rules from the two seminal
    books on C++: *Effective C++* and *More Effective C++* by Scott Meyers. The two
    books document in total 90 guidelines for C++ programmers, ranging from issues
    of resource initialization and release to minute ways to improve performance,
    inheritance, exception handling, and so on. This is also when I started using
    STL extensively, although the standard library was much more limited in scope
    than it is today.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我必须学习和了解Scott Meyers的两本关于C++的奠基性书籍《Effective C++》和《More Effective C++》中的所有规则。这两本书总共记录了90条针对C++程序员的指南，从资源初始化和释放的问题到提高性能、继承、异常处理等细节。这也是我开始大量使用STL的时候，尽管与今天相比，标准库的范围要小得多。
- en: This newly acquired knowledge made my C++ programs more reliable and made me
    more productive. An important contributing factor was the process we used in synergy
    with the wisdom of the two books. We wrote unit tests, we performed design and
    code reviews, and we carefully crafted our code knowing that it would be dissected
    by a colleague before getting accepted in the code base. This made our code quasi-bug-free
    and helped us implement complex features with high performance in a reasonable
    time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这项新获得的知识使我的C++程序更加可靠，并提高了我的工作效率。一个重要的贡献因素是我们与两本书的智慧相结合所采用的过程。我们编写了单元测试，进行了设计和代码审查，并精心编写我们的代码，因为我们知道在代码库接受之前，它将被同事剖析。这使得我们的代码几乎无错误，并帮助我们以合理的时间实现了高性能的复杂功能。
- en: However, the language was still fighting against us. We knew how to write good
    C++ code, only it required a level of attention and care that inevitably slowed
    us down. Mastering C++ was not enough; the language had to give something back.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种语言仍在与我们作对。我们知道如何编写好的C++代码，但这需要一种注意力和关怀，这不可避免地会减慢我们的速度。仅仅掌握C++是不够的；这种语言必须有所回报。
- en: After this project, I left the C++ world and learned C# and managed C++, Java,
    PHP, Python, Haskell, JavaScript, and Groovy, to limit myself to those languages
    I’d used for professional programming. While every programming language offered
    higher abstractions and fewer headaches compared to C++, I still had nostalgia
    for my formative years in programming. The fact that I knew C++ and all the intricacies
    of memory management gave me a deep understanding of the inner workings of these
    other languages, allowing me to use them to their fullest. Haskell proved to be
    very familiar to me since it was closely mapping the meta-programming techniques
    I’d learned from the seminal book by Andrei Alexandrescu, *Modern C++ Design*
    . C++ was living on in my mind, not only as the first programming language I used
    professionally but also as a foundation for every other language I’ve used since.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目之后，我离开了C++的世界，学习了C#和托管C++、Java、PHP、Python、Haskell、JavaScript和Groovy，仅限于那些我用于专业编程的语言。虽然每种编程语言都比C++提供了更高的抽象层次和更少的烦恼，但我仍然怀念我的编程成长岁月。我知道C++以及内存管理的所有复杂性，这让我对这些其他语言的内部运作有了深刻的理解，使我能够充分利用它们。Haskell对我来说非常熟悉，因为它与我从Andrei
    Alexandrescu的奠基性著作《现代C++设计》中学到的元编程技术密切相关。C++在我的脑海中不仅是我使用的第一个专业编程语言，而且也是我自那以后使用的每种其他语言的基础。
- en: To my delight, around 2010, the news came that the C++ standardization committee
    was finally making bold and frequent changes to the language. The last C++ standard
    had been for many years C++ 98; suddenly we were seeing a new version every three
    years. This rolling release of new versions of the standard allowed the introduction
    of the functional programming paradigm, of ranges, of new primitives for parallel
    and asynchronous programming, of move semantics. But the biggest change for anyone
    who wants to learn C++ today is the simplification of memory management and the
    introduction of **auto** types. The big breakthrough offered by these changes
    is that a Java or C# programmer can understand modern C++ programs, something
    we weren’t sure about back when Java and C# started.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我高兴的是，大约在2010年，消息传来，C++标准化委员会终于开始对语言进行大胆和频繁的改革。上一个C++标准已经多年是C++ 98；突然我们每三年就看到一个新版本。这种标准的滚动发布使得函数式编程范式、范围、新的并行和异步编程原语、移动语义的引入成为可能。但对于今天想要学习C++的人来说，最大的变化是内存管理的简化以及**auto**类型的引入。这些变化带来的重大突破是，Java或C#程序员可以理解现代C++程序，这是我们当初Java和C#开始时不确定的。
- en: This means the language is much easier to learn today than in the 90s. A good
    example of this change is the complete irrelevance of the old exam question on
    the difference between an array to pointers or a pointer to arrays; naked arrays
    can easily be replaced with a **vector<>** or a **list<>** , while pointers are
    replaced with the more precise **shared_pointer<>** or **unique_pointer<>** .
    This in turn reduces concerns related to allocation and release of memory for
    the pointers, thus both cleaning up the code and reducing the potential for the
    inscrutable error messages so prevalent in C++ 98.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着与90年代相比，现在的语言学习要容易得多。这个变化的例子就是关于数组与指针或指针与数组之间区别的旧考试问题已经完全无关紧要；裸数组可以轻易地被**vector<>**或**list<>**所替代，而指针则被更精确的**shared_pointer<>**或**unique_pointer<>**所取代。这反过来又减少了与指针的分配和释放相关的担忧，从而既清理了代码，又减少了在C++
    98中普遍存在的难以理解的错误信息的可能性。
- en: We can’t say, however, that the C++ language is as easy to learn as the other
    mainstream ones today. Let’s see why.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法说C++语言像今天其他主流语言一样容易学习。让我们看看原因是什么。
- en: The hard parts of C++ and how to grasp them
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++的难点及其掌握方法
- en: 'Is C++ as easy to learn as Java, C#, PHP, JavaScript, or Python? Despite all
    the language improvements, the answer is: most likely not. The important question
    is: Should C++ be as easy to learn as all these other languages?'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C++像Java、C#、PHP、JavaScript或Python一样容易学习吗？尽管语言有所改进，但答案可能是：很可能不是。重要的是：C++是否应该像所有这些其他语言一样容易学习？
- en: The demise of C++ has been predicted for a very long time. Java, then C#, and
    nowadays Rust were in turn touted as complete replacements for our venerable subject
    of debate. Instead, each of them seems to carve their own niche while C++ is still
    leading in programs that require careful optimization or work in constrained environments.
    It helps that millions of lines of C++ exist today, some of them decades old.
    While some of them can be turned into cloud-native, serverless, or microservices
    architectures, there will always be problems better fit for the engineering style
    serviced by C++.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: C++的消亡已经被预测了很长时间。Java、然后是C#，如今是Rust，它们依次被吹捧为我们的尊贵辩论主题的完全替代品。然而，每个语言似乎都在开辟自己的领域，而C++仍然在需要仔细优化的程序或工作在受限环境中的程序中处于领先地位。今天，数百万行C++代码存在，其中一些已经存在了几十年。虽然其中一些可以被转换为云原生、无服务器或微服务架构，但总会有更适合由C++提供的工程风格解决的问题。
- en: 'We conclude, therefore, that C++ has its own purpose in the world of development,
    and any new programming language faces a steep uphill battle to displace it. This
    observation comes with its consequence: specific parts of C++ will necessarily
    be more difficult to grasp than other languages. While Java or C# will spare you
    from thinking of memory allocation and what happens with the memory when you pass
    arguments to another method, C++ needs to take these issues head-on and give you
    the option to optimize your code as your context dictates.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出结论，C++在开发世界中有着自己的目的，任何新的编程语言都面临着一场艰难的挑战，以取代它。这一观察带来了其后果：C++的某些特定部分将必然比其他语言更难以掌握。虽然Java或C#可以让你免于思考内存分配以及当将参数传递给另一个方法时内存会发生什么，但C++需要直面这些问题，并允许你根据上下文优化你的代码。
- en: Therefore, if you want to understand C++, you can’t escape memory management.
    Fortunately, it’s much less of an issue than it used to be.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想理解C++，你无法逃避内存管理。幸运的是，这已经不像以前那样成为一个大问题。
- en: Let’s analyze the differences by looking at how different languages manage memory
    allocation and release. Java uses a full **object-oriented** ( **OO** ) approach,
    in which every value is an object. C# designers decided to use both value types
    that include the typical numeric values, chars, structs, and enums, and reference
    types that correspond to the objects. In Python, every value is an object, and
    the type can be established later in the program. All these three languages feature
    a garbage collector that deals with memory release. The Python language uses a
    reference counting mechanism in addition to the garbage collector, thus allowing
    it to be optionally disabled.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过观察不同语言如何管理内存分配和释放来分析差异。Java使用完全的**面向对象**（**OO**）方法，其中每个值都是一个对象。C#的设计者决定使用包括典型数值、字符、结构体和枚举在内的值类型，以及与对象相对应的引用类型。在Python中，每个值都是一个对象，类型可以在程序中稍后确定。所有这些三种语言都具备垃圾回收器来处理内存释放。Python语言除了垃圾回收器外，还使用引用计数机制，因此可以可选地禁用它。
- en: The C++ 98 standard didn’t provide any built-in mechanism for pointer release,
    instead providing the full power and responsibility for memory management to the
    programmer. Unfortunately, this led to problems. Suppose that you initialize a
    pointer and allocate a large area of memory for a value. You then pass this pointer
    to other methods. Who is responsible for releasing the memory?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 98标准没有提供任何内置的指针释放机制，而是将内存管理的全部权力和责任交给了程序员。不幸的是，这导致了问题。假设你初始化了一个指针并为一个值分配了一个大内存区域。然后你将这个指针传递给其他方法。谁负责释放内存？
- en: 'See, for example, the following simple code sample:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下简单的代码示例：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Should the caller release the memory allocated in **pData** ? Should **call3**
    do it? What if **call3** calls another function with the same **pData** instance?
    Who is responsible for releasing it? What happens if **call2** fails?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者是否应该释放**pData**分配的内存？是**call3**来做吗？如果**call3**调用另一个具有相同**pData**实例的函数会发生什么？谁负责释放它？如果**call2**失败会发生什么？
- en: The responsibility for memory release is ambiguous and, therefore, needs to
    be specified for every function or for every scope, to be more precise. The complexity
    of this problem increases with the complexity of programs and data flows. This
    would make most programmers using the other mainstream languages scratch their
    heads or completely ignore the responsibility and end up either with memory leaks
    or with calls to memory areas that have been already released.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内存释放的责任是不明确的，因此需要为每个函数或每个作用域指定，更准确地说。随着程序和数据流复杂性的增加，这个问题变得更加复杂。这会让大多数使用其他主流语言的程序员感到困惑，或者完全忽略责任，最终导致内存泄漏或调用已释放的内存区域。
- en: 'Java, C#, and Python solve all these issues without asking the programmer to
    be careful. Two techniques are helpful: reference counting and garbage collection.
    Reference counting works as follows: upon every call to copy the value, the reference
    count is increased. When getting out of scope, the reference count is decreased.
    When the reference count gets to 0, release the memory. Garbage collectors work
    similarly, only they run periodically and check also for circular references,
    ensuring that even convoluted memory structures get released correctly, albeit
    with a delay.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java、C# 和 Python 在不要求程序员小心的情况下解决了所有这些问题。两种技术是有帮助的：引用计数和垃圾回收。引用计数的工作原理如下：每次调用复制值时，引用计数都会增加。当超出作用域时，引用计数会减少。当引用计数达到
    0 时，释放内存。垃圾回收器的工作原理类似，只是它们定期运行，并检查循环引用，确保即使复杂的内存结构也能正确释放，尽管可能会有延迟。
- en: Even back in the 2000s, nothing was stopping us from implementing reference
    counting in C++. The design pattern is known as smart pointers and allows us to
    think less about these issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 2000 年代，我们也没有阻止在 C++ 中实现引用计数。这种设计模式被称为智能指针，它允许我们不必过多考虑这些问题。
- en: 'In fact, C++ had from the very beginning yet another, more elegant way, to
    deal with this problem: pass-by-reference. There’s a good reason why pass-by-reference
    is the default way to pass objects around in Java, C#, and Python: it’s very natural
    and convenient. It allows you to create an object, allocate its memory, pass by
    reference, and the best part: its memory will automatically get released upon
    exiting the scope. Let’s look at a similar example to the one using pointers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，C++ 从一开始就还有一种更优雅的方式来处理这个问题：引用传递。有很好的理由说明为什么引用传递是 Java、C# 和 Python 中传递对象的默认方式：它非常自然和方便。它允许你创建一个对象，分配其内存，通过引用传递，最好的部分是：它的内存将在退出作用域时自动释放。让我们看看一个与使用指针类似的例子：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This time, it doesn’t really matter what happens in **call1** ; the memory will
    be released correctly after exiting the scope in which data is initialized. The
    only limitation of reference types is that the memory allocated for the variable
    cannot be reallocated. Personally, I see this as a big advantage, given that modifying
    data can get messy very quickly; in fact, I prefer to pass every value with **const&**
    if possible. There are, however, limited applications for highly optimized polymorphic
    data structures that are enabled through memory reallocation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，**call1** 中发生的事情并不重要；数据初始化的作用域退出后，内存将被正确释放。引用类型的唯一限制是，为变量分配的内存不能被重新分配。就我个人而言，我认为这是一个很大的优点，因为修改数据可能会很快变得混乱；事实上，如果可能的话，我更喜欢用
    **const&** 来传递每个值。然而，对于通过内存重新分配启用的高度优化的多态数据结构，其应用是有限的。
- en: Looking at the preceding program, if we ignore the **&** sign from **call1**
    and rename the functions to fit their corresponding conventions, we could also
    read Java or C#. So, C++ could have been close to these languages from the beginning.
    Why isn’t it still similar enough?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的程序，如果我们忽略 **call1** 中的 **&** 符号，并将函数重命名以符合相应的约定，我们也可以读懂 Java 或 C#。所以，C++
    本可以从一开始就接近这些语言。为什么它现在还不够相似呢？
- en: Well, you can’t escape memory management in C++. The preceding code would not
    make a Java or C# programmer think of anything more; we established that C++ is
    different, though. The standardization committee realized that there are situations
    when we need to allocate memory in one function and release it in another and
    that it would be ideal to avoid using pointers to do that. Enter move semantics.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在 C++ 中你无法逃避内存管理。前面的代码对 Java 或 C# 程序员来说并不会引起更多的思考；我们已经确定 C++ 是不同的。标准化委员会意识到，在某些情况下，我们需要在一个函数中分配内存，在另一个函数中释放它，并且避免使用指针来做这件事将是理想的。于是，引入了移动语义。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Move semantics is a key feature introduced in C++11 to enhance performance by
    eliminating unnecessary copying of objects. It allows resources to be transferred
    from one object to another without creating a copy, which is especially beneficial
    for objects that manage dynamic memory, file handles, or other resources. To utilize
    move semantics, you need to implement a move constructor, which initializes a
    new object by transferring resources from a **rvalue** (temporary object) to the
    new object, and a move assignment operator, which transfers resources from a rvalue
    to an existing object for your class. The **std::move** function is a utility
    that casts an object to a rvalue reference, enabling move semantics. To help,
    the compiler creates the move constructor in certain conditions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义是C++11中引入的一个关键特性，通过消除不必要的对象复制来提高性能。它允许资源从一个对象转移到另一个对象，而不创建副本，这对于管理动态内存、文件句柄或其他资源的对象特别有益。要利用移动语义，你需要实现一个移动构造函数，它通过从**rvalue**（临时对象）将资源转移到新对象来初始化新对象，以及一个移动赋值运算符，它将资源从rvalue转移到你的类中的现有对象。**std::move**函数是一个工具，它将对象转换为rvalue引用，从而启用移动语义。为了帮助，编译器在特定条件下创建移动构造函数。
- en: 'See in the following example how we might use move semantics to move the scope
    of a variable to the function process:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到如何使用移动语义将变量的作用域移动到函数process中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Not much seems different, other than using two ampersand signs. The behavior
    is, however, very different. The scope of the **data** variable moves into the
    called function, and **process** , and the memory gets released upon exiting it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用两个井号符号之外，似乎没有太多不同。然而，行为却非常不同。**data**变量的作用域移动到被调用的函数中，以及**process**，内存将在退出时释放。
- en: 'Move semantics allows us to avoid copying big data values and to transfer the
    responsibility for releasing the memory into called functions. This is a unique
    mechanic between the languages we’ve discussed until now. To my best knowledge,
    the only other programming languages to implement these mechanics are the other
    contenders for systems programming: Rust and Swift.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 移动语义允许我们避免复制大数据值，并将释放内存的责任转移到被调用的函数中。这是我们迄今为止讨论的语言中独特的机制。据我所知，唯一其他实现这些机制的编程语言是系统编程的其他竞争者：Rust和Swift。
- en: This proves to us that, as much as C++ resembles Java or C# nowadays, it does
    require programmers to understand in more detail the way memory allocation and
    release work. We may have gotten over the exam questions that focused on minor
    syntax differences with big effects, but we haven’t gotten over the need to learn
    more than for the other languages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了，尽管C++现在与Java或C#相似，但它确实要求程序员更详细地了解内存分配和释放的方式。我们可能已经克服了关注微小语法差异但影响很大的考试问题，但我们还没有克服学习比其他语言更多的需求。
- en: 'Memory management, while a big part of the conversation, is not the only thing
    that makes things more difficult when learning C++. A few things are different
    and can be a bit annoying for newcomers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内存管理是讨论的大问题的一部分，但它并不是使学习C++变得更困难唯一的原因。一些事情是不同的，对于新手来说可能有点烦人：
- en: The need for **#ifndef** preprocessor directives or the non-standard but often
    supported **#pragma once** to ensure that files are only included once
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要**#ifndef**预处理器指令或非标准的但通常支持的**#pragma once**来确保文件只包含一次
- en: Separate **.h** files along with arbitrary rules of what goes in **.h** and
    what goes in **.cpp**
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**.h**文件与任意规则分开，规定什么应该放在**.h**中，什么应该放在**.cpp**中
- en: The very weird way to define interfaces with **virtual methodName()=0**
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**virtual methodName()=0**定义接口的非常奇怪的方式
- en: 'While we can ensure we use all these contraptions with rules and guidelines
    automatically applied by modern IDEs, their presence begs the question: Why are
    they still needed?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过现代IDE自动应用规则和指南来确保我们使用所有这些装置，但它们的出现引发了一个问题：为什么它们仍然需要？
- en: Barring the aforementioned, it is much more difficult to get over the fact that
    there’s no easy way to build a program and add external references. Java, with
    all its faults, has a single compiler, and Maven/Gradle as standard tools for
    dependency management that allow the download and integration of a new library
    with a simple command. C#, although fraught with the same issue for a long time,
    has pretty much standardized the community-created NuGet command for getting external
    libraries. Python features the standard **pip** command for managing packages.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述内容，更难以接受的是，没有简单的方法来构建程序并添加外部引用。尽管Java存在许多缺陷，但它有一个单一的编译器，以及Maven/Gradle作为标准工具，用于依赖关系管理，允许通过简单的命令下载和集成新的库。C#虽然长时间存在相同的问题，但已经基本标准化了社区创建的NuGet命令，用于获取外部库。Python具有标准的**pip**命令，用于管理包。
- en: With C++, you need to work more. Unlike Java and C#, which count on a virtual
    machine, your C++ programs need to be compiled for every supported target, and
    each target matched with the right libraries. Of course, there are tools for that.
    The two package managers I’ve heard mentioned the most are Conan and **vcpkg**
    . For build systems, CMake seems quite popular. The trouble is that none of these
    tools are standard. While it’s true that neither Java’s Maven/Gradle nor C#’s
    NuGet have started as a standard, their integration in tools and fast adoption
    means that they are the de facto standard today. C++ has a little bit more to
    go until this part of the language matures. We’ll talk more about these issues
    in a separate chapter, but it’s obvious that part of the C++ confusion is also
    generated by this complexity in trying out simple programs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++，你需要做更多的工作。与依赖于虚拟机的Java和C#不同，你的C++程序需要为每个支持的目标进行编译，并且每个目标都需要匹配正确的库。当然，有相应的工具。我听说最多的两个包管理器是Conan和**vcpkg**。对于构建系统，CMake似乎相当受欢迎。问题是，这些工具都不是标准的。虽然Java的Maven/Gradle和C#的NuGet都不是从标准开始的，但它们的工具集成和快速采用意味着它们现在是事实上的标准。C++还需要一段时间才能使这个语言部分成熟。我们将在单独的章节中更多地讨论这些问题，但很明显，C++的困惑部分也是由尝试简单程序时的这种复杂性产生的。
- en: 'We looked at various complications in C++ compared to other languages, and
    we saw that while the language has gotten easier, it’s still not as easy as Java
    or C#. But the core question is: Is C++ very difficult to learn? To examine this,
    let’s look at three methods beginners can use to learn C++.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较了C++与其他语言的各种复杂性，并看到虽然语言变得更容易，但它仍然不像Java或C#那样容易。但核心问题是：C++是否很难学？为了检验这一点，让我们看看初学者可以用来学习C++的三种方法。
- en: The Stroustrup method for learning C++
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斯特劳斯特普学习C++的方法
- en: 'While the C++ standard has evolved toward simplicity, many of the learning
    materials have stayed the same. I can imagine it’s difficult to keep up with the
    C++ standard, given its newfound speed of change after 2010, and a question always
    remains: How much code is using the latest standard? Won’t students need to learn
    anyway the old ways of C++ so that they can deal with decades-old code bases?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++标准已经向简单化发展，但许多学习材料仍然保持不变。我想象着，鉴于2010年之后C++标准变化的速度加快，跟上C++标准可能很困难，而且总有一个问题存在：有多少代码使用了最新的标准？学生难道不是无论如何都需要学习C++的旧方法，以便能够处理几十年前的代码库吗？
- en: 'Despite this possibility, we must progress at some point, and Bjarne Stroustrup
    thought the same. The third edition of his book, *Programming: Principles and
    Practice using C++* ( [https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/](https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/)
    ), published in 2024, is addressed to beginners in programming and takes them
    through the C++ language. The book is a very good introduction to C++, and it’s
    accompanied by examples and a slide deck useful for anyone who wants to teach
    or learn the language.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这种可能性，但我们必须在某一点上前进，Bjarne Stroustrup也有同样的想法。他的第三版书籍《*使用C++进行编程：原理与实践*》（[https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/](https://www.amazon.com/Programming-Principles-Practice-Using-C-ebook/dp/B0CW1HXMH3/)），于2024年出版，面向编程初学者，并引导他们学习C++语言。这本书是C++的一个非常好的入门介绍，并附有示例和幻灯片，对任何想要教授或学习这门语言的人来说都很有用。
- en: It’s interesting to note that Stroustrup does not shy away from the topic of
    pointers and memory management, instead discussing the minimum necessary and immediately
    showing the ways modern C++ avoids them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，斯特劳斯特普并没有回避指针和内存管理这个话题，反而讨论了必要的最小化内容，并立即展示了现代C++避免这些问题的方法。
- en: 'Let’s take as an example the slides associated with *Chapter 16* that focus
    on arrays. They start with an explanation of naked arrays, their connection with
    pointers, and how you can get in trouble when using pointers. Then, alternatives
    are introduced: **vector** , **set** , **map** , **unordered_map** , **array**
    , **string** , **unique_ptr** , **shared_ptr** , **span** , and **not_null** .
    The deck ends with an example of a palindrome implementation in multiple ways,
    comparing the differences in safety and brevity of the code. Therefore, the whole
    purpose of this chapter is to show the various issues with arrays and pointers
    and how STL structures help avoid these issues.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *第 16 章* 相关的幻灯片为例，该章节专注于数组。它们从裸数组的解释开始，解释它们与指针的联系，以及在使用指针时可能会遇到的问题。然后引入了替代方案：**vector**、**set**、**map**、**unordered_map**、**array**、**string**、**unique_ptr**、**shared_ptr**、**span**
    和 **not_null**。演示文稿以多种方式实现回文示例结束，比较了代码的安全性和简洁性。因此，整个章节的目的是展示数组与指针的各种问题，以及 STL
    结构如何帮助避免这些问题。
- en: The resulting code closely resembles the Java or C# variants. However, Stroustrup
    points out that pointer arithmetic is still useful to implement data structures.
    In other words, use it sparingly and only when you really need heavy optimizations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的代码与 Java 或 C# 变体非常相似。然而，斯特劳斯特普指出，指针运算仍然对于实现数据结构是有用的。换句话说，要谨慎使用，并且只有在真正需要重型优化时才使用。
- en: We conclude, therefore, that the language creator doesn’t shy away from pointers
    and memory management but is focused on removing a lot of the potential issues
    that come with it. This enables C++ programmers to care less about memory management
    than in the C++ 98 era, but still a little bit more than in Java or C#.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出结论，语言创造者并不回避指针和内存管理，而是专注于消除随之而来的许多潜在问题。这使得 C++ 程序员在 C++ 98 时代相比，对内存管理的关注较少，但仍然比
    Java 或 C# 多一点。
- en: 'The question still stands: Could beginners learn C++ without thinking much
    about pointers? Another teaching method seems to prove this is possible – if we
    want to train library users instead of library creators.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是仍然存在：初学者能否在不过多考虑指针的情况下学习 C++？另一种教学方法似乎证明了这是可能的——如果我们想训练库用户而不是库创建者的话。
- en: The Kate Gregory method – don’t teach C
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凯特·格雷戈里的方法——不教授 C
- en: In a talk at *CppCon 2015* ( [https://www.youtube.com/watch?v=YnWhqhNdYyk](https://www.youtube.com/watch?v=YnWhqhNdYyk)
    ), Kate Gregory makes the point that C is not a prerequisite for learning C++
    and that it’s actively harming the learning process to start by teaching **printf**
    , naked arrays, and char pointers on the first day of a beginner C++ course.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2015 年的 *CppCon* 讲座中（[https://www.youtube.com/watch?v=YnWhqhNdYyk](https://www.youtube.com/watch?v=YnWhqhNdYyk)），凯特·格雷戈里指出，学习
    C++ 并不需要 C 作为先决条件，而且一开始就教授 **printf**、裸数组以及字符指针，对初学者来说，这实际上是在损害学习过程。
- en: Instead, her proposal is to start with the objects available in STL. The string
    and vector classes are quite clear to beginners, and operator overloading is also
    a very natural way to use these objects. Beginners expect that **"abcd" + "efg"**
    will result in **"abcdefg"** ; there’s no need to explain the intricacies of operator
    overloading so that they can write simple programs. Moreover, this approach completely
    avoids discussing destructors and memory cleanup.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，她的建议是从 STL 中可用的对象开始。字符串和向量类对初学者来说相当清晰，并且运算符重载也是使用这些对象的一种非常自然的方式。初学者期望 **"abcd"
    + "efg"** 将产生 **"abcdefg"**；没有必要解释运算符重载的复杂性，以便他们可以编写简单的程序。此外，这种方法完全避免了讨论析构器和内存清理。
- en: She continues by arguing that teaching lambdas to beginners is also quite easy
    if you start with an example. Consider trying to find a value in a vector. A first
    approach would be using a **for** loop that you can skim over. The second method
    is using **std::find** . But what if we want to find an even value in a **vector<int>**
    instance? This introduces lambdas very naturally in the conversation, without
    a whole discussion on all the possible ways to write them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 她继续争辩说，如果从示例开始，教初学者使用 lambda 表达式也很简单。考虑尝试在一个向量中查找一个值。第一种方法可能是使用一个可以快速浏览的 **for**
    循环。第二种方法是使用 **std::find**。但如果我们想在 **vector<int>** 实例中查找一个偶数值呢？这很自然地将 lambda 表达式引入到对话中，而不需要对所有可能的编写方式进行整个讨论。
- en: With this method, she argues that beginners will be able to use existing libraries.
    They will have some gaps in their knowledge, and in the case of a course for programmers
    working on a specific code base, you might need to have a section that introduces
    them to reading specific idioms useful for their work. And if you want these programmers
    to become library creators, then you need a more advanced course that dives into
    the depths of memory management and optimizations possible with pointers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 她认为，使用这种方法，初学者将能够使用现有的库。他们将在知识上存在一些差距，在为特定代码库工作的程序员课程中，你可能需要有一个部分向他们介绍阅读对他们工作有用的特定习语。如果你想让这些程序员成为库的创建者，那么你需要一个更高级的课程，深入探讨内存管理和指针可能实现的优化。
- en: My 15 years of experience training people in complex skills tell me that this
    teaching method is very good. A key thing in training is to understand your target
    audience and do your best to avoid the curse of knowledge – the fact that you
    don’t remember how it was not to know something you know very well today. This
    method caters to the beginner mind by providing fast wins and good progression
    and giving the learners the courage to write code. So, it’s definitely an improvement
    in the methods of learning C++.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我在复杂技能培训方面的 15 年经验告诉我，这种教学方法非常好。培训中的一个关键点是理解你的目标受众，并尽最大努力避免知识的诅咒——即你无法回忆起你今天非常熟悉的东西不知道时的感觉。这种方法通过提供快速胜利和良好的进步，以及给予学习者编写代码的勇气，来迎合初学者的心态。因此，它无疑是学习
    C++ 方法的改进。
- en: 'However, this is not the only way to learn a language. It’s a structured way,
    yes, but exploration is an important part of learning. There’s a way to learn
    C++ through exploration that uses a method typically associated with Twitter clashes:
    **Test Driven** **Development** ( **TDD** ).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，学习语言的方法不止这一种。是的，这是一种结构化的方法，但探索是学习的一个重要部分。有一种通过探索学习 C++ 的方法，它使用通常与推特冲突相关的方法：**测试驱动开发**（**TDD**）。
- en: The test-driven method for learning C++
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 C++ 的测试驱动方法
- en: Learning from books or structured courses is only one method; the other one
    is through personal exploration. Imagine learning C++, but instead of having to
    look through a bunch of code examples first, write the code as you think it should
    work and learn incrementally the differences between your intuition and the actual
    language. In fact, people naturally combine these two methods even when going
    through a structured learning course.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍或结构化课程中学习只是其中一种方法；另一种是通过个人探索。想象一下学习 C++，但不是先要查看一大堆代码示例，而是编写你认为应该工作的代码，并逐步学习你的直觉与实际语言之间的差异。实际上，人们在通过结构化学习课程时自然会结合这两种方法。
- en: 'One downside of learning through exploration is that it’s hard to understand
    your progress, and you might often end up in difficult spots. A method comes to
    the rescue: TDD.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索学习的一个缺点是难以理解你的进度，你可能会经常陷入困境。有一种方法可以解救：TDD。
- en: 'TDD is a counter-intuitive, effective method for incremental design. Its simplest
    description is the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种反直觉但有效的增量设计方法。其最简单的描述如下：
- en: '**Step 1, also known as red** : Write one test that fails and shows the next
    case that needs to be implemented'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 1，也称为红色**：编写一个失败的测试，显示需要实现的下一个案例'
- en: '**Step 2, also known as green** : Write the simplest code to make the test
    pass (and keep all the other tests passing)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 2，也称为绿色**：编写最简单的代码以使测试通过（并保持所有其他测试通过）'
- en: '**Step 3, also known as refactor** : Refactor the production code and the test
    code to simplify.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤 3，也称为重构**：重构生产代码和测试代码以简化。'
- en: This red-green-refactor cycle repeats in very small cycles (often 5-10 minutes)
    until all the behaviors associated with the current feature or user story have
    been implemented.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种红-绿-重构周期在非常小的周期内重复（通常 5-10 分钟），直到所有与当前功能或用户故事相关的行为都已实现。
- en: Addressing TDD misconceptions
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 TDD 误解
- en: 'Personally, I am a fan of TDD, and I’ve used it for more than 10 years with
    a lot of success. In fact, I used TDD to write the sample code for this book.
    However, I know that TDD has been received with mixed feelings by the industry.
    Part of it is a failure in imagination, a common question being: How can I write
    a test for a method that doesn’t exist? Well, pretty much the same way in which
    you write code that hasn’t existed before: you imagine it’s there and focus on
    the desired inputs and outputs. Other criticism comes from failing to understand
    what TDD really is and how it works. Examples of faux TDD failures often involve
    starting with edge cases and showing that things get complicated very quickly
    when you should start with happy-path cases. Claims of TDD slowing down development
    are credible, but the truth is that this method helps us be more thorough and
    calculated, thus avoiding issues that are usually caught much later in the process
    and fixed with much sweat and stress. Finally, TDD is not a method for designing
    high-performing algorithms, but it can help you find a first solution that you
    later optimize with the help of a test suite.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 个人而言，我是一个TDD的粉丝，并且我已经成功使用了超过10年。实际上，我使用TDD来编写这本书的示例代码。然而，我知道TDD在业界受到了不同的评价。部分原因是想象力不足，一个常见的问题是：我该如何为一个不存在的函数编写测试？嗯，基本上和编写一个之前不存在的代码的方式一样：你想象它存在，并专注于期望的输入和输出。其他批评来自于对TDD真正是什么以及它是如何工作的理解不足。伪TDD失败的例子通常涉及从边缘情况开始，并显示当你应该从正常路径情况开始时，事情会迅速变得复杂。关于TDD会减慢开发速度的说法是可信的，但事实是，这种方法帮助我们更加彻底和有计划，从而避免了通常在后期才被发现并需要大量汗水和压力来修复的问题。最后，TDD不是设计高性能算法的方法，但它可以帮助你找到一个初始解决方案，你随后可以通过测试套件的帮助来优化它。
- en: To understand how to learn a programming language with a modified TDD cycle,
    we need to clarify two things about TDD. First, TDD is counter-intuitive because
    it requires a prolonged focus on the problem domain, while most programming courses
    teach us how to deal with the solution domain. Second, TDD is a method for incremental
    design; that is, finding a code structure that solves a specific problem in a
    step-by-step manner instead of all at once. These two characteristics make TDD
    the best fit for learning a new programming language, with some support.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何通过修改的TDD周期来学习编程语言，我们需要澄清关于TDD的两个问题。首先，TDD是非直观的，因为它要求对问题领域进行长时间的专注，而大多数编程课程教我们如何处理解决方案领域。其次，TDD是一种增量设计方法；也就是说，以逐步的方式找到一个解决特定问题的代码结构，而不是一次性解决。这两个特性使得TDD在有适当支持的情况下，成为学习新编程语言的最佳选择。
- en: 'Imagine that instead of learning the whole thing about C++ before being able
    to run a program, you just learn how to write a test. That is easy enough because
    tests tend to use a small subset of the language. Moreover, running the tests
    gives you instant feedback: failure or red when something is not right and success
    or green when everything is working fine. Finally, this allows you to explore
    a problem once you have one or more tests and figure out how to write the code
    such that the compiler understands it – which is what you want when you learn
    a language. It might be a bit problematic to figure out the error messages, particularly
    in C++, but if you have a person (or maybe an AI in the future) to ask for help,
    you’ll learn a lot on your way and see the green bar whenever you’ve learned something
    new.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在你能够运行一个程序之前，不是先学习关于C++的所有内容，而是先学习如何编写测试。这其实很简单，因为测试通常只使用语言的一小部分。此外，运行测试会立即给你反馈：如果有什么不对的地方，会显示失败或红色，而当一切正常时，会显示成功或绿色。最后，一旦你有一个或多个测试，这让你可以探索一个问题，并找出如何编写代码，使得编译器能够理解它——这正是你学习一门语言时想要的。在C++中，找出错误信息可能有点问题，但如果你有一个人（或者未来可能是一个AI）可以求助，你会在学习过程中学到很多东西，并且每当学到新东西时，你都会看到绿色的进度条。
- en: This method has been tested on a small scale, and it worked remarkably well.
    Here’s how a learning session might work for C++.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法已经在小规模上进行了测试，并且效果显著。以下是一个C++学习会议可能的工作方式。
- en: Setup
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: At least two actors are involved in the learning process; we’ll call them the
    coach and the student. I prefer using a coach instead of the instructor because
    the goal is to guide the students on their own learning path rather than teach
    them things directly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 学习过程中至少涉及两个参与者；我们将它们称为教练和学生。我更喜欢使用教练而不是讲师，因为目标是引导学生走他们自己的学习路径，而不是直接教他们东西。
- en: I will discuss the rest of the session as if only a student is involved. A similar
    setup can work with multiple students as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将讨论剩余的会话，好像只有学生参与一样。类似的设置也可以用于多个学生。
- en: The first thing the actors need to do is to set a goal. Typically, the goal
    is to learn a minimum of C++, but it can also be learning more about a specific
    topic – for example, **std::vector** or STL algorithms.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 行动者需要做的第一件事是设定一个目标。通常，目标是学习至少C++，但也可以是更深入地了解某个特定主题——例如，**std::vector** 或 STL算法。
- en: In terms of the technical setup, this process works best with the two people
    watching the code on the same monitor and working side by side. While this is
    best done in person, remote is possible as well through various tools.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术设置方面，两个人在同一个显示器上观看代码并并肩工作效果最好。虽然最好是面对面进行，但通过各种工具远程也是可能的。
- en: To start, the coach needs to set up a simple project composed of a test library,
    a production code file, and a test file. A simple way to run the tests needs to
    be provided, either as a button click, a keyboard shortcut, or a simple command.
    The setup I recommend for C++ is to use **doctest** ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ), a header file-only test library that is very fast and supports a lot of the
    features needed for production.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，教练需要设置一个简单的项目，包括测试库、生产代码文件和测试文件。需要提供一个简单的方式来运行测试，无论是通过按钮点击、键盘快捷键还是简单的命令。我推荐的C++设置是使用
    **doctest**（[https://github.com/doctest/doctest](https://github.com/doctest/doctest)），这是一个仅包含头文件的测试库，它非常快，并支持生产所需的大量功能。
- en: 'Here’s the simplest structure for this project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个项目的最简单结构：
- en: A test file, **test.cpp**
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个测试文件，**test.cpp**
- en: A production header file, **prod.h**
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个生产头文件，**prod.h**
- en: A **doctest.h** file
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **doctest.h** 文件
- en: A Makefile allowing us to run the tests
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许我们运行测试的Makefile
- en: A **production cpp** file may also be needed depending on the learning objectives.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据学习目标，可能还需要一个 **production cpp** 文件。
- en: 'The coach also needs to provide an example of a first test that fails and show
    how to run the tests. The student takes over the keyboard and runs the test as
    well. This test can be very simple, as in the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 教练还需要提供一个第一次测试失败示例，并展示如何运行测试。学生接管键盘并运行测试。这个测试可以非常简单，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The production header shows the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生产头文件显示了以下内容：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first order of business is then to make the test pass. The question the
    coach will keep asking the student is: “How do you think this will work? Write
    whatever you find intuitive.” If the student finds the correct answer, great!
    If not, show the correct answer and explain the reasons.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是让测试通过。教练会不断问学生的一个问题：“你认为这会怎么工作？写下你找到的任何直观的想法。”如果学生找到了正确答案，太好了！如果没有，展示正确答案并解释原因。
- en: 'This example is very useful because it introduces a few elements of the language
    and shows them working: a function declaration, a variable, a test, and a return
    value. At the same time, the process is very nice because it gives the student
    a measure of progress: tests passing is good, and tests not passing means there’s
    something to learn.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例非常有用，因为它介绍了一些语言元素并展示了它们的工作：函数声明、变量、测试和返回值。同时，这个过程也非常好，因为它给学生提供了一个进度衡量标准：测试通过是好的，测试未通过则意味着有东西要学习。
- en: With all these done, it’s time to enter the exploration phase.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，就到了探索阶段。
- en: Exploring the language
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索语言
- en: 'There are two ways to explore a programming language in this manner: through
    simple problems that introduce concepts one by one, also known as koans, or through
    solving a more complex problem.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式探索编程语言有两种方法：通过简单的问题逐一引入概念，也称为禅宗，或者通过解决更复杂的问题。
- en: 'Either way, the method stays the same: first, the coach writes a simple test
    or helps the student write a simple test that fails. Then, the student is asked
    to write the solution that seems most intuitive to them. Tests are run, and if
    they don’t pass, the coach needs to explain what is not working. Either the coach
    or the student makes the change, and when the tests pass, the step ends with clear
    progress.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，方法都是一样的：首先，教练写一个简单的测试或帮助学生写一个失败的简单测试。然后，要求学生写出他们认为最直观的解决方案。运行测试，如果它们没有通过，教练需要解释哪里出了问题。无论是教练还是学生进行更改，当测试通过时，步骤以清晰的进度结束。
- en: During this process, it’s important to focus on the next natural step for the
    student. If the student has specific questions or curiosities, the next test can
    treat these instead of going through a scripted process. This adaptive way of
    learning helps students feel in charge, and the process gives them an illusion
    of autonomy that eventually turns into reality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，重要的是要关注学生的下一步自然步骤。如果学生有具体的问题或好奇心，下一个测试可以处理这些问题，而不是通过脚本化的过程。这种适应性学习方法帮助学生感到掌控全局，这个过程给他们一种自主性的错觉，最终变成现实。
- en: What about memory issues?
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于内存问题呢？
- en: We spent some time in this chapter discussing the fact that C++ programmers
    need to learn more about memory management than their colleagues using other mainstream
    programming languages. How can they learn memory management with this method?
    Tests will not catch memory issues, will they?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中花了一些时间讨论这样一个事实：与使用其他主流编程语言相比，C++程序员需要学习更多的内存管理知识。他们如何通过这种方法学习内存管理？测试不会捕捉到内存问题，对吧？
- en: 'Indeed, we want students to learn that they need to care about memory from
    the very beginning. Therefore, memory checks need to be integrated into our test
    suite. We have two options to do this: either use a specialized tool or select
    a test library that can detect memory issues.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们希望学生从一开始就意识到他们需要关注内存。因此，内存检查需要集成到我们的测试套件中。我们有两个选择来实现这一点：要么使用专门的工具，要么选择可以检测内存问题的测试库。
- en: 'A specialized tool such as **valgrind** is easy to integrate into our process.
    See the following example of a Makefile:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如 **valgrind** 这样的专用工具很容易集成到我们的流程中。请参见以下 Makefile 的示例：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The **test.cpp** target is compiling the tests. The test target depends on **test.cpp**
    and runs the tests. And the first target, **check-leaks** , runs **valgrind**
    automatically with options to show errors only when they come up so that students
    don’t get overwhelmed. When running **make** without any parameters, the first
    target is picked, so the memory analysis is done by default.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**test.cpp** 目标正在编译测试。测试目标依赖于 **test.cpp** 并运行测试。第一个目标，**check-leaks**，会自动运行
    **valgrind**，并带有仅当出现错误时显示错误的选项，这样学生就不会感到不知所措。在没有参数的情况下运行 **make** 时，第一个目标会被选中，因此默认情况下会进行内存分析。'
- en: 'Assume we are running the tests with a memory leak, as in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在运行带有内存泄漏的测试，如下例所示：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are immediately greeted by this output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即看到了以下输出：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This output provides enough information for a conversation with the student.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出为学生提供了足够的信息进行讨论。
- en: The second option is to use a test library that already has memory leak detection
    implemented. CppUTest ( [http://cpputest.github.io/](http://cpputest.github.io/)
    ) is such a library, and it also has the advantage of supporting C and working
    for embedded code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用已经实现了内存泄漏检测的测试库。CppUTest ([http://cpputest.github.io/](http://cpputest.github.io/))
    就是这样一种库，它还有支持C和适用于嵌入式代码的优势。
- en: With these tools at our disposal, it’s now clear that this method works for
    teaching C++ to anyone who wants to try it or to dive deeper into specific parts,
    using exploration as a method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，现在很明显，这种方法适用于向任何想要尝试或深入研究特定部分的C++学习者教授C++。
- en: Now that we learned two methods for learning C++ today, let’s go back to understanding
    what C++’s niche is and why it necessarily needs to be more complex than other
    languages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们今天学习了两种学习C++的方法，让我们回到理解C++的利基是什么以及为什么它必然比其他语言更复杂。
- en: With great power…
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有很大的力量……
- en: If there’s one thing I’d like you to take away from this chapter, it’s that
    C++ is a very powerful language, and with this power comes the programmer’s responsibility
    to use the appropriate level of abstraction.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想要你从本章中带走的东西，那就是C++是一个非常强大的语言，而随着这种力量的到来，程序员有责任使用适当的抽象级别。
- en: I’m certain that a team of C++ programmers starting a new project today that
    solves specific business problems, using only the latest standard and specific
    libraries, can write code safely and with good performance without worrying about
    memory issues more than their Java or C# colleagues. In fact, it’s likely their
    code will resemble quite closely that written in other languages, with the expectation
    of better performance.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信，今天开始一个新项目、解决特定商业问题、仅使用最新标准和特定库的C++程序员团队可以安全地编写代码，并具有良好的性能，无需过多担心内存问题，比他们的Java或C#同事还要少。事实上，他们的代码很可能与其他语言的代码非常相似，预期有更好的性能。
- en: 'However, even such a team will occasionally face a choice: Do we implement
    a slightly less performant solution using the existing tools offered to us by
    STL, or do we optimize it to the stars by recursing to pointer arithmetic, move
    semantics, or custom memory management? This is when the power of C++ requires
    an equally high level of responsibility, care, and deep understanding.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是这样一个团队，偶尔也会面临选择：我们是使用STL提供的现有工具实现一个稍微低效的解决方案，还是通过递归到指针算术、移动语义或自定义内存管理来优化它？这就是C++的力量需要同样高水平的责任、细心和深刻理解的时候。
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As I’m writing these words, the world is still in turmoil after the CrowdStrike
    incident of July 2024. The causes for the incident are still not 100% clear, despite
    the official disclosure ( [https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage](https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage)
    ). Either way, it looks as if a memory access error in a C++ program has led to
    a kernel panic in Windows systems around the world, grounding planes, stopping
    money transfers, and – most dreadfully – shutting down emergency services. Of
    course, this change should have never reached production, but it’s nonetheless
    a reminder of how much the world depends on software and of the consequences of
    the misuse of the power of C++.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写下这些文字时，世界仍在2024年7月的CrowdStrike事件之后陷入混乱。尽管官方已经披露（[https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage](https://www.scmagazine.com/news/crowdstrike-discloses-new-technical-details-behind-outage)），但事件的起因仍然不十分清楚。无论如何，似乎是一个C++程序中的内存访问错误导致了全球Windows系统的内核恐慌，导致飞机停飞、资金转账停止，以及——最可怕的是——紧急服务关闭。当然，这种变化本不应该进入生产环境，但这却是一个提醒，说明世界对软件的依赖程度有多大，以及滥用C++力量的后果。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we examined a statement: *C++ is very difficult to learn*
    . So, is it?'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考察了一个声明：“C++非常难学”。那么，它是吗？
- en: We looked at the history of C++ and how initially it was indeed a challenge
    to write even the simplest of programs. We saw how Java, C#, and Python deal with
    some of the problems programmers face with C++ and how the C++ standard has evolved
    unexpectedly fast in the past 15 years to remove its impediments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了C++的历史，以及它最初确实是一个挑战，即使是编写最简单的程序。我们看到了Java、C#和Python如何处理程序员面临的某些问题，以及C++标准在过去15年中是如何意外地快速发展的，以消除其障碍。
- en: While you can write C++ code that resembles Java or C# today, you will likely
    still need to understand memory management, a fact we exemplified using move semantics.
    We also saw that the methods for learning C++ have evolved with the language and
    with the times, with Stroustrup introducing pointers only in passing and quickly
    switching to higher-level structures available in STL. We saw that a modified
    TDD cycle can help people learn C++ in an exploratory manner and without getting
    overwhelmed by the complexity of error messages and the language.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你现在可以写出类似于Java或C#的C++代码，但你可能仍然需要理解内存管理，这一点我们通过使用移动语义进行了例证。我们还看到，随着语言和时代的发展，学习C++的方法也在不断演变，Stroustrup只是简单介绍了指针，然后迅速转向STL中可用的更高级结构。我们看到，修改后的TDD循环可以帮助人们以探索的方式学习C++，而不会因为错误信息的复杂性和语言的复杂性而感到不知所措。
- en: We also pointed out that C++ has a disadvantage when it comes to tooling and
    portability. Installing a new dependency is a whole thing in C++, unlike Java,
    Python, or C#, which provide one de facto standard command to manage packages.
    This can turn off wannabe C++ programmers who make a deeper analysis.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指出，C++在工具和可移植性方面存在劣势。在C++中安装一个新的依赖项是一项完整的工作，与Java、Python或C#不同，它们提供了一个事实上的标准命令来管理包。这可能会让想要成为C++程序员的初学者望而却步。
- en: Finally, despite the progress in the standard, we cannot forget the sheer size
    of C++ code that is in the world and not up to the latest standard. Chances are,
    even if you learn modern C++, your work will involve dealing with older code sooner
    or later.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管标准有了进步，但我们不能忘记世界上存在的大量C++代码，这些代码还没有达到最新的标准。很可能，即使你学习了现代C++，你的工作迟早也会涉及到处理旧代码。
- en: We conclude, therefore, that C++ is still more difficult to learn than Java,
    C#, or Python, but that it’s closer than it’s ever been and that the power of
    the language continues to be attractive for a subset of programmers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出结论，C++仍然比Java、C#或Python更难学习，但它比以往任何时候都更接近，而且对于程序员的一个子集来说，语言的强大功能仍然具有吸引力。
- en: 'In the next chapter, Ferenc will examine the question: Is every C++ program
    standard? Or, maybe programmers are driven by solving problems and picking the
    solutions that work best in their environment, ignoring the standard or even creating
    idioms that end up in the standard after a while.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，Ferenc将探讨以下问题：每个C++程序都是标准化的吗？或者，也许程序员们是被解决问题和选择最适合他们环境的解决方案所驱动，忽略了标准，甚至创造了最终会被纳入标准的习惯用法。
