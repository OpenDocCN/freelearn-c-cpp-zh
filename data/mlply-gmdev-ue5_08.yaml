- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Introducing AI into a Multiplayer Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将人工智能引入多人游戏环境
- en: '**Artificial Intelligence** (**AI**) systems offer an exciting and unique gaming
    experience for players by providing dynamic challenges that are unpredictable
    and engaging. This allows developers to create immersive worlds with realistic
    behavior from **non-player** **characters** (**NPCs**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**人工智能**（**AI**）系统通过提供不可预测和吸引人的动态挑战，为玩家提供令人兴奋和独特的游戏体验。这允许开发者创建具有逼真行为的沉浸式世界，来自**非玩家****角色**（**NPC**）。'
- en: In this chapter, I will introduce you to the basics of AI in Unreal Engine but,
    as this is a book about multiplayer games, I will not go deep into the details
    of the system – instead, you will take the first steps in the creation of opponents,
    which will make your game fully playable from a networked point of view.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您介绍虚幻引擎中人工智能的基础知识，但由于这是一本关于多人游戏的书籍，我将不会深入探讨系统的细节——相反，你将迈出创建对手的第一步，这将使你的游戏从网络角度完全可玩。
- en: By the end of the chapter, you will have created an enemy Actor that wanders
    around the level and actively pursues the player’s character once it is detected.
    This will serve as a starting point for creating more diverse and compelling enemies
    in your game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将创建一个敌人演员，它在关卡中四处游荡，一旦检测到玩家角色就会积极追击。这将成为你在游戏中创建更多样化和引人入胜的敌人的起点。
- en: 'So, in this chapter, I will present you with the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我将向您介绍以下主题：
- en: Setting up the AI system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置人工智能系统
- en: Creating an AI opponent
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建人工智能对手
- en: Adding opponents to the level
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向关卡添加对手
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the topics presented in this chapter, you should have completed the
    previous ones and understood their content.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中介绍的主题，你应该已经完成了前面的章节，并理解了它们的内容。
- en: 'Additionally, if you would prefer to begin with code from the companion repository
    for this book, you can download the `.zip` project files provided in this book’s
    accompanying project repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你希望从本书的配套仓库开始编写代码，你可以下载本书配套项目仓库中提供的`.zip`项目文件：
- en: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5](https://github.com/PacktPublishing/Multiplayer-Game-Development-with-Unreal-Engine-5)'
- en: You can download the files that are up to date with the end of the last chapter
    by clicking the `Unreal Shadows –` `Chapter 07``End` link.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击`Unreal Shadows –` `Chapter 07``End`链接下载与上一章结尾相符的最新文件。
- en: Setting up the AI system
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置人工智能系统
- en: Crafting an AI opponent in Unreal Engine can be quite a hard task. Luckily,
    this book is focused on boosting your multiplayer prowess, rather than getting
    bogged down in all the details of AI, so I will not go deep into the Unreal Engine
    AI system. However, if you want to make your game enjoyable, it definitely helps
    to have some know-how on creating a worthy AI opponent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中制作人工智能对手可能是一项相当困难的任务。幸运的是，这本书专注于提升你的多人游戏技巧，而不是陷入人工智能的所有细节，所以我将不会深入探讨虚幻引擎的人工智能系统。然而，如果你想使你的游戏有趣，了解如何创建一个值得尊敬的人工智能对手肯定有帮助。
- en: In order to make the AI character move around the level, you will need to define
    which areas are allowed and which are not (as an example, you will most definitely
    need to give the character a safe place that the opponents won’t dare to step
    into). Once we’ve done that, in the next steps, we will create these areas so
    that the AI system can manage the minions’ walking paths. Once we’ve done that,
    we’ll be well on our way to creating awesome, mindless, walking undead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让人工智能角色在关卡中移动，你需要定义哪些区域是允许的，哪些是不允许的（例如，你肯定需要给角色一个安全的地方，对手不敢踏入）。一旦我们完成了这个，在接下来的步骤中，我们将创建这些区域，以便人工智能系统可以管理小兵的行走路径。一旦我们完成了这个，我们就会朝着创建令人惊叹的、无意识的、行走的亡灵迈出坚实的步伐。
- en: To make everything work properly, first of all, we need to give our minion opponents
    something to walk on. As you may already know, Unreal Engine uses a **Navigation
    System** to let AI Actors navigate a level using pathfinding algorithms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一切正常工作，首先，我们需要给我们的小兵对手一些可以行走的地方。正如你可能已经知道的，虚幻引擎使用**导航系统**让AI演员使用路径查找算法在关卡中导航。
- en: The Navigation System takes the collision geometry in your level and generates
    a **Navigation Mesh**, which is then split into portions (i.e., polygon geometries)
    that are used to create a graph. This graph is what **agents** (such as AI characters)
    use to navigate to their destination. Each portion is given a cost, which agents
    then use to calculate the most efficient path (the one with the lowest overall
    cost). It’s like a smart GPS for your game characters!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 导航系统将您级别中的碰撞几何形状生成一个**导航网格**，然后将其分割成部分（即多边形几何形状），这些部分用于创建一个图。这个图是**代理**（如AI角色）用来导航到其目的地的东西。每个部分都会被赋予一个成本，然后代理使用这个成本来计算最有效的路径（成本最低的路径）。这就像为您的游戏角色提供了一个智能GPS！
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want more information about the Unreal Engine Navigation System and
    its inner workings, you can visit the official Epic Games documentation at this
    link: [https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于虚幻引擎导航系统及其内部工作原理的信息，您可以访问以下链接的官方Epic Games文档：[https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/](https://docs.unrealengine.com/5.1/en-US/navigation-system-in-unreal-engine/).
- en: 'To add a Navigation Mesh to the level, you will need to take the following
    steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要将导航网格添加到级别中，您需要执行以下步骤：
- en: Open the game level you’ve been working on so far and, from the **Quickly add
    to the project** button, select **NavMeshBoundsVolume**. This will add the **NavMeshBoundsVolume**
    component to the level and a **RecastNavMesh** Actor.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您迄今为止一直在工作的游戏级别，并从**快速添加到项目**按钮中选择**NavMeshBoundsVolume**。这将向级别添加**NavMeshBoundsVolume**组件和一个**RecastNavMesh**
    Actor。
- en: In the **Outliner**, select **NavMeshBoundsVolume** and, with the **Scale**
    tool enabled, resize it so that it covers your desired portion of the level –
    avoid the spawn region for your player characters, as you want to give them a
    safe place to rest or escape to if needed.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**大纲**中，选择**NavMeshBoundsVolume**，并启用**缩放**工具，将其大小调整为覆盖您想要的级别部分——避免玩家角色的出生区域，因为您希望他们有一个安全的地方休息或必要时逃离。
- en: 'Hit the *P* key on your keyboard to show the newly created Navigation Mesh,
    which should look similar to the one depicted in *Figure 8**.1*:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下键盘上的*P*键以显示新创建的导航网格，它应该看起来类似于*图8**.1*中描述的：
- en: '![Figure 8.1 – The Navigation Mesh area](img/Figure_08_01_B18203.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 导航网格区域](img/Figure_08_01_B18203.jpg)'
- en: Figure 8.1 – The Navigation Mesh area
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 导航网格区域
- en: The green-colored area (i.e., the Navigation Mesh) represents the places where
    the AI character can walk. You will notice that walls and doors will create “holes”
    in this mesh, so the AI will be forbidden to step into it. Don’t worry about the
    portions outside of your dungeon – there are no open doors to connect them, so
    the minions won’t be able to reach them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色区域（即导航网格）表示AI角色可以行走的地方。您会注意到墙壁和门会在该网格中形成“洞”，因此AI将无法进入。不用担心您地牢外的部分——没有开放的门将它们连接起来，所以小兵无法到达那里。
- en: In this section, you were briefly introduced to the Unreal Engine Navigation
    System and you have set up a navigable area for the soon-to-be-created AI opponents.
    As I see you’re eager to start coding, let’s fire up your programming IDE and
    start writing some code together! It’s time to summon some undead minions and
    let them walk around the dungeon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您简要介绍了虚幻引擎导航系统，并为即将创建的AI对手设置了一个可导航的区域。鉴于您急切地想要开始编码，让我们启动您的编程IDE并一起编写一些代码！是时候召唤一些亡灵小兵，让他们在地牢中四处走动了。
- en: Creating an AI opponent
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建AI对手
- en: In this section, you’ll start by creating a class for your hero’s foes, complete
    with the basic ability to patrol and attack. Sure, they might not be the sharpest
    guys around, but hey, they’re the Lichlord’s undead minions – not exactly known
    for their intelligence, are they?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将开始为您的英雄的敌人创建一个类，包括基本的巡逻和攻击能力。当然，他们可能不是最聪明的人，但嘿，他们是巫妖王的亡灵小兵——并不以他们的智慧著称，对吧？
- en: We’ll be starting by extending the Character class, which, as you may already
    know, can be controlled by an `AIController`, allowing independent actions during
    gameplay.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先扩展Character类，如您可能已经知道的，它可以由`AIController`控制，允许在游戏过程中进行独立操作。
- en: 'At this point, we want the minion to have the following features:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们希望小兵具有以下功能：
- en: A random patrolling movement around the level
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该层周围进行随机巡逻移动
- en: A perception system that will allow it to see and hear the player’s character
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个感知系统，将允许它看到和听到玩家的角色
- en: The ability to seek out the player once it has been detected
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦检测到玩家，就有能力去寻找它
- en: In the next chapters, we’ll extend the Character class further by adding some
    more features such as health and spawnable goodies (when the AI has been defeated)
    but for now, we’ll just focus on the movement and perception system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过添加更多功能（如健康和可召唤的物品，当 AI 被击败时）来进一步扩展 Character 类，但到目前为止，我们只会关注移动和感知系统。
- en: Adding the navigation module
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加导航模块
- en: The first thing to do in order to have an agent that can navigate through a
    Navigation Mesh is to add the corresponding module to your project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让代理能够通过导航网格导航，首先的事情是向你的项目中添加相应的模块。
- en: 'To do this, get back to your programming IDE and open your project build file
    – the one named `UnrealShadows_LOTL.Build.cs` (or similar, if you opted for a
    different project name). Locate the following line of code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，回到你的编程 IDE 并打开你的项目构建文件——名为 `UnrealShadows_LOTL.Build.cs` 的文件（或者如果你选择了不同的项目名称，则类似）。找到以下代码行：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Change it by adding the `NavigationSystem` declaration, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `NavigationSystem` 声明来更改它，如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the project settings updated, we can start working on the minion AI, by
    creating a dedicated class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更新了项目设置后，我们可以开始着手处理 minion AI，通过创建一个专门的类。
- en: Creating the minion class
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 minion 类
- en: 'It’s time to create the AI minion class, so create a new class derived from
    `Character` and name it `US_Minion`. Once the class has been created, open the
    `US_Minion.h` header file and, in the `private` section, add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建 AI minion 类了，因此创建一个从 `Character` 派生的新的类，并将其命名为 `US_Minion`。一旦类创建完成，打开
    `US_Minion.h` 头文件，在 `private` 部分，添加以下代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Collision` property will be used as a trigger for the AI to grab the character,
    while `PatrolLocation` will be used to tell the AI where to go if not chasing
    the character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collision` 属性将用作 AI 抓取角色的触发器，而 `PatrolLocation` 将用于告诉 AI 如果没有追捕角色，它应该去哪里。'
- en: The `PawnSense` property is the declaration for `PawnSensingComponent`, a component
    that can be used by the AI character to see and hear pawns around the level (i.e.,
    the player characters). This component is quite straightforward to use and is
    easily configurable, letting you make the opponent more or less “dumb” during
    gameplay. You’ll get mere info on this in a minute or two when you’ll be initializing
    it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`PawnSense` 属性是 `PawnSensingComponent` 的声明，这是一个 AI 角色可以用来观察和听到关卡周围棋子的组件（即玩家角色）。这个组件使用起来相当简单，并且易于配置，让你在游戏过程中可以调整对手的“愚蠢”程度。你将在初始化它的一两分钟后得到关于它的更多信息。'
- en: 'Now it’s time to add some properties to the `public` section. Just add the
    following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在 `public` 部分添加一些属性了。只需添加以下代码：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have defined two movement speed properties: `PatrolSpeed` will be used when
    the minion is walking around aimlessly, while `ChaseSpeed` will be used whenever
    the minion is seeking the character, in order to make it a new pawn for the Lichlord’s
    army! The `PatrolRadius` property will be used to find a new location in the level
    for the minion to inspect.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个移动速度属性：`PatrolSpeed` 将在 minion 无目的地四处走动时使用，而 `ChaseSpeed` 将在 minion 寻找角色时使用，以便让它成为
    Lichlord 军队的新棋子！`PatrolRadius` 属性将用于在关卡中为 minion 找到新的检查位置。
- en: 'After the properties, you will be declaring the public methods needed for the
    correct behavior of the AI opponent. Still in the `public` section, add this block
    of code to declare them:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性之后，你将声明 AI 对手正确行为所需的公共方法。仍然在 `public` 部分，添加以下代码块来声明它们：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `SetNextPatrolLocation()` and `Chase()` methods will be used to let the
    AI character move around the scene, looking for a new spot or seeking the player
    character. The `PostInitializeComponent()` override will be used to register the
    character events. Lastly, we are declaring the usual getters for the character
    components that have been added.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetNextPatrolLocation()` 和 `Chase()` 方法将被用来让 AI 角色在场景中移动，寻找新的位置或寻找玩家角色。`PostInitializeComponent()`
    覆盖将用于注册角色事件。最后，我们声明了已添加的字符组件的常用获取器。'
- en: 'The last step in the header declaration is to add the event handlers for this
    character:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件声明中的最后一步是添加此角色的事件处理器：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first one will manage the minion logic once it has detected a pawn with
    its senses, while the second one will be used to check whether a player character
    has been captured.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将管理 minion 逻辑，一旦它通过感官检测到棋子，而第二个将用于检查是否有玩家角色被捕获。
- en: The header has finally been declared – please note that, at the moment, we are
    not taking into consideration the hearing capabilities of the minion; this is
    something we are going to implement in the next chapter when our thief hero starts
    to make some noise!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标头已经声明完毕——请注意，目前我们并没有考虑小兵的听觉能力；这是我们将在下一章中实现的内容，当我们的盗贼英雄开始制造一些噪音时！
- en: Implementing the minions’ behaviors
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现小兵的行为
- en: You’ve declared all your functions and properties, so now it’s time to put them
    to good use by implementing some behaviors for your AI minions. Let’s make sure
    everything is running smoothly and get this project rolling!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经声明了所有你的函数和属性，现在是时候通过实现一些AI小兵的行为来充分利用它们了。让我们确保一切运行顺利，并让这个项目启动起来！
- en: 'Open the `US_Minion.cpp` file and add the following `include` statements at
    the top:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`US_Minion.cpp`文件，并在顶部添加以下`include`语句：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As usual, these lines of code will declare the classes we will use from now
    on. After you have done that, it’s time to implement the constructor by adding
    the needed components and initializing all the properties.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '如同往常，这些代码行将声明我们将从现在开始使用的类。在你完成这些之后，现在是时候实现构造函数了，通过添加所需组件并初始化所有属性。 '
- en: Declaring the constructor
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明构造函数
- en: 'Once the `include` statements have been properly declared, you can start by
    locating the `AUS_Minion()` constructor and inserting the character initialization.
    Inside the brackets, just after the `PrimaryActorTick.bCanEverTick` declaration,
    add the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`include`语句被正确声明，你可以开始定位`AUS_Minion()`构造函数，并插入角色初始化代码。在括号内，紧接在`PrimaryActorTick.bCanEverTick`声明之后，添加以下代码：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll already be familiar with most of the code from the thief character creation,
    but you will see some noticeable additions. First of all, we are setting the `AutoPossessAI`
    property, which lets us define whether the game system will possess the AI character
    once in the level – we want it to be both in full control when it is spawned at
    runtime and when it is already in the level when the game starts, so we have opted
    for a value of `PlacedInWorldOrSpawned`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将熟悉从盗贼角色创建中大部分的代码，但你将看到一些明显的添加。首先，我们正在设置`AutoPossessAI`属性，这让我们可以定义游戏系统是否会在关卡中占用AI角色一次——我们希望它在运行时生成时以及当游戏开始时已经在关卡中时都能完全控制，所以我们选择了`PlacedInWorldOrSpawned`的值。
- en: Then, we define which controller will be used for the AI system by setting the
    `AIControllerClass` property; in this case, we are just using the base `AAIController`
    class, but you can obviously implement your own with additional features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过设置`AIControllerClass`属性来定义将用于AI系统的控制器；在这种情况下，我们只是使用基础的`AAIController`类，但你显然可以添加更多功能来自定义实现。
- en: The last notable thing is the `PawnSense` component creation – as you can see,
    we are initializing the properties that will make the minion see and hear at a
    certain distance. You should take note of the `SensingInterval` initialization,
    which will let us tweak how much time will pass between two sense perceptions.
    This will make the difference between a very reactive character (i.e., a lower
    value) or a really dumb one (i.e., a higher one).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值得注意的是`PawnSense`组件的创建——正如你所见，我们正在初始化将使小兵在一定距离内看到和听到的属性。你应该注意`SensingInterval`的初始化，这将让我们调整两次感知之间经过的时间。这将决定一个非常反应灵敏的角色（即，较低的值）或一个非常愚蠢的角色（即，较高的值）。
- en: Initializing the minion
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化小兵
- en: 'It’s now time to initialize the character when it is added to the game. As
    you already know, this is usually done from the `BeginPlay()` method. So, just
    after the `Super::BeginPlay()` declaration, add the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在角色被添加到游戏中时初始化角色了。正如你所知，这通常是通过`BeginPlay()`方法完成的。所以，在`Super::BeginPlay()`声明之后，添加以下内容：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This call will simply start the patrolling behavior. Then, add the `PostInitializeComponents()`
    implementation by adding this code to the file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将简单地启动巡逻行为。然后，通过向文件中添加以下代码来实现`PostInitializeComponents()`：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we are using two delegates to react to an Actor overlap, for
    checking whether we have reached the player character, and to handle the pawn
    perception to check whether we can see the player character. Also, notice that
    they are initialized only if the role of this object is authoritative (i.e., the
    method is being executed on the server).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用两个委托来响应Actor重叠，用于检查我们是否到达了玩家角色，以及处理Pawn感知以检查我们是否可以看到玩家角色。注意，它们仅在对象的角色为权威角色（即，该方法是在服务器上执行的）时才初始化。
- en: The next step is to implement these two delegate functions in order to manage
    the aforementioned events.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现这两个代理函数，以管理上述事件。
- en: Handling the delegate functions
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理代理函数
- en: 'Whenever the minion detects a pawn, it will immediately check whether it is
    a character and, if the result is successful, it will start chasing it. Let’s
    add the method to handle the delegate in the source file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 无论小兵检测到棋子，它都会立即检查它是否是一个角色，如果结果是成功的，它就会开始追逐它。让我们在源文件中添加处理代理的方法：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code here is quite straightforward – we just have added a debug message
    stating that a character has been detected.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码相当简单——我们只是添加了一条调试信息，表明检测到了一个角色。
- en: 'The second delegate we need to handle is the overlap, so add the following
    method implementation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理的第二个代理是重叠，因此添加以下方法实现：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we check again whether we have found a character, and after
    that, we simply display a debug message – it looks like our hero got a little
    too close to the minions and now they’ve roped them into joining the Lichlord’s
    undead army! Later on, you’ll implement a respawn system to let the player restart
    the game with a brand-new character.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们再次检查是否找到了一个角色，然后简单地显示一个调试信息——看起来我们的英雄离小兵太近了，现在他们已经被套上了绳索，加入了巫妖王的亡灵军队！稍后，您将实现一个重生系统，让玩家能够用全新的角色重新开始游戏。
- en: The next step will be the actual AI’s movement through the Navigation Mesh,
    both for the patrol and chase behaviors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是AI在导航网格中的实际移动，包括巡逻和追逐行为。
- en: Implementing the chase and patrol behaviors
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现追逐和巡逻行为
- en: 'It’s now time to start implementing the movement control for your AI character
    – specifically, you’ll be implementing the `SetNextPatrolLocation()` function,
    which will find a new reachable point for the minion, and the `Chase()` function,
    which will send the minion on a “seek and destroy” mission toward the character.
    To do so, add the following code to the file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始实现你的AI角色的运动控制了——具体来说，你将实现`SetNextPatrolLocation()`函数，该函数将为小兵找到一个新的可到达点，以及`Chase()`函数，该函数将小兵派往一个“寻找并摧毁”任务，目标是角色。为此，请将以下代码添加到文件中：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first function sets the character speed to the patrolling value and uses
    the `UNavigationSystemV1::K2_GetRandomReachablePointInRadius()` method to find
    a reachable point in the Navigation Mesh. Then, the AI is simply commanded to
    reach that location.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将角色速度设置为巡逻值，并使用`UNavigationSystemV1::K2_GetRandomReachablePointInRadius()`方法在导航网格中找到一个可到达的点。然后，AI被简单地命令到达那个位置。
- en: The second function does something similar, but the target point will be the
    character – after all, it is on a mission from the Lichlord to get as many soon-to-be
    undead heroes as possible!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数做类似的事情，但目标点将是角色——毕竟，它肩负着从巫妖王那里获取尽可能多的即将成为亡灵的英雄的任务！
- en: Implementing the Tick() event
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Tick()事件
- en: 'The last thing you need to implement in order to make the patrolling system
    fully operational is to check whether the AI character has reached its destination;
    in this case, it will just have to find another point in the Navigation Mesh.
    As we need to continuously check the distance between the AI and the target point,
    the best place to write the code is within the `Tick()` event. Let’s find the
    method and, just after the `Super::Tick(DeltaTime)` call, add this piece of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使巡逻系统完全运行，你需要实现最后一件事情，即检查AI角色是否已到达目的地；在这种情况下，它只需在导航网格中找到另一个点。由于我们需要持续检查AI和目标点之间的距离，编写代码的最佳位置是在`Tick()`事件中。让我们找到这个方法，并在`Super::Tick(DeltaTime)`调用之后，添加以下代码：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the first line checks whether the character is patrolling (i.e.,
    the maximum speed should not equal the chase speed). Then, we are checking that
    we are near enough (about half a meter) to the patrol location in order to look
    for another reachable point.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第一行检查角色是否在巡逻（即最大速度不应等于追逐速度）。然后，我们检查我们是否足够接近巡逻位置（大约半米），以便寻找另一个可到达的点。
- en: Testing the AI opponent
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试AI对手
- en: 'Now that the enemy AI has been created, you can test it out in the game level.
    To do this, open the Unreal Engine Editor and, from the Content Browser, drag
    an instance of the `US_Minion` class (located in the `C++ Classes` | `UnrealShadows_LOTL`
    folder) into the level. You should see something similar to *Figure 8**.2*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人AI已经创建，你可以在游戏级别中测试它。为此，打开Unreal Engine编辑器，从内容浏览器中拖动`US_Minion`类的一个实例（位于`C++
    Classes` | `UnrealShadows_LOTL`文件夹）到级别中。你应该看到类似于*图8**.2*的类似内容：
- en: '![Figure 8.2 – The AI opponent in the level](img/Figure_08_02_B18203.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 级别中的AI对手](img/Figure_08_02_B18203.jpg)'
- en: Figure 8.2 – The AI opponent in the level
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 级别中的AI对手
- en: The gizmos around the character represent the `PawnSense` component – its sight
    and hearing capabilities. The sight area is represented by a green cone that shows
    how wide and far the AI can see. The hearing sense is represented by two spheres
    – a yellow one that shows how far the AI will hear a noise if it is not obstructed
    by any obstacle, and a cyan one that shows how far the AI will sense noise, even
    if generated behind an obstacle, such as a wall.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕角色的工具代表`PawnSense`组件——它的视线和听觉能力。视线区域由一个绿色圆锥体表示，显示了AI可以看到的宽度和距离。听觉感知由两个球体表示——一个黄色的球体表示如果没有障碍物阻挡，AI可以听到多远的声音，一个青色的球体表示即使声音在障碍物后面生成，AI也能感知多远的声音，例如墙壁。
- en: Go into play mode and the opponent should start wandering around the level and
    over the Navigation Mesh. Whenever a player character enters the minion’s line
    of sight (i.e., the green cone), the enemy will react and start chasing the player
    at a higher speed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 进入游戏模式，对手应该开始在级别和导航网格中四处游荡。每当玩家角色进入小兵的视线范围内（即，绿色圆锥体），敌人就会做出反应，并以更高的速度开始追逐玩家。
- en: Once the character has been reached, you will notice that the minion will stop
    moving – its mission has been completed and it can rest!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦角色到达，你会注意到小兵会停止移动——它的任务已经完成，它可以休息了！
- en: As an extra exercise, you may want to add a timer that will check whether the
    AI is staying still for too long; in that case, it will restart its patrolling
    system by looking for a new reachable location.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可能想要添加一个计时器来检查AI是否停留得太久；如果是这样，它将通过寻找一个新的可到达位置来重新启动其巡逻系统。
- en: So, in this section, you have created your AI opponent, ready to roam around
    the dungeon, seeking its next victim. You have created a simple but effective
    patrolling system and added a perception sense to the AI so that it can intercept
    the player when they are not stealthy enough.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，你已经创建了你的AI对手，准备好在地下城中四处游荡，寻找下一个受害者。你已经创建了一个简单但有效的巡逻系统，并为AI添加了感知能力，以便在玩家不够隐秘时拦截他们。
- en: In the next section, you’ll create a spawning system in order to add minions
    as the game progresses and make things more challenging for the players.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建一个生成系统，以便在游戏进行过程中添加小兵，并为玩家制造更多的挑战。
- en: Adding opponents to the level
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向级别添加对手
- en: Now that you have an opponent for your thief hero, it is time to let the system
    spawn a bunch of them at runtime. You’ll be doing this by implementing a spawn
    system similar to the one used in [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065),
    *Testing the Multiplayer System with a Project Prototype* – this time, you’ll
    create the spawner in C++ instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为你的盗贼英雄找到了对手，是时候让系统在运行时生成一大群它们了。你将通过实现与[*第3章*](B18203_03.xhtml#_idTextAnchor065)中使用的类似生成系统——这次，你将在C++中创建生成器。
- en: 'What we want to implement here is an Actor that will have the following features:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里想要实现的是一个具有以下功能的Actor：
- en: Spawns a few minions at the start of the game.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏开始时生成几个小兵。
- en: Spawns new minions at predefined intervals.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预定义的间隔生成新的小兵。
- en: Spawns the minions in a selected area.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选定的区域内生成小兵。
- en: Randomly selects a minion type every time it spawns. At the moment, we have
    just one minion type, but in the following chapters, we will add more variations.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次生成时随机选择一个小兵类型。目前我们只有一个小兵类型，但在接下来的章节中，我们将添加更多变体。
- en: Let’s get started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Creating a spawner class
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个生成器类
- en: 'Start by creating a C++ class that extends from Actor and name it `US_MinionSpawner`.
    Once created, open the `.h` file and, in the `private` section, add the following
    declarations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个从Actor扩展的C++类，命名为`US_MinionSpawner`。创建后，打开`.h`文件，在`private`部分添加以下声明：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should be already familiar with the first declaration from [*Chapter 3*](B18203_03.xhtml#_idTextAnchor065),
    *Testing the Multiplayer System with a Project Prototype* – we are declaring an
    area that will be used to randomize the spawned minion location. The second declaration
    will be used to store a reference of the timer handler used by the spawner to
    generate new minions at predefined intervals.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉了来自 [*第3章*](B18203_03.xhtml#_idTextAnchor065) 的第一个声明，*使用项目原型测试多人游戏系统*
    – 我们正在声明一个将用于随机生成随从位置的区域。第二个声明将用于存储生成器使用的计时器处理程序引用，以在预定间隔生成新的随从。
- en: 'Now we are going to declare some properties that will make this class customizable
    in the level. In the `public` section, add the following property declarations:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将声明一些属性，使这个类在关卡中可定制。在 `public` 部分添加以下属性声明：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first property will expose an array that will contain all the spawnable
    minion types. As stated before, at the moment, we have just one type, but we will
    add some more later on. The other two properties are self-explanatory, letting
    us define the spawn timing and how many minions should already be in the level
    when the game starts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性将公开一个包含所有可生成随从类型的数组。如前所述，目前我们只有一个类型，但稍后我们会添加更多。其他两个属性是自解释的，让我们能够定义生成时间和游戏开始时应该在关卡中存在的随从数量。
- en: 'The last step is to add a `Spawn()` method in the protected section of the
    header:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在头文件的保护部分添加一个 `Spawn()` 方法：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The header is now finished. Now, let’s switch to the `.cpp` and implement some
    code logic.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头文件已经完成。现在，让我们切换到 `.cpp` 文件并实现一些代码逻辑。
- en: Implementing the spawner logic
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实现生成器逻辑
- en: 'It’s time to implement the spawner features. To do so, open the `.cpp` file,
    find the constructor, and add the required includes at the top of the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现生成器的功能了。为了做到这一点，打开 `.cpp` 文件，找到构造函数，并在文件顶部添加所需的包含项：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, add the following piece of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码片段：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You are already well versed in creating components, so let’s dive right into
    the `BeginPlay()` method and add this code just after the `Super::BeginPlay()`
    declaration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经非常熟悉创建组件，所以让我们直接进入 `BeginPlay()` 方法，并在 `Super::BeginPlay()` 声明之后添加这段代码：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First of all, we are checking that there is at least one spawnable minion type
    – if the array is empty, there is no need to go on with the code. Then, we check
    that the Actor has the authority to spawn something; as usual, we want the server
    to be in full control of what’s happening.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查至少有一个可生成的随从类型 – 如果数组为空，就没有必要继续执行代码。然后，我们检查角色是否有生成东西的权限；像往常一样，我们希望服务器完全控制正在发生的事情。
- en: After that, we call the `Spawn()` function in a loop, in order to create a starting
    pool of enemies. The last step is to create a timer, which will call the `Spawn()`
    function at an interval defined by the `SpawnDelay` value.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过循环调用 `Spawn()` 函数，以创建一个敌人的起始池。最后一步是创建一个计时器，该计时器将在 `SpawnDelay` 值定义的间隔内调用
    `Spawn()` 函数。
- en: 'The last thing to do to have the spawner fully functional is to add the `Spawn()`
    function implementation. Let’s add it at the end of the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使生成器完全功能，最后一步是添加 `Spawn()` 函数的实现。让我们把它添加到文件的末尾：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As long as it may seem, this code is quite straightforward, and you have already
    done something similar at the start of this book (do you remember the falling
    fruits?). We are just taking a random minion type from the array, retrieving a
    random location in the spawn area, and then we are going to spawn the minion at
    that location. The only thing worth mentioning is `SpawnCollisionHandlingOverride`,
    which is set to spawn the Actor, avoiding any collision with other objects in
    the level.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来可能很复杂，但这段代码相当简单，你在这本书的开头已经做过类似的事情（还记得掉落的水果吗？）。我们只是从数组中随机选择一个随从类型，检索生成区域中的随机位置，然后在该位置生成随从。唯一值得提的是
    `SpawnCollisionHandlingOverride`，它被设置为生成角色，避免与关卡中的其他对象发生碰撞。
- en: As an extra exercise, you may add a limit to the number of minions that will
    be spawned from a single spawner object. This will avoid overcrowding your level
    and making the game unplayable for your players!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，你可以在单个生成器对象生成的随从数量上设置一个限制。这将避免你的关卡过于拥挤，让你的玩家无法玩游戏！
- en: The spawn Actor is ready, so it is time to compile your project and do some
    proper testing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器角色已经准备好了，所以现在是时候编译你的项目并进行一些适当的测试。
- en: Testing the spawner
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试生成器
- en: It is now time to venture into the glories of the Unreal Engine Editor and summon
    those mischievous minions to frolic throughout the level! Locate the `US_MinionSpawner`
    class (found inside the `C++ Classes` | `UnrealShadows_LOTL` folder) and drag
    it into your level to create an instance of it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索虚幻引擎编辑器的辉煌，召唤那些顽皮的亡灵小兵，让它们在整个关卡中嬉戏！找到`US_MinionSpawner`类（位于`C++ Classes`
    | `UnrealShadows_LOTL`文件夹中），并将其拖入您的关卡以创建其实例。
- en: 'Next, position the Actor in a suitable place and resize the **Box Extent**
    parameters to set a nice size for the minions to be located within. In my case,
    I opted to place the spawner in the room labeled **SP3** with the **Box Extent**
    property set to **(900, 400, 100)**, as you can see in *Figure 8**.3*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将演员放置在合适的位置，并调整**盒尺寸**参数以设置小兵所在的好位置。在我的情况下，我选择将生成器放置在标记为**SP3**的房间中，**盒尺寸**属性设置为**（900，400，100）**，正如您在*图8.3*中看到的那样：
- en: '![Figure 8.3 – The spawn area](img/Figure_08_03_B18203.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 出生区域](img/Figure_08_03_B18203.jpg)'
- en: Figure 8.3 – The spawn area
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 出生区域
- en: 'Then, with the Actor still selected, do the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在演员仍然被选中时，执行以下操作：
- en: Locate the **Spawn System** category in the **Details** panel.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中找到**出生系统**类别。
- en: Add an element to the **Spawnable Minions** array, which will be labeled as
    **Index[0]**. From the corresponding drop-down menu, select **US_Minion**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向**可生成小兵**数组添加一个元素，将其标记为**Index[0]**。从相应的下拉菜单中选择**US_Minion**。
- en: 'Tweak **Spawn Delay** and **Num Minions at Start** to suit your needs; in my
    case, I have left the default values, as you can see in *Figure 8**.4*:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整**出生延迟**和**起始最小兵数量**以满足您的需求；在我的情况下，我保留了默认值，正如您在*图8.4*中看到的那样：
- en: '![Figure 8.4 – The spawn settings](img/Figure_08_04_B18203.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 出生设置](img/Figure_08_04_B18203.jpg)'
- en: Figure 8.4 – The spawn settings
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 出生设置
- en: You obviously have the freedom to add as many spawner Actors as you feel necessary
    to balance your game level.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您显然有自由添加尽可能多的生成器演员，以平衡您的游戏级别。
- en: Once you enter the realm of play mode, lo and behold, the undead minions shall
    materialize before your very eyes, their replication and synchronization across
    all clients being a testament to the mystical powers of the Lichlord! Well, actually,
    it’s a testament to the power of the Unreal Engine replication system, but you
    don’t want to let your players in on the secret. Keep them in the dark and let
    them marvel at the seamless magic of your game’s performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入游戏模式，请注意，亡灵小兵将出现在您的眼前，它们在所有客户端上的复制和同步是对Lichlord神秘力量的证明！实际上，这是对虚幻引擎复制系统力量的证明，但您不希望让您的玩家知道这个秘密。让他们保持黑暗，让他们惊叹于您游戏性能的无缝魔法。
- en: '*Figure 8**.5* displays how the spawner looks in action whenever you test it,
    but more simply and less poetically:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.5*显示了您测试生成器时的外观，但更简单、更不诗意：'
- en: '![Figure 8.5 – The spawner in action](img/Figure_08_05_B18203.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 生成器在行动中](img/Figure_08_05_B18203.jpg)'
- en: Figure 8.5 – The spawner in action
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 生成器在行动中
- en: In this section, you created a fully customizable spawn system that can be used
    and tweaked for any level in your game. It’s time to wrap things up and move on
    to the next chapter of this adventure-packed multiplayer game.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您创建了一个完全可定制的出生系统，该系统可用于并调整您游戏中任何级别的游戏。现在是时候总结一下，继续这个充满冒险的多人游戏的新篇章了。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to the basics of AI in a multiplayer game.
    First of all, you were given some information on how to create a Navigation System
    that will let your AI move independently around the level. After that, you created
    a base minion, which will patrol around seeking the player characters, changing
    its behavior to a more aggressive stance once it finds them. As a last step, you
    added spawn points around the dungeon in order to populate the area with worthy
    opponents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了多人游戏中AI的基础。首先，您获得了一些关于如何创建导航系统以使AI能够在关卡中独立移动的信息。之后，您创建了一个基础小兵，它将在关卡中巡逻寻找玩家角色，一旦找到它们，就会将其行为改为更具侵略性的姿态。最后一步，您在地下城周围添加了出生点，以便用有价值的对手填充区域。
- en: The most important thing to take away from this chapter is that, with your previously
    acquired knowledge, everything is correctly synchronized over the network. I promised
    you that learning things from the start would be a huge advantage in the future!
    And trust me, putting in the effort and really grasping the basics is now paying
    off with your project!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中最重要的收获是，凭借你之前获得的知识，所有内容在网络中都是正确同步的。我承诺过，从一开始学习将会在未来带来巨大的优势！而且请相信我，投入努力并真正掌握基础知识，现在正通过你的项目得到回报！
- en: In the next chapter, we’ll keep on exploring some of the possibilities of implementing
    worthy opponents for your hero – we will give it a sense of hearing and a health
    system in order to make it more engaging and, at the very least, defeatable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索为你的英雄实现有价值的对手的一些可能性——我们将给它赋予听觉和健康系统，以便使其更具吸引力，至少是可击败的。
