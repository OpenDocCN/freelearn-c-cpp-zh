- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Hierarchies with Single Inheritance
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单继承实现层次结构
- en: This chapter will extend our pursuit of object-oriented programming in C++.
    We will begin by introducing additional OO concepts, such as **generalization**
    and s**pecialization**, and then understand how these concepts are implemented
    in C++ through *direct language support*. We will begin building hierarchies of
    related classes, and understand how each class can become an easier to maintain,
    potentially reusable building block in our applications. We will understand how
    the new OO concepts presented in this chapter will support well-planned designs,
    and we will have a clear understanding of how to implement these designs with
    robust code in C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将扩展我们在C++中追求面向对象编程的旅程。我们将从介绍额外的OO概念开始，例如**泛化**和**特化**，然后理解这些概念是如何通过*直接语言支持*在C++中实现的。我们将开始构建相关类的层次结构，并理解每个类如何成为我们应用程序中更容易维护、可能可重用的构建块。我们将理解本章中提出的新OO概念将如何支持精心设计的计划，并且我们将清楚地理解如何使用健壮的C++代码实现这些设计。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Object-oriented concepts of generalization and specialization, and *Is-A* relationships
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛化和特化的面向对象概念，以及*Is-A*关系
- en: Single inheritance basics – defining derived classes, accessing inherited members,
    understanding inherited access labels and regions, and `final` class specification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单继承基础 – 定义派生类，访问继承成员，理解继承访问标签和区域，以及`final`类指定
- en: Construction and destruction sequence in a single inheritance hierarchy; selecting
    base class constructors with the member initialization list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单继承层次结构中的构造和析构序列；使用成员初始化列表选择基类构造函数
- en: Modifying access labels in the base class list – `public` versus `privat`e and
    `protected` base classes – to change the OO purpose of inheritance to *Implementation
    Inheritance*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改基类列表中的访问标签 – `public`与`private`和`protected`基类 – 以改变继承的OO目的为*实现继承*
- en: By the end of this chapter, you will understand the object-oriented concepts
    of generalization and specialization and will know how to use inheritance in C++
    as a mechanism to realize these ideals. You will understand terms such as base
    and derived classes, as well as OO motivations for building hierarchies, such
    as supporting Is-A relationships or supporting implementation inheritance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解面向对象的概念，如泛化和特化，并了解如何将继承用于C++，作为一种实现这些理想的机制。你将了解诸如基类和派生类等术语，以及构建层次结构时的OO动机，例如支持“是...的”关系或支持实现继承。
- en: Specifically, you will understand how to grow inheritance hierarchies using
    single inheritance, and how to access inherited data members and member functions.
    You will also understand which inherited members you may directly access, based
    on their defined access regions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你将理解如何使用单继承来扩展继承层次结构，以及如何访问继承的数据成员和成员函数。你还将理解基于它们定义的访问区域，你可以直接访问哪些继承成员。
- en: You will understand the order of constructor and destructor invocations when
    instances of derived class types are instantiated and destroyed. You will know
    how to make use of the member initialization list to select which, from a potential
    group, of inherited constructors a derived class object may need to utilize as
    part of its own construction.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将理解在派生类类型的实例化和销毁时，构造函数和析构函数调用的顺序。你将知道如何利用成员初始化列表来选择派生类对象在其自身构造过程中可能需要利用的潜在继承构造函数组中的哪一个。
- en: You will also understand how changing access labels in a base class list changes
    the OO meaning for the type of inheritance hierarchy you are growing. By examining
    public versus private and protected base classes, you will understand different
    types of hierarchies, such as those built to support Is-A relationships versus
    those built to support implementation inheritance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将理解如何通过改变基类列表中的访问标签来改变你正在构建的继承层次结构的OO含义。通过比较公共、私有和受保护的基类，你将理解不同类型的层次结构，例如那些用于支持“是...的”关系与那些用于支持实现继承的层次结构。
- en: By understanding the direct language support of single inheritance in C++, you
    will be able to implement the OO concepts of generalization and specialization.
    Each class within your hierarchy will be a more easily maintained component and
    can serve as a potential building block for creating new, more specialized components.
    Let us further our understanding of C++ as an OOP language by detailing single
    inheritance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解C++中单继承的直接语言支持，你将能够实现泛化和特殊化的面向对象概念。你层次结构中的每个类都将是一个更容易维护的组件，并可以作为创建新的、更专业组件的潜在构建块。让我们通过详细说明单继承来进一步理解C++作为面向对象语言。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in this chapter can be found in the subdirectory `Chapter06`
    in a file named `Chp6-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter06)。每个完整程序示例都可以在GitHub上找到，位于相应章节标题（子目录）下的文件中，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，本章的第一个完整程序可以在上述GitHub目录下的`Chapter06`子目录中找到，文件名为`Chp6-Ex1.cpp`。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3R7uNci](https://bit.ly/3R7uNci).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可以在以下链接查看：[https://bit.ly/3R7uNci](https://bit.ly/3R7uNci)。
- en: Expanding object-oriented concepts and terminology
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展面向对象概念和术语
- en: In this section, we will introduce essential object-oriented concepts, as well
    as applicable terminology that will accompany these key ideas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍必要的面向对象概念，以及伴随这些关键思想的适用术语。
- en: From [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in
    Detail*, you now understand the key OO ideas of encapsulation and information
    hiding, and how C++ supports these ideals through the C++ class. Now, we will
    look at how we can grow a hierarchy of related classes, using a very general class
    as a building block, and then extend that class by creating a more specific class.
    Through growing a hierarchy of related classes in this repeated fashion, OO systems
    provide building blocks of potential reuse. Each class within the hierarchy is
    encapsulated, so maintenance and upgrades to a specific class can be made more
    easily and without impact to the entire system. By incrementally refining each
    class with a more specific and more detailed class to build a hierarchy of related
    classes, specific maintenance for each component is in a focused area for maintenance
    and changes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*，你现在已经理解了封装和信息隐藏的关键面向对象思想，以及C++如何通过类支持这些理念。现在，我们将探讨如何通过使用一个非常通用的类作为构建块，然后通过创建一个更具体的类来扩展该类，从而构建一个相关类的层次结构。通过以这种方式重复构建相关类的层次结构，面向对象系统提供了潜在的复用构建块。层次结构中的每个类都是封装的，因此对特定类的维护和升级可以更容易地进行，而不会影响整个系统。通过使用更具体和更详细的类逐步细化每个类，以构建相关类的层次结构，每个组件的特定维护集中在维护和变更的焦点区域。
- en: Let’s start by extending our basic OO terminology.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从扩展我们的基本面向对象术语开始。
- en: Deciphering generalization and specialization
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密泛化和特殊化
- en: The main object-oriented concepts extending through this chapter are *generalization*
    and *specialization*. Incorporating these principles into your design will provide
    the basis for writing more easily modifiable and maintainable code, and for code
    that can potentially be reused in related applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展的主要面向对象概念是*泛化*和*特殊化*。将这些原则纳入你的设计中，将为编写更易于修改和维护的代码，以及为可能在相关应用程序中复用的代码提供基础。
- en: '**Generalization** describes the process of abstracting commonalities from
    a grouping of classes and creating a more generalized class for that grouping
    to house the common properties and behaviors. The more generalized class can be
    known as a **base** (or **parent**) class. Generalization can also be used to
    collect more general properties and behaviors of a single class into a base class
    with the expectation that the new, generalized class can later serve as a building
    block or basis for additional, more specific (derived) classes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛化**描述了从一组类中抽象出共同性，并为该组创建一个更通用的类，以便容纳共同的属性和行为。这个更通用的类可以被称为**基类**（或**父类**）。泛化还可以用来将单个类的更通用属性和行为收集到一个基类中，期望这个新的、通用的类可以后来作为构建块或基础，用于创建更多、更具体的（派生）类。'
- en: '**Specialization** describes the process of deriving a new class from an existing,
    generalized base class, for the purpose of adding specific, distinguishable properties
    and behaviors to adequately represent the new class. The specialized class can
    also be referred to as a **derived** (or **child**) class. A hierarchy of classes
    can incrementally refine their respective properties and behaviors through specialization.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**特殊化**描述了从现有的通用基类派生出一个新类的过程，目的是为了添加特定的、可区分的属性和行为，以便充分表示新类。这个特殊化的类也可以被称为**派生类**（或**子类**）。通过特殊化，类层次结构可以逐步细化各自的属性和行为。'
- en: Though reuse is difficult to achieve, the OOP concepts such as generalization
    and specialization make reuse more easily obtainable. Reuse can potentially be
    realized in applications that are similar in nature or in the same project domain,
    in continuations of existing projects, or potentially in related domains where
    minimally the most generalized classes and associated components can be reused.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重用很难实现，但泛化和特殊化等面向对象的概念使得重用更容易获得。重用可以在性质相似的应用程序中、在同一项目领域中、在现有项目的延续中，或者在相关领域中实现，在这些领域中至少最通用的类和相关组件可以被重用。
- en: Building a hierarchy is a fundamental language feature of C++. Let’s move forward
    by exploring single inheritance to put this idea into action.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 构建层次结构是C++语言的一个基本特性。让我们通过探索单继承来将这个想法付诸实践。
- en: Understanding single inheritance basics
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单继承基础
- en: '**Inheritance** is the C++ language mechanism that allows the concepts of generalization
    and specialization to be realized. **Single inheritance** is when a given class
    has exactly one immediate base class. Both single inheritance and multiple inheritance
    are supported in C++; however, we will focus on single inheritance in this chapter
    and will cover multiple inheritance in a later chapter.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**是C++语言机制，它允许实现泛化和特殊化的概念。**单继承**是指一个给定的类恰好有一个直接基类。C++支持单继承和多继承；然而，在本章中，我们将专注于单继承，并在后面的章节中介绍多继承。'
- en: Inheritance hierarchies can be built using both classes and structures in C++.
    Classes, however, are most often utilized rather than structures to support inheritance
    and OOP.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，可以使用类和结构来构建继承层次结构。然而，类通常比结构更常用于支持继承和面向对象。
- en: Growing an inheritance hierarchy for the purpose of generalization and specialization
    supports an `Person` and a derived class of `Student`, we can say *a Student Is-A
    Person*. That is, a `Student` is a specialization of a `Person`, adding additional
    data members and member functions above and beyond those provided by its base
    class, `Person`. Specifying an Is-A relationship through generalization and specialization
    is the most typical reason inheritance is used to create base and derived classes.
    Later in this chapter, we will look at another reason to utilize inheritance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通用化和特殊化而构建的继承层次结构支持一个`Person`类和一个派生类`Student`，我们可以说*一个学生是一个人*。也就是说，`Student`是`Person`的一个特殊化，它在其基类`Person`提供的数据成员和成员函数之上添加了额外的数据成员和成员函数。通过泛化和特殊化指定Is-A关系是使用继承创建基类和派生类最典型的原因。在本章的后面，我们将探讨利用继承的另一个原因。
- en: Let’s get started by looking at the language mechanics in C++ to specify base
    and derived classes and to define an inheritance hierarchy.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看C++语言机制开始，以指定基类和派生类并定义继承层次结构。
- en: Defining base and derived classes and accessing inherited members
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义基类和派生类以及访问继承成员
- en: With single inheritance, the derived class specifies who its immediate ancestor
    or base class is. The base class does not specify that it has any derived classes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在单继承中，派生类指定其直接祖先或基类是谁。基类不指定它有任何派生类。
- en: The derived class simply creates a base class list by adding a `:` after its
    class name, followed by the keyword `public` (for now), and then the specific
    base class name. Whenever you see a `public` keyword in the base class list, it
    means that we are using inheritance to specify an Is-A relationship.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类只需在其类名后添加一个`:`，然后跟上一个关键字`public`（目前是这样），最后是具体的基类名称。每当你在基类列表中看到`public`关键字时，这意味着我们正在使用继承来指定一个“是”关系。
- en: 'Here is a simple example to illustrate the basic syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子来说明基本的语法：
- en: '`Student` *Is-A* derived class of `Person`:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Student`是`Person`的派生类：'
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the base class is `Person`, and the derived class is `Student`. The derived
    class need only define additional data members and member functions that augment
    those specified in the base class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，基类是`Person`，派生类是`Student`。派生类只需定义额外的数据成员和成员函数，以增强基类中指定的那些。
- en: Instances of a derived class may generally access `public` members specified
    by the derived class or by any ancestor of the derived class. Inherited members
    are accessed in the same fashion as those specified by the derived class. Recall,
    dot notation (`.`) is used to access members of objects, and arrow notation (`->`)
    is used to access members of pointers to objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类的实例通常可以访问由派生类或派生类的任何祖先指定的`public`成员。继承成员的访问方式与派生类指定的方式相同。回想一下，点符号（`.`）用于访问对象的成员，箭头符号（`->`）用于访问指向对象的指针的成员。
- en: Of course, to make this example complete, we will need to add the applicable
    constructors, which we currently assume exist. Naturally, there will be nuances
    with constructors relating to inheritance, which we will soon cover in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使这个例子完整，我们需要添加适用的构造函数，我们目前假设它们存在。自然地，与构造函数相关的细微差别，我们将在本章的后续内容中讨论。
- en: 'Simple access of inherited members can be seen using the aforementioned classes
    as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上述类，我们可以看到对继承成员的简单访问如下：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code fragment, the derived class instance of `Student`, pointed
    to by `s1`, can access both base and derived class members, such as `Person::GetTitle()`
    and `Student::GetGpa()`. The base class instance of `Person`, `p1`, can only access
    its own members, such as `Person::GetTitle()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，由`s1`指向的`Student`派生类实例可以访问基类和派生类成员，例如`Person::GetTitle()`和`Student::GetGpa()`。`Person`基类实例`p1`只能访问其自身的成员，例如`Person::GetTitle()`。
- en: 'Looking at a memory model for the preceding example, we have the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前一个示例的记忆模型，我们有以下内容：
- en: '![Figure 6.1 – Memory model for current example](img/Figure_6.01_B19087.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 当前示例的内存模型](img/Figure_6.01_B19087.jpg)'
- en: Figure 6.1 – Memory model for current example
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 当前示例的内存模型
- en: Notice that in the preceding memory model, a `Student` instance is comprised
    of a `Person` subobject. That is, at the memory address indicating the beginning
    of `*s1`, a `Student`, we first see the memory layout of its `Person` data members.
    Then, we see the memory layout of its additional `Student` data members. Of course,
    `p1`, which is a `Person`, only contains `Person` data members.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的内存模型中，`Student`实例由一个`Person`子对象组成。也就是说，在指示`*s1`开始的内存地址处，我们首先看到其`Person`数据成员的内存布局。然后，我们看到其额外的`Student`数据成员的内存布局。当然，`p1`，它是一个`Person`，只包含`Person`数据成员。
- en: Access to base and derived class members will be subject to the access regions
    specified by each class. Let’s take a look to see how inherited access regions
    work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对基类和派生类成员的访问将受每个类指定的访问区域所约束。让我们看看继承的访问区域是如何工作的。
- en: Examining inherited access regions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查继承的访问区域
- en: Access regions, including inherited access regions, define from which scope
    members, including inherited members, are directly accessible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 访问区域，包括继承的访问区域，定义了成员（包括继承成员）可以直接访问的范围。
- en: The derived class inherits all members specified in its base class. However,
    direct access to those members is subject to the access regions specified in the
    base class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类继承了其基类中指定的所有成员。然而，对这些成员的直接访问受基类中指定的访问区域所约束。
- en: 'Members (both data and function) inherited from the *base class* are accessible
    to the *derived class* as specified by the access regions that are imposed by
    the base class. The inherited access regions, and how they relate to derived class
    access, are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *基类* 继承的成员（数据和函数）可以通过基类施加的访问区域访问 *派生类*。继承的访问区域以及它们与派生类访问的关系如下：
- en: '**private** members defined in the base class are inaccessible outside the
    scope of the base class. The scope of a class includes member functions of that
    class.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中定义的 **private** 成员在基类的作用域之外不可访问。类的作用域包括该类的成员函数。
- en: '**protected** members defined in the base class are accessible in the scope
    of the base class and within the scope of the derived class, or its descendants.
    This means member functions of these classes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中定义的 **protected** 成员可以在基类的范围内以及派生类或其派生类的范围内访问。这意味着这些类的成员函数。
- en: '**public** members defined in the base class are accessible from any scope,
    including the scope of the derived class.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中定义的 **public** 成员可以从任何作用域访问，包括派生类的作用域。
- en: In the previous, simple example, we noticed that both a `Person` and a `Student`
    instance accessed the `public` member function `Person::GetTitle()` from the scope
    of `main()`. Also, we noticed that the `Student` instance accessed its `public`
    member `Student::GetGpa()` from `main()`. Generally, outside the scope of a given
    class, the only members that are accessible are those that are in the public interface,
    such as in this example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的简单示例中，我们注意到一个 `Person` 实例和一个 `Student` 实例都从 `main()` 的作用域中调用了 `public` 成员函数
    `Person::GetTitle()`。同样，我们也注意到 `Student` 实例从 `main()` 中调用了其 `public` 成员 `Student::GetGpa()`。通常，在给定类的范围之外，可访问的成员只有那些在公共接口中的成员，例如在这个例子中。
- en: We will soon see a larger, full program example in this chapter showcasing the
    `protected` access region. But first, let’s discover an additional specifier that
    may be useful in determining the shape and extensibility of our inheritance hierarchy.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中很快看到一个更大的、完整的程序示例，展示 `protected` 访问区域。但首先，让我们发现一个可能有助于确定我们的继承层次结构形状和可扩展性的附加指定符。
- en: Specifying a class as final
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定类为最终
- en: In C++, we can indicate that a class may not be further extended within our
    inheritance hierarchy. This is known as a `final` is used in the base class list
    to designate a class as a **final** (unextendible) class or **leaf-node**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们可以指示一个类在我们的继承层次结构中不能进一步扩展。这被称为在基类列表中使用 `final` 来指定一个类为 **final**（不可扩展）类或
    **叶节点**。
- en: 'Here is a simple example to illustrate the basic syntax:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例来说明基本语法：
- en: 'Given our previous base class `Person`, `Student` *Is-A* derived class of `Person`.
    Additionally, `GradStudent` *Is-A* final derived class of `Student`:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定我们之前的基类 `Person`，`Student` 是 `Person` 的 *派生类*。此外，`GradStudent` 是 `Student`
    的 *最终派生类*：
- en: '[PRE2]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `GradStudent` is specified as a final, unextendible class. Therefore,
    `GradStudent` may not appear in the base class list of a new derived class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`GradStudent` 被指定为一个最终、不可扩展的类。因此，`GradStudent` 可能不会出现在新派生类的基础类列表中。
- en: Next, let’s review inherited constructors and destructors so that our upcoming
    full program example can provide greater overall utility.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾继承的构造函数和析构函数，以便我们即将到来的完整程序示例可以提供更大的整体效用。
- en: Understanding inherited constructors and destructors
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承的构造函数和析构函数
- en: Through single inheritance, we can build a hierarchy of related classes. We
    have seen that when we instantiate a derived class object, memory for its base
    class data members is then followed by the additional memory required for the
    additional derived class data members. Each of these subobjects will need to be
    constructed. Luckily, each class will have defined a suite of constructors for
    just that purpose. We then need to understand how the language can be utilized
    to allow us to specify the appropriate base class constructor for the base class
    subobject when instantiating and constructing a derived class object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单继承，我们可以构建一个相关类的层次结构。我们已经看到，当我们实例化一个派生类对象时，其基类数据成员的内存随后是额外派生类数据成员所需的内存。每个这些子对象都需要被构造。幸运的是，每个类都将定义一套用于此目的的构造函数。然后我们需要了解语言如何被利用，以便在实例化和构造派生类对象时指定适当的基类构造函数。
- en: Similarly, when an object of a derived class type is no longer needed and will
    be destructed, it is important to note that a destructor for each subobject comprising
    the derived class instance will be implicitly called on our behalf.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当一个派生类类型的对象不再需要并被销毁时，需要注意的是，将隐式调用每个组成派生类实例的子对象的析构函数。
- en: Let’s take a look at the constructor and destructor sequence in a single inheritance
    hierarchy, and how we can make choices when more than one constructor is available
    for a base class subobject found in a derived class instance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看单继承层次结构中的构造函数和析构函数的调用顺序，以及当在派生类实例中找到一个基类子对象时，如果存在多个构造函数可供选择，我们如何做出选择。
- en: Implicit constructor and destructor invocations
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式构造函数和析构函数调用
- en: Constructors and destructors are two types of member functions that are not
    explicitly inherited by the derived class. This means that the signature of a
    base class constructor may not be used to instantiate a derived class object.
    However, we will see that when a derived class object is instantiated, the memory
    for both the base and derived class portions of the overall object will be separately
    initialized using each class’s respective constructors.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数是两种派生类没有显式继承的成员函数。这意味着不能使用基类构造函数的签名来实例化派生类对象。然而，我们将看到，当实例化派生类对象时，将分别使用每个类的相应构造函数来单独初始化整体对象中的基类和派生类部分。
- en: When an object of a derived class type is instantiated, not only will one of
    its constructors be invoked but so will one in each of its preceding base classes.
    The most generalized base class constructor will first be executed, followed by
    the constructors all the way down the hierarchy until we arrive at the derived
    class constructor that is the same type as the instance at hand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化派生类类型的对象时，不仅会调用其构造函数，还会调用其所有先前基类的构造函数。最一般的基类构造函数首先执行，然后是层次结构中的所有构造函数，直到我们到达与当前实例类型相同的派生类构造函数。
- en: Similarly, when a derived class instance goes out of scope (or is explicitly
    deallocated for pointers to instances), all the relevant destructors will be invoked,
    but in the opposite order of construction. First, the derived class destructor
    will be executed, then all the destructors in an upward fashion for each preceding
    base class will be invoked and executed until we reach the most generalized base
    class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当一个派生类实例超出作用域（或显式地释放了指向实例的指针）时，所有相关的析构函数都将被调用，但调用顺序与构造顺序相反。首先执行派生类析构函数，然后以向上递归的方式调用并执行每个先前基类的析构函数，直到达到最一般的基类。
- en: You may now ask, how may I choose from a set of potential base class constructors
    for my base class subobject when instantiating a derived class? Let’s take a more
    detailed look at the member initialization list to discover the solution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会问，在实例化派生类时，我如何从一组潜在的基类构造函数中选择我的基类子对象？让我们更详细地看看成员初始化列表，以发现解决方案。
- en: Usage of member initialization list to select a base class constructor
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用成员初始化列表选择基类构造函数
- en: The member initialization list may be used to specify which base class constructor
    should be invoked when instantiating a derived class object. Each derived class
    constructor may specify that a different base class constructor should be used
    to initialize the given base class portion of the derived class object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 成员初始化列表可以用来指定在实例化派生类对象时应该调用哪个基类构造函数。每个派生类构造函数可以指定使用不同的基类构造函数来初始化派生类对象中给定的基类部分。
- en: If the derived class constructor’s member initialization list does not specify
    which base class constructor should be utilized, the default base class constructor
    will be invoked.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类构造函数的成员初始化列表没有指定应该使用哪个基类构造函数，将调用默认的基类构造函数。
- en: The member initialization list is specified using a `:` after the parameter
    list in the derived class constructor. To specify which base class constructor
    should be used, the name of the base class constructor, followed by parentheses
    including any values to be passed to that base class constructor, can be indicated.
    Based upon the signature of the parameters in the base class list following the
    base class name, the appropriate base class constructor will be selected to initialize
    the base class portion of the derived class object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成员初始化列表是在派生类构造函数中的参数列表之后使用 `:` 指定的。为了指定应该使用哪个基类构造函数，可以指示基类构造函数的名称，后面跟着括号，包括要传递给该基类构造函数的任何值。根据基类名称之后基类列表中参数的签名，将选择合适的基类构造函数来初始化派生类对象中的基类部分。
- en: 'Here is a simple example to illustrate the basic syntax for base class constructor
    selection:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子来说明基类构造函数选择的基本语法：
- en: 'Let’s start with the basic class definitions (note that many member functions
    are omitted, as are some usual data members):'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们从基本的类定义开始（注意，省略了许多成员函数和一些常用的数据成员）：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructors for the previous class definitions would be as follows (notice
    two of the derived class constructors use the member initialization list):'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前类定义的构造函数如下（注意两个派生类构造函数使用了成员初始化列表）：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous short segment of code, notice that the system-supplied default
    derived class constructor, `Student::Student()`, has been elected with `=default`
    added to the constructor prototype. With an alternate constructor in this class
    definition, this specification (or by writing the default constructor ourselves)
    is necessary if we would like to support this simple interface for class instantiation.
    Remember, we only get a system-supplied default constructor if there are no other
    constructors (that is, means for instantiation) in our class definition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，请注意，系统提供的默认派生类构造函数 `Student::Student()` 已经被选中，并在构造函数原型中添加了 `=default`。在这个类定义中有另一个构造函数，如果我们想支持这个简单的类实例化接口，这个指定（或者通过我们自己编写默认构造函数）是必要的。记住，我们只有在类定义中没有其他构造函数（即实例化方法）时，才会得到系统提供的默认构造函数。
- en: Next, notice in the alternate derived class constructor, `Student::Student(const
    string &, const string &, float)`, the use of the member initialization list for
    base class construction specification. Here, the `Person` constructor matching
    the signature of `Person::Person(const string &, const string &)` is selected
    to initialize the `Person` subobject at hand. Also, notice that parameters from
    the `Student` constructor, `n` and `t`, are passed up to the aforementioned `Person`
    constructor to help complete the `Person` subobject initialization. Had we not
    specified which `Person` base class constructor should be used in the member initialization
    list, the default `Person` constructor will be used to initialize the `Person`
    base class subobject of `Student`. The member initialization list is additionally
    used in this constructor to initialize data members introduced within the `Student`
    class definition (such as `gpa`).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意在替代派生类构造函数 `Student::Student(const string &, const string &, float)`
    中，用于基类构造函数指定的成员初始化列表的使用。在这里，选择与 `Person::Person(const string &, const string &)`
    签名匹配的 `Person` 构造函数来初始化当前的 `Person` 子对象。此外，请注意，从 `Student` 构造函数中传递的参数 `n` 和 `t`
    被传递到上述 `Person` 构造函数中，以帮助完成 `Person` 子对象的初始化。如果我们没有在成员初始化列表中指定应该使用哪个 `Person`
    基类构造函数，将使用默认的 `Person` 构造函数来初始化 `Student` 的 `Person` 基类子对象。此外，这个构造函数还使用了成员初始化列表来初始化在
    `Student` 类定义中引入的数据成员（例如 `gpa`）。
- en: Now, notice in the copy constructor for the derived class, `Student::Student(const
    Student &)`, the member initialization list is used to select the `Person` copy
    constructor, passing `s` as a parameter to the `Person` copy constructor. Here,
    the object referenced by `s` is a `Student`, however, the top part of `Student`
    memory contains `Person` data members. Hence, it is acceptable to implicitly upcast
    the `Student` to a `Person` to allow the `Person` copy constructor to initialize
    the `Person` subobject. Also, in the member initialization list of the `Student`
    copy constructor, the additional data member added by the `Student` class definition
    is initialized, namely, by initializing `gpa(s.gpa)`. These additional data members
    could have also been set in the body of this constructor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注意在派生类的复制构造函数`Student::Student(const Student &)`中，使用了成员初始化列表来选择`Person`的复制构造函数，将`s`作为参数传递给`Person`的复制构造函数。在这里，由`s`引用的对象是一个`Student`，然而，`Student`内存的上部包含`Person`的数据成员。因此，隐式地将`Student`提升为`Person`是可接受的，以便`Person`的复制构造函数初始化`Person`子对象。此外，在`Student`复制构造函数的成员初始化列表中，`Student`类定义中添加的额外数据成员被初始化，即通过初始化`gpa(s.gpa)`。这些额外的数据成员也可以在这个构造函数的主体中设置。
- en: Now that we understand how to utilize the member initialization list to specify
    a base class constructor, let’s move forward with a complete program example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何利用成员初始化列表来指定基类构造函数，让我们继续一个完整的程序示例。
- en: Putting all the pieces together
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有部件组合在一起
- en: So far in this chapter, we have seen many pieces contributing to a full program
    example. It is important to see our code in action, with all its various components.
    We need to see the basic mechanics of inheritance, how the member initialization
    list is used to specify which base class constructor should implicitly be invoked,
    and the significance of the `protected` access region.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了许多贡献于一个完整的程序示例的片段。看到我们的代码在行动中，以及所有其各种组件，是很重要的。我们需要看到继承的基本机制，如何使用成员初始化列表来指定应该隐式调用的哪个基类构造函数，以及`protected`访问区域的重要性。
- en: 'Let’s take a look at a more complex, full program example to fully illustrate
    single inheritance. This example will be broken into segments; the full program
    can be found in the following GitHub location:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂、完整的程序示例，以充分说明单继承。这个示例将被分成几个部分；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex1.cpp)'
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous class definition, we now have a fully-fledged class definition
    for `Person`, with many more details than our simple syntax examples formerly
    used in this section. Notice that we have introduced a `protected` access region
    and placed member function `void ModifyTitle(const string &);` in this access
    region.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类定义中，我们现在有一个完整的`Person`类定义，比我们在这个部分以前使用的简单语法示例包含更多的细节。注意，我们引入了一个`protected`访问区域，并将成员函数`void
    ModifyTitle(const string &);`放置在这个访问区域中。
- en: 'Moving onward, let’s examine the non-line member function definitions for `Person`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，让我们检查`Person`的非线成员函数定义：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The implementation for the aforesaid `Person` member functions is as expected.
    Now, let’s add the class definition for the derived class, `Student`, along with
    its inline function definitions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述`Person`成员函数的实现是预期的。现在，让我们添加派生类`Student`的类定义，以及其内联函数定义：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding definition of `Student`, `class Student` is derived from `Person`
    using `public` inheritance (that is, a public base class), which supports an Is-A
    relationship. Notice the `public` access label after the base class list following
    the `:` in the derived class definition (that is, `class Student: public Person`).
    Notice that our `Student` class has added data members and member functions above
    and beyond those that it automatically inherits from `Person`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '在`Student`的前面定义中，`class Student`使用`public`继承（即公共基类）从`Person`派生，这支持一个Is-A关系。注意在派生类定义中冒号后面的基类列表之后的`public`访问标签（即`class
    Student: public Person`）。注意，我们的`Student`类添加了比从`Person`自动继承的更多的数据成员和成员函数。'
- en: 'Next, adding in the non-inline `Student` member functions, we continue growing
    our code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加非内联的`Student`成员函数，我们继续扩展我们的代码：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the aforementioned segment of code, we define the non-inline member functions
    of `Student`. Notice that the default constructor merely uses the member initialization
    list to initialize a data member, as we did in the last chapter. Since no `Person`
    constructor has been specified in the member initialization list of the default
    `Student` constructor, the default `Person` constructor will be used to initialize
    the `Person` subobject when instantiating a `Student` with its default constructor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码段中，我们定义了`Student`的非内联成员函数。请注意，默认构造函数仅使用成员初始化列表来初始化一个数据成员，就像我们在上一章中所做的那样。由于在默认`Student`构造函数的成员初始化列表中没有指定`Person`构造函数，因此当使用默认构造函数实例化`Student`时，将使用默认的`Person`构造函数来初始化`Person`子对象。
- en: Next, the alternate constructor for `Student` uses the member initialization
    list to specify that the alternate constructor of `Person` should be utilized
    to construct the `Person` subobject contained within a given `Student` instance.
    Notice that the selected constructor will match the signature `Person::Person(const
    string &, const string &, char, const string &)`, and that selected input parameters
    from the `Student` constructor (namely `fn`, `ln`, `mi`, and `t`) will be passed
    as parameters to the `Person` alternate constructor. The `Student` constructor’s
    member initialization list is then used to initialize additional data members
    introduced by the `Student` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Student`类的替代构造函数使用成员初始化列表来指定应该使用`Person`的替代构造函数来构建给定`Student`实例中包含的`Person`子对象。请注意，所选构造函数将与签名`Person::Person(const
    string &, const string &, char, const string &)`匹配，并且从`Student`构造函数中选择的输入参数（即`fn`、`ln`、`mi`和`t`）将作为参数传递给`Person`的替代构造函数。然后，`Student`构造函数的成员初始化列表被用来初始化`Student`类引入的任何附加数据成员。
- en: In the copy constructor for `Student`, the member initialization list is used
    to specify that the `Person` copy constructor should be called to initialize the
    `Person` subobject of the `Student` instance that is being constructed. The `Student
    &` will be implicitly upcast to a `Person &` as the `Person` copy constructor
    is called. Recall that the top part of a `Student` object *Is-A* `Person`, so
    this is fine. Next, in the remainder of the copy constructor’s member initialization
    list for `Student`, we initialize any remaining data members the `Student` class
    has defined. Any data members requiring a deep copy (such as those that are pointers)
    may be handled in the body of the copy constructor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Student`类的复制构造函数中，成员初始化列表被用来指定应该调用`Person`的复制构造函数来初始化正在构建的`Student`实例的`Person`子对象。当调用`Person`的复制构造函数时，`Student
    &`将隐式地向上转换为`Person &`。回想一下，`Student`对象的上半部分是`Is-A` `Person`，所以这是可以的。接下来，在复制构造函数的剩余成员初始化列表中，我们初始化`Student`类定义的任何剩余数据成员。任何需要深度复制的数据成员（例如指针）可以在复制构造函数的主体中处理。
- en: Moving onward, we see a comment indicating the `Student` destructor. Implicitly,
    as the *last* line of code in this method (whether the destructor is system-supplied
    or user-written), a call to the `Person` destructor is patched in for us by the
    compiler. This is how the destructor sequence is automated for us. Consequently,
    the most specialized portion of the object, the `Student` pieces, will first be
    destructed, followed by the implicit call to the `Person` destructor to destruct
    the base class subobject.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们看到一条注释，指出了`Student`析构函数。隐式地，作为此方法（无论析构函数是系统提供的还是用户编写的）的最后一行代码，编译器为我们修补了一个对`Person`析构函数的调用。这就是析构函数序列自动化的方式。因此，对象最专业的一部分，即`Student`部分，将首先被析构，然后是隐式调用`Person`析构函数来析构基类子对象。
- en: Next, in the `Print()` method for `Student`, notice that we would like to print
    out various data members that are inherited from `Person`. Alas, these data members
    are `private`. We may not access them outside the scope of the `Person` class.
    Nevertheless, the `Person` class has left us with a public interface, such as
    `Person::GetTitle()` and `Person::GetFirstName()`, so that we may access these
    data members from any scope of our application, including from `Student::Print()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`Student`类的`Print()`方法中，请注意我们希望打印出从`Person`类继承的各种数据成员。唉，这些数据成员是`private`的。我们可能无法在`Person`类的作用域之外访问它们。然而，`Person`类为我们留下了一个公共接口，例如`Person::GetTitle()`和`Person::GetFirstName()`，这样我们就可以从应用程序的任何作用域中访问这些数据成员，包括从`Student::Print()`中访问。
- en: Finally, we come to the `Student::EarnPhD()` method. Notice that all this method
    does is invoke the `protected` member function `Person::ModifyTitle("Dr.");`.
    Recall that `protected` members defined by the base class are accessible within
    the scope of the derived class. `Student::EarnPhD()` is a member function of the
    derived class. `EarnPhD()` provides a public interface to modify the title of
    a `Person`, perhaps after checking whether the student has met graduation requirements.
    Because `Person::ModifyTitle()` is not `public`, instances of `Person` or `Student`
    must go through a controlled `public` interface to change their respective titles.
    Such interfaces might include methods such as `Student::EarnPhD()` or `Person::GetMarried()`,
    and so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了 `Student::EarnPhD()` 方法。注意，这个方法所做的只是调用受保护的成员函数 `Person::ModifyTitle("Dr.");`。回想一下，由基类定义的
    `protected` 成员在派生类的范围内是可访问的。`Student::EarnPhD()` 是派生类的一个成员函数。`EarnPhD()` 提供了一个公共接口来修改
    `Person` 的头衔，可能是在检查学生是否满足毕业要求之后。因为 `Person::ModifyTitle()` 不是 `public`，所以 `Person`
    或 `Student` 的实例必须通过受控的 `public` 接口来更改它们各自的头衔。这些接口可能包括 `Student::EarnPhD()` 或 `Person::GetMarried()`
    等方法，等等。
- en: 'Nonetheless, let’s complete our full program example by examining `main()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们通过检查 `main()` 函数来完成我们的完整程序示例：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last segment of this program, in `main()`, we simply instantiate a `Student`,
    namely `s1`. The `Student` utilizes `Student::Print()` to print its current data.
    The `Student` then sets her current course set to `"Doctoral Thesis"` and then
    invokes `Student::EarnPhD();`. Note that any `public` members of `Student` or
    `Person` are available for `s1` to utilize outside the scope of their class, such
    as in `main()`. To complete the example, `s1` reprints her details using `Student::Print()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的最后一个部分 `main()` 中，我们简单地实例化了一个 `Student`，即 `s1`。`Student` 使用 `Student::Print()`
    来打印其当前数据。然后 `Student` 将她的当前课程设置为 `"Doctoral Thesis"`，然后调用 `Student::EarnPhD();`。请注意，`Student`
    或 `Person` 的任何 `public` 成员都可以在它们的作用域之外由 `s1` 使用，例如在 `main()` 中。为了完成这个示例，`s1` 使用
    `Student::Print()` 重新打印她的详细信息。
- en: 'Here is the output for the full program example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是完整程序示例的输出：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have competency with the basic mechanics of single inheritance,
    and have used single inheritance to model an Is-A relationship, let’s move onward
    to see how inheritance can be used to model a different concept by exploring `protected`
    and `private` base classes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了单继承的基本机制，并使用单继承来建模 Is-A 关系，让我们继续前进，看看如何通过探索 `protected` 和 `private`
    基类来使用继承来建模不同的概念。
- en: Implementation inheritance – changing the purpose of inheritance
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现继承 – 改变继承的目的
- en: So far we demonstrated using a public base class, known also as *public inheritance*.
    Public base classes are used to model Is-A relationships and provide the primary
    motivation behind building an inheritance hierarchy. This usage supports the concepts
    of generalization and specialization.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示了使用公共基类，也称为 *公共继承*。公共基类用于建模 Is-A 关系，并提供了构建继承层次结构的主要动机。这种用法支持泛化和特殊化的概念。
- en: Occasionally, inheritance may be used as a tool to implement one class in terms
    of another, that is, by one class using another as its underlying implementation.
    This is known as **implementation inheritance** and it does not support the ideals
    of generalization and specialization. Yet, implementation inheritance can provide
    a quick and easily reusable way to implement one class based upon another. It
    is fast and relatively error-free. Many class libraries use this tool without
    the knowledge of their class users. It is important to distinguish implementation
    inheritance from traditional hierarchy building for the motivation of specifying
    Is-A relationships.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，继承可能被用作一种工具，通过另一个类来实现一个类，也就是说，一个类使用另一个类作为其底层实现。这被称为 **实现继承**，它不支持泛化和特殊化的理念。然而，实现继承可以提供一种快速且易于重用的方式来实现一个基于另一个类的类。它是快速且相对无错误的。许多类库在不知道其类用户的情况下使用这个工具。区分实现继承和传统的层次结构构建对于指定
    Is-A 关系是有动机的。
- en: Implementation inheritance, supported in C++ with private and protected base
    classes, is exclusive to C++. Other OOP languages choose to only embrace inheritance
    for the purpose of modeling Is-A relationships, which is supported in C++ through
    public base classes. An OO purist would endeavor to use inheritance only to support
    generalization and specialization (*Is-A*). However, using C++, we will understand
    appropriate uses of implementation inheritance so that we may use this language
    feature wisely.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持实现继承，使用私有和受保护的基类，这是C++独有的。其他面向对象编程语言选择只接受继承用于建模*Is-A*关系，这在C++中通过公共基类得到支持。面向对象纯主义者会努力只使用继承来支持泛化和特殊化（*Is-A*）。然而，使用C++，我们将了解实现继承的适当用途，以便我们能够明智地使用这种语言特性。
- en: Let’s move onward to understand how and why we might utilize this type of inheritance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，了解我们可能如何以及为什么利用这种类型的继承。
- en: Modifying access labels in the base class list by using protected or private
    base classes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过使用受保护的或私有的基类修改基类列表中的访问标记
- en: To reiterate, the usual type of inheritance is `public` inheritance. The `public`
    label is used in the base class list for a given derived class. However, in the
    base class list, the keywords `protected` and `private` are also options.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，通常的继承类型是`public`继承。对于给定的派生类，基类列表中使用`public`标记。然而，在基类列表中，`protected`和`private`关键字也是可选项。
- en: That is, in addition to labeling access regions within a class or structure
    definition, an access label can be used in the base class list of a derived class
    definition to designate how members defined in a base class are inherited by derived
    classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除了在类或结构定义内标记访问区域外，访问标记还可以在派生类定义的基类列表中使用，以指定基类中定义的成员如何被派生类继承。
- en: Inherited members can only be made more restrictive than they were designated
    to be in the base class. When the derived class specifies that inherited members
    should be treated in a more restrictive fashion, any descendants of that derived
    class will also be subject to these specifications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 继承成员只能比在基类中指定的更严格。当派生类指定继承成员应以更严格的方式处理时，该派生类的任何后代也将受到这些规定的约束。
- en: 'Let’s see a quick example of the *base class list*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下*基类列表*的例子：
- en: Recall that most often, a `public` access label will be specified in the base
    class list.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，通常在基类列表中会指定一个`public`访问标记。
- en: 'In this example, a `public` access label is used to specify that a `Person`
    is a `public` base class of `Student`. That is, a `Student` *Is-A* `Person`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`public`访问标记来指定`Person`是`Student`的`public`基类。也就是说，`Student`是`Person`的*一种*：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Access labels specified in the *base class list* modify inherited access regions
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基类列表*中指定的访问标记将按以下方式修改继承的访问区域：
- en: '**public**: Public members in the base class are accessible from any scope;
    protected members in the base class are accessible from the scope of the base
    and derived classes. We are familiar with using a public base class.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共的**：基类中的公共成员可以从任何范围访问；基类中的受保护成员可以从基类和派生类的范围访问。我们熟悉使用公共基类。'
- en: '**protected**: Public and protected members in the base class act as though
    they are defined as protected by the derived class (that is, accessible from the
    scope of the base and derived classes and any descendants of the derived class).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的**：基类中的公共和受保护成员的行为就像它们被派生类定义为受保护的（即，可以从基类和派生类的范围以及派生类后代的范围内访问）。'
- en: '**private**: Public and protected members in the base class act as though they
    are defined as private by the derived class, allowing these members to be accessible
    within the scope of the derived class, but not within the scope of any of the
    derived class descendants.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有的**：基类中的公共和受保护成员的行为就像它们被派生类定义为私有的，允许这些成员在派生类的范围内访问，但不能在任何派生类后代的范围内访问。'
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In all cases, class members labeled as private within a class definition, are
    accessible only within the scope of the defining class. Modifying the access labels
    in the base class list can only treat inherited members more restrictively, never
    less restrictively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，在类定义中将成员标记为私有的，只能在其定义的范围内访问。修改基类列表中的访问标记只能使继承成员更严格，而不能更宽松。
- en: In the absence of an access label specified in conjunction with the base class,
    `private` will be assumed if the user defined type is a `class`, and `public`
    will be the default if the user defined type is a `struct`. A good rule of thumb
    is to always include the access label in the base class list for a derived class
    (or structure) definition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有在基类中指定访问标签，当用户定义的类型是`class`时，将假定其为`private`，而当用户定义的类型是`struct`时，默认为`public`。一个很好的经验法则是，在派生类（或结构）定义的基类列表中始终包含访问标签。
- en: Creating a base class to illustrate implementation inheritance
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基类以说明实现继承
- en: 'To understand implementation inheritance, let’s review a base class that may
    serve as a basis to implement other classes. We will examine a typical pair of
    classes to implement an encapsulated `LinkList`. Though this example will be broken
    into several segments, the full example will be shown, and can also be found in
    the GitHub:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解实现继承，让我们回顾一个可以作为其他类实现基础的基类。我们将检查一对典型的类来实现封装的`LinkList`。尽管这个例子将被分成几个部分，但完整的示例将展示出来，也可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex2.cpp)'
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We begin the previous segment of code with class definitions for both `LinkListElement`
    and `LinkList`. The `LinkList` class will contain data members that are pointers
    to the `head`, `tail`, and `current` element in the `LinkList`. Each of these
    pointers is of type `LinkListElement`. A variety of typical `LinkList` processing
    methods are included, such as `InsertAtFront()`, `RemoveAtFront()`, `DeleteAtFront()`,
    `IsEmpty()`, and `Print()`. Let’s take a quick peek at the implementation of these
    methods with the next segment of code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从代码的前一部分开始，定义了`LinkListElement`和`LinkList`两个类的定义。`LinkList`类将包含指向`LinkList`中的`head`、`tail`和`current`元素的指针。这些指针的类型都是`LinkListElement`。它包括各种典型的`LinkList`处理方法，如`InsertAtFront()`、`RemoveAtFront()`、`DeleteAtFront()`、`IsEmpty()`和`Print()`。让我们快速浏览一下这些方法的实现，代码的下一部分将展示：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previously mentioned member function definitions, we note that a `LinkList`
    can be constructed either empty or with one element (note the two available constructors).
    `LinkList::InsertAtFront()` adds an item to the front of the list for efficiency.
    `LinkList::RemoveAtFront()` removes an item and returns it to the user, whereas
    `LinkList::DeleteAtFront()` removes and deletes the front item. The `LinkList::Print()`
    function allows us to view the `LinkList` whenever necessary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前提到的成员函数定义中，我们注意到`LinkList`可以构造为空或包含一个元素（注意有两个可用的构造函数）。`LinkList::InsertAtFront()`为了效率，将项目添加到列表的前面。`LinkList::RemoveAtFront()`移除一个项目并将其返回给用户，而`LinkList::DeleteAtFront()`移除并删除前面的项目。`LinkList::Print()`函数允许我们在必要时查看`LinkList`。
- en: 'Next, let’s see a typical `main()` function to illustrate how a `LinkList`
    can be instantiated and manipulated:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个典型的`main()`函数，以说明如何实例化和操作`LinkList`：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `main()`, we create a few items, of type `Item`, which will later be data
    for `LinkListElement`. We then instantiate a `LinkListElement`, namely `element1`,
    and add it to a newly constructed `LinkList`, using `LinkList list1(element1);`.
    We then add several items to the list using `LinkList::InsertAtFront()`, and call
    `LinkList::Print()` to print out `list1` for a baseline. Next, we delete elements
    from `list1`, one by one, printing as we go, using `LinkList::DeleteAtFront()`
    and `LinkList::Print()`, respectively.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们创建了一些类型为`Item`的项目，这些项目将后来成为`LinkListElement`的数据。然后我们实例化一个`LinkListElement`，即`element1`，并将其添加到一个新构建的`LinkList`中，使用`LinkList
    list1(element1);`。然后我们使用`LinkList::InsertAtFront()`向列表中添加几个项目，并调用`LinkList::Print()`来打印出`list1`作为基线。接下来，我们逐个从`list1`中删除元素，打印过程中使用`LinkList::DeleteAtFront()`和`LinkList::Print()`，分别进行。
- en: Now, we instantiate a second `LinkList`, namely `list2`, which starts out empty.
    We gradually insert several items using `LinkList::InsertAtFront()`, then print
    the list, and then delete each element, one by one, using `LinkList::DeleteAtFront()`,
    printing the revised list with each step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实例化第二个`LinkList`，即`list2`，它一开始是空的。我们逐渐使用`LinkList::InsertAtFront()`插入几个项目，然后打印列表，然后逐个使用`LinkList::DeleteAtFront()`删除每个元素，并在每个步骤中打印修改后的列表。
- en: The point of this example is not to exhaustively review the inner workings of
    this code. You are undoubtedly familiar with the concept of a `LinkList`. More
    so, the point is to establish this set of classes, `LinkListElement` and `LinkList`,
    as a set of building blocks in which several *Abstract Data Types* can be built.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的目的不是详尽无遗地审查这段代码的内部工作原理。你无疑已经熟悉了`LinkedList`的概念。更重要的是，这个示例的目的是建立这一系列类，`LinkListElement`和`LinkList`，作为构建块集合，在这个集合中可以构建多个*抽象数据类型*。
- en: 'Nonetheless, the output for the preceding example is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面示例的输出如下：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, let’s see how `LinkList` can be used as a private base class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何将`LinkedList`用作私有基类。
- en: Using a private base class to implement one class in terms of another
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用私有基类通过一个类实现另一个类
- en: We have just created a `LinkList` class to support the basic handling of an
    encapsulated linked list data structure. Now, let’s imagine that we would like
    to implement an `Push()`, `Pop()`, `IsEmpty()`, and perhaps `Print()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个`LinkList`类来支持封装的链表数据结构的基本处理。现在，让我们想象一下，我们想要实现`Push()`、`Pop()`、`IsEmpty()`，也许还有`Print()`。
- en: You may ask how a stack is implemented. The answer is that the implementation
    does not matter, so long as it supports the expected interface of the ADT being
    modeled. Perhaps a stack is implemented using an array, or perhaps it is implemented
    in a file. Perhaps it is implemented using a `LinkedList`. Each implementation
    has pros and cons. In fact, the underlying implementation of the ADT might change,
    yet users of the ADT should not be affected by such a change. This is the basis
    of *implementation inheritance*. A derived class is implemented in terms of a
    base class, yet the underlying details of the base class from which the new class
    is derived are effectively hidden. These details cannot be directly used by instances
    of the derived class (in this case, the ADT). Nonetheless, the base class silently
    provides the implementation for the derived class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问堆栈是如何实现的。答案是，实现方式并不重要，只要它支持所建模的ADT（抽象数据类型）预期的接口即可。也许堆栈是通过数组实现的，也许它是通过文件实现的。也许它是通过`LinkedList`实现的。每种实现都有其优缺点。实际上，ADT的底层实现可能会改变，但ADT的用户不应受到这种变化的影响。这就是*实现继承*的基础。派生类是在基类的基础上实现的，但派生出新类的基础类的底层细节实际上是被隐藏的。这些细节不能直接被派生类的实例（在这种情况下，ADT的实例）使用。尽管如此，基类默默地为派生类提供了实现。
- en: We will use this approach to implement a `Stack` using a `LinkedList` as its
    underlying implementation. To do this, we will have `class Stack` extend `LinkedList`
    using a `private` base class. `Stack` will define a public interface for its users
    to establish the interface for this ADT, such as `Push()`, `Pop()`, `IsEmpty()`,
    and `Print()`. The implementation of these member functions will make use of selected
    `LinkedList` member functions, but `Stack` users will not see this, nor will `Stack`
    instances be able to use any `LinkList` members directly themselves.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这种方法，通过使用`LinkedList`作为其底层实现来实现`Stack`。为此，我们将使用`class Stack`通过一个`private`基类扩展`LinkedList`。`Stack`将为用户定义一个公共接口，以建立这个ADT的接口，例如`Push()`、`Pop()`、`IsEmpty()`和`Print()`。这些成员函数的实现将利用选定的`LinkedList`成员函数，但`Stack`的用户将看不到这一点，`Stack`的实例也不能直接使用任何`LinkedList`成员。
- en: Here, we are not saying a `Stack` *Is-A* `LinkList`, but rather, a `Stack` is
    implemented in terms of a `LinkedList` at the moment—and that underlying implementation
    could change!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们并不是说`Stack` *是* `LinkedList`，而是说，目前`Stack`是通过`LinkedList`实现的——而且这种底层实现可能会改变！
- en: 'The code to implement `Stack` is simple. Assume we are using the `LinkList`
    and `LinkListElement` classes from the previous example. Let’s add the `Stack`
    class here. The full program example can be found in our GitHub:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Stack`的代码很简单。假设我们正在使用前面示例中的`LinkList`和`LinkListElement`类。让我们在这里添加`Stack`类。完整的程序示例可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex3.cpp)'
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how compact the aforementioned code is for our `Stack` class! We begin
    by specifying that `Stack` has a `private` base class of `LinkList`. Recall that
    a `private` base class means that the `protected` and `public` members inherited
    from `LinkList` act as though they were defined by `Stack` as `private` (and are
    only accessible within the scope of `Stack`, that is, member functions of `Stack`).
    This means that instances of `Stack` may not use the *former* public interface
    of `LinkList`. This also means that the underlying implementation of `Stack` as
    a `LinkList` is effectively hidden. Of course, `LinkList` instances are not affected
    in any way and may use their `public` interface as usual.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述代码对于我们的`Stack`类是多么紧凑！我们首先指定`Stack`有一个`private`基类`LinkList`。回想一下，`private`基类意味着从`LinkList`继承的`protected`和`public`成员就像是由`Stack`定义的`private`一样（并且只可以在`Stack`的作用域内访问，即`Stack`的成员函数）。这意味着`Stack`的实例可能无法使用`LinkList`的*原有*公共接口。这也意味着`Stack`作为`LinkList`的底层实现实际上是隐藏的。当然，`LinkList`实例不会受到影响，并且可以像往常一样使用它们的`public`接口。
- en: We notice that `=default` has been added to both the `Stack` constructor and
    destructor prototypes. Neither of these methods has work to do because we are
    not adding any data members to this class; therefore, the default system-supplied
    versions are acceptable. Note that if we omitted both the default constructor
    and destructor prototypes, we get both system-supplied versions linked in.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`=default`已经被添加到`Stack`构造函数和析构函数的原型中。这两个方法都没有工作要做，因为我们没有向这个类添加任何数据成员；因此，默认的系统提供的版本是可以接受的。注意，如果我们省略了构造函数和析构函数的原型，我们将链接系统提供的两个版本。
- en: We easily define `Stack::Push()` to simply call `LinkList::InsertAtFront()`,
    just as `Stack::Pop()` does little more than call `LinkList::RemoveAtFront()`.
    Even though `Stack` would love to simply use the inherited implementations of
    `LinkList::IsEmpty()` and `LinkList::Print()`, due to `LinkList` being a `private`
    base class, these functions are not part of the public interface of `Stack`. Accordingly,
    `Stack` adds an `IsEmpty()` method that simply calls `LinkList::IsEmpty();`. Notice
    the use of the scope resolution operator to specify the `LinkList::IsEmpty()`
    method; without the base class qualification, we would be adding a recursive function
    call! This call to the base class method is allowed because `Stack` member functions
    can call the *once public* methods of `LinkList` (they are now treated as `private`
    within `Stack`). Similarly, `Stack::Print()` merely calls `LinkList::Print()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易地将`Stack::Push()`定义为简单地调用`LinkList::InsertAtFront()`，就像`Stack::Pop()`所做的只是调用`LinkList::RemoveAtFront()`一样。尽管`Stack`很想简单地使用从`LinkList`继承的实现，但由于`LinkList`是一个`private`基类，这些函数不是`Stack`的公共接口的一部分。因此，`Stack`添加了一个简单的`IsEmpty()`方法，该方法仅调用`LinkList::IsEmpty();`。注意使用作用域解析运算符来指定`LinkList::IsEmpty()`方法；如果没有基类限定符，我们将会添加一个递归函数调用！这个调用基类方法是允许的，因为`Stack`成员函数可以调用`LinkList`的*一次公开*方法（它们现在在`Stack`内部被视为`private`）。同样，`Stack::Print()`仅仅调用`LinkList::Print()`。
- en: In the scope of `main()`, we instantiate a `Stack`, namely `stack1`. Using the
    public interface of `Stack`, we easily manipulate `stack1` using `Stack::Push()`,
    `Stack::Pop()`, `Stack::IsEmpty()`, and `Stack::Print()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数的作用域内，我们实例化了一个`Stack`，即`stack1`。使用`Stack`的公共接口，我们可以轻松地通过`Stack::Push()`、`Stack::Pop()`、`Stack::IsEmpty()`和`Stack::Print()`来操作`stack1`。
- en: 'The output for this example is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的输出如下：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is important to note that a pointer to a `Stack` instance cannot be upcast
    to be stored as a pointer to a `LinkList`. Upcasting is not allowed across a `private`
    base class boundary. This would allow a `Stack` to reveal its underlying implementation;
    C++ does not allow this to happen. Here, we see that a `Stack` is merely implemented
    in terms of a `LinkList`; we are not saying that a `Stack` *Is-A* `LinkedList`.
    This is the concept of implementation inheritance in its best light; this example
    illustrates implementation inheritance favorably.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Stack`实例的指针不能向上转换为存储为指向`LinkList`的指针。不允许跨越`private`基类边界的向上转换。这将允许`Stack`揭示其底层实现；C++不允许这种情况发生。在这里，我们看到`Stack`仅仅是基于`LinkList`实现的；我们并不是说`Stack`
    *是* `LinkedList`。这是实现继承的最佳概念；这个例子有利的说明了实现继承。
- en: Next, let’s move forward to see how we can use a `protected` base class, and
    how that differs from a `private` base class using implementation inheritance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续前进，看看我们如何使用一个`protected`基类，以及它是如何通过实现继承与一个`private`基类不同的。
- en: Using a protected base class to implement one class in terms of another
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用受保护的基类通过另一个类来实现一个类
- en: We have just implemented a `Stack` in terms of a `LinkList` using a `private`
    base class. Now, let’s implement a `Queue` and a `PriorityQueue`. We will implement
    a `Queue` using `LinkList` as a `protected` base class, and a `PriorityQueue`
    using `Queue` as a `public` base class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用`private`基类在`LinkList`的基础上实现了一个`Stack`。现在，让我们实现一个`Queue`和一个`PriorityQueue`。我们将使用`LinkList`作为`protected`基类来实现`Queue`，并使用`Queue`作为`public`基类来实现`PriorityQueue`。
- en: Again, `Queue` and `PriorityQueue` are Abstract Data Types. It is (relatively)
    unimportant how a `Queue` is implemented. The underlying implementation may change.
    Implementation inheritance allows us to implement our `Queue` using a `LinkedList`
    without revealing the underlying implementation to users of the `Queue` class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`Queue`和`PriorityQueue`都是抽象数据类型。`Queue`是如何实现的（相对）并不重要。底层的实现可能会改变。实现继承允许我们使用`LinkedList`来实现我们的`Queue`，而不向`Queue`类的用户透露底层的实现。
- en: Now, our class `Queue` will use `LinkedList` as a `protected` base class. `Queue`
    will define a public interface for its users to establish the expected interface
    for this ADT, such as `Enqueue()`, `Dequeue()`, `IsEmpty()`, and `Print()`. The
    implementation of these member functions will make use of selected `LinkedList`
    member functions, but `Queue` users will not see this, nor will `Queue` instances
    be able to use any `LinkList` members directly themselves.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的类`Queue`将使用`LinkedList`作为`protected`基类。`Queue`将为用户定义一个公共接口，以建立这个ADT的预期接口，例如`Enqueue()`、`Dequeue()`、`IsEmpty()`和`Print()`。这些成员函数的实现将利用选定的`LinkedList`成员函数，但`Queue`的用户将看不到这一点，`Queue`实例也不能直接使用任何`LinkList`成员。
- en: Furthermore, our class `PriorityQueue` will extend `Queue` using `public` inheritance.
    That’s right, we’re back to Is-A. We are saying that a `PriorityQueue` *Is-A*
    `Queue`, and a `Queue` is implemented using a `LinkedList`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的类`PriorityQueue`将通过`public`继承来扩展`Queue`。没错，我们又回到了“是-一个”的关系。我们说`PriorityQueue`“是-一个”`Queue`，而`Queue`是通过`LinkedList`实现的。
- en: We will just add a priority enqueuing method to our `PriorityQueue` class; this
    class will be glad to inherit the `public` interface from `Queue` (but obviously
    not from `LinkList`, which luckily is hidden behind a `protected` base class at
    its parent’s level).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅仅在我们的`PriorityQueue`类中添加一个优先级入队方法；这个类将很高兴地继承自`Queue`的`public`接口（但显然不是从`LinkList`继承，幸运的是，`LinkList`在其父级的级别上被隐藏在一个`protected`基类之后）。
- en: 'The code to implement `Queue` and `PriorityQueue` is again straightforward.
    The `LinkList` base class needs to be augmented to be more fully functional in
    order to proceed. The `LinkListElement` class can remain the same. We will show
    the basics of the revised `LinkList` class with only its class definition. The
    full code for both `Queue` and `PriorityQueue` will be shown in a separate segment.
    The full program example can be found in our GitHub:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Queue`和`PriorityQueue`的代码同样简单直接。为了继续进行，`LinkList`基类需要增强以实现更完整的功能。`LinkListElement`类可以保持不变。我们将仅通过其类定义展示修订后的`LinkList`类的基本内容。`Queue`和`PriorityQueue`的完整代码将在单独的部分展示。完整的程序示例可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter06/Chp6-Ex4.cpp)'
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that `LinkList` has been expanded to have a fuller set of features, such
    as being able to add, remove, and delete elements at various positions within
    the `LinkList`. To keep our examined code together brief, we will not show the
    implementation of these methods.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`LinkList`已经被扩展，具有更完整的功能集，例如能够在`LinkList`的各个位置添加、删除和删除元素。为了保持我们检查的代码简短，我们不会展示这些方法的实现。
- en: 'Now, let’s add the class definitions for `Queue` and `PriorityQueue` in the
    next code segment:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一段代码中添加`Queue`和`PriorityQueue`的类定义：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous segment of code, we define the `Queue` and `PriorityQue` classes.
    Notice that `Queue` has a `protected` base class of `LinkList`. With a `protected`
    base class, the `protected` and `public` members inherited from `LinkList` act
    as though they are defined by `Queue` as `protected`, which means that these inherited
    members are not only accessible within the scope of `Queue`, but also within any
    potential descendants of `Queue`. As before, these restrictions only apply to
    the `Queue` class, its descendants, and their instances; the `LinkList` class
    and its instances are unaffected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码段中，我们定义了`Queue`和`PriorityQue`类。请注意，`Queue`有一个`protected`基类`LinkList`。使用`protected`基类，从`LinkList`继承的`protected`和`public`成员表现得好像是由`Queue`作为`protected`定义的，这意味着这些继承成员不仅可以在`Queue`的作用域内访问，还可以在任何潜在的`Queue`后代中访问。和以前一样，这些限制仅适用于`Queue`类、其后代及其实例；`LinkList`类及其实例不受影响。
- en: In the `Queue` class, no new data members are necessary. The internal implementation
    is handled by `LinkList`. With a `protected` base class, we are saying that the
    `Queue` is implemented using a `LinkList`. Nonetheless, we must provide the `public`
    interface for `Queue` and we do so by adding methods such as `Queue::Enqueue()`,
    `Queue::Dequeue()`, `Queue::IsEmpty()` and `Queue::Print()`. Notice that in their
    implementations, these methods merely call `LinkList` methods to perform the necessary
    operations. Users of `Queue` must use `Queue`’s public interface; the *once public*
    `LinkList` interface is hidden to `Queue` instances.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Queue`类中，不需要新的数据成员。内部实现由`LinkList`处理。使用`protected`基类，我们表示`Queue`是通过`LinkList`实现的。尽管如此，我们必须提供`Queue`的`public`接口，我们通过添加方法如`Queue::Enqueue()`、`Queue::Dequeue()`、`Queue::IsEmpty()`和`Queue::Print()`来实现。请注意，在这些方法的实现中，它们仅仅调用`LinkList`方法来执行必要的操作。`Queue`的使用者必须使用`Queue`的公共接口；`LinkList`的*曾经公开*接口对`Queue`实例是隐藏的。
- en: Next, we define `PriorityQueue`, another ADT. Notice that `PriorityQueue` defines
    `Queue` as a `public` base class. We are back to inheritance to support an Is-A
    relationship. A `PriorityQueue` *Is-A* `Queue` and can do everything a `Queue`
    can do, just a little more. As such, `PriorityQueue` inherits as usual from `Queue`,
    including `Queue`’s public interface. `PriorityQueue` needs only to add an additional
    method for priority enqueuing, namely `PriorityQueue::PriorityEnqueue()`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`PriorityQueue`，另一个ADT。请注意，`PriorityQueue`将`Queue`定义为`public`基类。我们回到了继承来支持Is-A关系。`PriorityQueue`*是*一个`Queue`，可以做到`Queue`能做的所有事情，只是更多一点。因此，`PriorityQueue`像往常一样从`Queue`继承，包括`Queue`的公共接口。`PriorityQueue`只需要添加一个额外的优先级入队方法，即`PriorityQueue::PriorityEnqueue()`。
- en: Since `Queue` has a protected base class of `LinkList`, the `public` interface
    from `LinkList` is considered `protected` to `Queue` and its descendants, including
    `PriorityQueue`, so that `LinkList`’s *once public* methods are considered `protected`
    to both `Queue` and `PriorityQueue`. Notice that `PriorityQueue::PriorityEnqueue()`
    makes use of `LinkList::InsertBeforeItem()`. This would not be possible if `LinkList`
    were a `private`, versus a `protected`, base class of `Queue`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Queue`有一个`protected`基类`LinkList`，`LinkList`的`public`接口对`Queue`及其后代，包括`PriorityQueue`，被认为是`protected`的，这样`LinkList`的*曾经公开*方法对`Queue`和`PriorityQueue`都是`protected`的。请注意，`PriorityQueue::PriorityEnqueue()`使用了`LinkList::InsertBeforeItem()`。如果`LinkList`是`Queue`的`private`基类而不是`protected`基类，这将是不可能的。
- en: 'With the class definitions and implementation in place, let’s continue with
    our `main()` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义和实现到位后，让我们继续我们的`main()`函数：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, in `main()`, we instantiate a `Queue`, namely `q1`, which utilizes the
    public interface of `Queue`. Note that `q1` may not use the *once public* interface
    of `LinkList`. The `Queue` may only behave like a `Queue`, not a `LinkList`. The
    ADT of `Queue` is preserved.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main()`中，我们实例化一个`Queue`，即`q1`，它使用`Queue`的公共接口。请注意，`q1`可能不会使用`LinkList`的*曾经公开*接口。`Queue`只能表现得像一个`Queue`，而不能像一个`LinkList`。`Queue`的ADT得到了保留。
- en: Finally, we instantiate a `PriorityQueue`, namely `q2`, which utilizes the public
    interface of both `Queue` and `PriorityQueue`, such as `Queue::Enqueue()` and
    `PriorityQueue::PriorityEnqueue()`, respectively. Because a `Queue` *Is-A* `PriorityQueue`
    (`Queue` is the `public` base class), the typical mechanics of inheritance are
    in place, allowing `PriorityQueue` to utilize the public interface of its ancestors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实例化一个`PriorityQueue`，即`q2`，它利用了`Queue`和`PriorityQueue`的公共接口，例如`Queue::Enqueue()`和`PriorityQueue::PriorityEnqueue()`。因为一个`Queue`*是*一个`PriorityQueue`（`Queue`是`public`基类），继承的典型机制就位，允许`PriorityQueue`利用其祖先的公共接口。
- en: 'The output for this example is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的输出如下：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we have seen two examples of using implementation inheritance; it is
    not an often-used feature of C++. However, you now understand `protected` or `private`
    base classes should you run across them in library code, application code that
    you are maintaining, or the rare opportunity in which this technique may prove
    useful for a programming task you may encounter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了使用实现继承的两个示例；这并不是C++中常用的特性。然而，你现在应该理解，如果你在库代码、你正在维护的应用代码中，或者在罕见的机会中，这种技术可能对你要遇到的编程任务有用，那么你会遇到`protected`或`private`基类。
- en: Optional uses for =default
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`=default`的可选用途'
- en: We have seen `=default` used in constructor and destructor prototypes to alleviate
    the user need to supply such method definitions. However, let’s recall some guidelines
    for when a constructor (or destructor) is provided for us automatically. In such
    cases, using `=default` with a constructor or destructor prototype will be more
    documentative in nature than a requirement; we will get the same system-supplied
    method in the absence of the `=default` prototype.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在构造函数和析构函数原型中使用`=default`来减轻用户提供此类方法定义的需求。然而，让我们回顾一下当构造函数（或析构函数）自动为我们提供时的一些指南。在这种情况下，使用构造函数或析构函数原型中的`=default`将具有更多文档性质，而不是要求；如果没有`=default`原型，我们将得到相同的系统提供的方法。
- en: Using an `=default` prototype is not necessary if the default constructor is
    the only constructor in a class; recall that you will get a system-supplied default
    constructor if a class has no constructors (to provide an interface to instantiate
    the class). Using `=default` with a default constructor prototype is crucial,
    however, if there are other constructors in the class (not including the copy
    constructor) and you want to maintain the default object creation (construction)
    interface. For the copy constructor, if the default system-supplied version is
    adequate, you will get this method regardless of whether you use an `=default`
    prototype or omit the prototype entirely. Likewise, with the destructor, if the
    system-supplied version is adequate, you will get this version linked in regardless
    of whether you use an `=default` prototype or omit the prototype altogether; the
    latter style is becoming more prevalent.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认构造函数是一个类中唯一的构造函数，则不需要使用`=default`原型；回想一下，如果一个类没有构造函数，你将得到一个系统提供的默认构造函数（以提供实例化类的接口）。然而，如果类中有其他构造函数（不包括复制构造函数），并且你想要保持默认对象创建（构造）接口，则使用默认构造函数原型中的`=default`是至关重要的。对于复制构造函数，如果你使用的是系统提供的默认版本，你将得到这个方法，无论你是否使用`=default`原型或完全省略原型。同样，对于析构函数，如果系统提供的版本足够好，你将得到这个版本，无论你是否使用`=default`原型或完全省略原型；后者风格越来越普遍。
- en: We have now covered the basic features of single inheritance in C++. Let’s quickly
    review what we’ve covered before moving to the next chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了C++中单继承的基本特性。在进入下一章之前，让我们快速回顾一下我们已经覆盖的内容。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have moved further along our journey with object-oriented
    programming. We have added additional OO concepts and terms, and have seen how
    C++ has direct language support for these concepts. We have seen how inheritance
    in C++ supports generalization and specialization. We have seen how to incrementally
    build a hierarchy of related classes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续我们的面向对象编程之旅。我们添加了额外的OO概念和术语，并看到了C++如何直接支持这些概念。我们已经看到了C++中的继承如何支持泛化和特殊化。我们已经看到了如何逐步构建相关类的层次结构。
- en: We have seen how to grow inheritance hierarchies using single inheritance, and
    how to access inherited data members and member functions. We have reviewed access
    regions to understand which inherited members may be directly accessed, based
    upon the access regions in which the members are defined in the base class. We
    know that having a `public` base class equates to defining an Is-A relationship,
    which supports the ideals of generalization and specialization, which is the most
    commonly used reason for inheritance.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用单继承来扩展继承层次结构，以及如何访问继承的数据成员和成员函数。我们已经回顾了访问区域，以了解哪些继承成员可以直接访问，这取决于成员在基类中定义的访问区域。我们知道，有一个`public`基类等同于定义了一个Is-A关系，这支持了泛化和特殊化的理念，这是继承最常用的原因。
- en: We have detailed the order of constructor and destructor invocations when instances
    of derived class types are instantiated and destroyed. We have seen the member
    initialization list to select which inherited constructor a derived class object
    may choose to utilize as part of its own construction (for its base class subobject).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细说明了在实例化和销毁派生类类型实例时构造函数和析构函数调用的顺序。我们看到了成员初始化列表，以选择派生类对象可能选择利用作为其自身构造（其基类子对象）的一部分的继承构造函数。
- en: We have seen how changing access labels in a base class list changes the OO
    meaning for the type of inheritance being used. By comparing `public` versus `private`
    and `protected` base classes, we now understand different types of hierarchies,
    such as those built to support Is-A relationships versus those built to support
    implementation inheritance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在基类列表中更改访问标签如何改变所使用的继承类型的面向对象意义。通过比较 `public` 与 `private` 和 `protected`
    基类，我们现在理解了不同类型的层次结构，例如那些用于支持 Is-A 关系与那些用于支持实现继承的层次结构。
- en: We have seen that base classes in our hierarchies may serve as potential building
    blocks for more specialized components, leading to potential reuse. Any potential
    reuse of existing code saves development time and cuts down on maintenance of
    otherwise duplicated code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在我们的层次结构中的基类可以作为更专用组件的潜在构建块，从而实现潜在的复用。任何现有代码的潜在复用都可以节省开发时间，并减少对其他重复代码的维护。
- en: Through extending our OOP knowledge, we have gained a preliminary set of skills
    relating to inheritance and hierarchy building in C++. With the basic mechanics
    of single inheritance under our belts, we can now move forward to learn about
    many more interesting object-oriented concepts and details relating to inheritance.
    Continuing to [*Chapter 7*](B19087_07.xhtml#_idTextAnchor366), *Utilizing Dynamic
    Binding through Polymorphism*, we will next learn how to dynamically bind methods
    to their respective operations in a hierarchy of related classes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们的面向对象（OOP）知识，我们已经获得了一组与 C++ 中的继承和层次结构构建相关的初步技能。在掌握了单继承的基本机制后，我们现在可以继续学习更多有关继承的有趣面向对象概念和细节。继续阅读[*第7章*](B19087_07.xhtml#_idTextAnchor366)，*通过多态利用动态绑定*，我们将接下来学习如何将方法动态绑定到相关类层次结构中的相应操作。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Using your [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes
    in Detail*, solution, create a C++ program to build an inheritance hierarchy,
    generalizing `Person` as a base class from the derived class of `Student`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 [*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类* 的解决方案，创建一个 C++ 程序来构建继承层次结构，将
    `Person` 作为基类从 `Student` 的派生类中泛化。
- en: Decide which data members and member functions of your `Student` class are more
    generic and would be better positioned in a `Person` class. Build your `Person`
    class with these members, including appropriate constructors (default, alternate,
    and copy), a destructor, access member functions, and a suitable public interface.
    Be sure to place your data members in the private access region.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你的 `Student` 类中哪些数据成员和成员函数更通用，并且更适合放在 `Person` 类中。使用这些成员构建你的 `Person` 类，包括适当的构造函数（默认、替代和复制）、析构函数、访问成员函数和合适的公共接口。务必将数据成员放在私有访问区域。
- en: Using a `public` base class, derive `Student` from `Person`. Remove members
    from `Student` that are now represented in `Person`. Adjust constructors and the
    destructor accordingly. Use the member initialization list to specify base class
    constructors as needed.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `public` 基类，从 `Person` 派生 `Student`。从 `Student` 中删除现在在 `Person` 中表示的成员。相应地调整构造函数和析构函数。根据需要使用成员初始化列表指定基类构造函数。
- en: Instantiate both `Student` and `Person` several times and utilize the appropriate
    `public` interfaces on each. Be sure to dynamically allocate several instances.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化多次 `Student` 和 `Person`，并利用每个的适当 `public` 接口。务必动态分配几个实例。
- en: Add a message using `cout` as the first line in each of your constructors and
    as the first line in your destructors so that you can see the construction and
    destruction order of each instance.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个构造函数和析构函数的第一行使用 `cout` 添加一条消息，以便您可以查看每个实例的构造和销毁顺序。
- en: (Optional) Complete the class hierarchy, which includes `LinkList`, `Queue`,
    and `PriorityQueue`, using the online code as a basis. Complete the remaining
    operations in the `LinkList` class, and call them as appropriate in the public
    interface of `Queue` and `PriorityQueue`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）使用在线代码作为基础，完成包括 `LinkList`、`Queue` 和 `PriorityQueue` 在内的类层次结构。完成 `LinkList`
    类中的剩余操作，并在 `Queue` 和 `PriorityQueue` 的公共接口中适当地调用它们。
- en: Be sure to add copy constructors for each class (or prototype them in the private
    access region or use `=delete` in the prototype to suppress copying if you truly
    do not want to allow copies).
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保为每个类添加复制构造函数（或者在私有访问区域中对其进行原型化，或者如果你确实不希望允许复制，在原型中使用 `=delete` 来抑制复制）。
- en: Instantiate `LinkList` using either constructor, then demonstrate how each of
    your operations works. Be sure to invoke `Print()` after adding or deleting an
    element.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任一构造函数实例化 `LinkList`，然后演示你的每个操作是如何工作的。确保在添加或删除元素后调用 `Print()`。
- en: Instantiate `Queue` and `PriorityQueue`, and demonstrate that each of the operations
    in their `public` interfaces works correctly. Remember to demonstrate the inherited
    operations in the `public` interface of `Queue` for instances of `PriorityQueue`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化 `Queue` 和 `PriorityQueue`，并演示它们 `public` 接口中的每个操作都能正确工作。请记住，对于 `PriorityQueue`
    的实例，也要演示 `Queue` 的 `public` 接口中继承的操作。
