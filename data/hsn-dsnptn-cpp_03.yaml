- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Memory and Ownership
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存与所有权
- en: Memory mismanagement is one of the most common problems in C++ programs. Many
    of these problems boil down to incorrect assumptions about which part of the code
    or which entity owns a particular memory. Then, we get memory leaks, accessing
    unallocated memory, excessive memory use, and other problems that are difficult
    to debug. Modern C++ has a set of memory ownership idioms that, taken together,
    allow the programmer to clearly express their design intent when it comes to memory
    ownership. This, in turn, makes it much easier to write code that correctly allocates,
    accesses, and deallocates memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理不当是C++程序中最常见的问题之一。许多这些问题归结为对代码的哪一部分或哪个实体拥有特定内存的错误假设。然后，我们得到内存泄漏、访问未分配的内存、过度使用内存和其他难以调试的问题。现代C++有一套内存所有权惯用法，当结合起来时，允许程序员在内存所有权方面清楚地表达他们的设计意图。这反过来又使得编写正确分配、访问和释放内存的代码变得容易得多。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: What is memory ownership and resource ownership?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是内存所有权和资源所有权？
- en: What are the characteristics of well-designed resource ownership? When and how
    should we be agnostic about resource ownership? How do we express exclusive memory
    ownership in C++?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀设计的资源所有权的特征是什么？何时以及如何对资源所有权保持无知？我们如何在C++中表达独占内存所有权？
- en: How do we express shared memory ownership in C++?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在C++中表达共享内存所有权？
- en: What is the cost of different memory ownership language constructs?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同内存所有权语言结构的成本是什么？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the C++ Core Guidelines at [https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md)找到C++核心指南。
- en: You can find the C++ **Guidelines Support Library** (**GSL**) at [https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL).
    Examples are available at [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/Microsoft/GSL](https://github.com/Microsoft/GSL)找到C++
    **指南支持库**（**GSL**）。示例可在[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter03)找到。
- en: What is memory ownership?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是内存所有权？
- en: In C++, the term *memory ownership* refers to the entity that is responsible
    for enforcing the lifetime of a particular memory allocation. In reality, we rarely
    talk about the ownership of raw memory. Usually, we manage the ownership and the
    lifetime of the objects that reside in said memory and memory ownership is really
    just shorthand for *object ownership*. The concept of memory ownership is closely
    tied to that of *resource ownership*. First of all, memory is a resource. It is
    not the only resource a program can manage, but it is by far the most commonly
    used one. Second, the C++ way of managing resources is to have objects own them.
    Thus, the problem of managing resources is reduced to the problem of managing
    the owning objects, which, as we just learned, is what we really mean when we
    talk about memory ownership. In this context, memory ownership is about owning
    more than memory, and mismanaged ownership can leak, miscount, or lose track of
    any resource that can be controlled by the program—memory, mutexes, files, database
    handles, cat videos, airline seat reservations, or nuclear warheads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，术语*内存所有权*指的是负责执行特定内存分配生命周期的实体。实际上，我们很少谈论原始内存的所有权。通常，我们管理驻留在该内存中的对象的所有权和生命周期，而内存所有权实际上只是*对象所有权*的简称。内存所有权的概念与*资源所有权*的概念紧密相关。首先，内存是一种资源。它不是程序可以管理的唯一资源，但它是迄今为止最常用的一个。其次，C++管理资源的方式是让对象拥有它们。因此，管理资源的问题简化为管理拥有对象的
    问题，正如我们刚刚学到的，这就是我们谈论内存所有权时真正所指的。在这种情况下，内存所有权不仅仅是关于拥有内存，管理不当的所有权可能会导致泄漏、误计或丢失任何程序可以控制的资源——内存、互斥锁、文件、数据库句柄、猫视频、航班座位预订或核弹头。
- en: Well-designed memory ownership
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优秀设计的内存所有权
- en: 'What does well-designed memory ownership look like? The naive answer that first
    comes up is that, at every point in the program, it is clear who owns which object.
    This, however, is overly constraining—most of the program does not deal with ownership
    of resources, including memory. These parts of the program merely use resources.
    When writing such code, it is sufficient to know that a particular function or
    class does not own the memory. It is completely irrelevant to know who does what:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的内存所有权看起来是什么样子？首先浮现出的朴素答案是，在程序的每个点上，都清楚谁拥有哪个对象。然而，这过于约束——程序的大部分内容并不处理资源的所有权，包括内存。这些程序部分仅仅使用资源。在编写此类代码时，知道特定的函数或类不拥有内存就足够了。知道谁做什么是完全无关紧要的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How about this, then—at every point in the program, is it clear who owns that
    object, or is it clear that the owner is not changing? This is better since most
    of the code will fall under the second part of our answer. However, it’s still
    too constraining—when taking ownership of an object, it is usually not important
    to know who it is taken from:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这样呢——在程序的每个点上，是否清楚谁拥有那个对象，或者是否清楚所有者没有改变？这更好，因为大部分代码将属于我们答案的第二部分。然而，这仍然过于约束——在获取对象所有权时，通常并不重要知道它是从哪里获取的：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, the whole point of shared ownership (expressed through the reference-counted
    `std::shared_ptr`) is that we don’t need to know who else owns the object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，共享所有权的全部意义（通过引用计数的`std::shared_ptr`表达）是我们不需要知道谁还拥有该对象：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A more accurate description of well-designed memory ownership takes more than
    one quoted sentence. Generally, the following are the attributes of good memory
    ownership practices:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对设计良好的内存所有权的更准确描述需要不止一句话。一般来说，以下是一些良好的内存所有权实践的特征：
- en: If a function or a class does not alter memory ownership in any way, this should
    be clear to every client of this function or class, as well as the implementer.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数或类以任何方式不改变内存所有权，这一点应该对每个函数或类的客户端以及实现者都是清晰的。
- en: If a function or a class takes exclusive ownership of some of the objects passed
    to it, this should be clear to the client (we assume that the implementer knows
    this already since they have to write the code).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数或类独占拥有传递给它的某些对象，这一点应该对客户端是清晰的（我们假设实现者已经知道这一点，因为他们必须编写代码）。
- en: If a function or a class shares ownership of an object passed to it, this should
    be clear to the client (or anyone who reads the client code, for that matter).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数或类与它传递的对象共享所有权，这一点应该对客户端（或者任何阅读客户端代码的人）是清晰的。
- en: For every object that is created, for every unit of code where it’s used, it
    is clear whether this code is expected to delete the object or not.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个创建的对象，对于每个使用它的代码单元，都清楚这段代码是否预期删除该对象。
- en: Poorly designed memory ownership
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计不良的内存所有权
- en: Just as good memory ownership defies a simple description and instead is characterized
    by a set of criteria it satisfies, so can bad memory ownership practices be recognized
    by their common manifestations. In general, where a good design makes it clear
    whether a particular piece of code owns a resource or not, a bad design requires
    additional knowledge that cannot be deduced from the context. For example, who
    owns the object returned by the following `MakeWidget()` function?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如良好的内存所有权无法用简单的描述来概括，而是通过它满足的一系列标准来定义一样，不良的内存所有权实践也可以通过它们的共同表现来识别。一般来说，良好的设计使代码是否拥有资源变得清晰，而糟糕的设计则需要额外的知识，这些知识不能从上下文中推断出来。例如，以下`MakeWidget()`函数返回的对象由谁拥有？
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Is the client expected to delete the widget when it’s no longer needed? If
    yes, how should it be deleted? If we decide to delete the widget and do it in
    the wrong way, for example, by calling `operator delete` on a widget that was
    not, in fact, allocated by `operator new`, memory corruption will certainly result.
    In the best-case scenario, the program will just crash:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 客户是否需要在不再需要时删除小部件？如果是，应该如何删除？如果我们决定删除小部件并以错误的方式执行，例如，在实际上没有通过`operator new`分配的小部件上调用`operator
    delete`，则肯定会发生内存损坏。在最佳情况下，程序将只是崩溃：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Does the Factory own the widgets it created? Will it delete them when the Factory
    object is deleted? Alternatively, is the client expected to do that? If we decide
    that the Factory probably knows what it created and will delete all such objects
    in due time, we may end up with a memory leak (or worse, if the objects owned
    some other resources):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是否拥有它创建的小部件？当工厂对象被删除时，它会删除它们吗？或者，客户端被期望去做这件事？如果我们决定工厂可能知道它创建了什么，并且将在适当的时候删除所有这样的对象，我们可能会遇到内存泄漏（或者更糟，如果对象拥有其他资源）：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Does `Transmogrify()` take ownership of the widget? Is the `w` widget still
    around after `Transmogrify()` is done with it? If the widget is deleted to construct
    a new, transmogrified, `w1` widget, we now have a dangling pointer. If the widget
    is not deleted, but we assume it might be, we have a memory leak.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transmogrify()` 是否拥有小部件的所有权？在 `Transmogrify()` 完成对小部件的处理后，`w` 小部件是否仍然存在？如果为了构建一个新的、经过转换的
    `w1` 小部件而删除了小部件，我们现在有一个悬垂指针。如果我们没有删除小部件，但假设它可能被删除，我们就有了一个内存泄漏。'
- en: 'Lest you think that all bad memory management practices can be recognized by
    the presence of raw pointers somewhere, here is an example of a rather poor approach
    to memory management that often arises as a knee-jerk response to the problems
    caused by the use of raw pointers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不要以为所有糟糕的内存管理实践都可以通过存在原始指针来识别，这里有一个关于内存管理的较差方法的例子，这种做法通常是对使用原始指针造成的问题的一种本能反应：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Double()` function is claiming in its interface that it takes shared ownership
    of the vector. However, that ownership is entirely gratuitous—there is no reason
    for `Double()` to own its argument—it does not attempt to extend its lifetime
    and, it does not transfer ownership to anyone else; it merely modifies a vector
    passed in by the caller. We can reasonably expect that the caller owns the vector
    (or that somebody else even higher in the call stack does), and that the vector
    will still be around when `Double()` returns control to the caller—after all,
    the caller wanted us to double the elements, presumably so that they can do something
    else with them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Double()` 函数在其接口中声称它对向量拥有共享所有权。然而，这种所有权完全是多余的——`Double()` 没有必要拥有其参数——它不试图延长其生命周期，也不将所有权转让给任何人；它只是修改了调用者传入的向量。我们可以合理地期望调用者拥有该向量（或者甚至更高层次的调用栈中的某人拥有），并且当
    `Double()` 将控制权返回给调用者时，向量仍然存在——毕竟，调用者希望我们将元素加倍，可能以便进行其他操作。'
- en: While this list is hardly complete, it serves to demonstrate the spectrum of
    problems that can be caused by a slap-dash approach to memory ownership. In the
    next section, we review the patterns and guidelines developed by the C++ community
    to help to avoid these problems and express the programmer’s intent clearly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个列表远非完整，但它有助于展示由于对内存所有权的草率处理可能引起的问题范围。在下一节中，我们将回顾 C++ 社区开发的模式和指南，以帮助避免这些问题并清楚地表达程序员的意图。
- en: Expressing memory ownership in C++
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中表达内存所有权
- en: Throughout its history, the C++ language has evolved in its approach to expressing
    memory ownership. The same syntactic constructs have been, at times, imbued with
    different assumed semantics. This evolution was partially driven by new features
    added to the language (it’s hard to talk about shared memory ownership if you
    don’t have any shared pointers). On the other hand, most of the memory management
    tools added in C++ 11 and later were not new ideas or new concepts. The notion
    of a shared pointer has been around for a long time. This language support makes
    it easier to implement one (and having a shared pointer in the standard library
    makes most custom implementations unnecessary), but shared pointers were used
    in C++ long before C++ 11 added them to the standard. The more important change
    that has occurred was the evolution of the understanding of the C++ community
    and the emergence of common practices and idioms. It is in this sense, as a set
    of conventions and semantics commonly associated with different syntactic features,
    that we can talk about the set of memory management practices as a design pattern
    of the C++ language. Let’s now learn the different ways that we can express different
    types of memory ownership.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在其历史发展过程中，C++语言在表达内存所有权方面的方法不断演变。有时，相同的语法结构被赋予了不同的假设语义。这种演变部分是由语言中添加的新特性所驱动的（如果没有共享指针，就很难谈论共享内存所有权）。另一方面，C++11及以后版本中添加的大多数内存管理工具并非新想法或新概念。共享指针的概念已经存在很长时间了。这种语言支持使得实现它变得更加容易（并且标准库中的共享指针使得大多数自定义实现变得不必要），但共享指针在C++11将其添加到标准之前就已经在C++中使用。更为重要的变化是C++社区对内存所有权的理解演变，以及共同实践和习惯用法的出现。正是在这个意义上，作为与不同语法特征相关联的一组惯例和语义，我们可以将内存管理实践视为C++语言的设计模式。现在，让我们学习可以表达不同类型内存所有权的不同方法。
- en: Expressing non-ownership
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达非拥有权
- en: Let’s start with the most common kind of memory ownership. Most code does not
    allocate, deallocate, construct, or delete. It just does its work on objects that
    were created by someone else earlier and will be deleted by someone else later.
    How do you express the notion that a function is going to operate on an object
    but will not attempt to delete it or, conversely, extend its lifetime past the
    completion of the function itself?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最常见的内存所有权类型开始。大多数代码并不分配、释放、构造或删除。它只是在由他人先前创建并由他人稍后删除的对象上执行其工作。你如何表达一个函数将要操作一个对象，但不会尝试删除它，或者相反，在函数本身完成之后延长其生命周期的概念？
- en: 'Very easily, in fact, and every C++ programmer has done it many times:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上非常简单，每个C++程序员都多次这样做：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In a well-written program, a function with a raw pointer parameter signals
    that it is not involved with the ownership of the corresponding object in any
    way; the same goes for references. Similarly, a class that contains a member function
    pointer refers to an object but expects someone else to own it and manage its
    lifetime. Note that the destructor of the `WidgetProcessor` class in the next
    example does not delete the object the class points to – this is a sure sign that
    we refuse ownership of that object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个编写良好的程序中，具有原始指针参数的函数表明它以任何方式都不参与相应对象的拥有权；引用也是同样的情况。同样，包含成员函数指针的类引用一个对象，但期望其他人拥有它并管理其生命周期。请注意，下一个示例中`WidgetProcessor`类的析构函数不会删除该类所指向的对象——这是我们不拥有该对象的明确标志：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Non-owning access to an object should be granted by using raw pointers or references.
    Yes—even in C++ 14, with all its smart pointers, there is a place for raw pointers.
    Not only that but in the bulk of the code, the majority of pointers will be raw
    pointers—all the non-owning ones (as we will see in the next section, C++17 and
    C++20 take this point much further).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过使用原始指针或引用来授予对对象的非拥有访问权限。是的——即使在C++14中，尽管它拥有所有智能指针，原始指针也有其位置。不仅如此，在大量代码中，大多数指针将是原始指针——所有非拥有指针（正如我们将在下一节中看到的，C++17和C++20在这方面走得更远）。
- en: You might reasonably point out at this time that the preceding example of recommended
    practices for granting non-owning access looks exactly like one of the examples
    of bad practices shown earlier. The distinction is in the context—in a well-designed
    program, only non-owning access is granted through raw pointers and references.
    Actual ownership is always expressed in some other way. Thus, it is clear that
    when a raw pointer is encountered, the function or class is not going to mess
    with the ownership of the object in any way. This, of course, creates some confusion
    when it comes to converting old legacy code, with raw pointers everywhere, to
    modern practices. As a matter of clarity, it is recommended to convert such code
    one part at a time, with clearly indicated transitions between code that follows
    the modern guidelines and code that does not.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这个时候合理地指出，前面推荐的授予非拥有访问权的示例看起来与之前展示的坏习惯示例之一完全一样。区别在于上下文——在一个设计良好的程序中，只有非拥有访问权是通过原始指针和引用授予的。实际的所有权总是以某种其他方式表达。因此，当遇到原始指针时，函数或类不会以任何方式干涉对象的所有权。当然，这会在将带有原始指针的旧遗产代码转换为现代实践时造成一些混淆。为了清晰起见，建议一次转换一部分代码，并在遵循现代指南的代码和不遵循的代码之间清楚地标明过渡。
- en: Another issue to discuss here is the use of pointers versus references. As a
    matter of syntax, the reference is basically a pointer that is never null and
    cannot be left uninitialized. It is tempting to adopt a convention that any pointer
    passed to a function may be null and must, therefore, be checked, and any function
    that cannot accept a null pointer must instead take a reference. It is a good
    convention and widely used, but not widely enough to be considered an accepted
    design pattern. Perhaps in recognition of this, the C++ Core Guidelines library
    offers an alternative for expressing non-null pointers—`not_null<T*>`. Note that
    this is not a part of the language itself, but can be implemented in standard
    C++ without any language extension.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要讨论的问题是指针与引用的使用。就语法而言，引用基本上是一个永远不会为空的指针，并且不能被未初始化。采用一种约定，任何传递给函数的指针都可能为空，因此必须进行检查，任何不能接受空指针的函数必须改为接受引用。这是一个好习惯，并且被广泛使用，但使用得还不够广泛，以至于可以被视为一个接受的设计模式。也许是为了认识到这一点，C++
    Core Guidelines 库提供了一个表达非空指针的替代方案——`not_null<T*>`。请注意，这本身不是语言的一部分，但可以在标准 C++ 中实现，而不需要任何语言扩展。
- en: Expressing exclusive ownership
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达独占所有权
- en: 'The second most common type of ownership is exclusive ownership—the code creates
    an object and will delete it later. The task of deletion will not be delegated
    to someone else, and no extension of the lifetime of the object is permitted.
    This type of memory ownership is so common that we do it all the time without
    even thinking about it:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种最常见的所有权类型是独占所有权——代码创建一个对象，稍后会删除它。删除任务不会被委托给其他人，并且不允许对象寿命的扩展。这种内存所有权如此常见，以至于我们经常这样做，甚至没有意识到：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All local (stack) variables express unique memory ownership! Note that ownership
    in this context does not mean that someone else will not modify the object. It
    merely means that when the creator of the `w` widget—the `DoWork()` function,
    in our case—decides to delete it; the deletion will succeed (nobody has deleted
    it already) and the object will actually be deleted (nobody attempted to keep
    the object alive after the end of its scope).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有局部（栈）变量都表达独特的内存所有权！请注意，在这个上下文中，“所有权”并不意味着其他人不会修改该对象。它仅仅意味着当`w`小部件的创建者——在我们的例子中是`DoWork()`函数——决定删除它时；删除将成功（还没有人删除它）并且对象实际上将被删除（没有人试图在作用域结束时保持对象存活）。
- en: 'This is the oldest way to construct an object in C++, and it’s still the best
    one. If a stack variable does what you need, use it. C++ 11 provides another way
    to express unique ownership, and it is mainly used in cases where an object cannot
    be created on the stack but must be allocated on the heap. Heap allocation often
    happens when ownership is shared or transferred—after all, the stack-allocated
    object will be deleted at the end of the containing scope; there is no way around
    it. If we need to keep the object alive for longer, it has to be allocated somewhere
    else. The other reason to create objects on the heap is that the size or type
    of the object may not be known at compile time. This usually happens when the
    object is polymorphic—a derived object is created, but the base class pointer
    is used. Whatever the reason for not allocating objects on the stack, we have
    a way of expressing the exclusive ownership of such objects using `std::unique_ptr`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 C++ 中构建对象的最古老方式，但仍然是最好的方式。如果栈变量能满足你的需求，就使用它。C++ 11 提供了另一种表达独家所有权的方法，它主要用在对象不能在栈上创建而必须分配在堆上的情况下。堆分配通常发生在所有权共享或转移时——毕竟，栈分配的对象将在包含作用域的末尾被删除；这是无法避免的。如果我们需要让对象存活更长时间，它必须分配在其他地方。创建对象在堆上的另一个原因是对象的大小或类型可能在编译时未知。这通常发生在对象是多态的情况下——创建了一个派生对象，但使用了基类指针。无论不分配对象在栈上的原因是什么，我们都有一种方法可以使用
    `std::unique_ptr` 来表达这种对象的独家所有权：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also a technical reason why you may have to construct objects on the
    heap even when a stack-allocated object seems sufficient: the stack size is quite
    limited, usually anywhere between 2 MB and 10 MB. That is the space for all stack
    allocations in one thread, and when it is exceeded, the program crashes. A large
    enough object can exhaust the stack space or push it too close to the limit for
    subsequent allocations. Such objects must be created on the heap and owned by
    stack-allocated unique pointers or other resource-owning objects.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个技术原因，即使栈分配的对象似乎足够用，你也可能需要在堆上构建对象：栈的大小相当有限，通常在 2 MB 到 10 MB 之间。这是单个线程中所有栈分配的空间，当它超过这个限制时，程序会崩溃。足够大的对象可能会耗尽栈空间，或者将其推得太接近限制，以至于后续的分配无法进行。这样的对象必须创建在堆上，并由栈分配的唯一指针或其他资源拥有对象拥有。
- en: What if the way to create an object is more complex than just `operator new`,
    and we need a Factory function? That is the type of ownership we will consider
    next.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建对象的方式比仅仅使用 `operator new` 更复杂，我们需要一个工厂函数？这就是我们将考虑的类型的所有权。
- en: Expressing transfer of exclusive ownership
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达独家所有权的转移
- en: 'In the preceding example, a new object was created and immediately bound to
    a unique pointer, `std::unique_ptr`, which guarantees exclusive ownership. The
    client code looks exactly the same if the object is created by a Factory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，创建了一个新的对象，并立即将其绑定到一个唯一的指针，`std::unique_ptr`，这保证了独家所有权。如果对象是由工厂创建的，客户端代码看起来完全一样：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But what should the Factory function return? It could certainly return a raw
    pointer, `Widget*`. After all, that is what `new` returns. But this opens the
    way to incorrect use of `WidgetFactory`—for example, instead of capturing the
    returned raw pointer in a unique pointer, we could pass it to a function such
    as `Transmogrify` that takes a raw pointer because it does not deal with the ownership.
    Now, nobody owns the widget, and it ends up as a memory leak. Ideally, `WidgetFactory`
    would be written in a way that would force the caller to take ownership of the
    returned object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但工厂函数应该返回什么？它当然可以返回一个原始指针，`Widget*`。毕竟，这就是 `new` 返回的内容。但这为错误使用 `WidgetFactory`
    开辟了道路——例如，我们可能不会在唯一指针中捕获返回的原始指针，而是将其传递给一个像 `Transmogrify` 这样的函数，该函数接受原始指针因为它不处理所有权。现在，没有人拥有小部件，最终导致内存泄漏。理想情况下，`WidgetFactory`
    应该被编写成强制调用者接收返回对象的拥有权。
- en: 'What we need here is an ownership transfer—`WidgetFactory` is certainly an
    exclusive owner of the object it constructs, but at some point, it needs to hand
    off that ownership to a new, also exclusive, owner. The code to do so is very
    simple:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要的是所有权转移——`WidgetFactory` 当然是它所构建的对象的独家所有者，但在某个时候，它需要将所有权转交给一个新的、也是独家所有者。执行此操作的代码非常简单：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works exactly the way we want it to, but why? Doesn’t the unique pointer
    provide exclusive ownership? The answer is, it does, but it is also a movable
    object (it has a move constructor). Moving the content of a unique pointer into
    another one transfers the ownership of the object; the original pointer is left
    in the moved-from state (its destruction will not delete any objects). What is
    so good about this idiom? It clearly expresses, and forces at compile time, that
    the Factory expects the caller to take exclusive (or shared) ownership of the
    object. For example, the following code, which would have left the new widget
    with no owner, does not compile:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的方式，但为什么？难道唯一指针不提供独占所有权吗？答案是，它确实提供了，但它也是一个可移动对象（它有一个移动构造函数）。将唯一指针的内容移动到另一个唯一指针中会转移对象的所有权；原始指针将留在移动前的状态（它的销毁不会删除任何对象）。这种习语有什么好处呢？它清楚地表达了，并在编译时强制要求，工厂期望调用者对对象拥有独占（或共享）所有权。例如，以下代码，它会导致新的小部件没有所有者，无法编译：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, how do we call `Transmogrify()` on a widget after we properly assumed ownership?
    This is still done with a raw pointer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在我们正确假定所有权之后，我们如何调用`Transmogrify()`函数呢？这仍然是通过原始指针来完成的：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But what about the stack variables? Can exclusive ownership be transferred
    to someone else before the variable is destroyed? This is going to be slightly
    more complicated—the memory for the object is allocated on the stack and is going
    away, so some amount of copying is involved. Exactly how much copying depends
    on whether the object is movable. Moving, in general, transfers the ownership
    from the moved-from object to the moved-to one. This can be used for return values
    but is more often used for passing arguments to functions that take exclusive
    ownership. Such functions must be declared to take the parameters by the `rvalue`
    reference `T&&`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但栈变量怎么办？在变量被销毁之前，所有权能否转移到其他人那里？这将会稍微复杂一些——对象的内存是在栈上分配的，并且正在消失，因此涉及到一些复制操作。确切需要复制的量取决于对象是否可移动。一般来说，移动操作会将所有权从被移动的对象转移到移动到的对象。这可以用于返回值，但更常用于传递参数给需要独占所有权的函数。这些函数必须声明为通过`rvalue`引用`T&&`来接受参数：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the caller must explicitly give up ownership by wrapping the argument
    in `std::move`. This is one of the advantages of this idiom; without it, an ownership-transferring
    call would look exactly the same as a regular call.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用者必须通过将参数包裹在`std::move`中来显式放弃所有权。这是这种习语的优点之一；没有它，所有权转移的调用将看起来与普通调用完全相同。
- en: Expressing shared ownership
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达共享所有权
- en: The last type of ownership we need to cover is shared ownership, where multiple
    entities own the object equally. First, a word of caution—shared ownership is
    often misused, or over-used. Consider the preceding example, where a function
    was passed a shared pointer to an object it did not need to own. It is tempting
    to let the reference counting deal with the ownership of objects and *not worry
    about deletion*. However, this is often a sign of poor design. In most systems,
    at some level, there is clear ownership of resources, and this should be reflected
    in the chosen design of resource management. The *not worry about deletion* concern
    remains valid; explicit deletion of objects should be rare, but automatic deletion
    does not require shared ownership, merely a clearly expressed one (unique pointers,
    data members, and containers provide automatic deletion just as well).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要覆盖的最后一种所有权类型是共享所有权，其中多个实体平等地拥有该对象。首先，提醒一下——共享所有权经常被误用，或者过度使用。考虑前面的例子，其中函数传递了一个它不需要拥有的对象的共享指针。让引用计数处理对象的所有权并且*不担心删除*是很诱人的。然而，这通常是设计不佳的迹象。在大多数系统中，在某个层面上，资源有明确的归属，并且这一点应该反映在资源管理的选择设计中。*不担心删除*的担忧仍然有效；显式删除对象应该是罕见的，但自动删除不需要共享所有权，只需要明确表达的所有权（唯一指针、数据成员和容器同样可以提供自动删除）。
- en: That being said, there are definite cases for shared ownership. The most common
    valid applications of shared ownership are at a low level, inside data structures
    such as lists, trees, and more. A data element may be owned by other nodes of
    the same data structure, by any number of iterators currently pointing to it,
    and, possibly by some temporary variables inside data structure member functions
    that operate on the entire structure or a part of it (such as rebalancing a tree).
    The ownership of the entire data structure is usually clear in a well-thought-out
    design. But the ownership of each node, or data element, may be truly shared in
    the sense that any owner is equal to any other; none is privileged or primary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，共享所有权确实有一些明确的用例。共享所有权最常见的有效应用是在底层，例如在列表、树等数据结构内部。一个数据元素可能被同一数据结构的其他节点拥有，也可能被任何数量的当前指向它的迭代器拥有，还可能是由操作整个结构或其一部分（例如树的重新平衡）的数据结构成员函数中的某些临时变量拥有。在精心设计的情况下，整个数据结构的所有权通常是明确的。但每个节点或数据元素的所有权在真正意义上可能是共享的，即任何所有者都等同于其他所有者；没有一个是特权或主要的。
- en: 'In C++, the notion of shared ownership is expressed through a shared pointer,
    `std::shared_ptr`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，共享所有权的概念通过共享指针`std::shared_ptr`来表示：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The advantage of this design is that a list element that was unlinked from the
    list remains alive for as long as there is a way to access it through an iterator.
    This is not the way `std::list` is done, and it does not provide such guarantees
    (deleting a `std::list` object invalidates all iterators). Note that the doubly
    linked list of shared pointers makes it so any two consecutive nodes in the list
    own each other and neither is deleted even when the list head is deleted; this
    leaks the owned objects. For this reason, a real design would likely use `std::weak_pointer`
    for one of `next` or `prev`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的优点是，从列表中解除链接的列表元素只要存在一种通过迭代器访问它的方式就会保持活跃。这并不是`std::list`的做法，它不提供这样的保证（删除`std::list`对象会使所有迭代器失效）。请注意，共享指针的双向链表使得列表中任何两个连续的节点都相互拥有对方，即使列表头被删除，它们也不会被删除；这会导致拥有的对象泄漏。因此，实际的设计可能会使用`std::weak_pointer`作为`next`或`prev`之一。
- en: Such complications aside, this may be a valid design for certain applications
    where the iterators need to own the data they refer to even after the list is
    deleted or some elements are erased from the list. One example is a thread-safe
    list, where it is very difficult to guarantee that one thread does not erase a
    list element while another still has an iterator pointing to it. Note that this
    particular application would also require atomic shared pointers, which are only
    available in C++ 20 (or you can write your own using C++ 11).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些复杂性之外，这可能是一些应用程序的有效设计，在这些应用程序中，迭代器需要在列表被删除或某些元素从列表中删除后仍然拥有它们所引用的数据。一个例子是线程安全的列表，在这种情况下，很难保证一个线程不会在另一个线程仍然有一个指向它的迭代器时删除列表元素。请注意，这个特定的应用程序还需要原子共享指针，这些指针仅在C++
    20中可用（或者你可以使用C++ 11编写自己的）。
- en: Now, what about functions taking shared pointers as parameters? In a program
    that follows good memory ownership practices, such a function conveys to the caller
    that it intends to take partial ownership that lasts longer than the function
    call itself—a copy of the shared pointer will be created. In the concurrent context,
    it may also indicate that the function needs to protect the object from deletion
    by another thread for at least as long as it’s executing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于接受共享指针作为参数的函数呢？在一个遵循良好内存所有权实践的程序中，这样的函数会向调用者传达它打算获取比函数调用本身持续时间更长的部分所有权——将创建共享指针的副本。在并发环境中，这也可能表明函数需要保护对象免受另一个线程删除，至少在它执行期间。
- en: There are several disadvantages to shared ownership that you must keep in mind.
    The best-known one is the bane of shared pointers, that is, the circular dependency.
    If two objects with shared pointers point to each other, the entire pair remains
    *in use* indefinitely. C++ offers a solution to that in the form of `std::weak_ptr`,
    a counterpart to the shared pointer that provides a safe pointer to an object
    that may have already been deleted. If the previously mentioned pair of objects
    uses one shared and one weak pointer, the circular dependency is broken.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 共享所有权的几个缺点你必须牢记在心。最著名的一个是共享指针的祸害，即循环依赖。如果两个具有共享指针的对象相互指向对方，整个对将无限期地保持*使用状态*。C++通过`std::weak_ptr`的形式提供了一个解决方案，它是共享指针的对应物，提供了一个指向可能已经被删除的对象的安全指针。如果前面提到的对象对使用了一个共享指针和一个弱指针，循环依赖就会被打破。
- en: The circular dependency problem is real, but it happens more often in designs
    where shared ownership is used to conceal the larger problem of unclear resource
    ownership. However, there are other downsides to shared ownership. The performance
    of a shared pointer is always going to be lower than that of a raw pointer. On
    the other hand, a unique pointer can be just as efficient as a raw pointer (and
    in fact, `std::unique_ptr` is). When the shared pointer is first created, an additional
    memory allocation for the reference count must take place.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖问题确实是存在的，但它更常出现在使用共享所有权来掩盖资源所有权不明确这一更大问题的设计中。然而，共享所有权还有其他缺点。共享指针的性能始终会低于原始指针。另一方面，唯一指针可以与原始指针一样高效（实际上，`std::unique_ptr`
    就是）。当共享指针首次创建时，必须进行额外的内存分配来存储引用计数。
- en: In C++ 11, `std::make_shared` can be used to combine the allocations for the
    object itself and the reference counter, but this implies that the object is created
    with the intent to share (often, the object Factory returns unique pointers, some
    of which are later converted to shared pointers). Copying or deleting a shared
    pointer must also increment or decrement the reference counter. Shared pointers
    are often attractive in concurrent data structures, where, at least at the low
    level, the notion of ownership may indeed be fuzzy, with several accesses to the
    same object happening at the same time. However, designing a shared pointer to
    be thread-safe in all contexts is not easy and carries additional runtime overhead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中，可以使用 `std::make_shared` 来结合对象本身的分配和引用计数器的分配，但这意味着对象是带有共享意图创建的（通常，对象工厂返回的是唯一指针，其中一些后来被转换为共享指针）。复制或删除共享指针时，也必须增加或减少引用计数器。共享指针在并发数据结构中通常很有吸引力，在这些数据结构中，至少在低级别上，所有权的概念可能确实模糊，同时有多个访问同一对象的情况发生。然而，设计一个在所有上下文中都线程安全的共享指针并不容易，并且会带来额外的运行时开销。
- en: So far, we have mostly restricted ourselves to pointers as means of owning objects
    (and their memory and other resources). Non-ownership has been similarly expressed
    through raw pointers and references or simple non-owning pointers. However, this
    is not the only way to own resources (and we did mention that the most common
    form of exclusive ownership is a stack variable). We are now going to see how
    resource-owning objects can be used directly to express both ownership and non-ownership.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要将指针作为拥有对象（及其内存和其他资源）的手段（非拥有性也通过原始指针和引用或简单的非拥有性指针来表示）。然而，这并不是拥有资源的唯一方式（我们之前也提到，最常见的独占拥有形式是栈变量）。现在我们将看到如何直接使用拥有资源的对象来表示拥有性和非拥有性。
- en: Owning objects and views
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有对象和视图
- en: 'C++ has not been limited to owning pointers since its creation: any object
    can own resources, and we already mentioned that the simplest way to express exclusive
    ownership is to create a local variable on the stack. Of course, any of such objects
    can also be owned by a pointer (unique or shared) and when non-owning access is
    desired, these objects are commonly accessed through raw pointers or references.
    However, in C++17 and C++20 a different pattern has emerged, and it is worth exploring.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 自创建以来并未局限于拥有指针：任何对象都可以拥有资源，我们之前也提到，表达独占所有权的最简单方式是在栈上创建一个局部变量。当然，这样的对象也可以被指针（唯一或共享）拥有，当需要非拥有性访问时，这些对象通常通过原始指针或引用来访问。然而，在
    C++17 和 C++20 中出现了一种不同的模式，这值得探索。
- en: Resource-owning objects
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥有资源的对象
- en: Every C++ programmer is familiar with resource-owning objects; perhaps the most
    common one is `std::string` – an object that owns a character string. Of course,
    it also has a lot of specialized member functions for operating on strings, but
    from the point of view of memory ownership, `std::string` is essentially an owning
    `char*` pointer. Similarly, `std::vector` is an owning object for an array of
    objects of arbitrary type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个熟悉 C++ 的程序员都熟悉拥有资源的对象；可能最常见的一个是 `std::string` – 一个拥有字符字符串的对象。当然，它也有许多专门的操作字符串的成员函数，但从内存所有权的角度来看，`std::string`
    实质上是一个拥有 `char*` 指针。同样，`std::vector` 是任意类型对象数组的拥有对象。
- en: 'The most common way to construct such objects is either as local variables
    or as data members of a class. In the latter case, the issue of who owns the entire
    class is managed elsewhere, but, within the class, all data members are owned
    exclusively by the object itself. Consider this simple example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此类对象最常见的方式是作为局部变量或作为类的数据成员。在后一种情况下，整个类的所有权问题由其他地方管理，但在类内部，所有数据成员都由对象本身独占拥有。考虑这个简单的例子：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So far, we have not said anything new compared to the section on exclusive
    ownership just a few pages earlier in this chapter. However, we have subtly changed
    the focus from owning pointers to owning objects. As long as we focus on the ownership
    aspect, these objects are essentially specialized owning (unique) pointers. There
    is an important difference, however: most such objects convey additional information,
    such as the length of the string for `std::string` or the size of the array for
    `std::vector`. Keep this in mind: it is going to come up again when we get to
    the changes brought by C++17/20.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，与本章前面几页关于独占所有权的部分相比，我们并没有说出任何新的内容。然而，我们已经微妙地将焦点从拥有指针转变为拥有对象。只要我们关注所有权方面，这些对象本质上就是专门的拥有（唯一）指针。然而，有一个重要的区别：大多数这样的对象会传递额外的信息，例如`std::string`的字符串长度或`std::vector`的数组大小。请记住：当我们到达C++17/20带来的变化时，这个问题还会再次出现。
- en: 'While resource-owning objects have been around since the beginning of C++,
    they themselves have been often owned through pointers. There are, perhaps, two
    main reasons for this; both have been rendered obsolete by C++ advances. The first
    reason to own, for example, a string via an owning pointer is the need to transfer
    ownership. A stack object is destroyed at the end of the scope. A class data member
    is destroyed when the object is destroyed. In either case, there is no way to
    transfer the ownership of the object itself, such as `std::string`, to someone
    else. However, if we focus on the ownership aspect, then the string object itself
    is just a (decorated) owning pointer, and the goal is to transfer the ownership
    of the underlying resource (the character string for `std::string`) to another
    owner. When we put it this way, the answer is obvious: since C++11, the string
    has move semantics, and moving a string is barely more expensive than moving a
    pointer (remember, the string is an owning pointer that also knows the length,
    so that has to be moved too).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然资源拥有对象自C++开始以来就存在，但它们自身通常是通过指针拥有的。可能有两个主要原因；这两个原因都已被C++的进步所淘汰。例如，通过拥有指针拥有字符串的第一个原因是需要转移所有权。栈对象在作用域结束时被销毁。类数据成员在对象被销毁时被销毁。在两种情况下，都没有办法将对象本身的所有权（例如`std::string`）转移到其他人。然而，如果我们关注所有权方面，那么字符串对象本身就是一个（装饰过的）拥有指针，目标是把底层资源（`std::string`的字符字符串）的所有权转移到另一个所有者。当我们这样表述时，答案很明显：自C++11以来，字符串有了移动语义，移动字符串几乎和移动指针一样便宜（记住，字符串是一个知道长度的拥有指针，所以长度也必须移动）。
- en: 'We can say, more generally, that there is no reason to own a cheap-to-move
    owning object via a pointer if the only reason is ownership transfer. For example,
    consider this string builder class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更普遍地说，如果唯一的原因是所有权转移，就没有必要通过指针拥有一个易于移动的所有权对象。例如，考虑这个字符串构建器类：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While it gets the job done, a much better way to write the same class is to
    simply move the string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做可以完成任务，但编写相同类的更好方法是简单地移动字符串：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The same is true for factories that construct owning cheap-to-move objects.
    Instead of returning them via `std::unique_ptr`, the factory can return the object
    itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建拥有易于移动对象的工厂来说，也是如此。工厂不是通过`std::unique_ptr`返回它们，而是可以直接返回对象本身：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The return value may benefit from the return-value optimization (the compiler
    constructs the return value directly in the memory allocated for the final object,
    `my_string`). But even without this optimization, we have a guarantee that there
    is no copying of the string here, only moving (if this move is optimized away,
    the optimization is sometimes called **move elision**, similar to the better-known
    **copy elision**, which optimizes away copy constructors).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值可能受益于返回值优化（编译器直接在为最终对象`my_string`分配的内存中构造返回值）。即使没有这种优化，我们也有保证这里没有复制字符串，只有移动（如果这个移动被优化掉，这种优化有时被称为**移动省略**，类似于更为人所知的**复制省略**，它优化掉了复制构造函数）。
- en: 'The second reason to use owning pointers for resource-owning objects is that
    the object’s existence itself may be conditional:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有权指针来处理资源拥有对象的第二个原因是对象的存在本身可能是条件性的：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In many cases, an “*empty*” object can be used instead, such as a zero-length
    string. Again, for many owning objects, and certainly for all cheap-to-move STL
    containers, the cost of constructing such an object is trivial. But there could
    be a meaningful difference between the empty string and no string at all (that
    is, an empty string could be a valid result, and an absence of any string signifies
    something to the rest of the program). In C++17, we have a straightforward way
    to express this behavior using `std::optional`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以使用“*空*”对象来代替，例如零长度的字符串。同样，对于许多拥有对象，尤其是对于所有廉价的移动STL容器，构建此类对象的开销是微不足道的。但是，空字符串和完全没有字符串（即空字符串可能是一个有效的结果，而没有任何字符串的存在对程序的其他部分有特殊意义）之间可能存在有意义的差异。在C++17中，我们可以使用`std::optional`来直接表达这种行为：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The object of the `std::optional<std::string>` type may contain a string or
    be empty. The non-empty `std::optional` owns the object it contains (deleting
    the `std::optional` will also delete the string). Unlike `std::unique_pointer`,
    there are no heap memory allocations here: the `std::optional` object contains
    enough space within it to store a `std::string` object. `std::optional` is also
    movable, just like the string itself, so this pattern can be combined with the
    previous one. In general, we can say that in modern C++ there is no reason to
    own lightweight owning objects such as `std::string` indirectly. However, expressing
    the non-ownership of such objects has not received as much attention until recently.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional<std::string>`类型的对象可能包含一个字符串或为空。非空的`std::optional`拥有它包含的对象（删除`std::optional`也会删除字符串）。与`std::unique_pointer`不同，这里没有堆内存分配：`std::optional`对象内部有足够的空间来存储`std::string`对象。`std::optional`也是可移动的，就像字符串本身一样，因此这种模式可以与之前的一种模式结合。总的来说，我们可以说在现代C++中，没有必要间接拥有像`std::string`这样的轻量级所有权对象。然而，表达此类对象非所有权的做法直到最近才得到足够的关注。'
- en: Non-owning access to resource-owning objects
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对资源拥有对象的非所有权访问
- en: 'We have seen how a `std::string` object can, for most purposes, replace an
    owning pointer to `char*` (or to `std::string`). How do we, then, express non-owning
    access? Let us say that we need to pass a string to a function that operates on
    the string but does not take ownership of it (does not destroy it). This is a
    trivial exercise:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`std::string`对象在大多数情况下可以替代`char*`（或`std::string`）的所有权指针。那么，我们如何表达非所有权访问呢？让我们假设我们需要将一个字符串传递给一个操作字符串但不拥有它（不销毁它）的函数。这是一个简单的练习：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is what we have been doing since C++ was created. But this simplicity
    hides a profound distinction: remember that, as long as we don’t care about all
    the extra methods and the features they provide, `std::string` is just an owning
    pointer to a character string that also knows its length. So, how would we handle
    the same situation if we used an owning pointer instead of a string? The corresponding
    pointer is `std::unique_ptr<char[]>`, so we would write something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们自从C++被创建以来一直在做的事情。但这种简单性隐藏着一个深刻的区别：记住，只要我们不关心所有额外的方法和它们提供的功能，`std::string`就只是一个指向字符字符串的所有权指针，同时它也知道自己的长度。那么，如果我们用一个所有权指针而不是字符串来处理相同的情况，我们会怎么处理呢？相应的指针是`std::unique_ptr<char[]>`，所以我们会写一些像这样的事情：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Following the earlier guidelines, we passed a non-owning raw pointer to the
    function. We definitely would not write this declaration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的指南，我们向函数传递了一个非所有权的原始指针。我们绝对不会写这个声明：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Yet we do this without a second thought when the same character array is owned
    by a `std::string` object. Why do we approach these very similar problems so differently?
    This is the time to remember why a string is not just an owning pointer restricted
    to character arrays; it contains more information than just the pointer: it also
    knows the length of the string. There was no good way in C++ to grant non-owning
    access to such “*rich*” owning pointers, short of passing the entire pointer object
    by reference. By contrast, a unique pointer (or any other owning pointer) contains
    the same information as a basic pointer, so when ownership is not required, the
    owning pointer naturally reduces to a raw pointer without any information loss.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当相同的字符数组由`std::string`对象拥有时，我们却毫不犹豫地这样做。为什么我们对这些非常相似的问题采取如此不同的方法？现在是时候记住为什么字符串不仅仅是一个限制在字符数组中的拥有指针；它包含的信息不仅仅是指针：它还知道字符串的长度。在C++中没有很好的方法可以授予对这种“*丰富*”拥有指针的非拥有访问权限，除非通过引用传递整个指针对象。相比之下，唯一指针（或任何其他拥有指针）包含的信息与基本指针相同，所以当不需要所有权时，拥有指针自然地减少到原始指针，而没有任何信息损失。
- en: 'The difference is about more than just symmetry. Consider that passing a string
    by a `const` reference prevents the function `work_on_string` from changing the
    content of the string. On the other hand, a non-`const` reference allows the function
    to clear the string (release the memory it owns), which is an ownership aspect.
    We are forced to muddle the clarity of intent by mixing together two unrelated
    types of access we can grant to a function: the ability to change the content
    of the data and the ownership of the data.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异不仅仅是关于对称性。考虑一下，通过`const`引用传递字符串可以防止`work_on_string`函数改变字符串的内容。另一方面，非`const`引用允许函数清除字符串（释放它拥有的内存），这是所有权的一个方面。我们被迫通过混合两种无关的类型来模糊意图的清晰性，我们可以授予函数的访问类型：改变数据内容的能力和数据所有权。
- en: 'C++17 addressed this problem in a very limited context: specifically for strings,
    it introduced a new type `std::string_view`. A string view is a (`const`) non-owning
    pointer to a string that also stores the length of the string. In other words,
    it is a perfect non-owning equivalent to `std::string`: a string view to a string
    is exactly what a `const` raw pointer is to a unique pointer. Now, to grant non-owning
    access to a `std::string` object, we write:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C++17在非常有限的范围内解决了这个问题：具体来说，对于字符串，它引入了一个新的类型`std::string_view`。字符串视图是一个指向字符串的（`const`）非拥有指针，同时也存储了字符串的长度。换句话说，它是一个完美的非拥有等价物，类似于`std::string`：字符串视图到字符串的关系正好与`const`原始指针到唯一指针的关系相同。现在，为了授予对`std::string`对象的非拥有访问权限，我们编写：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In contrast, a function that takes ownership of a `std::string` object must
    still take it by reference. Specifically, use an rvalue reference to transfer
    the ownership:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个接收`std::string`对象所有权的函数仍然必须通过引用来接收它。具体来说，使用右值引用来转移所有权：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use a non-`const` lvalue reference only to allow the function to change the
    string; in C++17, there is no good *rich pointer* equivalent to a non-`const`
    raw pointer. There is probably no need to use `const std::string&` except when
    the existing interfaces require it since `std::string_view` offers equivalent
    functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用非`const`左值引用来允许函数更改字符串；在C++17中，没有好的*丰富指针*可以与非`const`原始指针等价。可能没有必要使用`const
    std::string&`，除非现有的接口需要它，因为`std::string_view`提供了等效的功能。
- en: There are other benefits and advantages of using `std::string_view` (in particular,
    it greatly simplifies writing common code for processing C and C++ strings), but
    in this chapter, we focus on the ownership aspect. Also, remember that the string
    view is limited to character strings. We could have the exact same discussion
    about another owning class, for example, `std::vector<int>`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::string_view`（特别是，它极大地简化了处理C和C++字符串的常见代码的编写）还有其他好处和优势，但在这个章节中，我们关注的是所有权方面。此外，记住字符串视图仅限于字符字符串。我们可以就另一个拥有类进行完全相同的讨论，例如，`std::vector<int>`。
- en: 'We now see a new pattern emerge: for a “*rich*” owning pointer that, in addition
    to owning memory, contains some information about the data it owns, the corresponding
    non-owning object (the equivalent of a raw pointer) should be a view object that
    contains the same information but does not own the resource. We find this view
    object in C++20 as `std::span`. Until then, the only good way to grant non-owning
    access to a vector of integers was to pass it by reference:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到一个新的模式出现：对于“丰富”的拥有指针，除了拥有内存外，还包含有关它所拥有的数据的一些信息，相应的非拥有对象（相当于原始指针）应该是一个视图对象，它包含相同的信息但不拥有资源。我们在C++20中找到了这个视图对象，即`std::span`。在此之前，唯一授予对整数向量非拥有访问权的好方法是按引用传递它：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In C++20, we can use the span to clearly differentiate the non-owning view
    (raw pointer equivalent) from the owning object (unique pointer equivalent):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，我们可以使用范围来清楚地区分非拥有视图（原始指针等价物）和拥有对象（唯一指针等价物）：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Thus, `std::span<int>` is a *rich pointer* equivalent to `int*`—it contains
    a non-`const` pointer and the size is cheap to copy and does not own the resource
    it points to. Unlike `std::string_view`, we can modify the object accessed through
    a span. But if we want the equivalent to a `const` pointer, we can use `std::span<const
    int>`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`std::span<int>`是一个与`int*`等价的“丰富指针”——它包含一个非`const`指针，大小便宜地复制且不拥有它所指向的资源。与`std::string_view`不同，我们可以修改通过范围访问的对象。但如果我们想要`const`指针的等价物，我们可以使用`std::span<const
    int>`：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since `std::string` contains a contiguous array of characters, it too can be
    used with a span, in this case, `std::span<char>` or `std::span<const char>`.
    The latter is essentially the same as `std::string_view`, including the option
    to construct them from string literals. The former is the equivalent of a non-`const`
    pointer to `char`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::string`包含一个连续的字符数组，它也可以与范围一起使用，在这种情况下，是`std::span<char>`或`std::span<const
    char>`。后者本质上与`std::string_view`相同，包括从字符串字面量构造它们的选择。前者相当于非`const`的`char`指针。
- en: 'The span pairs well with a vector or a string because they offer a non-owning
    view of an array. But it does not work for other STL containers since they all
    allocate memory in multiple non-contiguous allocations. For that, we need to use
    the C++20 ranges library. For example, the generalization of the preceding non-owning
    vector access to an arbitrary container can be written like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 范围与向量或字符串配合良好，因为它们提供了对数组的非拥有视图。但对于其他STL容器则不适用，因为它们都在多个非连续分配中分配内存。为此，我们需要使用C++20的范围库。例如，将前面的非拥有向量访问泛化到任意容器可以写成这样：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you have never seen a C++20 template, this takes some getting used to. The
    first line is a template function: `auto` parameters make “*ordinary*” functions
    into templates even without the `template` keyword. The incantation `std::ranges::view`
    before `auto` restricts the template parameters to those that satisfy the view
    concept. A view is a container-like object that has `begin()` and `end()` member
    functions and, in addition, must be cheap to move and either cheap to copy or
    non-copyable (this is, of course, a loose paraphrasing of the exact requirements
    enumerated by the standard). We could have written the same function with the
    `template` and `requires` keywords, but this compact syntax is idiomatic in C++20.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过C++20的模板，这需要一些习惯。第一行是一个模板函数：“auto”参数使“普通”函数成为模板，即使没有`template`关键字。在`auto`之前的`std::ranges::view`咒语限制了模板参数只能满足视图概念。视图是一个类似容器的对象，它具有`begin()`和`end()`成员函数，并且，此外，必须便宜地移动，或者便宜地复制或不可复制（这当然是对标准中列举的精确要求的宽松解释）。我们可以用`template`和`requires`关键字编写相同的函数，但这种紧凑的语法在C++20中是惯用的。
- en: 'Note that, in this concept-based coding style, the restrictions on the function
    arguments are specified by the concept requirements. We could have written the
    same template function to require ranges instead of views:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种基于概念的开发风格中，对函数参数的限制由概念要求指定。我们可以编写相同的模板函数，要求范围而不是视图：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Ranges are essentially arbitrary objects with `begin()` and `end()`, so `std::list`
    is a range (but not a view, it can be copied but not cheaply). Note that, as written,
    the function takes the argument by value, so a copy is made. Unless that was the
    intent (and in this case, it is not), the correct way to write this function is
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 范围本质上是有`begin()`和`end()`的任意对象，所以`std::list`是一个范围（但不是视图，它可以复制但并不便宜）。注意，按照目前的写法，函数是通过值传递参数的，因此会创建一个副本。除非这是意图（在这种情况下，并不是），正确编写此函数的方式如下：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A `const` reference would also work if we wanted to express non-modifying access.
    But the important point to note is that we did not have to do the same for views:
    by restricting the `work_on_data` function to accept only views, we have limited
    it to cheap-to-copy types similar to `std::string_view` (or a raw pointer, for
    that matter). Indeed, passing a range by reference is exactly like passing a string
    or a vector itself: this gives the callee access to the ownership. If we want
    to write a function that explicitly does not take ownership of a range, the view
    is the right way to express this.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要表达非修改性访问，`const`引用也会起作用。但需要注意的是，我们不必对视图做同样的事情：通过将`work_on_data`函数限制为仅接受视图，我们已经将其限制为类似`std::string_view`（或原始指针）的便宜复制类型。确实，通过引用传递范围就像传递字符串或向量本身一样：这给了被调用者访问所有权。如果我们想要编写一个明确不拥有范围的所有权的函数，视图是表达这种意思的正确方式。
- en: 'It is still too early to talk about patterns for C++20 ranges: they have not
    been around long enough to establish commonly recognized and accepted use practices
    (a necessary requirement for a pattern) and the library is still incomplete. C++23
    is expected to contain several significant enhancements (in particular, there
    is no good equivalent to `std::span<const char>` in C++20 ranges – it is going
    to be added in C++23).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++20范围的模式，现在谈论还为时过早：它们存在的时间还不够长，还没有形成公认的、被广泛接受的使用惯例（模式所必需的要求），并且库仍然不完整。预计C++23将包含几个重大增强（特别是，C++20范围中没有`std::span<const
    char>`的良好等效项——它将在C++23中添加）。
- en: 'However, we can confidently talk about the more general pattern becoming established
    in C++: resource ownership, including memory, should be handled by owning objects,
    while non-owning access should be granted through views. The owning objects can
    be smart pointers or more complex and specialized container objects. These containers,
    in addition to managing the memory in more complex ways, embed more information
    about the data they contain. In general, for each container, there should be a
    corresponding view that grants non-owning access while preserving all the additional
    information. For smart pointers, this view is a raw pointer or a reference. For
    `std::string`, this view is `std::string_view`. For `std::vector`, arrays, and
    any other containers that own contiguous memory, you will want `std::span`. For
    arbitrary containers, the corresponding views may be found in the C++20 ranges
    library; for a custom container, you may have to write your own view objects as
    well (just make sure they satisfy the relevant view concepts).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以自信地谈论在C++中逐渐形成的更一般的模式：资源所有权，包括内存，应由拥有对象来处理，而非拥有访问应通过视图来授予。拥有对象可以是智能指针或更复杂和专业的容器对象。这些容器除了以更复杂的方式管理内存外，还嵌入有关它们包含的数据的更多信息。一般来说，对于每个容器，都应该有一个相应的视图，它授予非拥有访问权限，同时保留所有附加信息。对于智能指针，这个视图是一个原始指针或引用。对于`std::string`，这个视图是`std::string_view`。对于`std::vector`、数组以及任何其他拥有连续内存的容器，你将想要`std::span`。对于任意容器，相应的视图可以在C++20范围库中找到；对于自定义容器，你可能还需要编写自己的视图对象（只需确保它们满足相关的视图概念即可）。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In C++, memory ownership is really just shorthand for object ownership, which,
    in turn, is the way to manage arbitrary resources, their ownership, and access.
    We have reviewed the contemporary idioms that the C++ community has developed
    to express different types of memory ownership. C++ allows the programmer to express
    exclusive or shared memory ownership. Just as important is expressing *non-ownership*
    in programs that are agnostic about the ownership of resources. We have also learned
    about the practices and attributes of resource ownership in a well-designed program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，内存所有权实际上只是对象所有权的简称，而对象所有权则是管理任意资源、其所有权和访问的方式。我们已经回顾了C++社区为表达不同类型的内存所有权而开发的当代习惯用语。C++允许程序员表达独占或共享内存所有权。同样重要的是，在关于资源所有权无知的程序中表达*非所有权*。我们还了解了一个设计良好的程序中资源所有权的实践和属性。
- en: 'We now have the idiomatic language to clearly express which entity in the program
    owns each object or resource, and when non-owning access is granted. The next
    chapter covers the idiom for the simplest operation on resources: the exchange,
    or swap.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了习惯用语来清楚地表达程序中哪个实体拥有每个对象或资源，以及何时授予非拥有访问权限。下一章将介绍对资源进行最简单操作的习惯用语：交换或交换。
- en: Questions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to clearly express memory ownership in a program?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在程序中清楚地表达内存所有权很重要？
- en: What are the common problems that arise from unclear memory ownership?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不清晰的内存所有权会导致哪些常见问题？
- en: What types of memory ownership can be expressed in C++?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++中可以表达哪些类型的内存所有权？
- en: How do you write non-memory-owning functions and classes?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何编写不拥有内存的函数和类？
- en: Why should exclusive memory ownership be preferred to a shared one?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该优先选择独占内存所有权而不是共享所有权？
- en: How do you express exclusive memory ownership in C++?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在C++中表达独占内存的所有权？
- en: How do you express shared memory ownership in C++?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在C++中表达共享内存的所有权？
- en: What are the potential downsides of shared memory ownership?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 共享内存所有权的潜在缺点是什么？
- en: What are views? How is a string view better than passing a string by reference?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图是什么？字符串视图为什么比通过引用传递字符串更好？
- en: Further reading
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++20 STL Cookbook* by *Bill* *Weinman*: [https://www.packtpub.com/product/c20-stl-cookbook/9781803248714](https://www.packtpub.com/product/c20-stl-cookbook/9781803248714)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++20 STL 烹饪书》* 由 *Bill Weinman* 撰写：[https://www.packtpub.com/product/c20-stl-cookbook/9781803248714](https://www.packtpub.com/product/c20-stl-cookbook/9781803248714)'
- en: '*Template Metaprogramming with C++* by *Marius* *Bancila*: [https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450](https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用C++进行模板元编程》* 由 *Marius Bancila* 撰写：[https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450](https://www.packtpub.com/product/template-metaprogramming-with-c/9781803243450)'
- en: '*C++ Data Structures and Algorithms* by *Wisnu* *Anggoro*: [https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++ 数据结构和算法》* 由 *Wisnu Anggoro* 撰写：[https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
- en: '*Expert C++ Programming* by *Jeganathan Swaminathan*, *Maya Posch*, and *Jacek*
    *Galowicz*: [https://www.packtpub.com/application-development/expert-c-programming](https://www.packtpub.com/application-development/expert-c-programming)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《专家C++编程》* 由 *Jeganathan Swaminathan*、*Maya Posch* 和 *Jacek Galowicz* 撰写：[https://www.packtpub.com/application-development/expert-c-programming](https://www.packtpub.com/application-development/expert-c-programming)'
- en: 'Part 2: Common C++ Idioms'
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：常见的C++惯用法
- en: 'This part describes some of the more common C++ idioms: established, universally
    recognized ways to express a specific idea or implement a frequently needed task.
    The boundary between “patterns” and “idioms” is fuzzy at best. In this book, we
    consider more complete design solutions to be patterns, while simpler techniques
    are idioms. In other words, choosing a pattern may influence the design of your
    entire application or its major component, while using an idiom is more of an
    implementation decision that has been learned from someone else’s mistakes.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分描述了一些更常见的C++惯用法：这些是公认的、普遍认可的方式来表达特定的想法或实现频繁需要的任务。在“模式”和“惯用法”之间的界限模糊至极。在这本书中，我们认为更完整的设计解决方案是模式，而更简单的技术是惯用法。换句话说，选择一个模式可能会影响你整个应用程序或其主要组件的设计，而使用惯用法则更多是借鉴他人的错误而做出的实现决策。
- en: 'This part has the following chapters:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B19262_04.xhtml#_idTextAnchor152), *Swap - From Simple to Subtle*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B19262_04.xhtml#_idTextAnchor152)，*交换 - 从简单到微妙*'
- en: '[*Chapter 5*](B19262_05.xhtml#_idTextAnchor199), *A Comprehensive Look at RAII*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19262_05.xhtml#_idTextAnchor199)，*全面审视RAII*'
- en: '[*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding Type Erasure*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*'
- en: '[*Chapter 7*](B19262_07.xhtml#_idTextAnchor314), *SFINAE, Concepts, and Overload
    Resolution Management*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19262_07.xhtml#_idTextAnchor314)，*SFINAE、概念和重载解析管理*'
