- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Asynchronous Programming with Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步编程
- en: The generator class implemented in the previous chapter helped us to use coroutines
    for building lazily evaluated sequences. C++ coroutines can also be used for asynchronous
    programming by having a coroutine represent an asynchronous computation or an
    **asynchronous task**. Although asynchronous programming is the most important
    driver for having coroutines in C++, there is no support for asynchronous tasks
    based on coroutines in the standard library. If you want to use coroutines for
    asynchronous programming, I recommend you find and use a library that complements
    C++20 coroutines. I've already recommended CppCoro ([https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro)),
    which at the time of writing seems like the most promising alternative. It's also
    possible to use asynchronous coroutines with the well-established library Boost.Asio,
    as you will see later on in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中实现的生成器类帮助我们使用协程构建惰性求值序列。C++协程也可以用于异步编程，通过让协程表示异步计算或**异步任务**。尽管异步编程是C++中协程的最重要驱动因素，但标准库中没有基于协程的异步任务支持。如果你想使用协程进行异步编程，我建议你找到并使用一个补充C++20协程的库。我已经推荐了CppCoro（[https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro)），在撰写本文时似乎是最有前途的替代方案。还可以使用成熟的Boost.Asio库来使用异步协程，稍后在本章中将会看到。
- en: 'This chapter will show that asynchronous programming is possible using coroutines
    and that there are libraries available to complement C++20 coroutines. More specifically,
    we will focus on:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示使用协程进行异步编程是可能的，并且有可用的库来补充C++20协程。更具体地，我们将重点关注：
- en: The `co_await` keyword and awaitable types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await`关键字和可等待类型'
- en: The implementation of a rudimentary task type—a type that can be returned from
    coroutines that perform some asynchronous work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了一个基本任务类型——一种可以从执行一些异步工作的协程中返回的类型
- en: Boost.Asio to exemplify asynchronous programming using coroutines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程来举例说明Boost.Asio中的异步编程
- en: Before moving on, it should also be said that there are no performance-related
    topics in this chapter and very few guidelines and best practices are presented.
    Instead, this chapter serves more as an introduction to the novel feature of asynchronous
    coroutines in C++. We'll begin this introduction by exploring awaitable types
    and `co_await` statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，还应该说一下，本章没有涉及与性能相关的主题，也没有提出很多指导方针和最佳实践。相反，本章更多地作为C++中异步协程的新特性的介绍。我们将通过探索可等待类型和`co_await`语句来开始这个介绍。
- en: Awaitable types revisited
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视可等待类型
- en: We already talked a bit about awaitable types in the previous chapter. But now
    we need to get a little bit more specific about what `co_await` does and what
    an awaitable type is. The keyword `co_await` is a unary operator, meaning that
    it takes a single argument. The argument we pass to `co_await` needs to fulfill
    some requirements that we will explore in this section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章已经谈到了一些关于可等待类型的内容。但现在我们需要更具体地了解`co_await`的作用以及可等待类型是什么。关键字`co_await`是一个一元运算符，意味着它接受一个参数。我们传递给`co_await`的参数需要满足本节中将要探讨的一些要求。
- en: When we say `co_await` in our code, we express that we are *waiting* for something
    that may or may not be ready for us. If it's not ready, `co_await` suspends the
    currently executing coroutine and returns control back to its caller. When the
    asynchronous task has completed, it should transfer the control back to the coroutine originally
    waiting for the task to finish. From here on, I will typically refer to the awaiting
    function as the **continuation**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中使用`co_await`时，我们表达了我们正在*等待*一些可能或可能不准备好的东西。如果它还没有准备好，`co_await`会暂停当前执行的协程，并将控制返回给它的调用者。当异步任务完成时，它应该将控制权转回最初等待任务完成的协程。从现在开始，我通常会将等待函数称为**续体**。
- en: 'Now consider the following expression:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下表达式：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this code to compile, `X` needs to be an awaitable type. So far we have
    only used the trivial awaitable types: `std::suspend_always` and `std::suspend_never`.
    Any type that directly implements the three member functions listed next, or alternatively
    defines `operator co_wait()` to produce an object with these member functions,
    is an awaitable type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码编译通过，`X`需要是一个可等待类型。到目前为止，我们只使用了一些简单的可等待类型：`std::suspend_always`和`std::suspend_never`。任何直接实现了接下来列出的三个成员函数，或者另外定义了`operator
    co_wait()`以产生一个具有这些成员函数的对象的类型，都是可等待类型：
- en: '`await_ready()` returns a `bool` that indicates whether the result is ready
    (`true`) or whether it is necessary to suspend the current coroutine and wait
    for the result to become ready.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await_ready()`返回一个`bool`，指示结果是否已准备就绪（`true`），或者是否需要暂停当前协程并等待结果变得就绪。'
- en: '`await_suspend(coroutine_handle)` – If `await_ready()` returned `false`, this
    function will be called with a handle to the coroutine that executed `co_await`.
    This function gives us an opportunity to start asynchronous work and subscribe
    for a notification that will trigger when the task has finished and thereafter
    resume the coroutine.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await_suspend(coroutine_handle)` - 如果`await_ready()`返回`false`，将调用此函数，传递一个执行`co_await`的协程的句柄。这个函数给了我们一个机会来开始异步工作，并订阅一个通知，当任务完成后触发通知，然后恢复协程。'
- en: '`await_resume()` is the function responsible for unpacking the result (or error)
    back to the coroutine. If an error has occurred during the work initiated by `await_suspend()`,
    this function could rethrow the caught error or return an error code. The result
    of the entire `co_await` expression is whatever `await_resume()` returns.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await_resume()`是负责将结果（或错误）解包回协程的函数。如果在`await_suspend()`启动的工作中发生了错误，这个函数可以重新抛出捕获的错误，或者返回一个错误代码。整个`co_await`表达式的结果是`await_resume()`返回的内容。'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With this overload in place, we can now pass a time interval to the `co_await`
    operator, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个重载，我们现在可以将一个时间间隔传递给`co_await`运算符，如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The example is not complete but gives you a hint about how to use the unary
    operator `co_await`. As you may have noticed, the three `await_*()` functions
    are not called directly by us; instead, they are invoked by code inserted by the
    compiler. Another example will clarify the transformations made by the compiler.
    Assume that the compiler stumbles upon the following statement in our code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例并不完整，但是给出了如何使用一元运算符`co_await`的提示。正如您可能已经注意到的那样，三个`await_*()`函数不是直接由我们调用的；相反，它们是由编译器插入的代码调用的。另一个示例将澄清编译器所做的转换。假设编译器在我们的代码中遇到以下语句：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then the compiler will (very) roughly transform the code into something like
    this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器将（非常）粗略地将代码转换为以下内容：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `await_ready()` function is first called to check whether a suspension is
    needed. If so, `await_suspend()` is called with a handle to the coroutine that
    will be suspended (the coroutine with the `co_await` statement). Finally, the
    result of the awaitable is requested and assigned to the `result` variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用`await_ready()`函数来检查是否需要挂起。如果需要，将使用一个句柄调用`await_suspend()`，该句柄将挂起协程（具有`co_await`语句的协程）。最后，请求等待结果并将其分配给`result`变量。
- en: The implicit suspend points
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式挂起点
- en: 'As you have seen in numerous examples, a coroutine defines *explicit* suspend
    points by using `co_await` and `co_yield`. Each coroutine also has two *implicit*
    suspend points:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在众多示例中所看到的，协程通过使用`co_await`和`co_yield`来定义*显式*挂起点。每个协程还有两个*隐式*挂起点：
- en: The **initial suspend point**, which occurs at the initial invocation of a coroutine
    before the coroutine body is executed
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始挂起点**，在协程体执行之前协程的初始调用时发生'
- en: The **final suspend point**, which occurs after the coroutine body has been
    executed and before the coroutine is destroyed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终挂起点**，在协程体执行后和协程被销毁前发生'
- en: The promise type defines the behavior of these two points by implementing `initial_suspend()`
    and `final_suspend()`. Both functions return awaitable objects. Typically, we
    pass `std::suspend_always` from the `initial_suspend()` function so that the coroutine
    is started lazily rather than eagerly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺类型通过实现`initial_suspend()`和`final_suspend()`来定义这两个点的行为。这两个函数都返回可等待的对象。通常，我们从`initial_suspend()`函数中传递`std::suspend_always`，以便协程是懒惰启动而不是急切启动。
- en: The final suspend point plays an important role for asynchronous tasks, because
    it makes it possible for us to tweak the behavior of `co_await`. Normally, a coroutine
    that has been `co_await:`ed should resume the awaiting coroutine at the final
    suspend point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的挂起点对于异步任务非常重要，因为它使我们能够调整`co_await`的行为。通常，已经`co_await:`的协程应在最终挂起点恢复等待的协程。
- en: Next, let's get a better understanding of how the three awaitable functions
    are meant to be used and how they cooperate with the `co_await` operator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们更好地了解三个可等待函数的用法以及它们如何与`co_await`运算符配合。
- en: Implementing a rudimentary task type
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个基本的任务类型
- en: 'The task type we are about to implement is a type that can be returned from
    coroutines that represent asynchronous tasks. The task is something that a caller
    can wait for using `co_await`. The goal is to be able to write asynchronous application
    code that looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实现的任务类型是可以从代表异步任务的协程中返回的类型。任务是调用者可以使用`co_await`等待的东西。目标是能够编写看起来像这样的异步应用程序代码：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The standard library already provides a type that allows a function to return
    an object that a caller can use for waiting on a result to be computed, namely
    `std::future`. We could potentially wrap `std::future` into something that would
    conform to the awaitable interface. However, `std::future` does not support continuations,
    which means that whenever we try to get the value from a `std::future`, we block
    the current thread. In other words, there is no way to compose asynchronous operations
    without blocking when using `std::future`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库已经提供了一种类型，允许函数返回一个调用者可以用于等待计算结果的对象，即`std::future`。我们可以将`std::future`封装成符合可等待接口的东西。但是，`std::future`不支持连续性，这意味着每当我们尝试从`std::future`获取值时，我们都会阻塞当前线程。换句话说，在使用`std::future`时，没有办法组合异步操作而不阻塞。
- en: 'Another alternative would be to use `std::experimental::future` or a future
    type from the Boost library, which supports continuations. But these future types
    allocate heap memory and include synchronization primitives that are not needed
    in the use cases set out for our tasks. Instead, we will create a new type with
    minimum overhead with the responsibilities to:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`std::experimental::future`或Boost库中的future类型，它支持连续性。但是这些future类型会分配堆内存，并包含不需要的同步原语。相反，我们将创建一个新类型，具有最小的开销和以下职责：
- en: Forward return values and exceptions to the caller
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将返回值和异常转发给调用者
- en: Resume the caller waiting for the result
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复等待结果的调用者
- en: A coroutine task type has been proposed (see P1056R0 at [http://www7.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1056r0.html](http://www7.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1056r0.html)),
    and the proposal gives us a good hint about what components we need. The implementation
    that follows is based on work presented by Gor Nishanov and source code shared
    by Lewis Baker, which is available in the CppCoro library.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 已经提出了协程任务类型（请参阅[http://www7.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1056r0.html](http://www7.open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1056r0.html)的P1056R0），该提案为我们提供了关于我们需要的组件的良好提示。接下来的实现基于Gor
    Nishanov提出的工作和Lewis Baker分享的源代码，该源代码可在CppCoro库中找到。
- en: 'Here is the implementation of the class template for representing an asynchronous
    task:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于表示异步任务的类模板的实现：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An explanation of each part will follow in the subsequent sections, but first
    we need the implementation of the promise type that uses a `std::variant` to hold
    a value or an error. The promise also keeps a reference to the coroutine waiting
    for the task to complete using the `continuation_` data member:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将在后续部分解释每个部分，但首先我们需要实现一个promise类型，该类型使用`std::variant`来保存值或错误。promise还保持对使用`continuation_`数据成员等待任务完成的协程的引用：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s important to distinguish between the two coroutine handles we are using:
    the handle identifying the *current coroutine* and the handle identifying the
    *continuation*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分我们正在使用的两个协程句柄：标识*当前协程*的句柄和标识*继续执行*的句柄。
- en: Note that this implementation doesn't support `Task<void>` due to limitations
    of `std::variant`, and also the limitation that we can't have both `return_value()`
    and `return_void()` on the same promise type. Not supporting `Task<void>` is unfortunate
    since not all asynchronous tasks necessarily return values. We will overcome this
    limitation in a while by providing a template specialization for `Task<void>`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`std::variant`的限制，此实现不支持`Task<void>`，并且我们不能在同一个promise类型上同时具有`return_value()`和`return_void()`的限制。不支持`Task<void>`是不幸的，因为并非所有异步任务都必然返回值。我们将通过为`Task<void>`提供模板特化来克服这个限制。
- en: Since we implemented a few coroutine return types in the previous chapter (`Resumable`
    and `Generator`), you will already be familiar with the requirements of a type
    that can be returned from a coroutine. Here, we will focus on the things that
    are new to you, such as exception handling and the ability to resume the caller
    currently waiting for us. Let's start looking at how `Task` and `Promise` handle return
    values and exceptions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一章中实现了一些协程返回类型（`Resumable`和`Generator`），您已经熟悉了可以从协程返回的类型的要求。在这里，我们将专注于对您新的事物，例如异常处理和恢复当前等待我们的调用者的能力。让我们开始看一下`Task`和`Promise`如何处理返回值和异常。
- en: Handling return values and exceptions
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理返回值和异常
- en: An asynchronous task can complete by returning (a value or `void`) or by throwing
    an exception. The value and the error need to be handed over to the caller, which
    has been waiting for the task to complete. As usual, this is the responsibility
    of the promise object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务可以通过返回（一个值或`void`）或抛出异常来完成。值和错误需要交给调用者，调用者一直在等待任务完成。通常情况下，这是promise对象的责任。
- en: 'The `Promise` class uses a `std::variant` to store the result of three possible
    outcomes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`类使用`std::variant`来存储三种可能结果的结果：'
- en: No value at all (the `std::monostate`). We use this in our variant to make it
    default-constructible, but without requiring the other two types to be default-constructible.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本没有值（`std::monostate`）。我们在我们的variant中使用这个来使其默认可构造，但不需要其他两种类型是默认可构造的。
- en: A return value of type `T`, where `T` is the template argument of `Task`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`T`的返回值，其中`T`是`Task`的模板参数。
- en: A `std::exception_ptr`, which is a handle to an exception that was thrown earlier.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::exception_ptr`，它是对先前抛出的异常的句柄。'
- en: The exception is captured by using the `std::current_exception()` function inside
    the function `Promise::unhandled_exception()`. By storing a `std::exception_ptr`,
    we can later rethrow this exception in another context. This is also the mechanism
    used when exceptions are passed between threads.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是通过在`Promise::unhandled_exception()`函数内部使用`std::current_exception()`函数来捕获的。通过存储`std::exception_ptr`，我们可以在另一个上下文中重新抛出此异常。当异常在线程之间传递时，也是使用的机制。
- en: A coroutine that uses `co_return value;` must have a promise type that implements
    `return_value()`. However, coroutines that use `co_return;`, or run off the body
    without returning a value, must have a promise type that implements `return_void()`.
    Implementing a promise type that contains both `return_void()` and `return_value()`
    generates a compilation error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`co_return value;`的协程必须具有实现`return_value()`的promise类型。然而，使用`co_return;`或在没有返回值的情况下运行的协程必须具有实现`return_void()`的promise类型。实现同时包含`return_void()`和`return_value()`的promise类型会生成编译错误。
- en: Resuming an awaiting coroutine
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复等待的协程
- en: 'When the asynchronous task has completed, it should transfer the control back
    to the coroutine waiting for the task to finish. To be able to resume this continuation,
    the `Task` object needs the `coroutine_handle` to the continuation coroutine.
    This handle was passed to the `Task` object''s `await_suspend()` function, and
    conveniently we made sure to save that handle into the promise object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当异步任务完成时，它应该将控制权转移到等待任务完成的协程。为了能够恢复这个继续执行，`Task`对象需要`coroutine_handle`到继续执行的协程。这个句柄被传递给`Task`对象的`await_suspend()`函数，并且我们方便地确保将该句柄保存到promise对象中：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `final_suspend()` function is responsible for suspending at the final suspend
    point of this coroutine and transferring execution to the awaiting coroutine.
    This is the relevant part of the `Promise` reproduced for your convenience:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`final_suspend()`函数负责在此协程的最终挂起点挂起，并将执行转移到等待的协程。这是`Promise`的相关部分，供您参考：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To begin with, returning `false` from `await_ready()` will leave the coroutine
    suspended at the final suspend point. The reason we do this is so that the promise
    is still alive and available for the continuation to have a chance to pull the
    result out from this promise.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`await_ready()`返回`false`将使协程在最终挂起点挂起。我们这样做的原因是为了保持promise仍然存活，并且可以让继续执行有机会从promise中取出结果。
- en: 'Next, let''s have a look at the `await_suspend()` function. This is the place
    where we want to resume the continuation. We could potentially call `resume()`
    directly on the `continuation_` handle and wait for it to finish, like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`await_suspend()`函数。这是我们想要恢复执行的地方。我们可以直接在`continuation_`句柄上调用`resume()`，并等待它完成，就像这样：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, that would run the risk of creating a long chain of nested call frames
    on the stack, which eventually could result in a stack overflow. Let''s see how
    this could happen with a short example using two coroutines, `a()` and `b()`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做会有在堆栈上创建一长串嵌套调用帧的风险，最终可能导致堆栈溢出。让我们看看通过一个简短的例子使用两个协程`a()`和`b()`会发生什么：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the `Promise` object associated with coroutine `a()` directly called `resume()`
    on the handle to coroutine `b()`, a new call frame to resume `b()` would be created
    on the stack on top of the call frame for `a()`. This process would be repeated
    over and over again in the loop, creating new nested call frames on the stack
    for each iteration. This call sequence when two functions call each other is a
    form of recursion, sometimes called mutual recursion:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与协程`a()`关联的`Promise`对象直接在协程`b()`的句柄上调用`resume()`，则在`a()`的调用帧之上会在堆栈上创建一个新的调用帧来恢复`b()`。这个过程会在循环中一遍又一遍地重复，为每次迭代在堆栈上创建新的嵌套调用帧。当两个函数互相调用时，这种调用顺序是一种递归形式，有时被称为相互递归：
- en: '![](img/B15619_13_01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_13_01.png)'
- en: 'Figure 13.1: Coroutine b() calls coroutine a(), which resumes b(), which calls
    a(), which resumes b(), and so on'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：协程b()调用协程a()，协程a()恢复b()，协程b()调用a()，协程a()恢复b()，依此类推
- en: 'Even though there is only one coroutine frame created for `b()`, each call
    to `resume()` that resumes coroutine `b()` creates a new frame on the stack. The
    solution to avoid this problem is called **symmetric transfer**. Instead of resuming
    the continuation directly from the coroutine that is about to finish, the task
    object instead returns the `coroutine_handle` identifying the continuation from
    `await_suspend()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管为`b()`创建了一个协程帧，但每次调用`resume()`来恢复协程`b()`都会在堆栈上创建一个新的帧。避免这个问题的解决方案称为**对称传输**。任务对象不是直接从即将完成的协程中恢复继续，而是从`await_suspend()`中返回标识继续的`coroutine_handle`：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: An optimization called *tail call optimization* is then guaranteed to happen
    by the compiler. In our case, this means that the compiler will be able to transfer
    control directly to the continuation without creating a new nested call frame.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编译器保证会发生一种叫做*尾递归优化*的优化。在我们的情况下，这意味着编译器将能够直接将控制转移到继续，而不会创建新的嵌套调用帧。
- en: 'We will not spend more time on the details of symmetric transfer and tail calls,
    but an excellent and more in-depth explanation of these topics can be found in
    the article *C++ Coroutines: Understanding Symmetric Transfer* by Lewis Baker,
    available at [https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不会再花更多时间讨论对称传输和尾调用的细节，但可以在Lewis Baker的文章*C++ Coroutines: Understanding Symmetric
    Transfer*中找到关于这些主题的出色且更深入的解释，网址为[https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer](https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer)。'
- en: As mentioned earlier, our `Task` template has the limitation of not handling
    a template parameter of type `void`. Now it's time to fix that.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的`Task`模板有一个限制，即不能处理`void`类型的模板参数。现在是时候修复这个问题了。
- en: Supporting void tasks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持void任务
- en: 'To overcome the limitations addressed earlier regarding the inability to handle
    tasks that do not produce any values, we need a template specialization for `Task<void>`.
    It is spelled out here for completeness, but it does not add many new insights
    beyond the general `Task` template defined earlier:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服之前提到的关于无法处理不产生任何值的任务的限制，我们需要为`Task<void>`进行模板特化。这里为了完整起见进行了详细说明，但除了之前定义的一般`Task`模板之外，并没有添加太多新的见解：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The promise type in this template specialization only keeps a reference to a
    potentially unhandled exception. And instead of having `return_value()` defined,
    the promise contains the member function `return_void()`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板特化中的promise类型只保留对潜在未处理异常的引用。而不是定义`return_value()`，promise包含成员函数`return_void()`。
- en: We can now represent tasks that return values or `void`. But there is still
    some work to be done before we can actually build a standalone program to test
    our `Task` type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以表示返回值或`void`的任务。但在我们实际构建一个独立程序来测试我们的`Task`类型之前，还有一些工作要做。
- en: Synchronously waiting for a task to complete
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步等待任务完成
- en: 'An important aspect of the `Task` type is that whatever invokes a coroutine
    that returns a `Task` must `co_await` on it, and is therefore also a coroutine.
    This creates a chain of coroutines (continuations). For example, assume we have
    a coroutine like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类型的一个重要方面是，无论是什么调用了返回`Task`的协程，都必须对其进行`co_await`，因此也是一个协程。这创建了一系列协程（继续）。例如，假设我们有这样一个协程：'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, it''s not possible to use it in the following way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就不可能以以下方式使用它：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we call an asynchronous function that returns a `Task`, we need to `co_await`
    on it, or nothing will happen. This is also the reason why we declare `Task` to
    be `nodiscard`: so that it generates a compilation warning if the return value
    is ignored, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用返回`Task`的异步函数，我们需要对其进行`co_await`，否则什么都不会发生。这也是我们声明`Task`为`nodiscard`的原因：这样如果忽略返回值，它会生成编译警告，就像这样：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The forced chaining of coroutines has the interesting effect that we finally
    get to the `main()` function of the program, which the C++ standard says is not
    allowed to be a coroutine. This needs to be addressed somehow, and the proposed
    solution is to provide at least one function that synchronously waits on the asynchronous
    chains to complete. For example, the CppCoro library includes the function `sync_wait()`,
    which has this effect of breaking the chain of coroutines, which makes it possible
    for an ordinary function to use coroutines.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的强制链接具有一个有趣的效果，即我们最终到达程序的`main()`函数，而C++标准规定不允许它是一个协程。这需要以某种方式解决，提出的解决方案是提供至少一个函数来同步等待异步链完成。例如，CppCoro库包括函数`sync_wait()`，它具有打破协程链的效果，使得普通函数可以使用协程成为可能。
- en: 'Unfortunately, implementing `sync_wait()` is rather complicated, but in order
    to at least make it possible to compile and test our `Task` type, I will here
    provide a simplified version based on the Standard C++ Proposal P1171R0, [https://wg21.link/P1171R0](https://wg21.link/P1171R0).
    Our goal here is to be able to write a test program like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，实现 `sync_wait()` 相当复杂，但为了至少使得编译和测试我们的 `Task` 类成为可能，我将在这里提供一个基于标准 C++ 提案
    P1171R0 的简化版本，[https://wg21.link/P1171R0](https://wg21.link/P1171R0)。我们的目标是能够编写如下的测试程序：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the aim of testing and running asynchronous tasks, let's continue with
    the implementation of `sync_wait()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和运行异步任务，让我们继续实现 `sync_wait()`。
- en: Implementing sync_wait()
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 sync_wait()
- en: '`sync_wait()` internally uses a custom task class specifically designed for
    our purpose, called `SyncWaitTask`. Its definition will be revealed in a while,
    but first let''s have a look at the definition of the function template `sync_wait()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync_wait()` 在内部使用了一个专门为我们的目的设计的自定义任务类，称为 `SyncWaitTask`。它的定义将在稍后揭示，但首先让我们看一下函数模板
    `sync_wait()` 的定义：'
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, in order to specify the type that the task is returning, we use a combination
    of `decltype` and `declval`. The rather cumbersome `using-e`xpression gives us
    the type returned by `T::await_resume()`, where `T` is the type of the task passed
    to `sync_wait()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了指定任务返回的类型，我们使用了 `decltype` 和 `declval` 的组合。这种相当繁琐的 `using` 表达式给出了由传递给 `sync_wait()`
    的任务的类型 `T::await_resume()` 返回的类型。
- en: Inside `sync_wait()` we distinguish between tasks that return values and tasks
    that return `void`. We make a distinction here to avoid the need for implementing
    a template specialization of `SyncWaitTask` to handle both `void` and non-void
    types. Both cases are handled similarly by introducing an empty `struct`, which
    can be provided as the template argument to `SyncWaitTask` for handling `void`
    tasks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sync_wait()` 中，我们区分返回值和返回 `void` 的任务。我们在这里做出区分，以避免需要实现 `SyncWaitTask` 的模板特化来处理
    `void` 和非 `void` 类型。通过引入一个空的 `struct`，可以将这两种情况类似地处理，该结构可以作为模板参数提供给 `SyncWaitTask`，用于处理
    `void` 任务。
- en: In the case where an actual value is returned, a lambda expression is used to
    define a coroutine that will `co_await` on the result and then finally yield its
    value. It's important to note that the coroutine might resume from `co_await`
    on another thread, which requires us to use a synchronization primitive in the
    implementation of `SyncWaitTask`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际返回值的情况下，使用 lambda 表达式来定义一个协程，该协程将在结果上进行 `co_await`，然后最终产生其值。重要的是要注意，协程可能会从
    `co_await` 在另一个线程上恢复，这要求我们在 `SyncWaitTask` 的实现中使用同步原语。
- en: Calling `get()` on the coroutine lambda resumes the coroutine until it yields
    a value. The implementation of `SyncWaitTask` guarantees that the coroutine lambda
    will never have a chance to resume again after the `co_yield` statement.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程 lambda 上调用 `get()` 会恢复协程，直到它产生一个值。`SyncWaitTask` 的实现保证协程 lambda 在 `co_yield`
    语句之后永远不会有机会再次恢复。
- en: 'We used `co_yield` extensively in the previous chapter, but without mentioning
    its relationship to `co_await`; namely that the following `co_yield` expression:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中我们广泛使用了 `co_yield`，但没有提及它与 `co_await` 的关系；即以下 `co_yield` 表达式：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'is transformed by the compiler into:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 被编译器转换为：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: where `promise` is the promise object associated with the currently executing
    coroutine. Knowing this is helpful when trying to understand the control flow
    between `sync_wait()` and the `SyncWaitTask` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`promise` 是与当前执行的协程关联的 promise 对象。当尝试理解 `sync_wait()` 和 `SyncWaitTask` 类之间的控制流时，了解这一点是有帮助的。'
- en: Implementing SyncWaitTask
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 SyncWaitTask
- en: 'Now we are ready to inspect the `SyncWaitTask`, which is a type intended only
    to be used as a helper for `sync_wait()`. For that reason, we add it under a namespace
    called `detail` to make it clear that this class is an implementation detail:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备检查 `SyncWaitTask`，这是一种类型，只用作 `sync_wait()` 的辅助。因此，我们将其添加到名为 `detail` 的命名空间下，以明确表示这个类是一个实现细节：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The most interesting part to pay attention to is the function `get()` and its
    blocking call to `acquire()` on a semaphore owned by the promise object. This
    is what makes this task type synchronously wait for a result to be ready for us.
    The promise type that owns the binary semaphore looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的部分是函数 `get()` 及其对 promise 对象拥有的信号量的 `acquire()` 的阻塞调用。这是使得这种任务类型同步等待结果准备好的关键。拥有二进制信号量的
    promise 类型如下：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There''s a lot of boilerplate code here that we have already talked about.
    But pay special attention to `yield_value()` and `final_suspend()`, which is the
    interesting part of this class. Recall that the coroutine lambda inside `sync_wait()`
    yielded the return value like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多我们已经讨论过的样板代码。但要特别注意 `yield_value()` 和 `final_suspend()`，这是这个类的有趣部分。回想一下，在
    `sync_wait()` 中，协程 lambda 产生了返回值，如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, once the value is yielded, we end up in `yield_value()` of the promise object.
    And the fact that `yield_value()` can return an awaitable type gives us the opportunity
    to customize the behavior of the `co_yield` keyword. In this case, `yield_value()`
    returns an awaitable that will signal through the binary semaphore that a value
    from the original `Task` object has been produced.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦值被产出，我们就会进入 promise 对象的 `yield_value()`。而 `yield_value()` 可以返回一个可等待类型的事实，使我们有机会定制
    `co_yield` 关键字的行为。在这种情况下，`yield_value()` 返回一个可等待对象，该对象将通过二进制信号量发出信号，表明原始 `Task`
    对象已经产生了一个值。
- en: The semaphore is signaled inside `await_suspend()`. We cannot signal earlier
    than that because the other end of the code waiting for the signal will eventually
    destroy the coroutine. Destroying a coroutine must only happen if the coroutine
    is in a suspended state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `await_suspend()` 中发出信号。我们不能比这更早发出信号，因为等待信号的代码的另一端最终会销毁协程。销毁协程只能在协程处于挂起状态时发生。
- en: The blocking call to `semaphore_`.`acquire()` from within `SyncWaitTask::get()`
    will return on the signal, and finally the computed value will be handed over
    to the client that called `sync_wait()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyncWaitTask::get()`中对`semaphore_`.`acquire()`的阻塞调用将在信号上返回，最终计算值将被传递给调用`sync_wait()`的客户端。'
- en: Testing asynchronous tasks with sync_wait()
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sync_wait()测试异步任务
- en: 'Finally, a small asynchronous test program using `Task` and `sync_wait()` can
    be constructed like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以构建一个使用`Task`和`sync_wait()`的小型异步测试程序，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have implemented the absolute minimum infrastructure for using asynchronous
    tasks with C++ coroutines. More infrastructure is needed, though, in order to
    use coroutines for asynchronous programming effectively. This is a big difference
    from the generator (presented in the previous chapter), which required a fairly
    small amount of groundwork before we could really benefit from it. To get a little
    bit closer to the real world, we will, in the following sections, explore some
    examples using Boost.Asio. The first thing we will do is to try to wrap a callback-based
    API inside an API compatible with C++ coroutines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了使用C++协程的最低限度基础设施。然而，为了有效地使用协程进行异步编程，还需要更多的基础设施。这与生成器（在上一章中介绍）有很大的不同，生成器在我们真正受益之前需要进行相当少量的准备工作。为了更接近现实世界，我们将在接下来的章节中探索一些使用Boost.Asio的示例。我们将首先尝试将基于回调的API包装在与C++协程兼容的API中。
- en: Wrapping a callback-based API
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装基于回调的API
- en: There are many asynchronous APIs based on callbacks. Typically, an asynchronous
    function takes a callback function provided by the caller. The asynchronous function
    returns immediately and then eventually invokes the callback (completion handler)
    when the asynchronous function has a computed value or is done waiting for something.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多基于回调的异步API。通常，异步函数接受调用者提供的回调函数。异步函数立即返回，然后最终在异步函数计算出一个值或完成等待某事时调用回调（完成处理程序）。
- en: To show you what an asynchronous callback-based API can look like, we will take
    a peek at a Boost library for asynchronous I/O named **Boost.Asio**. There is
    a lot to learn about Boost.Asio that won't be covered here; I will only describe
    the absolute minimum of the Boost code and instead focus on the parts directly
    related to C++ coroutines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示异步基于回调的API是什么样子，我们将一窥名为**Boost.Asio**的异步I/O的Boost库。关于Boost.Asio有很多内容需要学习，这里不会涉及到太多；我只会描述与C++协程直接相关的Boost代码的绝对最低限度。
- en: 'To make the code fit the pages of the book, the examples assume that the following
    namespace alias has been defined whenever we use code from Boost.Asio:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码适应本书的页面，示例假设每当我们使用Boost.Asio的代码时，已经定义了以下命名空间别名：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is a complete example of using Boost.Asio for delaying a function call
    but without blocking the current thread. This asynchronous example runs in a single
    thread:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Boost.Asio延迟函数调用但不阻塞当前线程的完整示例。这个异步示例在单个线程中运行：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compiling and running this program will generate the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编译和运行此程序将生成以下输出：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When using Boost.Asio, we always need to create an `io_context` object that
    runs an event processing loop. The call to `async_wait()` is asynchronous; it
    returns immediately back to `main()` and invokes the callback (the lambda) when
    the timer expires.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Boost.Asio时，我们总是需要创建一个运行事件处理循环的`io_context`对象。对`async_wait()`的调用是异步的；它立即返回到`main()`并在计时器到期时调用回调（lambda）。
- en: 'The timer example does not use coroutines but instead a callback API to provide
    asynchronicity. Boost.Asio is also compatible with C++20 coroutines, which I will
    demonstrate later on. But on our path to explore awaitable types, we will take
    a detour and instead assume that we need to provide a coroutine-based API that
    returns awaitable types on top of the callback-based API of Boost.Asio. In that
    way, we can use a `co_await` expression to call and wait (but without blocking
    the current thread) for the asynchronous task to complete. Instead of using a
    callback, we would like to be able to write something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器示例不使用协程，而是使用回调API来提供异步性。Boost.Asio也与C++20协程兼容，我稍后会进行演示。但在探索可等待类型的过程中，我们将绕道而行，而是假设我们需要在Boost.Asio的基于回调的API之上提供一个基于协程的API，该API返回可等待类型。这样，我们可以使用`co_await`表达式来调用并等待（但不阻塞当前线程）异步任务完成。我们希望能够写出类似这样的代码，而不是使用回调：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s see how we can implement the function `async_sleep()` so that it can
    be used with `co_await`. The pattern we will follow is to have `async_sleep()`
    return an awaitable object that will implement the three required functions: `await_ready()`,
    `await_suspend()`, and `await_resume()`. An explanation of the code will follow
    after it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何实现函数`async_sleep()`，以便可以与`co_await`一起使用。我们将遵循的模式是让`async_sleep()`返回一个可等待对象，该对象将实现三个必需的函数：`await_ready()`、`await_suspend()`和`await_resume()`。代码解释将在此后跟随：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once again, we are creating a custom awaitable type that does all the necessary
    work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在创建一个自定义的可等待类型，它完成了所有必要的工作：
- en: '`await_ready()` will return `false` unless the timer has already reached zero.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非计时器已经达到零，否则`await_ready()`将返回`false`。
- en: '`await_suspend()` starts the asynchronous operation and passes a callback that will
    be called when the timer has expired or produced an error. The callback saves
    the error code (if any) and resumes the suspended coroutine.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await_suspend()`启动异步操作并传递一个回调，当计时器到期或产生错误时将调用该回调。回调保存错误代码（如果有）并恢复挂起的协程。'
- en: '`await_resume()` has no result to unpack because the asynchronous function
    we are wrapping, `boost::asio::timer::async_wait()`, does not return any value
    except an optional error code.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await_resume()`没有结果需要解包，因为我们正在包装的异步函数`boost::asio::timer::async_wait()`除了可选的错误代码外不返回任何值。'
- en: 'Before we can actually test `async_sleep()` in a standalone program, we need
    some way to start the `io_context` run loop and break the chain of coroutines,
    as we did when testing the `Task` type previously. We will do that in a rather
    hacky way here by implementing two functions, `run_task()` and `run_task_impl()`,
    and a naive coroutine return type called `Detached` that ignores error handling
    and can be discarded by the caller:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际测试`async_sleep()`的独立程序之前，我们需要一种方法来启动`io_context`运行循环并打破协程链，就像我们之前测试`Task`类型时所做的那样。我们将通过实现两个函数`run_task()`和`run_task_impl()`以及一个称为`Detached`的天真协程返回类型来以一种相当巧妙的方式来做到这一点，该类型忽略错误处理并可以被调用者丢弃：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Detached` type makes the coroutine start immediately and runs the coroutine
    detached from the caller. The `executor_work_guard` prevents the `run()` call
    from returning until the coroutine `run_task_impl()` has completed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Detached`类型使协程立即启动并从调用者分离运行。`executor_work_guard`防止`run()`调用在协程`run_task_impl()`完成之前返回。'
- en: Starting operations and detaching them should typically be avoided. It's similar
    to detached threads or allocated memory without any references. However, the purpose
    of this example is to demonstrate what we can use awaitable types for and how
    we can write asynchronous programs and run them single-threaded.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免启动操作并分离它们。这类似于分离的线程或分配的没有任何引用的内存。然而，此示例的目的是演示我们可以使用可等待类型以及如何编写异步程序并在单线程中运行。
- en: 'Everything is in place; the wrapper called `async_sleep()` returns a `Task`
    and a function `run_task()`, which can be used to execute a task. It''s time to
    write a small coroutine to test the new code we implemented:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪；名为`async_sleep()`的包装器返回一个`Task`和一个名为`run_task()`的函数，该函数可用于执行任务。是时候编写一个小的协程来测试我们实现的新代码了：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Executing this program will generate the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序将生成以下输出：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You have seen how a callback-based API can be wrapped in a function that can
    be used by `co_await` and therefore allows us to use coroutines instead of callbacks
    for asynchronous programming. This program also provided a typical example of
    how the functions in the awaitable type can be used. However, as mentioned earlier,
    it turns out that recent versions of Boost, starting with 1.70, already provide
    an interface that is compatible with C++20 coroutines. In the next section, we
    will use this new coroutine API when building a tiny TCP server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何将基于回调的API包装在可以被`co_await`使用的函数中，因此允许我们使用协程而不是回调进行异步编程。该程序还提供了可等待类型中的函数如何使用的典型示例。然而，正如前面提到的，最近的Boost版本，从1.70开始，已经提供了与C++20协程兼容的接口。在下一节中，我们将在构建一个小型TCP服务器时使用这个新的协程API。
- en: A concurrent server using Boost.Asio
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost.Asio的并发服务器
- en: This section will demonstrate how to write concurrent programs that have multiple
    threads of execution but only use a single OS thread. We are about to implement
    a rudimentary concurrent single-threaded TCP server that can handle multiple clients.
    There are no networking capabilities in the C++ standard library, but fortunately
    Boost.Asio provides us with a platform-agnostic interface for handling socket
    communication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示如何编写并发程序，该程序具有多个执行线程，但仅使用单个操作系统线程。我们将要实现一个基本的并发单线程TCP服务器，可以处理多个客户端。C++标准库中没有网络功能，但幸运的是，Boost.Asio为我们提供了一个平台无关的接口，用于处理套接字通信。
- en: Instead of wrapping the callback-based Boost.Asio API, I will demonstrate how
    to use the `boost::asio::awaitable` class for the purpose of showing a more realistic
    example of how asynchronous application programming using coroutines can look.
    The class template `boost::asio::awaitable` corresponds to the `Task` template
    we created earlier; it's used as a return type for coroutines that represent asynchronous
    computations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示如何使用`boost::asio::awaitable`类，而不是包装基于回调的Boost.Asio API，以展示使用协程进行异步应用程序编程的更真实的示例。类模板`boost::asio::awaitable`对应于我们之前创建的`Task`模板；它用作表示异步计算的协程的返回类型。
- en: Implementing the server
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施服务器
- en: 'The server is very simple; once a client connects, it starts updating a numeric
    counter and writes back the value whenever it is updated. This time we will follow
    the code from top to bottom, starting with the `main()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器非常简单；一旦客户端连接，它就开始更新一个数字计数器，并在更新时写回该值。这次我们将从上到下跟踪代码，从`main()`函数开始：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The mandatory `io_context` runs the event processing loop. It's possible to
    invoke `run()` from multiple threads as well, if we want our server to execute
    multiple OS threads. In our case we only use one thread but with multiple concurrent
    flows. The function `boost::asio::co_spawn()` starts a detached concurrent flow.
    The server is implemented using a lambda; it defines a TCP endpoint (with port
    37259) and starts listening for incoming client connections on the endpoint.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 强制性的`io_context`运行事件处理循环。也可以从多个线程调用`run()`，如果我们希望服务器执行多个操作系统线程。在我们的情况下，我们只使用一个线程，但具有多个并发流。函数`boost::asio::co_spawn()`启动一个分离的并发流。服务器使用lambda表达式实现；它定义了一个TCP端点（端口37259），并开始在端点上监听传入的客户端连接。
- en: 'The coroutine `listen()` is fairly simple and looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程`listen()`相当简单，如下所示：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The executor is the object responsible for actually executing our asynchronous
    functions. An executor may represent a thread pool or a single system thread,
    for example. We will most likely see some form of executors in upcoming versions
    of C++ to give us programmers more control and flexibility over when and where
    our code executes (including GPUs).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器是实际执行我们的异步函数的对象。执行器可以表示线程池或单个系统线程，例如。我们很可能会在即将推出的C++版本中看到某种形式的执行器，以便让我们程序员更多地控制和灵活地执行我们的代码（包括GPU）。
- en: Next, the coroutine runs an infinite loop and waits for TCP clients to connect.
    The first `co_await` expression returns a socket when a new client successfully
    connects to our server. The socket object is then moved to the coroutine `serve_client()`,
    which will serve the newly connected client until the client disconnects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，协程运行一个无限循环，并等待TCP客户端连接。第一个`co_await`表达式在新客户端成功连接到服务器时返回一个套接字。然后将套接字对象移动到协程`serve_client()`中，该协程将为新连接的客户端提供服务，直到客户端断开连接。
- en: 'The main application logic of the server happens in the coroutine that handles
    each client. Here is how it looks:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的主要应用逻辑发生在处理每个客户端的协程中。下面是它的样子：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each coroutine invocation serves one unique client during the entire client
    session; it runs until the client disconnects from the server. The coroutine updates
    a counter at regular intervals (every 100 ms) and writes the value asynchronously
    back to the client using `async_write()`. Note how we can write the function `serve_client()`
    in a linear fashion although it invokes two asynchronous operations: `async_write()`
    and `async_wait()`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协程调用在整个客户端会话期间为一个唯一的客户端提供服务；它在客户端断开连接之前一直运行。协程会定期更新计数器（每100毫秒一次），并使用`async_write()`异步将值写回给客户端。请注意，尽管它调用了两个异步操作：`async_write()`和`async_wait()`，但我们可以以线性方式编写函数`serve_client()`。
- en: Running and connecting to the server
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和连接到服务器
- en: 'Once we have started this server, we can connect clients on port 37259\. To
    try this out, I''m using a tool called `nc` (netcat), which can be used for communicating
    over TCP and UDP. Here is an example of a short session where a client connects
    to the server running on localhost:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了这个服务器，我们可以在端口37259上连接客户端。为了尝试这个，我使用了一个叫做`nc`（netcat）的工具，它可以用于通过TCP和UDP进行通信。下面是一个客户端连接到运行在本地主机上的服务器的短会话的示例：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can start multiple clients and they will all be served by a dedicated `serve_client()`
    coroutine invocation and have their own copy of the incrementing counter variable,
    as shown in the screenshot below:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以启动多个客户端，它们都将由专用的`serve_client()`协程调用来提供服务，并且拥有自己的递增计数变量的副本，如下面的屏幕截图所示：
- en: '![](img/B15619_13_02.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_13_02.png)'
- en: 'Figure 13.2: A running server with two connected clients'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：运行中的服务器与两个连接的客户端
- en: Another way to create an application serving multiple sessions concurrently
    would be to create one thread for each new client that connects. However, the
    memory overhead of threads would set the limit of the number of sessions substantially
    lower compared to this model using coroutines.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建同时为多个会话提供服务的应用程序的方法是为每个连接的新客户端创建一个线程。然而，与使用协程的模型相比，线程的内存开销会大大降低会话数量的限制。
- en: The coroutines in this example are all executed on the same thread, which makes
    the locking of shared resources unnecessary. Imagine we had a global counter that
    each session updated. If we used multiple threads, the access to the global counter
    would need some kind of synchronization (using a mutex or an atomic data type).
    This is not necessary for coroutines that execute on the same thread. In other
    words, coroutines that execute on the same thread can share state without using
    any locking primitives.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的协程都在同一个线程上执行，这使得共享资源的锁定变得不必要。想象一下，如果我们有一个每个会话都会更新的全局计数器。如果我们使用多个线程，对全局计数器的访问就需要某种形式的同步（使用互斥锁或原子数据类型）。但是对于在同一线程上执行的协程来说，这是不必要的。换句话说，在同一线程上执行的协程可以共享状态，而不需要使用任何锁定原语。
- en: What we have achieved with the server (and what we haven't)
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们通过服务器实现了什么（以及我们没有实现的）
- en: 'The example application using Boost.Asio demonstrates that coroutines can be
    used for asynchronous programming. Instead of implementing continuations with
    nested callbacks, we can write code in a linear fashion using `co_await` statements.
    However, this example is minimal and avoids some really important aspects of asynchronous
    programming, such as:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio示例应用程序演示了协程可以用于异步编程。我们可以使用`co_await`语句以线性方式编写代码，而不是使用嵌套回调来实现延续。然而，这个例子很简单，避开了一些真正重要的异步编程方面，比如：
- en: Asynchronous read and write operations. The server only writes data to its clients
    and ignores the challenge of synchronizing read and write operations.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步读写操作。服务器只向其客户端写入数据，并忽略了同步读写操作的挑战。
- en: Canceling asynchronous tasks and graceful shutdown. The server runs in an infinite
    loop, completely ignoring the challenge of a clean shutdown.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消异步任务和优雅关闭。服务器在一个无限循环中运行，完全忽略了干净关闭的挑战。
- en: Error handling and exception safety when using multiple `co_await` statements.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个`co_await`语句时的错误处理和异常安全。
- en: These topics are immensely important but are out of scope for this book. I already
    mentioned that detached operations are best avoided. Creating detached tasks using
    `boost::asio::co_spawn()`, as shown in the example, should be done with utmost
    caution. A fairly new programming paradigm for avoiding detached work is called
    **structured concurrency**. It aims to solve exception safety and the cancellation
    of multiple asynchronous tasks by encapsulating concurrency into general and reusable
    algorithms such as `when_all()` and `stop_when()`. The key idea is to never allow
    some child task to exceed the lifetime of its parent. This makes it possible to
    pass local variables by reference to asynchronous child operations safely and
    with better performance. Strictly nested lifetimes of concurrent tasks also make
    the code easier to reason about.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题非常重要，但超出了本书的范围。我已经提到了最好避免使用分离的操作。使用`boost::asio::co_spawn()`创建分离的任务，应该非常谨慎。一个相当新的用于避免分离工作的编程范式被称为**结构化并发**。它旨在通过将并发封装到通用和可重用的算法中（例如`when_all()`和`stop_when()`）来解决异常安全和多个异步任务的取消。关键思想是永远不允许某个子任务的生命周期超过其父任务。这使得可以安全地通过引用传递本地变量给异步子操作，并且性能更好。严格嵌套的并发任务生命周期也使得代码更容易理解。
- en: Another important aspect is that asynchronous tasks should always be lazy (immediately
    suspended), so that continuations can be attached before any exceptions can be
    thrown. This is also a requirement if you want to be able to cancel a task in
    a safe manner.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的方面是，异步任务应该始终是懒惰的（立即挂起），这样在抛出任何异常之前就可以附加继续。如果您想要能够以安全的方式取消任务，这也是一个要求。
- en: 'There will most likely be a lot of talks, libraries, and articles related to
    this important subject in the years to come. Two talks from CppCon 2019 addressed
    this topic:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 未来几年很可能会有很多关于这一重要主题的讲座、库和文章。CppCon 2019的两场讲座涉及了这个主题。
- en: '*A Unifying Abstraction for Async in C++*, Eric Neibler and D. S. Hollman,
    [https://sched.co/SfrC](https://sched.co/SfrC)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用于C++中异步的统一抽象*，Eric Neibler和D.S. Hollman，[https://sched.co/SfrC](https://sched.co/SfrC)'
- en: '*Structured Concurrency: Writing Safer Concurrent Code with Coroutines and
    Algorithms*, Lewis Baker, [https://sched.co/SfsU](https://sched.co/SfsU)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构化并发：使用协程和算法编写更安全的并发代码*，Lewis Baker，[https://sched.co/SfsU](https://sched.co/SfsU)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've seen how to use C++ coroutines for writing asynchronous
    tasks. To be able to implement the infrastructure in the form of a `Task` type
    and a `sync_wait()` function, you needed to fully understand the concept of awaitable
    types and how they can be used to customize the behavior of coroutines in C++.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了如何使用C++协程来编写异步任务。为了能够以`Task`类型和`sync_wait()`函数的形式实现基础设施，您需要充分理解可等待类型的概念以及它们如何用于自定义C++中协程的行为。
- en: By using Boost.Asio, we could build a truly minimal but fully functional concurrent
    server application executing on a single thread while handling multiple client
    sessions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Boost.Asio，我们可以构建一个真正最小但完全功能的并发服务器应用程序，该应用程序在单个线程上执行，同时处理多个客户会话。
- en: Lastly, I briefly introduced a methodology called structured concurrency and
    gave some directions for where you can find more information about this topic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我简要介绍了一种称为结构化并发的方法论，并指出了一些关于这个主题的更多信息的方向。
- en: In the next chapter, we will move on to explore parallel algorithms, which are
    a way to speed up concurrent programs by utilizing multiple cores.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨并行算法，这是一种通过利用多个核心来加速并发程序的方法。
