- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Coin Dash – Build Your First 2D Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coin Dash – 构建你的第一个2D游戏
- en: This first project will guide you through making your first Godot Engine game.
    You will learn how the Godot editor works, how to structure a project, and how
    to build a small 2D game using some of Godot’s most commonly used nodes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个项目将指导您制作您的第一个 Godot 引擎游戏。您将学习 Godot 编辑器的工作方式，如何构建项目结构，以及如何使用 Godot 最常用的节点构建一个小型
    2D 游戏。
- en: Why start with 2D?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么从2D开始？
- en: In a nutshell, 3D games are much more complex than 2D ones. However, many of
    the underlying game engine features you’ll need to know are the same. You should
    stick to 2D until you have a good understanding of Godot’s workflow. At that point,
    the jump to 3D will feel much easier. You’ll get a chance to work in 3D in this
    book’s later chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，3D 游戏比 2D 游戏复杂得多。然而，您需要了解的许多底层游戏引擎功能是相同的。您应该坚持使用 2D，直到您对 Godot 的工作流程有很好的理解。到那时，转向
    3D 将感觉容易得多。您将在本书的后续章节中有机会在 3D 中工作。
- en: Don’t skip this chapter, even if you aren’t a complete newcomer to game development.
    While you may already understand many of the concepts, this project will introduce
    Godot’s features and design paradigms – things you’ll need to know going forward.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不是游戏开发的完全新手，也不要跳过本章。虽然您可能已经理解了许多概念，但这个项目将介绍 Godot 的功能和设计范式——您在前进过程中需要了解的事情。
- en: 'The game in this chapter is called *Coin Dash*. Your character must move around
    the screen, collecting as many coins as possible while racing against the clock.
    When you’re finished, the game will look like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的游戏称为 *Coin Dash*。您的角色必须在屏幕上移动，尽可能多地收集金币，同时与时间赛跑。完成游戏后，游戏将看起来像这样：
- en: '![Figure 2.1: The completed game](img/B19289_02_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：完成的游戏](img/B19289_02_01.jpg)'
- en: 'Figure 2.1: The completed game'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：完成的游戏
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a new project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新项目
- en: Creating character animations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建角色动画
- en: Moving a character
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动角色
- en: Using `Area2D` to detect when objects touch
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Area2D`检测对象接触
- en: Using `Control` nodes to display information
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Control`节点显示信息
- en: Communicating between game objects using signals
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号在游戏对象之间进行通信
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Download the game assets from the following link below and unzip them into
    your new project folder: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载游戏资源：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)，并将它们解压缩到您的新项目文件夹中。
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 GitHub 上找到本章的完整代码：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter02%20-%20Coin%20Dash)
- en: Setting up the project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: Launch Godot, and in the Project Manager, click the **+ New** **Project** button.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Godot，然后在项目管理器中点击**+ 新建** **项目**按钮。
- en: You first need to create a project folder. Type `Coin Dash` in the **Project
    Name** box and click **Create Folder**. Creating a folder for your project is
    important to keep all your project files separate from any other projects on your
    computer. Next, you can click **Create & Edit** to open the new project in the
    Godot editor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要创建一个项目文件夹。在**项目名称**框中输入`Coin Dash`，然后点击**创建文件夹**。为您的项目创建一个文件夹对于将所有项目文件与您计算机上的其他任何项目分开非常重要。接下来，您可以点击**创建
    & 编辑**以在 Godot 编辑器中打开新项目。
- en: '![Figure 2.2: The new project window](img/B19289_02_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2：新项目窗口](img/B19289_02_02.jpg)'
- en: 'Figure 2.2: The new project window'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：新项目窗口
- en: In this project, you’ll make three independent scenes – the player character,
    the coin, and a display to show the score and clock – all of which will be combined
    into the game’s “main” scene (see [*Chapter 1*](B19289_01.xhtml#_idTextAnchor015)).
    In a larger project, it might be useful to create separate folders to organize
    each scene’s assets and scripts, but for this relatively small game, you can save
    all of your scenes and scripts in the root folder, which is referred to as `res://`
    (res is short for resources). All resources in your project will be located relative
    to the res:// folder. You can see the project’s files in the `icon.svg,` which
    is the Godot icon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将创建三个独立的场景——玩家角色、金币和一个显示得分和计时的显示界面——所有这些都将组合到游戏的“主”场景中（见[*第1章*](B19289_01.xhtml#_idTextAnchor015)）。在一个更大的项目中，创建单独的文件夹来组织每个场景的资产和脚本可能很有用，但在这个相对较小的游戏中，您可以将所有场景和脚本保存在根文件夹中，该文件夹被称为`res://`（res是资源的缩写）。您项目中的所有资源都将位于`res://`文件夹的相对位置。您可以在`icon.svg`中看到项目文件，这是Godot的图标。
- en: 'You can download a ZIP file of the art and sounds (collectively known as *assets*)
    for the game here: [https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads).
    Unzip this file in the new project folder you created.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载游戏的艺术和声音（统称为*资产*）的ZIP文件：[https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads)。将此文件解压到您创建的新项目文件夹中。
- en: '![Figure 2.3: The FileSystem tab](img/B19289_02_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3：文件系统选项卡](img/B19289_02_03.jpg)'
- en: 'Figure 2.3: The FileSystem tab'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：文件系统选项卡
- en: For example, the images for the coin are located in `res://assets/coin/`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，金币的图像位于`res://assets/coin/`。
- en: Since this game will be in portrait mode (taller than it is wide), we’ll start
    by setting up the game window.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这款游戏将以竖屏模式（高度大于宽度）运行，我们首先需要设置游戏窗口。
- en: 'Click **Project** -> **Project Settings** from the menu at the top. The settings
    window looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部菜单中选择**项目** -> **项目设置**。设置窗口看起来像这样：
- en: '![Figure 2.4: The Project Settings window](img/B19289_02_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4：项目设置窗口](img/B19289_02_04.jpg)'
- en: 'Figure 2.4: The Project Settings window'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：项目设置窗口
- en: Look for the `480` and `720`, as shown in the preceding figure. Also in this
    section, under **Stretch**, set **Mode** to **canvas_items** and **Aspect** to
    **keep**. This will ensure that if a user resizes the game window, everything
    will scale appropriately and not become stretched or deformed. You can also uncheck
    the **Resizable** box under **Size** to prevent the window from being resized
    at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查找前文图示中的`480`和`720`。在此部分，在**拉伸**选项下，将**模式**设置为**canvas_items**，将**纵横比**设置为**保持**。这将确保如果用户调整游戏窗口大小，所有内容都将适当缩放，而不会拉伸或变形。您还可以在**大小**下的**可调整大小**框中取消勾选，以防止窗口被调整大小。
- en: Congratulations! You’ve set up your new project, and you’re ready to start making
    your first game. In this game, you’ll make objects that move around in 2D space,
    so it’s important to understand how objects are positioned and moved using 2D
    coordinates. In the next section, you’ll learn how that works and how to apply
    it to your game.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已设置好新项目，并准备好开始制作您的第一个游戏。在这个游戏中，您将创建在2D空间中移动的对象，因此了解如何使用2D坐标定位和移动对象非常重要。在下一节中，您将了解这是如何工作的以及如何将其应用于您的游戏。
- en: Vectors and 2D coordinate systems
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量和2D坐标系
- en: This section is a very brief overview of 2D coordinate systems and vector math
    as it’s used in game development. Vector math is an essential tool in game development,
    so if you need a broader understanding of the topic, see Khan Academy’s linear
    algebra series ([https://www.khanacademy.org/math/linear-algebra](https://www.khanacademy.org/math/linear-algebra)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要概述了2D坐标系和向量数学在游戏开发中的应用。向量数学是游戏开发中的基本工具，如果您需要对该主题有更广泛的理解，请参阅可汗学院的线性代数系列([https://www.khanacademy.org/math/linear-algebra](https://www.khanacademy.org/math/linear-algebra))。
- en: When working in 2D, you’ll use Cartesian coordinates to identify locations in
    the 2D plane. A particular position in 2D space is written as a pair of values,
    such as `(4, 3)`, representing the position along the *x* and *y* axes, respectively.
    Any position in the 2D plane can be described in this way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D工作中，您将使用笛卡尔坐标系来识别2D平面上的位置。2D空间中的特定位置以一对值表示，例如`(4, 3)`，分别代表沿*x*轴和*y*轴的位置。2D平面上的任何位置都可以用这种方式描述。
- en: 'In 2D space, Godot follows the common computer graphics practice of orienting
    the *x* axis to the right and the *y* axis downward:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维空间中，Godot 遵循计算机图形学中常见的做法，将 *x* 轴朝右，将 *y* 轴朝下：
- en: '![Figure 2.5: A 2D coordinate system](img/B19289_02_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5：二维坐标系](img/B19289_02_05.jpg)'
- en: 'Figure 2.5: A 2D coordinate system'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：二维坐标系
- en: That’s not what my math teacher taught me!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我的数学老师教给我的！
- en: If you’re new to computer graphics or game development, it might seem odd that
    the positive *y* axis points downward instead of upward, which you likely learned
    in math class. However, this orientation is very common in computer graphics applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触计算机图形学或游戏开发，可能会觉得正 *y* 轴向下而不是向上，这在你的数学课上可能学过，这看起来很奇怪。然而，这种方向在计算机图形学应用中非常常见。
- en: Vectors
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量
- en: 'You can also think of the `(4, 3)` position as an *offset* from the `(0, 0)`
    point, or *origin*. Imagine an arrow pointing from the origin to the point:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `(4, 3)` 位置视为从 `(0, 0)` 点或 *原点* 的偏移，或者称为 *偏移量*。想象一下从原点指向该点的箭头：
- en: '![Figure 2.6: A 2D vector](img/B19289_02_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6：二维向量](img/B19289_02_06.jpg)'
- en: 'Figure 2.6: A 2D vector'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6：二维向量
- en: This arrow is a *vector*. It represents a great deal of useful information,
    including the point’s location, its distance or *length* (`m`), and its angle
    from the *x a*xis (`θ`). More specifically, this type of vector is referred to
    as a *position* vector – that is, one that describes a position in space. Vectors
    can also represent movement, acceleration, or any other quantity that has a size
    and a direction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这支箭是一个 *向量*。它代表了许多有用的信息，包括点的位置、其距离或 *长度* (`m`)，以及其相对于 *x* 轴的 *角度* (`θ`)。更具体地说，这种类型的向量被称为
    *位置向量*——即描述空间中位置的向量。向量还可以表示运动、加速度或任何具有大小和方向的量。
- en: In Godot, vectors have a wide array of uses, and you’ll use them in every project
    in this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Godot 中，向量有广泛的应用，你将在本书的每个项目中都会用到它们。
- en: You should now have an understanding of how the 2D coordinate space works and
    how vectors can help to position and move objects. In the next section, you’ll
    create the player object and use this knowledge to control its movement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经了解了二维坐标空间的工作原理以及向量如何帮助定位和移动对象。在下一节中，你将创建玩家对象并使用这些知识来控制其移动。
- en: Part 1 – the player scene
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分——玩家场景
- en: The first scene you’ll make is the player object. One of the benefits of creating
    a separate scene for the player (and other objects) is that you can test it independently,
    even before you’ve created other parts of a game. This separation of game objects
    will become more and more helpful as your projects grow in size and complexity.
    Keeping individual game objects separate from each other makes them easier to
    troubleshoot, modify, and even replace entirely without affecting other parts
    of the game. It also means your player can be reusable – you can drop this player
    scene into an entirely different game and it will work just the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将制作的第一个场景是玩家对象。为玩家（和其他对象）创建单独的场景的一个好处是，你可以在创建游戏的其他部分之前独立测试它。随着你的项目规模和复杂性的增长，这种游戏对象的分离将变得越来越有帮助。将单个游戏对象与其他对象保持分离，使得它们更容易调试、修改，甚至完全替换而不影响游戏的其它部分。这也意味着你的玩家对象可以重复使用——你可以将这个玩家场景放入一个完全不同的游戏中，它将正常工作。
- en: 'Your player scene needs to do the following things:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你的玩家场景需要完成以下事情：
- en: Display your character and its animations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示你的角色及其动画
- en: Respond to user input by moving the character
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过移动角色来响应用户输入
- en: Detect collisions with other game objects such as coins or obstacles
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测与其他游戏对象（如金币或障碍物）的碰撞
- en: Creating the scene
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建场景
- en: Start by clicking the `Area2D`. Then, click on the node’s name and change it
    to `Player`. Click **Scene** -> **Save Scene** (*Ctrl* + *S*) to save the scene.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先点击 `Area2D`。然后，点击节点的名称并将其更改为 `Player`。点击 **场景** -> **保存场景** (*Ctrl* + *S*)
    来保存场景。
- en: '![Figure 2.7: Adding a node](img/B19289_02_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7：添加节点](img/B19289_02_07.jpg)'
- en: 'Figure 2.7: Adding a node'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：添加节点
- en: Take a look at the `player.tscn` file now appears. Whenever you save a scene
    in Godot, it will use the `.tscn` extension – this is the file format for Godot’s
    scenes. The “t” in the name stands for “text” because these are text files. Feel
    free to take a look at it in an external text editor if you’re curious, but you
    shouldn’t edit one by hand; otherwise, you run the risk of accidentally corrupting
    the file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查看 `player.tscn` 文件。每次你在 Godot 中保存场景时，它都会使用 `.tscn` 扩展名——这是 Godot 场景的文件格式。"t"
    在名称中的含义是 "text"，因为这些是文本文件。如果你好奇，可以自由地在外部文本编辑器中查看它，但你不应该手动编辑它；否则，你可能会不小心损坏文件。
- en: You’ve now created the scene’s `Area2D` because it’s a 2D node, so it can move
    in 2D space, and it can detect overlap with other nodes, so we’ll be able to detect
    the coins and other game objects. Choosing which node to use for a particular
    game object is your first important decision when designing your game objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了场景的 `Area2D` 节点，因为它是一个 2D 节点，所以它可以在 2D 空间中移动，并且可以检测与其他节点的重叠，因此我们可以检测到硬币和其他游戏对象。在设计游戏对象时，选择用于特定游戏对象的节点是你的第一个重要决定。
- en: 'Before adding any child nodes, it’s a good idea to make sure you don’t accidentally
    move or resize them by clicking on them. Select the `Player` node and hover your
    mouse on the icon next to the lock, **Group** **Selected Node(s)**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何子节点之前，确保你不小心通过点击它们来移动或调整它们的大小是一个好主意。选择 `Player` 节点并将鼠标悬停在锁旁边的图标上，**选择节点分组**：
- en: '![Figure 2.8: Toggle the node grouping](img/B19289_02_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8：切换节点分组](img/B19289_02_08.jpg)'
- en: 'Figure 2.8: Toggle the node grouping'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：切换节点分组
- en: 'The tooltip says **Make selected node’s children not selectable.**, and that’s
    good – it will help avoid mistakes. Click the button, and you’ll see the same
    icon appear next to the player node’s name:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示说 **使选定的节点子节点不可选择**，这是好的——它将有助于避免错误。点击按钮，你会在玩家节点名称旁边看到相同的图标：
- en: '![Figure 2.9: The node grouping icon](img/B19289_02_09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9：节点分组图标](img/B19289_02_09.jpg)'
- en: 'Figure 2.9: The node grouping icon'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：节点分组图标
- en: It’s a good idea to always do this when creating a new scene. If an object’s
    child nodes become offset or scaled, it can cause unexpected errors and be difficult
    to troubleshoot.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新场景时始终这样做是个好主意。如果一个对象的子节点发生偏移或缩放，可能会导致意外的错误并且难以调试。
- en: Sprite animation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵动画
- en: 'With `Area2D`, you can detect when other objects overlap or run into a player,
    but `Area2D` doesn’t have an appearance on its own. You’ll also need a node that
    can display an image. Since the character has animations, select the player node
    and add an `AnimatedSprite2D` node. This node will handle the appearance and animations
    for the player. Note that there’s a warning symbol next to the node. `AnimatedSprite2D`
    requires a `SpriteFrames` resource, which contains the animation(s) it can display.
    To create one, find the **Frames** property in the **Inspector** window and click
    on **<empty>** to see the dropdown. Select **New SpriteFrames**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Area2D`，你可以检测其他对象是否与玩家重叠或碰撞，但 `Area2D` 本身没有外观。你还需要一个可以显示图像的节点。由于角色有动画，请选择玩家节点并添加一个
    `AnimatedSprite2D` 节点。此节点将处理玩家的外观和动画。注意节点旁边有一个警告符号。`AnimatedSprite2D` 需要一个 `SpriteFrames`
    资源，其中包含它可以显示的动画。要创建一个，找到 **Inspector** 窗口中的 **Frames** 属性并点击 **<empty>** 以查看下拉菜单。选择
    **New SpriteFrames**：
- en: '![Figure 2.10: Adding a SpriteFrames resource](img/B19289_02_10.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10：添加 SpriteFrames 资源](img/B19289_02_10.jpg)'
- en: 'Figure 2.10: Adding a SpriteFrames resource'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：添加 SpriteFrames 资源
- en: 'Next, in the same location, click the `SpriteFrames` label that appeared there
    to open a new panel at the bottom of the screen:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在相同的位置，点击那里出现的 `SpriteFrames` 标签以在屏幕底部打开一个新面板：
- en: '![Figure 2.11: The SpriteFrames panel](img/B19289_02_11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11：SpriteFrames 面板](img/B19289_02_11.jpg)'
- en: 'Figure 2.11: The SpriteFrames panel'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：SpriteFrames 面板
- en: On the left is the list of animations. Click the `default` one and rename it
    `run`. Then, click the `idle` and a third named `hurt`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是动画列表。点击 `default` 并将其重命名为 `run`。然后，点击 `idle` 和第三个名为 `hurt`。
- en: 'In the `res://assets/player/` folder and drag them into the corresponding animations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `res://assets/player/` 文件夹中，并将它们拖动到相应的动画中：
- en: '![Figure 2.12: Setting up player animations](img/B19289_02_12.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12：设置玩家动画](img/B19289_02_12.jpg)'
- en: 'Figure 2.12: Setting up player animations'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：设置玩家动画
- en: Each new animation has a default speed setting of `5` frames per second. This
    is a little too slow, so select each of the animations and set `8`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的动画都有一个默认的每秒`5`帧的速度设置。这有点太慢了，所以选择每个动画并将速度设置为`8`。
- en: 'To see the animations in action, click the **Play** button (![](img/B19289_02_13.png)).
    Your animations will appear in the **Inspector** window in the dropdown for the
    **Animation** property. Choose one to see it in action:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看动画的实际效果，请点击**播放**按钮 (![](img/B19289_02_13.png))。您的动画将出现在**检查器**窗口中**动画**属性的下拉菜单中。选择一个来查看其效果：
- en: '![Figure 2.13: The Animation property](img/B19289_02_14.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13：动画属性](img/B19289_02_14.jpg)'
- en: 'Figure 2.13: The Animation property'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：动画属性
- en: You can also choose an animation to play by default. Select the `idle` animation
    and click the **Autoplay on** **Load** button.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择一个默认播放的动画。选择`idle`动画并点击**加载时自动播放**按钮。
- en: '![Figure 2.14: Setting animation to autoplay](img/B19289_02_15.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14：设置动画自动播放](img/B19289_02_15.jpg)'
- en: 'Figure 2.14: Setting animation to autoplay'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：设置动画自动播放
- en: Later, you’ll write code to select between these animations, depending on what
    the player is doing. However, first, you need to finish setting up the player’s
    nodes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将编写代码来根据玩家的行为在这些动画之间进行选择。然而，首先，您需要完成玩家节点的设置。
- en: The player image is a bit small, so set the `AnimatedSprite2D` to `(2, 2)` in
    order to increase it in scale. You can find this property under the **Transform**
    section in the **Inspector** window.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家图像有点小，所以将`AnimatedSprite2D`的缩放设置为`(2, 2)`以增加其大小。您可以在**检查器**窗口的**变换**部分找到此属性。
- en: '![Figure 2.15: Setting the Scale property](img/B19289_02_16.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15：设置缩放属性](img/B19289_02_16.jpg)'
- en: 'Figure 2.15: Setting the Scale property'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：设置缩放属性
- en: Collision shape
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞形状
- en: When using `Area2D` or one of the other collision objects, you need to tell
    Godot what the shape of the object is. Its collision shape defines the region
    it occupies and is used to detect overlaps and/or collisions. Shapes are defined
    by the various `Shape2D` types and include rectangles, circles, and polygons.
    In game development, this is sometimes referred to as a **hitbox**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Area2D`或其他碰撞对象时，你需要告诉Godot对象的具体形状。其碰撞形状定义了它所占据的区域，并用于检测重叠和/或碰撞。形状由各种`Shape2D`类型定义，包括矩形、圆形和多边形。在游戏开发中，这有时被称为**击打框**。
- en: For convenience, when you need to add a shape to an area or physics body, you
    can add `CollisionShape2D` as a child. Then, you can select the type of shape
    you want and edit its size in the editor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，当您需要向区域或物理体添加形状时，您可以添加`CollisionShape2D`作为子节点。然后，您可以在编辑器中选择所需的形状类型并编辑其大小。
- en: Add `CollisionShape2D` as a child of the `Player` node (make sure you don’t
    add it as a child of `AnimatedSprite2D`). In the **Inspector** window, find the
    **Shape** property and click **<empty>** to select **New RectangleShape2D**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CollisionShape2D`作为`Player`节点的子节点添加（确保不要将其作为`AnimatedSprite2D`的子节点添加）。在**检查器**窗口中，找到**形状**属性并点击**<empty>**以选择**新矩形形状2D**。
- en: '![Figure 2.16: Adding a collision shape](img/B19289_02_17.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16：添加碰撞形状](img/B19289_02_17.jpg)'
- en: 'Figure 2.16: Adding a collision shape'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16：添加碰撞形状
- en: Drag the orange handles to adjust the shape’s size to cover the sprite. Hint
    – if you hold the *Alt* key while dragging a handle, the shape will size symmetrically.
    You may have noticed that the collision shape is not centered on the sprite. That
    is because the sprite images themselves are not centered vertically. You can fix
    this by adding a small offset to `AnimatedSprite2D`. Select the node and look
    for the `(``0, -5)`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动橙色手柄以调整形状的大小以覆盖精灵。提示 - 如果您在拖动手柄时按住*Alt*键，形状将对称地调整大小。您可能已经注意到碰撞形状不是在精灵上居中的。这是因为精灵图像本身在垂直方向上并不居中。您可以通过向`AnimatedSprite2D`添加一个小偏移量来修复这个问题。选择节点并查找`(``0,
    -5)`。
- en: '![Figure 2.17: Sizing the collision shape](img/B19289_02_18.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17：调整碰撞形状大小](img/B19289_02_18.jpg)'
- en: 'Figure 2.17: Sizing the collision shape'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17：调整碰撞形状大小
- en: 'When you’re finished, your **Player** scene should look like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您的**Player**场景应该看起来像这样：
- en: '![Figure 2.18: The Player node setup](img/B19289_02_19.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18：玩家节点设置](img/B19289_02_19.jpg)'
- en: 'Figure 2.18: The Player node setup'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18：玩家节点设置
- en: Scripting the player
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家脚本
- en: 'Now, you’re ready to add some code to the player. Attaching a script to a node
    allows you to add additional functionality that isn’t provided by the node itself.
    Select the `Player` node and click the **new** **script** button:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好向玩家添加一些代码了。将脚本附加到节点允许你添加节点本身不提供的额外功能。选择 `Player` 节点并点击 **新建** **脚本**
    按钮：
- en: '![Figure 2.19: The new script button](img/B19289_02_20.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19：新建脚本按钮](img/B19289_02_20.jpg)'
- en: 'Figure 2.19: The new script button'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19：新建脚本按钮
- en: In the **Attach Node Script** window, you can leave the default settings as
    they are. If you’ve remembered to save the scene, the script will be automatically
    named to match the scene’s name. Click **Create**, and you’ll be taken to the
    script window. Your script will contain some default comments and hints.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **附加节点脚本** 窗口中，你可以保持默认设置不变。如果你记得保存场景，脚本将自动命名为与场景名称匹配。点击 **创建**，你将被带到脚本窗口。你的脚本将包含一些默认的注释和提示。
- en: 'The first line of every script describes what type of node it is attached to.
    Just after that, you can start defining your variables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个脚本的第一个行描述了它附加到的节点类型。就在那之后，你可以开始定义你的变量：
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the `@export` annotation on the `speed` variable allows you to set its
    value in the `Player` node, and you’ll see the `350` speed value you wrote in
    the script.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@export` 注解在 `speed` 变量上允许你在 `Player` 节点中设置其值，你将看到你在脚本中编写的 `350` 速度值。
- en: '![Figure 2.20: The exported variable in the Inspector window](img/B19289_02_21.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20：检查器窗口中导出的变量](img/B19289_02_21.jpg)'
- en: 'Figure 2.20: The exported variable in the Inspector window'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20：检查器窗口中导出的变量
- en: As for the other variables, `velocity` will contain the character’s movement
    speed and direction, while `screensize` will help set the limits of the character’s
    movement. Later, you’ll set this value automatically from the game’s main scene,
    but for now, setting it manually will allow you to test that everything is working.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他变量，`velocity` 将包含角色的移动速度和方向，而 `screensize` 将帮助设置角色移动的限制。稍后，你将从游戏的主场景自动设置此值，但就目前而言，手动设置它将允许你测试一切是否正常工作。
- en: Moving the player
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动玩家
- en: 'Next, you’ll use the `_process()` function to define what the player will do.
    The `_process()` function is called on every frame, so you can use it to update
    elements of your game that you expect to change often. In each frame, you need
    the player to do three things:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 `_process()` 函数来定义玩家将执行的操作。`_process()` 函数在每一帧都会被调用，因此你可以用它来更新你期望经常更改的游戏元素。在每一帧中，你需要玩家执行以下三件事：
- en: Check for keyboard input
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查键盘输入
- en: Move in the given direction
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿给定方向移动
- en: Play the appropriate animation
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放适当的动画
- en: First, you need to check the inputs. For this game, you have four directional
    inputs to check (the four arrow keys). Input actions are defined in **Project
    Settings** under the **Input Map** tab. In this tab, you can define custom events
    and assign keys, mouse actions, or other inputs to them. By default, Godot has
    events assigned to the keyboard arrows, so you can use them for this project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要检查输入。对于这个游戏，你有四个方向输入需要检查（四个箭头键）。输入动作在 **项目设置** 下的 **输入映射** 标签中定义。在这个标签中，你可以定义自定义事件并将键、鼠标动作或其他输入分配给它们。默认情况下，Godot
    已经将事件分配给了键盘箭头，因此你可以使用它们在这个项目中。
- en: You can detect whether an input action is pressed using `Input.is_action_pressed()`,
    which returns `true` if a key is held down and `false` if it is not. Combining
    the states of all four keys will give you the resulting direction of movement.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Input.is_action_pressed()` 来检测是否按下了输入动作，如果按键被按下则返回 `true`，如果没有则返回 `false`。通过组合所有四个键的状态，你可以得到运动的结果方向。
- en: 'You can do this by checking all four keys separately using multiple `if` statements,
    but since this is such a common need, Godot provides a useful function called
    `Input.get_vector()` that will handle this for you – you just have to tell it
    which four inputs to use. Note the order that the input actions are listed in;
    `get_vector()` expects them in this order. The result of this function is a **direction
    vector** – a vector pointing in one of the eight possible directions resulting
    from the pressed inputs:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用多个 `if` 语句分别检查所有四个键来完成此操作，但由于这是一个如此常见的需求，Godot 提供了一个有用的函数 `Input.get_vector()`，它会为你处理这些操作——你只需要告诉它要使用哪四个输入。注意输入动作的列表顺序；`get_vector()`
    期望它们按照这个顺序。此函数的结果是一个 **方向向量**——一个指向八个可能方向之一的向量，这些方向由按下的输入产生：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After that, you’ll have a `velocity` vector indicating which direction to move
    in, so the next step will be to actually update the player’s `position` using
    that velocity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将有一个指示移动方向的 `velocity` 向量，所以下一步将是使用该速度实际更新玩家的 `position`。
- en: Click **Run Current Scene** (*F6*) at the top right, and check that you can
    move the player around using all four arrow keys.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角点击 **运行当前场景** (*F6*)，并检查你是否可以使用所有四个箭头键移动玩家。
- en: 'You may notice that the player continues running off the side of the screen.
    You can use the `clamp()` function to limit the player’s `position` to minimum
    and maximum values, preventing them from leaving the screen. Add these two lines
    next, immediately after the previous line:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到玩家继续从屏幕的一侧跑出去。你可以使用 `clamp()` 函数将玩家的 `position` 限制在最小和最大值之间，防止他们离开屏幕。在上一行之后立即添加这两行：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: About delta
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 delta
- en: The `_process()` function includes a parameter called `delta` that is then multiplied
    by `velocity`. What is `delta`?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`_process()` 函数包括一个名为 `delta` 的参数，然后将其乘以 `velocity`。`delta` 是什么？'
- en: The game engine attempts to run at a constant `60` frames per second. However,
    this can change due to computer slowdowns, either in Godot or from other programs
    running on your computer at the same time. If the frame rate is not consistent,
    then it will affect the movement of objects in your game. For example, consider
    an object that you want to move at `10` pixels every frame. If everything runs
    smoothly, this will mean the object moves `600` pixels in one second. However,
    if some of those frames take a bit longer, then there may have been only `50`
    frames in that second, so the object only moved `500` pixels.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎试图以每秒 `60` 帧的速率运行。然而，这可能会因为 Godot 或你电脑上同时运行的其他程序导致的计算机减速而改变。如果帧率不稳定，那么它将影响你游戏中对象的移动。例如，考虑一个你想要每帧移动
    `10` 像素的对象。如果一切运行顺利，这意味着对象在一秒内移动 `600` 像素。然而，如果其中一些帧耗时较长，那么那一秒可能只有 `50` 帧，因此对象只移动了
    `500` 像素。
- en: Godot, like many game engines and frameworks, solves this by passing you a value
    called `delta`, which is the elapsed time since the previous frame. Most of the
    time, this will be very close to `0.016` seconds (around 16 milliseconds). If
    you then take your desired speed of `600` px/second and multiply it by `delta`,
    you’ll get a movement of exactly `10` pixels. If, however, `delta` increased to
    `0.3` seconds, then the object would move `18` pixels. Overall, the movement speed
    remains consistent and independent of the frame rate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Godot，就像许多游戏引擎和框架一样，通过传递一个名为 `delta` 的值来解决此问题，这个值是自上一帧以来的经过时间。大多数情况下，这将是非常接近
    `0.016` 秒（大约 16 毫秒）。如果你然后将你期望的速度 `600` 像素/秒乘以 `delta`，你将得到正好 `10` 像素的移动。然而，如果
    `delta` 增加到 `0.3` 秒，那么对象将移动 `18` 像素。总的来说，移动速度保持一致，且与帧率无关。
- en: As a side benefit, you can express your movement in units of pixels per second
    rather than pixels per frame, which is easier to visualize.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项额外的好处，你可以用每秒像素数而不是每帧像素数来表示你的移动，这更容易可视化。
- en: Choosing animations
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择动画
- en: 'Now that the player can move, you need to change which animation `AnimatedSprite2D`
    is playing, based on whether the player moves or stands still. The art for the
    `run` animation faces to the right, which means it needs to be flipped horizontally
    (using the `_process()` function after the movement code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以移动了，你需要根据玩家是移动还是静止来更改 `AnimatedSprite2D` 正在播放的动画。`run` 动画的美术面向右侧，这意味着它需要水平翻转（在移动代码之后使用
    `_process()` 函数）：
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting nodes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取节点
- en: When using the `$` notation, the node name is *relative* to the node running
    the script. For example, `$Node1/Node2` would refer to a node (`Node2`) that is
    a child of `Node1`, which is itself a child of the node that runs the script.
    Godot’s autocomplete will suggest node names as you type. Note that if the name
    contains spaces, you must put quote marks around it – for example, `$"``My Node"`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `$` 符号时，节点名称是相对于运行脚本的节点而言的。例如，`$Node1/Node2` 将指代一个节点（`Node2`），它是 `Node1`
    的子节点，而 `Node1` 本身又是运行脚本的节点的子节点。Godot 的自动完成功能会在你输入时建议节点名称。请注意，如果名称包含空格，你必须将其放在引号内——例如，`$"``My
    Node"`。
- en: Note that this code takes a little shortcut. `flip_h` is a Boolean property,
    which means it can be `true` or `false`. A Boolean value is also the result of
    a comparison, such as `<`. Because of this, you can directly set the property
    equal to the result of the comparison.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码采取了一些捷径。`flip_h`是一个布尔属性，这意味着它可以设置为`true`或`false`。布尔值也是比较的结果，例如`<`。正因为如此，你可以直接将属性设置为比较的结果。
- en: Play the scene again and check that the animations are correct in each case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再次播放场景，并检查每种情况下动画是否正确。
- en: Starting and ending the player’s movement
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始和结束玩家的移动
- en: 'The main scene will need to inform the player when the game has started and
    ended. To do that, add a `start()` function to the player, which will set the
    player’s starting position and animation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 主场景需要通知玩家游戏何时开始和结束。为此，向玩家添加一个`start()`函数，该函数将设置玩家的起始位置和动画：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, add a `die()` function to be called when the player hits an obstacle
    or runs out of time:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加一个`die()`函数，当玩家撞到障碍物或用完时间时调用：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using `set_process(false)` tells Godot to stop calling the `_process()` function
    every frame. Since the movement code is in that function, you’ll no longer be
    able to move when the game is over.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set_process(false)`告诉Godot停止每帧调用`_process()`函数。由于移动代码在该函数中，因此当游戏结束时，你将无法移动。
- en: Preparing for collisions
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备碰撞
- en: The player should detect when it hits a coin or an obstacle, but you haven’t
    made those objects yet. That’s OK because you can use Godot’s *signal* functionality
    to make it work. Signals are a way for nodes to send out messages that other nodes
    can detect and react to. Many nodes have built-in signals to alert you when events
    occur, such as a body colliding or a button being pressed. You can also define
    custom signals for your own purposes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该能够检测到它撞到硬币或障碍物，但你还没有制作这些对象。没关系，因为你可以使用Godot的*信号*功能来实现这一点。信号是节点发送消息的方式，其他节点可以检测并响应。许多节点都有内置的信号，用于在事件发生时提醒你，例如身体碰撞或按钮被按下。你也可以为你的目的定义自定义信号。
- en: Signals are used by *connecting* them to the node(s) that you want to listen
    for them. This connection can be made in the **Inspector** window or in code.
    Later in the project, you’ll learn how to connect signals in both ways.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通过*连接*到你想监听的节点来使用。这种连接可以在**Inspector**窗口或代码中完成。在项目后期，你将学习如何以这两种方式连接信号。
- en: 'Add the following lines to the top of the script (after `extends Area2D`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到脚本顶部（在`extends Area2D`之后）：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These lines declare custom signals that your player will `Area2D` itself. Select
    the `Player` node, and click the **Node** tab next to the **Inspector** tab to
    see a list of signals the player can emit:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行声明了玩家将向`Area2D`本身发出的自定义信号。选择`Player`节点，然后点击**Inspector**标签旁边的**Node**标签，以查看玩家可以发出的信号列表：
- en: '![Figure 2.21: The node’s list of signals](img/B19289_02_22.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21：节点的信号列表](img/B19289_02_22.jpg)'
- en: 'Figure 2.21: The node’s list of signals'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：节点的信号列表
- en: Note your custom signals there as well. Since the other objects will also be
    `Area2D` nodes, you’ll want to use the `area_entered` signal. Select it and click
    `_on_area_entered()` in your script.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 也要在那里记录你的自定义信号。由于其他对象也将是`Area2D`节点，你将想要使用`area_entered`信号。选择它，并在你的脚本中点击`_on_area_entered()`。
- en: When connecting a signal, instead of having Godot create the function for you,
    you can also give the name of an existing function that you want to use instead.
    Toggle the **Make Function** switch off if you don’t want Godot to create the
    function for you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接信号时，你不仅可以让Godot为你创建函数，还可以指定你想要使用的现有函数的名称。如果你不想让Godot为你创建函数，请关闭**Make Function**开关。
- en: 'Add the following code to this new function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到这个新函数中：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whenever another area object overlaps with the player, this function will be
    called, and that overlapping area will be passed in with the `area` parameter.
    The coin object will have a `pickup()` function that defines what the coin does
    when picked up (playing an animation or sound, for example). When you create the
    coins and obstacles, you’ll assign them to the appropriate **group** so that they
    can be detected correctly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一个区域对象与玩家重叠时，此函数将被调用，并且重叠的区域将通过`area`参数传递。硬币对象将有一个`pickup()`函数，该函数定义了捡起硬币时硬币会做什么（例如播放动画或声音）。当你创建硬币和障碍物时，你需要将它们分配到适当的**组**，以便它们可以被正确检测。
- en: 'To summarize, here is the complete player script so far:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，到目前为止的完整玩家脚本如下：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ve completed setting up the player object, and you’ve tested that the movement
    and animations work correctly. Before you move on to the next step, review the
    player scene setup and the script, and make sure you understand what you’ve done
    and why. In the next section, you’ll make some objects for the player to collect.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了玩家对象的设置，并且已经测试了移动和动画是否正常工作。在继续下一步之前，请回顾玩家场景设置和脚本，并确保你理解你所做的一切以及为什么这样做。在下一节中，你将为玩家创建一些可收集的对象。
- en: Part 2 – the coin scene
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分 – 硬币场景
- en: In this part, you’ll make coins for the player to collect. This will be a separate
    scene, describing all the properties and behavior of a single coin. Once saved,
    the main scene will load this one and create multiple **instances** (that is,
    copies) of it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将为玩家创建硬币。这将是一个独立的场景，描述单个硬币的所有属性和行为。一旦保存，主场景将加载这个场景并创建多个 **实例**（即副本）。
- en: The node setup
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点设置
- en: 'Click `Player` scene:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `Player` 场景：
- en: '`Area2D` (named `Coin`):'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D`（命名为 `Coin`）:'
- en: '`AnimatedSprite2D`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimatedSprite2D`'
- en: '`CollisionShape2D`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: Make sure to save the scene once you’ve added the nodes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在添加节点后保存场景。
- en: Set up `AnimatedSprite2D` as you did in the player scene. This time, you only
    have one animation – a shine/sparkle effect that makes the coin look dynamic and
    interesting. Add all the frames and set the animation speed to `12 FPS`. The images
    are also a little too large, so set the `AnimatedSprite2D` to `(0.4, 0.4)`. In
    `CollisionShape2D`, use `CircleShape2D` and resize it to cover the coin image.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照玩家场景中的方式设置 `AnimatedSprite2D`。这次，你只有一个动画 – 一种使硬币看起来动态且有趣的光泽/闪耀效果。添加所有帧并将动画速度设置为
    `12 FPS`。图像也稍微有点大，所以将 `AnimatedSprite2D` 设置为 `(0.4, 0.4)`。在 `CollisionShape2D`
    中，使用 `CircleShape2D` 并将其调整大小以覆盖硬币图像。
- en: Using groups
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用组
- en: 'Groups provide a tagging system for nodes, allowing you to identify similar
    nodes. A node can belong to any number of groups. In order for the player script
    to correctly detect a coin, you need to ensure that all coins will be in a group
    called `Coin` node, click the `coins` in the box and click **Add**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 组为节点提供了一种标记系统，允许你识别相似的节点。一个节点可以属于任意数量的组。为了让玩家脚本正确检测到硬币，你需要确保所有硬币都将位于一个名为 `Coin`
    的组中，点击框中的 `coins` 并点击 **添加**：
- en: '![Figure 2.22: The Groups tab](img/B19289_02_23.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22：组选项卡](img/B19289_02_23.jpg)'
- en: 'Figure 2.22: The Groups tab'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：组选项卡
- en: Coin script
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬币脚本
- en: 'Your next step is to add a script to the `Coin` node. Select the node and click
    the new script button, just like you did with the `Player` node. If you uncheck
    the **Template** option, you’ll get an empty script without any comments or suggestions.
    The code for the coin is much shorter than the code for the player:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一步是为 `Coin` 节点添加一个脚本。选择节点并点击新脚本按钮，就像你对 `Player` 节点所做的那样。如果你取消选择 **模板** 选项，你将得到一个没有注释或建议的空脚本。硬币的代码比玩家的代码要短得多：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Recall that the `pickup()` function is called by the player script. It defines
    what the coin will do when collected. `queue_free()` is Godot’s method for removing
    nodes. It safely removes the node from the tree and deletes it from memory, along
    with all its children. Later, you’ll add visual and audio effects here, but for
    now, just having the coin disappear is good enough.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`pickup()` 函数是由玩家脚本调用的。它定义了收集硬币时硬币将执行的操作。`queue_free()` 是 Godot 用于删除节点的函数。它安全地从树中删除节点并从内存中删除它及其所有子节点。稍后，你将在这里添加视觉和音频效果，但现在，让硬币消失就足够了。
- en: Removing nodes
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点
- en: '`queue_free()` doesn’t delete the object immediately, but rather adds it to
    a queue to be deleted at the end of the current frame. This is safer than immediately
    deleting the node because other code running in the game may still need the node
    to exist. By waiting until the end of the frame, Godot can be sure that all code
    that can access the node has completed and the node can be removed safely.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_free()` 并不会立即删除对象，而是将其添加到队列中，在当前帧结束时删除。这比立即删除节点更安全，因为游戏中可能还有其他代码需要节点存在。通过等待到帧的末尾，Godot
    可以确保所有可以访问节点的代码都已完成，节点可以安全地被移除。'
- en: You’ve now completed the second of the two objects needed for this game. The
    coin object is ready to be placed randomly on the screen, and it can detect when
    it’s touched by the player, so it can be collected. The remaining piece of the
    puzzle is how to put it all together. In the next section, you’ll create a third
    scene to randomly create coins and allow the player to interact with them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经完成了这个游戏所需的两个对象中的第二个。硬币对象可以随机放置在屏幕上，并且它可以检测玩家何时触摸它，因此可以被收集。拼图的剩余部分是如何将所有这些组合在一起。在下一节中，你将创建第三个场景以随机生成硬币并允许玩家与之交互。
- en: Part 3 – the Main scene
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 – 主场景
- en: The `Main` scene is what ties all the pieces of the game together. It will manage
    the player, the coins, the clock, and all the other pieces of the game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 场景是将游戏的所有部分联系在一起的关键。它将管理玩家、硬币、时钟以及游戏的所有其他部分。'
- en: Node setup
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点设置
- en: Create a new scene and add a `Node` named `Main`. The simplest type of node
    is `Node` – it doesn’t do much at all on its own, but you’ll use it as the parent
    for all the game objects and add a script that will give it the functionality
    you need. Save the scene.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为 `Main` 的 `Node`。最简单的节点类型是 `Node` —— 它本身几乎不做任何事情，但你会将其用作所有游戏对象的父节点，并添加一个脚本，使其具有你需要的功能。保存场景。
- en: 'Add the player as a child of `Main` by clicking the `player.tscn`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 `player.tscn` 将玩家添加为 `Main` 的子节点：
- en: '![Figure 2.23: Instantiating a scene](img/B19289_02_24.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23：实例化场景](img/B19289_02_24.jpg)'
- en: 'Figure 2.23: Instantiating a scene'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23：实例化场景
- en: 'Add the following nodes as children of `Main`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下节点作为 `Main` 的子节点添加：
- en: A `TextureRect` node named `Background` – for the background image
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Background` 的 `TextureRect` 节点——用于背景图像
- en: A `Timer` node named `GameTimer` – for the countdown timer
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `GameTimer` 的 `Timer` 节点——用于倒计时计时器
- en: 'Make sure `Background` is the first child node by dragging it above the player
    in the node list. Nodes are drawn in the order shown in the tree, so if `Background`
    is first, that ensures it’s drawn behind the player. Add an image to the `Background`
    node by dragging the `grass.png` image from the `assets` folder into the **Texture**
    property. Change **Stretch Mode** to **Tile**, and then set the size to **Full
    Rect** by clicking the layout button at the top of the editor window:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `Background` 作为第一个子节点，通过在节点列表中将它拖到玩家上方。节点按照在树中显示的顺序绘制，所以如果 `Background`
    是第一个，那么确保它在玩家后面绘制。通过将 `assets` 文件夹中的 `grass.png` 图像拖动到编辑器窗口顶部的布局按钮上的 **Texture**
    属性来添加图像到 `Background` 节点。将 **Stretch Mode** 改为 **Tile**，然后通过点击编辑器窗口顶部的布局按钮将大小设置为
    **Full Rect**：
- en: '![Figure 2.24: Layout options](img/B19289_02_25.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24：布局选项](img/B19289_02_25.jpg)'
- en: 'Figure 2.24: Layout options'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24：布局选项
- en: Main script
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主脚本
- en: 'Add a script to the `Main` node and add the following variables:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到 `Main` 节点，并添加以下变量：
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Main` node. Drag `coin.tscn` from the **FileSystem** panel and drop it
    into the **Coin** **Scene** property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 节点。从 **FileSystem** 面板拖动 `coin.tscn` 并将其放入 **Coin** **Scene** 属性。'
- en: Initializing
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: 'To start things off, add the `_ready()` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加 `_ready()` 函数：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Godot automatically calls `_ready()` on every node when it’s added. This is
    a good place to put code that you want to happen at the beginning of a node’s
    lifetime.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 在每个节点被添加时自动调用 `_ready()`。这是一个放置你希望在节点生命周期开始时执行的代码的好地方。
- en: Note that you’re referring to the `Player` node by name using the `$` syntax,
    allowing you to find the size of the game screen and set the player’s `screensize`
    variable. `hide()` makes a node invisible, so you won’t see the player before
    the game starts.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你正在使用 `$` 语法通过名称引用 `Player` 节点，这使得你可以找到游戏屏幕的大小并设置玩家的 `screensize` 变量。`hide()`
    使节点不可见，所以在游戏开始之前你不会看到玩家。
- en: Starting a new game
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: 'The `new_game()` function will initialize everything for a new game:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_game()` 函数将为新游戏初始化一切：'
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In addition to setting the variables to their starting values, this function
    calls the player’s `start()` function that you wrote earlier. Starting `GameTimer`
    will start counting down the remaining time in the game.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置变量的起始值外，此函数还调用你之前编写的玩家的 `start()` 函数。启动 `GameTimer` 将开始倒计时游戏剩余时间。
- en: 'You also need a function that will create a number of coins based on the current
    level:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个函数，该函数将根据当前级别创建一定数量的硬币：
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, you create multiple `Coin` object and add them as children
    of `Main` (in code this time, rather than by manually clicking on the `add_child()`.
    Lastly, you choose a random position for the coin, using the `screensize` variable
    so that they won’t appear off screen. You’ll call this function at the start of
    every level, generating more coins each time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你创建多个 `Coin` 对象并将它们作为 `Main` 的子对象添加（这次是通过代码，而不是手动点击 `add_child()`。最后，你使用
    `screensize` 变量选择金币的随机位置，这样它们就不会出现在屏幕之外。你将在每个级别的开始时调用这个函数，每次生成更多的金币。
- en: Eventually, you’ll want `new_game()` to be called when the player clicks the
    `new_game()` to the end of your `_ready()` function and click `main.tscn`. Now,
    whenever you play the project, the `Main` scene will be started.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你希望当玩家点击 `_ready()` 函数末尾的 `new_game()` 并点击 `main.tscn` 时调用 `new_game()`。现在，每次你玩这个项目时，`Main`
    场景都将启动。
- en: At this point, you should see your player and five coins appear on the screen.
    When the player touches a coin, it disappears.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你应该在屏幕上看到你的玩家和五个金币出现。当玩家触摸一个金币时，它会消失。
- en: Once you’re done testing, remove `new_game()` from the `_ready()` function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，从 `_ready()` 函数中移除 `new_game()`。
- en: Checking for remaining coins
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查剩余金币
- en: 'The `main` script needs to detect whether the player has picked up all the
    coins. Since the coins are all in the `coins` group, you can check the size of
    the group to see how many remain. Since it needs to be checked continuously, put
    it in the `_process()` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 脚本需要检测玩家是否已经捡起所有金币。由于所有金币都在 `coins` 组中，你可以检查组的大小以查看剩余多少。由于需要持续检查，将其放在
    `_process()` 函数中：'
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If no more coins remain, then the player advances to the next level.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的金币剩余，那么玩家将进入下一级。
- en: This completes the main scene. The most important thing you learned in this
    step was how to dynamically create new objects in code using `instantiate()`.
    This is something that you will use again and again in building many types of
    game systems. In the last step, you’ll create one more scene to handle displaying
    game information, such as the player’s score and the time remaining.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了主要场景。在这个步骤中，你学到的最重要的东西是如何使用 `instantiate()` 动态在代码中创建新对象。这是在构建许多类型的游戏系统时你会反复使用的东西。在上一个步骤中，你将创建一个额外的场景来处理显示游戏信息，例如玩家的得分和剩余时间。
- en: Part 4 – the user interface
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分 – 用户界面
- en: The final element your game needs is a **user interface** (**UI**). This will
    display information that the player needs to see during gameplay, which is often
    referred to as a **heads-up display** (**HUD**) because the information appears
    as an overlay on top of the game view. You’ll also use this scene to display a
    start button after the game ends.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏需要的最后一个元素是 **用户界面**（**UI**）。这将在游戏过程中显示玩家需要看到的信息，通常被称为 **抬头显示**（**HUD**），因为信息以叠加的形式出现在游戏视图之上。你还将使用这个场景在游戏结束后显示一个开始按钮。
- en: 'Your HUD will display the following information:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 HUD 将显示以下信息：
- en: The score
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分
- en: The time remaining
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余时间
- en: A message, such as **Game Over**
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个消息，例如 **游戏结束**
- en: A start button
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个开始按钮
- en: Node setup
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点设置
- en: Create a new scene and add a `CanvasLayer` node named `HUD`. A `CanvasLayer`
    node creates a new drawing layer, which will allow you to draw your UI elements
    above the rest of the game so that it doesn’t get covered up by game objects,
    such as the player or coins.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为 `HUD` 的 `CanvasLayer` 节点。一个 `CanvasLayer` 节点创建一个新的绘图层，这将允许你在游戏的其他部分之上绘制你的
    UI 元素，这样它就不会被游戏对象，如玩家或金币，覆盖。
- en: 'Godot provides a variety of UI elements that can be used to create anything
    from indicators, such as health bars, to complex interfaces, such as inventories.
    In fact, the Godot editor that you use to make this game is built using the Godot
    UI elements. The basic nodes for a UI are all extended from `Control` and appear
    with green icons in the node list. To create your UI, you’ll use various `Control`
    nodes to position, format, and display information. Here’s what the HUD will look
    like when complete:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 提供了各种 UI 元素，可以用来创建从指示器，如生命值条，到复杂界面，如存货界面。实际上，你用来制作这个游戏的 Godot 编辑器就是使用
    Godot UI 元素构建的。UI 的基本节点都扩展自 `Control`，并在节点列表中显示为绿色图标。为了创建你的 UI，你将使用各种 `Control`
    节点来定位、格式化和显示信息。以下是完成后的 HUD 看起来的样子：
- en: '![Figure 2.25: The HUD layout](img/B19289_02_26.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25：HUD 布局](img/B19289_02_26.jpg)'
- en: 'Figure 2.25: The HUD layout'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25：HUD 布局
- en: Message label
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息标签
- en: Add a `Label` node to the scene and change its name to `Message`. This label
    will display the game’s title as well as **Game Over** when the game ends. This
    label should be centered on the game screen. You can drag it with the mouse, or
    set the values directly in the **Inspector** window, but it’s easiest to use the
    shortcuts provided in the layout menu, which will set the values for you.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个`Label`节点添加到场景中，并将其名称更改为`Message`。当游戏结束时，此标签将显示游戏的标题以及**游戏结束**。此标签应位于游戏屏幕中央。您可以使用鼠标拖动它，或在**检查器**窗口中直接设置值，但使用布局菜单中提供的快捷键最简单，这将为您设置值。
- en: 'Select **HCenter Wide** from the layout menu:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从布局菜单中选择**HCenter Wide**：
- en: '![Figure 2.26: Positioning the message](img/B19289_02_27.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图2.26：消息定位](img/B19289_02_27.jpg)'
- en: 'Figure 2.26: Positioning the message'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26：消息定位
- en: The label now spans the width of the screen and is centered vertically. The
    **Text** property sets what text the label displays. Set it to **Coin Dash!**,
    and set **Horizontal Alignment** and **Vertical Alignment** both to **Center**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 标签现在横跨屏幕宽度并垂直居中。**文本**属性设置标签显示的文本。将其设置为**Coin Dash!**，并将**水平对齐**和**垂直对齐**都设置为**居中**。
- en: The default font for `Label` nodes is very small and unattractive, so the next
    step is to assign a custom font. In the **Label Settings** property, select **New
    LabelSettings** and then click it to expand.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`节点的默认字体非常小且不吸引人，所以下一步是分配一个自定义字体。在**标签设置**属性中，选择**新标签设置**然后点击它以展开。'
- en: 'From the `Kenney Bold.ttf` font file and drop it into the **Font** property,
    and then set **Size** to **48**. You can also improve the appearance by adding
    a shadow – try the settings shown in the following screenshot, or experiment with
    your own:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Kenney Bold.ttf`字体文件中拖动它到**字体**属性，并将**大小**设置为**48**。您还可以通过添加阴影来改善外观——尝试以下截图中的设置，或尝试您自己的设置：
- en: '![Figure 2.27: Font settings](img/B19289_02_28.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图2.27：字体设置](img/B19289_02_28.jpg)'
- en: 'Figure 2.27: Font settings'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27：字体设置
- en: Score and time display
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数和时间显示
- en: The top of the HUD will display the player’s score and the time remaining on
    the clock. Both of these will be `Label` nodes, arranged at opposite sides of
    the game screen. Rather than position them separately, you’ll use a **container**
    node to manage their positions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: HUD的顶部将显示玩家的分数和时钟剩余时间。这两个都将使用`Label`节点，并安排在游戏屏幕的相对两侧。您将使用**容器**节点来管理它们的位置。
- en: Containers
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: Godot’s `Container` nodes automatically arrange the positions and sizes of their
    child `Control` nodes (including other containers). You can use them to add padding
    around elements, keep them centered, or arrange them in rows and columns. Each
    type of `Container` has special properties that control how they arrange their
    children.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Godot的`Container`节点会自动安排其子`Control`节点（包括其他容器）的位置和大小。您可以使用它们在元素周围添加填充、使它们居中，或按行和列排列。每种类型的`Container`都有特殊的属性来控制它们如何排列其子节点。
- en: Remember that containers automatically arrange their children. If you try to
    move or resize a `Control` that’s inside a `Container` node, you’ll get a warning
    from the editor. You can manually arrange controls *or* arrange them with a container,
    but not both.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，容器会自动排列其子节点。如果您尝试移动或调整容器节点内的`Control`的大小，编辑器会发出警告。您可以手动排列控件*或*使用容器排列控件，但不能同时进行。
- en: Score and time display
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数和时间显示
- en: To manage the score and time labels, add a `MarginContainer` node to the `HUD`.
    Use the layout menu to set the anchors to `10`. This will add some padding so
    that the text isn’t against the edge of the screen.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理分数和时间标签，请将一个`MarginContainer`节点添加到`HUD`中。使用布局菜单设置锚点为`10`。这将添加一些填充，使文本不会紧贴屏幕边缘。
- en: Since the score and time labels will use the same font settings as `Message`,
    you can save time by duplicating it. Select `Message` and press *Ctrl* + *D* twice
    to create two duplicate labels. Drag them both and drop them onto `MarginContainer`
    to make them its children. Name one child `Score` and the other `Time`, and set
    the `Score` but `Time`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分数和时间标签将使用与`Message`相同的字体设置，您可以通过复制它来节省时间。选择`Message`并按*Ctrl* + *D*两次以创建两个副本标签。将它们都拖动并放到`MarginContainer`中，使它们成为其子节点。将一个子节点命名为`Score`，另一个命名为`Time`，并设置`Score`但不要设置`Time`。
- en: Updating the UI via GDScript
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过GDScript更新UI
- en: 'Add a script to the `HUD` node. This script will update the UI elements when
    their properties need to change, such as updating the `Score` text whenever a
    coin is collected. See the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到 `HUD` 节点。此脚本将在需要更改属性时更新 UI 元素，例如，每当收集到一个硬币时更新 `Score` 文本。请参阅以下代码：
- en: '[PRE15]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Main` scene’s script will call these two functions to update the display
    whenever there is a change in a value. For the `Message` label, you also need
    a timer to make it disappear after a brief period.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 场景的脚本将调用这两个函数以在值发生变化时更新显示。对于 `Message` 标签，您还需要一个计时器，以便在短时间内消失。'
- en: 'Add a `Timer` node as a child of `HUD`, and set `2` seconds and **One Shot**
    to **On**. This ensures that, when started, the timer will only run once, rather
    than repeating. Add the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HUD` 下添加一个 `Timer` 节点，并设置 `2` 秒和 **One Shot** 为 **开启**。这确保了当启动计时器时，它只会运行一次，而不是重复。添加以下代码：
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this function, you will display the message and start the timer. To hide
    the message, connect the `timeout` signal of `Timer` (remember that it will automatically
    create the new function):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，您将显示消息并启动计时器。要隐藏消息，连接 `Timer` 的 `timeout` 信号（记住，它将自动创建新函数）：
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using buttons
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用按钮
- en: Add a `Button` node to `HUD` and change its name to `StartButton`. This button
    will be displayed before the game starts, and when clicked, it will hide itself
    and send a signal to the `Main` scene to start the game. Set the `Message`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HUD` 中添加一个 `Button` 节点，并将其名称更改为 `StartButton`。此按钮将在游戏开始前显示，点击后将隐藏自身并向 `Main`
    场景发送信号以开始游戏。设置 `Message`。
- en: In the layout menu, choose **Center Bottom** to center the button at the bottom
    of the screen.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局菜单中，选择 **Center Bottom** 以将按钮居中显示在屏幕底部。
- en: 'When a button is pressed, it emits a signal. In the `StartButton`, connect
    the `pressed` signal:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，它会发出一个信号。在 `StartButton` 中连接 `pressed` 信号：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Game over
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'The final task for your UI script is to react to the game ending:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 UI 脚本的最终任务是响应游戏结束：
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this function, you need the `show_message("Game Over")` does. However, you
    then want to show the start button and game title once the message has disappeared.
    The `await` command pauses the execution of a function until the given node (`Timer`)
    emits a given signal (`timeout`). Once the signal is received, the function continues,
    and everything will be returned to its initial state so that you can play again.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，您需要 `show_message("Game Over")` 执行的操作。然而，一旦消息消失，您希望显示开始按钮和游戏标题。`await`
    命令暂停函数的执行，直到给定的节点（`Timer`）发出给定的信号（`timeout`）。一旦接收到信号，函数将继续，一切将恢复到初始状态，以便您可以再次游戏。
- en: Adding HUD to Main
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 HUD 添加到 Main
- en: 'The next task is to set up the communication between `Main` and `HUD`. Add
    an instance of `HUD` to `Main`. In `Main`, connect the `timeout` signal of `GameTimer`
    and add the following so that every time `GameTimer` times out (every second),
    the remaining time is reduced:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是设置 `Main` 和 `HUD` 之间的通信。将 `HUD` 的实例添加到 `Main` 中。在 `Main` 中，连接 `GameTimer`
    的 `timeout` 信号，并添加以下内容，以便每次 `GameTimer` 超时（每秒）时，剩余时间都会减少：
- en: '[PRE20]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, select the instance of `Player` in `Main` and connect its `pickup` and
    `hurt` signals:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择 `Main` 中的 `Player` 实例，并连接其 `pickup` 和 `hurt` 信号：
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Several things need to happen when the game ends, so add the following function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时需要发生几件事情，因此添加以下函数：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This function halts the game and also uses `call_group()` to remove all remaining
    coins by calling `queue_free()` on each of them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数停止游戏并使用 `call_group()` 通过对每个剩余的硬币调用 `queue_free()` 来移除所有剩余的硬币。
- en: 'Finally, pressing `StartButton` needs to activate `Main`’s `new_game()` function.
    Select the instance of `HUD` and connect its `start_game` signal:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按下 `StartButton` 需要激活 `Main` 的 `new_game()` 函数。选择 `HUD` 的实例，并连接其 `start_game`
    信号：
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Make sure you’ve removed `new_game()` from `Main`’s `_ready()` function (remember,
    that was only there to test), and add these two lines to `new_game()`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已从 `Main` 的 `_ready()` 函数中删除 `new_game()`（记住，那只是为了测试），并将这两行添加到 `new_game()`
    中：
- en: '[PRE24]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, you can play the game! Confirm that all parts are working as intended –
    the score, the countdown, the game ending and restarting, and so on. If you find
    a part that’s not working, go back and check the step where you created it, as
    well as the step(s) where it may have been connected to the rest of the game.
    A common mistake is to forget to connect one of the many signals you used in different
    parts of the game.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以玩游戏了！确认所有部分都按预期工作——得分、倒计时、游戏结束和重新开始等。如果你发现某个部分没有正常工作，请返回并检查你创建它的步骤，以及可能将其连接到游戏其他部分的步骤。一个常见的错误是忘记连接你在游戏不同部分使用的许多信号之一。
- en: Once you’ve played the game and confirmed that everything works correctly, you
    can move on to the next section, where you can add a few additional features to
    round out the game experience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你玩过游戏并确认一切正常工作，你就可以继续到下一部分，在那里你可以添加一些额外的功能来完善游戏体验。
- en: Part 5 – finishing up
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分 - 收尾
- en: Congratulations on creating a complete, working game! In this section, you’ll
    add a few extra things to the game to make it a little more exciting. Game developers
    use the term **juice** to describe the things that make a game feel good to play.
    Juice can include things such as sound, visual effects, or any other addition
    that adds to the player’s enjoyment, without necessarily changing the nature of
    the gameplay.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你创建了一个完整、可工作的游戏！在本节中，你将向游戏中添加一些额外的东西，使其更加有趣。游戏开发者使用术语**juice**来描述使游戏感觉好玩的事物。juice可以包括声音、视觉效果或任何其他增加玩家享受的东西，而无需改变游戏玩法本身。
- en: Visual effects
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉效果
- en: When you pick up the coins, they just disappear, which is not very appealing.
    Adding a visual effect will make it much more satisfying to collect lots of coins.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你捡起硬币时，它们只是消失了，这并不很有吸引力。添加视觉效果将使收集大量硬币变得更加令人满意。
- en: What is a tween?
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是tween？
- en: A **tween** is a way to **interpolate** (change gradually) some value over time
    using a particular mathematical function. For example, you might choose a function
    that steadily changes a value or one that starts slow but ramps up in speed. Tweening
    is also sometimes referred to as **easing**. You can see animated examples of
    lots of tweening functions at https://easings.net/.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**tween**是一种使用特定的数学函数在时间上逐渐改变某个值的方法。例如，你可能选择一个稳定改变值的函数，或者一个开始缓慢但逐渐加速的函数。tweening有时也被称为**easing**。你可以在https://easings.net/看到许多tweening函数的动画示例。'
- en: When using a tween in Godot, you can assign it to alter one or more properties
    of a node. In this case, you’re going to increase the scale of the coin and also
    cause it to fade out using the **Modulate** property. Once the tween has finished
    its job, the coin will be deleted.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中使用tween时，你可以将其分配给改变一个或多个节点的属性。在这种情况下，你将增加硬币的缩放，并使用**Modulate**属性使其淡出。一旦tween完成其工作，硬币将被删除。
- en: However, there’s a problem. If we don’t remove the coin immediately, then it’s
    possible for the player to move onto the coin again – triggering the `area_entered`
    signal a second time and registering it as a second pickup. To prevent this, you
    can disable the collision shape so that the coin can’t trigger any further collisions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题。如果我们不立即移除硬币，那么玩家可能再次移动到硬币上——触发`area_entered`信号第二次，并注册为第二次拾取。为了防止这种情况，你可以禁用碰撞形状，这样硬币就不能触发任何进一步的碰撞。
- en: 'Your new `pickup()` function should look like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你新的`pickup()`函数应该看起来像这样：
- en: '[PRE25]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s a lot of new code, so let’s break it down:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要很多新的代码，所以让我们来分解一下：
- en: First, `CollisionShape2D`’s `disabled` property needs to be set to `true`. However,
    if you try setting it directly, Godot will complain. You’re not allowed to change
    physics properties while collisions are being processed; you have to wait until
    the end of the current frame. That’s what `set_deferred()` does.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`CollisionShape2D`的`disabled`属性需要设置为`true`。然而，如果你直接尝试设置它，Godot会抱怨。在碰撞正在处理时，不允许更改物理属性；你必须等待当前帧的结束。这就是`set_deferred()`的作用。
- en: Next, `create_tween()` creates a tween object, `set_parallel()` says that any
    following tweens should happen at the same time, instead of one after another,
    and `set_trans()` sets the transition function to the “quadratic” curve.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`create_tween()`创建一个tween对象，`set_parallel()`表示任何后续的tween都应该同时发生，而不是一个接一个地发生，`set_trans()`将过渡函数设置为“二次”曲线。
- en: After that come two lines that set up the tweening of the properties. `tween_property()`
    takes four parameters – the object to affect (`self`), the property to change,
    the ending value, and the duration (in seconds).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是两行设置属性缓动的代码。`tween_property()`函数接受四个参数——要影响的对象（`self`）、要更改的属性、结束值和持续时间（以秒为单位）。
- en: Now, when you run the game, you should see the coins playing the effect when
    they’re picked up.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏时，你应该看到硬币在被拾取时播放效果。
- en: Sound
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音
- en: Sound is an important but often neglected piece of game design. Good sound design
    can add a huge amount of juice to your game for a very small amount of effort.
    Sounds can give a player feedback, connect them emotionally to the characters,
    or even be a direct part of gameplay (“you hear footsteps behind you”).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏设计中重要但常被忽视的部分。良好的声音设计可以在非常小的努力下为你的游戏增添大量活力。声音可以给玩家提供反馈，将他们与角色情感上联系起来，甚至可以是游戏玩法的一部分（“你听到背后有脚步声”）。
- en: For this game, you’re going to add three sound effects. In the `Main` scene,
    add three `AudioStreamPlayer` nodes and name them `CoinSound`, `LevelSound`, and
    `EndSound`. Drag each sound from the `res://assets/audio/` folder into the corresponding
    node’s **Stream** property.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你将添加三个声音效果。在`Main`场景中，添加三个`AudioStreamPlayer`节点，并分别命名为`CoinSound`、`LevelSound`和`EndSound`。将每个声音从`res://assets/audio/`文件夹拖放到相应节点的**Stream**属性中。
- en: 'To play a sound, you call the `play()` function on the node. Add each of the
    following lines to play the sounds at the appropriate times:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，你需要在节点上调用`play()`函数。将以下每一行添加到适当的时间以播放声音：
- en: '`$CoinSound.play()` to `_on_player_pickup()`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`_on_player_pickup()`中调用`$CoinSound.play()`
- en: '`$EndSound.play()` to `game_over()`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`game_over()`中调用`$EndSound.play()`
- en: '`$LevelSound.play()` to `spawn_coins()` (but not inside the loop!)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`spawn_coins()`中调用`$LevelSound.play()`（但不要在循环内！）
- en: Powerups
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速道具
- en: There are many possibilities for objects that give the player a small advantage
    or powerup. In this section, you’ll add a powerup item that gives the player a
    small time bonus when collected. It will appear occasionally for a short time,
    and then disappear.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种对象可以为玩家提供小的优势或加速道具。在本节中，你将添加一个加速道具项目，当收集时会给玩家一小段时间奖励。它将偶尔短暂出现，然后消失。
- en: The new scene will be very similar to the `Coin` scene you already created,
    so click on your `Coin` scene and choose `powerup.tscn`. Change the name of the
    root node to `Powerup` and remove the script by clicking the **Detach script**
    button – **<****IMG>**.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 新场景将与你已经创建的`Coin`场景非常相似，因此点击你的`Coin`场景，选择`powerup.tscn`。将根节点的名称更改为`Powerup`，并通过点击**分离脚本**按钮——**<****IMG>**移除脚本。
- en: In the `coins` group by clicking the trash can button and add a new group called
    `powerups` instead.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击垃圾桶按钮在`coins`组中删除，并添加一个名为`powerups`的新组。
- en: In `AnimatedSprite2D`, change the images from the coin to the powerup, which
    you can find in the `res://assets/pow/` folder.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AnimatedSprite2D`中，将硬币的图像更改为加速道具，你可以在`res://assets/pow/`文件夹中找到它。
- en: Click to add a new script and copy the code from the `coin.gd` script.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加新脚本，并从`coin.gd`脚本中复制代码。
- en: 'Next, add a `Timer` node named `Lifetime`. This will limit the amount of time
    the object remains on the screen. Set its `2` and both `timeout` signal so that
    the powerup can be removed at the end of the time period:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`Lifetime`的`Timer`节点。这将限制对象在屏幕上停留的时间。将其`2`和`timeout`信号都设置为2，以便在时间周期结束时移除加速道具：
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, go to your `Main` scene and add another `Timer` node called `PowerupTimer`.
    Set its `Powerup.wav` sound in the `audio` folder that you can add with another
    `AudioStreamPlayer`. Connect the `timeout` signal and add the following to spawn
    a powerup:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到你的`Main`场景，并添加另一个名为`PowerupTimer`的`Timer`节点。在`audio`文件夹中设置其`Powerup.wav`声音，你可以通过另一个`AudioStreamPlayer`添加。连接`timeout`信号，并添加以下代码以生成加速道具：
- en: '[PRE27]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Powerup` scene needs to be linked to a variable, as you did with the `Coin`
    scene, so add the following line at the top of `main.gd` and then drag `powerup.tscn`
    into the new property:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Powerup`场景需要与一个变量链接，就像你与`Coin`场景所做的那样，因此在`main.gd`顶部添加以下行，然后将`powerup.tscn`拖放到新属性中：'
- en: '[PRE28]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The powerups should appear unpredictably, so the wait time of `PowerupTimer`
    needs to be set whenever you begin a new level. Add this to the `_process()` function
    after the new coins are spawned with `spawn_coins()`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 加速道具应该随机出现，因此每次开始新关卡时都需要设置`PowerupTimer`的等待时间。在用`spawn_coins()`生成新硬币后，将以下代码添加到`_process()`函数中：
- en: 'Now, you will have powerups appearing; the last step is to give the player
    the ability to collect them. Currently, the player script assumes that anything
    it runs into is either a coin or an obstacle. Change the code in `player.gd` to
    check what kind of object has been hit:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到道具出现；最后一步是给玩家收集它们的能力。目前，玩家脚本假设它遇到的是硬币或障碍物。将 `player.gd` 中的代码更改以检查被击中的对象类型：
- en: '[PRE29]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that now you emit the `pickup` signal with an additional argument that
    names the type of object. The corresponding function in `main.gd` must now be
    changed to accept that argument and decide what action to take:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在你使用额外的参数来发射 `pickup` 信号，该参数命名了对象的类型。`main.gd` 中的相应函数现在必须更改以接受该参数并决定采取什么行动：
- en: '[PRE30]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `match` statement is a useful alternative to `if` statements, especially
    when you have a large number of possible values to test.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 语句是 `if` 语句的有用替代品，尤其是在你有大量可能值要测试时。'
- en: Try running the game and collecting the powerup (remember, it won’t appear on
    level 1). Make sure the sound plays and the timer increases by five seconds.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并收集道具（记住，它不会出现在第 1 关）。确保播放声音，计时器增加五秒。
- en: Coin animation
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬币动画
- en: When you created the coin, you used `AnimatedSprite2D`, but it isn’t playing
    yet. The coin animation displays a “shimmer” effect, traveling across the face
    of the coin. If all the coins display this at the same time, it will look too
    regular, so each coin needs a small random delay in its animation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建硬币时，你使用了 `AnimatedSprite2D`，但它还没有播放。硬币动画显示一个“闪烁”效果，在硬币的表面上移动。如果所有硬币同时显示这个效果，看起来会太规律，所以每个硬币的动画都需要一个小的随机延迟。
- en: First, click on `AnimatedSprite2D` and then on the `SpriteFrames` resource.
    Make sure **Animation Looping** is set to **Off** and **Speed** is set to **12
    FPS**.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击 `AnimatedSprite2D`，然后点击 `SpriteFrames` 资源。确保 **动画循环** 设置为 **关闭**，**速度**
    设置为 **12 FPS**。
- en: '![Figure 2.28: Animation settings](img/B19289_02_29.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28：动画设置](img/B19289_02_29.jpg)'
- en: 'Figure 2.28: Animation settings'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28：动画设置
- en: 'Add a `Timer` node to the `Coin` scene and then add this to the coin’s script:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Timer` 节点添加到 `Coin` 场景中，然后将其添加到硬币的脚本中：
- en: '[PRE31]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, connect the `Timer`’s `timeout` signal and add this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，连接 `Timer` 的 `timeout` 信号并添加以下内容：
- en: '[PRE32]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try running the game and watching the coins animate. It’s a nice visual effect
    for a very small amount of effort, at least on the part of the programmer –the
    artist had to draw all those frames! You’ll notice a lot of effects like this
    in professional games. Although subtle, the visual appeal makes for a much more
    pleasing experience.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并观察硬币的动画。这需要非常小的努力就能产生一个很好的视觉效果，至少对程序员来说是这样——艺术家必须绘制所有这些帧！你会在专业游戏中注意到很多这样的效果。虽然很微妙，但视觉吸引力使得游戏体验更加愉悦。
- en: Obstacles
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 障碍物
- en: Finally, the game can be made more challenging by introducing an obstacle that
    the player must avoid. Touching the obstacle will end the game.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过引入玩家必须避免的障碍物，可以使游戏更具挑战性。触摸障碍物将结束游戏。
- en: '![Figure 2.29: Example game with obstacles](img/B19289_02_30.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29：带有障碍物的示例游戏](img/B19289_02_30.jpg)'
- en: 'Figure 2.29: Example game with obstacles'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29：带有障碍物的示例游戏
- en: Create a new `Area2D` scene and name it `Cactus`. Give it `Sprite2D` and `CollisionShape2D`
    children. Drag the cactus texture from `Sprite2D`. Add `RectangleShape2D` to the
    collision shape and size it so that it covers the image. Remember when you added
    `if area.is_in_group("obstacles"?)` to the player code? Add `Cactus` to the `obstacles`
    group using the **Node** tab. Play the game and see what happens when you run
    into the cactus.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Area2D` 场景并将其命名为 `Cactus`。给它添加 `Sprite2D` 和 `CollisionShape2D` 子节点。从
    `Sprite2D` 拖动仙人掌纹理。将 `RectangleShape2D` 添加到碰撞形状中，并调整其大小以覆盖图像。记得你在玩家代码中添加了 `if
    area.is_in_group("obstacles"?)` 吗？使用 **节点** 选项卡将 `Cactus` 添加到 `obstacles` 组。玩玩游戏，看看撞到仙人掌会发生什么。
- en: 'You may have spotted a problem – coins can spawn on top of the cactus, making
    them impossible to pick up. When the coin is placed, it needs to move if it detects
    that it’s overlapping with the obstacle. In the `Coin` scene, connect its `area_entered`
    signal and add the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经发现了问题——硬币可以出现在仙人掌上，这使得它们无法被捡起。当硬币放置时，如果它检测到与障碍物重叠，则需要移动。在 `Coin` 场景中，连接其
    `area_entered` 信号并添加以下内容：
- en: '[PRE33]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you added the `Powerup` object from the previous section, you’ll need to
    do the same in its script.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上一节添加了 `Powerup` 对象，你需要在它的脚本中也做同样的事情。
- en: Play the game, and test that the objects all spawn correctly and that they don’t
    overlap with an obstacle. Running into an obstacle should end the game.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 玩这个游戏，并测试对象是否正确生成，以及它们是否与障碍物重叠。撞到障碍物应该结束游戏。
- en: Do you find the game challenging or easy? Before moving on to the next chapter,
    take some time to think about other things you might add to this game. Go ahead
    and see whether you can add them, using what you’ve learned so far. If not, write
    them down and come back later, after you’ve learned some more techniques in the
    following chapters.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这个游戏是具有挑战性还是容易？在进入下一章之前，花点时间思考一下你可能添加到这个游戏中的其他元素。尝试使用你到目前为止所学到的知识，看看你是否能够添加它们。如果不能，把它们写下来，稍后再回来，在你学习了下一章中的一些更多技术之后。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the basics of the Godot Engine by creating a small
    2D game. You set up a project and created multiple scenes, worked with sprites
    and animations, captured user input, used **signals** to communicate between nodes,
    and created a UI. The things you learned in this chapter are important skills
    that you’ll use in any Godot project.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你通过创建一个小型2D游戏学习了Godot引擎的基础知识。你设置了一个项目并创建了多个场景，与精灵和动画一起工作，捕捉用户输入，使用**信号**在节点之间进行通信，并创建了一个用户界面。你在这一章中学到的知识是你在任何Godot项目中都会用到的关键技能。
- en: Before moving to the next chapter, look through the project. Do you know what
    each node does? Are there any bits of code that you don’t understand? If so, go
    back and review that section of the chapter.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，回顾一下项目。你知道每个节点的作用吗？有没有你不理解的代码片段？如果有，回到并复习那一章节。
- en: Also, feel free to experiment with the game and change things around. One of
    the best ways to get a good feel for what different parts of the game do is to
    change them and see what happens.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以自由地尝试这个游戏并改变一些东西。了解游戏不同部分功能的一个最好的方法就是改变它们，看看会发生什么。
- en: Remember the tip from [*Chapter 1*](B19289_01.xhtml#_idTextAnchor015)? If you
    really want to advance your skills quickly, close this book, start a new Godot
    project, and try to make *Coin Dash* again without peeking. If you have to look
    in the book, it’s OK, but try to only look for things once you’ve tried to figure
    out how to do it yourself.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[第1章](B19289_01.xhtml#_idTextAnchor015)中的提示吗？如果你真的想快速提高你的技能，关闭这本书，开始一个新的Godot项目，并尝试再次制作*Coin
    Dash*，不要偷看。如果你不得不看书，那没关系，但尽量只在尝试自己解决问题之后再查找东西。
- en: In the next chapter, you’ll explore more of Godot’s features and learn how to
    use more node types by building a more complex game.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索Godot的更多功能，并通过构建一个更复杂的游戏来学习如何使用更多类型的节点。
