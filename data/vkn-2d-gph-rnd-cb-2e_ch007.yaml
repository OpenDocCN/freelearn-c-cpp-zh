- en: 6 Physically Based Rendering Using the glTF 2.0 Shading Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 使用 glTF 2.0 着色模型进行基于物理的渲染
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file40.png)'
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: This chapter will cover the integration of **physically based rendering** (**PBR**)
    into your graphics applications. We use the glTF 2.0 shading model as an example.
    PBR is not a single specific technique but rather a set of concepts, like using
    measured surface values and realistic shading models, to accurately represent
    real-world materials. Adding PBR to your graphics application or retrofitting
    an existing rendering engine with PBR might be challenging, as it requires multiple
    big tasks that work simultaneously before a correct image can be rendered.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍将**基于物理的渲染**（**PBR**）集成到您的图形应用程序中。我们以 glTF 2.0 着色模型为例。PBR 不是一个特定的单一技术，而是一系列概念，例如使用测量的表面值和逼真的着色模型，以准确表示现实世界的材料。将
    PBR 添加到您的图形应用程序或对现有渲染引擎进行 PBR 改造可能具有挑战性，因为它需要在正确渲染图像之前同时完成多个大型任务。
- en: Our goal here is to show how to implement all these steps from scratch. Some
    of these steps, like precomputing irradiance maps or **bidirectional reflectance
    distribution function** (**BRDF**) look-up tables, require additional tools to
    be written. We are not going to use any third-party tools here and will show how
    to implement the entire skeleton of a PBR pipeline from the ground up, including
    creating rudimental tools to work with. Some pre-calculations can be done using
    **General-Purpose Graphics Processing Unit** (**GPGPU**) techniques and compute
    shaders, all of which will be covered here as well.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标是展示如何从头开始实现所有这些步骤。其中一些步骤，如预计算辐照度图或**双向反射分布函数**（**BRDF**）查找表，需要编写额外的工具。我们不会使用任何第三方工具，并将展示如何从头开始实现整个
    PBR 管道骨架，包括创建基本的工具来工作。一些预计算可以使用**通用图形处理单元**（**GPGPU**）技术和计算着色器来完成，所有这些内容都将在此涵盖。
- en: 'In this chapter, we will learn the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下食谱：
- en: An introduction to the glTF 2.0 physically based shading model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: glTF 2.0 物理基础着色模型的简介
- en: Rendering unlit glTF 2.0 materials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染未着光的 glTF 2.0 材料实现
- en: Precomputing BRDF look-up tables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预计算 BRDF 查找表
- en: Precomputing irradiance maps and diffuse convolution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预计算辐照度图和漫反射卷积
- en: Implementing the glTF 2.0 core metallic-roughness shading model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现glTF 2.0核心金属-粗糙度着色模型
- en: Implementing the glTF 2.0 core specular-glossiness shading model
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现glTF 2.0核心光泽度着色模型
- en: In all future references to glTF, we mean the glTF 2.0 specification. Since
    glTF 1.0 is obsolete and deprecated, we do not cover it in this book.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在所有未来对 glTF 的引用中，我们指的是 glTF 2.0 规范。由于 glTF 1.0 已过时并已弃用，我们在此书中不涉及它。
- en: An introduction to the glTF 2.0 physically based shading model
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: glTF 2.0 物理基础着色模型的简介
- en: In this section, we will learn the PBR Material basics and provide enough context
    for the actual implementation of some ratified glTF 2.0 PBR extensions. The actual
    code will be presented in the subsequent recipes and chapters. Since the topic
    of PBR rendering is vast, we will focus on a minimalistic implementation just
    to guide you and get you started. In this section, we will focus on the GLSL shader
    code for the glTF 2.0 PBR shading model. Roughly speaking, rendering a physically
    based image is nothing more than running a fancy pixel shader with a set of textures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 PBR 材料的基础知识，并为实际实现一些批准的 glTF 2.0 PBR 扩展提供足够的背景信息。实际的代码将在后续的食谱和章节中展示。由于
    PBR 渲染的主题非常广泛，我们将关注一个简约的实现，仅为了指导您并帮助您开始。在本节中，我们将关注 glTF 2.0 PBR 着色模型的 GLSL 着色器代码。简而言之，渲染基于物理的图像不过是运行一个花哨的像素着色器，并使用一系列纹理。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: We assume you already have some basic understanding of linear algebra and calculus.
    It is recommended to get yourself familiar with the glTF 2.0 specification, which
    can be found at [https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.xhtml](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.xhtml).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经对线性代数和微积分有了一些基本了解。建议您熟悉 glTF 2.0 规范，该规范可在 [https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.xhtml](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.xhtml)
    找到。
- en: What is PBR?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 PBR？
- en: '**Physically based rendering** (**PBR**) is a set of techniques that aim to
    simulate how light interacts with real-world materials. By using realistic models
    for light scattering and reflection, PBR materials can create much more believable
    and immersive visuals compared to traditional methods.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于物理的渲染**（**PBR**）是一套旨在模拟光与真实世界材料相互作用的技术。通过使用光散射和反射的逼真模型，PBR材质可以创造出比传统方法更逼真、更沉浸式的视觉效果。'
- en: The glTF PBR material model is a standardized way of representing physically
    based materials in the glTF 2.0 format. This model allows you to create highly
    realistic 3D content across diverse platforms and applications, making it a crucial
    tool for modern 3D development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: glTF PBR材质模型是glTF 2.0格式中表示基于物理材质的一种标准化方法。此模型允许您在多种平台和应用中创建高度逼真的3D内容，使其成为现代3D开发的重要工具。
- en: Light-object interactions
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光与物体相互作用
- en: Let’s step back and see what a ray of light is as a physical phenomenon – it’s
    a geometric line along which light energy travels, or a beam of light. It has
    a starting point and a direction of propagation. Two important interactions of
    light with surfaces are **reflection** and **diffusion** (also known as “specular”
    and “diffuse” reflection, respectively). While we intuitively understand these
    concepts through everyday experience, their physical characteristics may be less
    familiar.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，看看光线作为一个物理现象是什么——它是一束光线沿其传播的几何线，或者是一束光。它有一个起点和传播方向。光与表面的重要相互作用有两种：**反射**和**扩散**（分别称为“镜面”和“漫反射”）。虽然我们通过日常经验直观地理解这些概念，但它们的物理特性可能不太熟悉。
- en: When light encounters a surface, part of it bounces back in the opposite direction
    of the surface’s normal, like how a ball rebounds at an angle off a wall. This
    type of reflection, occurring on smooth surfaces, creates a mirror-like effect
    called **specular reflection** (derived from speculum, a Latin word for “mirror”).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当光线遇到表面时，其中一部分会以与表面法线相反的方向弹回，就像球在墙上以角度反弹一样。这种在光滑表面上发生的反射，产生了一种称为**镜面反射**的效果（源自拉丁语中的“speculum”，意为“镜子”）。
- en: However, not all light reflects. Some light penetrates the surface, where it
    can either be absorbed, converted into heat, or scattered in various directions.
    The scattered light that exits the surface again is known as **diffuse light**,
    **photon diffusion**, or **subsurface scattering**. These terms all refer to the
    same physical phenomenon of photon movement. However, diffusion and scattering
    are different in how they disperse photons. Scattering involves photons being
    redirected in various directions, while diffusion involves photons spreading out
    evenly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有光线都会反射。有些光线穿透表面，在那里它可以被吸收、转化为热量或向各个方向散射。从表面再次散出的散射光被称为**漫射光**、**光子扩散**或**次表面散射**。这些术语都指同一物理现象——光子运动。然而，扩散和散射在如何分散光子方面是不同的。散射涉及光子被重新导向到各个方向，而扩散涉及光子均匀地扩散开来。
- en: The way materials absorb and scatter diffuse light varies for different wavelengths
    of light, giving objects their distinct colors. For example, an object that absorbs
    most colors but scatters blue light will appear blue. This scattering is often
    so chaotic that it appears the same from all directions, unlike a specular mirror-like
    reflection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 材料吸收和散射漫射光的方式因光的不同波长而异，赋予物体独特的颜色。例如，吸收大多数颜色但散射蓝光的物体将呈现蓝色。这种散射通常是如此混乱，以至于从所有方向看起来都一样，与镜面反射不同。
- en: '![Figure 6.1: Diffuse and specular reflection](img/file41.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：漫反射和镜面反射](img/file41.png)'
- en: 'Figure 6.1: Diffuse and specular reflection'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：漫反射和镜面反射
- en: Simulating this behavior in computer graphics often requires only a single input,
    **albedo**, which represents the color defined by the mix of the fractions of
    various light wavelengths that scatter back out across a surface. The term **diffuse
    color** is often used interchangeably with albedo.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中模拟这种行为通常只需要一个输入，即**漫反射率**，它表示由各种光波长的混合比例散射回表面的颜色。术语**漫反射颜色**通常与漫反射率互换使用。
- en: When materials have wider scattering angles, such as human skin or milk, simulating
    their lighting requires more complex approaches than simple light interaction
    with a surface. This is because the light scattering in these materials is not
    just limited to the surface; it also occurs within the material itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当材料具有更宽的散射角度，如人类皮肤或牛奶时，模拟它们的照明需要比简单的表面光相互作用更复杂的方法。这是因为这些材料中的光散射不仅限于表面，还发生在材料本身内部。
- en: For thin objects, the light can even scatter out of their back side, making
    them **translucent**. As the scattering further decreases, like in glass, the
    material becomes transparent, allowing entire images to pass through it, preserving
    their visible shape.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于薄物体，光甚至可以散射到它们的背面，使它们变得**半透明**。随着散射进一步减少，就像在玻璃中一样，材料变得透明，允许整个图像通过它，保持其可见形状。
- en: These unique light scattering behaviors are significantly different from the
    typical “close to the surface” diffusion, requiring special handling for accurate
    rendering.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些独特的光散射行为与典型的“接近表面”扩散有很大不同，需要特殊处理才能准确渲染。
- en: Energy conservation
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 能量守恒
- en: The fundamental principle in PBR revolves around the law of conservation of
    energy. This law asserts that within an isolated system, the overall energy remains
    unchanged. In the context of rendering, it signifies that the quantity of incoming
    light at any given location in the scene equals the combined amount of light that
    is reflected, transmitted, and absorbed at that location.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PBR的基本原则围绕着能量守恒定律。这条定律断言，在一个孤立系统中，总能量保持不变。在渲染的背景下，它表示场景中任何给定位置的入射光量等于在该位置反射、透射和吸收的光量之和。
- en: Enforcing energy conservation is crucial for PBS. It allows assets to adjust
    reflectivity and albedo values for a material without inadvertently violating
    the laws of physics, which often leads to unnatural- looking results. Implementing
    these constraints in code prevents assets from deviating too far from the reality
    or becoming inconsistent under varying lighting conditions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在PBS中强制执行能量守恒至关重要。它允许资产在不无意中违反物理定律的情况下调整材料的反射率和反照率值，这通常会导致看起来不自然的结果。在代码中实施这些约束可以防止资产偏离现实太远或在不同的光照条件下变得不一致。
- en: Implementing this principle in a shading system is straightforward. We simply
    subtract reflected light before computing the diffuse shading. This implies that
    highly reflective objects will exhibit minimal to no diffuse light, as most of
    the light is reflected instead of penetrating the surface. Conversely, materials
    with strong diffusion cannot be particularly reflective.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色系统中实现这一原则很简单。我们只需在计算漫反射之前减去反射光。这意味着高反射物体将表现出最小到没有漫反射光，因为大部分光被反射而不是穿透表面。相反，具有强烈扩散的材料不能特别具有反射性。
- en: Surface properties
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表面特性
- en: In any given environment, you can readily observe various complex surfaces that
    exhibit distinct light interactions. These unique surface properties are represented
    by general mathematical functions, known as **Bidirectional Scattering Distribution
    Functions** (**BSDFs**).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定环境中，你可以轻松观察到各种具有独特光相互作用的复杂表面。这些独特的表面特性由称为**双向散射分布函数**（**BSDFs**）的通用数学函数表示。
- en: Think of a BSDF as an equation that describes how light scatters upon encountering
    a surface. It considers the surface’s physical properties and predicts probabilities
    of incident light coming from one direction getting scattered in other directions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将BSDF视为一个方程，描述光遇到表面时的散射情况。它考虑了表面的物理特性，并预测了入射光从某一方向散射到其他方向的概率。
- en: 'Although the term BSDF might sound complex, let’s break it down:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然BSDF这个术语可能听起来很复杂，但让我们将其分解：
- en: '**Bidirectional**: This refers to the two-way nature of light interaction with
    a surface. Incident light arrives at a surface from one direction and then scatters
    in various directions.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向性**：这指的是光与表面相互作用的两种性质。入射光从一个方向到达表面，然后向各个方向散射。'
- en: '**Scattering**: This describes how incident light can be redirected into multiple
    outgoing directions. This can involve reflection, transmission, or a combination
    of both.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散射**：这描述了入射光如何被重新导向到多个出射方向。这可能涉及反射、透射或两者的组合。'
- en: '**Distribution function**: This defines the probability of light scattering
    in a particular direction based on the surface’s characteristics. The distribution
    can range from perfectly uniform scattering to a concentrated reflection in a
    single direction.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布函数**：这定义了基于表面特性的光线在特定方向上散射的概率。分布可以从完全均匀散射到单一方向上的集中反射。'
- en: 'In practice, the BSDF is usually split into two parts that are treated separately:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，BSDF通常分为两部分，分别处理：
- en: '**Bidirectional Reflectance Distribution Functions** (**BRDFs**): These functions
    specifically describe how incident light is reflected from a surface. They explain
    why a seemingly white light source illuminating a banana makes it appear yellow
    instead. The BRDF reveals that the banana primarily reflects light in the yellow
    part of the spectrum while absorbing or transmitting other wavelengths.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向反射分布函数**（**BRDFs**）：这些函数专门描述入射光线如何从表面反射。它们解释了为什么看似白色的光源照亮香蕉会使它看起来是黄色的。BRDF揭示了香蕉主要反射光谱中的黄色部分的光线，同时吸收或传输其他波长。'
- en: '**Bidirectional Transmittance Distribution Functions** (**BTDFs**): These functions
    specifically describe how light is transmitted through a material. This is evident
    in materials such as glass and plastics, where we see how incident light passes
    through the material.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向透射分布函数**（**BTDFs**）：这些函数专门描述光线如何通过材料。这在玻璃和塑料等材料中很明显，我们可以看到入射光线如何穿过材料。'
- en: Additionally, other types of BSDFs exist to account for more complex light interaction
    phenomena, such as subsurface scattering. This occurs when light enters a material
    and bounces around before re-emerging in a new direction, at points significantly
    distant from the points of incidence of the incident rays.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还存在其他类型的BSDF，用于解释更复杂的光相互作用现象，例如次表面散射。这发生在光线进入材料并在重新以新的方向出现之前在显著远离入射光线入射点的位置反弹。
- en: '![Figure 6.2: BRDF and BTDF](img/file42.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：BRDF和BTDF](img/file42.png)'
- en: 'Figure 6.2: BRDF and BTDF'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：BRDF和BTDF
- en: Types of reflection
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射类型
- en: 'There are four primary surface types characterized by their BRDFs, which define
    the likelihood of light scattering in various directions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种主要的表面类型，由它们的BRDF定义，这些BRDF定义了光线在不同方向上散射的可能性：
- en: '**Diffuse surfaces** scatter light uniformly in all directions, exemplified
    by the consistent color of matte paint.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**漫反射表面**在所有方向上均匀地散射光线，例如哑光油漆的均匀颜色。'
- en: '**Glossy specular surfaces** preferentially scatter light in specific reflected
    directions, exhibiting blurred reflections, such as specular highlights on plastic.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光滑镜面表面**优先在特定的反射方向上散射光线，表现出模糊的反射，例如塑料上的镜面高光。'
- en: '**Perfect specular surfaces** scatter light precisely in a single outgoing
    direction, mirroring the incident light with respect to the surface normal—similar
    to flawless reflections seen in perfect mirrors.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完美镜面表面**精确地在单一输出方向上散射光线，相对于表面法线反射入射光线——类似于在完美镜子中看到的无瑕疵反射。'
- en: '**Retro-reflective surfaces** scatter light predominantly back along the incident
    direction to the light source, akin to the specular highlights observed on velvet
    or road signs.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反光表面**主要在入射方向上散射光线，返回到光源，类似于在天鹅绒或路标上观察到的镜面高光。'
- en: However, it’s improbable that a real-world surface strictly adheres to only
    one of these models. As a result, most materials can be modeled as intricate combinations
    of these surface types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实世界的表面严格遵循这些模型之一的可能性很小。因此，大多数材料都可以被建模为这些表面类型的复杂组合。
- en: 'Moreover, each type of reflection— diffuse, glossy specular, perfect specular,
    and retro-reflective— can exhibit isotropic or anisotropic distributions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每种反射类型——漫反射、光滑镜面、完美镜面和反光——都可以表现出各向同性或各向异性分布：
- en: '**Isotropic reflections** maintain a consistent amount of reflected light at
    a point, irrespective of the object rotation angle. This characteristic aligns
    with the behavior of most surfaces encountered in daily life.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**各向同性反射**在一点上保持一致的反射光量，不受物体旋转角度的影响。这一特性与日常生活中遇到的大多数表面的行为相一致。'
- en: '**Anisotropic reflections** vary in the amount of reflected light based on
    the orientation of an object to the light source. This occurs due to the alignment
    of small surface irregularities aligned predominantly in one direction, resulting
    in elongated and blurry reflections. Such behavior is noticeable in materials
    such as brushed metal and velvet.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**各向异性反射**根据物体相对于光源的朝向而变化反射光量。这是由于小表面不规则性的排列主要在一个方向上，导致反射延长并模糊。这种行为在刷金属和天鹅绒等材料中尤为明显。'
- en: Transmission
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输
- en: Reflection distribution types can be used for transmission as well, except for
    retro-reflection. Conversely, when light passes through a material, its path is
    affected by the material’s properties. To illustrate how this differs from reflection,
    consider a single light ray passing through a material, like perfect specular
    transmission. In perfect specular transmission, the medium’s refractive index
    determines the direction in which light travels. This behavior adheres to **Snell’s
    Law**, which is described using the equation n1θ1 = n2θ2n2θ2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 反射分布类型也可以用于传输，除了全向反射。相反，当光线穿过材料时，其路径会受到材料特性的影响。为了说明这与反射的不同，考虑一束光线穿过材料，如完美的镜面透射。在完美的镜面透射中，介质的折射率决定了光传播的方向。这种行为遵循**斯涅尔定律**，该定律使用方程
    n1θ1 = n2θ2 来描述。
- en: '![Figure 6.3: The index of refraction](img/file43.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：折射率](img/file43.png)'
- en: 'Figure 6.3: The index of refraction'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：折射率
- en: Here, `n` represents the refractive index of the first and second media, while
    `θ` denotes the angle of the incoming light concerning the surface normal. Consequently,
    when both media share identical refractive indices, light proceeds in a perfectly
    straight path. Conversely, if the refractive indices differ, the light changes
    its direction upon transitioning into the next medium. A notable instance of this
    is when light shifts direction upon entering water from air, leading to distortions
    in our underwater observations. This contrasts with perfect specular reflection,
    where the incoming angle always equals the outgoing angle.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`n`代表第一和第二介质的折射率，而`θ`表示入射光相对于表面法线的角度。因此，当两种介质具有相同的折射率时，光线将沿完美直线传播。相反，如果折射率不同，光线在进入下一介质时会改变方向。一个显著的例子是当光线从空气进入水中时方向改变，导致水下观察的扭曲。这与完美的镜面反射形成对比，其中入射角始终等于出射角。
- en: Fresnel equation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菲涅耳方程
- en: It is important for physically based renderers to know how much light is reflected
    or transmitted on the surface. It is a combination of these effects that describes
    substances such as honey and stained glass, which both have color and can be seen
    through.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于物理的渲染器来说，了解表面反射或透射的光量是很重要的。这些效果的组合描述了诸如蜂蜜和彩色玻璃这样的物质，它们都具有颜色且可以透过。
- en: These amounts are directly related to each other and are described by the **Fresnel
    equations**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数值彼此直接相关，并由**菲涅耳方程**描述。
- en: These equations are tailored for two types of media, **conductors** (**metals**)
    and **dielectrics** (**nonmetals**). Metals do not transmit light; they only reflect
    it entirely, or practically entirely. Dielectrics possess the property of diffuse
    reflection—light rays pass beneath the surface of the material and some of them
    are absorbed, while some are returned in the form of reflection. This is particularly
    evident in the specular highlight of these materials—for metals, it will be colored,
    while for dielectrics, it appears white or, more accurately, retains the color
    of the incident light.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程针对两种类型的介质，**导体**（**金属**）和**介电体**（**非金属**）。金属不透光；它们只完全反射，或者实际上完全反射。介电体具有漫反射的特性——光线穿过材料的表面，其中一些被吸收，而一些以反射的形式返回。这在这些材料的镜面高光中尤为明显——对于金属，它将是彩色的，而对于介电体，它看起来是白色的，或者更准确地说，保留了入射光的颜色。
- en: Although both conductors and dielectrics are subject to the same set of Fresnel
    equations, glTF 2.0 opts to develop a distinct evaluation function for dielectrics.
    This choice is made to leverage the notably straightforward structure that these
    equations assume when the refractive indices are definitely real numbers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然导体和介电体都受到同一组菲涅耳方程的约束，但glTF 2.0选择为介电体开发一个独特的评估函数。这种选择是为了利用这些方程在折射率肯定是实数时所假设的明显简单结构。
- en: '**Nonmetals (dielectrics)**: These are materials like glass, plastic, and ceramics,
    which lack distinctive metallic properties.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非金属（电介质）**：这些材料如玻璃、塑料和陶瓷，缺乏独特的金属特性。'
- en: '**Metals (conductors)**: These materials can conduct both heat and electricity
    to a certain extent. Examples include many metals, such as copper, silver, and
    gold, although not all metals exhibit this property. Unlike dielectrics, conductors
    do not transmit light; rather, they absorb some of the incident light, converting
    it into heat.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属（导体）**：这些材料可以在一定程度上传导热量和电流。例如，包括许多金属，如铜、银和金，尽管并非所有金属都表现出这种特性。与电介质不同，导体不传导光；相反，它们吸收一些入射光，将其转化为热量。'
- en: Microfacets
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微facet
- en: According to the microfacet theory, a rough surface is composed of countless
    microfacets or tiny surface elements, each having its own orientation with respect
    to the surface normal. These microfacets scatter incoming light in different directions
    due to their orientations, resulting in a diffused reflection rather than a perfect
    mirror-like reflection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微facet 理论，粗糙表面由无数微facet 或微小的表面元素组成，每个元素相对于表面法线都有自己的方向。由于这些微facet 的方向不同，它们会散射入射光，从而产生漫反射而不是完美的镜面反射。
- en: '**Blinn-Phong Model**: It was introduced by James F. Blinn in 1977 as an enhancement
    of the empirical Phong reflection model, devised by Bui Tuong Phong in 1973.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blinn-Phong 模型**：它由詹姆斯·F·布林于1977年提出，作为1973年由裴东光（Bui Tuong Phong）设计的经验Phong反射模型的改进。'
- en: This model computes the intensity of the reflected light based on the angle
    between the viewer’s direction and the halfway vector `h=(L+V)/length(L+V)`, which
    is halfway between the light direction `L` and the view direction `V`. The model
    includes a specular term that provides a highlight on the surface, simulating
    the effect of a shiny surface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型根据观察者方向与半向量 `h=(L+V)/length(L+V)` 之间的角度计算反射光的强度，半向量 `h` 位于光方向 `L` 和观察方向 `V`
    之间。该模型包括一个提供表面高光的镜面项，模拟了光滑表面的效果。
- en: '**Cook-Torrance Model**: In 1982, Robert Cook and Kenneth Torrance introduced
    a reflectance model that offered a more precise depiction of light reflectance
    in comparison to the Phong and Blinn-Phong models. The microfacet BRDF equation
    is as follows:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cook-Torrance 模型**：1982年，罗伯特·库克和肯尼思·托伦斯提出了一种反射模型，与 Phong 和 Blinn-Phong 模型相比，它提供了对光反射的更精确描述。微facet
    BRDF 方程如下：'
- en: 'Where:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*f*[r]​(*ω*[i]​,*ω*[o]​) is the microfacet BRDF'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*[r]​(*ω*[i]​,*ω*[o]​) 是微facet BRDF'
- en: '*F*(*ω*[i]​,*h*) is the Fresnel term'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*(*ω*[i]​,*h*) 是菲涅耳项'
- en: '*D*(*h*) is the microfacet distribution function'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*(*h*) 是微facet 分布函数'
- en: '*G*(*ω*[i]​,*ω*[o]​,*h*) is the geometry function'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*(*ω*[i]​,*ω*[o]​,*h*) 是几何函数'
- en: '*ω*[i​] is the incident light direction'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ω*[i] 是入射光方向'
- en: '*ω*[o]​ is the outgoing light direction'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ω*[o]​ 是出射光方向'
- en: '*h* is the half vector'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*h* 是半向量'
- en: '*n* is the surface normal'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 是表面法线'
- en: The proposed approach is versatile, featuring **three interchangeable component**
    functions, `F`, `D`, and `G`, which can be substituted with equations of your
    preference. Additionally, it proves efficient in accurately representing a wide
    range of real-world materials.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的方法具有多功能性，具有**三个可互换的成分函数**，`F`、`D` 和 `G`，可以用你偏好的方程替换。此外，它证明了在准确表示广泛的真实世界材料方面的效率。
- en: This equation represents the amount of light reflected in a specific direction
    `ωo`​, given an incident light direction `ωi`​ and the surface properties. The
    initial component `F` represents the Fresnel effect, the subsequent component
    `D` is a **normal distribution function** (**NDF**), and the final component accounts
    for the shadowing factor `G`, referred to as the **G term**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此方程表示在特定方向 `ωo` 上反射的光量，给定入射光方向 `ωi` 和表面特性。初始成分 `F` 表示菲涅耳效应，随后的成分 `D` 是一个**正态分布函数**（**NDF**），最后的成分考虑了阴影因子
    `G`，称为**G 项**。
- en: Of all the factors in this formulation, the NDF term typically exerts the greatest
    importance. The specific form of the NDF is heavily influenced by the roughness
    of the BRDF. To sample the microfacet BRDF model efficiently, it is customary
    to first sample the NDF, obtain a random microfacet normal that conforms to the
    NDF, and subsequently reflect the incident radiance along this normal to determine
    the outgoing direction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式的所有因素中，NDF 项通常具有最大的重要性。NDF 的具体形式受到 BRDF 粗糙度的影响很大。为了有效地采样微facet BRDF 模型，通常首先采样
    NDF，获得一个符合 NDF 的随机微facet 法线，然后沿着这个法线反射入射辐射，以确定出射方向。
- en: The normalization requirement for the NDF in microfacet theory ensures that
    the total amount of energy reflected or transmitted by a surface remains consistent
    across different roughness levels.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微facet 理论中 NDF 的归一化要求确保在不同粗糙度级别上，表面反射或透射的总能量保持一致。
- en: In microfacet theory, the NDF describes the statistical distribution of microfacet
    normals on a surface. It specifies the probability density of finding a microfacet
    with a particular orientation. When integrating the BRDF over all possible directions,
    the integral should yield a value representing the total reflectance or transmittance
    of the surface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在微facet 理论中，NDF 描述了表面微facet 法线的统计分布。它指定了找到具有特定方向的微facet 的概率密度。当对所有可能的方向进行 BRDF
    的积分时，积分应得到一个表示表面总反射率或透射率的值。
- en: Normalization of the NDF guarantees that the total amount of light reflected
    or transmitted by the surface remains constant, regardless of the surface roughness.
    This ensures energy conservation, a fundamental principle in physics, stating
    that energy cannot be created or destroyed, only transformed or transferred.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NDF 的归一化保证了无论表面粗糙度如何，表面反射或透射的总光量保持不变。这确保了能量守恒，这是物理学的一个基本原理，即能量不能被创造或摧毁，只能被转换或转移。
- en: Several NDFs are commonly used to simulate the behavior of surfaces with microscale
    roughness. Some examples are GGX, Beckmann, and Blinn. In the next recipes, we
    will learn how to implement some of them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的几种 NDF 用于模拟具有微观粗糙度的表面行为。一些例子是 GGX、Beckmann 和 Blinn。在接下来的食谱中，我们将学习如何实现其中的一些。
- en: What is a material?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是材质？
- en: Materials serve as high-level descriptions utilized to represent surfaces, defined
    by combinations of BRDFs and BTDFs. These BSDFs are articulated as parameters
    that govern the visual characteristics of the material. For instance, a matte
    material can be delineated by specifying a diffuse reflection value to elucidate
    how light interacts with the surface, along with a scalar roughness value to characterize
    its texture. Transitioning from a matte to a plastic material could be achieved
    by simply appending a glossy specular reflection value to the matte material,
    thus recreating the specular highlights typical of plastics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 材质作为高级描述，用于表示表面，由 BRDF 和 BTDF 的组合定义。这些 BSDF 被表述为控制材料视觉特性的参数。例如，可以通过指定漫反射值来阐明光线与表面的相互作用，以及一个标量粗糙度值来表征其纹理，从而定义一个哑光材料。要从哑光材料过渡到塑料材料，只需简单地将哑光材料附加一个光泽镜面反射值，从而重现塑料典型的镜面高光。
- en: glTF PBR specification
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: glTF PBR 规范
- en: The glTF PBR specification approaches material representation in a manner that
    emphasizes realism, efficiency, and consistency across different rendering engines
    and applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: glTF PBR 规范以强调真实感、效率和在不同渲染引擎和应用程序之间的一致性为方法来处理材质表示。
- en: One key aspect of the glTF PBR specification is its adherence to physically
    based principles. This means that the materials defined in glTF accurately simulate
    real-world behavior, such as how light interacts with surfaces. Parameters like
    base color (albedo), roughness, metallic, and specular are used to describe materials,
    aligning with physical properties like surface color, smoothness, metallicity,
    and specular reflectivity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: glTF PBR 规范的一个关键方面是它遵循基于物理的原则。这意味着 glTF 中定义的材质能够准确模拟现实世界的特性，例如光线与表面的相互作用。如基础颜色（反照率）、粗糙度、金属和镜面等参数用于描述材质，与物理属性如表面颜色、平滑度、金属性和镜面反射率相一致。
- en: Another notable feature of the glTF PBR approach is its simplicity and ease
    of implementation. By standardizing the parameters used to describe materials,
    glTF simplifies the process of creating and exporting 3D models with PBR materials.
    This consistency across different applications and rendering engines streamlines
    the workflow for artists and developers, enabling them to work more efficiently
    and interchangeably.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: glTF PBR 方法的一个显著特点是它的简单性和易于实现。通过标准化用于描述材质的参数，glTF 简化了创建和导出具有 PBR 材质的 3D 模型的过程。这种在不同应用程序和渲染引擎之间的一致性简化了艺术家和开发者的工作流程，使他们能够更高效、更灵活地工作。
- en: Furthermore, the glTF PBR specification is designed for real-time rendering
    applications, making it well-suited for use in interactive experiences, games,
    and other real-time graphics applications. Its efficient representation of materials
    and optimized file format contribute to faster loading times and better performance
    in real-time rendering scenarios.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，glTF PBR 规范是为实时渲染应用设计的，使其非常适合用于交互式体验、游戏和其他实时图形应用。它对材质的高效表示和优化的文件格式有助于加快加载时间并在实时渲染场景中提供更好的性能。
- en: Overall, the glTF PBR specification stands out for its commitment to physical
    accuracy, simplicity, and efficiency, making it a preferred choice to represent
    materials in 3D graphics applications. Its widespread adoption and support across
    various platforms further cement its status as a leading standard for PBR material
    representation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，glTF PBR 规范因其对物理精度、简洁性和效率的承诺而脱颖而出，使其成为 3D 图形应用中材质表示的首选选择。它在各个平台上的广泛应用和支持进一步巩固了其在
    PBR 材质表示领域的领先地位。
- en: 'The *Khronos 3D Formats Working Group* continually strives to enhance PBR material
    capabilities by introducing new extension specifications. You can always stay
    updated on the status of ratified extensions by visiting the Khronos GitHub page:
    [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Khronos 3D 格式工作组* 不断通过引入新的扩展规范来提高 PBR 材质的功能。你可以通过访问 Khronos GitHub 页面来始终了解已批准扩展的状态：[https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)'
- en: There’s more...
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'For those who wish to acquire deeper knowledge, make sure you read the free
    book *Physically Based Rendering: From Theory to Implementation* by Matt Pharr,
    Wenzel Jakob, and Greg Humphreys, available online at [http://www.pbr-book.org](http://www.pbr-book.org).
    Another great reference is the book *Real Time Rendering, 4th Edition* by Tomas
    Akenine-Möller, Eric Haines, and Naty Hoffman.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望获得更深入知识的人来说，请确保阅读由 Matt Pharr、Wenzel Jakob 和 Greg Humphreys 撰写的免费书籍 *基于物理的渲染：从理论到实现*，可在[http://www.pbr-book.org](http://www.pbr-book.org)在线获取。另一本优秀的参考书籍是
    Tomas Akenine-Möller、Eric Haines 和 Naty Hoffman 撰写的 *实时渲染，第4版*。
- en: 'Also, we recommend SIGGRAPH’s *Physically Based Rendering* courses. For example,
    you can find a comprehensive collection of links on GitHub: [https://github.com/neil3d/awesome-pbr](https://github.com/neil3d/awesome-pbr).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还推荐 SIGGRAPH 的 *基于物理的渲染* 课程。例如，你可以在 GitHub 上找到一个全面的链接集合：[https://github.com/neil3d/awesome-pbr](https://github.com/neil3d/awesome-pbr)。
- en: 'Besides that, the *Filament* rendering engine provides a very comprehensive
    explanation of PBR materials: [https://google.github.io/filament/Filament.md.xhtml](https://google.github.io/filament/Filament.md.xhtml).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*Filament* 渲染引擎提供了对 PBR 材质的非常全面的解释：[https://google.github.io/filament/Filament.md.xhtml](https://google.github.io/filament/Filament.md.xhtml)。
- en: Rendering unlit glTF 2.0 materials
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染未光照的 glTF 2.0 材质
- en: In this recipe, we will start to develop a code framework that allows us to
    load and render glTF 2.0 assets.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开始开发一个代码框架，使我们能够加载和渲染 glTF 2.0 资产。
- en: 'We start with the `unlit` material because it is the simplest glTF 2.0 PBR
    material extension, and the actual shader implementation is very simple and straightforward.
    The official name of the extension is `KHR_materials_unlit`. Here is the link
    to its specification: [https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_unlit](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_unlit).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `unlit` 材质开始，因为它是最简单的 glTF 2.0 PBR 材质扩展，实际的着色器实现非常简单直接。该扩展的官方名称是 `KHR_materials_unlit`。以下是其规范的链接：[https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_unlit](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_unlit)。
- en: 'The `unlit` material technically is not PBR-based, as it might break the energy
    conservation assumptions or provide any artistic representations that do not reflect
    any law of physics. The `unlit` material was designed with the following motivations
    in mind:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`unlit` 材质不是基于 PBR 的，因为它可能会破坏能量守恒的假设，或者提供不反映任何物理定律的艺术表现。`unlit` 材质的设计考虑了以下动机：
- en: Mobile devices with limited resources, where unlit materials offer a performant
    alternative to higher-quality shading models.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源有限的移动设备，其中未光照材料提供了比高质量着色模型更高效的替代方案。
- en: Photogrammetry, in which the lighting information is already prebaked into the
    texture data and additional lighting should not be applied.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立体摄影测量，其中光照信息已经预先烘焙到纹理数据中，不应再应用额外的光照。
- en: Stylized materials (like those resembling “anime” or hand-drawn art) in which
    lighting is undesirable for aesthetic reasons.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不希望用于美学原因的样式化材料（如类似“动漫”或手绘艺术的作品）。
- en: Let’s get started with the basic implementation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始基本实现。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe is in `Chapter06/01_Unlit/main.cpp`. The corresponding
    GLSL vertex and fragment shaders are in `main.vert` and `main.frag`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的源代码位于 `Chapter06/01_Unlit/main.cpp`。相应的 GLSL 顶点和片段着色器位于 `main.vert` 和 `main.frag`。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will create a feature-rich glTF viewer in the following chapters. In this
    chapter, we start building a simple framework that allows us to load and render
    basic glTF models.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将创建一个功能丰富的 glTF 查看器。在本章中，我们开始构建一个简单的框架，使我们能够加载和渲染基本的 glTF 模型。
- en: 'We will use `VulkanApp` and the *Assimp* library from previous chapters. As
    usual, most of the error checking is omitted from the book text but is present
    in the actual source code files:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章中的 `VulkanApp` 和 *Assimp* 库。与往常一样，本书文本中省略了大多数错误检查，但在实际的源代码文件中是存在的：
- en: 'Let’s load our `.gltf` file using *Assimp*:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 *Assimp* 加载我们的 `.gltf` 文件：
- en: '[PRE0]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the loading function is a single line of code. *Assimp* supports
    loading `.gltf` and `.glb` files out of the box. We use the *DamagedHelmet* asset
    from the official Khronos repository: [https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet](https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet).
    This model uses the **Metallic-Roughness** material, but for demonstration purposes,
    we will apply the `unlit` shader to it.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，加载函数是一行代码。*Assimp* 默认支持加载 `.gltf` 和 `.glb` 文件。我们使用官方 Khronos 存储库中的 *DamagedHelmet*
    资产：[https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet](https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet)。此模型使用
    **Metallic-Roughness** 材质，但出于演示目的，我们将应用 `unlit` 着色器。
- en: 'The next step is to build the mesh geometry. The `unlit` material uses only
    the `baseColor` property of the material in three different input forms: as a
    vertex attribute, as a static fragment shader color factor, and as a base color
    texture input. For our vertex format, it means we need to provide the following
    three per-vertex attributes:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是构建网格几何形状。`unlit` 材质仅使用材质的 `baseColor` 属性，以三种不同的输入形式：作为顶点属性、作为静态片段着色器颜色因子和作为基础颜色纹理输入。对于我们的顶点格式，这意味着我们需要提供以下三个每顶点属性：
- en: '[PRE1]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To fill in these attributes, we will use the following code. Empty colors are
    filled with the white color value `(1, 1, 1, 1),` and the empty texture coordinates
    are filled with zeroes `(0, 0, 0)` according to the glTF specification:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了填写这些属性，我们将使用以下代码。空颜色用白色颜色值 `(1, 1, 1, 1)` 填充，空纹理坐标根据 glTF 规范用零 `(0, 0, 0)`
    填充：
- en: '[PRE2]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If a vertex color is not presented in the mesh, then we replace it with the
    default white color. It is a convenient way to simplify the final shader permutation,
    where we can just combine all three inputs in a simple manner. We will come back
    to it later in this recipe.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果网格中没有呈现顶点颜色，则我们将其替换为默认的白色颜色。这是一种简化最终着色器排列的便捷方式，我们可以简单地组合所有三个输入。我们将在本菜谱的后面再次提到它。
- en: 'We build the index buffer using the *Assimp* mesh faces information:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 *Assimp* 网格面信息构建索引缓冲区：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, we should load a diffuse or albedo base color texture. For simplicity,
    we will use the hardcoded file path here instead of obtaining it from the `.gltf`
    model:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们应该加载漫反射或反照率基础颜色纹理。为了简单起见，我们将在这里使用硬编码的文件路径，而不是从 `.gltf` 模型中获取它：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The vertex and index data are static and can be uploaded into corresponding
    Vulkan buffers:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点和索引数据是静态的，可以上传到相应的 Vulkan 缓冲区：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To finish the mesh setup, we need to load GLSL shaders and create a render
    pipeline. The member fields of the `VertexInput` struct correspond to the `Vertex`
    struct mentioned above:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成网格设置，我们需要加载 GLSL 着色器并创建渲染管线。`VertexInput` 结构的成员字段对应于上面提到的 `Vertex` 结构：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This was the preparation code. Let’s now look inside the application’s main
    loop:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是准备代码。现在让我们看看应用程序的主循环内部：
- en: 'Within the rendering loop, we prepare the model-view-projection matrix `mvp`
    and pass it into GLSL shaders, using push constants and the `PerFrameData` structure,
    together with the base color value and the albedo texture ID:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染循环中，我们准备模型视图投影矩阵`mvp`，并通过推送常量和`PerFrameData`结构将其传递到GLSL着色器中，包括基色值和漫反射纹理ID：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the actual 3D mesh rendering is simple, so we post the code here in its
    entirety:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实际的3D网格渲染很简单，所以我们在这里完整地发布代码：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, lets add a few nice touches at the end to render the infinite grid,
    as described in the *Chapter 5* recipe, *Implementing an infinite grid GLSL shader*,
    and the FPS counter, as described in the *Chapter 4* recipe *Adding a frames-per-second
    counter*:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在结束时添加一些漂亮的细节来渲染无限网格，如第5章菜谱中所述的，*实现无限网格GLSL着色器*，以及帧率计数器，如第4章菜谱中所述的*添加每秒帧数计数器*：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This was all the C++ code. Now, let’s dive into the GLSL shaders for this example.
    They’re straightforward and short:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有的C++代码。现在，让我们深入到这个示例的GLSL着色器。它们很简单且简短：
- en: 'The vertex shader `Chapter06/01_Unlit/src/main.vert` does the vertex transformation
    and pre-multiplies the per-vertex color with the provided base color value from
    push constants:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器`Chapter06/01_Unlit/src/main.vert`执行顶点变换，并将每个顶点的颜色与提供的基色值进行预乘，该基色值来自推送常量：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The fragment shader `Chapter06/01_Unlit/src/main.frag` is very simple as well.
    All it does is multiply the precomputed per-vertex base color value by the color
    value sampled from the albedo texture. The glTF 2.0 specification guarantees to
    provide at least one `baseColorFactor` value for the Metallic-Roughness property,
    and this guarantees the correctness of the result as long as we keep all the remaining
    parameters equal to `1`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器`Chapter06/01_Unlit/src/main.frag`同样很简单。它所做的只是将预先计算的每个顶点的基色值乘以从漫反射纹理中采样的颜色值。glTF
    2.0规范保证至少提供一个`baseColorFactor`值用于金属-粗糙度属性，并且只要我们保持所有其他参数等于`1`，这保证了结果的正确性：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The running application `Chapter06/01_Unlit/src/main.cpp` should look like the
    following screenshot.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的应用程序`Chapter06/01_Unlit/src/main.cpp`应该看起来像下面的截图。
- en: '![Figure 6.4: Unlit glTF 2.0 model](img/file44.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：未光照的glTF 2.0模型](img/file44.png)'
- en: 'Figure 6.4: Unlit glTF 2.0 model'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：未光照的glTF 2.0模型
- en: In this example, we enforced the use of the albedo texture for rendering to
    keep the code simple, making it easier to understand. In the subsequent chapters,
    we’ll fully support various combinations of material parameters as specified in
    the glTF 2.0 specification, providing a more accurate and complete glTF 2.0 viewer
    implementation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们强制使用漫反射纹理进行渲染以保持代码简单，使其更容易理解。在随后的章节中，我们将完全支持glTF 2.0规范中指定的各种材料参数组合，提供更准确和完整的glTF
    2.0查看器实现。
- en: Precomputing BRDF look-up tables
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预计算BRDF查找表
- en: In the previous recipes, we learned the basic theory behind glTF 2.0 PBR and
    implemented a simple unlit glTF 2.0 renderer. Let’s continue our PBR exploration
    and learn how to precompute the Smith GGX BRDF **look-up table (LUT)** for our
    upcoming glTF 2.0 viewer.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们学习了glTF 2.0 PBR背后的基本理论，并实现了一个简单的未光照的glTF 2.0渲染器。让我们继续我们的PBR探索，并学习如何为即将到来的glTF
    2.0查看器预先计算Smith GGX BRDF**查找表（LUT）**。
- en: To render a PBR image, we have to evaluate the BRDF at each point on the surface
    being rendered, considering the surface properties and the viewing direction.
    This is computationally expensive, and many real-time implementations, including
    the reference glTF-Sample-Viewer from Khronos, use precalculated tables of some
    sort to find the BRDF value, based on surface roughness and the viewing direction.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要渲染PBR图像，我们必须在渲染表面的每个点上评估BRDF，考虑到表面特性和观察方向。这计算成本很高，包括Khronos的参考glTF-Sample-Viewer在内的许多实时实现，都使用某种预先计算的表格来查找BRDF值，基于表面粗糙度和观察方向。
- en: BRDF LUT can be stored as a two-dimensional texture. The X-axis represents the
    dot product between the surface normal vector and the viewing direction, while
    the Y-axis represents the surface roughness values `0...1`. Each texel holds three
    16-bit floating point values. The first two values represent the scale and bias
    to F0, *which is the specular reflectance at normal incidence*. The third value
    is utilized for the sheen material extension, which will be covered in the following
    chapter.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BRDF LUT可以存储为二维纹理。X轴表示表面法向量与观察方向的点积，而Y轴表示表面粗糙度值 `0...1`。每个texel包含三个16位浮点值。前两个值表示F0的缩放和偏移，*F0是正常入射时的镜面反射率*。第三个值用于光泽材料扩展，将在下一章中介绍。
- en: We are going to use Vulkan to calculate this LUT texture on the GPU and implement
    a compute shader to do it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Vulkan在GPU上计算这个LUT纹理，并实现一个计算着色器来完成它。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is helpful to revisit the Vulkan compute pipeline creation from the *Chapter
    5* recipe *Generating textures in Vulkan using compute shaders*. Our implementation
    is based on a shader from [http://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag](http://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag),
    which runs very similar computations in a fragment shader. Our GLSL compute shader
    can be found in `Chapter06/02_BRDF_LUT/src/main.comp`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有助于回顾一下来自 *第5章* 的配方 *使用计算着色器在Vulkan中生成纹理* 中的Vulkan计算管线创建。我们的实现基于来自 [http://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag](http://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag)
    的着色器，该着色器在片段着色器中执行非常相似的运算。我们的GLSL计算着色器可以在 `Chapter06/02_BRDF_LUT/src/main.comp`
    中找到。
- en: Why precompute?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么预计算？
- en: 'Earlier in this chapter, we explained what BRDF is and introduced its major
    components, such as the Fresnel term `F`, the Normal Distribution Function `NDF`,
    and the Geometry term `G`. As you may notice, the BRDF results depend on several
    factors, such as the incident and outgoing light directions, surface normal, and
    viewer’s direction:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们解释了什么是BRDF，并介绍了其主要组成部分，例如Fresnel项 `F`、法线分布函数 `NDF` 和几何项 `G`。如您所注意到的，BRDF的结果取决于几个因素，例如入射光和出射光的方向、表面法线和观察者的方向：
- en: 'Where the individual terms have the following meanings:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其中各个项的含义如下：
- en: '`D` is the GGX NDF microfacet distribution function:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D` 是GGX NDF微观面分布函数：'
- en: '`G` accounts for mutual shadowing of microfacets and looks as follows:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G` 考虑了微观面的相互阴影，其形式如下：'
- en: 'The Fresnel `F` term defines the amount of light reflected off the surface
    under the given angle of incidence:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fresnel `F` 项定义了在给定入射角下从表面反射的光量：
- en: If we check any component of the BRDF, we will see that all of them are quite
    complex for real-time per-pixel calculations. Therefore, we can use an offline
    process to precompute some parts of the BRDF equation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查BRDF的任何分量，我们会看到它们对于实时每像素计算来说都非常复杂。因此，我们可以使用离线过程预计算BRDF方程的一些部分。
- en: As you can see, the `G` term and some parts of the `F` term depend only on the
    `v`, `h`, and `Roughness` parameters. We will take advantage of this to do precomputation.
    Also, please note that we never need `n` and `v` separately, so we can always
    use their dot product instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`G` 项和 `F` 项的一些部分只依赖于 `v`、`h` 和 `Roughness` 参数。我们将利用这一点来进行预计算。同时，请注意，我们永远不需要单独的
    `n` 和 `v`，因此我们可以始终使用它们的点积。
- en: One important question remains. How can we iterate all possible `v` and `n`
    combinations? To do that, we need to integrate over all angles on a hemisphere,
    but we can use a simpler approximation for that. To make it efficient, we use
    two assumptions. First, we need to find a way to integrate with a limited number
    of samples. Second, we need to choose samples wisely, not just randomly.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重要的问题。我们如何迭代所有可能的 `v` 和 `n` 组合？为了做到这一点，我们需要在一个半球上对所有角度进行积分，但我们可以使用一个更简单的近似。为了使其高效，我们使用两个假设。首先，我们需要找到一种方法，用有限数量的样本进行积分。其次，我们需要明智地选择样本，而不仅仅是随机选择。
- en: As described in *Chapter 20*, *GPU-Based Importance Sampling*, of the book *GPU
    Gems 3* [https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling),
    the solution is to use the **Monte Carlo estimation** with **importance sampling**.
    The Monte Carlo estimation lets us approximate an integral by a weighted sum of
    random samples. Importance sampling exploits the idea that certain values of random
    points over a hemisphere have more impact on the function being estimated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如书中*第20章*，*基于GPU的重要性采样*，在《GPU Gems 3》中所述[https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling)，解决方案是使用**蒙特卡洛估计**配合**重要性采样**。蒙特卡洛估计允许我们通过随机样本的加权求和来近似积分。重要性采样利用了这样的想法：半球上某些随机点的值对被估计的函数有更大的影响。
- en: 'The paper *Real Shading in Unreal Engine 4* by Brian Karis provides a detailed
    explanation of all the mathematical aspects. We strongly recommend reading it
    for a better understanding of the math behind PBR: [https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf](https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由Brian Karis撰写的论文*Real Shading in Unreal Engine 4*提供了所有数学方面的详细解释。我们强烈建议您阅读它，以更好地理解PBR背后的数学：[https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf](https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf)。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Before we investigate the GLSL shader code, let’s implement all the necessary
    C++ code to process data arrays on the GPU.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究GLSL着色器代码之前，让我们实现所有必要的C++代码来处理GPU上的数据数组。
- en: 'To manipulate data buffers on the GPU and utilize the data effectively, we
    require four basic operations: loading a shader module, creating a compute pipeline,
    creating a buffer, and dispatching compute commands. After that, we need to transfer
    the data from the GPU buffer to the host memory and save it as a texture file.
    Let’s walk through these steps by examining the code in `Chapter06/02_BRDF_LUT/src/main.cpp`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在GPU上操作数据缓冲区并有效地利用数据，我们需要四个基本操作：加载着色器模块、创建计算管线、创建缓冲区以及调度计算命令。之后，我们需要将数据从GPU缓冲区传输到主机内存，并保存为纹理文件。让我们通过检查`Chapter06/02_BRDF_LUT/src/main.cpp`中的代码来逐步了解这些步骤：
- en: 'The function `calculateLUT()` implements most of the described functionality.
    We will start with the shader module loading and compute pipeline creation. The
    GLSL shader is specialized using the constant `kNumSamples`, which defines the
    number of Monte Carlo trials for our LUT calculation. We will store 16-bit float
    RGBA values in the buffer:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`calculateLUT()`函数实现了大部分描述的功能。我们将从加载着色器模块和创建计算管线开始。使用常量`kNumSamples`对GLSL着色器进行特殊化，该常量定义了LUT计算的蒙特卡洛试验次数。我们将在缓冲区中存储16位浮点RGBA值：'
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to create a GPU storage buffer for our output data:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为我们的输出数据创建一个GPU存储缓冲区：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we acquire a command buffer, update push constants, and dispatch the
    compute commands:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们获取一个命令缓冲区，更新推送常量，并调度计算命令：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before reading the generated data back to the CPU memory, we must wait for
    the GPU to finish processing the buffer. It can be done using the `wait()` function,
    which waits for a command buffer to finish. We discussed this in the *Chapter
    2* recipe *Using Vulkan command buffers*. Once the GPU has finished working, we
    can copy the memory-mapped buffer back to the CPU memory, referenced by the pointer
    `output`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将生成的数据回读至CPU内存之前，我们必须等待GPU完成缓冲区的处理。这可以通过使用`wait()`函数来实现，该函数会等待命令缓冲区完成。我们曾在*第2章*的配方*使用Vulkan命令缓冲区*中讨论过这一点。一旦GPU完成工作，我们就可以将内存映射的缓冲区复制回CPU内存，该内存由指针`output`引用：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That was the C++ part. Now, let’s investigate the GLSL shader compute code
    in `Chapter06/02_BRDF_LUT/src/main.comp`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是C++部分。现在，让我们研究`Chapter06/02_BRDF_LUT/src/main.comp`中的GLSL着色器计算代码：
- en: 'To break down our work into smaller pieces, we will start with the shader preamble
    and the `main()` function of the BRDF LUT calculation shader. The preamble code
    sets the compute shader dispatching parameters. In our case, a 16x16 chunk of
    the LUT texture is calculated by one GPU work group. The number of Monte Carlo
    trials for numeric integration is declared as a specialization constant that we
    can override from the C++ code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将我们的工作分解成更小的部分，我们将从BRDF LUT计算着色器的着色器前缀和`main()`函数开始。前缀代码设置了计算着色器调度参数。在我们的情况下，LUT纹理的16x16块由一个GPU工作组计算。数值积分的蒙特卡洛试验次数被声明为一个特殊常量，我们可以从C++代码中覆盖它：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We use user-provided width and height to calculate our output buffer dimensions.
    `PI` is the global “physical” constant we use in the shader:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用用户提供的宽度和高度来计算我们的输出缓冲区尺寸。`PI`是在着色器中使用的全局“物理”常数：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `main()` function wraps the `BRDF()` function call and stores the results.
    First, we recalculate the worker ID to output array indices:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()`函数封装`BRDF()`函数调用并存储结果。首先，我们重新计算工作ID以输出数组索引：'
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `BRDF()` function does all the actual work. The calculated value is put
    into the output array:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BRDF()`函数执行所有实际工作。计算出的值被放入输出数组中：'
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we use three channels of the texture. The `R` and `G` channels
    are used for GGX BRDF LUT, and the third channel is used for Charlie BRDF LUT,
    which is required for the **Sheen** material extension and will be covered in
    *Chapter 7*, *Advanced PBR Extensions*.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们使用纹理的三个通道。`R`和`G`通道用于GGX BRDF LUT，第三个通道用于Charlie BRDF LUT，这是**Sheen**材质扩展所必需的，将在*第7章*，*高级PBR扩展*中介绍。
- en: 'Now that we have described the scaffolding parts of our compute shader, we
    can see how the BRDF LUT values are calculated. Let’s look at the steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了我们的计算着色器的框架部分，我们可以看到BRDF LUT值是如何计算的。让我们看看步骤：
- en: 'To generate random directions in a hemisphere, we will use so-called Hammersley
    points, calculated by the following function:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在半球中生成随机方向，我们将使用所谓的Hammersley点，该点由以下函数计算：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Important Note**'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The code is based on the following post: [http://holger.dammertz.org:80/stuff/notes_HammersleyOnHemisphere.xhtml](http://holger.dammertz.org:80/stuff/notes_HammersleyOnHemisphere.xhtml).
    The bit-shifting magic for this and many other applications are thoroughly examined
    in Henry J. Warren’s book called *Hacker’s Delight*. Interested readers may also
    look up the “Van der Corput sequence” to see why this can be used as a series
    of random directions on a hemisphere.'
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码基于以下帖子：[http://holger.dammertz.org:80/stuff/notes_HammersleyOnHemisphere.xhtml](http://holger.dammertz.org:80/stuff/notes_HammersleyOnHemisphere.xhtml)。这本书名为*Hacker’s
    Delight*的Henry J. Warren彻底检查了这种和许多其他应用的位操作魔法。感兴趣的读者还可以查找“Van der Corput序列”以了解为什么它可以作为半球上的一系列随机方向使用。
- en: 'We also need some kind of a pseudorandom number generator. We use the output
    array indices as an input and pass them through another magic set of formulas:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要某种类型的伪随机数生成器。我们使用输出数组索引作为输入并通过另一组神奇的公式传递：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Check out this link to find some useful details about this code: [http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0](http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看此链接以获取有关此代码的一些有用细节：[http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0](http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0)。
- en: 'Let’s look at how importance sampling is implemented according to the paper
    *Real Shading in Unreal Engine 4* by Brian Karis. Check out the fourth page of
    [https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf).
    This function maps an `i`-th 2D point, `Xi`, to a hemisphere with spread based
    on the surface roughness:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何根据Brian Karis的论文*Real Shading in Unreal Engine 4*实现重要性采样。查看[https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)的第四页。此函数将第`i`个2D点`Xi`映射到基于表面粗糙度的半球上：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calculations are done in tangent space, defined by the vectors `up`, `tangentX`,
    and `tangentY`, and then converted to world space:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在切线空间中进行，由向量`up`、`tangentX`和`tangentY`定义，然后转换为世界空间：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another utility function, `G_SchlicksmithGGX()`, calculates the GGX geometric
    shadowing factor:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个实用函数`G_SchlicksmithGGX()`计算GGX几何阴影因子：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also precalculate LUT for the Sheen material, so there are two more helper
    functions, `V_Ashikhmin()` and `D_Charlie()`. They are based on the code from
    the Filament engine: [https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136](https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还预先计算了光泽材料的 LUT，因此还有两个额外的辅助函数，`V_Ashikhmin()` 和 `D_Charlie()`。它们基于 Filament
    引擎的代码：[https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136](https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136)：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is a corresponding sampling function, `importanceSample_Charlie()`, for
    the Sheen material, which is very similar to `importanceSample_GGX()`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是针对光泽材料的相应采样函数，`importanceSample_Charlie()`，它与 `importanceSample_GGX()` 非常相似：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The value of BRDF is calculated the following way, using all of the helper
    functions we declared above. The number of Monte Carlo trials, `NUM_SAMPLES`,
    is set earlier to be `1024`. The normal vector `N` always points along the Z-axis
    for the 2D look-up:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BRDF 的值按照以下方式计算，使用我们上面声明的所有辅助函数。蒙特卡洛试验次数 `NUM_SAMPLES` 之前设置为 `1024`。法向量 `N`
    对于 2D 查找始终指向 Z 轴：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first loop calculates the `R` and `G` components of our LUT, which correspond
    to the scale and bias to `F0`, respectively:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个循环计算我们 LUT 的 `R` 和 `G` 分量，分别对应于对 `F0` 的缩放和偏移：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The third component, `B`, used for the sheen material is calculated in another
    loop. We will revisit it in *Chapter 7*, *Advanced PBR Extensions*:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于光泽材料的第三个分量 `B` 在另一个循环中计算。我们将在 *第 7 章*，*高级 PBR 扩展* 中重新讨论它：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That is the entire GLSL compute shader used to precalculate the look-up table.
    Let’s now see how it works with the C++ `main()` function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是整个用于预计算查找表的 GLSL 计算着色器。现在让我们看看它是如何与 C++ 的 `main()` 函数一起工作的。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `main()` function creates a KTX texture using the *KTX-Software* library
    so that our 16-bit RGBA LUT texture can be saved in the `.ktx` format, preserving
    the data. Then, it calls the `calculateLUT()` function we discussed above, which
    outputs the generated LUT data into the KTX texture. The texture is saved in `data/brdfLUT.ktx`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数使用 *KTX-Software* 库创建一个 KTX 纹理，以便我们的 16 位 RGBA LUT 纹理可以保存为 `.ktx`
    格式，从而保留数据。然后，它调用我们上面讨论的 `calculateLUT()` 函数，该函数将生成的 LUT 数据输出到 KTX 纹理中。纹理保存在 `data/brdfLUT.ktx`：'
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can use *Pico Pixel* ([https://pixelandpolygon.com](https://pixelandpolygon.com))
    to view the generated image. It should resemble the screenshot below. The horizontal
    axis represents the dot product between the surface normal vector and the viewing
    direction, while the vertical axis represents the surface roughness values `0...1`.
    Each texel holds three 16-bit floating point values. The first two values represent
    the scale and bias to `F0`, which is the specular reflectance at normal incidence.
    The third value is utilized for the sheen material extension, which will be covered
    in the next chapter:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 *Pico Pixel* ([https://pixelandpolygon.com](https://pixelandpolygon.com))
    来查看生成的图像。它应该类似于下面的截图。水平轴表示表面法向量与观察方向的点积，而垂直轴表示表面粗糙度值 `0...1`。每个纹理像素包含三个 16 位浮点值。前两个值表示对
    `F0` 的缩放和偏移，`F0` 是正入射时的镜面反射率。第三个值用于光泽材料扩展，这将在下一章中介绍：
- en: '![Figure 6.5: BRDF lookup table](img/file45.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5：BRDF 查找表](img/file45.png)'
- en: 'Figure 6.5: BRDF lookup table'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：BRDF 查找表
- en: This concludes the BRDF lookup table tool description. We will need yet another
    tool to calculate an irradiance cube map from an environment cube map, which we
    will cover in the next recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了 BRDF 查找表工具的描述。我们还需要另一个工具来从环境立方体贴图计算辐照度立方体贴图，这将在下一道菜谱中介绍。
- en: There’s more...
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The method described above can be used to precompute BRDF look-up tables, using
    high-quality Monte Carlo integration, and store them as textures. Dependent texture
    fetches can be expensive on some mobile platforms. There is an interesting runtime
    approximation used in Unreal Engine that does not rely on any precomputation,
    as described in the blog post *Physically Based Shading on Mobile* by Brian Karis:
    [https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile](https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile).
    Here is the GLSL source code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上文描述的方法可以用于使用高质量的蒙特卡洛积分预计算 BRDF 查找表，并将它们作为纹理存储。在某些移动平台上，依赖于纹理的提取可能很昂贵。Unreal
    Engine 中使用了一个有趣的运行时近似，它不依赖于任何预计算，如 Brian Karis 在博客文章 *Physically Based Shading
    on Mobile* 中所述：[https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile](https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile)。以下是
    GLSL 源代码：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Precomputing irradiance maps and diffuse convolution
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预计算辐照度图和漫反射卷积
- en: As we discussed earlier in the recipe *An introduction to the glTF 2.0 Physically
    Based Shading Model*, the second part of the split sum approximation necessary
    to calculate the glTF 2.0 physically based shading model comes from the irradiance
    cube map, which is precalculated by convolving the input environment cube map
    with the GGX distribution of our shading model. Our implementation is based on
    the code at [https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag](https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在菜谱*glTF 2.0 物理着色模型简介*中之前讨论的，计算glTF 2.0物理着色模型所需的分割和近似法的第二部分来自辐照度立方体贴图，该立方体贴图通过卷积输入环境立方体贴图和我们的着色模型的GGX分布来预计算。我们的实现基于[https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag](https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/main/source/shaders/ibl_filtering.frag)中的代码。
- en: '**Image-based lighting** (**IBL**) is a technique for illuminating a scene
    using captured light information. This information can be stored as panoramic
    photo images (for example, see *Figure 6.6*). It is very hard to simulate entire
    real-world environments, so capturing the real world and using images is a very
    common technique nowadays to produce realistic renders. Using IBL allows us to
    precompute the parts of the diffuse and specular BRDF equations and make them
    more runtime-friendly.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于图像的照明**（**IBL**）是一种使用捕获的光信息照亮场景的技术。这些信息可以存储为全景照片图像（例如，参见*图6.6*）。模拟整个真实世界环境非常困难，因此捕获真实世界并使用图像是如今产生逼真渲染的非常常见的技术。使用IBL允许我们预计算漫反射和镜面BRDF方程的部分，并使它们在运行时更加友好。'
- en: 'Note that precomputing irradiance and diffusion is quite a mathematical process.
    If you want to learn more about the theory behind these computations, make sure
    you read Brian Karis’s paper *Real Shading in Unreal Engine 4*: [https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预计算辐照度和扩散是一个相当数学的过程。如果您想了解更多关于这些计算背后的理论，请确保您阅读Brian Karis的论文*Real Shading
    in Unreal Engine 4*：[https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf](https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf)。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: Check out the source code for this recipe in `Chapter06/03_FilterEnvmap`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter06/03_FilterEnvmap`中查看此菜谱的源代码。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will do Monte-Carlo integration inside a fragment shader, which is located
    here: `Chapter06/03_FilterEnvmap/src/main.frag`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在片段着色器内部进行蒙特卡洛积分，该着色器位于此处：`Chapter06/03_FilterEnvmap/src/main.frag`。
- en: 'The C++ source code can be found in the `Chapter06/03_FilterEnvmap/src/main.cpp`
    file. Let’s go through the function `prefilterCubemap()` to precompute the irradiance
    and diffuse maps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: C++源代码可以在`Chapter06/03_FilterEnvmap/src/main.cpp`文件中找到。让我们通过函数`prefilterCubemap()`来预计算辐照度和漫反射图：
- en: First, we need to create a cube map texture to store the results of prefiltering.
    We will use the 32-bit RGBA floating point pixel format because most of our color-related
    calculations happen in linear space. Low-end mobile devices might be not performant
    enough, and in this case, the dynamic range can be clamped to 16-bit or even 8-bit,
    but that might significantly impact the visual fidelity.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个立方体贴图纹理来存储预过滤的结果。我们将使用32位RGBA浮点像素格式，因为我们的大多数颜色相关计算都在线性空间中进行。低端移动设备可能性能不足，在这种情况下，动态范围可以限制为16位甚至8位，但这可能会显著影响视觉效果。
- en: 'We use cubemap mip-levels to precompute multiple lookups for different values
    of material roughness `0…1`. The function takes in the `distribution` parameter,
    which is passed to the shader to select an appropriate distribution, Lambertian,
    GGX, or Charlie:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用立方体贴图MIP级别来预计算不同材料粗糙度`0…1`的不同值的多个查找。该函数接受`distribution`参数，该参数传递给着色器以选择适当的分布，Lambertian、GGX或Charlie：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We require GLSL shader modules and a rendering pipeline:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要GLSL着色器模块和渲染管线：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can start doing the actual rendering in the cubemap. One command buffer
    is filled with all the commands necessary to render in `6` cubemap faces, with
    all the required mip-levels:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在立方体贴图中开始实际渲染。一个命令缓冲区填充了渲染`6`个立方体贴图面所需的所有命令，包括所有所需的MIP级别：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We set the cube map face and the specific mip-level we want to render:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置要渲染的立方体贴图面和特定的MIP级别：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Push constants are used to pass all the data into the shaders:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用推送常量将所有数据传递到着色器中：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, a full-screen triangle is rendered to cover the entire cube face and
    let the fragment shader do its work. After the command buffer is filled up, we
    can submit it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，渲染一个全屏三角形以覆盖整个立方体贴图面，并让片段着色器完成其工作。在命令缓冲区填满后，我们可以提交它：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The remaining part of the `prefilterCubemap()` function retrieves the generated
    cubemap data from the GPU and saves it in a `.ktx` file. Let’s look at the GLSL
    fragment shader code, which does all the heavy lifting in `Chapter06/03_FilterEnvmap/src/main.frag`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefilterCubemap()` 函数的剩余部分从 GPU 获取生成的立方体贴图数据，并将其保存为 `.ktx` 文件。让我们看看 GLSL
    片段着色器代码，它位于 `Chapter06/03_FilterEnvmap/src/main.frag` 目录中，执行了所有繁重的工作：'
- en: 'To unwind the shader logic, let’s start with the entry point, `main()`. The
    code is trivial and invokes two functions. The function `uvToXYZ()` converts a
    cubemap face index and `vec2` coordinates into a `vec3` cubemap sampling direction.
    The function `filterColor()` does the actual Monte Carlo sampling, which we will
    come back to in a moment:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解开着色器逻辑，让我们从入口点 `main()` 开始。代码很简单，调用了两个函数。函数 `uvToXYZ()` 将立方体贴图面索引和 `vec2`
    坐标转换为 `vec3` 立方体贴图采样方向。函数 `filterColor()` 执行实际的蒙特卡洛采样，我们稍后会回到这个话题：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s the code of `uvToXYZ()` for your reference:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是 `uvToXYZ()` 的代码，供您参考：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The function `filterColor()` does the integration part for irradiance and Lambertian
    diffuse convolution. The argument `N` is the cubemap sampling direction vector.
    We iterate `sampleCount` samples and get the importance sampling information,
    which includes the importance sample direction and the **probability distribution
    function** (**PDF**) for this direction. The mathematical part is described in
    detail in this blog post: [https://bruop.github.io/ibl](https://bruop.github.io/ibl).
    Here, we will focus on putting a minimalistic working implementation together:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `filterColor()` 为辐照度和朗伯漫反射卷积执行积分部分。参数 `N` 是立方体贴图采样方向向量。我们迭代 `sampleCount`
    个样本，并获取重要性采样信息，包括重要性采样方向和该方向的 **概率密度函数**（**PDF**）。数学部分在本博客文章中有详细描述：[https://bruop.github.io/ibl](https://bruop.github.io/ibl)。在这里，我们将专注于构建一个最小化工作实现：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Mipmap samples are filtered as described in *GPU Gems 3* at section *20.4*,
    *Mapping and Distortion.* Sample Lambertian at a lower resolution to avoid pixels
    that are too bright, also known as **fireflies**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同在 *GPU Gems 3* 的 *20.4* 节 *映射和扭曲* 中描述的那样，对米普贴样本进行过滤：在较低分辨率下采样朗伯，以避免过亮的像素，也称为
    **飞火**：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output color value is renormalized using the sum of all `NdotL` weights,
    or the number of samples for the Lambertian case:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出颜色值使用所有 `NdotL` 权重的总和进行重新归一化，或者对于朗伯情况下的样本数量：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The importance sampling function `getImportanceSample()` returns a `vec4` value,
    with an importance sample direction in the `.xyz` components and the PDF scalar
    value in the `.w` component. We generate a Hammersley point, as we described earlier
    in the previous recipe, *Precomputing BRDF look-up tables*, and then, based on
    the distribution type (Lambertian, GGX, or Charlie), we generate a sample and
    rotate it in the normal direction. This function uses a helper structure, `MicrofacetDistributionSample`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要性采样函数 `getImportanceSample()` 返回一个 `vec4` 值，其中重要性采样方向位于 `.xyz` 组件中，而 PDF 标量值位于
    `.w` 组件中。我们生成一个 Hammersley 点，正如我们在之前的配方中描述的，*预计算 BRDF 查找表*，然后根据分布类型（朗伯、GGX 或 Charlie）生成一个样本，并在法线方向上旋转它。此函数使用辅助结构
    `MicrofacetDistributionSample`：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Generate points on a hemisphere with a mapping corresponding to the desired
    distribution. For example, Lambertian distribution uses a cosine importance:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在半球上生成点，其映射对应于所需的分布。例如，朗伯分布使用余弦重要性：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Transform the hemisphere sample point into the tangent coordinate frame. The
    helper function `generateTBN()` generates a tangent-bitangent-normal coordinate
    frame from the provided normal vector:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将半球采样点转换为切线坐标系。辅助函数 `generateTBN()` 从提供的法线向量生成切线-切线-法线坐标系：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will skip the details of the individual distribution calculation functions
    `Lambertian()`, `GGX()`, and `Charlie()`. The actual GLSL shader `Chapter06/03_FilterEnvmap/src/main.frag`
    contains all the necessary code.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将跳过个别分布计算函数 `Lambertian()`、`GGX()` 和 `Charlie()` 的细节。实际的 GLSL 着色器 `Chapter06/03_FilterEnvmap/src/main.frag`
    包含所有必要的代码。
- en: 'The process of importance sampling can introduce visual artifacts. One way
    to improve visual quality without compromising performance is by utilizing hardware-accelerated
    mip-mapping for swift filtering and sampling. This idea was proposed in the following
    paper: [https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf](https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf).
    This link has a more detailed treatment of the subject: [https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling).
    Here, we use a formula that takes a **PDF** value and calculates a proper mip-map
    LOD level for it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 重要性采样的过程可能会引入视觉伪影。在不影响性能的情况下提高视觉质量的一种方法是通过利用硬件加速的米波映射进行快速过滤和采样。这个想法在以下论文中提出：[https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf](https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf)。此链接对该主题有更详细的说明：[https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling](https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling)。在这里，我们使用一个公式，它接受一个**PDF**值并为其计算适当的米波映射
    LOD 级别：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The rest of the code involves purely mechanical tasks, such as loading the
    cube map image from a file, calling the rendering functions for various distribution
    types (Lambertian, GGX, and Charlie), and saving the result using the KTX library.
    Let’s check out the results of prefiltering for the following input image:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分涉及纯粹机械的任务，例如从文件中加载立方体贴图图像，调用各种分布类型（朗伯、GGX 和 Charlie）的渲染函数，以及使用 KTX 库保存结果。让我们检查以下输入图像的预过滤结果：
- en: '![Figure 6.6: Environment cube map](img/file46.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：环境立方体贴图](img/file46.png)'
- en: 'Figure 6.6: Environment cube map'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：环境立方体贴图
- en: 'The convolved image should look like the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 卷积后的图像应该看起来像以下截图：
- en: '![Figure 6.7: Prefiltered environment cube map using diffuse convolution](img/file47.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：使用漫反射卷积预过滤的环境立方体贴图](img/file47.png)'
- en: 'Figure 6.7: Prefiltered environment cube map using diffuse convolution'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：使用漫反射卷积预过滤的环境立方体贴图
- en: Now, we have all supplementary parts in place to render a PBR image. In the
    next recipe, *Implementing the glTF 2.0 metallic-roughness shading model*, we
    are going to put everything together into a simple application to render a physically
    based glTF 2.0 3D model.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了所有辅助部分来渲染 PBR 图像。在下一个配方“实现 glTF 2.0 金属-粗糙度着色模型”中，我们将把所有内容组合到一个简单的应用程序中，以渲染基于物理的
    glTF 2.0 3D 模型。
- en: There’s more...
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Paul Bourke created a set of tools and a great resource that explains how to
    convert cube maps into different formats. Make sure to check it out: [http://paulbourke.net/panorama/cubemaps/index.xhtml](http://paulbourke.net/panorama/cubemaps/index.xhtml).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Paul Bourke 创建了一套工具和丰富的资源，解释了如何将立方体贴图转换为不同的格式。请确保查看：[http://paulbourke.net/panorama/cubemaps/index.xhtml](http://paulbourke.net/panorama/cubemaps/index.xhtml)。
- en: Implementing the glTF 2.0 metallic-roughness shading model
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 glTF 2.0 金属-粗糙度着色模型
- en: This recipe will cover how to integrate PBR into your graphics pipeline. Since
    the topic of PBR is vast, we will focus on a minimalistic implementation just
    to guide you and get you started. In this section, we will focus on the metallic-roughness
    shading model and minimalistic C++ viewer implementation. In the following chapters,
    we will create a more complex and feature-rich glTF viewer, including advanced
    material extensions and geometry features.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将介绍如何将 PBR 集成到您的图形管线中。由于 PBR 的主题非常广泛，我们将关注最小化实现，仅为了指导您并让您开始。在本节中，我们将关注金属-粗糙度着色模型和最小化
    C++ 观察器实现。在接下来的章节中，我们将创建一个更复杂、功能更丰富的 glTF 观察器，包括高级材质扩展和几何特征。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: It is recommended to revisit the recipe *An introduction to the glTF 2.0 physically
    based shading model* before you proceed with this one. A lightweight introduction
    to the glTF 2.0 shading model can be found at [https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR](https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续进行之前，建议您重新阅读配方《glTF 2.0 基于物理的着色模型简介》。有关 glTF 2.0 着色模型的轻量级介绍，可以在[https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR](https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR)找到。
- en: The C++ source code for this recipe is in the `Chapter06/04_MetallicRoughness`
    folder. The GLSL shader code responsible for PBR calculations can be found in
    `Chapter06/04_MetallicRoughness/src/PBR.sp`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此配方的 C++ 源代码位于 `Chapter06/04_MetallicRoughness` 文件夹中。负责 PBR 计算的 GLSL 着色器代码可以在
    `Chapter06/04_MetallicRoughness/src/PBR.sp` 中找到。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Before we dive deep into the GLSL code, we’ll look at how the input data is
    set up from the C++ side. We are going to use the *Damaged Helmet* 3D model provided
    by Khronos. You can find the glTF file here: [https://github.com/KhronosGroup/glTF-Sample-Models/blob/main/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf](https://github.com/KhronosGroup/glTF-Sample-Models/blob/main/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 GLSL 代码之前，我们将查看从 C++ 端设置输入数据的方式。我们将使用 Khronos 提供的 *损坏头盔* 3D 模型。您可以在以下位置找到
    glTF 文件：[https://github.com/KhronosGroup/glTF-Sample-Models/blob/main/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf](https://github.com/KhronosGroup/glTF-Sample-Models/blob/main/2.0/DamagedHelmet/glTF/DamagedHelmet.gltf)。
- en: 'Let’s start with structures and helper functions first:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从结构和辅助函数开始：
- en: 'The helper struct `GLTFGlobalSamplers` contains three samplers necessary to
    access glTF IBL textures. It is declared in `shared/UtilsGLTF.h`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助结构 `GLTFGlobalSamplers` 包含了访问 glTF IBL 纹理所需的三个采样器。它在 `shared/UtilsGLTF.h`
    中声明：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `GLTFGlobalSamplers` constructor creates all three samplers in the following
    way:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GLTFGlobalSamplers` 构造函数以以下方式创建所有三个采样器：'
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The helper struct `EnvironmentMapTextures` stores all IBL environment map textures
    and the BRDF look-up table, providing default textures for the sake of simplicity:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助结构 `EnvironmentMapTextures` 存储了所有 IBL 环境图纹理和 BRDF 查找表，为了简单起见提供了默认纹理：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Check the previous recipe *Precomputing irradiance maps and diffuse convolution*
    for details on how to precalculate the IBL textures. The BRDF look-up table was
    precalculated in the recipe *Precomputing BRDF look-up tables*.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅之前的配方 *预计算辐照度图和漫反射卷积*，了解如何预计算 IBL 纹理的详细信息。BRDF 查找表是在配方 *预计算 BRDF 查找表* 中预计算的。
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The structure `GLTFMaterialTextures` contains all the textures necessary to
    render any glTF 2.0 model we support in our demos. It is a container for many
    `Holder<TextureHandle>` objects, as follows:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构 `GLTFMaterialTextures` 包含了渲染我们演示中支持的任何 glTF 2.0 模型所需的所有纹理。它是一个包含多个 `Holder<TextureHandle>`
    对象的容器，如下所示：
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The helper function `loadMaterialTextures()` is not shared and will be different
    in each app. This variant of the function loads a subset of necessary textures
    for our metallic-roughness demo:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助函数 `loadMaterialTextures()` 不可共享，并且每个应用程序中都会有所不同。此函数的变体加载了金属-粗糙度演示所需纹理的子集：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'One important step is to load the material data and fill out the `MetallicRoughnessDataGPU`
    structure. We will use the Assimp API to retrieve the material properties and
    fill out the corresponding values. The glTF specification requires well-defined
    default values for non-optional and optional properties, so we fill them out in
    this snippet as well. For each texture, we read and set the data for a sampler
    state and a `uv` coordinates index:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个重要步骤是加载材质数据并填写 `MetallicRoughnessDataGPU` 结构。我们将使用 Assimp API 获取材质属性并填写相应的值。glTF
    规范要求非可选和可选属性有明确的默认值，因此我们也在这个片段中填写了它们。对于每个纹理，我们读取并设置采样状态和 `uv` 坐标索引的数据：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we pack the `metallicFactor`, `roughnessFactor`, `normalScale`, and `occlusionStrength`
    glTF properties into one `vec4` member field, `metallicRoughnessNormalOcclusion`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将 `metallicFactor`、`roughnessFactor`、`normalScale` 和 `occlusionStrength`
    glTF 属性打包到一个 `vec4` 成员字段 `metallicRoughnessNormalOcclusion` 中。
- en: 'We do this packing as a very basic optimization. GPU stores this data in vector
    registers, and reading it will be more efficient if we pack all the parameters
    into a single `vec4` value. Another reason is avoiding any additional alignment
    requirements, especially for `vec3` types. Similar packing is done for a `vec3`
    glTF property, `emissiveFactor`, and a `float`, `alphaCutoff`, both of which are
    packed into a single `vec4` value:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们这样做是为了进行非常基本的优化。GPU 将此数据存储在向量寄存器中，如果我们将所有参数打包到一个单一的 `vec4` 值中，读取它将更加高效。另一个原因是避免任何额外的对齐要求，特别是对于
    `vec3` 类型。类似的打包也用于 `vec3` glTF 属性 `emissiveFactor` 和一个 `float`，`alphaCutoff`，它们都被打包到一个单一的
    `vec4` 值中：
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The other member fields hold texture and sampler IDs for our bindless shaders.
    They have no default values other than `0`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他成员字段持有用于我们的无绑定着色器的纹理和采样器 ID。除了 `0` 以外没有默认值：
- en: '[PRE55]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `alphaMode` property defines how the alpha value is interpreted. The alpha
    value itself should be taken from the `4`-th component of the base color for the
    metallic-roughness material model:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alphaMode` 属性定义了如何解释 alpha 值。alpha 值本身应从金属-粗糙度材质模型的基色 `4`-th 组件中获取：'
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `MetallicRoughnessDataGPU` structure is filled out using a helper function,
    `setupMetallicRoughnessData()`. The structure `GLTFMaterialTextures` was discussed
    above:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用辅助函数 `setupMetallicRoughnessData()` 填充 `MetallicRoughnessDataGPU` 结构。上面讨论了
    `GLTFMaterialTextures` 结构：
- en: '[PRE57]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The rest of the function continues to read various glTF material properties,
    using the Assimp API. We paste just the beginning of its code here. All other
    material properties are loaded in a similarly repeating pattern:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的其余部分继续读取各种 glTF 材质属性，使用 Assimp API。我们在这里粘贴其代码的起始部分。所有其他材质属性都以类似重复的模式加载：
- en: '[PRE58]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The helper function `assignUVandSampler()` looks as follows:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助函数 `assignUVandSampler()` 的样子如下：
- en: '[PRE59]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s go through the `main()` function:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过 `main()` 函数来分析：
- en: 'First, we load the glTF file using Assimp. We support only triangulated topology;
    hence, the flag `aiProcess_Triangulate` is used to instruct Assimp to triangulate
    the mesh during the import:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 Assimp 加载 glTF 文件。我们只支持三角化拓扑；因此，使用标志 `aiProcess_Triangulate` 指示 Assimp
    在导入期间对网格进行三角化：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We populate the vertex data. The struct Vertex is shared across all glTF demos
    and is declared in `shared/UtilsGLTF.h`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们填充顶点数据。结构 `Vertex` 在所有 glTF 演示中共享，并在 `shared/UtilsGLTF.h` 中声明：
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A glTF model commonly uses two sets of UV texture coordinates. The first set,
    `uv0`, is used for the primary texture mapping, such as diffuse color, specular
    reflection, or normal mapping. These coordinates are typically used for surface
    details and color information. The second set, `uv1`, is commonly used for lightmaps
    or reflection maps. These maps often need separate texture coordinates to be mapped
    correctly onto the model, distinct from the primary texture coordinates. The glTF
    specification says that a viewer app should support at least two texture coordinate
    sets:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: glTF 模型通常使用两组 UV 纹理坐标。第一组，`uv0`，用于主纹理映射，例如漫反射颜色、镜面反射或法线映射。这些坐标通常用于表面细节和颜色信息。第二组，`uv1`，通常用于光照图或反射图。这些图通常需要单独的纹理坐标来正确映射到模型上，与主纹理坐标不同。glTF
    规范指出，查看器应用程序应至少支持两组纹理坐标集：
- en: '[PRE62]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let’s set up indices that define our triangles and upload the resulting vertex
    and index data into the corresponding buffers:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们设置定义我们的三角形的索引，并将生成的顶点和索引数据上传到相应的缓冲区：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The next step is to load all the material textures. We use the same combination
    of textures for most of our glTF demos, so we store them in a structure, `GLTFMaterialTextures`,
    declared in `shared/UtilsGLTF.h`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是加载所有材质纹理。我们的大多数 glTF 演示使用相同的纹理组合，因此我们将它们存储在结构 `GLTFMaterialTextures` 中，该结构在
    `shared/UtilsGLTF.h` 中声明：
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Before we continue with the graphics pipeline creation and rendering, we have
    to set up IBL samplers, textures, and BRDF look-up tables. This data is shared
    between all our demos, so we have introduced a couple of helper structs to do
    all this work for us. Here are the definitions within the `main()` function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续创建图形管线和渲染之前，我们必须设置 IBL 样本、纹理和 BRDF 查找表。这些数据在所有我们的演示中是共享的，因此我们引入了一些辅助结构来为我们完成所有这些工作。以下是
    `main()` 函数中的定义：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The next step is to create a render pipeline step for our glTF rendering. We
    must provide a vertex input description. Here’s how to create one for our model:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是为我们的 glTF 渲染创建一个渲染管线步骤。我们必须提供一个顶点输入描述。以下是为我们的模型创建一个描述的方法：
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A rendering pipeline should be created as follows. We will investigate the
    GLSL shaders in the *How it works…* section:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染管线应按以下方式创建。我们将在 *How it works…* 部分研究 GLSL 着色器：
- en: '[PRE67]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can call `setupMetallicRoughnessData()` to load all the material data from
    glTF and properly pack it on the CPU side:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以调用 `setupMetallicRoughnessData()` 来从 glTF 加载所有材质数据，并在 CPU 端正确打包：
- en: '[PRE68]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We store the material data inside a dedicated Vulkan buffer and access it in
    GLSL shaders, using a buffer device address. This address is passed into shaders
    through Vulkan push constants.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将材质数据存储在一个专用的 Vulkan 缓冲区中，并在 GLSL 着色器中使用缓冲区设备地址访问它。此地址通过 Vulkan 推送常量传递到着色器中：
- en: '[PRE69]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The same treatment applies to our environment textures. They should be packed
    for the GPU, too:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相同的处理也适用于我们的环境纹理。它们也应该为 GPU 打包：
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The maximum allowed push constant size is 128 bytes. In order to handle data
    exceeding this size, we will set up a couple of round-robin buffers:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许的最大推送常量大小为 128 字节。为了处理超出此大小的数据，我们将设置几个循环缓冲区：
- en: '[PRE71]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Everything else is just mesh rendering, similar to how it was done in the previous
    chapters. Here is how `draw` commands to render a glTF mesh are generated:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他一切都是网格渲染，类似于前几章中执行的方式。以下是生成渲染 glTF 网格的 `draw` 命令的方式：
- en: '[PRE72]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Let’s skip the rest of the C++ code, which contains trivial command buffer submission
    and other scaffolding, and check how GLSL shaders work.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过其余的 C++ 代码，这些代码包含平凡的命令缓冲区提交和其他框架，并检查 GLSL 着色器是如何工作的。
- en: How it works…
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are two GLSL shaders that are used to render our metallic-roughness PBR
    model, a vertex shader `Chapter06/04_MetallicRoughness/src/main.vert`, and a fragment
    shader, `Chapter06/04_MetallicRoughness/src/main.frag`, which include additional
    files for shared input declarations and our glTF PBR code GLSL library. The vertex
    shader uses programmable-vertex-pulling to read the vertex data from buffers.
    The most important aspect of the vertex shader is that we define our own functions,
    such as `getModel()` or `getTexCoord()`, to hide the implementation details of
    vertex pulling. It allows us to be flexible when we want to change the structure
    of our input data. We use a similar approach for fragment shaders.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 GLSL 着色器用于渲染我们的金属-粗糙度 PBR 模型，一个是顶点着色器 `Chapter06/04_MetallicRoughness/src/main.vert`，另一个是片段着色器
    `Chapter06/04_MetallicRoughness/src/main.frag`，它们包括用于共享输入声明和我们的 glTF PBR 代码 GLSL
    库的附加文件。顶点着色器使用可编程顶点提取来从缓冲区读取顶点数据。顶点着色器最重要的方面是我们定义了自己的函数，例如 `getModel()` 或 `getTexCoord()`，以隐藏顶点提取的实现细节。这允许我们在想要更改输入数据结构时更加灵活。我们为片段着色器采用类似的方法。
- en: 'It is the fragment shader that does the actual work. Let’s take a look:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实际工作是由片段着色器完成的。让我们看看：
- en: 'First, we check our inputs. We will use buffer references for materials and
    environment buffers that correspond to the C++ structures `MetallicRoughnessDataGPU`
    and `EnvironmentMapDataGPU`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查我们的输入。我们将使用与 C++ 结构 `MetallicRoughnessDataGPU` 和 `EnvironmentMapDataGPU`
    对应的材料和环境缓冲区的引用：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We use four helper functions, `getMaterialId()`, `getMaterial()`, `getEnvironmentId()`,
    and `getEnvironment()`, as shortcuts to access the buffer references provided
    in the push constants:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用四个辅助函数，`getMaterialId()`、`getMaterial()`、`getEnvironmentId()` 和 `getEnvironment()`，作为访问推送常量中提供的缓冲区引用的快捷方式：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inside the file `Chapter06/04_MetallicRoughness/src/inputs.frag`, there are
    a bunch of helper functions – such as `sampleAO()`, `samplerEmissive()`, `sampleAlbedo()`,
    and many others – to sample from various glTF PBR texture maps based on the material
    `mat`. All of them use bindless textures and samplers:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件 `Chapter06/04_MetallicRoughness/src/inputs.frag` 中，有一系列辅助函数，例如 `sampleAO()`、`samplerEmissive()`、`sampleAlbedo()`
    以及许多其他函数，它们根据材料 `mat` 从各种 glTF PBR 纹理贴图中采样。所有这些函数都使用无绑定纹理和采样器：
- en: '[PRE75]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Within the fragment shader’s `main()` function, we use these helper functions
    to sample the texture maps based on the material ID value returned by `getMaterialId()`:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器的 `main()` 函数中，我们使用这些辅助函数根据 `getMaterialId()` 返回的材料 ID 值采样纹理贴图：
- en: '[PRE76]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: To calculate the proper normal mapping effect based on a provided normal map,
    we evaluate the normal vector per pixel. We do it in world space. The normal map
    is in tangent space. Hence, the function `perturbNormal()` calculates the tangent
    space per pixel using the derivatives of texture coordinates, which is implemented
    in `data/shaders/UtilsPBR.sp`, and transforms the perturbed normal to world space.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了根据提供的法线贴图计算适当的标准法线映射效果，我们评估每个像素的法线向量。我们在世界空间中执行此操作。法线贴图位于切线空间中。因此，`perturbNormal()`
    函数使用纹理坐标的导数来计算每个像素的切线空间，该函数在 `data/shaders/UtilsPBR.sp` 中实现，并将扰动的法线转换到世界空间。
- en: 'The last step here is to negate the normal for double-sided materials. We use
    the `gl_FrontFacing` intrinsic variable to do the check:'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步是对双面材料的法线取反。我们使用 `gl_FrontFacing` 内置变量进行检查：
- en: '[PRE77]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, we are ready to fill out the `PBRInfo` structure, which holds multiple
    inputs utilized later by the various functions in the PBR shading equation:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备填写 `PBRInfo` 结构，该结构包含多个输入，这些输入随后在 PBR 着色方程中的各种函数中使用：
- en: '[PRE78]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next step is to calculate the specular and diffuse color contributions
    from the IBL environment lighting. We can directly add `diffuse_color` and `specular_color`
    because our precalculated BRDF LUT already takes care of energy conservation:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是计算IBL环境光照的镜面和漫反射颜色贡献。我们可以直接将`diffuse_color`和`specular_color`相加，因为我们的预计算的BRDF
    LUT已经处理了能量守恒：
- en: '[PRE79]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For this demo application, we use only one hardcoded directional light source,
    `(0, 0, -5)`. Let’s calculate its lighting contribution:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个演示应用程序，我们只使用一个硬编码的方向性光源`(0, 0, -5)`。让我们计算它的光照贡献：
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we should multiply the color by the ambient occlusion factor. Use `1.0`
    if there is no ambient occlusion texture available:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该将颜色乘以环境遮蔽因子。如果没有环境遮蔽纹理可用，则使用`1.0`：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we apply the emissive color contribution. Before writing the framebuffer
    output, we convert the resulting color back into the sRGB color space using a
    hardcoded gamma value of `2.2`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应用发射颜色贡献。在写入帧缓冲区输出之前，我们使用硬编码的伽玛值`2.2`将结果颜色转换回sRGB颜色空间：
- en: '[PRE82]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We mentioned a bunch of helper functions that use the `PBRInfo` structure,
    such as `getIBLRadianceContributionGGX()`, `getIBLRadianceLambertian()`, and `calculatePBRLightContribution()`.
    Let’s look inside `Chapter06/04_MetallicRoughness/src/PBR.sp` to see how they
    work. Our implementation is based on the reference implementation of the glTF
    2.0 Sample Viewer from Khronos: [https://github.com/ KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR](https://github.com/):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '我们提到了一些使用`PBRInfo`结构的辅助函数，例如`getIBLRadianceContributionGGX()`、`getIBLRadianceLambertian()`和`calculatePBRLightContribution()`。让我们查看`Chapter06/04_MetallicRoughness/src/PBR.sp`文件，看看它们是如何工作的。我们的实现基于Khronos的glTF
    2.0 Sample Viewer的参考实现：[https://github.com/KhronosGroup/glTF-Sample-Viewer/tree/glTF-WebGL-PBR](https://github.com/):'
- en: 'First of all, here is the `PBRInfo` structure, which holds various input parameters
    for our metallic-roughness glTF PBR shading model. The first values represent
    the geometric properties of the surface at the current point:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，这是`PBRInfo`结构，它包含我们金属-粗糙度glTF PBR着色模型的多个输入参数。前几个值代表当前点的表面几何属性：
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following values represent the material properties:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下值代表材料属性：
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The sRGB to linear color space conversion routine is implemented this way.
    It is a popular rough approximation done for simplicity:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: sRGB到线性颜色空间的转换例程是这样实现的。这是一个为了简单而做的流行近似：
- en: '[PRE85]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Calculation of the lighting contribution from an image-based light source is
    split into two parts – diffuse irradiance and specular radiance. First, let’s
    start with the radiance part. We will use the Lambertian diffuse term. Khronos
    implementation is quite complex; here, we will skip some of its details. For those
    looking into the underlying math theory, check out [https://bruop.github.io/ibl/#single_scattering_results](https://bruop.github.io/ibl/#single_scattering_results):'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '基于图像的光源的光照贡献计算分为两部分——漫反射辐照度和镜面辐射率。首先，让我们从辐射率部分开始。我们将使用Lambertian漫反射项。Khronos的实现相当复杂；在这里，我们将跳过其中的一些细节。对于想要了解底层数学理论的读者，请参阅[https://bruop.github.io/ibl/#single_scattering_results](https://bruop.github.io/ibl/#single_scattering_results):'
- en: '[PRE86]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Radiance contribution uses the GGX model. Please note that we use roughness
    as an LOD level for the precomputed mip lookup. This trick allows us to save performance
    to avoid excessive texture lookups and integration over them:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辐射率贡献使用GGX模型。请注意，我们将粗糙度用作预计算米普查找的LOD级别。这个技巧允许我们节省性能，避免过多的纹理查找和积分：
- en: '[PRE87]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Retrieve a scale and bias to `F0` from the BRDF lookup table:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从BRDF查找表中检索`F0`的缩放和偏移量：
- en: '[PRE88]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Fetch values from the cube map. No conversion to the linear color space is
    required, since HDR cube maps are already linear:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从立方体贴图中获取值。不需要转换为线性颜色空间，因为HDR立方体贴图已经是线性的：
- en: '[PRE89]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, let’s go through all the helper functions that are necessary to calculate
    different parts of the rendering equation:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐一查看所有必要的辅助函数，这些函数用于计算渲染方程的不同部分：
- en: 'The `diffuseBurley()` function implements the diffuse term, as discussed in
    the paper *Physically-Based Shading at Disney* by Brent Burley: [http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdfhttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf](http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdfhttp://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf):'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `diffuseBurley()` 实现了漫反射项，如布伦特·伯利在论文《迪士尼的基于物理的着色》中所述：[http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf](http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf)：
- en: '[PRE90]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The next function models the Fresnel specular reflectance term of the rendering
    equation, also known as the `F` term:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数模拟了渲染方程中的菲涅耳镜面反射率项，也称为 `F` 项：
- en: '[PRE91]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The function `geometricOcclusion()` calculates the specular geometric attenuation
    `G`, where materials with a higher roughness will reflect back less light to the
    viewer:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `geometricOcclusion()` 计算镜面几何衰减 `G`，其中粗糙度较高的材料将反射较少的光线给观察者：
- en: '[PRE92]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The function `microfacetDistribution()` models the distribution `D` of microfacet
    normals across the area being drawn:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `microfacetDistribution()` 模拟了正在绘制区域上微面法线分布 `D`：
- en: '[PRE93]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This implementation is based on the paper *Average Irregularity Representation
    of a Roughened Surface for Ray Reflection* by T. S. Trowbridge and K. P. Reitz.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此实现基于 T. S. Trowbridge 和 K. P. Reitz 的论文《粗糙化表面的平均不规则性表示法，用于光线反射》：
- en: 'The utility function `perturbNormal()` provides a normal in world space based
    on inputs. It expects a sample from the normal map `normalSample`, sampled at
    `uv` texture coordinates, a vertex normal, `n`, and a vertex position, `v`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实用函数 `perturbNormal()` 根据输入提供世界空间中的法线。它期望从法线图 `normalSample` 中采样，采样在 `uv` 纹理坐标上，一个顶点法线
    `n` 和一个顶点位置 `v`：
- en: '[PRE94]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The function `cotangentFrame()` creates tangent space based on the vertex position
    `p`, the per-vertex normal vector `N`, and `uv` texture coordinates. This is not
    the best way to get the tangent basis, as it suffers from `uv` mapping discontinuities,
    but it’s acceptable to use it in cases where a per-vertex precalculated tangent
    basis is not provided:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 `cotangentFrame()` 基于顶点位置 `p`、每个顶点的法线向量 `N` 和 `uv` 纹理坐标创建切线空间。这不是获取切线基的最佳方式，因为它受到
    `uv` 映射不连续性的影响，但在没有提供每个顶点预先计算的切线基的情况下，使用它是可以接受的：
- en: '[PRE95]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Calculate the handedness of the resulting cotangent frame and adjust the tangent
    vector if necessary:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算结果切线框架的右手性，并在必要时调整切线向量：
- en: '[PRE96]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'There’s a lot of scaffolding, so to speak, that is necessary to implement the
    glTF PBR shading model. Before we can calculate light contribution from a light
    source, we should fill in the `PBRInfo` structure fields. Let’s take a look at
    the code of `calculatePBRInputsMetallicRoughness()` to understand how this is
    done:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有很多所谓的脚手架是必要的，以实现 glTF PBR 着色模型。在我们能够从光源计算光贡献之前，我们应该填写 `PBRInfo` 结构的字段。让我们看看
    `calculatePBRInputsMetallicRoughness()` 函数的代码，以了解这是如何完成的：
- en: 'As it is supposed to be in glTF 2.0, roughness is stored in the `green` channel,
    and metallicity is stored in the `blue` channel. This layout intentionally reserves
    the `red` channel for optional occlusion map data. We set the minimal roughness
    value to `0.04`. It is a widely used constant for many PBR implementations. It
    comes from the assumption that even dielectrics have at least 4% specular reflection:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如 glTF 2.0 中所预期的，粗糙度存储在 `green` 通道中，而金属度存储在 `blue` 通道中。这种布局有意保留了 `red` 通道用于可选的遮挡图数据。我们将最小粗糙度值设置为
    `0.04`。这是许多 PBR 实现中广泛使用的常数，它来源于即使介电体至少有 4% 的镜面反射的假设：
- en: '[PRE97]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Roughness is authored as perceptual roughness; by convention, we convert to
    material roughness by squaring the perceptual roughness. Perceptual roughness
    was introduced by Burley ([https://disneyanimation.com/publications/physically-based-shading-at-disney](https://disneyanimation.com/publications/physically-based-shading-at-disney))
    to make the roughness distribution more linear. The albedo value may be defined
    from a base texture or a flat color. Let’s compute specular reflectance the following
    way:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粗糙度被编写为感知粗糙度；按照惯例，我们通过平方感知粗糙度将其转换为材料粗糙度。感知粗糙度是由 Burley ([https://disneyanimation.com/publications/physically-based-shading-at-disney](https://disneyanimation.com/publications/physically-based-shading-at-disney))
    引入的，以使粗糙度分布更加线性。漫反射值可以从基础纹理或纯色中定义。让我们以下这种方式计算镜面反射率：
- en: '[PRE98]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'For a typical incident reflectance range between 4% to 100%, we should set
    the grazing reflectance to 100% for the typical Fresnel effect. For a very low
    reflectance range on highly diffuse objects, below 4%, incrementally reduce grazing
    reflectance to 0%:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于典型的入射反射率范围在 4% 到 100% 之间，我们应该将掠射反射率设置为 100% 以获得典型的菲涅耳效应。对于高度漫反射物体上的非常低的反射率范围，低于
    4%，逐步将掠射反射率降低到 0%：
- en: '[PRE99]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Finally, we should fill in the `PBRInfo` structure with these values. It is
    used to calculate the contributions of each individual light in the scene:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们应该用这些值填充 `PBRInfo` 结构。它用于计算场景中每个单独光线的贡献：
- en: '[PRE100]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The lighting contribution from a single light source can be calculated in the
    following way, using the precalculated values from `PBRInfo`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下方式计算单个光源的光照贡献，使用从 `PBRInfo` 预先计算出的值：
- en: 'Here, `ld` is the vector from the surface point to the light source, and `h`
    is the half vector between `ld` and `v`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，`ld` 是从表面点到光源的向量，而 `h` 是 `ld` 和 `v` 之间的半向量：
- en: '[PRE101]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Check if the light direction is correct and calculate the shading terms `F`,
    `G`, and `D` for the microfacet specular shading model, using the helper functions
    described earlier in this recipe:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查光的方向是否正确，并使用本食谱中前面描述的辅助函数计算微facet 镜面反射光照模型的阴影项 `F`、`G` 和 `D`：
- en: '[PRE102]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Calculate the analytical lighting contribution. We obtain the final intensity
    as reflectance (BRDF), scaled by the energy of the light (the cosine law):'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算分析光照贡献。我们得到最终强度作为反射率（BRDF），并按光的能量（余弦定律）进行缩放：
- en: '[PRE103]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'That is all and should be sufficient to implement the glTF metallic-roughness
    PBR shading model. The resulting demo application should render the following
    image. Also, try using different glTF 2.0 files:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这些了，应该足够实现 glTF 金属-粗糙度 PBR 光照模型。生成的演示应用程序应该渲染以下图像。也可以尝试使用不同的 glTF 2.0 文件：
- en: '![Figure 6.8: Physically based rendering of the Damaged Helmet glTF 2.0 model](img/file48.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：损坏头盔 glTF 2.0 模型的基于物理的渲染](img/file48.png)'
- en: 'Figure 6.8: Physically based rendering of the Damaged Helmet glTF 2.0 model'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：损坏头盔 glTF 2.0 模型的基于物理的渲染
- en: There’s more...
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The whole area of physically based rendering is vast, and given the book volume
    constraints, it is possible to only scratch its surface. In real life, much more
    complicated PBR implementations can be created, which are normally based on the
    requirements of content production pipelines. For an endless source of inspiration
    to see what can be done, we recommend looking at the Unreal Engine source code,
    which is available for free on GitHub: [https://github.com/EpicGames/UnrealEngine/tree/release/Engine/Shaders/Private](https://github.com/EpicGames/UnrealEngine/tree/release/Engine/Shaders/Private).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物理的渲染的整个领域非常广泛，鉴于本书的篇幅限制，我们只能触及其表面。在现实生活中，可以创建更复杂的 PBR 实现，这些实现通常基于内容制作流程的要求。为了获得无尽的灵感，我们建议查看
    GitHub 上免费提供的 Unreal Engine 源代码：[https://github.com/EpicGames/UnrealEngine/tree/release/Engine/Shaders/Private](https://github.com/EpicGames/UnrealEngine/tree/release/Engine/Shaders/Private)。
- en: In the next recipe, we will explore one more important PBR shading model, the
    glTF 2.0 specular-glossiness model, and implement a demo application for it.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将探索另一个重要的 PBR 光照模型，即 glTF 2.0 镜面-光泽度模型，并为其实现一个演示应用程序。
- en: Implementing the glTF 2.0 specular-glossiness shading model
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 glTF 2.0 镜面-光泽度光照模型
- en: Specular-glossiness is a deprecated and archived extension in the official Khronos
    repository, but we’d like to demonstrate how to use it because it’s still available
    for many existing assets. In the next chapter, we will introduce a new glTF specular
    extension that supersedes this old specular-glossiness shading model. We will
    show how to convert from this old specular glossiness to the new specular extension.
    The specular-glossiness model was initially added to glTF PBR as an extension
    to address an artistic-driven approach. For example, game development often requires
    greater flexibility in controlling the accuracy of specular effects, and the ability
    to adjust glossiness is a common necessity in such scenarios. Later on, the glTF
    PBR shading model received more advanced extensions that contradicted this initial
    one. A new specular extension was introduced to offer similar functionality to
    the standard metallic-roughness model. Consequently, Khronos recommended discontinuing
    the use of this extension, and it archived it. However, we will explore it, considering
    how many existing 3D models were created using this specular-glossiness shading
    model.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面光泽度是官方Khronos存储库中已弃用和存档的扩展，但我们要演示如何使用它，因为它仍然适用于许多现有资产。在下一章中，我们将介绍一个新的glTF镜面扩展，它取代了这个旧的镜面光泽度着色模型。我们将展示如何将旧的镜面光泽度转换为新的镜面扩展。镜面光泽度模型最初被添加到glTF
    PBR中作为一个扩展，以解决艺术驱动的方法。例如，游戏开发通常需要更大的灵活性来控制镜面效果的确切性，而在这种情况下调整光泽度是一个常见的需求。后来，glTF
    PBR着色模型收到了更多高级扩展，与最初的这一扩展相矛盾。引入了一个新的镜面扩展，以提供与标准金属-粗糙度模型类似的功能。因此，Khronos建议停止使用此扩展，并将其存档。然而，我们将探讨它，考虑到许多现有的3D模型都是使用这个镜面光泽度着色模型创建的。
- en: What is specular glossiness?
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是镜面光泽度？
- en: As you may have noticed from the PBR section above, PBR doesn’t enforce how
    the material model should be expressed. The metallic-roughness model uses a simplified
    and intuitive way to describe any surface as non-metal-metal and smooth-rough.
    These parameters are still non-physically correct, but they express a wide variety
    of materials for real-life objects around us. In some cases, it’s not enough to
    express the variations in the appearance of materials, and the specular-glossiness
    model provides this flexibility.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上面的PBR部分注意到的那样，PBR并不强制规定材质模型应该如何表达。金属-粗糙度模型使用一种简化和直观的方式来描述任何表面为非金属-金属和光滑-粗糙。这些参数仍然不符合物理规律，但它们可以表达我们周围现实物体中广泛的各种材料。在某些情况下，仅表达材料外观的变化是不够的，而镜面光泽度模型提供了这种灵活性。
- en: 'The specular-glossiness workflow is a technique for characterizing materials
    based on their specular features. Within this method, materials are described
    using three maps: albedo, specular, and glossiness. The albedo map determines
    the material’s color, the specular map defines its reflectivity or the specular
    color of the material, and the glossiness map defines its glossiness or smoothness.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面光泽度工作流程是一种基于材质镜面特征的表征技术。在这个方法中，材质使用三个图来描述：漫反射图、镜面图和光泽度图。漫反射图决定了材质的颜色，镜面图定义了其反射性或材质的镜面颜色，光泽度图定义了其光泽度或光滑度。
- en: A distinguishing factor between the metallic-roughness and specular-glossiness
    workflows lies in the specular property that specifies material reflectivity in
    RGB channels. Each channel—red, green, and blue—represents reflectivity at different
    angles, providing a wider array of material appearances compared to metallic-roughness.
    Another difference is that this property has one significant flow that cannot
    be used within the glTF PBR model. By its very nature, this value cannot distinguish
    between dielectrics and metals, and that’s the reason why the majority of glTF
    PBR extensions are not compatible with the specular-glossiness model. The Khronos
    group introduced the **KHR materials specular** extension that allows you to add
    a spectral specular color to the metallic-roughness model.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 金属-粗糙度工作流程和镜面光泽度工作流程之间的一个区别在于指定材料在RGB通道中反射性的镜面属性。每个通道——红色、绿色和蓝色——代表不同角度的反射性，与金属-粗糙度相比，提供了更广泛的各种材质外观。另一个区别是，这个属性有一个重要的流程，不能在glTF
    PBR模型中使用。由于其本质，这个值不能区分介电体和金属，这也是为什么大多数glTF PBR扩展与镜面光泽度模型不兼容的原因。Khronos小组引入了**KHR材质镜面**扩展，允许您向金属-粗糙度模型添加光谱镜面颜色。
- en: Getting ready
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The C++ source code for this recipe is in the `Chapter06/05_SpecularGlossiness`
    folder. The GLSL shader code responsible for PBR calculations can be found in
    `Chapter06/05_ SpecularGlossiness/src/PBR.sp`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的 C++ 源代码位于 `Chapter06/05_SpecularGlossiness` 文件夹中。负责 PBR 计算的 GLSL 着色器代码可以在
    `Chapter06/05_ SpecularGlossiness/src/PBR.sp` 中找到。
- en: How to do it...
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is very similar to the previous one. In fact, much of the model
    loading and rendering code remains unchanged, except for retrieving values for
    different material properties. We extend the metallic-roughness data to include
    specular-glossiness parameters, and then we apply these parameters in the shader
    based on the material type.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱与上一个非常相似。实际上，大部分的模型加载和渲染代码保持不变，除了获取不同材质属性值。我们将金属粗糙度数据扩展到包括镜面光泽度参数，然后根据材质类型将这些参数应用于着色器中。
- en: 'We are going to use the 3D model *SpecGlossVsMetalRough* provided by Khronos.
    It provides a side-by-side comparison of the same model, rendered with metallic-roughness
    shading and specular-glossiness shading. You can find the glTF file here: `deps/src/glTF-Sample-Assets/Models/SpecGlossVsMetalRough/glTF/`.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Khronos 提供的 3D 模型 *SpecGlossVsMetalRough*。它提供了使用金属粗糙度着色和镜面光泽度着色渲染的相同模型的并排比较。您可以在以下位置找到
    glTF 文件：`deps/src/glTF-Sample-Assets/Models/SpecGlossVsMetalRough/glTF/`。
- en: 'Let’s get started. Here are the C++ code changes necessary to accommodate specular-glossiness
    parameters:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。以下是必要的 C++ 代码更改，以适应镜面光泽度参数：
- en: We will modify our material data structure by adding two new data members, `vec4
    specularGlossiness` and `uint32_t materialType`. The first one will provide the
    necessary parameters for the specular-glossiness material, and the second one
    will specify the exact material type.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过添加两个新的数据成员来修改我们的材质数据结构，`vec4 specularGlossiness` 和 `uint32_t materialType`。第一个将提供镜面光泽度材质所需的参数，第二个将指定确切的材质类型。
- en: 'Please notice the padding member at the end of the structure. We need it to
    keep the binary representation of this structure aligned with GLSL shader inputs.
    The GLSL `st430` layout and alignment rules are not complex but might not be correctly
    implemented by different hardware vendors, especially on mobile devices. In this
    case, manual padding is just an easy and good enough way to fix compatibility
    between all GPUs. For further reading, we recommend the official Khronos Vulkan
    Guide documentation ([https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/shader_memory_layout.adoc](https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/shader_memory_layout.adoc)):'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意结构体末尾的填充成员。我们需要它来保持此结构体的二进制表示与 GLSL 着色器输入对齐。GLSL `st430` 布局和对齐规则并不复杂，但可能不会由不同的硬件供应商正确实现，尤其是在移动设备上。在这种情况下，手动填充只是简单且足够好的方法来修复所有
    GPU 之间的兼容性。为了进一步阅读，我们推荐官方 Khronos Vulkan 指南文档（[https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/shader_memory_layout.adoc](https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/shader_memory_layout.adoc)）：
- en: '[PRE104]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is how we identify a glTF material type. We implement a helper function,
    `detectMaterialType()`, in `shared/UtilsGLTF.cpp`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们识别 glTF 材质类型的方法。我们在 `shared/UtilsGLTF.cpp` 中实现了一个辅助函数，`detectMaterialType()`：
- en: '[PRE105]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The next difference is how we load extra material properties. Nothing interesting
    here; just load and assign the values using the Assimp API:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个差异是我们如何加载额外的材质属性。这里没有太多有趣的内容；只需使用 Assimp API 加载并分配值即可：
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The rest of the C++ code is mostly identical to the previous recipe, *Implementing
    the glTF 2.0 metallic-roughness shading model*. The highlighted differences related
    to adjusting to the different material properties and providing necessary data.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的 C++ 代码与上一个食谱基本相同，*实现 glTF 2.0 金属粗糙度着色模型*。突出显示的差异与调整不同材质属性和提供必要数据相关。
- en: Let’s now look at the corresponding GLSL shaders.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相应的 GLSL 着色器。
- en: 'The differences are introduced in the code of the fragment shader `05_SpecularGlossinesss/src/main.frag`,
    where we calculate and apply `PBRInfo` parameters:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 差异体现在片段着色器 `05_SpecularGlossinesss/src/main.frag` 的代码中，我们在其中计算并应用 `PBRInfo`
    参数：
- en: 'First, we will identify the specular-glossiness material type:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将识别镜面光泽度材质类型：
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Based on the material type, we will calculate `perceptualRoughness` and `f0`,
    as well as the diffuse and specular color contributions. We will follow the official
    Khronos recommendations ([https://kcoley.github.io/glTF/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness](https://kcoley.github.io/glTF/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness))
    to convert values from specular-glossiness to metallic-roughness:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据材料类型，我们将计算`perceptualRoughness`和`f0`，以及漫反射和镜面反射的颜色贡献。我们将遵循官方Khronos推荐（[https://kcoley.github.io/glTF/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness](https://kcoley.github.io/glTF/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness)）将值从镜面光泽度转换为金属粗糙度：
- en: '[PRE108]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The remaining fragment shader code remains the same. The resulting image produced
    by this example should look like the following screenshot:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的片段着色器代码保持不变。此示例产生的图像应该看起来像以下截图：
- en: '![Figure 6.9: Specular-glossiness versus metallic-roughness materials](img/file49.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：镜面光泽度与金属粗糙度材料对比](img/file49.png)'
- en: 'Figure 6.9: Specular-glossiness versus metallic-roughness materials'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：镜面光泽度与金属粗糙度材料对比
- en: One bottle has a metallic-roughness material and the other uses a specular-glossiness
    one. As you can see, the objects appear identical, and by adjusting the specular
    and glossiness values within a compatible range, you can achieve the exact same
    result with two different shading models.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一个瓶子使用了金属粗糙度材料，另一个则使用了镜面光泽度材料。正如你所见，物体看起来完全相同，通过在兼容范围内调整镜面和光泽度值，你可以使用两种不同的着色模型达到完全相同的结果。
- en: There’s more...
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here’s an article by Don McCurdy explaining the reasons for switching over
    from the specular-glossiness shading model to the metallic-roughness one: [https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough](https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一篇由Don McCurdy撰写的文章，解释了从镜面光泽度着色模型切换到金属粗糙度模型的原因：[https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough](https://www.donmccurdy.com/2022/11/28/converting-gltf-pbr-materials-from-specgloss-to-metalrough)。
