["```cpp\n      int sum {0};\n      for (size_t i {0}; i < array_size; ++i) { sum += array[i]; }\n```", "```cpp\n      int sum {0};\n      while (list_node != nullptr) { \n          sum += list_node->value; list_node = list_node->next; \n      }\n```", "```cpp\nint sum {0};\nfor (int i : array_or_vector_or_map_or_list) { sum += i; }\n```", "```cpp\n{ \n    auto && __range = array_or_vector_or_map_or_list ; \n    auto __begin = std::begin(__range);\n    auto __end   = std::end(__range);\n    for ( ; __begin != __end; ++__begin) { \n        int i = *__begin; \n        sum += i;\n    } \n}\n```", "```cpp\n      #include <iostream>\n```", "```cpp\n      class num_iterator {\n```", "```cpp\n          int i;\n      public:\n\n          explicit num_iterator(int position = 0) : i{position} {}\n```", "```cpp\n          int operator*() const { return i; }\n```", "```cpp\n          num_iterator& operator++() {\n              ++i;\n              return *this;\n          }\n```", "```cpp\n          bool operator!=(const num_iterator &other) const {\n              return i != other.i;\n          }\n      };\n```", "```cpp\n      class num_range {\n```", "```cpp\n          int a;\n          int b;\n\n      public:\n          num_range(int from, int to)\n              : a{from}, b{to}\n          {}\n```", "```cpp\n          num_iterator begin() const { return num_iterator{a}; }\n          num_iterator end()   const { return num_iterator{b}; }\n      };\n```", "```cpp\n      int main()\n      {\n          for (int i : num_range{100, 110}) {\n              std::cout << i << \", \";\n          }\n          std::cout << 'n';\n      }\n```", "```cpp\n      100, 101, 102, 103, 104, 105, 106, 107, 108, 109,\n```", "```cpp\nfor (auto x : range) { code_block; }\n```", "```cpp\n{ \n    auto __begin = std::begin(range);\n    auto __end   = std::end(range);\n    for ( ; __begin != __end; ++__begin) { \n        auto x = *__begin; \n        code_block\n    } \n}\n```", "```cpp\n      #include <iostream>\n      #include <algorithm>\n```", "```cpp\n      class num_iterator \n      {\n          int i;\n      public:\n\n          explicit num_iterator(int position = 0) : i{position} {}\n\n          int operator*() const { return i; }\n\n          num_iterator& operator++() {\n              ++i;\n              return *this;\n          }\n\n          bool operator!=(const num_iterator &other) const {\n              return i != other.i;\n          }\n\n          bool operator==(const num_iterator &other) const {\n              return !(*this != other); \n          }\n      };\n\n      class num_range {\n          int a;\n          int b;\n\n      public:\n          num_range(int from, int to)\n              : a{from}, b{to}\n          {}\n\n          num_iterator begin() const { return num_iterator{a}; }\n          num_iterator end()   const { return num_iterator{b}; }\n      };\n```", "```cpp\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          num_range r {100, 110};\n```", "```cpp\n          auto [min_it, max_it] (minmax_element(begin(r), end(r)));\n          cout << *min_it << \" - \" << *max_it << 'n';\n      }\n```", "```cpp\n      namespace std {\n        struct iterator_traits<num_iterator> {\n\n          using iterator_category = std::forward_iterator_tag;\n\n          using value_type = int;\n\n          using difference_type = void;\n\n          using pointer = int*;\n\n          using reference = int&;\n\n        };\n      }\n```", "```cpp\n      100 - 109\n```", "```cpp\n      #include <iostream>\n      #include <string>\n      #include <iterator>\n      #include <sstream>\n      #include <deque>\n```", "```cpp\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          istream_iterator<int> it_cin {cin};\n          istream_iterator<int> end_cin;\n```", "```cpp\n          deque<int> v;\n\n          copy(it_cin, end_cin, back_inserter(v));\n```", "```cpp\n          istringstream sstr {\"123 456 789\"};\n```", "```cpp\n          auto deque_middle (next(begin(v), \n                                  static_cast<int>(v.size()) / 2));\n```", "```cpp\n          copy(istream_iterator<int>{sstr}, {}, inserter(v, deque_middle));\n```", "```cpp\n          initializer_list<int> il2 {-1, -2, -3};\n          copy(begin(il2), end(il2), front_inserter(v));\n```", "```cpp\n          copy(begin(v), end(v), ostream_iterator<int>{cout, \", \"});\n          cout << 'n';\n      }\n```", "```cpp\n      $ echo \"1 2 3 4 5\" | ./main\n      -3, -2, -1, 1, 2, 123, 456, 789, 3, 4, 5,\n```", "```cpp\nsize_t a {0};\nsize_t b {1};\n\nfor (size_t i {0}; i < N; ++i) {\n    const size_t old_b {b};\n    b += a;\n    a  = old_b;\n\n    // do something with b, which is the current fibonacci number\n}\n```", "```cpp\n      #include <iostream>\n```", "```cpp\n      class fibit\n      {\n          size_t i {0};\n          size_t a {0};\n          size_t b {1};\n```", "```cpp\n      public:\n          fibit() = default;\n\n          explicit fibit(size_t i_)\n              : i{i_}\n          {}\n```", "```cpp\n          size_t operator*() const { return b; }\n```", "```cpp\n          fibit& operator++() {\n              const size_t old_b {b};\n              b += a;\n              a = old_b;\n              ++i;\n              return *this;\n          }\n```", "```cpp\n          bool operator!=(const fibit &o) const { return i != o.i; }\n      };\n```", "```cpp\n      class fib_range\n      {\n          size_t end_n;\n\n      public:\n          fib_range(size_t end_n_)\n              : end_n{end_n_}\n          {}\n```", "```cpp\n          fibit begin() const { return fibit{}; }\n          fibit end()   const { return fibit{end_n}; }\n      };\n```", "```cpp\n      int main()\n      {\n          for (size_t i : fib_range(10)) {\n              std::cout << i << \", \";\n          }\n          std::cout << 'n';\n      }\n```", "```cpp\n      1, 1, 2, 3, 5, 8, 13, 21, 34, 55,\n```", "```cpp\n      #include <iostream>\n      #include <list>\n      #include <iterator>\n```", "```cpp\n      using namespace std;\n```", "```cpp\n      int main()\n      {\n          list<int> l {1, 2, 3, 4, 5};\n```", "```cpp\n          copy(l.rbegin(), l.rend(), ostream_iterator<int>{cout, \", \"});\n          cout << 'n';\n```", "```cpp\n          copy(make_reverse_iterator(end(l)),\n               make_reverse_iterator(begin(l)),\n               ostream_iterator<int>{cout, \", \"});\n          cout << 'n';\n      }\n```", "```cpp\n      5, 4, 3, 2, 1, \n      5, 4, 3, 2, 1,\n```", "```cpp\nfor (const char *c_ponter = some_c_string; *c_pointer != ''; ++c_pointer) {\n    const char c = *c_pointer;\n    // do something with c\n}\n```", "```cpp\nfor (char c : std::string(some_c_string)) { /* do something with c */ }\n```", "```cpp\n      #include <iostream>\n```", "```cpp\n      class cstring_iterator_sentinel {};\n```", "```cpp\n      class cstring_iterator {\n          const char *s {nullptr};\n```", "```cpp\n      public:\n          explicit cstring_iterator(const char *str)\n              : s{str}\n          {}\n```", "```cpp\n          char operator*() const { return *s; }\n```", "```cpp\n          cstring_iterator& operator++() {\n              ++s;\n              return *this;\n          }\n```", "```cpp\n          bool operator!=(const cstring_iterator_sentinel) const {\n              return s != nullptr && *s != '';\n          }\n      };\n```", "```cpp\n      class cstring_range {\n          const char *s {nullptr};\n```", "```cpp\n      public:\n          cstring_range(const char *str)\n              : s{str}\n          {}\n```", "```cpp\n          cstring_iterator begin() const { \n              return cstring_iterator{s}; \n          }\n          cstring_iterator_sentinel end() const { \n              return {}; \n          }\n      };\n```", "```cpp\n      int main(int argc, char *argv[])\n      {\n          if (argc < 2) {\n              std::cout << \"Please provide one parameter.n\";\n              return 1;\n          }\n```", "```cpp\n          for (char c : cstring_range(argv[1])) {\n              std::cout << c;\n          }\n          std::cout << 'n';\n      }\n```", "```cpp\n      $ ./main \"abcdef\"\n      abcdef\n```", "```cpp\n      #include <iostream>\n      #include <vector>\n```", "```cpp\n      int main()\n      {\n          std::vector<int> v {1, 2, 3};\n          v.shrink_to_fit();\n\n          const auto it (std::begin(v));\n```", "```cpp\n          std::cout << *it << 'n';\n```", "```cpp\n          v.push_back(123);\n```", "```cpp\n          std::cout << *it << 'n'; // bad bad bad!\n      }\n```", "```cpp\nstd::vector<double> a {1.0, 2.0, 3.0};\nstd::vector<double> b {4.0, 5.0, 6.0};\n\ndouble sum {0};\nfor (size_t i {0}; i < a.size(); ++i) {\n    sum += a[i] * b[i];\n}\n// sum = 32.0\n```", "```cpp\n      #include <iostream>\n      #include <vector>\n      #include <numeric>\n```", "```cpp\n      class zip_iterator {\n```", "```cpp\n          using it_type = std::vector<double>::iterator;\n\n          it_type it1;\n          it_type it2;\n```", "```cpp\n      public:\n          zip_iterator(it_type iterator1, it_type iterator2)\n              : it1{iterator1}, it2{iterator2}\n          {}\n```", "```cpp\n          zip_iterator& operator++() {\n              ++it1;\n              ++it2;\n              return *this;\n          }\n```", "```cpp\n          bool operator!=(const zip_iterator& o) const {\n              return it1 != o.it1 && it2 != o.it2;\n          }\n```", "```cpp\n          bool operator==(const zip_iterator& o) const {\n              return !operator!=(o);\n          }\n```", "```cpp\n          std::pair<double, double> operator*() const {\n              return {*it1, *it2};\n          }\n      };\n```", "```cpp\n      namespace std {\n\n      template <>\n      struct iterator_traits<zip_iterator> {\n         using iterator_category = std::forward_iterator_tag;\n         using value_type = std::pair<double, double>;\n         using difference_type = long int;\n      };\n\n      }\n```", "```cpp\n      class zipper {\n          using vec_type = std::vector<double>;\n          vec_type &vec1;\n          vec_type &vec2;\n```", "```cpp\n      public:\n          zipper(vec_type &va, vec_type &vb)\n              : vec1{va}, vec2{vb}\n          {}\n```", "```cpp\n          zip_iterator begin() const { \n              return {std::begin(vec1), std::begin(vec2)}; \n          }\n          zip_iterator end() const { \n              return {std::end(vec1), std::end(vec2)}; \n          }\n      };\n```", "```cpp\n      int main()\n      {\n          using namespace std;\n          vector<double> a {1.0, 2.0, 3.0};\n          vector<double> b {4.0, 5.0, 6.0};\n```", "```cpp\n          zipper zipped {a, b};\n```", "```cpp\n          const auto add_product ([](double sum, const auto &p) {\n             return sum + p.first * p.second;\n          });\n```", "```cpp\n          const auto dot_product (accumulate(\n                  begin(zipped), end(zipped), 0.0, add_product));\n```", "```cpp\n          cout << dot_product << 'n';\n      }\n```", "```cpp\n      32\n```", "```cpp\n#include <iostream>\n#include <valarray>\n\nint main()\n{\n    std::valarray<double> a {1.0, 2.0, 3.0};\n    std::valarray<double> b {4.0, 5.0, 6.0};\n\n    std::cout << (a * b).sum() << 'n';\n}\n```", "```cpp\n      const int sum = accumulate(view::ints(1)\n                               | view::transform([](int i){return i*i;})\n                               | view::take(10), 0);\n```", "```cpp\n      std::vector<int> v {1,2,3,4,5,6,7,8,9,10};\n\n      auto rng = v | view::remove_if([](int i){return i % 2 == 1;})\n                   | view::transform([](int i){return std::to_string(i);});\n\n      // rng == {\"2\"s,\"4\"s,\"6\"s,\"8\"s,\"10\"s};\n```"]