["```cpp\nint var;\ndouble* pd = new double(4.2);\n```", "```cpp\nregister int num = 14;\n```", "```cpp\nauto number{42};\nfor (int ix = 0; ix < 10000000; ++ix) {\n int res{number + ix};\n  // do something with res\n}\n```", "```cpp\nregister auto number{42};\n// the loop omitted for code brevity\n```", "```cpp\nfor (int ix = 0; ix < 1000000; ++ix) {\n int res{42 + ix};\n  // do something with res\n}\n```", "```cpp\nint a{40}, b{2};\nint c{a + b};\n```", "```cpp\nmov eax, a\nmov ebx, b\nadd eax, ebx\n```", "```cpp\nlong factorial(long n) {\n  if (n <= 1) { return 1; }\n  return n * factorial(n - 1);\n}\n```", "```cpp\nfactorial(5); // calls factorial(4), which calls factorial(3), and so on\nfactorial(6); // calls factorial(5), which calls factorial(4), and so on\n```", "```cpp\nstd::unordered_map<long, long> cache;\n\nlong factorial(long n) {\n  if (n <= 1) return 1;\n if (cache.contains(n)) return cache[n];\n cache[n] = n * factorial(n - 1);\n return cache[n];\n}\n```", "```cpp\nfactorial(4);\n// the next line calls factorial(4), stores the result in cache[5], which then calls factorial(3)\n// and stores the result in cache[4] and so on\nfactorial(5);\nfactorial(6); // calls the factorial(5) which returns already calculated value in cache[5]\n```", "```cpp\nstd::vector<int> vec;\nvec.push_back(1);\n...\nvec.push_back(9999);\n```", "```cpp\nfor (auto it: vec) {\n  std::cout << it;\n}\n// 1\n// 2\n// 3\n// ...\n// 9999\n```", "```cpp\nT* p = new T(); // allocate memory space\np->do_something(); // use the space to do something useful\ndelete p; // deallocate memory space\n```", "```cpp\nvoid print_sorted() {\n  short* arr{new short[420]};\n  for (int ix = 0; ix < 420; ++ix) {\n    std::cin >> arr[ix];\n  }\n  std::sort(arr, arr + 420);\n  for (int ix = 0; ix < 420; ++ix) {\n    std::cout << arr[ix];\n  }\n  delete arr; // very bad!\n}\n```", "```cpp\nvoid print_sorted() {\n short* arr{new short[420]};\n  for (int ix = 0; ix < 420; ++ix) {\n    std::cin >> arr[ix];\n if (arr[ix] < 0) return;\n  }\n  std::sort(arr, arr + 420);\n  // print the sorted array, code omitted for brevity\n delete[] arr;\n}\n```", "```cpp\nvoid print_sorted() {\n short* arr{new short[420]};\n  for(int ix = 0; ix < 420; ++ix) {\n    std::cin >> arr[ix];\n if (arr[ix] < 0) {\n delete[] arr;\n return;\n }\n  }\n  // sort and print the sorted array, code omitted for brevity\n delete[] arr;\n}\n```", "```cpp\nimport <strange_sort.h>;\n\nvoid print_sorted() {\n  short* arr{new short[420]};\n  for (...) { /* code omitted for brevity */ }\n strange_sort::sort(arr, arr + 420);\n  // print the sorted array, code omitted for brevity\n  delete[] arr;\n}  \n```", "```cpp\ntry {\n  strange_sort::sort(arr, arr + 420);\n} catch (ex) { delete[] arr; }\n```", "```cpp\n// a code sample of the language (not-C++) supporting automated garbage collection\nvoid foo(int age) {\n  Person p = new Person(\"John\", 35);\n  if (age <= 0) { return; }\n  if (age > 18) {\n   p.setAge(18);\n  }\n  // do something useful with the \"p\"\n}\n// no need to deallocate memory manually\n```", "```cpp\ntemplate <typename T>\nclass ArrayManager {\npublic:\n  ArrayManager(T* arr) : arr_{arr} {}\n  ~ArrayManager() { delete[] arr_; }\n\n  T& operator[](int ix) { return arr_[ix]; }\n\n  T* raw() { return arr_; }\n};\n```", "```cpp\nvoid print_sorted() {\n ArrayManager<short> arr{new short[420]};\n  for (int ix = 0; ix < 420; ++ix) {\n    std::cin >> arr[ix];\n  }\n  strange_sort::sort(arr.raw(), arr.raw() + 420);\n  for (int ix = 0; ix < 420; ++ix) {\n    std::cout << arr[ix];\n  }\n}\n```", "```cpp\nProduct* apple{new Product};\napple->set_name(\"Red apple\");\napple->set_price(0.42);\napple->set_available(true);\n// use the apple\n// don't forget to release the resource\ndelete apple;\n```", "```cpp\nResourceManager<Product> res{new Product};\nres->set_name(\"Red apple\");\nres->set_price(0.42);\nres->set_available(true);\n// use the res the way we use a Product\n// no need to delete the res, it will automatically delete when gets out of the scope\n```", "```cpp\ntemplate <typename T>\nclass ResourceManager {\npublic:\n  ResourceManager(T* ptr) : ptr_{ptr} {}\n  ~ResourceManager() { delete ptr_; }\n\n T& operator*() { return *ptr_; }\n T* operator->() { return ptr_; }\n};\n```", "```cpp\nvoid print_name(ResourceManager<Product> apple) {\n  std::cout << apple->name();\n}\n\nResourceManager<Product> res{new Product};\nres->set_name(\"Red apple\");\nprint_name(res);\nres->set_price(0.42);\n// ...\n```", "```cpp\nstd::unique_ptr<Product> res{new Product};\nres->set_name(\"Red apple\");\n// res will delete its acquired resource when goes out of scope\n```", "```cpp\nProduct* p = res.release();\n// now we should delete p manually to deallocate memory\n```", "```cpp\nstd::unique_ptr<Product> up{new Product()};\nProduct* p = res.get();\n// now p also points to the object managed by up\n```", "```cpp\n// Don't do this\nvoid print_name(std::unique_ptr<Product> apple) {\n  std::cout << apple->name();\n}\nstd::unique_ptr<Product> res{new Product};\nres->set_name(\"Red apple\");\nprint_name(res); // bad code\nres->set_price(0.42);\n// ...\n```", "```cpp\nvoid print_name(std::shared_ptr<Product> apple) {\n  std::cout << apple->name();\n}\nstd::shared_ptr<Product> res{new Product};\nres->set_name(\"Red apple\");\nprint_name(res);\nres->set_price(0.42);\n// ...\n```", "```cpp\nvoid print_name(std::shared_ptr<Product> apple) {\n  std::cout << apple.use_count() << \" eyes on the \" << apple->name();\n}\n\nstd::shared_ptr<Product> res{new Product};\nres->set_name(\"Red apple\");\nstd::cout << res.use_count() << std::endl;\nprint_name(res);\nstd::cout << res.use_count() << std::endl;\nres->set_price(0.42);\n// ...\n```", "```cpp\n1\n2 eyes on the Red apple\n1\n```", "```cpp\nstd::shared_ptr<Product> ptr1{new Product()};\nProduct* temp = ptr1.get();\nif (true) {\n  std::shared_ptr<Product> ptr2{temp};\n  ptr2->set_name(\"Apple of truth\");\n}\nptr1->set_name(\"Peach\"); // danger!\n```", "```cpp\nstd::shared_ptr<int[]> sh_arr{new int[42]};\nsh_arr[11] = 44;\n```", "```cpp\nstruct Base\n{\n  virtual void test() { std::cout << \"Base::test()\" << std::endl; }\n}; \n\nstruct Derived : Base\n{\n  void test() override { std::cout << \"Derived::test()\" << std::endl; }\n};\n```", "```cpp\nstd::unique_ptr<Base> ptr = std::make_unique_default_init<Derived>();\nptr->test();\n```", "```cpp\nstruct Garbage {\n  char ch;\n  int i;\n};\n\nvoid foo() {\n  Garbage* g1 = new Garbage();\n  if (true) {\n    Garbage* g2 = new Garbage();\n  }\n}\n\nint main() {\n  static Garbage* g3 = new Garbage();\n}\n```", "```cpp\nclass GarbageCollector {\npublic:\n template <typename T>\n static T* allocate() { \n   T* ptr{new T()};\n objects_[ptr] = true;\n   return ptr;\n }\n\n static void deallocate(T* p) {\n   if (objects_[p]) {\n     objects_[p] = false;\n     delete p;\n   }\n } private:\n std::unordered_map<T*, bool> objects_;\n};\n```", "```cpp\nint* ptr = GarbageCollector::allocate<int>();\n*ptr = 42;\nGarbageCollector::deallocate(ptr);\n```", "```cpp\nStudent* ptr = new Student;\nint* ip = new int{42};\n// do something with ptr and ip\ndelete ptr;\ndelete ip;\n```", "```cpp\n[[nodiscard]] constexpr T* allocate(std::size_t num);\n```", "```cpp\nimport <memory>;\n\nint main()\n{\n  std::allocator<int> IntAlloc;\n  int* ptr = IntAlloc.allocate(5);\n  // construct an integer at the second position\n std::allocator_traits<IntAlloc>::construct(IntAlloc, ptr + 1, 42);\n  IntAlloc.deallocate(ptr, 5); // deallocate all\n}\n```", "```cpp\nconstexpr void deallocate(T* p, std::size_t n)\n```"]