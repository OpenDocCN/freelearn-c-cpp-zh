- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Mastering Algorithms with std::vector
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::vector掌握算法
- en: In this chapter, we will explore the interaction of `std::vector` with C++ **Standard
    Template Library** (**STL**) algorithms to unlock the potential of the C++ STL.
    This chapter delineates the process of efficiently sorting, searching, and manipulating
    vectors, leveraging the algorithms provided in the header. Moreover, focusing
    on lambda expressions, custom comparators, and predicates establishes a clear
    path to customizable, concise, and efficient vector operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨`std::vector`与C++ **标准模板库**（**STL**）算法的交互，以释放C++ STL的潜力。本章阐述了高效排序、搜索和操作向量的过程，利用头文件中提供的算法。此外，关注lambda表达式、自定义比较器和谓词，为可定制、简洁和高效的向量操作铺平了道路。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Sorting a vector
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对向量进行排序
- en: Searching elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索元素
- en: Manipulating vectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作向量
- en: Custom comparators and predicates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义比较器和谓词
- en: Understanding container invariants and iterator invalidation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器不变性和迭代器失效
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Sorting a vector
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对向量进行排序
- en: 'It’s a common requirement in software: organizing data. In C++, `std::vector`
    is frequently the container of choice for many, and quite naturally, one would
    want to sort its elements. Enter the `std::sort` algorithm, a versatile tool from
    the `<algorithm>` header that elevates your `std::vector` game to the next level.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，组织数据是一个常见的需求。在C++中，`std::vector`经常是许多人的首选容器，并且很自然地，人们会希望对其元素进行排序。于是，`std::sort`算法应运而生，这是来自`<algorithm>`头文件的一个多功能工具，它将你的`std::vector`游戏提升到了新的水平。
- en: Getting started with std::sort
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用std::sort
- en: '`std::sort` isn’t just for vectors; it can sort any sequential container. However,
    its symbiotic relationship with `std::vector` is particularly noteworthy. At its
    simplest, using `std::sort` to sort a vector is a straightforward task, as shown
    in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort`不仅仅适用于向量；它可以对任何顺序容器进行排序。然而，它与`std::vector`的共生关系特别值得注意。最简单地说，使用`std::sort`对向量进行排序是一个直接的任务，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After execution, `numbers` would store `{1, 2, 3, 4, 5}`. The beauty lies in
    simplicity: pass the start and end iterators of the vector to `std::sort`, and
    it takes care of the rest.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，`numbers`将存储`{1, 2, 3, 4, 5}`。其美在于简单：将向量的起始和结束迭代器传递给`std::sort`，它就会处理其余部分。
- en: The engine under the hood – introsort
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部引擎——introsort
- en: In the vast array of algorithms offered by the C++ STL, one that consistently
    stands out for its efficacy is `std::sort`. When paired with the dynamic nature
    of `std::vector`, it becomes an unstoppable force, propelling your code’s efficiency
    to new heights. But what makes it tick?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++ STL提供的众多算法中，有一个始终因其有效性而突出，那就是`std::sort`。当与`std::vector`的动态特性结合时，它成为一股不可阻挡的力量，将你的代码效率推向新的高度。但是什么让它如此出色呢？
- en: 'To appreciate the genius behind `std::sort`, one must first get acquainted
    with the introsort algorithm. Introsort isn’t just any ordinary sorting algorithm.
    It’s a magnificent hybrid, artfully melding the strengths of three celebrated
    sorting algorithms: quicksort, heapsort, and insertion sort. This combination
    ensures that `std::sort` can adapt and perform optimally in myriad scenarios.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要欣赏`std::sort`背后的天才，首先必须熟悉introsort算法。Introsort不仅仅是一个普通的排序算法。它是一个杰出的混合体，巧妙地融合了三种著名排序算法（快速排序、堆排序和插入排序）的优点。这种组合确保了`std::sort`能够在各种场景中适应并表现出最佳性能。
- en: 'While we could plunge deep into algorithmic intricacies, what truly matters
    for everyday use is this: introsort ensures that `std::sort` remains blazingly
    fast. The underlying mechanics have been refined and optimized to suit various
    data patterns.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以深入探讨算法的复杂性，但对于日常使用来说，真正重要的是这一点：introsort确保`std::sort`保持惊人的速度。其底层机制已经经过精炼和优化，以适应各种数据模式。
- en: Efficiency unparalleled – O(n log n)
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无与伦比的效率——O(n log n)
- en: For those not deep into computer science jargon, time complexities might sound
    like arcane chants. However, there’s a simple beauty to them. When we say that
    `std::sort` has an average time complexity of *O(n log n)*, we express its commitment
    to speed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不深入计算机科学术语的人来说，时间复杂度可能听起来像是古老的咒语。然而，它们中蕴含着一种简单的美。当我们说`std::sort`的平均时间复杂度为*O(n
    log n)*时，我们表达了对速度的承诺。
- en: Think of *O(n log n)* as a promise. Even as your vector grows, scaling to vast
    sizes, `std::sort` ensures that the number of operations doesn’t explode uncontrollably.
    It strikes a balance, ensuring that the time taken to sort grows at a manageable
    rate, making it a reliable choice for even the largest vectors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将*O(n log n)*视为一个承诺。即使你的向量增长，扩展到巨大的大小，`std::sort`也能确保操作的数量不会无控制地爆炸。它找到了一个平衡点，确保排序所需的时间以可管理的速率增长，使其成为即使是最大向量也能信赖的选择。
- en: Sorting in descending order
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降序排序
- en: 'While ascending order is the default behavior, there are scenarios where you’d
    want the largest values at the front. C++ has got you covered. With the aid of
    `std::greater<>()`, a predefined comparator from the `<functional>` header, you
    can sort your vector in descending order as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然升序是默认行为，但在某些情况下，你可能希望最大的值在前面。C++为你提供了支持。借助`std::greater<>()`，一个来自`<functional>`头文件预定义的比较器，你可以按以下代码所示对向量进行降序排序：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After execution, if `numbers` originally had `{1, 2, 3, 4, 5}`, it would now
    store `{5, 4, 3,` `2, 1}`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，如果`numbers`最初有`{1, 2, 3, 4, 5}`，现在将存储`{5, 4, 3, 2, 1}`。
- en: Sorting custom data types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对自定义数据类型进行排序
- en: Vectors aren’t limited to primitive types. You might have vectors of custom
    objects. To demonstrate this, we will use an example. We will use a `Person` class
    and a vector of `Person` objects. The goal is to sort the vector first by name
    (using an inline comparator) and then by age (using a lambda function object as
    a comparator).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 向量不仅限于原始类型。你可能有自定义对象的向量。为了演示这一点，我们将使用一个例子。我们将使用`Person`类和一个`Person`对象的向量。目标是首先按名称（使用内联比较器）然后按年龄（使用lambda函数对象作为比较器）对向量进行排序。
- en: 'Let’s look at an example of a custom sort:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个自定义排序的例子：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the example output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是示例输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, we do the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下操作：
- en: We define a `Person` class with a name and age as attributes.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个具有姓名和年龄属性的`Person`类。
- en: We also provide an inline comparator function (`compareByName`) to sort `Person`
    objects by name.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还提供了一个内联比较函数（`compareByName`）来按姓名对`Person`对象进行排序。
- en: We then sort the `people` vector using the inline comparator.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后使用内联比较器对`people`向量进行排序。
- en: Afterward, we sort the `people` vector by age using a lambda function as a comparator.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们使用lambda函数作为比较器对`people`向量按年龄进行排序。
- en: The results are displayed to verify that the sorting operations work as expected.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果被显示出来以验证排序操作是否按预期工作。
- en: Pitfalls and precautions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱和注意事项
- en: There’s a temptation to view `std::sort` as a magic wand, but remember that
    while it is powerful, it is not omniscient. The algorithm assumes that the range
    `(``begin, end)` is valid; passing invalid iterators can lead to undefined behavior.
    Additionally, the comparator provided must establish a strict weak ordering; failing
    to do so might produce unexpected results.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种诱惑将`std::sort`看作是一根魔杖，但请记住，虽然它很强大，但它并非无所不知。算法假设范围`(``begin, end)`是有效的；传递无效迭代器可能导致未定义的行为。此外，提供的比较器必须建立严格弱排序；否则可能会产生意外的结果。
- en: Strict weak ordering
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格弱排序
- en: 'The term `std::sort`. This concept pertains to the comparison function that
    is used to order the elements in a collection. Let’s break it down for clarity:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`std::sort`。这个概念涉及到用于对集合中的元素进行排序的比较函数。让我们为了清晰起见将其分解：
- en: '**Strictness**: This means that for any two distinct elements *a* and *b*,
    the comparison function comp must not report both *comp(a, b)* and *comp(b, a)*
    as true. In simpler terms, if *a* is considered less than *b*, then *b* cannot
    be less than *a*. This ensures a consistent ordering.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格性**：这意味着对于任何两个不同的元素*a*和*b*，比较函数comp必须不能同时报告*comp(a, b)*和*comp(b, a)*为真。用更简单的话说，如果*a*被认为是小于*b*的，那么*b*不能小于*a*。这确保了排序的一致性。'
- en: '**Weakness**: The term *weak* in this context refers to the allowance of equivalence
    classes. In a strict ordering (such as a strict total ordering), two different
    elements cannot be equivalent. However, in a strict weak ordering, different elements
    can be considered equivalent. For example, if you have a list of people sorted
    by age, two people of the same age are in the same equivalence class even if they
    are different individuals.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱点**：在此上下文中，“弱”一词指的是允许等价类。在严格排序（如严格全序）中，两个不同的元素不能是等效的。然而，在严格弱排序中，不同的元素可以被认为是等效的。例如，如果你有一个按年龄排序的人的列表，年龄相同的人即使在他们是不同个体的情况下也属于同一个等价类。'
- en: '**Transitivity of comparison**: If *comp(a, b)* is true and *comp(b, c)* is
    true, then *comp(a, c)* must also be true. This ensures that the ordering is consistent
    across the entire set of elements.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较的传递性**：如果 *comp(a, b)* 为真且 *comp(b, c)* 为真，那么 *comp(a, c)* 也必须为真。这确保了整个元素集合的排序一致性。'
- en: '**Transitivity of equivalence**: If *a* is not less than *b* and *b* is not
    less than *a* (meaning they are equivalent in terms of the sorting criteria),
    and similarly *b* and *c* are equivalent, then *a* and *c* must also be considered
    equivalent.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等价关系的传递性**：如果 *a* 不小于 *b* 且 *b* 不小于 *a*（意味着它们在排序标准上等效），并且类似地 *b* 和 *c* 也等效，那么
    *a* 和 *c* 也必须被认为是等效的。'
- en: A comparator providing a strict weak ordering allows `std::sort` to correctly
    and efficiently sort elements. It ensures that the order is consistent, allows
    for the grouping of equivalent elements, and respects the logical transitivity
    both in terms of comparison and equivalence. Failing to adhere to these rules
    can lead to unpredictable behavior in sorting algorithms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提供严格弱排序的比较器允许 `std::sort` 正确且高效地排序元素。它确保了排序的一致性，允许对等效元素进行分组，并在比较和等效方面尊重逻辑传递性。未能遵守这些规则可能导致排序算法中出现不可预测的行为。
- en: 'Let’s illustrate the concepts mentioned in the text with a code example. We
    will show what happens when an invalid range is provided to `std::sort`, and what
    can occur if the comparator doesn’t establish a strict weak ordering:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来说明文本中提到的概念。我们将展示当向 `std::sort` 提供无效范围时会发生什么，以及如果比较器没有建立严格的弱排序会发生什么：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做以下操作：
- en: We see how mistakenly providing an end iterator beyond the vector’s end can
    lead to undefined behavior. (This portion is commented out for safety reasons.)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到错误地提供一个超出向量末尾的结束迭代器如何导致未定义的行为。（出于安全原因，这部分已注释掉。）
- en: We provide a comparator that does not maintain a strict weak ordering because
    it returns true even when two numbers are equal. Using such a comparator with
    `std::sort` can lead to unexpected results or other undefined behaviors.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们提供了一个不维护严格弱排序的比较器，因为它在两个数字相等时也返回 true。使用这样的比较器与 `std::sort` 结合可能会导致意外结果或其他未定义的行为。
- en: With `std::sort` at your disposal, you have an efficient and adaptable tool.
    You can handle a broad spectrum of sorting tasks with confidence and finesse by
    understanding its default behaviors, harnessing the power of standard comparators,
    and crafting custom comparators for unique scenarios. As we proceed in this chapter,
    remember this foundational skill as we delve deeper into the vast landscape of
    STL algorithms and `std::vector`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `std::sort`，你拥有一个高效且适应性强的工具。通过理解其默认行为，利用标准比较器的力量，并为独特场景定制比较器，你可以自信且巧妙地处理各种排序任务。随着我们继续本章的学习，请记住这项基础技能，因为我们将进一步深入到
    STL 算法和 `std::vector` 的广阔领域。
- en: In this section, we optimized element sorting in `std::vector` with the `std::sort`
    algorithm, unpacking its introsort mechanism—a hybrid of quicksort, heapsort,
    and insertion sort—to ensure top performance, usually with *O(n log n)* complexity.
    This understanding is pivotal for data processing efficiency in algorithmic design
    and high-performance application development.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `std::sort` 算法优化了 `std::vector` 中的元素排序，解包其 introsort 机制——一个快速排序、堆排序和插入排序的混合体，以确保最佳性能，通常具有
    *O(n log n)* 的复杂度。这种理解对于算法设计中的数据处理效率和高性能应用开发至关重要。
- en: Next, we’ll shift our focus from sorting to searching, contrasting the linear
    and binary search techniques to effectively find elements in `std::vector`, dissecting
    their efficiency in various use cases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重点从排序转移到搜索，对比线性搜索和二分搜索技术，以有效地在 `std::vector` 中找到元素，分析它们在不同用例中的效率。
- en: Searching elements
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索元素
- en: Finding elements in a collection is as crucial as storing them. In the C++ STL,
    there’s a buffet of algorithms tailored for searching. Whether `std::vector` is
    sorted or unsorted, the STL provides an array of functions that’ll lead you straight
    to your target using the classic linear or faster binary search. With `std::vector`,
    these techniques become indispensable in many scenarios.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中查找元素与存储它们一样重要。在 C++ STL 中，有一系列针对搜索的算法。无论 `std::vector` 是否排序，STL 都提供了一系列函数，可以直接使用经典的线性搜索或更快的二分搜索找到目标。使用
    `std::vector`，这些技术在许多场景中变得不可或缺。
- en: Linear search with std::find
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::find` 进行线性搜索
- en: The most basic and intuitive searching algorithm is the **linear search**. If
    you’re not sure about the order of your vector or it is simply unsorted, this
    method comes to the rescue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本且直观的搜索算法是**线性搜索**。如果你不确定向量的顺序，或者它只是未排序的，这种方法就会派上用场。
- en: 'Consider `std::vector<int> numbers = {21, 12, 46, 2};`. To find the position
    of the element `46`, we will use the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `std::vector<int> numbers = {21, 12, 46, 2};`。要找到元素 `46` 的位置，我们将使用以下代码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the element exists, it will point to its location; otherwise, it’ll point
    to `numbers.end()`. It’s a direct, no-frills approach, checking each element from
    the beginning to the end. However, the time it takes grows linearly with the size
    of the vector, making it less ideal for massive datasets.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素存在，它将指向其位置；否则，它将指向 `numbers.end()`。这是一个直接、无装饰的方法，从开始到结束检查每个元素。然而，它所需的时间会随着向量的大小线性增长，这使得它对于大规模数据集来说不太理想。
- en: Binary search techniques
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分搜索技术
- en: Few algorithmic searching strategies stand out for their sheer elegance and
    efficiency, quite like the `std::vector`, binary search offers a masterclass in
    how strategic thinking can transform how we tackle problems. Let’s delve deeper
    into the world of halves to unearth the brilliance behind binary search.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有算法搜索策略因其纯粹的美感和效率而脱颖而出，就像 `std::vector`，二分搜索为我们提供了一堂关于战略思维如何改变我们解决问题的方法的示范课。让我们深入探讨一半的世界，揭示二分搜索背后的
    brilliance。
- en: 'Binary search operates on a beautifully simple principle: divide and conquer.
    Instead of tediously scanning each element one by one, binary search makes a beeline
    to the center of the dataset. A quick assessment determines whether the desired
    element lies in the dataset’s first or second half. This insight allows it to
    dismiss half of the remaining elements, continually narrowing down the search
    field until the desired element emerges.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索基于一个简单而美丽的原则：分而治之。而不是逐个扫描每个元素，二分搜索直接跳到数据集的中心。快速评估确定所需元素位于数据集的前半部分还是后半部分。这种洞察力使它能够排除剩余元素的一半，不断缩小搜索范围，直到找到所需的元素。
- en: 'For the binary search to work its magic, there’s one non-negotiable requirement:
    the dataset, or `std::vector`, must be sorted in our context. This precondition
    is vital because the efficiency of binary search hinges on predictability. Each
    decision to halve the search space is made with the confidence that elements are
    organized in a specific order. This structured arrangement allows the algorithm
    to confidently exclude large data portions, making the search incredibly efficient.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了二分搜索能够发挥作用，有一个不可协商的要求：数据集，或 `std::vector`，必须在我们这个上下文中排序。这个先决条件至关重要，因为二分搜索的效率依赖于可预测性。每次将搜索空间减半的决定都是基于对元素按特定顺序组织的信心。这种结构化的安排允许算法有信心排除大量数据，从而使搜索非常高效。
- en: Using std::lower_bound and std::upper_bound
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `std::lower_bound` 和 `std::upper_bound`
- en: 'But what if you want more than just existence? Sometimes, the questions we
    seek to answer are more nuanced: If this element isn’t in the vector, where would
    it fit best based on the current ordering? Or, given multiple occurrences of an
    element, where do they commence or conclude? The C++ STL offers two powerful tools
    to address these queries: `std::lower_bound` and `std::upper_bound`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要的不仅仅是存在呢？有时，我们试图回答的问题更为复杂：如果这个元素不在向量中，根据当前的排序，它最适合放在哪里？或者，给定一个元素的多个出现，它们是从哪里开始或结束的？C++
    STL 提供了两个强大的工具来解决这些查询：`std::lower_bound` 和 `std::upper_bound`。
- en: The `std::lower_bound` function plays a pivotal role in the realm of sorted
    vectors. When presented with a specific element, this function ventures to find
    the position where this element either first appears in the vector or where it
    would be rightly placed, ensuring the vector’s order remains intact. It effectively
    returns an iterator pointing to the first element that is not less than (i.e.,
    greater than or equal to) the specified value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::lower_bound`函数在排序向量领域扮演着关键角色。当遇到一个特定元素时，这个函数会尝试找到这个元素在向量中首次出现的位置，或者它应该正确放置的位置，以确保向量的顺序保持不变。它有效地返回一个迭代器，指向第一个不小于（即大于或等于）指定值的元素。'
- en: For instance, if our vector contains `{1, 3, 3, 5, 7}` and we’re seeking `3`
    using `std::lower_bound`, the function would point to the first occurrence of
    `3`. However, if we were searching for `4`, the function would indicate the position
    right before `5`, highlighting where `4` would fit best while preserving the vector’s
    sorted nature.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的向量包含`{1, 3, 3, 5, 7}`，并且我们使用`std::lower_bound`来寻找`3`，函数将指向`3`的第一个出现位置。然而，如果我们正在寻找`4`，函数将指示`5`之前的位置，突出`4`最适合的位置，同时保持向量的排序特性。
- en: On the other hand, `std::upper_bound` provides insight into the ending of a
    sequence. When given an element, it identifies the first position where an element
    greater than the specified value resides. Effectively, if you have multiple occurrences
    of an element, `std::upper_bound` will point just past the last occurrence.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::upper_bound`提供了对序列结束的洞察。当给定一个元素时，它确定第一个大于指定值的元素的位置。实际上，如果你有多个元素的出现，`std::upper_bound`将指向最后一个出现之后的元素。
- en: Referring back to our vector `{1, 3, 3, 5, 7}`, if we employ `std::upper_bound`
    in search of `3`, it would direct us to the position right before `5`, showcasing
    the end of the `3` sequence.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的向量`{1, 3, 3, 5, 7}`，如果我们使用`std::upper_bound`来搜索`3`，它将引导我们到`5`之前的位置，展示了`3`序列的结束。
- en: Let’s look at a complete example of using `std::upper_bound` and `std::lower_bound`
    with `std::vector` of integers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`std::upper_bound`和`std::lower_bound`与整数`std::vector`的完整示例。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you run the preceding code, the following output will be generated for
    the specified values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码时，对于指定的值将生成以下输出：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The explanation of the code example is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码示例的解释：
- en: For `std::lower_bound` with `3`, it returns an iterator pointing to the first
    occurrence of `3`, which is at index `1`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`std::lower_bound`和`3`，它返回一个迭代器，指向`3`的第一个出现位置，即索引`1`。
- en: For `std::lower_bound` with `4`, it indicates where `4` would fit best, right
    before `5` (i.e., at index `3`).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`std::lower_bound`和`4`，它指示了`4`最适合的位置，即在`5`之前（即索引`3`）。
- en: For `std::upper_bound` with `3`, it points just past the last occurrence of
    `3`, right before `5` (i.e., at index `3`).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`std::upper_bound`和`3`，它指向`3`的最后一个出现之后的元素，即在`5`之前（即索引`3`）。
- en: While confirming the existence of an element is undoubtedly essential, the actual
    depth of algorithmic exploration with `std::vector` comes when we pose more detailed
    questions. With the combined capabilities of `std::lower_bound` and `std::upper_bound`,
    we begin to appreciate the data analysis capabilities supported by the STL.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然确认元素的存在无疑是必要的，但当我们提出更详细的问题时，使用`std::vector`的算法探索的深度才真正显现。结合`std::lower_bound`和`std::upper_bound`的能力，我们开始欣赏STL支持的数据分析能力。
- en: Binary search versus linear search – efficiency and versatility
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分查找与线性查找——效率和多功能性
- en: Within the realm of algorithmic searching techniques, both binary and linear
    search emerge as fundamental strategies. Each has unique strengths and ideal use
    cases, mainly applied to the versatile `std::vector`. Let’s delve deeper into
    understanding the nuances of these two approaches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法搜索技术的领域内，二分和线性搜索都成为基本策略。每个都有其独特的优势和理想的应用场景，主要应用于多功能的`std::vector`。让我们更深入地了解这两种方法的细微差别。
- en: Binary search – the speedster with a condition
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二分查找——条件下的速度高手
- en: 'Binary search is a highly efficient method renowned for its logarithmic time
    complexity. This efficiency translates into significant speed, especially when
    dealing with large vectors. However, this swiftness has a caveat: `std::vector`
    must be sorted. The essence of binary search is its ability to eliminate half
    of the remaining elements with each step, making educated guesses based on the
    order of the elements.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 二分查找是一种高度有效的方法，以其对数时间复杂度而闻名。这种效率转化为显著的速度，尤其是在处理大型向量时。然而，这种迅速也有一个前提：`std::vector`必须是有序的。二分查找的本质在于其每次都能消除一半剩余元素的能力，基于元素的顺序进行有根据的猜测。
- en: But what happens if this order isn’t maintained? Simply put, the results become
    unpredictable. If a vector isn’t sorted, binary search might fail to locate an
    element even if it exists or return inconsistent results. Thus, it is imperative
    to ensure a sorted landscape before venturing into a binary search on `std::vector`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这种顺序没有得到保持会发生什么？简单地说，结果变得不可预测。如果一个向量没有排序，二分查找可能无法找到即使存在的元素，或者返回不一致的结果。因此，在尝试在`std::vector`上进行二分查找之前，确保有序性是至关重要的。
- en: Linear search – the reliable workhorse
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性查找 – 可靠的工作马
- en: Linear search, on the other hand, is characterized by its straightforward approach.
    It methodically checks each element in the vector until it finds the desired item
    or concludes it isn’t present. This simplicity is its strength; the method doesn’t
    require any prior conditions on the arrangement of elements, making it versatile
    and applicable to sorted and unsorted vectors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，线性查找以其直接的方法为特征。它系统地检查向量中的每个元素，直到找到所需的项或得出它不存在的结论。这种简单性是其优势；该方法不需要对元素的排列有任何先前的条件，使其变得灵活且适用于有序和无序向量。
- en: 'However, this step-by-step examination comes at a cost: linear search has a
    linear time complexity. While it might be efficient for smaller vectors, its performance
    can be noticeably slower as the size of the vector increases, especially when
    compared to the swift binary search in sorted vectors.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种逐步检查是有代价的：线性查找具有线性时间复杂度。虽然它可能对较小的向量来说效率很高，但随着向量大小的增加，其性能可能会明显变慢，尤其是在与排序向量的快速二分查找相比时。
- en: Searching is fundamental, and mastering linear and binary techniques amplifies
    your proficiency with `std::vector`. Whether you’re hunting down a single element,
    gauging the position of an item in a sorted sequence, or finding the range of
    an element’s occurrences, the STL grants you robust and efficient tools to accomplish
    these tasks. As you venture further into `std::vector` and the STL, understanding
    these searching methods is a bedrock, ensuring that no element remains elusive
    in your C++ journey.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索是基础，掌握线性和二分技术可以增强你对`std::vector`的熟练程度。无论你是寻找单个元素，测量有序序列中项的位置，还是找到元素出现的范围，STL都为你提供了强大而高效的工具来完成这些任务。随着你进一步探索`std::vector`和STL，理解这些搜索方法是基石，确保在C++之旅中没有任何元素被遗漏。
- en: This section honed our skills in element discovery within `std::vector`, starting
    with `std::find` for linear searches and advancing to binary searches with `std::lower_bound`
    and `std::upper_bound` for sorted data. Unlike linear search, we recognized binary
    search’s speed advantage, though it requires a pre-sorted vector. Choosing the
    correct search technique is crucial for performance optimization in various applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提高了我们在`std::vector`中查找元素的能力，从线性搜索的`std::find`开始，到使用`std::lower_bound`和`std::upper_bound`进行排序数据的二分搜索。与线性搜索不同，我们认识到二分搜索的速度优势，尽管它需要一个预先排序的向量。选择正确的搜索技术对于各种应用中的性能优化至关重要。
- en: We’ll next explore altering vector contents with methods such as `std::copy`,
    focusing on practical manipulation techniques and the key considerations for preserving
    data structure integrity and performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨使用如`std::copy`等方法来更改向量内容，重点关注实际操作技巧以及保持数据结构完整性和性能的关键考虑因素。
- en: Manipulating vectors
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作向量
- en: Vectors in C++ are dynamic arrays that not only store data but offer a suite
    of operations to manipulate that data, especially when paired with the algorithms
    provided by the STL. These algorithms allow developers to optimize data movement
    and transformation tasks with elegance. Let’s delve into the art of manipulating
    `std::vector` with some powerful algorithms.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的向量是动态数组，不仅存储数据，还提供了一系列操作来处理这些数据，尤其是在与STL提供的算法结合使用时。这些算法允许开发者以优雅的方式优化数据移动和转换任务。让我们深入探讨使用一些强大的算法来操作`std::vector`的艺术。
- en: Transforming with std::copy
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::copy 进行转换
- en: 'Imagine you’ve got one vector and wish to copy its elements to another. Simple
    looping might come to mind, but there’s a more efficient and expressive way: `std::copy`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个向量并希望将其元素复制到另一个向量。简单的循环可能出现在你的脑海中，但有一个更高效和更表达性的方法：`std::copy`。
- en: 'Consider two vectors as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码中的两个向量：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Copying the elements is as straightforward as shown in the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 复制元素就像以下所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`destination` holds `{1, 2, 3, 4, 5}`. It’s worth noting that the `destination`
    vector should have enough space to accommodate the copied elements.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination` 包含 `{1, 2, 3, 4, 5}`。值得注意的是，`destination` 向量应该有足够的空间来容纳复制的元素。'
- en: Reversing elements with std::reverse
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::reverse 反转元素
- en: 'Often, you might need to reverse the elements of a vector. Instead of manually
    swapping elements, `std::reverse` comes to the rescue, as shown in the following
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，你可能需要反转向量的元素。而不是手动交换元素，`std::reverse` 就会派上用场，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The vector numbers now read `{5, 4, 3,` `2, 1}`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 向量数字现在读作 `{5, 4, 3,` `2, 1}`.
- en: Rotating vectors with std::rotate
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::rotate 旋转向量
- en: 'Another handy algorithm for manipulating vectors is `std::rotate`, which allows
    you to rotate elements. Let’s say you have a vector as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于操作向量的实用算法是 `std::rotate`，它允许你旋转元素。假设你有一个如下向量的例子：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to rotate it so that `3` becomes the first element, you will do
    the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将其旋转，使 `3` 成为第一个元素，你将执行以下操作：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Your vector `values` now hold `{3, 4, 5, 1, 2}`. This shifts the elements, wrapping
    them around the vector.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的向量 `values` 现在包含 `{3, 4, 5, 1, 2}`。这会将元素移动，并围绕向量回绕。
- en: Filling a vector with std::fill
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 std::fill 填充向量
- en: 'There might be scenarios where you wish to reset or initialize all vector elements
    to a specific value. `std::fill` is the perfect tool for this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些场景，你希望将所有向量元素重置或初始化为特定值。`std::fill` 是这个任务的完美工具：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every element in the `data` is now `42`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `data` 中的每个元素都是 `42`。
- en: Putting manipulation to use
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将操作应用于实践
- en: 'A music streaming service wants to allow users to manage their playlists in
    the following ways:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个音乐流媒体服务希望允许用户以下方式管理他们的播放列表：
- en: 'At the end of the year, they have a unique feature: users can take their top
    10 songs and move them to the beginning of the playlist as a *Year* *in Review*.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年末时，它们有一个独特的功能：用户可以将他们最喜欢的10首歌曲移动到播放列表的开头，作为 *年度回顾*。
- en: Users can reverse their playlist to rediscover old songs they haven’t listened
    to in a while for a specific promotion.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以反转他们的播放列表，以重新发现他们很久没听过的旧歌，以特定的促销活动。
- en: Occasionally, when a user buys a new album, they like to insert its tracks in
    the middle of their current playlist and rotate the old favorites to the end to
    have a mix of new and old songs.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，当用户购买新专辑时，他们喜欢将其曲目插入到当前播放列表的中间，并将旧喜爱的歌曲旋转到末尾，以混合新旧歌曲。
- en: For a fresh start in spring, users can fill their playlist with calm and refreshing
    spring-themed music.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于春天的全新开始，用户可以用平静和清新的春季主题音乐填充他们的播放列表。
- en: 'The following code shows how users can manage their playlists:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了用户如何管理他们的播放列表：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the example output (truncated):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出（已截断）：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, we do the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做以下操作：
- en: The `std::rotate` function brings the user’s top 10 songs to the beginning.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::rotate` 函数将用户的10首最受欢迎的歌曲带到列表开头。'
- en: The `std::reverse` function helps rediscover old songs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::reverse` 函数有助于重新发现旧歌。'
- en: The user’s new album purchase demonstrates a more practical use of `std::rotate.`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的新专辑购买展示了 `std::rotate` 的更实际用途。
- en: The `std::fill` function fills the playlist with spring-themed songs for a fresh
    start.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill` 函数用春季主题的歌曲填充播放列表，以迎接新的开始。'
- en: Considerations in manipulation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作注意事项
- en: 'While these functions provide a robust and efficient way to transform vectors,
    there are a few things to keep in mind:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些函数提供了转换向量的强大和高效方式，但还有一些事情需要注意：
- en: Ensure that the destination vectors, especially with functions such as `std::copy`
    have adequate space to accommodate the data. Using `std::back_inserter` can be
    helpful if you’re unsure about the size.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保目标向量，特别是像 `std::copy` 这样的函数有足够的空间来容纳数据。如果你不确定大小，使用 `std::back_inserter` 可能会有所帮助。
- en: Algorithms such as `std::rotate` are highly efficient. They minimize the number
    of element moves. However, the order in which elements are shifted might not be
    apparent initially. Practicing with different scenarios will instill a more precise
    understanding.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`std::rotate`这样的算法非常高效。它们最小化了元素移动的数量。然而，元素移动的顺序可能一开始并不明显。通过练习不同的场景，将培养出更精确的理解。
- en: Functions such as `std::fill` and `std::reverse` work in place, transforming
    the original vector. Always ensure you won’t need the original order or values
    before applying these functions or backing up.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数如`std::fill`和`std::reverse`在原地工作，转换原始向量。在应用这些函数或备份之前，始终确保你不需要原始顺序或值。
- en: Vectors paired with STL algorithms empower developers to create efficient, expressive,
    and concise manipulations. Whether you’re copying, rotating, reversing, or filling,
    there’s an algorithm tailored to the task. As you continue your journey with `std::vector`,
    embracing these tools ensures you handle data with finesse and speed, crafting
    efficient code that is a pleasure to read and write.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与STL算法配对的向量使开发者能够创建高效、表达性和简洁的操作。无论是复制、旋转、反转还是填充，都有针对该任务的算法。随着你继续使用`std::vector`，采用这些工具确保你以优雅和速度处理数据，编写出既易于阅读又易于编写的有效代码。
- en: In this section, we’ve mastered modifying the contents of `std::vector` with
    STL algorithms, particularly `std::copy`, central to performing secure and efficient
    data operations. We’ve also covered critical considerations such as avoiding iterator
    invalidation to maintain data integrity and performance. This expertise is invaluable
    for C++ developers, as streamlining the execution of complex data manipulations
    is critical in practical applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经掌握了使用STL算法修改`std::vector`的内容，特别是`std::copy`，这对于执行安全高效的数据操作至关重要。我们还涵盖了关键考虑因素，例如避免迭代器失效以维护数据完整性和性能。这种专业知识对于C++开发者来说是无价的，因为在实际应用中，简化复杂数据操作的执行是至关重要的。
- en: Moving forward, we’ll delve into customizing STL algorithm behavior using comparators
    and predicates, enabling the definition of bespoke sorting and searching criteria
    for user-defined data types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将深入探讨使用比较器和谓词自定义STL算法行为，从而为用户定义的数据类型定义定制的排序和搜索标准。
- en: Custom comparators and predicates
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制比较器和谓词
- en: When working with `std::vector` and STL algorithms, you’ll often encounter scenarios
    where the default behavior doesn’t fit the bill. Sometimes, the way two elements
    are compared or the criteria for selecting elements must deviate from the norm.
    Here’s where custom comparators and predicates come into play. They are a testament
    to the power and flexibility of the C++ STL, allowing you to inject your logic
    seamlessly into established algorithms.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`std::vector`和STL算法时，你经常会遇到默认行为不符合需求的情况。有时，两个元素的比较方式或选择元素的准则必须偏离常规。这就是自定义比较器和谓词发挥作用的地方。它们是C++
    STL强大和灵活性的证明，允许你将逻辑无缝地注入到既定的算法中。
- en: Understanding comparators
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解比较器
- en: A `bool`. It’s used to dictate the order of elements, especially in sorting
    or searching operations. By default, operations such as `std::sort` use the `(<)`
    operator to compare elements, but with a custom comparator, you can redefine this.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`bool`。它用于指定元素顺序，尤其是在排序或搜索操作中。默认情况下，`std::sort`等操作使用`(<)`运算符来比较元素，但通过自定义比较器，你可以重新定义这一点。
- en: 'Imagine a `std::vector` of integers, and you want to sort them in descending
    order. Instead of writing another algorithm, you can use `std::sort` with a comparator:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个整数的`std::vector`，你想要按降序排序它们。无需再编写另一个算法，你可以使用带有比较器的`std::sort`：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the lambda expression acts as a comparator, reversing the usual
    less-than behavior.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，lambda表达式充当比较器，反转了通常的**小于**行为。
- en: The power of predicates
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词的力量
- en: While comparators define ordering, predicates help in making decisions. A `bool`
    like a comparator. Predicates are commonly used with algorithms that need to make
    a selection or decision based on some criteria.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**比较器**定义了顺序，但**谓词**有助于做出决策。与比较器一样，谓词也是一个`bool`。谓词通常与需要根据某些准则进行选择或决策的算法一起使用。
- en: 'For instance, if you wanted to count how many numbers in a vector are even,
    you could employ `std::count_if` with a predicate as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要计算向量中有多少个偶数，你可以使用如下代码中的`std::count_if`谓词：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, the lambda predicate checks whether a number is even, allowing `std::count_if`
    to tally accordingly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，lambda谓词检查一个数字是否为偶数，允许`std::count_if`相应地计数。
- en: Crafting effective comparators and predicates
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建有效的比较器和谓词
- en: 'The following are the best practices to be kept in mind to craft effective
    comparators and predicates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在构建有效的比较器和谓词时需要牢记的最佳实践：
- en: '**Clarity**: Ensure that the logic within is clear. The purpose of a comparator
    or predicate should be evident upon reading.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰性**：确保内部的逻辑清晰。比较器或谓词的目的应该在阅读后显而易见。'
- en: '**Statelessness**: A comparator or predicate should be stateless, meaning it
    should not have any side effects or change behavior between calls.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态性**：比较器或谓词应该是无状态的，这意味着它不应该有任何副作用或改变调用之间的行为。'
- en: '**Efficiency**: Since comparators and predicates might be called repeatedly
    in algorithms, they should be efficient. Avoid unnecessary computations or calls
    within them.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：由于比较器和谓词可能在算法中被反复调用，它们应该高效。避免在它们内部进行不必要的计算或调用。'
- en: User-defined structs and classes
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户定义的结构体和类
- en: While lambdas are concise and convenient, defining a struct or class allows
    us to define behavior that is more complex or better lends itself to reusability.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda简洁方便，但定义一个结构体或类允许我们定义更复杂或更适合重用的行为。
- en: 'Consider a vector of students with names and grades. If you want to sort by
    grade and then by name, use the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含学生姓名和成绩的向量。如果你想按成绩排序，然后按姓名排序，可以使用以下代码：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'While the lambda approach works, using a struct might be clearer for complex
    logic:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda方法有效，但对于复杂的逻辑，使用结构体可能更清晰：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Custom comparators and predicates are like giving you the keys to the STL’s
    engine room. They allow you to harness the raw power of the library but tailor
    it precisely to your needs. This fine-tuned control makes C++ a standout language
    for algorithmic tasks and data processing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义比较器和谓词就像给你打开了STL引擎室的钥匙。它们允许你利用库的原始力量，但又能精确地满足你的需求。这种精细的控制使得C++在算法任务和数据处理方面成为一个突出的语言。
- en: This section introduced us to custom comparators and predicates, enhancing our
    ability to sort and filter elements in `std::vector`. We learned how to define
    sorting criteria with comparators and set conditions with predicates, particularly
    for user-defined types, allowing for intricate data organization within algorithms.
    Understanding and utilizing these tools is crucial for developers to customize
    and optimize data operations in C++.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了自定义比较器和谓词，增强了我们在`std::vector`中对元素进行排序和过滤的能力。我们学习了如何使用比较器定义排序标准，以及如何使用谓词设置条件，特别是对于用户定义的类型，允许在算法中进行复杂的数据组织。理解和利用这些工具对于开发者来说至关重要，以便在C++中自定义和优化数据操作。
- en: Next, we’ll explore container invariants and iterator invalidation, learning
    to manage container stability and avoid the common issue of invalidation, which
    is essential for ensuring robustness, especially in multi-threaded contexts.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨容器不变性和迭代器失效，学习如何管理容器稳定性并避免常见的失效问题，这对于确保健壮性，尤其是在多线程环境中至关重要。
- en: Understanding container invariants and iterator invalidation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器不变性和迭代器失效
- en: 'Within the C++ STL, there lies a crucial consideration often overlooked by
    many: `std::vector`, one such invariant might be that the elements are stored
    in contiguous memory locations. However, certain operations can disrupt these
    invariants, leading to potential pitfalls such as iterator invalidation. Armed
    with this knowledge, we can craft more resilient and efficient code.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++ STL中，有一个关键的考虑因素经常被许多人忽视：`std::vector`，其中一个不变量可能是元素存储在连续的内存位置。然而，某些操作可能会破坏这些不变量，导致潜在的陷阱，如迭代器失效。有了这个知识，我们可以编写更健壮和高效的代码。
- en: Understanding iterator invalidation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解迭代器失效
- en: A study of `std::vector` is incomplete without a grasp of **iterator invalidation**.
    Iterator invalidation is akin to trying to use a bookmark after someone’s reshuffled
    the pages in your book. You think you’re pointing to one location, but the data
    there might have changed or ceased to exist.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有掌握**迭代器失效**的情况下，对`std::vector`的研究是不完整的。迭代器失效就像在有人重新排列了你书中的页面后尝试使用书签一样。你认为你指向了一个位置，但那里的数据可能已经改变或不存在了。
- en: For instance, when we push an element to a vector (`push_back`), the element
    is added without any hitches if there’s enough reserved memory (`capacity`). But,
    if the vector needs to allocate new memory due to space constraints, it may relocate
    all its elements to this new memory block. As a result, any iterator, pointer,
    or reference pointing to an element in the old memory block will now be invalidated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们向向量中推送一个元素（`push_back`）时，如果预留了足够的内存（`capacity`），则元素可以无障碍地添加。但是，如果由于空间限制，向量需要分配新的内存，它可能会将所有元素重新定位到这个新的内存块。结果，任何指向旧内存块中元素的迭代器、指针或引用现在都将失效。
- en: Similarly, other operations, such as `insert`, `erase`, or `resize`, can also
    invalidate an iterator. The crux is to recognize when these operations might disrupt
    the vector’s layout and be prepared to deal with the consequences.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，其他操作，如`insert`、`erase`或`resize`，也可能使迭代器失效。关键是要认识到这些操作何时可能会破坏向量的布局，并准备好处理其后果。
- en: 'The following is a code example that demonstrates iterator invalidation with
    `std::vector` and how certain operations might disrupt the container’s layout:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，演示了使用`std::vector`的迭代器失效以及某些操作如何可能破坏容器的布局：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the example, we do the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了以下操作：
- en: We first set an iterator to point to the third element of the `numbers` vector.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先将一个迭代器设置为指向`numbers`向量的第三个元素。
- en: After pushing many elements to the vector, the original memory block might be
    reallocated to a new one, causing the iterator to become invalidated.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向向量中推送许多元素之后，原始内存块可能会重新分配到一个新的内存块，导致迭代器失效。
- en: We further demonstrate how the `insert` and `erase` operations can invalidate
    an iterator.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进一步展示了`insert`和`erase`操作如何使迭代器失效。
- en: It’s emphasized that using an invalidated iterator can lead to undefined behavior,
    and therefore, one should always re-acquire iterators after modifying a vector.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调使用失效的迭代器可能导致未定义的行为，因此，在修改向量后，应始终重新获取迭代器。
- en: Always be cautious after modifying operations on a vector, as they might invalidate
    your iterators. Re-acquire your iterators after such operations to ensure they’re
    valid.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在对向量进行修改操作后，始终要小心，因为它们可能会使你的迭代器失效。在这些操作之后重新获取你的迭代器，以确保它们是有效的。
- en: Strategies to counteract invalidation
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对抗失效的策略
- en: Now that we have a clue about when our iterators might become invalidated, it
    is time to uncover ways to circumvent or handle these scenarios gracefully.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了迭代器可能失效的时间，现在是时候揭示绕过或优雅处理这些场景的方法了。
- en: '`reserve` method. This pre-allocates memory, reducing the need for reallocation
    and subsequent iterator invalidation during additions.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reserve`方法。这预分配了内存，减少了在添加过程中重新分配和后续迭代器失效的需要。'
- en: '**Prefer positions over iterators**: Consider storing positions (e.g., index
    values) instead of storing iterators. After an operation that may lead to iterator
    invalidation, you can easily recreate a valid iterator using the position.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用位置而非迭代器**：考虑存储位置（例如，索引值）而不是存储迭代器。在可能导致迭代器失效的操作之后，你可以轻松地使用位置重新创建一个有效的迭代器。'
- en: '**Refresh iterators post-operation**: After any disruptive operation, avoid
    using any old iterators, pointers, or references. Instead, obtain fresh iterators
    to ensure they point to the correct elements.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作后刷新迭代器**：在任何破坏性操作之后，避免使用任何旧的迭代器、指针或引用。相反，获取新的迭代器以确保它们指向正确的元素。'
- en: '`<algorithm>` header offers many algorithms optimized for containers such as
    `std::vector`. These often handle potential invalidations internally, safeguarding
    your code against such pitfalls.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<algorithm>`头文件提供了许多针对容器（如`std::vector`）优化的算法。这些算法通常内部处理潜在的失效，保护你的代码免受此类陷阱的影响。'
- en: '**Caution with custom comparators and predicates**: When using algorithms that
    require comparators or predicates, ensure they don’t internally modify the vector
    in a way that could cause invalidation. Maintain the principle of separation of
    concerns.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小心使用自定义比较器和谓词**：当使用需要比较器或谓词的算法时，确保它们不会以可能导致失效的方式内部修改向量。维护关注点分离的原则。'
- en: 'Let’s look at an example that integrates key strategies to avoid iterator invalidation:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个集成了避免迭代器失效的关键策略的例子：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is the example output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This example does the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子做了以下操作：
- en: Demonstrates how to use `reserve` to pre-allocate memory, anticipating the size.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示了如何使用`reserve`来预分配内存，以预测大小。
- en: Shows positions (index values) instead of iterators to handle potential invalidations.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示位置（索引值）而不是迭代器来处理潜在的失效。
- en: Refreshes iterators after a disruptive operation (`insert`).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在破坏性操作（`insert`）之后刷新迭代器。
- en: Uses the `<algorithm>` header (i.e., `std::sort` and `std::count_if`) that is
    optimized for containers and respect invariants.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`<algorithm>`头文件（即`std::sort`和`std::count_if`），该文件针对容器进行了优化并尊重不变性。
- en: Emphasizes the importance of read-only operations (through the `isOdd` lambda)
    to avoid possible invalidations. (The `isOdd` lambda function is just a read-only
    operation and doesn’t modify the vector, ensuring we don’t have to worry about
    invalidation.)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调了只读操作（通过`isOdd` lambda）的重要性，以避免可能的失效。（`isOdd` lambda 函数只是一个只读操作，不会修改向量，确保我们不必担心失效。）
- en: Dealing with invalidation in multi-threaded scenarios
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多线程场景中的失效
- en: 'While iterator invalidation in a single-threaded application is easier to manage,
    things can get trickier in multi-threaded contexts. Imagine one thread modifying
    a vector while another attempts to read from it using an iterator. The chaos!
    The catastrophe! The following are the ways to tackle invalidation in multi-threaded
    scenarios:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在单线程应用程序中迭代器失效更容易管理，但在多线程环境中事情可能会变得复杂。想象一下，一个线程正在修改一个向量，而另一个线程试图使用迭代器从中读取。混乱！灾难！以下是在多线程场景中处理失效的方法：
- en: '**Use mutexes and locks**: Safeguard sections of your code that modify the
    vector with **mutexes**. This ensures that only one thread can change the vector
    at a given time, preventing concurrent operations that might lead to unpredictable
    invalidations.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用互斥锁和锁定**：使用**互斥锁**保护修改向量的代码部分。这确保了在任何给定时间只有一个线程可以更改向量，防止可能导致不可预测失效的并发操作。'
- en: '**Use atomic operations**: Some operations might be made atomic, ensuring they’re
    completed fully without interruption, reducing the chances of unsynchronized access
    and modification.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用原子操作**：某些操作可能是原子的，确保它们在没有中断的情况下完全完成，从而减少未同步访问和修改的可能性。'
- en: '**Consider thread-safe containers**: If multi-threading is central to your
    application, consider using **thread-safe containers** designed to handle concurrent
    accesses and modifications without compromising on invariants.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑线程安全的容器**：如果你的应用程序以多线程为中心，考虑使用专为处理并发访问和修改而设计的**线程安全容器**，这样就不会损害不变性。'
- en: Mutex
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁
- en: A mutex, short for **mutual exclusion**, is a synchronization primitive used
    in concurrent programming to protect shared resources or critical sections of
    code from being accessed by multiple threads simultaneously. By locking a mutex
    before accessing a shared resource and unlocking it afterward, a thread ensures
    that no other thread can access the resource while it’s being used, thus preventing
    race conditions and ensuring data consistency in multi-threaded applications.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁（mutex），即**互斥**，是一种同步原语，用于并发编程中保护共享资源或代码的关键部分，防止多个线程同时访问。通过在访问共享资源之前锁定互斥锁并在之后解锁，一个线程确保在资源被使用时没有其他线程可以访问该资源，从而防止竞争条件并确保多线程应用程序中的数据一致性。
- en: Thread-safe containers
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全容器
- en: A thread-safe container refers to a data structure that allows multiple threads
    to access and modify its contents concurrently without causing data corruption
    or inconsistencies. This is achieved through internal mechanisms such as locking
    or atomic operations that ensure synchronization and mutual exclusion, thereby
    maintaining the integrity of the container’s data even in a multi-threaded environment.
    Such containers are crucial in concurrent programming for safe and efficient data
    sharing between threads.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 线程安全容器指的是一种数据结构，允许多个线程并发访问和修改其内容，而不会导致数据损坏或不一致。这是通过内部机制（如锁定或原子操作）实现的，这些机制确保同步和互斥，从而在多线程环境中保持容器数据的完整性。这种容器在并发编程中对于线程之间安全高效的数据共享至关重要。
- en: 'Let’s look at a practical example of multi-threaded access to `std::vector`.
    This example will demonstrate the use of mutexes to prevent concurrent modifications,
    ensuring thread safety:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看多线程访问`std::vector`的实际例子。此示例将演示使用互斥锁来防止并发修改，确保线程安全：
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the example output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This example illustrates the following concepts:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了以下概念：
- en: We use a mutex (`vecMutex`) to protect the shared `std::vector` from concurrent
    access and modification.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用互斥锁（`vecMutex`）来保护共享的`std::vector`免受并发访问和修改。
- en: The `add_to_vector` and `print_vector` functions lock the mutex using `std::lock_guard`,
    ensuring exclusive access to the vector during their scope.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_to_vector`和`print_vector`函数使用`std::lock_guard`锁定互斥锁，确保在它们的范围内对向量的独占访问。'
- en: We use `std::thread` to run functions that concurrently modify or read from
    the vector. The use of mutexes ensures that these operations are thread-safe.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`std::thread`来运行同时修改或从向量中读取的函数。使用互斥锁确保这些操作是线程安全的。
- en: Remember, while mutexes safeguard against concurrent modifications, they can
    also introduce potential deadlocks and reduce parallelism. If multi-threading
    is deeply integrated into your application, you might consider other thread-safe
    containers or advanced synchronization techniques.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然互斥锁可以防止并发修改，但它们也可能引入潜在的死锁并降低并行性。如果你的应用程序深度集成了多线程，你可能需要考虑其他线程安全的容器或高级同步技术。
- en: Understanding and respecting container invariants is paramount in harnessing
    the full power of STL containers and the `<algorithm>` header. Knowing when and
    why certain invariants might be disrupted allows for the creation of robust, efficient,
    and reliable code. As we continue our exploration of algorithms beyond `std::vector`,
    always keep these principles in mind.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和尊重容器不变性对于充分利用STL容器和`<algorithm>`头文件的功能至关重要。了解何时以及为什么某些不变性可能会被破坏，可以让我们创建出健壮、高效和可靠的代码。在我们继续探索`std::vector`之外的算法时，始终牢记这些原则。
- en: In this section, we addressed the importance of preserving `std::vector` stability
    and the risks of iterator invalidation during container modification. We identified
    actions that cause invalidation and their potential to disrupt program integrity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了在容器修改过程中保持`std::vector`稳定性以及迭代器失效的风险的重要性。我们确定了导致失效的操作及其可能破坏程序完整性的潜在影响。
- en: Understanding iterator behavior is vital for bug prevention and ensuring the
    robustness of our applications. We’ve also learned methods to mitigate invalidation
    risks, maintaining vector consistency throughout operations that might jeopardize
    it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 理解迭代器行为对于防止错误和确保我们应用程序的健壮性至关重要。我们还学习了减轻失效风险的方法，在可能危及向量一致性的操作中保持向量的一致性。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have deepened our understanding of the STL through
    the lens of `std::vector` and its interaction with various algorithms. We commenced
    with sorting vectors, where we explored the `std::sort` algorithm and its underlying
    engine, introsort, appreciating its *O(n log n)* efficiency. We progressed to
    searching within vectors, contrasting the conditions and efficiencies of linear
    and binary search techniques.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个章节中，我们通过`std::vector`及其与各种算法的交互，加深了对STL的理解。我们从对向量进行排序开始，探讨了`std::sort`算法及其底层引擎introsort，并欣赏了其*O(n
    log n)*效率。我们进一步到向量中进行搜索，对比了线性搜索和二分搜索技术的条件和效率。
- en: The chapter then guided us through effective vector manipulation, including
    transformation with `std::copy` and the considerations necessary to prevent performance
    degradation or logical errors. We learned to use custom comparators and predicates
    to extend the functionality of standard algorithms when working with user-defined
    structs and classes. Finally, we explored container invariants and iterator invalidation,
    acquiring strategies to maintain data integrity even in complex, multi-threaded
    environments.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，章节引导我们了解有效的向量操作，包括使用`std::copy`进行转换以及防止性能下降或逻辑错误的必要考虑。我们学习了如何使用自定义比较器和谓词来扩展与用户定义的结构体和类一起使用时的标准算法的功能。最后，我们探讨了容器不变性和迭代器失效，获得了在复杂的多线程环境中保持数据完整性的策略。
- en: Critically, this information provides us with practical and detailed insights
    into how to leverage `std::vector` effectively. Mastery of these algorithms allows
    developers to write efficient, robust, and adaptable code to various programming
    challenges.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这些信息为我们提供了如何有效利用`std::vector`的实际和详细见解。掌握这些算法使开发者能够编写针对各种编程挑战的高效、健壮和适应性强代码。
- en: Next, we will shift our focus from the technical intricacies of algorithms to
    a broader discussion on why `std::vector` should be our default container of choice.
    We will compare `std::vector` with other containers, dive into its memory advantages,
    and reflect on practical use cases, from data processing to game development.
    This will underscore the versatility and efficiency of `std::vector`, solidifying
    its status as a safe and powerful default choice, yet one among many tools available
    to the adept C++ programmer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的关注点从算法的技术复杂性转移到对为什么`std::vector`应该成为我们首选容器的大讨论上。我们将比较`std::vector`与其他容器，深入探讨其内存优势，并反思从数据处理到游戏开发的实际应用案例。这将强调`std::vector`的通用性和效率，巩固其在安全且强大的默认选择中的地位，同时作为熟练的C++程序员众多工具之一。
