- en: Graphical User Interface with Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt进行图形用户界面
- en: C++ doesn't provide **Graphical User Interface** (**GUI**) programming out of
    the box. First, we should understand that a GUI is strongly tied to a specific
    **Operating System**(**OS**). You can program GUI applications in Windows using
    the Windows API, or in Linux using the Linux-specific API, and so on. Each OS
    has its own specific forms of Windows and GUI components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++并不直接提供**图形用户界面**（**GUI**）编程。首先，我们应该了解GUI与特定的**操作系统**（**OS**）密切相关。您可以使用Windows
    API在Windows中编写GUI应用程序，或者使用Linux特定的API在Linux中编写GUI应用程序，依此类推。每个操作系统都有自己特定的窗口和GUI组件形式。
- en: We touched on the different platforms and their differences in [Chapter 1](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml),
    *Building C++ Applications*. When discussing GUI programming, the difference between
    platforms is even more daunting. Cross-platform development had become a big pain
    in GUI developer's lives. They had to focus on a specific OS. Implementing the
    same application for other platforms took almost the same amount of work again.
    That's an unreasonably huge waste of time and resources. Languages such as *Java*
    provide a smart model of running applications in the virtual environment. This
    allows developers to focus on one language and one project since the environment
    takes care of running the application on different platforms. One of the main
    disadvantages of this approach is forcing the user to install a virtual machine
    and the slow execution time compared to platform-specific applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](2297d785-7242-4149-8b31-f9af1fcdd833.xhtml)中提到了不同平台及其差异。在讨论GUI编程时，平台之间的差异更加令人望而生畏。跨平台开发已经成为GUI开发人员生活中的一大痛苦。他们不得不专注于特定的操作系统。为其他平台实现相同的应用程序几乎需要同样多的工作。这是一个不合理的巨大时间和资源浪费。诸如*Java*之类的语言提供了在虚拟环境中运行应用程序的智能模型。这使得开发人员可以专注于一种语言和一个项目，因为环境负责在不同的平台上运行应用程序。这种方法的一个主要缺点是强制用户安装虚拟机，以及与特定平台应用程序相比较慢的执行时间。
- en: To solve these problems, the Qt framework was created. In this chapter, we'll
    find out how the Qt framework supports cross-platform GUI application development.
    To do this, you will need to become familiar with Qt and its key features. This
    will allow you to develop GUI applications using your favorite programming language
    – C++. We will start by understanding Qt's approach to GUI development, and then
    we will cover its concepts and features, such as signals and slots, and Model/View
    programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，Qt框架被创建了。在本章中，我们将了解Qt框架如何支持跨平台GUI应用程序开发。为此，您需要熟悉Qt及其关键特性。这将使您能够使用您喜爱的编程语言——C++来开发GUI应用程序。我们将首先了解Qt的GUI开发方法，然后我们将涵盖其概念和特性，如信号和槽，以及模型/视图编程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Fundamentals of cross-platform GUI programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨平台GUI编程的基础
- en: Qt core components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt核心组件
- en: Using Qt widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt小部件
- en: Designing a network application using Qt Network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt Network设计网络应用程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to install the latest Qt framework to run the examples in this
    chapter. We suggest using Qt Creator as the IDE for your projects. To download
    Qt, along with the corresponding tools, visit the [qt.io](https://www.qt.io/)
    website and choose the open source version of the framework. The code for this
    chapter could be found at: [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装最新的Qt框架才能运行本章的示例。我们建议使用Qt Creator作为项目的IDE。要下载Qt及相应的工具，请访问[qt.io](https://www.qt.io/)网站，并选择框架的开源版本。本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Understanding cross-platform GUI programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解跨平台GUI编程
- en: 'Each OS has its own API. It relates to the GUI in particular. When companies
    plan to design, implement, and ship desktop applications, they should decide what
    platform to focus on. A team of developers working on one platform will spend
    almost the same amount of time writing the same application for the other platform.
    The biggest reason for this is the different approaches and APIs provided by OS.
    The complexity of the API may also play a big role in implementing applications
    on time. For example, the following snippet from the official documentation shows
    how to create a button in Windows using C++:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有自己的API。它与GUI特别相关。当公司计划设计、实现和发布桌面应用程序时，他们应该决定专注于哪个平台。一个团队的开发人员在一个平台上工作，几乎需要花同样多的时间为另一个平台编写相同的应用程序。这最大的原因是操作系统提供的不同方法和API。API的复杂性也可能在按时实现应用程序方面起到重要作用。例如，官方文档中的以下片段显示了如何使用C++在Windows中创建按钮：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tackling Windows GUI programming requires you to work with `HWND`, `HINSTACNCE`,
    and many other weirdly named and confusing components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 解决Windows GUI编程需要你使用`HWND`、`HINSTACNCE`和许多其他奇怪命名和令人困惑的组件。
- en: .NET Framework made a drastic improvement to Windows GUI programming. If you
    want to support OS other than Windows, you have to think twice before using .NET
    Framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework对Windows GUI编程进行了重大改进。如果您想支持除Windows之外的操作系统，使用.NET Framework之前要三思。
- en: 'However, to support multiple OS, you still have to dive into APIs to implement
    the same application to cover all OS users out there. The following code shows
    an example of creating a button in Linux using the *Gtk+* GUI toolkit:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了支持多个操作系统，您仍然需要深入了解API来实现相同的应用程序，以满足所有操作系统的用户。以下代码显示了在Linux中使用*Gtk+* GUI工具包创建按钮的示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compared to the Windows API, it seems a bit easier to understand. However, you
    should dive into `GtkWidgets` and other components with *Gtk* prefixes to find
    out more about them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows API相比，它似乎更容易理解。但是，您应该深入了解`GtkWidgets`和其他带有*Gtk*前缀的组件，以了解更多关于它们的信息。
- en: As we have already mentioned, cross-platform languages such as Java and .NET
    Core use virtual machines to run the code on different platforms. The Qt framework
    supports cross-platform GUI programming using a platform-based compilation approach.
    Let's discuss both approaches with regard to the C++ language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，诸如Java和.NET Core之类的跨平台语言使用虚拟机在不同平台上运行代码。Qt框架支持使用基于平台的编译方法进行跨平台GUI编程。让我们就C++语言讨论这两种方法。
- en: Using C++ as Java
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++作为Java
- en: Languages such as Java or C# have different compilation models. The first chapter
    of this book introduced the C++ compilation model. First of all, we consider C++
    as a fully compilable language, while Java maintains a hybrid model. It compiles
    the source code into a middle representation called **bytecode**, and then the
    virtual machine runs it by translating it into the machine code for the specific
    platform.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Java或C#之类的语言有不同的编译模型。本书的第一章介绍了C++的编译模型。首先，我们认为C++是一种完全可编译的语言，而Java保持了混合模型。它将源代码编译成称为**字节码**的中间表示，然后虚拟机通过将其翻译成特定平台的机器代码来运行它。
- en: 'The following diagram depicts the differences between the C++ and Java compilation
    models:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了C++和Java编译模型之间的差异：
- en: '![](img/c0552bd5-d588-48b5-b7ec-9491231fbe30.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0552bd5-d588-48b5-b7ec-9491231fbe30.png)'
- en: The **Java virtual machine** (**JVM**) serves as a middle tier. It has a unique
    implementation for each platform. Users need to install the specific implementation
    of the virtual machine before running Java programs. The installation process
    only happens once. On the other hand, C++ programs are translated into machine
    code, which is run without a middle-tier environment such as the JVM. That's one
    of the reasons why C++ applications are generally faster. When we compile C++
    programs on a certain platform, the compiler outputs an executable file consisting
    of instructions in a format that's specific to that platform. When we move the
    application to another platform, it just can't run.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java虚拟机**（JVM）充当中间层。它对每个平台有一个独特的实现。用户需要在运行Java程序之前安装特定实现的虚拟机。安装过程只发生一次。另一方面，C++程序被翻译成机器代码，而不需要像JVM这样的中间层环境。这是C++应用程序通常更快的原因之一。当我们在某个平台上编译C++程序时，编译器会输出一个由特定于该平台的格式的指令组成的可执行文件。当我们将应用程序移动到另一个平台时，它就无法运行。'
- en: 'The other platform cannot recognize its format, nor its instructions (although
    they might be similar in some way). The Java approach works by presenting some
    bytecode that is the same for all the implementations of virtual machines. But
    virtual machines know exactly which instruction they should generate for the bytecode
    that''s been provided as their input. The same bytecode can be run on many computers
    if they have the virtual machine installed. The following diagram demonstrates
    the Java application compilation model:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台无法识别它的格式，也无法识别它的指令（尽管它们可能在某种程度上相似）。Java方法通过提供一些字节码来工作，这些字节码对于所有虚拟机的实现都是相同的。但是虚拟机确切地知道他们应该为作为输入提供的字节码生成哪些指令。如果安装了虚拟机，相同的字节码可以在许多计算机上运行。以下图表演示了Java应用程序编译模型：
- en: '![](img/4395de50-bc9b-4255-a882-8203041b2429.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4395de50-bc9b-4255-a882-8203041b2429.png)'
- en: As you can see, the source code is compiled into bytecode that can be run on
    every OS. However, each OS must be provided with its own virtual machine implementation.
    This means we can run a Java application on any OS if we have installed a JVM
    specifically implemented for that OS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，源代码被编译成可以在每个操作系统上运行的字节码。然而，每个操作系统必须提供其自己的虚拟机实现。这意味着如果我们为该操作系统安装了专门为该操作系统实现的JVM，我们就可以在任何操作系统上运行Java应用程序。
- en: 'Although C++ is a cross-platform language, meaning that we don''t modify the
    code to compile it in other platforms, the language doesn''t support GUI programming
    out of the box. To program GUI applications, as we mentioned previously, we need
    to access the OS API directly from the code. This makes C++ GUI applications platform-dependent
    because you need to modify the code base to compile it on the other platform.
    The following diagram shows how GUIs spoil the cross-platform nature of the language:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++是一种跨平台语言，也就是说我们不需要修改代码就可以在其他平台上编译它，但是这种语言并不直接支持GUI编程。为了编写GUI应用程序，正如我们之前提到的，我们需要直接从代码中访问操作系统API。这使得C++
    GUI应用程序依赖于平台，因为你需要修改代码基础才能在其他平台上编译它。以下图表显示了GUI是如何破坏语言的跨平台性的：
- en: '![](img/2cba1673-03ed-49cd-89b0-123652d0f46b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cba1673-03ed-49cd-89b0-123652d0f46b.png)'
- en: Though the application logic, name, and mission might be the same, it now has
    three different implementations with three different executables. To ship the
    application to the end user, we need to discover their OS and ship the correct
    executable. You might have encountered a similar scenario when downloading applications
    on the web. They offer download applications based on the OS. This is where Qt
    comes to the rescue. Let's see how.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用程序的逻辑、名称和任务可能相同，但现在它有三种不同的实现，有三种不同的可执行文件。要将应用程序交付给最终用户，我们需要发现他们的操作系统并交付正确的可执行文件。您可能在从网上下载应用程序时遇到了类似的情况。它们基于操作系统提供下载应用程序。这就是Qt发挥作用的地方。让我们看看它是如何做到的。
- en: Qt's cross-platform model
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt的跨平台模型
- en: 'Qt is a popular widget toolkit for creating GUI applications. It also allows
    us to create cross-platform applications that run on various systems. Qt consists
    of the following modules:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Qt是一个用于创建GUI应用程序的流行的小部件工具包。它还允许我们创建在各种系统上运行的跨平台应用程序。Qt包括以下模块：
- en: '**Qt Core**: Core classes'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt核心**：核心类'
- en: '**Qt** **GUI**: Base classes for GUI components'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt GUI**：GUI组件的基本类'
- en: '**Qt Widgets**: Classes to extend the Qt GUI with C++ widgets'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt小部件**：用于扩展Qt GUI的C++小部件的类'
- en: '**Qt Multimedia**: Classes for audio, video, radio, and camera functionality'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt多媒体**：音频、视频、广播和摄像功能的类'
- en: '**Qt Multimedia Widgets**: Classes for implementing multimedia functionality'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt多媒体小部件**：实现多媒体功能的类'
- en: '**Qt Network**: Classes for network programming (we will use them in this chapter)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt网络**：网络编程的类（我们将在本章中使用它们）'
- en: '**Qt Modeling Language** (**QML**): A declarative framework for building applications
    with custom user interfaces'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt建模语言**（**QML**）：用于构建具有自定义用户界面的声明性框架'
- en: '**Qt SQL**: Classes for database integration using SQL'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt SQL**：使用SQL进行数据库集成的类'
- en: '**Qt Quick family of modules**: A list of QML-related modules that won''t be
    discussed in this book'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt Quick模块系列**：一个与QML相关的模块列表，本书不会讨论'
- en: '**Qt Test**: Classes for unit testing Qt applications'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt测试**：用于单元测试Qt应用程序的类'
- en: 'Every module that we use in the program is attached to the compiler via a project
    file that has the `.pro` extension. This file describes everything that `qmake`
    needs to build the application. *qmake* is a tool aimed to simplify the build
    process. We describe the project components (sources, Qt modules, libraries, and
    so on) in the `.pro` file of the project. For example, a project that uses Qt
    Widgets and Qt Network and consists of `main.cpp` and `test.cpp` files will have
    the following content for the `.pro` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中使用的每个模块都通过具有`.pro`扩展名的项目文件连接到编译器。该文件描述了`qmake`构建应用程序所需的一切。*qmake*是一个旨在简化构建过程的工具。我们在项目的`.pro`文件中描述项目组件（源文件、Qt模块、库等）。例如，一个使用Qt小部件和Qt网络，由`main.cpp`和`test.cpp`文件组成的项目将在`.pro`文件中具有以下内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can specify platform-specific sources in the `.pro` file too, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`.pro`文件中指定特定于平台的源文件，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we build the application in a Windows environment, the `windows_specific.cpp` file
    will take part in the build process. Contrary to that, when building in a Unix
    environment, the `linux_world.cpp` file will be included while the `windows_specific.cpp` file
    will be ignored. With that, we've come to the compilation model of Qt applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Windows环境中构建应用程序时，`windows_specific.cpp`文件将参与构建过程。相反，当在Unix环境中构建时，将包括`linux_world.cpp`文件，而`windows_specific.cpp`文件将被忽略。通过这样，我们已经了解了Qt应用程序的编译模型。
- en: 'The whole point of Qt''s powerful abilities to provide cross-platform programming
    is meta-compiling the source code; that is, before the code is passed to the C++
    compiler, the Qt compiler cleans it up by introducing or replacing platform-specific
    components. For example, when we use a button component (`QPushButton`), it will
    be replaced by a Windows-specific button component if compiled in a Windows environment.
    That''s why the `.pro` file also can contain platform-specific modifications for
    the project. The following diagram depicts this compilation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Qt强大的跨平台编程能力的整个重点在于元编译源代码；也就是说，在代码传递给C++编译器之前，Qt编译器通过引入或替换特定于平台的组件来清理它。例如，当我们使用按钮组件（`QPushButton`）时，如果在Windows环境中编译，它将被替换为特定于Windows的按钮组件。这就是为什么`.pro`文件也可以包含项目的特定于平台的修改。以下图表描述了这个编译过程：
- en: '![](img/ea855027-5cfa-4dbb-861e-3c3c908077f2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea855027-5cfa-4dbb-861e-3c3c908077f2.png)'
- en: The meta-compiler is usually referred to as a **Meta-Object Compiler** (**MOC**).
    The beauty of this approach is that the produced output represents the same machine
    code that we run without a virtual machine. We can ship that executable right
    away. The downside of this approach is that we, again, have different executables
    for different platforms. However, we only write one application – there's no need
    to use different languages, dive into OS-specific APIs, or study OS-specific GUI
    component class names. As Qt says, *Write once, compile everywhere*. Now, let's
    move on to building a simple GUI application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 元编译器通常被称为**元对象编译器**（**MOC**）。这种方法的美妙之处在于产生的输出代表了我们可以直接运行的相同机器代码，而无需虚拟机。我们可以立即发布可执行文件。这种方法的缺点是，我们再次为不同的平台有不同的可执行文件。然而，我们只编写一个应用程序
    - 无需使用不同的语言，深入研究特定于操作系统的API，或学习特定于操作系统的GUI组件类名称。正如Qt所说，*一次编写，到处编译*。现在，让我们继续构建一个简单的GUI应用程序。
- en: Writing a simple application
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的应用程序
- en: 'We won''t discuss all the modules we mentioned previously in this book, simply
    because this would require a whole new book. You can refer to the books listed
    at the end of this chapter, in the *Further reading* section, for more information.
    The  `main` function looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中讨论我们之前提到的所有模块，因为这需要一本全新的书。您可以在本章末尾列出的书籍中的*进一步阅读*部分中查阅更多信息。`main`函数如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s take a look at the various components we used in the code. The first
    one is the `QtWidgets` header file. It contains widget components that we can
    use to build a fine-grained GUI for our application. Next, there''s the `QPushButton`
    class, which represents a wrapper for a clickable button. We''re intentionally
    introducing it as a wrapper here so that we can explain it when we discuss the
    compilation process of Qt programs later in this chapter. Here''s the result of
    running the preceding code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们在代码中使用的各种组件。第一个是`QtWidgets`头文件。它包含了我们可以用来为应用程序构建细粒度GUI的小部件组件。接下来是`QPushButton`类，它代表一个可点击按钮的包装器。我们故意在这里引入它作为一个包装器，这样我们可以在本章后面讨论Qt程序的编译过程时解释它。这是运行上述代码的结果：
- en: '![](img/10a68757-4e71-4c70-a722-b05add3fda63.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10a68757-4e71-4c70-a722-b05add3fda63.png)'
- en: As you can see, we only declared the `QPushButton` class, but it appeared as
    a window with the close and minimize buttons that are standard to the OS (in the
    example, this is macOS). The reason for this is because `QPushButton` indirectly
    inherits from `QWidget`, which is a widget with a frame; that is, a window. The
    button took almost all the space of the window. We can resize the window and see
    how the button resizes along with it. We will discuss widgets in more detail later
    in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所看到的，我们只声明了`QPushButton`类，但它出现为一个具有标准OS的关闭和最小化按钮的窗口（在本例中是macOS）。这是因为`QPushButton`间接继承自`QWidget`，它是一个带有框架的小部件；也就是说，一个窗口。按钮几乎占据了窗口的所有空间。我们可以调整窗口的大小，看看按钮如何随之调整大小。我们将在本章后面更详细地讨论小部件。 '
- en: The GUI builds when we run `app.exec()`. Pay attention to the type of the `app`
    object. It's a `QApplication` object. This is the starting point of Qt applications.
    When we call the `exec()` function, we start Qt's event loop. Our perception of
    program execution should be changed a bit to understand the GUI application life
    cycle. Redefining the perception of program construction and execution shouldn't
    be surprising for you after [Chapter 7](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml),
    *Functional Programming*. It's not that hard this time. The main thing to know
    here is that GUI applications have an additional entity running along with the
    main program. This entity is called an **event loop**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`app.exec()`时，GUI构建完成。注意`app`对象的类型。它是一个`QApplication`对象。这是Qt应用程序的起点。当我们调用`exec()`函数时，我们启动了Qt的事件循环。我们对程序执行的感知应该有所改变，以理解GUI应用程序的生命周期。重新定义程序构建和执行的感知在[第7章](decf1d72-ca4f-4954-85cb-860fbbf33580.xhtml)之后对你来说应该不足为奇，*函数式编程*。这次并不那么困难。这里需要知道的主要事情是，GUI应用程序在主程序之外还有一个额外的实体在运行。这个实体被称为**事件循环**。
- en: Recall the event loop, which we discussed in [Chapter 11](0e28887e-1a43-4510-a8ef-b3ad7531868d.xhtml),
    *Designing a Strategy Game Using Design Patterns*. The game represents a program
    with visual components that the user intensively interacts with. The same relates
    to regular GUI applications with buttons, labels, and other graphical components.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第11章](0e28887e-1a43-4510-a8ef-b3ad7531868d.xhtml)中讨论过的事件循环，*使用设计模式设计策略游戏*。游戏代表了用户密集交互的可视组件的程序。同样适用于具有按钮、标签和其他图形组件的常规GUI应用程序。
- en: 'The user interacts with the application and each user action is interpreted
    as an event. Each event is then pushed to the queue. The event loop processes
    those events one by one. Processing an event means calling a special handler function
    attached to the event. For example, whenever a button is clicked, the `keyPressedEvent()`
    function is invoked. It''s a virtual function, so we can override it when designing
    custom buttons, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与应用程序交互，每个用户操作都被解释为一个事件。然后将每个事件推送到队列中。事件循环逐个处理这些事件。处理事件意味着调用与事件相关联的特殊处理程序函数。例如，每当单击按钮时，将调用`keyPressedEvent()`函数。它是一个虚函数，因此在设计自定义按钮时可以重写它，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The only argument of the event is a pointer to `QKeyEvent`, a subtype of `QEvent`.
    `QEvent` is the base class of all event classes in Qt. Note the weird `Q_OBJECT`
    placed right after the opening block of the class. It's a Qt-specific macro that
    should be placed in the first line of your custom classes if you tend to make
    them discoverable by Qt's MOC.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的唯一参数是指向`QKeyEvent`的指针，它是`QEvent`的子类型。`QEvent`是Qt中所有事件类的基类。注意在类的开头块之后放置的奇怪的`Q_OBJECT`。这是一个Qt特定的宏，如果你想让它们被Qt的MOC发现，应该将它放在自定义类的第一行。
- en: In the next section, we will introduce the mechanism of signals and slots that
    are specific to Qt objects. To make our custom objects support that mechanism,
    we place the `Q_OBJECT` macro in the class definition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍特定于Qt对象的信号和槽的机制。为了使我们的自定义对象支持该机制，我们在类定义中放置`Q_OBJECT`宏。
- en: 'Now, let''s build something bigger than a simple button. The following example
    creates a window with the title `Mastering C++`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建比简单按钮更大的东西。以下示例创建了一个标题为“精通C ++”的窗口：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s what we get by executing the preceding program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行上述程序，我们得到以下结果：
- en: '![](img/9d9f3077-f55d-4e9d-969c-943ce57ae816.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d9f3077-f55d-4e9d-969c-943ce57ae816.png)'
- en: 'The title is cut; we can see only the Mast... part of Mastering C++. Now, if
    we manually resize it or change the source code so that it has a larger value
    for the second parameter for the `resize()` function, we get the following result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 标题被截断了；我们只能看到“Mast...”部分的“Mastering C ++”。现在，如果我们手动调整大小，或者更改源代码，使第二个参数的`resize()`函数具有更大的值，我们会得到以下结果：
- en: '![](img/e176177a-de4c-4ab2-8043-e63400a3a368.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e176177a-de4c-4ab2-8043-e63400a3a368.png)'
- en: The `window` object is of the `QWidget` type. `QWidget` is the central class
    for all user interface objects. Whenever you want to create a custom widget or
    extend an existing one, you directly or indirectly inherit from `QWidget`. It
    has a lot of functions for every use case. You can move it through the screen
    using the `move()` function, you can make the window full screen by calling `showFullScreen()`,
    and so on. In the preceding code, we called the `resize()` function, which takes
    the width and height to resize the widget. Also, note the `setWindowTitle()` function,
    which does exactly what it says on the tin – it sets the passed string argument
    as the title of the window. Its good practice to use the `QApplication::translate()`
    function when using string values in code. It makes program localization much
    easier because when the language setting is changed, Qt automatically replaces
    the text with the right translation. Almost the same functionality is provided
    by `QObject::tr()`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`对象是`QWidget`类型。`QWidget`是所有用户界面对象的中心类。每当您想要创建自定义小部件或扩展现有小部件时，您都会直接或间接地继承自`QWidget`。它有很多函数适用于每种用例。您可以使用`move()`函数在屏幕上移动它，可以通过调用`showFullScreen()`使窗口全屏，等等。在上面的代码中，我们调用了`resize()`函数，它接受宽度和高度来调整小部件的大小。还要注意`setWindowTitle()`函数，它正如其名-将传递的字符串参数设置为窗口的标题。在代码中使用字符串值时，最好使用`QApplication::translate()`函数。这样做可以使程序本地化变得更容易，因为当语言设置更改时，Qt会自动用正确的翻译替换文本。`QObject::tr()`提供了几乎相同的功能。'
- en: '`QObject` is the base class of all Qt types. In languages such as Java or C#,
    every object is directly or indirectly inherited from a generic type, mostly named
    `Object`. C++ doesn''t incorporate a common base class. Qt, on the other hand,
    introduces `QObject`, which comes with the base functionality that all objects
    should support.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`QObject`是所有Qt类型的基类。在诸如Java或C＃之类的语言中，每个对象都直接或间接地继承自一个通用类型，通常命名为`Object`。C ++没有包含一个公共基类。另一方面，Qt引入了`QObject`，它具有所有对象应支持的基本功能。'
- en: Now that we've touched on the basics of Qt application development, let's dive
    a little bit deeper into the framework and discover its key features.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Qt应用程序开发的基础知识，让我们深入了解框架并发现其关键特性。
- en: Discovering Qt
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Qt
- en: Qt evolved over time and at the time of writing this book, its version is 5.14\.
    Its first public prerelease version was announced in 1995\. More than two decades
    have passed and now Qt has a lot of powerful features that are used in almost
    all platforms, including mobile systems such as Android and iOS. With few exceptions,
    we can confidently write fully-featured GUI applications in C++ and Qt for all
    platforms. This is a big game-changer because companies hire smaller teams that
    specialize in one technology rather than having several teams for each specific
    platform.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Qt随着时间的推移不断发展，在撰写本书时，其版本为5.14。它的第一个公共预发布版本是在1995年宣布的。已经过去了二十多年，现在Qt在几乎所有平台上都有许多强大的功能，包括Android和iOS等移动系统。除了少数例外，我们可以自信地为所有平台使用C++和Qt编写功能齐全的GUI应用程序。这是一个重大的变革，因为公司可以雇佣专门从事一种技术的小团队，而不是为每个特定平台都有几个团队。
- en: If you are new to Qt, it is strongly recommended that you get familiar with
    it as much as you can (go to the end of this chapter for book references). Besides
    the regular components that GUI frameworks provide, Qt also introduces several
    concepts that are new or neatly implemented in the framework. One such concept
    is the communication between objects using signals and slots.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是Qt的新手，强烈建议你尽可能熟悉它（在本章的末尾有书籍参考）。除了GUI框架提供的常规组件外，Qt还引入了一些在框架中新的或精心实现的概念。其中一个概念是使用信号和槽进行对象之间的通信。
- en: Grasping signals and slots
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握信号和槽
- en: Qt introduced the concept of signals and slots as a flexible communication mechanism between
    objects. The concept of signals and slots and their implementation mechanism is
    one of the features that sets Qt aside from other GUI frameworks. In previous
    chapters, we discussed the Observer pattern. The main idea of this pattern is
    to have an object that notifies other objects (subscribers) of an event. The mechanism
    of signals and slots is similar to the Observer pattern's implementation. It's
    a way for an object to notify another object about its change. Qt provides a generic
    interface that can be used to connect objects together by tying a signal from
    one object to the slot of another. Both signals and slots are regular member functions
    of objects. The signal is the function that is invoked on a specified action for
    the object. The slot is another function that serves as the subscriber. It is
    invoked by the signal function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Qt引入了信号和槽的概念作为对象之间灵活的通信机制。信号和槽的概念及其实现机制是将Qt与其他GUI框架区分开的特性之一。在之前的章节中，我们讨论了观察者模式。这个模式的主要思想是有一个对象通知其他对象（订阅者）一个事件。信号和槽的机制类似于观察者模式的实现。这是一种对象通知另一个对象其变化的方式。Qt提供了一个通用接口，可以用来通过将一个对象的信号与另一个对象的槽绑定来连接对象。信号和槽都是对象的常规成员函数。信号是在对象的指定动作上调用的函数。槽是作为订阅者的另一个函数。它由信号函数调用。
- en: 'As we mentioned previously, Qt introduced us to the base type for all objects,  `QObject`.
    The basic functionality for supporting signals and slots is implemented in `QObject`.
    Any object that you declare in your code, `QWidget`, `QPushButton`, and others
    all inherit from `QObject`, so all of them support signals and slots. QObject
    provides us with two functions for managing object communication. These objects
    are `connect()` and `disconnect()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Qt向我们介绍了所有对象的基本类型`QObject`。支持信号和槽的基本功能在`QObject`中实现。你在代码中声明的任何对象，`QWidget`、`QPushButton`等都继承自`QObject`，因此它们都支持信号和槽。QObject为我们提供了两个用于管理对象通信的函数。这些对象是`connect()`和`disconnect()`：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the `connect()` function takes the `receiver` and `sender`
    objects as arguments. Also, it takes the names of the signal and the slot. `signal`
    is associated with the sender, while `slot` is what the receiver provides. The
    following diagram shows this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`connect()`函数将`receiver`和`sender`对象作为参数。它还接受信号和槽的名称。`signal`与发送者相关联，而`slot`是接收者提供的。以下图表显示了这一点：
- en: '![](img/2583b4a4-6b3d-4aa9-b879-885fcb19b63b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2583b4a4-6b3d-4aa9-b879-885fcb19b63b.png)'
- en: When programming Qt applications, operating with signals and slots will become
    natural and sooner or later, you would think that every other framework will support signals
    and slots because of their convenience. Also, note that the signal and the slot
    are processed as strings in the `connect()` and `disconnect()` functions. To specify
    the signal and the slot when connecting objects, we use two other macros, `SIGNAL()`
    and `SLOT()`, respectively. No more macros will be introduced from now on – we
    promise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写Qt应用程序时，操作信号和槽将变得自然，迟早你会认为每个其他框架都支持信号和槽，因为它们很方便。还要注意，在`connect()`和`disconnect()`函数中，信号和槽被处理为字符串。在连接对象时指定信号和槽，我们使用另外两个宏，分别是`SIGNAL()`和`SLOT()`。从现在开始不会再介绍更多的宏
    - 我们保证。
- en: 'Here''s how we connect two objects together. Let''s say we want to change the
    text of a label (an instance of `QLabel`) so that it receives a signal when the
    button is clicked. To achieve this, we connect the `clicked()` signal of `QPushButton`
    to the slot of `QLabel`, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何连接两个对象的方式。假设我们想要改变标签（`QLabel`的一个实例）的文本，使其在按钮被点击时接收一个信号。为了实现这一点，我们将`QPushButton`的`clicked()`信号连接到`QLabel`的槽，如下所示：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code might look a bit verbose, but you will get used to it. Consider
    it as the price for a convenient mechanism for signals and slots. However, the
    preceding example won''t give us the required results; that is, it won''t set
    the text of the label to state that it received a signal. We should somehow pass
    that string to the label''s slot. The `clicked()` signal doesn''t do that for
    us. One of the ways to achieve this is by extending `QLabel` so that it implements
    a custom slot that sets the text to `received a signal`. Here''s how we can do
    that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可能看起来有点冗长，但你会习惯的。把它看作是信号和槽的便利机制的代价。然而，前面的例子不会给我们所需的结果；也就是说，它不会将标签的文本设置为接收到信号。我们应该以某种方式将该字符串传递给标签的槽。`clicked()`信号不会为我们做到这一点。实现这一点的一种方法是通过扩展`QLabel`，使其实现一个自定义槽，将文本设置为`received
    a signal`。下面是我们可以这样做的方法：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To declare a slot, we specify the section, just like we did in the preceding
    code. Signals are declared almost the same way: by specifying a section with `signals:`.
    The only difference is that signals cannot be private or protected. We just declare
    them as-is:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个槽，我们像在前面的代码中所做的那样指定部分。信号的声明方式几乎相同：通过指定一个带有`signals：`的部分。唯一的区别是信号不能是私有或受保护的。我们只是按原样声明它们：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we should only update the preceding code in order to change the signal
    of the label (as well as the type of the label object):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要更新前面的代码，以更改标签的信号（以及标签对象的类型）：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We say that the slot will be called when the signal is emitted. You can declare
    and emit signals from within your objects as well. An important detail related
    to signals and slots is that they are independent of the GUI event loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说槽将在信号被发射时被调用。您还可以在对象内部声明和发射信号。与GUI事件循环无关的信号和槽的一个重要细节。
- en: 'When a signal is emitted, the connected slot is executed immediately. However,
    we can specify the type of connection by passing one of `Qt::ConnectionType` as
    the fifth argument of the `connect()` function. It comprises the following values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号被发射时，连接的槽立即执行。但是，我们可以通过将`Qt::ConnectionType`之一作为`connect()`函数的第五个参数来指定连接的类型。它包括以下值：
- en: '`AutoConnection`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoConnection`'
- en: '`DirectConnection`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DirectConnection`'
- en: '`QueuedConnection`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueuedConnection`'
- en: '`BlockingQueuedConnection`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockingQueuedConnection`'
- en: '`UniqueConnection`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UniqueConnection`'
- en: In `DirectConnection`, the slot is invoked immediately when the signal is emitted.
    On the other hand, when `QueuedConnection` is used, the slot is invoked when execution
    returns to the event loop of the receiver object's thread. `BlockingQueuedConnection`
    is similar to `QueuedConnection`, except that the signaling thread is blocked
    until the slot returns a value. `AutoConnection` can be either `DirectConnection`
    or `QueuedConnection`. The type is determined when the signal is emitted. If the
    receiver and the emitter are in the same thread, `DirectConnection` is used; otherwise,
    the connection goes with `QueuedConnection`. Finally, `UniqueConnection` is used
    with any of the connection types described previously. It is combined with one
    of them using the bitwise OR. Its sole purpose is for the `connect()` function
    to fail if the connection has already been established between the signal and
    the thread.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DirectConnection`中，当信号被发射时，槽立即被调用。另一方面，当使用`QueuedConnection`时，当执行返回到接收对象线程的事件循环时，槽被调用。`BlockingQueuedConnection`类似于`QueuedConnection`，只是信号线程被阻塞，直到槽返回一个值。`AutoConnection`可以是`DirectConnection`或`QueuedConnection`。当信号被发射时，类型被确定。如果接收者和发射者在同一线程中，使用`DirectConnection`；否则，连接使用`QueuedConnection`。最后，`UniqueConnection`与前面描述的任何连接类型一起使用。它与其中一个使用按位或组合。它的唯一目的是使`connect()`函数在信号和线程之间的连接已经建立时失败。
- en: Signals and slots form a powerful mechanism that makes Qt an outstanding framework
    in GUI programming. The next mechanism that we introduce is popular among frameworks
    and relates to the way we manipulate data in applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽构成了Qt在GUI编程中出色的机制。我们介绍的下一个机制在框架中很受欢迎，与我们在应用程序中操作数据的方式有关。
- en: Understanding Model/View programming
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模型/视图编程
- en: 'Model/View programming has its roots in the **Model View Controller** (**MVC**)
    design pattern. The main idea behind the pattern is to decompose your problem
    into three loosely coupled components, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 模型/视图编程根植于**模型视图控制器**（MVC）设计模式。该模式的主要思想是将问题分解为三个松散耦合的组件，如下所示：
- en: The Model, which is responsible for storing and manipulating data
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型负责存储和操作数据
- en: The View, which is responsible for rendering and visualizing the data
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图负责渲染和可视化数据
- en: The Controller, which is responsible for additional business logic and providing
    data from the model to the view
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器负责额外的业务逻辑，并从模型向视图提供数据
- en: 'Through its evolution, we now have a simplified and more convenient approach
    to programming called **Model/View programming**. It''s similar to the MVC pattern,
    except it omits the Controller by making the View and the Model more concerned
    about the functionality at hand. We can say that the View and the Controller are
    combined together in the Model/View architecture. Take a look at the following
    architecture diagram:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其演变，我们现在有了一种简化和更便利的编程方法，称为**模型/视图编程**。它类似于MVC模式，只是通过使视图和模型更关注手头的功能来省略了控制器。我们可以说视图和控制器在模型/视图架构中合并在一起。看一下以下架构图：
- en: '![](img/f039425a-e465-49bd-81db-34ca31d2918f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f039425a-e465-49bd-81db-34ca31d2918f.png)'
- en: The model represents the data, which communicates with its source and provides
    a convenient interface for the other components in the architecture. The model's
    implementation and its communication with other components is based on the type
    of data at hand.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表数据，与其来源通信，并为架构中的其他组件提供方便的接口。模型的实现及其与其他组件的通信基于手头数据的类型。
- en: The view gets references to data items by obtaining so-called model indexes.
    The view can retrieve and supply data to the model. The point is, the data item
    can be edited using the view, and the delegate plays the role of communicating
    with the model to keep data synchronized.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通过获取所谓的模型索引来引用数据项。视图可以从模型检索和提供数据。关键是，数据项可以使用视图进行编辑，委托起到了与模型通信以保持数据同步的作用。
- en: Each of the introduced components – model, view, and delegate – are defined
    by abstract classes that provide common interfaces. In some cases, classes also
    provide default implementations of features. To write specialized components,
    we subclass from abstract classes. And of course, models, views, and delegates
    communicate using signals and slots, which we introduced in the previous section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍的每个组件——模型、视图和委托——都由提供共同接口的抽象类定义。在某些情况下，类还提供了功能的默认实现。要编写专门的组件，我们从抽象类继承。当然，模型、视图和委托使用我们在上一节中介绍的信号和槽进行通信。
- en: When the model encounters changes in the data, it informs the view. On the other
    hand, user interactions with rendered data items are informed by signals from
    the view. Finally, signals from the delegate inform the model and view about the
    state of data editing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当模型遇到数据变化时，它会通知视图。另一方面，渲染数据项的用户交互由视图发出的信号通知。最后，委托发出的信号通知模型和视图有关数据编辑状态的信息。
- en: Models are based on the `QAbstractItemModel` class, which defines an interface
    that's used by views and delegates. Qt provides a set of existing model classes
    that we can use without modifications; however, if you need to create new models,
    you should inherit your class from `QAbstractItemModel`. For example, the `QStringListModel`,
    `QStandardItemModel`, and `QFileSystemModel` classes are ready-made to handle
    data items. `QStringListModel` is used to store a list of string items (represented
    as `QString` objects). Also, there are convenient model classes for working with
    SQL databases. `QSqlQueryModel`, `QSqlTableModel`, and `QSqlRelationalTableModel` allow
    us to access relational databases in the context of model/view conventions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 模型基于`QAbstractItemModel`类，该类定义了视图和委托使用的接口。Qt提供了一组现有的模型类，我们可以在不进行修改的情况下使用；但是，如果需要创建新模型，应该从`QAbstractItemModel`继承您的类。例如，`QStringListModel`、`QStandardItemModel`和`QFileSystemModel`类已经准备好处理数据项。`QStringListModel`用于存储字符串项列表（表示为`QString`对象）。此外，还有方便的模型类用于处理SQL数据库。`QSqlQueryModel`、`QSqlTableModel`和`QSqlRelationalTableModel`允许我们在模型/视图约定的上下文中访问关系数据库。
- en: Views and delegates also have corresponding abstract classes, that is, `QAbstractItemView`
    and `QAbstractItemDelegate`. Qt provides existing views that can be used right
    away, such as `QListView`, `QTableView`, and `QTreeView`. These are the basic
    types of views that most applications deal with. `QListView` displays a list of
    items, `QTableView` displays data in a table, and `QTreeView` displays data in
    a hierarchical list. If you want to work with those view classes, Qt suggests
    inheriting your custom models from `QAbstractListModel` or `QAbstractTableModel`
    instead of subclassing `QAbstractItemModel`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和委托也有相应的抽象类，即`QAbstractItemView`和`QAbstractItemDelegate`。Qt提供了现有的视图，可以立即使用，例如`QListView`、`QTableView`和`QTreeView`。这些是大多数应用程序处理的基本视图类型。`QListView`显示项目列表，`QTableView`以表格形式显示数据，`QTreeView`以分层列表形式显示数据。如果要使用这些视图类，Qt建议从`QAbstractListModel`或`QAbstractTableModel`继承自定义模型，而不是对`QAbstractItemModel`进行子类化。
- en: '`QListView`, `QTreeView`, and `QTableView` are considered core and low-level
    classes. There are more convenient classes that provide better usability to novice
    Qt programmers – `QListWidget`, `QTreeWidget`, and `QTableWidget`. We will look
    at examples of using widgets in the next section of this chapter. Before that,
    let''s look at a simple example of a `QListWidget` in action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`QListView`、`QTreeView`和`QTableView`被认为是核心和低级别的类。还有更方便的类，为新手Qt程序员提供更好的可用性——`QListWidget`、`QTreeWidget`和`QTableWidget`。我们将在本章的下一节中看到使用小部件的示例。在那之前，让我们看一个`QListWidget`的简单示例：'
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One of the ways to add items to the list widget is by creating them, which
    we can do by setting the list widget as its owner. In the following code, we''re
    declaring three `QListWidgetItem` objects, each holding a name and associated
    with the list widget we declared preceding:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表窗口小部件添加项目的一种方法是通过创建它们，我们可以通过将列表窗口小部件设置为其所有者来实现。在下面的代码中，我们声明了三个`QListWidgetItem`对象，每个对象都包含一个名称，并与我们之前声明的列表窗口小部件相关联：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, we can declare an item and then insert it into the list widget:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以声明一个项目，然后将其插入到列表窗口小部件中：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter of the `insertItem()` member function is the number of `row`
    to insert the item in. We placed the `Sveta` item in the first position of the
    list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertItem()`成员函数的第一个参数是要将项目插入的`row`的数量。我们将`Sveta`项目放在列表的第一个位置。'
- en: 'Now that we''ve touched on the concept of the row, we should get back to models
    and their indexes. The model encapsulates the data as a collection of data items.
    Each item in the model has a unique index specified by a `QModelIndex` class.
    This means that every item in the model can be accessed by the associated model
    index. To obtain the model index, we need to use the `index()` function. The following
    diagram depicts a model that organizes its data in a table-like structure:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涉及了行的概念，我们应该回到模型和它们的索引。模型将数据封装为数据项的集合。模型中的每个项都有一个由`QModelIndex`类指定的唯一索引。这意味着模型中的每个项都可以通过关联的模型索引访问。要获取模型索引，我们需要使用`index()`函数。以下图表描述了一个以表格结构组织其数据的模型：
- en: '![](img/394f992b-dd5a-4d0b-a1cf-ad364cf58851.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/394f992b-dd5a-4d0b-a1cf-ad364cf58851.png)'
- en: 'Views use this convention to access data items in the model. However, note
    that views are not restricted in terms of how they present the data to the user.
    It''s up to the view implementation to render and present the data in a way that''s
    convenient to the user. The following diagram shows how the data is organized
    within a model:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 视图使用这种约定来访问模型中的数据项。但是，请注意，视图在呈现数据给用户方面并没有限制。视图的实现方式取决于如何以对用户方便的方式呈现和展示数据。以下图表显示了数据在模型中的组织方式：
- en: '![](img/8cadf899-4035-46fc-9457-dc68738f5099.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cadf899-4035-46fc-9457-dc68738f5099.png)'
- en: 'Here''s how we can access a specific data item at row 1, column 2 using the
    model index:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用模型索引访问第1行第2列的特定数据项：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let''s declare a view and set a model to it to see model/view programming
    in action:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们声明一个视图并为其设置一个模型，以查看模型/视图编程的实际效果：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will continue this example in the next section, once we become familiar with
    the various widgets provided by Qt.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了Qt提供的各种小部件，我们将在下一节继续这个示例。
- en: Using Qt widgets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt小部件
- en: 'Widgets are visual GUI components. If a widget doesn''t have a parent, it is
    treated as a window, otherwise known as a **top-level widget**. Earlier in this
    chapter, we created the simplest possible window in Qt, as shown in the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是可视化GUI组件。如果一个小部件没有父级，它将被视为一个窗口，也就是**顶级小部件**。在本章的前面，我们创建了Qt中最简单的窗口，如下所示：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, the `window` object doesn''t have a parent. The thing is, the
    constructor of `QWidget` takes another `QWidget` as the parent of the current
    one. So, when we declare a button and want it to be a child of our `window` object,
    we do so in the following way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`window`对象没有父级。问题是，`QWidget`的构造函数接受另一个`QWidget`作为当前对象的父级。因此，当我们声明一个按钮并希望它成为`window`对象的子级时，我们可以这样做：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Observe the second argument of the `QPushButton` constructor. We passed a reference
    to the `window` object as its parent. When a parent object is destroyed, its children
    are automatically destroyed. There are many other widgets supported by Qt; let's
    have a look at some of them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 观察`QPushButton`构造函数的第二个参数。我们将`window`对象的引用作为其父级传递。当父对象被销毁时，其子对象将自动被销毁。Qt支持许多其他小部件；让我们看看其中一些。
- en: Common Qt widgets
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的Qt小部件
- en: 'In the previous section, we introduced the `QPushButton` class and stated that
    it indirectly inherits the `QWidget` class. To create a window, we used the `QWidget`
    class. As it turns out, QWidget represents the capability to render to the screen,
    and it''s the basic class that all widgets inherit from. It has a lot of properties
    and functions, such as `enabled`, a boolean property that''s true if the widget
    is enabled. To access it, we use the `isEnabled()` and `setEnabled()` functions.
    To control the size of the widget, we use its `height` and `width`, which represent
    the height and width of the widget. To get their values, we call `height()` and
    `width()`, respectively. To set a new height and width, we should use the `resize()`
    function, which takes two arguments – the width and the height. You can also control
    the minimum and maximum size of the widget using the `setMinimumWidth()`, `setMinimumHeight()`,
    `setMaximumWidth()`, and `setMaximumHeight()` functions. This might come in useful
    when you set up widgets in layouts (see the next section). Besides properties
    and functions, we are mainly interested in the public slots of QWidget, which
    are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了`QPushButton`类，并指出它间接继承了`QWidget`类。要创建一个窗口，我们使用了`QWidget`类。事实证明，QWidget代表了向屏幕渲染的能力，它是所有小部件都继承的基本类。它具有许多属性和函数，例如`enabled`，一个布尔属性，如果小部件启用则为true。要访问它，我们使用`isEnabled()`和`setEnabled()`函数。要控制小部件的大小，我们使用它的`height`和`width`，分别表示小部件的高度和宽度。要获取它们的值，我们分别调用`height()`和`width()`。要设置新的高度和宽度，我们应该使用`resize()`函数，它接受两个参数
    - 宽度和高度。您还可以使用`setMinimumWidth()`、`setMinimumHeight()`、`setMaximumWidth()`和`setMaximumHeight()`函数来控制小部件的最小和最大大小。当您在布局中设置小部件时，这可能会很有用（请参阅下一节）。除了属性和函数，我们主要对QWidget的公共槽感兴趣，它们如下：
- en: '`close()`: Closes the widget.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`: 关闭小部件。'
- en: '`hide()`: Equivalent to `setVisible(false)`, this function hides the widget.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hide()`: 等同于`setVisible(false)`，此函数隐藏小部件。'
- en: '`lower()` and `raise()`: Move the widget through the parent widget''s stack
    (to the bottom or to the top). Each widget can have a parent widget. A widget
    without a parent widget becomes an independent window. We can set a title and
    an icon for this window using the `setWindowTitle()` and `setWindowIcon()` functions.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower()`和`raise()`: 将小部件移动到父小部件的堆栈中（到底部或顶部）。每个小部件都可以有一个父小部件。没有父小部件的小部件将成为独立窗口。我们可以使用`setWindowTitle()`和`setWindowIcon()`函数为此窗口设置标题和图标。'
- en: '`style`: The property holds the style of the widget. To modify it, we use the
    `setStyleSheet()` function by passing a string describing the style of the widget. Another
    way to do this is by calling the `setStyle()` function and passing an object of
    the `QStyle` type that encapsulates style-related properties.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style`: 该属性保存小部件的样式。要修改它，我们使用`setStyleSheet()`函数，通过传递描述小部件样式的字符串。另一种方法是调用`setStyle()`函数，并传递封装了与样式相关属性的`QStyle`类型的对象。'
- en: 'Qt widgets have almost all the necessary properties out there to use out of
    the box. You rarely encounter situations where you have to build your own widget.
    However, some teams create an entire set of custom widgets for their software.
    That''s fine if you are planning to have a custom look and feel for your programs.
    For example, you can incorporate flat-styled widgets, which means you have to
    modify the style of the default widgets provided by the framework. Custom widgets
    should inherit from `QWidget` (or any of its descendants), as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Qt小部件几乎具备所有必要的属性，可以直接使用。很少遇到需要构建自定义小部件的情况。然而，一些团队为他们的软件创建了整套自定义小部件。如果您计划为程序创建自定义外观和感觉，那是可以的。例如，您可以整合扁平风格的小部件，这意味着您需要修改框架提供的默认小部件的样式。自定义小部件应该继承自`QWidget`（或其任何后代），如下所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want the widget to expose signals and slots, you need to use the `Q_OBJECT`
    macro at the beginning of the class declaration. The definition of the updated
    `MyWidget` class will look as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望小部件公开信号和插槽，您需要在类声明的开头使用`Q_OBJECT`宏。更新后的`MyWidget`类的定义如下：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you have probably already guessed, signals don''t have an access modifier,
    while slots can be separated into public, private, and protected sections. As
    we mentioned previously, Qt provides enough widgets out of the box. To go over
    the set of widgets, Qt provides a set of examples that compose widgets together.
    If you have installed Qt Creator (the IDE for developing Qt applications), you
    should be able to go over the examples in a single click. Here''s what it looks
    like in the Qt Creator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，信号没有访问修饰符，而插槽可以分为公共、私有和受保护部分。正如我们之前提到的，Qt提供了足够的小部件。为了了解这些小部件，Qt提供了一组将小部件组合在一起的示例。如果您已安装了Qt
    Creator（用于开发Qt应用程序的IDE），您应该能够通过单击一次来查看示例。在Qt Creator中的样子如下：
- en: '![](img/477bcb65-d63d-444f-b137-11aa76371cd2.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/477bcb65-d63d-444f-b137-11aa76371cd2.png)'
- en: 'Configuring and running the Address Book example will give us the following
    interface:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 配置和运行地址簿示例将给我们提供以下界面：
- en: '![](img/d0e7b66e-749a-4d36-9520-e04b702e354a.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0e7b66e-749a-4d36-9520-e04b702e354a.png)'
- en: 'Clicking the Add button will open a dialog so that we can add a new entry to
    the address book, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“添加”按钮将打开一个对话框，以便我们可以向地址簿添加新条目，如下所示：
- en: '![](img/5bd497c5-53ec-4f80-8c12-1b1143f90e84.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5bd497c5-53ec-4f80-8c12-1b1143f90e84.png)'
- en: 'After adding a couple of entries, the main window shows the entries in a table,
    as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了几个条目后，主窗口将以表格形式显示条目，如下所示：
- en: '![](img/91bc9193-20c4-4f05-8660-b43300552cd6.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91bc9193-20c4-4f05-8660-b43300552cd6.png)'
- en: 'The preceding screenshots show a wide range of widgets composed together in
    one application. Here are some of the most common widgets that we regularly use
    in GUI application development:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了在一个应用程序中组合在一起的各种小部件。以下是我们在GUI应用程序开发中经常使用的一些常见小部件：
- en: '`QCheckBox`: Represents a checkbox with a text label.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QCheckBox`：表示带有文本标签的复选框。'
- en: '`QDateEdit`: Represents a widget that you can use to input the date. You can
    also use `QDateTimeEdit` if want to input the time as well.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QDateEdit`：表示可以用来输入日期的小部件。如果还要输入时间，也可以使用`QDateTimeEdit`。'
- en: '`QLabel` : Text display. Also used to display images.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLabel`：文本显示。也用于显示图像。'
- en: '`QLineEdit`: A single-line edit box.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QLineEdit`：单行编辑框。'
- en: '`QProgressBar`: Renders a vertical or horizontal progress bar.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QProgressBar`：渲染垂直或水平进度条。'
- en: '`QTabWidget`: As stack of tabbed widgets. This is one of the many organizer
    widgets. Some of the other organizers are `QButtonGroup`, `QGroupBox`, and `QStackedWidget`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTabWidget`：标签式小部件的堆栈。这是许多组织小部件中的一个。其他组织者包括`QButtonGroup`、`QGroupBox`和`QStackedWidget`。'
- en: The preceding list is not final, but it gives a basic idea of Qt's capabilities.
    The address book example we used here uses many of these widgets. `QTabWidget`
    represents an organizing widget. It groups several widgets together. Another way
    to organize widgets is using layouts. In the next section, we will introduce you
    to how to organize widgets together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表并非最终版本，但它给出了Qt的基本功能的基本概念。我们在这里使用的地址簿示例使用了许多这些小部件。`QTabWidget`表示一个组织小部件。它将几个小部件组合在一起。另一种组织小部件的方法是使用布局。在下一节中，我们将介绍如何将小部件组织在一起。
- en: Composing widgets using layouts
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用布局组合小部件
- en: Qt provides us with a flexible and simple platform where we can use the widgets
    arrangement mechanism in the form of layouts. This helps us ensure the space inside
    the widget is used both efficiently and provides a friendly user experience.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了一个灵活和简单的平台，我们可以在其中使用布局机制来安排小部件。这有助于确保小部件内部的空间被高效地使用，并提供友好的用户体验。
- en: 'Lets look at the basic usage of layout management classes. The advantage of
    using layout management classes is that they automatically resize and position
    widgets when the container widget changes its size. Another advantage of Qt''s
    layout classes is that they allow us to arrange the widgets by writing code rather
    than using a UI composer. While Qt Creator provides a great way of composing widgets
    by hand (dragging and dropping widgets on the screen), most programmers feel more
    comfortable when they actually write code that arranges the look and feel of their
    widgets. Assuming you like the latter approach as well, we are going to introduce
    the following layout classes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看布局管理类的基本用法。使用布局管理类的优势在于，当容器小部件更改大小时，它们会自动调整小部件的大小和位置。Qt的布局类的另一个优势是，它们允许我们通过编写代码来安排小部件，而不是使用UI组合器。虽然Qt
    Creator提供了一种通过手工组合小部件的好方法（在屏幕上拖放小部件），但大多数程序员在实际编写安排小部件外观和感觉的代码时会感到更舒适。假设您也喜欢后一种方法，我们将介绍以下布局类：
- en: '`QHBoxLayout`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QHBoxLayout`'
- en: '`QVBoxLayout`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QVBoxLayout`'
- en: '`QGridLayout`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QGridLayout`'
- en: '`QFormLayout`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QFormLayout`'
- en: 'All of these classes inherit from `QLayout`, the base class for geometry management.
    `QLayout` is an abstract base class that inherits from `QObject`. It doesn''t
    inherit from `QWidget` because it doesn''t have anything to do with rendering;
    instead, it takes care of organizing widgets that should be rendered on the screen.
    You probably won''t need to implement your own layout manager, but if you do,
    you should inherit your class from `QLayout` and provide implementations for the
    following functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类都继承自`QLayout`，这是几何管理的基类。`QLayout`是一个抽象基类，继承自`QObject`。它不继承自`QWidget`，因为它与渲染无关；相反，它负责组织应该在屏幕上呈现的小部件。您可能不需要实现自己的布局管理器，但如果需要，您应该从`QLayout`继承您的类，并为以下函数提供实现：
- en: '`addItem()`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addItem()`'
- en: '`sizeHint()`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeHint()`'
- en: '`setGeometry()`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setGeometry()`'
- en: '`itemAt()`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itemAt()`'
- en: '`takeAt()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeAt()`'
- en: '`minimumSize()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimumSize()`'
- en: 'The classes listed here are more than enough to compose widgets of almost any
    complexity. And what''s more important is that we can place one layout into another,
    resulting in a more flexible organization of widgets. Using `QHBoxLayout`, we
    can organize widgets horizontally from left to right, as shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的类已经足够组成几乎任何复杂的小部件。更重要的是，我们可以将一个布局放入另一个布局中，从而更灵活地组织小部件。使用`QHBoxLayout`，我们可以从左到右水平地组织小部件，如下面的屏幕截图所示：
- en: '![](img/41c40a4b-c3e7-48f1-b380-1e50488376d7.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41c40a4b-c3e7-48f1-b380-1e50488376d7.png)'
- en: 'To achieve the preceding organization, we need to use the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现上述组织，我们需要使用以下代码：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Take a look at the line where we call the `setLayout()` function on the widget.
    Each widget can be assigned a layout. A layout itself doesn''t do much without
    a container, so we need to set it to a widget that serves as a container for organized
    widgets (buttons, in our case). `QHBoxLayout` inherits from `QBoxLayout`, which
    has another descendant that we listed previously – `QVBoxLayout`. It''s similar
    to `QHBoxLayout` but organizes widgets vertically, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们在小部件上调用`setLayout()`函数的那一行。每个小部件都可以分配一个布局。布局本身没有太多作用，除非有一个容器，所以我们需要将其设置为一个作为组织小部件（在我们的情况下是按钮）容器的小部件。`QHBoxLayout`继承自`QBoxLayout`，它有另一个我们之前列出的后代——`QVBoxLayout`。它类似于`QHBoxLayout`，但是垂直地组织小部件，如下面的屏幕截图所示：
- en: '![](img/a74e6782-1f0b-4911-a676-6caff1a6e7cf.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a74e6782-1f0b-4911-a676-6caff1a6e7cf.png)'
- en: 'The only thing that we need to do in the preceding code is replace `QHBoxLayout`
    with `QVBoxLayout`, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们唯一需要做的是将`QHBoxLayout`替换为`QVBoxLayout`，如下所示：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`GridLayout` allows us to organize widgets into a grid, as shown in the following
    screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridLayout`允许我们将小部件组织成网格，如下面的屏幕截图所示：'
- en: '![](img/76ec7f99-4a11-45e6-938a-9693af4e5f5f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76ec7f99-4a11-45e6-938a-9693af4e5f5f.png)'
- en: 'And here''s the corresponding code block:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的代码块：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, similar to `QGridLayout`, `QFormLayout` is more helpful when it comes
    to designing input forms because it lays out widgets in a two-column descriptive
    style.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类似于`QGridLayout`，`QFormLayout`在设计输入表单时更有帮助，因为它以两列描述的方式布置小部件。
- en: 'As we mentioned previously, we can compose a layout into another one. To do
    so, we need to use the `addItem()` function, as shown here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以将一个布局组合到另一个布局中。为此，我们需要使用`addItem()`函数，如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Layout managers are flexible enough to build complex user interfaces.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 布局管理器足够灵活，可以构建复杂的用户界面。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: If you are new to Qt, this chapter will have served as a general introduction
    to the framework. We touched on the basics of GUI application development and
    compared the Java approach with Qt's approach. One of the biggest pros of using
    Qt is its support for cross-platform development. While Java does the same, Qt
    goes beyond that by producing executables that are native to the platform. This
    makes applications written in Qt much faster compared to alternatives that incorporate
    virtual machines.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Qt的新手，本章将作为对框架的一般介绍。我们涉及了GUI应用程序开发的基础知识，并比较了Java方法和Qt方法。使用Qt的最大优点之一是它支持跨平台开发。虽然Java也可以做到，但Qt通过生成与平台原生的可执行文件而更进一步。这使得使用Qt编写的应用程序比集成虚拟机的替代方案快得多。
- en: We also discussed Qt's signals and slots as a flexible mechanism for inter-object
    communication. By using this, you are able to design complex communication mechanisms
    in your GUI applications. Although we looked at rather simple examples in this
    chapter, you are free to experiment with various ways of using signals and slots.
    We also became familiar with common Qt widgets and the mechanism of layout management.
    You now have a fundamental understanding that allows you to design even the most
    complex GUI layouts. This means you're free to implement a complex Qt application
    by applying the techniques and widgets that were introduced in this chapter. In
    the next chapter, we are going to discuss a popular topic nowadays – artificial
    intelligence and machine learning.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了Qt的信号和槽作为对象间通信的灵活机制。通过使用这个机制，您可以在GUI应用程序中设计复杂的通信机制。虽然本章中我们只看了一些简单的例子，但您可以自由地尝试各种使用信号和槽的方式。我们还熟悉了常见的Qt小部件和布局管理机制。现在您已经有了基本的理解，可以设计甚至最复杂的GUI布局。这意味着您可以通过应用本章介绍的技术和小部件来实现复杂的Qt应用程序。在下一章中，我们将讨论一个当今流行的话题——人工智能和机器学习。
- en: Questions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why doesn't Qt need a virtual machine?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Qt不需要虚拟机？
- en: What does the `QApplication::exec()` function do?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QApplication::exec()`函数的作用是什么？'
- en: How would you change the title of a top-level widget?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何更改顶层小部件的标题？
- en: Given the `m` model, how would you access an item at row 2 and column 3?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`m`模型，如何访问第2行第3列的项目？
- en: Given the `wgt` widget, how would you change its width to 400 and height to
    450?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定`wgt`小部件，如何将其宽度更改为400，高度更改为450？
- en: Which functions should you implement when inheriting from `QLayout` to create
    your own layout manager class?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`QLayout`继承以创建自己的布局管理器类时，应该实现哪些函数？
- en: How can you connect a signal to a slot?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将信号连接到槽？
- en: Further reading
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Qt5 C++ GUI Programming Cookbook* by Lee Zhi Eng: [https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition](https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Qt5 C++ GUI Programming Cookbook* by Lee Zhi Eng: [https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition](https://www.packtpub.com/application-development/qt5-c-gui-programming-cookbook-second-edition)'
- en: '*Mastering Qt5* by Guillaume Lazar, Robin Penea: [https://www.packtpub.com/web-development/mastering-qt-5-second-edition](https://www.packtpub.com/web-development/mastering-qt-5-second-edition)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mastering Qt5* by Guillaume Lazar, Robin Penea: [https://www.packtpub.com/web-development/mastering-qt-5-second-edition](https://www.packtpub.com/web-development/mastering-qt-5-second-edition)'
