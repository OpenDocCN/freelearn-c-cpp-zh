- en: 6\. Graph Algorithms I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 图算法I
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够：
- en: Describe the utility of graphs for solving various real-world problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述图在解决各种现实世界问题中的实用性
- en: Choose and implement the right traversal method to find an element in a graph
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择并实现正确的遍历方法来找到图中的元素
- en: Solve the minimum spanning tree (MST) problem using Prim's algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prim算法解决最小生成树（MST）问题
- en: Identify when to use the Prim's and Kruskal's algorithms to solve the MST problem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定何时使用Prim和Kruskal算法解决MST问题
- en: Find the shortest path between two vertices/nodes in a graph using Dijkstra's
    algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dijkstra算法在图中找到两个顶点/节点之间的最短路径
- en: In this chapter, we will study the basic and most commonly used algorithms for
    solving problems that can be represented in the form of graphs, which shall then
    be discussed further in the next chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习解决可以用图表示的问题的基本和最常用的算法，这将在下一章中进一步讨论。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous two chapters, we discussed two algorithm design paradigms:
    divide and conquer and the greedy approach, which led us to well-known solutions
    to widely used and important computational problems such as sorting, searching,
    and finding the minimum weight spanning tree on a graph. In this chapter, we shall
    discuss some algorithms that are specifically applicable to the graph data structure.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们讨论了两种算法设计范式：分治和贪婪方法，这使我们得到了广泛使用和重要的计算问题的众所周知的解决方案，如排序、搜索和在图上找到最小权重生成树。在本章中，我们将讨论一些专门适用于图数据结构的算法。
- en: A **graph** is defined as a set of **vertices** and **edges** that connect a
    pair of vertices. Mathematically, this is often written as *G = < V, E >*, where
    *V* denotes the set of vertices and *E* denotes the set of edges that constitute
    a graph. Edges that point from one node to another are called *directed*, while
    edges that have no direction are called *undirected*. Edges may also be associated
    with a *weight* or be *unweighted*, as we saw in *Chapter 2*, *Trees, Heaps, and
    Graphs*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图**被定义为一组连接一对顶点的**顶点**和**边**。在数学上，这经常被写为*G = < V, E >*，其中*V*表示顶点的集合，*E*表示构成图的边的集合。指向另一个节点的边称为*有向*，而没有方向的边称为*无向*。边也可以与*权重*相关联，也可以是*无权重*，正如我们在*第2章*，*树、堆和图*中看到的那样。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The terms "node" and "vertex" can be used interchangeably when we talk about
    graphs. In this chapter, we shall stick with "vertex."
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论图时，“节点”和“顶点”可以互换使用。在本章中，我们将坚持使用“顶点”。
- en: 'Graphs are some of the most versatile data structures – so much so that other
    linked data structures such as trees and linked lists are known to be just special
    cases of graphs. What makes graphs useful is that they are the general representation
    of *relationships* (represented as **edges**) between *objects* (represented as
    **nodes**). Graphs can have multiple edges between the same pair of nodes, or
    even have multiple edge weights on a single edge, and nodes can also have edges
    from themselves to themselves (also known as self edges). The graph shown in the
    following diagram shows how these features can be present in a graph. Variants
    of graphs, called "hypergraphs," are also allowed to have edges that connect multiple
    nodes, and another set of variants called "mixed graphs" are also allowed to have
    both directed and undirected edges within the same graph:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一些最通用的数据结构之一，以至于其他链接数据结构，如树和链表，被认为只是图的特殊情况。图的有用之处在于它们是*关系*（表示为**边**）和*对象*（表示为**节点**）的一般表示。图可以在同一对节点之间有多个边，甚至可以在单个边上有多个边权重，节点也可以从自身到自身有边（也称为自环）。下图显示了这些特征如何存在于图中。图的变体称为“超图”，允许有连接多个节点的边，另一组变体称为“混合图”，允许在同一图中既有有向边又有无向边：
- en: '![Figure 6.1: A graph with multiple edge weights, self edges (also called loops),
    and both directed and undirected edges](img/C14498_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：具有多个边权重、自环（也称为循环）以及有向和无向边的图](img/C14498_06_01.jpg)'
- en: 'Figure 6.1: A graph with multiple edge weights, self edges (also called loops),
    and both directed and undirected edges'
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.1：具有多个边权重、自环（也称为循环）以及有向和无向边的图
- en: As a result of the high degree of generality that graphs offer, they find use
    in several applications. Theoretical computer scientists use graphs to model finite
    state machines and automata, artificial intelligence and machine learning experts
    use graphs to extract information from changes in the structure of different kinds
    of networks over time, and traffic engineers use graphs to study the flow of traffic
    through road networks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图提供了高度的通用性，它们在多个应用中被使用。理论计算机科学家使用图来建模有限状态机和自动机，人工智能和机器学习专家使用图来从不同类型的网络结构随时间变化中提取信息，交通工程师使用图来研究交通通过道路网络的流动。
- en: 'In this chapter, we shall restrict ourselves to studying algorithms that use
    weighted, directed graphs, and if needed, positive edge weights. We shall first
    study the **graph traversal problem** and cover two solutions to it: **breadth-first
    search** (**BFS**) and **depth-first search** (**DFS**). Next, we shall revert
    to the minimum spanning tree problem we introduced in the previous chapter and
    provide a different solution to it called Prim''s algorithm. Finally, we shall
    cover the single-source shortest path problem that powers navigation applications
    such as Google Maps and the OSRM route planner.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将限制自己研究使用加权、有向图的算法，如果需要，还有正边权。我们将首先研究**图遍历问题**并提供两种解决方案：**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。接下来，我们将回到前一章介绍的最小生成树问题，并提供一个称为Prim算法的不同解决方案。最后，我们将涵盖单源最短路径问题，该问题支持导航应用程序，如Google地图和OSRM路线规划器。
- en: Let's begin by taking a look at the basic problem of traversing a graph.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下遍历图的基本问题。
- en: The Graph Traversal Problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图遍历问题
- en: Imagine that you have recently moved into an apartment in a new neighborhood.
    As you meet your new neighbors and make new friends, people often recommend restaurants
    to dine at in the vicinity. You wish to visit all the recommended restaurants,
    so you pull out a map of the neighborhood and mark all the restaurants and your
    home on the map, which already has all the roads marked on it. If we represent
    each restaurant and your home as a vertex, and the roads connecting the restaurants
    as edges in a graph, the problem of visiting all the vertices in the graph, when
    starting from a given vertex, is called the graph traversal problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您最近搬进了一个新社区的公寓。当您遇到新邻居并交新朋友时，人们经常推荐附近的餐馆用餐。您希望访问所有推荐的餐馆，因此您拿出社区地图，在地图上标记所有餐馆和您的家，地图上已经标有所有道路。如果我们将每个餐馆和您的家表示为一个顶点，并将连接餐馆的道路表示为图中的边，则从给定顶点开始访问图中所有顶点的问题称为图遍历问题。
- en: 'In the following figure, the numbers in blue are assumed vertex IDs. Vertex
    *1* is *Home*, and the restaurants are labeled from *R1* to *R7*. None of the
    edges have arrows since the edges are assumed to be bidirectional, that is, you
    can travel on the roads in either direction:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，蓝色数字表示假定的顶点ID。顶点*1*是*Home*，餐馆从*R1*到*R7*标记。由于边被假定为双向的，因此没有边箭头，也就是说，可以沿着道路双向行驶：
- en: '![Figure 6.2: Representing a neighborhood map as a graph](img/C14498_06_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：将邻域地图表示为图](img/C14498_06_02.jpg)'
- en: 'Figure 6.2: Representing a neighborhood map as a graph'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.2：将邻域地图表示为图
- en: In mathematical notation, given a graph, *G = < V, E >*, the graph traversal
    problem is to visit all *v* *∈* *V* starting from a given vertex, *s*. The graph
    traversal problem is also called **the graph search problem** since it can be
    used to "find" a vertex in the graph. Different graph traversal algorithms give
    different orders for visiting the vertices in the graph.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学表示中，给定一个图，*G = < V, E >*，图遍历问题是从给定顶点*s*开始访问所有*V*中的所有*v*。图遍历问题也称为**图搜索问题**，因为它可以用来在图中“找到”一个顶点。不同的图遍历算法给出了访问图中顶点的不同顺序。
- en: Breadth-First Search
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: 'A "breadth-first" search or breadth-first traversal of the graph starts by
    adding the starting vertex to a **frontier** that consists of the set of previously
    visited vertices and then iteratively exploring the vertices adjacent to the current
    frontier. The following illustrated steps should help you understand this idea:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图的“广度优先”搜索或广度优先遍历从将起始顶点添加到由先前访问的顶点组成的**前沿**开始，然后迭代地探索与当前前沿相邻的顶点。下面的示例步骤应该帮助您理解这个概念：
- en: 'First, the *Home* vertex, which is the starting point, is visited. *R1* and
    *R2* are the neighbors of the vertices in the current frontier, which is represented
    by a blue dotted line in the following figure:![Figure 6.3: Initialization of
    the BFS frontier](img/C14498_06_03.jpg)'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先访问*Home*顶点，即起点。*R1*和*R2*是当前前沿顶点的邻居，如下图中蓝色虚线所示：![图6.3：BFS前沿的初始化](img/C14498_06_03.jpg)
- en: 'Figure 6.3: Initialization of the BFS frontier'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.3：BFS前沿的初始化
- en: 'The following figure shows BFS after visiting *R1* and *R1*, either of which
    can be visited before the other. The order of visiting vertices that are at the
    same distance from the source vertex is irrelevant; however, the vertices with
    lower distance from the source are always visited first:![Figure 6.4: The BFS
    frontier after visiting the R1 and R2 vertices](img/C14498_06_04.jpg)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图显示了访问*R1*和*R1*后的BFS，可以先访问其中任何一个。从源顶点距离相同的顶点的访问顺序是无关紧要的；但是，距离源顶点较近的顶点总是首先被访问：![图6.4：访问R1和R2顶点后的BFS前沿](img/C14498_06_04.jpg)
- en: 'Figure 6.4: The BFS frontier after visiting the R1 and R2 vertices'
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.4：访问R1和R2顶点后的BFS前沿
- en: 'The following figure shows the state of BFS after visiting *R3*, *R5*, and
    *R6*. This is essentially the penultimate stage before the entire graph is traversed:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下图显示了访问*R3*、*R5*和*R6*后BFS的状态。这基本上是整个图被遍历之前的倒数第二阶段：
- en: '![Figure 6.5: The BFS frontier after visiting R3, R5, and R6](img/C14498_06_05.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：访问R3、R5和R6后的BFS前沿](img/C14498_06_05.jpg)'
- en: 'Figure 6.5: The BFS frontier after visiting R3, R5, and R6'
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.5：访问R3、R5和R6后的BFS前沿
- en: A useful property of BFS is that for every vertex that is visited, all of its
    children vertices are visited before any grandchildren vertices. However, while
    implementing BFS, the frontier is typically not explicitly maintained in a separate
    data structure. Instead, a queue of vertex IDs is used to ensure that the vertices
    that are closer to the source vertex are always visited before the vertices that
    are farther away. In the following exercise, we shall implement BFS in C++.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的一个有用特性是，对于每个被访问的顶点，所有子顶点都会在任何孙顶点之前被访问。然而，在实现BFS时，前沿通常不会在单独的数据结构中显式维护。相反，使用顶点ID的队列来确保比离源顶点更近的顶点总是在更远的顶点之前被访问。在下面的练习中，我们将在C++中实现BFS。
- en: 'Exercise 28: Implementing BFS'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习28：实现BFS
- en: 'In this exercise, we shall implement the breadth-first search algorithm using
    an edge list representation of the graph. To do so, perform the following steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用图的边缘列表表示来实现广度优先搜索算法。为此，请执行以下步骤：
- en: 'Add the required header files and declare the graph, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件并声明图，如下所示：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Write the following struct, which represents an edge in our graph:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下结构，表示图中的一条边：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since our definition of an edge uses templates, the edges can be easily made
    to have an edge weight of any data type that's needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对边的定义使用了模板，因此可以轻松地使边具有所需的任何数据类型的边权重。
- en: 'Next, overload the `<<` operator for the `Graph` data type in order to display
    the contents of the graph:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重载`<<`运算符，以便显示图的内容：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Write a class to define our graph data structure, as shown here:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类来定义我们的图数据结构，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For this exercise, we shall test our implementation of BFS on the following
    graph:![Figure 6.6: Graph for implementing BFS traversal in Exercise 28'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在以下图上测试我们的BFS实现：![图6.6：在练习28中实现BFS遍历的图
- en: '](img/C14498_06_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_06.jpg)'
- en: 'Figure 6.6: Graph for implementing BFS traversal in Exercise 28'
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.6：在练习28中实现BFS遍历的图
- en: 'We need a function to create and return the required graph. Note that while
    edge weights are assigned to each edge in the graph, this is not necessary since
    the BFS algorithm does not need to use edge weights. Implement the function as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数来创建并返回所需的图。请注意，虽然图中为每条边分配了边权重，但这并不是必需的，因为BFS算法不需要使用边权重。实现函数如下：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the breadth-first search like so:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实施广度优先搜索如下：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following test and driver code that creates the reference graph, runs
    BFS starting from vertex *1*, and outputs the results:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下测试和驱动代码，创建参考图，从顶点*1*开始运行BFS，并输出结果：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the preceding code. Your output should look as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码。您的输出应如下所示：
- en: '![Figure 6.7: Expected output of Exercise 28'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：练习28的预期输出'
- en: '](img/C14498_06_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_07.jpg)'
- en: 'Figure 6.7: Expected output of Exercise 28'
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.7：练习28的预期输出
- en: 'The following figure shows the order of vertices that our BFS implementation
    visits. Notice that the search starts from vertex *1* and then gradually visits
    vertices farther away from the source. In the following figure, the integers in
    red show the order, and the arrows show the direction in which our BFS implementation
    visits the vertices of the graph:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们的BFS实现访问顶点的顺序。请注意，搜索从顶点*1*开始，然后逐渐访问离源顶点更远的顶点。在下图中，红色的整数显示了顺序，箭头显示了我们的BFS实现访问图的顶点的方向：
- en: '![Figure 6.8: BFS implementation in Exercise 28'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：练习28中的BFS实现'
- en: '](img/C14498_06_08.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_08.jpg)'
- en: 'Figure 6.8: BFS implementation in Exercise 28'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.8：练习28中的BFS实现
- en: The time complexity of the BFS is *O(V + E)*, where *V* is the number of vertices
    and *E* is the number of edges in the graph.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的时间复杂度为*O(V + E)*，其中*V*是顶点数，*E*是图中的边数。
- en: Depth-First Search
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'While BFS starts from the source vertex and gradually expands the search outward
    to vertices farther away, DFS starts from the source vertex and iteratively visits
    vertices as far away as possible along a certain path, returning to earlier vertices
    to explore vertices along a different path in the graph. This method of searching
    the graph is also called **backtracking**. The following illustrated steps show
    the working of DFS:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然BFS从源顶点开始，逐渐向外扩展搜索到更远的顶点，DFS从源顶点开始，迭代地访问尽可能远的顶点沿着某条路径，然后返回到先前的顶点，以探索图中另一条路径上的顶点。这种搜索图的方法也称为**回溯**。以下是说明DFS工作的步骤：
- en: 'Naturally, we begin our traversal by visiting the *Home* vertex, as shown in
    the following figure:![Figure 6.9: DFS initialization](img/C14498_06_09.jpg)'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自然地，我们开始遍历，访问*Home*顶点，如下图所示：![图6.9：DFS初始化](img/C14498_06_09.jpg)
- en: 'Figure 6.9: DFS initialization'
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.9：DFS初始化
- en: 'Next, we visit vertex *R2*. Note that *R2* is chosen arbitrarily over *R1*
    since both are adjacent to *Home*, and either could have been chosen without affecting
    the correctness of the algorithm:![Figure 6.10: DFS after visiting R2](img/C14498_06_10.jpg)'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们访问顶点*R2*。请注意，*R2*是任意选择的，因为*R2*和*R1*都与*Home*相邻，选择任何一个都不会影响算法的正确性：![图6.10：访问R2后的DFS](img/C14498_06_10.jpg)
- en: 'Figure 6.10: DFS after visiting R2'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.10：访问R2后的DFS
- en: 'Next, we visit vertex *R3*, as shown in the following figure. Again, either
    of *R3* or *R1* could have been chosen arbitrarily, as both are adjacent to *R2*:![Figure
    6.11: DFS after visiting R3](img/C14498_06_11.jpg)'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们访问顶点*R3*，如下图所示。同样，*R3*或*R1*都可以任意选择，因为它们都与*R2*相邻：![图6.11：访问R3后的DFS](img/C14498_06_11.jpg)
- en: 'Figure 6.11: DFS after visiting R3'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.11：访问R3后的DFS
- en: 'The search continues by visiting an arbitrary unvisited neighbor vertex at
    each iteration. After *R1* is visited, the search tries to look for the next unvisited
    vertex. Since there are none left, the search terminates:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索继续通过在每次迭代中访问任意未访问的相邻顶点来进行。访问了*R1*之后，搜索尝试寻找下一个未访问的顶点。由于没有剩下的顶点，搜索终止：
- en: '![Figure 6.12: DFS after visiting all the vertices in the graph](img/C14498_06_12.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：访问图中所有顶点后的DFS](img/C14498_06_12.jpg)'
- en: 'Figure 6.12: DFS after visiting all the vertices in the graph'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.12：访问图中所有顶点后的DFS
- en: 'While implementing the BFS, we used a queue to keep track of unvisited vertices.
    Since a queue is a **First-In, First-Out** (**FIFO**) data structure where vertices
    are removed from the queue in the same order as they are added to the queue, it
    was used by the BFS algorithm to ensure that vertices closer to the starting vertex
    are visited before the vertices farther away. Implementing DFS is remarkably similar
    to implementing BFS, except for one difference: instead of using a queue as a
    container for the list of vertices to be visited, we can now use a stack, while
    the rest of the algorithm remains the same. This approach works because on each
    iteration, DFS visits an unvisited neighbor of the current vertex, which can easily
    be tracked using a stack, which is a **Last-In, First-Out** (**LIFO**) data structure.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现BFS时，我们使用队列来跟踪未访问的顶点。由于队列是**先进先出**（**FIFO**）数据结构，顶点被按照加入队列的顺序从队列中移除，因此BFS算法使用它来确保离起始顶点更近的顶点先被访问，然后才是离得更远的顶点。实现DFS与实现BFS非常相似，唯一的区别是：不再使用队列作为待访问顶点列表的容器，而是使用栈，而算法的其余部分保持不变。这种方法之所以有效，是因为在每次迭代中，DFS访问当前顶点的未访问邻居，这可以很容易地通过栈来跟踪，栈是**后进先出**（**LIFO**）数据结构。
- en: 'Exercise 29: Implementing DFS'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习29：实现DFS
- en: 'In this exercise, we shall implement the DFS algorithm in C++ and test it on
    the graph shown in *figure 6.2*. The steps are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在C++中实现DFS算法，并在*图6.2*中显示的图上进行测试。步骤如下：
- en: 'Include the required header files, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件，如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Write the following struct in order to implement an edge in our graph:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下结构以实现图中的边：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, since our implementation uses a templatized version of the struct, it
    allows us to assign edge weights of any data type required. However, for the purposes
    of DFS, we shall use null values as placeholders for the edge weights.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于我们的实现使用了结构的模板化版本，它允许我们分配任何所需的数据类型的边权重。然而，为了DFS的目的，我们将使用空值作为边权重的占位符。
- en: 'Next, overload the `<<` operator for the graph so that it can be printed out
    using the following function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重载图的`<<`运算符，以便可以使用以下函数打印出来：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the graph data structure that uses an edge list representation as
    follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现使用边列表表示的图数据结构如下：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need a function to perform DFS for our graph. Implement it as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来执行我们的图的DFS。实现如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We shall test our implementation of the DFS on the graph shown here:![Figure
    6.13: Graph for implementing DFS traversal in Exercise 29'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里显示的图上测试我们的DFS实现：![图6.13：用于实现练习29中DFS遍历的图
- en: '](img/C14498_06_13.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_13.jpg)'
- en: 'Figure 6.13: Graph for implementing DFS traversal in Exercise 29'
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.13：用于实现练习29中DFS遍历的图
- en: 'Use the following function to create and return the graph:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下函数创建并返回图：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the use of null values for edge weights since DFS does not require edge
    weights. A simpler implementation of the graph could have omitted the edge weights
    entirely without affecting the behavior of our DFS algorithm.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在DFS中使用空值表示边权重，因此DFS不需要边权重。图的更简单的实现可以完全省略边权重而不影响我们的DFS算法的行为。
- en: 'Finally, add the following test and driver code, which runs our DFS implementation
    and prints the output:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下测试和驱动代码，运行我们的DFS实现并打印输出：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile and run the preceding code. Your output should look as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行上述代码。您的输出应如下所示：
- en: '![Figure 6.14: Expected output of Exercise 29'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14：练习29的预期输出'
- en: '](img/C14498_06_14.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_14.jpg)'
- en: 'Figure 6.14: Expected output of Exercise 29'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.14：练习29的预期输出
- en: 'The following figure shows the order in which the vertices were visited by
    our DFS implementation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我们的DFS实现访问顶点的顺序：
- en: '![Figure 6.15: The order of vertices visited and the direction of DFS](img/C14498_06_15.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15：访问顶点的顺序和DFS的方向](img/C14498_06_15.jpg)'
- en: 'Figure 6.15: The order of vertices visited and the direction of DFS'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.15：访问顶点的顺序和DFS的方向
- en: 'The time complexity of both BFS and DFS is *O(V + E)*. However, there are several
    important differences between the two algorithms. The following list summarizes
    the differences between the two and points out some cases where one should be
    preferred over the other:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: BFS和DFS的时间复杂度均为*O(V + E)*。然而，这两种算法之间有几个重要的区别。以下列表总结了两者之间的区别，并指出了一些情况下应该优先选择其中一种：
- en: BFS is more suited to finding vertices that are closer to the source vertex,
    whereas DFS is often more suited to finding vertices that are farther away from
    the source.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BFS更适合找到靠近源顶点的顶点，而DFS通常更适合找到远离源顶点的顶点。
- en: Once a vertex is visited in BFS, the path that's found from the source to the
    vertex is guaranteed to be the shortest path, while no such guarantees exist for
    DFS. This is the reason why all single-source and multiple-source shortest path
    algorithms use some variant of BFS. This shall be explored in the upcoming sections
    of this chapter.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在BFS中访问了一个顶点，从源到该顶点找到的路径将保证是最短路径，而对于DFS则没有这样的保证。这就是为什么所有单源和多源最短路径算法都使用BFS的某种变体的原因。这将在本章的后续部分中探讨。
- en: As BFS visits all the vertices adjacent to the current frontier, the search
    trees that are created by BFS are short and wide, and require comparatively more
    memory, whereas the search trees that are created by DFS are long and narrow,
    and require comparatively less memory.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于BFS访问当前前沿相邻的所有顶点，因此BFS创建的搜索树短而宽，需要相对更多的内存，而DFS创建的搜索树长而窄，需要相对较少的内存。
- en: 'Activity 13: Finding out Whether a Graph is Bipartite Using DFS'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：使用DFS找出图是否为二部图
- en: A bipartite graph is one where the vertices can be divided into two sets so
    that any edges in the graph must connect a vertex from one set to a vertex from
    the other set.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 二部图是指顶点可以分为两组，使得图中的任何边必须连接一组中的顶点到另一组中的顶点。
- en: 'Bipartite graphs can be used to model several different practical use cases.
    For instance, if we are given a list of students and a list of classes, the relationship
    between students and classes can be modeled as a bipartite graph containing an
    edge between a student and a class if the student is enrolled in that class. As
    you would imagine, edges leading from one student to another, or from one subject
    to another, would not make sense. Therefore, such edges are not allowed in a bipartite
    graph. The following figure illustrates such a model:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 二部图可用于模拟几种不同的实际用例。例如，如果我们有一个学生名单和一个课程名单，学生和课程之间的关系可以被建模为一个二部图，如果学生在该课程中注册，则包含学生和课程之间的边。正如您所想象的那样，从一个学生到另一个学生，或者从一个科目到另一个科目的边是没有意义的。因此，在二部图中不允许这样的边。以下图示例了这样一个模型：
- en: '![Figure 6.16: A sample bipartite graph representing student enrollment in
    different classes](img/C14498_06_16.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16：代表不同班级学生注册情况的样本二部图](img/C14498_06_16.jpg)'
- en: 'Figure 6.16: A sample bipartite graph representing student enrollment in different
    classes'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.16：代表不同班级学生注册情况的样本二部图
- en: 'Once a model such as the one shown here has been prepared, it can be used to
    create a schedule of classes so that no two classes that have been enrolled by
    the same student overlap. For example, if Jolene is enrolled in *Math* and *Computer
    Science*, these two classes should not be scheduled at the same time to avoid
    a conflict. Minimizing such conflicts in timetables can be achieved through solving
    a maximum flow problem in graphs. Several standard algorithms are known for the
    maximum flow problem: Ford-Fulkerson''s, Dinic''s, and the push-relabel algorithms
    are some examples. However, such algorithms are often complex and, therefore,
    beyond the scope of this book.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦像这里展示的模型准备好了，就可以用它来创建课程表，以便没有两个被同一学生选修的课程时间冲突。例如，如果Jolene选修了*数学*和*计算机科学*，这两门课就不应该在同一时间安排，以避免冲突。通过解决图中的最大流问题可以实现在时间表中最小化这种冲突。已知有几种标准算法用于最大流问题：Ford-Fulkerson算法、Dinic算法和推-重标记算法是其中的一些例子。然而，这些算法通常很复杂，因此超出了本书的范围。
- en: Another use case of modeling relationships between entities using a bipartite
    graph is between the viewers and the list of movies maintained by large video
    streaming platforms such as Netflix and YouTube.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 建模实体之间关系的另一个用例是使用二部图在大型视频流媒体平台（如Netflix和YouTube）的观众和电影列表之间建立关系。
- en: An interesting property of bipartite graphs is that some operations such as
    finding a maximum matching and vertex cover, which are *NP-complete* for general
    graphs, can be solved in polynomial time for bipartite graphs. Therefore, it is
    useful to determine whether a given graph is bipartite or not. In this activity,
    you are required to implement a C++ program that checks whether a given graph,
    *G*, is bipartite.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 二部图的一个有趣特性是，一些在一般图中是*NP完全*的操作，如查找最大匹配和顶点覆盖，对于二部图可以在多项式时间内解决。因此，确定给定图是否是二部图是很有用的。在这个活动中，您需要实现一个检查给定图*G*是否是二部图的C++程序。
- en: 'The bipartite checking algorithm uses a slightly modified version of DFS and
    works as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 二部图检查算法使用了DFS的略微修改版本，并按以下方式工作：
- en: Assume that the DFS starts with vertex *1*. Add the vertex ID, *1*, to the stack.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设DFS从顶点*1*开始。将顶点ID *1*添加到堆栈。
- en: If unvisited vertices remain on the stack, pop a vertex from the stack and set
    it as the current vertex.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果堆栈上仍有未访问的顶点，则弹出一个顶点并将其设置为当前顶点。
- en: If the color that was assigned to the parent vertex was blue, assign the current
    vertex red; otherwise, assign the current vertex blue.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果分配给父顶点的颜色是蓝色，则将当前顶点分配为红色；否则，将当前顶点分配为蓝色。
- en: Add all the unvisited adjacent vertices of the current vertex to the stack and
    mark the current vertex as visited.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前顶点的所有未访问相邻顶点添加到堆栈，并将当前顶点标记为已访问。
- en: Repeat *steps 2*, *3*, and *4* until all the vertices have been assigned a color.
    If all the vertices are colored when the algorithm terminates, the given graph
    is bipartite.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤2*、*3*和*4*，直到所有顶点都被赋予颜色。如果算法终止时所有顶点都被着色，则给定的图是二部图。
- en: If, while running *step 2*, the search encounters a vertex that has already
    been visited and assigned a color that is different from the color that it would
    have been assigned in *step 3* (the inverse of the color assigned to its parent
    vertex in the search tree), the algorithm terminates immediately and the given
    graph is not bipartite.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在运行*步骤2*时，搜索遇到一个已经被访问并且被赋予与在*步骤3*中应该被赋予的颜色不同的颜色（与搜索树中其父顶点被赋予的颜色相反）的顶点，算法立即终止，给定的图就不是二部图。
- en: 'The following figures illustrate the working of the preceding algorithm:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了前述算法的工作方式：
- en: '![Figure 6.17: Initialization](img/C14498_06_17.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17：初始化](img/C14498_06_17.jpg)'
- en: 'Figure 6.17: Initialization'
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.17：初始化
- en: '![Figure 6.18: Since vertex 1 was assigned blue, we color vertex 2 red](img/C14498_06_18.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18：由于顶点1被赋予蓝色，我们将顶点2涂成红色](img/C14498_06_18.jpg)'
- en: 'Figure 6.18: Since vertex 1 was assigned blue, we color vertex 2 red'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.18：由于顶点1被赋予蓝色，我们将顶点2涂成红色
- en: '![](img/C14498_06_19.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_06_19.jpg)'
- en: 'Figure 6.19: Since vertex 2 was colored red, we color vertex 8 blue.'
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.19：由于顶点2被涂成红色，我们将顶点8涂成蓝色。
- en: As can be observed from the preceding set of figures, the algorithm zigzags
    through the graph, assigning alternate colors to each vertex that's visited. If
    all the vertices can be colored this way, the graph is bipartite. If DFS reaches
    two vertices that have already been assigned the same color, the graph can be
    safely declared to be not bipartite.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面一系列图中可以观察到，该算法在图中穿行，为每个访问的顶点分配交替的颜色。如果所有顶点都可以以这种方式着色，那么图就是二部图。如果DFS到达两个已经被分配相同颜色的顶点，那么可以安全地声明图不是二部图。
- en: 'Using the graph in *figure 6.17* as input, your final output should look as
    follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*图6.17*中的图作为输入，最终输出应如下所示：
- en: '![Figure 6.20: Expected output of Activity 13'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.20：活动13的预期输出'
- en: '](img/C14498_06_20.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_20.jpg)'
- en: 'Figure 6.20: Expected output of Activity 13'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.20：活动13的预期输出
- en: Note
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注
- en: The solution to this activity can be found on page 524.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第524页找到。
- en: Prim's MST Algorithm
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prim的MST算法
- en: 'The MST problem was introduced in *Chapter 5*, *Greedy Algorithms*, and is
    defined as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: MST问题在*第5章*“贪婪算法”中介绍，并定义如下：
- en: '*"Given a graph, G = < V, E >, where V is the set of vertices and E is the
    set of edges, each associated with an edge weight, find a tree, T, that spans
    all vertices in V and has the minimum total weight."*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*“给定图G = <V，E>，其中V是顶点集，E是边集，每个边关联一个边权重，找到一棵树T，它跨越V中的所有顶点并具有最小总权重。”*'
- en: In *Chapter 5*, *Greedy Algorithm*, we discussed the practical applications
    of the MST problem and Kruskal's algorithm, which finds an MST in a given graph.
    Kruskal's algorithm adds all the edges of the graph to a min-heap and greedily
    adds minimum-cost edges to MST, checking that no cycles are formed in the tree
    on each addition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*贪婪算法*中，我们讨论了MST问题和Kruskal算法的实际应用，Kruskal算法将图的所有边添加到最小堆中，并贪婪地将最小成本边添加到MST中，每次添加时检查树中是否形成了循环。
- en: The idea behind Prim's algorithm (also known as Jarvik's algorithm) is similar
    to that of BFS. The algorithm starts by adding the starting vertex to a *frontier*,
    which consists of the set of previously visited vertices and then iteratively
    explores the vertices adjacent to the current frontier. However, while choosing
    the vertex to be visited on each iteration, the vertex with the lowest cost edge
    from the frontier is picked.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Prim算法（也称为Jarvik算法）的思想与BFS类似。该算法首先将起始顶点添加到*frontier*中，*frontier*包括先前访问过的顶点集，然后迭代地探索与当前*frontier*相邻的顶点。然而，在每次迭代选择要访问的顶点时，会选择*frontier*中具有最低成本边的顶点。
- en: 'While implementing Prim''s algorithm, we attach a *label* to each vertex of
    the graph, which stores its distance from the starting vertex. The algorithm works
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Prim算法时，我们为图的每个顶点附加一个*label*，用于存储其与起始顶点的距离。算法的工作方式如下：
- en: First, it initializes the labels on all the vertices and sets all the distances
    to infinity. Since the distance from the starting vertex to itself is *0*, it
    sets the label of the starting vertex to *0*. Then, it adds all the labels to
    a min-heap, *H*.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，初始化所有顶点的标签，并将所有距离设置为无穷大。由于从起始顶点到自身的距离为*0*，因此将起始顶点的标签设置为*0*。然后，将所有标签添加到最小堆*H*中。
- en: 'In the following figure, the numbers shown in red represent the estimated distance
    from the starting vertex, which is assumed to be vertex *1*; the numbers shown
    in black represent edge weights:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，红色数字表示从起始顶点（假定为顶点*1*）的估计距离；黑色数字表示边权重：
- en: '![](img/C14498_06_21.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/C14498_06_21.jpg)'
- en: 'Figure 6.21: Initializing Prim''s MST algorithm'
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.21：初始化Prim的MST算法
- en: Next, it pops a vertex, *U*, from *H*. Naturally, *U* is the vertex with a minimum
    distance from the starting vertex.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从*H*中弹出一个顶点*U*。显然，*U*是距离起始顶点最近的顶点。
- en: 'For all vertices, *V*, adjacent to *U*, if the label of *V* > edge weight of
    *(U, V)*, set the label of *V* = edge weight of *(U, V)*. This step is called
    *settling* or *visiting* vertex *U*:![Figure 6.22: The status of the graph after
    visiting vertex 1](img/C14498_06_22.jpg)'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有与*U*相邻的顶点*V*，如果*V*的标签 > *(U, V)*的边权重，则将*V*的标签设置为*(U, V)*的边权重。这一步骤称为*settling*或*visiting*顶点*U*：![图6.22：访问顶点1后图的状态](img/C14498_06_22.jpg)
- en: 'Figure 6.22: The status of the graph after visiting vertex 1'
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.22：访问顶点1后图的状态
- en: While unvisited vertices remain in the graph, go to *step 2*. The following
    figure shows the state of the graph after visiting vertex *2*, where the edge
    shown in green is the sole edge in our MST so far:![](img/C14498_06_23.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图中仍有未访问的顶点时，转到*步骤2*。下图显示了访问顶点*2*后图的状态，绿色边是迄今为止我们MST中的唯一边：![](img/C14498_06_23.jpg)
- en: 'Figure 6.23: The status of the graph after visiting vertex 2'
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.23：访问顶点2后图的状态
- en: 'The final MST after all vertices have been settled is shown here:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有顶点都已经settled后的最终MST如下所示：
- en: '![Figure 6.24: MST for our graph](img/C14498_06_24.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24：我们的图的MST](img/C14498_06_24.jpg)'
- en: 'Figure 6.24: MST for our graph'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.24：我们的图的MST
- en: 'Exercise 30: Prim''s Algorithm'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习30：Prim算法
- en: 'In this exercise, we shall implement Prim''s algorithm to find the MST in the
    graph shown in *figure 6.22*. Follow these steps to complete this exercise:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现Prim算法来找到*图6.22*中所示图中的MST。按照以下步骤完成这个练习：
- en: 'Add the required header files, as shown here:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的头文件，如下所示：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement an edge in the graph by using the following struct:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下结构在图中实现一条边：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the following function to overload the `<<` operator for the `Graph` class
    so that we can output the graph to C++ streams:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下函数重载`Graph`类的`<<`运算符，以便我们可以将图输出到C++流中：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add an edge list-based graph implementation, as shown here:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加基于边列表的图实现，如下所示：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Make a function to create and return the graph shown in *figure 6.22* by using
    the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建并返回*图6.22*中所示的图的函数：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we shall implement the `Label` structure, an instance of which is assigned
    to each vertex in the graph in order to store its distance from the frontier.
    Use the following code to do so:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`Label`结构，为图中的每个顶点分配一个实例，以存储其与*frontier*的距离。使用以下代码来实现：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write a function to implement Prim''s MST algorithm, as shown here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来实现Prim的MST算法，如下所示：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, add the following code, which runs our implementation of Prim''s algorithm
    and outputs the results:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下代码，运行我们的Prim算法实现并输出结果：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the program. Your output should look as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。您的输出应如下所示：
- en: '![Figure 6.25: Output of Exercise 30'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25：练习30的输出'
- en: '](img/C14498_06_25.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_25.jpg)'
- en: 'Figure 6.25: Output of Exercise 30'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.25：练习30的输出
- en: The time complexity of Prim's algorithm is *O(E log V)* when using a binary
    min-heap and an adjacency list for storing the MST, which can be improved to *O(E
    + V log V)* when using a type of heap called the "Fibonacci min-heap."
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制最小堆和邻接表存储MST时，Prim算法的时间复杂度为*O(E log V)*，当使用一种称为“Fibonacci最小堆”的堆时，可以改进为*O(E
    + V log V)*。
- en: 'While both Prim''s and Kruskal''s are examples of greedy algorithms, they differ
    in important ways, some of which are summarized here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Prim和Kruskal都是贪婪算法的例子，但它们在一些重要方面有所不同，其中一些总结如下：
- en: '![Figure 6.26: Table comparing Kruskal’s and Prim’s algorithms](img/C14498_06_26.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图6.26：比较Kruskal和Prim算法的表](img/C14498_06_26.jpg)'
- en: 'Figure 6.26: Table comparing Kruskal''s and Prim''s algorithms'
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.26：比较Kruskal和Prim算法的表
- en: Dijkstra's Shortest Path Algorithm
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dijkstra的最短路径算法
- en: 'The single-source shortest path problem on a graph is solved every time a user
    requests a route on a route planning application such as Google Maps or in the
    navigation software built into cars. The problem is defined as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户在路线规划应用程序（如Google地图）或内置在汽车中的导航软件上请求路线时，都会解决图上的单源最短路径问题。该问题定义如下：
- en: '*"Given a directed graph, G - < V, E > where V is the set of vertices and E
    is the set of edges, each of which is associated with an edge weight, a source
    vertex, and a destination vertex, find a minimum-cost path from a source to a
    destination."*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*“给定一个有向图G - <V，E>，其中V是顶点集合，E是边集合，每条边都与边权重、源顶点和目标顶点相关联，找到从源到目标的最小成本路径。”*'
- en: 'Dijkstra''s algorithm works for graphs with non-negative edge weights and is
    only a slight modification of Prim''s MST algorithm, with two major changes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法适用于具有非负边权重的图，它只是Prim最小生成树算法的轻微修改，有两个主要变化：
- en: Instead of setting labels on every vertex equal to the minimum distance from
    the frontier, Dijkstra's algorithm sets the labels on each vertex with the distance
    equal to the total distance of the vertex from the source.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法不是将每个顶点上的标签设置为从前沿到顶点的最小距离，而是将每个顶点上的标签设置为顶点到源的总距离。
- en: Dijkstra's algorithm terminates if the destination vertex is popped from the
    heap, whereas Prim's algorithm terminates only when there are no more vertices
    left to be settled on the heap.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra算法在从堆中弹出目的地顶点时终止，而Prim算法只有在没有更多顶点需要在堆上解决时才终止。
- en: 'The working of the algorithm is illustrated in the following steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的工作如下步骤所示：
- en: First, it initializes the labels on all the vertices and sets all the distances
    to infinity. Since the distance from the starting vertex to itself is *0*, it
    sets the label of the starting vertex to *0*. Then, it adds all the labels to
    a min-heap, *H*.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，初始化所有顶点的标签，并将所有距离设置为无穷大。由于从起始顶点到自身的距离为0，因此将起始顶点的标签设置为0。然后，将所有标签添加到最小堆*H*中。
- en: 'In the following diagram, the numbers shown in red represent the current best-known
    distances from the source (vertex *2*) and the destination (vertex *6*):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，红色数字表示从源顶点（顶点2）和目标顶点（顶点6）的当前已知最佳距离：
- en: '![Figure 6.27: Initializing Dijkstra’s algorithm](img/C14498_06_27.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图6.27：初始化Dijkstra算法](img/C14498_06_27.jpg)'
- en: 'Figure 6.27: Initializing Dijkstra''s algorithm'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.27：初始化Dijkstra算法
- en: Then, it pops a vertex, *U*, from *H*. Naturally, *U* is the vertex with the
    minimum distance from the starting vertex. If *U* is the required destination,
    we have found our shortest path and the algorithm terminates.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从*H*中弹出顶点*U*。自然地，*U*是距离起始顶点最小的顶点。如果*U*是所需的目的地，则我们已经找到了最短路径，算法终止。
- en: For all vertices, *V*, adjacent to *U*, if the label of *V* > (label of *U*
    + edge weight of *(U, V)*), we have found a path to *V* that is shorter than the
    previously known minimum-cost path. Therefore, set the label of *V* to (label
    of *U* + edge weight of *(U, V)*). This step is called **settling** or **visiting**
    the vertex *U*:![](img/C14498_06_28.jpg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有邻接到*U*的顶点*V*，如果*V*的标签>(*U*的标签+ *(U，V)*的边权重)，则找到了一条到*V*的路径，其长度比先前已知的最小成本路径更短。因此，将*V*的标签设置为(*U*的标签+
    *(U，V)*的边权重)。这一步称为**解决**或**访问**顶点*U*：![](img/C14498_06_28.jpg)
- en: 'Figure 6.28: The state of the algorithm after settling vertex 1'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.28：解决顶点1后算法的状态
- en: While unvisited vertices remain in the graph, go to *step 2*. The following
    figure shows the state of the graph after settling vertex *2*:![](img/C14498_06_29.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当图中仍有未访问的顶点时，转到*步骤2*。下图显示了在解决顶点2后图的状态：![](img/C14498_06_29.jpg)
- en: 'Figure 6.29: The state of the algorithm after settling vertex 2'
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.29：解决顶点2后算法的状态
- en: 'The algorithm terminates when the destination vertex (vertex ID *6*) is popped
    from *H*. The shortest path that''s found by the algorithm from *1* to *6* is
    shown in the following figure. Also, the labels on other settled vertices show
    the shortest distance from *1* to that vertex:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当目标顶点（顶点ID为6）从H中弹出时，算法终止。算法从1到6找到的最短路径如下图所示。此外，其他已解决顶点上的标签显示了从1到该顶点的最短距离：
- en: '![Figure 6.30: The shortest path from 1 to 6](img/C14498_06_30.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图6.30：从1到6的最短路径](img/C14498_06_30.jpg)'
- en: 'Figure 6.30: The shortest path from 1 to 6'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.30：从1到6的最短路径
- en: 'Exercise 31: Implementing Dijkstra''s Algorithm'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习31：实现Dijkstra算法
- en: 'In this exercise, we shall implement Dijkstra''s algorithm to find the shortest
    path in the graph shown in *figure 6.28*. Follow these steps to complete this
    exercise:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现Dijkstra算法来找到*图6.28*中的图中的最短路径。按照以下步骤完成这个练习：
- en: 'Include the required header files and declare the graph data structure, as
    shown here:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括所需的头文件并声明图数据结构，如下所示：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Write the following struct to implement an edge in our graph implementation:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下结构来实现图中边的结构：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Overload the `<<` operator for the `Graph` class so that it can be output using
    streams, as shown here:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载`Graph`类的`<<`运算符，以便可以使用流输出，如下所示：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the graph, as shown here:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现图，如下所示：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write a function to create the reference graph shown in *figure 6.28* using
    the `Graph` class, as shown here:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，使用`Graph`类创建*图6.28*中显示的参考图，如下所示：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement Dijkstra''s algorithm, as shown here:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现Dijkstra算法，如下所示：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our implementation works in two phases – it searches for the destination vertex
    starting from the source and uses the backtracking phase, where the shortest path
    is found by following the parent pointers from the destination back to the source.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现分为两个阶段——从源顶点开始搜索目标顶点，并使用回溯阶段，在这个阶段通过从目标顶点回溯到源顶点的父指针来找到最短路径。
- en: 'Finally, add the following code to test our implementation of Dijkstra''s algorithm
    by finding the shortest path between vertices *1* and *6* in the graph:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下代码来测试我们对Dijkstra算法的实现，以找到图中顶点1和6之间的最短路径：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the program. Your output should look as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。您的输出应如下所示：
- en: '![Figure 6.31: Output of Exercise 31'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.31：练习31的输出'
- en: '](img/C14498_06_31.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_31.jpg)'
- en: 'Figure 6.31: Output of Exercise 31'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.31：练习31的输出
- en: As you can see in the preceding output, our program traces the vertices along
    the shortest path between vertices *1* and *6*. The best known running time of
    Dijkstra's algorithm is *O(E + V log V)* when Fibonacci min-heaps are used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们的程序在顶点*1*和*6*之间的最短路径上跟踪了顶点。Dijkstra算法的已知最佳运行时间是*O(E + V log V)*，当使用斐波那契最小堆时。
- en: 'Activity 14: Shortest Path in New York'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：纽约的最短路径
- en: 'In this activity, you are required to implement Dijkstra''s algorithm in C++
    so that it can be used to find the shortest path in the given road network of
    New York. Our road graph consists of 264,326 vertices and 733,846 directed edges,
    and the edge weight is the Euclidean distance between the vertices. The steps
    for this activity are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您需要在C++中实现Dijkstra算法，以便在纽约给定的道路网络中找到最短路径。我们的道路图包括264,326个顶点和733,846个有向边，边的权重是顶点之间的欧几里德距离。此活动的步骤如下：
- en: 'Download the road graph file from the following link: [https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr](https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr).'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载道路图文件：[https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr](https://raw.githubusercontent.com/TrainingByPackt/CPP-Data-Structures-and-Algorithm-Design-Principles/master/Lesson6/Activity14/USA-road-d.NY.gr)。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If the file is not automatically downloaded, and instead is opened in your browser,
    download it by right-clicking on any blank space and selecting "**Save as…**"
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件没有自动下载，而是在浏览器中打开，请右键单击任何空白处并选择“**另存为…**”进行下载
- en: If you're running Windows, move the downloaded file to `<project directory>/out/x86-Debug/Chapter6`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在运行Windows，请将下载的文件移动到`<project directory>/out/x86-Debug/Chapter6`。
- en: If you're running Linux, move the downloaded file to `<project directory>/build/Chapter6`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Linux，请将下载的文件移动到`<project directory>/build/Chapter6`。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The directory structure may vary based on your IDE. The file needs to be placed
    in the same directory as your compiled binary. Alternatively, you may tweak the
    implementation to accept a path to the file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构可能会根据您的IDE而有所不同。文件需要放在与已编译二进制文件相同的目录中。或者，您可以调整实现以接受文件路径。
- en: 'The road graph is a text file with three different kinds of rows:![Figure 6.32:
    Table describing the road graph file for New York](img/C14498_06_32.jpg)'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 道路图是一个文本文件，有三种不同类型的行：![图6.32：描述纽约道路图文件的表](img/C14498_06_32.jpg)
- en: 'Figure 6.32: Table describing the road graph file for New York'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.32：描述纽约道路图文件的表
- en: Implement a weighted edge graph. It is okay to assume that once the graph is
    created, no vertices can be added or deleted from the graph.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现加权边图。假设一旦创建了图，就不能从图中添加或删除顶点。
- en: Implement a function to parse the road graph file and populate the graph.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数来解析道路图文件并填充图。
- en: 'Implement Dijkstra''s algorithm and test your implementation by finding the
    shortest path between vertices `913` and `542`. Your output should look as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现Dijkstra算法，并通过找到顶点`913`和`542`之间的最短路径来测试您的实现。您的输出应如下所示：
- en: '![Figure 6.33: Expected output of Activity 14'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.33：活动14的预期输出'
- en: '](img/C14498_06_33.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14498_06_33.jpg)'
- en: 'Figure 6.33: Expected output of Activity 14'
  id: totrans-239
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6.33：活动14的预期输出
- en: Note
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 530.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第530页找到。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We covered three major graph problems in this chapter: first, the graph traversal
    problem for which two solutions were introduced, breadth-first search (BFS) and
    depth-first search (DFS). Second, we revisited the minimum spanning tree (MST)
    problem and solved it using Prim''s algorithm. We also compared it with Kruskal''s
    algorithm and discussed the conditions under which one should be preferred over
    the other. Finally, we introduced the single-source shortest path problem, which
    finds a minimum-cost shortest path in graphs, and covered Dijkstra''s shortest
    path algorithm.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了三个主要的图问题：首先是图遍历问题，介绍了两种解决方案，即广度优先搜索（BFS）和深度优先搜索（DFS）。其次，我们重新讨论了最小生成树（MST）问题，并使用Prim算法解决了该问题。我们还将其与Kruskal算法进行了比较，并讨论了应优先选择哪种算法的条件。最后，我们介绍了单源最短路径问题，该问题在图中寻找最小成本的最短路径，并介绍了Dijkstra的最短路径算法。
- en: However, Dijkstra's algorithm only works for graphs with positive edge weights.
    In the next chapter, we shall seek to relax this constraint and introduce a shortest
    path algorithm that can handle negative edge weights. We shall also generalize
    the shortest path problem to find the shortest paths between all the pairs of
    vertices in graphs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Dijkstra算法仅适用于具有正边权重的图。在下一章中，我们将寻求放宽此约束，并引入一种可以处理负边权重的最短路径算法。我们还将将最短路径问题概括为在图中找到所有顶点对之间的最短路径。
