- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building a Touch Screen Application with Qt 6
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt 6构建触摸屏应用程序
- en: Qt is not only a cross-platform software development kit for PC platforms; it
    also supports mobile platforms, such as iOS and Android. The developers of Qt
    introduced **Qt Quick** back in 2010, which provides an easy way to build custom
    user interfaces that are highly dynamic, where users can easily create fluid transitions
    and effects with only minimal coding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt不仅是一个适用于PC平台的跨平台软件开发工具包；它还支持移动平台，如iOS和Android。Qt的开发者在2010年引入了**Qt Quick**，它提供了一种简单的方式来构建高度动态的自定义用户界面，用户可以通过仅使用最少的编码轻松创建流畅的过渡和效果。
- en: Qt Quick uses a declarative scripting language called **QML**, which is similar
    to the **JavaScript** language used in web development. Advanced users can also
    create custom functions in C++ and port them over to Qt Quick to enhance their
    functionality. At the moment, Qt Quick supports multiple platforms, such as Windows,
    Linux, macOS, iOS, and Android.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick使用一种名为**QML**的声明性脚本语言，这与在Web开发中使用的**JavaScript**语言类似。高级用户还可以在C++中创建自定义函数并将它们移植到Qt
    Quick中，以增强其功能。目前，Qt Quick支持多个平台，如Windows、Linux、macOS、iOS和Android。
- en: 'This chapter will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Setting up Qt for mobile applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为移动应用程序设置Qt
- en: Designing a basic user interface with QML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QML设计基本用户界面
- en: Touch events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸事件
- en: Animation in QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的动画
- en: Displaying information using model/view
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型/视图显示信息
- en: Integrating QML and C++
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成QML和C++
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include Qt 6.6.1, Qt Creator 12.0.2,
    Android **Software Development Kit** (**SDK**), Android **Native Development Kit**
    (**NDK**), **Java Development Kit** (**JDK**), and Apache Ant. All the code used
    in this chapter can be downloaded from the following GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括Qt 6.6.1、Qt Creator 12.0.2、Android **软件开发工具包**（**SDK**）、Android **本地开发工具包**（**NDK**）、**Java开发工具包**（**JDK**）和Apache
    Ant。本章使用的所有代码都可以从以下GitHub仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter09)。
- en: Setting up Qt for mobile applications
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移动应用程序设置Qt
- en: In this example, we will learn how to set up our Qt project in Qt Quick and
    enable it to be built and exported to mobile devices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何在Qt Quick中设置我们的Qt项目，并使其能够构建并导出到移动设备。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s get started and learn how to create our first mobile application using
    Qt 6:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何使用Qt 6创建我们的第一个移动应用程序：
- en: 'First of all, let’s create a new project by going to **File** | **New Project…**.
    Then, a window will pop up for you to choose a project template. Select **Qt Quick
    Application** and click the **Choose...** button, as shown in the following screenshot:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过访问**文件** | **新建项目…**来创建一个新的项目。然后，将弹出一个窗口供您选择项目模板。选择**Qt Quick应用程序**并点击**选择...**按钮，如图下截图所示：
- en: '![Figure 9.1 – Create a Qt Quick application project](img/B20976_09_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 创建Qt Quick应用程序项目](img/B20976_09_001.jpg)'
- en: Figure 9.1 – Create a Qt Quick application project
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 创建Qt Quick应用程序项目
- en: After that, insert the project name and select the project location. Click the
    **Next** button, and it will ask you to select the minimum Qt version required
    for your project.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，输入项目名称并选择项目位置。点击**下一步**按钮，系统将要求您选择项目所需的最低Qt版本。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please make sure that you select a version that exists on your computer. Otherwise,
    you won’t be able to run it properly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您选择的是您计算机上存在的版本。否则，您将无法正确运行它。
- en: Once you have done that, proceed by clicking the **Next** button.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，通过点击**下一步**按钮继续。
- en: 'Then, Qt Creator will ask you which kit you want to use for your project. These
    **kits** are basically different compilers that you can use to compile your project
    for different platforms. Since we’re making an application for a mobile platform,
    we will enable the Android kit (or the iOS kit if you’re running a Mac) to build
    and export your app to your mobile device, as shown in the following screenshot.
    You can also enable one of the desktop kits so you can test your program on the
    desktop beforehand. Do note that you need to configure the Android kit if you’re
    using it for the first time so that Qt can find the directory of the Android SDK.
    Click **Next** once you’re done with it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Qt Creator将询问您希望为项目使用哪个套件。这些**套件**基本上是不同的编译器，您可以使用它们为不同的平台编译项目。由于我们正在为移动平台制作应用程序，我们将启用Android套件（如果您正在运行Mac，则为iOS套件）以构建和导出您的应用到移动设备，如下面的截图所示。您还可以启用桌面套件之一，以便您可以在桌面平台上事先测试您的程序。请注意，如果您是第一次使用Android套件，则需要配置它，以便Qt可以找到Android
    SDK的目录。完成配置后，点击**下一步**：
- en: '![Figure 9.2 – Create an Android Kit for this project](img/B20976_09_002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 为此项目创建Android套件](img/B20976_09_002.jpg)'
- en: Figure 9.2 – Create an Android Kit for this project
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 为此项目创建Android套件
- en: 'Once the project has been created, Qt Creator will automatically open up a
    file from your project called `Main.qml`. You will see a different type of script,
    as shown in the following code, that is very different from your usual C/C++ projects:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，Qt Creator将自动打开一个名为`Main.qml`的项目文件。您将看到与您通常的C/C++项目非常不同类型的脚本，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Build and run the project now by clicking on the green arrow button located
    at the bottom-left corner of your Qt Creator, as shown in *Figure 9**.3*. If you
    set the default kit to one of the desktop kits, an empty window will pop up once
    the project has been compiled:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过点击Qt Creator左下角的绿色箭头按钮来构建和运行项目，如图*图9.3*所示。如果您将默认套件设置为桌面套件之一，则在项目编译完成后将弹出一个空窗口：
- en: '![Figure 9.3 – Press the triangle button to build and run](img/B20976_09_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 点击三角形按钮进行构建和运行](img/B20976_09_003.jpg)'
- en: Figure 9.3 – Press the triangle button to build and run
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 点击三角形按钮进行构建和运行
- en: 'As shown in the next screenshot, We can switch between different kits by going
    to the Projects interface and selecting the kit you want your project to be built
    with. You can also manage all the kits available on your computer or add a new
    kit to your project from the **Projects** interface:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下一张截图所示，我们可以通过转到项目界面并选择您希望项目使用的套件来在不同的套件之间切换。您还可以从**项目**界面管理您计算机上可用的所有套件或向项目添加新的套件：
- en: '![Figure 9.4 – Change to any kits in the Projects interface](img/B20976_09_004.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 在项目界面更改任何套件](img/B20976_09_004.jpg)'
- en: Figure 9.4 – Change to any kits in the Projects interface
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 在项目界面更改任何套件
- en: 'If this is your first time building and running your project, you need to create
    a template for the Android kit under the **Build** settings. Once you have clicked
    the **Create Templates** button under the **Build Android APK** tab, as shown
    in *Figure 9**.5*, Qt will generate all the files required to run your app on
    an Android device. If you don’t plan to use Gradle in your project, disable the
    **Copy the Gradle files to Android directory** option. Otherwise, you may encounter
    problems when trying to compile and deploy your app to your mobile device:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次构建和运行项目，您需要在**构建**设置下为Android套件创建一个模板。一旦您在**构建Android APK**标签页下点击了**创建模板**按钮，如图*图9.5*所示，Qt将生成运行您的应用所需的全部文件。如果您不打算在项目中使用Gradle，请禁用**将Gradle文件复制到Android目录**选项。否则，在尝试编译和部署您的应用到移动设备时可能会遇到问题：
- en: '![Figure 9.5 – Click the Create Templates button to create an Android template
    file](img/B20976_09_005.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 点击创建模板按钮以创建Android模板文件](img/B20976_09_005.jpg)'
- en: Figure 9.5 – Click the Create Templates button to create an Android template
    file
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 点击创建模板按钮以创建Android模板文件
- en: 'Once you click the `AndroidManifest.xml`, Gradle-related files, and other resources
    that are required by the Android platform. Let’s open up the `AndroidManifest.xml`
    file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦点击`AndroidManifest.xml`、与Gradle相关的文件以及Android平台所需的其它资源。让我们打开`AndroidManifest.xml`文件：
- en: '![Figure 9.6 – Set your app’s settings in AndroidManifest.xml](img/B20976_09_006.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 在AndroidManifest.xml中设置您的应用设置](img/B20976_09_006.jpg)'
- en: Figure 9.6 – Set your app’s settings in AndroidManifest.xml
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 在AndroidManifest.xml中设置您的应用设置
- en: Once you have opened `AndroidManifest.xml`, you can set your app’s package name,
    version code, app icon, and permissions before exporting the app. To build and
    test your Android app, click on the **Run** button on Qt Creator. You should now
    see the following window pop up, asking which device it should export to.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您打开了`AndroidManifest.xml`，您可以在导出应用程序之前设置您的应用程序包名、版本代码、应用程序图标和权限。要构建和测试您的Android应用程序，请点击Qt
    Creator上的**运行**按钮。现在您应该会看到一个窗口弹出，询问它应该导出到哪个设备。
- en: Select the device that is currently connected to your computer and press the
    **OK** button. Wait for a while for it to build the project, and you should be
    able to get a blank app running on your mobile device.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前连接到您电脑的设备，并按下**确定**按钮。等待片刻，让它构建项目，您应该能够在您的移动设备上运行一个空白的应用程序。
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Qt Quick application project is quite different from a widget application
    project. You will be writing QML script most of the time instead of writing C/C++
    code. **Android Software Development Kit** (**SDK**), **Android Native Development
    Kit** (**NDK**), **Java Development Kit** (**JDK**), and **Apache Ant** are required
    to build and export your app to the Android platform.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick应用程序项目与窗口应用程序项目有很大不同。您大部分时间将编写QML脚本而不是C/C++代码。**Android软件开发工具包**（**SDK**）、**Android本地开发工具包**（**NDK**）、**Java开发工具包**（**JDK**）和**Apache
    Ant**是构建并将您的应用程序导出到Android平台所必需的。
- en: 'Alternatively, you can also use Gradle instead of Apache Ant for your Android
    kit. All you need to do is enable the **Use Gradle** instead of Ant option and
    provide Qt with Gradle’s installation path. Note that Android Studio is currently
    (at the time of authoring this book) not supported by Qt Creator:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用Gradle而不是Apache Ant来构建您的Android套件。您需要做的只是启用**使用Gradle**而不是Ant选项，并给Qt提供Gradle的安装路径。请注意，截至本书编写时，Android
    Studio目前不支持Qt Creator：
- en: '![Figure 9.7 – Set up your Android settings in the Android tab in the Preferences
    window](img/B20976_09_007.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 在首选项窗口的Android选项卡中设置您的Android设置](img/B20976_09_007.jpg)'
- en: Figure 9.7 – Set up your Android settings in the Android tab in the Preferences
    window
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 在首选项窗口的Android选项卡中设置您的Android设置
- en: If you’re running the app on an Android device, make sure that you have **USB
    debugging mode** enabled. To enable USB debugging mode, you need to first enable
    the developer options on your Android device by going to **Settings | About Phone**
    and tapping **Build Number** seven times. After that, go to **Settings | Developer
    Options**, and you will see the **USB debugging** option in the menu. Enable that
    option, and you can now export your app to your device for testing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Android设备上运行应用程序，请确保您已启用**USB调试模式**。要启用USB调试模式，您需要首先通过转到**设置 | 关于手机**并点击**构建号**七次来启用您的Android设备上的开发者选项。之后，转到**设置
    | 开发者选项**，您将在菜单中看到**USB调试**选项。启用该选项，您现在可以将应用程序导出到您的设备进行测试。
- en: To build for the iOS platform, you need to run Qt Creator on a Mac and make
    sure the latest **Xcode** is installed on your Mac as well. To test your app on
    an iOS device, you need to register a developer account with Apple, register your
    device at the developer portal, and install the provisioning to your **Xcode**,
    which is a lot trickier than Android. You will be given access to the developer
    portal once you have obtained a developer account from Apple.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要为iOS平台构建，您需要在Mac上运行Qt Creator，并确保您的Mac上已安装最新的**Xcode**。要在iOS设备上测试您的应用程序，您需要向Apple注册一个开发者账户，在开发者门户注册您的设备，并将配置文件安装到您的**Xcode**中，这比Android复杂得多。一旦您从Apple获得开发者账户，您将获得对开发者门户的访问权限。
- en: Designing a basic user interface with QML
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QML设计基本用户界面
- en: This example will teach us how to use Qt Design Studio to design our program’s
    user interface.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本例将教会我们如何使用Qt Design Studio来设计我们程序的用户界面。
- en: How to do it…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s follow these steps to get started:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'First of all, create a new **Qt Quick application** project, just like we did
    in the previous recipe. This time, however, make sure you check on the **Creates
    a project that you can open in Qt Design Studio** option as well:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的**Qt Quick应用程序**项目，就像我们在前面的食谱中所做的那样。然而，这次，请确保您还勾选了**创建一个可以在Qt Design
    Studio中打开的项目**选项：
- en: '![Figure 9.8 – Make sure your project can be opened by Qt Design Studio](img/B20976_09_008.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 确保您的项目可以被Qt Design Studio打开](img/B20976_09_008.jpg)'
- en: Figure 9.8 – Make sure your project can be opened by Qt Design Studio
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 确保您的项目可以被Qt Design Studio打开
- en: You will see a QML file in your project resources called `main.qml`. This is
    where we implement the logic for our application, but we will also need another
    QML file where we define our user interface.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在项目资源中看到一个名为`main.qml`的QML文件。这是我们实现应用程序逻辑的地方，但我们还需要另一个QML文件来定义我们的用户界面。
- en: 'Before we proceed to design our program’s user interface, let’s download and
    install **Qt Design Studio** from Qt’s official website: [https://www.qt.io/product/ui-design-tools](https://www.qt.io/product/ui-design-tools).
    This is a new editor created by Qt for UI/UX designers to design user interfaces
    for their Qt Quick projects.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续设计程序的用户界面之前，让我们从Qt的官方网站下载并安装**Qt Design Studio**：[https://www.qt.io/product/ui-design-tools](https://www.qt.io/product/ui-design-tools)。这是一个Qt为UI/UX设计师创建的新编辑器，用于设计他们的Qt
    Quick项目的用户界面。
- en: 'Once you have installed `.qmlproject` file in your project directory by pressing
    the **Open** **Project…** button:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您通过按下**打开项目…**按钮将`.qmlproject`文件安装到项目目录中：
- en: '![Figure 9.9 – Click the Open Project … button](img/B20976_09_009.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 点击“打开项目…”按钮](img/B20976_09_009.jpg)'
- en: Figure 9.9 – Click the Open Project … button
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 点击“打开项目…”按钮
- en: After that, a default QML UI file called `Sreen01.ui.qml` will be opened by
    **Qt Design Studio**. You will see an entirely different user interface editor
    compared to the one we used in previous chapters.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，**Qt Design Studio**将打开一个默认的QML UI文件，名为`Sreen01.ui.qml`。您将看到一个与之前章节中使用的完全不同的用户界面编辑器。
- en: 'Since Qt 6, the Qt team released the **Qt Design Studio**, which is a new editor
    used specifically to design user interfaces for Qt Quick projects. The components
    of this editor are described as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从Qt 6以来，Qt团队发布了**Qt Design Studio**，这是一个专门用于为Qt Quick项目设计用户界面的新编辑器。该编辑器的组件描述如下：
- en: '**Components**: The **Components** window displays all the predefined QML types
    that you can add to your user interface canvas. You can also create custom Qt
    Quick components from the Create Component button and display them here.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：**组件**窗口显示您可以添加到用户界面画布上的所有预定义QML类型。您还可以从创建组件按钮创建自定义Qt Quick组件，并将它们显示在这里。'
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file in a tree structure.'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航器**：**导航器**窗口以树状结构显示当前QML文件中的项目。'
- en: '**Connections**: You can use the tools provided in the **Connections** window
    to connect objects to signals, specify dynamic properties for objects, and create
    bindings between the properties of two objects.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：您可以使用**连接**窗口中提供的工具将对象连接到信号，指定对象的动态属性，并在两个对象的属性之间创建绑定。'
- en: '**States**: The **States** window displays the different states of an item.
    You can add a new state for an item by clicking on the **+** button on the right
    of the **State** window.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：**状态**窗口显示项目的不同状态。您可以通过点击**状态**窗口右侧的**+**按钮为项目添加一个新状态。'
- en: '**2D/3D Canvas**: The canvas is where you design your program’s user interface.
    You can drag and drop a **Qt Quick** component from the **Components** window
    onto the canvas and instantly see what it will look like in the program. You can
    create a 2D or 3D canvas for different types of applications.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D/3D画布**：画布是您设计程序用户界面的地方。您可以从“组件”窗口中将一个**Qt Quick**组件拖放到画布上，并立即看到它在程序中的样子。您可以为不同类型的应用程序创建2D或3D画布。'
- en: '**Properties**: This is where you change the properties of a selected item.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这是您更改所选项目属性的地方。'
- en: 'You can also select pre-defined workspaces for your **Qt Design Studio** editor
    by selecting from the drop-down box in the top-right corner:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过在右上角的下拉框中选择来为您的**Qt Design Studio**编辑器选择预定义的工作空间：
- en: '![Figure 9.10 – Select a pre-defined workspace](img/B20976_09_010.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 选择预定义的工作空间](img/B20976_09_010.jpg)'
- en: Figure 9.10 – Select a pre-defined workspace
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 选择预定义的工作空间
- en: We’re about to make a simple login screen. First, delete the editing components
    from the 2D canvas. Then, from the **Components** window, drag two text widgets
    onto the canvas.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们即将制作一个简单的登录屏幕。首先，从2D画布中删除编辑组件。然后，从“组件”窗口中拖动两个文本小部件到画布上。
- en: 'Set the `Username:` and `Password:`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`用户名:`和`密码:`：
- en: '![Figure 9.11 – Set the Text property](img/B20976_09_011.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11 – 设置文本属性](img/B20976_09_011.jpg)'
- en: Figure 9.11 – Set the Text property
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 设置文本属性
- en: Drag two rectangles from the `1` and the `5`. Then, set the echo mode of one
    of the text fields to **Password**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`1`和`5`拖动两个矩形。然后，将其中一个文本字段的回显模式设置为**密码**。
- en: Now, we’re going to manually create a button widget by combining a mouse area
    widget with a rectangle and a text widget. Drag a mouse area widget onto the canvas,
    then drag a rectangle and a text widget onto the canvas and parent them both to
    the mouse area. Set the color of the rectangle to `#bdbdbd`, then set its `1`
    and its `5`. Then, set the `Login` and make sure the size of the mouse area is
    the same as the rectangle.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过将鼠标区域小部件与矩形和文本小部件组合来手动创建一个按钮小部件。将鼠标区域小部件拖放到画布上，然后拖动矩形和文本小部件到画布上，并将它们都设置为鼠标区域的小部件。将矩形的颜色设置为`#bdbdbd`，然后设置其`1`和`5`。然后，设置`Login`并确保鼠标区域的大小与矩形相同。
- en: After that, drag another rectangle onto the canvas to act as the container for
    the login form so that it will look neat. Set its `#5e5858` and its `2`. Then,
    set its `5` to make its corners look a little rounded.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将另一个矩形拖放到画布上，作为登录表单的容器，使其看起来整洁。将其颜色设置为`#5e5858`，然后设置其`2`。然后，设置其`5`以使其角落看起来稍微圆润一些。
- en: 'Make sure the rectangle that we added in the previous step is positioned at
    the top of the hierarchy in the **Navigator** window so that it appears behind
    all the other widgets. You can arrange the widget positions within the hierarchy
    by pressing the arrow buttons located at the top of the **Navigator** window as
    follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们在上一步中添加的矩形在**导航器**窗口的层次结构顶部定位，这样它就会出现在所有其他小部件的后面。你可以通过按下**导航器**窗口顶部的箭头按钮来安排层次结构内的小部件位置，如下所示：
- en: '![Figure 9.12 – Click the Move up button](img/B20976_09_012.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12 – 点击向上移动按钮](img/B20976_09_012.jpg)'
- en: Figure 9.12 – Click the Move up button
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 点击向上移动按钮
- en: 'Next, we will export three widgets: mouse area and the two text input widgets
    as the alias properties of the root item so that later on, we can access these
    widgets from the `App.qml` file. The widgets can be exported by clicking on the
    small icon behind the widget name and making sure the icon changes to the **On**
    status.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导出三个小部件：鼠标区域和两个文本输入小部件作为根项的别名属性，这样我们就可以在以后从`App.qml`文件中访问这些小部件。可以通过点击小部件名称后面的图标来导出小部件，并确保图标变为**开启**状态。
- en: 'By now, your user interface should look something like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你的用户界面应该看起来像这样：
- en: '![Figure 9.13 – A simple login screen](img/B20976_09_013.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13 – 一个简单的登录屏幕](img/B20976_09_013.jpg)'
- en: Figure 9.13 – A simple login screen
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 – 一个简单的登录屏幕
- en: Now, let’s open up `App.qml`. Qt Creator will not open this file in `Screen01.ui.qml`,
    and `App.qml` is only used for defining the logic and functions that will be applied
    to the UI. You can, however, open it with Qt Design Studio to preview the user
    interface by clicking on the **Design** button located in the sidebar on the left
    of the editor.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开`App.qml`。Qt Creator不会在`Screen01.ui.qml`中打开这个文件，`App.qml`仅用于定义将应用于UI的逻辑和函数。然而，你可以通过点击编辑器左侧侧边栏上的**设计**按钮，使用Qt
    Design Studio打开它来预览用户界面。
- en: 'At the top of the script, add the third line to import the dialog module to
    `App.qml`, as shown in the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本顶部，将第三行添加到`App.qml`中导入对话框模块，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, replace the following code with this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将以下代码替换为这个：
- en: '[PRE2]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We continue to define `messageDialog` as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续定义`messageDialog`如下：
- en: '[PRE3]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build and run this program on your PC, and you should get a simple program
    that shows a message box when you click on the **Login** button:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的PC上构建并运行这个程序，你应该得到一个简单的程序，当你点击**登录**按钮时会显示一个消息框：
- en: '![Figure 9.14 – A message box showing after clicking on the Login button](img/B20976_09_014.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14 – 点击登录按钮后显示的消息框](img/B20976_09_014.jpg)'
- en: Figure 9.14 – A message box showing after clicking on the Login button
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 – 点击登录按钮后显示的消息框
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since Qt 5.4, a new file extension called `.ui.qml` has been introduced. The
    QML engine handles it like the normal `.qml` files but forbids any logic implementation
    from being written in it. It serves as the user interface definition template
    that can be reused in different `.qml` files. The separation of UI definition
    and logic implementation improves the maintainability of QML code and creates
    a better workflow.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Qt 5.4以来，引入了一个新的文件扩展名`.ui.qml`。QML引擎像处理正常的`.qml`文件一样处理它，但禁止在其中编写任何逻辑实现。它作为用户界面定义模板，可以在不同的`.qml`文件中重用。UI定义和逻辑实现的分离提高了QML代码的可维护性，并创建了一个更好的工作流程。
- en: Since Qt 6, `.ui.qml` files have no longer been handled by Qt Creator. Instead,
    Qt provides you with another program called Qt Design Studio to edit your Qt Quick
    UI. They intend to give programmers and designers their separate tools that fit
    their workflow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Qt 6以来，`.ui.qml`文件不再由Qt Creator处理。相反，Qt为您提供了一个名为Qt Design Studio的程序来编辑您的Qt
    Quick UI。他们打算为程序员和设计师提供适合他们工作流程的独立工具。
- en: 'All the widgets under **Basic** are the most basic widgets that we can use
    to mix and match and create a new type of widget, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**基本**下的所有小部件是我们可以用以混合匹配并创建新类型小部件的最基本小部件，如下所示：'
- en: '![Figure 9.15 – Drag and drop widgets from here](img/B20976_09_015.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15 – 从这里拖放小部件](img/B20976_09_015.jpg)'
- en: Figure 9.15 – Drag and drop widgets from here
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 从这里拖放小部件
- en: 'In the previous example, we learned how to put three widgets together—a text,
    a mouse area, and a rectangle—to form a button widget. You can also create your
    custom component by clicking the **Create Component** button at the top right
    corner:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何将三个小部件组合在一起——一个文本、一个鼠标区域和一个矩形——以形成一个按钮小部件。您也可以通过点击右上角的**创建组件**按钮来创建自己的自定义组件：
- en: '![Figure 9.16 – You can also create your custom component](img/B20976_09_016.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图9.16 – 您也可以创建自己的自定义组件](img/B20976_09_016.jpg)'
- en: Figure 9.16 – You can also create your custom component
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 您也可以创建自己的自定义组件
- en: We imported the `QtQuick.Dialogs` module in `App.qml` and created a message
    box that displays the username and password filled in by the user when the `Screen01.ui.qml`,
    we will not be able to access their properties in `App.qml`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`App.qml`中导入了`QtQuick.Dialogs`模块，并创建了一个显示用户在`Screen01.ui.qml`中填写的用户名和密码的消息框。当我们在`App.qml`中无法访问它们的属性。
- en: At this point, we can export the program to iOS and Android, but the user interface
    may not look accurate on some of the devices that have a higher resolution or
    a higher **density-per-pixel** (**DPI**) unit. We will cover this issue later
    on in this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以将程序导出到iOS和Android，但用户界面在某些具有更高分辨率或更高**每像素密度**（DPI）单位的设备上可能看起来不准确。我们将在本章后面讨论这个问题。
- en: Touch events
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸事件
- en: In this section, we will learn how to develop a touch-driven application that
    runs on mobile devices using Qt Quick.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用Qt Quick开发一个在移动设备上运行的触摸驱动应用程序。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s get started by following this step-by-step guide:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤一步步开始：
- en: Create a new **Qt Quick** **application** project.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**Qt Quick** **应用程序**项目。
- en: 'In Qt Design Studio, click on the `tux.png` and add it to the project as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Design Studio中，点击`tux.png`并将其按照以下方式添加到项目中：
- en: '![Figure 9.17 – Import tux.png into your project](img/B20976_09_017.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17 – 将tux.png导入到您的项目中](img/B20976_09_017.jpg)'
- en: Figure 9.17 – Import tux.png into your project
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 将tux.png导入到您的项目中
- en: Next, open up `Screen01.ui.qml`. Drag an image widget from the `tux.png` and
    set its `200` and its `20`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`Screen01.ui.qml`。从`tux.png`拖动一个图像小部件，并设置其`200`和`20`。
- en: Make sure that both the mouse area widget and the image widget are exported
    as the alias properties of the root item by clicking on the small icon beside
    their respective widget name.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过点击它们各自小部件名称旁边的小图标，将鼠标区域小部件和图像小部件都导出为根项的别名属性。
- en: 'After that, switch over to the script editor by clicking on the **Edit** button
    on the sidebar located on the left side of the editor. We need to change the mouse
    area widget to a multi-point touch area widget, as in the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过点击位于编辑器左侧侧边栏上的**编辑**按钮，切换到脚本编辑器。我们需要将鼠标区域小部件更改为多点触摸区域小部件，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also set the **Image** widget to be automatically placed at the center of
    the window by default, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还设置了**图像**小部件默认自动放置在窗口中心，如下所示：
- en: '[PRE5]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final user interface should look something like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终用户界面应该看起来像这样：
- en: '![Figure 9.18 – Place the penguin in your application window](img/B20976_09_018.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图9.18 – 将企鹅放置到您的应用程序窗口中](img/B20976_09_018.jpg)'
- en: Figure 9.18 – Place the penguin in your application window
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 – 将企鹅放置到您的应用程序窗口中
- en: 'Once you’re done with that, let’s open up `App.qml`. First, clear everything
    within the `anchors.fill: parent`, as shown in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '完成这些操作后，让我们打开`App.qml`。首先，清除`anchors.fill: parent`内的所有内容，如下面的代码所示：'
- en: '[PRE6]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, declare several variables within the **MainForm** object that will
    be used to rescale the image widget. If you want to know more about the property
    keyword used in the following code, check out the **There’s more…** section at
    the end of this example:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在**MainForm**对象中声明几个变量，这些变量将用于重新缩放图像小部件。如果您想了解更多关于以下代码中使用的属性关键字的信息，请查看本例末尾的**更多内容**部分：
- en: '[PRE7]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the following code, we will define what will happen when our finger touches
    the multi-point area widget. In this case, we will save the positions of the first
    and second touch points if more than one finger touches the multi-point touch
    area. We also save the width and height of the image widget so that, later on,
    we can use these variables to calculate the scale of the image when the fingers
    start to move:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将定义当我们的手指触摸多点区域小部件时会发生什么。在这种情况下，如果多于一个手指触摸多点触摸区域，我们将保存第一个和第二个触摸点的位置。我们还保存了图像小部件的宽度和高度，以便稍后我们可以使用这些变量来计算手指开始移动时图像的缩放比例：
- en: '[PRE8]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following diagram shows the example of touch points being registered when
    two fingers are touching the screen within the `touchArea` boundary. The `touchArea.touchPoints[0]`
    is the first registered touch point, and `touchArea.touchPoints[1]` is the second.
    We then calculate the X and Y distance between the two touch points and save them
    as `prevDistX` and `prevDistY`, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图表显示了当两个手指在`touchArea`边界内触摸屏幕时注册的触摸点示例。`touchArea.touchPoints[0]`是第一个注册的触摸点，`touchArea.touchPoints[1]`是第二个。然后我们计算两个触摸点之间的X和Y距离，并将它们保存为`prevDistX`和`prevDistY`，如下所示：
- en: '![Figure 9.19 – Calculate the distances between two touch points](img/B20976_09_019.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图9.19 – 计算两个触摸点之间的距离](img/B20976_09_019.jpg)'
- en: Figure 9.19 – Calculate the distances between two touch points
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 – 计算两个触摸点之间的距离
- en: 'After that, we will define what will happen when our fingers move while remaining
    in contact with the screen and still within the boundary of the touch area using
    the following code. At this point, we will calculate the scale of the image by
    using the variables we saved in the previous step. At the same time, if we detect
    that only a single touch is found, then we will move the image instead of altering
    its scale:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将使用以下代码定义当我们的手指在保持与屏幕接触并仍在触摸区域边界内移动时会发生什么。在此点，我们将通过使用之前步骤中保存的变量来计算图像的缩放比例。同时，如果我们检测到只有一个触摸，那么我们将移动图像而不是改变其缩放比例：
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following diagram shows the example of moving touch points; `touchArea.touchPoints[0]`
    moved from point A to point B, and `touchArea.touchPoints[1]` moved from point
    C to point D. We can then determine how many units have the touch points moved
    by looking at the differences between the previous X, and Y variables with the
    current ones:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下图表显示了移动触摸点的示例；`touchArea.touchPoints[0]`从点A移动到点B，`touchArea.touchPoints[1]`从点C移动到点D。然后我们可以通过查看先前X和Y变量与当前变量的差异来确定触摸点移动了多少单位：
- en: '![Figure 9.20 – Compare two sets of touch points to determine movement](img/B20976_09_020.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图9.20 – 比较两组触摸点以确定移动](img/B20976_09_020.jpg)'
- en: Figure 9.20 – Compare two sets of touch points to determine movement
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 – 比较两组触摸点以确定移动
- en: You can now build and export the program to your mobile device. You will not
    be able to test this program on a platform that does not support multi-touch.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以构建并将程序导出到您的移动设备上。您将无法在不支持多点触控的平台测试此程序。
- en: 'Once the program is running on the mobile device (or a desktop/laptop that
    supports multi-touch), try two things—put only one finger on the screen and move
    it around, and put two fingers on the screen and move them in opposite directions.
    What you should see is that the penguin will be moved to another place if you
    use only one finger, and it will be scaled up or down if you use two fingers,
    as shown in the following screenshot:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦程序在移动设备（或支持多点触控的桌面/笔记本电脑）上运行，尝试两件事——只将一个手指放在屏幕上并移动它，以及将两个手指放在屏幕上并朝相反方向移动。你应该看到，如果你只使用一个手指，企鹅将被移动到另一个地方，如果你使用两个手指，它将放大或缩小，如以下截图所示：
- en: '![Figure 9.21 – Scaling up and down using your fingers](img/B20976_09_021.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图9.21 – 使用手指放大和缩小](img/B20976_09_021.jpg)'
- en: Figure 9.21 – Scaling up and down using your fingers
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 – 使用手指放大和缩小
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: When a finger touches the screen of the device, the multi-point touch area widget
    triggers the `onPressed` event and registers the position of each of the touch
    points in an internal array. We can get these data by telling Qt which touch point
    we want to get access to. The first touch will bear the index number of 0, the
    second touch will be 1, and so on. We will then save these data into variables
    so that we can retrieve them later to calculate the scaling of the penguin image.
    Other than `onPressed`, you can also use `onReleased` if you want the event to
    be triggered when the user releases his/her finger from the touch area.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当手指触摸设备的屏幕时，多点触控区域小部件将触发`onPressed`事件并记录每个触摸点的位置在一个内部数组中。我们可以通过告诉Qt我们想要获取哪个触摸点来获取这些数据。第一个触摸点将具有索引号0，第二个触摸点将是1，依此类推。然后我们将这些数据保存到变量中，以便我们可以在以后检索它们来计算企鹅图像的缩放。除了`onPressed`之外，如果您想在用户从触摸区域释放手指时触发事件，也可以使用`onReleased`。
- en: When one or more fingers remain in contact with the screen while moving, a multi-point
    touch area will trigger the `onUpdated` event. We will then check how many touches
    there are; if only one touch is found, we will just move the penguin image based
    on how much our finger has moved. If there is more than one touch, we will compare
    the distance between the two touches and compare this with the previous variables
    we have saved to determine how much we should rescale the image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '当一个或多个手指在移动时保持与屏幕接触，多点触控区域将触发`onUpdated`事件。然后我们将检查有多少个触摸点；如果只找到一个触摸点，我们只需根据我们的手指移动的距离移动企鹅图像。如果有多个触摸点，我们将比较两个触摸点之间的距离，并将其与我们之前保存的变量进行比较，以确定我们应该重新缩放图像多少。 '
- en: 'The diagram shows tapping your finger on the screen will trigger the `onPressed`
    event, while swiping your finger on the screen will trigger the `onUpdated` event:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示，在屏幕上轻触手指将触发`onPressed`事件，而在屏幕上滑动手指将触发`onUpdated`事件：
- en: '![Figure 9.22 – Difference between onPressed and onUpdated](img/B20976_09_022.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图9.22 – onPressed和onUpdated之间的区别](img/B20976_09_022.jpg)'
- en: Figure 9.22 – Difference between onPressed and onUpdated
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 – onPressed和onUpdated之间的区别
- en: We must also check whether the first touch is on the left side or if the second
    touch is on the right side. In this way, we can prevent the image from being scaled
    in the inverse direction of the finger movement and producing an inaccurate result.
    As for the movement of the penguin, we will just get the difference between the
    current touch position and the previous one and add that to the coordinate of
    the penguin; after this, it’s done. A single touch event is usually a lot more
    straightforward than a multi-touch event.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须检查第一个触摸点是否在左侧，或者第二个触摸点是否在右侧。这样，我们可以防止图像以手指移动的反方向缩放并产生不准确的结果。至于企鹅的移动，我们只需获取当前触摸位置与上一个位置之间的差异，并将其添加到企鹅的坐标中；然后，就完成了。单点触摸事件通常比多点触摸事件更直接。
- en: There’s more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In Qt Quick, all its components have built-in properties, such as `int`, `float`,
    and so on) keyword; here is an example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中，所有组件都内置了属性，例如`int`、`float`等关键字；以下是一个示例：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also bind the custom `property` to a value by using a colon (`:`) before
    the value, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在值之前使用冒号（`:`）将自定义`property`绑定到值，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'To learn more about the property types supported by Qt Quick, check out this
    link: [http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Qt Quick支持的属性类型，请查看此链接：[http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-6/qtqml-typesystem-basictypes.html)。
- en: Animation in QML
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QML中的动画
- en: Qt allows us to easily animate a user interface component without writing a
    bunch of code. In this example, we will learn how to make our program’s user interface
    more interesting by applying animations to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Qt允许我们轻松地通过编写大量代码来对用户界面组件进行动画处理。在本例中，我们将学习如何通过应用动画使我们的程序用户界面更加有趣。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let’s learn how to add animation to our Qt Quick application by following these
    steps:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤学习如何为我们的Qt Quick应用程序添加动画：
- en: Once again, we will start everything from scratch. Therefore, create a new `Screen01.ui.qml`
    file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将从头开始。因此，创建一个新的`Screen01.ui.qml`文件。
- en: Open up `Screen01.ui.qml` and go to the `QtQuick.Controls` to your project.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Screen01.ui.qml`文件并转到您的项目中的`QtQuick.Controls`。
- en: After that, you will see a new category appear in the **QML Types** tab called
    **QtQuick Controls**, which contains many new widgets that can be placed on the
    canvas.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你将在 **QML Types** 选项卡中看到一个新类别，称为 **QtQuick Controls**，其中包含许多可以放置在画布上的新小部件。
- en: 'Next, drag three button widgets to the canvas and set their `45`. Then, go
    to the `0`. This will make the buttons resize horizontally according to the width
    of the main window. After that, set the y value of the first button to `0`, the
    second to `45`, and the third to `90`. The user interface should now look like
    this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将三个按钮小部件拖到画布上，并设置它们的 `45`。然后，转到 `0`。这将使按钮根据主窗口的宽度水平调整大小。之后，将第一个按钮的 y 值设置为
    `0`，第二个设置为 `45`，第三个设置为 `90`。现在，用户界面应该看起来像这样：
- en: '![Figure 9.23 – Add three buttons to the layout](img/B20976_09_023.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.23 – 在布局中添加三个按钮](img/B20976_09_023.jpg)'
- en: Figure 9.23 – Add three buttons to the layout
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23 – 在布局中添加三个按钮
- en: 'Now, open up the `fan.png` to the project, as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `fan.png` 打开到项目中，如下所示：
- en: '![Figure 9.24 – Add fan.png to your project](img/B20976_09_024.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.24 – 将 fan.png 添加到你的项目中](img/B20976_09_024.jpg)'
- en: Figure 9.24 – Add fan.png to your project
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.24 – 将 fan.png 添加到你的项目中
- en: Then, add two mouse area widgets to the canvas. After that, drag a **Rectangle**
    widget and an **Image** widget onto the canvas. Parent the rectangle and image
    to the mouse areas we have just added before this.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在画布上添加两个鼠标区域小部件。之后，将一个 **Rectangle** 小部件和一个 **Image** 小部件拖到画布上。将矩形和图像设置为之前添加的鼠标区域的父级。
- en: 'Set the `#0000ff` and apply `fan.png` to the image widget. Your user interface
    should now look like this:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `#0000ff` 并将 `fan.png` 应用到图像小部件上。现在，你的用户界面应该看起来像这样：
- en: '![Figure 9.25 – Place a rectangle and the fan image in the layout](img/B20976_09_025.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.25 – 在布局中放置矩形和风扇图像](img/B20976_09_025.jpg)'
- en: Figure 9.25 – Place a rectangle and the fan image in the layout
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.25 – 在布局中放置矩形和风扇图像
- en: 'After that, export all the widgets in your `Screen01.ui.qml` as alias properties
    of the root item by clicking on the icons located to the right of the widget name,
    as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过单击小部件名称右侧的图标，将你的 `Screen01.ui.qml` 中的所有小部件导出为根项的别名属性，如下所示：
- en: '![Figure 9.26 – Adding aliases to the widgets](img/B20976_09_026.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.26 – 向小部件添加别名](img/B20976_09_026.jpg)'
- en: Figure 9.26 – Adding aliases to the widgets
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.26 – 向小部件添加别名
- en: Next, we will apply animation and logic to the user interface, but we won’t
    be doing it in `Screen01.ui.qml`. Instead, we will do it all in `App.qml`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将应用动画和逻辑到用户界面，但不会在 `Screen01.ui.qml` 中进行。相反，我们将在 `App.qml` 中完成所有操作。
- en: 'In `App.qml`, remove the default code for the mouse area and add in a **width**
    and **height** for the window so that we get more space to preview, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App.qml` 中，移除鼠标区域的默认代码，并添加窗口的 **width** 和 **height**，以便我们获得更多空间进行预览，如下所示：
- en: '[PRE12]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, add the following code that defines the behavior of the buttons
    in the **Screen01** widget:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加以下代码，该代码定义了 `Screen01` 小部件中按钮的行为：
- en: '[PRE13]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following code, we continue to define `button3`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们继续定义 `button3`：
- en: '[PRE14]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, follow this with the behavior of the fan image and the mouse area widget
    it is attached to as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式继续添加风扇图像及其附加的鼠标区域小部件的行为：
- en: '[PRE15]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the following code, we then define `mouseArea1`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们接着定义 `mouseArea1`：
- en: '[PRE16]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Last but not least, add the behavior of the rectangle and the mouse area widget
    it’s attached to as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，按照以下方式添加矩形及其附加的鼠标区域小部件的行为：
- en: '[PRE17]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following code, we continue to add the `RED` state:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们继续添加 `RED` 状态：
- en: '[PRE18]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then finish the code by defining `mouseArea2` as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着通过如下定义 `mouseArea2` 来完成代码：
- en: '[PRE19]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you compile and run the program now, you should see three buttons at the
    top of the window and a moving rectangle at the bottom left, followed by a spinning
    fan at the bottom right, as demonstrated in the following screenshot. If you click
    any of the buttons, they will move slightly downward with a nice, smooth animation.
    If you click on the rectangle, it will change color from **blue** to **red**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在编译并运行程序，你应该在窗口顶部看到三个按钮，在左下角看到一个移动的矩形，在右下角看到一个旋转的风扇，如下面的截图所示。如果你点击任何按钮，它们将稍微向下移动，并带有流畅的动画。如果你点击矩形，它将从
    **蓝色** 变为 **红色**。
- en: 'Meanwhile, the fan image will pause its animation if you click on it while
    it’s animating, and it will resume the animation if you click on it again:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，如果你在风扇图像动画时点击它，它将暂停动画；如果你再次点击，它将恢复动画：
- en: '![Figure 9.27 – You can now control the animation and color of the widgets](img/B20976_09_027.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图9.27 – 现在您可以控制小部件的动画和颜色](img/B20976_09_027.jpg)'
- en: Figure 9.27 – You can now control the animation and color of the widgets
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 – 现在您可以控制小部件的动画和颜色
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Most of the animation elements supported by the C++ version of Qt, such as transition,
    sequential animation, and parallel animation, are also available in Qt Quick.
    If you are familiar with the Qt animation framework in C++, you should be able
    to grasp this pretty easily.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数C++版本的Qt支持的动画元素，如过渡、顺序动画和并行动画，在Qt Quick中也是可用的。如果您熟悉C++中的Qt动画框架，您应该能够很容易地掌握这一点。
- en: In this example, we added a spring animation element to all three buttons that
    specifically tracked their respective y-axes. If Qt detects that the y value has
    changed, the widget will not instantly pop to the new position; instead, it will
    be interpolated, move across the canvas, and perform a little shaking animation
    when reaching its destination that simulates the spring effect. We just have to
    write one line of code and leave the rest to Qt.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为所有三个按钮添加了一个弹簧动画元素，该元素专门跟踪各自的y轴。如果Qt检测到y值已更改，小部件不会立即弹跳到新位置；相反，它将被插值，在画布上移动，并在到达目的地时执行轻微的震动动画，以模拟弹簧效果。我们只需写一行代码，其余的交给Qt处理。
- en: As for the fan image, we added a rotation animation element to it and set the
    duration to `1000 milliseconds`, which means it will complete a full rotation
    in one second. We also set it to loop its animation infinitely. When we clicked
    on the mouse area widget it’s attached to, we just called `pause()` or `resume()`
    to enable or disable the animation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 至于风扇图像，我们为其添加了一个旋转动画元素，并将其持续时间设置为`1000毫秒`，这意味着它将在一秒内完成一次完整旋转。我们还将其设置为无限循环动画。当我们点击它所附加的鼠标区域小部件时，我们只需调用`pause()`或`resume()`来启用或禁用动画。
- en: Next, for the rectangle widget, we added two states to it, one called **BLUE**
    and one called **RED**, each of which carries a **color** property that will be
    applied to the rectangle upon state change. At the same time, we added **sequential
    animation group** to the mouse area widget that the rectangle is attached to and
    then added two **property animation** elements to the group. You can also mix
    different types of group animation; Qt can handle this very well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于矩形小部件，我们为其添加了两个状态，一个称为**蓝色**，另一个称为**红色**，每个状态都携带一个**颜色**属性，该属性将在状态改变时应用于矩形。同时，我们在矩形所附加的鼠标区域小部件中添加了**顺序动画组**，然后向该组添加了两个**属性动画**元素。您还可以混合不同类型的组动画；Qt可以很好地处理这一点。
- en: Displaying information using model/view
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型/视图显示信息
- en: Qt includes a **model/view framework** that maintains separation between the
    way data are organized and managed and the way that they are presented to the
    user. In this section, we will learn how to make use of the model/view; in particular,
    by using the list view to display information and, at the same time, apply our
    own customization to make it look slick.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Qt包含一个**模型/视图框架**，它保持了数据组织和管理方式与它们向用户展示方式之间的分离。在本节中，我们将学习如何使用模型/视图；特别是通过使用列表视图来显示信息，同时，应用我们的自定义使其看起来更精致。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s get started by following these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'Create a new `home.png`, `map.png`, `profile.png`, `search.png`, `settings.png`,
    and `arrow.png` to the project, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`home.png`、`map.png`、`profile.png`、`search.png`、`settings.png`和`arrow.png`添加到项目中，如下所示：
- en: '![Figure 9.28 – Adding more images to the project](img/B20976_09_028.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图9.28 – 向项目中添加更多图像](img/B20976_09_028.jpg)'
- en: Figure 9.28 – Adding more images to the project
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 – 向项目中添加更多图像
- en: 'After that, create and open `Screen01.ui.qml`, as we did in all previous examples.
    Drag a **List View** widget from under the **Qt Quick – Views** category in the
    **Components** window and place it onto the canvas. Then, set its **Anchors**
    setting to fill the parent size by clicking on the button located in the middle
    of the **Layout** window, as shown in the following screenshot:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建并打开`Screen01.ui.qml`，就像我们在所有之前的例子中所做的那样。从**组件**窗口的**Qt Quick – 视图**类别下拖动一个**列表视图**小部件到画布上。然后，通过点击**布局**窗口中间的按钮将其**锚点**设置设置为填充父大小，如图下所示：
- en: '![Figure 9.29 – Set the layout anchor as a fill parent](img/B20976_09_029.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图9.29 – 将布局锚点设置为填充父容器](img/B20976_09_029.jpg)'
- en: Figure 9.29 – Set the layout anchor as a fill parent
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 – 将布局锚点设置为填充父容器
- en: 'Next, switch over to the script editor, as we will define what the list view
    will look like as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，切换到脚本编辑器，我们将定义列表视图的外观如下：
- en: '[PRE20]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will continue to write the code by adding the following list view:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过添加以下列表视图来继续编写代码：
- en: '[PRE21]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will continue to add rows to the list view, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续向列表视图中添加行，如下所示：
- en: '[PRE22]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then add a mouse area and an image, as shown in the following code snippet:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个鼠标区域和一个图像，如下所示代码片段：
- en: '[PRE23]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, continue to add two text objects, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续添加两个文本对象，如下所示：
- en: '[PRE24]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, add an image object, as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，添加一个图像对象，如下所示：
- en: '[PRE25]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the following code, we will then define the list model:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，我们将定义列表模型：
- en: '[PRE26]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will continue to write the code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续编写代码：
- en: '[PRE27]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will now add the final list element, as shown in the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加最终的列表元素，如下所示代码所示：
- en: '[PRE28]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, open up `App.qml` and replace the code with the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开 `App.qml` 并将代码替换为以下内容：
- en: '[PRE29]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build and run the program, and now your program should look like this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序，现在您的程序应该看起来像这样：
- en: '![Figure 9.30 – Navigation menu with different fonts and icons](img/B20976_09_030.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.30 – 带有不同字体和图标的导航菜单](img/B20976_09_030.jpg)'
- en: Figure 9.30 – Navigation menu with different fonts and icons
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.30 – 带有不同字体和图标的导航菜单
- en: How it works…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt Quick allows us to customize the look of each row of the list view with ease.
    The delegate defines what each row will look like, and the model is where you
    store the data that will be displayed on the list view.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 允许我们轻松自定义列表视图中每一行的外观。委托定义了每一行将看起来是什么样子，而模型是您存储将在列表视图中显示的数据的地方。
- en: In this example, we added a background with a gradient on each row, and then
    we also added an icon on each side of the item, a title, a description, and a
    mouse area widget that makes each row of the list view clickable. The delegate
    is not static, as we allow the model to change the title, description, and icon
    to make each row look unique.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在每一行添加了带有渐变的背景，然后我们还在每个项目的两侧添加了图标，一个标题，一个描述，以及一个鼠标区域小部件，使得列表视图的每一行都可以点击。委托不是静态的，因为我们允许模型更改标题、描述和图标，使每一行看起来独特。
- en: In `App.qml`, we defined the behavior of the mouse area widget that will halve
    its own opacity value when pressed and return to fully opaque when released. Since
    all other elements, such as title and icon, are all the children of the mouse
    area widget, all will also automatically follow their parent widget’s behavior
    and become semi-transparent.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.qml` 中，我们定义了鼠标区域小部件的行为，当按下时会将其自身的透明度值减半，并在释放时恢复到完全不透明。由于所有其他元素，如标题和图标，都是鼠标区域小部件的子元素，因此它们也会自动遵循其父小部件的行为并变为半透明。
- en: 'Additionally, we have finally solved the display problem on mobile devices
    with high resolution and DPI. It’s a very simple trick; first, we defined a variable
    called `sizeMultiplier`. The value of `sizeMultiplier` is the result of dividing
    the width of the window by a predefined value, say 480, which is the current window
    width we used for the PC. Then, multiply `sizeMultiplier` by all the widget variables
    that are related to size and position, including font size. Do note that, in this
    case, you should use the `pixelSize` property for text instead of `pointSize`,
    so that you will get the correct display when multiplying by `sizeMultiplier`.
    The following screenshot shows you what the app looks like on the mobile device
    with and without `sizeMultiplier`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们最终解决了高分辨率和DPI的移动设备上的显示问题。这是一个非常简单的技巧；首先，我们定义了一个名为 `sizeMultiplier` 的变量。`sizeMultiplier`
    的值是窗口宽度除以一个预定义值的结果，比如说480，这是我们用于PC的当前窗口宽度。然后，将 `sizeMultiplier` 乘以所有与大小和位置相关的变量，包括字体大小。请注意，在这种情况下，您应该使用
    `pixelSize` 属性来代替 `pointSize`，这样在乘以 `sizeMultiplier` 时您将得到正确的显示。以下截图显示了带有和不带有
    `sizeMultiplier` 的应用程序在移动设备上的外观：
- en: '![Figure 9.31 – Correcting size using size multiplier](img/B20976_09_031.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.31 – 使用大小乘数校正大小](img/B20976_09_031.jpg)'
- en: Figure 9.31 – Correcting size using size multiplier
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.31 – 使用大小乘数校正大小
- en: Notice that you may get a messed-up user interface in the editor once you multiply
    everything by the `sizeMultiplier` variable. This is because the width variable
    may return as `0` in the editor. Hence, by multiplying 0 by 480, you may get the
    result `0`, which makes the entire user interface look funny. However, it will
    look fine when running the actual program. If you want to preview the user interface
    on the editor, temporarily set `1`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦你将所有内容乘以`sizeMultiplier`变量，编辑器中的用户界面可能会变得混乱。这是因为宽度变量在编辑器中可能返回`0`。因此，将`0`乘以`480`，你可能会得到结果`0`，这使得整个用户界面看起来很奇怪。然而，当运行实际程序时，它看起来会很好。如果你想预览编辑器上的用户界面，暂时将其设置为`1`。
- en: Integrating QML and C++
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成QML和C++
- en: Qt supports bridging between C++ classes with the QML engine. This combination
    allows developers to take advantage of both the simplicity of QML and the flexibility
    of C++. You can even integrate features that are not supported by Qt from external
    components, then pass the resulting data to Qt Quick to be displayed in the UI.
    In this example, we will learn how to export our user interface components from
    QML to the C++ framework and manipulate their properties before displaying them
    on screen.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Qt支持通过QML引擎在C++类之间进行桥接。这种组合允许开发者利用QML的简单性和C++的灵活性。你甚至可以集成外部组件不支持的功能，然后将结果数据传递给Qt
    Quick以在UI中显示。在本例中，我们将学习如何将我们的用户界面组件从QML导出到C++框架，并在它们显示在屏幕上之前操作它们的属性。
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s go through the following steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤进行：
- en: Once again, we will start everything from scratch. Therefore, create a new `Screen01.ui.qml`
    with Qt Design Studio. Then, open up `Screen01.ui.qml`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们将从头开始。因此，使用Qt Design Studio创建一个新的`Screen01.ui.qml`。然后，打开`Screen01.ui.qml`。
- en: 'We can keep the mouse area and text widget but place the text widget at the
    bottom of the window. Change the `Text` property of the text widget to `18`. After
    that, go to the `120`, as shown in the following screenshot:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以保留鼠标区域和文本小部件，但将文本小部件放置在窗口底部。将文本小部件的`Text`属性更改为`18`。之后，转到`120`，如下面的屏幕截图所示：
- en: '![Figure 9.32 – Place it at the center of the layout](img/B20976_09_032.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图9.32 – 将其放置在布局的中心](img/B20976_09_032.jpg)'
- en: Figure 9.32 – Place it at the center of the layout
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 – 将其放置在布局的中心
- en: 'Next, drag a rectangle widget from the `#ff0d0d`. Set its `200` and enable
    both the vertical and horizontal center anchor. After that, set the `-14`. Your
    UI should now look something like this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从`#ff0d0d`拖动一个矩形小部件。设置其`200`并启用垂直和水平中心锚点。之后，设置`-14`。你的UI现在应该看起来像这样：
- en: '![Figure 9.33 – Place the square and text as they are positioned in this image](img/B20976_09_033.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图9.33 – 将正方形和文本放置如图所示的图像中](img/B20976_09_033.jpg)'
- en: Figure 9.33 – Place the square and text as they are positioned in this image
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 – 将正方形和文本放置如图所示的图像中
- en: 'Once you are done with that, right-click on your project directory in `myclass.h`
    and `myclass.cpp`—will now be created and added to your project:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，在`myclass.h`和`myclass.cpp`中的项目目录上右键单击——现在将创建并添加到你的项目中：
- en: '![Figure 9.34 – Create a new custom class](img/B20976_09_034.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图9.34 – 创建一个新的自定义类](img/B20976_09_034.jpg)'
- en: Figure 9.34 – Create a new custom class
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34 – 创建一个新的自定义类
- en: 'Now, open up `myclass.h` and add a variable and function under the class constructor,
    as shown in the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`myclass.h`并在类构造函数下添加一个变量和函数，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that, open up `myclass.cpp` and define the `setMyObject()` function,
    as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开`myclass.cpp`并定义`setMyObject()`函数，如下所示：
- en: '[PRE31]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now close `myclass.cpp` and open up `App.qml`. At the top of the file,
    import the `MyClassLib` components that we just created in C++:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭`myclass.cpp`并打开`App.qml`。在文件顶部，导入我们在C++中刚刚创建的`MyClassLib`组件：
- en: '[PRE32]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Window {
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Window {
- en: 'visible: true'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'visible: true'
- en: 'width: 480'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'width: 480'
- en: 'height: 320'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'height: 320'
- en: MyClass {
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MyClass {
- en: 'id: myclass'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'id: myclass'
- en: '}'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Screen01 {
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Screen01 {
- en: 'anchors.fill: parent'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'anchors.fill: parent'
- en: 'mouseArea.onClicked: {'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'mouseArea.onClicked: {'
- en: Qt.quit();
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qt.quit();
- en: '}'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'Component.onCompleted:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Component.onCompleted:'
- en: myclass.setMyObject(messageText);
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: myclass.setMyObject(messageText);
- en: '}'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE33]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, open up `main.cpp` and register the custom class to the QML engine.
    We will also change the properties of the text widget and the rectangle here using
    C++ code, as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`main.cpp`并将自定义类注册到QML引擎。我们还将使用C++代码更改文本小部件和矩形的属性，如下所示：
- en: '[PRE34]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, proceed to create the objects, just like the highlighted section in the
    following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，继续创建对象，就像以下代码中突出显示的部分一样：
- en: '[PRE35]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, build and run the program, and you should see that the colors of the rectangle
    and the text are completely different from what you defined earlier in Qt Quick,
    as shown in the following screenshot. This is because their properties have been
    changed by the C++ code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并运行程序，你应该会看到矩形的颜色和文本的颜色与你在 Qt Quick 中之前定义的完全不同，如下面的截图所示。这是因为它们的属性已经被 C++
    代码所改变：
- en: '![Figure 9.35 – Text and color can now be changed by C++](img/B20976_09_035.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.35 – 现在可以通过 C++ 改变文本和颜色](img/B20976_09_035.jpg)'
- en: Figure 9.35 – Text and color can now be changed by C++
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.35 – 现在可以通过 C++ 改变文本和颜色
- en: How it works…
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: QML is designed to be easily extendable through C++ code. The classes in the
    Qt QML module enable QML objects to be loaded and manipulated from C++.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: QML 被设计成可以通过 C++ 代码轻松扩展。Qt QML 模块中的类使 QML 对象能够从 C++ 中加载和处理。
- en: Only classes that are inherited from the `QObject` base class can be integrated
    with QML, as it is part of the Qt ecosystem. Once the class has been registered
    with the QML engine, we get the root item from the QML engine and use it to find
    the objects we want to manipulate.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 只有继承自 `QObject` 基类 的类才能与 QML 集成，因为它是 Qt 生态系统的一部分。一旦类被 QML 引擎注册，我们就从 QML 引擎获取根项，并使用它来找到我们想要操作的对象。
- en: 'After that, use the `setProperty()` function to change any of the properties
    belonging to the widget. Other than `setProperty()`, you may also use the `Q_PROPERTY()`
    macro in a class that inherits `QObject` to declare a property. Here is an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用 `setProperty()` 函数来更改属于小部件的任何属性。除了 `setProperty()` 之外，你还可以在继承自 `QObject`
    的类中使用 `Q_PROPERTY()` 宏来声明属性。以下是一个示例：
- en: '[PRE36]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that the `Q_INVOKABLE` macro needs to be placed in front of the function
    that you intend to call in QML. Without it, Qt will not expose the function to
    Qt Quick, and you will not be able to call it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Q_INVOKABLE` 宏需要放在你打算在 QML 中调用的函数之前。如果没有它，Qt 不会将函数暴露给 Qt Quick，你将无法调用它。
