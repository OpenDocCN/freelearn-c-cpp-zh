["```cpp\n    /* singlethread.cpp */\n    #include <thread>\n    #include <iostream>\n\n    using namespace std;\n\n    void threadProc()\n    {\n      cout << \"Thread ID: \";\n      cout << this_thread::get_id() << endl;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[singlethread.cpp]\" << endl;\n\n      thread thread1(threadProc);\n      thread1.join();\n\n      return 0;\n    }\n\n```", "```cpp\n    /* singlethread2.cpp */\n    #include <thread>\n    #include <chrono>\n    #include <iostream>\n\n    using namespace std;\n\n    void threadProc()\n    {\n      for (int i = 0; i < 5; i++)\n      {\n        cout << \"thread: current i = \";\n        cout << i << endl;\n      }\n    }\n\n    auto main() -> int\n    {\n      cout << \"[singlethread2.cpp]\" << endl;\n\n      thread thread1(threadProc);\n\n      for (int i = 0; i < 5; i++)\n {\n cout << \"main : current i = \" << i << endl;\n\n        this_thread::sleep_for(\n            chrono::milliseconds(5)); }\n\n      thread1.join();\n\n      return 0;\n    }\n\n```", "```cpp\n    /* multithread.cpp */\n    #include <thread>\n    #include <iostream>\n\n    using namespace std;\n\n    void threadProc()\n    {\n      cout << \"Thread ID: \";\n      cout << this_thread::get_id() << endl;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[multithread.cpp]\" << endl;\n\n      thread threads[5];\n\n      for (int i = 0; i < 5; ++i)\n      {\n        threads[i] = thread(threadProc);\n      }\n\n      for (auto& thread : threads)\n      {\n        thread.join();\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    /* lambdathread.cpp */\n    #include <thread>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[lambdathread.cpp]\" << endl;\n\n      thread threads[5];\n\n      for (int i = 0; i < 5; ++i)\n      {\n threads[i] = thread([]()\n {\n cout << \"Thread ID: \";\n cout << this_thread::get_id() << endl;\n });\n       }\n\n      for (auto& thread : threads)\n      {\n        thread.join();\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    /* notsync.cpp */\n    #include <thread>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[notsync.cpp]\" << endl;\n\n      int counter = 0;\n\n      thread threads[5];\n\n      for (int i = 0; i < 5; ++i)\n      {\n        threads[i] = thread([&counter]()\n        {\n for (int i = 0; i < 10000; ++i)\n {\n ++counter;\n cout << \"Thread ID: \";\n cout << this_thread::get_id();\n cout << \"\\tCurrent Counter = \";\n cout << counter << endl;\n }\n        });\n      }\n\n      for (auto& thread : threads)\n      {\n        thread.join();\n      }\n\n      cout << \"Final result = \" << counter << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* mutex.cpp */\n    #include <thread>\n    #include <mutex>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[mutex.cpp]\" << endl;\n\n      mutex mtx;\n      int counter = 0;\n\n      thread threads[5];\n\n      for (int i = 0; i < 5; ++i)\n      {\n        threads[i] = thread([&counter, &mtx]()\n        {\n           for (int i = 0; i < 10000; ++i)\n           {\n             mtx.lock();\n             ++counter;\n             mtx.unlock();\n\n             cout << \"Thread ID: \";\n             cout << this_thread::get_id();\n             cout << \"\\tCurrent Counter = \";\n             cout << counter << endl;\n           }\n        });\n      }\n\n      for (auto& thread : threads)\n      {\n        thread.join();\n      }\n\n      cout << \"Final result = \" << counter << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* automutex.cpp */\n    #include <thread>\n    #include <mutex>\n    #include <iostream>\n\n    using namespace std;\n\n    auto main() -> int\n    {\n      cout << \"[automutex.cpp]\" << endl;\n\n      mutex mtx;\n      int counter = 0;\n\n      thread threads[5];\n\n      for (int i = 0; i < 5; ++i)\n      {\n        threads[i] = thread([&counter, &mtx]()\n        {\n          for (int i = 0; i < 10000; ++i)\n          {\n            {\n              lock_guard <mutex> guard(mtx);\n              ++counter;\n             }\n\n             cout << \"Thread ID: \";\n             cout << this_thread::get_id();\n             cout << \"\\tCurrent Counter = \";\n             cout << counter << endl;\n          }\n         });\n       }\n\n       for (auto& thread : threads)\n       {\n          thread.join();\n       }\n\n      cout << \"Final result = \" << counter << endl;\n\n      return 0;\n    }\n\n```", "```cpp\n    /* deadlock.cpp */\n    #include <thread>\n    #include <mutex>\n    #include <iostream>\n\n    using namespace std;\n\n    struct Math\n    {\n      mutex mtx;\n      int m_content;\n\n      Math() : m_content(0)\n      {\n      }\n\n      // This method will lock the mutex\n      void Multiplexer(int i)\n      {\n        lock_guard<mutex> lock(mtx);\n        m_content *= i;\n        cout << \"Multiplexer() is called. m_content = \";\n        cout << m_content << endl;\n      }\n\n      // This method will lock the mutex also\n      void Divisor(int i)\n      {\n        lock_guard<mutex> lock(mtx);\n        m_content /= i;\n        cout << \"Divisor() is called. m_content = \";\n        cout << m_content << endl;\n      }\n\n      // This method will invoke \n      // the two preceding methods\n      // which each method locks the mutex\n      void RunAll(int a)\n      {\n        lock_guard<mutex> lock(mtx);\n        Multiplexer(a);\n        Divisor(a);\n      }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[deadlock.cpp]\" << endl;\n\n      // Instantiating Math struct\n      // and invoking the RunAll() method \n      Math math;\n      math.RunAll(10);\n\n      return 0;\n    }\n\n```", "```cpp\n    /* recursivemutex.cpp */\n    #include <thread>\n    #include <mutex>\n    #include <iostream>\n\n    using namespace std;\n\n    struct Math\n    {\n recursive_mutex mtx;\n      int m_content;\n\n      Math() : m_content(1)\n      {\n      }\n\n      // This method will lock the mutex\n      void Multiplexer(int i)\n      {\n        lock_guard<recursive_mutex> lock(mtx);\n        m_content *= i;\n        cout << \"Multiplexer() is called. m_content = \";\n        cout << m_content << endl;\n      }\n\n      // This method will lock the mutex also\n      void Divisor(int i)\n      {\n        lock_guard<recursive_mutex> lock(mtx);\n        m_content /= i;\n        cout << \"Divisor() is called. m_content = \";\n        cout << m_content << endl;\n      }\n\n      // This method will invoke \n      // the two preceding methods\n      // which each method locks the mutex\n      void RunAll(int a)\n      {\n        lock_guard<recursive_mutex> lock(mtx);\n        Multiplexer(a);\n        Divisor(a);\n      }\n    };\n\n    auto main() -> int\n    {\n      cout << \"[recursivemutex.cpp]\" << endl;\n\n      // Instantiating Math struct\n      // and invoking the RunAll() method \n      Math math;\n      math.RunAll(10);\n\n      return 0;\n    }\n\n```", "```cpp\n    /* threadhandle.cpp */\n    #include <iostream>\n    #include <windows.h>\n\n    using namespace std;\n\n    auto threadProc(void*) -> unsigned long\n    {\n      cout << \"threadProc() is run.\" << endl;\n      return 100;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[threadhandle.cpp]\" << endl;\n\n      auto hnd = HANDLE\n      {\n        CreateThread(\n            nullptr,\n            0,\n            threadProc,\n            nullptr,\n            0,\n            nullptr)\n      };\n\n      if (hnd)\n      {\n        WaitForSingleObject(hnd, INFINITE);\n\n        unsigned long exitCode;\n        GetExitCodeThread(hnd, &exitCode);\n\n        cout << \"The result = \" << exitCode << endl;\n\n        CloseHandle(hnd);\n      }\n\n      return 0;\n    }\n\n```", "```cpp\n    template <typename C>\n    class UniqueHandle\n    {\n      private:\n        HANDLE m_val;\n\n        void Close()\n        {\n          if (*this)\n          {\n            C::Exit(m_val);\n          }\n        }\n\n      public:\n        // Copy assignment operator \n        UniqueHandle(UniqueHandle const &) = delete;\n        auto operator=(UniqueHandle const &)->UniqueHandle & = delete;\n\n        // UniqueHandle constructor\n        explicit UniqueHandle(HANDLE value = C::Invalid()) :\n        m_val{ value }\n        {\n        }\n\n        // Move assignment operator\n        UniqueHandle(UniqueHandle && other) :\n        m_val{ other.Release() }\n        {\n        }\n\n        // Move assignment operator\n        auto operator=(UniqueHandle && other) -> UniqueHandle &\n        {\n          if (this != &other)\n          {\n            Reset(other.Release());\n          }\n\n          return *this;\n        }\n\n        // Destructor of UniqueHandle class\n        ~UniqueHandle()\n        {\n          Close();\n        }\n\n        // bool operator for equality\n        explicit operator bool() const \n        {\n          return m_val != C::Invalid();\n        }\n\n        // Method for retrieving the HANDLE value\n        HANDLE Get() const\n        {\n          return m_val;\n        }\n\n       // Method for releasing the HANDLE value\n       HANDLE Release()\n       {\n         auto value = m_val;\n         m_val = C::Invalid();\n         return value;\n       }\n\n       // Method for reseting the HANDLE\n       bool Reset(HANDLE value = C::Invalid())\n       {\n        if (m_val != value)\n        {\n           Close();\n           m_val = value;\n        }\n\n         return static_cast<bool>(*this);\n       }\n    };\n\n```", "```cpp\n    using NullHandle = UniqueHandle<NullHandleCharacteristics>;\n\n```", "```cpp\n    struct NullHandleCharacteristics\n    {\n      // Returning nullptr when the HANDLE is invalid\n      static HANDLE Invalid()\n      {\n         return nullptr;\n      }\n\n      // Exit the HANDLE by closing it\n      static void Exit(HANDLE val)\n      {\n         CloseHandle(val);\n      }\n    };\n\n```", "```cpp\n    auto hnd = NullHandle\n    {\n      CreateThread(\n        nullptr,\n        0,\n        threadProc,\n        nullptr,\n        0,\n        nullptr)\n    };\n\n```", "```cpp\n    auto WaitOneThread(\n      HANDLE const h,\n      DWORD const ms = INFINITE) -> bool\n      {\n        auto const r = WaitForSingleObject(\n        h,\n        ms);\n\n        // Inform that thread is not idle\n        if (r == WAIT_OBJECT_0)\n          return true;\n\n        // Inform that thread is not idle\n        if (r == WAIT_TIMEOUT)\n          return false;\n\n        throw WinException();\n      }\n\n```", "```cpp\n    struct WinException\n    {\n      unsigned long error;\n\n      explicit WinException(\n        unsigned long value = GetLastError()) :\n        error{ value }\n       {\n       }\n    };\n\n```", "```cpp\n    if (hnd)\n    {\n      if (WaitOneThread(hnd.Get(), 0))\n        cout << \"Before running thread\" << endl;\n\n      WaitOneThread(hnd.Get());\n\n      if (WaitOneThread(hnd.Get(), 0))\n        cout << \"After running thread\" << endl;\n\n      unsigned long exitCode;\n      GetExitCodeThread(hnd.Get(), &exitCode);\n\n      cout << \"The result = \" << exitCode << endl;\n    }\n\n```", "```cpp\n    /* threaduniquehandle.cpp */\n    #include <iostream>\n    #include <windows.h>\n    #include \"../uniquehandle_h/uniquehandle.h\"\n\n    using namespace std;\n\n    unsigned long threadProc(void*)\n    {\n      cout << \"threadProc() is run.\" << endl;\n      return 100;\n    }\n\n    struct WinException\n    {\n      unsigned long error;\n      explicit WinException(\n        unsigned long value = GetLastError()) :\n        error{ value }\n        {\n        }\n    };\n\n    auto WaitOneThread(\n      HANDLE const h,\n      DWORD const ms = INFINITE) -> bool\n      {\n        auto const r = WaitForSingleObject(\n        h,\n        ms);\n\n       // Inform that thread is not idle\n       if (r == WAIT_OBJECT_0)\n         return true;\n\n       // Inform that thread is not idle\n       if (r == WAIT_TIMEOUT)\n         return false;\n\n       throw WinException();\n      }\n\n    auto main() -> int\n    {\n      cout << \"[threaduniquehandle.cpp]\" << endl;\n\n      auto hnd = NullHandle\n      {\n        CreateThread(\n            nullptr,\n            0,\n            threadProc,\n            nullptr,\n            0,\n            nullptr)\n      };\n\n      if (hnd)\n      {\n        if (WaitOneThread(hnd.Get(), 0))\n          cout << \"Before running thread\" << endl;\n\n        WaitOneThread(hnd.Get());\n\n        if (WaitOneThread(hnd.Get(), 0))\n          cout << \"After running thread\" << endl;\n\n        unsigned long exitCode;\n        GetExitCodeThread(hnd.Get(), &exitCode);\n\n        cout << \"The result = \" << exitCode << endl;\n      }\n\n     return 0;\n    }\n\n```", "```cpp\n    class Event\n    {\n      private:\n        NullHandle hnd;\n\n      public:\n        Event(Event const &) = delete;\n        auto operator=(Event const &)->Event & = delete;\n        ~Event() = default;\n\n        explicit Event(bool manual) :\n         hnd\n         {\n           CreateEvent(nullptr,\n            manual, false, nullptr)\n         }\n         {\n           if (!hnd)\n            throw WinException();\n         }\n\n        explicit Event(EventType evType) :\n         hnd\n         {\n           CreateEvent(\n            nullptr,\n            static_cast<BOOL>(evType),\n            false,\n            nullptr)\n         }\n         {\n           if (!hnd)\n            throw WinException();\n         }\n\n         Event(Event && other) throw() :\n           hnd\n           {\n             other.hnd.Release()\n           }\n           {\n           }\n\n         auto operator=(Event && other) throw()->Event &\n         {\n           hnd = move(other.hnd);\n         }\n\n         void Set()\n         {\n           cout << \"The event is set\" << endl;\n           SetEvent(hnd.Get());\n         }\n\n         void Clear()\n         {\n           cout << \"The event is cleared\" << endl;\n           ResetEvent(hnd.Get());\n         }\n\n         auto Wait(\n           DWORD const ms = INFINITE) -> bool\n           {\n             auto const result = WaitForSingleObject(\n             hnd.Get(), ms);\n\n            return result == WAIT_OBJECT_0;\n           }\n     };\n\n```", "```cpp\n    enum class EventType\n    {\n      AutoReset,\n      ManualReset\n    };\n\n```", "```cpp\n    /* event.cpp */\n    #include <iostream>\n    #include <windows.h>\n    #include \"../uniquehandle_h/uniquehandle.h\"\n\n    using namespace std;\n\n    struct WinException\n    {\n      unsigned long error;\n\n      explicit WinException(\n        unsigned long value = GetLastError()) :\n        error{ value }\n        {\n        }\n    };\n\n    enum class EventType\n    {\n      AutoReset,\n      ManualReset\n    };\n\n    class Event\n    {\n      private:\n        NullHandle hnd;\n\n      public:\n        Event(Event const &) = delete;\n        auto operator=(Event const &)->Event & = delete;\n        ~Event() = default;\n\n        explicit Event(bool manual) :\n         hnd\n         {\n           CreateEvent(nullptr,\n           manual, false, nullptr)\n         }\n         {\n           if (!hnd)\n            throw WinException();\n         }\n\n         explicit Event(EventType evType) :\n          hnd\n          {\n            CreateEvent(\n            nullptr,\n            static_cast<BOOL>(evType),\n            false,\n            nullptr)\n          }\n          {\n            if (!hnd)\n             throw WinException();\n          }\n\n          Event(Event && other) throw() :\n            hnd\n            {\n              other.hnd.Release()\n            }\n            {\n            }\n\n          auto operator=(Event && other) throw() -> Event &\n          {\n              hnd = move(other.hnd);\n          }\n\n          void Set()\n          {\n              cout << \"The event is set\" << endl;\n              SetEvent(hnd.Get());\n          }\n\n          void Clear()\n          {\n               cout << \"The event is cleared\" << endl;\n               ResetEvent(hnd.Get());\n          }\n\n          auto Wait(\n            DWORD const ms = INFINITE) -> bool\n              {\n                auto const result = WaitForSingleObject(\n                  hnd.Get(), ms);\n\n                return result == WAIT_OBJECT_0;\n             }\n          };\n\n          void CheckEventSignaling( bool b)\n          {\n            if (b)\n            {\n              cout << \"The event is signaled\" << endl;\n            }\n            else\n            {\n             cout << \"The event is not signaled\" << endl;\n            }\n         }\n\n         auto main() -> int\n         {\n           cout << \"[event.cpp]\" << endl;\n\n           auto ev = Event{\n             EventType::ManualReset };\n\n             CheckEventSignaling(ev.Wait(0));\n\n             ev.Set();\n\n             CheckEventSignaling(ev.Wait(0));\n\n             ev.Clear();\n\n             CheckEventSignaling(ev.Wait(0));\n\n             return 0;\n          }\n\n```", "```cpp\n    void Wrap(HANDLE *)\n    {\n    }\n\n    template <typename T, typename... Args>\n    void Wrap(\n      HANDLE * left,\n      T const & right,\n      Args const & ... args)\n      {\n        *left = right.Get();\n        Wrap(++left, args...);\n      }\n\n```", "```cpp\n    template <typename... Args>\n    void WaitAllThreads(Args const & ... args)\n    {\n      HANDLE handles[sizeof...(Args)];\n\n      Wrap(handles, args...);\n\n      WaitForMultipleObjects(\n        sizeof...(Args),\n        handles,\n        true,\n        INFINITE);\n    }\n\n```", "```cpp\n    /* eventthread.cpp */\n    #include <iostream>\n    #include <windows.h>\n    #include \"../uniquehandle_h/uniquehandle.h\"\n\n    using namespace std;\n\n    void Wrap(HANDLE *)\n    {\n    }\n\n    template <typename T, typename... Args>\n    void Wrap(\n      HANDLE * left,\n      T const & right,\n      Args const & ... args)\n      {\n        *left = right.Get();\n        Wrap(++left, args...);\n      }\n\n    template <typename... Args>\n    void WaitAllThreads(Args const & ... args)\n    {\n      HANDLE handles[sizeof...(Args)];\n\n      Wrap(handles, args...);\n\n      WaitForMultipleObjects(\n        sizeof...(Args),\n        handles,\n        true,\n        INFINITE);\n    }\n\n    auto threadProc(void*) -> unsigned long\n    {\n      cout << \"Thread ID: \";\n      cout << GetCurrentThreadId() << endl;\n      return 120;\n    }\n\n    auto main() -> int\n    {\n      cout << \"[eventthread.cpp]\" << endl;\n\n      auto thread1 = NullHandle\n      {\n        CreateThread(\n          nullptr,\n          0,\n          threadProc,\n          nullptr,\n          CREATE_SUSPENDED,\n          nullptr)\n      };\n\n      auto thread2 = NullHandle\n      {\n        CreateThread(\n          nullptr,\n          0,\n          threadProc,\n          nullptr,\n          CREATE_SUSPENDED,\n          nullptr)\n     };\n\n ResumeThread(thread1.Get());\n ResumeThread(thread2.Get());\n\n     WaitAllThreads(thread1, thread2);\n\n     return 0;\n    }\n\n```", "```cpp\n    /* eventthread2.cpp */\n    #include <iostream>\n    #include <windows.h>\n    #include \"../uniquehandle_h/uniquehandle.h\"\n\n    using namespace std;\n\n    struct WinException\n    {\n      unsigned long error;\n\n      explicit WinException(\n        unsigned long value = GetLastError()) :\n        error{ value }\n        {\n        }\n    };\n\n    enum class EventType\n    {\n      AutoReset,\n      ManualReset\n     };\n\n    class Event\n    {\n      private:\n        NullHandle hnd;\n\n      public:\n        Event(Event const &) = delete;\n        auto operator=(Event const &)->Event & = delete;\n        ~Event() = default;\n\n        explicit Event(bool manual) :\n          hnd\n          {\n            CreateEvent(nullptr,\n            manual, false, nullptr)\n          }\n          {\n            if (!hnd)\n             throw WinException();\n          }\n\n        explicit Event(EventType evType) :\n          hnd\n          {\n            CreateEvent(\n              nullptr,\n              static_cast<BOOL>(evType),\n              false,\n              nullptr)\n           }\n           {\n             if (!hnd)\n              throw WinException();\n           }\n\n        Event(Event && other) throw() :\n          hnd\n          {\n            other.hnd.Release()\n          }\n          {\n          }\n\n        auto operator=(Event && other) throw() -> Event &\n        {\n          hnd = move(other.hnd);\n        }\n\n        void Set()\n        {\n          cout << \"The event is set\" << endl;\n          SetEvent(hnd.Get());\n        }\n\n        void Clear()\n        {\n          cout << \"The event is cleared\" << endl;\n          ResetEvent(hnd.Get());\n        }\n\n        auto Wait( DWORD const ms = INFINITE) -> bool\n        {\n           auto const result = WaitForSingleObject(\n            hnd.Get(), ms);\n\n           return result == WAIT_OBJECT_0;\n        }\n     };\n\n        void Wrap(HANDLE *)\n        {\n        }\n\n        template <typename T, typename... Args>\n        void Wrap(\n        HANDLE * left,\n        T const & right,\n        Args const & ... args)\n        {\n          *left = right.Get();\n           Wrap(++left, args...);\n        }\n\n        template <typename... Args>\n        void WaitAllThreads(Args const & ... args)\n        {\n        HANDLE handles[sizeof...(Args)];\n\n        Wrap(handles, args...);\n\n        WaitForMultipleObjects(\n          sizeof...(Args),\n          handles,\n          true,\n          INFINITE);\n        }\n\n        static auto ev = Event{\n        EventType::ManualReset };\n\n        auto threadProc(void*) -> unsigned long\n        {\n          cout << \"Thread ID: \";\n          cout << GetCurrentThreadId() << endl;\n\n          ev.Wait();\n\n          cout << \"Run Thread ID: \";\n          cout << GetCurrentThreadId() << endl;\n\n          return 120;\n        }\n\n        auto main() -> int\n        {\n          cout << \"[eventthread2.cpp]\" << endl;\n\n          auto thread1 = NullHandle\n          {\n            CreateThread(\n              nullptr,\n              0,\n              threadProc,\n              nullptr,\n              0,\n              nullptr)\n          };\n\n          auto thread2 = NullHandle\n          {\n            CreateThread(\n              nullptr,\n              0,\n              threadProc,\n              nullptr,\n              0,\n              nullptr)\n         };\n\n Sleep(100);\n ev.Set();\n Sleep(100);\n\n         WaitAllThreads(thread1, thread2);\n\n         return 0;\n    }\n\n```", "```cpp\n    /* eventthread3.cpp */\n    #include <iostream>\n    #include <windows.h>\n    #include \"../uniquehandle_h/uniquehandle.h\"\n\n    using namespace std;\n\n    struct WinException\n    {\n      unsigned long error;\n\n      explicit WinException(\n        unsigned long value = GetLastError()) :\n        error{ value }\n        {\n        }\n    };\n\n    enum class EventType\n    {\n      AutoReset,\n      ManualReset\n    };\n\n    class Event\n    {\n       private:\n         NullHandle hnd;\n\n       public:\n         Event(Event const &) = delete;\n         auto operator=(Event const &)->Event & = delete;\n         ~Event() = default;\n\n         explicit Event(bool manual) :\n           hnd\n           {\n             CreateEvent(nullptr,\n             manual, false, nullptr)\n           }\n           {\n             if (!hnd)\n              throw WinException();\n           }\n\n          explicit Event(EventType evType) :\n             hnd\n             {\n               CreateEvent(\n                 nullptr,\n                 static_cast<BOOL>(evType),\n                 false,\n                 nullptr)\n             }\n             {\n               if (!hnd)\n                throw WinException();\n             }\n\n         Event(Event && other) throw() :\n           hnd\n           {\n             other.hnd.Release()\n           }\n           {\n           }\n\n         auto operator=(Event && other) throw() -> Event &\n           {\n              hnd = move(other.hnd);\n           }\n\n          void Set()\n          {\n             cout << \"The event is set\" << endl;\n             SetEvent(hnd.Get());\n          }\n\n          void Clear()\n          {\n              cout << \"The event is cleared\" << endl;\n              ResetEvent(hnd.Get());\n          }\n\n          auto Wait(\n            DWORD const ms = INFINITE) -> bool\n            {\n              auto const result = WaitForSingleObject(\n                hnd.Get(), ms);\n\n             return result == WAIT_OBJECT_0;\n            }\n       };\n\n         void Wrap(HANDLE *)\n         {\n         }\n\n         template <typename T, typename... Args>\n         void Wrap(\n           HANDLE * left,\n           T const & right,\n           Args const & ... args)\n           {\n             *left = right.Get();\n             Wrap(++left, args...);\n           }\n\n           template <typename... Args>\n           void WaitAllThreads(Args const & ... args)\n           {\n              HANDLE handles[sizeof...(Args)];\n\n              Wrap(handles, args...);\n\n              WaitForMultipleObjects(\n                sizeof...(Args),\n                handles,\n                true,\n                INFINITE);\n           }\n\n static auto ev = Event{\n EventType::AutoReset };\n\n           auto threadProc(void*) -> unsigned long\n           {\n             cout << \"Thread ID: \";\n             cout << GetCurrentThreadId() << endl;\n\n             ev.Wait();\n\n             cout << \"Run Thread ID: \";\n             cout << GetCurrentThreadId() << endl;\n\n             Sleep(1000);\n ev.Set();\n\n             return 120;\n           }\n\n           auto main() -> int\n           {\n             cout << \"[eventthread3.cpp]\" << endl;\n\n             auto thread1 = NullHandle\n             {\n               CreateThread(\n                 nullptr,\n                 0,\n                 threadProc,\n                 nullptr,\n                 0,\n                 nullptr)\n             };\n\n             auto thread2 = NullHandle\n             {\n                CreateThread(\n                  nullptr,\n                  0,\n                  threadProc,\n                  nullptr,\n                  0,\n                  nullptr)\n             };\n\n             Sleep(100);\n             ev.Set();\n             Sleep(100);\n\n             WaitAllThreads(thread1, thread2);\n\n             return 0;\n       }\n\n```"]