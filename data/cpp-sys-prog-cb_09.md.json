["```cpp\n#include <iostream>\n#include <vector>\n#include <chrono>\n```", "```cpp\nint main ()\n{\n    std::cout << \"Starting ... \" << std::endl;\n    std::vector <int> elements;\n    auto start = std::chrono::system_clock::now();\n\n    for (auto i = 0; i < 100'000'000; ++i)\n        elements.push_back(i);\n\n    auto end = std::chrono::system_clock::now();\n```", "```cpp\n    // default seconds\n    std::chrono::duration<double, std::milli> diff = end - start;\n    std::cout << \"Time Spent for populating a vector with     \n        100M of integer ...\" \n              << diff.count() << \"msec\" << std::endl;\n```", "```cpp\n    auto tpStart = std::chrono::system_clock::to_time_t(start);\n    std::cout << \"Start: \" << std::ctime(&tpStart) << std::endl;\n\n    auto tpEnd = std::chrono::system_clock::to_time_t(end);\n    std::cout << \"End: \" << std::ctime(&tpEnd) << std::endl;\n    std::cout << \"Ended ... \" << std::endl;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main ()\n{\n    auto bday = January/30/2021;\n    cout << weekday(bday) << endl;\n\n    auto anotherDay = December/25/2020;\n    if (bday == anotherDay)\n        cout << \"the two date represent the same day\" << endl;\n    else\n        cout << \"the two dates represent two different days\"    \n            << endl;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main ()\n{\n    auto today = year_month_day{ floor<days>(system_clock::now()) };\n    auto ymdl = year_month_day_last(today.year(), month*day* last{ month{ 2 } });\n    auto last_day_feb = year_month_day{ ymdl };\n    std::cout << \"last day of Feb is: \" << last_day_feb\n        << std::endl;\n\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main()\n{\n    auto zone_names = {\n       \"Asia/Tokyo\",\n       \"Europe/Berlin\",\n       \"Europe/London\",\n       \"America/New_York\",\n    };\n\n    auto localtime = zoned_time<milliseconds>(date::current_zone(),\n                                              system_clock::now());\n    for(auto const& name : zone_names)\n        cout << name\n             << zoned_time<milliseconds>(name, localtime)\n             << std::endl;\n\n    return 0;\n}\n```", "```cpp\n#include <chrono>\n#include <iostream>\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main()\n{\n    auto current = system_clock::now();\n    auto lon = zoned_time{\"Europe/London\", current_time};\n    auto newYork = zoned_time{\"America/New_York\", current_time};\n    cout <<\"Time Difference between London and New York:\" \n         << (lon.get_local_time() - newYork.get_local_time())\n             << endl;\n\n    return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <time.h>\n#include <vector>\n\nvoid timespec_diff(struct timespec* start, struct timespec* stop, struct timespec* result);\n```", "```cpp\nint main ()\n{\n    std::cout << \"Starting ...\" << std::endl;\n    struct timespec tsRealTime, tsMonotonicStart;\n    clock_gettime(CLOCK_REALTIME, &tsRealTime);\n    clock_gettime(CLOCK_MONOTONIC, &tsMonotonicStart);\n```", "```cpp\n    std::cout << \"Real Time clock (i.e.: wall clock):\"\n        << std::endl;\n    std::cout << \" sec :\" << tsRealTime.tv_sec << std::endl;\n    std::cout << \" nanosec :\" << tsRealTime.tv_nsec << std::endl;\n\n    std::cout << \"Monotonic clock:\" << std::endl;\n    std::cout << \" sec :\" << tsMonotonicStart.tv_sec << std::endl;\n    std::cout << \" nanosec :\" << tsMonotonicStart.tv_nsec+\n        << std::endl;\n```", "```cpp\n    std::vector <int> elements;\n    for (int i = 0; i < 100'000'000; ++i)\n        elements.push_back(i);\n\n    struct timespec tsMonotonicEnd;\n    clock_gettime(CLOCK_MONOTONIC, &tsMonotonicEnd);\n```", "```cpp\n    struct timespec duration;\n    timespec_diff (&tsMonotonicStart, &tsMonotonicEnd, &duration);\n\n    std::cout << \"Time elapsed to populate a vector with\n        100M elements:\" << std::endl;\n    std::cout << \" sec :\" << duration.tv_sec << std::endl;\n    std::cout << \" nanosec :\" << duration.tv_nsec << std::endl;\n    std::cout << \"Finished ...\" << std::endl;\n}\n```", "```cpp\n// helper method\nvoid timespec_diff(struct timespec* start, struct timespec* stop, struct timespec* result)\n{\n    if ((stop->tv_nsec - start->tv_nsec) < 0) \n    {\n        result->tv_sec = stop->tv_sec - start->tv_sec - 1;\n        result->tv_nsec = stop->tv_nsec - start->tv_nsec\n          + 100'000'0000;\n    } \n    else \n    {\n        result->tv_sec = stop->tv_sec - start->tv_sec;\n        result->tv_nsec = stop->tv_nsec - start->tv_nsec;\n    }\n    return;\n}\n```", "```cpp\n#include <iostream>\n#include <chrono>\n#include <thread>    // sleep_for\n#include <unistd.h>  // for sleep\n#include <time.h>    // for nanosleep and clock_nanosleep\n```", "```cpp\nint main ()\n{\n    std::cout << \"Starting ... \" << std::endl;\n\n    auto start = std::chrono::steady_clock::now();\n    sleep (1);\n    auto end = std::chrono::steady_clock::now();\n    std::cout << \"sleep() call cause me to sleep for: \" \n              << std::chrono::duration_cast<std::chrono::\n                  milliseconds> (end-start).count() \n              << \" millisec\" <<     std::endl;\n```", "```cpp\n    struct timespec reqSleep = {.tv_sec = 0, .tv_nsec = 99999999};\n    start = std::chrono::steady_clock::now();\n    int ret = nanosleep (&reqSleep, NULL);\n    if (ret)\n         std::cerr << \"nanosleep issue\" << std::endl;\n    end = std::chrono::steady_clock::now();\n    std::cout << \"nanosleep() call cause me to sleep for: \" \n              << std::chrono::duration_cast<std::\n                  chrono::milliseconds> (end-start).count() \n              << \" millisec\" << std::endl;\n```", "```cpp\n    struct timespec reqClockSleep = {.tv_sec = 1, \n        .tv_nsec = 99999999};\n    start = std::chrono::steady_clock::now();\n    ret = clock_nanosleep (CLOCK_MONOTONIC, 0,\n        &reqClockSleep, NULL);\n    if (ret)\n        std::cerr << \"clock_nanosleep issue\" << std::endl;\n    end = std::chrono::steady_clock::now();\n    std::cout << \"clock_nanosleep() call cause me to sleep for: \" \n              << std::chrono::duration_cast<std::chrono::\n                  milliseconds> (end-start).count() \n              << \" millisec\" << std::endl;\n```", "```cpp\n    start = std::chrono::steady_clock::now();\n    std::this_thread::sleep_for(std::chrono::milliseconds(1500));\n    end = std::chrono::steady_clock::now();\n    std::cout << \"std::this_thread::sleep_for() call\n      cause me to sleep for: \" \n              << std::chrono::duration_cast<std::chrono::\n                  milliseconds> (end-start).count() \n              << \" millisec\" << std::endl;\n    std::cout << \"End ... \" << std::endl;\n}\n```"]