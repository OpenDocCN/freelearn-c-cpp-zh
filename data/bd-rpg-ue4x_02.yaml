- en: Chapter 2. Scripting and Data in Unreal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Unreal中的脚本和数据
- en: Now that we've got a design to work from, we can begin to develop the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以工作的设计，我们可以开始开发游戏了。
- en: Before we can do that, however, we'll be exploring the variety of ways in which
    we can work with game code and game data in the Unreal game engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够这样做之前，我们将探索各种方法，了解我们如何在Unreal游戏引擎中与游戏代码和游戏数据一起工作。
- en: 'This chapter will walk you through the steps necessary to get Unreal and Visual
    Studio installed, and to create a new Unreal Engine project. Additionally, you
    will learn how to create new C++ game code, work with Blueprints and Blueprint
    graphs, and work with custom data for your game. In this chapter, we will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您完成安装Unreal和Visual Studio以及创建新的Unreal Engine项目的步骤。此外，您还将学习如何创建新的C++游戏代码，使用蓝图和蓝图图，以及使用自定义数据为您的游戏工作。在本章中，我们将涵盖以下主题：
- en: Downloading Unreal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载Unreal
- en: Setting up Visual Studio for use with Unreal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Unreal设置Visual Studio
- en: Setting up a new Unreal project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新的Unreal项目
- en: Creating new C++ classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的C++类
- en: Creating Blueprints and Blueprint graphs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建蓝图和蓝图图
- en: Using Data Tables to import spreadsheet data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据表导入电子表格数据
- en: Downloading Unreal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Unreal
- en: Before getting started, make sure that you have at least 18 GB of free disk
    space on your computer. You will need this disk space to hold the development
    environments for Unreal and also your project files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您的计算机上至少有18 GB的空闲磁盘空间。您需要这些磁盘空间来存储Unreal的开发环境和项目文件。
- en: We will now need to download Unreal. To do this, go to [https://www.unrealengine.com](https://www.unrealengine.com)
    and click on the **GET UNREAL** button.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要下载Unreal。为此，请访问[https://www.unrealengine.com](https://www.unrealengine.com)并点击**GET
    UNREAL**按钮。
- en: Before you can download Unreal, you'll need to make an Epic Games account. The
    **GET UNREAL** button will redirect you to an account creation form, so fill it
    out and submit it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在您下载Unreal之前，您需要创建一个Epic Games账户。**GET UNREAL**按钮将带您到一个账户创建表单，所以填写并提交它。
- en: After you've signed in, you'll see the **Download** button. This will download
    the installer for the Epic Games Launcher (from this launcher, you can download
    Unreal version 4.12).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将看到**下载**按钮。这将下载Epic Games Launcher的安装程序（从这个启动器，您可以下载Unreal版本4.12）。
- en: Downloading Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载Visual Studio
- en: We will need to start programming soon, so if you haven't already, now is the
    time to download Visual Studio, which is the integrated development environment
    that we will need to program the framework for our engine and game logic in C++.
    Luckily, Microsoft provides Visual Studio Community for free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就需要开始编程，所以如果您还没有，现在是下载Visual Studio的时候了，这是我们编写引擎和游戏逻辑框架所需的集成开发环境。幸运的是，Microsoft免费提供了Visual
    Studio Community。
- en: To download Visual Studio Community, go to [https://www.visualstudio.com/](https://www.visualstudio.com/)
    and download Community 2015\. This will download the installer for Visual Studio.
    After it downloads, simply run the installer. Note that Visual Studio Community
    2015 does not install C++ by default, so be sure that under **Features**, you
    are installing Visual C++, Common Tools for Visual C++ 2015, and Microsoft Foundation
    Classes for C++. If you do not have C++ installed, you will not be able to write
    or compile code written for UE4 in Visual Studio since UE4 is built on C++.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载Visual Studio Community，请访问[https://www.visualstudio.com/](https://www.visualstudio.com/)并下载Community
    2015。这将下载Visual Studio的安装程序。下载后，只需运行安装程序即可。请注意，Visual Studio Community 2015默认不安装C++，所以请确保在**功能**下安装Visual
    C++、Visual C++ 2015的通用工具和C++的Microsoft Foundation Classes。如果您没有安装C++，您将无法在Visual
    Studio中编写或编译为UE4编写的代码，因为UE4是基于C++构建的。
- en: Setting up Visual Studio for Unreal
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Unreal设置Visual Studio
- en: After you've installed Visual Studio, there are some steps you can take to make
    it easier to work with C++ code in Unreal. These steps are not at all necessary,
    and can be safely skipped.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Visual Studio后，您可以采取一些步骤来使在Unreal中使用C++代码更容易。这些步骤并非绝对必要，可以安全地跳过。
- en: Adding the Solution Platforms drop-down list
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加“解决方案平台”下拉列表
- en: 'On the right-hand side of the toolbar is a drop-down arrow, as shown in the
    following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏的右侧有一个下拉箭头，如下面的截图所示：
- en: '![Adding the Solution Platforms drop-down list](img/B04548_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![添加“解决方案平台”下拉列表](img/B04548_02_01.jpg)'
- en: Click on this button, hover over the **Add** or **Remove** buttons, and click
    on **Solution Platforms** to add the menu to the toolbar.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此按钮，将鼠标悬停在**Add**或**Remove**按钮上，然后点击**Solution Platforms**以将菜单添加到工具栏。
- en: The **Solution Platforms** drop-down list allows you to switch the project between
    target platforms (for instance, Windows, Mac, and so on).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Solution Platforms**下拉列表允许你在目标平台之间切换项目（例如，Windows、Mac等）。'
- en: Disabling the Error List tab
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用错误列表标签
- en: The error list in Visual Studio shows you the errors that it detects in your
    code before you even compile the project. While normally this is incredibly useful,
    in Unreal, it can frequently detect false positives and become more annoying than
    helpful.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio中的错误列表在你编译项目之前显示它检测到的错误。虽然这通常非常有用，但在Unreal中，它可能会频繁检测到假阳性，并且比有帮助还要令人烦恼。
- en: 'To disable the error list, first close the **Error List** tab (you can find
    this in the bottom pane, as shown in the following screenshot):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用错误列表，首先关闭**Error List**标签（你可以在下面的面板中找到，如下面的截图所示）：
- en: '![Disabling the Error List tab](img/B04548_02_10.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![禁用错误列表标签](img/B04548_02_10.jpg)'
- en: 'Then, navigate to **Tools** | **Options**, expand the **Projects and Solutions**
    group, and uncheck the **Always show Error List if build finishes with errors**
    option:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，导航到**Tools** | **Options**，展开**Projects and Solutions**组，并取消选中**Always show
    Error List if build finishes with errors**选项：
- en: '![Disabling the Error List tab](img/B04548_02_11.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![禁用错误列表标签](img/B04548_02_11.jpg)'
- en: Setting up a new Unreal project
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新的Unreal项目
- en: Now that you have both Unreal and Visual Studio downloaded and installed, we're
    going to create a project for our game.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载并安装了Unreal和Visual Studio，我们将为我们的游戏创建一个项目。
- en: Unreal comes with a variety of starter kits that you can use, but for our game,
    we'll be scripting everything from scratch.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal提供了一系列你可以使用的入门套件，但为了我们的游戏，我们将从头开始编写所有脚本。
- en: 'After signing into Epic Games Launcher, you''ll first want to download the
    Unreal Engine. This book uses version 4.12\. You may use a later version, but
    depending on the version, some code and the navigation of the engine may slightly
    differ. The steps for creating a new project are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录Epic Games Launcher后，你首先想要下载Unreal Engine。本书使用版本4.12。你可以使用更高版本，但根据版本的不同，一些代码和引擎的导航可能会有所不同。创建新项目的步骤如下：
- en: Firstly, in the **Unreal Engine** tab, select **Library**. Then, under **Engine
    Versions**, click on **Add Versions** and select the version you'd like to download.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**Unreal Engine**标签下，选择**Library**。然后，在**Engine Versions**下，点击**Add Versions**并选择你想要下载的版本。
- en: After the engine has downloaded, click on the **Launch** button.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完引擎后，点击**Launch**按钮。
- en: Once the Unreal Engine has launched, click on the **New Project** tab. Then,
    click on the **C++** tab and select **Basic Code**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unreal Engine启动，点击**New Project**标签。然后，点击**C++**标签并选择**Basic Code**。
- en: Finally, choose a location for your project and give it a name (in my case,
    I named the project `RPG`).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，选择你的项目位置并给它命名（在我的情况下，我给项目命名为`RPG`）。
- en: In my case, after the project was created, it automatically closed the engine
    and opened Visual Studio. At this point, I've found it best to close Visual Studio,
    go back to Epic Games Launcher, and relaunch the engine. Then, open your new project
    from here. Finally, after the editor has launched, go to **File** | **Open Visual
    Studio**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，创建项目后，引擎会自动关闭并打开Visual Studio。在这个时候，我发现最好关闭Visual Studio，回到Epic Games
    Launcher，并重新启动引擎。然后，从这里打开你的新项目。最后，在编辑器启动后，转到**File** | **Open Visual Studio**。
- en: The reason for this is because, while you can launch the editor by compiling
    your Visual Studio project, in some rare cases you may have to close the editor
    any time you want to compile a new change. If, on the other hand, you launch Visual
    Studio from the editor (rather than the other way around), you can make a change
    in Visual Studio and then compile the code from within the editor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，虽然你可以通过编译Visual Studio项目来启动编辑器，但在某些罕见情况下，你可能每次想要编译新的更改时都必须关闭编辑器。另一方面，如果你从编辑器（而不是反过来）启动Visual
    Studio，你可以在Visual Studio中做出更改，然后从编辑器内部编译代码。
- en: At this point, you have an empty Unreal project and Visual Studio that are ready
    to go.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有一个空白的Unreal项目和准备就绪的Visual Studio。
- en: Creating a new C++ class
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的C++类
- en: 'We''re now going to create a new C++ class with the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将按照以下步骤创建一个新的C++类：
- en: To do this, from the Unreal editor, click on **File** | **New C++ Class**. We'll
    be creating an Actor class, so select **Actor** as the base class. Actors are
    the objects that are placed in the scene (anything from meshes, to lights, to
    sounds, and more).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，从 Unreal 编辑器中，点击 **文件** | **新建 C++ 类**。我们将创建一个演员类，因此选择 **Actor** 作为基类。演员是放置在场景中的对象（从网格到灯光，再到声音等等）。
- en: Next, enter a name for your new class, such as `MyNewActor`. Hit **Create Class**.
    After it adds the files to the project, open `MyNewActor.h` in Visual Studio.
    When you create a new class using this interface, it will generate both a header
    file and a source file for your class.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为你的新类输入一个名称，例如 `MyNewActor`。点击 **创建类**。在它将文件添加到项目后，在 Visual Studio 中打开 `MyNewActor.h`
    文件。当你使用此界面创建新类时，它将为你的类生成一个头文件和一个源文件。
- en: Let's just make our actor print a message to the output log when we start our
    game. To do this, we'll use the `BeginPlay` event. `BeginPlay` is called once
    the game has started (in a multiplayer game, this might be called after an initial
    countdown, but in our case, it will be called immediately).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们的演员在游戏开始时向输出日志打印一条消息。为此，我们将使用 `BeginPlay` 事件。`BeginPlay` 在游戏开始后调用（在多人游戏中，这可能在初始倒计时之后调用，但在我们的情况下，它将立即调用）。
- en: 'The `MyNewActor.h` file (which should already be open at this point) should
    contain the following code after the `GENERATED_BODY()` line:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此点应该已经打开的 `MyNewActor.h` 文件应该在 `GENERATED_BODY()` 行之后包含以下代码：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, in `MyNewActor.cpp`, add a log that prints **Hello, world!** in the `void
    AnyNewActor::BeginPlay()` function, which runs as soon as the game starts:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `MyNewActor.cpp` 文件中，添加一个日志，在 `void AnyNewActor::BeginPlay()` 函数中打印 **Hello,
    world!**，该函数在游戏开始时运行：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, switch back to the editor and click on the **Compile** button in the main
    toolbar.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，切换回编辑器并点击主工具栏中的 **编译** 按钮。
- en: Now that your actor class has compiled, we need to add it to the scene. To do
    this, navigate to the **Content Browser** tab located at the bottom of the screen.
    Search for `MyNewActor` (there's a search bar to help you find it) and drag it
    into the scene view, which is the level viewport. It's invisible, so you won't
    see it or be able to click on it. However, if you scroll the **Scene/World Outliner**
    pane (on the right-hand side) to the bottom, you should see the **MyNewActor1**
    actor has been added to the scene:![Creating a new C++ class](img/B04548_02_02.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在既然你的演员类已经编译，我们需要将其添加到场景中。为此，导航到屏幕底部的 **内容浏览器** 选项卡。搜索 `MyNewActor`（有一个搜索栏帮助你找到它），并将其拖入场景视图，即级别视口。它是不可见的，所以你看不到它或无法点击它。然而，如果你将右侧的
    **场景/世界大纲** 窗格（在右侧）滚动到底部，你应该会看到 **MyNewActor1** 演员已经被添加到场景中：![创建新的 C++ 类](img/B04548_02_02.jpg)
- en: To test your new actor class, click on the **Play** button. You should see a
    yellow **Hello, world!** message printed to the console, as shown in the following
    screenshot. This can be seen in the **Output Log** tab on the right-hand side
    of the **Content Browser** tab at the bottom of the screen:![Creating a new C++
    class](img/B04548_02_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试你的新演员类，点击 **播放** 按钮。你应该在控制台看到一条黄色的 **Hello, world!** 消息，如下面的截图所示。这可以在屏幕底部的
    **内容浏览器** 选项卡右侧的 **输出日志** 选项卡中看到：![创建新的 C++ 类](img/B04548_02_03.jpg)
- en: Congratulations, you have created your first actor class in Unreal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你在 Unreal 中创建了第一个演员类。
- en: Blueprints
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图
- en: Blueprints in Unreal is a C++ based visual scripting language built proprietary
    to Unreal. Blueprints will allow us to create code without the need to touch a
    line of text in an IDE such as Visual Studio. Instead, Blueprints allows us to
    create code through the use of drag and drop visual nodes, and connect them together
    to create nearly any kind of functionality you desire. Those of you who have come
    from UDK may find some similarity between Kismet and Blueprints, but unlike Kismet,
    Blueprints allows you to have full control over the creation and modification
    of functions and variables. It also compiles, which is something Kismet did not
    do.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 中的蓝图是一种基于 C++ 的专有可视化脚本语言。蓝图将允许我们创建代码，而无需在 Visual Studio 等集成开发环境（IDE）中触摸任何一行文本。相反，蓝图允许我们通过拖放可视化节点来创建代码，并将它们连接起来以创建你想要的几乎所有功能。那些从
    UDK 过来的人可能会在 Kismet 和蓝图之间发现一些相似之处，但与 Kismet 不同，蓝图允许你对函数和变量的创建和修改拥有完全控制权。它还会进行编译，这是
    Kismet 所没有的功能。
- en: Blueprints can inherit from C++ classes, or from other Blueprints. So, for instance,
    you might have an `Enemy` class. An enemy might have a **Health** field, a **Speed**
    field, an **Attack** field, and a **Mesh** field. You can then create multiple
    enemy templates by creating Blueprints that inherit from your `Enemy` class and
    changing each type of enemy's Health, Speed, Attack, and Mesh.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图可以继承自 C++ 类，或者从其他蓝图继承。例如，你可能有一个 `Enemy` 类。敌人可能有一个 **健康** 字段，一个 **速度** 字段，一个
    **攻击** 字段和一个 **网格** 字段。然后，你可以通过创建继承自你的 `Enemy` 类的蓝图并更改每种敌人的健康、速度、攻击和网格来创建多个敌人模板。
- en: You can also expose parts of your C++ code to Blueprint graphs so that your
    Blueprint graphs and your core game code can communicate and work with each other.
    As an example, your inventory code may be implemented in C++, and it might expose
    functions to Blueprints so that a Blueprint graph can give items to the player.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将你的 C++ 代码的部分暴露给蓝图图，以便你的蓝图图和核心游戏代码可以相互通信并协同工作。例如，你的库存代码可能是在 C++ 中实现的，并且它可能向蓝图暴露函数，以便蓝图图可以给玩家提供物品。
- en: Creating a new Blueprint
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的蓝图
- en: 'The steps to create a new Blueprint are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新蓝图的操作步骤如下：
- en: In the **Content Browser** pane, create a new Blueprint folder by clicking on
    the **Add New** drop-down list and selecting **New Folder**, then renaming the
    folder `Blueprint`. Inside this folder, right-click and select **Blueprints**
    | **Blueprint Class**. Select **Actor** as the parent class for the Blueprint.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **内容浏览器** 面板中，通过点击 **添加新内容** 下拉列表并选择 **新建文件夹**，然后重命名文件夹为 `Blueprint`，来创建一个新的蓝图文件夹。在这个文件夹中，右键单击并选择
    **蓝图** | **蓝图类**。将蓝图作为父类选择 **Actor**。
- en: Next, give a name to your new Blueprint, such as `MyNewBlueprint`. To edit this
    Blueprint, double-click on its icon in the **Content Browser** tab.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，给你的新蓝图命名，例如 `MyNewBlueprint`。要编辑这个蓝图，双击 **内容浏览器** 选项卡中它的图标。
- en: Next, switch to the **Event Graph** tab.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，切换到 **事件图** 选项卡。
- en: If **Event Begin Play** is not already there, right-click on the graph and expand
    **Add Event**; then, click on **Event Begin Play**. If you ever need to move around
    nodes such as **Event Begin Play**, you can simply left-click on the node and
    drag it anywhere on the graph you want. You can also navigate through the graph
    by holding down the right-click mouse button and dragging across the screen:![Creating
    a new Blueprint](img/B04548_02_05.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 **事件开始播放** 节点还没有在那里，右键单击图并展开 **添加事件**；然后，点击 **事件开始播放**。如果你需要移动 **事件开始播放**
    等节点，只需在节点上左键单击并拖动到图上你想要的位置。你还可以通过按住鼠标右键并拖动屏幕来在图中导航：![创建新的蓝图](img/B04548_02_05.jpg)
- en: This will add a new event node to the graph.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在图中添加一个新的事件节点。
- en: Next, right-click and begin typing `print` into the search bar. You should see
    the **Print String** option in the list. Click on it to add a new **Print String**
    node to your graph.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击并开始在搜索栏中输入 `print`。你应该会在列表中看到 **打印字符串** 选项。点击它以将一个新的 **打印字符串** 节点添加到你的图中。
- en: Next, we want to have this node triggered when the **Event Begin Play** node
    is triggered. To do this, drag from the output arrow of the **Event Begin Play**
    node to the input arrow of the **Print String** node:![Creating a new Blueprint](img/B04548_02_06.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望当 **事件开始播放** 节点被触发时，这个节点被触发。为此，从 **事件开始播放** 节点的输出箭头拖动到 **打印字符串** 节点的输入箭头：![创建新的蓝图](img/B04548_02_06.jpg)
- en: Now, the **Print String** node will be triggered when the game begins. However,
    let's take this one step further and add a variable to our Blueprint.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**打印字符串** 节点将在游戏开始时被触发。但是，让我们更进一步，给我们的蓝图添加一个变量。
- en: On the left-hand side in the **My Blueprint** pane, click on the **Variable**
    button. Give a name to your variable (such as `MyPrintString`) and change the
    **Variable Type** drop-down list to **String**.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **我的蓝图** 面板中，点击 **变量** 按钮。给你的变量命名（例如 `MyPrintString`）并将 **变量类型** 下拉列表更改为
    **字符串**。
- en: To feed the value of this variable into our **Print String** node, right-click
    and search for `MyPrintString`. You should see a **Get My Print String** node
    available in the list. Click on this to add the node to your graph:![Creating
    a new Blueprint](img/B04548_02_07.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这个变量的值输入到我们的 **打印字符串** 节点中，右键单击并搜索 `MyPrintString`。你应该会在列表中看到一个可用的 **获取我的打印字符串**
    节点。点击它以将节点添加到你的图中：![创建新的蓝图](img/B04548_02_07.jpg)
- en: Next, just as you did to connect **Event Begin Play** and **Print String** together,
    drag from the output arrow of the **Get My Print String** node to the input pin
    of the **Print String** node that is right next to the **In String** label.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，就像您将**事件开始播放**和**打印字符串**连接在一起一样，从**获取我的打印字符串**节点的输出箭头拖动到紧挨着**字符串输入**标签的**打印字符串**节点的输入引脚。
- en: Finally, switch over to the **Defaults** tab. At the very top, under the **Defaults**
    section, there should be a text field for editing the value of the `MyPrintString`
    variable. Enter whatever text you'd like into this field. Then, to save your Blueprint,
    first press the **Compile** button in the **Blueprint** window and then click
    on the **Save** button next to it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，切换到**默认**选项卡。在最顶部，在**默认**部分下，应该有一个用于编辑`MyPrintString`变量值的文本字段。将您想要的任何文本输入到这个字段中。然后，要保存您的蓝图，首先在**蓝图**窗口中按**编译**按钮，然后点击旁边的**保存**按钮。
- en: Adding a Blueprint to the scene
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将蓝图添加到场景中
- en: Now that you've created the Blueprint, simply drag it from the **Content Browser**
    tab into the scene. Just as with our custom actor class, it will be invisible,
    but if you scroll **Scene Outliner** to the bottom, you'll see the **MyNewBlueprint**
    item in the list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了蓝图，只需将其从**内容浏览器**选项卡拖动到场景中。就像我们的自定义实体类一样，它将是不可见的，但如果您将**场景大纲**滚动到底部，您会在列表中看到**MyNewBlueprint**项。
- en: To test our new Blueprint, press the **Play** button. You should see that the
    text you entered is briefly printed to the screen (it will also show up in the
    **Output Log**, but it may be difficult to spot amidst the other output messages).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们新的蓝图，请按**播放**按钮。您应该看到您输入的文本被短暂地打印到屏幕上（它也会出现在**输出日志**中，但可能难以在其他输出消息中找到）。
- en: Blueprints for Actor classes
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体类蓝图
- en: 'You can choose other classes for a Blueprint to inherit from. For instance,
    let''s create a new Blueprint to inherit from the custom `MyNewActor` class we
    created earlier:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为蓝图选择其他类进行继承。例如，让我们创建一个新的蓝图，从我们之前创建的定制`MyNewActor`类继承：
- en: To do this, start creating a new Blueprint as before. Then, when choosing a
    parent class, search for `MyNewActor`. Click on the **MyNewActor** entry in the
    list:![Blueprints for Actor classes](img/B04548_02_12.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，首先像之前一样创建一个新的蓝图。然后，在选择父类时，搜索`MyNewActor`。点击列表中的**MyNewActor**条目：![实体类蓝图](img/B04548_02_12.jpg)
- en: You can name this Actor whatever you want. Next, open the Blueprint and click
    on **Save**. Now, add the Blueprint to your scene and run the game. You should
    now have two **Hello, world!** messages logged to the console (one from our placed
    actor and the other from our new Blueprint).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以为这个实体命名任何您想要的名称。接下来，打开蓝图并点击**保存**。现在，将蓝图添加到您的场景中并运行游戏。您现在应该在控制台看到两条**Hello,
    world!**消息记录（一条来自我们放置的实体，另一条来自我们新的蓝图）。
- en: Using Data Tables to import spreadsheet data
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据表导入电子表格数据
- en: In Unreal, **Data Tables** are a method of importing and using custom game data
    exported from a spreadsheet application. To do this, you first ensure that your
    spreadsheet follows some guidelines for format; additionally, you write a C++
    struct that contains the data for one row of the spreadsheet. Then, you export
    a CSV file and select your C++ struct as the data type for that file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，**数据表**是导入和使用从电子表格应用程序导出的自定义游戏数据的方法。为此，您首先确保您的电子表格遵循一些格式指南；此外，您编写一个包含电子表格一行数据的C++结构体。然后，您导出一个CSV文件，并将您的C++结构体选择为该文件的数据类型。
- en: The spreadsheet format
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子表格格式
- en: Your spreadsheet must follow some simple rules in order to correctly export
    to Unreal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电子表格必须遵循一些简单的规则，才能正确导出到虚幻引擎。
- en: The very first cell must remain blank. After this, the first row will contain
    the names of the fields. These will be the same as the variable names in your
    C++ struct later, so do not use spaces or other special characters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 非常第一个单元格必须保持空白。在此之后，第一行将包含字段的名称。这些将与您稍后C++结构体中的变量名相同，因此不要使用空格或其他特殊字符。
- en: The first column will contain the **lookup key** for each entry. That is, if
    the first cell of the first item in this spreadsheet is 1, then in Unreal, you
    would use 1 to find that entry. This must be unique for every row.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列将包含每个条目的**查找键**。也就是说，如果这个电子表格中第一项的第一单元格是1，那么在虚幻引擎中，您将使用1来查找该条目。这必须对每一行都是唯一的。
- en: Then, the following columns contain the values for each variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下列包含每个变量的值。
- en: A sample spreadsheet
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例电子表格
- en: 'Let''s create a simple spreadsheet to import into Unreal. It should look like
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的工作表导入到Unreal中。它应该看起来像这样：
- en: '![A sample spreadsheet](img/B04548_02_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![一个示例工作表](img/B04548_02_08.jpg)'
- en: 'As mentioned in the previous section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述：
- en: Column **A** contains the lookup keys for each row. The first cell is empty
    and the following cells have the lookup keys for each row.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列**A**包含每行的查找键。第一个单元格是空的，后面的单元格包含每行的查找键。
- en: Column **B** contains the values for the `SomeNumber` field. The first cell
    contains the field name (`SomeNumber`) and the following cells contain the values
    for that field.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列**B**包含`SomeNumber`字段的值。第一个单元格包含字段名称（`SomeNumber`），后面的单元格包含该字段的值。
- en: Column **C** contains the values for the `SomeString` field. Just as with column
    **B**, the first cell contains the name of the field (`SomeString`) and the following
    cells contain the values for that field.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列**C**包含`SomeString`字段的值。就像列**B**一样，第一个单元格包含字段名称（`SomeString`），后面的单元格包含该字段的值。
- en: I'm using Google Spreadsheets—with this, you would click on **File** | **Download
    as** | **Comma-separated values (.csv, current sheet)** to export this to CSV.
    Most spreadsheet applications have the ability to export to the CSV format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Google表格——使用这个，你会点击**文件** | **另存为** | **逗号分隔值 (.csv, 当前工作表)**来导出为CSV。大多数电子表格应用程序都有导出为CSV格式的功能。
- en: At this point, you have a CSV file that can be imported into Unreal. However,
    do not import it yet. Before we do that, we'll need to create the C++ struct for
    it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你有一个可以导入Unreal的CSV文件。然而，现在不要导入它。在我们这样做之前，我们需要为它创建一个C++结构体。
- en: The Data Table struct
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据表结构体
- en: Just as you created the actor class earlier, let's create a new class. Choose
    `Actor` as the parent class and give it a name such as `TestCustomData`. Our class
    won't actually inherit from `Actor` (and, for that matter, it won't be a class),
    but doing this allows Unreal to generate some code in the background for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前创建演员类一样，让我们创建一个新的类。选择`Actor`作为父类，并给它一个像`TestCustomData`这样的名字。我们的类实际上不会从`Actor`继承（并且，就这个而言，它不会是一个类），但这样做允许Unreal在后台为我们生成一些代码。
- en: 'Next, open the `TestCustomData.h` file and replace the entire file with the
    following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`TestCustomData.h`文件，并用以下代码替换整个文件：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the variable names are exactly the same as the header cells in the
    spreadsheet—this is important, as it shows how Unreal matches columns in the spreadsheet
    to the fields of this struct.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变量名与工作表中的表头单元格完全相同——这很重要，因为它显示了Unreal如何将工作表中的列与该结构体的字段匹配。
- en: Next, remove everything from the `TestCustomData.cpp` file, with the exception
    of the `#include` statements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`TestCustomData.cpp`文件中删除所有内容，除了`#include`语句。
- en: Now, switch back to the editor and click on **Compile**. It should compile without
    any issues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换回编辑器并点击**编译**。它应该没有问题编译。
- en: Now that you've created the struct, it's time to import your custom spreadsheet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了结构体，是时候导入你的自定义工作表了。
- en: Importing the spreadsheet
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入工作表
- en: Next, simply drag your CSV file into the **Content Browser** tab. This will
    show a pop-up window, asking you to pick how you want to import the data and also
    what type of data it is. Leave the first drop-down list to **Data Table** and
    expand the second drop-down list to pick **TestCustomData** (the struct you just
    created).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只需将你的CSV文件拖放到**内容浏览器**标签页中。这将弹出一个窗口，询问你想要如何导入数据以及数据的类型。将第一个下拉列表保留为**数据表**，展开第二个下拉列表以选择**TestCustomData**（你刚刚创建的结构体）。
- en: 'Click on **OK** and it will import the CSV file. If you double-click the asset
    in the **Content Browser** tab, you''ll see a list of the items that were in the
    spreadsheet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**，它将导入CSV文件。如果你在**内容浏览器**标签页中双击该资产，你会看到工作表中包含的项目列表：
- en: '![Importing the spreadsheet](img/B04548_02_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![导入工作表](img/B04548_02_09.jpg)'
- en: Querying the spreadsheet
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询工作表
- en: You can query the spreadsheet in order to find particular rows by name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过名称查询工作表以找到特定的行。
- en: We'll add this to our custom actor class, `MyNewActor`. The first thing we need
    to do is expose a field to a Blueprint, allowing us to assign a Data Table for
    our actor to use.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把它添加到我们的自定义演员类`MyNewActor`中。首先，我们需要将一个字段暴露给蓝图，这样我们就可以为我们的演员分配一个数据表。
- en: 'Firstly, add the following code just after the `GENERATED_BODY` line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`GENERATED_BODY`行之后添加以下代码：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will expose the Data Table to Blueprint and allow it to
    be edited within Blueprint. Next, we''ll fetch the first row and log its `SomeString`
    field. In the `MyNewActor.cpp` file, add this code to the end of the `BeginPlay`
    function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将数据表暴露给蓝图，并允许在蓝图内对其进行编辑。接下来，我们将获取第一行并记录其`SomeString`字段。在`MyNewActor.cpp`文件中，将以下代码添加到`BeginPlay`函数的末尾：
- en: '[PRE4]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will also need to add `#include TestCustomData.h` at the top of your `MyNewActor.cpp`
    file so that you can see the Data Table properties in it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在`MyNewActor.cpp`文件的顶部添加`#include TestCustomData.h`，这样您就可以在其中看到数据表属性。
- en: Compile the code in the editor. Next, open up the Blueprint you created from
    this actor class. Switch to the **Class Defaults** tab and find the **My New Actor**
    group (this should be at the very top). This should show a **Data Table** field
    that you can expand to pick the CSV file you imported.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中编译代码。接下来，打开您从actor类创建的蓝图。切换到**类默认值**选项卡，找到**My New Actor**组（这应该在最顶部）。这应该显示一个可以展开以选择您导入的CSV文件的**数据表**字段。
- en: Compile and save the Blueprint and then press **Play**. You should see the value
    of `SomeString` for the entry `2` logged to the console.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并保存蓝图，然后按**播放**。你应该能在控制台中看到条目`2`的`SomeString`值。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up Unreal and Visual Studio and created a new project.
    Additionally, we learned how to create new actor classes in C++, what a Blueprint
    is, and how to create and use Blueprint graphs for visual scripting. Finally,
    we learned how to import custom data from spreadsheet applications and query them
    from the game code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了Unreal和Visual Studio，并创建了一个新项目。此外，我们学习了如何在C++中创建新的actor类，什么是蓝图，以及如何创建和使用蓝图图进行可视化脚本编写。最后，我们学习了如何从电子表格应用程序导入自定义数据，并在游戏代码中查询它们。
- en: In the next chapter, we'll start diving into some actual gameplay code and start
    prototyping our game.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将开始深入研究一些实际的游戏代码，并开始原型化我们的游戏。
