- en: Functions and Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和宏
- en: 'When writing code, you''ll find yourself needing to run the same code multiple
    times. The last thing you want to do is to copy and paste the same code in a bunch
    of different places (after all, what happens if you need to make a change?). Wouldn''t
    it be easier to just write it once and call it multiple times? That''s what we''re
    covering in this chapter. The topics we will cover include the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你会发现自己需要多次运行相同的代码。 你最不想做的事情就是在许多不同的地方复制和粘贴相同的代码（毕竟，如果你需要做出改变会发生什么？）。
    只写一次然后多次调用会不会更容易？ 这就是我们在本章中要讨论的内容。 我们将要涵盖的主题包括以下内容：
- en: Functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Functions with arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带参数的函数
- en: Functions that return a value
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的函数
- en: Initializer lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化列表
- en: More on variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于变量
- en: Macros
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏
- en: Constexpr
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Constexpr
- en: Functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Some things need to be repeated. Code is not one of them. A function is a bundle
    of code that can get called any number of times, as often you wish.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情需要重复。 代码不是其中之一。 函数是一束可以被调用任意次数的代码，你希望多频繁就多频繁。
- en: Analogies are good. Let's explore an analogy that deals with waiters, chefs,
    pizzas, and functions. In English, when we say a person has a function, we mean
    that the person performs some very specific (usually very important) task. They
    can do this task again and again, whenever they are called upon to do so.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类比是很好的。 让我们探讨一个涉及服务员、厨师、披萨和函数的类比。 在英语中，当我们说一个人有一个功能时，我们的意思是这个人执行一些非常具体（通常非常重要）的任务。
    他们可以一遍又一遍地做这个任务，每当他们被要求这样做时。
- en: 'The following comic strip shows the interaction between a waiter (caller) and
    a chef (callee). The waiter wants food for his table, so he calls upon the chef
    to prepare the food required by the waiting table. The chef prepares the food
    and then returns the result to the waiter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下漫画展示了服务员（调用者）和厨师（被调用者）之间的互动。 服务员想要他的桌子上的食物，所以他叫厨师准备等待桌子所需的食物。 厨师准备食物，然后将结果返回给服务员：
- en: '![](img/fc74aa10-910d-4458-9ff7-f6a46c30b1c7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc74aa10-910d-4458-9ff7-f6a46c30b1c7.png)'
- en: Here, the chef performs his function of cooking food. The chef accepted the
    parameters about what type of food to cook (three pepperoni pan pizzas). The chef
    then went away, did some work, and returned with three pizzas. Note that the waiter
    does not know and does not care about how the chef goes about cooking the pizzas.
    The chef abstracts away the process of cooking pizzas for the waiter, so cooking
    a pizza is just a simple, single-line command for the waiter. The waiter just
    wants his request to be completed and the pizzas returned to him.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，厨师执行他烹饪食物的功能。 厨师接受了关于要烹饪什么类型的食物（三个意大利辣香肠披萨）的参数。 厨师然后离开，做了一些工作，然后带着三个披萨回来。
    请注意，服务员不知道也不关心厨师如何烹饪披萨。 厨师为服务员抽象出了烹饪披萨的过程，所以对于服务员来说，烹饪披萨只是一个简单的单行命令。 服务员只是希望他的要求得到满足，并且披萨被送回给他。
- en: When a function (chef) gets called with some arguments (types of pizzas to be
    prepared), the function performs some actions (preparing the pizzas) and optionally
    returns a result (the actual finished pizzas).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数（厨师）被一些参数（要准备的披萨类型）调用时，函数执行一些操作（准备披萨）并可选地返回一个结果（实际完成的披萨）。
- en: An example of a library function – sqrt()
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库函数的一个例子 - sqrt()
- en: Now, let's talk about a more practical example and relate it to the pizza example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈一个更实际的例子，并将其与披萨的例子联系起来。
- en: 'There is a function in the `<cmath>` library called the `sqrt()` function.
    Let me quickly illustrate its use, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<cmath>`库中有一个叫做`sqrt()`的函数。 让我快速说明它的用法，如下所示的代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function call is after the `=` character: `sqrt( 5 )`. So, `sqrt()` can
    find the mathematical square root of any number given to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用在`=`字符之后：`sqrt( 5 )`。 所以，`sqrt()`可以找到任何给定数字的数学平方根。
- en: Do you know how to find the square root of a tough number such as 5? It's not
    simple. A clever soul sat down and wrote a function that can find the square roots
    of all types of numbers. Do you have to understand the math behind how the square
    root of 5 is found to use the `sqrt(5)` function call? Heck, no! So, just as the
    waiter didn't have to understand how to cook a pizza in order to get a pizza as
    the result, the caller of a C++ library function does not have to fully understand
    how that library function works internally to use it effectively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何找到一个像5这样的难题的平方根吗？ 这并不简单。 一个聪明的灵魂坐下来写了一个可以找到各种类型数字的平方根的函数。 你必须理解如何找到5的平方根的数学原理才能使用`sqrt(5)`函数调用吗？
    当然不！ 就像服务员不必理解如何烹饪披萨就能得到披萨一样，C++库函数的调用者不必完全理解库函数的内部工作原理就能有效地使用它。
- en: 'The following are the advantages of using functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的优点如下：
- en: Functions abstract away a complex task into a simple, callable routine. This
    makes the code required to *cook a pizza*, for instance, just a single-line command
    for the caller (the caller is typically your program).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将复杂的任务抽象成一个简单的可调用例程。 这使得为了*烹饪披萨*所需的代码对于调用者（通常是你的程序）来说只是一个单行命令。
- en: Functions avoid the repetition of code where it is not necessary. Say we have
    20 or so lines of code that can find the square root of a double value. We wrap
    these lines of code into a callable function; instead of repeatedly copying and
    pasting these 20 lines of code, we simply call the `sqrt` function (with the number
    to root) whenever we need a root.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数避免了不必要的代码重复。 假设我们有大约20行代码，可以找到一个双精度值的平方根。 我们将这些行代码包装成一个可调用的函数；而不是重复地复制和粘贴这20行代码，我们只需在需要根时简单地调用`sqrt`函数（带有要开方的数字）。
- en: 'The following diagram shows the process of finding a square root:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了找到平方根的过程：
- en: '![](img/59897c3a-4d94-4e10-b59b-a99f766f8a8f.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59897c3a-4d94-4e10-b59b-a99f766f8a8f.png)'
- en: Writing our own functions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们自己的函数
- en: 'Say we want to write some code that prints out a strip of road, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想写一些代码，打印出一条道路，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, say we want to print two strips of road in a row, or three strips of road.
    Or, say we want to print any number of strips of road. We will have to repeat
    the four lines of code that produce the first strip of road once per strip of
    road we're trying to print.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要连续打印两条道路，或者三条道路。或者说我们想要打印任意数量的道路。我们将不得不重复产生第一条道路的四行代码，以每条道路一次的方式。
- en: 'What if we introduced our own C++ command that allowed us to print a strip
    of road on calling the command? Here''s how that will look:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们引入自己的C++命令，允许我们在调用命令时打印一条道路，那将是什么样子：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the definition of a function. A C++ function has the following anatomy:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数的定义。C++函数具有以下结构：
- en: '![](img/0bbc34fb-1b86-45cd-9566-5d90babc62e7.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bbc34fb-1b86-45cd-9566-5d90babc62e7.png)'
- en: 'The `void` means it does not return any values and, since there is nothing
    inside the parentheses, it doesn''t take any parameters. We''ll get into parameters
    and return values later. Using a function is simple: we simply invoke the function
    we want to execute by name, followed by two round brackets, `()`. For example,
    calling the `printRoad()` function will cause the `printRoad()` function to run.
    Let''s trace an example program to fully understand what this means.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`表示它不返回任何值，并且由于括号内没有任何内容，它不需要任何参数。我们稍后会讨论参数和返回值。使用函数很简单：我们只需通过名称调用要执行的函数，后面跟着两个圆括号`()`。例如，调用`printRoad()`函数将导致`printRoad()`函数运行。让我们跟踪一个示例程序，以充分理解这意味着什么。'
- en: A sample program trace
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个示例程序跟踪
- en: 'Here''s a complete example of how a function call works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数调用的完整示例：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's trace the program's execution from beginning to end. Remember that, for
    all C++ programs, execution begins on the first line of `main()`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头到尾跟踪程序的执行。请记住，对于所有C++程序，执行都从`main()`的第一行开始。
- en: '`main()` is also a function. It oversees the execution of the whole program.
    Once `main()` executes the `return` statement, your program ends.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`也是一个函数。它监督整个程序的执行。一旦`main()`执行`return`语句，程序就结束了。'
- en: 'A line-by-line trace of the execution of the preceding program is shown as
    follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述程序执行的逐行跟踪：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is how the output of this program will look:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出将是什么样子：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here''s an explanation of the preceding code, line by line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对上述代码的逐行解释：
- en: The program's execution begins on the first line of `main()`, which outputs
    `program begin!`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的执行从`main()`的第一行开始，输出`program begin!`。
- en: The next line of code that is run is the call to `printRoad()`. What this does
    is it jumps the program counter to the first line of `printRoad()`. All the lines
    of `printRoad()` then execute in order (lines 3-6).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来运行的代码行是对`printRoad()`的调用。这样做的作用是将程序计数器跳转到`printRoad()`的第一行。然后按顺序执行`printRoad()`的所有行（第3-6行）。
- en: After the function call to `printRoad()` is complete, control returns to the
    `main()` statement. We then see `Program end` printed.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`printRoad()`的函数调用完成后，控制权返回到`main()`语句。然后我们看到打印了`Program end`。
- en: Don't forget the brackets after the function call to `printRoad()`. A function
    call must always be followed by round brackets, `()`, otherwise the function call
    will not work and you will get a compiler error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在对`printRoad()`的函数调用后加上括号。函数调用后必须始终跟着圆括号`()`，否则函数调用将无效，并且会得到编译器错误。
- en: 'The following code is used to print four strips of road:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于打印四条道路：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can also use the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用以下代码：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, instead of repeating the four lines of `cout` every time a box is printed,
    we simply call the `printRoad()` function to make it print. Also, if we want to
    change how a printed road looks, we have to simply modify the implementation of
    the `printRoad()` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不需要每次打印一个方框时重复四行`cout`，我们只需调用`printRoad()`函数进行打印。此外，如果我们想要更改打印道路的外观，只需修改`printRoad()`函数的实现即可。
- en: Calling a function entails running the entire body of that function, line by
    line. After the function call is complete, the control of the program then resumes
    at the point of the function call.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数意味着逐行运行该函数的整个主体。函数调用完成后，程序的控制权会在函数调用点恢复。
- en: Exercise
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'As an exercise, find out what is wrong with the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，找出以下代码的问题所在：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Solution
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The correct answer to this problem is that the call to `myFunction` (in the
    last line of `main()`) is not followed by round brackets. All function calls must
    be followed by round brackets. The last line of `main()` should read `myFunction();`,
    not just `myFunction`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的正确答案是，在`main()`的最后一行中对`myFunction`的调用后没有跟着圆括号。所有函数调用后都必须跟着圆括号。`main()`的最后一行应该是`myFunction();`，而不仅仅是`myFunction`。
- en: Functions with arguments
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的函数
- en: How can we extend the `printRoad()` function to print a road with a certain
    number of segments? The answer is simple. We can let the `printRoad()` function
    accept a parameter, called `numSegments`, to print a certain number of road segments.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何扩展`printRoad()`函数以打印具有一定数量段的道路？答案很简单。我们可以让`printRoad()`函数接受一个名为`numSegments`的参数，以打印一定数量的道路段。
- en: 'The following code snippet shows how that will appear:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了它的外观：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the anatomy of a function that accepts an argument:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了接受参数的函数的解剖结构：
- en: '![](img/696b374e-dfb2-4f95-b0c2-ce4c02b8ed63.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/696b374e-dfb2-4f95-b0c2-ce4c02b8ed63.png)'
- en: 'Call this new version of `printRoad()`, asking it to print four segments, as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个新版本的`printRoad()`，要求它打印四个段，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value `4` between the brackets of `function call` in the preceding statement
    gets assigned to the `numSegments` variable of the `printRoad(int numSegments)`
    function. This is how the value `4` gets passed to `numSegments`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，`function call`括号中的值`4`被赋给了`printRoad(int numSegments)`函数的`numSegments`变量。这就是`4`的值如何传递给`numSegments`的方式：
- en: '![](img/6b5ac394-8767-4232-9b36-27f662031484.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b5ac394-8767-4232-9b36-27f662031484.png)'
- en: An illustration of how printRoad(4) will assign the value 4 to the numSegments
    variable
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`printRoad(4)`将把值4赋给numSegments变量的示例'
- en: So, `numSegments` gets assigned the value passed between the brackets in the
    call
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`numSegments`被赋予了调用中括号内传递的值
- en: to `printRoad()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`printRoad()`。'
- en: Functions that return values
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值的函数
- en: An example of a function that returns a value is the `sqrt()` function. The
    `sqrt()` function accepts a single parameter between its brackets (the number
    to root) and returns the actual root of the number.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一个返回值的例子是`sqrt()`函数。`sqrt()`函数接受括号内的单个参数（要开方的数字），并返回该数字的实际平方根。
- en: 'Here''s an example using the `sqrt` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`sqrt`函数的示例：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `sqrt()` function does something analogous to what the chef did when preparing
    the pizzas.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt()`函数做的事情类似于厨师准备比萨时所做的事情。'
- en: As a caller of the function, you do not care about what goes on inside the body
    of the `sqrt()` function; that information is irrelevant since all you want is
    the result of the square root of the number that you are passing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数的调用者，你不关心`sqrt()`函数内部发生了什么；那些信息是无关紧要的，因为你只想要传递的数字的平方根的结果。
- en: 'Let''s declare our own simple function that returns a value, as shown in the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个简单的返回值函数，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the anatomy of a function with parameters and
    a returned value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有参数和返回值的函数的解剖结构：
- en: '![](img/ac3d5a85-c21c-45c1-b467-d1a6eb6f54e6.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac3d5a85-c21c-45c1-b467-d1a6eb6f54e6.png)'
- en: The `sum` function is very basic. All it does is take two `int` numbers, `a`
    and `b`, sums them up together, and returns a result. You might say that we don't
    even need an entire function just to add two numbers. You're right, but bear with
    me for a moment. We will use this simple function to explain the concept of returned
    values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数非常基本。它只是取两个`int`数，`a`和`b`，将它们加在一起，并返回一个结果。你可能会说我们甚至不需要一个完整的函数来只是加两个数字。你是对的，但请稍等片刻。我们将使用这个简单的函数来解释返回值的概念。'
- en: 'You will use the `sum` function in this way (from `main()`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以这种方式使用`sum`函数（从`main()`）：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the `cout` command to complete, the `sum( 5,6 )` function call must be evaluated.
    At the point where the `sum( 5,6 )` function call occurs, the returned value from
    `sum( 5,6 )` is put right there.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`cout`命令完成，必须评估`sum(5,6)`函数调用。在`sum(5,6)`函数调用发生的地方，从`sum(5,6)`返回的值就放在那里。
- en: 'In other words, this is the line of code that `cout` actually sees after evaluating
    the `sum( 5,6 )` function call:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在评估`sum(5,6)`函数调用后，这是`cout`实际看到的代码行：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The returned value from `sum( 5,6 )` is effectively cut and pasted at the point
    of the function call. A value must always be returned by a function that promises
    to do so (if the return type of the function is anything other than `void`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sum(5,6)`返回的值实际上是在函数调用点剪切和粘贴的。如果函数承诺返回一个值（如果函数的返回类型不是`void`），则必须始终返回一个值。
- en: Exercises
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write an `isPositive` function that returns `true` when the double parameter
    passed to it is indeed positive.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`isPositive`函数，当传递给它的双精度参数确实为正时返回`true`。
- en: 'Complete the following function definition:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成以下函数定义：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Write a `getGrade()` function that accepts an integer value (marks out of 100)
    and returns the grade (either `A`, `B`, `C`, `D`, or `F`).
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`getGrade()`函数，接受一个整数值（100分制的分数）并返回等级（`A`、`B`、`C`、`D`或`F`）。
- en: A mathematical function is of the form `f(x) = 3x + 4`. Write a C++ function
    that returns values for `f(x)`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数学函数的形式为`f(x) = 3x + 4`。编写一个返回`f(x)`值的C++函数。
- en: Solutions
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'The `isPositive` function accepts a double parameter and returns a Boolean
    value:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isPositive`函数接受一个双精度参数并返回一个布尔值：'
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the completed `absEqual` function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是完成的`absEqual`函数：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `getGrade()` function is given in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getGrade()`函数在以下代码中给出：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This program is a simple one that should entertain you. The origin of the name function in
    C++ actually came from the math world, as shown in the following code:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序是一个简单的程序，应该能让你娱乐一下。C++中的函数名实际上来自数学世界，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Initializer lists
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化列表
- en: 'Sometimes, you may not know how many items you want to pass to an array. Newer
    versions of C++ have added a simple way of doing this, an initializer list. This
    allows you to pass in any number of items inside curly brackets and separated
    by commas, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不知道要传递给数组多少个项目。C++的新版本添加了一种简单的方法，即初始化列表。这允许你在大括号内传递任意数量的项目，并用逗号分隔，就像这样：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To set this up, you need to use `initializer_list` as the type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，你需要使用`initializer_list`作为类型：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is a template, which we will go into later, but for now all you need to
    know is the type of object you''re putting in the list is inside the angle brackets
    like this: `<int>`.  This could just as easily been another type, such as `float`
    or `char`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模板，我们稍后会详细介绍，但现在你只需要知道放在列表中的对象类型在尖括号内，像这样：`<int>`。这也可以是另一种类型，比如`float`或`char`。
- en: 'To call this function, you can pass in the values like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用这个函数，你可以像这样传入值：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The result will be `10` for this case.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，结果将是`10`。
- en: Variables revisited
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量重温
- en: It's always nice to revisit a topic you've covered before, now that you understand
    C++ coding in much more depth.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你更深入地了解了C++编程，重新讨论之前涉及的主题总是很好的。
- en: Global variables
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: Now that we've introduced the concept of functions, the concept of a global
    variable can be introduced.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍了函数的概念，可以介绍全局变量的概念了。
- en: What is a global variable? A global variable is any variable that is made accessible
    to all of the functions of the program. How can we make a variable that is accessible
    to all of the functions of the program? We simply declare the global variable
    at the top of the code file, usually after or near the `#include` statements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是全局变量？全局变量是程序中所有函数都可以访问的任何变量。我们如何使一个变量可以被程序中所有函数访问？我们只需在代码文件的顶部声明全局变量，通常在`#include`语句之后或附近。
- en: 'Here''s an example program with some global variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个带有一些全局变量的示例程序：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the same `g_string` global variable is accessible to all four functions
    in the program (`addA()`, `addB()`, `addC()`, and `main()`). Global variables
    live for the duration of the program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，相同的`g_string`全局变量可以被程序中的所有四个函数（`addA()`、`addB()`、`addC()`和`main()`）访问。全局变量在程序运行期间存在。
- en: People sometimes prefer to prefix global variables with `g_`, but prefixing
    the variable name with `g_` is not a requirement for a variable to be global.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们喜欢在全局变量前加上`g_`前缀，但在变量名前加上`g_`并不是变量成为全局变量的要求。
- en: Local variables
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量
- en: A local variable is a variable that is defined within a block of code. Local
    variables go out of scope at the end of the block in which they are declared.
    Some examples will follow in the next section, *The* *scope of a variable*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量是在代码块内定义的变量。局部变量在其声明的代码块结束时会超出范围。接下来的部分将举一些例子，*变量的作用域*。
- en: The scope of a variable
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 'The scope of a variable is the area of code where that variable can be used.
    The scope of any variable is basically the block in which it is defined. We can
    demonstrate a variable''s scope using an example, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的作用域是变量可以使用的代码区域。任何变量的作用域基本上就是它定义的代码块。我们可以使用一个示例来演示变量的作用域，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The main thing that defines a variable''s scope is a block. Let''s discuss
    the scope of a couple of the variables defined in the preceding code example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量的作用域的主要因素是代码块。让我们讨论前面代码示例中几个变量的作用域：
- en: '`g_int`: This is a global integer with a scope that ranges from the point it
    was declared until the end of the code file. That is to say, `g_int` can be used
    inside `func()` and `main()`, but it cannot be used in other code files. To have
    a single global variable that is used across multiple code files, you will need
    an external variable.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_int`：这是一个全局整数，其范围从声明它的地方一直到代码文件的末尾。也就是说，`g_int`可以在`func()`和`main()`中使用，但不能在其他代码文件中使用。要想在多个代码文件中使用单个全局变量，你需要一个外部变量。'
- en: '`arg` (the argument of `func()`): This can be used from the first line of `func()`
    (after the opening curly brace, `{`) to the last line of `func()` (until the closing
    curly brace, `}`).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg`（`func()`的参数）：这可以在`func()`的第一行（在开大括号`{`后）到最后一行（在闭大括号`}`前）使用。'
- en: '`fx`: This can be used anywhere inside `func()` until the closing curly brace
    (`}`) of `func()`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fx`：这可以在`func()`的闭合大括号`}`之前的任何地方使用。'
- en: '`main()` (variables inside `main()`): This can be used as marked in the comments.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`（`main()`内的变量）：可以按照注释中标记的使用。'
- en: 'Notice how variables declared inside the brackets of a function''s argument
    list can only be used inside the block below that function''s declaration, for
    example, the `arg` variable passed to `func()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数参数列表括号内声明的变量只能在该函数声明下面的代码块中使用，例如传递给`func()`的`arg`变量：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `arg` variable will die after the closing curly brace (`}`) of the `func()`
    function. This is counter intuitive as the round brackets are technically outside
    the curly braces that define the `{` block `}`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg`变量将在`func()`函数的闭大括号`}`后消失。这与技术上圆括号在定义`{`块`}`之外的大括号外部是相悖的。'
- en: 'The same goes for variables declared inside the round brackets of a `for` loop.
    Take as an example the following `for` loop:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的圆括号内声明的变量也是一样。以以下`for`循环为例：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `int c` variable can be used inside the round brackets of the `for` loop
    declaration or inside the block below the `for` loop declaration. The `c` variable
    will die after the closing of the curly brace of the `for` loop it is declared
    in. If you want the `c` variable to live on after the brace brackets of the `for`
    loop, you need to declare the `c` variable before the `for` loop, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`int c`变量可以在`for`循环声明的圆括号内或在`for`循环声明下面的代码块中使用。`c`变量将在声明它的`for`循环的闭大括号后消失。如果希望`c`变量在`for`循环的大括号外继续存在，需要在`for`循环之前声明`c`变量，如下所示：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Static local variables
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态局部变量
- en: '`static` local variables have a local scope, but they don''t go away when you
    exit the function, and instead remember the value between calls, as shown in the
    following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`局部变量具有局部作用域，但当退出函数时不会消失，而是记住调用之间的值，如下面的代码所示：'
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With the use of the `static` keyword inside `testFunc()`, the `runCount` variable
    remembers its value between calls of `testFunc()`. So, the output of the two separate
    preceding runs of `testFunc()` is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`testFunc()`内使用`static`关键字，`runCount`变量在调用`testFunc()`时记住了它的值。因此，两次分开运行`testFunc()`的输出如下：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s because static variables are only created and initialized once (the
    first time when the function they are declared in runs), and after that, the static
    variable retains its old value. Say we declare `runCount` as a regular, local,
    nonstatic variable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为静态变量只会创建和初始化一次（在声明它的函数第一次运行时），之后静态变量会保留其旧值。假设我们将`runCount`声明为常规的、局部的、非静态变量：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, this is how the output will look:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输出将如下所示：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we see `testFunc` saying `Ran this function 1 time` both times. As a local
    variable, the value of `runCount` is not retained between function calls.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`testFunc`两次都输出`Ran this function 1 time`。作为局部变量，`runCount`的值在函数调用之间不会保留。
- en: You should not overuse static local variables. In general, you should only use
    a static local variable when it is absolutely necessary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应滥用静态局部变量。一般来说，只有在绝对必要时才应使用静态局部变量。
- en: Const variables
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量变量
- en: 'A `const` variable is a variable whose value you promise the compiler not to
    change after the first initialization. We can declare one simply, for example,
    for the value of `pi`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量是一个变量，您承诺编译器在第一次初始化后不会更改其值。我们可以简单地声明一个，例如，对于`pi`的值：'
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since `pi` is a universal constant (one of the few things you can rely on to
    be the same), there should be no need to change `pi` after initialization. In
    fact, changes to `pi` should be forbidden by the compiler. Try, for example, to
    assign `pi` a new value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pi`是一个通用常量（您可以依赖的少数事物之一），因此在初始化后不应该有必要更改`pi`。实际上，编译器应该禁止对`pi`的更改。例如，尝试为`pi`分配一个新值：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will get the following compiler error:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下编译器错误：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This error makes perfect sense because, besides the initialization, we should
    not be able to change the value of `pi`—a variable that is constant.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是完全合理的，因为除了初始化之外，我们不应该能够更改`pi`的值——这是一个常量变量。
- en: Const and functions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和函数
- en: '`const` can be used in many ways, some of which involve functions. Sometimes,
    you are passing a variable into a function, but you don''t want the function to
    make any changes to the value. You may think well, I can just make sure I don''t
    change it, can''t I? That may be the case on your own projects, but what if you''re
    on a big team with multiple programmers? You could just put a comment, but it''s
    generally better to make sure the parameter is marked as `const`. To do that,
    you write the function like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`可以以多种方式使用，其中一些涉及函数。有时，您将一个变量传递到函数中，但您不希望函数对该值进行任何更改。您可能会认为，好吧，我可以确保我不改变它，不是吗？在您自己的项目中可能是这样，但如果您在一个有多个程序员的大团队中呢？您可以添加注释，但通常最好确保将参数标记为`const`。为此，您可以编写以下函数：'
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, if you try to change either of these values, you will cause an error.
    For example, this won''t work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您尝试更改这些值中的任何一个，将会导致错误。例如，这样不起作用：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also return a constant value by changing it to something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将其更改为以下内容之一来返回一个常量值：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Just make sure you save the value that the function returns in a variable that
    is also marked as `const` or you'll get an error.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只需确保将函数返回的值保存在一个也标记为`const`的变量中，否则将会出错。
- en: Function prototypes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数原型
- en: 'A function prototype is the signature of the function without the body. For
    example, let''s prototype the `isPositive`, `absEqual`, and `getGrade` functions
    from the following exercises:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数原型是函数的签名，不包括函数体。例如，让我们从以下练习中原型化`isPositive`，`absEqual`和`getGrade`函数：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how the function prototypes are just the return type, function name,
    and argument list that the function requires. Function prototypes don't get a
    body. The body of the function is typically put in the `.cpp` file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数原型只是函数需要的返回类型、函数名称和参数列表。函数原型不包含函数体。函数的主体通常放在`.cpp`文件中。
- en: .h and .cpp files
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .h和.cpp文件
- en: It is typical to put your function prototypes in a `.h` file and the bodies
    of the functions in a `.cpp` file. The reason for this is you can include your
    `.h` file in a bunch of `.cpp` files and not get multiple definition errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数原型放在`.h`文件中，将函数的主体放在`.cpp`文件中是典型的。这样做的原因是您可以在一堆`.cpp`文件中包含您的`.h`文件，而不会出现多重定义错误。
- en: 'The following screenshot gives you a clear picture of `.h` and `.cpp` files,
    showing `.cpp` files for the main code and for functions, and a `.h` file holding
    the function prototypes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图向您展示了`.h`和`.cpp`文件的清晰图像，显示了主代码和函数的`.cpp`文件，以及保存函数原型的`.h`文件：
- en: '![](img/95086156-bec4-4b0d-bb04-96ccf2f21185.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95086156-bec4-4b0d-bb04-96ccf2f21185.jpg)'
- en: 'Here, we have three files in this Visual C++ project:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Visual C++项目中，我们有三个文件：
- en: '![](img/fe37fba4-9f16-44bf-a7a6-42836edb896e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe37fba4-9f16-44bf-a7a6-42836edb896e.png)'
- en: prototypes.h
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prototypes.h
- en: 'The `prototypes.h` file contains function prototypes. We will explain what
    the `extern` keyword does later:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototypes.h`文件包含函数原型。我们稍后将解释`extern`关键字的作用：'
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: funcs.cpp
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: funcs.cpp
- en: 'The following is the content of `funcs.cpp`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`funcs.cpp`的内容：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: main.cpp
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main.cpp
- en: 'The following is the content of `main.cpp`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`main.cpp`的内容：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When you split up the code into `.h` and `.cpp` files, the `.h` file (the header
    file) is called the interface and the `.cpp` file (the one with the actual functions
    in it) is called the implementation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将代码拆分为`.h`和`.cpp`文件时，`.h`文件（头文件）称为接口，而`.cpp`文件（其中包含实际函数的文件）称为实现。
- en: The puzzling part at first for some programmers is how does C++ know where the
    `isPositive` and `getGrade` function bodies are, if we only `#include` the prototypes?
    Shouldn't we `#include` the `funcs.cpp` file into `main.cpp` too?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些程序员来说，最初令人困惑的部分是，如果我们只`#include`原型，C++如何知道`isPositive`和`getGrade`函数体在哪里？如果我们只`#include`原型，`main.cpp`中也应该`#include`
    `funcs.cpp`文件吗？
- en: The answer is *magic*. You only need to `#include` the `prototypes.h` header
    file in both `main.cpp` and `funcs.cpp`. As long as both `.cpp` files are included
    in your C++ **Integrated Development Environment** (**IDE**) project (that is,
    they appear in the Solution Explorer tree view at the left-hand side), the linkup
    of the prototypes to the function bodies is done automatically by the compiler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是*魔法*。您只需要在`main.cpp`和`funcs.cpp`中都`#include` `prototypes.h`头文件。只要这两个`.cpp`文件都包含在您的C++
    **集成开发环境**（**IDE**）项目中（即它们出现在左侧的解决方案资源管理器树视图中），编译器会自动完成原型与函数主体的链接。
- en: extern variables
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部变量
- en: An `extern` declaration is similar to a function prototype, only it is used
    on a variable. You can put an `extern` global variable declaration in a `.h` file
    and include this `.h` file in a whole bunch of other files. This way, you can
    have a single global variable that gets shared across multiple source files, without
    getting the multiply defined symbols found linker error. You'd put the actual
    variable declaration in a `.cpp` file so that the variable only gets declared
    once. There is an `extern` variable in the `prototypes.h` file in the previous
    example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`声明类似于函数原型，只是用于变量。您可以在`.h`文件中放置一个`extern`全局变量声明，并在许多其他文件中包含此`.h`文件。这样，您可以拥有一个单一的全局变量，可以在多个源文件中共享，而不会出现多次定义的符号找到链接器错误。您可以将实际的变量声明放在`.cpp`文件中，以便变量只被声明一次。在前面的示例中，`prototypes.h`文件中有一个`extern`变量。'
- en: Macros
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: 'C++ macros are from a class of C++ commands called preprocessor directives.
    A preprocessor directive is executed before compilation takes place. Macros start
    with `#define`. For example, say we have the following macro:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C++宏属于C++命令类别中的一种称为预处理器指令的命令。预处理器指令以`#define`开头。例如，假设我们有以下宏：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the lowest level, macros are simply copy and paste operations that occur
    just before compile time. In the preceding macro statement, the `3.14159` literal
    will be copied and pasted everywhere the symbol `PI` occurs in the program.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，宏只是在编译之前发生的复制和粘贴操作。在前面的宏语句中，文字`3.14159`将被复制和粘贴到程序中符号`PI`出现的每个地方。
- en: 'Take as an example the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What the C++ preprocessor will do is first go through the code and look for
    any use of the `PI` symbol. It will find one such use on this line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: C++预处理器将首先浏览代码，查找`PI`符号的任何使用。它将在这一行找到一个这样的使用：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding line will convert into the following just before compilation:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，前面的行将转换为以下内容：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, all that happens with a `#define` statement is that all of the occurrences
    of the symbol used (for example, `PI`) are replaced by the literal number `3.14159`
    even before compilation occurs. The point of using macros in this way is to avoid
    hardcoding numbers into the code. Symbols are typically easier to read than big,
    long numbers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在`#define`语句中发生的一切就是，使用的符号（例如`PI`）的所有出现都会在编译之前被文字`3.14159`替换。使用宏的目的是避免将数字硬编码到代码中。符号通常比大而长的数字更容易阅读。
- en: 'Advice: try to use `const` variables where possible.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 建议：尽可能使用`const`变量。
- en: 'You can use macros to define constant variables. You can also use `const` variable
    expressions instead. So, say we have the following line of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用宏来定义常量变量。您也可以使用`const`变量表达式。因此，假设我们有以下代码行：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We will be encouraged to use the following instead:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被鼓励使用以下内容：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using a `const` variable will be encouraged because it stores your value inside
    an actual variable. The variable is typed and typed data is a good thing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼓励使用`const`变量，因为它将您的值存储在实际变量中。变量是有类型的，有类型的数据是一件好事。
- en: Macros with arguments
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的宏
- en: 'We can also write macros that accept arguments. Here''s an example of a macro
    with an argument:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写接受参数的宏。以下是带参数的宏的示例：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What this macro will do is every time `println("Some value")` is encountered
    in the code, the code on the right-hand side (`cout << "Some value" << endl`)
    will be copied and pasted into the console. Notice how the argument between the
    brackets is copied in the place of `X`. Say we had the following line of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏的作用是，每当代码中遇到`println("Some value")`时，右侧的代码（`cout << "Some value" << endl`）将被复制和粘贴到控制台中。注意括号中的参数是在`X`的位置被复制的。假设我们有以下代码行：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will be replaced by the following statement:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被以下语句替换：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Macros with arguments are exactly like very short functions. Macros cannot contain
    any newline characters in them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的宏与非常简短的函数完全相同。宏中不能包含任何换行符。
- en: 'Advice: use inline functions instead of macros with arguments.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 建议：使用内联函数而不是带参数的宏。
- en: You have to know about how macros with arguments work because you will encounter
    them in C++ code a lot. Whenever possible, however, many C++ programmers prefer
    to use inline functions over macros with arguments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须了解带参数的宏的工作原理，因为您会在C++代码中经常遇到它们。然而，许多C++程序员在可能的情况下更喜欢使用内联函数而不是带参数的宏。
- en: 'A normal function call execution involves a `jump` instruction to the function
    and then the execution of the function. An inline function is one whose lines
    of code are copied to the point of the function call and no jump is issued. Using
    inline functions usually makes sense for very small, simple functions that don''t
    have a lot of lines of code. For example, we might inline a simple function, `max`,
    that finds the larger of two values:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的函数调用执行涉及`jump`指令到函数，然后执行函数。内联函数是指其代码行被复制到函数调用点，不发出跳转。通常情况下，使用内联函数是有意义的，因为它们是非常小的、简单的函数，没有很多代码行。例如，我们可能会内联一个简单的函数`max`，找到两个值中的较大值：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Everywhere this `max` function is used, the code for the function body will
    be copied and pasted at the point of the function call. Not having to `jump` to
    the function saves execution time, making inline functions effectively similar
    to macros.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用`max`函数时，函数体的代码将被复制和粘贴到函数调用点。不必跳转到函数可以节省执行时间，使内联函数实际上类似于宏。
- en: There is a catch to using inline functions. Inline functions must have their
    bodies completely contained in the `.h` header file. This is so that the compiler
    can make optimizations and actually inline the function wherever it is used. Functions
    are made inline typically for speed (since you don't have to jump to another body
    of the code to execute the function) but at the cost of code bloat.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联函数有一个限制。内联函数的函数体必须完全包含在`.h`头文件中。这样编译器才能进行优化，并在使用的地方实际内联函数。通常将函数设置为内联是为了提高速度（因为不需要跳转到代码的另一个部分来执行函数），但代价是代码膨胀。
- en: 'The following are the reasons why inline functions are preferred over macros:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内联函数优于宏的原因：
- en: 'Macros are error prone: The argument to the macro is not typed.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏容易出错：宏的参数没有类型。
- en: 'Macros have to be written in one line or you will see them using escaped:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏必须写在一行中，否则您将看到它们使用转义：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the macro is not carefully written, it will result in difficult-to-fix compiler
    errors. For example, if you do not bracket your argument properly, your code will
    just be wrong.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宏没有仔细编写，将导致难以修复的编译器错误。例如，如果您没有正确地使用括号括起参数，您的代码将是错误的。
- en: Large macros are hard to debug.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型宏很难调试。
- en: It should be said that macros do allow you to perform some preprocessor compilation
    magic. UE4 makes a lot of use of macros with arguments, as you will see later.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 应该说的是，宏确实允许您执行一些预处理编译的魔术。正如您将在后面看到的那样，UE4大量使用带参数的宏。
- en: Constexpr
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Constexpr
- en: 'There is one other new way you can also do things that happen at compile time,
    instead of at runtime, and that is by using `constexpr`. As with macros, you can
    create variables and functions that will get automatically copied by the compiler
    to where they are used. So, you can do variables like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种新的方法，您也可以在编译时执行某些操作，而不是在运行时，那就是使用`constexpr`。与宏一样，您可以创建变量和函数，编译器会自动将它们复制到它们被使用的地方。因此，您可以像这样创建变量：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also add `constexpr` to functions you want to run at compile time like
    this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像这样将`constexpr`添加到要在编译时运行的函数中：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'One more thing you can do with `constexpr` is use it with `if` statements to
    evaluate something at compile time. So, if you want to do something different
    for the demo version of the game when you compile it, you can do something like
    this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`if`语句中使用`constexpr`来在编译时评估某些内容。因此，如果您想在编译时为游戏的演示版本执行不同的操作，可以像这样做：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You'll find more uses for these when we talk about templates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论模板时，您会发现更多用途。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Function calls allow you to reuse basic code. Code reuse is important for a
    number of reasons, mainly because programming is hard and duplicating effort should
    be avoided wherever possible. The efforts of the programmer that wrote the `sqrt()`
    function do not need to be repeated by other programmers who want to solve the
    same problem.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用允许您重用基本代码。代码重用对许多原因都很重要，主要是因为编程很困难，应尽量避免重复劳动。编写`sqrt()`函数的程序员的工作不需要其他想解决同样问题的程序员重复。
