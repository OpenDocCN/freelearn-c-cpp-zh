- en: Using Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数
- en: 'Functions are the basic infrastructure of C++; code is contained in functions
    and to execute that code you have to call a function. C++ is remarkably flexible
    in the ways that you can define and call functions: you can define functions with
    a fixed number of parameters or a variable number of parameters; you can write
    generic code so that the same code can be used with different types; and you can
    even write generic code with a variable number of types.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是C++的基本基础设施；代码包含在函数中，要执行该代码，你必须调用一个函数。C++在定义和调用函数的方式上非常灵活：你可以定义具有固定数量参数或可变数量参数的函数；你可以编写通用代码，以便相同的代码可以用于不同的类型；甚至可以编写具有可变数量类型的通用代码。
- en: Defining C++ functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义C++函数
- en: At the most basic level, a function has parameters, has code to manipulate the
    parameters, and returns a value. C++ gives you several ways to determine these
    three aspects. In the following section, we will cover those parts of a C++ function
    from the left to the right of the declaration. Functions can also be **templated**,
    but this will be left to a later section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，函数有参数，有用于操作参数的代码，并返回一个值。C++提供了几种方法来确定这三个方面。在接下来的部分中，我们将从声明的左边到右边来介绍C++函数的这些部分。函数也可以是**模板**的，但这将留到以后的部分。
- en: Declaring and defining functions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和定义函数
- en: A function must be defined exactly once, but through overloading, you can have
    many functions with the same name that differ by their parameters. Code that uses
    a function has to have access to the name of the function, and so it needs to
    have access to either the function definition (for example, the function is defined
    earlier in the source file) or the declaration of the function (also called the
    function prototype). The compiler uses the prototype to type-check that the *calling
    code* is calling the function, using the right types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须被定义一次，但通过重载，你可以有许多具有相同名称但参数不同的函数。使用函数的代码必须能够访问函数的名称，因此它需要访问函数的定义（例如，函数在源文件中较早地定义）或函数的声明（也称为函数原型）。编译器使用原型来对*调用代码*进行类型检查，以确保使用正确的类型调用函数。
- en: Typically, libraries are implemented as separate compiled library files and
    prototypes of the library functions are provided in header files so that many
    source files can use the functions by including the headers. However, if you know
    the function name, parameters, and return type, you can type the prototype yourself
    in your file. Whichever you do, you are simply providing the information for the
    compiler to type-check the expression that calls function. It is up to the linker
    to locate the function in the library and either copy the code into the executable
    or set up the infrastructure to use the function from a shared library. Including
    the header file for a library does not mean that you will be able to use the functions
    from that library because in standard C++, the header file does not have information
    about the library that contains a function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，库被实现为单独的编译库文件，并且库函数的原型在头文件中提供，以便许多源文件可以通过包含这些头文件来使用这些函数。然而，如果你知道函数的名称、参数和返回类型，你可以在你的文件中自己输入原型。无论你做什么，你只是提供信息给编译器来对调用函数的表达式进行类型检查。链接器负责在库中定位函数，并将代码复制到可执行文件中，或者设置基础设施以从共享库中使用函数。包含库的头文件并不意味着你可以使用该库中的函数，因为在标准C++中，头文件并不包含包含函数的库的信息。
- en: Visual C++ provides a `pragma` called `comment`, which can be used with the
    `lib` option as a message to the linker to link with a specific library. So `#pragma
    comment(lib, "mylib")` in a header file will tell the linker to link with `mylib.lib`.
    In general, it is better to use project management tools, such as **nmake** or
    **MSBuild**, to ensure that the right libraries are linked in the project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++提供了一个名为`pragma`的`comment`，它可以与`lib`选项一起使用，作为向链接器发送链接到特定库的消息。因此，在头文件中使用`#pragma
    comment(lib, "mylib")`将告诉链接器链接到`mylib.lib`。一般来说，最好使用项目管理工具，如**nmake**或**MSBuild**，以确保正确的库被链接到项目中。
- en: 'Most of the C Runtime Library is implemented this way: the function is compiled
    in a static library or a dynamic link library, and the function prototypes are
    provided in a header file. You provide the library in the linker command line,
    and typically you will include the header file for the library so that the function
    prototypes are available to the compiler. As long as the linker knows about the
    library, you can type the prototype in your code (and describe it as *external
    linkage* so the compiler knows the function is defined elsewhere). This can save
    you from including some large files into your source files, files that will mostly
    have prototypes of functions that you will not use.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分C运行库都是这样实现的：函数被编译为静态库或动态链接库，函数的原型在头文件中提供。你需要在链接器命令行中提供库，并且通常你会包含库的头文件，以便编译器可以使用函数的原型。只要链接器知道库的存在，你就可以在你的代码中输入原型（并将其描述为*外部链接*，以便编译器知道函数是在其他地方定义的）。这可以避免将一些大文件包含到你的源文件中，这些文件大多数情况下只包含你不会使用的函数的原型。
- en: However, much of the C++ Standard Library is implemented in header files, which
    means that these files can be quite large. You can save compile time by including
    these header files in a precompiled header, as explained in [Chapter 1](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml),
    *Starting with C++*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++标准库的大部分实现在头文件中，这意味着这些文件可能会非常大。你可以通过将这些头文件包含在预编译头文件中来节省编译时间，如[第1章](318b7b93-7e5a-437b-95b3-9b6178ece82c.xhtml)中所述，*开始学习C++*。
- en: 'So far in this book, we have used one source file so all the functions are
    defined in the same file as where they are used, and we have defined the function
    before calling it, that is, the function is defined *above* the code that calls
    it. You do not have to define the function before it is used as long as the function
    prototype is defined before the function is called:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们只使用了一个源文件，因此所有的函数都是在使用它们的同一个文件中定义的，并且我们在调用函数之前定义了函数，也就是说，函数在调用它的代码*上方*被定义。只要在调用函数之前定义了函数原型，就不必在使用函数之前定义函数：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `mult` function is defined after the `main` function, but this code will
    compile because the prototype is given before the `main` function. This is called
    a **forward declaration**. The prototype does not have to have the parameter names.
    This is because the compiler only needs to know the types of the parameters, not
    their names. However, since parameter names should be self-documenting, it is
    usually a good idea to give the parameter names so that you can see the purpose
    of the function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`mult`函数在`main`函数之后定义，但这段代码将会编译，因为在`main`函数之前给出了原型。这被称为**前向声明**。原型不必有参数名。这是因为编译器只需要知道参数的类型，而不需要它们的名称。然而，由于参数名应该是自我说明的，通常最好给出参数名，以便你可以看到函数的目的。'
- en: Specifying linkage
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定链接
- en: 'In the previous example, the function is defined in the same source file, so
    there is *internal linkage*. If the function is defined in another file, the prototype
    will have *external linkage* and so the prototype will have to be defined like
    this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数在同一个源文件中定义，因此具有*内部链接*。如果函数在另一个文件中定义，原型将具有*外部链接*，因此原型必须这样定义：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `extern` keyword is one of many specifiers that you can add to a function
    declaration, and in the previous chapters we have seen others. For example, the
    `static` specifier can be used on a prototype to indicate that the function has
    internal linkage and the name can only be used in the current source file. In
    the preceding example, it is appropriate to mark the function as `static` in the
    prototype.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`关键字是你可以添加到函数声明中的许多限定符之一，在前几章中我们已经见过其他的。例如，`static`限定符可以用于原型，表示函数具有内部链接，名称只能在当前源文件中使用。在前面的例子中，在原型中将函数标记为`static`是合适的。'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also declare a function as `extern "C"`, which affects how the name
    of the function is stored in the object file. This is important for libraries,
    and will be covered shortly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将函数声明为`extern "C"`，这会影响函数名称在目标文件中的存储方式。这对库很重要，不久将会介绍。
- en: Inlining
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联
- en: If a function calculates a value that can be calculated at compile time, you
    can mark it on the left of the declaration with `constexpr` to indicate that the
    compiler can optimize the code by computing the value at compile time. If the
    function value can be calculated at compile time, it means that the parameters
    in the function call must be known at compile time and so they must be literals.
    The function must also be a single line. If these restrictions are not met, then
    the compiler is free to ignore the specifier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数计算的值可以在编译时计算，你可以在声明的左边使用`constexpr`标记它，以指示编译器可以通过在编译时计算值来优化代码。如果函数值可以在编译时计算，这意味着函数调用中的参数必须在编译时已知，因此它们必须是文字。函数还必须是单行的。如果不满足这些限制，那么编译器可以自由地忽略该限定符。
- en: Related is the `inline` specifier. This can be placed on the left of a function
    declaration as a suggestion to the compiler that, when other code calls the function,
    rather than the compiler inserting a jump to the function in memory (and the creation
    of a stack frame), the compiler should put a copy of the actual code in the calling
    function. Again, the compiler is free to ignore this specifier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的是`inline`限定符。这可以放在函数声明的左边，作为对编译器的建议，当其他代码调用函数时，编译器不是插入一个跳转到内存中的函数（和创建一个堆栈帧），而是将实际代码的副本放在调用函数中。同样，编译器可以自由地忽略这个限定符。
- en: Determining the return type
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定返回类型
- en: Functions may be written to run a routine and not return a value. If this is
    the case, you must specify that the function returns `void`. In most cases, a
    function will return a value, if only to indicate that the function has completed
    correctly. There is no requirement that the calling function obtains the return
    value or does anything with it. The calling function can simply ignore the return
    value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能被编写为运行一个例程而不返回值。如果是这种情况，你必须指定函数返回`void`。在大多数情况下，函数会返回一个值，即使只是表示函数已经正确完成。没有要求调用函数获取返回值或对其进行任何操作。调用函数可以简单地忽略返回值。
- en: 'There are two ways to specify the return type. The first way is to give the
    type before the function name. This is the method used in most of the examples
    so far. The second way is called the **trailing return type** and requires that
    you place `auto` as the return type before the function name and use the `->`
    syntax to give the actual return type after the parameter list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以指定返回类型。第一种方法是在函数名之前给出类型。这是到目前为止大多数示例中使用的方法。第二种方法称为**尾返回类型**，要求在函数名之前将`auto`作为返回类型，并使用`->`语法在参数列表之后给出实际的返回类型：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function is so simple that it is a good candidate to be inlined. The return
    type on the left is given as `auto`, meaning that the actual return type is specified
    after the parameter list. The `-> int` means that the return type is `int`. This
    syntax has the same effect as using `int` on the left. This syntax is useful when
    a function is templated and the return type may not be noticeable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单，因此很适合内联。左边的返回类型是`auto`，意味着实际的返回类型在参数列表之后指定。`-> int`表示返回类型是`int`。这种语法与在左边使用`int`具有相同的效果。当函数是模板化的且返回类型可能不明显时，这种语法很有用。
- en: In this trivial example, you can omit the return type entirely and just use
    `auto` on the left of the function name. This syntax means that the compiler will
    deduce the return type from the actual value returned. Clearly the compiler will
    only know what the return type is from the function body, so you cannot provide
    a prototype for such functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，你可以完全省略返回类型，只需在函数名的左边使用`auto`。这种语法意味着编译器将根据实际返回的值推断返回类型。显然，编译器只能从函数体知道返回类型，因此你不能为这种函数提供原型。
- en: Finally, if a function does not return at all (for example, if it goes into
    a never-ending loop to poll some value) you can mark it with the C++11 attribute
    `[[noreturn]]`. The compiler can use this attribute to write more efficient code
    because it knows that it does not need to provide code to return a value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果一个函数根本不返回（例如，如果它进入一个永不结束的循环来轮询某个值），你可以使用C++11属性`[[noreturn]]`标记它。编译器可以使用这个属性来编写更高效的代码，因为它知道不需要提供返回值的代码。
- en: Naming the function
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名函数
- en: 'In general, function names have the same rules for variables: they must begin
    with a letter or an underscore and cannot contain spaces or other punctuation
    characters. Following the general principle of self-documenting code, you should
    name the function according to what it does. There is one exception and these
    are the special functions used to provide overloads for operators (which are mostly
    punctuation symbols). These functions have a name in the form of `operatorx`,
    where `x` is the operator that you will use in your code. A later section will
    explain how to implement operators with global functions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，函数名的规则与变量相同：它们必须以字母或下划线开头，不能包含空格或其他标点符号。遵循自解释代码的一般原则，你应该根据函数的功能来命名函数。有一个例外，那就是用于为运算符提供重载的特殊函数（大部分是标点符号）。这些函数的名称形式为`operatorx`，其中`x`是你在代码中将使用的运算符。后面的部分将解释如何使用全局函数实现运算符。
- en: Operators are one example of overloading. You can overload any function, that
    is, use the same name but provide implementations with different parameter types
    or different numbers of parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是重载的一个例子。你可以重载任何函数，也就是说，使用相同的名称但提供不同参数类型或不同数量的参数的实现。
- en: Function parameters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数
- en: Functions may have no parameters, in which case the function is defined with
    a pair of empty parentheses. A function definition must give the type and name
    of the parameters between the parentheses. In many cases, functions will have
    a fixed number of parameters, but you can write functions with a variable number
    of parameters. You can also define functions with default values for some of the
    parameters, in effect, providing a function that overloads itself on the number
    of parameters passed to the function. Variable argument lists and default arguments
    will be covered later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能没有参数，这种情况下函数定义为一对空括号。函数定义必须在括号之间给出参数的类型和名称。在许多情况下，函数将有固定数量的参数，但你可以编写具有可变数量参数的函数。你还可以为一些参数定义默认值，实际上，提供了一个根据传递给函数的参数数量进行重载的函数。可变参数列表和默认参数将在后面介绍。
- en: Specifying exceptions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定异常
- en: Functions can also be marked to indicate whether they will throw an exception.
    More details about exceptions will be given in [Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml),
    *Diagnostics and Debugging*, but there are two syntaxes you need to be aware of.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数还可以标记是否会抛出异常。关于异常的更多细节将在[第10章](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml)
    *诊断和调试*中给出，但你需要了解两种语法。
- en: 'Earlier versions of C++ allowed you to use the `throw` specifier on a function
    in three ways: firstly, you can provide a comma separated list of the types of
    the exceptions that may be thrown by code in the function; secondly, you can provide
    an ellipsis (`...`) which means that the function may throw any exception; and
    thirdly, you can provide an empty pair of parentheses, which means the function
    will not throw exceptions. The syntax looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的C++允许你以三种方式在函数上使用`throw`说明符：首先，你可以提供一个逗号分隔的异常类型列表，这些异常可能由函数中的代码抛出；其次，你可以提供一个省略号(`...`)，这意味着函数可能抛出任何异常；第三，你可以提供一个空的括号对，这意味着函数不会抛出异常。语法看起来像这样：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `throw` specifier has been deprecated in C++11 largely because the ability
    to indicate the type of exception was not useful. However, the version of `throw`
    that indicates that no exception will be thrown was found to be useful because
    it enables a compiler to optimize code by providing no code infrastructure to
    handle exceptions. C++11 retains this behavior with the `noexcept` specifier:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`说明符在C++11中已经被弃用，主要是因为指示异常类型的能力并不实用。然而，C++11保留了指示不会抛出异常的`throw`版本，因为它使编译器能够通过提供不处理异常的代码基础设施来优化代码。C++11使用`noexcept`说明符保留了这种行为：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Function body
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数体
- en: After the return type, function name, and parameters have been determined, you
    then need to define the body of the function. The code for a function must appear
    between a pair of braces (`{}`). If the function returns a value, then the function
    must have at least one line (the last line in the function) with the `return`
    statement. This must return the appropriate type or a type that can be implicitly
    converted to the return type of the function. As mentioned before, if the function
    is declared as returning `auto`, then the compiler will deduce the return type.
    In this case, all the `return` statements *must* return the same type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了返回类型、函数名和参数之后，你需要定义函数的主体。函数的代码必须出现在一对大括号(`{}`)之间。如果函数返回一个值，那么函数必须至少有一行（函数中的最后一行）带有`return`语句。这个语句必须返回适当的类型或者可以隐式转换为函数返回类型的类型。如前所述，如果函数声明为返回`auto`，那么编译器将推断返回类型。在这种情况下，所有的`return`语句*必须*返回相同的类型。
- en: Using function parameters
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数参数
- en: When a function is called, the compiler checks all the overloads of the function
    to find one that matches the parameters in the calling code. If there is no exact
    match then standard and user-defined type conversions are performed, so the values
    provided by the calling code may be a different type from the parameters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，编译器会检查函数的所有重载，以找到与调用代码中的参数匹配的函数。如果没有完全匹配，则执行标准和用户定义的类型转换，因此调用代码提供的值可能与参数的类型不同。
- en: 'By default, parameters are passed by value and a copy is made, which means
    that the parameters are treated as local variables in the function. The writer
    of the function can decide to pass a parameter by reference, either through a
    pointer or a C++ reference. **Pass-by-reference** means that the variable in the
    calling code can be altered by the function, but this can be controlled by making
    the parameters `const`, in which case the reason for pass-by-reference is to prevent
    a (potentially costly) copy being made. Built-in arrays are always passed as a
    pointer to the first item to the array. The compiler will create temporaries when
    needed. For example, when a parameter is a `const` reference and the calling code
    passes a literal, a temporary object is created, and is only available to code
    in the function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数是按值传递的，并且会进行复制，这意味着参数在函数中被视为局部变量。函数的编写者可以决定通过指针或C++引用通过引用传递参数。**按引用传递**意味着调用代码中的变量可以被函数修改，但这可以通过使参数`const`来控制，这样按引用传递的原因是为了防止进行（可能昂贵的）复制。内置数组始终作为指向数组第一项的指针传递。编译器将在需要时创建临时对象。例如，当参数是`const`引用时，调用代码传递文字时，将创建临时对象，并且仅可用于函数中的代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing Initializer lists
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递初始化列表
- en: 'You can pass an initializer list as a parameter if that list can be converted
    to the type of the parameter. For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该列表可以转换为参数的类型，则可以将初始化列表作为参数传递。例如：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code defines a structure that has two members. In the `main` function,
    a new instance of `point` is created on the stack and it is initialized by accessing
    the members directly. The instance is then passed to a function that has a `point`
    parameter. Since the parameter of `set_point` is pass-by-value, the compiler creates
    a copy of the structure on the stack of the function. The second call of `set_point`
    does the same: the compiler will create a temporary `point` object on the stack
    of the function and initialize it with the values in the initializer list.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个具有两个成员的结构。在`main`函数中，在堆栈上创建了一个`point`的新实例，并通过直接访问成员对其进行初始化。然后将该实例传递给具有`point`参数的函数。由于`set_point`的参数是按值传递的，编译器会在函数的堆栈上创建结构的副本。第二次调用`set_point`也是如此：编译器将在函数的堆栈上创建一个临时的`point`对象，并使用初始化列表中的值对其进行初始化。
- en: Using default parameters
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认参数
- en: 'There are situations when you have one or more parameters that have values
    that are so frequently used that you want them to be treated as a default value
    for the parameter, while still having the option of allowing the caller to provide
    a different value if necessary. To do this, you provide the default value in the
    parameter list of the definition:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您有一个或多个参数，其值使用得如此频繁，以至于您希望它们被视为参数的默认值，同时又可以允许调用者在必要时提供不同的值。为此，您在定义的参数列表中提供默认值：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In most cases, this function is expected to be used to print a single message,
    but occasionally the user may want to have the screen cleared first (say, for
    the first message, or after a pre-determined count of lines). To accommodate this
    use of the function, the `clear_screen` parameter is given a default value of
    `false`, but the caller still has the option of passing a value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，预计该函数用于打印单个消息，但偶尔用户可能希望首先清除屏幕（例如，对于第一条消息，或在预定的行数之后）。为了适应函数的这种用法，`clear_screen`参数被赋予了默认值`false`，但调用者仍然可以选择传递一个值：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the default values occur in the function definition, not in a function
    prototype, so if the `log_message` function is declared in a header file the prototype
    should be:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认值出现在函数定义中，而不是在函数原型中，因此如果`log_message`函数在头文件中声明，则原型应为：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The parameters that can have default values are the right-most parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以具有默认值的参数是最右边的参数。
- en: 'You can treat each parameter with a default value as representing a separate
    overload of the function, so conceptually the `log_message` function should be
    treated as two functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将具有默认值的每个参数视为函数的单独重载，因此在概念上，`log_message`函数应该被视为两个函数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you define a `log_message` function that has just a `const string&` parameter,
    then the compiler will not know whether to call that function or the version where
    `clear_screen` is given a default value of `false`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了一个只有`const string&`参数的`log_message`函数，那么编译器将不知道是调用该函数还是`clear_screen`被赋予默认值`false`的版本。
- en: Variable number of parameters
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数的数量可变
- en: A function with default parameter values can be regarded as having a variable
    number of user-provided parameters, where you know at compile time the maximum
    number of parameters and their values if the caller chooses not to provide values.
    C++ also allows you to write functions where there is less certainty about the
    number of parameters, and the values passed to the function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 具有默认参数值的函数可以被视为具有用户提供的可变数量的参数，其中您在编译时知道参数的最大数量和它们的值，如果调用者选择不提供值。C++还允许您编写函数，其中对于参数的数量以及传递给函数的值存在较少的确定性。
- en: 'There are three ways to have a variable number of parameters: initializer lists,
    C-style variable argument lists, and variadic templated functions. The latter
    of these three will be addressed later in the chapter once templated functions
    have been covered.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以具有可变数量的参数：初始化列表，C风格的可变参数列表和可变模板函数。这三种方法中的后者将在本章后面讨论，一旦涵盖了模板函数。
- en: Initializer lists
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化列表
- en: 'So far in this book, initializer lists have been treated as a kind of C++11
    construct, a bit like built-in arrays. In fact, when you use the initializer list
    syntax using braces, the compiler actually creates an instance of the templated
    `initialize_list` class. If an initializer list is used to initialize another
    type (for example, to initialize a `vector`), the compiler creates an `initialize_list`
    object with the values given between the braces, and the container object is initialized
    using the `initialize_list` iterators. This ability to create an `initialize_list`
    object from a braced initializer list can be used by to give a function a variable
    number of parameters, albeit all of the parameters must be of the same type:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，初始化列表被视为一种C++11构造，有点像内置数组。实际上，当你使用大括号的初始化列表语法时，编译器实际上会创建一个模板化的`initialize_list`类的实例。如果使用初始化列表来初始化另一种类型（例如，初始化一个`vector`），编译器会使用大括号中给定的值创建一个`initialize_list`对象，并使用`initialize_list`迭代器初始化容器对象。这种从大括号初始化列表创建`initialize_list`对象的能力可以用来给函数传递可变数量的参数，尽管所有参数都必须是相同类型的：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `sum` function has a single parameter of `initializer_list<int>`, which
    can only be initialized with a list of integers. The `initializer_list` class
    has very few functions because it only exists to give access to the values in
    the braced list. Significantly, it implements a `size` function that returns the
    number of items in the list, and `begin` and `end` functions that return a pointer
    to the first item in the list, and to the position after the last item. These
    two functions are needed to give iterator access to the list, and it enables you
    to use the object with the ranged-`for` syntax.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数有一个`initializer_list<int>`的单一参数，它只能用整数列表进行初始化。`initializer_list`类的函数非常少，因为它只存在于给予大括号列表中的值的访问。重要的是，它实现了一个`size`函数，返回列表中的项目数，以及`begin`和`end`函数，返回指向列表中第一个项目和最后一个项目后面位置的指针。这两个函数是为了给列表提供迭代器访问而需要的，并且它使你可以使用范围-`for`语法来使用对象。'
- en: This is typical in the C++ Standard Library. If a container holds data in a
    contiguous block of memory, then pointer arithmetic can use the pointer to the
    first item and a pointer immediately after the last item to determine how many
    items are in the container. Incrementing the first pointer gives sequential access
    to every item, and pointer arithmetic allows random access. All containers implement
    a `begin` and `end` function to give access to the container *iterators*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这在C++标准库中很典型。如果一个容器在内存中以连续的内存块保存数据，那么指针算术可以使用指向第一个项目的指针和指向最后一个项目后面的指针来确定容器中有多少项目。递增第一个指针可以顺序访问每个项目，并且指针算术允许随机访问。所有容器都实现了`begin`和`end`函数，以便访问容器的*迭代器*。
- en: In this example, the `main` function calls this function three times, each time
    with a braced initializer list, and the function will return a sum of the items
    in the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`main`函数三次调用这个函数，每次都使用大括号初始化列表，并且函数将返回列表中项目的总和。
- en: Clearly this technique means that each item in the *variable* parameter list
    has to be the same type (or a type that can be converted to the specified type).
    You would have the same result if the parameter had been a `vector`; the difference
    is that an `initializer_list` parameter requires less initialization.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种技术意味着*可变*参数列表中的每个项目都必须是相同类型（或者可以转换为指定类型的类型）。如果参数是一个`vector`，你会得到相同的结果；不同之处在于`initializer_list`参数需要更少的初始化。
- en: Argument lists
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数列表
- en: C++ inherits from C the idea of argument lists. To do this, you use the ellipses
    syntax (`...`) as the last parameter to indicate that the caller can provide zero
    or more parameters. The compiler will check how the function is called and will
    allocate space on the stack for these extra parameters. To access the extra parameters,
    your code must include the `<cstdarg>` header file, which has macros that you
    can use to extract the extra parameters off the stack.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++继承了C的参数列表的概念。为了实现这一点，你可以使用省略号语法（`...`）作为最后一个参数，表示调用者可以提供零个或多个参数。编译器将检查函数的调用方式，并在堆栈上为这些额外的参数分配空间。要访问额外的参数，你的代码必须包含`<cstdarg>`头文件，其中包含了可以用来从堆栈中提取额外参数的宏。
- en: 'This is inherently type-unsafe because the compiler cannot check that the parameters
    that the function will get off the stack at runtime will be the same type as the
    parameters put on the stack by the calling code. For example, the following is
    an implementation of a function that will sum integers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是固有的类型不安全，因为编译器无法检查函数在运行时从堆栈中获取的参数是否与调用代码放在堆栈上的参数类型相同。例如，以下是一个求和整数的函数实现：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The definition of the function must have at least one parameter so that the
    macros work; in this case the parameter is called `first`. It is important that
    your code leaves the stack in a consistent state and this is carried out using
    a variable of the `va_list` type. This variable is initialized at the beginning
    of the function by calling the `va_start` macro and the stack is restored to its
    previous state at the end of the function by calling the `va_end` macro.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的定义必须至少有一个参数，以便宏起作用；在这种情况下，参数被称为`first`。重要的是，你的代码要保持堆栈处于一致的状态，这是通过`va_list`类型的变量来实现的。这个变量在函数开始时通过调用`va_start`宏进行初始化，并在函数结束时通过调用`va_end`宏将堆栈恢复到其先前的状态。
- en: The code in this function simply iterates through the argument list, and maintains
    a sum, and the loop finishes when the parameter has a value of -1\. There are
    no macros to give information about how many parameters there are on the stack,
    nor are there any macros to give an indication of the type of the parameter on
    the stack. Your code has to assume the type of the variable and provide the desired
    type in the `va_arg` macro. In this example, `va_arg` is called, assuming that
    every parameter on the stack is an `int`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的代码简单地遍历参数列表，并维护一个总和，当参数的值为-1时循环结束。没有宏可以提供关于堆栈上有多少参数的信息，也没有宏可以提供关于堆栈上参数的类型的指示。你的代码必须假设变量的类型，并在`va_arg`宏中提供所需的类型。在这个例子中，`va_arg`被调用，假设堆栈上的每个参数都是`int`。
- en: 'Once all parameters have been read off the stack, the code calls `va_end` before
    returning the sum. The function can be called like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有参数都从堆栈中读取完毕后，代码在返回总和之前调用`va_end`。函数可以这样调用：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since `-1` is used to indicate the end of the list, it means that to sum a zero
    number of parameters, you have to pass at least one parameter, that is `-1`. In
    addition, the second line shows that you have a problem if you are passing a list
    of negative numbers (in this case `-1` cannot be a parameter). This problem could
    be addressed in this implementation by choosing another *marker value*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`-1`用于指示列表的结尾，这意味着要对零个参数求和，你必须至少传递一个参数，即`-1`。此外，第二行显示了如果传递了一系列负数（在这种情况下`-1`不能是一个参数），那么你会遇到问题。在这个实现中，这个问题可以通过选择另一个*标记值*来解决。
- en: 'Another implementation could eschew the use of a marker for the end of the
    list, and instead use the first, required, argument to give the count of the parameters
    that follow:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现可以放弃使用列表末尾的标记，而是使用第一个必需的参数来给出后续参数的数量：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time, the first value is the *number of arguments* that follow, and so
    the routine will extract this exact number of integers off the stack and sum them.
    The code is called like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，第一个值是*后面跟随的参数的数量*，因此例程将从堆栈中提取这个确切数量的整数并对它们求和。代码的调用方式如下：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is no convention for how to handle the issue of determining how many parameters
    have been passed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有约定来处理确定传递了多少参数的问题。
- en: 'The routine assumes that every item on the stack is an `int`, but there is
    no information about this in the prototype of the function, so the compiler cannot
    do type checking on the parameters actually used to call the function. If the
    caller provides a parameter of a different type, the wrong number of bytes could
    be read off the stack, making the results of all the other calls to `va_arg` invalid.
    Consider this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该例程假设堆栈上的每个项都是`int`，但在函数的原型中没有关于这一点的信息，因此编译器无法对调用函数时实际使用的参数进行类型检查。如果调用者提供了不同类型的参数，可能会从堆栈中读取错误数量的字节，使得对`va_arg`的所有其他调用的结果无效。考虑这个：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It is easy to press both, the comma and period keys, at the same time, and
    this has happened after typing the `10` parameter. The period means that the `10`
    is a `double`, and so the compiler puts a `double` value on the stack. When the
    function reads values off the stack with the `va_arg` macro, it will read the
    8-byte `double` as two 4-byte `int` values and for code produced by Visual C++
    this results in a total sum of `1076101140`. This illustrates the type unsafe
    aspect of argument lists: you cannot get the compiler to do type checks of the
    parameters passed to the function.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同时按下逗号和句号键很容易，这在输入`10`参数后发生了。句号意味着`10`是一个`double`，因此编译器将一个`double`值放在堆栈上。当函数使用`va_arg`宏从堆栈中读取值时，它将把8字节的`double`读取为两个4字节的`int`值，对于Visual
    C++生成的代码，这将导致总和为`1076101140`。这说明了参数列表的类型不安全方面：你无法让编译器对传递给函数的参数进行类型检查。
- en: 'If your function has different types passed to it then you have to implement
    some mechanism to determine what those parameters are. A good example of argument
    lists is the C `printf` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数传递了不同的类型，那么你必须实现一些机制来确定这些参数是什么类型。参数列表的一个很好的例子是C的`printf`函数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The required parameter of this function is a format string, and importantly
    this has an ordered list of variable parameters and their types. The format string
    provides the information that is not available via the `<cstdarg>` macros: the
    number of variable parameters and the type of each one. The implementation of
    the `printf` function will iterate through the format string and when it comes
    across a format specifier for a parameter (a character sequence starting with
    `%`) it will read the expected type off the stack with `va_arg`. It should be
    clear that C-style argument lists are not as flexible as they appear on first
    sight; moreover, they can be quite dangerous.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的必需参数是一个格式字符串，而且这个格式字符串包含一个变量参数及其类型的有序列表。格式字符串提供了通过`<cstdarg>`宏不可用的信息：可变参数的数量和每个参数的类型。`printf`函数的实现将遍历格式字符串，当它遇到一个参数的格式说明符（以`%`开头的字符序列）时，它将使用`va_arg`从堆栈中读取期望的类型。很明显，C风格的参数列表并不像它们一开始看起来那样灵活；而且，它们可能非常危险。
- en: Function features
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数特性
- en: Functions are modularized pieces of code defined as part of your application,
    or in a library. If a function is written by another vendor it is important that
    your code calls the function in the way intended by the vendor. This means understanding
    the calling convention used and how it affects the stack.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是应用程序或库中定义的模块化代码片段。如果一个函数是由另一个供应商编写的，重要的是你的代码以供应商预期的方式调用函数。这意味着理解所使用的调用约定以及它如何影响堆栈。
- en: Call stack
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用堆栈
- en: When you call a function, the compiler will create a stack frame for the new
    function call and it will push items on to the stack. The data put on the stack
    depends on your compiler and whether the code is compiled for the debug or release
    build; however, in general there will be information about the parameters passed
    to the function, the return address (the address after the function call), and
    the automatic variables allocated in the function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用函数时，编译器将为新函数调用创建一个堆栈帧，并将项目推送到堆栈上。放在堆栈上的数据取决于您的编译器以及代码是为调试还是发布构建而编译的；但是，一般来说，将有关于传递给函数的参数、返回地址（函数调用后的地址）以及函数中分配的自动变量的信息。
- en: This means that, when you make a function call at runtime, there will be a memory
    overhead and performance overhead from creating the stack frame before the function
    runs, and a performance overhead in cleaning up, after the function completes.
    If a function is inlined, this overhead does not occur because the function call
    will use the current stack frame rather than a new one. Clearly, inlined functions
    should be small, both in terms of code and the memory used on the stack. The compiler
    can ignore the `inline` specifier and call the function with a separate stack
    frame.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在运行时进行函数调用时，将会有一个内存开销和性能开销，因为在函数运行之前创建堆栈帧，并在函数完成后进行清理，会有性能开销。如果函数是内联的，这种开销就不会发生，因为函数调用将使用当前堆栈帧而不是新的堆栈帧。显然，内联函数应该很小，无论是代码还是堆栈上使用的内存。编译器可以忽略`inline`说明符，并使用单独的堆栈帧调用函数。
- en: Specifying calling conventions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定调用约定
- en: 'When your code uses your own functions, you do not need to pay any attention
    to *calling conventions* because the compiler will make sure the appropriate convention
    is used. However, if you are writing library code that can be used by other C++
    compilers, or even by other languages, then the calling convention becomes important.
    Since this book is not about interoperable code we won''t go into much depth,
    but instead will look at two aspects: function naming and stack maintenance.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码使用自己的函数时，您不需要关注*调用约定*，因为编译器将确保使用适当的约定。但是，如果您正在编写可以被其他C++编译器使用，甚至可以被其他语言使用的库代码，那么调用约定就变得重要起来。由于本书不涉及可互操作的代码，我们不会深入讨论，而是将关注两个方面：函数命名和堆栈维护。
- en: Using C linkage
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C链接
- en: When you give a C++ function a name, this is the name that you will use to call
    the function in your C++ code. However, under the covers, the C++ compiler will
    *decorate* the name with extra symbols for the return type and parameters so that
    overloaded functions all have different names. To C++ developers, this is also
    known as **name mangling**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您给C++函数命名时，这是您在C++代码中调用函数时将使用的名称。但是，在底层，C++编译器将使用额外的符号为返回类型和参数*修饰*名称，以便重载函数都有不同的名称。对于C++开发人员来说，这也被称为**名称修饰**。
- en: If you need to export a function through a shared library (in Windows, a **dynamic
    linked library**), you must use types and names that other languages can use.
    To do this, you can mark a function with `extern "C"`. This means that the function
    has C linkage and the compiler will not use C++ name mangling. Clearly, you should
    use this only on functions that will be used by external code and you should not
    use it with functions that have return values and parameters that use C++ custom
    types. However, if such a function does return a C++ type, the compiler will only
    issue a warning. The reason is that C is a flexible language and a C programmer
    will be able to work out how to turn the C++ type into something usable, but it
    is poor practice to abuse them like this!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过共享库（在Windows中为**动态链接库**）导出函数，您必须使用其他语言可以使用的类型和名称。为此，您可以使用`extern "C"`标记函数。这意味着函数具有C链接，并且编译器不会使用C++名称修饰。显然，您应该仅在外部代码将使用的函数上使用此功能，并且不应将其用于具有返回值和使用C++自定义类型的参数的函数。但是，如果这样的函数确实返回C++类型，编译器将只发出警告。原因是C是一种灵活的语言，C程序员将能够弄清楚如何将C++类型转换为可用的东西，但滥用它们是不好的做法！
- en: The `extern "C"` linkage can also be used with global variables, and you can
    use it on a single item or (using braces) on many items.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern "C"`链接也可以用于全局变量，并且可以在单个项目上使用它，也可以（使用大括号）在多个项目上使用它。'
- en: Specifying how the stack Is maintained
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定如何维护堆栈
- en: 'Visual C++ supports six calling conventions that you can use on a function.
    The `__clrcall` specifier means that the function should be called as a .NET function
    and allows you to write code that has mixed native code and managed code. C++/CLR
    (Microsoft''s language extensions to C++ to write .NET code) is beyond the scope
    of this book. The other five are used to indicate how parameters are passed to
    a function (on the stack or using CPU registers) and whose responsibility it is
    to maintain the stack. We will cover just three: `__cdecl`, `__stdcall`, and `__thiscall`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++支持六种调用约定，您可以在函数上使用。`__clrcall`说明符表示该函数应该作为.NET函数调用，并允许您编写具有混合本机代码和托管代码的代码。C++/CLR（Microsoft的C++语言扩展，用于编写.NET代码）超出了本书的范围。其他五种用于指示参数如何传递给函数（在堆栈上还是使用CPU寄存器）以及谁负责维护堆栈。我们只会涵盖三种：`__cdecl`，`__stdcall`和`__thiscall`。
- en: You will rarely explicitly use `__thiscall`; it is the calling convention used
    for functions defined as members of custom types, and indicates that the function
    has a hidden parameter that is a pointer to the object that can be accessed through
    the `this` keyword in the function. More details will be given in the next chapter,
    but it is important to realize that such member functions have a different calling
    convention, especially when you need to initialize function pointers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您很少会显式使用`__thiscall`；它是用于自定义类型成员函数的调用约定，并且指示函数具有一个隐藏参数，该参数是可以通过函数中的`this`关键字访问的对象的指针。更多细节将在下一章中给出，但重要的是要意识到这样的成员函数具有不同的调用约定，特别是当您需要初始化函数指针时。
- en: By default, C++ global functions will use the `__cdecl` calling convention.
    The stack is maintained by the calling code, so in the calling code each call
    to a `__cdecl` function is followed by code to clean up the stack. This makes
    each function call a little larger, but it is needed for variable argument lists
    to be used. The `__stdcall` calling convention is used by most of the Windows
    SDK functions and it indicates that the called function cleans up the stack so
    there is no need for such code to be generated in the calling code. Clearly, it
    is important that the compiler knows that a function uses `__stdcall` because,
    otherwise, it will generate code to clean up a stack frame that has already been
    cleaned up by the function. You will usually see Windows functions marked with
    `WINAPI,` which is a `typedef` for `__stdcall`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C++全局函数将使用`__cdecl`调用约定。堆栈由调用代码维护，因此在调用代码中，对`__cdecl`函数的每次调用后都会有清理堆栈的代码。这使得每个函数调用都会变得稍微大一些，但这是为了能够使用可变参数列表。大多数Windows
    SDK函数使用`__stdcall`调用约定，它表示被调用的函数清理堆栈，因此在调用代码中不需要生成这样的代码。显然，编译器知道函数使用`__stdcall`是很重要的，否则它将生成代码来清理已经被函数清理的堆栈帧。通常会看到使用`WINAPI`标记的Windows函数，这是`__stdcall`的`typedef`。
- en: Using recursion
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归
- en: 'In most cases the memory overhead of a call stack is unimportant. However,
    when you use recursion it is possible to build up a long chain of stack frames.
    As the name suggests, recursion is when a function calls itself. A simple example
    is a function that calculates a factorial:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，调用堆栈的内存开销并不重要。然而，当您使用递归时，可能会建立一个很长的堆栈帧链。顾名思义，递归是指一个函数调用自身。一个简单的例子是计算阶乘的函数：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you call this for 4, the following calls are made:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为4调用此函数，则会进行以下调用：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The important point is that in the recursive function there must be at least
    one way to leave the function without recursion. In this case, it will be when
    `factorial` is called with a parameter of 1\. In practice, a function like this
    should be marked as `inline` to avoid creating any stack frames at all.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，在递归函数中必须至少有一种方法可以在没有递归的情况下离开函数。在这种情况下，当使用参数1调用`factorial`时，函数将结束。在实践中，这样的函数应该标记为`inline`，以避免创建任何堆栈帧。
- en: Overloading functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: You can have several functions with the same name, but where the parameter list
    is different (the number of parameters and/or the type of the parameters). This
    is *overloading* the function name. When such a function is called, the compiler
    will attempt to find the function that best fits the parameters provided. If there
    is not a suitable function, the compiler will attempt to convert the parameters
    to see if a function with those types exists. The compiler will start with trivial
    conversions (for example, an array name to a pointer, a type to a `const` type),
    and if this fails the compiler will try to promote the type (for example, `bool`
    to `int`). If that fails, the compiler will try standard conversions (for example,
    a reference to a type). If such conversions results in more than one possible
    candidate, then the compiler will issue an error that the function call is ambiguous.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有几个具有相同名称的函数，但参数列表不同（参数的数量和/或参数的类型）。这就是*函数重载*。当调用这样的函数时，编译器将尝试找到最适合提供的参数的函数。如果没有合适的函数，编译器将尝试转换参数，看看是否存在具有这些类型的函数。编译器将从简单的转换开始（例如，数组名称到指针，类型到`const`类型），如果失败，编译器将尝试提升类型（例如，`bool`到`int`）。如果失败，编译器将尝试标准转换（例如，引用到类型）。如果这样的转换导致有多个可能的候选项，那么编译器将发出函数调用模糊的错误。
- en: Functions and scope
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和作用域
- en: 'The compiler will also take the scope of the function into account when looking
    for a suitable function. You cannot define a function within a function, but you
    can provide a function prototype within the scope of a function and the compiler
    will attempt (if necessary through conversions) to call a function with such a
    prototype first. Consider this code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在寻找合适的函数时也会考虑函数的作用域。您不能在函数内定义函数，但是您可以在函数的作用域内提供函数原型，并且编译器将尝试（如果需要通过转换）首先调用具有这样原型的函数。考虑以下代码：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this code, the function `f` is overloaded with one version that takes an
    `int` and the other with a `double`. Normally, if you call `f(1)` then the compiler
    will call the first version of the function. However, in `main` there is a prototype
    for the version that takes a `double`, and an `int` can be converted to a `double`
    with no loss of information. The prototype is in the same scope as the function
    call, so in this code the compiler will call the version that takes a `double`.
    This technique essentially *hides* the version with an `int` parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，函数`f`被重载为一个接受`int`的版本和一个接受`double`的版本。通常，如果您调用`f(1)`，那么编译器将调用函数的第一个版本。然而，在`main`中有一个接受`double`的版本的原型，并且`int`可以被转换为`double`而不会丢失信息。原型在与函数调用相同的作用域内，因此在这段代码中，编译器将调用接受`double`的版本。这种技术本质上*隐藏*了带有`int`参数的版本。
- en: Deleted functions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除函数
- en: 'There is a more formal way to hide functions than using the scope. C++ will
    attempt to explicitly convert built-in types. For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种比使用作用域更正式的隐藏函数的方法。C++将尝试显式转换内置类型。例如：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can call this with an `int`, or anything that can be converted to an `int`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`int`调用此函数，或者任何可以转换为`int`的东西：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the second case, a `char` is an integer, so it is promoted to an `int` and
    the function is called. In the third case, the compiler will issue a warning that
    the conversion can cause a loss of data, but it is a warning and so the code will
    compile. If you want to prevent this implicit conversion you can *delete* the
    functions that you do not want callers to use. To do this, provide a prototype
    and use the syntax `= delete`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，`char`是一个整数，因此它被提升为`int`并调用函数。在第三种情况下，编译器将发出警告，表示转换可能会导致数据丢失，但这只是一个警告，所以代码将编译。如果要防止这种隐式转换，可以*删除*您不希望调用者使用的函数。要做到这一点，提供一个原型并使用语法`=
    delete`：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, when the code attempts to call the function with a `char` or a `double`
    (or `float`, which will be implicitly converted to a `double`), the compiler will
    issue an error.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当代码尝试使用`char`或`double`（或`float`，它将被隐式转换为`double`）调用函数时，编译器将发出错误。
- en: Passing by value and passing by reference
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按值传递和按引用传递
- en: By default, the compiler will pass parameters by value, that is, a copy is made.
    If you pass a custom type, then its *copy constructor* is called to create a new
    object. If you pass a pointer to an object of a built-in type or custom type,
    then the *pointer* will be passed by value, that is, a new pointer is created
    on the function stack for the parameter and it is initialized with the memory
    address passed to the function. This means that, in the function, you can change
    the pointer to point to other memory (this is useful if you want to use pointer
    arithmetic on that pointer). The data that the pointer points to will be passed
    by a reference, that is, the data remains where it is, outside of the function,
    but the function can use the pointer to change the data. Similarly, if you use
    a reference on a parameter then it means that the object is passed by the reference.
    Clearly, if you use `const` on a pointer or reference parameter then this will
    affect whether the function can change the data pointed to or referenced.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器将按值传递参数，即会创建一个副本。如果传递自定义类型，则会调用其*复制构造函数*来创建一个新对象。如果传递指向内置类型或自定义类型对象的指针，则*指针*将按值传递，即在函数堆栈上为参数创建一个新指针，并用传递给函数的内存地址进行初始化。这意味着在函数中，您可以更改指针指向的其他内存（如果您想对该指针进行指针算术运算，则这很有用）。指针指向的数据将通过引用传递，即数据保留在函数外部，但函数可以使用指针来更改数据。同样，如果在参数上使用引用，则表示通过引用传递对象。显然，如果在指针或引用参数上使用`const`，则这将影响函数是否可以更改指向或引用的数据。
- en: 'In some cases, you may want to return several values from a function, and you
    may choose to use the return value of the function to indicate if the function
    executed correctly. One way to do this is to make one of the parameters an *out*
    parameter, that is, it is either a pointer or a reference to an object or container
    that the function will alter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望从函数中返回多个值，并且您可能选择使用函数的返回值来指示函数是否正确执行。做到这一点的一种方法是将其中一个参数设置为*out*参数，即它是一个指针或引用，指向函数将要改变的对象或容器：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To call this function, you must create a `vector` object and pass it to the
    function:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此函数，必须创建一个`vector`对象并将其传递给函数：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because the `values` parameter is a reference it means that when `get_values`
    calls `push_back` to insert a value in the `values` container it is actually inserting
    that value into the `items` container.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`values`参数是一个引用，这意味着当`get_values`调用`push_back`来在`values`容器中插入一个值时，实际上是将该值插入到`items`容器中。
- en: 'If an out parameter is passed via a pointer it is important to look at the
    pointer declaration. A single `*` means that the variable is a pointer, two means
    that it is a pointer to a pointer. The following function returns an `int` through
    an out parameter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过指针传递out参数，则重要的是查看指针声明。一个`*`表示变量是一个指针，两个表示它是一个指向指针的指针。以下函数通过out参数返回一个`int`：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code is called like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的调用方式如下：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This pattern of returning a value indicating success is frequently used, particularly
    with code that accesses data across process or machine boundaries. The function
    return value can be used to give detailed information about why the call failed
    (no network access?, invalid security credentials?, and so on), and indicates
    that the data in the out parameters should be discarded.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种返回成功值的模式经常被使用，特别是在访问跨进程或机器边界的数据的代码中。函数返回值可用于提供有关调用失败原因的详细信息（无网络访问？无效的安全凭据？等等），并指示应丢弃out参数中的数据。
- en: 'If the out parameter has a double `*` then it means the return value is itself
    a pointer, either to a single value or to an array:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果out参数有一个双`*`，那么意味着返回值本身是一个指针，可以是指向单个值或数组的指针：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this case, you pass in the size of the buffer you want using the first parameter
    and on return you receive the actual size of the buffer via this parameter (it
    is in/out) and a pointer to the buffer in the second parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您使用第一个参数传入您想要的缓冲区的大小，并在返回时通过此参数接收缓冲区的实际大小（它是in/out），以及第二个参数中的缓冲区的指针：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Any function that returns a memory buffer must document who has the responsibility
    of deallocating the memory. In most cases, it is usually the caller, as assumed
    in this example code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 任何返回内存缓冲区的函数都必须记录谁有责任释放内存。在大多数情况下，通常是调用者，就像这个示例代码中假设的那样。
- en: Designing functions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计函数
- en: Often functions will act upon global data, or data passed in by the caller.
    It is important that when the function completes, it leaves this data in a consistent
    state. Equally so, it is important that, the function can make assumptions about
    the data before it accesses it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常函数将对全局数据或由调用者传入的数据进行操作。重要的是，当函数完成时，它将使这些数据处于一致的状态。同样重要的是，函数在访问数据之前可以对数据做出假设。
- en: Pre- and post-conditions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件和后置条件
- en: 'A function will typically alter some data: values passed into the function,
    data returned by the function, or some global data. It is important when designing
    a function that you determine what data will be accessed and changed and that
    these rules are documented.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通常会改变一些数据：传递给函数的值，函数返回的数据，或一些全局数据。在设计函数时，确定将访问和更改的数据，并记录这些规则是很重要的。
- en: A function will have pre-conditions, assumptions about the data that it will
    use. For example, if a function is passed a filename, with the intention that
    the function will extract some data from the file, whose responsibility is it
    to check that the file exists? You can make it the responsibility of the function,
    and so the first few lines will check that the name is a valid path to a file
    and call operating system functions to check that the file exists. However, if
    you have several functions that will perform actions on the file, you will be
    replicating this checking code in each function and it may be better to put that
    responsibility on the calling code. Clearly such actions can be expensive, so
    it is important to avoid both the calling code and the function to perform the
    checks.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将具有前置条件，即它将使用的数据的假设。例如，如果一个函数传递了一个文件名，并且意图是从文件中提取一些数据，那么谁负责检查文件是否存在？你可以让函数负责，并且前几行将检查该名称是否是文件的有效路径，并调用操作系统函数来检查文件是否存在。然而，如果你有几个函数将对文件执行操作，你将在每个函数中复制这个检查代码，把这个责任放在调用代码上可能更好。显然，这样的操作可能很昂贵，因此重要的是避免调用代码和函数执行检查。
- en: '[Chapter 10](5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml), *Diagnostics and
    Debugging*, will describe how to add debugging code, called **asserts**, that
    you can place in your functions to check the values of the parameters to make
    sure that the calling code is following the pre-condition rules you have set.
    Asserts are defined using conditional compilation and so will only appear in **debug
    builds** (that is, C++ code compiled with debugging information). **Release builds**
    (completed code that will be delivered to the end user) will conditionally compile
    asserts away; this makes the code faster, and if your testing is thorough enough,
    you can be assured that pre-conditions are met.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 《第10章》（5a2f36d4-7d0b-4f2d-ae7c-f9e51f5d7dc4.xhtml），*诊断和调试*，将描述如何添加调试代码，称为**断言**，你可以将其放在函数中，以检查参数的值，以确保调用代码遵循你设置的前置条件规则。断言是使用条件编译定义的，因此只会出现在**调试构建**中（即使用调试信息编译的C++代码）。**发布构建**（将交付给最终用户的完成代码）将有条件地将断言编译掉；这使得代码更快，如果你的测试足够彻底，你可以确保前置条件得到满足。
- en: You should also document the post-conditions of your function. That is, assumptions
    about the data returned by the function (through the function return value, out
    parameters, or parameters passed by a reference). Post-conditions are the assumptions
    that the calling code will make. For example, you may return a signed integer
    where the function is meant to return a positive value, but a negative value is
    used to indicate an error. Often functions that return pointers will return `nullptr`
    if the function fails. In both cases, the calling code knows that it needs to
    check the return value and only use it if it is either positive or not `nullptr`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该记录函数的后置条件。也就是说，关于函数返回的数据的假设（通过函数返回值、输出参数或引用传递的参数）。后置条件是调用代码将做出的假设。例如，你可能返回一个有符号整数，而函数本来应该返回一个正值，但使用负值来表示错误。通常，返回指针的函数在失败时会返回`nullptr`。在这两种情况下，调用代码知道需要检查返回值，并且只有在它是正值或不是`nullptr`时才使用它。
- en: Using invariants
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不变量
- en: You should be careful to document how a function uses data external to the function.
    If the intention of the function is to change external data, you should document
    what the function will do. If you don't explicitly document what the function
    does to external data, then you must ensure that when the function finishes such
    data is left untouched. The reason is that the calling code will only assume what
    you have said in the documentation and the side-effects of changing global data
    may cause problems. Sometimes it is necessary to store the state of global data
    and return the item back to that state before the function returns.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该小心记录函数如何使用函数外部的数据。如果函数的意图是改变外部数据，你应该记录函数将做什么。如果你没有明确记录函数对外部数据的影响，那么你必须确保当函数完成时，这些数据保持不变。原因是调用代码只会假设你在文档中所说的，并且改变全局数据的副作用可能会导致问题。有时需要存储全局数据的状态，并在函数返回之前将项目返回到该状态。
- en: We have already seen an example of this in [Chapter 3](b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml),
    *Exploring C++ Types*, with the `cout` object. The `cout` object is global to
    your application, and it can be changed through manipulators to make it interpret
    numeric values in certain ways. If you change it in a function (say, by inserting
    the `hex` manipulator), then this change will remain when the `cout` object is
    used outside the function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在《第3章》（b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml）中看到了一个例子，使用了`cout`对象。`cout`对象是全局的，它可以通过操纵器进行更改，以使其以某种方式解释数值。如果你在函数中更改它（比如插入`hex`操纵器），那么当在函数外部使用`cout`对象时，这个更改将保留下来。
- en: '[Chapter 3](b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml), *Exploring C++ Types*,
    shows how to address such an issue. In that chapter, you created a function called
    `read16` that reads 16 bytes from a file and prints the values out to the console
    both in hexadecimal form and interpreted as an ASCII character:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 《第3章》（b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml），*探索C++类型*，展示了如何解决这样的问题。在那一章中，你创建了一个名为`read16`的函数，它从文件中读取16个字节，并以十六进制形式和ASCII字符形式打印出这些值：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code stores the state of the `cout` object in a temporary variable, `flags`.
    The `read16` function can change the `cout` object in any way necessary, but because
    we have the stored state it means that the object can be restored to its original
    state before returning.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`cout`对象的状态存储在临时变量`flags`中。`read16`函数可以以任何必要的方式更改`cout`对象，但因为我们有存储的状态，这意味着在返回之前可以将对象恢复到其原始状态。
- en: Function pointers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数指针
- en: When an application is run, the functions it will call will exist in memory
    somewhere. This means that you can get the address of a function. C++ allows you
    to use the function call operator (a pair of parentheses enclosing the parameters
    `()`) to call a function through a function pointer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，它将调用的函数将存在于内存中的某个位置。这意味着你可以获得函数的地址。C++允许你使用函数调用运算符（一对括号括住参数`()`）通过函数指针调用函数。
- en: Remember the parentheses!
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记住括号！
- en: 'First, a simple example of how function pointers can cause difficult to notice
    bugs in your code. A global function called `get_status` performs various validation
    actions to determine if the state of the system is valid. The function returns
    a value of zero to mean that the system state is valid and values over zero are
    error codes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个简单的例子，说明函数指针如何导致代码中难以注意到的错误。一个名为`get_status`的全局函数执行各种验证操作，以确定系统状态是否有效。该函数返回零表示系统状态有效，大于零的值表示错误代码：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code could be called like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样调用代码：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is an error because the developer has missed off the `()`, so the compiler
    does not treat this as a function call. Instead, it treats this as a test of the
    memory address of the function, and since the function will never be located at
    a memory address of zero, the comparison will always be `true` and the message
    will be printed even if the system state is valid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误，因为开发人员遗漏了`()`，所以编译器不会将其视为函数调用。相反，它将其视为对函数的内存地址进行测试，由于函数永远不会位于内存地址为零的位置，比较将始终为`true`，即使系统状态有效也会打印出消息。
- en: Declaring function pointers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数指针
- en: 'The last section highlights how easy it is to get the address of a function:
    you just use the name of the function without the parentheses:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节强调了获取函数地址有多么容易：你只需使用函数的名称而不带括号：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The pointer `pv` is only of mild interest; you now know where in memory the
    function is stored, but to print this address you still need to cast it to an
    integer. To make the pointer useful, you need to be able to declare a pointer
    through which the function can be called. To look at how to do this, let''s go
    back to the function prototype:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 指针`pv`只是稍微有趣；你现在知道函数存储在内存中的位置，但要打印这个地址，你仍然需要将其转换为整数。为了使指针有用，你需要能够声明一个通过该函数可以被调用的指针。为了看看如何做到这一点，让我们回到函数原型：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The function pointer must be able to call the function passing no parameters
    and expecting a return value of an integer. The function pointer is declared like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针必须能够调用不带参数并期望返回整数值的函数。函数指针声明如下：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `*` indicates that the variable `fn` is a pointer; however, this binds
    to the left, so without the parentheses surrounding `*fn` the compiler would interpret
    this to mean that the declaration is for an `int*` pointer. The rest of the declaration
    indicates how this function pointer is called: taking no parameters and returning
    an `int`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`表示变量`fn`是一个指针；然而，这会绑定到左边，所以如果没有括号包围`*fn`，编译器会将其解释为`int*`指针的声明。声明的其余部分表示如何调用这个函数指针：不带参数并返回一个`int`。'
- en: 'Calling through a function pointer is simple: you give the name of the pointer
    where you would normally give the name of the function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数指针调用很简单：在通常给出函数名称的地方给出指针的名称：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note again how important the parentheses are; they indicates that the function
    at the address held in the function pointer, `fn`, is called.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意括号的重要性；它们表示在函数指针`fn`中保存的地址处调用函数。
- en: 'Function pointers can make code look rather cluttered, especially when you
    use them to point to templated functions, so often code will define an alias:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针可能会使代码看起来相当凌乱，特别是当你使用它们指向模板函数时，因此通常代码会定义一个别名：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These two lines declare aliases for the type of the function pointer needed
    to call the `get_status` function. Both are valid, but the `using` version is
    more readable since it is clear that `pf1` is the alias being defined. To see
    why, consider this alias:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行为调用`get_status`函数所需的函数指针类型声明了别名。两者都是有效的，但`using`版本更易读，因为清楚地表明了`pf1`是正在定义的别名。为了理解原因，考虑这个别名：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The type alias is called `MyPtr` and it is to a function that returns a `bool`
    and takes two `MyType` pointers. This is much clearer with `using`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名称为`MyPtr`，它是一个返回`bool`并接受两个`MyType`指针的函数。使用`using`更清晰：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The tell-tale sign here is the `(*)`, which indicates that the type is a function
    pointer because you are using the parenthesis to break the associatively of the
    `*`. You can then read outwards to see the prototype of the function: to the left
    to see the return type, and to the right to get the parameter list.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的显著标志是`(*)`，它表示类型是函数指针，因为你使用括号来打破`*`的关联性。然后你可以向外读取函数的原型：向左看返回类型，向右看参数列表。
- en: 'Once you have declared an alias, you can create a pointer to a function and
    call it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你声明了一个别名，你就可以创建一个指向函数的指针并调用它：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice that, because the `two_ints` alias is declared as a pointer, you do not
    use a `*` when declaring a variable of this type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`two_ints`别名声明为指针，所以在声明此类型的变量时不使用`*`。
- en: Using function pointers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数指针
- en: 'A function pointer is merely a pointer. This means that you can use it as a
    variable; you can return it from a function, or pass it as a parameter. For example,
    you may have some code that performs some lengthy routine and you want to provide
    some feedback during the routine. To make this flexible, you could define your
    function to take a **callback pointer** and periodically in the routine call the
    function to indicate progress:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数指针只是一个指针。这意味着您可以将其用作变量；您可以从函数中返回它，或将其作为参数传递。例如，您可能有一些执行一些冗长例程的代码，并且希望在例程期间提供一些反馈。为了使其灵活，您可以定义函数以接受**回调指针**，并在例程中定期调用该函数以指示进度：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here `big_routine` has a function pointer parameter called `progress`. The function
    has a loop that will be called many times and every one hundredth loop it calls
    the callback function, passing a `string` that gives information about the progress.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`big_routine`有一个名为`progress`的函数指针参数。该函数有一个循环，将被多次调用，每100次循环它调用回调函数，传递一个包含有关进度信息的`string`。
- en: Note that the `string` class defines a `+=` operator that can be used to append
    a string to the end of the `string` in the variable and the `<string>` header
    file defines a function called `to_string` that is overloaded for each of the
    built-in types to return a `string` formatted with the value of the function parameter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`string`类定义了`+=`运算符，可用于将字符串附加到变量中字符串的末尾，而`<string>`头文件定义了一个名为`to_string`的函数，该函数对每个内置类型进行了重载，以返回一个使用函数参数值格式化的`string`。
- en: 'This function declares the function pointer as `const` merely so that the compiler
    knows that the function pointer should not be changed to a pointer to another
    function in this function. The code can be called like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将函数指针声明为`const`，只是为了让编译器知道该函数指针在此函数中不应更改为指向另一个函数的指针。代码可以这样调用：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `monitor` function has the same prototype as described by the `callback`
    function pointer (if, for example, the function parameter was `string&` and not
    `const string&,` then the code will not compile). The `big_routine` function is
    then called, passing a pointer to the `monitor` function as the second parameter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor`函数的原型与`callback`函数指针描述的原型相同（例如，如果函数参数是`string&`而不是`const string&`，那么代码将无法编译）。然后调用`big_routine`函数，将`monitor`函数的指针作为第二个参数传递。'
- en: If you pass callback functions to library code, you must pay attention to the
    calling convention of the function pointer. For example, if you pass a function
    pointer to a Windows function, such as `EnumWindows`, it must point to a function
    declared with the `__stdcall` calling convention.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将回调函数传递给库代码，必须注意函数指针的调用约定。例如，如果将函数指针传递给Windows函数（如`EnumWindows`），它必须指向使用`__stdcall`调用约定声明的函数。
- en: The C++ standards uses another technique to call functions defined at runtime,
    which is, functors. It will be covered shortly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准使用另一种在运行时调用函数的技术，即函数对象。稍后将对此进行介绍。
- en: Templated functions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板函数
- en: When you write library code, you often have to write several functions that
    differ only between the types that are passed to the function; the routine action
    is the same, it's just the types that have changed. C++ provides *templates* to
    allow you to write more generic code; you write the routine using a *generic type*
    and at compile time the compiler will generate a function with the appropriate
    types. The templated function is marked as such using the `template` keyword and
    a list of parameters in angle brackets (`<>`) that give placeholders for the types
    that will be used. It is important to understand that these template parameters
    are types and refer to the types of the parameters (and return a value of the
    function) that will be replaced with the actual types used by calling the functions.
    They are not parameters of the function, and you do not (normally) provide them
    when you call the function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写库代码时，通常必须编写几个函数，这些函数之间的唯一区别在于传递给函数的类型；例程操作相同，只是类型已更改。C++提供了*模板*，允许您编写更通用的代码；您使用*通用类型*编写例程，并且在编译时编译器将生成具有适当类型的函数。使用`template`关键字和尖括号（`<>`）中的参数列表标记模板函数，这些参数列表为将要使用的类型提供了占位符。重要的是要理解这些模板参数是类型，并且指的是将在调用函数时用实际类型替换的参数（和函数的返回值）。它们不是函数的参数，通常在调用函数时不提供它们。
- en: 'It is best to explain template functions with an example. A simple `maximum`
    function can be written like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过示例来解释模板函数。一个简单的`maximum`函数可以这样写：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can call this with other integer types, and smaller types (`short`, `char`,
    `bool`, and so on) will be promoted to an `int`, and values of larger types (`long
    long`) will be truncated. Similarly, variables of `unsigned` types will be converted
    to the `signed int` which could cause problems. Consider this call of the function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他整数类型调用此函数，较小的类型（如`short`、`char`、`bool`等）将被提升为`int`，较大类型（`long long`）的值将被截断。同样，`unsigned`类型的变量将被转换为`signed
    int`，这可能会导致问题。考虑以下函数调用：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What is the value of the `result` variable: `s1` or `s2`? It is `s2`. The reason
    is that both values are converted to `signed int` and when converted to a signed
    type `s1` will be a value of `-1` and `s2` will be a value of `2147483647`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`变量的值是什么：`s1`还是`s2`？是`s2`。原因是两个值都转换为`signed int`，当转换为有符号类型时，`s1`将是值`-1`，而`s2`将是值`2147483647`。'
- en: 'To handle unsigned types, you need to *overload* the function and write a version
    for signed and unsigned integers:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理无符号类型，需要*重载*函数，并为有符号和无符号整数编写一个版本：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The routine is the same, but the types have changed. There is another issue--what
    if the caller mixes types? Does the following expression make any sense:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例程相同，但类型已更改。还有另一个问题——如果调用者混合类型会怎样？以下表达式是否有意义：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This code will compile because a `bool` and a `double` can be converted to an
    `int` and the first overload will be called. Since such a call is nonsense, it
    would be much better if the compiler caught this error.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将编译，因为`bool`和`double`可以转换为`int`，并且将调用第一个重载。由于这样的调用是无意义的，如果编译器能捕捉到这个错误将会更好。
- en: Defining templates
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模板
- en: 'Returning back to the two versions of the `maximum` function, the routine is
    the same for both; all that has changed is the type. If you had a generic type,
    let''s call it `T`, where `T` could be any type that implements an `operator>`,
    the routine could be described by this pseudocode:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`maximum`函数的两个版本，它们的例程都是一样的；改变的只是类型。如果你有一个通用类型，让我们称之为`T`，其中`T`可以是任何实现`operator>`的类型，那么这个例程可以用伪代码描述如下：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will not compile because we have not defined the type `T`. Templates allow
    you to tell the compiler that the code uses a type and will be determined from
    the parameter passed to the function. The following code will compile:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不会编译，因为我们没有定义类型`T`。模板允许你告诉编译器代码使用了一个类型，并且将从传递给函数的参数中确定。以下代码将编译：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The template declaration specifies the type that will be used using the `typename`
    identifier. The type `T` is a placeholder; you can use any name you like as long
    as it is not a name used elsewhere at the same scope, and of course, it must be
    used in the parameter list of the function. You can use `class` instead of `typename`,
    but the meaning is the same.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 模板声明使用`typename`标识符指定将要使用的类型。类型`T`是一个占位符；你可以使用任何你喜欢的名称，只要它不是在同一作用域中的其他名称，当然，它必须在函数的参数列表中使用。你可以使用`class`代替`typename`，但意思是一样的。
- en: You can call this function, passing values of any type, and the compiler will
    create the code for that type, calling the `operator>` for that type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用这个函数，传递任何类型的值，编译器将为该类型创建代码，调用该类型的`operator>`。
- en: It is important to realize that, the first time the compiler comes across a
    templated function, it will create a version of the function for the specified
    type. If you call the templated function for several different types, the compiler
    will create, or instantiate, a *specialized* function for each of these types.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，当编译器第一次遇到模板函数时，它将为指定的类型创建函数的版本。如果你为几种不同的类型调用模板函数，编译器将为每种类型创建或实例化一个*专门的*函数。
- en: 'The definition of this template indicates that only one type will be used,
    so you can only call it with two parameters of the same type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板的定义表明只会使用一个类型，所以你只能用相同类型的两个参数来调用它：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All of these will compile and the first two will give the expected results.
    The last line will assign `b` to a value of `true` because `bool` is an integer
    and `true` has a value of `1+` and `false` has a value of `0`. This may not be
    what you would want, so we will return to this issue later. Note that, since the
    template says that both parameters must be the same type, the following will not
    compile:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将编译，前两个将给出预期的结果。最后一行将把`b`赋值为`true`，因为`bool`是一个整数，`true`的值是`1+`，`false`的值是`0`。这可能不是你想要的，所以我们稍后会回到这个问题。请注意，由于模板规定两个参数必须是相同的类型，以下代码将不会编译：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The reason is that the `template` parameter list only gives a single type.
    If you want to define a function with parameters of different types, then you
    will have to provide extra parameters to the template:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`template`参数列表只给出了一个类型。如果你想要定义一个带有不同类型参数的函数，那么你将不得不为模板提供额外的参数：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is done to illustrate how templates work; it really does not make sense
    to define a maximum function that takes two different types.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了说明模板是如何工作的；定义一个接受两种不同类型的最大函数实际上是没有意义的。
- en: 'This version is written for two different types, the template declaration mentions
    two types, and these are used for the two parameters. But notice that the function
    returns `T`, the type of the first parameter. The function can be called like
    this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本是为两种不同的类型编写的，模板声明提到了两种类型，并且这些类型用于两个参数。但请注意，函数返回`T`，第一个参数的类型。函数可以这样调用：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output from the first is `1` (or if you use the `bool alpha` manipulator,
    `true`) and the result of the second line is `100.99`. The reason is not immediately
    obvious. In both cases, the comparison will return `100.99` from the function,
    but because the type of the return value is `T`, the returned value type will
    be the type of the first parameter. In the first case, `100.99` is first converted
    to a `bool`, and since `100.99` is not zero, the value returned is `true` (or
    `1`). In the second case, the first parameter is a `double`, so the function returns
    a `double` and this means that `100.99` is returned. If the template version of
    `maximum` is changed to return `U` (the type of the second parameter) then the
    values returned by the preceding code are reversed: the first line returns `100.99`
    and the second returns `1`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的输出是`1`（或者如果你使用`bool alpha`操作符，是`true`），第二行的结果是`100.99`。原因并不是立即显而易见。在两种情况下，比较都将从函数返回`100.99`，但是因为返回值的类型是`T`，返回值的类型将是第一个参数的类型。在第一种情况下，`100.99`首先被转换为`bool`，由于`100.99`不是零，返回的值是`true`（或者`1`）。在第二种情况下，第一个参数是`double`，所以函数返回一个`double`，这意味着返回`100.99`。如果`maximum`的模板版本被改为返回`U`（第二个参数的类型），那么前面代码返回的值将被颠倒：第一行返回`100.99`，第二行返回`1`。
- en: Note that when you *call* the template function, you do not have to give the
    types of the template parameters because the compiler will deduce them. It is
    important to point out that this applies only to the parameters. The return type
    is not determined by the type of the variable the caller assigns to the function
    value because the function can be called without using the return value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你*调用*模板函数时，你不必给出模板参数的类型，因为编译器会推断它们。重要的是要指出，这仅适用于参数。返回类型不是由调用者分配给函数值的变量的类型决定的，因为函数可以在不使用返回值的情况下被调用。
- en: 'Although the compiler will deduce the template parameters from how you call
    the function, you can explicitly provide the types in the called function to call
    a specific version of the function and (if necessary) get the compiler to perform
    implicit conversions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器将根据您调用函数的方式推断模板参数，但您可以在调用的函数中显式提供类型，以调用函数的特定版本，并（如果必要）让编译器执行隐式转换：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This code will call the version of `maximum` that has two `int` parameters and
    returns an `int`, so the return value is `100`, that is, `100.99` converted to
    an `int`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将调用具有两个`int`参数并返回`int`的`maximum`版本，因此返回值为`100`，即`100.99`转换为`int`。
- en: Using template parameter values
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板参数值
- en: 'The templates defined so far have had types as the parameters of the template,
    but you can also provide integer values. The following is a rather contrived example
    to illustrate the point:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止定义的模板已经将类型作为模板的参数，但您也可以提供整数值。以下是一个相当牵强的例子来说明这一点：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There are two template parameters. The second parameter provides the name of
    a type where `T` is a placeholder used for the type of the parameter of the function.
    The first parameter looks like a function parameter because it is used in a similar
    way. The parameter `size` can be used in the function as a local (read-only) variable.
    The function parameter is `T` and so the compiler can deduce the second template
    parameter from the function call, but it cannot deduce the first parameter, so
    you *must* provide a value in the call. Here is an example of calling this template
    function for an `int` for `T` and a value of `10` for `size`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个模板参数。第二个参数提供了一个类型的名称，其中`T`是函数参数的类型的占位符。第一个参数看起来像一个函数参数，因为它以类似的方式使用。参数`size`可以在函数中作为本地（只读）变量使用。函数参数是`T`，因此编译器可以从函数调用中推断出第二个模板参数，但无法推断出第一个参数，因此您*必须*在调用中提供一个值。以下是调用此模板函数的示例，`T`为`int`，`size`为`10`的值：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first line calls the function with `10` as the template parameter and `42`
    as the function parameter. Since `42` is an `int`, the `init` function will create
    an `int` array with ten members and each one is initialized to a value of `42`.
    The compiler deduced `int` as the second parameter, but this code could have called
    the function with `init<10,int>(42)` to explicitly indicate that you require an
    `int` array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行调用函数，模板参数为`10`，函数参数为`42`。由于`42`是一个`int`，`init`函数将创建一个具有十个成员的`int`数组，每个成员的值都初始化为`42`。编译器推断`int`为第二个参数，但此代码也可以调用`init<10,int>(42)`函数，以明确指示您需要一个`int`数组。
- en: 'The non-type parameters must be constant at compile time: the value can be
    integral (including an enumeration), but not a floating point. You can use arrays
    of integers, but these will be available through the template parameter as a pointer.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 非类型参数必须在编译时是常量：值可以是整数（包括枚举），但不能是浮点数。您可以使用整数数组，但这些将通过模板参数作为指针可用。
- en: 'Although in most cases the compiler cannot deduce the value parameter, it can
    if the value is defined as the size of an array. This can be used to make it appear
    that a function can determine the size of a built-in array, but of course, it
    can''t because the compiler will create a version of the function for each size
    needed. For example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数情况下，编译器无法推断值参数，但如果该值被定义为数组的大小，则可以。这可以用来使函数似乎可以确定内置数组的大小，但当然，它不能，因为编译器将为所需的每个大小创建函数的版本。例如：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here, there are two template parameters: one is the type of the array, and
    the other is the size of the array. The parameter of the function looks a little
    odd, but it is just a built-in array being passed by a reference. If the parentheses
    are not used then the parameter is `T& arr[N]`, that is, an N-sized built-in array
    of references to objects of type `T`, which is not what we want. We want an N-sized
    built-in array objects of type `T`. This function is called like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两个模板参数：一个是数组的类型，另一个是数组的大小。函数的参数看起来有点奇怪，但它只是通过引用传递的内置数组。如果不使用括号，则参数为`T&
    arr[N]`，即大小为N的引用数组，引用对象的类型为`T`，这不是我们想要的。我们想要一个大小为N的内置数组对象的类型为`T`。这个函数的调用如下：
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The interesting thing about the preceding code is that the compiler sees that
    there are five items in the initializer list. The built-in array has five items,
    thus calls the function like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的有趣之处在于编译器看到初始化列表中有五个项目。内置数组有五个项目，因此调用函数如下：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As mentioned, the compiler will instantiate this function for every combination
    of `T` and `N` that your code calls. If the template function has a large amount
    of code, then this may be an issue. One way around this is to use a helper function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译器将为代码调用的每种`T`和`N`组合实例化此函数。如果模板函数有大量代码，则可能会出现问题。解决此问题的一种方法是使用辅助函数：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This does two things. First, there is a version of `print_array` that takes
    a pointer and the number of items that the pointer points to. This means that
    the `size` parameter is determined at runtime, so versions of this function are
    only instantiated at compile time for the types of the arrays used, not for both
    type and array size. The second thing to note is that the function that is templated
    with the size of the array is declared as `inline` and it calls the first version
    of the function. Although there will be a version of this for each combination
    of type and array size, the instantiation will be inline rather than a complete
    function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做两件事。首先，有一个接受指针和指针指向的项目数的`print_array`版本。这意味着`size`参数在运行时确定，因此此函数的版本仅在编译时为所使用的数组类型实例化，而不是类型和数组大小。另一个要注意的是，使用数组大小作为模板的函数被声明为`inline`，并调用函数的第一个版本。尽管对于每种类型和数组大小的组合都会有一个版本，但实例化将是内联的，而不是完整的函数。
- en: Specialized templates
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用模板
- en: 'In some cases, you may have a routine that works for most types (and a candidate
    for a templated function), but you may identify that some types need a different
    routine. To handle this, you can write a specialized template function, that is,
    a function that will be used for a specific type and the compiler will use this
    code when a caller uses types that fit this specialization. As an example, here
    is a fairly pointless function; it returns the size of a type:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能有一个适用于大多数类型（并且适合模板函数的候选函数），但您可能会发现某些类型需要不同的例程。为了处理这种情况，您可以编写一个特化的模板函数，也就是说，当调用者使用符合此特化的类型时，编译器将使用此代码。例如，这是一个相当无意义的函数；它返回类型的大小：
- en: '[PRE61]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This works for most built-in types, but if you call it with a pointer, you
    will get the size of the pointer, not what the pointer points to. So, `number_of_bytes("x")`
    will return 4 (on a 32-bit system) rather than 2 for the size of the `char` array.
    You may decide that you want a specialization for `char*` pointers that uses the
    C function, `strlen`, to count the number of characters in the string until the
    `NUL` character. To do this, you need a similar prototype to the templated function,
    replacing the template parameter with the actual type, and since the template
    parameter is not needed you miss this out. Since this function is for a specific
    type, you need to add the specialized type to the function name:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于大多数内置类型，但如果使用指针调用它，您将得到指针的大小，而不是指针指向的内容。因此，`number_of_bytes("x")`将返回4（在32位系统上），而不是`char`数组的大小为2。您可能决定为`char*`指针编写一个使用C函数`strlen`来计算字符串中字符数的特化版本，直到`NUL`字符。为此，您需要与模板函数类似的原型，将模板参数替换为实际类型，由于不需要模板参数，因此可以省略。由于此函数是为特定类型而设计的，因此需要将特定类型添加到函数名称中。
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now when you call `number_of_bytes("x")` the specialization will be called and
    it will return a value of 2.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您调用`number_of_bytes("x")`时，将调用特化版本，并返回值为2。
- en: 'Earlier, we defined a templated function to return a maximum of two parameters
    of the same type:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们定义了一个模板函数来返回相同类型的两个参数的最大值：
- en: '[PRE63]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using specialization, you can write versions for types that are not compared
    using the `>` operator. Since it makes no sense to find the maximum of two Booleans,
    you can delete the specialization for `bool`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特化，您可以为不使用`>`运算符进行比较的类型编写版本。由于找到两个布尔值的最大值是没有意义的，您可以删除`bool`的特化版本。
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This now means that, if the code calls `maximum` with `bool` parameters, the
    compiler will generate an error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果代码使用`bool`参数调用`maximum`，编译器将生成错误。
- en: Variadic templates
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变模板
- en: 'A variadic template is when there is a variable number of template parameters.
    The syntax is similar to variable arguments to a function; you use ellipses, but
    you use them on the left of the argument in the parameter list, which declares
    it a *parameter pack*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板是指模板参数的数量是可变的。语法类似于函数的可变参数；您使用省略号，但是您将它们放在参数列表中参数的左侧，这声明了它为*参数包*：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `Arguments` template parameter is zero or more types, which are the types
    of the corresponding number of arguments, `args`, of the function. In this example,
    the function has at least one parameter, of type `T`, but you can have any number
    of fixed parameters, including none at all.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arguments`模板参数是零个或多个类型，它们是函数的相应数量的参数`args`的类型。在此示例中，函数至少有一个类型为`T`的参数，但您可以有任意数量的固定参数，包括没有。'
- en: Within the function, you need to unpack the parameter pack to get access to
    the parameters passed by the caller. You can determine how many items there are
    in the parameter pack using the special operator, `sizeof...` (note the ellipses
    are part of the name); unlike the `sizeof` operator, this is the item count and
    not the size in bytes. To unpack the parameter pack, you need to use the ellipses
    on the right of the name of the parameter pack (for example, `args...`). The compiler
    will expand the parameter pack at this point, replacing the symbol with the contents
    of the parameter pack.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，您需要解包参数包以访问调用者传递的参数。您可以使用特殊运算符`sizeof...`（注意省略号是名称的一部分）确定参数包中有多少项；与`sizeof`运算符不同，这是项数而不是字节大小。要解包参数包，您需要在参数包名称的右侧使用省略号（例如，`args...`）。编译器将在此时展开参数包，用参数包的内容替换符号。
- en: 'However, you will not know at design time how many parameters there are or
    what types they are, so there are some strategies to address this. The first uses
    recursion:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您在设计时不会知道有多少参数或它们是什么类型，因此有一些策略可以解决这个问题。第一个使用递归：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The variadic templated `print` function can be called with one or more parameters
    of any type that can be handled by the `ostream` class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板`print`函数可以使用任何可以由`ostream`类处理的任意类型的一个或多个参数进行调用。
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When this is called, the parameter list is split into two: the first parameter
    (`1`) in the first parameter, `first,` and the other three are put in the parameter
    pack, `next`. The function body then calls the first version of `print` which,
    prints the `first` parameter to the console. The next line in the variadic function
    then expands the parameter pack in a call to `print`, that is, this calls itself
    recursively. In this call, the `first` parameter will be `2.0`, and the rest will
    be put in the parameter pack. This continues until the parameter pack has been
    expanded so much that there are no more parameters.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此函数时，参数列表被分成两部分：第一个参数（`1`）在第一个参数`first`中，其他三个参数放在参数包`next`中。然后函数体调用`print`的第一个版本，将`first`参数打印到控制台。可变函数的下一行然后展开参数包调用`print`，也就是递归调用自身。在此调用中，`first`参数将是`2.0`，其余参数将放在参数包中。这将继续进行，直到参数包扩展到没有更多参数为止。
- en: 'Another way to unpack the parameter pack is to use an initializer list. In
    this case, the compiler will create an array with each parameter:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 解包参数包的另一种方法是使用初始化列表。在这种情况下，编译器将创建一个包含每个参数的数组。
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The array, `arr,` is created with the size of the parameter pack and the unpack
    syntax used with the initializer braces will fill the array with the parameters.
    Although this will work with any number of parameters, all the parameters have
    to be the same type of the array, `arr`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数组`arr`的大小与参数包的大小相同，并且使用初始化大括号的解包语法将数组填充为参数。尽管这将适用于任意数量的参数，但所有参数都必须是数组`arr`的相同类型。
- en: 'One trick is to use the comma operator:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个技巧是使用逗号运算符：
- en: '[PRE69]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This creates a dummy array called `dummy`. This array is not used, other than
    in the expansion of the parameter pack. The array is created in the size of the
    `args` parameter pack and the ellipsis expands the parameter pack using the *expression*
    between the parentheses. The expression uses the comma operator, which will return
    the right side of the comma. Since this is an integer, it means that each entry
    of `dummy` has a value of zero. The interesting part is the left side of the comma
    operator. Here the version of `print` with a single templated parameter is called
    with each item in the `args` parameter pack.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`dummy`的虚拟数组。除了在参数包的扩展中使用之外，不使用该数组。该数组的大小与`args`参数包相同，并且省略号使用括号之间的*表达式*扩展参数包。表达式使用逗号运算符，它将返回逗号的右侧。由于这是一个整数，这意味着`dummy`的每个条目的值为零。有趣的部分是逗号运算符的左侧。这里使用具有单个模板化参数的`print`版本，该版本使用`args`参数包中的每个项目进行调用。
- en: Overloaded operators
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载运算符
- en: 'Earlier we said that function names should not contain punctuation. That is
    not strictly true because, if you are writing an operator, you *only* use punctuation
    in the function name. An operator is used in an expression acting on one or more
    operands. A unary operator has one operand, a binary operator has two operands,
    and an operator returns the result of the operation. Clearly this describes a
    function: a return type, a name, and one or more parameters.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我们说过函数名不应包含标点符号。这并不完全正确，因为如果您正在编写运算符，*只能*在函数名中使用标点符号。运算符用于对一个或多个操作数进行操作的表达式。一元运算符有一个操作数，二元运算符有两个操作数，并且运算符返回操作的结果。显然，这描述了一个函数：返回类型，名称和一个或多个参数。
- en: C++ provides the keyword `operator` to indicate that the function is not used
    with the function call syntax, but instead is called using the syntax associated
    with the operator (usually, a unary operator the first parameter is on the right
    of the operator, and for a binary operator the first parameter is on the left
    and the second is on the right, but there are exceptions to this).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了关键字`operator`，以指示该函数不使用函数调用语法，而是使用与运算符相关的语法调用（通常，一元运算符的第一个参数位于运算符的右侧，而二元运算符的第一个参数位于左侧，第二个参数位于右侧，但也有例外）。
- en: 'In general, you will provide the operators as part of a custom type (so the
    operators act upon variables of that type) but in some cases, you can declare
    operators at a global scope. Both are valid. If you are writing a custom type
    (classes, as explained in the next chapter), then it makes sense to encapsulate
    the code for an operator as part of the custom type. In this section, we will
    concentrate on the other way to define an operator: as a global function.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将提供运算符作为自定义类型的一部分（因此运算符作用于该类型的变量），但在某些情况下，您可以在全局范围内声明运算符。两者都是有效的。如果您正在编写自定义类型（如下一章中所述的类），那么将运算符的代码封装为自定义类型的一部分是有意义的。在本节中，我们将集中讨论定义运算符的另一种方法：作为全局函数。
- en: 'You can provide your own versions of the following unary operators:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供以下一元运算符的自定义版本：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can also provide your own versions of the following binary operators:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以提供以下二元运算符的自定义版本：
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can also write versions of the function call operator `()`, array subscript
    `[]`, conversion operators, the cast operator `(),` and `new` and `delete`. You
    cannot redefine the `.`, `.*`, `::`, `?:`, `#` or `##` operators, nor the "named"
    operators, `sizeof`, `alignof` or `typeid`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写函数调用运算符`()`、数组下标`[]`、转换运算符、强制转换运算符`()`、`new`和`delete`的版本。您不能重新定义`.`、`.*`、`::`、`?:`、`#`或`##`运算符，也不能重新定义“命名”运算符`sizeof`、`alignof`或`typeid`。
- en: 'When defining the operator, you write a function where the function name is
    `operator*x*` and `*x*` is the operator symbol (note that there is no space).
    For example, if you define a `struct` that has two members defining a Cartesian
    point, you may want to compare two points for equality. The `struct` can be defined
    like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义运算符时，您编写一个函数，其中函数名为`operator*x*`，而`*x*`是运算符符号（请注意，没有空格）。例如，如果您定义了一个具有两个成员的`struct`，用于定义笛卡尔点，您可能希望比较两个点是否相等。可以这样定义`struct`：
- en: '[PRE72]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Comparing two `point` objects is easy. They are the same if `x` and `y` of
    one object are equal to the corresponding values in the other object. If you define
    the `==` operator, then you should also define the `!=` operator using the same
    logic because `!=` should give the exact opposite result of the `==` operator.
    This is how these operators can be defined:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个`point`对象很容易。如果一个对象的`x`和`y`等于另一个对象中对应的值，则它们相同。如果定义了`==`运算符，则还应该使用相同的逻辑定义`!=`运算符，因为`!=`应该给出`==`运算符的确切相反结果。这是如何定义这些运算符的方式：
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The two parameters are the two operands of the operator. The first one is the
    operand on the left-hand side and the second parameter is the operand on the right-hand
    side of the operator. These are passed as references so that a copy is not made,
    and they are marked as `const` because the operator will not alter the objects.
    Once defined, you can use the `point` type like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数是运算符的两个操作数。第一个是左侧的操作数，第二个参数是运算符右侧的操作数。它们作为引用传递，以便不进行复制，并且它们标记为`const`，因为运算符不会改变对象。一旦定义，您可以像这样使用`point`类型：
- en: '[PRE74]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You could have defined a pair of functions called `equals` and `not_equals`
    and use these instead:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一对名为`equals`和`not_equals`的函数，并使用这些函数：
- en: '[PRE75]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: However, defining operators makes the code more readable because you use the
    type like the built-in types. Operator overloading is often referred to as *syntactic
    sugar*, syntax that makes the code easier to read--but this trivializes an important
    technique. For example, smart pointers are a technique that involves class **destructors**
    to manage resource lifetime, and are only useful because you can call the objects
    of such classes as if they are pointers. You can do this because the smart pointer
    class implements the `->` and `*` operators. Another example is **functors**,
    or function objects, where the class implements the `()` operator so that objects
    can be accessed as if they are functions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，定义运算符使代码更易读，因为您可以像内置类型一样使用该类型。运算符重载通常被称为*语法糖*，使代码更易于阅读的语法--但这淡化了一个重要的技术。例如，智能指针是一种涉及类**析构函数**来管理资源生命周期的技术，仅因为您可以调用此类对象，就好像它们是指针一样。您可以这样做，因为智能指针类实现了`->`和`*`运算符。另一个例子是**函数器**，或函数对象，其中类实现了`()`运算符，以便可以像访问函数一样访问对象。
- en: When you write a custom type, you should ask yourself if overloading an operator
    for your type makes sense. If the type is a numeric type, for example, a complex
    number or a matrix - then it makes sense to implement arithmetic operators, but
    would it make sense to implement the logical operators since the type does not
    have a logical aspect? There is a temptation to redefine the *meaning* of operators
    to cover your specific operation, but this will make your code less readable.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写自定义类型时，应该问自己是否重载该类型的运算符是有意义的。例如，如果该类型是数值类型，例如复数或矩阵 - 那么实现算术运算符是有意义的，但实现逻辑运算符是否有意义，因为该类型没有逻辑方面？有一种诱惑，即重新定义运算符的*含义*以涵盖您的特定操作，但这将使您的代码不太可读。
- en: 'In general, a unary operator is implemented as a global function that takes
    a single parameter. The postfix increment and decrement operators are an exception
    to allow for a different implementation from prefix operators. Prefix operators
    will have a reference to the object as a parameter (which the operator will increment
    or decrement) and return a reference to this changed object. The postfix operator,
    however, has to return the value of the object before the increment or decrement.
    Thus, the operator function has two parameters: a reference to an object that
    will be changed and an integer (which will always be a value of 1); it will return
    a copy of the original object.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，一元运算符被实现为接受单个参数的全局函数。后缀递增和递减运算符是一个例外，允许与前缀运算符不同的实现。前缀运算符将具有对对象的引用作为参数（运算符将递增或递减的对象），并返回对此更改后的对象的引用。然而，后缀运算符必须返回递增或递减之前对象的值。因此，运算符函数有两个参数：将被更改的对象的引用和一个整数（始终是1的值）；它将返回原始对象的副本。
- en: 'A binary operator will have two parameters and return an object or a reference
    to an object. For example, for the `struct` we defined previously, we could define
    an insertion operator for `ostream` objects:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符将有两个参数并返回一个对象或对象的引用。例如，对于我们之前定义的`struct`，我们可以为`ostream`对象定义插入运算符：
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This means that you can now insert a `point` object to the `cout` object to
    print it on the console:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在可以将`point`对象插入到`cout`对象中，以在控制台上打印它：
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Function objects
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象
- en: 'A function object, or **functor**, is a custom type that implements the function
    call operator: (`operator()`). This means that a function operator can be called
    in a way that looks like it is a function. Since we haven''t covered classes yet,
    in this section we will just explore the function objects types that are provided
    by the Standard Library and how to use them.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象，或**函数器**，是实现函数调用运算符（`operator()`）的自定义类型。这意味着可以以类似函数的方式调用函数运算符。由于我们还没有涵盖类，因此在本节中，我们将仅探讨标准库提供的函数对象类型以及如何使用它们。
- en: 'The `<functional>` header file contains various types that can be used as function
    objects. The following table lists these:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`<functional>`头文件包含各种可用作函数对象的类型。以下表列出了这些类型：'
- en: '| **Purpose** | **Types** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| **目的** | **类型** |'
- en: '| Arithmetic | `divides`, `minus`, `modulus`, `multiplies`, `negate`, `plus`
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | `divides`，`minus`，`modulus`，`multiplies`，`negate`，`plus` |'
- en: '| Bitwise | `bit_and`, `bit_not`, `bit_or`, `bit_xor` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 位运算 | `bit_and`，`bit_not`，`bit_or`，`bit_xor` |'
- en: '| Comparison | `equal_to`, `greater`, `greater_equal`, `less`, `less_equals`,
    `not_equal_to` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `equal_to`，`greater`，`greater_equal`，`less`，`less_equals`，`not_equal_to`
    |'
- en: '| Logical | `logical_and`, `logical_not`, `logical_or` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | `logical_and`，`logical_not`，`logical_or` |'
- en: 'These are all binary function classes, other than `bit_not`, `logical_not,`
    and `negate`, which are unary. Binary function objects act on two values and return
    a result, unary function objects act on a single value and return a result. For
    example, you could calculate the modulus of two numbers with this code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是二元函数类，除了`bit_not`，`logical_not`和`negate`是一元的。二元函数对象作用于两个值并返回一个结果，一元函数对象作用于单个值并返回一个结果。例如，您可以使用以下代码计算两个数字的模：
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This declares a function object called `fn` that will perform modulus. The
    object is used in the second line, which calls the `operator()` function on the
    object with two parameters, so the following line is equivalent to the preceding
    line:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个名为`fn`的函数对象，将执行模运算。该对象在第二行中使用，该行调用对象上的`operator()`函数，带有两个参数，因此以下行等同于前一行：
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The result is that the value of `0` is printed on the console. The `operator()`
    function merely performs the modulus on the two parameters, in this case `10 %
    2`. This does not look too exciting. The `<algorithm>` header contains functions
    that work on function objects. Most take predicates, that is, logical function
    objects, but one, `transform`, takes a function object that performs an action:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在控制台上打印出`0`的值。`operator()`函数仅对两个参数执行模运算，在这种情况下是`10 % 2`。这看起来并不太令人兴奋。`<algorithm>`头文件包含可以用于函数对象的函数。大多数采用谓词，即逻辑函数对象，但`transform`采用执行操作的函数对象：
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This code will perform five modulus calculations on the values in the two vectors.
    Conceptually, it does this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将对两个向量中的值执行五次模运算。在概念上，它是这样做的：
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: That is, each item in `result` is the modulus of the corresponding item in `v1`
    and `v2`. In the code, the first line creates a `vector` with the five values.
    We will calculate the modulus of these values with `2`, so the second line declares
    an empty `vector` but with the same capacity as the first `vector`. This second
    `vector` is filled by calling the `fill` function. The first parameter is the
    address of the first item in the `vector` and the `end` function returns the address
    after the *last* item in the `vector`. The final item in the function call is
    the value that will be placed in the `vector` in every item starting with the
    item pointed to by the first parameter up to, but excluding, the item pointed
    to by the second parameter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`result`中的每个项目都是`v1`和`v2`中对应项目的模。在代码中，第一行创建了一个具有五个值的`vector`。我们将用`2`计算这些值的模，因此第二行声明了一个空的`vector`，但容量与第一个`vector`相同。通过调用`fill`函数来填充这个第二个`vector`。第一个参数是`vector`中第一个项目的地址，`end`函数返回`vector`中*最后*一个项目之后的地址。函数调用的最后一个项目是将放置在从第一个参数指向的项目开始到第二个参数指向的项目之前（不包括）的`vector`中的值。
- en: 'At this point, the second `vector` will contain five items and each one will
    be `2`. Next, a `vector` is created for the results; and again, it is the same
    size as the first array. Finally, the calculation is performed by the `transform`
    function, shown here again:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，第二个`vector`将包含五个项目，每个项目都是`2`。接下来，创建了一个用于结果的`vector`；同样，它的大小与第一个数组相同。最后，通过`transform`函数执行计算，再次显示如下：
- en: '[PRE82]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first two parameters give the iterators of the first `vector` and from this
    the number of items can be calculated. Since all three `vector`s are the same
    size, you only need the `begin` iterator for `v2` and `result`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数给出了第一个`vector`的迭代器，从中可以计算出项目的数量。由于所有三个`vector`的大小相同，因此只需要`v2`和`result`的`begin`迭代器。
- en: The last parameter is the function object. This is a temporary object and only
    exists during this statement; it has no name. The syntax used here is an explicit
    call to the constructor of the class; it is templated so you need to give the
    template parameter. The `transform` function will call the `operator(int,int)`
    function on this function object for each item in `v1` as the first parameter
    and the corresponding item in `v2` as the second parameter and it will store the
    result in the corresponding position in `result`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是函数对象。这是一个临时对象，仅在此语句期间存在；它没有名称。这里使用的语法是对类的构造函数的显式调用；它是模板化的，因此需要给出模板参数。`transform`函数将对`v1`中的每个项目调用此函数对象的`operator(int,int)`函数作为第一个参数，并将`v2`中的相应项目作为第二参数，并将结果存储在`result`中的相应位置。
- en: Since `transform` takes any binary function object as the second parameter,
    you can pass an instance of `plus<int>` to add a value of 2 to every item in `v1`,
    or pass an instance of `multiplies<int>` to multiply every item in `v1` by 2.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`transform`将任何二进制函数对象作为第二个参数，您可以传递`plus<int>`的实例来将`v1`中的每个项目加2，或者传递`multiplies<int>`的实例来将`v1`中的每个项目乘以2。
- en: 'One situation where function objects are useful is when performing multiple
    comparisons using a predicate. A predicate is a function object that compares
    values and returns a Boolean. The `<functional>` header contains several classes
    to allow you to compare items. Let''s see how many items in the `result` container
    are zero. To do this, we use the `count_if` function. This will iterate over a
    container, apply the predicate to every item, and count how many times the predicate
    returns a value of `true`. There are several ways to do this. The first defines
    a predicate function:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象有用的一种情况是使用谓词进行多个比较。谓词是一个比较值并返回布尔值的函数对象。`<functional>`头文件包含几个类，允许您比较项目。让我们看看`result`容器中有多少个项目是零。为此，我们使用`count_if`函数。这将遍历容器，对每个项目应用谓词，并计算谓词返回`true`值的次数。有几种方法可以做到这一点。第一种定义了一个谓词函数：
- en: '[PRE83]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A pointer to this can then be passed to the `count_if` function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将指向此的指针传递给`count_if`函数：
- en: '[PRE84]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The first two parameters indicate the range of values to check. The last parameter
    is a pointer to the function that is used as the predicate. Of course, if you
    are checking for different values you can make this more generic:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数指示要检查的值的范围。最后一个参数是用作谓词的函数的指针。当然，如果要检查不同的值，可以使其更通用：
- en: '[PRE85]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Call it like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样调用它：
- en: '[PRE86]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The problem with this code is that we are defining the operation in a place
    other than where it is used. The `equals` function could be defined in another
    file; however, with a predicate it is more readable to have the code that does
    the checking defined close to the code that needs the predicate.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于我们在使用操作的地方之外定义了它。`equals`函数可以在另一个文件中定义；然而，使用谓词时，将检查代码定义在需要谓词的代码附近更易读。
- en: 'The `<functional>` header also defines classes that can be used as function
    objects. For example, `equal_to<int>`, which compares two values. However, the
    `count_if` function expects a unary function object, to which it will pass a single
    value (see the `equals_zero` function, described previously). `equal_to<int>`
    is a binary function object, comparing two values. We need to provide the second
    operand and to do this we use the helper function called `bind2nd`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`<functional>`头文件还定义了可以用作函数对象的类。例如，`equal_to<int>`，用于比较两个值。但是，`count_if`函数期望一个一元函数对象，它将传递一个单个值（参见前面描述的`equals_zero`函数）。`equal_to<int>`是一个二元函数对象，用于比较两个值。我们需要提供第二个操作数，为此我们使用名为`bind2nd`的辅助函数：'
- en: '[PRE87]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `bind2nd` will *bind* the parameter `0` to the function object created from
    `equal_to<int>`. Using a function object like this brings the definition of the
    predicate closer to the function call that will use it, but the syntax looks rather
    messy. C++11 provides a mechanism to get the compiler to determine the function
    objects that are required and bind parameters to them. These are called lambda
    expressions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind2nd`将参数`0`*绑定*到从`equal_to<int>`创建的函数对象。像这样使用函数对象将谓词的定义与将使用它的函数调用更加接近，但语法看起来相当混乱。C++11提供了一种机制，可以让编译器确定所需的函数对象并将参数绑定到它们。这些被称为lambda表达式。'
- en: Introducing lambda expressions
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入lambda表达式
- en: 'A lambda expression is used to create an anonymous function object at the location
    where the function object will be used. This makes your code much more readable
    because you can see what will be executed. On first sight, a lambda expression
    looks like a function definition in-place as a function parameter:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式用于在将使用函数对象的位置创建匿名函数对象。这使得您的代码更易读，因为您可以看到将执行什么。乍一看，lambda表达式看起来像是在函数参数的地方定义的函数：
- en: '[PRE88]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: So that we don't have the complication of a function that uses a predicate,
    in this code we have assigned a variable to the lambda expression. This is not
    normally how you would use it, but it makes the description clearer. The square
    brackets at the beginning of the lambda expression are called the **capture list**.
    This expression does not capture variables, so the brackets are empty. You can
    use variables declared outside of the lambda expression and these have to be *captured*.
    The capture list indicates whether all such variables will be captured by a reference
    (use `[&]`) or by a value (use `[=]`). You can also name the variables that will
    be captured (if there are more than one, use a comma-separated list) and if they
    are captured by a value, you use just their names. If they are captured by a reference,
    use a `&` on their names.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用谓词的函数的复杂性，在此代码中，我们将一个变量分配给lambda表达式。这通常不是您使用它的方式，但这样可以使描述更清晰。lambda表达式开头的方括号称为**捕获列表**。此表达式不捕获变量，因此方括号为空。您可以使用在lambda表达式外声明的变量，并且这些变量必须被*捕获*。捕获列表指示所有这些变量是否将被引用捕获（使用`[&]`）还是值捕获（使用`[=]`）。您还可以命名将被捕获的变量（如果有多个，则使用逗号分隔的列表），如果它们被值捕获，只需使用它们的名称。如果它们被引用捕获，使用它们的名称上加`&`。
- en: 'You could make the preceding lambda expression more generic by introducing
    a variable declared outside of the expression called `limit`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过引入在表达式外声明的名为`limit`的变量，使前面的lambda表达式更通用：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If you compare a lambda expression to a global function, the capture list is
    a bit like identifying the global variables that the global function can access.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将lambda表达式与全局函数进行比较，捕获列表有点像标识全局函数可以访问的全局变量。
- en: After the caption list, you give the parameter list in parentheses. Again, if
    you compare a lambda to a function, the lambda parameter list is equivalent to
    the function parameter list. If the lambda expression does not have any parameters,
    then you can miss out the parentheses altogether.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获列表之后，您在括号中给出参数列表。同样，如果将lambda与函数进行比较，lambda参数列表等同于函数参数列表。如果lambda表达式没有任何参数，则可以完全省略括号。
- en: 'The body for the lambda is given in a pair of braces. This can contain anything
    that can be found in a function. The lambda body can declare local variables,
    and it can even declare `static` variables, which looks bizarre, but is legal:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: lambda的主体在一对大括号中给出。这可以包含任何可以在函数中找到的内容。lambda主体可以声明局部变量，甚至可以声明`static`变量，这看起来很奇怪，但是合法的：
- en: '[PRE90]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The return value of the lambda is deduced from the item that is returned. A
    lambda expression does not have to return a value, in which case the expression
    will return `void`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda的返回值是从返回的项目中推断出来的。Lambda表达式不一定要返回一个值，如果不返回值，表达式将返回`void`：
- en: '[PRE91]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The power of lambda expressions is that you can use them in cases when a function
    object or a predicate is needed:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的强大之处在于您可以在需要函数对象或谓词的情况下使用它们：
- en: '[PRE92]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here we declare a `vector` and initialize it with some values. The `count_if`
    function is used to count how many items in the container are less than 3\. So,
    the first two parameters are used to give the range of items to check, and the
    third parameter is a lambda expression that performs the comparison. The `count_if`
    function will call this expression for every item in the range that is passed
    in via the `a` parameter of the lambda. The `count_if` function keeps a running
    count of how many times the lambda returns `true`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个`vector`并用一些值初始化它。`count_if`函数用于计算容器中小于3的项目数。因此，前两个参数用于指定要检查的项目范围，第三个参数是执行比较的lambda表达式。`count_if`函数将为传递给lambda的`a`参数的范围中的每个项目调用此表达式。`count_if`函数将持续计算lambda返回`true`的次数。
- en: Using functions in C++
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中使用函数
- en: 'The example in this chapter uses the techniques you have learned in this chapter
    to list all the files in a folder, and subfolders, in order of file size, giving
    a listing of the filenames and their sizes. The example is the equivalent of typing
    the following at the command line:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例使用了本章学到的技术，列出了文件夹和子文件夹中所有文件的文件大小，并按文件大小顺序给出文件名和它们的大小。该示例相当于在命令行中输入以下内容：
- en: '[PRE93]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, `folder` is the folder you are listing. The `/s` option recurses, `/a-d`
    removes folders from the list, and `/os` orders by size. The problem is that without
    the `/b` option we get information about each folder, but using it removes the
    file size in the list. We want a list of filenames (and their paths), their size,
    ordered by the smallest first.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`folder`是您要列出的文件夹。`/s`选项递归，`/a-d`从列表中删除文件夹，`/os`按大小排序。问题在于，如果没有`/b`选项，我们会得到有关每个文件夹的信息，但使用它会删除列表中的文件大小。我们希望得到一个文件名（及其路径）和大小的列表，按最小的顺序排列。
- en: 'Start by creating a new folder for this chapter (`Chapter_05`) under the `Beginning_C++`
    folder. In Visual C++ create a new C++ source file and save it as `files.cpp`
    under this new folder. The example will use basic output and strings. It will
    take a single command line parameter; if more command-line parameters are passed,
    we just use the first one. Add the following to `files.cpp`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`Beginning_C++`文件夹下创建一个新的文件夹（`Chapter_05`）用于本章。在Visual C++中创建一个新的C++源文件，并将其保存为`files.cpp`，保存在这个新文件夹下。该示例将使用基本的输出和字符串。它将接受一个命令行参数；如果传递了更多的命令行参数，我们将只使用第一个。将以下内容添加到`files.cpp`中：
- en: '[PRE94]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The example will use the Windows functions, `FindFirstFile` and `FindNextFile`,
    to get information about files that meet a file specification. These return data
    in a `WIN32_FIND_DATAA` structure, which has information about the filename, the
    file size, and file attributes. The functions also return information about folders
    too, so it means we can test for subfolders and recurse. The `WIN32_FIND_DATAA`
    structure gives the file size as a 64-bit number in two parts: the upper and lower
    32 bits. We will create our own structure to hold this information. At the top
    of the file, after the C++ include files, add the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将使用Windows函数`FindFirstFile`和`FindNextFile`来获取符合文件规范的文件的信息。这些函数返回`WIN32_FIND_DATAA`结构中的数据，该结构包含有关文件名、文件大小和文件属性的信息。这些函数还返回有关文件夹的信息，因此我们可以测试子文件夹并进行递归。`WIN32_FIND_DATAA`结构以两部分的64位数字给出文件大小：高32位和低32位。我们将创建自己的结构来保存这些信息。在文件顶部，在C++包含文件之后，添加以下内容：
- en: '[PRE95]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The first line is the Windows SDK header file so that you can access the Windows
    functions, and the structure is used to hold the information about a file's size.
    We want to compare files by their sizes. The `WIN32_FIND_DATAA` structure provides
    the size in two `unsigned long` members (one with the upper 4 bytes and the other
    with the lower 4 bytes). We could store this as a 64-bit number, but instead,
    so that we have an excuse to write some operators, we store the size in our `file_size`
    structure. The example will print out file sizes and will compare file sizes,
    so we will write an operator to insert a `file_size` object into an output steam;
    since we want to order the files by size, we need an operator to determine if
    one `file_size` object is greater than the other.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是Windows SDK头文件，以便您可以访问Windows函数，该结构用于保存有关文件大小的信息。我们想要通过它们的大小来比较文件。`WIN32_FIND_DATAA`结构提供了两个`unsigned
    long`成员的大小（一个带有高4字节，另一个带有低4字节）。我们可以将其存储为64位数字，但是为了有借口编写一些操作符，我们将大小存储在我们的`file_size`结构中。该示例将打印文件大小并比较文件大小，因此我们将编写一个操作符将`file_size`对象插入输出流；由于我们想按大小对文件进行排序，我们需要一个操作符来确定一个`file_size`对象是否大于另一个。
- en: 'The code will use Windows functions to get information about the files, in
    particular their name and size. This information will be stored in a `vector`,
    so at the top of the file add these two highlighted lines:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将使用Windows函数获取有关文件的信息，特别是它们的名称和大小。这些信息将存储在一个`vector`中，因此在文件顶部添加这两行：
- en: '[PRE96]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `tuple` class is needed so that we can store both a `string` (the filename)
    and a `file_size` object as each item in the `vector`. To make the code more readable
    add the following alias after the structure definition:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple`类是必需的，以便我们可以将`string`（文件名）和`file_size`对象作为`vector`中的每个项目进行存储。为了使代码更易读，在结构定义之后添加以下别名：'
- en: '[PRE97]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Then just above the `main` function add the skeleton code for the function
    that will get the file in a folder:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`main`函数的上面添加获取文件夹中文件的函数的框架代码：
- en: '[PRE98]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'This function takes a reference to a `vector` and a folder path. The code will
    go through each item in the specified folder. If it is a file, it will store the
    details in the `vector`; otherwise, if the item is a folder it will call itself
    to get the files in that subfolder. Add a call to this function at the bottom
    of the `main` function:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个`vector`的引用和一个文件夹路径。代码将遍历指定文件夹中的每个项目。如果它是一个文件，它将在`vector`中存储详细信息；否则，如果该项目是一个文件夹，它将调用自身以获取该子文件夹中的文件。在`main`函数的底部添加对该函数的调用：
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The code has already checked that there is at least one command line argument,
    and we use this as the folder to examine. The `main` function should print out
    the file information, so we declare a `vector` on the stack and pass this by reference
    to the `files_in_folder` function. This code does nothing so far, but you can
    compile the code to make sure that there are no typos (remember to use the `/EHsc`
    parameter).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经检查了至少有一个命令行参数，并将其用作要检查的文件夹。`main`函数应该打印文件信息，因此我们在堆栈上声明一个`vector`并将其通过引用传递给`files_in_folder`函数。到目前为止，这段代码什么也没做，但您可以编译代码以确保没有拼写错误（记得使用`/EHsc`参数）。
- en: 'Most of the work is carried out in the `files_in_folder` function. As a start,
    add the following code to this function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作是在`files_in_folder`函数中完成的。首先，在该函数中添加以下代码：
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We will use the ASCII version of the functions (hence the trailing `A` on the
    structure and function names). The `FindFirstFileA` function takes a search path,
    and in this case, we use the name of a folder suffixed with a `*`, meaning *everything
    in this folder*. Notice that the Windows function wants a `const char*` parameter,
    so we use the `c_str` function on the `string` object. If the function call succeeds
    and it finds an item that meets this criterion, then the function fills in the
    `WIN32_FIND_DATAA` structure passed by the reference and it also returns an opaque
    pointer which will be used to make subsequent calls on this search (you do not
    need to know what it points to). The code checks to see if the call was successful,
    and if so, it repeatedly calls `FindNextFileA` to get the next item until this
    function returns 0, indicating there are no more items. The opaque pointer is
    passed to `FindNextFileA` so that it knows which search is being checked. When
    the search is complete, the code calls `FindClose` to release whatever resources
    Windows allocates for the search.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用函数的ASCII版本（因此在结构和函数名称后面加上`A`）。`FindFirstFileA`函数接受搜索路径，在这种情况下，我们使用文件夹的名称后缀为`*`，表示*此文件夹中的所有内容*。请注意，Windows函数需要`const
    char*`参数，因此我们在`string`对象上使用`c_str`函数。如果函数调用成功并找到符合此条件的项目，那么函数会填充传递的`WIN32_FIND_DATAA`结构的引用，并且还会返回一个不透明指针，该指针将用于对此搜索进行后续调用（您不需要知道它指向什么）。代码检查调用是否成功，如果成功，它将重复调用`FindNextFileA`以获取下一个项目，直到此函数返回0，表示没有更多项目。将不透明指针传递给`FindNextFileA`，以便它知道正在检查哪个搜索。搜索完成后，代码调用`FindClose`以释放Windows为搜索分配的任何资源。
- en: 'The search will return both file and folder items; to handle each differently,
    we can test the `dwFileAttributes` member of the `WIN32_FIND_DATAA` structure.
    Add the following code in the `do` loop:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索将返回文件和文件夹项目；要分别处理每个项目，我们可以测试`WIN32_FIND_DATAA`结构的`dwFileAttributes`成员。在`do`循环中添加以下代码：
- en: '[PRE101]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `WIN32_FIND_DATAA` structure contains just the relative name of the item
    in the folder, so the first few lines create an absolute path. The following lines
    test to see if the item is a folder (directory) or a file. If the item is a file,
    then we simply add it to the vector passed to the function. Add the following
    to the `else` clause:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: WIN32_FIND_DATAA结构仅包含文件夹中项目的相对名称，因此前几行创建了绝对路径。接下来的几行测试项目是文件夹（目录）还是文件。如果项目是文件，那么我们只需将其添加到传递给函数的向量中。将以下内容添加到`else`子句中：
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The first three lines initialize a `file_size` structure with the size data,
    and the last line adds a `tuple` with the name of the file and its size to the
    `vector`. So that you can see the results of a simple call to this function, add
    the following to the bottom of the `main` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行初始化了一个`file_size`结构，并且最后一行将带有文件名和大小的`tuple`添加到`vector`中。因此，为了看到对此函数的简单调用的结果，请将以下内容添加到`main`函数的底部：
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This iterates through the items in the `files` vector. Each item is a `tuple<string,
    file_size>` object and to get the `string` item, you can use the Standard Library
    function, `get,` using 0 as the function template parameter, and to get the `file_size`
    object you call `get` with 1 as the function template parameter. The code calls
    the `setw` manipulator to make sure that the file sizes are always printed in
    a column 16 characters wide. To use this, you need to add an include for `<iomanip>`
    at the top of the file. Notice that `get<1>` will return a `file_size` object
    and this is inserted into `cout`. As it stands, this code will not compile because
    there is no operator to do this. We need to write one.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过`files`向量中的项目进行迭代。每个项目都是一个`tuple<string, file_size>`对象，要获取`string`项目，可以使用标准库函数`get`，使用0作为函数模板参数，要获取`file_size`对象，可以使用1作为函数模板参数调用`get`。代码调用`setw`操纵符，以确保文件大小始终以16个字符宽的列打印。要使用此功能，需要在文件顶部添加`<iomanip>`的包含。请注意，`get<1>`将返回一个`file_size`对象，并将其插入`cout`。就目前而言，此代码将无法编译，因为没有运算符可以执行此操作。我们需要编写一个。
- en: 'After the definition of the structure, add the following code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构的定义之后，添加以下代码：
- en: '[PRE104]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This operator will alter the `ostream` object, so we store the initial state
    at the beginning of the function and restore the object to this state at the end.
    Since the file size is a 64-bit number, we convert the constituent parts of the
    `file_size` object and then print it out as a hexadecimal number.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此运算符将更改`ostream`对象，因此我们在函数开始时存储初始状态，并在函数结束时将对象恢复到此状态。由于文件大小是64位数字，我们将`file_size`对象的组成部分转换为十六进制数，然后将其打印出来。
- en: 'Now you can compile and run this application. For example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译并运行此应用程序。例如：
- en: '[PRE105]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This will list the names and sizes of the files in the `windows` folder.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出`windows`文件夹中文件的名称和大小。
- en: 'There are two more things that need to be done--recurse subfolders and sort
    the data. Both are straightforward to implement. In the `files_in_folder` function,
    add the following code to the code block of the `if` statement:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两件事需要做-递归子文件夹和对数据进行排序。这两者都很容易实现。在`files_in_folder`函数中，将以下代码添加到`if`语句的代码块中：
- en: '[PRE106]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The search will return the `.` (current) folder and `..` (parent) folder, so
    we need to check for these and ignore them. The next action is to recursively
    call the `files_in_folder` function to obtain the files in the subfolder. If you
    wish, you can compile and test the application, but this time it is best to test
    the code using the `Beginning_C++` folder because recursively listing the Windows
    folder will produce a lot of files.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索将返回“.”（当前）文件夹和“..”（父级）文件夹，因此我们需要检查并忽略它们。下一步是递归调用`files_in_folder`函数，以获取子文件夹中的文件。如果愿意，可以编译和测试应用程序，但这次最好使用`Beginning_C++`文件夹来测试代码，因为递归列出Windows文件夹将产生大量文件。
- en: 'The code returns the list of files as they were obtained, but we want to see
    them in order of file size. To do this we can use the sort function in the `<algorithm>`
    header, so add an include to this after the include for `<tuple>`. In the `main`
    function, after the call to `files_in_folder,` add this code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 代码返回了获取的文件列表，但我们希望按文件大小顺序查看它们。为此，我们可以使用`<algorithm>`头文件中的`sort`函数，因此在`<tuple>`的包含之后添加一个包含。在`main`函数中，在调用`files_in_folder`之后，添加以下代码：
- en: '[PRE107]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first two parameters of the `sort` function indicate the range of items
    to check. The third item is a predicate, and the function will pass two items
    from the `vector` to the predicate. You have to return a value of `true` if the
    two parameters are in order (the first is smaller than the second).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数的前两个参数表示要检查的项目范围。第三个项目是一个谓词，函数将把`vector`中的两个项目传递给谓词。如果两个参数顺序正确（第一个小于第二个），则必须返回`true`值。'
- en: 'The predicate is provided by a lambda expression. There are no captured variables
    so the expression starts with `[]` and this is followed by the parameter list
    of the items being compared by the `sort` algorithm (passed by `const` reference,
    because they will not be changed). The actual comparison is carried out between
    the braces. Since we want to list the files in ascending order, we have to ensure
    that the second of the two is bigger than the first. In this code, we use the
    `>` operator on the two `file_size` objects. So that this code will compile, we
    need to define this operator. After the insertion operator add the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词由lambda表达式提供。没有捕获的变量，所以表达式以`[]`开头，然后是被`sort`算法比较的项目的参数列表（通过`const`引用传递，因为它们不会被改变）。实际的比较是在大括号之间进行的。由于我们想要按升序列出文件，我们必须确保两者中的第二个比第一个大。在这段代码中，我们使用`>`运算符对两个`file_size`对象进行比较。为了使这段代码编译通过，我们需要定义这个运算符。在插入运算符之后添加以下内容：
- en: '[PRE108]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You can now compile the example and run it. You should find that the files in
    the specified folder and subfolders are listed in order of the size of the files.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译示例并运行它。您应该发现指定文件夹和子文件夹中的文件按文件大小顺序列出。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Functions allow you to segment your code into logical routines, which makes
    your code more readable, and gives the flexibility of being able to reuse code.
    C++ provides a wealth of options to define functions, including variable argument
    lists, templates, function pointers, and lambda expressions. However, there is
    one main issue with global functions: the data is separate from the function.
    This means that the function has to access the data via global data items, or
    data has to be passed to a function via a parameter every time the function is
    called. In both cases, the data exists outside the function and could be used
    by other functions unrelated to the data. The next chapter will give a solution
    to this: classes. A `class` allows you to encapsulate data in a custom type, and
    you can define functions on that type so that only these functions will be able
    to access the data.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 函数允许您将代码分割成逻辑程序，这样可以使您的代码更易读，并且具有能够重用代码的灵活性。C++提供了丰富的选项来定义函数，包括可变参数列表、模板、函数指针和lambda表达式。然而，全局函数存在一个主要问题：数据与函数是分离的。这意味着函数必须通过全局数据项访问数据，或者数据必须在每次调用函数时通过参数传递给函数。在这两种情况下，数据存在于函数之外，可能被与数据无关的其他函数使用。下一章将提供解决方案：类。`class`允许您将数据封装在自定义类型中，并且可以在该类型上定义函数，以便只有这些函数才能访问数据。
