- en: Cloud-Native Design
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生设计
- en: As the name suggests, cloud-native design describes the application's architecture
    built, first and foremost, to operate in the cloud. It is not defined by a single
    technology or language, but rather takes advantage of all that the modern cloud
    platforms offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，云原生设计描述了首先建立在云中运行的应用程序架构。它不是由单一技术或语言定义的，而是充分利用现代云平台所提供的一切。
- en: This may mean a combination of using **Platform-as-a-Service** (**PaaS**) whenever
    necessary, multi-cloud deployments, edge computing, **Function-as-a-Service**
    (**FaaS**), static file hosting, microservices, and managed services. It transcends
    the boundaries of traditional operating systems. Instead of targeting the POSIX
    API and UNIX-like operating systems, cloud-native developers build on higher-level
    concepts using libraries and frameworks such as boto3, Pulumi, or Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着在必要时结合使用**平台即服务**（**PaaS**），多云部署，边缘计算，**函数即服务**（**FaaS**），静态文件托管，微服务和托管服务。它超越了传统操作系统的边界。云原生开发人员不再针对POSIX
    API和类UNIX操作系统，而是使用诸如boto3、Pulumi或Kubernetes等库和框架构建更高级别的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding cloud-native
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解云原生
- en: Using Kubernetes to orchestrate cloud-native workloads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes编排云原生工作负载
- en: Connecting services with a service mesh
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务网格连接服务
- en: Observability in distributed systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式系统中的可观察性
- en: Going GitOps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用GitOps
- en: By the end of the chapter, you'll have a good understanding of how modern trends
    in software architecture can be used in your applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对如何在应用程序中使用软件架构的现代趋势有很好的理解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Some of the examples in this chapter require Kubernetes 1.18.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些示例需要Kubernetes 1.18。
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter15](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter15).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码已放置在GitHub上[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter15](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter15)。
- en: Understanding cloud-native
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解云原生
- en: Whereas it is possible to migrate an existing application to run in the cloud,
    such migration won't make the application cloud-native. It would be running in
    the cloud, but the architectural choices would still be based on the on-premises
    model.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以将现有应用程序迁移到云中运行，但这种迁移不会使应用程序成为云原生。它可能在云中运行，但架构选择仍然基于本地模型。
- en: In short, cloud-native applications are distributed by nature, loosely coupled,
    and are scalable. They're not tied to any particular physical infrastructure and
    don't require the developers to even think about specific infrastructure. Such
    applications are usually web-centric.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，云原生应用程序通常是分布式的，松散耦合的，并且可扩展的。它们不受特定的物理基础设施约束，也不需要开发人员考虑特定的基础设施。这类应用程序通常是面向Web的。
- en: In this chapter, we'll go over some examples of cloud-native building blocks
    and describe some cloud-native patterns.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些云原生构建模块的示例，并描述一些云原生模式。
- en: Cloud-Native Computing Foundation
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生计算基金会
- en: 'One proponent of cloud-native design is the **Cloud Native Computing Foundation**
    (**CNCF**), which hosts the Kubernetes project. CNCF is home to various technologies,
    making it easier to build cloud-native applications independent of the cloud vendor.
    Examples of such technologies include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生设计的支持者之一是**Cloud Native Computing Foundation**（**CNCF**），它托管了Kubernetes项目。CNCF拥有各种技术，使得更容易构建与云供应商无关的云原生应用程序。此类技术的示例包括以下内容：
- en: '**Fluentd**, a unified logging layer'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fluentd**，统一的日志记录层'
- en: '**Jaeger**, for distributed tracing'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jaeger**，用于分布式跟踪'
- en: '**Prometheus**, for monitoring'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prometheus**，用于监控'
- en: '**CoreDNS**, for service discovery'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreDNS**，用于服务发现'
- en: Cloud-native applications are typically built with application containers, often
    running on top of the Kubernetes platform. However, this is not a requirement,
    and it's entirely possible to use many of the CNCF frameworks outside Kubernetes
    and containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序通常使用应用程序容器构建，通常在Kubernetes平台上运行。但这不是必需的，完全可以在Kubernetes和容器之外使用许多CNCF框架。
- en: Cloud as an operating system
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云作为操作系统
- en: The main trait of cloud-native design is to treat the various cloud resources
    as the building blocks of your application. Individual **virtual machines** (**VMs**)
    are seldom used in cloud-native design. Instead of targeting a given operating
    system running on some instances, with a cloud-native approach, you target either
    the cloud API directly (for example, with FaaS) or some intermediary solution
    such as Kubernetes. In this sense, the cloud becomes your operating system, as
    the POSIX API no longer limits you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生设计的主要特点是将各种云资源视为应用程序的构建模块。在云原生设计中，很少使用单独的**虚拟机**（**VMs**）。与针对在某些实例上运行的特定操作系统相反，在云原生方法中，您要么直接针对云API（例如使用FaaS），要么针对Kubernetes等中间解决方案。在这种意义上，云成为您的操作系统，因为POSIX
    API不再限制您。
- en: As containers changed the approach to building and distributing software, it
    is now possible to free yourself from thinking about the underlying hardware infrastructure.
    Your software is not working in isolation, so it's still necessary to connect
    different services, monitor them, control their life cycle, store data, or pass
    the secrets. This is something that Kubernetes provides and it's one of the reasons
    why it became so popular.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器改变了构建和分发软件的方式，现在可以摆脱对基础硬件基础设施的思考。您的软件并非在孤立运行，因此仍然需要连接不同的服务，监视它们，控制它们的生命周期，存储数据或传递秘密。这是Kubernetes提供的功能之一，也是它变得如此受欢迎的原因之一。
- en: As you can probably imagine, cloud-native applications are web- and mobile-first.
    Desktop applications can also benefit from having some cloud-native components,
    but it's a less common use case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以想象，云原生应用程序是面向Web和移动设备的。桌面应用程序也可以从具有一些云原生组件中受益，但这是一个不太常见的用例。
- en: It's still possible to use hardware and other low-level access in cloud-native
    applications. If your workload requires the use of the GPU, this should not prevent
    you from going cloud-native. What's more, cloud-native applications can be built
    on-premises if you want access to custom hardware unavailable elsewhere. The term
    is not limited to the public cloud, but rather to the way of thinking about different
    resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生应用程序中仍然可以使用硬件和其他低级访问。如果您的工作负载需要使用GPU，这不应该阻止您进行云原生。而且，如果您想要访问其他地方无法获得的自定义硬件，云原生应用程序也可以在本地构建。这个术语不仅限于公共云，而是一种思考不同资源的方式。
- en: Load balancing and service discovery
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载平衡和服务发现
- en: Load balancing is an essential part of distributed applications. It not only
    spreads the incoming requests across a cluster of services, which is essential
    for scaling, but can also help the responsiveness and availability of the applications.
    A smart load balancer can gather metrics to react to patterns in incoming traffic,
    monitor the state of the servers in its cluster, and forward requests to the less
    loaded and faster responding nodes – avoiding the currently unhealthy ones.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 负载平衡是分布式应用程序的重要组成部分。它不仅可以将传入的请求分散到一组服务中，这对于扩展至关重要，还可以帮助应用程序的响应性和可用性。智能负载均衡器可以收集指标以应对传入流量的模式，监视其集群中服务器的状态，并将请求转发到负载较轻和响应更快的节点，避免当前不健康的节点。
- en: Load balancing brings more throughput and less downtime. By forwarding requests
    to many servers, a single point of failure is eliminated, especially if multiple
    load balancers are used, for example, in an active-passive scheme.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 负载平衡带来更高的吞吐量和更少的停机时间。通过将请求转发到多个服务器，消除了单点故障，尤其是如果使用多个负载均衡器，例如在主备方案中。
- en: 'Load balancers can be used anywhere in your architecture: you can balance the
    requests coming from the web, requests done by web servers to other services,
    requests to cache or database servers, and whatever else suits your requirements.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器可以在架构的任何地方使用：您可以平衡来自Web的请求，Web服务器对其他服务的请求，对缓存或数据库服务器的请求，以及其他满足您需求的请求。
- en: 'There are a few things to remember when introducing load balancing. One of
    them is session persistence—make sure all requests from the same customer go to
    the same server, so the carefully chosen pink stilettos won''t disappear from
    their basket in your e-commerce site. Sessions can get tricky with load balancing:
    take extra care to not mix sessions, so customers won''t suddenly start being
    logged into each other''s profiles – countless companies stumbled upon this error
    before, especially when adding caching into the mix. It''s a great idea to combine
    the two; just make sure it is done the right way.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入负载平衡时有一些事项需要记住。其中之一是会话持久性——确保来自同一客户的所有请求都发送到同一服务器，这样精心选择的粉红色高跟鞋就不会从他们的购物篮中消失在您的电子商务网站上。负载均衡可能会让会话变得棘手：要特别小心，不要混淆会话，这样客户就不会突然开始被登录到彼此的个人资料中——许多公司在这方面出现过错误，尤其是在添加缓存时。将两者结合起来是一个好主意；只要确保它是正确的方式。
- en: Reverse proxies
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反向代理
- en: Even if you want to deploy just one instance of your server, it might be a good
    idea to add yet another service in front of it instead of the load balancer—a
    reverse proxy. While a proxy usually acts on behalf of the client sending some
    requests, a reverse proxy acts on behalf of the servers handling those requests,
    hence the name.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只想部署一个服务器实例，将另一个服务添加到负载均衡器之前，而不是负载均衡器，即反向代理，可能是一个好主意。虽然代理通常代表客户端发送一些请求，但反向代理代表处理这些请求的服务器，因此得名。
- en: 'Why use it, you ask? There are several reasons and uses for such a proxy:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你问为什么要使用它？有几个原因和用途可以使用这样的代理：
- en: '**Security**: The address of your server is now hidden, and the server can
    be protected by the proxy''s DDoS prevention capabilities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：您的服务器地址现在被隐藏，服务器可以受到代理的DDoS防护能力的保护。'
- en: '**Flexibility and scalability**: You can modify the infrastructure hidden behind
    the proxy in any way you want and when you want.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性和可扩展性**：您可以以任何您想要的方式和时间修改代理后面隐藏的基础设施。'
- en: '**Caching**: Why bother the server if you already know what answer it will
    give?'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓���**：如果您已经知道服务器将给出什么答案，为什么还要打扰服务器呢？'
- en: '**Compression**: Compressing data will reduce the bandwidth needed, which may
    be especially useful for mobile users with poor connectivity. It can also lower
    your networking costs (but will likely cost you compute power).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩**：压缩数据将减少所需的带宽，这对于连接质量差的移动用户可能特别有用。它还可以降低您的网络成本（但可能会消耗计算能力）。'
- en: '**SSL termination**: Reduce the backend server''s load by taking its burden
    to encrypt and decrypt network traffic.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSL终止**：通过接管加密和解密网络流量的负担，减轻后端服务器的负载。'
- en: An example of a reverse proxy is **NGINX**. It also provides load balancing
    capabilities, A/B testing, and much more. One of its other capabilities is service
    discovery. Let's see how it can be helpful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理的一个例子是**NGINX**。它还提供负载平衡能力、A/B测试等等。它的另一个能力是服务发现。让我们看看它如何有帮助。
- en: Service Discovery
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务发现
- en: As the name suggests, **Service Discovery** (**SD**) allows for automatically
    detecting instances of specific services in a computer network. Instead of hardcoding
    a domain name or IP where the service should be hosted, the caller must only be
    pointed to a service registry. Using this approach, your architecture gets a lot
    more flexible, as now all the services you use can be easily found. If you design
    a microservice-based architecture, introducing SD really goes a long way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，**服务发现**（**SD**）允许自动检测计算机网络中特定服务的实例。调用者不必硬编码服务应该托管的域名或IP，而只需指向服务注册表。使用这种方法，您的架构变得更加灵活，因为现在您使用的所有服务都可以很容易地找到。如果您设计了基于微服务的架构，引入SD确实可以大有作为。
- en: There are several approaches to SD. In client-side discovery, the caller contacts
    the SD instance directly. Each service instance has a registry client, which registers
    and de-registers the instance, handles heartbeats, and others. While quite straightforward,
    in this approach, each client has to implement the service discovery logic. Netflix
    Eureka is an example of a service registry commonly used in this approach.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种SD的方法。在客户端发现中，调用者直接联系SD实例。每个服务实例都有一个注册表客户端，用于注册和注销实例，处理心跳等。虽然相当直接，但在这种方法中，每个客户端都必须实现服务发现逻辑。Netflix
    Eureka是在这种方法中常用的服务注册表的一个例子。
- en: An alternative is to use server-side discovery. Here, a service registry is
    also present, along with the registry clients in each service instance. The callers,
    however, don't contact it directly. Instead, they connect to a load balancer,
    for example, the AWS Elastic Load Balancer, which, in turn, either calls a service
    registry or uses its built-in service registry before dispatching the client calls
    to specific instances. Aside from AWS ELB, NGINX and Consul can be used to provide
    server-side SD capabilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用服务器端发现。在这种情况下，服务注册表也存在，并且每个服务实例中都有注册表客户端。但是，调用者不直接联系它。相反，他们连接到负载均衡器，例如AWS弹性负载均衡器，然后再调用服务注册表或使用其内置服务注册表，然后将客户端调用分派到特定实例。除了AWS
    ELB，还可以使用NGINX和Consul来提供服务器端SD功能。
- en: We now know how to find and use our services efficiently, so let's learn how
    best to deploy them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何高效地找到和使用我们的服务，那么让我们学习如何最好地部署它们。
- en: Using Kubernetes to orchestrate cloud-native workloads
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes编排云原生工作负载
- en: Kubernetes is an extensible open source platform for automating and managing
    container applications. It is sometimes referred to as k8s since it starts with
    'k,' ends with 's,' and there are eight letters in the middle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个可扩展的开源平台，用于自动化和管理容器应用程序。有时被称为k8s，因为它以'k'开头，以's'结尾，在中间有八个字母。
- en: 'Its design is based on Borg, a system used internally by Google. Some of the
    features present in Kubernetes are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其设计基于Borg，这是Google内部使用的系统。Kubernetes中的一些功能包括：
- en: Autoscaling of applications
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的自动扩展
- en: Configurable networking
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的网络
- en: Batch job execution
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批处理作业执行
- en: Unified upgrading of applications
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的统一升级
- en: The ability to run highly available applications on top of it
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其上运行高可用性应用程序的能力
- en: The declarative configuration
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性配置
- en: There are different ways to run Kubernetes in your organization. Choosing one
    over the other requires you to analyze additional costs and benefits related to
    them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织中运行Kubernetes有不同的方式。选择其中一种需要您分析与其相关的额外成本和收益。
- en: Kubernetes structure
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes结构
- en: While it is possible to run Kubernetes on a single machine (for example, using
    minikube, k3s, or k3d), it is not recommended to do so in production. Single-machine
    clusters have limited functionality and no failover mechanisms. A typical size
    for a Kubernetes cluster is six machines or more. Three of the machines then form
    the control plane. The other three are worker nodes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在单台机器上运行Kubernetes（例如使用minikube、k3s或k3d），但不建议在生产环境中这样做。单机集群功能有限，没有故障转移机制。Kubernetes集群的典型大小是六台或更多。其中三台机器组成控制平面。另外三台是工作节点。
- en: The minimum requirement of three machines comes from the fact that this is the
    minimal number to provide high availability. It is possible to have the control
    plane nodes also available as worker nodes, although this is not encouraged.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 三台机器的最低要求来自于这是提供高可用性的最小数量。控制平面节点也可以作为工作节点可用，尽管这并不被鼓励。
- en: Control plane
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制平面
- en: In Kubernetes, you rarely interact with individual worker nodes. Instead, all
    the API requests go to the control plane. The control plane then decides on the
    actions to take based on the requests, and then it communicates with the worker
    nodes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，您很少与单个工作节点进行交互。相反，所有API请求都发送到控制平面。然后，控制平面根据请求决定要采取的操作，然后与工作节点通信。
- en: 'The interaction with the control plane can take several forms:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制平面的交互可以采取多种形式：
- en: Using the kubectl CLI
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用kubectl CLI
- en: Using a web dashboard
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web仪表板
- en: Using the Kubernetes API from inside an application other than kubectl
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序内部使用Kubernetes API而不是kubectl
- en: Control plane nodes usually run the API server, scheduler, a configuration store
    (etcd), and possibly some additional processes to handle the specific needs. For
    example, Kubernetes clusters deployed in a public cloud such as Google Cloud Platform
    have cloud controllers running on control plane nodes. The cloud controller interacts
    with the cloud provider's API to replace the failed machines, provision load balancers,
    or assign external IP addresses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面节点通常运行API服务器、调度器、配置存储（etcd）以及可能处理特定需求的其他一些附加进程。例如，在Google Cloud Platform等公共云中部署的Kubernetes集群上，控制平面节点上运行云控制器。云控制器与云提供商的API交互，以替换失败的机器、提供负载均衡器或分配外部IP地址。
- en: Worker nodes
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作节点
- en: The nodes that form the control plane and the worker pool are the actual machines
    the workload will run on. They may be physical servers that you host on-premises,
    VMs hosted privately, or VMs from your cloud provider.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构成控制平面和工作节点池的节点是实际运行工作负载的机器。它们可以是你在本地托管的物理服务器，私有托管的VM，或者来自你的云提供商的VM。
- en: 'Every node in a cluster runs at least the three programs as listed follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 集群中的每个节点至少运行以下三个程序：
- en: A container runtime (for example, Docker Engine or cri-o) that allows the machine
    to handle the application containers
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时（例如Docker Engine或cri-o），允许机器处理应用程序容器
- en: A kubelet, which is responsible for receiving requests from the control plane
    and manages the individual containers based on those requests
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubelet，负责接收来自控制平面的请求，并根据这些请求管理单个容器
- en: A kube-proxy, which is responsible for networking and load balancing on the
    node level
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kube-proxy，负责节点级别的网络和负载平衡
- en: Possible approaches to deploying Kubernetes
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Kubernetes的可能方法
- en: As you may have realized from reading the previous section, there are different
    possible ways to deploy Kubernetes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从阅读前一节中所了解的，部署Kubernetes有不同的可能方式。
- en: One of them is to deploy it to bare-metal servers hosted on-premises. One of
    the benefits is that this may be cheaper for large-scale applications than what
    the cloud providers offer. This approach has one major drawback—you will require
    an operator to provide the additional nodes whenever necessary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是将其部署到本地托管的裸金属服务器上。其中一个好处是对于大规模应用程序来说，这可能比云提供商提供的更便宜。这种方法有一个主要缺点——当需要时，你将需要操作员提供额外的节点。
- en: To mitigate this issue, you can run a virtualization appliance on top of your
    bare-metal servers. This makes it possible to use the Kubernetes built-in cloud
    controller to provision the necessary resources automatically. You still have
    the same control over the costs, but there's less manual work. Virtualization
    adds some overhead, but in most cases, this should be a fair trade-off.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，你可以在裸金属服务器上运行一个虚拟化设备。这样就可以使用Kubernetes内置的云控制器自动提供必要的资源。你仍然可以控制成本，但手动工作会减少。虚拟化会增加一些开销，但在大多数情况下，这应该是一个公平的权衡。
- en: If you are not interested in hosting the servers yourself, you can deploy Kubernetes
    to run on top of VMs from a cloud provider. By choosing this route, you can use
    some of the existing templates for optimal setup. There are Terraform and Ansible
    modules available to build a cluster on popular cloud platforms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己托管服务器，你可以部署Kubernetes在云提供商的VM上运行。通过选择这种方式，你可以使用一些现有的模板进行最佳设置。在流行的云平台上有Terraform和Ansible模块可用于构建集群。
- en: Finally, there are the managed services available from the major cloud players.
    You only have to pay for the worker nodes in some of them, while the control plane
    is free of charge.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主要云服务提供商提供的托管服务。在其中一些服务中，你只需要为工作节点付费，而控制平面是免费的。
- en: Why would you choose self-hosted Kubernetes over the managed services when operating
    in a public cloud? One of the reasons may be a specific version of Kubernetes
    that you require. Cloud providers are typically a bit slow when it comes to introducing
    updates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云中运行时，为什么会选择自托管的Kubernetes而不是托管服务？其中一个原因可能是你需要的特定版本的Kubernetes。当涉及到引入更新时，云提供商通常会有些慢。
- en: Understanding the Kubernetes concepts
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Kubernetes的概念
- en: 'Kubernetes introduces some concepts that may sound unfamiliar or be confusing
    if you hear them for the first time. When you learn their purpose, it should be
    easier to grasp what makes Kubernetes special. Here are some of the most common
    Kubernetes objects:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes引入了一些概念，如果你第一次听到它们可能会感到陌生或困惑。当你了解它们的目的时，就会更容易理解Kubernetes的特殊之处。以下是一些最常见的Kubernetes对象：
- en: A *container*, specifically, an application container, is a method of distributing
    and running a single application. It contains the code and configuration necessary
    to run the unmodified application anywhere.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器*，特别是应用容器，是一种分发和运行单个应用程序的方法。它包含了在任何地方运行未经修改的应用程序所需的代码和配置。'
- en: A *Pod* is a basic Kubernetes building block. It is atomic and consists of one
    or more containers. All the containers inside the pod share the same network interfaces,
    volumes (such as persistent storage or secrets), and resources (CPU and memory).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*是基本的Kubernetes构建块。它是原子的，由一个或多个容器组成。Pod中的所有容器共享相同的网络接口、卷（如持久存储或秘密）和资源（CPU和内存）。'
- en: A *deployment* is a higher-level object that describes the workload and its
    life cycle features. It typically manages a set of pod replicas, allows for rolling
    upgrades, and manages the rollbacks in case of failure. This is what makes it
    easy to scale and manage the life cycle of Kubernetes applications.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*是一个描述工作负载及其生命周期特性的高级对象。它通常管理一组pod副本，允许滚动升级，并在失败时管理回滚。这使得扩展和管理Kubernetes应用程序的生命周期变得容易。'
- en: A *DaemonSet* is a controller similar to a deployment in that it manages where
    the pods are distributed. While deployments are concerned with keeping a given
    number of replicas, DaemonSets spreads the pods across all worker nodes. The primary
    use case is to run a system-level service, such as a monitoring or logging agent
    on each node.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DaemonSet*是一个类似于部署的控制器，它管理pod的分布位置。部署关注保持给定数量的副本，而DaemonSets将pod分布在所有工作节点上。主要用例是在每个节点上运行系统级服务，比如监控或日志代理。'
- en: '*Jobs* are designed for one-off tasks. Pods in deployments restart automatically
    when the containers inside them terminate. They are suitable for all the always-on
    services that listen on network ports for requests. However, deployments are unsuited
    for batch jobs, such as thumbnail generation, which you want to run only when
    required. Jobs create one or more pods and watch them until they complete a given
    task. When a specific number of successful pods terminate, the job is considered
    complete.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jobs*设计用于一次性任务。部署中的pod在其中的容器终止时会自动重新启动。它们适用于所有始终开启的服务，以便监听网络端口的请求。但是，部署不适用于批处理作业，例如缩略图生成，您只希望在需要时运行。作业创建一个或多个pod，并监视它们直到完成给定的任务。当特定数量的成功pod终止时，作业被视为完成。'
- en: '*CronJobs*, as the name suggests, are the jobs that are run periodically within
    the cluster.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CronJobs*，顾名思义，是定期在集群中运行的作业。'
- en: '*Services* represent a particular function performed within a cluster. They
    have a network endpoint associated with them (which is usually load balanced).
    Services may be performed by one or more pods. The life cycle of services is independent
    of the life cycles of the many pods. Since pods are transient, they may be created
    and destroyed at any time. Services abstract the individual pods to allow for
    high availability. Services have their own IP addresses and DNS names for ease
    of use.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务*代表集群中执行的特定功能。它们有与之关联的网络端点（通常是负载平衡）。服务可以由一个或多个pod执行。服务的生命周期独立于许多pod的生命周期。由于pod是瞬时的，它们可以随时创建和销毁。服务将个体pod抽象出来，以实现高可用性。服务具有自己的IP地址和DNS名称，以便使用。'
- en: Declarative approach
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性方法
- en: We've covered the differences between declarative and imperative approaches
    earlier in [Chapter 9](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit),
    *Continuous Integration/Continuous Deployment*[.](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit)
    Kubernetes takes the declarative approach. Instead of giving instructions regarding
    the steps that need to be taken, you provide the resources that describe your
    cluster's desired state. It is up to the control plane to allocate internal resources
    so that they fulfill your needs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第9章](https://cdp.packtpub.com/hands_on_software_architecture_with_c__/wp-admin/post.php?post=33&action=edit)中已经介绍了声明性和命令式方法之间的区别，*持续集成/持续部署*。Kubernetes采用声明性方法。您不是提供关于需要采取的步骤的指示，而是提供描述集群所需状态的资源。由控制平面来分配内部资源，以满足您的需求。
- en: It is possible to add the resources using the command line directly. This can
    be quick for testing, but you want to have a trail of the resources you created
    most of the time. Thus, most people work with manifest files, which provide a
    coded description of the resources required. Manifests are typically YAML files,
    but it is also possible to use JSON.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接使用命令行添加资源。这对于测试可能很快，但大多数时候您希望有您创建的资源的记录。因此，大多数人使用清单文件，这些文件提供所需资源的编码描述。清单通常是YAML文件，但也可以使用JSON。
- en: 'Here''s an example YAML manifest with a single Pod:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有单个Pod的示例YAML清单：
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line is mandatory, and it tells which API version will be used in
    the manifest. Some resources are only available in extensions, so this is the
    information for the parser on how to behave.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是必需的，它告诉清单中将使用哪个API版本。某些资源仅在扩展中可用，因此这是解析器如何行为的信息。
- en: The second line describes what resource we are creating. Next, there is metadata
    and the specification of the resource.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行描述了我们正在创建的资源。接下来是元数据和资源的规范。
- en: A name is mandatory in metadata as this is the way to distinguish one resource
    from another. If we wanted to create another pod with the same name, we would
    get an error stating that such a resource already exists. The label is optional
    and useful when writing selectors. For example, if we wanted to create a service
    that allows connection to the pod, we would use a selector matching label app
    with a value equal to `dominican-front`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据中的名称是必需的，因为这是区分一个资源和另一个资源的方式。如果我们想要创建另一个具有相同名称的pod，我们将收到一个错误，指出已经存在这样的资源。标签是可选的，在编写选择器时非常有用。例如，如果我们想要创建一个允许连接到pod的服务，我们将使用一个匹配标签应用程序的选择器，其值等于`dominican-front`。
- en: The specification is also the mandatory part as it describes the actual content
    of the resource. In our example, we list all the containers that are running inside
    the pod. To be precise, one container named `webserver` using an image, `nginx`,
    from Docker Hub. Since we want to connect to the Nginx web server from the outside,
    we also expose the container port `80` on which the server is listening. The name
    in the port description is optional.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 规范也是必需的部分，因为它描述了资源的实际内容。在我们的示例中，我们列出了在pod内运行的所有容器。准确地说，一个名为`webserver`的容器，使用来自Docker
    Hub的图像`nginx`。由于我们希望从外部连接到Nginx web服务器，我们还公开了服务器正在侦听的容器端口`80`。端口描述中的名称是可选的。
- en: Kubernetes networking
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes网络
- en: Kubernetes allows for pluggable network architectures. Several drivers exist
    that may be used depending on requirements. Whichever driver you select, some
    concepts are universal. The following are the typical networking scenarios.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许可插拔的网络架构。根据要求，可以使用几种驱动程序。无论选择哪个驱动程序，一些概念是通用的。以下是典型的网络场景。
- en: Container-to-container communication
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器与容器之间的通信
- en: A single pod may host several different containers. Since the network interface
    is tied to the pod and not to the containers, each container operates in the same
    networking namespace. This means various containers may address one another using
    localhost networking.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 单个pod可以托管多个不同的容器。由于网络接口绑定到pod而不是容器，每个容器在相同的网络命名空间中运行。这意味着各种容器可以使用本地主机网络相互通信。
- en: Pod-to-pod communication
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod与Pod之间的通信
- en: Each pod has an internal cluster-local IP address assigned. The address does
    not persist once the pod has been deleted. One pod can connect to another's exposed
    ports when it knows the other's address as they share the same flat network. You
    can think of pods as VMs hosting containers with regard to this communication
    model. This is rarely used as the preferred method is pod-to-service communication.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个pod都有一个分配的内部集群本地IP地址。一旦pod被删除，该地址就不会持久存在。当一个pod知道另一个pod的地址时，它可以连接到另一个pod的暴露端口，因为它们共享相同的扁平网络。就这种通信模型而言，您可以将pod视为托管容器的VM。这很少被使用，因为首选方法是pod到服务的通信。
- en: Pod-to-service communication
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pod到服务的通信
- en: Pod-to-service communication is the most popular use case for communication
    within the cluster. Each service has an individual IP address and a DNS name assigned
    to it. When a pod connects to a service, the connection is proxied to one of the
    pods in the group selected by the service. Proxying is a task of the kube-proxy
    tool described earlier.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: pod到服务的通信是集群内通信的最常见用例。每个服务都有一个分配的IP地址和DNS名称。当一个pod连接到一个服务时，连接被代理到服务选择的组中的一个pod。代理是早期描述的kube-proxy工具的任务。
- en: External-to-internal communication
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部到内部的通信
- en: External traffic typically comes to the cluster via the means of load balancers.
    These are either tied to or handled by specific services or ingress controllers.
    When the externally exposed services handle the traffic, it behaves like pod-to-service
    communication. With the ingress controller, you have additional features available
    that allow for routing, observability, or advanced load balancing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 外部流量通常通过负载均衡器进入集群。这些负载均衡器要么与特定服务绑定，要么由特定服务处理。当外部暴露的服务处理流量时，它的行为类似于pod到服务的通信。通过Ingress控制器，您可以使用其他功能，如路由、可观察性或高级负载平衡。
- en: When is using Kubernetes a good idea?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kubernetes是一个好主意吗？
- en: Introducing Kubernetes within an organization requires some investment. There
    are many benefits provided by Kubernetes, such as autoscalability, automation,
    or deployment scenarios. However, these benefits may not justify the necessary
    investment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织内引入Kubernetes需要一些投资。Kubernetes提供了许多好处，如自动扩展、自动化或部署方案。然而，这些好处可能无法证明必要的投资。
- en: 'This investment concerns several areas:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这项投资涉及几个领域：
- en: '**Infrastructure costs**: The costs associated with running the control plane
    and the worker nodes may be relatively high. Additionally, the costs may rise
    if you want to use various Kubernetes expansions, such as GitOps or a service
    mesh (described later). They also require additional resources to run and provide
    more overhead on top of your application''s regular services. Apart from the nodes
    themselves, you should also factor in other costs. Some of the Kubernetes features
    work best when deployed to a supported cloud provider. This means that in order
    to benefit from those features, you''d have to go down one of the following routes:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施成本**：运行控制平面和工作节点所需的成本可能相对较高。此外，如果您想使用各种Kubernetes扩展，如GitOps或服务网格（稍后描述），成本可能会上升。它们还需要额外的资源来运行，并在您的应用程序常规服务的基础上提供更多的开销。除了节点本身，您还应考虑其他成本。一些Kubernetes功能在部署到支持的云提供商时效果最佳。这意味着为了从这些功能中受益，您必须选���以下路线之一：'
- en: a. Move your workload to the specifically supported cloud.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将您的工作负载移至特定支持的云。
- en: b. Implement your own drivers for a cloud provider of your choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: b. 为您选择的云提供商实现自己的驱动程序。
- en: c. Migrate your on-premises infrastructure to a virtualized API-enabled environment
    such as VMware vSphere or OpenStack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将您的本地基础架构迁移到虚拟化的API启用环境，如VMware vSphere或OpenStack。
- en: '**Operations costs**: The Kubernetes cluster and associated services require
    maintenance. Even though you get less maintenance for your applications, this
    benefit is slightly offset by the cost of keeping the cluster running.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运营成本**：Kubernetes集群和相关服务需要维护。尽管您的应用程序需要较少的维护，但这一好处略微被保持集群运行的成本所抵消。'
- en: '**Education costs**: Your entire product team has to learn new concepts. Even
    if you have a dedicated platform team that will provide developers with easy-to-use
    tools, developers would still require a basic understanding of how the work they
    do influences the entire system and which API they should use.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育成本**：您的整个产品团队都必须学习新概念。即使您有一个专门的平台团队为开发人员提供易于使用的工具，开发人员仍需要基本了解他们的工作如何影响整个系统以及他们应该使用哪个API。'
- en: Before you decide on introducing Kubernetes, consider first whether you can
    afford the initial investment it requires.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定引入Kubernetes之前，首先考虑一下您是否能负担起它所需的初始投资。
- en: Observability in distributed systems
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统中的可观察性
- en: Distributed systems such as cloud-native architecture pose some unique challenges.
    The sheer number of different services working at any given time makes it very
    inconvenient to investigate how well the components perform.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如云原生架构之类的分布式系统提出了一些独特的挑战。在任何给定时间，不同服务的数量使得调查组件的性能变得非常不方便。
- en: In monolithic systems, logging and performance monitoring are usually enough.
    With a distributed system, even logging requires a design choice. Different components
    produce different log formats. Those logs have to be stored somewhere. Keeping
    them together with a service that delivers them will make it challenging to get
    the big picture in an outage case. Besides, since microservices may be short-lived,
    you will want to decouple the life cycle of logs from the life cycle of a service
    that provides them or a machine that hosts the service.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在单片系统中，通常日志记录和性能监控就足够了。在分布式系统中，即使日志记录也需要设计选择。不同的组件产生不同的日志格式。这些日志必须存储在某个地方。将它们与提供它们的服务放在一起，将使在停机情况下获得整体情况变得具有挑战性。此外，由于微服务可能存在时间很短，您将希望将日志的生命周期与提供它们的服务或托管服务的机器的生命周期解耦。
- en: In [C](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml)[hapter 13](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml),
    *Designing Microservices*, we described how a unified logging layer helps manage
    the logs. But logs only show what happens at a given point in the system. To see
    the picture from a single transaction point of view, you require a different approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ccc9ef2c-747a-4b56-9009-21382c7838d5.xhtml)中，*设计微服务*，我们描述了统一的日志记录层如何帮助管理日志。但日志只显示系统中特定点发生的情况。要从单个事务的角度看到整个图片，您需要采用不同的方法。
- en: This is where tracing comes in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是追踪的作用。
- en: How tracing differs from logging
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪与日志记录的不同之处
- en: Tracing is a specialized form of logging. It provides lower-level information
    than logs. This may include all the function calls, their parameters, their size,
    and execution time. They also contain the unique ID of the transaction being processed.
    These details make it possible to reassemble them and see the life cycle of a
    given transaction as it passes through your system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪是日志记录的一种专门形式。它提供的信息比日志更低级。这可能包括所有函数调用、它��的参数、大小和执行时间。它们还包含正在处理的事务的唯一ID。这些细节使得重新组装它们并查看给定事务在系统中的生命周期成为可能。
- en: Performance information present in tracing helps you with uncovering bottlenecks
    and sub-optimal components in the system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪中的性能信息可帮助您发现系统中的瓶颈和次优组件。
- en: While logs are often read by operators and developers, they tend to be human-readable.
    There are no such requirements for tracing. To view the traces, you will use a
    dedicated visualization program. This means that even though traces are more detailed,
    they may also take up less space than logs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日志通常由操作员和开发人员阅读，但它们往往是人类可读的。对于追踪没有这样的要求。要查看跟踪，您将使用专用的可视化程序。这意味着即使跟踪更详细，它们可能也比日志占用更少的空间。
- en: 'The following diagram is an overview of a single trace:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是单个跟踪的概述：
- en: '![](img/99975346-44c1-441b-a623-58d5513d59d7.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99975346-44c1-441b-a623-58d5513d59d7.png)'
- en: Figure 15.1 – Single trace
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 单个跟踪
- en: Two services communicate over a network. In *Service A*, we have one parent
    span that contains a child span and a single log. Child spans usually correspond
    to deeper function calls. A log represents the smallest piece of information.
    Each of them is timed and may contain additional information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 两个服务通过网络通信。在*Service A*中，我们有一个包含子跨度和单个日志的父跨度。子跨度通常对应于更深层的函数调用。日志代表最小的信息片段。它们中的每一个都被计时，并可能包含其他信息。
- en: The network call to *Service B* preserves the span context. Even though *Service
    B* is executed in a different process on another machine, all of the information
    can be later reassembled as the transaction ID is preserved.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对*Service B*的网络调用保留了跨度上下文。即使*Service B*在另一台机器上的不同进程中执行，所有信息也可以稍后重新组装，因为事务ID得以保留。
- en: A piece of bonus information that we get from reassembling traces is the dependency
    graph between the services in our distributed system. As traces contain the entire
    call chain, it is possible to visualize this information and inspect unexpected
    dependencies.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从重新组装跟踪中获得的额外信息是我们分布式系统中服务之间的���赖关系图。由于跟踪包含整个调用链，因此可以可视化此信息并检查意外的依赖关系。
- en: Choosing a tracing solution
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择追踪解决方案
- en: There are several possible solutions to choose from when implementing tracing.
    As you may imagine, there are both self-hosted and managed tools that you can
    use to instrument your applications. We will briefly describe the managed ones
    and focus on the self-hosted ones.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施追踪时，有几种可能的解决方案可供选择。正如您可能想象的那样，您可以使用自托管工具和托管工具来为您的应用程序进行仪器化。我们将简要描述托管工具，并重点关注自托管工具。
- en: Jaeger and OpenTracing
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jaeger和OpenTracing
- en: 'One of the standards in distributed tracing is OpenTracing proposed by the
    authors of Jaeger. Jaeger is a tracer built for cloud-native applications. It
    addresses the problems of monitoring distributed transactions and propagating
    the tracing context. It''s useful for the following purposes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式跟踪的标准之一是Jaeger的作者提出的OpenTracing。Jaeger是为云原生应用程序构建的跟踪器。它解决了监视分布式事务和传播跟踪上下文的问题。它对以下目的很有用：
- en: Performance or latency optimization
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能或延迟优化
- en: Performing a root cause analysis
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行根本原因分析
- en: Analyzing the inter-service dependencies
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析服务之间的依赖关系
- en: OpenTracing is an open standard presenting an API that is independent of the
    tracer used. This means that when your application is instrumented using OpenTracing,
    you avoid lock-in to one particular vendor. If, at some point, you decide to switch
    from Jaeger to Zipkin, DataDog, or any other compatible tracer, you won't have
    to modify the entire instrumentation code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTracing是一个开放标准，提供了一个独立于使用的跟踪器的API。这意味着当您的应用程序使用OpenTracing进行仪器化时，您避免了对特定供应商的锁定。如果在某个时候，您决定从Jaeger切换到Zipkin、DataDog或任何其他兼容的跟踪器，您不必修改整个仪器化代码。
- en: 'There are many client libraries compatible with OpenTracing. You can also find
    many resources, including tutorials and articles that explain how to implement
    the API for your needs. OpenTracing officially supports the following languages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多与OpenTracing兼容的客户端库。您还可以找到许多资源，包括教程和文章，解释如何根据您的需求实现API。OpenTracing官方支持以下语言：
- en: Go
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: JavaScript
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: Java
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: Python
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Ruby
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby
- en: PHP
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PHP
- en: Objective-C
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C
- en: C++
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: C#
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#
- en: There are also unofficial libraries available, and specific applications can
    export OpenTracing data as well. This includes Nginx and Envoy, both popular web
    proxies.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些非官方的库可用，特定应用程序也可以导出OpenTracing数据。这包括Nginx和Envoy，两个流行的Web代理。
- en: Jaeger also accepts samples in Zipkin format. We will cover Zipkin in the next
    section. What it means is that you don't have to rewrite the instrumentation from
    one format to another if you (or any of your dependencies) already use Zipkin.
    For all new applications, OpenTracing is the recommended approach.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger还接受Zipkin格式的样本。我们将在下一节中介绍Zipkin。这意味着如果您（或您的任何依赖项）已经使用Zipkin，您就不必将仪器从一种格式重写为另一种格式。对于所有新应用程序，OpenTracing是推荐的方法。
- en: Jaeger scales well. You can run it as a single binary or a single application
    container if you want to evaluate it. You may configure Jaeger for production
    use to use its own backend or a supported external one, such as Elasticsearch,
    Cassandra, or Kafka.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger的扩展性很好。您可以将其作为单个二进制文件或单个应用程序容器来运行以进行评估。您可以配置Jaeger以在生产中使用其自己的后端或支持的外部后端，如Elasticsearch、Cassandra或Kafka。
- en: Jaeger is a CNCF graduated project. This means it has reached a similar level
    of maturity to Kubernetes, Prometheus, or Fluentd. Because of this, we expect
    it to gain even more support in other CNCF applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger是一个CNCF毕业项目。这意味着它已经达到了与Kubernetes、Prometheus或Fluentd类似的成熟水平。因此，我们期望它在其他CNCF应用程序中获得更多支持。
- en: Zipkin
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Zipkin
- en: The main competitor for Jaeger is Zipkin. It's an older project, which also
    means it is more mature. Usually, more senior projects are also better supported,
    but in this case, the endorsement of CNCF plays in Jaeger's favor.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger的主要竞争对手是Zipkin。这是一个更老的项目，这意味着它更加成熟。通常，更老的项目也会得到更好的支持，但在这种情况下，CNCF的认可对Jaeger更有利。
- en: Zipkin uses its proprietary protocol to handle tracing. It has OpenTracing support
    available, but it may not be at the same maturity and support level as the native
    Jaeger protocol. As we've mentioned earlier, it is also possible to configure
    Jaeger to collect traces in Zipkin format. This means the two are, at least to
    some point, interchangeable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin使用其专有协议来处理跟踪。它支持OpenTracing，但可能不具有与本机Jaeger协议相同的成熟度和支持水平。正如我们之前提到的，还可以配置Jaeger以收集Zipkin格式的跟踪。这意味着这两者至少在某种程度上是可以互换的。
- en: The project is hosted under the Apache foundation, but is not considered a CNCF
    project. When developing cloud-native applications, Jaeger is a better alternative.
    If you are looking instead for an all-purpose tracing solution, it is worth considering
    Zipkin as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目由Apache基金会托管，但不被视为CNCF项目。在开发云原生应用程序时，Jaeger是一个更好的选择。如果您正在寻找一个多用途的跟踪解决方案，那么考虑Zipkin也是值得的。
- en: One drawback is that Zipkin doesn't have a supported C++ implementation. There
    are unofficial libraries, but they don't seem to be well-supported. Using a C++
    OpenTracing library is the preferred way to instrument the C++ code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin没有支持的C++实现是一个缺点。有非官方的库，但似乎支持不够好。使用C++ OpenTracing库是仪表化C++代码的首选方式。
- en: Instrumenting an application with OpenTracing
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OpenTracing为应用程序添加仪表
- en: This section will illustrate how to add instrumentation with Jaeger and OpenTracing
    to an existing application. We'll use the `opentracing-cpp` and `jaeger-client-cpp`
    libraries.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明如何向现有应用程序添加Jaeger和OpenTracing的仪表。我们将使用`opentracing-cpp`和`jaeger-client-cpp`库。
- en: 'First, we want to set up the tracer:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要设置跟踪器：
- en: '[PRE1]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The two preferred methods for configuring a sampling server are either by using
    the environment variable, as we did, or by using a YAML configuration file. When
    using environment variables, we will have to set them up before running the application.
    The most important ones are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 配置采样服务器的两种首选方法要么使用环境变量，就像我们做的那样，要么使用YAML配置文件。当使用环境变量时，我们必须在运行应用程序之前设置它们。最重要的是以下几个：
- en: '`JAEGER_AGENT_HOST`: The hostname where the Jaeger agent is located'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAEGER_AGENT_HOST`：Jaeger代理所在的主机名'
- en: '`JAEGER_AGENT_POR`: The port on which the Jaeger agent is listening'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAEGER_AGENT_POR`：Jaeger代理正在监听的端口'
- en: '`JAEGER_SERVICE_NAME`: The name of our application'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JAEGER_SERVICE_NAME`：我们应用程序的名称'
- en: Next, we configure the tracer and supply the logging implementation. It is possible
    to implement a custom logging solution if the available `ConsoleLogger` is not
    enough. For container-based applications with a unified logging layer, the ConsoleLogger
    should be enough.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置跟踪器并提供日志记录实现。如果可用的`ConsoleLogger`不够，可以实现自定义日志记录解决方案。对于基于容器的应用程序，统一的日志记录层，`ConsoleLogger`应该足够了。
- en: 'When we have the tracer set up, we want to add spans to the functions that
    we want to be instrumented. The following code does just that:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置好跟踪器后，我们希望在要仪表化的函数中添加span。以下代码就是这样做的：
- en: '[PRE2]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This span may be used later to create child spans within a given function.
    It may also be propagated to deeper function calls as a parameter. This is how
    it appears:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个span可以在以后用来在给定函数内创建子span。它也可以作为参数传播到更深的函数调用中。它的使用方式如下：
- en: '[PRE3]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Context propagation happens when we call the `opentracing::ChildOf` function.
    We may also pass the context over network calls using the `inject()` and `extract()`
    calls.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`opentracing::ChildOf`函数时，上下文传播就会发生。我们还可以使用`inject()`和`extract()`调用通过网络调用传递上下文。
- en: Connecting services with a service mesh
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务网格连接服务
- en: Microservices and cloud-native design come with their own set of problems. Communication
    between different services, observability, debugging, rate limiting, authentication,
    access control, and A/B testing may be challenging even with a limited number
    of services. When the number of services rises, so does the complexity of the
    aforementioned requirements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和云原生设计带来了一系列问题。不同服务之间的通信、可观察性、调试、速率限制、身份验证、访问控制和A/B测试可能会具有挑战性，即使服务数量有限。随着服务数量的增加，上述要求的复杂性也会增加。
- en: That's where a service mesh enters the fray. In short, a service mesh trades
    off some resources (necessary to run the control plane and sidecars) for an automated
    and centrally controlled solution to the aforementioned challenges.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务网格介入的地方。简而言之，服务网格通过一些资源（运行控制平面和边车所需的资源）来交换自动化和集中控制的解决方案，以解决上述挑战。
- en: Introducing a service mesh
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入服务网格
- en: All the requirements we mentioned in the introduction to this chapter used to
    be coded within the application itself. As it turns out, many may be abstracted
    as they are shared across many different applications. When your application consists
    of many services, adding new features to all of them starts to be costly. With
    a service mesh, you may control these features from a single point instead.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章介绍中提到的所有要求以前都是在应用程序内部编码的。事实证明，许多要求可以被抽象化，因为它们在许多不同的应用程序中共享。当您的应用程序由许多服务组成时，向所有这些服务添加新功能开始变得昂贵。通过服务网格，您可以从一个单一点控制这些功能。
- en: Since a containerized workflow already abstracts some of the runtime and some
    networking, a service mesh takes the abstraction to another level. This way, the
    application within a container is only aware of what happens at the application
    level of the OSI networking model. The service mesh handles lower levels.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器化工作流已经抽象化了一些运行时和一些网络，服务网格将抽象化提升到了另一个层次。这样，容器中的应用程序只知道OSI网络模型的应用程序级别发生了什么。服务网格处理更低级别的内容。
- en: Setting up a service mesh allows you to control all network traffic in a new
    way and gives you better insights into this traffic. The dependencies become visible,
    as does the flow, shape, and amount of traffic.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置服务网格允许您以一种新的方式控制所有网络流量，并更好地了解这些流量。依赖关系变得可见，流动、形状和流量量也变得可见。
- en: Not only is the flow of traffic handled by the service mesh. Other popular patterns,
    such as circuit breaking, rate limiting, or retries, don't have to be implemented
    by each application and configured separately. This is also a feature that can
    be outsourced to the service mesh. Similarly, A/B testing or canary deployments
    are the use cases that a service mesh is able to fulfill.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格不仅处理流量的流动。其他流行的模式，如断路器、速率限制或重试，不必由每个应用程序单独实现和配置。这也是可以外包给服务网格的功能。同样，A/B测试或金丝雀部署是服务网格能够实现的用例。
- en: One of the benefits of the service mesh, as previously mentioned, is greater
    control. Its architecture typically consists of a manageable edge proxy for external
    traffic and internal proxies usually deployed as sidecars along each microservice.
    This way, the networking policies can be written as code and stored alongside
    all the other configuration in a single place. Rather than having to switch on
    mutual TLS encryption for two of the services you want to connect, you only have
    to enable the feature once in your service mesh configuration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，服务网格的一个好处是更大的控制权。其架构通常包括一个可管理的外部流量边缘代理和通常部署为旁路的内部代理。这样，网络策略可以被编写为代码，并存储在一个地方与所有其他配置一起。与为要连接的两个服务打开双向TLS加密相比，您只需在服务网格配置中启用一次该功能。
- en: Next, we'll cover some of the service mesh solutions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些服务网格解决方案。
- en: Service mesh solutions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务网格解决方案
- en: All of the solutions described here are self-hosted.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的所有解决方案都是自托管的。
- en: Istio
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Istio
- en: Istio is a powerful collection of service mesh tools. It allows you to connect
    microservices through the deployment of Envoy proxies as sidecar containers. Because
    Envoy is programmable, the Istio control plane's configuration changes are communicated
    to all the proxies, which then reconfigure themselves accordingly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Istio是一组强大的服务网格工具。它允许您通过部署Envoy代理作为旁路容器来连接微服务。由于Envoy是可编程的，Istio控制平面的配置更改会被传达给所有代理，然后代理会相应地重新配置自己。
- en: The Envoy proxies are, among other things, responsible for handing encryption
    and authentication. With Istio, enabling mutual TLS between your services requires
    a single switch in the configuration for the majority of the time. If you don't
    want mTLS between all your services, you may also select those that demand this
    additional protection while allowing unencrypted traffic between everything else.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy代理除了其他功能外，还负责处理加密和身份验证。使用Istio，为服务之间启用双向TLS通常只需要在配置中进行一次切换。如果您不希望所有服务之间都使用mTLS，您还可以选择那些需要此额外保护的服务，同时允许其他所有服务之间的未加密流量。
- en: 'Istio also helps with observability. First of all, the Envoy proxies export
    proxy-level metrics compatible with Prometheus. There are also service-level metrics
    and control plane metrics exported by Istio. Next, there are distributed traces
    that describe the traffic flow within the mesh. Istio can serve the traces to
    different backends: Zipkin, Jaeger, Lightstep, and Datadog. Finally, there are
    Envoy access logs, which show every call in a format similar to Nginx.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Istio还有助于可观察性。首先，Envoy代理导出与Prometheus兼容的代理级别指标。 Istio还导出服务级别指标和控制平面指标。接下来，有描述网格内流量流动的分布式跟踪。Istio可以将跟踪提供给不同的后端：Zipkin、Jaeger、Lightstep和Datadog。最后，还有Envoy访问日志，以类似Nginx的格式显示每个调用。
- en: It's possible to visualize your mesh using Kiali, an interactive web interface.
    This way, you can see a graph of your services, including information such as
    whether the encryption is enabled, what the size of the flow between different
    services is, or what's the health check status of each of them is.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kiali可以可视化您的网格，这是一个交互式的Web界面。这样，您可以看到服务的图表，包括加密是否已启用，不同服务之间流量的大小，以及每个服务的健康检查状态。
- en: The authors of Istio claim that this service mesh should be compatible with
    different technologies. At the time of writing, the best documented, best integrated,
    and best tested is the integration with Kubernetes. Other supported environments
    are on-premises, general-purpose clouds, Mesos, and Nomad with Consul.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Istio的作者声称，这种服务网格应该与不同的技术兼容。在撰写本文时，最好的文档化、最好的集成和最好的测试是与Kubernetes的集成。其他支持的环境包括本地环境、通用云、Mesos和带有Consul的Nomad。
- en: If you work in an industry concerned with compliance (such as financial institutions),
    then Istio can help in these aspects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在关注合规性的行业工作（如金融机构），那么Istio可以在这些方面提供帮助。
- en: Envoy
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Envoy
- en: While Envoy is not a service mesh in itself, it is worth mentioning in this
    section due to its use in Istio.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Envoy本身不是服务网格，但由于其在Istio中的使用，它值得在本节中提及。
- en: Envoy is a service proxy that acts much like Nginx or HAProxy. The main difference
    is that it can be reconfigured on the fly. This happens programmatically via an
    API and does not require the configuration file to be changed and the daemon to
    then be reloaded.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy是一个类似于Nginx或HAProxy的服务代理。主要区别在于它可以动态重新配置。这是通过API以编程方式实现的，不需要更改配置文件然后重新加载守护程序。
- en: Interesting facts regarding Envoy are its performance and popularity. According
    to tests performed by SolarWinds, Envoy beats the competition when it comes to
    performance as a service proxy. This competition includes HAProxy, Nginx, Traefik,
    and AWS Application Load Balancer. Envoy is much younger than the established
    leaders in this space, such as Nginx, HAProxy, Apache, and Microsoft IIS, but
    this didn't stop Envoy from entering the top 10 list of most-used web servers,
    according to Netcraft.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Envoy的有趣事实是其性能和流行度。根据SolarWinds进行的测试，Envoy在作为服务代理时击败了竞争对手。这些竞争对手包括HAProxy、Nginx、Traefik和AWS应用负载均衡器。Envoy比Nginx、HAProxy、Apache和Microsoft
    IIS等这个领域的老牌领导者要年轻得多，但这并没有阻止Envoy进入Netcraft最常用的前10名网页服务器列表。
- en: Linkerd
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linkerd
- en: Before Istio became synonymous with a service mesh, this field was represented
    by Linkerd. There is some confusion regarding the naming, as the original Linkerd
    project was designed to be platform-agnostic and targeted the Java VM. This meant
    that it was resource-heavy and often sluggish. The newer version, called Linkerd2,
    has been rewritten to address these issues. Linkerd2, as opposed to the original
    Linkerd, is only focused on Kubernetes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Istio成为服务网格的代名词之前，这个领域由Linkerd代表。关于命名存在一些混淆，因为最初的Linkerd项目旨在是平台无关的，并且针对Java虚拟机。这意味着它资源密集且经常运行缓慢。更新的版本Linkerd2已经重写以解决这些问题。与最初的Linkerd相反，Linkerd2只专注于Kubernetes。
- en: Both Linkerd and Linkerd2 use their own proxy solution instead of relying on
    an existing project such as Envoy. The rationale for that is that a dedicated
    proxy (versus a general-purpose Envoy) offers better security and performance.
    An interesting feature of Linkerd2 is that the company that developed it also
    offers paid support.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd和Linkerd2都使用自己的代理解决方案，而不是依赖于Envoy等现有项目。这样做的理由是，专用代理（而不是通用的Envoy）提供了更好的安全性和性能。Linkerd2的一个有趣特性是，开发它的公司也提供付费支持。
- en: Consul service mesh
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Consul服务网格
- en: A recent addition to the service mesh space is the Consul service mesh. This
    is a product from HashiCorp, a well-established cloud company known for such tools
    as Terraform, Vault, Packer, Nomad, and Consul.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格领域的最新增加是Consul服务网格。这是HashiCorp的产品，这家知名的云公司以Terraform、Vault、Packer、Nomad和Consul等工具而闻名。
- en: Just like the other solutions, it features mTLS and traffic management. It's
    advertised as a multi-cloud, multi-data center, and multi-region mesh. It integrates
    with different platforms, data plane products, and observability providers. At
    the time of writing, the reality is a bit more modest as the main supported platforms
    are Nomad and Kubernetes, while the supported proxies are either the built-in
    proxy or Envoy.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他解决方案一样，它具有mTLS和流量管理。它被宣传为一个多云、多数据中心和多地区的网格。它与不同的平台、数据平面产品和可观察性提供者集成。在撰写本文时，现实情况要逊色一些，因为主要支持的平台是Nomad和Kubernetes，而支持的代理要么是内置代理，要么是Envoy。
- en: If you are considering using Nomad for your application, then the Consul service
    mesh may be a great choice and a good fit as both are HashiCorp products.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑使用Nomad来部署应用程序，那么Consul服务网格可能是一个很好的选择，因为两者都是HashiCorp产品。
- en: Going GitOps
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps进行中
- en: The last topic that we would like to cover in this chapter is GitOps. Even though
    the term sounds new and trendy, the idea behind it is not entirely novel. It's
    an extension of the well-known **Continuous Integration**/**Continuous Deployment**
    (**CI**/**CD**) pattern. Or maybe an extension is not a good description.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们想要讨论的最后一个话题是GitOps。尽管这个术语听起来很新潮，但其背后的理念并不是全新的。它是**持续集成**/**持续部署**（**CI**/**CD**）模式的延伸。或许延伸并不是一个很好的描述。
- en: While CI/CD systems usually aim to be very flexible, GitOps seeks to minimize
    the number of possible integrations. The two main constants are Git and Kubernetes.
    Git is used for version control, release management, and environment separation.
    Kubernetes is used as a standardized and programmable deployment platform.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CI/CD系统通常旨在非常灵活，但GitOps旨在最小化可能的集成数量。两个主要的常量是Git和Kubernetes。Git用于版本控制、发布管理和环境分离。Kubernetes用作标准化和可编程的部署平台。
- en: 'This way, the CI/CD pipeline becomes almost transparent. It''s the opposite
    approach to that of imperative code handling all the stages of the build. To allow
    such a level of abstraction, you will typically need the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，CI/CD流水线几乎变得透明。这与处理构建的所有阶段的命令式代码的方法相反。为了允许这种抽象级别，通常需要以下内容：
- en: Infrastructure as Code to allow the automated deployment of all the necessary
    environments
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施即代码，以允许所有必要环境的自动化部署
- en: A Git workflow with feature branches and pull requests or merge requests
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有功能分支和拉取请求或合并请求的Git工作流
- en: A declarative workflow configuration, which is already available in Kubernetes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性工作流配置，这在Kubernetes中已经��用
- en: The principles of GitOps
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps的原则
- en: Since GitOps is an extension of the established CI/CD pattern, it may not be
    very clear to distinguish between the two. Here are some of the GitOps principles
    that differentiate this approach from general-purpose CI/CD.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitOps是已建立的CI/CD模式的延伸，可能很难清楚地区分两者。以下是一些GitOps原则，它们将这种方法与通用的CI/CD区分开来。
- en: Declarative description
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性描述
- en: 'The main difference between a classical CI/CD system and GitOps lies in the
    mode of operation. Most CI/CD systems are imperative: they consist of a sequence
    of steps to be taken in order for a pipeline to succeed.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 经典CI/CD系统和GitOps之间的主要区别在于操作模式。大多数CI/CD系统是命令式的：它们由一系列必须按顺序执行的步骤组成，以使管道成功。
- en: Even the pipeline's notion is imperative as it implies an object that has an
    entry, a set of connections, and a sink. Some of the steps may be performed in
    parallel, but a process has to stop and wait for the depending step to finish
    whenever there is a dependency.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 即使管道的概念是必要的，因为它意味着一个具有入口、一组连接和一个接收器的对象。一些步骤可以并行执行，但是每当存在依赖关系时，进程必须停止并等待依赖步骤完成。
- en: In GitOps, the configuration is declarative. This refers to the entire state
    of your system – the applications, their configuration, monitoring, and dashboards.
    It is all treated as code, giving it the same features as regular application
    code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitOps中，配置是声明性的。这指的是系统的整个状态 - 应用程序、它们的配置、监控和仪表板。所有这些都被视为代码，具有与常规应用程序代码相同的特性。
- en: The system's state versioned in Git
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统的状态在Git中进行版本控制
- en: Since the state of your system is written in code, you derive some benefits
    from that fact. Features such as easier auditing, code reviews, and version control
    are now applicable not just to the application code. The consequence is that in
    case anything goes wrong, reverting back to a working state requires a single
    `git revert` command.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统的状态是以代码编写的，您从中获得了一些好处。诸如更容易的审计、代码审查和版本控制等功能现在不仅适用于应用程序代码。其结果是，如果出现任何问题，恢复���工作状态只需要一个`git
    revert`命令。
- en: You can use the power of Git's signed commits and SSH and GPG keys to give control
    over different environments. By adding a gating mechanism that makes sure only
    the commits meeting required standards can be pushed to the repository, you also
    eliminate many accidental errors that may result from running commands manually
    using `ssh` or `kubectl`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用Git的签名提交、SSH和GPG密钥来控制不同环境。通过添加一个门控机制，确保只有符合要求标准的提交才能推送到存储库，您还可以消除许多可能由手动运行`ssh`或`kubectl`命令而导致的意外错误。
- en: Auditable
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可审计
- en: Everything that you store in your version control systems becomes auditable.
    Before introducing a new code, you perform a code review. When you notice a bug,
    you can revert the change that introduced it or get back to the last working version.
    Your repository becomes the single point of truth regarding your entire system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您存储在版本控制系统中的所有内容都可以进行审计。在引入新代码之前，您进行代码审查。当您注意到错误时，您可以撤消引入错误的更改，或者返回到上一个工作版本。您的存储库成为关于整个系统的唯一真相。
- en: It's already useful when applied to the application code. However, extending
    the ability to audit configuration, helper services, metrics, dashboards, and
    even deployment strategies makes it even more powerful. You no longer have to
    ask yourself, "*OK, so why did this configuration end up in production?*" All
    you have to do is check the Git log.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将其应用于应用程序代码时已经很有用。然而，将审计配置、辅助服务、指标、仪表板甚至部署策略的能力扩展，使其变得更加强大。您不再需要问自己，“好吧，为什么这个配置最终进入了生产环境？”您只需要检查Git日志。
- en: Integrated with established components
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与已建立的组件集成
- en: Most CI/CD tools introduce proprietary configuration syntax. Jenkins uses Jenkins
    DSL. Each of the popular SaaS solutions uses YAML, but the YAML files are incompatible
    with each other. You can't switch from Travis to CircleCI or from CircleCI to
    GitLab CI without rewriting your pipelines.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数CI/CD工具引入了专有的配置语法。Jenkins使用Jenkins DSL。每个流行的SaaS解决方案都使用YAML，但这些YAML文件彼此不兼容。您无法在Travis和CircleCI之间切换，也无法在CircleCI和GitLab
    CI之间切换，而无需重写您的管道。
- en: This has two drawbacks. One is the obvious vendor lock-in. The other is the
    need to learn the configuration syntax to use the given tool. Even if most of
    your pipeline is already defined elsewhere (shell scripts, Dockerfiles, or Kubernetes
    manifests), you still need to write some glue code to instruct the CI/CD tool
    to use it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个缺点。一个是明显的供应商锁定。另一个是需要学习配置语法以使用给定的工具。即使您的大部分管道已在其他地方定义（shell脚本、Dockerfile或Kubernetes清单），您仍然需要编写一些粘合代码来指示CI/CD工具使用它。
- en: It's different with GitOps. Here, you don't write explicit instructions or use
    proprietary syntax. Instead, you reuse other common standards, such as Helm or
    Kustomize. There's less to learn, and the migration process is much more comfortable.
    Also, GitOps tools usually integrate well with other components from the CNCF
    ecosystem, so you can get your deployment metrics stored in Prometheus and auditable
    with Grafana.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps与之不同。在这里，您不编写显式指令或使用专有语法。相反，您可以重用其他常见标准，例如Helm或Kustomize。需要学习的内容更少，迁移过程更加轻松。此外，GitOps工具通常与CNCF生态系统中的其他组件很好地集成，因此您可以将部署指标存储在Prometheus中，并使用Grafana进行审计。
- en: Configuration drift prevention
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置漂移预防
- en: Configuration drift happens when a given system's current state differs from
    the desired state as described in the repository. Multiple causes are contributing
    to the configuration drift.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 配置漂移发生在给定系统的当前状态与存储库中描述的期望状态不同时。多种原因导致了配置漂移。
- en: For example, let's consider a configuration management tool with a VM-based
    workload. All of the VMs start in the same state. As the CM runs for the first
    time, it brings the machines to the desired state. But if an auto-update agent
    is running on those machines by default, this agent may update some of the packages
    on its own, without considering the desired state from the CM. Moreover, as network
    connectivity may be fragile, some of the machines may update to a newer version
    of a package, while others won't.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个具有基于VM的工作负载的配置管理工具。所有VM都以相同的状态启动。当CM第一次运行时，它将机器带到期望的状态。但是，如果默认情况下在这些机器上运行自动更新代理，该代理可能会自行更新一些软件包，而不考虑CM中的期望状态。此外，由于网络连接可能不稳定，一些机器可能会更新到软件包的新版本，而其他机器则不会。
- en: One of the updated packages may be incompatible with the pinned package that
    your application requires in extreme cases. Such a situation will break the entire
    CM workflow and leave your machine in an unusable state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在极端情况下，更新的软件包可能与您的应用程序所需的固定软件包不兼容。这种情况将破坏整个CM工作流程，并使您的机器处于不可用状态。
- en: With GitOps, an agent is always running inside your system that keeps track
    of the current state and the desired state of the system. If the current state
    suddenly differs from the desired one, an agent may fix it or issue an alert regarding
    configuration drift.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps，系统内始终运行着一个代理，用于跟踪系统的当前状态和期望状态。如果当前状态突然与期望状态不同，代理可以修复它或发出有关配置漂移的警报。
- en: Preventing configuration drift adds another layer of self-healing to your system.
    If you're running Kubernetes, you already have self-healing on the pod level.
    Whenever a pod fails, another one is recreated in its place. If you are using
    a programmable infrastructure underneath (such as a cloud provider or OpenStack
    on-premises), you also have self-healing capabilities of your nodes. With GitOps,
    you get the self-healing for workloads and its configuration.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 防止配置漂移为您的系统增加了另一层自愈。如果您正在运行Kubernetes，您已经在Pod级别上具有自愈能力。每当一个Pod失败时，另一个将在其位置重新创建。如果您在其下使用可编程基础设施（例如云提供商或本地OpenStack），您还具有节点的自愈能力。通过GitOps，您可以获得工作负载及其配置的自愈。
- en: The benefits of GitOps
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps的好处
- en: As you can imagine, the described features of GitOps afford several benefits.
    Here are some of them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以想象的那样，GitOps的描述功能提供了几个好处。以下是其中一些。
- en: Increased productivity
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高生产力
- en: CI/CD pipelines already automate a lot of usual tasks. They reduce lead time
    by helping get more deployments. GitOps adds a feedback loop that prevents configuration
    drift and allows self-healing. This means that your team can ship quicker and
    worry less about introducing potential problems as they are easy to revert. This,
    in turn, means that the development throughput increases and you can introduce
    new features faster and with more confidence.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线已经自动化了许多常规任务。它们通过帮助进行更多部署来减少交付时间。GitOps增加了一个反馈循环，可以防止配置漂移并允许自愈。这意味着您的团队可以更快地交付，并且不必担心引入潜在问题，因为它们很容易恢复。这反过来意味着开发吞吐量增加，您可以更快地引入新功能并更有信心。
- en: Better developer experience
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的开发人员体验
- en: With GitOps, developers don't have to worry about building containers or using
    kubectl to control the cluster. Deploying new features requires just the use of
    Git, which is already a familiar tool in most environments.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps，开发人员不必担心构建容器���使用kubectl来控制集群。部署新功能只需要使用Git，这在大多数环境中已经是一个熟悉的工具。
- en: This also means that onboarding is quicker since new hires don't have to learn
    a lot of new tools in order to be productive. GitOps uses standard and consistent
    components, so introducing changes to the operations side should not impact developers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着入职速度更快，因为新员工不必学习很多新工具才能提高工作效率。GitOps使用标准和一致的组件，因此对运营方面的更改不应影响开发人员。
- en: Higher stability and reliability
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更高的稳定性和可靠性
- en: Using Git to store the state of your system means you have access to an audit
    log. This log contains a description of all the changes introduced. If your task
    tracking system integrates with Git (which is a good practice), you can typically
    tell which business feature is related to the system's change.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Git来存储系统状态意味着您可以访问审计日志。该日志包含所有引入的更改的描述。如果您的任务跟踪系统与Git集成（这是一个好习惯），通常可以确定与系统更改相关的业务功能。
- en: With GitOps, there is less need to allow manual access to the nodes or the entire
    cluster, which reduces the chance of accidental errors originating from running
    an invalid command. Those random errors that get into the system are easily fixed
    by using Git's powerful revert feature.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps，不需要手动访问节点或整个集群的需求减少了，这减少了因运行无效命令而产生意外错误的机会。通过使用Git强大的还原功能，可以轻松修复系统中出现的随机错误。
- en: Recovery from a severe disaster (such as losing the entire control plane) is
    also a lot easier. All it requires is setting up a new clean cluster, installing
    a GitOps operator there, and pointing it to the repository with your configuration.
    After a short while, you have an exact replica of your previous production system,
    all without manual intervention.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从严重灾难（如失去整个控制平面）中恢复也更容易。所需的只是设置一个新的干净集群，在那里安装一个GitOps运算符，并将其指向具有您配置的存储库。不久之后，您将获得与以前的生产系统完全相同的副本，而无需手动干预。
- en: Improved security
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高安全性
- en: A reduced need to give access to the cluster and nodes means improved security.
    There is less to worry about in terms of lost or stolen keys. You avoid a situation
    where someone retains access to your production environment even though this person
    is no longer working on the team (or in the company).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 减少对集群和节点的访问需求意味着提高了安全性。在丢失或盗窃密钥方面可以少操心。您避免了这样一种情况：即使某人不再在团队（或公司）工作，但仍然保留对生产环境的访问权限。
- en: When it comes to access to the system, the single point of truth is handled
    by the Git repository. Even if a malicious actor decides to introduce a backdoor
    into your system, the change required will undergo a code review. Impersonating
    another developer is also more challenging when your repository uses GPG-signed
    commits with strong verification.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及对系统的访问时，Git存储库处理单一真相。即使恶意行为者决定在系统中引入后门，所需的更改也将经过代码审查。当您的存储库使用具有强验证的GPG签名提交时，冒充其他开发人员也更具挑战性。
- en: So far, we've mainly covered the benefits from the development and operations
    point of view. But GitOps also benefits the business. It affords business observability
    in the system, something that was hard to achieve before.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了从开发和运营角度的好处。但是GitOps也有利于业务。它为系统提供了业务可观察性，这是以前很难实现的。
- en: It's easy to track the features present in a given release as they are all stored
    in Git. Since Git commits a link to the task tracker, business people can get
    preview links to see how the application looks in various development stages.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易跟踪给定发布中存在的功能，因为它们都存储在Git中。由于Git提交了一个任务跟踪器的链接，业务人员可以获得预览链接，以查看应用程序在各种开发阶段的外观。
- en: 'It also gives clarity that allows the following common questions to be answered:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了清晰度，可以回答以下常见问题：
- en: What's running in production?
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境中运行什么？
- en: Which tickets have been resolved with the last release?
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个发布解决了哪些问题？
- en: Which change might be responsible for service degradations?
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个更改可能导致服务降级？
- en: The questions for all those answers may even be presented in a friendly dashboard.
    Naturally, the dashboard itself can be stored in Git as well.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些答案的问题甚至可以在友好的仪表板中呈现。当然，仪表板本身也可以存储在Git中。
- en: GitOps tools
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitOps工具
- en: The GitOps space is a new and growing one. There are already tools that can
    be considered stable and mature. Here are some of the most popular ones.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps空间是一个新兴的领域。已经有一些可以被认为是稳定和成熟的工具。以下是一些最受欢迎的工具。
- en: FluxCD
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FluxCD
- en: FluxCD is an opinionated GitOps operator for Kubernetes. Selected integrations
    provide core functionality. It uses Helm charts and Kustomize to describe the
    resources.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: FluxCD是Kubernetes的一个主观的GitOps操作者。选择的集成提供核心功能。它使用Helm图表和Kustomize来描述资源。
- en: Its integration with Prometheus adds observability to the deployment process.
    To help with maintenance, FluxCD features a CLI.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它与Prometheus的集成为部署过程增加了可观察性。为了帮助维护，FluxCD具有CLI。
- en: ArgoCD
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ArgoCD
- en: Unlike FluxCD, it offers a broader choice of tools to use. This might be useful
    if you're already using Jsonnet or Ksonnet for your configuration. Like FluxCD,
    it integrates with Prometheus and features a CLI.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与FluxCD不同，它提供了更广泛的工具选择。如果您已经在配置中使用Jsonnet或Ksonnet，这可能会很有用。与FluxCD一样，它与Prometheus集成，并具有CLI。
- en: At the time of writing this book, ArgoCD is a more popular solution than FluxCD.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，ArgoCD比FluxCD更受欢迎。
- en: Jenkins X
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins X
- en: Contrary to what the name might suggest, Jenkins X doesn't have much in common
    with the well-known Jenkins CI system. It is backed by the same company, but the
    entire concepts of Jenkins and Jenkins X are totally different.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与名称可能暗示的相反，Jenkins X与著名的Jenkins CI系统没有太多共同之处。它由同一家公司支持，但Jenkins和Jenkins X的整个概念完全不同。
- en: While the other two tools are purposefully small and self-contained, Jenkins
    X is a complex solution with many integrations and a broader scope. It supports
    the triggering of custom build tasks, making it look like a bridge between a classic
    CI/CD system and GitOps.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他两个工具都是特意小而自包含的，但Jenkins X是一个复杂的解决方案，具有许多集成和更广泛的范围。它支持触发自定义构建任务，使其看起来像是经典CI/CD系统和GitOps之间的桥梁。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations on reaching the end of the chapter! Using modern C++ is not
    limited to understanding the recently added language features. Your applications
    will run in production. As an architect, it's also your choice to make sure the
    runtime environment matches requirements. In the few previous chapters, we described
    some popular trends in distributed applications. We hope this knowledge will help
    you decide which one is the best fit for your product.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了本章的阅读！使用现代C++不仅仅是理解最近添加的语言特性。您的应用程序将在生产环境中运行。作为架构师，您还可以选择确保运行时环境符合要求。在前几章中，我们描述了分布式应用程序中的一些流行趋势。我们希��这些知识将帮助您决定哪种最适合您的产品。
- en: Going cloud-native brings a lot of benefits and can automate a good chunk of
    your workflow. Switching custom-made tools to industry standards makes your software
    more resilient and easier to update. In this chapter, we have covered the pros,
    cons, and use cases of popular cloud-native solutions.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 进行云原生转型带来了许多好处，并且可以自动化大部分工作流程。将定制工具切换到行业标准可以使您的软件更具弹性并更易于更新。在本章中，我们已经涵盖了流行的云原生解决方案的优缺点和用例。
- en: Some, such as distributed tracing with Jaeger, bring immediate benefits to most
    projects. Others, such as Istio or Kubernetes, perform best in large-scale operations.
    After reading this chapter, you should have sufficient knowledge to decide whether
    introducing cloud-native design into your application is worth the cost.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工具，如Jaeger的分布式跟踪，对大多数项目都带来了即时的好处。其他工具，如Istio或Kubernetes，在大规模操作中表现最佳。阅读本章后，您应该具有足够的知识来决定是否值得为您的应用程序引入云原生设计。
- en: Questions
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between running your applications in your cloud and making
    them cloud-native?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在云中运行应用程序和使其成为云原生之间有什么区别？
- en: How can you run cloud-native applications on-premises?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在本地运行云原生应用程序？
- en: What's the minimal highly available cluster size for Kubernetes?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes的最小高可用集群大小是多少？
- en: Which Kubernetes object represents a microservice that allows network connections?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Kubernetes对象代表允许网络连接的微服务？
- en: Why is logging not sufficient in distributed systems?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在分布式系统中日志记录不足够？
- en: How does a service mesh help with building secure systems?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务网格如何帮助构建安全系统？
- en: How does GitOps increase productivity?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitOps如何提高生产力？
- en: What's the standard CNCF project for monitoring?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控的标准CNCF项目是什么？
- en: Further reading
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Kubernetes*: [https://www.packtpub.com/product/mastering-kubernetes-third-edition/9781839211256](https://www.packtpub.com/product/mastering-kubernetes-third-edition/9781839211256)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通Kubernetes*：[https://www.packtpub.com/product/mastering-kubernetes-third-edition/9781839211256](https://www.packtpub.com/product/mastering-kubernetes-third-edition/9781839211256)'
- en: '*Mastering Distributed Tracing*: [https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464](https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通分布式跟踪*：[https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464](https://www.packtpub.com/product/mastering-distributed-tracing/9781788628464)'
- en: '*Mastering Service Mesh*: [https://www.packtpub.com/product/mastering-service-mesh/9781789615791](https://www.packtpub.com/product/mastering-service-mesh/9781789615791)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《精通服务网格》：[https://www.packtpub.com/product/mastering-service-mesh/9781789615791](https://www.packtpub.com/product/mastering-service-mesh/9781789615791)
