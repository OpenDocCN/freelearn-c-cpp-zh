- en: Types of light sources and combining of lights
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光源类型和灯光的组合
- en: In this chapter, we'll discuss the various types of lighting effects, such as
    diffuse light, ambient light, and specular light. You'll also explore the different
    type of light sources, such as directional light, point light, and spot light.
    We'll also discuss how to combine these different types of light sources for your
    game world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论各种光照效果类型，例如漫反射光、环境光和镜面反射光。您还将探索不同类型的光源，例如方向性光源、点光源和聚光灯。我们还将讨论如何将这不同类型的光源结合到您的游戏世界中。
- en: 'In this chapter we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Implementing different light sources, such as directional, point, and spot light
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同类型的光源，例如方向性光源、点光源和聚光灯
- en: Understanding the different effects of lights, such as diffused, ambient, and
    specular
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同类型的光照效果，例如漫反射光、环境光和镜面反射光
- en: How to combine different effects of light and the sources in your game world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的游戏世界中组合不同类型的光照效果和光源
- en: Let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: You can refer to all the code files for this chapter in the `Chapter05` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上的`Chapter05`文件夹中找到本章的所有代码文件。GitHub链接可以在书的序言中找到。
- en: Directional light
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向性光源
- en: In this section, we're going to talk about a directional light. We are advancing
    quite a bit now into the different lighting mechanics that you can use in OpenGL.
    We've looked at lighting maps, to be able to shine a light and have it affect
    an object differently depending on what sort of material a particular object or
    a particular part of the object is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论方向性光源。我们现在已经相当深入地了解了OpenGL中可以使用的不同光照机制。我们探讨了光照贴图，以便能够照亮物体，并根据特定物体或物体特定部分的材料类型以不同的方式影响物体。
- en: Directional lights
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向性光源
- en: 'We''ve looked at other basic material and basic lighting, but there are a few
    main types of lights that you can use in your game, such as directional lights,
    point lights, and spotlights. We''ll be covering point lights and spotlights in
    later sections; but directional lights are the most basic version of lights in
    3D graphics, in general:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了其他基本材料和基本光照，但你在游戏中可以使用几种主要的光源类型，例如方向性光源、点光源和聚光灯。我们将在后面的章节中介绍点光源和聚光灯；但方向性光源通常是3D图形中最基本的光源类型：
- en: '![](img/30b0c351-57f1-43f0-a528-39f7f48e379c.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30b0c351-57f1-43f0-a528-39f7f48e379c.png)'
- en: So, as you can see in the preceding diagram, there are arrows coming from some
    sort of light source. A directional light doesn't have an origin, or more precisely,
    a position, because the light source is infinitely far away.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您在前面的图中可以看到的，有一些箭头从一个光源发出。方向性光源没有原点，或者更准确地说，没有位置，因为光源无限远。
- en: So, for example, you had five cubes. Irrespective of what material they are,
    let's just assume they were all the same and they were rotated in the same way,
    but were positioned all over the place. So, let's say each one of them was (we
    don't really have a concept of distance in miles or kilometers in our engine)
    100 miles away from each other and in any direction. The actual light and the
    directional light would affect each individual box object in the same way because
    the directional light has no starting position. You can't get any closer to the
    light source; you might think that if you move in the light's direction, you'll
    get closer to the light source. Technically, you could say that's true. But if
    it has no original location and no original position, and it's infinitely far
    away, it's still going to be infinitely far away. So that's what a directional
    light is.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有五个立方体。无论它们的材质如何，我们假设它们都是相同的，并且以相同的方式旋转，但位置各不相同。所以，让我们假设它们彼此之间相距100英里，并且朝任何方向。实际上，光和方向性光将以相同的方式影响每个单独的立方体对象，因为方向性光源没有起始位置。您无法接近光源；您可能会认为如果您朝光源的方向移动，您会接近光源。技术上，您可以说这是真的。但如果它没有原始位置和原始位置，并且无限远，它仍然会无限远。所以这就是方向性光源。
- en: A directional light is sort of just a general light you have in the scene, and
    then you use spotlights and point lights to enhance your scene to create more
    specific stuff. So, let's consider this example. If you have a game that's set
    on flat ground or some island, then the directional light could be the sun.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 方向光在场景中类似于你拥有的普通光，然后你使用聚光灯和点光源来增强你的场景，创建更具体的东西。所以，让我们考虑这个例子。如果你有一个设定在平坦地面或某个岛屿上的游戏，那么方向光可以是太阳。
- en: If you're not really going vertically up, you're not going into space, you can't
    really get any nearer to the sun; then you could think of that as a directional
    light and most of the time, that is thought of as a directional light in a lot
    of games.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是真正垂直向上，你没有进入太空，你不能真正地靠近太阳；那么你可以将其视为方向光，在许多游戏中，这通常被认为是方向光。
- en: 'Again, it depends on what sort of game you''re playing. If you''re playing
    a game where you can go into space and you can get to the stars or the sun, then
    that really wouldn''t be a directional light; that would be a different light.
    But more different types of light will be covered in different sections. So let''s
    implement this by using the `shaders/lighting.frag` file, as shown in the following
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这取决于你玩的游戏类型。如果你玩的游戏可以进入太空并到达星星或太阳，那么这根本就不是方向光；那将是另一种光。但不同类型的光将在不同的部分中介绍。所以，让我们通过使用`shaders/lighting.frag`文件来实现这一点，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What we are doing is commenting out an original position, `vec3 position`, and
    instead adding a direction, that is, `vec3 direction`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是注释掉原始位置`vec3 position`，而不是添加一个方向，即`vec3 direction`。
- en: 'In the diffuse lighting, we need to modify it slightly:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在漫反射光照中，我们需要稍作修改：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, let's just comment out `lightDir` because though we're going to have a light
    direction again, we want to leave in this code in case we need it later on. So,
    add a new code line, `lightDir = normalize -light.direction`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们只注释掉`lightDir`，因为尽管我们还将有一个光方向，但我们想保留这段代码以备将来使用。所以，添加一个新的代码行，`lightDir
    = normalize -light.direction`。
- en: So that's all we have to do here, because we're not working out the difference
    between the position (`light.position`) and the actual fragment shader position
    (`FragPos`). We don't have to do that, because all we are concerned about is the
    light's direction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是我们在这里需要做的全部，因为我们不是在计算位置（`light.position`）和实际片段着色器位置（`FragPos`）之间的差异。我们不需要这样做，因为我们只关心光的方向。
- en: Making changes to main code to integrate directional light in our world
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主代码以整合我们的世界中的方向光
- en: 'Now open the `main.cpp` file, which is used for the actual light and the shaders.
    Comment out our shader programs, because we''re not going to actually use the
    lamp shader in this section, simply because we don''t want any sort of light source
    with an origin position:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`main.cpp`文件，该文件用于实际的光照和着色器。注释掉我们的着色器程序，因为我们在这个部分实际上不会使用灯着色器，仅仅是因为我们不希望有任何具有原点位置的光源：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we're going to use an array of different cube positions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用不同立方体位置的一个数组。
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''re going to spawn several cubes, very similar to what we''ve done before,
    and you can see the variance in having different cubes. We don''t need the light
    vertex array object anymore because we''re not doing the lamp shader, so let''s
    just comment that out:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成几个立方体，非常类似于我们之前所做的那样，你可以看到不同立方体之间的差异。我们不再需要光照顶点数组对象，因为我们不做灯着色器，所以让我们只注释掉它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All this looks good so far, but we''ve to do a few changes within the `while`
    loop, to the part where we''re using the lighting shader. So, add `GLint lightDirLoc
    = glGetUniformLocation` and `glUniform3f`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都很好，但我们需要在`while`循环中进行一些更改，到我们使用光照着色器的部分。所以，添加`GLint lightDirLoc
    = glGetUniformLocation`和`glUniform3f`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The view position location, which is just the camera's position, is fine. The
    ambient and the diffuse need not be changed. You can modify them if you want to,
    but it's not needed for this particular chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 视图位置位置，也就是摄像机的位置，是好的。环境光和漫反射不需要更改。如果你想修改它们，也可以，但在这个特定的章节中不是必需的。
- en: 'Now, create a for loop as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个如下所示的循环：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we add `glm::mat4` as a 4x4 matrix. We will call it model. Then we add
    `glBindVertexArray`, which will take the box vertex array object. Sometimes we
    only want one cube; sometimes we want several, so we will use `cubePositions`
    and it will take the iterator as the index. Now we're going to add `GLfloat angle
    = 20.0f * i; model = glm::rotate` and for the rotation, it's going to take the
    model again. For the angle, we are just going to put angle. After that, we will
    add a vector,`glm::vec3`, and for this, we are just going to put `1.0f`, `0.3f`,
    and `0.5f`. We're just going to uniform the 4x4 matrix. Use `glUniformMatrix4fv`,
    because its four float values and `modelLoc`, which is what we created previously,
    will take the value `1`. Then add `GL_FALSE` and `glm::value_ptr (model)`. `glDrawArrays`
    will take `GL_TRIANGLES`, the starting index `0`, and `36` different vertices.
    So, if we put a semicolon there, we just need to `glBind` the vertex array to
    `0`, so we will just unbind it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加`glm::mat4`作为一个4x4矩阵。我们将称之为模型。然后我们添加`glBindVertexArray`，它将获取盒子顶点数组对象。有时我们只想有一个立方体；有时我们想有多个，所以我们将使用`cubePositions`，它将迭代器作为索引。现在我们将添加`GLfloat
    angle = 20.0f * i; model = glm::rotate`，对于旋转，它将再次使用模型。对于角度，我们只是放置角度。之后，我们将添加一个向量，`glm::vec3`，对于这个，我们只是放置`1.0f`、`0.3f`和`0.5f`。我们只是将4x4矩阵统一化。使用`glUniformMatrix4fv`，因为它有四个浮点值和`modelLoc`，这是我们之前创建的，它将取值为`1`。然后添加`GL_FALSE`和`glm::value_ptr
    (model)`。`glDrawArrays`将取`GL_TRIANGLES`，起始索引`0`和`36`个不同的顶点。所以，如果我们在这里放置一个分号，我们只需要将顶点数组绑定到`0`，所以我们只是取消绑定它。
- en: 'Now we will run this bad boy and we get Build Failed. This is happening because
    we commented out the light vertex array object and hence there''s no need for
    us to use `glDeleteVertexArrays( 1, &lightVAO )`. So, now run it again and you
    will get Build Succeeded and the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行这个家伙，结果却是构建失败。这是因为我们注释掉了光顶点数组对象，因此我们也就没有必要使用`glDeleteVertexArrays( 1,
    &lightVAO )`了。所以，现在再次运行它，你将得到构建成功，并看到以下输出：
- en: '![](img/0650b9a6-801a-4251-b1d3-9ed9596d1fb6.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0650b9a6-801a-4251-b1d3-9ed9596d1fb6.png)'
- en: Here, we've got our different objects. All of these objects are affected by
    the light in the same way. Obviously, there are angle differences, and that's
    what makes the intensity of the light affecting it different. But in terms of
    their position, that doesn't matter. Because the light is coming from one direction,
    the objects are affected exactly the same. They are just as dark and bright. The
    specular lighting will affect them just the same way, and it's the angle that
    makes the lighting affect it differently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有我们的不同对象。所有这些对象都受到光照的影响方式相同。显然，角度不同，这就是光照影响它的强度不同的原因。但在它们的位置方面，这并不重要。因为光照来自一个方向，物体受到的影响完全相同。它们既不暗也不亮。镜面光照将以相同的方式影响它们，并且是角度使得光照影响它不同。
- en: So far, we have learned about directional lights in modern OpenGL. We'll cover
    an advanced form of lighting in the next section where we'll create some really,
    really cool stuff with lighting. When you see all our games, especially games
    that look really, really good in terms of graphical fidelity, you'll find that
    when you start going under the layers and start doing programming in graphics,
    you'll see a lot of it's due to lighting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了现代OpenGL中的方向光。在下一节中，我们将介绍一种更高级的光照形式，我们将使用光照创建一些非常酷的东西。当你看到我们的所有游戏，尤其是那些在图形保真度方面看起来非常棒的游戏时，你会发现，当你开始深入到这些游戏的底层并开始进行图形编程时，你会看到很多都是由于光照造成的。
- en: The way lighting affects things has probably the biggest effect because by using
    normal lighting you can make an object look like it's got depth, even though it's
    just a flat texture, and that is pretty radical.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 光照影响事物的方式可能具有最大的影响，因为通过使用正常光照，你可以使一个物体看起来有深度，即使它只是一个平面纹理，这相当激进。
- en: Point lights
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点光源
- en: In this chapter, we will discuss point lights. We've covered lighting systems
    in a bit of depth so far. One technique is directional lights, which essentially
    are light sources that point in a certain direction, hence the name directional
    light; but they do not have an original location, that is, they are infinitely
    far away. So, say for example, we have two objects that are exactly the same,
    rotated exactly the same way, and there's no other lighting affecting those objects;
    no matter how far they are away from each other, they will not be affected differently
    by the directional light source.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论点光源。到目前为止，我们已经对光照系统进行了深入的探讨。一种技术是方向性光源，本质上是指向某个方向的光源，因此得名方向性光源；但它们没有原始位置，也就是说，它们在无限远处。所以，比如说，我们有两个完全相同的物体，以完全相同的方式旋转，并且没有其他光照影响这些物体；无论它们彼此距离多远，它们都不会受到方向性光源的不同影响。
- en: The point light concept
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点光源的概念
- en: 'A **point light** is a light that has an actual origin, and it emits the light
    in every single direction:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**点光源**是一种具有实际起源的光源，它向每个方向发出光：'
- en: '![](img/361b24d4-eebe-4fec-93cf-eed080f9f7b9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/361b24d4-eebe-4fec-93cf-eed080f9f7b9.png)'
- en: You can almost think of a point light like our sun or a star in real life. You
    could argue that the sun technically emits different amounts of light from different
    sides, but we could, for argument's sake, say it emits the same intensity, the
    same type of light from its origin in all directions. It's very common for, let's
    say, space games to have something like a point light as the sun, a star, or some
    other sort of object like that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以将一个点光源想象成我们生活中的太阳或星星。你可以争论说，从技术上讲，太阳从不同的侧面发出不同数量的光，但为了争论，我们可以这样说，它从其起源向所有方向发出相同强度、相同类型的光。在空间游戏中，像太阳、星星或其他类似物体一样有一个点光源是非常常见的。
- en: 'First of all, just open your lighting fragment shader, that is, `../shaders/lighting.frag`,
    and in this file, we need to modify a few things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，只需打开你的光照片段着色器，即`../shaders/lighting.frag`，在这个文件中，我们需要修改一些东西：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, we will comment out the `direction` vector because
    we don't need the direction anymore since the lighting source has a position,
    and it just emits light in every direction. So, `ambient`, `diffuse`, and `specular`
    will need no changes. Now, we will add a constant, a linear, and a quadratic float.
    That's all for the lighting struct.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将注释掉`direction`向量，因为我们不再需要方向，因为光源有一个位置，它只是向每个方向发出光。所以，`ambient`、`diffuse`和`specular`将不需要更改。现在，我们将添加一个常数、一个线性和一个二次浮点数。这就是灯光结构体的全部内容。
- en: The diffuse section
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩散部分
- en: 'Now, let''s check out the diffuse section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下扩散部分：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're still going to normalize our `Normal`, but we want the difference between
    the light position and the fragment position. So we'll comment out the light direction,
    `vec3 lightDir = normalize(-light.direction)` and we'll uncomment `light.position
    - FragPos`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然将规范化我们的`Normal`，但我们想要光位置和片段位置之间的差异。所以我们将注释掉光方向，`vec3 lightDir = normalize(-light.direction)`，我们将取消注释`light.position
    - FragPos`。
- en: The difference, `max (dot( norm, lightDir)`, will be kept as it is. In terms
    of `diffuse`, we're still using `light.diffuse`, multiplying it by the `float
    diffuse` variable, `diff`, and then `vec3`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 差异，`max (dot( norm, lightDir)`, 将保持不变。在`diffuse`方面，我们仍在使用`light.diffuse`，将其乘以`float
    diffuse`变量，`diff`，然后是`vec3`。
- en: The specular section
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜面反射部分
- en: 'Let''s look at the specular section now:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看镜面反射部分：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the view direction and the reflection direction won't change. What we
    need to add is something called attenuation, something like, distance and lighting.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，视方向和反射方向不会改变。我们需要添加的是称为衰减的东西，类似于距离和光照。
- en: The attenuation section
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 衰减部分
- en: 'Attenuation is essentially dropout. Attenuation lighting is a decrease in lighting
    as you move away from an object. Take a look at this image:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 衰减实际上是一种断开连接。衰减光照是随着你远离物体而光照的减少。看看这张图片：
- en: '![](img/192a78ff-bd4b-4424-b46e-5baed84f8879.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/192a78ff-bd4b-4424-b46e-5baed84f8879.png)'
- en: We've got four different light sources, **A**, **B**, **C**, and **D**. We will
    assume they're all the same. **A** has more of an effect on the ground than **D**
    because **D** is further away. So, basically attenuation is the fall-off.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个不同的光源，**A**、**B**、**C**和**D**。我们将假设它们都是相同的。**A**对地面的影响比**D**更大，因为**D**更远。所以，基本上衰减就是衰减。
- en: 'So, let''s implement it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来实现它：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, if the light source was further away but still
    had the same sort of angle, it would still affect our object the same, and we
    don't want that. So, we will add `float distance = length(light.position - FragPos)`,
    and after that, add `float attenuation = 1.0f / (light.constant + light.linear
    * distance + light.quadratic * (distance * distance))`. So, this is how we calculated
    the distance and the attenuation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，如果光源距离更远但角度相同，它仍然会以相同的方式影响我们的对象，而我们不希望这样。因此，我们将添加`float distance =
    length(light.position - FragPos)`，然后添加`float attenuation = 1.0f / (light.constant
    + light.linear * distance + light.quadratic * (distance * distance))`。所以，这就是我们计算距离和衰减的方法。
- en: 'If you want more information about how this works, feel free to check out the
    following links:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于它是如何工作的信息，请随意查看以下链接：
- en: '[https://open.gl](https://open.gl/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://open.gl](https://open.gl/)'
- en: '[https://learnopengl.com](https://learnopengl.com)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learnopengl.com](https://learnopengl.com)'
- en: These are great resources, so feel free to check them out.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是很好的资源，所以请随意查看它们。
- en: 'Now we are going to add attenuation to the ambient, diffuse, and specular lights:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加环境光、漫反射和镜面光的衰减：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need these because all three of them will have attenuation factored in as
    they need to factor in distance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些，因为所有三个都需要考虑衰减，因为它们需要考虑距离。
- en: Time for changes in main.cpp
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main.cpp中的更改时间
- en: 'Open the `main.cpp` file. We will have to do a few modifications to it. The
    first thing we need to actually uncomment out is `lampShader`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`main.cpp`文件。我们需要对其进行一些修改。首先，我们需要实际取消注释`lampShader`：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is because we're using the lamp again since we are dealing with the point
    light.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们再次使用灯，因为我们正在处理点光源。
- en: 'The next thing we need to change is the light vertex array object because we''re
    using the lamp shader now. So, uncomment the following code block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个我们需要改变的是光顶点数组对象，因为我们现在正在使用灯着色器。所以，取消注释以下代码块：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need an emission map, so we will add `emissionMap`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个发射贴图，所以我们将添加`emissionMap`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The only change we need to make now is actually within our `while` loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的唯一改变实际上是在我们的`while`循环中：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we also need to add the constants, the linear, and the quadratic, which
    are float values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要添加常量、线性项和二次项，这些都是浮点值：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in order to bind our textures, we need to uncomment out the `lampShader.Use(
    )` block. Also, delete the light vertex array object, that is, uncomment the `glDeleteVertexArrays(
    1, &lightVAO );` line:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了绑定我们的纹理，我们需要取消注释`lampShader.Use( )`块。同时，删除光顶点数组对象，即取消注释`glDeleteVertexArrays(
    1, &lightVAO );`行：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we are ready to run our application and we get the following screen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备运行我们的应用程序，我们得到以下屏幕：
- en: '![](img/7df644a1-5179-4278-9289-a8bf38296192.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7df644a1-5179-4278-9289-a8bf38296192.png)'
- en: If you examine the output, we've got our original light source and the objects
    that are further away are a bit darker, as they should be.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查输出，我们得到了原始的光源，并且距离较远的对象稍微暗一些，正如它们应该的那样。
- en: 'But let''s make one more change in `main.cpp`; we can actually move our light
    by uncommenting the following lines in the `while` loop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们在`main.cpp`中再做一个更改；我们实际上可以通过在`while`循环中取消注释以下行来移动我们的光：
- en: '`lightPos.x -=0.005f;`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightPos.x -=0.005f;`'
- en: '`lightPos.z -=0.005f;`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightPos.z -=0.005f;`'
- en: 'And now, if you re-run the application, as you can see in the following screenshot,
    attenuation is factored in. You can see that this object is getting slightly brighter
    now, and you''ll actually start seeing this particular object getting brighter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新运行应用程序，正如你在以下屏幕截图中所见，衰减已经考虑在内。你可以看到这个对象现在稍微亮一些，你实际上会开始看到这个特定的对象变亮：
- en: '![](img/6ed63f29-bf47-432b-9963-1cd4d0bdc4db.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ed63f29-bf47-432b-9963-1cd4d0bdc4db.png)'
- en: 'Now, again comment out the following lines back in the `while` loop:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次在`while`循环中取消注释以下行：
- en: '`lightPos.x -=0.005f;`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightPos.x -=0.005f;`'
- en: '`lightPos.z -=0.005f;`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightPos.z -=0.005f;`'
- en: 'And, instead we will try changing the light position in the camera section:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们将尝试在相机部分改变光的位置：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, as you can see in the preceding code, we have replaced `2.0f` to `-2.0f`
    in the light attributes section. Now, if you run your application, you can see
    the light is being emitted in every single direction. Nearer objects are brighter
    than more distant objects:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你可以在前面的代码中看到的那样，我们在光属性部分将`2.0f`替换为`-2.0f`。现在，如果你运行你的应用程序，你可以看到光正在向每个方向发射。较近的对象比远处的对象更亮：
- en: '![](img/b5e35832-190e-4e04-891a-8fd890d2c685.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e35832-190e-4e04-891a-8fd890d2c685.png)'
- en: So, that is it for point lights.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是点光源的全部内容。
- en: Spotlight
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚光灯
- en: Let's discuss and take a look at how we can add spotlights to our game. We've
    looked at directional lights, we've looked at point lights. Directional lights
    have a direction but they don't have an original position, so they are infinitely
    far away. A point light has a position but it shines light in every single direction,
    whereas a spotlight has a position and a direction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论并看看我们如何将聚光灯添加到我们的游戏中。我们已经看过方向光，我们也看过点光源。方向光有一个方向，但没有原始位置，所以它是无限远的。点光源有一个位置，但它向每个方向发光，而聚光灯有一个位置和方向。
- en: 'Take a look at the following diagram of a spotlight:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下聚光灯的图示：
- en: '![](img/3b3fb65f-787c-4a2d-b82c-25d886312251.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b3fb65f-787c-4a2d-b82c-25d886312251.png)'
- en: So, the position of the light is high up somewhere, and you can also see that
    there is a direction for the light. It essentially creates a cone-like effect,
    sort of what a lamp or a torch would do. Spotlights are used on stages. But spotlights
    are used in several scenarios in games throughout your world.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，光源的位置很高，你还可以看到有一个光的方向。它本质上创建了一个圆锥形的效果，就像灯或火炬一样。聚光灯在舞台上使用。但在你的世界中，聚光灯在游戏的多个场景中使用。
- en: So, without further ado, let's get on with coding our spotlights.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无需多言，让我们开始编写我们的聚光灯代码。
- en: Making changes to shader files
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改着色器文件
- en: 'Follow the below mentioned steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: Updating shader files is actually very, very simple. We only need to actually
    modify the lighting fragment shader in terms of the shader files; everything else
    looks fine. In `lighting.frag`, we can keep the `Material` struct as it is because
    it's got `diffuse`, `specular`, and `shininess`, and that's what we require for
    a spot light.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新着色器文件实际上非常非常简单。我们只需要实际修改着色器文件中的光照片段着色器；其他所有内容看起来都很好。在`lighting.frag`中，我们可以保持`Material`结构体不变，因为它有`diffuse`、`specular`和`shininess`，这正是我们需要的聚光灯特性。
- en: 'But with the light struct, we need the direction because the spotlight has
    an original position and a direction in which it is shining. So, we''ll uncomment
    `vec3 direction`. We also need a couple of float variables. The first one is `float
    cutOff`. The next one is `float outerCutOff`. Take a look at the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，与光结构体一起，我们需要方向，因为聚光灯有一个原始位置和它照射的方向。所以，我们将取消注释`vec3 direction`。我们还需要几个浮点变量。第一个是`float
    cutOff`。下一个是`float outerCutOff`。看看以下代码：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The rest of the terms till `void main` starts remain the same.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`void main`开始之前的其余术语保持不变。
- en: In `void main`, the ambient calculation, the diffuse calculation, and the specular
    calculation aren't changing. Even the attenuation calculation isn't going to be
    changing. All we actually need to do is add an extra section for the spotlight,
    which is going to be calculating soft edges.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void main`中，环境计算、漫反射计算和镜面反射计算都没有变化。甚至衰减计算也不会变化。我们实际上需要做的只是为聚光灯添加一个额外的部分，这将计算柔和的边缘。
- en: 'So, for the calculation of the soft edges, we''re going to add `float theta
    = dot();`, and to this we are going to pass `lightDir`. This needs to be normalized,
    so we''re passing `normalize()`. And then finally, here you need to specify `-light.direction`.
    You need to add a negative light value because you''re doing it from the perspective
    of the camera, not from the user. That''s the reason the position is negated.
    On the other line, we need to calculate the difference between `cutOff` and `outerCutOff`,
    so we''ll add the following:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，对于柔和边缘的计算，我们将添加`float theta = dot();`，并将`lightDir`传递给它。这需要被归一化，所以我们传递`normalize()`。然后最后，在这里你需要指定`-light.direction`。你需要添加一个负的光值，因为你是从摄像机的角度而不是从用户的角度来做的。这就是为什么位置被取反。在下一行，我们需要计算`cutOff`和`outerCutOff`之间的差异，所以我们将添加以下内容：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then add `float intensity = clamp();`. And in here, we are going to pass `theta
    - light.outerCutOff`. We want to divide this calculation by `epsilon` and then
    just put two values, `0.0` and `1.0`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`float intensity = clamp();`。在这里，我们将传递`theta - light.outerCutOff`。我们想将这个计算除以`epsilon`，然后只放两个值，`0.0`和`1.0`：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we just need to add the intensity into `diffuse` and `specular`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要将强度添加到`diffuse`和`specular`中：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, we're now actually done with the updating the shader.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在实际上已经完成了着色器的更新。
- en: Minor modification to Camera.h
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Camera.h进行微小修改
- en: 'In this section, we''ll need `GetFront`, which is a private variable in our
    main code. We''ll make a minor modification for it in our `Camera.h` file. So,
    below the `glm:: vec3 GetPosition()` method, we''ll add a simple method as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们需要 `GetFront`，这是主代码中的一个私有变量。我们将在 `Camera.h` 文件中对它进行一些小的修改。所以，在 `glm::vec3
    GetPosition()` 方法下面，我们将添加一个简单的方法，如下所示：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Making changes to the main code
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改主代码
- en: 'Now, if we go to main.cpp, we''ll make the following modifications:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们转到 `main.cpp`，我们将进行以下修改：
- en: We don't need `lampShader` because we're going to be doing it via a spotlight,
    so we'll comment out the code. The reason we don't need any sort of lamp shader
    or anything like that is because what we're going to do in this section is attach
    the spotlight to, essentially, the camera. You can almost think of it like those
    helmets with the light on top that people use for rock climbing and that sort
    of stuff. We're simply going to simulate that because directional light and point
    lights are great and if you have them static, they're easy to see and understand
    what is going on. With a spotlight, it really does help if you can move it, and
    the best way to move it is with the camera.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要 `lampShader`，因为我们将通过聚光灯来完成，所以我们将注释掉代码。我们不需要任何类型的灯片着色器或其他类似的东西，因为我们在这个部分要做的是将聚光灯附着在本质上相当于相机的位置。你几乎可以把它想象成那些顶部带有灯的头盔，人们用来攀岩和类似的活动。我们只是简单地模拟这个效果，因为方向光和点光源很棒，如果你让它们保持静态，它们很容易被看到和理解正在发生的事情。有了聚光灯，如果你能移动它，那真的很有帮助，而移动它的最好方法就是使用相机。
- en: We'll comment out the light vertex array object as we don't need it anymore.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将注释掉光顶点数组对象，因为我们不再需要它了。
- en: 'After we''ve commented that out, we can go directly into the while loop and
    we need to change a few things here. When we go to `lightingShader.Use`, we need
    to change some of the code there. We''re going to add `GLint lightSpotDirLocation
    = glGetUniformLocation();`. In here, we need to pass `lightingShader.Program`,
    and the other parameter you need to specify is `"light.direction"`. What we are
    going to do next is duplicate the preceding code and make the following modifications
    to it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注释掉这些代码之后，我们可以直接进入循环，并需要在这里做一些修改。当我们到达 `lightingShader.Use` 时，我们需要更改那里的某些代码。我们将添加
    `GLint lightSpotDirLocation = glGetUniformLocation();`。在这里，我们需要传递 `lightingShader.Program`，另一个需要指定的参数是
    `"light.direction"`。我们接下来要做的是复制前面的代码，并对其进行以下修改：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll modify the remaining terms of `lightingShader` code where we set the
    light properties as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将修改 `lightingShader` 代码中剩余的术语，其中我们设置光属性如下：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's only one thing we're going to change in here now. We'll comment out
    the whole `lampShader` code. Because we commented out the declaration and initialization,
    we need to do the same here.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只改变一件事。我们将注释掉整个 `lampShader` 代码。因为我们已经注释掉了声明和初始化，所以在这里我们也需要这样做。
- en: We also need to comment out `glDeleteVertexArrays();`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要注释掉 `glDeleteVertexArrays();`。
- en: We're all ready to run this now. You will see similar output on your screen.
    So, as you can see, we've got some light. The spot light is attached to us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行这个程序了。你会在屏幕上看到类似的输出。所以，正如你所见，我们有一些光线。聚光灯附着在我们身上。
- en: 'So, if we move forward, as you can see, we''ve got sort of a spotlight effect,
    and it''s more profound the closer we get to it, as seen in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们向前移动，正如你所见，我们得到了一种聚光灯效果，而且越靠近它，效果越明显，如下面的截图所示：
- en: '![](img/dbabce09-5e94-4d38-bbb3-0cb242d2d466.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbabce09-5e94-4d38-bbb3-0cb242d2d466.png)'
- en: 'Otherwise, it''s very wide as we move further away from the objects, as seen
    in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，当我们远离物体时，它非常宽，如下面的截图所示：
- en: '![](img/4b6b6d74-0d58-4c8c-bc75-0803755a7255.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b6b6d74-0d58-4c8c-bc75-0803755a7255.png)'
- en: 'Hence, they''re smaller. As we look around, we get a sort of spotlight effect.
    As you can see, it affects objects that are further away slightly differently,
    and we have this really cool spotlight, as seen in the following screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们较小。当我们四处张望时，我们得到了一种聚光灯效果。正如你所见，它对远离物体的物体产生的影响略有不同，我们有一个非常酷的聚光灯，如下面的截图所示：
- en: '![](img/2c107481-f0bc-4cc8-be1b-200ac41a92ab.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c107481-f0bc-4cc8-be1b-200ac41a92ab.png)'
- en: 'Let''s try and do it on a corner, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在角落处做一下，如下所示：
- en: '![](img/8e3cab23-d7f1-4482-ae37-608c8c1d507d.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e3cab23-d7f1-4482-ae37-608c8c1d507d.png)'
- en: We've got this really cool spotlight that is attached to our head. You could
    go ahead and create some sort of building game or some sort of miner's game where
    you have a light on your head. That would be pretty cool.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个非常酷的附着在我们头上的聚光灯。你可以继续创建某种建筑游戏或某种矿工游戏，其中你头上有一个光源。那会非常酷。
- en: Combining light
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合光线
- en: 'In this section, we''re going to be looking at combining our light sources.
    So far we''ve covered directional lights, point lights, and spotlights in the
    previous sections. The following is a brief overview of what they are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何结合我们的光源。到目前为止，在前面几节中，我们已经介绍了方向光、点光源和聚光灯。以下是对它们的简要概述：
- en: '**Directional light**: A directional light is a light that has a particular
    direction. It shines light in a particular direction. But it doesn''t have a location,
    a position. It''s just infinitely far away from everything.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**: 方向光是一种具有特定方向的光。它以特定方向发光，但没有位置，没有位置。它只是无限地远离一切。'
- en: '**Point light**: A point light has a position, but it shines light in every
    single direction. Depending on what you''re doing and what sort of game you''ve
    got, you could potentially have the sun or a star'' as a directional light, but
    if you could go into space, go around your star or get near it, then you''d probably
    want a point light.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**: 点光源有一个位置，但它向每个方向发光。根据你所做的工作和你的游戏类型，你可能会将太阳或星星作为方向光，但如果你能进入太空，绕着你的星星或靠近它，那么你可能想要一个点光源。'
- en: '**Spotlight**: A spotlight essentially is like a lamp. It casts a light in
    an initial position, and then in a direction as well. So it''s like a combination
    of the preceding two types of light.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**: 聚光灯本质上就像一盏灯。它在初始位置投射光线，然后在方向上也是如此。所以它就像是前两种光类型的组合。'
- en: In the previous sections, we looked at all of them, but at the moment, in these
    sections, we've just been covering them one at a time. We've either been commenting
    out code or modifying code to just show one realistically. But in a real game
    scenario or a free application scenario, you'll want multiple light sources. You'll
    want multiple instances of directional lights, point lights, and spotlights. You'll
    probably want to try and create your own really cool effects as well. In this
    section, we're going to be combining our three types of light casters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看了所有这些，但此刻，在这些章节中，我们只是逐个介绍它们。我们要么注释掉代码，要么修改代码，只是为了展示一个真实的情况。但在实际的游戏场景或自由应用程序场景中，你将想要多个光源。你将想要多个方向光、点光源和聚光灯的实例。你可能还想要尝试创建你自己的非常酷的效果。在本节中，我们将结合我们三种类型的光投射器。
- en: As usual, we'll start by updating the shader files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将从更新着色器文件开始。
- en: Getting the shader files ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备着色器文件
- en: 'Take a look at the below mentioned steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面提到的步骤：
- en: 'The first thing that we need to do is go to the fragment shader for lighting,
    `lighting.frag`. That''s the only shader that we actually need to modify, so we
    won''t touch `lighting.vs`. Check out the following steps to understand the changes
    that we need to make to the fragment shader:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是进入片段着色器中的照明部分，`lighting.frag`。这是我们实际上需要修改的唯一着色器，所以我们不会触摸`lighting.vs`。查看以下步骤以了解我们需要对片段着色器做出的更改：
- en: So, first of all, we're going to add `#define`, and this is just going to be
    `NUMBER_OF_POINT_LIGHTS`. For our project, we'll add the value as 4 because we're
    going to have four point lights.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，首先，我们将添加`#define`，这将是`NUMBER_OF_POINT_LIGHTS`。对于我们的项目，我们将添加值为4，因为我们将有四个点光源。
- en: 'Next, we''re going to need a data type for three different types of light source:
    a directional light, a point light, and a spotlight. For that, what we''ll do
    is actually duplicate the struct that we already have in code. We''ll rename each
    one of them appropriately: `DirLight` for directional light, `PointLight` for
    point light, and `SpotLight` for the spot light. We don''t need all of the vectors
    and the floats that we''ve got in the structs. Take a look at the following code
    to understand all the changes we need to make in the new struct that we have defined:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为三种不同类型的光源创建一个数据类型：方向光、点光源和聚光灯。为此，我们将实际上复制代码中已有的结构体。我们将适当地重命名每一个：`DirLight`用于方向光，`PointLight`用于点光源，`SpotLight`用于聚光灯。我们不需要结构体中所有的向量和浮点数。查看以下代码以了解我们需要在定义的新结构体中做出的所有更改：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The directional light, as you may remember, doesn''t have a position, it has
    a direction. It has an ambient, diffuse, and specular, but it doesn''t have any
    of the float variables: constant linear and quadratic. So we''ll just remove them:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方向光，如您可能记得的，没有位置，它有一个方向。它有环境光、漫反射和镜面反射，但没有任何浮点变量：常数、线性二次。所以我们将只移除它们：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the point light, remember it doesn''t have a direction; it has a position
    because it just emits light in every direction. We can get rid of `cutOff` and
    `outerCutOff`, but we''re going to need everything else:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于点光源，请记住它没有方向；它有一个位置，因为它只是向所有方向发射光。我们可以去掉`cutOff`和`outerCutOff`，但我们需要其他所有东西：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For the spotlight, nothing will be changing in here because this structure
    was created in the previous section, which covered spotlights:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于聚光灯，这里不会有任何变化，因为这个结构是在上一节中创建的，该节涵盖了聚光灯：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we move down, `uniform Light light` is going to change slightly as we''ve
    got three different sources of light. So we''ll make the following changes to
    it:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们向下移动，`uniform Light light`将略有变化，因为我们有三个不同的光源。所以我们将对其进行以下更改：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, for a `PointLight` as you may remember, we created a
    `#define`. So, the `uniform PointLight` is going to be an array of lights. Even
    though we're creating multiple spotlights and only one directional light and spotlight,
    you can create multiple directional lights and you can create multiple spotlights
    such as lamps, lights on a stick and that sort of thing. You might have one really
    strong source of light such as a directional light that could be simulating the
    sun, and then you might have just other general small lights.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如您可能记得的，我们创建了一个`#define`。因此，`uniform PointLight`将是一个灯光数组。尽管我们创建了多个聚光灯和一个方向光以及聚光灯，但您也可以创建多个方向光和多个聚光灯，例如台灯、棍子上点的灯等。您可能有一个非常强烈的光源，例如模拟太阳的方向光，然后您可能只有其他一些普通的小灯。
- en: 'What we need to do next is create some function prototypes because at the moment,
    what we''ve been doing is just doing everything in main. This has been alright
    for now, but we need a bit more flexibility with the way we''re doing things.
    So, we''re going to add `vec3 CalcDirLight();`, and this is going to take a few
    parameters such as `DirLight`. Then we''re going to take a `vec3` for the normal.
    We''ve explained the use of all of these different vectors and properties before.
    Again, we''re just combining what we''ve done over the past few sections. And
    then, we''ll duplicate the code and make the following highlighted changes to
    it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是创建一些函数原型，因为到目前为止，我们一直在`main`函数中做所有的事情。到目前为止这还不错，但我们需要在做事的方式上增加一些灵活性。所以，我们将添加`vec3
    CalcDirLight();`，这将接受一些参数，例如`DirLight`。然后我们将取一个`vec3`作为法线。我们之前已经解释了所有这些不同向量和属性的使用。再次强调，我们只是在结合过去几节中我们所做的工作。然后，我们将复制代码并对其做出以下突出显示的更改：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Making modifications void main of lighting.frag
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`lighting.frag`的`void main`中修改
- en: 'Check out the following steps to understand the modifications:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下步骤以了解修改：
- en: In the void main of `lighting.frag`, we're going to get rid of all the initially
    present code and add fresh code to it. We'll start by adding `vec3` normal. We're
    just going to be normalizing using `Normal`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lighting.frag`的`void main`中，我们将移除所有最初存在的代码并添加新的代码。我们将从添加`vec3 normal`开始。我们只是使用`Normal`进行标准化。
- en: Then we're going to create a vec3 for `viewDir`. This is going to normalize
    the difference between `viewPos` and `FragPos`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为`viewDir`创建一个`vec3`。这将标准化`viewPos`和`FragPos`之间的差异。
- en: Now we need to do the directional lighting calculation. With this, we're just
    going to be calling the `CalcDirLight` method. So, we're not going to be doing
    much code in main. Because we're adding more stuff to it, it's becoming like another
    C++ project because we are abstracting it out into different methods, so we can
    reuse this code when and where we need to. So, we'll add `vec3 result` and we'll
    assign the value of `CalcDirLight();`, and this is going to take the `dirLight`
    variable, the `norm` that we've just calculated, and the `viewDir`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要进行方向光计算。为此，我们只需调用`CalcDirLight`方法。所以，我们不会在`main`中做很多代码。因为我们正在向其中添加更多内容，它正变得像另一个C++项目，因为我们正在将其抽象成不同的方法，这样我们就可以在需要的时候重用这段代码。所以，我们将添加`vec3
    result`并将`CalcDirLight();`的值赋给它，这将接受`dirLight`变量、我们刚刚计算出的`norm`和`viewDir`。
- en: Next, we're just going to loop over the point lights, then factor them in. So,
    add a for loop and pass the initializing parameters, `int i = 0; i < NUMBER_OF_POINT_LIGHTS;
    i++`. In the `for` loop we are going to add `result += CalcPointLight()` . Again,
    what we're doing now is adding the effect of the different point lights to our
    result because again, this lighting is affecting our particular object, and this
    is the way it's done. So, to `CalcPointLight()` we're going to pass `pointLights[i]`,
    `norm`, and `FragPos`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只是将点光源循环遍历，然后考虑它们。所以，添加一个 for 循环并传递初始化参数，`int i = 0; i < NUMBER_OF_POINT_LIGHTS;
    i++`。在 `for` 循环中，我们将添加 `result += CalcPointLight()`。我们正在做的是将不同点光源的效果添加到我们的结果中，因为这种光照再次影响我们的特定对象，这就是它的做法。所以，我们将
    `pointLights[i]`、`norm` 和 `FragPos` 传递给 `CalcPointLight()`。
- en: 'What we''re going to do now is add the code for the spotlight. So, we''ll factor
    in the spotlight and add `result += CalcSpotLight()`. And this simply takes in
    the `spotLight` variable, `norm`, `FragPos`, and `viewDir`.Then we''ll add `color
    = vec4(result,1.0);`. Take a look at the following code to understand the description:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加聚光灯的代码。所以我们将考虑聚光灯并添加 `result += CalcSpotLight()`。这简单地接受 `spotLight` 变量、`norm`、`FragPos`
    和 `viewDir`。然后我们将添加 `color = vec4(result,1.0);`。请查看以下代码以了解描述：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is all stuff we've done before, and we're just abstracting it out now.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这都是我们之前做过的事情，我们现在只是将其抽象出来。
- en: Now let's do the calculation of colors for the different sources of light. So
    here, what we'll do is copy and paste the `vec3 calc` code for all three sources
    of light. Now let's do the directional light calculation. So to the `vec3 CalcDirLight()`
    method we'll add vec3 lightDir, and this is going to equal to `normalize( -light.direction
    );`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来计算不同光源颜色的计算。所以在这里，我们将复制并粘贴 `vec3 calc` 代码到所有三个光源。现在我们来计算方向光。所以我们将向 `vec3
    CalcDirLight()` 方法添加 `vec3 lightDir`，这将等于 `normalize( -light.direction )`。
- en: The reason for `-light.direction` is because we're not doing it from our object,
    we're doing it from the light. So, instead of the way the object is looking at
    the light, it's coming from the light. So, that's the reason why it's flipped.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`-light.direction` 的原因是因为我们不是从我们的对象出发来做的，而是从光线出发。所以，不是对象看光线的方向，而是光线从对象出发。这就是为什么它被翻转的原因。'
- en: And now we need to add float. This is going to be the diffuse shading. So, `diff
    = max ()`, and to `max()` we'll pass `dot( normal, lightDir ), 0.0`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加 `float`。这将是要素阴影。所以 `diff = max()`，并将 `dot( normal, lightDir ), 0.0`
    传递给 `max()`。
- en: Next, we're going to be calculating the specular shading. So add `vec3 reflectDir
    = reflect()`, and to `reflect()` we'll pass `-lightDir`, `normal` .
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将计算镜面反射阴影。所以添加 `vec3 reflectDir = reflect()`，并将 `-lightDir` 和 `normal`
    传递给 `reflect()`。
- en: Then we'll add `float spec = pow()` , and to that we'll pass `max ()`, and to
    `max()` we'll pass `dot( viewDir, reflectDir )` and `0.0`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加 `float spec = pow()`，并将 `max()` 传递给 `max()`，其中包含 `dot( viewDir, reflectDir
    )` 和 `0.0`。
- en: 'Finally, we need to add `material.shininess`. Now we need to combine the results.
    So, add `vec3 ambient = light.ambient * vec3 ();`, and to `vec3()` we''ll pass
    `texture( material.diffuse, TexCoords )`. This is going to be the texture diffuse
    and the texture coordinates, and for the diffuse and specular light it''s similar
    to ambient light, so make the highlighted changes to in the following code. Also,
    take a look at the following code to understand the preceding description:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加 `material.shininess`。现在我们需要组合结果。所以添加 `vec3 ambient = light.ambient
    * vec3 ()`，并将 `vec3()` 传递给 `texture( material.diffuse, TexCoords )`。这将是要素纹理的漫反射和纹理坐标，对于漫反射和镜面反射光，它与环境光类似，所以请在以下代码中做出突出显示的更改。同时，请查看以下代码以了解前面的描述：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we just need to return the calculation, which is `ambient
    + diffuse + specular`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只需要返回计算结果，即 `ambient + diffuse + specular`。
- en: 'Now we need to calculate the point light, so what we''ll do is duplicate the
    lines of code mentioned in the previous steps and paste in the `CalcPointLight()`
    method; we''ll add, change, and remove what we need to. Take a look at the following
    highlighted code to understand the changes:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要计算点光源，所以我们将复制前面步骤中提到的代码行，并将其粘贴到 `CalcPointLight()` 方法中；我们将添加、更改和删除所需的内容。请看以下突出显示的代码以了解更改：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, after defining the `specular` shading we added the attenuation
    code, as we need to factor in the attenuation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在定义了 `specular` 阴影之后，我们添加了衰减代码，因为我们需要考虑衰减。
- en: 'Now we need to do the calculations for the `spotlight ()` method. Again, we''re
    just going to copy and paste the previous code because we''ll most likely be adding
    quite a lot to it, but we''ll need most of it. So take a look at the following
    highlighted code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要对`spotlight ()`方法进行计算。同样，我们只是复制并粘贴之前的代码，因为我们很可能会添加很多东西，但我们需要大部分。所以请看以下突出显示的代码：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, before we go on to the `ambient`, `diffuse`, and `specular`
    vectors, we needed to add the spotlight intensity calculation code. Take a good
    look at the highlighted code. Then, finally, we just need to factor in the intensity.
    So we just multiplied the attenuation by the intensity in the final lines of code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在我们继续到`ambient`、`diffuse`和`specular`向量之前，我们需要添加聚光灯强度计算的代码。仔细查看突出显示的代码。然后，最后，我们只需要考虑强度。所以我们在代码的最后几行中只是将衰减乘以强度。
- en: We're done now updating the fragment lighting shader. We've covered all of this
    before in the previous sections. We are just combining it all together. Now, we're
    done. I'm sure there are going to be errors, because there's quite a lot of code
    in here, so we'll get to that when we start compiling it. So let's just save it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经更新了片段光照着色器。我们之前已经覆盖了所有这些内容。我们现在只是将它们全部组合在一起。现在，我们已经完成了。我相信这里肯定会有错误，因为这里有很多代码，所以当我们开始编译它时我们会处理这些错误。所以让我们保存它。
- en: Now we will move on to our main code to make modifications to it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续修改我们的主要代码。
- en: Changes to the main code
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主代码的更改
- en: 'Follow the below mentioned steps to combine the light source in our code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在我们的代码中组合光源：
- en: 'In `main.cpp`, we need the lamp shader, so we''ll uncomment it. After `cubePositions`,
    because now we''ve got multiple point light positions, we''re going to add `glm::vec3`,
    and this is going to be called `pointLightPositions[]`. We are going to add `glm::vec3();`
    in there, and for this, we are going to pass `0.7f`, `0.2f`, and `2.0f`. Duplicate
    this line of code, paste it four times, and make the following changes:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`中，我们需要灯的着色器，所以我们将取消注释它。在`cubePositions`之后，因为我们现在有多个点光源位置，我们将添加`glm::vec3`，这将被称为`pointLightPositions[]`。我们将在其中添加`glm::vec3();`，为此，我们将传递`0.7f`、`0.2f`和`2.0f`。复制这一行代码，粘贴四次，并做以下修改：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next, we'll uncomment the light vertex array object as we need it now to combine
    the lights.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将取消注释灯光顶点数组对象，因为我们现在需要它来组合灯光。
- en: 'The major changes that we need to make are within the `while` loop now. We''re
    using the lighting shader, so we''ll make the following changes to it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的重大更改现在都在`while`循环中。我们正在使用光照着色器，所以我们将对其进行以下更改：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''re setting the uniforms for the directional light:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在设置方向光的制服：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we''ll set the uniforms for point light 1:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将为点光源1设置制服：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, set the uniforms for point light 2:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，为点光源2设置制服：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here are the definition of the uniforms for point light 3:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是点光源3的制服定义：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here are the definitions for point light 4:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是点光源4的定义：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we''ll define uniforms for the spotlight as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将按照以下方式定义聚光灯的制服：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding lines of code, we set all the uniforms for the 5 or 6 types
    of lights we have. We have to set them manually and index the proper `PointLight`
    struct in the array to set each uniform variable. This can be made more code-friendly
    by defining light types as classes and setting their values in there, or by using
    a more efficient uniform approach by using uniform buffer objects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们为5或6种类型的灯光设置了所有制服。我们必须手动设置它们，并在数组中索引正确的`PointLight`结构来设置每个制服变量。这可以通过定义灯光类型为类并在其中设置它们的值，或者通过使用更高效的制服方法，即使用制服缓冲对象来使代码更友好。
- en: We've still got all of the code that we don't need anymore, so, from just below
    the point where we finished our spotlight stuff to the point where we start defining
    our view matrix, we need to get rid of that all that code. These are the remnants
    from when we only had one type of light, and it was called `Light`, so we'll get
    rid of that.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然有我们不再需要的所有代码，所以，从我们完成spotlight相关内容的点开始，到我们开始定义视图矩阵的点，我们需要删除所有这些代码。这些都是当只有一种灯光类型时的残留代码，它被称为`Light`，所以我们将删除它。
- en: We need to comment back in the shader, and I need to comment back in the deleting
    of the light vertex array object.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将着色器中的注释重新添加回去，并且需要将删除灯光顶点数组对象的注释重新添加回去。
- en: We've looped through our box array, we have created all the different boxes,
    and we've got our lamp shader. Remember, we've got multiple point lights, so we
    just need to create a loop for that. So, after binding the vertex array and unbinding
    it, we need to add `glBindVertexArray( lightVAO );`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经遍历了我们的盒子数组，创建了所有不同的盒子，并且我们有了我们的灯着色器。记住，我们有多个点光源，所以我们只需要为它创建一个循环。所以，在绑定顶点数组和解绑它之后，我们需要添加
    `glBindVertexArray( lightVAO );`。
- en: 'Then we''ll add our `for` loop and pass the initializing parameters for the
    loop as `GLuint i = 0; i < 4; i++`, and to the loop we''re going to add, `model
    = glm:: mat4();`.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加我们的 `for` 循环，并将循环的初始化参数作为 `GLuint i = 0; i < 4; i++` 传递，并将 `model = glm::mat4();`
    添加到循环中。
- en: Then, on the other line, we are going to add `model = glm::translate();`, and
    this is just going to be translating the `model`. And then the vector for this
    is going to be `pointLightPositions`. Then pass the iterator `[i]`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在另一行，我们将添加 `model = glm::translate();`，这只是为了将 `model` 平移。然后这个向量的值将是 `pointLightPositions`。然后传递迭代器
    `[i]`。
- en: And now, we're just going to make the cube a little bit smaller, as we have
    done before. So we'll add `model = glm::scale();`, and to that we are going to
    pass `model` and `glm::vec3( 0.2f )`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只是将立方体稍微缩小一点，就像我们之前做的那样。所以我们将添加 `model = glm::scale();`，并将 `model` 和 `glm::vec3(
    0.2f )` 传递给它。
- en: 'On the other line we''re going to add `glUniformMatrix4fv()` because it''s
    a 4x4 matrix, and to that, we need to pass `modelLoc, 1, GL_FALSE;`, and `glm::
    value_ptr()`; to this, we are going to pass the model.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一行我们将添加 `glUniformMatrix4fv()`，因为它是一个 4x4 矩阵，我们需要传递 `modelLoc, 1, GL_FALSE;`
    和 `glm::value_ptr()`；到这个，我们将传递模型。
- en: 'Then we''ll add `glDrawArrays();`, and to that, we''ll pass `GL_TRIANGLES`,
    `0`, and `36`. And, after this for loop is completed on the other line, we need
    to unbind the vertex array as `glBindVertexArray( 0 );`. Take a look at the following
    code to understand the description:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加 `glDrawArrays();`，并传递 `GL_TRIANGLES`、`0` 和 `36`。在这段循环在另一行完成后，我们需要取消绑定顶点数组，即
    `glBindVertexArray( 0 );`。请查看以下代码以了解描述：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We are now all set to run the code. Save the updated code and compile it. You
    will get output similar to the following on your screen:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好运行代码了。保存更新后的代码并编译它。你将在屏幕上看到类似以下输出：
- en: '![](img/a2be11c3-3074-454d-89c2-dd74675550ff.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2be11c3-3074-454d-89c2-dd74675550ff.png)'
- en: 'We''ve got our multiple light sources, four of which are point lights and one
    of which is just a regular lamp. We recommend you figure out which ones are the
    point lights and which one is the lamp. As you can see, we have the spotlight
    that is attached, and we also have the general directional light. You might be
    thinking that it''s hard to tell which light is which, and generally, in the real
    world, it''s hard to tell too. Light has an effect on everything around us, and
    this is how it works in the game. Now if you try to go further away from the object,
    our spotlight really isn''t affecting the cube anymore, but it''s still there,
    as seen in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多个光源，其中四个是点光源，一个是普通的灯。我们建议你找出哪些是点光源，哪个是灯。正如你所见，我们有一个附加的聚光灯，还有一个普通的方向光。你可能认为很难分辨出哪种光是什么，在现实世界中通常也是如此。光会影响我们周围的一切，这就是它在游戏中的工作方式。现在，如果你试图远离物体，我们的聚光灯实际上已经不再影响立方体了，但它仍然在那里，如下面的截图所示：
- en: '![](img/123d6f1e-1ae6-46d3-bee8-3c5e1ceb4146.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/123d6f1e-1ae6-46d3-bee8-3c5e1ceb4146.png)'
- en: 'As we get closer to it, it starts affecting the object:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越接近它，它开始影响物体：
- en: '![](img/8fa7a101-2e88-4f72-b9a4-8780bc8d8f4a.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fa7a101-2e88-4f72-b9a4-8780bc8d8f4a.png)'
- en: It's cool to see how the effect is combined with the other light sources. So,
    that's it for combining directional lights, point lights, and spotlights. There
    is a lot of lengthy code in this chapter, but a lot of it we've already done before.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很酷，可以看到效果是如何与其他光源结合的。所以，这就是结合方向光、点光和聚光灯的方法。这一章有很多冗长的代码，但我们已经在前面的章节中做了很多。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed about the different types of light sources such
    as directional, point and spotlight. Then we learned how to combine these light
    source and the lighting effects to generate realistic lighting in our game world.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了不同类型的光源，如方向光、点光和聚光灯。然后我们学习了如何将这些光源和光照效果结合起来，以在我们的游戏世界中生成逼真的光照。
- en: In the next chapter, we'll discuss about the cube maps and we'll learn to generate
    the skybox using for our game.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论立方体贴图，并学习如何为我们游戏生成天空盒。
