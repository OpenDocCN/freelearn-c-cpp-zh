- en: Network Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: In [Chapter 6](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml), *Pipes, First-In
    First-Out (FIFO), Message Queues, and Shared Memory*, we learned different IPC
    techniques to allow processes running on the same machine to communicate with
    each other. In this chapter, (which compliments what was covered in [Chapter 6](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml),
    *Pipes, First-In First-Out (FIFO), Message Queues, and Shared Memory*, you'll
    learn how two processes running on two different computers can achieve the same
    result. The topics presented here are the foundation of how the internet today
    works. You'll learn, hands-on, the difference between connection-oriented and
    connectionless-oriented communication, the characteristics that define an endpoint,
    and finally two recipes that will teach you how to use TCP/IP and UDP/IP.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml)中，*管道，先进先出（FIFO），消息队列和共享内存*，我们学习了不同的IPC技术，允许在同一台机器上运行的进程相互通信。在本章中（补充了[第6章](b108b814-40ec-42d5-ab03-cc3cd6400641.xhtml)中的内容），你将学习两个在两台不同计算机上运行的进程如何实现相同的结果。这里介绍的主题是当今互联网运行的基础。你将亲自学习连接导向和无连接导向通信之间的区别，定义端点的特征，最后学习两个使用TCP/IP和UDP/IP的方法。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning the basics of connection-oriented communication
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习连接导向通信的基础知识
- en: Learning the basics of connectionless-oriented communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习无连接导向通信的基础知识
- en: Learning what a communication endpoint is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习通信端点是什么
- en: Learning to use TCP/IP to communicate with processes on another machine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用TCP/IP与另一台机器上的进程进行通信
- en: Learning to use UDP/IP to communicate with processes on another machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用UDP/IP与另一台机器上的进程进行通信
- en: Dealing with endianness
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字节序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to let you start using the programs immediately, we've set up a Docker
    image that has all the tools and libraries that we'll need throughout the book.
    It is based on Ubuntu 19.04.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你立即开始使用这些程序，我们设置了一个Docker镜像，其中包含了本书中需要的所有工具和库。它基于Ubuntu 19.04。
- en: 'In order to set it up, follow these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，按照以下步骤进行：
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](https://www.docker.com/)下载并安装Docker Engine。
- en: Pull the image from Docker Hub using `docker pull kasperondocker/system_programming_cookbook:latest`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker pull kasperondocker/system_programming_cookbook:latest`从Docker Hub拉取镜像。
- en: The image should now be available. Type in `docker images` to view the image.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像现在应该可用。输入`docker images`查看镜像。
- en: You should have at least `kasperondocker/system_programming_cookbook` now.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该至少有`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell by using `docker run -it --cap-add
    sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`运行Docker镜像与交互式shell。
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs, listed by chapter.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。使用`root@39a5a8934370/# cd /BOOK/`获取按章节列出的所有程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow **GNU Project Debugger** (**GDB**)
    in the Docker container to set breakpoints, which by default Docker does not allow.
    To launch a second shell on the same container, run the `docker exec -it container-name
    bash` command. You can get the container name from the `docker ps` command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cap-add sys_ptrace`参数是为了允许Docker容器中的**GNU项目调试器**（**GDB**）设置断点，Docker默认情况下不允许。要在同一个容器上启动第二个shell，运行`docker
    exec -it container-name bash`命令。你可以从`docker ps`命令中获取容器名称。'
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 免责声明：C++20标准已经在二月底的布拉格会议上得到了WG21的批准（也就是在技术上已经最终确定）。这意味着本书使用的GCC编译器版本8.3.0不包括（或者对C++20的新功能支持非常有限）。因此，Docker镜像不包括C++20的代码。GCC将最新功能的开发保留在分支中（你必须使用适当的标志，例如`-std=c++2a`）；因此，鼓励你自己尝试。所以，克隆并探索GCC的合同和模块分支，玩得开心。
- en: Learning the basics of connection-oriented communication
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习连接导向通信的基础知识
- en: If you sit at your desk and you browse the internet, it is likely that you're
    using a connection-oriented type of communication. When you request a page via
    HTTP or HTTPS, under the hood, a connection between your machine and the server
    you're trying to contact is established before the actual communication takes
    place. The *de facto* standard for internet communications is the **Transport
    Control Protocol** (**TCP**). In this chapter, you will learn what it is and why
    it is important, and you will also learn (on the command line) what a connection
    is.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坐在桌前浏览互联网，很可能你正在使用连接导向类型的通信。当你通过HTTP或HTTPS请求页面时，在实际通信发生之前，你的机器和你试图联系的服务器之间建立了连接。互联网通信的*事实上*标准是**传输控制协议**（**TCP**）。在本章中，你将学习它是什么，为什么它很重要，你还将学习（在命令行上）什么是连接。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this section, we''ll explore use of the command line to understand what
    happens when we make a connection with a remote machine. Specifically, we''ll
    learn the internal aspects of a TCP/IP connection. Let''s go through the following
    steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用命令行来了解当我们与远程机器建立连接时发生了什么。具体来说，我们将学习TCP/IP连接的内部方面。让我们按照以下步骤进行：
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker镜像运行后，打开一个shell，输入以下命令，然后按*Enter*键：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open another shell, type the following command, and press *Enter*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个shell，输入以下命令，然后按*Enter*：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first shell, you''ll see an output similar to the following:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个shell中，您将看到类似以下的输出：
- en: '![](img/5a48ff38-c4f1-4ee1-934f-f71da9db0be1.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a48ff38-c4f1-4ee1-934f-f71da9db0be1.png)'
- en: All of this might seem cryptic, but it's actually simple. The next section will
    explain to you, in great detail, how it works.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些可能看起来很神秘，但实际上很简单。下一节将详细解释它是如何工作的。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A connection-oriented communication is based on the assumption that a connection
    between two entities is made. In this section, we'll explore what exactly a connection
    is.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基于连接的通信是基于两个实体之间建立连接的假设。在本节中，我们将探讨连接到底是什么。
- en: The first step uses `tcpdump` (`man tcpdump`), which is a command-line tool
    that dumps all the traffic on a network. In our case, it writes all the TCP traffic
    from port `80` on the standard output showing the data in a hexadecimal representation.
    Once *Enter* is pressed, `tcpdump` will switch to listening mode.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步使用`tcpdump`（`man tcpdump`），这是一个在网络上转储所有流量的命令行工具。在我们的情况下，它将把端口`80`上的所有TCP流量写入标准输出，并以十六进制表示形式显示数据。按下*Enter*后，`tcpdump`将切换到监听模式。
- en: The second step uses `telnet` to establish a connection with a remote service
    running on port `80` at `amazon.com`. Once *Enter* is pressed, after a few moments,
    the connection will be established.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步使用`telnet`与在`amazon.com`端口`80`上运行的远程服务建立连接。按下*Enter*后，几秒钟后，连接将建立。
- en: 'In the third step, we see the output of the connection between the local machine
    through the `telnet` (or `man telnet` , to give it its full name) service and
    a remote machine at `amazon.com` (translated to the IP). The first thing to keep
    in mind is that a connection in TCP is a three-step process called a **three-way
    handshake**. The client sends *SYN*, the server replies *SYN+ACK*, and the client
    replies *ACK*. The following diagram represents the TCP header specification:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们看到了本地机器通过`telnet`（或`man telnet`，以其全名命名）服务与`amazon.com`（转换为IP）之间的连接输出。要记住的第一件事是，TCP中的连接是一个称为**三次握手**的三步过程。客户端发送*SYN*，服务器回复*SYN+ACK*，客户端回复*ACK*。以下图表示了TCP头规范：
- en: '![](img/a90e0c44-8eec-4e64-b1de-f2cb80cfd1ff.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a90e0c44-8eec-4e64-b1de-f2cb80cfd1ff.png)'
- en: 'What data do the client and the server exchange in the *SYN* | *SYN+ACK* |
    *ACK* phase in order to successfully establish a connection? Let''s go through
    it, step by step:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在*SYN* | *SYN+ACK* | *ACK*阶段，客户端和服务器交换了什么数据以成功建立连接？让我们一步一步地来看：
- en: 'The client sends *SYN* to the server (`amazon.com`):'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器(`amazon.com`)发送*SYN*：
- en: '![](img/40eb9534-c86f-4741-9bba-1c40ba1910ca.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40eb9534-c86f-4741-9bba-1c40ba1910ca.png)'
- en: Let's start from `0xe8f4` and `0x050` (the Ethernet header is before this, which
    is beyond the scope of this chapter). As we can see from the preceding TCP header,
    the first two bytes represent the source port (`0xe8f4` = `59636`) and the second
    two bytes represent the destination port (`0x0050` = `80`). In the next four bytes, the
    client sets a random number called the sequence number: `0x9bd0 | 0xb114`. The
    acknowledgment number is not set in this case. In order to mark this packet as
    *SYN*, the client has to set the *SYN *bit to `1` and indeed the value of the
    next two bytes is `0xa002`, which in binary is `1010 0000 0000 0010`. We can see
    that the second to last bit is set to 1 (compare this with the TCP header, as
    seen in the preceding screenshot).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`0xe8f4`和`0x050`开始（以太网头部在此之前，这超出了本章的范围）。从前面的TCP头部中可以看到，前两个字节表示源端口（`0xe8f4`
    = `59636`），接下来的两个字节表示目标端口（`0x0050` = `80`）。在接下来的四个字节中，客户端设置了一个称为序列号的随机数：`0x9bd0
    | 0xb114`。在这种情况下，确认号没有设置。为了将此数据包标记为*SYN*，客户端必须将*SYN*位设置为`1`，确实下两个字节的值为`0xa002`，在二进制中为`1010
    0000 0000 0010`。我们可以看到倒数第二位设置为1（将其与前面的屏幕截图中的TCP头部进行比较）。
- en: 'The server sends *SYN+ACK* to the client:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器向客户端发送*SYN+ACK*：
- en: '![](img/e30cbd29-ea67-47fc-92dd-8dad6943277d.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e30cbd29-ea67-47fc-92dd-8dad6943277d.png)'
- en: 'The server, which has received the *SYN* from the client, has to respond with
    *SYN+ACK*. Leaving out the first 16 bytes, the Ethernet header, we can see the
    following content: 2 bytes represent the source port (`0x0050` = `80`) and the
    second 2 bytes represent the destination port (`0xe8f4` = `59636`). Then we start
    to see a few interesting things: the server puts a random number in the sequence
    number, which in this case is `0x1afe = | 0x5e1e`, and in the acknowledgment number,
    the sequence number received from the client + 1 = `0x9bd0 | 0xb11**5**`. As we
    learned, the server must set the flag to *SYN+ACK* and, according to the TCP header,
    the specification is correctly implemented by setting the two bytes to `0x7012`
    = `0111 0000 000**1** 00**1**0`. The highlighted parts are *ACK* and *SYN* respectively.
    The TCP packet is then sent back to the client.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器收到来自客户端的*SYN*后，必须以*SYN+ACK*进行响应。忽略前16个字节，即以太网头部，我们可以看到以下内容：2个字节表示源端口（`0x0050`
    = `80`），第二个2个字节表示目标端口（`0xe8f4` = `59636`）。然后我们开始看到一些有趣的东西：服务器在序列号中放入一个随机数，这种情况下是`0x1afe
    = | 0x5e1e`，在确认号中，是从客户端接收的序列号+1 = `0x9bd0 | 0xb11**5**`。正如我们所学的，服务器必须将标志设置为*SYN+ACK*，根据TCP头规范，通过将两个字节设置为`0x7012`
    = `0111 0000 000**1** 00**1**0`来正确实现。高亮部分分别是*ACK*和*SYN*。然后TCP数据包被发送回客户端。
- en: 'The client sends *ACK* to the server (`amazon.com`):'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器(`amazon.com`)发送*ACK*：
- en: '![](img/626f2c3e-2a7b-4b54-9cb3-a082f5324929.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/626f2c3e-2a7b-4b54-9cb3-a082f5324929.png)'
- en: The last step of the three-way handshake algorithm is the reception of the ACK
    packet sent by the client to the server. The message consists of two bytes representing
    the source port (`0xe8f4` = `59636`) and the destination port (`0x050` = `80`);
    the sequence number this time contains the value the server originally received from
    the client, `0x9bd0 | 0xb115`; and the acknowledgement number contains the random
    value received from the server + 1: `0x1afe = | 0x5e1**f**`. Finally, the *ACK*
    is sent by setting the value `0x5010` = `0101 0000 000**1** 0000` (the part of
    the value that is highlighted is the *ACK*; compare it to the previous TCP header
    picture).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 三次握手算法的最后一步是接收客户端发送的ACK数据包。消息由两个字节组成，表示源端口（`0xe8f4` = `59636`）和目标端口（`0x050`
    = `80`）；这次的序列号包含了服务器最初从客户端接收到的值，`0x9bd0 | 0xb115`；确认号包含了服务器接收到的随机值加1：`0x1afe =
    | 0x5e1**f**`。最后，通过设置值`0x5010` = `0101 0000 000**1** 0000`来发送*ACK*（被突出显示的部分是*ACK*；与之前的TCP头部图片进行比较）。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The protocol you have learned so far is described in the RFC 793 ([https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)).
    If the internet works, it is because all the network vendors, device driver implementations,
    and many programs implement this RFC (and other related standards) perfectly.
    The TCP RFC defines much more than what we've learned in this recipe, which was
    strictly focused on the connectivity. It defines the flow control (through the
    concept of a window) and reliability (through the concept of a sequence number
    and the *ACK* in it).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您学到的协议在RFC 793中有描述（[https://tools.ietf.org/html/rfc793](https://tools.ietf.org/html/rfc793)）。如果互联网正常工作，那是因为所有网络供应商、设备驱动程序实现和许多程序都完美地实现了这个RFC（以及其他相关标准）。TCP
    RFC定义的远不止我们在这个配方中学到的内容，它严格关注于连接性。它定义了流量控制（通过窗口的概念）和可靠性（通过序列号和其中的*ACK*的概念）。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning to use TCP/IP to communicate with processes on another machine* recipe shows
    programmatically how two processes on two machines can communicate. The connection
    part is hidden in a system call, as we'll see.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习使用TCP/IP与另一台机器上的进程进行通信*的配方显示了两台机器上的两个进程如何进行通信。连接部分隐藏在系统调用中，我们将看到。'
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, for a refresher on processes and threads.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)，*处理进程和线程*，了解有关进程和线程的内容。'
- en: Learning the basics of connectionless-oriented communication
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习无连接导向通信的基础知识
- en: In the *Learning the basics of connection-oriented communication* recipe, we
    learned that a connection-oriented communication with flow control is reliable. To
    make two processes in communication, we must establish a connection first. This
    obviously comes at a cost in terms of performance, which we cannot always pay—for
    example, when you watch an online movie, the available bandwidth might not be
    enough to support all the features that TCP takes with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*学习面向连接的通信的基础知识*配方中，我们学到了面向连接的通信与流量控制是可靠的。要使两个进程进行通信，我们必须首先建立连接。这显然会在性能方面产生成本，我们并不总是能够支付——例如，当您观看在线电影时，可用的带宽可能不足以支持TCP所带来的所有功能。
- en: In this case, it is likely that the underlying communication mechanism is connectionless.
    The *de facto* standard protocol for connectionless communication is the **User
    Data Protocol** (**UDP**), which is on the same logical level as TCP. In this
    recipe, we'll learn what UDP looks like on the command line.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，底层通信机制很可能是无连接的。*事实上*的标准无连接通信协议是**用户数据协议**（**UDP**），它与TCP处于相同的逻辑级别。在这个配方中，我们将学习命令行上的UDP是什么样子。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll use `tcpdump` and `netcast` (`nc`) to analyze a connectionless
    link over UDP:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`tcpdump`和`netcast`（`nc`）来分析UDP上的无连接链路：
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker镜像正在运行时，打开一个shell，输入以下命令，然后按*Enter*：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s open another shell, type the following command, and press *Enter*:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开另一个shell，输入以下命令，然后按*Enter*：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On the first shell, you''ll see an output similar to the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个shell中，您将看到类似以下的输出：
- en: '![](img/e671d1fb-07cb-4c1a-a09e-5187ebd9b0e9.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e671d1fb-07cb-4c1a-a09e-5187ebd9b0e9.png)'
- en: This seems cryptic too, but it's actually simple. The next section will explain
    the steps in great detail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎也很神秘，但实际上很简单。下一节将详细解释这些步骤。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In a UDP connection, there is no concept of connection. In this case, a packet
    is sent to a receiver. There is no flow control and the link is not reliable.
    The UDP header is indeed very simple, as you can see from the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在UDP连接中，没有连接的概念。在这种情况下，数据包被发送到接收器。没有流量控制，连接也不可靠。正如您从下图中看到的那样，UDP头确实非常简单：
- en: '![](img/a29b794e-a166-43b2-96de-6adc69398346.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a29b794e-a166-43b2-96de-6adc69398346.png)'
- en: '*Step 1* uses `tcpdump` to listen on port `45998` using the `UDP` protocol
    on the `loopback` interface (`-i lo`) by printing the data of each packet in `hex`
    and `ASCII`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*使用`tcpdump`监听端口`45998`，在`loopback`接口上使用`UDP`协议（`-i lo`），通过打印每个数据包的十六进制和ASCII数据来查看数据。'
- en: '*Step 2* uses the `netcast` command `nc` (`man nc`) to send a UDP packet (`-u`)
    containing the string `welcome` to the localhost.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*使用`netcast`命令`nc`（`man nc`）发送一个包含字符串`welcome`的UDP数据包（`-u`）到本地主机。'
- en: '*Step 3* shows the details of the UDP protocol. We can see that the source
    port (randomly picked by the sender) is `0xdb255` = `56101` and the destination
    port is correctly set to `0xb3ae` = `459998`. Next, we set the length to `0x000f`
    = `15` and the checksum to `0xfe22` = `65058`. The length is `15` bytes, as `7`
    bytes is the length of the data received and `8` bytes is the length of the UDP
    header (source port + destination port + length + checksum).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 3* 显示了 UDP 协议的详细信息。我们可以看到源端口（由发送方随机选择）为 `0xdb255` = `56101`，目标端口正确设置为 `0xb3ae`
    = `459998`。接下来，我们将长度设置为 `0x000f` = `15`，校验和设置为 `0xfe22` = `65058`。长度为 `15` 字节，因为
    `7` 字节是接收到的数据长度，`8` 字节是 UDP 标头的长度（源端口 + 目标端口 + 长度 + 校验和）。'
- en: No retransmission, no control flow, no connection. A connectionless link is
    really just a message the sender sends to the receiver knowing that it might not
    receive it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有重传，没有控制流，没有连接。无连接的链接实际上只是发送方发送给接收方的消息，知道可能不会收到它。
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've talked about connections and we've seen the concepts of the source port
    and destination port in the UDP header. The address of the sender and receiver
    is stored somewhere else, in the **IP** (short for **Internet** **Protocol**)
    layer, logically right below the UDP layer. The IP layer has the information of
    the sender and receiver addresses (the IP addresses), which are used to route
    the UDP packet from the client to the server and vice versa.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了连接，并在 UDP 标头中看到了源端口和目标端口的概念。发送方和接收方的地址存储在其他地方，即在 **IP**（**Internet**
    **Protocol** 的缩写）层中，逻辑上位于 UDP 层的下方。IP 层具有发送方和接收方地址（IP 地址）的信息，用于将 UDP 数据包从客户端路由到服务器，反之亦然。
- en: The UDP is elaborately defined in RFC 768, at [https://www.ietf.org/rfc/rfc768.txt](https://www.ietf.org/rfc/rfc768.txt).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 在 RFC 768 中有详细定义，网址为 [https://www.ietf.org/rfc/rfc768.txt](https://www.ietf.org/rfc/rfc768.txt)。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting Started with
    System Programming*, for a review of the pipe of commands'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml)，*开始系统编程*，回顾命令管道'
- en: The *Learning the basics of a connectionless-oriented communication* recipe for
    a comparison with the TCP protocol
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无连接导向通信基础* 配方，与 TCP 协议进行比较'
- en: Learning what a communication endpoint is
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解通信端点是什么
- en: When two entities communicate with each other they essentially exchange information.
    In order to make this happen, each entity must be clear as to where to send the
    information. From the programmer's point of view, each entity involved in the
    communication must have a clear endpoint. This recipe will teach you what an endpoint
    is and will show, on the command line, how to identify them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个实体相互通信时，它们本质上是交换信息。为了使这种情况发生，每个实体都必须清楚地知道将信息发送到何处。从程序员的角度来看，参与通信的每个实体都必须有一个清晰的端点。本配方将教你端点是什么，并将在命令行上显示如何识别它们。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll be using the `netstat` command-line utility to inspect
    and learn what an endpoint is:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `netstat` 命令行实用程序来检查和了解端点是什么：
- en: 'With the Docker image running, open a shell, type the following command, and
    press *Enter*:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运行 Docker 镜像的 shell，输入以下命令，然后按 *Enter*：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open a second shell and type this command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个 shell 并输入以下命令：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next section will explain these two steps.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释这两个步骤。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In *step 1*, we used the `telnet` utility to connect to the local machine,
    with the `amazon.com` remote host on port `443` (HTTP). The output of this command
    is the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们使用 `telnet` 实用程序连接到本地机器，与 `amazon.com` 远程主机的端口 `443`（HTTP）连接。此命令的输出如下：
- en: '![](img/62b15a2f-680e-4b7e-af13-a937e1bc9e0a.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62b15a2f-680e-4b7e-af13-a937e1bc9e0a.png)'
- en: It is waiting for commands, which we won't send, as what we really care about
    is the connection.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它正在等待命令，我们不会发送命令，因为我们真正关心的是连接。
- en: 'In *step 2*, we want to know the details of the connection that we established between
    our local machine (`localhost`) and the remote host (`amazon.com` port `443`).
    For this, we executed the command in *step 2*. The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 2* 中，我们想要了解我们在本地机器（`localhost`）和远程主机（`amazon.com` 端口 `443`）之间建立的连接的详细信息。为此，我们执行了
    *步骤 2* 中的命令。输出如下：
- en: '![](img/027525f4-3f59-4b27-b3c6-6ef58b76f388.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/027525f4-3f59-4b27-b3c6-6ef58b76f388.png)'
- en: 'What information can we retrieve from the output in this command line? Well,
    we can retrieve a few very useful pieces of information. Let''s go through what
    we can learn from the preceding screenshot, reading the code from left to right:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从此命令行的输出中检索到什么信息？嗯，我们可以检索到一些非常有用的信息。让我们看看我们可以从前面的屏幕截图中学到什么，从左到右阅读代码：
- en: '`tcp` represents the type of connection. It is a connection-oriented connection,
    which means that the local and remote hosts went through the three-way handshake
    that we saw in the *Learning the basics of connection-oriented communication*
    recipe.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp` 代表连接的类型。这是一个面向连接的连接，这意味着本地和远程主机经历了我们在 *学习面向连接的通信基础* 配方中看到的三次握手。'
- en: '`Recv-Q` is a queue containing the data to be processed by the current process
    on localhost.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Recv-Q` 是一个队列，其中包含本地主机上当前进程要处理的数据。'
- en: '`Send-Q` is a queue containing the data to be sent by the current process on
    localhost to a remote process.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Send-Q` 是一个队列，其中包含本地主机上当前进程要发送到远程进程的数据。'
- en: '`Local Address` is a combination of the IP address and port number, which really
    represent the first endpoint of our communication, the local endpoint. Such an
    endpoint is often called, from a programming perspective, `Socket`, which is an
    integer representing, in its essence, `IP` and `PORT`. In this case, the endpoint
    is `172.17.0.2:40850`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Local Address` 是 IP 地址和端口号的组合，实际上代表了我们通信的第一个端点，即本地端点。从编程的角度来看，这样的端点通常被称为 `Socket`，它是一个代表
    `IP` 和 `PORT` 的整数。在这种情况下，端点是 `172.17.0.2:40850`。'
- en: '`Foreign Address`, like the `Local Address`, is a combination of `IP` and `PORT`,
    and represents the remote endpoint, in this case, `176.32.98.166:443`. Note that
    `443` is a well-known port and represents the `https` service.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Foreign Address`，就像`Local Address`一样，是`IP`和`PORT`的组合，代表远程端点，在这种情况下是`176.32.98.166:443`。请注意，`443`是一个众所周知的端口，代表`https`服务。'
- en: '`State` represents the state of the connection between the two endpoints, `ESTABLISHED` in
    this case.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`代表两个端点之间连接的状态，在这种情况下是`ESTABLISHED`。'
- en: '`PID/Program Name`, or in our case, `65`/`telnet`, represents the local process
    using both the endpoints to communicate with the remote host.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID/Program Name`，或者在我们的例子中，`65`/`telnet`，代表使用两个端点与远程主机通信的本地进程。'
- en: When programmers talk about `socket`, they are talking about `IP` and `PORT`
    for each endpoint of the communication. As we've seen, Linux makes it easy to
    analyze both the endpoints of the communication and the process they are attached
    to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序员谈论`socket`时，他们是在谈论通信的每个端点的`IP`和`PORT`。正如我们所见，Linux使得分析通信的两个端点和它们附加的进程变得容易。
- en: One important aspect to highlight is that a `PORT` represents a service. In
    our example, the local process telnet was connected with the remote host using
    IP `176.32.98.166` at port `80`, where we know an HTTP daemon is running. But
    how do we know the port number for a specific service? There is a list of well-known
    ports ([https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)) maintained
    by the **IANA** (short for the **Internet Assigned Numbers Authority**), which
    assigns `PORTS` to services. For example, the HTTPS service is expected to run
    at `PORT 443`, the `sftp` (short for **Secure File Transfer Protocol**) runs at
    `PORT 22`, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的方面要强调的是，`PORT`代表一个服务。在我们的例子中，本地进程telnet使用IP `176.32.98.166`连接到端口`80`的远程主机，我们知道那里运行着一个HTTP守护程序。但是我们如何知道特定服务的端口号？有一个由**IANA**（即**Internet
    Assigned Numbers Authority**的缩写）维护的众所周知的端口列表（[https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)）。例如，预期HTTPS服务在`PORT
    443`上运行，`sftp`（即**Secure File Transfer Protocol**的缩写）在`PORT 22`上运行，依此类推。
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `port` info is a 16 bits unsigned integer value (that is, `unsigned int`),
    is maintained by the IANA ([https://www.iana.org/](https://www.iana.org/)) and
    is split into these ranges:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`port`信息是一个16位无符号整数值（即`unsigned int`），由IANA（[https://www.iana.org/](https://www.iana.org/)）维护，并分为以下范围：'
- en: '0-1023: Well-known ports. Ports that are well known, for example, HTTP, SFTP,
    and HTTPS.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-1023：众所周知的端口。众所周知的端口，例如HTTP、SFTP和HTTPS。
- en: '1024-49151: Registered ports. Ports that organizations can ask to register
    for their purpose.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1024-49151：注册端口。组织可以要求为其目的注册的端口。
- en: 49152-65535: Dynamic, private, or ephemeral ports. Free to be used.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 49152-65535：动态、私有或临时端口。可自由使用。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning the basics of connectionless-oriented communication* recipe to
    learn how communication without a connection works
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习基本的无连接导向通信*的方法来学习无连接通信的工作原理'
- en: The *Learning the basics of connection-oriented communication* recipe to learn
    how communication with a connection works
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习基本的连接导向通信*的方法来学习带有连接的通信工作原理'
- en: The *Learning to use TCP/IP to communicate with processes on another machine* recipe
    to learn how to develop a connection-oriented program
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习使用TCP/IP与另一台机器上的进程通信*的方法来学习如何开发连接导向的程序'
- en: The *Learning to use UDP/IP to communicate with processes on another machine*
    recipe to learn how to develop a connectionless-oriented program
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习使用UDP/IP与另一台机器上的进程通信*的方法来学习如何开发无连接导向的程序'
- en: Learning to use TCP/IP to communicate with processes on another machine
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用TCP/IP与另一台机器上的进程通信
- en: This recipe will show you how to connect two programs by using a connection-oriented
    mechanism. This recipe will use TCP/IP, which is the *de facto* standard on the
    internet. So far, we've learned that TCP/IP is a reliable form of communication,
    and its connection is made in three phases. It is time now to write a program
    to learn how to make two programs communicate with each other. Although the language
    used will be C++, the communication part will be written using the Linux system
    calls, as it is not supported by the C++ standard library.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将向您展示如何使用连接导向的机制连接两个程序。这个方法将使用TCP/IP，这是互联网上的*事实*标准。到目前为止，我们已经了解到TCP/IP是一种可靠的通信形式，它的连接分为三个阶段。现在是时候编写一个程序来学习如何使两个程序相互通信了。尽管使用的语言将是C++，但通信部分将使用Linux系统调用编写，因为它不受C++标准库支持。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll develop two programs, a client and a server. The server will start and
    `listen` on a specific port that is ready to accept an incoming connection. The
    client will start and connect to the server identified by an IP and a port number:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发两个程序，一个客户端和一个服务器。服务器将启动并在准备接受传入连接的特定端口上进行`listen`。客户端将启动并连接到由IP和端口号标识的服务器：
- en: 'With the Docker image running, open a shell and create a new file, `clientTCP.cpp`.
    Let''s add some headers and constants that we''ll need later:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运行的Docker镜像，打开一个shell并创建一个新文件`clientTCP.cpp`。让我们添加一些稍后需要的头文件和常量：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s start writing the `main` method now. We start by initializing `socket`
    and getting the information that is related to the server:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在开始编写`main`方法。我们首先初始化`socket`并获取与服务器相关的信息：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we want to `connect` to the server, but we need the correct information,
    namely the `serv_addr`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要连接到服务器，但我们需要正确的信息，即`serv_addr`：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The server will reply with a connection `ack`, so we call the `read` method:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将回复连接`ack`，因此我们调用`read`方法：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now send the data to the server by just calling the `write` system call:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用`write`系统调用将数据发送到服务器：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, let''s go through the cleaning part, where we have to close the socket:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们进行清理部分，关闭socket：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now develop the server program. In a second shell, we create the `serverTCP.cpp` file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们开发服务器程序。在第二个shell中，我们创建`serverTCP.cpp`文件：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On a second shell, first of all, we need a `socket` descriptor that will identify
    our connection:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个shell中，首先，我们需要一个将标识我们连接的`socket`描述符：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have to bind the `socket` to a port and `serv_addr` on the local machine:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将`socket`绑定到本地机器上的一个端口和`serv_addr`：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we have to wait for and accept any incoming connection:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须等待并接受任何传入的连接：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As soon as we get a connection, we log who connected to the standard output (using
    their IP and port) and send a confirmation *ACK*:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们建立了连接，我们就会记录谁连接到标准输出（使用他们的IP和端口），并发送一个确认*ACK*：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We made the connection (a three-way handshake, remember?), so now we can read
    any data coming from the client:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们建立了连接（三次握手，记得吗？），所以现在我们可以读取来自客户端的任何数据：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we close both the sockets:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭两个套接字：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've written quite a lot of code, so it is time to explain how all of this
    works.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经写了相当多的代码，现在是时候解释所有这些是如何工作的了。
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Both the client and the server have a very common algorithm, which we have
    to describe in order for you to understand and generalize this concept. The client''s
    algorithm is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都有一个非常常见的算法，我们必须描述它以便你理解和概括这个概念。客户端的算法如下：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `connect()` and `receive()` are blocking calls (that is, the calling program
    will wait for their completion). The `connect` phrase specifically initiates the
    three-way handshake that we described in detail in the *Learning the basics of
    connection-oriented communication* recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`connect()`和`receive()`都是阻塞调用（即，调用程序将等待它们的完成）。`connect`短语特别启动了我们在*学习面向连接的通信基础*中详细描述的三次握手。
- en: 'The server''s algorithm is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的算法如下：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `accept` and `receive` are blocking the call. Let's now analyze in detail
    both the client's and server's code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`accept`和`receive`都是阻塞调用。现在让我们详细分析客户端和服务器的代码。
- en: 'The client code analysis is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码分析如下：
- en: The first step just contains the necessary includes that are needed to correctly
    use the four APIs that we listed in the preceding client's algorithm section.
    Just note that the constants, in pure C++ style, are not defined using the `#define`
    macro, but by using `constexpr`. The difference is that the latter is managed
    by the compiler, whereas the former is managed by the preprocessor. As a rule
    of thumb, you should always try to rely on the compiler.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步只包含了在前面客户端算法部分列出的四个API的必要包含文件。请注意，常量采用纯C++风格，不是使用`#define`宏定义，而是使用`constexpr`。区别在于后者由编译器管理，而前者由预处理器管理。作为一个经验法则，你应该总是尽量依赖编译器。
- en: The `socket()` system call creates a socket descriptor that we named `sockfd`,
    which will be used to send and receive information to/from the server. The two
    parameters indicate that the socket will be a TCP (`SOCK_STREAM`)/IP (`PF_INET`)
    socket type. Once we have a valid socket descriptor, and before calling the `connect`
    method, we need to know the server's details; for this, we use the `gethostbyname()` method,
    which, given a string like `localhost`, will return a pointer to `struct hostent
    *` with information about the host.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket()`系统调用创建了一个套接字描述符，我们将其命名为`sockfd`，它将用于与服务器发送和接收信息。这两个参数表示套接字将是一个TCP（`SOCK_STREAM`）/IP（`PF_INET`）套接字类型。一旦我们有了一个有效的套接字描述符，并在调用`connect`方法之前，我们需要知道服务器的详细信息；为此，我们使用`gethostbyname()`方法，它会返回一个指向`struct
    hostent *`的指针，其中包含有关主机的信息，给定一个类似`localhost`的字符串。'
- en: We're now ready to call the `connect()` method, which will take care of the
    three-way-handshake process. By looking at its prototype (`man connect`), we can
    see that as well as the socket, it needs a `const struct sockaddr *address` struct,
    so we need to copy the respective information into it and pass it to the `connect()`;
    that's why we use the `utility` method `bcopy()` (`bzero()` is just a helper method
    to reset the `sockaddr` struct before using it).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备调用`connect()`方法，它将负责三次握手过程。通过查看它的原型（`man connect`），我们可以看到它除了套接字外，还需要一个`const
    struct sockaddr *address`结构，因此我们需要将相应的信息复制到其中，并将其传递给`connect()`；这就是为什么我们使用`utility`方法`bcopy()`（`bzero()`只是在使用之前重置`sockaddr`结构的辅助方法）。
- en: We are now ready to send and receive data. Once the connection is established,
    the server will send an acknowledgment message (`You are connected!`). Have you
    noticed that we're using the `read()` method to receive information from the server
    through a socket? This is the beauty and simplicity of programming in a Linux
    environment. One method can support multiple interfaces—indeed, we're able to
    work with the same method to read files, receive data with sockets, and do many
    other things.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经准备好发送和接收数据。一旦建立了连接，服务器将发送一个确认消息（`You are connected!`）。你是否注意到我们正在使用`read()`方法通过套接字从服务器接收信息？这就是在Linux环境中编程的美和简单之处。一个方法可以支持多个接口——事实上，我们能够使用相同的方法来读取文件、通过套接字接收数据，以及做许多其他事情。
- en: We can send a message to the server. The method used is, as you may have guessed,
    `write()`. We pass `socket` to it, which identifies the connection, the message
    we want the server to receive, and the length of the message so that Linux will
    know when to stop reading from the buffer.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以向服务器发送消息。使用的方法是，你可能已经猜到了，是`write()`。我们将`socket`传递给它，它标识了连接，我们希望服务器接收的消息，以及消息的长度，这样Linux就知道何时停止从缓冲区中读取。
- en: As usual, we need to close, clean, and free any resource used. In this case,
    we have to close the socket by just using the `close()` method, passing the socket
    descriptor.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，我们需要关闭、清理和释放任何使用的资源。在这种情况下，我们需要通过使用`close()`方法关闭套接字描述符。
- en: 'The server code analysis is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器代码分析如下：
- en: We use a similar code to the one we used for the client, but include some headers
    and three defined constants, which we will use and explain later.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了类似于客户端的代码，但包含了一些头文件和三个定义的常量，我们稍后会使用和解释。
- en: We have to define a socket descriptor by calling the `socket()` API. Note that
    there is no difference between the client and the server. We just need a socket
    that is able to manage a TCP/IP type of a connection.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须通过调用`socket()` API来定义套接字描述符。请注意，客户端和服务器之间没有区别。我们只需要一个能够管理TCP/IP类型连接的套接字。
- en: We have to bind the socket descriptor created in the previous step to the network
    interface and port it on the local machine. We do this with the `bind()` method,
    which assigns an address (`const struct sockaddr *address` passed as the second
    parameter) to the socket descriptor passed as the first parameter. The call to
    the `setsockopt()` method is just to avoid the bind error, `Address already in
    use`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将在上一步中创建的套接字描述符绑定到本地机器上的网络接口和端口。我们使用`bind()`方法来实现这一点，它将地址（作为第二个参数传递的`const
    struct sockaddr *address`）分配给作为第一个参数传递的套接字描述符。调用`setsockopt()`方法只是为了避免绑定错误，即`地址已在使用`。
- en: 'We start listening for any incoming connection by calling the `listen()` API.
    The `listen()` system call is pretty simple: it gets the `socket` descriptor on
    which we are listening and the maximum number of connections to keep in the queue
    of pending connections, which in our case we set to `5`. Then we call `accept()`
    on the socket descriptor. The `accept` method is a blocking call: it means that
    it''ll block until a new incoming connection is available, and then it''ll return an
    integer representing the socket descriptor. The `cli_addr` structure is filled
    in with the connection''s information, which we use to log who connected (`IP`
    and `port`).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`listen()` API开始监听任何传入的连接。`listen()`系统调用非常简单：它获取我们正在监听的`socket`描述符以及保持在挂起连接队列中的最大连接数，我们在这种情况下设置为`5`。然后我们在套接字描述符上调用`accept()`。`accept`方法是一个阻塞调用：这意味着它将阻塞，直到有一个新的传入连接可用，然后它将返回一个表示套接字描述符的整数。`cli_addr`结构被填充了连接的信息，我们用它来记录谁连接了（`IP`和`端口`）。
- en: This step is just a logical continuation of step 10. Once the server accepts
    a connection, we log on the standard output who connected (in terms of their `IP` and `port`).
    We do this by querying the information that was filled in the `cli_addr` struct
    by the `accept` method.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步只是步骤10的逻辑延续。一旦服务器接受连接，我们就会在标准输出上记录谁连接了（以他们的`IP`和`端口`表示）。我们通过查询`accept`方法填充的`cli_addr`结构中的信息来实现这一点。
- en: In this step, we receive information from the connected client through the `read()`
    system call. We pass in the input, the socket descriptor of the incoming connection,
    the `buffer` where the data will be saved, and the maximum length of the data
    that we want to read (`MAX_BUFFER-1`).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们通过`read()`系统调用从连接的客户端接收信息。我们传入输入，传入连接的套接字描述符，`buffer`（数据将被保存在其中），以及我们想要读取的数据的最大长度（`MAX_BUFFER-1`）。
- en: We then clean up and free any eventual resource that is used and/or allocated.
    In this case, we have to close the two sockets' descriptors that were used (`sockfd`
    for the server and `incomingSock` for the incoming connection).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后清理和释放任何可能使用和/或分配的资源。在这种情况下，我们必须关闭使用的两个套接字描述符（服务器的`sockfd`和传入连接的`incomingSock`）。
- en: 'By building and running both the server and the client (in this order), we
    get the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按照这个顺序构建和运行服务器和客户端，我们得到以下输出：
- en: 'The server build and output are as follows:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器构建和输出如下：
- en: '![](img/6cb2d008-c48a-4572-95b5-c20f08518f1a.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cb2d008-c48a-4572-95b5-c20f08518f1a.png)'
- en: 'The client build and output are as follows:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端构建和输出如下：
- en: '![](img/56ff6da3-b779-438d-95c5-6821223a16ac.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56ff6da3-b779-438d-95c5-6821223a16ac.png)'
- en: This proves what we learned in this recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们在这个教程中学到的东西。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'How can we improve the server application to manage multiple concurrent incoming
    connections? The server''s algorithm that we implemented is sequential; after
    `listen()`, we just wait on `accept()` until the end, where we close the connections.
    You should go through the following steps as an exercise:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进服务器应用程序以管理多个并发的传入连接？我们实现的服务器算法是顺序的；在`listen()`之后，我们只是等待`accept()`，直到最后关闭连接。您应该按照以下步骤进行练习：
- en: Run an infinite loop over `accept()` so that a server is always up and ready
    to serve clients.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限循环运行`accept()`，以便服务器始终处于准备好为客户端提供服务的状态。
- en: Spin off a new thread for each accepted connection. You can do this by using
    `std::thread` or `std::async`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个接受的连接启动一个新线程。您可以使用`std::thread`或`std::async`来实现这一点。
- en: Another important practice is to pay attention to the data that the client and
    server exchange with each other. Usually, they agree to use a protocol that they
    both know. It might be a web server, which in that case will involve the exchange
    of HTML, files, resources, and so on between the client and the server. If it
    is a supervision and control system, it might be a protocol defined by a specific
    standard.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的实践是注意客户端和服务器之间交换的数据。通常，它们同意使用彼此都知道的协议。它可能是一个Web服务器，在这种情况下将涉及客户端和服务器之间的HTML、文件、资源等的交换。如果是监控和控制系统，可能是由特定标准定义的协议。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, to refresh your memory as to how processes and threads work to improve
    the server solution described here'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)，*处理进程和线程*，以便回顾一下进程和线程是如何工作的，以改进这里描述的服务器解决方案'
- en: The *Learning the basics of connection-oriented communication* recipe to learn
    how the TCP connection works
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习面向连接的通信基础*这个教程来学习TCP连接的工作原理'
- en: The *Learning what a communication endpoint* recipe to learn what an endpoint
    is and how it is related to a socket
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习通信端点是什么*这个教程来学习端点是什么以及它与套接字的关系'
- en: Learning to use UDP/IP to communicate with processes on another machine
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用UDP/IP与另一台机器上的进程进行通信
- en: When a process communicates with another, reliability is not always the main
    criterion to use when deciding the communication mechanism. Sometimes, what we
    need is fast communication without the burden or the connection, flow control,
    and all the other controls that the TCP protocol implemented to make it reliable.
    This is the case for video streaming, **Voice over Internet Protocol** (**VoIP**)
    calls, and many others. In this recipe, we'll learn how to program UDP code that
    makes two (or more) processes communicate with each other.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程与另一个进程通信时，可靠性并不总是决定通信机制的主要标准。有时，我们需要的是快速通信，而不需要TCP协议实现的连接、流量控制和所有其他控制，以使其可靠。这适用于视频流，**互联网语音**（**VoIP**）通话等情况。在这个示例中，我们将学习如何编写UDP代码，使两个（或更多）进程相互通信。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到的...
- en: 'We''ll develop two programs, a client and a server. The server will start,
    bind the socket to a local address, and then will just receive data from the clients:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发两个程序，一个客户端和一个服务器。服务器将启动，将套接字绑定到本地地址，然后只接收来自客户端的数据：
- en: 'With the Docker image running, open a shell, create a new file, `serverUDP.cpp`,
    and add some headers and constants that we''ll need later:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用运行的Docker镜像，打开一个shell，创建一个新文件`serverUDP.cpp`，并添加一些以后会用到的标头和常量：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `main` function, we have to instantiate the socket of the `DATAGRAM `type and
    set the option to reuse the address each time the server is rerun:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们必须实例化`数据报`类型的套接字，并设置选项以在每次重新运行服务器时重用地址：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have to bind the socket we''ve created with a local address:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将创建的套接字与本地地址绑定：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''re now ready to receive packets from the clients, this time using the `recvfrom`
    API:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备从客户端接收数据包，这次使用`recvfrom` API：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We want to send an *ACK* message to the client with the `sendto` API:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想用`sendto` API向客户端发送一个*ACK*消息：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we can close the socket:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以关闭套接字：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s now create the client program. On another shell, create the file `clientUDP.cpp`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建客户端程序。在另一个shell中，创建文件`clientUDP.cpp`：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have to instantiate the socket of the `datagram` type:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须实例化`数据报`类型的套接字：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We need to get the host information to be able to identify the server that
    we want to send the packet to, and we do this by calling the `gethostbyname` API:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要获取主机信息，以便能够识别要发送数据包的服务器，我们通过调用`gethostbyname` API来实现：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s copy the host information into the `sockaddr_in` struct to identify
    the server:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主机信息复制到`sockaddr_in`结构中以识别服务器：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can finally send a message to the server using the socket descriptor, the
    message from the user, and the server address:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用套接字描述符、用户的消息和服务器地址向服务器发送消息：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We know that the server will reply with an *ACK*, so let''s receive it with
    the `recvfrom` method:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道服务器会用*ACK*回复，所以让我们用`recvfrom`方法接收它：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, as usual, we take care of closing and freeing all the structures used:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像往常一样，我们要负责关闭和释放所有使用的结构：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's go deeper into the code and see how all of this works.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，看看所有这些是如何工作的。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the *Learning to use TCP/IP to communicate with processes on another machine*
    recipe, we learned the client''s and server''s TCP algorithms. The UDP algorithms
    are simpler and, as you can see, the connection part is missing:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在*学习使用TCP/IP与另一台机器上的进程通信*的示例中，我们学习了客户端和服务器的TCP算法。UDP算法更简单，正如你所看到的，连接部分是缺失的：
- en: '**The UDP client''s algorithm:**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP客户端的算法：**'
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**The UDP server''s algorithm:**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP服务器的算法：**'
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note how much simpler they are now—for example, the server, in this case, does
    not `listen` for and `accept` incoming connections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看它们现在简单多了——例如，服务器在这种情况下不会`listen`和`accept`传入的连接。
- en: 'The server-side code analysis is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的代码分析如下：
- en: We just defined some headers and two constants that represent the port where
    the server will expose the service (`SERVER_PORT`) and the maximum size of the
    data (`MAX_BUFFER`).
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一些标头和两个常量，表示服务器将公开服务的端口（`SERVER_PORT`）和数据的最大大小（`MAX_BUFFER`）。
- en: In this step, we defined the socket (`sockfd`), just like we did in the TCP
    code, but this time we use the `SOCK_DGRAM` (UDP) type. In order to avoid the
    bind issue of `Address already in use`, we set the option to allow the socket
    to reuse the address.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们定义了套接字（`sockfd`），就像我们在TCP代码中所做的那样，但这次我们使用了`SOCK_DGRAM`（UDP）类型。为了避免`Address
    already in use`的绑定问题，我们设置了选项以允许套接字重用地址。
- en: Next is the `bind` call. It accepts the parameters of `int socket`, `const struct
    sockaddr *address`, and `socklen_t address_len`, which are basically the socket,
    the address to bind the socket at, and the length of the address struct. In the
    `address` variable, we specify that we are listening to all the available local
    network interfaces (`INADDR_ANY`) and we will use the Internet Protocol version
    4 (`AF_INET`).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`bind`调用。它接受`int socket`、`const struct sockaddr *address`和`socklen_t address_len`这些参数，基本上是套接字、要绑定套接字的地址和地址结构的长度。在`address`变量中，我们指定我们正在监听所有可用的本地网络接口（`INADDR_ANY`），并且我们将使用Internet协议版本4（`AF_INET`）。
- en: We can now start receiving data by using the `recvfrom` method. The method takes
    as input the socket descriptor (`sockfd`), the buffer to store the data in (`buffer`),
    the maximum size of data we can store, a flag (`0`, in this case) to set the specific
    properties on the received message, the address of the sender of the datagram
    (`cli_addr`), and the length of the address (`len`). These last two parameters
    are returned filled in, so we'd know who sent the datagram.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过使用`recvfrom`方法开始接收数据。该方法以套接字描述符（`sockfd`）、用于存储数据的缓冲区（`buffer`）、我们可以存储的数据的最大大小、一个标志（在本例中为`0`）来设置接收消息的特定属性、数据报发送者的地址（`cli_addr`）和地址的长度（`len`）作为输入。最后两个参数将被填充返回，这样我们就知道是谁发送了数据报。
- en: We can now send an *ACK* to the client. We use the `sendto` method. As the UDP
    is a connectionless protocol, we don't have a client connected, so we need to
    pass this information somehow. We do this by passing the `cli_addr`, which is returned
    filled in by the `recvfrom` method along with the length (`len`), to the `sendto`
    method. Other than this, we need to pass the socket descriptor (`sockfd`), the
    buffer to send (`outBuffer`), the length of the buffer (`outBuffer.length()`),
    and the flag (`0`, in this case).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以向客户端发送一个*ACK*。我们使用`sendto`方法。由于UDP是一种无连接协议，我们没有连接的客户端，所以我们需要以某种方式传递这些信息。我们通过将`cli_addr`和长度(`len`)传递给`sendto`方法来实现这一点，这些信息是由`recvfrom`方法返回的。除此之外，我们还需要传递套接字描述符(`sockfd`)、要发送的缓冲区(`outBuffer`)、缓冲区的长度(`outBuffer.length()`)和标志(`0`)。
- en: Then, we just need to clean up at the end of the program. We have to close the
    socket descriptor with the `close()` method.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需要在程序结束时进行清理。我们必须使用`close()`方法关闭套接字描述符。
- en: 'The client-side code analysis is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码分析如下：
- en: In this step, we find the same headers that we have on the `serverUDP.cpp` source
    file with `SERVER_PORT` and `MAX_BUFFER`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，我们找到了与`serverUDP.cpp`源文件中的`SERVER_PORT`和`MAX_BUFFER`相同的头文件。
- en: We have to define the socket of the datagram type by calling the `socket` method,
    passing again as input `AF_INET` and `SOCK_DGRAM`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须通过调用`socket`方法来定义数据报类型的套接字，再次将`AF_INET`和`SOCK_DGRAM`作为输入。
- en: As we need to know who to send the datagram to, the client application takes
    as input on the command line the address of the server (for example, `localhost`)
    that we pass as input to the `gethostbyname`, which returns the host address (`server`).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要知道将数据报发送给谁，客户端应用程序在命令行上输入服务器的地址(例如`localhost`)，我们将其作为输入传递给`gethostbyname`，它返回主机地址(`server`)。
- en: We use the `server` variable to fill the `serv_addr` structure used to identify
    the address of the server that we want to send the datagram to (`serv_addr.sin_addr.s_addr`),
    the port (`serv_addr.sin_port`), and the family of the protocol (`AF_INET`).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`server`变量填充`serv_addr`结构，用于标识我们要发送数据报的服务器的地址(`serv_addr.sin_addr.s_addr`)、端口(`serv_addr.sin_port`)和协议的族(`AF_INET`)。
- en: We can then use the `sendto` method to send the user message to the server by
    passing the parameters of `sockfd`, `outBuffer`, `MAX_BUFFER`, the flag set to `0`,
    the address of the server `serv_addr`, and its length (`len`). Again, the client
    does not know at this stage who is the receiver of the message as it is not connected
    to anybody, and that is why the `serv_addr` structure must be properly filled
    in so that it contains a valid address.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`sendto`方法通过传递`sockfd`、`outBuffer`、`MAX_BUFFER`、设置为`0`的标志、服务器的地址`serv_addr`及其长度(`len`)来将用户消息发送到服务器。同样，在这个阶段，客户端不知道消息的接收者是谁，因为它没有连接到任何人，这就是为什么必须正确填写`serv_addr`结构，以便它包含有效的地址。
- en: We know that the server will send back an application *ACK*, so we have to receive
    it. We call the `recvfrom` method that is passing the socket descriptor (`sockfd`)
    as input, the buffer to store the returned data in (`buffer`), the maximum size
    of the data we can get, and a flag set to `0`. `recvfrom` returns the address
    of the sender of the message with its length, which we store in `cli_addr` and
    `len` respectively.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道服务器会发送一个应用程序*ACK*，所以我们必须接收它。我们调用`recvfrom`方法，将套接字描述符(`sockfd`)作为输入，用于存储返回数据的缓冲区(`buffer`)，我们可以获取的数据的最大大小，以及设置为`0`的标志。`recvfrom`返回消息发送者的地址及其长度，我们分别将其存储在`cli_addr`和`len`中。
- en: Let's run the server, then the client.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先运行服务器，然后再运行客户端。
- en: 'Run the server as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行服务器：
- en: '![](img/bdbbe7da-c8df-4197-912f-246ee3751e02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdbbe7da-c8df-4197-912f-246ee3751e02.png)'
- en: 'Run the client as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式运行客户端：
- en: '![](img/9a159ad9-61df-452c-91f6-b98de7bbfb2a.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a159ad9-61df-452c-91f6-b98de7bbfb2a.png)'
- en: This shows how UDP works.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了UDP的工作原理。
- en: There's more...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another way of using the UDP protocol, as a type of connectionless communication,
    is to send a datagram in multicast or broadcast format. A multicast is a communication
    technique that is used to send the same datagram to multiple hosts. The code does
    not change; we just have to set the IP of the multicast group so it knows where
    to send the message. It is a convenient and efficient way of communicating *one-to-many*,
    saving a lot of bandwidth. Another alternative is to send a datagram in broadcast
    mode. We have to set the IP of the receiver with a subnet mask in the form of `172.30.255.255`.
    The message will be sent to all the hosts in the same subnet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用UDP协议的方式是以多播或广播格式发送数据报，作为一种无连接通信类型。多播是一种通信技术，用于将相同的数据报发送到多个主机。代码不会改变；我们只需设置多播组的IP，以便它知道要发送消息的位置。这是一种方便和高效的*一对多*通信方式，可以节省大量带宽。另一种选择是以广播模式发送数据报。我们必须使用子网掩码设置接收者的IP，形式为`172.30.255.255`。消息将发送到同一子网中的所有主机。
- en: 'You''re invited to improve the server code by going through the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您通过以下步骤改进服务器代码：
- en: Set up an infinite loop over `recvfrom()` so that you always have a server up
    and ready to serve clients.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个无限循环，使用`recvfrom()`，以便您始终有一个准备好为客户端提供服务的服务器。
- en: Start a new thread for each accepted connection. You can do this by using `std::thread` or `std::async`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个接受的连接启动一个新线程。您可以使用`std::thread`或`std::async`来实现这一点。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*, to refresh how processes and threads work to improve the server
    solution described here'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)，*处理进程和线程*，以了解如何处理进程和线程以改进此处描述的服务器解决方案'
- en: The *Learning the basics of connectionless-oriented communication* recipe to
    learn how the UDP connection works
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习基于无连接的通信的基础知识*，以了解UDP连接的工作原理'
- en: The *Learning what a communication endpoint is* recipe to learn what an endpoint
    is and how it is related to a socket
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习通信端点是什么*，以了解端点是什么，以及它与套接字的关系'
- en: Dealing with endianness
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理字节序
- en: Writing code at system level might mean dealing with different processors' architectures.
    When doing this, there is one thing that programmers had to take care of by themselves
    before C++20, which is **endianness**. Endianness refers to the byte's order in
    the binary representation of a number. Fortunately, the last C++ standard helps
    us to enter endian information at compile time. This recipe will teach you how
    to be aware of endianness and write code that can run on both little- and big-endian
    architecture.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统级编写代码可能意味着处理不同处理器的架构。在这样做时，程序员在C++20之前必须自行处理的一件事是**字节序**。字节序指的是数字的二进制表示中字节的顺序。幸运的是，最新的C++标准帮助我们在编译时输入端口信息。本文将教你如何*意识到*字节序，并编写可以在小端和大端架构上运行的代码。
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll develop a program that will query the machine at compile time, so that
    we can make a conscious decision as to how to deal with numbers represented in
    different formats:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个程序，该程序将在编译时查询机器，以便我们可以有意识地决定如何处理以不同格式表示的数字：
- en: 'We need to include the `<bit>` headers file; then we can use the `std::endian`
    enumerations:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含`<bit>`头文件；然后我们可以使用`std::endian`枚举：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let's take a closer look at what implications this has in the next section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节更仔细地看看这对我们有什么影响。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Big-endian and little-endian are the two dominant types of data representation.
    The little-endian ordering format means that the least significant byte (also
    known as **LSB**) is placed in the highest address, while in a big-endian machine,
    the most significant byte (also known as **MSB**) is placed in the lowest address.
    An example of the representation for the hexadecimal value `0x1234` would be as
    follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 大端和小端是两种主要的数据表示类型。小端排序格式意味着最不重要的字节（也称为LSB）放在最高地址，而在大端机器上，最重要的字节（也称为MSB）放在最低地址。对于十六进制值0x1234的表示，示例如下：
- en: '|  | **Address** | **Address+1 (byte)** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|  | **地址** | **地址+1（字节）** |'
- en: '| **Big-endian** | `12` | `34` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **大端** | `12` | `34` |'
- en: '| **Little-endian** | `34` | `12` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **小端** | `34` | `12` |'
- en: 'The main goal of the code snippet in step 1 is to answer the question: how
    do I know what machine architecture I''m dealing with? The new C++20 enumeration
    `std::endian` helps us solve this problem perfectly. How? Well, first in terms
    of *endian awareness.* Having `std::endian` as part of the C++ standard library
    helps the programmer to query at any time the endian architecture of the underlying
    machine. Second: for shared resources, the two programs have to agree on a format
    (like the TCP protocol does, that is, sending the info in *network order*) so
    that the reader (or receiver, if exchanging data over the network) can make the
    appropriate conversions.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1中代码片段的主要目标是回答一个问题：我如何知道我正在处理什么样的机器架构？新的C++20枚举`std::endian`完美地帮助我们解决了这个问题。怎么做？首先是从*端口意识*方面。将`std::endian`作为C++标准库的一部分，帮助程序员随时查询底层机器的端口架构。其次：对于共享资源，两个程序必须就格式达成一致（就像TCP协议那样，即以*网络顺序*发送信息），以便读者（或者如果在网络上传输数据，则是接收者）可以进行适当的转换。
- en: 'The other question is: what should I do? There are two things that you should
    do: one is related to the application point of view and the second is related
    to networking. In both cases, if your application exchanges data with another
    machine with a different endian format (a file exchanged, or a filesystem shared,
    among many others) or sends data over the internet to a machine with a different
    architecture, then you have to make sure that your data will be understood. To
    do this, you can use the `hton`, `ntoh` macro and friends; this makes sure that
    the number is converted from host to network (for `hton`) and from network to
    host (for `ntoh`). We have to mention that most of the internet protocols use
    the big-endian format, which is the reason why, if you call `hton` from a big-endian
    machine, the function will not perform any conversion.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是：我应该怎么做？有两件事你应该做：一件与应用程序的观点有关，另一件与网络有关。在这两种情况下，如果你的应用程序与另一台具有不同字节序格式的机器交换数据（例如交换文件或共享文件系统等），或者将数据发送到具有不同架构的机器上，则必须确保你的数据能够被理解。为此，你可以使用`hton`、`ntoh`宏等；这可以确保数字从主机转换为网络（对于`hton`）和从网络转换为主机（对于`ntoh`）。我们必须提到，大多数互联网协议使用大端格式，这就是为什么如果你从大端机器调用`hton`，该函数将不执行任何转换的原因。
- en: The Intel x86 family and the AMD64 series of processors use all the little-endian
    format, while the IBM z/Architecture, Freescale, and all the Motorola 68000 heritage
    processers use the big-endian format. There are some processors (such as the PowerPC)
    that can switch endianness.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔x86系列和AMD64系列处理器都使用小端格式，而IBM z/Architecture、Freescale和所有Motorola 68000遗产处理器都使用大端格式。还有一些处理器（如PowerPC）可以切换字节序。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In theory, data representation formats other than little- and big-endian do
    exist. An example is the middle-endian format used by the Honeywell 316 minicomputer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，除了小端和大端之外，还存在其他数据表示格式。一个例子是Honeywell 316微型计算机使用的中端格式。
- en: See also
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning to use TCP/IP to communicate with processes on another machine*
    recipe
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习使用TCP/IP与另一台机器上的进程通信*配方'
- en: The *Learning to use UDP/IP to communicate with processes on another machine*
    recipe
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习使用UDP/IP与另一台机器上的进程通信*配方'
