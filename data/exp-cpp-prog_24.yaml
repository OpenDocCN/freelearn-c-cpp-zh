- en: Lambda Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖以下内容：
- en: Defining functions on the run using lambda expressions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式在运行时定义函数
- en: Adding polymorphy by wrapping lambdas into `std::function`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将 lambda 包装到`std::function`中添加多态性
- en: Composing functions by concatenation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过连接组合函数
- en: Creating complex predicates with logical conjunction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑连接创建复杂的谓词
- en: Calling multiple functions with the same input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的输入调用多个函数
- en: Implementing `transform_if` using `std::accumulate` and lambdas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::accumulate`和 lambda 实现`transform_if`
- en: Generating cartesian product pairs of any input at compile time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时生成任意输入的笛卡尔积对
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: One important new feature of C++11 was **lambda expressions**. In C++14 and
    C++17, the lambda expressions got some new additions, which have made them even
    more powerful. But first, what *is* a lambda expression?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 的一个重要新特性是**lambda 表达式**。在 C++14 和 C++17 中，lambda 表达式得到了一些新的添加，使它们变得更加强大。但首先，*什么是*
    lambda 表达式？
- en: 'Lambda expressions or lambda functions construct closures. A closure is a very
    generic term for *unnamed objects* that can be *called* like functions. In order
    to provide such a capability in C++, such an object must implement the `()` function
    calling operator, with or without parameters. Constructing such an object without
    lambda expressions before C++11 could still look like the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式或 lambda 函数构造闭包。闭包是一个非常通用的术语，用来描述可以像函数一样*调用*的*无名对象*。为了在 C++ 中提供这样的能力，这样的对象必须实现`()`函数调用运算符，可以带参数也可以不带参数。在
    C++11 之前，构造这样的对象而不使用 lambda 表达式可能看起来像下面这样：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Instances of the `name_greeter` struct obviously carry a string with them. Note
    that both this structure type and instance are not unnamed but lambda expressions
    can be, as we will see. In terms of closures, we would say they *capture* a string.
    When the example instance is called like a function without parameters, it prints
    `"Hello, John Doe"` because we constructed it with this name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_greeter` 结构的实例显然携带一个字符串。请注意，这种结构类型和实例都不是无名的，但是 lambda 表达式可以是无名的，我们将会看到。就闭包而言，我们会说它们*捕获*了一个字符串。当像没有参数的函数一样调用示例实例时，它会打印出`"Hello,
    John Doe"`，因为我们用这个名字构造了它。'
- en: 'Since C++11, it has become easier to create such closures:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 C++11 以来，创建这样的闭包变得更加容易：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's it. The whole struct, `name_greeter`, is replaced by a little `[] { /*
    do something */ }` construct, which might look a bit like magic at first, but
    the first section of this chapter will explain it thoroughly in all the possible
    variants.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。整个`name_greeter`结构都被一个小小的`[] { /* do something */ }`构造替代了，这一开始可能看起来有点像魔术，但本章的第一部分将会详细解释它的所有可能变体。
- en: Lambda expressions are of a great help to make code *generic* and *tidy*. They
    can be used as parameters for very generic algorithms in order to specialize what
    those do when processing specific user-defined types. They can also be used to
    wrap work packages together with data in order to be run in threads or just to
    save work and postpone the actual execution. Since C++11 came out, more and more
    libraries work with lambda expressions because they became a very natural thing
    in C++. Another use case is metaprogramming, because lambda expressions can also
    be evaluated at compile time. However, we are not going much into *that* direction,
    as this would quickly blast the scope of this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式对于使代码*通用*和*整洁*非常有帮助。它们可以作为参数用于非常通用的算法，以便在处理特定用户定义类型时专门化它们的操作。它们还可以用于将工作包装在一起，包括数据，以便在线程中运行，或者只是保存工作并推迟实际执行。自从
    C++11 推出以来，越来越多的库使用 lambda 表达式，因为它们在 C++ 中变得非常自然。另一个用例是元编程，因为 lambda 表达式也可以在编译时进行评估。然而，我们不会深入*那个*方向，因为这会很快超出本书的范围。
- en: This chapter does heavily rely on some *functional programming* patterns, which
    might look weird to novices or programmers who are already experienced but not
    with such patterns. If you see lambda expressions in the coming recipes that return
    lambda expressions, which again return lambda expressions, please don't feel frustrated
    or confused too quickly. We are pushing the boundaries a bit in order to prepare
    ourselves for modern C++, where functional programming patterns occur with increasing
    regularity. If some code in the following recipes looks a bit too complex, take
    your time to understand it. Once you got through this, complex lambda expressions
    in real projects in the wild will not confuse you any longer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在很大程度上依赖一些*函数式编程*模式，这可能对新手或已经有经验但不熟悉这些模式的程序员看起来很奇怪。如果在接下来的示例中看到返回 lambda 表达式的
    lambda 表达式，再返回 lambda 表达式，请不要感到沮丧或迷惑得太快。我们正在推动边界，以便为现代 C++ 做准备，在那里函数式编程模式越来越频繁地出现。如果在接下来的示例中看到一些代码看起来有点太复杂，请花点时间去理解它。一旦你通过了这一点，在野外的真实项目中复杂的
    lambda 表达式将不再让你困惑。
- en: Defining functions on the run using lambda expressions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式在运行时定义函数
- en: With lambda expressions, we can encapsulate code in order to call it later,
    and that also might be somewhere else because we can copy them around. We can
    also just encapsulate code to call it multiple times with slightly different parameters
    without having to implement a whole new function class for that task.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式，我们可以封装代码以便以后调用，而且也可能在其他地方调用，因为我们可以复制它们。我们也可以封装代码以便以稍微不同的参数多次调用它，而不必为此实现一个全新的函数类。
- en: The syntax of lambda expressions was really new in C++11, and it has slightly
    evolved with the next two standard versions until C++17\. In this section, we
    will see what lambda expressions can look like and what they mean.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式的语法在 C++11 中是全新的，它在接下来的两个标准版本中略有变化，直到 C++17。在本节中，我们将看到 lambda 表达式的样子和含义。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to write a little program in which we play with lambda expressions
    in order to get a feeling for them:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个小程序，其中我们将使用 lambda 表达式来熟悉它们：
- en: 'Lambda expressions do not need any library support, but we are going to write
    messages to the terminal and use strings, so we need the headers for this:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda表达式不需要任何库支持，但我们将向终端写入消息并使用字符串，因此我们需要这些头文件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Everything happens in the main function this time. We define two function objects
    that take no parameters and return integer constants with the values, `1` and
    `2`. Note that the return statement is surrounded by curly brackets `{}`, like
    it is in normal functions, and the `()` parentheses, which denote a parameterless
    function, are *optional,* we don''t provide them in the second lambda expression.
    But the `[]` brackets have to be there:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次所有的事情都发生在主函数中。我们定义了两个不带参数并返回整数常量值`1`和`2`的函数对象。请注意，返回语句被大括号`{}`包围，就像在普通函数中一样，`()`括号表示无参数函数，是*可选的*，我们在第二个lambda表达式中没有提供它们。但`[]`括号必须在那里：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can call both the function objects just by writing the names of the
    variables they are saved to and appending the parentheses. In this single line,
    they are indistinguishable from *normal functions* for the reader:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过只写它们保存的变量的名称并附加括号来调用这两个函数对象。在这一行中，它们对于读者来说与*普通函数*是无法区分的：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let''s forget about those and define another function object, which is
    called `plus` because it takes two parameters and returns their sum:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们忘记这些，定义另一个函数对象，称为`plus`，因为它接受两个参数并返回它们的和：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is also easy to use, just like any other binary function. As we defined
    its parameters to be of the `auto` type, it will work with anything that defines
    the plus operator `+`, just as strings do:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这也很容易使用，就像任何其他二进制函数一样。由于我们将其参数定义为`auto`类型，它将与定义了加法运算符`+`的任何东西一起工作，就像字符串一样：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We do not need to store a lambda expression in a variable in order to use it.
    We can also define it *in place* and then write the parameters in parentheses
    just behind it `(1, 2)`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要将lambda表达式存储在变量中才能使用它。我们也可以*就地*定义它，然后在其后面的括号中写入参数`(1, 2)`：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will define a closure that carries an integer counter value around
    with it. Whenever we call it, it increments its counter value and returns the
    new value. In order to tell it that it has an internal counter variable, we write
    `count = 0` within the brackets to tell it that there is a variable `count` initialized
    to the integer value `0`. In order to allow it to modify its own captured variables,
    we use the `mutable` keyword, as the compiler would not allow it otherwise:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个闭包，它携带一个整数计数器值。每当我们调用它时，它会增加其计数器值并返回新值。为了告诉它它有一个内部计数器变量，我们在括号内写入`count
    = 0`，告诉它有一个初始化为整数值`0`的变量`count`。为了允许它修改自己捕获的变量，我们使用`mutable`关键字，因为否则编译器不会允许它：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s call the function object five times and print the values it returns,
    so we can see the increasing number values later:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用函数对象五次并打印它返回的值，这样我们以后可以看到递增的数字值：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also take existing variables and capture them by *reference* instead
    of giving a closure its own value copy. This way, the captured variable can be
    incremented by the closure, but it is still accessible outside. In order to do
    so, we write `&a` between the brackets, where the `&` means that we store only
    a *reference* to the variable, not a *copy*:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以获取现有变量并通过*引用*捕获它们，而不是给闭包自己的值副本。这样，捕获的变量可以被闭包递增，但在外部仍然可以访问。为了这样做，我们在括号之间写入`&a`，其中`&`表示我们只存储对变量的*引用*，而不是*副本*：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If this works, then we should be able to call this function object multiple
    times, and then observe that it has really changed the value of variable `a`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这样做有效，那么我们应该能够多次调用这个函数对象，然后观察它是否真的改变了变量`a`的值：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last example is *currying*. Currying means that we take a function that
    can accept some parameters and store it in another function object, which accepts
    *fewer* parameters. In this case, we store the `plus` function and only accept
    *one* parameter, which we forward to the `plus` function. The other parameter
    is the value `10`, which we save in the function object. This way, we get a function,
    which we call `plus_ten` because it can add that value to the single parameter
    it accepts:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个例子是*柯里化*。柯里化意味着我们接受一些参数的函数并将其存储在另一个函数对象中，该函数对象接受*更少*的参数。在这种情况下，我们存储`plus`函数并只接受*一个*参数，然后将其转发给`plus`函数。另一个参数是值`10`，我们将其保存在函数对象中。这样，我们得到一个函数，我们称之为`plus_ten`，因为它可以将该值添加到它接受的单个参数中：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before compiling and running the program, go through the code again and try
    to foresee what it will print to the terminal. Then run it and check against the
    real output:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译和运行程序之前，再次检查代码并尝试预测它将打印到终端的内容。然后运行它并检查实际输出：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we just did was not overly complicated--we added numbers, and incremented
    and printed them. We even concatenated strings with a function object, which was
    implemented to add up numbers. But for anyone who didn't know lambda expression
    syntax yet, it might have looked confusing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的并不是过于复杂--我们添加了数字，并递增和打印它们。我们甚至用一个函数对象连接了字符串，该函数对象被实现为将数字相加。但是对于那些尚不了解lambda表达式语法的人来说，这可能看起来很困惑。
- en: 'So, let''s first have a look at all the lambda expression peculiarities:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们首先看一下所有lambda表达式的特点：
- en: '![](img/8d0ec8da-5bcf-4a59-945e-35aeb40addfe.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d0ec8da-5bcf-4a59-945e-35aeb40addfe.png)'
- en: We can usually omit most of this, which spares us some typing, in the average
    case. The shortest lambda expression possible is `[]{}`. It accepts no parameters,
    captures nothing, and essentially *does* nothing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们可以省略大部分内容，这样可以节省一些输入，平均情况下，最短的lambda表达式可能是`[]{}`。它不接受任何参数，不捕获任何内容，本质上*什么也不做*。
- en: So what does the rest mean?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么剩下的是什么意思？
- en: Capture list
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获列表
- en: 'Specifies if and what we capture. There are several forms to do so. There are
    two lazy variants:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指定我们是否以及捕获了什么。有几种形式可以这样做。还有两种懒惰的变体：
- en: If we write `[=] () {...}`, we capture every variable the closure references
    from outside by value, which means that the values are *copied*
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们写`[=] () {...}`，我们通过值捕获闭包从外部引用的每个变量，这意味着值会*被复制*
- en: Writing `[&] () {...}` means that everything the closure references outside
    is only captured by *reference*, which does *not* lead to a copy.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写`[&] () {...}`意味着闭包引用外部的一切都只通过*引用*捕获，不会导致复制。
- en: Of course, we can set the capturing settings for every variable individually.
    Writing `[a, &b] () {...}` means, that we capture the variable `a` by *value*,
    and `b` by *reference*. This is more typing work, but it's generally safer to
    be that verbose because we cannot accidentally capture something we don't want
    to capture from outside.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以为每个变量单独设置捕获设置。写`[a, &b] () {...}`意味着我们通过*值*捕获变量`a`，通过*引用*捕获`b`。这是更多的打字工作，但通常更安全，因为我们不能意外地从外部捕获我们不想捕获的东西。
- en: 'In the recipe, we defined a lambda expression as such: `[count=0] () {...}`.
    In this special case, we did not capture any variable from outside, but we defined
    a new one called `count`. Its type is deduced from the value we initialized it
    with, namely `0`, so it''s an `int`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将lambda表达式定义为`[count=0] () {...}`。在这种特殊情况下，我们没有从外部捕获任何变量，而是定义了一个名为`count`的新变量。它的类型是从我们初始化它的值中推断出来的，即`0`，所以它是一个`int`。
- en: 'It is also possible to capture some variables by value and some, by reference,
    as in:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过值和引用来捕获一些变量，如：
- en: '`[a, &b] () {...}`: This captures `a` by copy and `b` by reference.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a, &b] () {...}`：这通过复制捕获`a`，通过引用捕获`b`。'
- en: '`[&, a] () {...}`: This captures `a` by copy and any other used variable by
    reference.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[&, a] () {...}`：这通过复制捕获`a`，并通过引用捕获任何其他使用的变量。'
- en: '`[=, &b, i{22}, this] () {...}`: This captures `b` by reference, `this` by
    copy, initializes a new variable `i` with value `22`, and captures any other used
    variable by copy.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[=, &b, i{22}, this] () {...}`：这通过引用捕获`b`，通过复制捕获`this`，用值`22`初始化一个新变量`i`，并通过复制捕获任何其他使用的变量。'
- en: If you try to capture a member variable of an object, you cannot do this directly
    using `[member_a] () {...}`. Instead, you have to capture either `this` or `*this`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试捕获对象的成员变量，不能直接使用`[member_a] () {...}`。相反，必须捕获`this`或`*this`。
- en: mutable (optional)
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mutable（可选）
- en: If the function object should be able to *modify* the variables it captures
    by *copy* (`[=]`), it must be defined `mutable`. This includes calling non-const
    methods of captured objects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数对象应该能够*修改*它通过*复制*（`[=]`）捕获的变量，必须定义为`mutable`。这包括调用捕获对象的非const方法。
- en: constexpr (optional)
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: constexpr（可选）
- en: If we mark the lambda expression explicitly as `constexpr`, the compiler will
    *error* out if it does not satisfy the criteria of `constexpr` functions. The
    advantage of `constexpr` functions and lambda expressions is that the compiler
    can evaluate their result at compile time if they are called with compile-time
    constant parameters. This leads to less code in the binary later.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将lambda表达式明确标记为`constexpr`，如果不满足`constexpr`函数的条件，编译器将*报错*。`constexpr`函数和lambda表达式的优势在于，如果它们使用编译时常量参数调用，编译器可以在编译时评估它们的结果。这会导致后期二进制代码量减少。
- en: If we do not explicitly declare the lambda expression to be `constexpr` but
    it fits the requirements for that, it will be implicitly `constexpr` *anyway*.
    If we *want* a lambda expression to be `constexpr`, it helps to be explicit because
    the compiler will then help us by erroring out if we did it *wrong*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有明确声明lambda表达式为`constexpr`，但它符合要求，它将隐式地成为`constexpr`。如果我们*想要*一个lambda表达式是`constexpr`，最好是明确声明，因为编译器会在我们*错误*时帮助我们报错。
- en: exception attr (optional)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常属性（可选）
- en: This is the place to specify if the function object can throw exceptions when
    it's called and runs into an error case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指定函数对象在调用时是否能抛出异常并遇到错误情况的地方。
- en: return type (optional)
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回类型（可选）
- en: If we want to have ultimate control over the return type, we may not want the
    compiler to deduce it for us automatically. In such a case, we can just write
    `[] () -> Foo {}`, which tells the compiler that we will really always return
    the `Foo` type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对返回类型有终极控制，可能不希望编译器自动推断它。在这种情况下，我们可以写`[] () -> Foo {}`，告诉编译器我们确实总是返回`Foo`类型。
- en: Adding polymorphy by wrapping lambdas into std::function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过将lambda包装到std::function中添加多态性
- en: Let's say we want to write an observer function for some kind of value, which
    might change sometimes, which then notifies other objects; like a gas pressure
    indicator, or a stock price, or something similar. Whenever the value changes,
    a list of observer objects should be called, which then react their way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想为某种可能会偶尔改变的值编写一个观察者函数，然后通知其他对象；比如气压指示器，或者股票价格，或者类似的东西。每当值发生变化时，应该调用一个观察者对象列表，然后它们做出反应。
- en: In order to implement this, we could store a range of observer function objects
    in a vector, which all accept an `int` variable as the parameter, which represents
    the observed value. We do not know what these function objects do in particular
    when they are called with the new value, but we also don't care.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以在向量中存储一系列观察者函数对象，它们都接受一个`int`变量作为参数，表示观察到的值。我们不知道这些函数对象在调用新值时具体做什么，但我们也不在乎。
- en: Of what type will that vector of function objects be? The `std::vector<void
    (*)(int)>` type would be correct if we were capturing pointers to *functions*
    with signatures such as `void f(int);`. This would indeed also work with any lambda
    expression that does *not* capture any variables, such as `[](int x) {...}`. But
    a lambda expression that captures something is actually a *completely different
    type* compared with a normal function because it's not just a function pointer.
    It is an *object* that couples a certain amount of data with a function! Think
    of pre-C++11 times, when there were no lambdas. Classes and structs are the natural
    way of coupling data with functions, and if you change the data member types of
    a class, you get a completely different class type. It's just *natural* that a
    vector can't store completely different types using the same type name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数对象的向量将是什么类型？如果我们捕获具有`void f(int);`这样签名的*函数*的指针，那么`std::vector<void (*)(int)>`类型将是正确的。这实际上也适用于不捕获任何变量的任何lambda表达式，例如`[](int
    x) {...}`。但是，捕获某些东西的lambda表达式实际上是*完全不同的类型*，因为它不仅仅是一个函数指针。它是一个*对象*，它将一定数量的数据与一个函数耦合在一起！想想C++11之前的时代，当时没有lambda。类和结构是将数据与函数耦合在一起的自然方式，如果更改类的数据成员类型，您将得到完全不同的类类型。一个向量不能使用相同的类型名称存储完全不同的类型，这是*自然*的。
- en: Telling the user that it's only possible to save observer function objects that
    do not capture anything is bad because it limits the number of use cases very
    much. How can we allow the user to store any kind of function object, only constraining
    to the call interface, which takes a specific set of parameters that represent
    the value that shall be observed?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉用户只能保存不捕获任何东西的观察者函数对象是不好的，因为它非常限制了使用情况。我们如何允许用户存储任何类型的函数对象，只限制调用接口，该接口接受表示将被观察的值的特定参数集？
- en: This section shows how to solve this problem using `std::function`, which can
    act as a polymorphic wrapper around any lambda expression, no matter if and what
    it captures.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分展示了如何使用`std::function`解决这个问题，它可以作为任何lambda表达式的多态包装，无论它捕获了什么。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to create several lambda expressions that are
    completely different in regard to the variable types they capture but have the
    same function call signature in common. These will be saved in one vector using
    `std::function`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建几个完全不同的lambda表达式，它们在捕获的变量类型方面完全不同，但在共同的函数调用签名方面相同。这些将被保存在一个使用`std::function`的向量中：
- en: 'Let''s first do some necessary includes:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先做一些必要的包含：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We implement a little function that returns a lambda expression. It accepts
    a container and returns a function object that captures that container by reference.
    The function object itself accepts an integer parameter. Whenever that function
    object is fed with an integer, it will *append* that integer to the container
    it captures:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个小函数，它返回一个lambda表达式。它接受一个容器并返回一个捕获该容器的函数对象。函数对象本身接受一个整数参数。每当该函数对象被提供一个整数时，它将*追加*该整数到它捕获的容器中：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another little helper function will print whatever container instance we provide
    as a parameter:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个小的辅助函数将打印我们提供的任何容器实例：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the main function, we first instantiate a `deque`, a `list`, and a `vector`,
    which all store integers:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先实例化了一个`deque`，一个`list`和一个`vector`，它们都存储整数：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we use the `consumer` function with our container instances, `d`, `l`,
    and `v`: we produce consumer function objects for those and store them all in
    a `vector` instance. Then we have a vector that stores three function objects.
    These function objects each capture a reference to one of the container objects.
    These container objects are of completely different types and so are the function
    objects. Nevertheless, the vector holds instances of `std::function<void(int)>`.
    All the function objects are implicitly wrapped into such `std::function` objects,
    which are then stored in the vector:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`consumer`函数与我们的容器实例`d`，`l`和`v`：我们为这些产生消费者函数对象，并将它们全部存储在一个`vector`实例中。然后我们有一个存储三个函数对象的向量。这些函数对象每个都捕获一个对容器对象的引用。这些容器对象是完全不同的类型，所以函数对象也是完全不同的类型。尽管如此，向量持有`std::function<void(int)>`的实例。所有函数对象都被隐式地包装成这样的`std::function`对象，然后存储在向量中：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we feed 10 integer values to all the data structures by looping over the
    values and then looping over the consumer function objects, which we call with
    those values:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过循环遍历值并循环遍历消费者函数对象，将10个整数值输入所有数据结构，然后调用这些值：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All the three containers should now contain the same 10 number values. Let''s
    print their content:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有三个容器应该包含相同的10个数字值。让我们打印它们的内容：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Compiling and running the program yields the following output, which is just
    what we expect:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了以下输出，这正是我们所期望的：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The complicated part of this recipe is the following line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的复杂部分是以下行：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The objects `d`, `l`, and `v` are each wrapped into a `consumer(...)` call.
    This call returns function objects, which then each capture references to one
    of `d`, `l`, and `v`. Although these function objects all accept `int` values
    as parameters, the fact that they capture completely *different* variables also
    makes them completely different *types*. This is like trying to stuff variables
    of type `A`, `B`, and `C` into a vector, although these types have *nothing* in
    common.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`d`，`l`和`v`都被包装到一个`consumer(...)`调用中。这个调用返回函数对象，然后每个函数对象都捕获了`d`，`l`和`v`中的一个引用。尽管这些函数对象都接受`int`值作为参数，但它们捕获完全*不同*的变量的事实也使它们完全不同的*类型*。这就像试图将类型为`A`，`B`和`C`的变量塞进一个向量中，尽管这些类型*没有*任何共同之处。
- en: 'In order to fix this, we need to find a *common* type, which can store very
    *different* function objects, that is, `std::function`. An `std::function<void(int)>`
    object can store any function object or traditional function, which accepts an
    integer parameter and returns nothing. It decouples its type from the underlying
    function object type, using polymorphy. Consider we write something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要找到一个可以存储非常*不同*的函数对象的*通用*类型，也就是`std::function`。一个`std::function<void(int)>`对象可以存储任何接受整数参数并返回空的函数对象或传统函数。它使用多态性将其类型与底层函数对象类型分离。考虑我们写这样的东西：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the function object which is constructed from the lambda expression is
    wrapped into an `std::function` object, and whenever we call `f(123)`, this leads
    to a *virtual function call*, which is *redirected* to the actual function object
    inside it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，从lambda表达式构造的函数对象被包装到了一个`std::function`对象中，每当我们调用`f(123)`时，这将导致一个*虚函数调用*，它被*重定向*到其中的实际函数对象。
- en: While storing function objects, `std::function` instances apply some intelligence.
    If we capture more and more variables in a lambda expression, it must grow larger.
    If its size is not too large, `std::function` can store it within itself. If the
    size of the stored function object is too large, `std::function` will allocate
    a chunk of memory on the heap and then store the large function object there.
    This does not affect the functionality of our code, but we should know about this
    because this can impact the *performance* of our code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储函数对象时，`std::function`实例应用了一些智能。如果我们在lambda表达式中捕获了越来越多的变量，它必须变得更大。如果它的大小不是太大，`std::function`可以将其存储在自身内部。如果存储的函数对象的大小太大，`std::function`将在堆上分配一块内存，然后将大的函数对象存储在那里。这不会影响我们代码的功能，但我们应该知道这一点，因为这可能会影响我们代码的*性能*。
- en: A lot of novice programmers think or hope that `std::function<...>` actually
    expresses the *type* of a lambda expression. No, it doesn't. It is a polymorphic
    library helper, which is useful for wrapping lambda expressions and erasing their
    type differences.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 很多新手程序员认为或希望`std::function<...>`实际上表达了lambda表达式的*类型*。不，它不是。它是一个多态库助手，用于包装lambda表达式并擦除它们的类型差异。
- en: Composing functions by concatenation
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过连接组合函数
- en: 'A lot of tasks are not really worthy of being implemented in completely custom
    code. Let''s, for example, have a look on how a programmer might solve the task
    of finding out how many unique words a text contains with the programming language
    Haskell. The first line defines a function `unique_words` and the second one demonstrates
    its use with an example string:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很多任务实际上并不值得完全自定义代码来实现。例如，让我们看看程序员如何使用Haskell编程语言解决查找文本包含多少个唯一单词的任务。第一行定义了一个名为`unique_words`的函数，第二行演示了它在一个示例字符串中的使用：
- en: '![](img/d12ee785-b9b9-4b8e-9ba5-8c42f81de022.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d12ee785-b9b9-4b8e-9ba5-8c42f81de022.png)'
- en: Wow, that is short! Without explaining Haskell syntax too much, let's see what
    the code does. It defines the function called `unique_words`, which applies a
    series of functions to its input. It first maps all the characters from the input
    to lowercase with `map toLower`. This way, words like `FOO` and `foo` can be regarded
    as the *same* word. Then, the `words` function splits a sentence into individual
    words, as from `"foo bar baz"` to `["foo", "bar", "baz"]`. Next step is sorting
    the new list of words. This way, a word sequence such as `["a", "b", "a"]` becomes
    `["a", "a", "b"]`. Now, the `group` function takes over. It groups consecutive
    equal words into grouped lists, so `["a", "a", "b"]` becomes `[ ["a", "a"], ["b"]
    ]`. The job is now nearly done, as we now only need to count *how many* groups
    of equal words we got, which is exactly what the `length` function does.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这太简短了！不多解释Haskell语法，让我们看看代码做了什么。它定义了一个名为`unique_words`的函数，它将一系列函数应用于其输入。它首先使用`map
    toLower`将输入的所有字符映射为小写。这样，像`FOO`和`foo`这样的单词可以被视为*相同*的单词。然后，`words`函数将一个句子拆分为单独的单词，例如从`"foo
    bar baz"`到`["foo", "bar", "baz"]`。下一步是对新的单词列表进行排序。这样，一个单词序列，比如`["a", "b", "a"]`就变成了`["a",
    "a", "b"]`。现在，`group`函数接管了。它将连续相同的单词分组成分组列表，所以`["a", "a", "b"]`变成了`[ ["a", "a"],
    ["b"] ]`。工作现在几乎完成了，因为我们现在只需要计算有多少*组*相同的单词，这正是`length`函数所做的。
- en: This is a *wonderful* style of programming, as we can read *what* happens from
    right to left because we are just, kind of, describing a transformation pipeline.
    We don't need to care *how* the individual pieces are implemented (unless it turns
    out that they are slow or buggy).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种*奇妙*的编程风格，因为我们可以从右到左读取*发生*的事情，因为我们只是在描述一个转换管道。我们不需要关心个别部分是如何实现的（除非它们是慢的或有bug）。
- en: However, we are not here to praise Haskell but to improve our C++ skills. It
    is possible to work like this in C++ too. We will not completely reach the elegance
    of the Haskell example but we still have the fastest programming language there
    is. This example explains how to imitate *function concatenation* in C++ with
    lambda expressions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里不是为了赞扬Haskell，而是为了提高我们的C++技能。在C++中也可以像这样工作。我们可能无法完全达到Haskell示例的优雅，但我们仍然拥有最快的编程语言。这个示例解释了如何使用lambda表达式在C++中模拟*函数连接*。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we define some simple toy function objects and *concatenate*
    them, so we get a single function that applies the simple toy functions after
    each other to the input we give it. In order to do so, we write our own concatenation
    helper function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们定义了一些简单的玩具函数对象并*连接*它们，这样我们就得到了一个单一的函数，它将简单的玩具函数依次应用于我们给它的输入。为了做到这一点，我们编写了自己的连接辅助函数：
- en: 'First, we need some includes:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一些包含：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we implement the helper function, `concat`, which arbitrarily takes many
    parameters. These parameters will be functions, such as `f`, `g`, and `h`, and
    the result will be another function object that applies `f(g(h(...)))` on any
    input:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现了辅助函数`concat`，它任意地接受许多参数。这些参数将是函数，比如`f`、`g`和`h`，结果将是另一个函数对象，它对任何输入应用`f(g(h(...)))`：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, it gets a little complicated. When the user provides functions `f`, `g`,
    and `h`, we will evaluate this to `f( concat(g, h) )`, which again expands to
    `f( g( concat(h) ) )`, where the recursion aborts, so we get `f( g( h(...) ) )`.
    This chain of function calls representing the concatenation of these user functions
    is captured by a lambda expression, which can later take some parameters, `p`,
    and then forward them to `f(g(h(p)))`. This lambda expression is what we return.
    The `if constexpr` construct checks whether we are in a recursion step with more
    than one function to concatenate left:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它变得有点复杂。当用户提供函数`f`，`g`和`h`时，我们将将其评估为`f( concat(g, h) )`，这再次扩展为`f( g( concat(h)
    ) )`，递归中止，因此我们得到`f( g( h(...) ) )`。这些用户函数的连接链被lambda表达式捕获，稍后可以接受一些参数`p`，然后将它们转发到`f(g(h(p)))`。这个lambda表达式就是我们返回的内容。`if
    constexpr`构造检查我们是否处于递归步骤中，剩下的要连接的函数多于一个：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The other branch of the `if constexpr` construct is selected by the compiler
    if we are at the *end* of the recursion. In such a case, we just return the function,
    `t`, because it is the only parameter left:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if constexpr`构造的另一个分支是在递归的*末尾*时由编译器选择的。在这种情况下，我们只返回函数`t`，因为它是唯一剩下的参数：'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s use our cool new function concatenation helper with some functions
    we want to see concatenated. Let''s begin with the `main` function, where we define
    two cheap simple function objects:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们很酷的新函数连接助手与一些我们想要看到连接的函数。让我们从`main`函数开始，我们在其中定义两个简单的函数对象：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now let's concatenate. We concatenate our two multiplier function objects with
    the STL function, `std::plus<int>`, which takes two parameters and simply returns
    their sum. This way, we get a function that does `twice(thrice(plus( a, b )))`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们进行连接。我们将我们的两个乘法函数对象与STL函数`std::plus<int>`进行连接，该函数接受两个参数并简单地返回它们的和。这样，我们得到一个执行`twice(thrice(plus(a,
    b)))`的函数。
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s use it. The `combined` function looks like a single normal function
    now, and the compiler is also able to concatenate those functions without any
    unnecessary overhead:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用它。`combined`函数现在看起来像一个普通的单一函数，编译器也能够连接这些函数，而没有任何不必要的开销：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compiling and running our program yields the following output, which we also
    expected, because `2 * 3 * (2 + 3)` is `30`:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行我们的程序产生了以下输出，这也是我们预期的，因为`2 * 3 * (2 + 3)`是`30`：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The complicated thing in this section is the `concat` function. It looks horribly
    complicated because it unpacks the parameter pack `ts` into another lambda expression,
    which recursively calls `concat` again, with less parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的复杂之处在于`concat`函数。它看起来非常复杂，因为它将参数包`ts`解包到另一个lambda表达式中，该lambda表达式递归调用`concat`，并且参数更少：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s write a simpler version, which concatenates exactly *three* functions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个更简单的版本，它精确地连接*三个*函数：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This already looks similar, but less complicated. We return a lambda expression,
    which captures `f`, `g`, and `h`. This lambda expression arbitrarily accepts many
    parameters and just forwards them to a call chain of `f`, `g`, and `h`. When we
    write `auto combined (concat(f, g, h))`, and later call that function object with
    two parameters, such as `combined(2, 3)`, then the `2, 3` are represented by the
    `params` pack from the preceding `concat` function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来已经很相似，但不那么复杂。我们返回一个lambda表达式，它捕获了`f`，`g`和`h`。这个lambda表达式任意接受许多参数，并将它们转发到`f`，`g`和`h`的调用链。当我们写`auto
    combined (concat(f, g, h))`，然后稍后用两个参数调用该函数对象，比如`combined(2, 3)`，那么`2, 3`将由前面的`concat`函数的`params`包表示。
- en: Looking at the much more complex, generic `concat` function again; the only
    thing we do really differently is the `f ( g( h( params... ) ) )` concatenation.
    Instead, we write `f( concat(g, h) )(params...)`, which evaluates to `f( g( concat(h)
    ) )(params...)` in the next recursive call, which then finally results in `f(
    g( h( params... ) ) )`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看更复杂的通用`concat`函数；我们真正不同的唯一一件事是`f ( g( h( params... ) ) )`的连接。相反，我们写`f( concat(g,
    h) )(params...)`，这在下一次递归调用中会评估为`f( g( concat(h) ) )(params...)`，然后最终结果为`f( g(
    h( params... ) ) )`。
- en: Creating complex predicates with logical conjunction
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逻辑连接创建复杂的谓词
- en: When filtering data with generic code, we end up defining **predicates**, which
    tell what data we want, and what data we do not want. Sometimes predicates are
    the *combinations* of different predicates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用通用代码过滤数据时，我们最终会定义**谓词**，告诉我们想要什么数据，以及不想要什么数据。有时，谓词是不同谓词的*组合*。
- en: When filtering strings, for example, we could implement a predicate that returns
    `true` if its input string *begins* with `"foo"`. Another predicate could return
    true if its input string *ends* with `"bar"`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在过滤字符串时，我们可以实现一个谓词，如果其输入字符串以`"foo"`开头，则返回`true`。另一个谓词可以在其输入字符串以`"bar"`结尾时返回`true`。
- en: Instead of writing custom predicates all the time, we can *reuse* predicates
    by combining them. If we want to filter strings that begin with `"foo"` and end
    with `"bar"`, we can just pick our *existing* predicates and *combine* them with
    a logical *and*. In this section, we play with lambda expressions in order to
    find a comfortable way to do this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合来*重用*谓词，而不是一直编写自定义谓词。如果我们想要过滤以`"foo"`开头并以`"bar"`结尾的字符串，我们可以选择我们*现有*的谓词，并用逻辑*与*将它们*组合*起来。在本节中，我们将使用lambda表达式来寻找一种舒适的方法来做到这一点。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We will implement very simple string filter predicates, and then we will combine
    them with a little helper function that does the combination for us in a generic
    way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现非常简单的字符串过滤谓词，然后我们将用一个小助手函数将它们以通用方式组合起来。
- en: 'As always, we''ll include some headers first:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先包含一些头文件：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because we are going to need them later, we implement two simple predicate
    functions. The first one tells if a string begins with the character `''a''` and
    the second one tells if a string ends with the character `''b''`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们以后会需要它们，我们实现了两个简单的谓词函数。第一个告诉我们一个字符串是否以字符`'a'`开头，第二个告诉我们一个字符串是否以字符`'b'`结尾：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s implement a helper function, which we call `combine`. It takes
    a binary function as its first parameter, which could be the logical `AND` function
    or the logical `OR` function, for example. Then, it takes two other parameters,
    which shall be two predicate functions that are then combined:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个辅助函数，我们称之为`combine`。它以二进制函数作为第一个参数，这个函数可以是逻辑`AND`函数或逻辑`OR`函数，然后，它接受另外两个参数，这两个参数将被组合：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We simply return a lambda expression that captures the new predicate *combination*.
    It forwards a parameter to both predicates and, then, puts the results of both
    into the binary function and returns its result:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需返回一个捕获新谓词*combination*的lambda表达式。它将一个参数转发到两个谓词，然后将两者的结果放入二进制函数中，并返回其结果：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s state that we use the `std` namespace to spare us some typing in the
    `main` function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明我们在`main`函数中使用`std`命名空间来节省一些输入：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s combine our two predicate functions in another predicate function,
    which tells if a given string begins with `a` *and* ends with `b`, as `"ab"` does
    or `"axxxb"`. As the binary function, we choose `std::logical_and`. It is a template
    class that needs to be instantiated, so we use it with curly braces in order to
    instantiate it. Note that we don''t provide a template parameter because for this
    class, it defaults to `void`. This specialization of the class deduces all parameter
    types automatically:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将两个谓词函数组合成另一个谓词函数，告诉我们给定的字符串是否以`a`开头*并且*以`b`结尾，就像`"ab"`或`"axxxb"`一样。作为二进制函数，我们选择`std::logical_and`。它是一个需要实例化的模板类，因此我们使用大括号来实例化它。请注意，我们没有提供模板参数，因为对于这个类，默认为`void`。这个类的特化自动推断所有参数类型：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We iterate over the standard input and print all words back to the terminal,
    which satisfies our predicate:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历标准输入，并将所有满足我们谓词的单词打印回终端：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Compiling and running the program yields the following output. We feed the
    program with four words, but only two satisfy the predicate criteria:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。我们用四个单词输入程序，但只有两个满足谓词条件：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The STL already provides a useful bunch of functional objects such as `std::logical_and`,
    `std::logical_or`, as well as many others, so we do not need to reimplement them
    in every project. It''s a good idea to have a look at the C++ reference and explore
    what''s there already:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: STL已经提供了一堆有用的函数对象，比如`std::logical_and`，`std::logical_or`，以及许多其他函数，因此我们不需要在每个项目中重新实现它们。查看C++参考并探索已有的内容是一个好主意：
- en: '[http://en.cppreference.com/w/cpp/utility/functional](http://en.cppreference.com/w/cpp/utility/functional)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.cppreference.com/w/cpp/utility/functional](http://en.cppreference.com/w/cpp/utility/functional)'
- en: Calling multiple functions with the same input
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相同的输入调用多个函数
- en: There are a lot of tasks, which lead to repetitive code. A lot of repetitive
    code can be eliminated easily using lambda expressions and a lambda expression
    helper that wraps such repetitive tasks is created very quickly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多任务会导致重复的代码。使用lambda表达式和一个包装这种重复任务的lambda表达式辅助函数可以很容易地消除大量重复的代码。
- en: In this section, we will play with lambda expressions in order to forward a
    single call with all its parameters to multiple receivers. This is going to happen
    without any data structures in between, so the compiler has a simple job to generate
    a binary without overhead.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用lambda表达式来转发一个带有所有参数的单个调用到多个接收者。这将在没有任何数据结构的情况下发生，因此编译器可以简单地生成一个没有开销的二进制文件。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to write a lambda expression helper, which forwards a single call
    to multiple objects, and another lambda expression helper, which forwards a single
    call to multiple calls of other functions. In our example, we are going to use
    this to print a single message with different printer functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个lambda表达式辅助函数，将单个调用转发给多个对象，以及另一个lambda表达式辅助函数，将单个调用转发给其他函数的多个调用。在我们的示例中，我们将使用这个来使用不同的打印函数打印单个消息：
- en: 'Let''s include the STL header we need for printing first:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们包含我们需要打印的STL头文件：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At first, we implement the `multicall` function, which is central to this recipe.
    It accepts an arbitrary number of functions as parameters and returns a lambda
    expression that accepts one parameter. It forwards this parameter to all the functions
    that were provided before. This way, we can define `auto call_all (multicall(f,
    g, h))`, and then, `call_all(123)` leads to a sequence of calls,`f(123); g(123);
    h(123);`. This function looks really complicated because we need a syntax trick
    in order to expand the parameter pack, `functions`, into a series of calls by
    using an `std::initializer_list` constructor:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实现`multicall`函数，这是本教程的核心。它接受任意数量的函数作为参数，并返回一个接受一个参数的lambda表达式。它将此参数转发到之前提供的所有函数。这样，我们可以定义`auto
    call_all (multicall(f, g, h))`，然后`call_all(123)`导致一系列调用，`f(123); g(123); h(123);`。这个函数看起来非常复杂，因为我们需要一个语法技巧来展开参数包`functions`，通过使用`std::initializer_list`构造函数来进行一系列调用：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next helper accepts a function, `f`, and a pack of parameters, `xs`. What
    it does is it calls `f` with each of those parameters. This way, a `for_each(f,
    1, 2, 3)` call leads to a series of calls: `f(1); f(2); f(3);`. This function
    essentially uses the same syntax trick to expand the parameter pack, `xs`, to
    a series of function calls, as the other function before:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个辅助函数接受一个函数`f`和一组参数`xs`。它的作用是对每个参数调用`f`。这样，`for_each(f, 1, 2, 3)`调用导致一系列调用：`f(1);
    f(2); f(3);`。这个函数本质上使用了与之前的其他函数相同的语法技巧，将参数包`xs`展开为一系列函数调用：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `brace_print` function accepts two characters and returns a new function
    object, which accepts one parameter, `x`. It will *print* it, surrounded by the
    two characters we just captured before:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`brace_print`函数接受两个字符并返回一个新的函数对象，它接受一个参数`x`。它会*打印*它，用我们刚刚捕获的两个字符包围起来：'
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can finally put everything to use in the `main` function. At first,
    we define functions `f`, `g`, and `h`. They represent print functions that accept
    values and print them surrounded by different braces/parentheses each. The `nl`
    function takes any parameter and just prints a line break character:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以在`main`函数中把所有东西都用起来了。首先，我们定义了`f`、`g`和`h`函数。它们代表接受值并将其打印在不同的大括号/括号中的打印函数。`nl`函数接受任何参数，只是打印一个换行字符：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s combine all of them using our `multicall` helper:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用我们的`multicall`助手将它们全部组合起来：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For each of the numbers we provide, we want to see them individually printed
    three times surrounded by different pairs of braces/parentheses. This way, we
    can do a single function call and end up with five calls to our multifunction,
    which does another four calls to `f`, `g`, `h`, and `nl`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们提供的每个数字，我们希望看到它们被不同的大括号/括号包围打印三次。这样，我们可以进行一次函数调用，最终得到五次对我们的多功能函数的调用，它又会调用`f`、`g`、`h`和`nl`四次。
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Before compiling and running, think about what output to expect:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译和运行之前，想一想期望的输出：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The helpers we just implemented look horribly complicated. This is because
    we expand parameter packs with `std::initializer_list`. Why did we even use that
    data structure? Let''s have a look at `for_each` again:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现的辅助函数看起来非常复杂。这是因为我们使用`std::initializer_list`来展开参数包。我们为什么要使用这种数据结构呢？让我们再看看`for_each`：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The heart of this function is the `f(xs)` expression. `xs` is a parameter pack,
    and we need to *unpack* it in order to get the individual values out of it and
    feed them to individual `f` calls. Unfortunately, we cannot just write `f(xs)...`
    using the `...` notation, which we already know.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的核心是`f(xs)`表达式。`xs`是一个参数包，我们需要*展开*它，以便将其中的各个值取出并传递给各个`f`调用。不幸的是，我们不能只使用`...`符号写`f(xs)...`，这一点我们已经知道了。
- en: 'What we can do is constructing a list of values using `std::initializer_list`,
    which has a variadic constructor. An expression such as `return std::initializer_list<int>{f(xs)...};`
    does the job, but it has *downsides*. Let''s have a look at an implementation
    of `for_each` which does just this, so it looks simpler than what we have:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::initializer_list`构造一个值列表，它具有可变参数的构造函数。诸如`return std::initializer_list<int>{f(xs)...};`这样的表达式可以胜任，但它有*缺点*。让我们看看`for_each`的一个实现，它只是这样做，所以它看起来比我们现在有的更简单：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is easier to grasp, but its downsides are the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易理解，但它的缺点是：
- en: It constructs an actual initializer list of return values from all the `f` calls.
    At this point, we do not care about the return values.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它构造了一个实际的初始化器列表，其中包含所有`f`调用的返回值。在这一点上，我们不关心返回值。
- en: It *returns* that initializer list, although we want a *"fire and forget"* function,
    which returns *nothing*.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它*返回*了初始化列表，尽管我们想要一个*“发射并忘记”*的函数，它不返回*任何东西*。
- en: It's possible that `f` is a function, which does not even return anything, in
    which case, this would not even compile.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能`f`是一个函数，甚至不返回任何东西，如果是这样，那么这甚至不会编译。
- en: 'The much more complicated `for_each` function fixes all these problems. It
    does the following things to achieve that:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的`for_each`函数解决了所有这些问题。它做了以下几件事来实现这一点：
- en: It does not *return* the initializer list, but it *casts* the whole expression
    to `void` using `(void)std::initializer_list<int>{...}`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不是*返回*初始化列表，而是*将*整个表达式转换为`void`，使用`(void)std::initializer_list<int>{...}`。
- en: Within the initializer expression, it wraps `f(xs)...` into an `(f(xs), 0)...`
    expression. This leads to the return value being *thrown away*, while `0` is put
    into the initializer list.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化表达式中，它将`f(xs)...`包装成`(f(xs), 0)...`表达式。这导致返回值被*丢弃*，而`0`被放入初始化列表中。
- en: The `f(xs)` in the `(f(xs), 0)...` expression is again cast to `void`, so the
    return value is really not processed anywhere *if* it has any.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(f(xs), 0)...`表达式中的`f(xs)`再次被转换为`void`，因此如果有的话，返回值确实没有被处理到任何地方。'
- en: Putting all this together unluckily leads to an *ugly* construct, but it does
    it's work right and compiles with a whole variety of function objects, regardless
    of whether they return anything or what they return.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组合在一起不幸地导致了一个*丑陋*的结构，但它确实能正常工作，并且能够编译各种函数对象，无论它们是否返回任何东西或者返回什么。
- en: A nice detail of this technique is that the order in which the function calls
    are applied is guaranteed to be in a *strict sequence*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个好处是，函数调用的顺序是有严格顺序保证的。
- en: Casting anything using the old C-style notation `(void)expression` is advised
    against because C++ has its own cast operators. We should have used `reinterpret_cast<void>(expression)`
    instead, but this would have decreased the *readability* of the code further.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旧的C风格表示法`(void)expression`来转换任何东西是不建议的，因为C++有自己的转换操作符。我们应该使用`reinterpret_cast<void>(expression)`，但这会进一步降低代码的*可读性*。
- en: Implementing transform_if using std::accumulate and lambdas
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::accumulate和lambda实现transform_if
- en: Most developers who have used `std::copy_if` and `std::transform` may have asked
    themselves already, why there is no `std::transform_if`. The `std::copy_if` function
    copies items from a source range to a destination range, but *skips* the items
    that are not selected by a user-defined *predicate* function. The `std::transform`
    unconditionally copies all items from a source range to a destination range but
    transforms them in between. The transformation is provided by a user-defined function,
    which might do simple things, such as multiplying numbers or transforming items
    to completely different types.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用`std::copy_if`和`std::transform`的开发人员可能已经问过自己，为什么没有`std::transform_if`。`std::copy_if`函数从源范围复制项目到目标范围，但会*跳过*用户定义的*谓词*函数未选择的项目。`std::transform`无条件地从源范围复制所有项目到目标范围，但在中间进行转换。转换由用户定义的函数提供，可能做简单的事情，比如乘以数字或将项目转换为完全不同的类型。
- en: Such functions have been there for a long time now, but there is *still* no
    `std::transform_if` function. In this section, we are going to implement this
    function. It would be easy to do this by just implementing a function that iterates
    over the ranges while copying all the items that are selected by a predicate function
    and transforming them in between. However, we'll use this occasion to delve deeper
    into lambda expressions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数现在已经存在很长时间了，但仍然没有`std::transform_if`函数。在本节中，我们将实现这个函数。通过实现一个函数，它在复制被谓词函数选择的所有项目的同时迭代范围，进行中间转换，这样做很容易。然而，我们将利用这个机会更深入地研究lambda表达式。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to build our own `transform_if` function which works by supplying
    `std::accumulate` with the right function objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建自己的`transform_if`函数，通过提供`std::accumulate`正确的函数对象来工作：
- en: 'We need to include some headers, as always:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要像往常一样包含一些头文件：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, we will implement a function called `map`. It accepts an input-transforming
    function as parameter and returns a function object, which works well together
    with `std::accumulate`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个名为`map`的函数。它接受一个输入转换函数作为参数，并返回一个函数对象，它与`std::accumulate`很好地配合使用：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What we return is a function object that accepts a *reduce* function. When
    this object is called with such a reduce function, it returns another function
    object, which accepts an *accumulator* and an input parameter. It calls the reduce
    function on this accumulator and the `fn` transformed input variable. Don''t worry
    if this looks complicated, we''ll put it together later and see how it really
    works:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回的是一个接受*reduce*函数的函数对象。当这个对象被调用时，它会返回另一个函数对象，它接受一个*accumulator*和一个输入参数。它调用reduce函数对这个累加器和`fn`转换后的输入变量进行操作。如果这看起来很复杂，不要担心，我们稍后会把它整合在一起，看看它是如何真正工作的：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we implement a function called `filter`. It works exactly the same way
    as the `map` function, but it leaves the input *untouched*, while the `map` function
    *transforms* it using a transform function. Instead, we accept a predicate function
    and *skip* input variables without reducing them in case they are not accepted
    by the predicate function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们实现一个名为`filter`的函数。它的工作方式与`map`函数完全相同，但它保持输入*不变*，而`map`函数使用转换函数*转换*它。相反，我们接受一个谓词函数，并在不减少它们的情况下*跳过*输入变量，如果它们不被谓词函数接受：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The two lambda expressions have exactly the same function signature as the
    expressions in the `map` function. The only difference is that the `input` parameter
    is left untouched. The predicate function is used to distinguish if we call the
    `reduce_fn` function on the input or if we just reach the accumulator forward
    without any change:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个lambda表达式与`map`函数中的表达式具有完全相同的函数签名。唯一的区别是`input`参数保持不变。谓词函数用于区分我们是在输入上调用`reduce_fn`函数，还是只是在不做任何更改的情况下将累加器向前推进：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now let''s finally use those helpers. We instantiate iterators that let us
    read integer values from the standard input:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们最终使用这些辅助函数。我们实例化迭代器，让我们从标准输入中读取整数值：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then we define a predicate function, `even`, which just returns `true` if we
    have an *even number*. The transformation function `twice` multiplies its integer
    parameter with the factor `2`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个谓词函数`even`，如果我们有一个*偶数*，它就返回`true`。变换函数`twice`将它的整数参数乘以因子`2`：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `std::accumulate` function takes a range of values and *accumulates* them.
    Accumulating means *summing* the values up with the `+` operator in the default
    case. We want to provide our own accumulation function. This way, we do not maintain
    a *sum* of the values. What we do is we assign each value of the range to the
    dereferenced iterator, `it`, and then return this iterator after *advancing* it
    further:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::accumulate`函数接受一系列值并*累加*它们。累加意味着在默认情况下使用`+`运算符对值进行求和。我们想要提供我们自己的累加函数。这样，我们就不需要维护值的*总和*。我们做的是将范围的每个值赋给解引用的迭代器`it`，然后在*推进*它之后返回这个迭代器：'
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we finally put together the pieces. We iterate over the standard input
    and provide an output, `ostream_iterator`, which prints to the terminal. The `copy_and_advance`
    function object works on that output iterator by assigning the user input integers
    to it. Assigning to the output iterator effectively *prints* the assigned items.
    But we only want the *even* numbers from the user input, and we want to *multiply*
    them. To achieve this, we wrap the `copy_and_advance` function into an `even`
    *filter* and then into a `twice` *mapper*:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于把这些部分整合在一起了。我们遍历标准输入并提供一个输出，`ostream_iterator`，它打印到终端。`copy_and_advance`函数对象通过将用户输入的整数赋值给它来处理输出迭代器。将值赋给输出迭代器有效地*打印*了被赋值的项目。但我们只想要用户输入中的*偶数*，并且我们想要*乘以*它们。为了实现这一点，我们将`copy_and_advance`函数包装到一个`even`
    *filter*中，然后再包装到一个`twice` *mapper*中：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Compiling and running the program leads to the following output. The values
    `1`, `3`, and `5` are dropped because they are not even, and the values `2`, `4`,
    and `6` are printed after they have been doubled:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出。值`1`、`3`和`5`被丢弃，因为它们不是偶数，而值`2`、`4`和`6`在被加倍后被打印出来：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This recipe looks really complicated because we are nesting lambda expressions
    a lot. In order to understand how this works, let''s first have a look at the
    inner workings of `std::accumulate`. This is how it will look like in a typical
    STL implementation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱看起来非常复杂，因为我们嵌套了很多lambda表达式。为了理解这是如何工作的，让我们首先来看一下`std::accumulate`的内部工作。这是在典型的STL实现中的样子：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The function parameter, `f`, does the main work here, while the loop collects
    its results in the user provided `init` variable. In a usual example case, the
    iterator range may represent a vector of numbers, such as `0, 1, 2, 3, 4`, and
    the `init` value is `0`. The `f` function is then just a binary function that
    might calculate the *sum* of two items using the `+` operator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，函数参数`f`承担了主要工作，而循环在用户提供的`init`变量中收集其结果。在通常的例子中，迭代器范围可能代表一个数字向量，比如`0, 1, 2,
    3, 4`，而`init`值为`0`。`f`函数只是一个二元函数，可能使用`+`运算符计算两个项目的*总和*。
- en: In this example case, the loop just sums up all the items into the `init` variable,
    such as in `init = (((0 + 1) + 2) + 3) + 4`. Writing it down like this makes obvious
    that `std::accumulate` is just a general *folding* function. Folding a range means
    applying a binary operation to an accumulator variable and stepwise every item
    contained in the range (the result of each operation is then the accumulator value
    for the next one). As this function is so general, we can do all kinds of things
    with it, just like implementing `std::transform_if`! The `f` function is then
    also called the *reduce* function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，循环只是将所有项目相加到`init`变量中，比如`init = (((0 + 1) + 2) + 3) + 4`。像这样写下来很明显，`std::accumulate`只是一个通用的*折叠*函数。折叠一个范围意味着对累加器变量应用二元操作，并逐步应用范围中包含的每个项目（每次操作的结果就是下一个累加器值）。由于这个函数是如此通用，我们可以做各种各样的事情，就像实现`std::transform_if`一样！`f`函数也被称为*reduce*函数。
- en: 'A very direct implementation of `transform_if` will look as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform_if`的一个非常直接的实现如下所示：'
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This looks quite *similar* to `std::accumulate`, if we regard the parameter
    `out` as the `init` variable, and *somehow* get function `f` to substitute the
    if-construct and its body!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与`std::accumulate`非常*相似*，如果我们将参数`out`视为`init`变量，并且*以某种方式*让函数`f`替代if结构及其主体！
- en: 'We actually did that. We constructed that if-construct and its body with the
    binary function object we provided as a parameter to `std::accumulate`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上做到了。我们使用我们提供的二元函数对象构造了if结构及其主体，并将其作为参数提供给`std::accumulate`：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `std::accumulate` function puts the `init` variable into the binary function's
    `it` parameter. The second parameter is the current value from the source range
    per loop iteration step. *We* provided an *output iterator* as the `init` parameter
    of `std::accumulate.`. This way, `std::accumulate` does not calculate a sum, but
    forwards the items it iterates over to another range. This means that we just
    reimplemented `std::copy` without any predicate and transformation, yet.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::accumulate`函数将`init`变量放入二元函数的`it`参数中。第二个参数是源范围中每次循环迭代步骤的当前值。我们提供了一个*输出迭代器*作为`std::accumulate`的`init`参数。这样，`std::accumulate`不计算总和，而是将其迭代的项目转发到另一个范围。这意味着我们只是重新实现了`std::copy`，没有任何谓词和转换。'
- en: 'The filtering using a predicate was added by us by wrapping the `copy_and_advance`
    function object into *another* function object, which employs a predicate function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`copy_and_advance`函数对象包装成*另一个*函数对象来添加使用谓词进行过滤：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This construction does not look too simple at first but have a look at the `if`
    construct. If the `predicate` function returns `true`, it forwards the parameters
    to the `reduce_fn` function, which is `copy_and_advance` in our case. If the predicate
    returns `false`, the `accum` variable, which is the `init` variable of `std::accumulate`,
    is just returned without change. This implements the *skipping* part of a filter
    operation. The `if` construct is located within the inner lambda expression, which
    has the same binary function signature as the `copy_and_advance` function, which
    makes it a fitting substitute.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造一开始看起来并不简单，但是看看`if`结构。如果`predicate`函数返回`true`，它将参数转发给`reduce_fn`函数，这在我们的情况下是`copy_and_advance`。如果谓词返回`false`，则`accum`变量，即`std::accumulate`的`init`变量，将不经改变地返回。这实现了过滤操作的*跳过*部分。`if`结构位于内部lambda表达式中，其具有与`copy_and_advance`函数相同的二元函数签名，这使其成为一个合适的替代品。
- en: 'Now we are able to *filter* but are still not *transforming*. This is done
    with the `map` function helper:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够*过滤*，但仍然没有*转换*。这是由`map`函数助手完成的：
- en: '[PRE66]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code looks much easier. It again contains an inner lambda expression, which
    has the same signature as `copy_and_advance` has, so it can substitute it. The
    implementation just forwards the input values but *transforms* the *right* parameter
    of the binary function call with the `fn` function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来简单得多。它再次包含了一个内部lambda表达式，其签名与`copy_and_advance`相同，因此可以替代它。实现只是转发输入值，但是*转换*了二元函数调用的*右*参数，使用`fn`函数。
- en: 'Later, when we used those helpers, we wrote the following expression:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，当我们使用这些辅助函数时，我们写下了以下表达式：
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `filter(even)` call captures the `even` predicate and gives us a function,
    which takes a binary function in order to wrap it into *another* binary function,
    which does additional *filtering*. The `map(twice)` function does the same with
    the `twice` transformation function but wraps the binary function, `copy_and_advance`,
    into another binary function, which always *transforms* the right parameter.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter(even)`调用捕获了`even`谓词，并给了我们一个函数，它接受一个二元函数，以便将其包装成*另一个*二元函数，进行额外的*过滤*。`map(twice)`函数对`twice`转换函数做了同样的事情，但是将二元函数`copy_and_advance`包装成另一个二元函数，它总是*转换*右参数。'
- en: Without any optimization, we would get a horribly complicated nested construction
    of functions that call functions and do only a very little amount of work in between.
    However, it is a very simple task for the compiler to optimize all the code. The
    resulting binary is as simple as if it resulted from a more direct implementation
    of `transform_if`. We pay nothing in terms of performance this way. But what we
    get is a very nice composability of functions because we were able to stick the
    `even` predicate together with the `twice` transformation function, nearly as
    simply as if they were *lego* bricks.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何优化，我们将得到一个非常复杂的嵌套函数构造，调用函数并在其中间做很少的工作。然而，对于编译器来说，优化所有代码是一项非常简单的任务。生成的二进制代码就像是从`transform_if`的更直接的实现中得到的一样简单。这种方式在性能方面没有任何损失。但我们得到的是函数的非常好的可组合性，因为我们能够将`even`谓词与`twice`转换函数简单地组合在一起，几乎就像它们是*乐高积木*一样简单。
- en: Generating cartesian product pairs of any input at compile time
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编译时生成任何输入的笛卡尔积对
- en: Lambda expressions in combination with parameter packs can be used for complex
    tasks. In this section, we will implement a function object that accepts an arbitrary
    number of input parameters and generates the **cartesian product** of this set
    with *itself*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式与参数包结合可以用于复杂的任务。在本节中，我们将实现一个函数对象，它接受任意数量的输入参数，并生成这组参数与*自身*的**笛卡尔积**。
- en: 'The cartesian product is a mathematical operation. It is noted as `A x B`,
    meaning the cartesian product of set `A` and set `B`. The result is another *single
    set*, which contains pairs of *all* item combinations of the sets `A` and `B`.
    The operation basically means, c*ombine every item from A with every item from
    B*. The following diagram illustrates the operation:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积是一个数学运算。它表示为`A x B`，意思是集合`A`和集合`B`的笛卡尔积。结果是另一个*单一集合*，其中包含集合`A`和`B`的*所有*项目组合的对。该操作基本上意味着，*将A中的每个项目与B中的每个项目组合*。下图说明了该操作：
- en: '![](img/f83f3245-6b4c-4919-b137-17c2d6a11e7e.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f83f3245-6b4c-4919-b137-17c2d6a11e7e.png)'
- en: In the preceding diagram, if `A = (x, y, z)`, and `B = (1, 2, 3)`, then the
    cartesian product is `(x, 1)`, `(x, 2)`, `(x, 3)`, `(y, 1)`, `(y, 2)`, and so
    on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，如果`A = (x, y, z)`，`B = (1, 2, 3)`，那么笛卡尔积是`(x, 1)`，`(x, 2)`，`(x, 3)`，`(y,
    1)`，`(y, 2)`，等等。
- en: If we decide that `A` and `B` are the *same* set, say `(1, 2)`, then the cartesian
    product of that is `(1, 1)`, `(1, 2)`, `(2, 1)`, and `(2, 2)`. In some cases,
    this might be declared *redundant*, because the combination of items with *themselves*
    (like in `(1, 1)`) or redundant combinations of `(1, 2)` and `(2, 1)` may not
    be needed. In such a case, the cartesian product can be filtered with a simple
    rule.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定`A`和`B`是*相同*的集合，比如`(1, 2)`，那么它的笛卡尔积是`(1, 1)`，`(1, 2)`，`(2, 1)`和`(2, 2)`。在某些情况下，这可能被声明为*冗余*，因为与*自身*的项目组合（如`(1,
    1)`）或`(1, 2)`和`(2, 1)`的冗余组合可能是不需要的。在这种情况下，可以使用简单的规则过滤笛卡尔积。
- en: In this section, we will implement the cartesian product without any loops but
    with lambda expressions and parameter pack unpacking.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现笛卡尔积，但不使用任何循环，而是使用lambda表达式和参数包展开。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We implement a function object that accepts a function, `f`, and a set of parameters.
    The function object will *create* the cartesian product of the parameter set,
    *filter* out the redundant parts, and *call* the `f` function with each of them:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个接受函数`f`和一组参数的函数对象。函数对象将*创建*参数集的笛卡尔积，*过滤*掉冗余部分，并*调用*`f`函数的每一个：
- en: 'We only need to include the STL header that is needed for printing:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要包括用于打印的STL头文件：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we define a simple helper function that prints a pair of values, and
    we begin implementing the `main` function:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个简单的辅助函数，用于打印一对值，并开始实现`main`函数：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The hard part starts now. We first implement a helper for the `cartesian` function
    that we are going to implement in the next step. This function accepts a parameter,
    `f`, which will be the `print` function when we use it later. The other parameters
    are `x` and the parameter pack `rest`. These contain the actual items of which
    we want to have the cartesian product. Look at the `f(x, rest)` expression: for
    `x=1` and `rest=2, 3, 4`, this will result in calls such as `f(1, 2); f(1, 3);
    f(1, 4);`. The `(x < rest)` test is for removing redundancy in the generated pairs.
    We will look at this in more detail later:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在开始困难的部分。我们首先实现了`cartesian`函数的辅助函数，我们将在下一步中实现它。这个函数接受一个参数`f`，当我们以后使用它时，它将是`print`函数。其他参数是`x`和参数包`rest`。这些包含我们想要得到笛卡尔积的实际项目。看一下`f(x,
    rest)`表达式：对于`x=1`和`rest=2, 3, 4`，这将导致诸如`f(1, 2); f(1, 3); f(1, 4);`的调用。`(x < rest)`测试是为了消除生成的对中的冗余。我们稍后将更详细地看一下这一点：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `cartesian` function is the most complex piece of code in this whole recipe.
    It accepts the parameter pack `xs` and returns a function object that captures
    it. The returned function object accepts a function object, `f`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cartesian`函数是整个配方中最复杂的代码。它接受参数包`xs`并返回一个捕获它的函数对象。返回的函数对象接受一个函数对象`f`。'
- en: 'For a parameter pack, `xs=1, 2, 3`, the inner lambda expression will generate
    the following calls: `call_cart(f, **1**, 1, 2, 3); call_cart(f, **2**, 1, 2,
    3); call_cart(f, **3**, 1, 2, 3);`. From that range of calls, we can generate
    all the cartesian product pairs we need.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数包，`xs=1, 2, 3`，内部lambda表达式将生成以下调用：`call_cart(f, **1**, 1, 2, 3); call_cart(f,
    **2**, 1, 2, 3); call_cart(f, **3**, 1, 2, 3);`。从这一系列调用中，我们可以生成所有需要的笛卡尔积对。
- en: 'Note that we use the `...` notation for expanding the `xs` parameter pack *twice*,
    which looks weird at first. The first occurrence of `...` expands the entire `xs`
    parameter pack into the `call_cart` call. The second occurrence leads to multiple
    `call_cart` calls with a differing *second* parameter:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`...`符号来*两次*展开`xs`参数包，一开始看起来很奇怪。第一次出现的`...`将整个`xs`参数包展开为`call_cart`调用。第二次出现会导致多个`call_cart`调用，第二个参数不同：
- en: '[PRE71]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, let's generate the cartesian product of the numeric set `1, 2, 3` and print
    the pairs. Without the redundant pairs, this should result in the number pairs,
    `(1, 2)`, `(2, 3)`, and `(1, 3)`. More combinations are not possible if we ignore
    the order and do not want the same number in one pair. This means that we do *not*
    want `(1, 1)`, and consider `(1, 2)` and `(2, 1)` the *same* pair.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们生成数字集合`1, 2, 3`的笛卡尔积并打印这些配对。去除冗余配对后，这应该得到数字配对`(1, 2)`，`(2, 3)`和`(1, 3)`。如果我们忽略顺序并且不希望在一个配对中有相同的数字，那么就不可能有更多的组合。这意味着我们*不*希望`(1,
    1)`，并且认为`(1, 2)`和`(2, 1)`是*相同*的配对。
- en: First, we let `cartesian` generate a function object that already contains all
    possible pairs and accepts our print function. Then, we use it to let our `print`
    function being called with all these pairs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让`cartesian`生成一个函数对象，该对象已经包含了所有可能的配对，并接受我们的打印函数。然后，我们使用它来让我们的`print`函数被所有这些配对调用。
- en: 'We declare the `print_cart` variable, `constexpr`, so we can guarantee that
    the function object it holds (and all the pairs it generates) is created at compile
    time:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明`print_cart`变量为`constexpr`，这样我们可以保证它所持有的函数对象（以及它生成的所有配对）在编译时创建：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Compiling and running yields the following output, just as expected. Play around
    with the code by removing the `(x < xs)` conditional in the `call_cart` function
    and see that we get the full cartesian product with redundant pairs and the same
    number pairs:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行产生了以下输出，正如预期的那样。通过删除`call_cart`函数中的`(x < xs)`条件，可以尝试在代码中进行调整，看看我们是否会得到包含冗余配对和相同数字配对的完整笛卡尔积。
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: That was another really complicated-looking lambda expression construct. But
    as soon as we understand this thoroughly, we will not be confused by any lambda
    expression anytime soon!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个看起来非常复杂的lambda表达式构造。但一旦我们彻底理解了这一点，我们就不会被任何lambda表达式所困惑！
- en: 'So, let''s have a detailed look at it. We should get a mental picture of what
    needs to happen:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们仔细看一下。我们应该对需要发生的事情有一个清晰的认识：
- en: '![](img/957b7794-331d-4b2d-958e-ac82ee95071d.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/957b7794-331d-4b2d-958e-ac82ee95071d.png)'
- en: 'These are three steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是三个步骤：
- en: We take our set `1, 2, 3` and compose *three new* sets from it. The first part
    of each of these sets is consecutively a single item from the set, and the second
    part is the whole set itself.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们取我们的集合`1, 2, 3`，并从中组合*三个新*集合。每个集合的第一部分依次是集合中的一个单独项，第二部分是整个集合本身。
- en: We combine the first item with every item from the set and get as many *pairs*
    out of it.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将第一个项与集合中的每个项组合，得到尽可能多的*配对*。
- en: From these resulting pairs, we only pick the ones that are *not redundant* (as
    for example `(1, 2)` and `(2, 1)` are redundant) and not same-numbered (as for
    example `(1, 1)`).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这些得到的配对中，我们只挑选那些*不冗余*的（例如`(1, 2)`和`(2, 1)`是冗余的）和不相同编号的（例如`(1, 1)`）。
- en: 'Now, back to the implementation:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到实现：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The inner expression, `call_cart(xs, xs...)`, exactly represents the separation
    of `(1, 2, 3)` into those new sets, such as `1, [1, 2, 3]`. The full expression,
    `((void)call_cart(f, xs, xs...), 0)...` with the other `...` outside, does this
    separation for every value of the set, so we also get `2, [1, 2, 3]` and `3, [1,
    2, 3]`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 内部表达式`call_cart(xs, xs...)`恰好表示将`(1, 2, 3)`分成这些新集合，比如`1, [1, 2, 3]`。完整表达式`((void)call_cart(f,
    xs, xs...), 0)...`与其他`...`在外面，对集合的每个值进行了这种分割，所以我们也得到了`2, [1, 2, 3]`和`3, [1, 2,
    3]`。
- en: 'Step 2 and step 3 are done by `call_cart`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步和第3步是由`call_cart`完成的：
- en: '[PRE75]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Parameter `x` always contains the single value picked from the set, and `rest`
    contains the whole set again. Let's ignore the `(x < rest)` conditional at first.
    Here, the expression `f(x, rest)`, together with the `...` parameter pack expansion
    generates the function calls `f(1, 1)`, `f(1, 2)`, and so on, which results in
    the pairs being printed. This was step 2.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`x`始终包含从集合中选取的单个值，`rest`包含整个集合。首先忽略`(x < rest)`条件。在这里，表达式`f(x, rest)`与`...`参数包展开一起生成函数调用`f(1,
    1)`，`f(1, 2)`等等，这导致配对被打印。这是第2步。
- en: Step 3 is achieved by filtering out only the pairs where `(x < rest)` applies.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步是通过筛选出只有`(x < rest)`适用的配对来实现的。
- en: We made all lambda expressions and the variables holding them `constexpr`. By
    doing so, we can now guarantee that the compiler will evaluate their code at compile
    time and compile a binary that already contains all the number pairs instead of
    calculating them at runtime. Note that this *only* happens if all the function
    arguments we provide to a constexpr function are *known at compile time* already.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有的lambda表达式和持有它们的变量都设为`constexpr`。通过这样做，我们现在可以保证编译器将在编译时评估它们的代码，并编译出一个已经包含所有数字配对的二进制文件，而不是在运行时计算它们。请注意，*只有*当我们提供给constexpr函数的所有函数参数*在编译时已知*时才会发生这种情况。
