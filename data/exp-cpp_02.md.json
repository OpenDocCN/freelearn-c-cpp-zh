["```cpp\ntemplate <default_constructible T>\nvoid make_T() { return T(); }\n```", "```cpp\ngenerator<int> step_by_step(int n = 0) {\n  while (true) {\n    co_yield n++;\n  }\n}\n```", "```cpp\nimport <vector>\n\nint main()\n{\n  std::vector<int> elements{0, 1, 2, 3, 4, 5, 6};\n}\n```", "```cpp\nimport <vector>\nimport <ranges>\n\nint main()\n{\n  std::vector<int> elements{0, 1, 2, 3, 4, 5, 6};\n  for (int current : elements | ranges::view::filter([](int e) { return \n   e % 2 == 0; }))\n  {\n    std::cout << current << \" \";\n  }\n}\n```", "```cpp\n#define NUMBER 41 \nint main() { \n  int a = NUMBER + 1; \n  return 0; \n}\n```", "```cpp\nint main() { \n  int a = 41 + 1; \n  return 0;\n}\n```", "```cpp\nint b = NUMBER + 1; \nstruct T {}; // user-defined type \nT t = NUMBER; // preprocessed successfully, but compile error \n```", "```cpp\nint b = 41 + 1\nstruct T {};\nT t = 41; // error line\n```", "```cpp\n#define DOUBLE_IT(arg) (arg * arg) \n```", "```cpp\nint st = DOUBLE_IT(4);\nstd::cout << st;\n```", "```cpp\nint st = (4 * 4);\nstd::cout << st;\n```", "```cpp\nint bad_result = DOUBLE_IT(4 + 1); \nstd::cout << bad_result;\n```", "```cpp\nint bad_result = (4 + 1 * 4 + 1);\nstd::cout << bad_result;\n```", "```cpp\n#define DOUBLE_IT(arg) ((arg) * (arg)) \n```", "```cpp\nint bad_result = ((4 + 1) * (4 + 1)); \n```", "```cpp\nconstexpr int double_it(int arg) { return arg * arg; } \nint bad_result = double_it(4 + 1); \n```", "```cpp\nconst int NUMBER = 41; \n```", "```cpp\n// file: main.cpp \n#include <iostream> \n#include \"rect.h\"\nint main() { \n  Rect r(3.1, 4.05) \n  std::cout << r.get_area() << std::endl;\n}\n```", "```cpp\n// file: rect.h\nstruct Rect  \n{\nprivate:\n  double side1_;\n  double side2_;\npublic:\n  Rect(double s1, double s2);\n  const double get_area() const;\n};\n```", "```cpp\n// file: rect.cpp\n#include \"rect.h\"\n\nRect::Rect(double s1, double s2)\n  : side1_(s1), side2_(s2)\n{}\n\nconst double Rect::get_area() const {\n  return side1_ * side2_;\n}\n```", "```cpp\n#if __has_include(\"custom_io_stream.h\")\n#include \"custom_io_stream.h\"\n#else\n#include <iostream>\n#endif\n```", "```cpp\n// file: square.h\n#include \"rect.h\"\nstruct Square : Rect {\n  Square(double s);\n};\n```", "```cpp\n// file: main.cpp\n#include <iostream> \n#include \"rect.h\" \n#include \"square.h\"\n/* \n  preprocessor replaces the following with the contents of square.h\n*/\n// code omitted for brevity\n```", "```cpp\n// contents of the iostream file omitted for brevity \nstruct Rect {\n  // code omitted for brevity\n};\nstruct Rect {\n  // code omitted for brevity\n};\nstruct Square : Rect {\n  // code omitted for brevity\n};\nint main() {\n  // code omitted for brevity\n}\n```", "```cpp\n#ifndef RECT_H \n#define RECT_H \nstruct Rect { ... }; // code omitted for brevity  \n#endif // RECT_H \n\n```", "```cpp\nvoid foo() {\n  log(\"foo() called\");\n  // do some useful job\n}\nvoid start() {\n  log(\"start() called\");\n  foo();\n  // do some useful job\n}\n```", "```cpp\nvoid log(const std::string& msg) {\n#if DEBUG\n  std::cout << msg << std::endl;\n#endif\n}\n```", "```cpp\nexport module test;\n\nexport int twice(int a) { return a * a; }\n```", "```cpp\nimport test;\n\nint main()\n{\n  twice(21);\n}\n```", "```cpp\nimport <iostream>;\n#include <vector>\n\nint main()\n{\n  std::vector<int> vec{1, 2, 3};\n  for (int elem : vec) std::cout << elem;\n}\n```", "```cpp\nint a=42;\n```", "```cpp\nint b = a + 0;\n```", "```cpp\nint b = a + 0\n```", "```cpp\nclass A { \npublic:\n  int get_member() { return mem_; }\nprivate: \n  int mem_; \n};\n```", "```cpp\nstruct A { \n  int mem_; \n};\nint A_get_member(A* this) { return this->mem_; } \n```", "```cpp\nint a = 41; \nint b = a + 1; \n```", "```cpp\nint a = 41; \nint b = 41 + 1; \n```", "```cpp\nint a = 41; \nint b = 42; \n```", "```cpp\n// contents of the iostream \nstruct Rect {\nprivate:\n  double side1_;\n  double side2_;\npublic:\n  Rect(double s1, double s2);\n  const double get_area() const;\n};\n\nstruct Square : Rect {\n  Square(double s);\n};\n\nint main() {\n  Rect r(3.1, 4.05);\n  std::cout << r.get_area() << std::endl;\n  return 0;\n}\n```", "```cpp\nstruct Rect { \n  double side1_; \n  double side2_; \n};\nvoid _Rect_init_(Rect* this, double s1, double s2); \ndouble _Rect_get_area_(Rect* this); \n\nstruct Square { \n  Rect _subobject_; \n};\nvoid _Square_init_(Square* this, double s); \n\nint main() {\n  Rect r;\n  _Rect_init_(&r, 3.1, 4.05); \n  printf(\"%d\\n\", _Rect_get_area(&r)); \n  // we've intentionally replace cout with printf for brevity and \n  // supposing the compiler generates a C intermediate code\n  return 0;\n}\n```", "```cpp\ncode: \n0x00 main\n 0x01 Rect r; \n  0x02 _Rect_init_(&r, 3.1, 4.05); \n  0x03 printf(\"%d\\n\", _Rect_get_area(&r)); \ninformation:\n  main: 0x00\n  _Rect_init_: ????\n  printf: ????\n  _Rect_get_area_: ????\n```", "```cpp\n// file: rect.cpp \nstruct Rect {\n  // #include \"rect.h\" replaced with the contents  \n  // of the rect.h file in the preprocessing phase \n  // code omitted for brevity \n};\nRect::Rect(double s1, double s2) \n  : side1_(s1), side2_(s2)\n{}\nconst double Rect::get_area() const { \n  return side1_ * side2_;\n} \n```", "```cpp\ncode:  \n 0x00 _Rect_init_ \n  0x01 side1_ = s1 \n  0x02 side2_ = s2 \n  0x03 return \n  0x04 _Rect_get_area_ \n  0x05 register = side1_ \n  0x06 reg_multiply side2_ \n  0x07 return \ninformation: \n  _Rect_init_: 0x00\n  _Rect_get_area_: 0x04 \n```", "```cpp\ncode: \n 0x00 main\n  0x01 Rect r; \n  0x02 _Rect_init_(&r, 3.1, 4.05); \n  0x03 printf(\"%d\\n\", _Rect_get_area(&r)); \n 0x04 _Rect_init_ \n 0x05 side1_ = s1 \n 0x06 side2_ = s2 \n 0x07 return \n 0x08 _Rect_get_area_ \n 0x09 register = side1_ \n 0x0A reg_multiply side2_ \n 0x0B return \ninformation (symbol table):\n  main: 0x00\n  _Rect_init_: 0x04\n  printf: ????\n  _Rect_get_area_: 0x08 \n _Rect_init_: 0x04\n _Rect_get_area_: 0x08\n```", "```cpp\nint main() {\n  double result = sqrt(49.0);\n}\n```", "```cpp\n#include <cmath>\nint main() {\n  double result = std::sqrt(49.0);\n}\n```"]