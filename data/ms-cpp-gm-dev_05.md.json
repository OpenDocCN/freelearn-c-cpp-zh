["```cpp\nenum PlayerState \n{ \n    Idle, \n      Walking \n} \n... \nPlayerState currentState = PlayerState::Idle; //A holder variable for the state currently in \n... \n// A simple function to change states \nvoid ChangeState(PlayState nextState) \n{ \n    currentState = nextState; \n} \nvoid Update(float deltaTime) \n{ \n    ... \n    switch(currentState) \n{ \n    case PlayerState::Idle: \n        ... //Do idle stuff \n        //Change to next state \nChangeState(PlayerState::Walking); \nbreak; \n        case PlayerState::Walking: \n            ... //Do walking stuff \n            //Change to next state \n            ChangeState(PlayerState::Idle); \nbreak; \n    } \n    ... \n} \n```", "```cpp\n... \nnamespace BookEngine \n{ \n    class IState { \n    public: \n        IState() {} \n        virtual ~IState(){} \n        // Called when a state enters and exits  \n        virtual void OnEntry() = 0; \n        virtual void OnExit() = 0; \n\n        // Called in the main game loop \n        virtual void Update(float deltaTime) = 0; \n    }; \n} \n```", "```cpp\n#pragma once \n#include <BookEngine\\IState.h> \nclass GameState : BookEngine::IState \n{ \npublic: \n    GameState(); \n    ~GameState(); \n    //Our overrides \n    virtual void OnEntry() = 0; \n    virtual void OnExit() = 0; \n    virtual void Update(float deltaTime) = 0; \n    //Added specialty function \n    virtual void Draw() = 0; \n}; \n```", "```cpp\n#pragma once \n#include \"GameState.h\" \n\nclass GameWaiting: GameState \n{ \n    virtual void OnEntry() override; \n    virtual void OnExit() override; \n    virtual void Update(float deltaTime) override; \n    virtual void Draw() override; \n}; \n\nclass GameRunning: GameState \n{ \n    virtual void OnEntry() override; \n    virtual void OnExit() override; \n    virtual void Update(float deltaTime) override; \n    virtual void Draw() override; \n}; \n\nclass GameOver : GameState \n{ \n    virtual void OnEntry() override; \n    virtual void OnExit() override; \n    virtual void Update(float deltaTime) override; \n    virtual void Draw() override; \n}; \n```", "```cpp\n#include \"GameStates.h\" \n    void GameWaiting::OnEntry() \n{ \n...  \n//Called when entering the GameWaiting state's OnEntry function \n... \n} \n\nvoid GameWaiting::OnExit() \n{ \n...  \n//Called when entering the GameWaiting state's OnEntry function \n... \n} \n\nvoid GameWaiting::Update(float deltaTime) \n{ \n...  \n//Called when entering the GameWaiting state's OnEntry function \n... \n\n} \n\nvoid GameWaiting::Draw() \n{ \n...  \n//Called when entering the GameWaiting state's OnEntry function \n... \n\n} \n...  \n//Other GameState implementations  \n... \n```", "```cpp\n    class GameState; \n\n    class GameStateList { \n    public: \n        GameStateList (IGame* game); \n        ~ GameStateList (); \n\n        GameState* GoToNext(); \n        GameState * GoToPrevious(); \n\n        void SetCurrentState(int nextState); \n        void AddState(GameState * newState); \n\n        void Destroy(); \n\n        GameState* GetCurrent(); \n\n    protected: \n        IGame* m_game = nullptr; \n        std::vector< GameState*> m_states; \n        int m_currentStateIndex = -1; \n    }; \n} \n```", "```cpp\n... \n#include <glm/glm.hpp> \n#include <glm/gtc/matrix_transform.hpp> \n..., \n```", "```cpp\n... \n   public: \n      Camera3D(); \n      ~Camera3D(); \n      void Init(glm::vec3 cameraPosition = glm::vec3(4,10,10), \n              float horizontalAngle = -2.0f,  \n              float verticalAngle = 0.0f,  \n              float initialFoV = 45.0f); \n      void Update(); \n```", "```cpp\nglm::mat4 GetView() { return m_view; };\nglm::mat4 GetProjection() { return m_projection; };\nglm::vec3 GetForward() { return m_forward; };\nglm::vec3 GetRight() { return m_right; };\nglm::vec3 GetUp() { return m_up; };\n```", "```cpp\nvoid SetHorizontalAngle(float angle) { m_horizontalAngle = angle; };\nvoid SetVerticalAngle(float angle) { m_verticalAngle = angle; };\n```", "```cpp\nvoid MoveCamera(glm::vec3 movementVector) { m_position +=   movementVector; };\n```", "```cpp\n...\n  private:\n    glm::mat4 m_projection;\n    glm::mat4 m_view; // Camera matrix\n```", "```cpp\nglm::vec3 m_position;\nfloat m_horizontalAngle;\nfloat m_verticalAngle;\nfloat m_initialFoV;\n```", "```cpp\nglm::vec3 m_right;\nglm::vec3 m_up;\nglm::vec3 m_forward; \n```", "```cpp\nvoid Camera3D::Init(glm::vec3 cameraPosition, \n     float horizontalAngle, \n     float verticalAngle, \n     float initialFoV)\n   {\n     m_position = cameraPosition;\n     m_horizontalAngle = horizontalAngle;\n     m_verticalAngle = verticalAngle;\n     m_initialFoV = initialFoV;\n\n     Update();\n    }\n    ...\n\n```", "```cpp\n...\n   void Camera3D::Update()\n   {\n      m_forward = glm::vec3(\n          glm::cos(m_verticalAngle) * glm::sin(m_horizontalAngle),\n          glm::sin(m_verticalAngle),\n          glm::cos(m_verticalAngle) * glm::cos(m_horizontalAngle)\n        );\n```", "```cpp\n  m_right = glm::vec3(\n        glm::sin(m_horizontalAngle - 3.14f / 2.0f),\n        0,\n        glm::cos(m_horizontalAngle - 3.14f / 2.0f)\n     );  \n```", "```cpp\n m_up = glm::cross(m_right, m_forward);\n```", "```cpp\n  float FoV = m_initialFoV;\n```", "```cpp\nm_projection = glm::perspective(glm::radians(FoV), 4.0f / 3.0f, 0.1f, 100.0f);\n```", "```cpp\n m_view = glm::lookAt(\n            m_position,           \n            m_position + m_forward, \n            m_up\n         );\n      }\n```", "```cpp\nstruct BoundingBox\n{\n glm::vec3 m_vecMax;\n glm::vec3 m_vecMin;\n};  \n```", "```cpp\nbool PointInAABB(const BoundingBox& box, const glm::vec3 & vecPoint)\n {\n   if(vecPoint.x > tBox.m_vecMin.x && vecPoint.x < tBox.m_vecMax.x &&\n      vecPoint.y > tBox.m_vecMin.y && vecPoint.y < tBox.m_vecMax.y &&\n      vecPoint.z > tBox.m_vecMin.z && vecPoint.z < tBox.m_vecMax.z)\n     {\n         return true;\n     }\n    return false;\n  }\n\n```", "```cpp\nbool AABBtoAABB(const BoundingBox& box1, const BoundingBox& box2) \n{ \n if (box1.m_vecMax.x > tBox2.m_vecMin.x &&  \n    box1.m_vecMin.x < tBox2.m_vecMax.x && \n    box1.m_vecMax.y > tBox2.m_vecMin.y && \n    box1.m_vecMin.y < tBox2.m_vecMax.y && \n    box1.m_vecMax.z > tBox2.m_vecMin.z && \n    box1.m_vecMin.z < tBox2.m_vecMax.z)  \n{  \n   return true; \n} \nreturn false; \n} \n```", "```cpp\n... \nstruct BoundingSphere \n{ \nglm::vec3    m_vecCenter; \nfloat          m_radius; \n}; \n... \nbool SphereToSphere(const BoundingSphere & Sphere1, const BoundingSphere & Sphere2) \n{ \n\nglm::vec3 distance(Sphere2.m_vecCenter - Sphere1.m_vecCenter); \nfloat distanceSqaured(glm::dot( & distance, & distance) ); \n\n```", "```cpp\nfloat radiiSumSquared( Sphere1.m_radius + Sphere2.m_radius ); \nradiiSumSquared *= radiiSumSquared; \n```", "```cpp\nif( distanceSqaured <= radiiSumSquared ) \n{ \n    return true; \n} \nreturn false; \n} \n... \n```", "```cpp\nclass GroundObject : BookEngine::GameObject \n{ \n   ... \n\n   btCollisionShape* groundShape = nullptr; \n   btDefaultMotionState* groundMotionState = nullptr; \n   btRigidBody* groundRigidBody = nullptr; \n```", "```cpp\nvoid GroundObject::Init(const glm::vec3& pos, const glm::vec3& scale) \n{ \n   ... \n   groundShape = new btStaticPlaneShape(btVector3(0, 1, 0), 1); \n   groundMotionState = \n      new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(m_position.x, m_position.y, m_position.z))); \n```", "```cpp\nbtRigidBody::btRigidBodyConstructionInfo \n groundRigidBodyCI(0, groundMotionState, groundShape, btVector3(0, 0,  0)); \n groundRigidBody = new btRigidBody(groundRigidBodyCI); \n```", "```cpp\nbtDefaultMotionState* fallMotionState;\nbtScalar mass = 1;\nbtCollisionShape* fallShape;\nbtRigidBody* fallRigidBody;\n...  \n```", "```cpp\nvoid BallObject::Init(const glm::vec3& pos, const glm::vec3& scale)\n {\n    ...\n\n    fallShape = new btSphereShape(10);\n    btVector3 fallInertia(0.0f, 0.0f, 0.0f);  \n```", "```cpp\nfallMotionState =\n       new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1),     \n       btVector3(m_position.x, m_position.y, m_position.z)));\n```", "```cpp\n fallShape->calculateLocalInertia(mass, fallInertia);\n    btRigidBody::btRigidBodyConstructionInfo fallRigidBodyCI(mass,  fallMotionState, fallShape, fallInertia);\n    fallRigidBody = new btRigidBody(fallRigidBodyCI);\n     }\n\n```", "```cpp\nvoid BallObject::Update(float deltaTime)\n {\n    btTransform trans;\n    fallRigidBody->getMotionState()->getWorldTransform(trans);\n    m_position.x = trans.getOrigin().getX();\n    m_position.y = trans.getOrigin().getY();\n    m_position.z = trans.getOrigin().getZ();\n  }\n```", "```cpp\nbtBroadphaseInterface* broadphase = new btDbvtBroadphase();  \n```", "```cpp\nbtDefaultCollisionConfiguration* collisionConfiguration = new     \n       btDefaultCollisionConfiguration();\nbtCollisionDispatcher* dispatcher = new              \n       btCollisionDispatcher(collisionConfiguration); btSequentialImpulseConstraintSolver* solver = new    \n       btSequentialImpulseConstraintSolver;\n```", "```cpp\nbtDiscreteDynamicsWorld* dynamicsWorld = new       \n     btDiscreteDynamicsWorld(dispatcher, broadphase, solver,    \n     collisionConfiguration);\n```", "```cpp\nvoid GameplayScreen::OnEntry() \n{ \n   ... \n\n   dynamicsWorld->setGravity(btVector3(0, -1, 0)); \n   dynamicsWorld->addRigidBody(m_ground.groundRigidBody); \n   dynamicsWorld->addRigidBody(m_ball.fallRigidBody); \n... \n} \n```", "```cpp\nvoid GameplayScreen::Update(float deltaTime) \n{ \n   CheckInput(deltaTime); \n   dynamicsWorld->stepSimulation(1 / 60.f, 10); \n   m_ball.Update(deltaTime); \n```"]