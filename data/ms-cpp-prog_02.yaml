- en: Standard Template Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库
- en: 'This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: STL overview
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL概述
- en: STL architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL架构
- en: Containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Iterators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Functors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象
- en: STL containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL容器
- en: Sequence
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: Associative
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Unordered
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序
- en: Adaptors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Let's look into the STL topics one by one in the following sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下各节中逐个查看STL主题。
- en: The Standard Template Library architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库架构
- en: The C++ **Standard Template Library** (**STL**) offers ready-made generic containers,
    algorithms that can be applied to the containers, and iterators to navigate the
    containers. The STL is implemented with C++ templates, and templates allow generic
    programming in C++.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **标准模板库**（**STL**）提供了现成的通用容器、可应用于容器的算法以及用于导航容器的迭代器。STL是用C++模板实现的，模板允许在C++中进行通用编程。
- en: The STL encourages a C++ developer to focus on the task at hand by freeing up
    the developer from writing low-level data structures and algorithms. The STL is
    a time-tested library that allows rapid application development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: STL鼓励C++开发人员专注于手头的任务，通过摆脱编写低级数据结构和算法的开发人员。STL是一个经过时间考验的库，可以实现快速应用程序开发。
- en: 'The STL is an interesting piece of work and architecture. Its secret formula
    is compile-time polymorphism. To get better performance, the STL avoids dynamic
    polymorphism, saying goodbye to virtual functions. Broadly, the STL has the following
    four components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: STL是一项有趣的工作和架构。它的秘密公式是编译时多态性。为了获得更好的性能，STL避免了动态多态性，告别了虚函数。广义上来说，STL有以下四个组件：
- en: Algorithms
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法
- en: Functors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象
- en: Iterators
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Containers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: The STL architecture stitches all the aforementioned four components together.
    It has many commonly used algorithms with performance guarantees. The interesting
    part about STL algorithms is that they work seamlessly without any knowledge about
    the containers that hold the data. This is made possible due to the iterators
    that offer high-level traversal APIs, which completely abstracts the underlying
    data structure used within a container. The STL makes use of operator overloading
    quite extensively. Let's understand the major components of STL one by one to
    get a good grasp of the STL conceptually.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: STL架构将所有上述四个组件都连接在一起。它具有许多常用的算法，并提供性能保证。有趣的是，STL算法可以在不了解包含数据的容器的情况下无缝工作。这是由于迭代器的高级遍历API，它完全抽象了容器中使用的底层数据结构。STL广泛使用运算符重载。让我们逐个了解STL的主要组件，以便对STL的概念有一个很好的理解。
- en: Algorithms
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: The STL algorithms are powered by C++ templates; hence, the same algorithm works
    irrespective of what data type it deals with or independently of how the data
    is organized by a container. Interestingly, the STL algorithms are generic enough
    to support built-in and user-defined data types using templates. As a matter of
    fact, the algorithms interact with the containers via iterators. Hence, what matters
    to the algorithms is the iterator supported by the container. Having said that,
    the performance of an algorithm depends on the underlying data structure used
    within a container. Hence, certain algorithms work only on selective containers,
    as each algorithm supported by the STL expects a certain type of iterator.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法由C++模板支持；因此，相同的算法可以处理不同的数据类型，或者独立于容器中数据的组织方式。有趣的是，STL算法足够通用，可以使用模板支持内置和用户定义的数据类型。事实上，算法通过迭代器与容器进行交互。因此，对算法来说重要的是容器支持的迭代器。话虽如此，算法的性能取决于容器中使用的底层数据结构。因此，某些算法仅适用于选择性的容器，因为STL支持的每个算法都期望某种类型的迭代器。
- en: Iterators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: An iterator is a design pattern, but interestingly, the STL work started much
    before
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一种设计模式，但有趣的是，STL的工作开始得早得多
- en: '*Gang of Four* published their design patterns-related work to the software
    community. Iterators themselves are objects that allow traversing the containers
    to access, modify, and manipulate the data stored in the containers. Iterators
    do this so magically that we don''t realize or need to know where and how the
    data is stored and retrieved.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人帮*将他们与设计模式相关的工作发布给了软件社区。迭代器本身是允许遍历容器以访问、修改和操作容器中存储的数据的对象。迭代器以如此神奇的方式进行操作，以至于我们不会意识到或需要知道数据存储在何处以及如何检索。'
- en: 'The following image visually represents an iterator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像直观地表示了一个迭代器：
- en: '![](img/ac27623f-1c3e-4a4b-a210-f2bec635d541.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac27623f-1c3e-4a4b-a210-f2bec635d541.png)'
- en: From the preceding image, you can understand that every iterator supports the `begin()`
    API, which returns the first element position, and the `end()` API returns one
    position past the last element in the container.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图中，您可以了解到每个迭代器都支持`begin()` API，它返回第一个元素的位置，`end()` API返回容器中最后一个元素的下一个位置。
- en: 'The STL broadly supports the following five types of iterators:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: STL广泛支持以下五种类型的迭代器：
- en: Input iterators
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入迭代器
- en: Output iterators
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出迭代器
- en: Forward iterators
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向迭代器
- en: Bidirectional iterators
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向迭代器
- en: Random-access iterators
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机访问迭代器
- en: The container implements the iterator to let us easily retrieve and manipulate
    the data, without delving much into the technical details of a container.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器实现了迭代器，让我们可以轻松地检索和操作数据，而不需要深入了解容器的技术细节。
- en: 'The following table explains each of the five iterators:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了五种迭代器中的每一种：
- en: '| **The type of iterator** | **Description                                
                  ** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **迭代器的类型** | **描述** |'
- en: '| Input iterator |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 输入迭代器 |'
- en: It is used to read from the pointed element
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于从指向的元素中读取
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于单次导航，一旦到达容器的末尾，迭代器将失效
- en: It supports pre- and post-increment operators
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前增量和后增量运算符
- en: It does not support decrement operators
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持递减运算符
- en: It supports dereferencing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It supports the `==` and `!=` operators to compare with the other iterators
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持`==`和`!=`运算符来与其他迭代器进行比较
- en: The `istream_iterator` iterator is an input iterator
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`istream_iterator`迭代器是输入迭代器'
- en: All the containers support this iterator
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有容器都支持这个迭代器
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Output iterator |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 输出迭代器 |'
- en: It is used to modify the pointed element
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于修改指向的元素
- en: It is valid for single-time navigation, and once it reaches the end of the container,
    the iterator will be invalidated
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对于单次导航是有效的，一旦到达容器的末尾，迭代器将无效
- en: It supports pre- and post-increment operators
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前增量和后增量运算符
- en: It does not support decrement operators
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持减量运算符
- en: It supports dereferencing
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It doesn't support the `==` and `!=` operators
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持`==`和`!=`运算符
- en: The `ostream_iterator`, `back_inserter`, `front_inserter` iterators are examples
    of output iterators
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ostream_iterator`，`back_inserter`，`front_inserter`迭代器是输出迭代器的示例'
- en: All the containers support this iterator
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有容器都支持这个迭代器
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Forward iterator |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 前向迭代器 |'
- en: It supports the input iterator and output iterator functionalities
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持输入迭代器和输出迭代器的功能
- en: It allows multi-pass navigation
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许多次导航
- en: It supports pre-increment and post-increment operators
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前增量和后增量运算符
- en: It supports dereferencing
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: The `forward_list` container supports forward iterators
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward_list`容器支持前向迭代器'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Bidirectional iterator |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 双向迭代器 |'
- en: It is a forward iterator that supports navigation in both directions
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个支持双向导航的前向迭代器
- en: It allows multi-pass navigation
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许多次导航
- en: It supports pre-increment and post-increment operators
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前增量和后增量运算符
- en: It supports pre-decrement and post-decrement operators
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前减量和后减量运算符
- en: It supports dereferencing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It supports the `[]` operator
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持`[]`运算符
- en: The `list`, `set`, `map`, `multiset`, and `multimap` containers support bidirectional
    iterators
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`，`set`，`map`，`multiset`和`multimap`容器支持双向迭代器'
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Random-access iterator |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 随机访问迭代器 |'
- en: Elements can be accessed using an arbitrary offset position
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素可以使用任意偏移位置进行访问
- en: It supports pre-increment and post-increment operators
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前增量和后增量运算符
- en: It supports pre-decrement and post-decrement operators
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持前减量和后减量运算符
- en: It supports dereferencing
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持解引用
- en: It is the most functionally complete iterator, as it supports all the functionalities
    of the other types of iterators listed previously
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是功能上最完整的迭代器，因为它支持先前列出的其他类型迭代器的所有功能
- en: The `array`, `vector`, and `deque` containers support random-access iterators
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`，`vector`和`deque`容器支持随机访问迭代器'
- en: A container that supports random access will naturally support bidirectional
    and other types of iterators
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持随机访问的容器自然也支持双向和其他类型的迭代器
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Containers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: STL containers are objects that typically grow and shrink dynamically. Containers
    use complex data structures to store the data under the hood and offer high-level
    functions to access the data without us delving into the complex internal implementation
    details of the data structure. STL containers are highly efficient and time-tested.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器通常是动态增长和收缩的对象。容器在内部使用复杂的数据结构存储数据，并提供高级函数来访问数据，而不需要我们深入了解数据结构的复杂内部实现细节。STL容器非常高效且经过时间考验。
- en: Every container uses different types of data structures to store, organize,
    and manipulate data in an efficient way. Though many containers may seem similar,
    they behave differently under the hood. Hence, the wrong choice of containers
    leads to application performance issues and unnecessary complexities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器使用不同类型的数据结构以有效的方式存储、组织和操作数据。尽管许多容器可能看起来相似，但在内部它们的行为是不同的。因此，选择错误的容器会导致应用程序性能问题和不必要的复杂性。
- en: 'Containers come in the following flavors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 容器有以下几种类型：
- en: Sequential
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序
- en: Associative
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Container adapters
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器适配器
- en: The objects stored in the containers are copied or moved, and not referenced.
    We will explore every type of container in the upcoming sections with simple yet
    interesting examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中存储的对象是复制或移动的，而不是引用。我们将在接下来的部分中使用简单而有趣的示例来探索每种类型的容器。
- en: Functors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象
- en: Functors are objects that behave like regular functions. The beauty is that
    functors can be substituted in the place of function pointers. Functors are handy
    objects that let you extend or complement the behavior of an STL function without
    compromising the object-oriented coding principles.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是行为类似于常规函数的对象。美妙之处在于函数对象可以替代函数指针的位置。函数对象是方便的对象，让您在不损害面向对象编码原则的情况下扩展或补充STL函数的行为。
- en: Functors are easy to implement; all you need to do is overload the function
    operator. Functors are also referred to as functionoids.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象很容易实现；你只需要重载函数运算符。函数对象也被称为函数对象。
- en: 'The following code will demonstrate the way a simple functor can be implemented:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将演示如何实现一个简单的函数对象：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s quickly compile the program using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速编译程序，使用以下命令：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s check the output of the program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查程序的输出：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We hope you realize how easy and cool a functor is.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你意识到函数对象是多么简单和酷。
- en: Sequence containers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列容器
- en: 'The STL supports quite an interesting variety of sequence containers. Sequence
    containers store homogeneous data types in a linear fashion, which can be accessed
    sequentially. The STL supports the following sequence containers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持一系列非常有趣的序列容器。序列容器以线性方式存储同质数据类型，可以按顺序访问。STL支持以下序列容器：
- en: Arrays
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Vectors
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量
- en: Lists
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: '`forward_list `'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forward_list`'
- en: deque
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双端队列
- en: 'As the objects stored in an STL container are nothing but copies of the values,
    the STL expects certain basic requirements from the user-defined data types in
    order to hold those objects inside a container. Every object stored in an STL
    container must provide the following as a minimum requirement:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储在STL容器中的对象只是值的副本，STL从用户定义的数据类型中期望满足一些基本要求，以便将这些对象存储在容器中。存储在STL容器中的每个对象都必须提供以下最低要求：
- en: A default constructor
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个默认构造函数
- en: A copy constructor
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个复制构造函数
- en: An assignment operator
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个赋值运算符
- en: Let's explore the sequence containers one by one in the following subsections.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个探索序列容器在以下子节中。
- en: Array
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'The STL array container is a fixed-size sequence container, just like a C/C++
    built-in array, except that the STL array is size-aware and a bit smarter than
    the built-in C/C++ array. Let''s understand an STL array with an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: STL数组容器是一个固定大小的序列容器，就像C/C++内置数组一样，只是STL数组是大小感知的，比内置的C/C++数组要聪明一点。让我们通过一个例子来了解STL数组：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令编译前面的代码并查看输出：
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the program is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Code walkthrough
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following line declares an array of a fixed size (`5`) and initializes
    the array with five elements:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个固定大小（`5`）的数组，并用五个元素初始化了数组：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The size mentioned can't be changed once declared, just like a C/C++ built-in
    array. The `array::size()` method returns the size of the array, irrespective
    of how many integers are initialized in the initializer list. The `auto pos =
    a.begin()` method declares an iterator of `array<int,5>` and assigns the starting
    position of the array. The `array::end()` method points to one position after
    the last element in the array. The iterator behaves like or mimics a C++ pointer,
    and dereferencing the iterator returns the value pointed by the iterator. The
    iterator position can be moved forward and backwards with `++pos` and `--pos`,
    respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明，大小就不能更改，就像C/C++内置数组一样。`array::size()`方法返回数组的大小，不管在初始化列表中初始化了多少个整数。`auto
    pos = a.begin()`方法声明了一个`array<int,5>`的迭代器，并分配了数组的起始位置。`array::end()`方法指向数组中最后一个元素的下一个位置。迭代器的行为类似于或模拟C++指针，对迭代器进行解引用会返回迭代器指向的值。迭代器位置可以通过`++pos`和`--pos`向前和向后移动。
- en: Commonly used APIs in an array
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组中常用的API
- en: 'The following table shows some commonly used array APIs:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些常用的数组API：
- en: '| **API** | **Description** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at( int index )` | This returns the value stored at the position referred
    to by the index. The index is a zero-based index. This API will throw an `std::out_of_range`
    exception if the index is outside the index range of the array. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `at( int index )` | 这返回存储在由索引引用的位置的值。索引是从零开始的索引。如果索引超出数组的索引范围，此API将抛出`std::out_of_range`异常。
    |'
- en: '| `operator [ int index ]` | This is an unsafe method, as it won''t throw any
    exception if the index falls outside the valid range of the array. This tends
    to be slightly faster than `at`, as this API doesn''t perform bounds checking.
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `operator [ int index ]` | 这是一个不安全的方法，如果索引超出数组的有效范围，它不会抛出任何异常。这比`at`稍微快一点，因为此API不执行边界检查。
    |'
- en: '| `front()` | This returns the first element in the array. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回数组中的第一个元素。 |'
- en: '| `back()` | This returns the last element in the array. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `back()` | 这返回数组中的最后一个元素。 |'
- en: '| `begin()` | This returns the position of the first element in the array |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `begin()` | 这返回数组中第一个元素的位置 |'
- en: '| `end()`  | This returns one position past the last element in the array |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `end()` | 这返回数组中最后一个元素的下一个位置 |'
- en: '| `rbegin()` | This returns the reverse beginning position, that is, it returns
    the position of the last element in the array |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `rbegin()` | 这返回反向开始位置，即返回数组中的最后一个元素的位置 |'
- en: '| `rend()` | This returns the reverse end position, that is, it returns one
    position before the first element in the array |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `rend()` | 这返回反向结束位置，即返回数组中第一个元素之前的一个位置 |'
- en: '| `size()`  | This returns the size of the array |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这返回数组的大小 |'
- en: The array container supports random access; hence, given an index, the array
    container can fetch a value with a runtime complexity of *O(1)* or constant time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组容器支持随机访问；因此，给定一个索引，数组容器可以在*O(1)*或常量时间内获取一个值。
- en: 'The array container elements can be accessed in a reverse fashion using the
    reverse iterator:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用反向迭代器以反向方式访问数组容器元素：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will use the following command to get the output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令来获取输出：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Vector
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vector
- en: Vector is a quite useful sequence container, and it works exactly as an array,
    except that the vector can grow and shrink at runtime while an array is of a fixed
    size. However, the data structure used under the hood in an array and vector is
    a plain simple built-in C/C++ style array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Vector是一个非常有用的序列容器，它的工作原理与数组完全相同，只是向量可以在运行时增长和缩小，而数组的大小是固定的。但是，在数组和向量下面使用的数据结构是一个简单的内置C/C++样式数组。
- en: 'Let''s look at the following example to understand vectors better:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子更好地理解向量：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令编译前面的代码并查看输出：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the program is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Code walkthrough
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following line declares a vector and initializes the vector with five elements:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个向量，并用五个元素初始化了向量：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, a vector also allows appending values to the end of the vector by using
    the `vector::push_back<data_type>( value )` API. The `sort()` algorithm takes
    two random access iterators that represent a range of data that must be sorted.
    As the vector internally uses a built-in C/C++ array, just like the STL array
    container, a vector also supports random access iterators; hence the `sort()`
    function is a highly efficient algorithm whose runtime complexity is logarithmic,
    that is, *O(N log2 (N))*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向量还允许使用`vector::push_back<data_type>( value )` API将值附加到向量的末尾。`sort()`算法接受两个表示必须排序的数据范围的随机访问迭代器。由于向量内部使用内置的C/C++数组，就像STL数组容器一样，向量也支持随机访问迭代器；因此，`sort()`函数是一个高效的算法，其运行时复杂度是对数的，即*O(N
    log2 (N))*。
- en: Commonly used vector APIs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用的向量API
- en: 'The following table shows some commonly used vector APIs:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些常用的向量API：
- en: '| **API** | **Description** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `at ( int index )` | 这返回索引位置存储的值。如果索引无效，则会抛出`std::out_of_range`异常。 |'
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )`, since no bounds checking is performed by
    this function. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `operator [ int index ]` | 这返回索引位置存储的值。它比`at( int index )`更快，因为该函数不执行边界检查。
    |'
- en: '| `front()` | This returns the first value stored in the vector. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 这返回向量中存储的第一个值。 |'
- en: '| `back()`  | This returns the last value stored in the vector. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `back()`  | 这返回向量中存储的最后一个值。 |'
- en: '| `empty()` | This returns true if the vector is empty, and false otherwise.
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果向量为空，则返回true，否则返回false。 |'
- en: '| `size()`  | This returns the number of values stored in the vector. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `size()`  | 这返回向量中存储的值的数量。 |'
- en: '| `reserve( int size )`  | This reserves the initial size of the vector. When
    the vector size has reached its capacity, an attempt to insert new values requires
    vector resizing. This makes the insertion consume *O(N)* runtime complexity. The
    `reserve()` method is a workaround for the issue described. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `reserve( int size )`  | 这保留向量的初始大小。当向量大小达到容量时，插入新值需要重新调整向量大小。这使得插入消耗*O(N)*的运行时复杂度。`reserve()`方法是对描述的问题的一种解决方法。
    |'
- en: '| `capacity()` | This returns the total capacity of the vector, while the size
    is the actual value stored in the vector. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `capacity()` | 这返回向量的总容量，而大小是向量中实际存储的值。 |'
- en: '| `clear()`  | This clears all the values. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `clear()`  | 这清除所有值。 |'
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    vector. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `push_back<data_type>( value )` | 这在向量末尾添加一个新值。 |'
- en: 'It would be really fun and convenient to read and print to/from the vector
    using `istream_iterator` and `ostream_iterator`. The following code demonstrates
    the use of a vector:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`istream_iterator`和`ostream_iterator`从/向向量读取和打印会非常有趣和方便。以下代码演示了向量的使用：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the output of the program is skipped, as the output depends on the
    input entered by you. Feel free to try the instructions on the command line.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序的输出被跳过，因为输出取决于您输入的输入。请随时尝试在命令行上执行这些指令。
- en: Code walkthrough
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'Basically, the copy algorithm accepts a range of iterators, where the first
    two arguments represent the source and the third argument represents the destination,
    which happens to be the vector:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，复制算法接受一系列迭代器，其中前两个参数表示源，第三个参数表示目标，这恰好是向量：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `start_input` iterator instance defines an `istream_iterator` iterator that
    receives input from `istream` and `cin`, and the `end_input` iterator instance
    defines an end-of-file delimiter, which is an empty string by default (`""`).
     Hence, the input can be terminated by typing `""` in the command-line input terminal.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_input`迭代器实例定义了一个从`istream`和`cin`接收输入的`istream_iterator`迭代器，而`end_input`迭代器实例定义了一个文件结束符，它默认为空字符串(`""`)。因此，输入可以通过在命令行输入终端中键入`""`来终止。'
- en: 'Similarly, let''s understand the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们了解以下代码片段：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The copy algorithm is used to copy the values from a vector, one element at
    a time, to `ostream`, separating the output with a tab character (`\t`).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 复制算法用于将向量中的值逐个复制到`ostream`中，并用制表符(`\t`)分隔输出。
- en: Pitfalls of a vector
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量的陷阱
- en: Every STL container has its own advantages and disadvantages. There is no single
    STL container that works better in all the scenarios. A vector internally uses
    an array data structure, and arrays are fixed in size in C/C++. Hence, when you
    attempt to add new values to the vector at the time the vector size has already
    reached its maximum capacity, then the vector will allocate new consecutive locations
    that can accommodate the old values and the new value in a contiguous location.
    It then starts copying the old values into the new locations. Once all the data
    elements are copied, the vector will invalidate the old location.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个STL容器都有其优点和缺点。没有单个STL容器在所有情况下都表现更好。向量内部使用数组数据结构，而在C/C++中数组的大小是固定的。因此，当您尝试在向量大小已经达到最大容量时向向量添加新值时，向量将分配新的连续位置，以容纳旧值和新值在一个连续的位置。然后开始将旧值复制到新位置。一旦所有数据元素都被复制，向量将使旧位置无效。
- en: Whenever this happens, the vector insertion will take *O(N)* runtime complexity.
    As the size of the vector grows over time, on demand, the *O(N)* runtime complexity
    will show up a pretty bad performance. If you know the maximum size required,
    you could reserve so much initial size upfront in order to overcome this issue.
    However, not in all scenarios do you need to use a vector. Of course, a vector
    supports dynamic size and random access, which has performance benefits in some
    scenarios, but it is possible that the feature you are working on may not really
    need random access, in which case a list, deque, or some other container may work
    better for you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当这种情况发生时，向量插入将需要*O(N)*的运行时复杂度。随着向量大小随时间增长，按需，*O(N)*的运行时复杂度将表现出相当糟糕的性能。如果你知道所需的最大大小，你可以预留足够的初始大小来克服这个问题。然而，并不是在所有情况下你都需要使用向量。当然，向量支持动态大小和随机访问，在某些情况下具有性能优势，但你可能真的不需要随机访问，这种情况下列表、双端队列或其他一些容器可能更适合你。
- en: List
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: The list STL container makes use of a doubly linked list data structure internally.
    Hence, a list supports only sequential access, and searching a random value in
    a list in the worst case may take *O(N)* runtime complexity. However, if you know
    for sure that you only need sequential access, the list does offer its own benefits.
    The list STL container lets you insert data elements at the end, in the front,
    or in the middle with a constant time complexity, that is, *O(1)* runtime complexity
    in the best, average, and worst case scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 列表STL容器在内部使用双向链表数据结构。因此，列表只支持顺序访问，在最坏的情况下，在列表中搜索随机值可能需要*O(N)*的运行时复杂度。然而，如果你确定只需要顺序访问，列表确实提供了自己的好处。列表STL容器允许你以常数时间复杂度在最佳、平均和最坏的情况下在末尾、前面或中间插入数据元素，即*O(1)*的运行时复杂度。
- en: 'The following image demonstrates the internal data structure used by the list
    STL:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了列表STL使用的内部数据结构：
- en: '![](img/abf7a8f7-caa3-47ee-a981-b3e95cd9be16.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abf7a8f7-caa3-47ee-a981-b3e95cd9be16.png)'
- en: 'Let''s write a simple program to get first-hand experience of using the list
    STL:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，亲身体验使用列表STL：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I'm sure that by now you have got a taste of the C++ STL, its elegance, and
    its power. Isn't it cool to observe that the syntax remains the same for all the
    STL containers? You may have observed that the syntax remains the same no matter
    whether you are using an array, a vector, or a list. Trust me, you will get the
    same impression when you explore the other STL containers as well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信到现在为止你已经对C++ STL有了一些了解，它的优雅和强大。观察到语法在所有STL容器中保持不变是不是很酷？你可能已经注意到，无论你使用数组、向量还是列表，语法都保持不变。相信我，当你探索其他STL容器时，你会得到同样的印象。
- en: Having said that, the previous code is self-explanatory, as we did pretty much
    the same with the other containers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，前面的代码是不言自明的，因为我们在其他容器中做了差不多的事情。
- en: 'Let''s try to sort the list, as shown in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试对列表进行排序，如下所示的代码：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Did you notice the `sort()` method? Yes, the list container has its own sorting
    algorithms. The reason for a list container to support its own version of a sorting
    algorithm is that the generic `sort()` algorithm expects a random access iterator,
    whereas a list container doesn't support random access. In such cases, the respective
    container will offer its own efficient algorithms to overcome the shortcoming.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了`sort()`方法吗？是的，列表容器有自己的排序算法。列表容器支持自己版本的排序算法的原因是，通用的`sort()`算法需要一个随机访问迭代器，而列表容器不支持随机访问。在这种情况下，相应的容器将提供自己的高效算法来克服这个缺点。
- en: Interestingly, the runtime complexity of the `sort` algorithm supported by a
    list is *O (N log2 N)*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，列表支持的`sort`算法的运行时复杂度是*O(N log2 N)*。
- en: Commonly used APIs in a list
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表中常用的API
- en: 'The following table shows the most commonly used APIs of an STL list:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了STL列表的最常用API：
- en: '| **API** | **Description** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `front()` | This returns the first value stored in the list |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 返回列表中存储的第一个值 |'
- en: '| `back() ` | This returns the last value stored in the list |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `back() ` | 返回列表中存储的最后一个值 |'
- en: '| `size()` | This returns the count of values stored in the list |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 返回列表中存储的值的数量 |'
- en: '| `empty()` | This returns `true` when the list is empty, and `false` otherwise
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当列表为空时返回`true`，否则返回`false` |'
- en: '| `clear()` | This clears all the values stored in the list |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 清除列表中存储的所有值 |'
- en: '| `push_back<data_type>( value )` | This adds a value at the end of the list
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `push_back<data_type>( value )` | 这在列表末尾添加一个值 |'
- en: '| `push_front<data_type>( value )` | This adds a value at the front of the
    list |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `push_front<data_type>( value )` | 在列表的前面添加一个值 |'
- en: '| `merge( list )` | This merges two sorted lists with values of the same type
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `merge( list )` | 这将两个相同类型值的排序列表合并 |'
- en: '| `reverse()` | This reverses the list |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 这将列表反转 |'
- en: '| `unique()` | This removes duplicate values from the list |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `unique()` | 从列表中删除重复的值 |'
- en: '| `sort()` | This sorts the values stored in a list |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 这对存储在列表中的值进行排序 |'
- en: Forward list
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向列表
- en: The STL's `forward_list` container is built on top of a singly linked list data
    structure; hence, it only supports navigation in the forward direction. As `forward_list`
    consumes one less pointer for every node in terms of memory and runtime, it is
    considered more efficient compared with the list container. However, as price
    for the extra edge of performance advantage, `forward_list` had to give up some
    functionalities.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`forward_list`容器建立在单向链表数据结构之上；因此，它只支持向前导航。由于`forward_list`在内存和运行时方面每个节点消耗一个更少的指针，因此与列表容器相比，它被认为更有效。然而，作为性能优势的额外边缘的代价，`forward_list`不得不放弃一些功能。
- en: 'The following diagram shows the internal data-structure used in `forward_list`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`forward_list`中使用的内部数据结构：
- en: '![](img/2f5ce1b8-55ac-4d34-8501-cc9d92362cc3.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f5ce1b8-55ac-4d34-8501-cc9d92362cc3.png)'
- en: 'Let''s explore the following sample code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索以下示例代码：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output can be viewed with the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output will be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Code walkthrough
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code declares and initializes the `forward_list` container with
    some unique values and some duplicate values:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明并初始化了`forward_list`容器，其中包含一些唯一值和一些重复值：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As the `forward_list` container doesn''t support the `size()` function, we
    used the `distance()` function to find the size of the list:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`forward_list`容器不支持`size()`函数，我们使用`distance()`函数来找到列表的大小：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following `forward_list<int>::unique()` function removes the duplicate
    integers and retains only the unique values:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`forward_list<int>::unique()`函数删除重复的整数，保留唯一的值：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Commonly used APIs in a forward_list container
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`forward_list`容器中常用的API
- en: 'The following table shows the commonly used `forward_list` APIs:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了常用的`forward_list` API：
- en: '| **API** | **Description** |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `front()` | This returns the first value stored in the `forward_list` container
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 返回`forward_list`容器中存储的第一个值|'
- en: '| `empty()` | This returns true when the `forward_list` container is empty
    and false, otherwise |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 当`forward_list`容器为空时返回true，否则返回false|'
- en: '| `clear()` | This clears all the values stored in `forward_list` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 清除`forward_list`中存储的所有值|'
- en: '| `push_front<data_type>( value )` | This adds a value to the front of `forward_list`
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `push_front<data_type>( value )` | 在`forward_list`的前面添加一个值|'
- en: '| `merge( list )` | This merges two sorted `forward_list` containers with values
    of the same type |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `merge( list )` | 将两个排序的`forward_list`容器合并为相同类型的值|'
- en: '| `reverse()` | This reverses the `forward_list` container |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `reverse()` | 反转`forward_list`容器|'
- en: '| `unique()` | This removes duplicate values from the `forward_list` container
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `unique()` | 从`forward_list`容器中删除重复的值|'
- en: '| `sort()` | This sorts the values stored in `forward_list` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `sort()` | 对`forward_list`中存储的值进行排序|'
- en: 'Let''s explore one more example to get a firm understanding of the `forward_list`
    container:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再探索一个例子，以更好地理解`forward_list`容器：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code snippet is an interesting example that demonstrates the practical
    use of the `sort()`, `merge()`, and `unique()` STL algorithms.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个有趣的例子，演示了`sort()`、`merge()`和`unique()` STL算法的实际用法。
- en: 'The output can be viewed with the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the program is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output and the program are pretty self-explanatory.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 输出和程序都很容易理解。
- en: Deque
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Deque
- en: The deque container is a double-ended queue and the data structure used could
    be a dynamic array or a vector. In a deque, it is possible to insert an element
    both at the front and back, with a constant time complexity of *O(1)*, unlike
    vectors, in which the time complexity of inserting an element at the back is *O(1)*
    while that for inserting an element at the front is *O(N)*. The deque doesn't
    suffer from the problem of reallocation, which is suffered by a vector. However,
    all the benefits of a vector are there with deque, except that deque is slightly
    better in terms of performance as compared to a vector as there are several rows
    of dynamic arrays or vectors in each row.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: deque容器是一个双端队列，其使用的数据结构可以是动态数组或向量。在deque中，可以在前面和后面插入元素，时间复杂度为*O(1)*，而在向量中，插入元素在后面的时间复杂度为*O(1)*，而在前面的时间复杂度为*O(N)*。deque不会遭受向量遭受的重新分配问题。然而，deque具有向量的所有优点，除了在性能方面稍微优于向量，因为每一行都有几行动态数组或向量。
- en: 'The following diagram shows the internal data structure used in a deque container:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了deque容器中使用的内部数据结构：
- en: '![](img/861700ea-0d37-4ff0-9312-3fe6845d4002.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/861700ea-0d37-4ff0-9312-3fe6845d4002.png)'
- en: 'Let''s write a simple program to try out the deque container:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来尝试deque容器：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output can be viewed with the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the program is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Commonly used APIs in a deque
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: deque中常用的API
- en: 'The following table shows the commonly used deque APIs:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了常用的deque API：
- en: '| **API** | **Description** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( int index )` | This returns the value stored at the indexed position.
    It throws the `std::out_of_range` exception if the index is invalid. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `at ( int index )` | 返回索引位置存储的值。如果索引无效，则抛出`std::out_of_range`异常。|'
- en: '| `operator [ int index ]` | This returns the value stored at the indexed position.
    It is faster than `at( int index )` since no bounds checking is performed by this
    function. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `operator [ int index ]` | 返回索引位置存储的值。这个函数比`at( int index )`更快，因为它不执行边界检查。|'
- en: '| `front()` | This returns the first value stored in the deque. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `front()` | 返回deque中存储的第一个值。|'
- en: '| `back() ` | This returns the last value stored in the deque. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `back() ` | 返回deque中存储的最后一个值。|'
- en: '| `empty()` | This returns `true` if the deque is empty and `false`, otherwise.
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果deque为空则返回`true`，否则返回`false`。|'
- en: '| `size() ` | This returns the number of values stored in the deque. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `size() ` | 返回deque中存储的值的数量。|'
- en: '| `capacity()` | This returns the total capacity of the deque, while `size()`
    returns the actual number of values stored in the deque. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `capacity()` | 返回deque的总容量，而`size()`返回deque中实际存储的值的数量。|'
- en: '| `clear() ` | This clears all the values. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `clear() ` | 清除所有的值。|'
- en: '| `push_back<data_type>( value )` | This adds a new value at the end of the
    deque. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `push_back<data_type>( value )` | 在deque的末尾添加一个新值。|'
- en: Associative containers
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联容器
- en: Associative containers store data in a sorted fashion, unlike the sequence containers.
    Hence, the order in which the data is inserted will not be retained by the associative
    containers. Associative containers are highly efficient in searching a value with
    *O( log n )* runtime complexity. Every time a new value gets added to the container,
    the container will reorder the values stored internally if required.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器以有序方式存储数据，与序列容器不同。因此，关联容器不会保留插入数据的顺序。关联容器在搜索值时非常高效，具有*O(log n)*的运行时复杂度。每次向容器添加新值时，如果需要，容器将重新排序内部存储的值。
- en: 'The STL supports the following types of associative containers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持以下类型的关联容器：
- en: Set
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Map
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Multiset
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重集合
- en: Multimap
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重映射
- en: Unordered set
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序集合
- en: Unordered multiset
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重集合
- en: Unordered map
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序映射
- en: Unordered multimap
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: 'Associative containers organize the data as key-value pairs. The data will
    be sorted based on the key for random and faster access. Associative containers
    come in two flavors:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器将数据组织为键值对。数据将根据键进行排序，以实现随机和更快的访问。关联容器有两种类型：
- en: Ordered
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序
- en: Unordered
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序
- en: 'The following associative containers come under ordered containers, as they
    are ordered/sorted in a particular fashion. Ordered associative containers generally
    use some form of **Binary Search Tree** (**BST**); usually, a red-black tree is
    used to store the data:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关联容器属于有序容器，因为它们按特定顺序/排序。有序关联容器通常使用某种形式的**二叉搜索树**（**BST**）；通常使用红黑树来存储数据：
- en: Set
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Map
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Multiset
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重集合
- en: Multimap
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重映射
- en: 'The following associative containers come under unordered containers, as they
    are not ordered in any particular fashion and they use hash tables:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关联容器属于无序容器，因为它们没有按特定顺序排序，并且它们使用哈希表：
- en: Unordered Set
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序集合
- en: Unordered Map
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序映射
- en: Unordered Multiset
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重集合
- en: Unordered Multimap
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: Let's understand the previously mentioned containers with examples in the following
    subsections.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下子节中通过示例了解先前提到的容器。
- en: Set
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A set container stores only unique values in a sorted fashion. A set organizes
    the values using the value as a key. The set container is immutable, that is,
    the values stored in a set can't be modified; however, the values can be deleted.
    A set generally uses a red-black tree data structure, which is a form of balanced
    BST. The time complexity of set operations are guaranteed to be *O ( log N )*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 集合容器仅以有序方式存储唯一值。集合使用值作为键来组织值。集合容器是不可变的，也就是说，存储在集合中的值不能被修改；但是可以删除值。集合通常使用红黑树数据结构，这是一种平衡二叉搜索树。集合操作的时间复杂度保证为*O(log
    N)*。
- en: 'Let''s write a simple program using a set:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个集合编写一个简单的程序：
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output can be viewed with the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the program is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Code walkthrough
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code declares and initializes two sets, `s1` and `s2`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明并初始化两个集合`s1`和`s2`：
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following line will ensure that the vector has enough room to store the
    values in the resultant vector:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将确保向量有足够的空间来存储结果向量中的值：
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code will print the values in `s1` and `s2`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印`s1`和`s2`中的值：
- en: '[PRE36]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `set_difference()` algorithm will populate the vector `v` with values only
    present in set `s1` but not in `s2`. The iterator, `pos`, will point to the last
    element in the vector; hence, the vector `resize` will ensure that the extra spaces
    in the vector are removed:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_difference()`算法将向量`v`填充为仅存在于集合`s1`中而不在`s2`中的值。迭代器`pos`将指向向量中的最后一个元素；因此，向量`resize`将确保向量中的额外空间被移除：'
- en: '[PRE37]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following code will print the values populated in the vector `v`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印填充到向量`v`中的值：
- en: '[PRE38]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `set_union()` algorithm will merge the contents of sets `s1` and `s2` into
    the vector, and the vector is then resized to fit only the merged values:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_union()`算法将合并集合`s1`和`s2`的内容到向量中，然后向量被调整大小以适应合并后的值：'
- en: '[PRE39]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code will print the merged values populated in the vector `v`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印填充到向量`v`中的合并值：
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Commonly used APIs in a set
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合中常用的API
- en: 'The following table describes the commonly used set APIs:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了常用的集合API：
- en: '| **API** | **Description** |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `insert( value )` | This inserts a value into the set |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `insert( value )` | 这将值插入到集合中 |'
- en: '| `clear()` | This clears all the values in the set |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 这将清除集合中的所有值 |'
- en: '| `size()` | This returns the total number of entries present in the set |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 这将返回集合中存在的条目总数 |'
- en: '| `empty()` | This will print `true` if the set is empty, and returns `false` otherwise
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果集合为空，则打印`true`，否则返回`false` |'
- en: '| `find()` | This finds the element with the specified key and returns the
    iterator position |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `find()` | 这将查找具有指定键的元素并返回迭代器位置 |'
- en: '| `equal_range()` | This returns the range of elements matching a specific
    key |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `equal_range()` | 这将返回与特定键匹配的元素范围 |'
- en: '| `lower_bound()` | This returns an iterator to the first element not less than
    the given key |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `lower_bound()` | 这将返回指向第一个不小于给定键的元素的迭代器 |'
- en: '| `upper_bound()` | This returns an iterator to the first element greater than
    the given key  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `upper_bound()` | 这将返回指向第一个大于给定键的元素的迭代器 |'
- en: Map
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: A map stores the values organized by keys. Unlike a set, a map has a dedicated
    key per value.  Maps generally use a red-black tree as an internal data structure,
    which is a balanced BST that guarantees *O( log N )* runtime efficiency for searching
    or locating a value in the map. The values stored in a map are sorted based on
    the key, using a red-black tree. The keys used in a map must be unique. A map
    will not retain the sequences of the input as it reorganizes the values based
    on the key, that is, the red-black tree will be rotated to balance the red-black
    tree height.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 映射按键组织值。与集合不同，映射每个值都有一个专用键。映射通常使用红黑树作为内部数据结构，这是一种平衡的BST，可以保证在映射中搜索或定位值的*O(log
    N)*运行效率。映射中存储的值根据键使用红黑树进行排序。映射中使用的键必须是唯一的。映射不会保留输入的顺序，因为它根据键重新组织值，也就是说，红黑树将被旋转以平衡红黑树高度。
- en: 'Let''s write a simple program to understand map usage:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来理解映射的用法：
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s compile and check the output of the program:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并检查程序的输出：
- en: '[PRE42]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE43]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Code walkthrough
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码漫步
- en: 'The following line declares a map with a `string` name as the key and a `long`
    mobile number as the value stored in the map:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行声明了一个映射，其中`string`名称作为键，`long`移动号码作为映射中存储的值：
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following code snippet adds four contacts organized by name as the key:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段按名称添加了四个联系人：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following line will try to locate the contact with the name, `Sriram`,
    in the contacts map; if `Sriram` is found, then the `find()` function will return
    the iterator pointing to the location of the key-value pair; otherwise it returns
    the `contacts.end()` position:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将尝试在联系人映射中定位名称为`Sriram`的联系人；如果找到`Sriram`，则`find()`函数将返回指向键值对位置的迭代器；否则返回`contacts.end()`位置：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following code verifies whether the iterator, `pos`, has reached `contacts.end()`
    and prints the contact number. Since the map is an associative container, it stores
    a `key=>value` pair; hence, `pos->first` indicates the key and `pos->second` indicates
    the value:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码验证了迭代器`pos`是否已经到达`contacts.end()`并打印联系人号码。由于映射是一个关联容器，它存储一个`key=>value`对；因此，`pos->first`表示键，`pos->second`表示值：
- en: '[PRE47]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Commonly used APIs in a map
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射中常用的API
- en: 'The following table shows the commonly used map APIs:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表显示了常用的映射API：
- en: '| **API** | **Description** |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `at ( key )` | This returns the value for the corresponding key if the key
    is found; otherwise it throws the `std::out_of_range` exception |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `at ( key )` | 如果找到键，则返回相应键的值；否则抛出`std::out_of_range`异常 |'
- en: '| `operator[ key ]` | This updates an existing value for the corresponding
    key if the key is found; otherwise it will add a new entry with the respective
    `key=>value` supplied |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `operator[ key ]` | 如果找到键，则更新相应键的现有值；否则，将添加一个具有提供的`key=>value`的新条目 |'
- en: '| `empty()` | This returns `true` if the map is empty, and `false` otherwise
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果映射为空，则返回`true`，否则返回`false` |'
- en: '| `size()` | This returns the count of the `key=>value` pairs stored in the
    map |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 返回映射中存储的`key=>value`对的数量 |'
- en: '| `clear()` | This clears the entries stored in the map |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `clear()` | 清除映射中存储的条目 |'
- en: '| `count()` | This returns the number of elements matching the given key |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `count()` | 返回与给定键匹配的元素数 |'
- en: '| `find()` | This finds the element with the specified key |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `find()` | 查找具有指定键的元素 |'
- en: Multiset
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Multiset
- en: A multiset container works in a manner similar to a set container, except for
    the fact that a set allows only unique values to be stored whereas a multiset
    lets you store duplicate values. As you know, in the case of set and multiset
    containers, the values themselves are used as keys to organize the data. A multiset
    container is just like a set; it doesn't allow modifying the values stored in
    the multiset.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 多重集合容器的工作方式与集合容器类似，只是集合只允许存储唯一值，而多重集合允许存储重复值。在集合和多重集合容器的情况下，值本身被用作键来组织数据。多重集合容器就像集合一样；它不允许修改多重集合中存储的值。
- en: 'Let''s write a simple program using a multiset:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用多重集合编写一个简单的程序：
- en: '[PRE48]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output can be viewed with the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令查看输出：
- en: '[PRE49]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output of the program is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Interestingly, in the preceding output, you can see that the multiset holds
    duplicate values.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在前面的输出中，您可以看到multiset包含重复的值。
- en: Multimap
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Multimap
- en: A multimap works exactly as a map, except that a multimap container will allow
    multiple values to be stored with the same key.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 多重映射的工作方式与映射完全相同，只是多重映射容器允许使用相同的键存储多个值。
- en: 'Let''s explore the multimap container with a simple example:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来探索multimap容器：
- en: '[PRE51]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编译程序并使用以下命令查看输出：
- en: '[PRE52]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output of the program is as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE53]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Unordered sets
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序集合
- en: An unordered set works in a manner similar to a set, except that the internal
    behavior of these containers differs. A set makes use of red-black trees while
    an unordered set makes use of hash tables. The time complexity of set operations
    is *O( log N)* while the time complexity of unordered set operations is *O(1)*;
    hence, the unordered set tends to be faster than the set.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合的工作方式类似于集合，只是这些容器的内部行为不同。集合使用红黑树，而无序集合使用哈希表。集合操作的时间复杂度为*O(log N)*，而无序集合操作的时间复杂度为*O(1)*；因此，无序集合往往比集合更快。
- en: The values stored in an unordered set are not organized in any particular fashion,
    unlike in a set, which stores values in a sorted fashion. If performance is the
    criteria, then an unordered set is a good bet; however, if iterating the values
    in a sorted fashion is a requirement, then set is a good choice.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合中存储的值没有特定的顺序，不像集合那样以排序的方式存储值。如果性能是标准，那么无序集合是一个不错的选择；然而，如果需要以排序的方式迭代值，那么集合是一个不错的选择。
- en: Unordered maps
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序映射
- en: An unordered map works in a manner similar to a map, except that the internal
    behavior of these containers differs. A map makes use of red-black trees while
    unordered map makes use of hash tables. The time complexity of map operations
    is *O( log N)* while that of unordered map operations is *O(1);* hence, an unordered
    map tends to be faster than a map.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 无序映射的工作方式类似于映射，只是这些容器的内部行为不同。映射使用红黑树，而无序映射使用哈希表。映射操作的时间复杂度为*O(log N)*，而无序映射操作的时间复杂度为*O(1)*；因此，无序映射比映射更快。
- en: The values stored in an unordered map are not organized in any particular fashion,
    unlike in a map where values are sorted by keys.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 无序映射中存储的值没有特定的顺序，不像映射中的值按键排序。
- en: Unordered multisets
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序多重集
- en: An unordered multiset works in a manner similar to a multiset, except that the
    internal behavior of these containers differs. A multiset makes use of red-black
    trees while an unordered multiset makes use of hash tables. The time complexity
    of multiset operations is *O( log N)* while that of unordered multiset operations
    is *O(1)*. Hence, an unordered multiset tends to be faster than a multiset.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重集的工作方式类似于多重集，只是这些容器的内部行为不同。多重集使用红黑树，而无序多重集使用哈希表。多重集操作的时间复杂度为*O(log N)*，而无序多重集操作的时间复杂度为*O(1)*。因此，无序多重集比多重集更快。
- en: The values stored in an unordered multiset are not organized in any particular
    fashion, unlike in a multiset where values are stored in a sorted fashion. If
    performance is the criteria, unordered multisets are a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multiset is a good choice.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重集中存储的值没有特定的顺序，不像多重集中的值以排序的方式存储。如果性能是标准，无序多重集是一个不错的选择；然而，如果需要以排序的方式迭代值，那么多重集是一个不错的选择。
- en: Unordered multimaps
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无序多重映射
- en: An unordered multimap works in a manner similar to a multimap, except that the
    internal behavior of these containers differs. A multimap makes use of red-black
    trees while an unordered multimap makes use of hash tables. The time complexity
    of multimap operations is *O( log N)* while that of unordered multimap operations
    is *O(1)*; hence, an unordered multimap tends to be faster than a multimap.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重映射的工作方式类似于多重映射，只是这些容器的内部行为不同。多重映射使用红黑树，而无序多重映射使用哈希表。多重映射操作的时间复杂度为*O(log
    N)*，而无序多重映射操作的时间复杂度为*O(1)*；因此，无序多重映射比多重映射更快。
- en: The values stored in an unordered multimap are not organized in any particular
    fashion, unlike in multimaps where values are sorted by keys. If performance is
    the criteria, then an unordered multimap is a good bet; however, if iterating
    the values in a sorted fashion is a requirement, then multimap is a good choice.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 无序多重映射中存储的值没有特定的顺序，不像多重映射中的值按键排序。如果性能是标准，那么无序多重映射是一个不错的选择；然而，如果需要以排序的方式迭代值，那么多重映射是一个不错的选择。
- en: Container adapters
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器适配器
- en: Container adapters adapt existing containers to provide new containers. In simple
    terms, STL extension is done with composition instead of inheritance.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 容器适配器将现有容器适配为新容器。简单来说，STL扩展是通过组合而不是继承完成的。
- en: STL containers can't be extended by inheritance, as their constructors aren't
    virtual. Throughout the STL, you can observe that while static polymorphism is
    used both in terms of operator overloading and templates, dynamic polymorphism
    is consciously avoided for performance reasons. Hence, extending the STL by subclassing
    the existing containers isn't a good idea, as it would lead to memory leaks because
    container classes aren't designed to behave like base classes.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: STL容器不能通过继承进行扩展，因为它们的构造函数不是虚拟的。在整个STL中，您可以观察到静态多态性在操作符重载和模板方面都得到了使用，而出于性能原因，动态多态性被有意地避免使用。因此，通过对现有容器进行子类化来扩展STL不是一个好主意，因为这会导致内存泄漏，因为容器类不是设计成像基类一样行为的。
- en: 'The STL supports the following container adapters:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: STL支持以下容器适配器：
- en: Stack
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Queue
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Priority Queue
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Let's explore the container adapters in the following subsections.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下小节中探索容器适配器。
- en: Stack
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: Stack is not a new container; it is a template adapter class. The adapter containers
    wrap an existing container and provide high-level functionalities. The stack adapter
    container offers stack operations while hiding the unnecessary functionalities
    that are irrelevant for a stack. The STL stack makes use of a deque container
    by default; however, we can instruct the stack to use any existing container that
    meets the requirement of the stack during the stack instantiation.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 栈不是一个新的容器；它是一个模板适配器类。适配器容器包装现有容器并提供高级功能。栈适配器容器提供栈操作，同时隐藏对栈不相关的不必要功能。STL栈默认使用deque容器；然而，我们可以在栈实例化期间指示栈使用满足栈要求的任何现有容器。
- en: Deques, lists, and vectors meet the requirements of a stack adapter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列、列表和向量满足栈适配器的要求。
- en: A stack operates on the **Last In First Out** (**LIFO**) philosophy.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 栈遵循**后进先出**（**LIFO**）的原则。
- en: Commonly used APIs in a stack
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈中常用的API
- en: 'The following table shows commonly used stack APIs:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的栈API：
- en: '| **API** | **Description** |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **API** | **描述** |'
- en: '| `top()` | This returns the top-most value in the stack, that is, the value
    that was added last |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `top()` | 返回栈中的最顶部值，即最后添加的值 |'
- en: '| `push<data_type>( value )` | This will push the value provided to the top
    of the stack |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `push<data_type>( value )` | 这将把提供的值推到栈顶 |'
- en: '| `pop()` | This will remove the top-most value from the stack  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 这将从栈中移除最顶部的值 |'
- en: '| `size()` | This returns the number of values present in the stack |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `size()` | 返回栈中存在的值的数量 |'
- en: '| `empty()` | This returns `true` if the stack is empty; otherwise it returns
    `false` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `empty()` | 如果栈为空则返回`true`；否则返回`false` |'
- en: 'It''s time to get our hands dirty; let''s write a simple program to use a stack:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候动手写一个简单的程序来使用栈了：
- en: '[PRE54]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以通过以下命令编译，并查看输出：
- en: '[PRE55]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of the program is as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE56]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the preceding output, we can see the LIFO behavior of stack.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到栈的LIFO行为。
- en: Queue
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: A queue works based on the **First In First Out** (**FIFO**) principle. A queue is
    not a new container; it is a templatized adapter class that wraps an existing
    container and provides the high-level functionalities that are required for queue
    operations, while hiding the unnecessary functionalities that are irrelevant for
    a queue. The STL queue makes use of a deque container by default; however, we
    can instruct the queue to use any existing container that meets the requirement
    of the queue during the queue instantiation.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 队列基于**先进先出**（**FIFO**）原则工作。队列不是一个新的容器；它是一个模板化的适配器类，包装现有容器并提供队列操作所需的高级功能，同时隐藏对队列无关的不必要功能。STL队列默认使用deque容器；但是，在队列实例化期间，我们可以指示队列使用满足队列要求的任何现有容器。
- en: In a queue, new values can be added at the back and removed from the front.
    Deques, lists, and vectors meet the requirements of a queue adapter.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中，新值可以添加到后面，并从前面移除。双端队列、列表和向量满足队列适配器的要求。
- en: Commonly used APIs in a queue
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列中常用的API
- en: 'The following table shows the commonly used queue APIs:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的队列API：
- en: '| **API** | **Description** |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: API描述
- en: '| `push()` | This appends a new value at the back of the queue |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '`push()` 在队列的后面添加一个新值'
- en: '| `pop()` | This removes the value at the front of the queue |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '`pop()` 移除队列前面的值'
- en: '| `front()` | This returns the value in the front of the queue |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '`front()` 返回队列前面的值'
- en: '| `back()` | This returns the value at the back of the queue |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '`back()` 返回队列的后面的值'
- en: '| `empty()` | This returns `true` when the queue is empty; otherwise it returns
    `false` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '`empty()` 当队列为空时返回`true`；否则返回`false`'
- en: '| `size()` | This returns the number of values stored in the queue |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '`size()` 返回队列中存储的值的数量'
- en: 'Let''s use a queue in the following program:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下程序中使用队列：
- en: '[PRE57]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The program can be compiled and the output can be viewed with the following
    commands:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以通过以下命令编译，并查看输出：
- en: '[PRE58]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output of the program is as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE59]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: From the preceding output, you can observe that the values were popped out in
    the same sequence that they were pushed in, that is, FIFO.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以观察到值以与它们被推入的相同顺序弹出，即FIFO。
- en: Priority queue
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A priority queue is not a new container; it is a templatized adapter class that
    wraps an existing container and provides high-level functionalities that are required
    for priority queue operations, while hiding the unnecessary functionalities that
    are irrelevant for a priority queue. A priority queue makes use of a vector container
    by default; however, a deque container also meets the requirement of the priority
    queue. Hence, during the priority queue instantiation, you could instruct the
    priority queue to make use of a deque as well.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列不是一个新的容器；它是一个模板化的适配器类，包装现有容器并提供优先队列操作所需的高级功能，同时隐藏对优先队列无关的不必要功能。优先队列默认使用vector容器；但是，deque容器也满足优先队列的要求。因此，在优先队列实例化期间，您可以指示优先队列也使用deque。
- en: A priority queue organizes the data in such a way that the highest priority
    value appears first; in other words, the values are sorted in a descending order.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列以使最高优先级值首先出现的方式组织数据；换句话说，值按降序排序。
- en: The deque and vector meet the requirements of a priority queue adaptor.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: deque和vector满足优先队列适配器的要求。
- en: Commonly used APIs in a priority queue
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列中常用的API
- en: 'The following table shows commonly used priority queue APIs:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了常用的优先队列API：
- en: '| **API** | **Description** |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: API描述
- en: '| `push()` | This appends a new value at the back of the priority queue |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '`push()` 在优先队列的后面添加一个新值'
- en: '| `pop()` | This removes the value at the front of the priority queue |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '`pop()` 移除优先队列前面的值'
- en: '| `empty()` | This returns `true` when the priority queue is empty; otherwise
    it returns `false` |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '`empty()` 当优先队列为空时返回`true`；否则返回`false`'
- en: '| `size()` | This returns the number of values stored in the priority queue
    |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '`size()` 返回优先队列中存储的值的数量'
- en: '| `top()` | This returns the value in the front of the priority queue |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '`top()` 返回优先队列前面的值'
- en: 'Let''s write a simple program to understand `priority_queue`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来理解`priority_queue`：
- en: '[PRE60]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The program can be compiled and the output can be viewed with the following
    command:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以通过以下命令编译，并查看输出：
- en: '[PRE61]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output of the program is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE62]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: From the preceding output, you can observe that `priority_queue` is a special
    type of queue that reorders the inputs in such a way that the highest value appears
    first.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，您可以观察到`priority_queue`是一种特殊类型的队列，它重新排列输入，使最高值首先出现。
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter you learned about ready-made generic containers, functors, iterators,
    and algorithms. You also learned set, map, multiset, and multimap associative
    containers, their internal data structures, and common algorithms that can be
    applied on them. Further you learned how to use the various containers with practical
    hands-on code samples.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了现成的通用容器、函数对象、迭代器和算法。您还学习了集合、映射、多重集和多重映射关联容器，它们的内部数据结构，以及可以应用于它们的常见算法。此外，您还学习了如何使用各种容器，并进行了实际的代码示例。
- en: In the next chapter, you will learn template programming, which helps you master
    the essentials of templates.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习模板编程，这将帮助您掌握模板的基本知识。
