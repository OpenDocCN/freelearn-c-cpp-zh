["```cpp\n#define DEG_TO_RAD(deg) ((float)deg/180.0)*3.14159\n#define RAD_TO_DEG(rad) ((float)rad*180.0)/3.14159\n```", "```cpp\n#define CANVAS_WIDTH 800\n#define CANVAS_HEIGHT 600\n```", "```cpp\nextern float get_random_float( float min, float max );\n```", "```cpp\nclass Ship;\nclass Particle;\nclass Emitter;\nclass Collider;\nclass Asteroid;\nclass Star;\nclass PlayerShip;\nclass EnemyShip;\nclass Projectile;\nclass ProjectilePool;\nclass FiniteStateMachine;\n```", "```cpp\nenum FSM_STATE {\n    APPROACH = 0,\n    ATTACK = 1,\n    FLEE = 2,\n    WANDER = 3\n};\n```", "```cpp\nclass Vector2D {\n    public:\n        float x;\n        float y;\n\n        Vector2D();\n        Vector2D( float X, float Y );\n\n        void Rotate( float radians );\n        void Normalize();\n        float MagSQ();\n        float Magnitude();\n        Vector2D Project( Vector2D &onto );\n        float Dot(Vector2D &vec);\n        float FindRotation();\n\n        Vector2D operator=(const Vector2D &vec);\n        Vector2D operator*(const float &scalar);\n        void operator+=(const Vector2D &vec);\n        void operator-=(const Vector2D &vec);\n        void operator*=(const float &scalar);\n        void operator/=(const float &scalar);\n };\n```", "```cpp\nclass Range {\n    public:\n        float min;\n        float max;\n\n        Range();\n        Range( float min_val, float max_val );\n\n        void operator+=(const Range& range);\n        Range operator+(const Range& range);\n        Range operator=(const Range& range);\n\n        bool Overlap( Range &other );\n        void Sort();\n        void Extend( float ex );\n        float Clamp( float value );\n };\n```", "```cpp\nfloat m_SteeringRadius;\nfloat m_SteeringRadiusSQ;\n```", "```cpp\nbool SteeringLineTest( Vector2D &p1, Vector2D &p2 );\nbool SteeringRectTest( Vector2D &start_point, Vector2D &end_point );\nvoid WrapPosition();\n```", "```cpp\nclass Shield : public Collider {\n    public:\n        bool m_Active;\n        int m_ttl;\n        int m_NextFrame;\n        Uint32 m_CurrentFrame;\n        Ship* m_Ship;\n        SDL_Texture *m_SpriteTexture;\n\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 32, .h = 32 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 32, .h = 32 };\n\n        Shield( Ship* ship, const char* sprite_file );\n\n        void Move();\n        void Render();\n        bool Activate();\n        void Deactivate();\n};\n```", "```cpp\nclass Asteroid : public Collider {\n    public:\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 16, .h = 16 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 0, .h = 0 };\n\n        bool m_Alive;\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n        float m_Rotation;\n\n        Vector2D m_Direction;\n        Vector2D m_Velocity;\n\n        Emitter* m_Explode;\n        Emitter* m_Chunks;\n\n        Asteroid( float x, float y,\n                  float velocity,\n                  float rotation );\n\n        void Move();\n        void Render();\n        void Explode();\n};\n```", "```cpp\nclass Star : public Collider {\n    public:\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 64, .h = 64 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 64, .h = 64 };\n\n        std::vector<Emitter*> m_FlareList;\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n\n        Star();\n\n        void Move();\n        void Render();\n};\n```", "```cpp\nclass Ship : public Collider {\n    public:\n        const float c_Acceleration = 10.0f;\n        const float c_MaxVelocity = 50.0f;\n        const int c_AliveTime = 2000;\n        const Uint32 c_MinLaunchTime = 300;\n        const int c_Width = 32;\n        const int c_Height = 32;\n\n        bool m_Accelerating = false;\n        Uint32 m_LastLaunchTime;\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect src = {.x = 0, .y = 0, .w = 32, .h = 32 };\n\n        Emitter* m_Explode;\n        Emitter* m_Exhaust;\n        Shield* m_Shield;\n        std::vector<Collider*> m_Colliders;\n\n        bool m_Alive = true;\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n        float m_Rotation;\n\n        Vector2D m_Direction;\n        Vector2D m_Velocity;\n\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n        void Shoot();\n        virtual void Move() = 0;\n        Ship();\n        void Render();\n        bool CompoundHitTest( Collider* collider );\n};\n```", "```cpp\nShield* m_Shield;\n```", "```cpp\ndouble m_DX;  // x-direction variable\ndouble m_DY;  // y-direction variable\ndouble m_VX;  // x-velocity variable\ndouble m_VY;  // y-velocity variable\n```", "```cpp\nVector2D m_Direction;\nVector2D m_Velocity;\n```", "```cpp\nvoid Shoot();\n```", "```cpp\nclass EnemyShip: public Ship {\n    public:\n        const char* c_SpriteFile = \"/sprites/BirdOfAngerExp.png\";\n        const char* c_ShieldSpriteFile = \"/sprites/shield-bird.png\";\n        const int c_AIStateTime = 2000;\n\n        int m_AIStateTTL;\n        FiniteStateMachine* m_FSM;\n\n        EnemyShip();\n        void Move();\n};\n```", "```cpp\nclass FiniteStateMachine {\n    public:\n        const float c_AttackDistSq = 40000.0;\n        const float c_FleeDistSq = 2500.0;\n        const int c_MinRandomTurnMS = 100;\n        const int c_RandTurnMS = 3000;\n        const int c_ShieldDist = 20;\n        const int c_AvoidDist = 80;\n        const int c_StarAvoidDistSQ = 20000;\n        const int c_ObstacleAvoidForce = 150;\n        const int c_StarAvoidForce = 120;\n\n        FSM_STATE m_CurrentState;\n        EnemyShip* m_Ship;\n        bool m_HasLOS;\n        bool m_LastTurnLeft;\n        int m_SameTurnPct;\n        int m_NextTurnMS;\n        int m_CheckCycle;\n        float m_DesiredRotation;\n        float m_PlayerDistSQ;\n\n        FiniteStateMachine(EnemyShip* ship);\n\n        void SeekState(Vector2D &seek_point);\n        void FleeState(Vector2D &flee_point);\n        void WanderState();\n        void AttackState();\n        void AvoidForce();\n        bool ShieldCheck();\n        bool LOSCheck();\n        Vector2D PredictPosition();\n        float GetPlayerDistSq();\n        void Move();\n};\n```", "```cpp\n const float c_AttackDistSq = 40000.0;\n const float c_FleeDistSq = 2500.0;\n const int c_MinRandomTurnMS = 100;\n const int c_RandTurnMS = 3000;\n const int c_ShieldDist = 20;\n const int c_AvoidDist = 80;\n const int c_StarAvoidDistSQ = 20000;\n const int c_ObstacleAvoidForce = 150;\n const int c_StarAvoidForce = 120;\n```", "```cpp\n FSM_STATE m_CurrentState;\n EnemyShip* m_Ship;\n bool m_HasLOS;\n bool m_LastTurnLeft;\n int m_SameTurnPct;\n int m_NextTurnMS;\n int m_CheckCycle;\n float m_DesiredRotation;\n float m_PlayerDistSQ;\n```", "```cpp\nclass Projectile: public Collider {\n    public:\n        const char* c_SpriteFile = \"sprites/ProjectileExp.png\";\n        const int c_Width = 16;\n        const int c_Height = 16;\n        const double velocity = 6.0;\n        const double alive_time = 2000;\n\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect src = {.x = 0, .y = 0, .w = 16, .h = 16 };\n\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n        bool m_Active;\n        float m_TTL;\n        float m_VX;\n        float m_VY;\n\n        Projectile();\n        void Move();\n        void Render();\n        void Launch(double x, double y, double dx, double dy);\n};\n```", "```cpp\nextern std::vector<Asteroid*> asteroid_list;\nextern Star* star;\n```", "```cpp\nclass Star : public Collider {\n    public:\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 64, .h = 64 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 64, .h = 64 };\n\n        std::vector<Emitter*> m_FlareList;\n\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n\n        Star();\n\n        void Move();\n        void Render();\n};\n```", "```cpp\n#include \"game.hpp\"\n```", "```cpp\n#define STAR_SPRITE_FILE \"/sprites/rotating-star.png\"\n#define FLARE_FILE (char*)\"/sprites/flare.png\"\n```", "```cpp\nStar::Star() : Collider(32.0) {\n    SDL_Surface *temp_surface = IMG_Load( STAR_SPRITE_FILE );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship surface\\n\");\n    }\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship texture\\n\");\n    }\n    SDL_FreeSurface( temp_surface );\n\n    m_Radius = 36;\n\n    m_Position.x = CANVAS_WIDTH / 2;\n    m_Position.y = CANVAS_HEIGHT / 2;\n\n    m_dest.x = m_Position.x - m_Radius / 2;\n    m_dest.y = m_Position.y - m_Radius / 2;\n\n    m_FlareList.push_back(new \n    Emitter(FLARE_FILE,100,160,220,1500,0.05,true,30,40, 1, \n    m_Position.x+8, m_Position.y+8, 10,0.1, 0.2,0.5, 1.0,0xffffff, \n    0xffffff, 0.1, 50,true, true, 4409, 1));\n\n    m_FlareList.push_back(new \n    Emitter(FLARE_FILE,100,220,280,1500,0.05,true,30,40, 1, m_Position.x+8, \n    m_Position.y+8,10,0.1,0.2,0.5,1.0,0xffffff, 0xffffff, 0.0, \n    50,true,true,3571, 1));\n\n    m_FlareList.push_back(new \n    Emitter(FLARE_FILE,100,280,360,1500,0.05,true,30,40, 1, \n    m_Position.x+8, m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, \n    0xffffff, 0.2, 50, true, true, 3989, 1));\n\n    m_FlareList.push_back(new \n    Emitter(FLARE_FILE,100,0,60,1500,0.05,true,30,40, 1, m_Position.x+8, \n    m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, 0xffffff, 0.1, 50, \n    true, true, 3371, 1));\n\n    m_FlareList.push_back(new \n    Emitter(FLARE_FILE,100,60,100,1500,0.05,true,30,40, 1, m_Position.x+8, \n    m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, 0xffffff, 0.3, 50, \n    true, true, 4637, 1));\n}\n```", "```cpp\nStar::Star() : Collider(32.0) {\n```", "```cpp\nSDL_Surface *temp_surface = IMG_Load( STAR_SPRITE_FILE );\n\nif( !temp_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return;\n}\nelse {\n    printf(\"success creating enemy ship surface\\n\");\n}\nm_SpriteTexture = SDL_CreateTextureFromSurface( renderer, temp_surface );\nif( !m_SpriteTexture ) {\n    printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n    return;\n}\nelse {\n    printf(\"success creating enemy ship texture\\n\");\n}\nSDL_FreeSurface( temp_surface );\n```", "```cpp\nm_Radius = 36;\nm_Position.x = CANVAS_WIDTH / 2;\nm_Position.y = CANVAS_HEIGHT / 2;\nm_dest.x = m_Position.x - m_Radius / 2;\nm_dest.y = m_Position.y - m_Radius / 2;\n```", "```cpp\nm_FlareList.push_back(new Emitter(FLARE_FILE,100,160,220,1500,0.05,true,30,40, 1, m_Position.x+8, m_Position.y+8, 10,0.1, 0.2,0.5, 1.0,0xffffff, 0xffffff, 0.1, 50,true, true,4409, 1));\n\nm_FlareList.push_back(new Emitter(FLARE_FILE,100,220,280,1500,0.05,true,30,40, 1, m_Position.x+8, m_Position.y+8,10,0.1,0.2,0.5,1.0,0xffffff, 0xffffff, 0.0, 50,true,true,3571, 1));\n\nm_FlareList.push_back(new Emitter(FLARE_FILE,100,280,360,1500,0.05,true,30,40, 1, m_Position.x+8, m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, 0xffffff, 0.2, 50, true, true, 3989, 1));\n\nm_FlareList.push_back(new Emitter(FLARE_FILE,100,0,60,1500,0.05,true,30,40, 1, m_Position.x+8, m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, 0xffffff, 0.1, 50, true, true, 3371, 1));\n\nm_FlareList.push_back(new Emitter(FLARE_FILE,100,60,100,1500,0.05,true,30,40, 1, m_Position.x+8, m_Position.y+8, 10, 0.1, 0.2, 0.5, 1.0, 0xffffff, 0xffffff, 0.3, 50, true, true, 4637, 1));\n```", "```cpp\nvoid Star::Move() {\n    m_NextFrameTime -= diff_time;\n    if( m_NextFrameTime <= 0 ) {\n        ++m_CurrentFrame;\n        m_NextFrameTime = ms_per_frame;\n        if( m_CurrentFrame >= 8 ) {\n            m_CurrentFrame = 0;\n        }\n    }\n}\n```", "```cpp\nvoid Star::Render() {\n    Emitter* flare;\n    std::vector<Emitter*>::iterator it;\n\n    for( it = m_FlareList.begin(); it != m_FlareList.end(); it++ ) {\n        flare = *it;\n        flare->Move();\n    }\n    m_src.x = m_dest.w * m_CurrentFrame;\n\n    SDL_RenderCopy( renderer, m_SpriteTexture,\n                    &m_src, &m_dest );\n}\n```", "```cpp\nclass Asteroid : public Collider {\n    public:\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 16, .h = 16 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 0, .h = 0 };\n\n        bool m_Alive;\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n        float m_Rotation;\n        Vector2D m_Direction;\n        Vector2D m_Velocity;\n\n        Emitter* m_Explode;\n        Emitter* m_Chunks;\n\n        Asteroid( float x, float y,\n                  float velocity,\n                  float rotation );\n\n        void Move();\n        void Render();\n        void Explode();\n};\n```", "```cpp\n#include \"game.hpp\"\n#define ASTEROID_SPRITE_FILE (char*)\"/sprites/asteroid.png\"\n```", "```cpp\nAsteroid::Asteroid( float x, float y,\n                    float velocity,\n                    float rotation ): Collider(8.0) {\n    SDL_Surface *temp_surface = IMG_Load( ADSTEROID_SPRITE_FILE );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating asteroid surface\\n\");\n    }\n\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating asteroid texture\\n\");\n    }\n\n    SDL_FreeSurface( temp_surface );\n\n    m_Explode = new Emitter((char*)\"/sprites/Explode.png\",\n         100, 0, 360,     // int max_particles, float min_angle, float \n         max_angle,\n         1000, 0.3, false, // Uint32 particle_lifetime, float acceleration, \n         bool alpha_fade,\n         20.0, 40.0,     // float min_starting_velocity, float \n         max_starting_velocity,\n         10, 0, 0, 5,     // Uint32 emission_rate, int x_pos, int y_pos, \n         float radius,\n         1.0, 2.0,         // float min_start_scale, float max_start_scale,\n         1.0, 2.0,         // float min_end_scale, float max_end_scale,\n         0xffffff, 0xffffff,\n         0.01, 10,         // float burst_time_pct, Uint32 burst_particles,\n         false, false,     // bool loop, bool align_rotation,\n         800, 8 );         // Uint32 emit_time_ms, Uint32 animation_frames\n    m_Explode->m_parent_rotation_ptr = &m_Rotation;\n    m_Explode->m_parent_x_ptr = &(m_Position.x);\n    m_Explode->m_parent_y_ptr = &(m_Position.y);\n    m_Explode->m_active = false;\n\n    m_Chunks = new Emitter((char*)\"/sprites/small-asteroid.png\",\n         40, 0, 360, // int max_particles, float min_angle, float \n         max_angle,\n         1000, 0.05, false, // Uint32 particle_lifetime, float \n         acceleration, \n         bool alpha_fade,\n         80.0, 150.0, // float min_starting_velocity, float \n         max_starting_velocity,\n         5, 0, 0, 10, // Uint32 emission_rate, int x_pos, int y_pos, \n         float radius,\n         2.0, 2.0, // float min_start_scale, float max_start_scale,\n         0.25, 0.5, // float min_end_scale, float max_end_scale,\n         0xffffff, 0xffffff,\n         0.1, 10, // float burst_time_pct, Uint32 burst_particles,\n         false, true, // bool loop, bool align_rotation,\n         1000, 8 ); // Uint32 emit_time_ms, Uint32 animation_frames\n\n    m_Chunks->m_parent_rotation_ptr = &m_Rotation;\n    m_Chunks->m_parent_x_ptr = &m_Position.x;\n    m_Chunks->m_parent_y_ptr = &m_Position.    \n    m_Chunks->m_active = false;\n\n    m_Position.x = x;\n    m_Position.y = y;\n\n    Vector2D direction;\n    direction.x = 1;\n    direction.Rotate( rotation );\n\n    m_Direction = direction;\n    m_Velocity = m_Direction * velocity;\n\n    m_dest.h = m_src.h = m_dest.w = m_src.w = 16;\n\n    m_Rotation = rotation;\n    m_Alive = true;\n    m_CurrentFrame = 0;\n    m_NextFrameTime = ms_per_frame;\n}\n```", "```cpp\nAsteroid::Asteroid( float x, float y,\n                    float velocity,\n                    float rotation ): Collider(8.0) {\n```", "```cpp\nSDL_Surface *temp_surface = IMG_Load( ADSTEROID_SPRITE_FILE );\n\nif( !temp_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return;\n}\nelse {\n    printf(\"success creating asteroid surface\\n\");\n}\n\nm_SpriteTexture = SDL_CreateTextureFromSurface( renderer, temp_surface );\n\nif( !m_SpriteTexture ) {\n    printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n    return;\n}\nelse {\n    printf(\"success creating asteroid texture\\n\");\n}\n\nSDL_FreeSurface( temp_surface );\n```", "```cpp\nm_Explode = new Emitter((char*)\"/sprites/Explode.png\",\n     100, 0, 360, // int max_particles, float min_angle, float max_angle,\n     1000, 0.3, false, // Uint32 particle_lifetime, float acceleration, \n     bool alpha_fade,\n     20.0, 40.0, // float min_starting_velocity, float \n     max_starting_velocity,\n     10, 0, 0, 5, // Uint32 emission_rate, int x_pos, int y_pos, \n     float radius,\n     1.0, 2.0, // float min_start_scale, float max_start_scale,\n     1.0, 2.0, // float min_end_scale, float max_end_scale,\n     0xffffff, 0xffffff,\n     0.01, 10, // float burst_time_pct, Uint32 burst_particles,\n     false, false, // bool loop, bool align_rotation,\n     800, 8 ); // Uint32 emit_time_ms, Uint32 animation_frames\n\nm_Explode->m_parent_rotation_ptr = &m_Rotation;\nm_Explode->m_parent_x_ptr = &(m_Position.x);\nm_Explode->m_parent_y_ptr = &(m_Position.y);\nm_Explode->m_active = false;\n```", "```cpp\nm_Chunks = new Emitter((char*)\"/sprites/small-asteroid.png\",\n     40, 0, 360, // int max_particles, float min_angle, float max_angle,\n     1000, 0.05, false, // Uint32 particle_lifetime, float acceleration, \n     bool alpha_fade,\n     80.0, 150.0, // float min_starting_velocity, float \n     max_starting_velocity,\n     5, 0, 0, 10, // Uint32 emission_rate, int x_pos, int y_pos, \n     float radius,\n     2.0, 2.0, // float min_start_scale, float max_start_scale,\n     0.25, 0.5, // float min_end_scale, float max_end_scale,\n     0xffffff, 0xffffff,\n     0.1, 10, // float burst_time_pct, Uint32 burst_particles,\n     false, true, // bool loop, bool align_rotation,\n     1000, 8 ); // Uint32 emit_time_ms, Uint32 animation_frames\n\nm_Chunks->m_parent_rotation_ptr = &m_Rotation;\nm_Chunks->m_parent_x_ptr = &m_Position.x;\nm_Chunks->m_parent_y_ptr = &m_Position.y;\nm_Chunks->m_active = false;\n```", "```cpp\nm_Position.x = x;\nm_Position.y = y;\n\nVector2D direction;\ndirection.x = 1;\ndirection.Rotate( rotation );\n\nm_Direction = direction;\nm_Velocity = m_Direction * velocity;\nm_dest.h = m_src.h = m_dest.w = m_src.w = 16;\n\nm_Rotation = rotation;\nm_Alive = true;\nm_CurrentFrame = 0;\nm_NextFrameTime = ms_per_frame;\n```", "```cpp\nvoid Asteroid::Move() {\nm_NextFrameTime -= diff_time;\nif( m_NextFrameTime <= 0 ) {\n    m_NextFrameTime = ms_per_frame;\n    m_CurrentFrame++;\n    if( m_CurrentFrame >= 8 ) {\n        m_CurrentFrame = 0;\n    }\n}\nm_Position += m_Velocity * delta_time;\nWrapPosition();\n}\n```", "```cpp\nm_NextFrameTime -= diff_time;\nif( m_NextFrameTime <= 0 ) {\n    m_NextFrameTime = ms_per_frame;\n    m_CurrentFrame++;\n\n    if( m_CurrentFrame >= 8 ) {\n        m_CurrentFrame = 0;\n    }\n}\n```", "```cpp\nm_Position += m_Velocity * delta_time;\n```", "```cpp\nvoid Asteroid::Render() {\n    m_Explode->Move();\n    m_Chunks->Move();\n    if( m_Alive == false ) {\n        return;\n    }\n    m_src.x = m_dest.w * m_CurrentFrame;\n    m_dest.x = m_Position.x + m_Radius / 2;\n    m_dest.y = m_Position.y + m_Radius / 2;\n    SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                        &m_src, &m_dest,\n                        RAD_TO_DEG(m_Rotation), NULL, SDL_FLIP_NONE );\n}\n```", "```cpp\nm_Explode->Move();\nm_Chunks->Move();\n```", "```cpp\nif( m_Alive == false ) {\n    return;\n}\n```", "```cpp\nm_src.x = m_dest.w * m_CurrentFrame;\nm_dest.x = m_Position.x + m_Radius / 2;\nm_dest.y = m_Position.y + m_Radius / 2;\nSDL_RenderCopyEx( renderer, m_SpriteTexture,\n                  &m_src, &m_dest,\n                  RAD_TO_DEG(m_Rotation), NULL, SDL_FLIP_NONE );\n```", "```cpp\nvoid Asteroid::Explode() {\n    m_Explode->Run();\n    m_Chunks->Run();\n    m_Alive = false;\n}\n```", "```cpp\nclass Shield : public Collider {\n    public:\n        bool m_Active;\n        int m_ttl;\n        int m_NextFrame;\n        Uint32 m_CurrentFrame;\n        Ship* m_Ship;\n        SDL_Texture *m_SpriteTexture;\n\n        SDL_Rect m_src = {.x = 0, .y = 0, .w = 32, .h = 32 };\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 32, .h = 32 };\n\n        Shield( Ship* ship, const char* sprite_file );\n\n        void Move();\n        void Render();\n        bool Activate();\n        void Deactivate();\n};\n```", "```cpp\nShield::Shield( Ship* ship, const char* sprite_string ) : Collider(12.0) {\n    m_Active = false;\n    m_ttl = 25500;\n    m_Ship = ship;\n    m_CurrentFrame = 0;\n    m_NextFrame = ms_per_frame;\n    SDL_Surface *temp_surface = IMG_Load( sprite_string );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n   temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nm_Active = false;\nm_ttl = 25500;\nm_Ship = ship;\nm_CurrentFrame = 0;\nm_NextFrame = ms_per_frame;\n```", "```cpp\nSDL_Surface *temp_surface = IMG_Load( sprite_string );\n\nif( !temp_surface ) {\n    printf(\"failed to load image: %s\\n\", IMG_GetError() );\n    return;\n}\n\nm_SpriteTexture = SDL_CreateTextureFromSurface( renderer, temp_surface );\n\nif( !m_SpriteTexture ) {\n    printf(\"failed to create texture: %s\\n\", IMG_GetError() );\nreturn;\n}\n\nSDL_FreeSurface( temp_surface );\n```", "```cpp\nvoid Shield::Move() {\n    if( m_Active ) {\n        m_NextFrame -= diff_time;\n        m_ttl -= diff_time;\n\n        if( m_NextFrame <= 0 ) {\n            m_NextFrame = ms_per_frame;\n            m_CurrentFrame++;\n\n            if( m_CurrentFrame >= 6 ) {\n                m_CurrentFrame = 0;\n            }\n        }\n        if( m_ttl <= 0 ) {\n            m_Active = false;\n        }\n    }\n}\n```", "```cpp\nvoid Shield::Render() {\n    if( m_Active ) {\n        int color_green = m_ttl / 100 + 1;\n        int color_red = 255 - color_green;\n        m_src.x = m_CurrentFrame * m_dest.w;\n        m_dest.x = m_Ship->m_Position.x;\n        m_dest.y = m_Ship->m_Position.y;\n\n        SDL_SetTextureColorMod(m_SpriteTexture,\n                             color_red,\n                             color_green,\n                             0 );\n\n        SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                             &m_src, &m_dest,\n                             RAD_TO_DEG(m_Ship->m_Rotation),\n                             NULL, SDL_FLIP_NONE );\n    }\n}\n```", "```cpp\nint color_green = m_ttl / 100 + 1;\nint color_red = 255 - color_green;\n```", "```cpp\nSDL_SetTextureColorMod(m_SpriteTexture,\n                     color_red,\n                     color_green,\n                     0 );\n```", "```cpp\nclass Collider {\n    public:\n        float* m_ParentRotation;\n        float* m_ParentX;\n        float* m_ParentY;\n        Vector2D m_TempPoint;\n\n        bool CCHitTest( Collider* collider );\n\n        Vector2D m_Position;\n        float m_Radius;\n        float m_SteeringRadius;\n        float m_SteeringRadiusSQ;\n\n        void SetParentInformation( float* rotation, float* x, float* y );\n        Collider(float radius);\n        bool HitTest( Collider *collider );\n        bool SteeringLineTest( Vector2D &p1, Vector2D &p2 );\n        bool SteeringRectTest( Vector2D &start_point, Vector2D &end_point \n        );\n        void WrapPosition();\n };\n```", "```cpp\nCollider::Collider(float radius) {\n    m_ParentRotation = NULL;\n    m_ParentX = NULL;\n    m_ParentY = NULL;\n\n    m_Radius = radius;\n    m_SteeringRadius = m_Radius * 1.5;\n    m_SteeringRadiusSQ = m_SteeringRadius * m_SteeringRadius;\n}\n```", "```cpp\nbool Collider::SteeringLineTest( Vector2D &start, Vector2D &end ) {\n    if( m_Active == false ) {\n        return false;\n    }\n    Vector2D dist = start;\n    dist -= m_Position;\n\n    if( m_SteeringRadiusSQ > dist.MagSQ() ) {\n        return true;\n    }\n    dist = end;\n    dist -= m_Position;\n\n    if( m_SteeringRadiusSQ > dist.MagSQ() ) {\n        return true;\n    }\n    dist = end;\n    dist -= start;\n\n    Vector2D circle_vec = m_Position;\n    circle_vec -= start;\n\n    Vector2D near_point = circle_vec.Project( dist );\n    near_point += start;\n\n    Vector2D temp_vector = near_point;\n    circle_vec += start;\n    temp_vector -= circle_vec;\n\n    Range x_range;\n    x_range.min = start.x;\n    x_range.max = end.x;\n    x_range.Sort();\n    Range y_range;\n    y_range.min = start.y;\n    y_range.max = end.y;\n    y_range.Sort();\n\n    if ((x_range.min <= near_point.x && near_point.x <= x_range.max &&\n         y_range.min <= near_point.y && near_point.y <= y_range.max) == \n         false) {\n        return false;\n    }\n    if( temp_vector.MagSQ() < m_SteeringRadiusSQ ) {\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nif( m_Active == false ) {\n    return false;\n}\n\nVector2D dist = start;\ndist -= m_Position;\n\nif( m_SteeringRadiusSQ > dist.MagSQ() ) {\n    return true;\n}\n\ndist = end;\ndist -= m_Position;\nif( m_SteeringRadiusSQ > dist.MagSQ() ) {\n    return true;\n}\n```", "```cpp\ndist = end;\ndist -= start;\n\nVector2D circle_vec = m_Position;\ncircle_vec -= start;\n\nVector2D near_point = circle_vec.Project( dist );\nnear_point += start;\n\nVector2D temp_vector = near_point;\ncircle_vec += start;\ntemp_vector -= circle_vec;\n```", "```cpp\nRange x_range;\nx_range.min = start.x;\nx_range.max = end.x;\nx_range.Sort();\n\nRange y_range;\ny_range.min = start.y;\ny_range.max = end.y;\ny_range.Sort();\n\nif ((x_range.min <= near_point.x && near_point.x <= x_range.max &&\n     y_range.min <= near_point.y && near_point.y <= y_range.max) == false) {\n    return false;\n}\n```", "```cpp\nif( m_SteeringRadiusSQ > dist.MagSQ() ) {\n    return true;\n}\nreturn false;\n```", "```cpp\nclass Vector2D {\n    public:\n        float x;\n        float y;\n\n        Vector2D();\n        Vector2D( float X, float Y );\n\n        void Rotate( float radians );\n        void Normalize();\n        float MagSQ();\n        float Magnitude();\n\n        Vector2D Project( Vector2D &onto );\n        float Dot(Vector2D &vec);\n        float FindAngle();\n\n        Vector2D operator=(const Vector2D &vec);\n        Vector2D operator*(const float &scalar);\n        void operator+=(const Vector2D &vec);\n        void operator-=(const Vector2D &vec);\n        void operator*=(const float &scalar);\n        void operator/=(const float &scalar);\n};\n```", "```cpp\n#include \"game.hpp\"\n\nVector2D::Vector2D( float X, float Y ) {\n    x = X;\n    y = Y;\n}\nVector2D::Vector2D() {\n    y = x = 0.0;\n}\nVector2D Vector2D::operator=(const Vector2D& p) {\n    x = p.x;\n    y = p.y;\n    return *this;\n}\nvoid Vector2D::operator+=(const Vector2D& p) {\n    x += p.x;\n    y += p.y;\n}\nvoid Vector2D::operator-=(const Vector2D& p) {\n    x -= p.x;\n    y -= p.y;\n}\nvoid Vector2D::operator*=(const float& scalar) {\n    x *= scalar;\n    y *= scalar;\n}\nvoid Vector2D::operator/=(const float& scalar) {\n    x /= scalar;\n    y /= scalar;\n}\nVector2D Vector2D::operator*(const float& scalar) {\n    Vector2D vec = *this;\n    vec *= scalar;\n    return vec;\n}\nvoid Vector2D::Rotate( float radians ) {\n    float sine = sin(radians);\n    float cosine = cos(radians);\n    float rx = x * cosine - y * sine;\n    float ry = x * sine + y * cosine;\n    x = rx;\n    y = ry;\n}\nvoid Vector2D::Normalize() {\n    float mag = Magnitude();\n    x /= mag;\n    y /= mag;\n}\nVector2D Vector2D::Project(Vector2D &onto) {\n    Vector2D proj = *this;\n    float proj_dot_onto = proj.Dot(onto);\n    proj *= proj_dot_onto;\n    return proj;\n}\nfloat Vector2D::Dot(Vector2D &vec) {\n    Vector2D this_norm;\n    this_norm = *this;\n    this_norm.Normalize();\n    Vector2D vec_norm;\n    vec_norm = vec;\n    vec_norm.Normalize();\n\n    return this_norm.x * vec_norm.x + this_norm.y * vec_norm.y;\n}\nfloat Vector2D::FindAngle() {\n    if( x == 0.0 && y == 0.0 ) {\n        return 0.0;\n    }\n    Vector2D this_norm;\n    this_norm = *this;\n    this_norm.Normalize();\n    return atan2( this_norm.y, this_norm.x ) + PI / 2;\n}\nfloat Vector2D::MagSQ() {\n    return x * x + y * y;\n}\nfloat Vector2D::Magnitude() {\n    return sqrt( MagSQ() );\n}\n```", "```cpp\nVector2D::Vector2D( float X, float Y ) {\n    x = X;\n    y = Y;\n}\nVector2D::Vector2D() {\n    y = x = 0.0;\n}\n```", "```cpp\nVector2D Vector2D::operator=(const Vector2D& p) {\n    x = p.x;\n    y = p.y;\n    return *this;\n}\nvoid Vector2D::operator+=(const Vector2D& p) {\n    x += p.x;\n    y += p.y;\n}\nvoid Vector2D::operator-=(const Vector2D& p) {\n    x -= p.x;\n    y -= p.y;\n}\nvoid Vector2D::operator*=(const float& scalar) {\n    x *= scalar;\n    y *= scalar;\n}\nvoid Vector2D::operator/=(const float& scalar) {\n    x /= scalar;\n    y /= scalar;\n}\nVector2D Vector2D::operator*(const float& scalar) {\n    Vector2D vec = *this;\n    vec *= scalar;\n    return vec;\n}\n```", "```cpp\nvoid Vector2D::Rotate( float radians ) {\n    float sine = sin(radians);\n    float cosine = cos(radians);\n    float rx = x * cosine - y * sine;\n    float ry = x * sine + y * cosine;\n    x = rx;\n    y = ry;\n}\n```", "```cpp\nvoid Vector2D::Normalize() {\n    float mag = Magnitude();\n    x /= mag;\n    y /= mag;\n}\n```", "```cpp\nVector2D Vector2D::Project(Vector2D &onto) {\n    Vector2D proj = *this;\n    float proj_dot_onto = proj.Dot(onto);\n    proj *= proj_dot_onto;\n    return proj;\n}\n```", "```cpp\nfloat Vector2D::Dot(Vector2D &vec) {\n    Vector2D this_norm;\n    this_norm = *this;\n    this_norm.Normalize();\n\n    Vector2D vec_norm;\n    vec_norm = vec;\n    vec_norm.Normalize();\n\n    return this_norm.x * vec_norm.x + this_norm.y * vec_norm.y;\n}\n```", "```cpp\nfloat Vector2D::FindAngle() {\n    if( x == 0.0 && y == 0.0 ) {\n        return 0.0;\n    }\n    Vector2D this_norm;\n    this_norm = *this;\n    this_norm.Normalize();\n    return atan2( this_norm.y, this_norm.x ) + PI / 2;\n}\n```", "```cpp\nfloat Vector2D::MagSQ() {\n    return x * x + y * y;\n}\n\nfloat Vector2D::Magnitude() {\n    return sqrt( MagSQ() );\n}\n```", "```cpp\nclass FiniteStateMachine {\n    public:\n        const float c_AttackDistSq = 40000.0;\n        const float c_FleeDistSq = 2500.0;\n        const int c_MinRandomTurnMS = 100;\n        const int c_RandTurnMS = 3000;\n        const int c_ShieldDist = 20;\n        const int c_AvoidDist = 80;\n        const int c_StarAvoidDistSQ = 20000;\n        const int c_ObstacleAvoidForce = 150;\n        const int c_StarAvoidForce = 120;\n\n        FSM_STATE m_CurrentState;\n        EnemyShip* m_Ship;\n\n        bool m_HasLOS;\n        bool m_LastTurnLeft;\n        int m_SameTurnPct;\n        int m_NextTurnMS;\n        int m_CheckCycle;\n        float m_DesiredRotation;\n        float m_PlayerDistSQ;\n\n        FiniteStateMachine(EnemyShip* ship);\n\n        void SeekState(Vector2D &seek_point);\n        void FleeState(Vector2D &flee_point);\n        void WanderState();\n        void AttackState();\n\n        void AvoidForce();\n        bool ShieldCheck();\n        bool LOSCheck();\n\n        Vector2D PredictPosition();\n\n        float GetPlayerDistSq();\n        void Move();\n};\n```", "```cpp\nFiniteStateMachine::FiniteStateMachine(EnemyShip* ship) {\n    m_Ship = ship;\n    m_CurrentState = APPROACH;\n    m_HasLOS = false;\n    m_DesiredRotation = 0.0;\n    m_CheckCycle = 0;\n    m_PlayerDistSQ = 0;\n}\n```", "```cpp\nvoid FiniteStateMachine::SeekState(Vector2D &seek_point) {\n    Vector2D direction = seek_point;\n    direction -= m_Ship->m_Position;\n    m_DesiredRotation = direction.FindAngle();\n    float rotate_direction = m_Ship->m_Rotation - m_DesiredRotation;\n\n    if( rotate_direction > PI ) {\n        rotate_direction -= 2 * PI;\n    }\n    else if( rotate_direction < -PI ) {\n        rotate_direction += 2 * PI;\n    }\n\n    if( rotate_direction < -0.05 ) {\n        m_Ship->RotateRight();\n        m_Ship->RotateRight();\n    }\n    else if( rotate_direction > 0.05 ) {\n        m_Ship->RotateLeft();\n        m_Ship->RotateLeft();\n    }\n    m_Ship->Accelerate();\n    m_Ship->Accelerate();\n    m_Ship->Accelerate();\n    m_Ship->Accelerate();\n}\n```", "```cpp\nVector2D direction = seek_point;\ndirection -= m_Ship->m_Position;\nm_DesiredRotation = direction.FindAngle();\nfloat rotate_direction = m_Ship->m_Rotation - m_DesiredRotation;\n\nif( rotate_direction > PI ) {\n    rotate_direction -= 2 * PI;\n}\nelse if( rotate_direction < -PI ) {\n    rotate_direction += 2 * PI;\n}\n```", "```cpp\nif( rotate_direction < -0.05 ) {\n    m_Ship->RotateRight();\n    m_Ship->RotateRight();\n}\nelse if( rotate_direction > 0.05 ) {\n    m_Ship->RotateLeft();\n    m_Ship->RotateLeft();\n}\n```", "```cpp\nm_Ship->Accelerate();\nm_Ship->Accelerate();\nm_Ship->Accelerate();\nm_Ship->Accelerate();\n```", "```cpp\nvoid FiniteStateMachine::FleeState(Vector2D& flee_point) {\n    Vector2D direction = flee_point;\n    direction -= m_Ship->m_Position;\n    m_DesiredRotation = direction.FindAngle();\n    float rotate_direction = m_DesiredRotation - m_Ship->m_Rotation;\n    rotate_direction -= PI;\n\n    if( rotate_direction > 0 ) {\n        m_Ship->RotateRight();\n    }\n    else {\n        m_Ship->RotateLeft();\n    }\n    m_Ship->Accelerate();\n    m_Ship->Accelerate();\n}\n```", "```cpp\nvoid FiniteStateMachine::WanderState() {\n    m_NextTurnMS -= delta_time;\n\n    if( m_NextTurnMS <= 0 ) {\n        bool same_turn = ( m_SameTurnPct >= rand() % 100 );\n        m_NextTurnMS = c_MinRandomTurnMS + rand() % c_RandTurnMS;\n\n        if( m_LastTurnLeft ) {\n            if( same_turn ) {\n                m_SameTurnPct -= 10;\n                m_Ship->RotateLeft();\n            }\n            else {\n                m_SameTurnPct = 80;\n                m_Ship->RotateRight();\n            }\n        }\n        else {\n            if( same_turn ) {\n                m_SameTurnPct -= 10;\n                m_Ship->RotateRight();\n            }\n            else {\n                m_SameTurnPct = 80;\n                m_Ship->RotateLeft();\n            }\n        }\n    }\n    m_Ship->Accelerate();\n}\n```", "```cpp\nvoid FiniteStateMachine::AttackState() {\n    Vector2D prediction = PredictPosition();\n    SeekState( prediction );\n    m_Ship->Shoot();\n}\n```", "```cpp\nVector2D FiniteStateMachine::PredictPosition() {\n    Vector2D dist = player->m_Position;\n    dist -= m_Ship->m_Position;\n    float mag = dist.Magnitude();\n    Vector2D dir = player->m_Velocity;\n\n    if( dir.MagSQ() > 0 ) {\n        dir.Normalize();\n    }\n    dir *= (mag / 10);\n    Vector2D prediction = player->m_Position;\n    prediction += dir;\n    return prediction;\n}\n```", "```cpp\nvoid FiniteStateMachine::AvoidForce() {\n    Vector2D start_corner;\n    Vector2D end_corner;\n    Vector2D avoid_vec;\n    Vector2D dist;\n\n    float closest_square = 999999999999.0;\n    float msq;\n    Vector2D star_avoid;\n\n    star_avoid.x = CANVAS_WIDTH / 2;\n    star_avoid.y = CANVAS_HEIGHT / 2;\n    star_avoid -= m_Ship->m_Position;\n\n    msq = star_avoid.MagSQ();\n\n    if( msq >= c_StarAvoidDistSQ ) {\n        start_corner = m_Ship->m_Position;\n        start_corner.x -= c_AvoidDist;\n        start_corner.y -= c_AvoidDist;\n        end_corner = m_Ship->m_Position;\n        end_corner.x += c_AvoidDist;\n        end_corner.y += c_AvoidDist;\n        Asteroid* asteroid;\n        std::vector<Asteroid*>::iterator it;\n        int i = 0;\n\n        for( it = asteroid_list.begin(); it != asteroid_list.end(); \n             it++ ) {\n            asteroid = *it;\n            if( asteroid->m_Active == true &&\n                asteroid->SteeringRectTest( start_corner, end_corner ) ) {\n\n                dist = asteroid->m_Position;\n                dist -= m_Ship->m_Position;\n                msq = dist.MagSQ();\n\n                if( msq <= closest_square ) {\n                    closest_square = msq;\n                    avoid_vec = asteroid->m_Position;\n                }\n            }\n        }\n\n        // LOOP OVER PROJECTILES\n        Projectile* projectile;\n        std::vector<Projectile*>::iterator proj_it;\n\n        for( proj_it = projectile_pool->m_ProjectileList.begin(); \n             proj_it != projectile_pool->m_ProjectileList.end(); \n             proj_it++ ) {\n\n            projectile = *proj_it;\n\n            if( projectile->m_Active == true &&\n                projectile->SteeringRectTest( start_corner, end_corner ) \n                ) {\n\n                dist = projectile->m_Position;\n                dist -= m_Ship->m_Position;\n                msq = dist.MagSQ();\n\n                if( msq <= closest_square ) {\n                    closest_square = msq;\n                    avoid_vec = projectile->m_Position;\n                }\n            }\n        }\n        if( closest_square != 999999999999.0 ) {\n            avoid_vec -= m_Ship->m_Position;\n            avoid_vec.Normalize();\n            float rot_to_obj = avoid_vec.FindAngle();\n\n            if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n                if( rot_to_obj >= m_Ship->m_Rotation ) {\n                    m_Ship->RotateLeft();\n                }\n                else {\n                    m_Ship->RotateRight();\n                }\n            }\n            m_Ship->m_Velocity -= avoid_vec * delta_time * \n            c_ObstacleAvoidForce;\n        }\n    }\n    else {\n        avoid_vec.x = CANVAS_WIDTH / 2;\n        avoid_vec.y = CANVAS_HEIGHT / 2;\n        avoid_vec -= m_Ship->m_Position;\n        avoid_vec.Normalize();\n        float rot_to_obj = avoid_vec.FindAngle();\n\n        if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n            if( rot_to_obj >= m_Ship->m_Rotation ) {\n                m_Ship->RotateLeft();\n            }\n            else {\n                m_Ship->RotateRight();\n            }\n        }\n        m_Ship->m_Velocity -= avoid_vec * delta_time * c_StarAvoidForce;\n    }\n}\n```", "```cpp\nif( msq >= c_StarAvoidDistSQ ) {\n```", "```cpp\nif( msq >= c_StarAvoidDistSQ ) {\n    start_corner = m_Ship->m_Position;\n    start_corner.x -= c_AvoidDist;\n    start_corner.y -= c_AvoidDist;\n\n    end_corner = m_Ship->m_Position;\n    end_corner.x += c_AvoidDist;\n    end_corner.y += c_AvoidDist;\n\n    Asteroid* asteroid;\n    std::vector<Asteroid*>::iterator it;\n    int i = 0;\n\n    for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n        asteroid = *it;\n        if( asteroid->m_Active == true &&\n            asteroid->SteeringRectTest( start_corner, end_corner ) ) {\n\n            dist = asteroid->m_Position;\n            dist -= m_Ship->m_Position;\n            msq = dist.MagSQ();\n\n            if( msq <= closest_square ) {\n                closest_square = msq;\n                avoid_vec = asteroid->m_Position;\n            }\n        }\n    }\n    // LOOP OVER PROJECTILES\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator proj_it;\n\n    for( proj_it = projectile_pool->m_ProjectileList.begin(); \n         proj_it != projectile_pool->m_ProjectileList.end(); proj_it++ \n         ) {\n\n        projectile = *proj_it;\n\n        if( projectile->m_Active == true &&\n            projectile->SteeringRectTest( start_corner, end_corner \n            ) ) {\n            dist = projectile->m_Position;\n            dist -= m_Ship->m_Position;\n            msq = dist.MagSQ();\n\n            if( msq <= closest_square ) {\n                closest_square = msq;\n                avoid_vec = projectile->m_Position;\n            }\n        }\n    }\n    if( closest_square != 999999999999.0 ) {\n        avoid_vec -= m_Ship->m_Position;\n        avoid_vec.Normalize();\n        float rot_to_obj = avoid_vec.FindAngle();\n        if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n            if( rot_to_obj >= m_Ship->m_Rotation ) {\n                m_Ship->RotateLeft();\n            }\n            else {\n                m_Ship->RotateRight();\n            }\n        }\n        m_Ship->m_Velocity -= avoid_vec * delta_time * \n        c_ObstacleAvoidForce;\n    }\n}\n```", "```cpp\nstart_corner = m_Ship->m_Position;\nstart_corner.x -= c_AvoidDist;\nstart_corner.y -= c_AvoidDist;\n\nend_corner = m_Ship->m_Position;\nend_corner.x += c_AvoidDist;\nend_corner.y += c_AvoidDist;\n```", "```cpp\nAsteroid* asteroid;\nstd::vector<Asteroid*>::iterator it;\nint i = 0;\n\nfor( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) \n{\n    asteroid = *it;\n    if( asteroid->m_Active == true &&\n        asteroid->SteeringRectTest( start_corner, end_corner ) ) {\n\n        dist = asteroid->m_Position;\n        dist -= m_Ship->m_Position;\n        msq = dist.MagSQ();\n\n        if( msq <= closest_square ) {\n             closest_square = msq;\n             avoid_vec = asteroid->m_Position;\n        }\n    }\n}\n```", "```cpp\n    // LOOP OVER PROJECTILES\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator proj_it;\n    for( proj_it = projectile_pool->m_ProjectileList.begin(); \n         proj_it != projectile_pool->m_ProjectileList.end(); proj_it++ ) {\n        projectile = *proj_it;\n        if( projectile->m_Active == true &&\n            projectile->SteeringRectTest( start_corner, end_corner ) ) {\n            dist = projectile->m_Position;\n            dist -= m_Ship->m_Position;\n            msq = dist.MagSQ();\n\n            if( msq <= closest_square ) {\n                closest_square = msq;\n                avoid_vec = projectile->m_Position;\n            }\n        }\n    }\n```", "```cpp\nif( closest_square != 999999999999.0 ) {\n    avoid_vec -= m_Ship->m_Position;\n    avoid_vec.Normalize();\n    float rot_to_obj = avoid_vec.FindAngle();\n    if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n        if( rot_to_obj >= m_Ship->m_Rotation ) {\n            m_Ship->RotateLeft();\n        }\n        else {\n            m_Ship->RotateRight();\n        }\n    }\n    m_Ship->m_Velocity -= avoid_vec * delta_time * c_ObstacleAvoidForce;\n}\n```", "```cpp\nelse {\n    avoid_vec.x = CANVAS_WIDTH / 2;\n    avoid_vec.y = CANVAS_HEIGHT / 2;\n    avoid_vec -= m_Ship->m_Position;\n    avoid_vec.Normalize();\n    float rot_to_obj = avoid_vec.FindAngle();\n\n    if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n        if( rot_to_obj >= m_Ship->m_Rotation ) {\n            m_Ship->RotateLeft();\n        }\n        else {\n            m_Ship->RotateRight();\n        }\n    }\n    m_Ship->m_Velocity -= avoid_vec * delta_time * c_StarAvoidForce;\n}\n```", "```cpp\nbool FiniteStateMachine::ShieldCheck() {\n    Vector2D start_corner;\n    Vector2D end_corner;\n\n    start_corner = m_Ship->m_Position;\n    start_corner.x -= c_ShieldDist;\n    start_corner.y -= c_ShieldDist;\n\n    end_corner = m_Ship->m_Position;\n    end_corner.x += c_ShieldDist;\n    end_corner.y += c_ShieldDist;\n\n    Asteroid* asteroid;\n    std::vector<Asteroid*>::iterator it;\n    int i = 0;\n\n    for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n        asteroid = *it;\n        if( asteroid->m_Active &&\n            asteroid->SteeringRectTest( start_corner, end_corner ) ) {\n            return true;\n        }\n    }\n    // LOOP OVER PROJECTILES\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator proj_it;\n\n    for( proj_it = projectile_pool->m_ProjectileList.begin(); \n         proj_it != projectile_pool->m_ProjectileList.end(); proj_it++ ) {\n        projectile = *proj_it;\n        if( projectile->m_Active &&\n            projectile->SteeringRectTest( start_corner, end_corner ) ) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "```cpp\nbool FiniteStateMachine::LOSCheck() { // LINE OF SIGHT CHECK\n    // LOOP OVER ASTEROIDS\n    Asteroid* asteroid;\n    std::vector<Asteroid*>::iterator it;\n    int i = 0;\n    for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n        asteroid = *it;\n        if( asteroid->SteeringLineTest( m_Ship->m_Position, \n        player->m_Position ) ) {\n            return false;\n        }\n    }\n\n    // LOOP OVER PROJECTILES\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator proj_it;\n    for( proj_it = projectile_pool->m_ProjectileList.begin(); \n         proj_it != projectile_pool->m_ProjectileList.end(); proj_it++ ) {\n        projectile = *proj_it;\n        if( projectile->SteeringLineTest( m_Ship->m_Position, \n        player->m_Position ) ) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "```cpp\nfloat FiniteStateMachine::GetPlayerDistSq() {\n    float x_diff = m_Ship->m_Position.x - player->m_Position.x;\n    float y_diff = m_Ship->m_Position.y - player->m_Position.y;\n    return x_diff * x_diff + y_diff * y_diff;\n}\n```", "```cpp\nvoid FiniteStateMachine::Move() {\n    m_CheckCycle++;\n    if( m_CheckCycle == 0 ) {\n        m_HasLOS = LOSCheck();\n        if( !m_HasLOS ) {\n            m_CurrentState = WANDER;\n        }\n        float player_dist_sq = 0.0f;\n    }\n    else if( m_CheckCycle == 1 ) {\n        if( m_HasLOS ) {\n            m_PlayerDistSQ = GetPlayerDistSq();\n            if( m_PlayerDistSQ <= c_FleeDistSq ) {\n                m_CurrentState = FLEE;\n            }\n            else if( m_PlayerDistSQ <= c_AttackDistSq ) {\n                m_CurrentState = ATTACK;\n            }\n            else {\n                m_CurrentState = APPROACH;\n            }\n        }\n    }\n    else {\n        AvoidForce();\n        m_CheckCycle = -1;\n    }\n    if( ShieldCheck() ) {\n        m_Ship->m_Shield->Activate();\n    }\n    else {\n        m_Ship->m_Shield->Deactivate();\n    }\n    if( m_CurrentState == APPROACH ) {\n        Vector2D predict = PredictPosition();\n        SeekState(predict);\n    }\n    else if( m_CurrentState == ATTACK ) {\n        AttackState();\n    }\n    else if( m_CurrentState == FLEE ) {\n        Vector2D predict = PredictPosition();\n        FleeState(predict);\n    }\n    else if( m_CurrentState == WANDER ) {\n        WanderState();\n    }\n}\n```", "```cpp\nm_CheckCycle++;\n\nif( m_CheckCycle == 0 ) {\n    m_HasLOS = LOSCheck();\n    if( !m_HasLOS ) {\n        m_CurrentState = WANDER;\n    }\n    float player_dist_sq = 0.0f;\n}\nelse if( m_CheckCycle == 1 ) {\n    if( m_HasLOS ) {\n        m_PlayerDistSQ = GetPlayerDistSq();\n        if( m_PlayerDistSQ <= c_FleeDistSq ) {\n            m_CurrentState = FLEE;\n        }\n        else if( m_PlayerDistSQ <= c_AttackDistSq ) {\n            m_CurrentState = ATTACK;\n        }\n        else {\n            m_CurrentState = APPROACH;\n        }\n    }\n}\nelse {\n    AvoidForce();\n    m_CheckCycle = -1;\n}\n```", "```cpp\nif( ShieldCheck() ) {\n    m_Ship->m_Shield->Activate();\n}\nelse {\n    m_Ship->m_Shield->Deactivate();\n}\n```", "```cpp\nif( m_CurrentState == APPROACH ) {\n    Vector2D predict = PredictPosition();\n    SeekState(predict);\n}\nelse if( m_CurrentState == ATTACK ) {\n    AttackState();\n}\nelse if( m_CurrentState == FLEE ) {\n    Vector2D predict = PredictPosition();\n    FleeState(predict);\n}\nelse if( m_CurrentState == WANDER ) {\n    WanderState();\n}\n```", "```cpp\nem++ asteroid.cpp collider.cpp emitter.cpp enemy_ship.cpp finite_state_machine.cpp main.cpp particle.cpp player_ship.cpp projectile_pool.cpp projectile.cpp range.cpp shield.cpp ship.cpp star.cpp vector.cpp -o ai.html --preload-file sprites -std=c++17 -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] \n```"]