- en: Test-Driven Development for Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的测试驱动开发
- en: '**Test-driven development** (**TDD**) is a very useful method for designing
    software. The method is as follows—we first write one single test that fails,
    then we implement the minimum code to make the test pass, and finally we refactor.
    We do this in small cycles in quick succession.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种设计软件的非常有用的方法。该方法如下——我们首先编写一个失败的单一测试，然后实现最少的代码使测试通过，最后进行重构。我们在短时间内进行小循环来完成这个过程。'
- en: We will look at how pure functions simplify tests and provide an example of
    applying TDD with functions. Pure functions allow us to write simple tests because
    they always return the same values for the same input parameters; therefore, they
    are equivalent to big data tables. We can therefore write tests that emulate data
    tables for inputs and the expected outputs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看纯函数如何简化测试，并提供一个应用TDD的函数示例。纯函数允许我们编写简单的测试，因为它们始终为相同的输入参数返回相同的值；因此，它们相当于大数据表。因此，我们可以编写模拟输入和预期输出的数据表的测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use data-driven tests to take advantage of pure functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用数据驱动测试利用纯函数的优势
- en: Understanding the basics of the TDD cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解TDD周期的基础
- en: How to design a pure function using TDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用TDD设计纯函数
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a compiler that supports **C++ 17**. I used **GCC 7.3.0**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个支持**C++ 17**的编译器。我使用了**GCC 7.3.0**。
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter09` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在GitHub上找到，网址为[https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)，在`Chapter09`文件夹中。它包括并使用`doctest`，这是一个单头开源单元测试库。您可以在其GitHub存储库上找到它，网址为[https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest)。
- en: TDD for functional programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的TDD
- en: Programming in the 1950s was very different from what we know today. The job
    we now know as that of a programmer was split between three roles. The programmer
    would write the algorithm meant to be implemented. Then, a specialized typist
    would type it into punch cards using a special machine. The programmer then had
    to manually verify that the punch cards were correct—although there were hundreds
    of them. Once happy that the punch cards were correct, the programmer would take
    them to the mainframe operator. Since the only computers in existence were huge
    and very expensive, the time spent on the computer had to be protected. The mainframe
    operator took care of the computer, ensuring that the most important tasks took
    precedence, and thus a new program could wait for days until it was run. Once
    run, the program would print a full stack trace. If there was an error, the programmer
    had to look at a very long paper filled with weird symbols and figure out what
    might be wrong. The process was slow, error-prone, and unpredictable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪50年代的编程与今天的编程非常不同。我们现在所知道的程序员的工作被分为三个角色。程序员会编写要实现的算法。然后，专门的打字员会使用特殊的机器将其输入到穿孔卡片中。然后，程序员必须手动验证穿孔卡片是否正确——尽管有数百张。一旦确认穿孔卡片正确，程序员会将它们交给大型机操作员。由于当时唯一存在的计算机非常庞大且价格昂贵，因此在计算机上花费的时间必须受到保护。大型机操作员负责计算机，确保最重要的任务优先进行，因此新程序可能需要等待几天才能运行。运行后，程序将打印完整的堆栈跟踪。如果出现错误，程序员必须查看一张充满奇怪符号的非常长的纸，并找出可能出错的地方。这个过程缓慢、容易出错且不可预测。
- en: However, some of the engineers came up with an idea. What if, instead of getting
    the complex read-out from a failing program, they would get a clear indication
    of what was wrong? They decided to start writing additional code that would check
    the production code and produce an output of pass or fail. Instead of running
    the program, or in addition to running the program, they would run unit tests.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些工程师提出了一个想法。如果他们不是从失败的程序中获得复杂的输出，而是得到明确指出问题的信息会怎样？他们决定开始编写额外的代码，检查生产代码并生成通过或失败的输出。他们不是运行程序，或者在运行程序的同时，他们会运行单元测试。
- en: The practice of unit testing was forgotten once programmers had shorter feedback
    loops, with the invention of terminals and, later, personal computers and powerful
    debuggers. However, it never quite disappeared, and it suddenly came back in a
    different form.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序员拥有了更短的反馈循环，如终端的发明，后来是个人电脑和强大的调试器，单元测试的实践就被遗忘了。然而，它从未完全消失，突然以不同的形式回来了。
- en: It was in the 1990s that unit tests made a surprise re-appearance. A group of
    programmers, including Kent Beck, Ward Cunningham, and Ron Jeffries, experimented
    with taking development practices to the extreme. The result of their effort was
    called **extreme programming** (**XP**). One of these practices was unit testing,
    and the results were very interesting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 直到20世纪90年代，单元测试才意外地重新出现。包括Kent Beck、Ward Cunningham和Ron Jeffries在内的一群程序员尝试将开发实践推向极端。他们的努力的结果被称为**极限编程**（**XP**）。其中一种实践就是单元测试，结果非常有趣。
- en: The common practice of unit testing was to write some tests after the code was
    written, as part of the testing period. These tests were often written by testers—a
    different group from the programmers who implemented the features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的单元测试实践是在编写代码后写一些测试，作为测试期间的一部分。这些测试通常由测试人员编写——与实现功能的程序员不同的一个组。
- en: However, the initial XPers tried unit testing in a different way. What if we
    were to write the tests along with the code? And, more interestingly, what if
    we were to write the tests *before* the implementation? This led to two different
    techniques—**test-first programming** (**TFP**), which consists of writing a few
    tests first, and then some code to make the tests pass, and TDD, which we'll discuss
    in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最初的XPers尝试了一种不同的单元测试方式。如果我们在编写代码的同时编写测试呢？更有趣的是，如果我们在*实现之前*编写测试呢？这导致了两种不同的技术——**测试驱动编程**（**TFP**），它包括首先编写一些测试，然后编写一些代码使测试通过，以及我们将在更详细地讨论的TDD。
- en: When I first heard about these techniques, I was both puzzled and fascinated.
    How could you write tests for something that doesn't exist? What would be the
    benefit? Fortunately, with the support of J.B. Rainsberger, I quickly realized
    the power of TFP/TDD. Our clients and our stakeholders want working features in
    software as soon as possible. Yet, all too often, they can't explain what features
    they want. Starting with the tests means that you fully understand what to implement
    and leads to useful and interesting conversations that clarify the requirements.
    Once the requirements are clear, we can focus on the implementation. Moreover,
    in TDD, we clean the code as soon as possible, so that we don't create a mess
    as time passes. It truly is an amazingly powerful technique!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次听说这些技术时，我既感到困惑又着迷。你怎么能为不存在的东西编写测试呢？这有什么好处呢？幸运的是，在J.B. Rainsberger的支持下，我很快意识到了TFP/TDD的力量。我们的客户和利益相关者希望尽快在软件中获得可用的功能。然而，往往他们无法解释他们想要的功能。从测试开始意味着你完全理解了要实现什么，并且会引发有用和有趣的对话，澄清需求。一旦需求明确，我们就可以专注于实现。此外，在TDD中，我们尽快清理代码，以免随着时间的推移造成混乱。这真的是一种非常强大的技术！
- en: But let's start from the beginning. How do we write a unit test? And, more importantly
    for our purpose, is it easier to write unit tests for pure functions?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从头开始。我们如何编写单元测试呢？更重要的是，对于我们的目的来说，为纯函数编写单元测试更容易吗？
- en: Unit tests for pure functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数的单元测试
- en: 'Let''s first see what a unit test looks like. I have been using them already
    for a while in this book, and I''m sure you understand the code. But it''s time
    to look at one particular example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下单元测试是什么样子的。在本书中，我已经使用了一段时间，我相信你能理解这段代码。但是现在是时候看一个特定的例子了：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first initialize the two variables with specific values (the *Arrange* part
    of the unit test). We then call the production code (the *Act* part of the unit
    test). Finally, we check that the result is the one we expected (the *Assert*
    part of the unit test). The library we're using, called `doctest`, provides implementation
    for the macros that allow us to write the unit tests. While more unit testing
    libraries exist for C++, notable examples including GTest and `Boost::unit_test`,
    the facilities they offer to programmers are quite similar.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用特定值初始化两个变量（单元测试的*安排*部分）。然后我们调用生产代码（单元测试的*行动*部分）。最后，我们检查结果是否符合我们的预期（单元测试的*断言*部分）。我们正在使用的名为`doctest`的库提供了允许我们编写单元测试的宏的实现。虽然C++存在更多的单元测试库，包括GTest和`Boost::unit_test`等，但它们提供给程序员的功能相当相似。
- en: When talking about unit tests, it's more important to figure out the characteristics
    that make them useful. The previous test is small, focused, fast, and can fail
    for only one reason. All these characteristics make the test useful since it's
    easy to write, easy to maintain, crystal clear, and provides useful and fast feedback
    if a bug is introduced.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论单元测试时，更重要的是找出使其有用的特征。前面的测试是小型、专注、快速的，只能因为一个原因而失败。所有这些特征使测试有用，因为它易于编写、易于维护、清晰明了，并且在引入错误时提供有用和快速的反馈。
- en: 'In terms of technique, the previous test is example-based since it uses a very
    specific example to check a specific behavior of the code. We will look at a different
    method of unit testing called **property-based testing** in [Chapter 11](56c096aa-67a7-48ad-bf22-a78367941a26.xhtml),
    *Property-Based Testing*. Since this is an example-based test, an interesting
    question crops up: if we want to test the `greaterThan` function, what other examples
    would be interesting?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术方面，前面的测试是基于示例的，因为它使用一个非常具体的示例来检查代码的特定行为。我们将在[第11章](56c096aa-67a7-48ad-bf22-a78367941a26.xhtml)中看到一种名为**基于属性的测试**的不同单元测试方法，*基于属性的测试*。由于这是基于示例的测试，一个有趣的问题出现了：如果我们想测试`greaterThan`函数，还有哪些其他示例会很有趣呢？
- en: 'Well, we want to look at all the possible behaviors of the functions. So, what
    would be its possible outputs? Here''s a list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们想要查看函数的所有可能行为。那么，它可能的输出是什么？以下是一个列表：
- en: True, if the first value is greater than the second value
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值大于第二个值，则为True
- en: False, if the first value is less than the second value
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值小于第二个值，则为False
- en: 'However, that''s not enough. Let''s add the edge case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。让我们添加边缘情况：
- en: False, if the first value equals the second value
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值等于第二个值，则为False
- en: And, let's not forget possible errors. What is the domain for the values passed
    in? Is it OK to pass negative values? Floating point values? Complex numbers?
    This is an interesting conversation to have with the stakeholders of this function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有，不要忘记可能的错误。传入值的域是什么？可以传入负值吗？浮点数值？复数？这是与该函数的利益相关者进行有趣对话。
- en: 'Let''s assume the simplest case for now—the function will accept only valid
    integers. This means that we need two more unit tests checking the situations
    when the first parameter is less than the second and when the two are equal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设最简单的情况——该函数将仅接受有效的整数。这意味着我们需要另外两个单元测试来检查第一个参数小于第二个参数的情况以及两者相等的情况：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In [Chapter 7](9d86d296-6caf-4b65-9020-4307c85f3acd.xhtml), *Removing Duplication
    with Functional Operations*, we discussed code similarity and how to remove it.
    Here, we have a case of similarity between tests. One way to remove it is to write
    so-called **data-driven tests** (**DDT**). In DDT, we write a list of inputs and
    expected outputs and repeat the test over every line of data. Different testing
    frameworks offer different ways to write these tests; for now, `doctest` has limited
    support for DDT, but we can still write them as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](9d86d296-6caf-4b65-9020-4307c85f3acd.xhtml)中，*使用功能操作去除重复*，我们讨论了代码相似性以及如何去除它。在这里，我们有一个测试之间的相似性。去除它的一种方法是编写所谓的**数据驱动测试**（**DDT**）。在DDT中，我们编写一组输入和期望的输出，并在每行数据上重复测试。不同的测试框架提供了不同的编写这些测试的方式；目前，`doctest`对DDT的支持有限，但我们仍然可以按照以下方式编写它们：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we ignore the plumbing code (the `struct Data` definition and the call to
    the `CAPTURE` macro), this shows a very convenient way of writing tests—especially
    for pure functions. Given that pure functions return, by definition, the same
    output when they receive the same inputs, it's only natural to test them with
    a list of inputs/outputs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略管道代码（`struct Data`定义和对`CAPTURE`宏的调用），这显示了一种非常方便的编写测试的方式——特别是对于纯函数。鉴于纯函数根据定义在接收相同输入时返回相同输出，用一组输入/输出进行测试是很自然的。
- en: Another convenience of DDT is that we can easily add a new test by just adding
    a new line to the list. This, in particular, helps us when doing TDD with pure
    functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DDT的另一个便利之处在于，我们可以通过向列表添加新行来轻松添加新的测试。这在使用纯函数进行TDD时特别有帮助。
- en: The TDD cycle
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD循环
- en: 'TDD is a development cycle that is commonly presented as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一个常见的开发循环，通常如下所示：
- en: '**Red**: Write a test that fails.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：编写一个失败的测试。'
- en: '**Green**: Make the test pass by making the smallest change possible in the
    production code.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：通过对生产代码进行尽可能小的更改来使测试通过。'
- en: '**Refactor**: Reorganize the code to include the newly introduced behavior.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：重新组织代码以包含新引入的行为。'
- en: However, TDD practitioners (such as myself) will be keen to mention that the
    TDD cycle starts with another step—think. More precisely, before writing the first
    test, let's understand what we are trying to implement and find a good place in
    the existing code to add the behavior.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TDD的实践者（比如我自己）会急于提到TDD循环始于另一步骤——思考。更准确地说，在编写第一个测试之前，让我们理解我们要实现的内容，并找到现有代码中添加行为的好位置。
- en: This cycle is deceptively simple. However, beginners often struggle with what
    the first test should be and what the test after that should be, as well as with
    writing code that is too complex. **Refactoring** is an art in itself, requiring
    knowledge of code smells, design principles, and design patterns. Overall, the
    biggest mistake is to think too much about the code structure that you'd like
    to obtain, and write the tests that lead to that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环看起来简单得令人误解。然而，初学者经常在第一个测试应该是什么以及之后的测试应该是什么方面挣扎，同时编写过于复杂的代码。**重构**本身就是一门艺术，需要对代码异味、设计原则和设计模式有所了解。总的来说，最大的错误是过于考虑你想要获得的代码结构，并编写导致那种结构的测试。
- en: Instead, TDD requires a mindset change. We start from the behaviors and, in
    small steps, polish the code structure that fits the behavior. A good practitioner
    will have steps smaller than 15 minutes. But that's not the only surprise of TDD.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，TDD需要一种心态的改变。我们从行为开始，在小步骤中完善适合该行为的代码结构。一个好的实践者会有小于15分钟的步骤。但这并不是TDD的唯一惊喜。
- en: The biggest surprise of TDD is that it can teach you about software design by
    allowing you to explore various solutions to the same problem. The more solutions
    you're willing to explore, the better you'll become at designing code. TDD is
    a continuous learning experience when practiced with the right amount of curiosity.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TDD最大的惊喜是，它可以通过允许您探索同一问题的各种解决方案来教您软件设计。您愿意探索的解决方案越多，您在设计代码方面就会变得越好。当以适当的好奇心进行实践时，TDD是一个持续的学习经验。
- en: I hope I made you curious about TDD. There's a lot more to study about the topic,
    but, for our goals, it's enough to try out an example. And since we're talking
    about functional programming, we'll use TDD to design a pure function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我引起了你对TDD的好奇心。关于这个主题还有很多要学习的，但是对于我们的目标来说，尝试一个例子就足够了。而且，由于我们正在谈论函数式编程，我们将使用TDD来设计一个纯函数。
- en: Example – designing a pure function using TDD
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子——使用TDD设计一个纯函数
- en: Once again, we need a problem to showcase TDD in action. Since I like to practice
    development practices using games, I went through the list from Coding Dojo Katas
    ([http://codingdojo.org/kata/PokerHands/](http://codingdojo.org/kata/)) and I
    picked the poker hands problem for this exercise.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要一个问题来展示TDD的实际应用。由于我喜欢使用游戏来练习开发实践，我查看了Coding Dojo Katas（[http://codingdojo.org/kata/PokerHands/](http://codingdojo.org/kata/)）的列表，并选择了扑克牌问题来进行练习。
- en: The poker hands problem
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扑克牌问题
- en: A description of the problem is as follows—given two or more hands of poker,
    we need to compare them and return the one that has the higher rank and why it
    wins.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的描述如下——给定两个或多个扑克牌手，我们需要比较它们并返回排名较高的手以及它赢得的原因。
- en: Each hand has five cards, and the cards are picked from a normal 52-card deck.
    The deck is formed of four suits—clubs, diamonds, hearts, and spades. Each suit
    starts with a `2` and ends with an ace, and is denoted as follows—`2`, `3`, `4`,
    `5`, `6`, `7`, `8`, `9`, `T`, `J`, `Q`, `K`, `A` (`T` means 10).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每手有五张牌，这些牌是从一副普通的52张牌的牌组中挑选出来的。牌组由四种花色组成——梅花、方块、红桃和黑桃。每种花色从`2`开始，以A结束，表示如下——`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`、`T`、`J`、`Q`、`K`、`A`（`T`表示10）。
- en: 'The cards in a poker hand will create formations. The value of a hand is determined
    by those formations, in the following descending order:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 扑克牌手中的牌将形成不同的组合。手的价值由这些组合决定，按以下降序排列：
- en: '**Straight flush**: Five cards of the same suit with consecutive values. For
    example, `2♠`, `3♠`, `4♠`, `5♠`, and `6♠`. The higher the starting value, the
    more valuable the straight flush is.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同花顺**：五张相同花色的牌，连续的值。例如，`2♠`，`3♠`，`4♠`，`5♠`和`6♠`。起始值越高，同花顺的价值就越高。'
- en: '**Four of a kind**: Four cards with the same value. The highest one is four
    aces—`A♣`, `A♠`, `A♦`, and `A♥`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**四条**：四张相同牌值的牌。最高的是四张A——`A♣`，`A♠`，`A♦`和`A♥`。'
- en: '**Full house**: Three cards of the same value, and another two cards with the
    same value (but different). The highest one is as follows—`A♣`, `A♠`, `A♦`, `K♥`,
    and `K♠`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**葫芦**：三张相同牌值的牌，另外两张牌也是相同的牌值（但不同）。最高的是——`A♣`，`A♠`，`A♦`，`K♥`和`K♠`。'
- en: '**Flush**: Five cards of the same suit. For example—`2♠`, `3♠`, `5♠`, `6♠`,
    and `9♠`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同花**：五张相同花色的牌。例如——`2♠`，`3♠`，`5♠`，`6♠`和`9♠`。'
- en: '**Straight**: Five cards of consecutive values. For example—`2♣`, `3♠`, `4♥`,
    `5♣`, and `6♦`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺子**：五张连续值的牌。例如——`2♣`，`3♠`，`4♥`，`5♣`和`6♦`。'
- en: '**Three of a kind**: Three cards with the same value. For example—`2♣`, `2♠`,
    and `2♥`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三条**：三张相同牌值的牌。例如——`2♣`，`2♠`和`2♥`。'
- en: '**Two pairs**: See pair. For example—`2♣`, `2♠`, `3♥`, and `3♣`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**两对**：见对子。例如——`2♣`，`2♠`，`3♥`和`3♣`。'
- en: '**Pair**: Two cards of the same value. For example—`2♣` and `2♠`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对子**：两张相同牌值的牌。例如——`2♣`和`2♠`。'
- en: '**High card**: When no other formation is present, the highest cards from each
    hand are compared and the highest wins. If the highest cards have the same value,
    the next highest cards are compared, and so on.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高牌**：当没有其他组合时，比较每手中最高的牌，最高的获胜。如果最高的牌具有相同的值，则比较下一个最高的牌，以此类推。'
- en: Requirements
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'Our goal is to implement a program that compares two or more poker hands and
    returns both the winner and the reason. For example, let''s use the following
    input:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是实现一个程序，比较两个或更多个扑克牌手，并返回赢家和原因。例如，让我们使用以下输入：
- en: '**Player 1**: `*2♥ 4♦ 7♣ 9♠ K♦*`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家1**：`*2♥ 4♦ 7♣ 9♠ K♦*`'
- en: '**Player 2**: `*2♠ 4♥ 8♣ 9♠ A♥*`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家2**：`*2♠ 4♥ 8♣ 9♠ A♥*`'
- en: 'For this input, we should get the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个输入，我们应该得到以下输出：
- en: '*Player 2 wins with their high card—an ace*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩家2以他们的高牌——一张A赢得比赛*'
- en: Step 1 – Think
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤1 - 思考
- en: Let's look at the problem in more detail. More precisely, we are trying to split
    the problem into smaller pieces without thinking too much about the implementation.
    I find it useful to look at possible examples of inputs and outputs, and to start
    with a simplified problem that allows me to implement something that works as
    fast as possible while preserving the nature of the problem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下问题。更准确地说，我们试图将问题分解为更小的部分，而不要过多考虑实现。我发现查看可能的输入和输出示例，并从一个简化的问题开始，可以让我尽快实现一些有效的东西，同时保持问题的本质。
- en: It's obvious that we have a very large number of combinations to test for. So,
    what would be a useful simplification of the problem that limits our test cases?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们有很多组合要测试。那么，什么是限制我们测试用例的问题的有用简化呢？
- en: One obvious way is to start from a shorter hand. Instead of having five cards,
    we could start with one card in hand. This limits our rules to high cards. The
    next step is to have two cards, which introduces the *pair > high card*, and *higher
    pair > lower pair*, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的方法是从手中的牌较少开始。我们可以从一张牌开始，而不是五张牌。这将限制我们的规则为高牌。下一步是有两张牌，这引入了*对子>高牌*，*更高的对子>更低的对子*，依此类推。
- en: Another way is to start with five cards, but to limit the rules. Start with
    a high card, then implement one pair, then two pairs, and so on; or, the other
    way around, from the straight flush all the way down to the pair and high card.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是从五张牌开始，但限制规则。从高牌开始，然后实现一对，然后两对，依此类推；或者，从同花顺一直到对子和高牌。
- en: The interesting thing about TDD is that any of these roads will lead to results
    that work in the same way, albeit often with different code structures. One of
    the powers of TDD is to help you visit multiple designs for the same problem by
    varying the order of your tests.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的有趣之处在于，这些方法中的任何一个都将以相同的方式产生结果，尽管通常使用不同的代码结构。TDD的一个优势是通过改变测试的顺序来帮助您访问相同问题的多种设计。
- en: Needless to say, I've done this problem before, but I've always started from
    one card in hand. Let's have some fun and try a different way, shall we? I choose
    to go with five cards and start from the straight flush. To keep things simple,
    I'll just support two players for now, and since I like to name them, I'll use
    Alice and Bob.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，我以前做过这个问题，但我总是从手中的一张牌开始。让我们有些乐趣，尝试一种不同的方式，好吗？我选择用五张牌开始，从同花顺开始。为了保持简单，我现在只支持两个玩家，而且由于我喜欢给他们起名字，我会用Alice和Bob。
- en: Examples
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例子
- en: 'What would be some interesting examples for this situation? Let''s think about
    possible outputs first:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，有一些有趣的例子是什么？让我们先考虑可能的输出：
- en: Alice wins with a straight flush.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice以同花顺获胜。
- en: Bob wins with a straight flush.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob以同花顺获胜。
- en: Alice and Bob have equally good straight flushes.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice和Bob有同样好的同花顺。
- en: Undecided (as in not implemented yet).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未决（即尚未实施）。
- en: 'Now, let''s write some examples of inputs for these outputs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们写一些这些输出的输入示例：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these examples, we're ready to start writing our first test!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些例子，我们准备开始编写我们的第一个测试！
- en: First test
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个测试
- en: 'Based on our previous analysis, our first test is the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前的分析，我们的第一个测试如下：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s write it! We expect this test to fail, so we can do whatever we want
    at this point. We need to initialize two hands with the preceding card. For now, we
    will use `vector<string>` to represent each hand. Then, we will call a function
    (that doesn''t exist yet) that we imagine will, at some point, implement the comparison
    between the two hands. Finally, we check the result against the expected output
    message that was previously defined:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写吧！我们期望这个测试失败，所以在这一点上我们可以做任何我们想做的事情。我们需要用前面的卡片初始化两只手。现在，我们将使用`vector<string>`来表示每只手。然后，我们将调用一个函数（目前还不存在）来比较这两只手，我们想象这个函数将在某个时候实现。最后，我们将检查结果是否与之前定义的预期输出消息相匹配：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For now, this test doesn't compile because we haven't even created the `comparePokerHands` function. Time
    to move forward.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个测试无法编译，因为我们甚至还没有创建`comparePokerHands`函数。是时候继续前进了。
- en: Making the first test pass
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使第一个测试通过
- en: 'Let''s first write the function. The function needs to return something, so
    we''ll just return the empty string for now:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写这个函数。这个函数需要返回一些东西，所以我们暂时只返回空字符串：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What would be the simplest implementation that makes the test pass? This is
    the point where TDD gets weirder. The simplest implementation to make the test
    pass is to return the expected result as a hardcoded value:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使测试通过的最简单实现是什么？这是TDD变得更加奇怪的地方。使测试通过的最简单实现是将预期结果作为硬编码值返回：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this point, my compiler complains because I turned all warnings on, and
    I report all warnings as errors. The compiler notices that we don''t use the two
    arguments and complains. This is a valid complaint, but I plan to start using
    the arguments soon. The C++ language gives us an easy fix—just remove or comment
    out the parameter names, as shown in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我的编译器抱怨了，因为我打开了所有警告，并且将所有警告报告为错误。编译器注意到我们没有使用这两个参数并抱怨。这是一个合理的抱怨，但我计划很快开始使用这些参数。C++语言给了我们一个简单的解决方案——只需删除或注释掉参数名，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We run the tests, and our first test passes! Cool, something works!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行测试，我们的第一个测试通过了！太棒了，有东西可以用了！
- en: Refactoring
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: Is there anything to refactor? Well, we have two commented argument names, and
    I would normally remove them because commented code is just clutter. But, I've
    decided to keep them there for now, knowing that we will soon use them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么需要重构的吗？嗯，我们有两个被注释掉的参数名，我通常会把它们删除掉，因为注释掉的代码只会增加混乱。但是，我决定暂时保留它们，因为我知道我们很快会用到它们。
- en: We also have a duplication—the same `Alice wins with straight flush` string appears
    in both the test and the implementation. Would it be worth extracting it as a
    constant or common variable? If this was the end of our implementation, then sure.
    But I know that the string is actually built from multiple things—the name of
    the winning player, and the rule based on which hand wins. I'd like to keep this
    as it is for a while.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个重复的地方——在测试和实现中都出现了相同的“Alice以顺子获胜”的字符串。值得把它提取为一个常量或者公共变量吗？如果这是我们的实现的最终结果，那当然可以。但我知道这个字符串实际上是由多个部分组成的——获胜玩家的名字，以及根据哪种手牌获胜的规则。我想暂时保持它原样。
- en: Therefore, there is nothing to refactor. So, let's move on!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，没有什么需要重构的。让我们继续吧！
- en: Think (again)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次思考
- en: The current implementation feels underwhelming. Just returning a hardcoded value
    doesn't solve much. Or does it?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现感觉令人失望。只是返回一个硬编码的值并不能解决太多问题。或者呢？
- en: This is the mindset change needed when you're learning TDD. I know it because
    I went through it. I was so used to looking at the end result, comparing this
    solution with what I'm trying to accomplish feels underwhelming. However, there's
    a different way to look at it—we have something that works, and we have the simplest
    possible implementation. There's still a long time to go, but we can already demonstrate
    something to our stakeholders. Also, as we'll see, we'll always build on solid
    ground since the code we write is fully tested. These two things are incredibly
    liberating; I can only hope you will feel the same when trying out TDD.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是学习TDD时需要的心态转变。我知道这一点，因为我经历过。我习惯于看最终结果，将这个解决方案与我试图实现的目标进行比较，感觉令人失望。然而，有一种不同的看待方式——我们有一个可以工作的东西，而且我们有最简单的实现。还有很长的路要走，但我们已经可以向利益相关者展示一些东西。而且，正如我们将看到的，我们总是在坚实的基础上构建，因为我们编写的代码是经过充分测试的。这两件事是非常令人振奋的；我只希望你在尝试TDD时也能有同样的感受。
- en: But, what do we do next? We have a few options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，接下来我们该怎么办呢？我们有几个选择。
- en: Firstly, we could write another test in which Alice wins with a straight flush.
    However, that won't change anything in the implementation, and the test will immediately
    pass. While this seems to go against the TDD cycle, there's nothing wrong with
    adding more tests for our piece of mind. Definitely a valid option.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以写另一个测试，其中Alice以顺子获胜。然而，这不会改变实现中的任何东西，测试会立即通过。虽然这似乎违反了TDD循环，但为了我们的安心，增加更多的测试并没有错。绝对是一个有效的选择。
- en: Secondly, we could move to the next test in which Bob wins with a straight flush.
    This will definitely change a few things.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以转移到下一个测试，其中Bob以顺子获胜。这肯定会改变一些东西。
- en: Both options are good, and you can pick either of them. But since we want to
    see DDT in practice, let's write more tests first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项都不错，你可以选择其中任何一个。但由于我们想要看到DDT的实践，让我们先写更多的测试。
- en: More tests
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的测试
- en: 'It''s quite easy to turn our test into a DDT and add more cases. We will just
    vary the values of the Alice hand, while keeping Bob''s hand intact. The result
    is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的测试转换成DDT并添加更多的案例非常容易。我们只需改变Alice手牌的值，而保持Bob的手牌不变。结果如下：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once again, all these tests pass. Time to move on to our next test.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有这些测试都通过了。是时候继续进行我们的下一个测试了。
- en: Second test
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个测试
- en: 'The second test we''ve described is when Bob wins with a straight flush:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述的第二个测试是Bob以顺子获胜：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s write it! And this time, let''s use the data-driven format from the
    start:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写吧！这一次，让我们从一开始就使用数据驱动的格式：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When we run this test, it fails, for a simple reason—we have a hardcoded implementation
    that says that Alice wins. What now?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，它失败了，原因很简单——我们有一个硬编码的实现，说Alice获胜。现在怎么办？
- en: Making the test pass
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试通过
- en: Once again, we need to find the simplest way to make this test pass. Even if
    we won't like the implementation, the next step is about cleaning up the mess.
    So, what would the simplest implementation be?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要找到使这个测试通过的最简单方法。即使我们可能不喜欢这个实现，下一步是清理混乱。那么，最简单的实现是什么呢？
- en: We obviously need to introduce a conditional statement in our implementation.
    The question is, what should we check?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要在我们的实现中引入一个条件语句。问题是，我们应该检查什么？
- en: 'Once again, we have a few options. One option is to fake it once more, using
    something as simple as comparing Bob''s hand with the exact hand we expect to
    win:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有几个选择。一个选择是再次伪装，使用与我们期望获胜的确切手牌进行比较：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To make it compile, we also had to make the type of the `vector<string>` hands
    appear everywhere. Once these changes are made, the tests pass.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其编译，我们还必须使`vector<string>` hands的类型出现在各处。一旦这些更改完成，测试就通过了。
- en: Our second option is to start implementing the actual check for a straight flush.
    However, that is a small problem in itself, and to do it properly requires more
    tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选择是开始实现实际的同花顺检查。然而，这本身就是一个小问题，要做好需要更多的测试。
- en: I will go with the first option for now, refactor, and then start looking deeper
    into the implementation of the check for a straight flush.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在会选择第一种选项，重构，然后开始更深入地研究检查同花顺的实现。
- en: Refactor
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: Is there anything to refactor? We still have a duplication in strings. Moreover,
    we've added a duplication to the vector containing Bob's hand. But we expect both
    to go away quite soon.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么需要重构的吗？我们仍然有字符串的重复。此外，我们在包含Bob的手的向量中添加了重复。但我们期望这两者很快都会消失。
- en: 'However, another thing is bothering me—`vector<string>` appears everywhere.
    Let''s remove this duplication by naming the `vector<string>` type for what it
    is—`Hand`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一件事让我感到不安——`vector<string>` 出现在各处。让我们通过为`vector<string>`类型命名为`Hand`来消除这种重复：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Think
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考
- en: Time to think again. We have two cases implemented with hardcoded values. That's
    not a big problem for Alice winning with a straight flush, but it is a problem
    if we add another test case for Bob with a different set of cards. We could go
    on for a few more tests, but inevitably, we'll need to actually check for the
    straight flush. I think now is as good a time as any.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 再次思考。我们已经用硬编码的值实现了两种情况。对于Alice以同花顺获胜并不是一个大问题，但如果我们为Bob添加另一组不同的牌测试用例，这就是一个问题。我们可以进行更多的测试，但不可避免地，我们需要实际检查同花顺。我认为现在是一个很好的时机。
- en: 'So, what is a straight flush? It''s a set of five cards that have the same
    suit and consecutive values. We need a function that can take a set of five cards
    and return `true` if it''s a straight flush, or `false` if not. Let''s write down
    a few examples:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是同花顺？它是一组有相同花色和连续值的五张牌。我们需要一个函数，它可以接受一组五张牌，并在是同花顺时返回`true`，否则返回`false`。让我们写下一些例子：
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣` => Output: `true`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣ 6♣` => 输出：`true`
- en: 'Input: `2♠ 3♠ 4♠ 5♠ 6♠` => Output: `true`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♠ 3♠ 4♠ 5♠ 6♠` => 输出：`true`
- en: 'Input: `T♠ J♠ Q♠ K♠ A♠` => Output: `true`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`T♠ J♠ Q♠ K♠ A♠` => 输出：`true`
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 7♣` => Output: `false`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣ 7♣` => 输出：`false`
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♠` => Output: `false`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣ 6♠` => 输出：`false`
- en: 'Input: `2♣ 3♣ 4♣ 5♣` => Output: `false` (only four cards, need exactly five)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣` => 输出：`false`（只有四张牌，需要正好五张）
- en: 'Input: `[empty vector]` => Output: `false` (no cards, need exactly five)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`[空向量]` => 输出：`false`（没有牌，需要正好五张）
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣ 7♣` => Output: `false` (six cards, need exactly five)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣ 6♣ 7♣` => 输出：`false`（六张牌，需要正好五张）
- en: You will notice that we also considered edge cases and weird situations. We
    have enough information to continue, so let's write the next test.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们也考虑了边缘情况和奇怪的情况。我们有足够的信息可以继续，所以让我们写下下一个测试。
- en: Next test – simple straight flush
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一个测试-简单的同花顺
- en: 'I prefer to start from the positive cases, since they tend to advance the implementation
    more. Let''s see the simplest one:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢从正面案例开始，因为它们往往会更推进实现。让我们看最简单的一个：
- en: 'Input: `2♣ 3♣ 4♣ 5♣ 6♣` => Output: `true`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`2♣ 3♣ 4♣ 5♣ 6♣` => 输出：`true`
- en: 'The test appears as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如下：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once again, the test doesn't compile because we have no `isStraightFlush` function
    implemented. But the test is right, and it's failing, so it's time to move on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试无法编译，因为我们没有实现`isStraightFlush`函数。但测试是正确的，它失败了，所以是时候继续了。
- en: Making the test pass
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试通过
- en: 'Once again, the first step is to write the body of the function and to return
    the expected hardcoded value:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第一步是编写函数的主体并返回预期的硬编码值：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We ran the tests and they passed, so we're done for now!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了测试，它们通过了，所以现在我们完成了！
- en: Moving forward
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续前进
- en: Well, you can see where this is going. We can either add some more inputs for
    a correct straight flush, but they won't change the implementation. The first
    test that will force us to advance the implementation is our first example of
    a set of cards that isn't a straight flush.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你可以看到这是怎么回事。我们可以为正确的同花顺添加一些更多的输入，但它们不会改变实现。第一个将迫使我们推进实现的测试是我们的第一个不是同花顺的一组牌的例子。
- en: For the goals of this chapter, I will fast forward. However, I strongly advise
    you to go through all the small steps by yourself and compare your result with
    mine. The only way to learn TDD is to practice it by yourself and reflect on your
    methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的目标，我将快进。但我强烈建议你自己经历所有的小步骤，并将你的结果与我的进行比较。学习TDD的唯一方法是自己练习并反思自己的方法。
- en: Implementing isStraightFlush
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现isStraightFlush
- en: 'Let''s look at what we''re trying to accomplish again—a straight flush, which
    is defined by having exactly five cards with the same suit and consecutive values.
    We just need to express these three conditions in code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们要达到的目标——同花顺，它由正好五张具有相同花色和连续值的牌定义。我们只需要在代码中表达这三个条件：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The implementation is helped by a number of different lambdas. First, to check
    the length of the formation, we use `has5Cards`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现得到了一些不同的lambda的帮助。首先，为了检查组合的长度，我们使用`has5Cards`：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, to check that it has the same suit, we use `allSuits` to extract the
    suits from the hand, `isSuitEqual` to compare two suits, and `isSameSuit` to check
    that all suits from a hand are the same:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了检查它是否有相同的花色，我们使用`allSuits`来提取手中的花色，`isSuitEqual`来比较两个花色，`isSameSuit`来检查手中的所有花色是否相同：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, to verify that the values are consecutive, we use `valueOf` to extract
    the values from a card, `allValuesInOrder` to get all the values from a hand and
    sort them, `toRange` to create a range of consecutive values starting from an
    initial value, and `areValuesConsecutive` to check that the values from a hand
    are consecutive:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了验证这些值是连续的，我们使用`valueOf`从一张牌中提取值，使用`allValuesInOrder`获取一手牌中的所有值并排序，使用`toRange`从一个初始值开始创建一系列连续的值，使用`areValuesConsecutive`检查一手牌中的值是否连续：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The final piece of the puzzle is a map from `char` to `int` that helps us to
    translate all the card values, including `T`, `J`, `Q`, `K`, and `A`, into numbers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块拼图是一个从`char`到`int`的映射，帮助我们将所有的牌值，包括`T`、`J`、`Q`、`K`和`A`，转换成数字：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s also see our tests (which are obviously all passing). First, the ones
    for a valid straight flush; we''ll check straight flushes starting with `2`, `3`,
    `4`, and `10`, and how they vary along the data interval:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也看一下我们的测试（显然都通过了）。首先是有效的顺子同花的测试；我们将检查以`2`、`3`、`4`和`10`开头的顺子同花，以及它们在数据区间上的变化：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the tests for a set of cards that is not a valid straight flush. For
    input, we''ll use hands that are almost a straight flush, except for being from
    another suit, not having enough cards, or having too many cards:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于一组不是有效顺子同花的牌的测试。我们将使用几乎是顺子同花的手牌作为输入，除了花色不同、牌数不够或者牌数太多之外：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's now time to get back to our main problem—comparing the poker hands.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到我们的主要问题了——比较扑克牌的手。
- en: Plugging the check for straight flush back into comparePokerHands
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将检查顺子同花的代码重新插入到comparePokerHands中
- en: 'Despite everything we have implemented hitherto, our implementation of `comparePokerHands`
    is still hardcoded. Let''s remember its current status:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们迄今为止实现了所有这些，但我们的`comparePokerHands`的实现仍然是硬编码的。让我们回顾一下它当前的状态：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But, we now have a way of checking for a straight flush! So, let''s plug our
    implementation in:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在我们有了检查顺子同花的方法！所以，让我们把我们的实现插入进去：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All our tests pass, so we''re almost done. Time to add a few more tests to
    our `Bob wins with straight flush` case to be certain that we haven''t missed
    things. We''ll keep the same hand for Alice, an almost straight flush, and vary
    Bob''s hand from `2`, `3`, and `10`-based straight flushes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的测试都通过了，所以我们快要完成了。是时候为我们的`Bob赢得顺子同花`情况添加一些额外的测试，以确保我们没有遗漏。我们将保持Alice的相同手牌，一个几乎是顺子同花的手牌，然后改变Bob的手牌，从以`2`、`3`和`10`开头的顺子同花：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the previous tests pass. So, we're done with two cases—when either Alice
    or Bob have a straight flush and their competitor doesn't. Time to move to the
    next case.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的测试都通过了。所以，我们已经完成了两种情况——当Alice或Bob有顺子同花而对手没有时。是时候转移到下一个情况了。
- en: Comparing two straight flushes
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较两个顺子同花
- en: 'As we discussed in the beginning of this section, there''s another case when
    both Alice and Bob have straight flushes, but Alice wins with a higher one:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头讨论的那样，当Alice和Bob都有顺子同花时还有另一种情况，但是Alice用更高的顺子同花赢了：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s write the test and run it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写下测试并运行它：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The test fails, because our `comparePokerHands` function returns that Bob won
    instead of Alice. Let''s fix this with the simplest implementation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了，因为我们的`comparePokerHands`函数返回Bob赢了，而不是Alice。让我们用最简单的实现来修复这个问题：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our implementation decides that Alice always wins if both Alice and Bob have
    a straight flush. That's obviously not what we want, but the tests pass. So, what
    test can we write to push the implementation forward?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现决定了如果Alice和Bob都有顺子同花，那么Alice总是赢。这显然不是我们想要的，但测试通过了。那么我们可以写什么测试来推动实现向前发展呢？
- en: Think
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考
- en: 'It turns out that we missed one case from our previous analysis. We looked
    at what happens when both Alice and Bob have straight flushes and Alice wins;
    but what about when Bob has a higher straight flush? Let''s write down an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们在之前的分析中漏掉了一个情况。我们看了当Alice和Bob都有顺子同花并且Alice赢的情况；但是如果Bob有更高的顺子同花呢？让我们写一个例子：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Time to write another failing test.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写另一个失败的测试了。
- en: Comparing two straight flushes (continued)
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较两个顺子同花（续）
- en: 'The test is fairly obvious to write by now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在写这个测试已经相当明显了：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The test fails again, because our implementation assumes that Alice always wins
    when both Alice and Bob have straight flushes. It might be time to check which
    is the highest straight flush of them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 测试再次失败了，因为我们的实现假设当Alice和Bob都有顺子同花时，Alice总是赢。也许是时候检查哪个是它们中最高的顺子同花了。
- en: 'To do so, we will need once again to write down a few cases and go through
    our TDD cycles. Once again, I will fast forward to the implementation. We end
    up with the following helper function that compares two straight flushes. It returns
    `1` if the first hand has a higher straight flush, `0` if the two are equal, and
    `-1` if the second hand is a higher straight flush:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要再次写下一些情况并进行TDD循环。我将再次快进到实现。我们最终得到了以下的辅助函数，用于比较两个顺子同花。如果第一手牌有更高的顺子同花，则返回`1`，如果两者相等，则返回`0`，如果第二手牌有更高的顺子同花，则返回`-1`：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And, by changing our implementation, we can make the tests pass:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变我们的实现，我们可以让测试通过：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This leaves us with the final case—a draw. The test is once again quite clear:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们留下了最后一种情况——平局。测试再次非常明确：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And the change in implementation is fairly straightforward:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 而且实现的改变非常直接：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is not the prettiest function, but it passes all our tests for straight
    flush comparison. We can definitely refactor it into smaller functions, but I'll
    stop here since we've reached our goal—we've designed not only one, but multiple,
    pure functions using TDD and DDT.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最漂亮的函数，但它通过了我们所有的顺子同花比较测试。我们肯定可以将它重构为更小的函数，但我会在这里停下来，因为我们已经达到了我们的目标——使用TDD和DDT设计了不止一个纯函数。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you've learned how to write unit tests, how to write data-driven
    tests, and how to use data-driven tests combined with TDD to design pure functions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何编写单元测试，如何编写数据驱动测试，以及如何将数据驱动测试与TDD结合起来设计纯函数。
- en: TDD is one of the core practices of effective software development. While it
    may seem weird and counterintuitive at times, it has a strong advantage—every
    few minutes, you have something working that you can demo. A passing test is not
    only a demo point, but also a save point. If anything wrong happens while trying
    to refactor or to implement the following test, you can always go back to the
    last save point. I find this practice even more valuable in C++, where so many
    things can go wrong. In fact, I wrote all the code since [Chapter 3](c4cdce72-828b-4cb8-b904-481315999c60.xhtml), *Deep
    Dive into Lambdas*, with a TDD approach. This has been immensely helpful, since
    I know that my code is working—something that is quite difficult to do when writing
    a technical book without this method. I strongly advise you to look more into
    TDD and practice it for yourself; it's the only way you'll become proficient.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是有效软件开发的核心实践之一。虽然有时可能看起来奇怪和违反直觉，但它有一个强大的优势——每隔几分钟，你都有一个可以演示的工作内容。通过测试通过不仅是一个演示点，而且也是一个保存点。如果在尝试重构或实现下一个测试时发生任何错误，你总是可以回到上一个保存点。我发现这种实践在C++中更有价值，因为有很多事情可能会出错。事实上，我自[第3章](c4cdce72-828b-4cb8-b904-481315999c60.xhtml)
    *深入了解Lambda*以来，都是采用TDD方法编写的所有代码。这非常有帮助，因为我知道我的代码是有效的——在没有这种方法的情况下编写技术书籍时，这是相当困难的。我强烈建议你更深入地了解TDD并亲自实践；这是你成为专家的唯一途径。
- en: TDD with functional programming is a perfect fit. When using it with imperative
    object-oriented code, we often need to take into account mutation and it makes
    things more difficult. With pure functions and data-driven tests, the practice
    of adding more tests becomes as simple as it can be, and allows us to focus on
    implementation. With the support of functional operations, making a test pass
    becomes easier in many situations. I personally find this combination incredibly
    rewarding; I hope you'll find it equally useful.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程与TDD完美契合。当将其与命令式面向对象的代码一起使用时，我们经常需要考虑到变异，这使事情变得更加困难。通过纯函数和数据驱动的测试，添加更多的测试实践变得尽可能简单，并允许我们专注于实现。在函数操作的支持下，在许多情况下使测试通过变得更容易。我个人发现这种组合非常有益；我希望你也会觉得同样有用。
- en: Now it's time to move forward and revisit another section of software design—design
    patterns. Do they change with functional programming? (Spoiler alert—they actually
    become much simpler.) This is what we will discuss in the next chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向前迈进，重新审视软件设计的另一个部分——设计模式。它们在函数式编程中会发生变化吗？（剧透警告——实际上它们变得简单得多。）这是我们将在下一章讨论的内容。
