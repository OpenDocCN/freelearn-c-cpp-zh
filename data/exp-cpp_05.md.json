["```cpp\ntemplate <typename identifier_1, \u2026, typename identifier_n > \nfunction_declaration;\n\ntemplate <class identifier_1,\u2026, class identifier_n> \nfunction_declaration;\n```", "```cpp\ntemplate <class T>\nT app_max (T a, T b) {\n  return (a>b?a:b);   //note: we use ((a)>(b) ? (a):(b)) in macros  \n}                     //it is safe to replace (a) by a, and (b) by b now\n```", "```cpp\ncout << app_max<int>(3,5) << endl;\ncout << app_max<float>(3.0f,5.0f) << endl;\n```", "```cpp\nint app_max<int> ( int a, int b) {\n  return (a>b?a:b);\n}\n\nfloat app_max<float> (float a, float b) {\n  return (a>b?a:b);\n}\n```", "```cpp\ntemplate return-type \nfunction_name < template_argument_list > ( function_parameter-list ) ;\n\ntemplate return-type \nfunction_name ( function_parameter_list ) ;\n```", "```cpp\nextern template return-type \nfunction_name < template_argument_list > (function_parameter_list ); \n(since C++11)\n\nextern template return-type \nfunction_name ( function_parameter_list ); (since C++11)\n```", "```cpp\ntemplate double app_max<double>(double, double); \ntemplate int app_max<int>(int, int);\n```", "```cpp\nextern template double app_max<double>(double, double);//(since c++11)\nextren template int app_max<int>(int, int);            //(since c++11)\n```", "```cpp\ntemplate double f(double, double);\ntemplate int f(int, int);\n```", "```cpp\nextern template double f(double, double); //(since c++11)\nextern template int f(int, int);          //(since c++11)\n```", "```cpp\n//ch4_2_func_template_implicit_inst.cpp\n#include <iostream>\ntemplate <class T>\nT app_max (T a, T b) { return (a>b?a:b); }\nusing namespace std;\nint main(){\n //Part A: implicit instantiation in an explicit way \n cout << app_max<int>(5, 8) << endl;       //line A \n cout << app_max<float>(5.0, 8.0) << endl; //line B\n cout << app_max<int>(5.0, 8) << endl;     //Line C\n cout << app_max<double>(5.0, 8) << endl;  //Line D\n\n //Part B: implicit instantiation in an argument deduction way\n cout << app_max(5, 8) << endl;           //line E \n cout << app_max(5.0f, 8.0f) << endl;     //line F \n\n //Part C: implicit instantiation in a confuse way\n //cout<<app_max(5, 8.0)<<endl;          //line G  \n return 0;\n}\n```", "```cpp\n//ch4_3_func_template_specialization.cpp\n#include <iostream>\n#include <string>\n\n//Part A: define a  primary template\ntemplate <class T> T app_max (T a, T b) { return (a>b?a:b); }\n\n//Part B: explicit specialization for T=std::string, \ntemplate <> std::string app_max<std::string> (std::string a, std::string b){ \n    return (a[0]>b[0]?a:b);\n}\n\n//part C: test function\nusing namespace std; \nvoid main(){\n string a = \"abc\", b=\"efg\";\n cout << app_max(5, 6) << endl; //line A \n cout << app_max(a, b) << endl; //line B \n\n //question: what's the output if un-comment lines C and D?\n //char *x = \"abc\", *y=\"efg\";     //Line C\n //cout << app_max(x, y) << endl; //line D\n}\n```", "```cpp\ntemplate<typename T1, typename T2> void f( T1, T2 );// line 0\ntemplate<typename T> void f( T );                   // line 1\ntemplate<typename T> void f( T, T );                // line 2\ntemplate<typename T> void f( int, T* );             // line 3\ntemplate<> void f<int>( int );                      // line 4\nvoid f( int, double );                              // line 5\nvoid f( int );                                      // line 6\n```", "```cpp\nint i=0; \ndouble d=0; \nfloat x=0;\ncomplex<double> c;\nf(i);      //line A: choose f() defined in line 6\nf(i,d);    //line B: choose f() defined in line 5\nf<int>(i); //line C: choose f() defined in line 4\nf(c);      //line D: choose f() defined in line 1\nf(i,i);    //line E: choose f() defined in line 2\nf(i,x);    //line F: choose f() defined in line 0\nf(i, &d);  //line G: choose f() defined in line 3\n\n```", "```cpp\n[export] template <template_parameter_list> class-declaration \n```", "```cpp\ntemplate <class T>\nclass V {\npublic:\n  V( int n = 0) : m_nEle(n), m_buf(0) { creatBuf();}\n  ~V(){  deleteBuf();  }\n  V& operator = (const V &rhs) { /* ... */}\n  V& operator = (const V &rhs) { /* ... */}\n  T getMax(){ /* ... */ }\nprotected:\n  void creatBuf() { /* ... */}\n  void deleteBuf(){ /* ... */}\n\npublic:\n  int m_nEle;\n  T * m_buf;\n};\n```", "```cpp\nV<char> cV;\nV<int>  iV(10);\nV<float> fV(5);\n```", "```cpp\nclass V<char>{\npublic:\n  V(int n=0);\n // ...\npublic:\n  int  m_nEle;\n  char *m_buf;\n};\nclass V<int>{\npublic:\n  V(int n=0);\n // ...\npublic:\n  int  m_nEle;\n  int *m_buf;\n};\nclass V<float>{\npublic:\n  V(int n = 0);\n  // ...\npublic:\n  int   m_nEle;\n  float *m_buf;\n};\n```", "```cpp\ntemplate class template_name < argument_list >;\nextern template class template_name < argument_list >;//(since C++11)\n```", "```cpp\ntemplate class V<int>;\ntemplate class V<double>;\n```", "```cpp\nextern template class V<int>;\nextern template class V<double>;\n```", "```cpp\n//ch4_4_class_template_explicit.cpp\n#include <iostream>\nusing namespace std;\ntemplate <typename T>       //line A\nstruct A {\n  A(T init) : val(init) {}\n  virtual T foo();\n  T val;\n};                         //line B\n                           //line C \ntemplate <class T> //T in this line is template parameter\nT A<T>::foo() {    //the 1st T refers to function return type,\n                   //the T in <> specifies that this function's template\n                   //parameter is also the class template parameter\n  return val;\n}                        //line D\n\nextern template struct A<int>;  //line E\n#if 0                           //line F\nint A<int>::foo() {  \n    return val+1;    \n}                    \n#endif                         //line G\n\nint main(void) {\n  A<double> x(5);\n  A<int> y(5);\n  cout<<\"fD=\"<<x.foo()<<\",fI=\"<<y.foo()<< endl;\n  return 0;        //output: fD=5,fI=6\n}\n```", "```cpp\nclass_name<argument list> object_name; //for non-pointer object \nclass_name<argument list> *p_object_name; //for pointer object\n```", "```cpp\n//file ch4_5_class_template_implicit_inst.h\n#ifndef __CH4_5_H__ \n#define __CH4_5_H__ \n#include <iostream>\ntemplate <class T>\nclass X {\npublic:\n    X() = default;\n    ~X() = default;\n    void f() { std::cout << \"X::f()\" << std::endl; };\n    void g() { std::cout << \"X::g()\" << std::endl; };\n};\n#endif\n```", "```cpp\n//file ch4_5_class_template_implicit_inst_A.cpp\n#include \"ch4_5_class_template_implicit_inst.h\"\nvoid main()\n{\n    //implicit instantiation generates class X<int>, then create object xi\n    X<int>   xi ;  \n    //implicit instantiation generates class X<float>, then create object xf\n    X<float> xf;\n    return 0;  \n}\n```", "```cpp\n//file ch4_5_class_template_implicit_inst_B.cpp\n#include \"ch4_5_class_template_implicit_inst.h\"\nvoid main()\n{\n    //implicit instantiation generates class X<int>, then create object xi\n    X<int> xi;    \n    xi.f();      //and generates function X<int>::f(), but not X<int>::g()\n\n    //implicit instantiation generates class X<float>, then create object\n    //xf and generates function X<float>::g(), but not X<float>::f()\n    X<float> xf;  \n    xf.g() ;   \n}\n```", "```cpp\n//file ch4_5_class_template_implicit_inst_C.cpp\n#include \"ch4_5_class_template_implicit_inst.h\"\nvoid main()\n{\n   //inst. of class X<int> is not required, since p_xi is pointer object\n   X<int> *p_xi ;   \n   //inst. of class X<float> is not required, since p_xf is pointer object\n   X<float> *p_xf ; \n}\n```", "```cpp\n//file ch4_5_class_template_implicit_inst_D.cpp\n#include \"ch4_5_class_template_implicit_inst.h\"\nvoid main()\n{\n//inst. of class X<int> is not required, since p_xi is pointer object\n X<int> *p_xi; \n\n //implicit inst. of X<int> and X<int>::f(), but not X<int>::g()\n p_xi = new X<int>();\n p_xi->f(); \n\n//inst. of class X<float> is not required, since p_xf is pointer object\n X<float> *p_xf; \n p_xf = new X<float>();//implicit inst. of X<float> occurs here\n p_xf->f();            //implicit inst. X<float>::f() occurs here\n p_xf->g();            //implicit inst. of X<float>::g() occurs here\n\n delete p_xi;\n delete p_xf;\n}\n```", "```cpp\ntemplate <typename T>\nstruct X {\n  X(T init) : m(init) {}\n  T increase() { return ++m; }\n  T m;\n};\n```", "```cpp\ntemplate <>  //Note: no parameters inside <>, it tells compiler \n             //\"hi i am a fully specialized template\"\nstruct X<char> { //Note: <char> after X, tells compiler\n                 // \"Hi, this is specialized only for type char\"\n  X(char init) : m(init) {}\n  char increase() { return (m<127) ? ++m : (m=-128); }\n  char toUpperCase() {\n    if ((m >= 'a') && (m <= 'z')) m += 'A' - 'a';\n    return m;\n  }\n  char m;\n};\n```", "```cpp\nint main() {\n X<int> x1(5);         //line A\n std::cout << x1.increase() << std::endl;\n\n X<char> x2('b');     //line B\n std::cout << x2.toUpperCase() << std::endl;\n return 0;\n}\n```", "```cpp\ntemplate <> class[struct] class_name<template argument list> { ... }; \n```", "```cpp\ntemplate <> struct X<char> { ... };\n```", "```cpp\n//primary class template A\ntemplate <typename T>  class A{ /* ... */ }; \n\n//partial specialization for const T\ntemplate <typename T>  class A<const T>{ /* ... */ };  \n\n```", "```cpp\n//primary class template B\ntemplate <typename T1, typename T2> class B{ /* ... */ };          \n\n//partial specialization for T1 = int\ntemplate <typename T2> class B<int, T2>{ /* ... */};  \n```", "```cpp\n//primary class template C: template one parameter\ntemplate <typename T> struct C { T type; };  \n\n//specialization: two parameters in parameter list \n//but still one argument (<T[N]>) in argument list\ntemplate <typename T, int N> struct C<T[N]>          \n{T type; };                                 \n```", "```cpp\n//a class template with zero or more type parameters\ntemplate <typename... Args> class X { ... };     \n\n//a function template with zero or more type parameters\ntemplate <typename... Args> void foo( function param list) { ...}                                                                      \n```", "```cpp\nX<> x0;                       //with 0 template type argument\nX<int, std::vector<int> > x1; //with 2 template type arguments\n\n//with 4 template type arguments\nX<int, std::vector<int>, std::map<std::string, std::vector<int>>> x2; \n\n//with 2 template type arguments \nfoo<float, double>( function argument list ); \n\n//with 3 template type arguments\nfoo<float, double, std::vector<int>>( function argument list );\n```", "```cpp\ntemplate <typename A, typename... Rest> class Y { ... }; \n\ntemplate <typename A, typename... Rest> \nvoid goo( const int a, const float b) { ....};\n```", "```cpp\nY<int > y1;                                         \nY<int, std::vector<int>, std::map<std::string, std::vector<int>>> y2;\ngoo<int, float>(  const int a, const float b );                        \ngoo<int,float, double, std::vector<int>>(  const int a, const float b );      \n```", "```cpp\n//ch4_7_variadic_my_min.cpp\n//Only tested on g++ (Ubuntu/Linaro 7.3.0-27 ubuntu1~18.04)\n//It may have compile errors for other platforms\n#include <iostream>\n#include <math.h> \ndouble my_min(double n){\n  return n;\n}\ntemplate<typename... Args>\ndouble my_min(double n, Args... args){\n  return fmin(n, my_min(args...));\n}\nint main() {\n  double x1 = my_min(2);\n  double x2 = my_min(2, 3);\n  double x3 = my_min(2, 3, 4, 5, 4.7,5.6, 9.9, 0.1);\n  std::cout << \"x1=\"<<x1<<\", x2=\"<<x2<<\", x3=\"<<x3<<std::endl;\n  return 0;\n}\n```", "```cpp\n//ch4_8_variadic_printf.cpp part A: base function - recursive end\nvoid printf_vt(const char *s)\n{\n  while (*s){\n    if (*s == '%' && *(++s) != '%')\n      throw std::runtime_error(\"invalid format string: missing arguments\");\n     std::cout << *s++;\n  }\n}\n```", "```cpp\n//ch4_8_variadic_printf.cpp part B: recursive function\ntemplate<typename T, typename... Rest>\nvoid printf_vt(const char *s, T value, Rest... rest)\n{\n  while (*s) {\n    if (*s == '%' && *(++s) != '%') {\n      std::cout << value;\n      printf_vt(s, rest...); //called even when *s is 0, \n      return;                //but does nothing in that case\n    }\n    std::cout << *s++;\n  }\n}\n```", "```cpp\n//ch4_8_variadic_printf.cpp Part C: testing\nint main() {\n  int x = 10;\n  float y = 3.6;\n  std::string s = std::string(\"Variadic templates\");\n  const char* msg1 = \"%s can accept %i parameters (or %s), x=%d, y=%f\\n\";\n  printf(msg1, s, 100, \"more\",x,y);  //replace 's' by 's.c_str()' \n                                     //to prevent the output bug\n  const char* msg2 = \"% can accept % parameters (or %); x=%,y=%\\n\";\n  printf_vt(msg2, s, 100, \"more\",x,y);\n  return 0;\n}\n```", "```cpp\np.]\u00ef\u00bf\u00bdU can accept 100 parameters (or more), x=10, y=3.600000\nVariadic templates can accept 100 parameters (or more); x=10,y=3.6\n```", "```cpp\n//class template declaration\ntemplate <*parameter-list*> class-declaration\n\n//function template declaration\ntemplate <parameter-list> function-declaration\n```", "```cpp\n//for a non-type template parameter with an optional name\ntype name(optional)\n\n//for a non-type template parameter with an optional name \n//and a default value\ntype name(optional)=default  \n\n//For a non-type template parameter pack with an optional name\ntype ... name(optional) (since C++11) \n```", "```cpp\n//ch4_9_none_type_template_param1.cpp\n#include <iostream>\ntemplate<int N>\nclass V {\npublic:\n  V(int init) { \n    for (int i = 0; i<N; ++i) { a[i] = init; } \n  }\n  int a[N];\n};\n\nint main()\n{\n  V<5> x(1); //x.a is an array of 5 int, initialized as all 1's \n  x.a[4] = 10;\n  for( auto &e : x.a) {\n    std::cout << e << std::endl;\n  }\n}\n```", "```cpp\n//ch4_10_none_type_template_param2.cpp\n#include <iostream>\ntemplate<const char* msg>\nvoid foo() {\n  std::cout << msg << std::endl;\n}\n\n// need to have external linkage\nextern const char str1[] = \"Test 1\"; \nconstexpr char str2[] = \"Test 2\";\nextern const char* str3 = \"Test 3\";\nint main()\n{\n  foo<str1>();                   //line 1\n  foo<str2>();                   //line 2 \n  //foo<str3>();                 //line 3\n\n  const char str4[] = \"Test 4\";\n  constexpr char str5[] = \"Test 5\";\n  //foo<str4>();                 //line 4\n  //foo<str5>();                 //line 5\n  return 0;\n}\n```", "```cpp\n//A type Template Parameter (TP) with an optional name\ntypename |class name(optional)               \n\n//A type TP with an optional name and a default\ntypename[class] name(optional) = default         \n\n//A type TP pack with an optional name\ntypename[class] ... name(optional) (since C++11) \n```", "```cpp\nTemplate<class T>               //with name\nclass X { /* ... */ };     \n\nTemplate<class >               //without name\nclass Y { /* ... */ };\n```", "```cpp\nTemplate<class T = void>    //with name \nclass X { /* ... */ };     \n\nTemplate<class = void >     //without name\nclass Y { /* ... */ };\n```", "```cpp\ntemplate<typename... Ts>   //with name\nclass X { /* ... */ };\n\ntemplate<typename... >   //without name\nclass Y { /* ... */ };\n\n```", "```cpp\n//A template template parameter with an optional name\ntemplate <parameter-list> class *name*(optional) \n\n//A template template parameter with an optional name and a default\ntemplate <parameter-list> class *name*(optional) = default          \n\n//A template template parameter pack with an optional name\ntemplate <parameter-list> class ... *name*(optional) (since C++11)                                                                                               \n```", "```cpp\ntemplate<typename T>\nstatic inline std::ostream &operator << ( std::ostream &out, \n    std::list<T> const& v)\n{ \n    /*...*/ \n}\n```", "```cpp\n/ch4_11_template_template_param.cpp (courtesy: https://stackoverflow.com/questions/213761)\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\nusing namespace std;\ntemplate<class T, template<class, class...> class X, class... Args>\nstd::ostream& operator <<(std::ostream& os, const X<T, Args...>& objs) {\n  os << __PRETTY_FUNCTION__ << \":\" << endl;\n  for (auto const& obj : objs)\n    os << obj << ' ';\n  return os;\n}\n\nint main() {\n  vector<float> x{ 3.14f, 4.2f, 7.9f, 8.08f };\n  cout << x << endl;\n\n  list<char> y{ 'E', 'F', 'G', 'H', 'I' };\n  cout << y << endl;\n\n  deque<int> z{ 10, 11, 303, 404 };\n  cout << z << endl;\n  return 0;\n}\n```", "```cpp\nclass std::basic_ostream<char,struct std::char_traits<char> > &__cdecl operator\n<<<float,class std::vector,class std::allocator<float>>(class std::basic_ostream\n<char,struct std::char_traits<char> > &,const class std::vector<float,class std:\n:allocator<float> > &):\n3.14 4.2 7.9 8.08\nclass std::basic_ostream<char,struct std::char_traits<char> > &__cdecl operator\n<<<char,class std::list,class std::allocator<char>>(class std::basic_ostream<cha\nr,struct std::char_traits<char> > &,const class std::list<char,class std::alloca\ntor<char> > &):\nE F G H I\nclass std::basic_ostream<char,struct std::char_traits<char> > &__cdecl operator\n<<<int,class std::deque,class std::allocator<int>>(class std::basic_ostream<char\n,struct std::char_traits<char> > &,const class std::deque<int,class std::allocat\nor<int> > &):\n10 11 303 404 \n```", "```cpp\n//part 1: define template with non-type template parameters\ntemplate<const float* p> struct U {}; //float pointer non-type parameter\ntemplate<const Y& b> struct V {};     //L-value non-type parameter\ntemplate<void (*pf)(int)> struct W {};//function pointer parameter\n\n//part 2: define other related stuff\nvoid g(int,float);   //declare function g() \nvoid g(int);         //declare an overload function of g() \nstruct Y {           //declare structure Y \n    float m1;\n    static float m2;\n};         \nfloat a[10]; \nY y; //line a: create a object of Y\n\n//part 3: instantiation template with template non-type arguments\nU<a> u1;      //line b: ok: array to pointer conversion\nU<&y> u2;     //line c: error: address of Y\nU<&y.m1> u3;  //line d: error: address of non-static member\nU<&y.m2> u4;  //line e: ok: address of static member\nV<y> v;       //line f: ok: no conversion needed\nW<&g> w;      //line g: ok: overload resolution selects g(int)\n```", "```cpp\n//ch4_12_template_type_argument.cpp\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\n//part 1: define templates\ntemplate<class T> class C  {}; \ntemplate<class T> void f() { cout << \"T\" << endl; }; \ntemplate<int i>   void f() { cout << i << endl; };     \n\n//part 2: define structures\nstruct A{};            // incomplete type \ntypedef struct {} B; // type alias to an unnamed type\n\n//part 3: main() to test\nint main() {\n  cout << \"Tid1=\" << typeid(A).name() << \"; \"; \n  cout << \"Tid2=\" << typeid(A*).name() << \"; \";    \n  cout << \"Tid3=\" << typeid(B).name()  << \"; \";\n  cout << \"Tid4=\" << typeid(int()).name() << endl;\n\n  C<A> x1;    //line A: ok,'A' names a type\n  C<A*> x2;   //line B: ok, 'A*' names a type\n  C<B> x3;    //line C: ok, 'B' names a type\n  f<int()>(); //line D: ok, since int() is considered as a type, \n              //thus calls type template parameter f()\n  f<5>();     //line E: ok, this calls non-type template parameter f() \n  return 0;\n}\n```", "```cpp\nTid1=A; Tid2=P1A; Tid3=1B; Tid4=FivE\n```", "```cpp\nTid1=struct A; Tid2=struct A; Tid3=struct B; Tid4=int __cdecl(void)\n```", "```cpp\n//ch4_13_template_template_argument.cpp\n#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\n//primary class template X with template type parameters\ntemplate<class T, class U> \nclass X {\npublic:\n    T a;\n    U b;\n};\n\n//partially specialization of class template X\ntemplate<class U> \nclass X<int, U> {\npublic:\n    int a;  //customized a\n    U b;\n};\n\n//class template Y with template template parameter\ntemplate<template<class T, class U> class V> \nclass Y {\npublic:\n    V<int, char> i;\n    V<char, char> j;\n};\n\nY<X> c;\nint main() {\n    cout << typeid(c.i.a).name() << endl; //int\n    cout << typeid(c.i.b).name() << endl; //char\n    cout << typeid(c.j.a).name() << endl; //char\n    cout << typeid(c.j.b).name() << endl; //char\n    return 0;\n}\n```", "```cpp\n/ch4_14_default_template_arguments.cpp       //line 0\n#include <iostream>                          //line 1  \n#include <typeinfo>                          //line 2\ntemplate<class T1, class T2 = int> class X;  //line 3\ntemplate<class T1 = float, class T2> class X;//line 4\ntemplate<class T1, class T2> class X {       //line 5\npublic:                                      //line 6   \n T1 a;                                       //line 7\n T2 b;                                       //line 8  \n};                                           //line 9\nusing namespace std;\nint main() { \n X<int> x1;          //<int,int>\n X<float>x2;         //<float,int>\n X<>x3;              //<float,int>\n X<double, char> x4; //<double, char>\n cout << typeid(x1.a).name() << \", \" << typeid(x1.b).name() << endl;\n cout << typeid(x2.a).name() << \", \" << typeid(x2.b).name() << endl;\n cout << typeid(x3.a).name() << \", \" << typeid(x3.b).name() << endl;\n cout << typeid(x4.a).name() << \", \" << typeid(x4.b).name() << endl;\n return 0\n}\n```", "```cpp\ntemplate<class U = char, class V, class W = int> class X { };  //Error \ntemplate<class V, class U = char,  class W = int> class X { }; //OK\n```", "```cpp\ntemplate<class T = int> class Y;\n\n//compiling error, to fix it, replace \"<class T = int>\" by \"<class T>\"\ntemplate<class T = int> class Y { \n    public: T a;  \n};\n```", "```cpp\ntemplate <template_parameter_list> \nclass X { ... }\n\ntemplate <template_parameter_list> \nvoid foo( function_argument_list ) { ... } //assume return type is void\n```", "```cpp\nclass X<template_argument_list> x\nvoid foo<template_argument_list>( function_argument_list )\n```", "```cpp\n//primary class template is_void\ntemplate< typename T >\nstruct is_void{\n    static const bool value = false;  //default value=false \n};\n```", "```cpp\n//\"<>\" means a full specialization of template class is_void\ntemplate<> \nstruct is_void< void >{             //fully specialization for void\n    static const bool value = true; //only true for void type\n};\n```", "```cpp\nis_void<T>::value\n```", "```cpp\n//primary class template is_pointer\ntemplate< typename T > \nstruct is_pointer{\n    static const bool value = false;\n};\n```", "```cpp\n//\"typename T\" in \"<>\" means partial specialization\ntemplate< typename T >   \nstruct is_pointer< T* >{ //<T*> means partial specialization only for type T* \n  static const bool value = true;  //set value as true\n};\n```", "```cpp\nis_pointer<T>::value\n```", "```cpp\n//ch4_15_traits_boost.cpp\n#include <iostream>\n#include <type_traits>  //since C++11\nusing namespace std;\nstruct X {};\nint main()\n{\n cout << boolalpha; //set the boolalpha format flag for str stream.\n cout << is_void<void>::value << endl;          //true\n cout << is_void<int>::value << endl;           //false\n cout << is_pointer<X *>::value << endl;        //true\n cout << is_pointer<X>::value << endl;          //false\n cout << is_pointer<X &>::value << endl;        //false\n cout << is_pointer<int *>::value << endl;      //true\n cout << is_pointer<int **>::value << endl;     //true\n cout << is_pointer<int[10]>::value << endl;    //false\n cout << is_pointer< nullptr_t>::value << endl; //false\n}\n```", "```cpp\ntemplate<typename It1, typename It2> \nIt2 copy(It1 first, It1 last, It2 out);\n```", "```cpp\nnamespace detail{\n//1\\. Declare primary class template with a static function template\ntemplate <bool b>\nstruct copier {\n    template<typename I1, typename I2>\n    static I2 do_copy(I1 first, I1 last, I2 out);\n};\n//2\\. Implementation of the static function template\ntemplate <bool b>\ntemplate<typename I1, typename I2>\nI2 copier<b>::do_copy(I1 first, I1 last, I2 out) {\n    while(first != last) {\n        *out = *first; \n         ++out;\n         ++first;\n    }\n    return out;\n};\n//3\\. a full specialization of the primary function template\ntemplate <>\nstruct copier<true> {\n    template<typename I1, typename I2>\n    static I2* do_copy(I1* first, I1* last, I2* out){\n        memcpy(out, first, (last-first)*sizeof(I2));\n        return out+(last-first);\n    }\n};\n}  //end namespace detail\n```", "```cpp\n//copy() user interface \ntemplate<typename I1, typename I2>\ninline I2 copy(I1 first, I1 last, I2 out) {\n    typedef typename boost::remove_cv\n    <typename std::iterator_traits<I1>::value_type>::type v1_t;\n\n    typedef typename boost::remove_cv\n    <typename std::iterator_traits<I2>::value_type>::type v2_t;\n\n    enum{ can_opt = boost::is_same<v1_t, v2_t>::value\n                    && boost::is_pointer<I1>::value\n                    && boost::is_pointer<I2>::value\n                    && boost::has_trivial_assign<v1_t>::value \n   };\n   //if can_opt= true, using memcpy() to copy whole block by one \n   //call(optimized); otherwise, using assignment operator to \n   //do item-by-item copy\n   return detail::copier<can_opt>::do_copy(first, last, out);\n}\n```", "```cpp\n//ch4_17_factorial_recursion.cpp\n#include <iostream>\nuint32_t f1(const uint32_t n) {\n  return (n<=1) ? 1 : n * f1(n - 1);\n}\n\nconstexpr uint32_t f2(const uint32_t n) {\n  return ( n<=1 )? 1 : n * f2(n - 1);\n}\n\nint main() {\n  uint32_t a1 = f1(10);         //run-time computation \n  uint32_t a2 = f2(10);         //run-time computation \n  const uint32_t a3 = f2(10);   //compile-time computation \n  std::cout << \"a1=\" << a1 << \", a2=\" << a2 << std::endl;\n}\n```", "```cpp\n//ch4_18_factorial_metaprogramming.cpp\n#include <iostream>\n//define a primary template with non-type parameters\ntemplate <uint32_t n> \nstruct fact {\n  ***const static uint32_t*** value = n * fact<n - 1>::value;\n  //use next line if your compiler does not support declare and initialize\n  //a constant static int type member inside the class declaration \n  //enum { value = n * fact<n - 1>::value }; \n};\n\n//fully specialized template for n as 0\ntemplate <> \nstruct fact<0> { \n    const static uint32_t value = 1;\n    //enum { value = 1 };\n};\nusing namespace std;\nint main() {\n    cout << \"fact<0>=\" << fact<0>::value << endl;   //fact<0>=1\n    cout << \"fact<10>=\" << fact<10>::value << endl; //fact<10>=3628800\n\n    //Lab: uncomments the following two lines, build and run \n    //     this program, what are you expecting? \n    //uint32_t m=5;\n    //std::cout << fact<m>::value << std::endl;\n}\n```", "```cpp\nfact<10>::value = 10* fact<9>::value;\nfact<10>::value = 10* 9 * fact<8>::value;\nfact<10>::value = 10* 9 * 8 * fact<7>::value;\n.\n.\n.\nfact<10>::value = 10* 9 * 8 *7*6*5*4*3*2*fact<1>::value;\nfact<10>::value = 10* 9 * 8 *7*6*5*4*3*2*1*fact<0>::value;\n...\nfact<10>::value = 10* 9 * 8 *7*6*5*4*3*2*1*1;\n```", "```cpp\n//ch4_19_loop_unoolling_traditional.cpp\n#include <iostream>\nusing namespace std;\ntemplate<typename T>\nT dotp(int n, const T* a, const T* b)\n{\n  T ret = 0;\n  for (int i = 0; i < n; ++i) {\n      ret += a[i] * b[i];\n  }\n  return ret;\n}\n\nint main()\n{\n  float a[5] = { 1, 2, 3, 4, 5 };\n  float b[5] = { 6, 7, 8, 9, 10 };\n  cout<<\"dot_product(5,a,b)=\" << dotp<float>(5, a, b) << '\\n'; //130\n  cout<<\"dot_product(5,a,a)=\" << dotp<float>(5, a, a) << '\\n'; //55\n}\n```", "```cpp\n//ch4_20_loop_unroolling_metaprogramming.cpp\n#include <iostream>\n\n//primary template declaration\ntemplate <int N, typename T>    \nclass dotp {\npublic:\n  static T result(T* a, T* b) {\n    return (*a) * (*b) + dotp<N - 1, T>::result(a + 1, b + 1);\n  }\n};\n\n//partial specialization for end condition\ntemplate <typename T>   \nclass dotp<1, T> {\npublic:\n  static T result(T* a, T* b) {\n    return (*a) * (*b);\n  }\n};\n\nint main()\n{\n  float a[5] = { 1, 2, 3, 4, 5 };\n  float b[5] = { 6, 7, 8, 9, 10 };\n  std::cout << \"dot_product(5,a,b) = \" \n            << dotp<5, float>::result( a, b) << '\\n'; //130\n  std::cout << \"dot_product(5,a,a) = \" \n            << dotp<5,float>::result( a, a) << '\\n'; //55\n}\n```", "```cpp\ndotp<5, float>::result( a, b)\n= *a * *b + dotp<4,float>::result(a+1,b+1)\n= *a * *b + *(a+1) * *(b+1) + dotp<3,float>::result(a+2,b+2)\n= *a * *b + *(a+1) * *(b+1) + *(a+2) * *(b+2) \n  + dotp<2,float>::result(a+3,b+3)\n= *a * *b + *(a+1) * *(b+1) + *(a+2) * *(b+2) + *(a+3) * *(b+3) \n  + dotp<1,float>::result(a+4,b+4)\n= *a * *b + *(a+1) * *(b+1) + *(a+2) * *(b+2) + *(a+3) * *(b+3) \n  + *(a+4) * *(b+4)\n```", "```cpp\n//ch4_21_polymorphism_traditional.cpp\n#include <iostream>\nclass B{\npublic:\n    B() = default;\n    virtual void alg() { \n        std::cout << \"alg() in B\"; \n    }\n};\n\nclass D : public B{\npublic:\n    D() = default; \n    virtual void alg(){\n        std::cout << \"alg() in D\"; \n    }\n};\n\nint main()\n{\n    //derived object pointer p as an instance pointer of the base class\n    B *p = new D();\n    p->alg();       //outputs \"alg() in D\"\n    delete p;\n    return 0;\n}\n```", "```cpp\n//ch4_22_polymorphism_metaprogramming.cpp\n#include <iostream>\ntemplate <class D> struct B {\n    void ui() {\n        static_cast<D*>(this)->alg();\n    }\n};\n\nstruct D : B<D> {\n    void alg() {\n        cout << \"D::alg()\" << endl;\n     }\n};\n\nint main(){\n    B<D> b;\n    b.ui();\n    return 0;\n}\n```"]