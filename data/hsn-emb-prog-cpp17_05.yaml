- en: Resource-Restricted Embedded Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源受限的嵌入式系统
- en: Using a smaller embedded system such as a microcontroller (MCU) means having
    small amounts of RAM, CPU power, and storage. This chapter deals with planning
    for and making efficient use of limited resources taking into account the wide
    range of currently available MCUs and **System-on-Chip** (**SoC**) solutions.
    We will be considering the following aspects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较小的嵌入式系统，如微控制器（MCU），意味着具有较少的RAM、CPU功率和存储空间。本章涉及规划和有效利用有限资源，考虑到当前可用的各种MCU和**片上系统**（**SoC**）解决方案。我们将考虑以下方面：
- en: Selecting the right MCU for a project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目选择合适的MCU
- en: Concurrency and memory management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和内存管理
- en: Adding sensors, actuators, and network access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加传感器、执行器和网络访问
- en: Bare-metal development versus real-time OSes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸机开发与实时操作系统
- en: The big picture for small systems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小系统的大局观
- en: When first confronted with a new project that requires the use of at least one
    type of MCU, it can seem like an overwhelming task to. As we saw in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What
    are Embedded Systems?*, there is a large number of MCUs to choose from, even if
    we limit ourselves to just those that have been released recently.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次面对需要使用至少一种MCU的新项目时，可能会感到任务艰巨。正如我们在[第1章](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml)中看到的，*嵌入式系统是什么*，即使我们仅限于最近发布的MCU，也有大量MCU可供选择。
- en: It may seem obvious to start by asking how many bits one needs, as in selecting
    between 8-bit, 16-bit, and 32-bit MCUs, or something as easy to quantify as clock
    speed, but these metrics are sometimes misleading and often don't lend themselves
    well to narrowing down the product selection. As it turns out, the parent categories
    are availability of sufficient I/O and the integrated peripherals to make the
    hardware happen in a lean and reliable way, as well as processing power tailored
    to the requirements faced at design-time and predicted to emerge throughout the
    product life-time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时询问需要多少位可能似乎是显而易见的，比如在选择8位、16位和32位MCU之间，或者像时钟速度这样易于量化的东西，但这些指标有时会误导，并且通常不利于缩小产品选择范围。事实证明，父类别的可用性是足够的I/O和集成外围设备，以便以精简和可靠的方式实现硬件，以及针对设计时面临的要求和预计在产品寿命期间出现的处理能力。
- en: 'So in more detail we need to answer questions like these:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更详细地说，我们需要回答这些问题：
- en: '**Peripherals**: Which peripherals are needed to interact with the rest of
    the system?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围设备**：需要哪些外围设备与系统的其余部分进行交互？'
- en: '**CPU**: What level of CPU power is needed to run the application code?'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：运行应用程序代码需要多少CPU功率？'
- en: '**Floating point**: Do we need hardware floating point support?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：我们是否需要硬件浮点支持？'
- en: '**ROM**: How much ROM do we need to store the code?'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROM**：我们需要多少ROM来存储代码？'
- en: '**RAM**: How much RAM is required to run the code?'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：运行代码需要多少RAM？'
- en: '**Power and thermals**: What are the electrical power and thermal limitations?'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源和热量**：电气功率和热量限制是多少？'
- en: Each MCU family has its own strengths and weaknesses, though one of the most
    important factors to pick one MCU family over another the quality of its development
    tools. For hobby and other noncommercial projects, one would primarily consider
    the strength of the community and the available free development tools, while
    in the context of commercial projects one would also look at the support one could
    expect from the MCU manufacturer and possible third parties.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MCU系列都有其自身的优势和劣势，尽管选择一个MCU系列而不是另一个最重要的因素之一是其开发工具的质量。对于业余和其他非商业项目，人们主要会考虑社区的实力和可用的免费开发工具，而在商业项目的背景下，人们还会考虑MCU制造商和可能的第三方支持。
- en: A key aspect of embedded development is in-system programming and debugging.
    Since programming and debugging are intertwined, we'll be looking at the corresponding
    interface options later to be able to identify what satisfies our requirements
    and constraints.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发的一个关键方面是系统内编程和调试。由于编程和调试是相互交织的，我们将在稍后查看相应的接口选项，以便确定满足我们的需求和约束的内容。
- en: A popular and powerful debugging interface has become synonymous to the underlying
    Joint Test Action Group (JTAG) IEEE standard 1149.1 and easily recognized by signals
    frequently labeled TDI, TDO, TCK, TMS and TRST, defining the aptly-named Test
    Action Port (TAP). The larger standard has since been expanded up to 1149.8 and
    not all versions apply to digital logic, so we'll limit our scope to 1149.1 and
    a reduced pin count version described under 1149.7\. For now we just require that
    at least one of the full-featured JTAG, SWD and UPDI interfaces be supported.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个受欢迎且强大的调试接口已经成为底层联合测试动作组（JTAG）IEEE标准1149.1的代名词，并且很容易通过经常标记为TDI、TDO、TCK、TMS和TRST的信号来识别，定义了名副其实的测试动作端口（TAP）。该标准已经扩展到1149.8，并且并非所有版本都适用于数字逻辑，因此我们将限制我们的范围到1149.1和在1149.7下描述的降低的引脚计数版本。目前，我们只需要至少支持全功能JTAG、SWD和UPDI接口中的一个。
- en: Debugging MCU-based systems along with on-chip debugging, using both command-line
    tools and IDEs, is something that we will take an in-depth look at in [Chapter
    7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml), *Testing Resource-Limited Platforms*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml)中，我们将深入研究使用片上调试和命令行工具以及集成开发环境来调试基于MCU的系统的内容，*测试资源有限的平台*。
- en: Finally, if we are going to be making products containing the chosen MCU for
    an active production phase of a few years, it's vital that we ensure the MCU availability
    (or that of compatible replacements) for at least that period. Reputable manufacturers
    provide product life cycle information as part of their supply chain management,
    with discontinuation notices being sent 1 to 2 years in advance, and recommendations
    for lifetime buys.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们将在未来几年的活跃生产阶段中制造包含所选MCU的产品，那么至关重要的是我们确保至少在那段时间内MCU的可用性（或兼容替代品的可用性）。值得信赖的制造商将产品生命周期信息作为其供应链管理的一部分提供，提前1至2年发送停产通知，并建议进行寿命周期购买。
- en: For many applications, it is hard to ignore the wide availability of cheap,
    powerful, and easy-to-use Arduino compatible boards, especially the popular ones
    designed around the AVR family of MCUs. Among these, the ATmega MCUs—the mega168/328,
    and in particular the mega1280/2560 variants—provide significant amounts of processing
    power, ROM, and RAM for both high-level functionality and the handling of data
    for input, control, and telemetry, as well as a differentiated but rich sets of
    peripherals and GPIO.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用来说，很难忽视廉价、强大且易于使用的Arduino兼容板的广泛可用性，特别是围绕AVR系列MCU设计的流行板。在这些板中，ATmega MCU——mega168/328，特别是mega1280/2560变种——为高级功能和输入、控制和遥测数据处理提供了大量的处理能力、ROM和RAM，以及不同但丰富的外围设备和GPIO。
- en: All of these aspects make prototyping exceedingly simple before even committing
    to a more definitive variant with lower specifications and (hopefully) better
    BOM cost. As an example, the ATmega2560 "MEGA" board is shown as follows, and
    we will look at other boards in more detail later in this chapter as we work through
    a number of examples on how to develop for the AVR platform.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方面使得在承诺更具体的低规格和（希望）更好的BOM成本之前，原型设计变得非常简单。例如，ATmega2560“MEGA”板如下所示，我们将在本章后面的一些示例中更详细地研究其他板，以了解如何为AVR平台开发。
- en: '![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)'
- en: Generally, one would pick a number of MCUs that might work for the project,
    get the development boards, hook them up to the rest of the projected system components
    (often on their own development or breakout boards), and start developing the
    software for the MCU that will make everything work together.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会选择一些可能适用于项目的MCU，获取开发板，将它们连接到预期系统组件的其余部分（通常是在它们自己的开发板或分离板上），并开始为MCU开发软件，使一切协同工作。
- en: As more and more parts of the system become finalized, the number of development
    boards and bread-boarded components will dwindle until one reaches the point where
    one starts working on the final **printed circuit board** (**PCB**) layout. This
    will go through a number of iterations as well, as issues get ironed out, last-minute
    features are added, and the system as a whole is tested and optimized.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的更多部分变得最终确定，开发板和面包板组件的数量将减少，直到开始进行最终**印刷电路板**（**PCB**）布局。这也将经历多次迭代，因为问题得到解决，最后一刻添加功能，并且整个系统经过测试和优化。
- en: MCUs in such systems work on a physical level with the hardware, thus it is
    often a requirement to specify both hardware and software in tandem, if only because
    the software is so reliant on the hardware functionality. A common theme encountered
    in the industry is hardware modularity, either as small add-on PCBs with minimum
    added complexity, adding sensor or communication interfaces to devices such as
    temperature controllers and variable-frequency drives, or as full-fledged DIN
    rail modules connected to a common serial bus.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种系统中，MCU在物理层面与硬件一起工作，因此通常需要同时指定硬件和软件，因为软件对硬件功能非常依赖。在行业中经常遇到的一个共同主题是硬件模块化，可以作为小型附加PCB，最小化增加复杂性，为温度控制器和变频驱动器等设备添加传感器或通信接口，或作为全功能的DIN轨道模块连接到公共串行总线。
- en: Example – Machine controller for a laser cutter
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-激光切割机的机器控制器
- en: 'One of the fastest and most accurate ways to cut a wide range of materials
    is using a high-power laser. With the price of carbon dioxide (CO[2]) having dropped
    sharply over the years, this has led to widespread use of affordable (cheap) laser
    cutters as shown in the following image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高功率激光切割各种材料是最快速和最准确的方法之一。随着二氧化碳（CO[2]）的价格多年来急剧下降，这导致了廉价激光切割机的广泛使用，如下图所示：
- en: '![](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)'
- en: While it's perfectly possible to operate a laser cutter with nothing more than
    just a basic enclosure and the stepper motion control board that move the head
    across the machin bed, from a usability and safety point of view, this is not
    desirable. Still, many of the cheap laser cutters one can purchase online, however, do
    not come with any safety or usability features whatsoever.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以只使用基本的外壳和用于移动头部横跨机床的步进运动控制板来操作激光切割机，但从可用性和安全性的角度来看，这并不理想。然而，许多可以在线购买的廉价激光切割机完全没有任何安全或可用性功能。
- en: Functional specification
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规格
- en: 'To complete the product, we need to add a control system that uses sensors
    and actuators to monitor and control the state of the machine, ensuring that it
    is always in a safe state and shutting down the laser beam if necessary. This
    means protecting access to each of the following three sections:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成产品，我们需要添加一个控制系统，使用传感器和执行器来监视和控制机器的状态，确保它始终处于安全状态，并在必要时关闭激光束。这意味着保护以下三个部分的访问：
- en: '![](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)'
- en: The cutting beam is usually generated by a CO[2] laser, a type of gas laser
    that was invented in 1964\. The application of a high voltage causes current flow
    and thereby excitement of the gas molecules in the bore that make up the gain
    medium, ultimately resulting in the formation of a coherent beam of **long-wavelength
    infrared** (**LWIR**) or IR-C, light at a wavelength of 9.4 or 10.6 µm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 切割光束通常由CO[2]激光器产生，这是一种1964年发明的气体激光器。高电压的应用导致电流流动，从而激发孔内的气体分子，最终形成一束**长波红外**（**LWIR**）或IR-C的相干光束，波长为9.4或10.6微米。
- en: One characteristic of LWIR is that it is strongly absorbed by a large number
    of materials, so that it can be used for engraving, cutting, and even surgery
    on tissues as the water in biological tissues efficiently absorbs the laser beam.
    This also makes it obvious why even brief exposure of one's skin to a CO[2] laser's
    beam is extremely dangerous.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LWIR的一个特点是它被大量材料强烈吸收，因此可以用于雕刻、切割，甚至是组织的手术，因为生物组织中的水能够高效吸收激光束。这也解释了为什么即使皮肤短暂暴露于CO[2]激光束也是极其危险的。
- en: To achieve safe operation, exposure to laser light must be inhibited by locking
    the enclosure during normal operation, deactivating the laser power supply, and
    closing a beam shutter or preferably a combination of these measures when any
    of the interlocks is opened or any other safety condition is no longer satisfied.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现安全操作，必须通过在正常操作期间锁定封闭式空间、关闭激光电源，并在任何互锁打开或任何其他安全条件不再满足时关闭光束快门或最好是这些措施的组合来抑制激光光束的暴露。
- en: 'For example, temperature limits have to be upheld: most CO[2] lasers comprise
    of water-cooled gas discharge tube, which can quickly crack or bend in case of
    a cooling fault. What''s more, the cutting process creates irritating or toxic
    fumes that need to be continuously removed from the enclosure so as not to contaminate
    the optics and exit into the environment when the lid is opened.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，必须遵守温度限制：大多数CO[2]激光器由水冷气体放电管组成，在冷却故障的情况下可能会迅速破裂或弯曲。此外，切割过程会产生刺激性或有毒的烟雾，需要持续从封闭空间中排出，以免在打开盖子时污染光学器件并排出到环境中。
- en: These requirements necessitate that we monitor cooling water flow and temperature,
    air flow for the exhaust, and the air flow resistance (pressure drop over mass
    flow) of over the exhaust filter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求需要我们监测冷却水流量和温度，排气口的空气流动，以及排气过滤器的空气流动阻力（质量流量的压降）。
- en: Finally, we also want to make it convenient to use the laser cutter and avoid
    having to "bring your own device" to process the design in a machine-specific
    way, then convert it and upload it to the stepper motion controller board via
    USB. Instead, we want to load the design project from an SD card or USB stick
    and use a simple LCD and buttons to set options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还希望使用激光切割机变得更加方便，避免需要以机器特定的方式处理设计，然后将其转换并通过USB上传到步进电机控制板。相反，我们希望从SD卡或USB存储设备加载设计项目，并使用简单的LCD和按钮来设置选项。
- en: The design requirements
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计要求
- en: 'With the earlier requirements in mind, we can formulate a list of features
    needed for the control system:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到之前的要求，我们可以列出控制系统所需的功能列表：
- en: 'Operator safety:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员安全：
- en: Interlock switches on access panels (closed with the panel closed)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问面板上的互锁开关（关闭时）
- en: Locking mechanism (mechanically locking access panel; redundant)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定机制（机械锁定访问面板；冗余）
- en: Emergency stop
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急停止
- en: 'Laser cooling:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光冷却：
- en: Pump relay
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泵继电器
- en: Temperature sensor in water tank (cooling capacity, inlet temperature)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水箱中的温度传感器（冷却能力，进水温度）
- en: Temperature sensor on valve cooling exhaust (mantle temperature)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排气冷却口的温度传感器（外壳温度）
- en: Flow sensor (water flow speed; redundant)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量传感器（水流速；冗余）
- en: 'Air exhaust:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排气口：
- en: Fan relay
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇继电器
- en: Air filter status (differential pressure sensor)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气过滤器状态（差压传感器）
- en: Fan speed (RPM)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇速度（RPM）
- en: 'Laser module:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光模块：
- en: Laser power relay
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光功率继电器
- en: Beam shutter (redundant)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光束快门（冗余）
- en: User interface
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'Alert indicators for:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报指示灯：
- en: Panel interlock
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板互锁
- en: Air filter condition
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气过滤器状态
- en: Fan status
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇状态
- en: Pump status
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泵状态
- en: Water temperature
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水温
- en: 'Indicator LEDs for:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示灯：
- en: Standby
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待机
- en: Starting
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动
- en: Operation
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Emergency stop
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急停止
- en: Cool down
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冷却
- en: 'Communication:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通讯：
- en: USB communication with stepper board (UART)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与步进电机板的USB通信（UART）
- en: 'Motion control: generate stepper motor instructions'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动控制：生成步进电机指令
- en: Read files from SD card/USB stick
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从SD卡/USB存储设备读取文件
- en: Accept files over Ethernet/Wi-Fi
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以太网/ Wi-Fi接受文件
- en: NFC reader to identify users
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFC读卡器用于识别用户
- en: Implementation-related choices
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施相关选择
- en: 'As pointed out at the beginning of this chapter, mid-range MCUs are currently
    capable of providing the resources to satisfy most, if not all of our design requirements.
    So one of the tough questions is what we''ll be spending our money on: hardware
    components or software development? Imponderabilities aside, we''ll now take a
    closer look at three candidate solutions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所指出的，中档MCU目前能够提供资源来满足大多数，如果不是所有的设计要求。因此，我们将花钱在硬件组件上还是软件开发上是一个棘手的问题。除了无法预料的因素，我们现在将更仔细地研究三种候选解决方案：
- en: A single mid-range AVR MCU board (ATmega2560)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个中档AVR MCU板（ATmega2560）
- en: A higher-end Cortex-M3 MCU board (SAM3X8E)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高端的Cortex-M3 MCU板（SAM3X8E）
- en: A tandem of mid-range MCU board and an SBC with OS
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中档MCU板和带OS的SBC的组合
- en: We're pretty close to meeting hte design requirements with just an Arduino Mega
    (ATmega2560), as the first five sections require little in terms of CPU speed,
    just a number of digital input and output pins and a few analog ones depending
    on the exact sensors we'll be using or at most a peripheral interface to make
    use of (for example, for MEMS pressure sensors).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需一个Arduino Mega（ATmega2560）就可以满足设计要求，因为前五个部分在CPU速度方面要求不高，只需要一些数字输入和输出引脚，以及根据我们将使用的传感器的确切类型可能需要一些模拟引脚，或者最多需要一个外围接口来使用（例如，用于MEMS压力传感器）。
- en: The challenge starts with motion control feature under communications in the
    previous feature list, where we suddenly have to convert a **vector graphics file**
    (**.svg**) to a series of stepper commands. This is a compound problem of data
    transfer, file parsing, path generation, and what is known in the robotic world
    as inverse kinematics. USB communications can also be problematic for our 8-bit
    MCU, mostly because of peak processor loads coinciding with timeouts for USB endpoint
    communication or UART RX buffer register handling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战始于前一个功能清单中的通信中的运动控制功能，我们突然需要将**矢量图形文件**（**.svg**）转换为一系列步进命令。这是一个数据传输、文件解析、路径生成和在机器人世界中所知的逆运动学的复合问题。USB通信对我们的8位MCU也可能存在问题，主要是因为处理器负载的峰值与USB端点通信或UART
    RX缓冲寄存器处理的超时时间重合。
- en: 'The key is knowing when to change gears. Motion control is time critical as
    it''s tied to the inertia of the physical world. Additionally, we''re constrained
    by the processing and bandwidth resources of our controller to make control and
    data transfers, buffering, and ultimately the processing and output generation
    itself happen. As a general pattern, more capable internal or external peripherals
    can relax timing requirements by handling events and memory transactions themselves,
    reducing context switching and processing overhead. Here''s an incomplete list
    of such considerations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于知道何时改变策略。运动控制是时间关键的，因为它与物理世界的惯性有关。此外，我们受到控制器的处理和带宽资源的限制，使得控制和数据传输、缓冲以及最终的处理和输出生成本身成为可能。作为一个一般模式，更有能力的内部或外部外设可以通过处理事件和内存事务自己来放松时间要求，减少上下文切换和处理开销。以下是这些考虑的一个不完整列表：
- en: Simple UART requires collecting every byte upon RX Complete (RXC). Failure to
    do so results in data loss, as indicated by the DOR flag. A few controllers such
    as ATmega8u2 through ATmega32u4 provide native hardware flow control via RTS/CTS
    lines, which can prevent USB-UART converters such as PL2303 and FT232 from sending,
    forcing them to do the buffering instead until UDR is conveniently emptied again.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的UART需要在RX完成（RXC）时收集每个字节。如果未能这样做，将导致数据丢失，如DOR标志所示。一些控制器，如ATmega8u2到ATmega32u4，通过RTS/CTS线提供原生硬件流控制，可以防止USB-UART转换器（如PL2303和FT232）发送数据，迫使它们进行缓冲，直到UDR再次方便地清空。
- en: Dedicated USB host peripherals such as the MAX3421 are connected via SPI and
    effectively remove USB timing requirements for mass storage integration.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用的USB主机外设，如MAX3421，通过SPI连接，有效地消除了大容量存储集成的USB定时要求。
- en: UART aside, network communication peripherals are inherently buffered in software
    due to the complexity of the layer stack. For Ethernet, the W5500 is an attractive
    solution.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了UART之外，网络通信外设由于层堆栈的复杂性，在软件中具有固有的缓冲。对于以太网，W5500是一个有吸引力的解决方案。
- en: It sometimes makes sense to add another smaller MCU that independently handles
    I/O and pattern generation while implementing an interface of our choice – e.g.
    serial or parallel. This is already the case with some Arduino boards featuring
    an ATmega16u2 for USB serial conversion.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，添加另一个较小的MCU是有意义的，它可以独立处理I/O和模式生成，并实现我们选择的接口 - 例如串行或并行。这已经是一些Arduino板的情况，其中包含一个ATmega16u2用于USB串行转换。
- en: The NFC reader feature requirement calls for **Near-Field Communication** (**NFC**,
    a subset of RFID) to prevent unauthorized use of the laser cutter, which would
    add the biggest burden of all. Not due to the communicating with the NFC reader
    itself, but due to the increase in code size and CPU requirements to handle cryptography
    with certificates depending on the security level chosen. We would also need a
    secure place to store the certificates which usually bumps up MCU specs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: NFC读卡器功能要求**近场通信**（**NFC**，RFID的一个子集）以防止激光切割机的未经授权使用，这将增加最大的负担。不是因为与NFC读卡器本身的通信，而是由于代码大小的增加和处理密码学与证书的CPU需求增加，取决于所选择的安全级别。我们还需要一个安全的地方来存储证书，这通常会提高MCU的规格。
- en: Now we are at the point where we consider the more advanced options. The simpler
    ATmega2560 remains a great fit with its large amount of GPIO and can read SD cards
    over SPI along with communicating with an external integrated ethernet chip. However,
    the computationally or memory intensive tasks in motion control and NFC reader
    feature list would likely overburden the MCU or lead to convoluted "optimized"
    solutions with inferior maintainability if one were to try.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们到了考虑更高级选项的时候。更简单的ATmega2560仍然是一个很好的选择，因为它有大量的GPIO，并且可以通过SPI读取SD卡，同时与外部集成的以太网芯片通信。然而，在运动控制和NFC读卡器功能清单中的计算或内存密集型任务可能会使MCU负担过重，或者导致复杂的“优化”解决方案，可维护性较差。
- en: Upgrading the MCU to an ARM Cortex-M3 such as found on the Arduino Due development
    board, would likely resolve all those bottlenecks. It would preserve the large
    number of GPIO we got accustomed to on the ATmega2560, while increasing CPU performance
    significantly. The stepper drive patterns can be generated on the MCU, which also
    presents with native USB support, along with other advanced peripherals (USART,
    SPI and I2C and HSMCI, which also have DMA).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将MCU升级为Arduino Due开发板上找到的ARM Cortex-M3，可能会解决所有这些瓶颈。它将保留我们在ATmega2560上习惯的大量GPIO，同时显著提高CPU性能。步进驱动模式可以在MCU上生成，它还具有原生USB支持，以及其他高级外设（USART、SPI和I2C和HSMCI，它们也具有DMA）。
- en: 'A basic NFC tag reader could be connected via a UART, SPI, or I2C, and this
    design choice would lead to a system as shown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的NFC标签读卡器可以通过UART、SPI或I2C连接，这种设计选择会导致一个如图所示的系统：
- en: '![](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)'
- en: The third embodiment involving an SBC would again make use of the ATmega2560
    and add a low-powered SBC running an OS. This SBC would handle any CPU-intensive
    tasks, Ethernet and Wi-Fi connectivity, USB (host) tasks, and so on. It would
    communicate with the ATmega side via a UART, possibly adding a digital isolator
    or level shifter in between the boards to accommodate the 3.3V (SBC) and 5V TTL
    (Atmega) logic levels.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及SBC的第三种方案将再次使用ATmega2560，并添加一个运行OS的低功耗SBC。这个SBC将处理任何CPU密集型任务，以太网和Wi-Fi连接，USB（主机）任务等。它将通过UART与ATmega端通信，可能在两个板之间添加数字隔离器或电平转换器，以适应3.3V（SBC）和5V
    TTL（Atmega）逻辑电平。
- en: 'Choosing the SBC + MCU solution would substantially change the software challenges
    but only slightly reorganize our system on the hardware side. This would look
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择SBC + MCU解决方案将大大改变软件挑战，但在硬件方面只会略微重新组织我们的系统。这将如下所示：
- en: '![](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)'
- en: As with most development processes, there are only a few absolute answers, and
    many solutions pass functional requirements as *good enough* after trade-offs
    between power usage, complexity, and maintenance requirements affecting the final
    design choice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数开发过程一样，只有少数绝对的答案，许多解决方案在功耗、复杂性和维护要求之间进行权衡后，就能满足功能要求，被视为*足够好*的解决方案。
- en: In this particular example, one could choose either the higher-end single or
    dual-board solution, and it would most likely entail the same amount of effort
    to satisfy the requirements. One of the main differences would be that the OS-based
    solution adds the need to perform frequent OS updates, on account of it being
    a network-connected system running a full-blown OS whereas embedded ethernet controllers
    with offloaded hardwired TCP/IP stack and memories tend to be more robust and
    proven.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，可以选择高端单板或双板解决方案，而且很可能需要同样多的努力来满足要求。主要的区别之一是基于OS的解决方案需要进行频繁的OS更新，因为它是一个运行完整OS的网络连接系统，而嵌入式以太网控制器具有卸载的硬件TCP/IP堆栈和内存，往往更加稳健和可靠。
- en: The Cortex-M3-based option (or the even faster Cortex-M4) would feature just
    our own code, and thus would be unlikely to have any common security issues that
    could be easily targeted. We wouldn't be off the hook for maintenance, but our
    code would be small enough to validate and read through in its entirety, with
    the only letdown that the Arduino Due design fails to break out the pins for RMII
    to hook up an external Ethernet PHY, discouraging the use of its internal Ethernet
    MAC.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Cortex-M3的选项（或者更快的Cortex-M4）将只包含我们自己的代码，因此不太可能存在可以轻易被攻击的常见安全问题。我们仍然需要进行维护，但我们的代码足够小，可以完全验证和阅读，唯一的遗憾是Arduino
    Due设计未能为RMII引出引脚以连接外部以太网PHY，这会阻碍其内部以太网MAC的使用。
- en: 'Running down the checklist we put together at the beginning of this chapter,
    but this time with the ATmega2560 + SBC and application in mind, gives us the
    following distribution of duties:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在本章开头整理的清单，但这次考虑到ATmega2560 + SBC和应用程序，我们得到了以下的职责分配：
- en: '**Peripherals**: The MCU side will mostly need GPIO, some analog (ADC) inputs,
    Ethernet, USB, along with SPI and/or I2C.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围设备**：MCU端主要需要GPIO，一些模拟（ADC）输入，以太网，USB，以及SPI和/或I2C。'
- en: '**CPU**: The required MCU performance is time-critical but minor, except for
    when we need to do the processing of the vector path elements into stepper instructions.
    The SBC side can be sophisticated as long as enough commands can be queued for
    MCU-side execution and time-critical interaction is avoided.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：所需的MCU性能对时间至关重要，但较小，除非我们需要将矢量路径元素处理为步进指令。只要能够为MCU端执行足够的命令并避免时间关键的交互，SBC端可以很复杂。'
- en: '**Floating point**: The stepper instruction conversion algorithm on an MCU
    executes substantially faster if we have hardware floating point support. The
    length and time scales involved may make fixed point arithmetic feasible, relaxing
    this requirement.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点：如果我们有硬件浮点支持，MCU上的步进指令转换算法将执行得更快。所涉及的长度和时间尺度可能使固定点算术成为可能，从而放宽了这一要求。
- en: '**ROM**: The entire MCU code will likely fit into a few kilobytes since it''s
    not very complex. The SBC code will be larger by orders of magnitude just by invoking
    high-level libraries to provide the desired functionality but this will be more
    than offset by the similarly scaled mass storage and processing capabilities.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROM**：整个MCU代码可能只需要几千字节，因为它并不是非常复杂。SBC代码将通过调用高级库来提供所需的功能而大幅增加，但这将被类似规模的大容量存储和处理能力所抵消。'
- en: '**RAM**: A few KB of SRAM on the MCU should suffice. The stepper instruction
    conversion algorithm may require modifications to fit into the SRAM limitations
    with its buffering and processing data requirements. In a worst-case scenario,
    buffers can be downsized.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**：MCU上几KB的SRAM应该足够。步进指令转换算法可能需要修改以适应SRAM的限制，包括其缓冲和处理数据的要求。在最坏的情况下，缓冲区可以缩小。'
- en: '**Power and thermals**: In the light of the laser cutter system''s power needs
    and cooling system, we have got no significant power or thermal limitations. The
    section containing the control system also houses the main power supply and is
    already equipped with an appropriately sized cooling fan.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源和热量**：考虑到激光切割系统的功率需求和冷却系统，我们没有重大的功率或热量限制。包含控制系统的部分已经配备了适当尺寸的冷却风扇，并且已经安装了主电源供应。'
- en: It's important to note at this point that although we realized the complexity
    and requirements of the task at hand sufficiently to draw conclusions leading
    us to a selection of hardware components, the aspects of how to achieve them in
    detail are still left to the software developer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上需要注意的是，尽管我们已经充分意识到了手头任务的复杂性和要求，从而得出了对硬件组件的选择，但如何详细实现这些要求的方面仍然留给软件开发人员。
- en: For example, we could define our own data structures and formats and implement
    the machine-specific path generation and motion control ourselves, or adopt a
    (RS-274) G-code intermediate format which has been well-established in numerical
    control applications for several decades, and that lends itself well to generating
    motion control commands. G-code and has also found widespread acceptance in the
    diy hardware community, expecially for FDM 3D printing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义自己的数据结构和格式，并自行实现特定于机器的路径生成和运动控制，或者采用（RS-274）G代码中间格式，该格式在数控应用中已经有数十年的历史，并且非常适合生成运动控制命令。G代码在diy硬件社区中也得到了广泛的接受，特别是用于FDM
    3D打印。
- en: 'One noteworthy mature open source implementation of G-code based motion control
    is GRBL, introduced as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: G-code基于运动控制的一个值得注意的成熟开源实现是GRBL，引入为：
- en: Grbl is a free, open source, high performance software for controlling the motion
    of machines that move, that make things, or that make things move, and will run
    on a straight Arduino. If the maker movement was an industry, Grbl would be the
    industry standard.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Grbl是一个免费的、开源的、高性能的软件，用于控制移动的机器，制造东西，或者使东西移动，并且可以在直接的Arduino上运行。如果maker运动是一个行业，Grbl将成为行业标准。
- en: --https://github.com/gnea/grbl
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: --https://github.com/gnea/grbl
- en: Most likely we'll have to add halt and emergency stop features for different
    violations of our safety checks. While temperature excursions or a clogged filter
    would preferably just halt the laser cutter and permit resuming the job with the
    issues resolved, an interlock tripped by opening the enclosure must result in
    immediate shutdown of the laser, even without finishing the last command for a
    path segment and motion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能我们将不得不为不同的安全检查违规添加停止和紧急停止功能。虽然温度偏差或堵塞的过滤器最好只是停止激光切割机，并允许在解决问题后恢复工作，但是由于打开机箱而触发的联锁必须立即关闭激光，即使没有完成路径段和运动的最后命令。
- en: The choice to modularize the motion control task and produce G-code for it has
    benefits beyond the availability of proven implementations, allowing us to easily
    add usability features like manual control for setup and calibration as well as
    testability using previously generated, human-readable codes on the machine side
    just as inspection on the output of our file interpretation and path generation
    algorithms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化运动控制任务并为其生成G代码的选择除了具有经过验证的实现可用之外，还有其他好处，使我们可以轻松添加可用性功能，例如手动控制进行设置和校准，以及使用先前在机器端生成的可读代码进行可测试性，就像我们的文件解释和路径生成算法的输出检查一样。
- en: With the list of requirements, the initial design completed, and a deepened
    understanding of how we are going to achieve our goals, the next step would be
    to obtain a development board (or boards) with the chosen MCU and/or SoC, along
    with any peripherals so that one can get started on developing the firmware and
    integrating the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了需求列表，完成了初始设计，并对我们如何实现目标有了更深入的了解，下一步将是获取一个带有选择的MCU和/或SoC的开发板（或多个开发板），以及任何外围设备，以便可以开始开发固件并集成系统。
- en: While the full implementation of the machine control system as described in
    this example is beyond the scope of this book, an in-depth understanding of the
    development for both microcontroller and SBC target varieties will be strived
    for in the remainder of this chapter and [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml),
    *Example - Linux-Based Infotainment* System, and [Chapter 11](c90e29ad-2e13-4838-a9c2-885209717513.xhtml),
    *Developing for Hybrid SoC/FPGA Systems*, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书所述的机器控制系统的完整实现超出了本书的范围，但我们将在本章的其余部分和[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)中努力实现对微控制器和SBC目标品种的开发的深入理解，*测试基于OS的应用程序*，[第8章](4416b2de-d86a-4001-863d-b167635a0e10.xhtml)，*示例-基于Linux的信息娱乐系统*，以及[第11章](c90e29ad-2e13-4838-a9c2-885209717513.xhtml)，*为混合SoC/FPGA系统开发*。
- en: Embedded IDEs and frameworks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式IDE和框架
- en: While the application development for SoCs tends to be quite similar to desktop
    and server environments, as we saw in the previous chapter, MCU development requires
    a far more intimate knowledge of the hardware that one is developing for, sometimes
    down to the exact bits to set in a particular register.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SoC的应用开发往往与桌面和服务器环境非常相似，正如我们在上一章中看到的，MCU的开发需要对正在开发的硬件有更加深入的了解，有时甚至需要了解要在特定寄存器中设置的确切位。
- en: There exist some frameworks that seek to abstract away such details for particular
    MCU series, so that one can develop for a common API without having to worry about
    how it is implemented on a specific MCU. Of these, the Arduino framework is the
    most well-known outside of industrial applications, though there are also a number
    of commercial frameworks that are certified for production use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些旨在为特定MCU系列抽象这些细节的框架，以便可以开发一个通用API，而不必担心它在特定MCU上的实现方式。其中，Arduino框架是工业应用之外最为人所知的，尽管也有许多商业框架经过认证可用于生产。
- en: Frameworks such as the **Advanced Software Framework** (**ASF**) for AVR and
    SAM MCUs can be used with a variety of IDEs, including Atmel Studio, Keil µVision,
    and IAR Embedded Workbench.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如AVR和SAM MCU的**高级软件框架**（**ASF**）等框架可以与各种IDE一起使用，包括Atmel Studio、Keil µVision和IAR嵌入式工作室。
- en: 'A non-exhaustive list of popular embedded IDEs follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的嵌入式IDE的非尽事宜列表：
- en: '| **Name** | **Company** | **License** | **Platforms** | **Notes** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **公司** | **许可证** | **平台** | **备注** |'
- en: '| Atmel Studio | Microchip | Proprietary | AVR, SAM (ARM Cortex-M). | Originally
    developed by Atmel before being bought by Microchip. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Atmel Studio | Microchip | 专有 | AVR, SAM (ARM Cortex-M). | 最初由Atmel开发，后被Microchip收购。
    |'
- en: '| µVision | Keil (ARM) | Proprietary | ARM Cortex-M, 166, 8051, 251. | Part
    of the **Microcontroller Development Kit** (**MDK**) toolchain. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| µVision | Keil (ARM) | 专有 | ARM Cortex-M, 166, 8051, 251. | **微控制器开发套件**（**MDK**）工具链的一部分。
    |'
- en: '| Embedded Workbench | IAR | Proprietary | ARM Cortex-M, 8051, MSP430, AVR,
    Coldfire, STM8, H8, SuperH, etc. | Separate IDE for each MCU architecture. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 嵌入式工作台 | IAR | 专有 | ARM Cortex-M, 8051, MSP430, AVR, Coldfire, STM8, H8,
    SuperH等。 | 每个MCU架构都有单独的IDE。 |'
- en: '| MPLAB X | Microchip | Proprietary | PIC, AVR. | Uses the Java-based NetBeans
    IDE as foundation. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| MPLAB X | Microchip | 专有 | PIC, AVR. | 使用基于Java的NetBeans IDE作为基础。 |'
- en: '| Arduino | Arduino | GPLv2 | Some AVR and SAM MCUs (extendable). | Java-based
    IDE. Only supports its own C dialect language. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Arduino | Arduino | GPLv2 | 一些AVR和SAM MCU（可扩展）。 | 基于Java的IDE。仅支持自己的C方言语言。
    |'
- en: The main goal of an IDE is to integrate the entire workflow into a single application,
    from writing the initial code to programming the MCU memory with the compiled
    code and debugging the application while it runs on the platform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: IDE的主要目标是将整个工作流程集成到一个应用程序中，从编写初始代码到使用编译后的代码对MCU内存进行编程和调试应用程序运行时。
- en: Whether to use a full IDE is a matter of preference, however. All of the essential
    features are still there when using a basic editor and the tools from the command
    line, although frameworks such as the ASF are written to deeply integrate with
    IDEs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用完整的IDE是一个偏好问题。当使用基本编辑器和命令行工具时，所有基本功能仍然存在，尽管像ASF这样的框架是为了与IDE深度集成而编写的。
- en: One of the main advantages of the popular Arduino framework is that it has more
    or less standardized an API for various MCU peripherals and other functionality
    that is supported across an ever-growing number of MCU architectures. Coupled
    with the open source nature of the framework, it makes for an attractive target
    for a new project. This is particularly attractive when it comes to prototyping,
    courtesy of a large number of libraries and drivers written for this API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的Arduino框架的主要优势之一是，它已经在越来越多的MCU架构上支持了各种MCU外设和其他功能的API标准化。再加上框架的开源性质，使其成为一个新项目的吸引人的目标。当涉及到原型设计时，这一点尤为吸引人，因为有大量为这个API编写的库和驱动程序。
- en: Unfortunately, the Arduino IDE is unfortunately focused purely on a stripped-down
    dialect of the C programming language, despite its core libraries making widespread
    use of C++. Still this enables us to integrate just the libraries into our own
    embedded C++ projects, as we will see later in this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Arduino IDE只专注于C编程语言的简化方言，尽管其核心库广泛使用C++。尽管如此，这使我们能够将库集成到我们自己的嵌入式C++项目中，正如我们将在本章后面看到的那样。
- en: Programming MCUs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程MCU
- en: After we have compiled our code for the target MCU, the binary image needs to
    be written to a controller memory prior to execution and debugging. In this section
    we will look at the varied ways in which this can be accomplished. These days
    only factory-side programming is done with test sockets, or better yet at the
    wafer level before a known good die is bonded to a leadframe and encapsulated.
    Surface-mount parts already rule out easy removal of an MCU for (repeated) programming.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在为目标MCU编译代码之后，二进制图像需要在执行和调试之前写入控制器内存。在本节中，我们将看一下可以实现这一目标的各种方法。如今，只有在晶圆级别之前，已知良好的晶圆片被粘合到引线框架并封装之前，才会使用测试插座进行工厂端编程。表面贴装零件已经排除了轻松移除MCU进行（重复）编程的可能性。
- en: A number of (frequently vendor-specific) options for in-circuit programming
    exist, distinguished by the peripherals they use and the memories they affect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多（通常是特定供应商的）选项用于电路内编程，这些选项由它们使用的外设和它们影响的存储器区域来区分。
- en: So a pristine MCU often needs to be programmed using an external programming
    adapter. These generally work by setting the pins of the MCU so that it enters
    programming mode, after which the MCU accepts the data stream containing the new
    ROM image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个原始的MCU通常需要使用外部编程适配器进行编程。这些通常通过设置MCU的引脚，使其进入编程模式，之后MCU接受包含新ROM图像的数据流。
- en: Another option that is commonly used is to add a boot loader to the first section
    of the ROM, which allows the MCU to program itself. This works by having the boot
    loader check on startup whether it should switch to programming mode or continue
    loading the actual program, placed right after the boot loader section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的选项是在ROM的第一部分添加引导加载程序，允许MCU自行编程。这是通过引导加载程序在启动时检查是否应切换到编程模式或继续加载实际程序（放置在引导加载程序部分之后）来实现的。
- en: Memory programming and device debugging
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存编程和设备调试
- en: 'External programming adapters often utilize dedicated interfaces and associated
    protocols which permit programming and debugging of the target device. Protocols
    with which one can program an MCU include the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 外部编程适配器通常利用专用接口和相关协议，允许对目标设备进行编程和调试。可以用来编程MCU的协议包括以下内容：
- en: '| **Name** | **Pins** | **Features** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **引脚** | **特点** | **描述** |'
- en: '| **SPI (ISP)** | **4** | program | **Serial Peripheral Interface** (**SPI**),
    used with older AVR MCUs to access its Serial Programmer mode (**In-circuit Serial
    Programming** (**ISP**)). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **SPI（ISP）** | **4** | 程序 | **串行外围接口**（**SPI**），用于与旧AVR MCU一起访问其串行编程模式（**电路中串行编程**（**ISP**））。
    |'
- en: '| **JTAG** | **5** | program debug'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| **JTAG** | **5** | 程序调试'
- en: boundary | Dedicated, industry-standard on-chip interface for programming and
    debugging support. Supported on AVR ATxmega devices. |
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 边界 | 专用的，行业标准的芯片内接口，用于编程和调试支持。在AVR ATxmega设备上受支持。 |
- en: '| **UPDI** | **1** | program debug | The **Unified Programming and Debug Interface**
    (**UDPI**) used with newer AVR MCUs, including ATtiny devices. It''s a single-wire
    interface that''s the successor to the two-wire PDI found on ATxmega devices.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **UPDI** | **1** | 程序调试 | 用于较新的AVR MCU，包括ATtiny设备的**统一编程和调试接口**（**UDPI**）。这是ATxmega设备上发现的双线PDI的继任者的单线接口。
    |'
- en: '| **HVPP/****HVSP** | **17/****5** | program | High Voltage Parallel Programming
    / High Voltage Serial Programming. AVR programming mode using 12V on the reset
    pin and direct access to 8+ pins. Ignores any internal fuse setting or other configuration
    option. Mostly used for in-factory programming and for recovery. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **HVPP/****HVSP** | **17/****5** | 程序 | 高电压并行编程/高电压串行编程。AVR编程模式使用复位引脚上的12V和对8+引脚的直接访问。忽略任何内部保险丝设置或其他配置选项。主要用于工厂编程和恢复。'
- en: '| **TPI** | **3** | program | Tiny Programming Interface, used with some ATtiny
    AVR devices. These devices also lack the number of pins for HVPP or HVSP. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **TPI** | **3** | 程序 | 用于一些ATtiny AVR设备的微型编程接口。这些设备还缺少HVPP或HVSP的引脚数量。 |'
- en: '| **SWD** | **3** | program debug'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| **SWD** | **3** | 程序调试'
- en: boundary | Serial Wire Debug. Similar to reduced pin count JTAG with two lines,
    but uses ARM Debug Interface features, allowing a connected debugger to become
    a bus master with access to the MCU's memory and peripherals. |
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 边界 | 串行线调试。类似于具有两条线的减少引脚计数JTAG，但使用ARM调试接口功能，允许连接的调试器成为总线主机，访问MCU的存储器和外围设备。 |
- en: ARM MCUs generally provide JTAG as their primary means of programming and debugging.
    On 8-bit MCUs, JTAG is far less common, which is mostly due to the complexity
    of its requirements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ARM MCU通常提供JTAG作为其主要的编程和调试手段。在8位MCU上，JTAG并不常见，这主要是由于其要求的复杂性。
- en: AVR MCUs tend to offer In-System Programming (ISP) via SPI in addition to high
    voltage programming modes. Entering programming mode requires that the reset pin
    be held low during programming and verification and released and strobed at the
    end of the programming cycle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: AVR MCU倾向于提供通过SPI的系统编程（ISP），除了高电压编程模式。进入编程模式要求在编程和验证期间保持复位引脚低，并在编程周期结束时释放和触发。
- en: One requirement for ISP is that the relevant (SPIEN fuse bit) in the MCU is
    set to enable the in-system programming interface. Without this bit set, the device
    won’t respond on the SPI lines. Without JTAG available and enabled via the JTAGEN
    fuse bit, only HVPP or HVSP are available to recover and reprogram the chip. In
    the latter case, the unusual set of pins and the 12V supply voltage do not necessarily
    integrate well into the board circuitry.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ISP的一个要求是MCU中相关的（SPIEN保险丝位）被设置为启用系统编程接口。如果未设置此位，设备将不会在SPI线上响应。如果没有JTAG可用并通过JTAGEN保险丝位启用，则只能使用HVPP或HVSP来恢复和重新编程芯片。在后一种情况下，不寻常的引脚组合和12V供电电压不一定与板电路很好地集成。
- en: 'The physical connections required for most serial programming interfaces are
    fairly simple, even when the MCU has already been integrated into a circuit as
    shown in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数串行编程接口所需的物理连接都相当简单，即使MCU已经集成到电路中，如下图所示：
- en: '![](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)'
- en: Here, the external oscillator is optional if an internal one exists. The **PDI**,
    **PDO**, and **SCK** lines correspond to their respective SPI lines. The Reset
    line is held active (low) during programming. After connecting to the MCU in this
    manner, we are free to write to its flash memory, EEPROM, and configuration fuses.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果存在内部振荡器，则外部振荡器是可选的。 **PDI**，**PDO**和**SCK**线对应于它们各自的SPI线。在编程期间，复位线保持活动（低电平）。以这种方式连接到MCU后，我们可以自由地写入其闪存存储器，EEPROM和配置保险丝。
- en: On newer AVR devices, we find the **Unified Programming and Debug Interface**
    (**UPDI**), which uses just a single wire (in addition to the power and ground
    lines) to connect to the target MCU to provide both programming and debug support.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的AVR设备上，我们发现了**统一编程和调试接口**（**UPDI**），它只使用一根线（除了电源和地线）连接到目标MCU，以提供编程和调试支持。
- en: 'This interface simplifies the previous connection diagram to the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口简化了先前的连接图如下：
- en: '![](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)'
- en: 'This favorably compares to JTAG (IEEE 1149.1) on the ATxmega (when enabled)
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这与ATxmega上的JTAG（IEEE 1149.1）（启用时）有利地比较如下：
- en: '![](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)'
- en: Thereduced pin count JTAG standard (IEEE 1149) implemented on the ATxmega requires
    only one clock TCKC, one data wire TMSC and is aptly called Compact JTAG. Of these
    interfaces, UPDI still requires the fewest connections with the target device.
    Apart from that, both support similar features for AVR MCUs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在ATxmega上实现的减少引脚计数JTAG标准（IEEE 1149）仅需要一个时钟TCKC，一个数据线TMSC，因此被称为紧凑JTAG。在这些接口中，UPDI仍然需要与目标设备的最少连接。除此之外，它们都支持AVR
    MCU的类似功能。
- en: For other systems using JTAG for programming and debugging, no standard connection
    exists. Each manufacturer uses their own preferred connector, ranging from 2 x
    5 pins (Altera, AVR) to 2 x 10 pins (ARM), or a single 8-pin connector (Lattice).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用JTAG进行编程和调试的其他系统，没有标准连接。每个制造商都使用自己首选的连接器，从2 x 5引脚（Altera，AVR）到2 x 10引脚（ARM），或单个8引脚连接器（Lattice）。
- en: With JTAG being more a protocol standard rather than a physical specification,
    one should consult the documentation for one's target platform for the specific
    details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JTAG更多是一种协议标准而不是物理规范，因此应就特定细节咨询目标平台的文档。
- en: Boot loader
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: The boot loader has been introduced as a small extra application that uses an
    existing interface (for example, UART or Ethernet) to provide self-programming
    capabilities. On the AVR, a boot loader section of 256 bytes to 4 KB can be reserved
    in its flash. This code can perform any number of user-defined tasks, from setting
    up a serial link with a remote system, to booting from a remote image over Ethernet
    using PXE.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序已被引入为一个小的额外应用程序，它使用现有接口（例如UART或以太网）提供自我编程能力。在AVR上，可以在其闪存中保留256字节到4 KB的引导加载程序部分。此代码可以执行任意数量的用户定义任务，从与远程系统建立串行链接，到使用PXE通过以太网从远程镜像引导。
- en: 'At its core, an AVR boot loader is no different from any other AVR application,
    except that when compiling it one extra linker flag is added to set the starting
    byte address for the boot loader:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，AVR引导加载程序与任何其他AVR应用程序没有什么不同，只是在编译时添加了一个额外的链接器标志来设置引导加载程序的起始字节地址：
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace this address with a similar one for the specific MCU that you''re using
    (for AVR depending on the BOOTSZ flags set and controller used, see datasheet
    table about Boot Size Configuration: Boot Reset Address, where, for example, the
    boot reset address is 0xC00 is in words and the section start is defined in bytes).
    This ensures that the boot loader code will be written to the proper location
    in the MCU''s ROM. Writing the boot loader code to the ROM is almost always done
    via ISP.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用特定MCU的类似地址替换这个地址（对于AVR，根据设置的BOOTSZ标志和使用的控制器，查看关于引导大小配置的数据表：引导复位地址，例如，引导复位地址为0xC00是以字为单位的，部分起始位置以字节定义）。这确保引导加载程序代码将被写入MCU的ROM的正确位置。将引导加载程序代码写入ROM通常通过ISP完成。
- en: 'AVR MCUs divide the flash ROM into two sections: the **no-read-while-write **(**NRWW**)
    (for most, if not all application memory space) and **read-while-write** (**RWW**)
    sections. In brief, this means that the RWW section can be safely erased and rewritten
    without affecting the CPU''s operation. This is why the boot loader resides in
    the NRWW section and also why it''s not easy to have the boot loader update itself.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: AVR MCU将flash ROM分为两个部分：**不可读写时写**（对于大多数，如果不是所有的应用内存空间）和**可读写时写**（**RWW**）部分。简而言之，这意味着RWW部分可以安全地擦除和重写，而不会影响CPU的操作。这就是为什么引导加载程序驻留在NRWW部分的原因，也是为什么引导加载程序不容易更新自身的原因。
- en: Another important detail is that the boot loader can also not update the fuses
    that set various flags in the MCU. To change these, one has to externally program
    the device.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的细节是引导加载程序也不能更新设置MCU中各种标志的保险丝。要更改这些标志，必须通过外部编程设备进行。
- en: After programming the MCU with a boot loader, one would generally set the flags
    in the MCU that let the processor know that a boot loader has been installed.
    In the case of AVR, these flags are BOOTSZ and BOOTRST.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用引导加载程序对MCU进行编程后，通常会设置MCU中的标志，以让处理器知道已安装引导加载程序。在AVR的情况下，这些标志是BOOTSZ和BOOTRST。
- en: Memory management
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: The storage and memory system of microcontrollers consists out of multiple components.
    There is a section of **read-only-memory** (**ROM**) that is only written to once
    when the chip is programmed, but which cannot normally be altered by the MCU itself,
    as we saw in the previous section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器的存储和内存系统由多个组件组成。有一个**只读存储器**（**ROM**）部分，它只在芯片编程时写入一次，但通常不能被MCU本身改变，正如我们在前一节中看到的。
- en: 'The MCU may also have a bit of persistent storage, in the form of EEPROM or
    equivalent. Finally, there are CPU registers and the **random-access memory**
    (**RAM**). This results in the following exemplary memory layout:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: MCU可能还有一些持久存储，以EEPROM或等效形式存在。最后，还有CPU寄存器和**随机存取存储器**（**RAM**）。这导致以下示例性的内存布局：
- en: '![](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)'
- en: The use of a modified Harvard architecture (split program and data memory at
    some architectural level, generally with the data buses) is common with MCUs.
    With the AVR architecture, for example, the program memory is found in the ROM,
    which for the ATmega2560 is connected using its own bus with the CPU core, as
    one can seen on the block diagram for this MCU, which we looked at previously
    in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What Are Embedded
    Systems?*
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改后的哈佛架构（在某个架构级别上分割程序和数据存储器，通常使用数据总线）在MCU中很常见。例如，AVR架构中，程序存储器位于ROM中，对于ATmega2560，它使用自己的总线与CPU核心连接，正如我们在[第1章](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml)中所看到的那样，这是这个MCU的框图，*嵌入式系统是什么？*
- en: A major advantage of having separate buses for these memory spaces is that one
    can address each of them separately, which makes better use of the limited addressing
    space available to an 8-bit processor (1 and 2 byte wide address). It also allows
    for concurrent accesses while the CPU is busy with the other memory space, further
    optimizing the available resources.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内存空间分开为不同的总线的一个主要优势是可以分别访问它们，这样更好地利用了8位处理器可用的有限寻址空间（1和2字节宽地址）。这还允许在CPU忙于其他内存空间时进行并发访问，进一步优化了可用资源。
- en: For the data memory in the SRAM, we are then free to use it as we want. Here,
    we do need at least a stack to be able to run a program. Depending on how much
    SRAM is left in the MCU, we can then also add a heap. Applications of moderate
    complexity can be realized with only stack and statically allocated memory though,
    not involving higher-level language features that produce code with heap allocations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SRAM中的数据存储器，我们可以自由使用它。在这里，我们至少需要一个堆栈才能运行程序。根据MCU中剩余的SRAM量，我们还可以添加堆。然而，只涉及静态分配内存的中等复杂度的应用程序，不涉及产生带有堆分配代码的高级语言特性，可以实现。
- en: Stack and heap
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈和堆
- en: 'Whether one needs to initialize the stack on the MCU that one is programming
    for depends on how low-level one wishes to go. When using the C-runtime (on AVR:
    `avr-libc`), the runtime will handle initializing the stack and other details
    by letting the linker place naked code into init sections, for example specified
    by:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要在编程的MCU上初始化堆栈取决于一个人希望走多低级。当使用C运行时（在AVR上：`avr-libc`），运行时将通过让链接器将裸代码放入init部分（例如由以下指定）来处理初始化堆栈和其他细节：
- en: '[PRE1]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Preceding the execution of any of our own application code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何我们自己的应用代码之前。
- en: 'The standard RAM layout on AVR is to start with the `.data` variables at the
    beginning of the RAM, followed by `.bss`. The stack is started from the opposite
    site of the RAM, growing towards the beginning. There will be room left between
    the end of the `.bss` section and the end of the stack illustrated as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: AVR上的标准RAM布局是从RAM的开始处开始`.data`变量，然后是`.bss`。堆栈从RAM的相反位置开始，向开始位置增长。在`.bss`部分的结束和堆栈的结束之间将留下空间，如下所示：
- en: '![](img/c84909aa-7715-46f6-9538-5760568e9748.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c84909aa-7715-46f6-9538-5760568e9748.png)'
- en: 'Since the stack grows depending on the depth of the function calls in the application
    being run, it is hard to say how much space is available. Some MCUs allow one
    to use external RAM as well, which would be a possible location for the heap as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈的增长取决于正在运行的应用程序中函数调用的深度，很难说有多少空间可用。一些MCU还允许使用外部RAM，这可能是堆的可能位置如下：
- en: '![](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)'
- en: The AVR Libc library implements a `malloc()` memory allocator routine, optimized
    for the AVR architecture. Using it, one can implement one's own `new` and `delete`
    functionality as well—if one so desires—since the AVR toolchain does not implement
    either.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: AVR Libc库实现了一个针对AVR架构进行了优化的`malloc()`内存分配器例程。使用它，可以实现自己的`new`和`delete`功能，如果有需要的话，因为AVR工具链没有实现这两个功能。
- en: 'In order to use external memory with an AVR MCU for heap storage, one would
    have to make sure that the external memory has been initialized, after which the
    address space becomes available to `malloc()`. The start and end of the heap space
    is hereby defined by these global variables:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在AVR MCU上使用外部内存作为堆存储，必须确保已初始化外部内存，之后地址空间才可供`malloc()`使用。堆空间的起始和结束由以下全局变量定义：
- en: '[PRE2]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The AVR documentation has the following advice regarding adjusting the heap:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: AVR文档对调整堆的建议如下：
- en: If the heap is going to be moved to external RAM, `__malloc_heap_end` must be
    adjusted accordingly. This can either be done at runtime, by writing directly
    to this variable, or it can be done automatically at link-time, by adjusting the
    value of the symbol `__heap_end`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆将移动到外部RAM，`__malloc_heap_end`必须相应调整。这可以在运行时直接写入该变量，也可以在链接时通过调整符号`__heap_end`的值来自动完成。
- en: Interrupts, ESP8266 IRAM_ATTR
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断，ESP8266 IRAM_ATTR
- en: On a desktop PC or server the entire application binary would be loaded into
    RAM. On MCUs though it is common to leave as many of the program instructions
    in the ROM as possible until they are needed. This means that most of our application's
    instructions cannot be executed immediately, but first have to be fetched from
    ROM before the CPU of our MCU can fetch them via the instruction bus to be executed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在台式PC或服务器上，整个应用程序二进制文件将加载到RAM中。但是在MCU上，通常会尽可能多地将程序指令保留在ROM中，直到需要它们。这意味着我们应用程序的大部分指令不能立即执行，而必须先从ROM中获取，然后MCU的CPU才能通过指令总线获取它们以执行。
- en: 'On the AVR, each possible interrupt is defined in a vector table, which is
    stored in ROM. This offers either default handlers for each interrupt type, or
    the user-defined version. To mark an interrupt routine, one either uses the `__attribute__((signal))`
    attribute, or uses the `ISR()` macro:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在AVR上，每个可能的中断都在向量表中定义，该表存储在ROM中。这为每种中断类型提供了默认处理程序或用户定义的版本。要标记中断例程，可以使用`__attribute__((signal))`属性，或者使用`ISR()`宏：
- en: '[PRE3]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This macro handles the details of registering an interrupt. One just has to
    specify the name and define a function for the interrupt handler. This will then
    get called via the interrupt vector table.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏处理注册中断的细节。只需指定名称并为中断处理程序定义一个函数。然后通过中断向量表调用它。
- en: With the ESP8266 (and its successor, the ESP32) we can mark the interrupt handler
    function with a special attribute, `IRAM_ATTR`. Unlike the AVR, the ESP8266 MCU
    does not have built-in ROM, but has to use its SPI peripheral to load any instructions
    into RAM, which is obviously quite slow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ESP8266（及其后续产品ESP32），我们可以使用特殊属性`IRAM_ATTR`标记中断处理程序函数。与AVR不同，ESP8266 MCU没有内置ROM，而必须使用其SPI外设将任何指令加载到RAM中，这显然相当慢。
- en: 'An example of using this attribute with an interrupt handler looks as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性与中断处理程序的示例如下：
- en: '[PRE4]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have an interrupt handler that is connected to the signal from a motion
    detector, connected to an input pin. As with any well-written interrupt handler,
    it is quite simple and meant to be quickly executed before returning to the normal
    flow of the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个与运动检测器信号连接的中断处理程序，连接到一个输入引脚。与任何良好编写的中断处理程序一样，它非常简单，旨在在返回到应用程序的正常流程之前快速执行。
- en: Having this handler in ROM would mean that the routine would not respond near-instantly
    to the motion sensor's output changing. Worse, it would cause the handler to take
    much longer to finish, which would consequently delay the execution of the rest
    of the application code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将此处理程序放在ROM中，这意味着例程不会立即响应运动传感器输出的变化。更糟糕的是，这将导致处理程序需要更长的时间才能完成，从而延迟应用程序其余代码的执行。
- en: By marking it with `IRAM_ATTR`, we can avoid this problem, since the entire
    handler will already be in RAM when it's needed, instead of the whole system stalling
    as it waits for the SPI bus to return the requested data before it can continue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`IRAM_ATTR`标记，我们可以避免这个问题，因为整个处理程序在需要时已经在RAM中，而不是整个系统在等待SPI总线返回请求的数据之前就会停顿。
- en: Note that, tempting as it may seem, this kind of attribute should be used sparingly,
    as most MCUs have much more ROM than RAM. In the case of ESP8266, there are 64kB
    RAM for code execution complemented by possibly megabytes of external Flash ROM.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管这种属性可能看起来很诱人，但应该谨慎使用，因为大多数MCU的ROM比RAM多得多。在ESP8266的情况下，有64kB RAM用于代码执行，可能还有数兆字节的外部Flash
    ROM。
- en: When compiling our code, the compiler will put instructions marked with this
    attribute into a special section, so that the MCU knows to load it into RAM.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译我们的代码时，编译器会将带有此属性标记的指令放入一个特殊的部分，以便MCU知道将其加载到RAM中。
- en: Concurrency
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: With a few exceptions, MCUs are single-core systems. Multitasking is not something
    that is generally done; instead, there's a single thread of execution with timers
    and interrupts adding asynchronous methods of operation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了少数例外，MCU是单核系统。多任务处理通常不会进行；相反，有一个单一的执行线程，计时器和中断添加了异步操作的方法。
- en: Atomic operations are generally supported by compilers and AVR is no exception.
    The need for atomic blocks of instructions can be seen in the following cases.
    Keep in mind that while a few exceptions exist (MOVW to copy a register pair and
    indirect addressing via X, Y, Z pointers), instructions on an 8 bit architecture
    generally only affect 8 bit values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作通常由编译器支持，AVR也不例外。在以下情况下可以看到需要原子指令块。请记住，虽然存在一些例外情况（MOVW用于复制寄存器对和通过X、Y、Z指针进行间接寻址），但在8位架构上的指令通常只影响8位值。
- en: A 16 bit variable is byte-wise read in the main function and updated in an ISR.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主函数中以字节方式读取一个16位变量，并在ISR中更新它。
- en: A 32 bit variable is read, modified and subsequently stored back in either main
    function or ISR while the other routine could try to access it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个32位变量在主函数或ISR中被读取、修改，然后存储回去，而另一个例程可能会尝试访问它。
- en: The execution of a block of code is time-critical (bitbanging I/O, disabling
    JTAG).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的执行时间至关重要（比如位操作I/O，禁用JTAG）。
- en: 'A basic example for the first case is given in the AVR libc documentation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: AVR libc文档中给出了第一种情况的基本示例：
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, a 16-bit integer is being changed in the interrupt handler, while
    the main routine is copying its value into a local variable. We call `sei()` (SEt
    global Interrupt flag) to ensure that the interrupt register is in a known state.
    The `volatile` keyword hints to the compiler that this variable and how it's accessed
    should not be optimized in any way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，一个16位整数在中断处理程序中被改变，而主程序正在将其值复制到一个本地变量中。我们调用`sei()`（设置全局中断标志）来确保中断寄存器处于已知状态。`volatile`关键字提示编译器，这个变量及其访问方式不应以任何方式进行优化。
- en: Because we included the AVR atomic header, we can use the `ATOMIC_BLOCK` macro,
    along with the `ATOMIC_FORCEON` macro. What this does is create a code section
    that is guaranteed to be executed atomically, without any interference from interrupt
    handlers and the like. The parameter we pass to `ATOMIC_BLOCK` forces the global
    interrupt status flag into an enabled state.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们包含了AVR原子头文件，我们可以使用`ATOMIC_BLOCK`宏，以及`ATOMIC_FORCEON`宏。这样做会创建一个代码段，保证以原子方式执行，没有任何干扰来自中断处理程序等。我们传递给`ATOMIC_BLOCK`的参数将全局中断状态标志强制为启用状态。
- en: Since we set this flag to the same state before we started the atomic block,
    we do not need to save the previous value of this flag, which saves resources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在开始原子块之前将此标志设置为相同状态，我们不需要保存此标志的先前值，这节省了资源。
- en: As noted earlier, MCUs tend to be single-core systems, with limited multitasking
    and multithreading capabilities. For proper multithreading and multitasking, one
    would need to do context switches, whereby not only the stack pointer of the running
    task is saved, but also the state of all registers and related.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，MCU往往是单核系统，具有有限的多任务处理和多线程能力。要进行适当的多线程和多任务处理，需要进行上下文切换，不仅要保存运行任务的堆栈指针，还要保存所有寄存器和相关状态。
- en: This means that while it would be possible to run multiple threads and tasks
    on a single MCU, in the case of 8-bit MCUs such as the AVR and PIC (8-bit range),
    the effort would most likely not be worth it, and would require a significant
    amount of labor.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然在单个MCU上可能运行多个线程和任务是可能的，在8位MCU（如AVR和PIC（8位范围））的情况下，这样做的努力很可能不值得，而且需要大量的劳动。
- en: On more powerful MCUs (like the ESP8255 and ARM Cortex-M), one could run **real-time
    OSes** (**RTOSes**), which implement exactly such context switching, without having
    to do all of the heavy lifting. We will look at RTOSes later in this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在更强大的MCU上（如ESP8255和ARM Cortex-M），可以运行**实时操作系统**（RTOSes），这些系统实现了这种上下文切换，而不需要做所有的繁重工作。我们将在本章后面讨论RTOSes。
- en: AVR development with Nodate
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AVR开发与Nodate
- en: Microchip provides a binary version of the GCC toolchain for AVR development.
    At the time of writing, the most recent release of AVR-GCC is 3.6.1, containing
    GCC version 5.4.0\. This implies full support for C++14 and limited support for
    C++17.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Microchip为AVR开发提供了GCC工具链的二进制版本。在撰写本文时，最新版本的AVR-GCC是3.6.1，包含GCC版本5.4.0。这意味着对C++14的全面支持和对C++17的有限支持。
- en: Using this toolchain is pretty easy. One can simply download it from the Microchip
    website, extract it to a suitable folder, and add the folder containing the GCC
    executable files to the system path. After this, it can be used to compile AVR
    applications. Some platforms will have the AVR toolchain available via a package
    manager as well, which makes the process even easier.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具链非常容易。可以从Microchip网站上简单地下载它，将其解压到一个合适的文件夹，并将包含GCC可执行文件的文件夹添加到系统路径中。之后，它可以用来编译AVR应用程序。一些平台也会通过包管理器提供AVR工具链，这样的话过程会更加简单。
- en: 'One thing that one may notice after installing this GCC toolchain is that there
    is no C++ STL available. As a result, one is limited to just the C++ language
    features supported by GCC. As the Microchip AVR FAQ notes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这个GCC工具链后，一个可能注意到的事情是没有C++ STL可用。因此，只能使用GCC支持的C++语言特性。正如Microchip AVR FAQ所指出的：
- en: Obviously, none of the C++ related standard functions, classes, and template
    classes are available.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，C++相关的标准函数、类和模板类都不可用。
- en: The operators new and delete are not implemented; attempting to use them will
    cause the linker to complain about undefined external references. (This could
    perhaps be fixed.)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符new和delete没有被实现；尝试使用它们会导致链接器抱怨未定义的外部引用。（这可能可以修复。）
- en: Some of the supplied include files are not C++ safe, that is, they need to be
    wrapped into `extern"C" { . . . }`. (This could certainly be fixed, too.)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些提供的包含文件不是C++安全的，也就是说，它们需要被包装成`extern"C" { . . . }`。（这当然也可以修复。）
- en: Exceptions are not supported. Since exceptions are enabled by default in the
    C++ frontend, they explicitly need to be turned off using `-fno-exceptions` in
    the compiler options. Failing this, the linker will complain about an undefined
    external reference to `__gxx_personality_sj0`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持异常。由于C++前端默认启用异常，需要在编译器选项中使用`-fno-exceptions`显式关闭异常。如果没有这样做，链接器将抱怨对`__gxx_personality_sj0`的未定义外部引用。
- en: With the lack of a Libstdc++ implementation that would contain the STL features,
    we can only add such functionality by using a third-party implementation. These
    include versions that provide essentially the full STL, as well as lightweight
    re-implementations that do not follow the standard STL API. An example of the
    latter is the Arduino AVR core, which provides classes such as String and Vector,
    which are similar to their STL equivalents albeit with some limitations and differences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏包含STL功能的Libstdc++实现，我们只能通过使用第三方实现来添加这样的功能。这些包括基本上提供完整STL的版本，以及不遵循标准STL API的轻量级重新实现。后者的一个例子是Arduino
    AVR核心，它提供了类似于STL等效的String和Vector类，尽管存在一些限制和差异。
- en: An upcoming alternative to the Microchip AVR GCC toolchain is LLVM, a compiler
    framework to which experimental support for AVR as been recently added, and which
    at some point in the future should allow producing binaries for AVR MCUs, all
    the while providing full STL functionality via its Clang frontend (C/C++ support).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Microchip AVR GCC工具链的一种替代方案是LLVM，这是一个编译器框架，最近为AVR添加了实验性支持，并且在未来的某个时候应该允许为AVR
    MCU生成二进制文件，同时通过其Clang前端（C/C++支持）提供完整的STL功能。
- en: '![](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)'
- en: Consider this an abstract snapshot of LLVM development—all the while illustrating
    the general concept of LLVM and its emphasis on Intermediate Representation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将这视为LLVM开发的一个抽象快照，同时说明LLVM的一般概念及其对中间表示的强调。
- en: Unfortunately the PIC range of MCUs, despite also being owned by Microchip and
    resembling AVR in many ways, does at this point not have a C++ compiler available
    for it from Microchip until one moves up to the PIC32 (MIPS-based) range of MCUs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管PIC MCU系列在许多方面也属于Microchip并且类似于AVR，但在这一点上，Microchip并没有为其提供C++编译器，直到将其升级到PIC32（基于MIPS）MCU系列。
- en: Enter Nodate
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入Nodate
- en: You could at this point opt to use one of the IDEs we discussed previously in
    this chapter, but that wouldn't be nearly as educational for AVR development itself.
    For this reason, we will look at a simple application developed for an ATmega2560
    board that uses a modified version of the Arduino AVR core, called Nodate ([https://github.com/MayaPosch/Nodate](https://github.com/MayaPosch/Nodate)).
    This framework restructures the original core to allow it to be used as a regular
    C++ library instead of only with the Arduino C-dialect parser and frontend.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以选择使用我们在本章中之前讨论过的IDE之一，但这对于AVR开发本身来说并不那么有教育意义。因此，我们将看一个为使用修改后的Arduino
    AVR核心开发的ATmega2560板的简单应用程序，称为Nodate（[https://github.com/MayaPosch/Nodate](https://github.com/MayaPosch/Nodate)）。这个框架重构了原始核心，使其可以作为常规C++库来使用，而不仅仅是与Arduino
    C方言解析器和前端一起使用。
- en: 'Installing Nodate is pretty easy: simply download to a suitable location on
    one''s system and have the `NODATE_HOME` system variable point to the root folder
    of the Nodate installation. After this, we can take one of the example applications
    as a basis for a new project.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nodate非常简单：只需将其下载到系统的适当位置，并将`NODATE_HOME`系统变量指向Nodate安装的根文件夹。之后，我们可以以一个示例应用程序作为新项目的基础。
- en: Example – CMOS IC Tester
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - CMOS IC测试仪
- en: Here, we will look at a more full-featured example project, implementing an
    **integrated circuit** (**IC**) tester for 5V logic chips. In addition to probing
    chips with its GPIO pins, this project also reads a chip description and test
    program (in the form of a logic table) from an SD card over SPI. User control
    is added in the form of a serial-based command-line interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看一个更全面的示例项目，实现一个用于5V逻辑芯片的集成电路（IC）测试仪。除了使用其GPIO引脚探测芯片外，该项目还通过SPI从SD卡读取芯片描述和测试程序（以逻辑表的形式）。用户控制以串行命令行界面的形式添加。
- en: 'First, we look at the `Makefile` for this Nodate project, as found in the root
    of the project:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看一下该Nodate项目的`Makefile`，它位于项目的根目录中：
- en: '[PRE6]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first item we specify is the architecture we are targeting, since Nodate
    can be used to target other MCU types as well. Here, we specify AVR as the architecture.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定的第一项是我们要定位的架构，因为Nodate也可以用于定位其他MCU类型。在这里，我们将AVR指定为架构。
- en: 'Next, we use the preset for the Arduino Mega 2560 development board. Inside
    Nodate, we have a number of presets like these, which define a number of details
    about the board. For the Arduino Mega 2560, we get the following presets:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Arduino Mega 2560开发板的预设。在Nodate中，我们有许多类似这样的预设，它们定义了有关开发板的许多细节。对于Arduino
    Mega 2560，我们得到以下预设：
- en: '[PRE7]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If no board preset is defined, one has to define those variables in the project's
    Makefile and pick an existing value for each variable, each of which is defined
    as its own Makefile within the Nodate AVR subfolders. Alternatively, one can add
    one's own MCU, programmer, and (pin) variant file to Nodate, along with a new
    board preset, and use that.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义板预设，就必须在项目的Makefile中定义这些变量，并为每个变量选择一个现有值，每个变量都在Nodate AVR子文件夹的自己的Makefile中定义。或者，可以将自己的MCU、编程器和（引脚）变体文件添加到Nodate中，并添加一个新的板预设，然后使用它。
- en: 'With the makefile complete it is time to implement the main function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 完成makefile后，是时候实现主函数了：
- en: '[PRE8]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The wiring header provides access to all GPIO-related functionality. Furthermore,
    we include headers for the SPI bus, the SD card reader device, and a custom class
    that wraps the serial interface, as we will see in more detail in a moment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接线头文件提供了对所有与GPIO相关的功能的访问。此外，我们还包括了SPI总线、SD卡读卡器设备的头文件，以及一个包装串行接口的自定义类的头文件，稍后我们将会更详细地看到：
- en: '[PRE9]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Upon entering the main function, we initialize the GPIO functionality with a
    call to `init()`. The next call loads the pin configuration for the particular
    board we are targeting (the `VARIANT` variable on the top or in the board preset
    Makefile).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 进入主函数后，我们通过调用`init()`来初始化GPIO功能。接下来的调用加载了我们正在针对的特定板的引脚配置（在顶部的`VARIANT`变量或板预设的Makefile中）。
- en: 'After this, we start the first serial port with a speed of 9,600 baud, followed
    by the SPI bus, and finally the output of a welcome message, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们以9600波特率启动第一个串行端口，然后是SPI总线，最后是欢迎消息的输出，如下所示：
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An SD card is expected to be attached to the Mega board at this point, containing
    a list of available chips we can test. Here, pin 53 is the hardware SPI chip-select
    pin that is conveniently located next to the rest of the SPI pins on the board.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们期望Mega板上连接了一个SD卡，其中包含我们可以测试的可用芯片的列表。在这里，引脚53是硬件SPI片选引脚，方便地位于板上其他SPI引脚旁边。
- en: 'Assuming the board is hooked up properly and the card can be read without issues,
    we are presented with a command-line prompt on the console screen:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设板子已经正确连接并且可以无问题地读取卡片，我们会在控制台屏幕上看到一个命令行提示符：
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This loop simply waits for input to arrive on the serial input, after which
    it will attempt to execute the received command. The function we call for reading
    from the serial input is blocking, returning only if it has either received a
    newline (user pressed *Enter*), or its internal buffer size was exceeded without
    receiving a newline. In the latter case, we simply dismiss the input and try to
    read from the serial input once more. This concludes the `main()` implementation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环只是等待串行输入上的输入，之后它将尝试执行接收到的命令。我们调用用于从串行输入读取的函数是阻塞的，只有在收到换行符（用户按下*Enter*）或其内部缓冲区大小超过而没有收到换行符时才会返回。在后一种情况下，我们只是忽略输入，并尝试再次从串行输入读取。这结束了`main()`的实现。
- en: 'Let''s now look at the header of the `SerialComm` class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`SerialComm`类的头文件：
- en: '[PRE12]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We include the header for the hardware serial connection support. This gives
    us access to the underlying UART peripheral. The class itself is purely static,
    defining the maximum size of the character buffer, and the function to read a
    line from the serial input.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了硬件串行连接支持的头文件。这使我们可以访问底层的UART外设。这个类本身是纯静态的，定义了字符缓冲区的最大大小，以及从串行输入读取一行的函数。
- en: 'Next is its implementation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是它的实现：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `while` loop, we first enter a loop that runs while there are no characters
    to be read in the serial input buffer. This makes it a blocking read.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们首先进入一个循环，该循环在串行输入缓冲区中没有字符可读时运行。这使得它成为一个阻塞读取。
- en: Since we want to be able to see what we're typing, in the next section we echo
    back any character we have read. After this, we check whether we have received
    a newline character. If we did, we add a terminating null byte to the local buffer
    and read it into the String instance we were provided a reference to, after which
    we return true.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够看到我们输入的内容，所以在下一部分中，我们会回显我们已经读取的任何字符。之后，我们检查是否收到了换行符。如果是，我们会向本地缓冲区添加一个终止空字节，并将其读入我们提供引用的String实例中，之后返回true。
- en: A possible improvement one could implement here is that of a backspace feature,
    where the user could delete characters in the read buffer by using the backspace
    key. For this, one would have to add a case for the backspace control character
    (ASCII 0x8), which would delete the last character from the buffer, and optionally
    also have the remote terminal delete its last visible character.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以实现的一个可能的改进是增加一个退格功能，用户可以使用退格键删除读取缓冲区中的字符。为此，我们需要为退格控制字符（ASCII 0x8）添加一个情况，它将从缓冲区中删除最后一个字符，并且还可以让远程终端删除其最后一个可见字符。
- en: With no newline found yet, we continue to the next section. Here, we check whether
    we have received a valid character considered as ASCII 0x20, or a space. If we
    did, we continue to add the new character to the buffer and finally check whether
    we have reached the end of the read buffer. If we did not, we return false to
    indicate that the buffer is full yet no newline has been found.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在尚未找到换行符的情况下，我们继续到下一部分。在这里，我们检查是否收到了被视为ASCII 0x20的有效字符，或者空格。如果是，我们继续将新字符添加到缓冲区，最后检查是否已经到达读取缓冲区的末尾。如果没有，我们返回false以指示缓冲区已满但尚未找到换行符。
- en: 'Next are the handler functions `readIndex()` and `readChipConfig()` for the
    `index` and `chip` commands, respectively:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`index`和`chip`命令的处理函数`readIndex()`和`readChipConfig()`：
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function makes heavy use of the `SD` and associated `File` classes from
    the Arduino SD card library. Essentially, we open the chips index file on the
    SD card, ensure we got a valid file handle, then proceed to read out and print
    each line in the file. This file is a simple line-based text-file, with one chip
    name per line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数大量使用了Arduino SD卡库中的`SD`和相关的`File`类。基本上，我们在SD卡上打开芯片索引文件，确保我们得到了一个有效的文件句柄，然后继续读取并打印文件中的每一行。这个文件是一个简单的基于行的文本文件，每行一个芯片名称。
- en: At the end of the handler code, we're done reading from SD and the file handle
    can be closed with `sdFile.close()`. The same applies to the slightly more lengthy
    upcoming `readChipHandler()` implementation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序代码的末尾，我们已经从SD卡中读取完毕，文件句柄可以使用`sdFile.close()`关闭。稍后稍长一些的`readChipHandler()`实现也适用相同的方法。
- en: Usage
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: As an example, when we run the test with a simple HEF4001 IC (4000 CMOS series
    Quad 2-Input OR Gate) hooked up, we have to add a file to the SD card which contains
    the test description and control data for this IC. The `4001.ic` test file is
    shown here as it lends itself to following along the code that parses it and performs
    the corresponding tests.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，当我们使用一个简单的HEF4001 IC（4000 CMOS系列四输入或门）进行测试时，我们必须向SD卡添加一个文件，其中包含了这个IC的测试描述和控制数据。`4001.ic`测试文件如下所示，因为它适合跟踪解析它并执行相应测试的代码。
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first three lines are printed verbatim as we saw earlier, with the remaining
    lines specifying individual test scenarios. These tests are lines and use the
    following format:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前三行按原样打印，剩下的行指定了各个测试场景。这些测试是行，并使用以下格式：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We write this file as `4001.ic` along with an updated `index.idx` file (containing
    the ''4001'' entry on a new line) to the SD card. to support more ICs we would
    simply repeat this pattern with their respective test sequences and list them
    in the index file.Finally there is the handler for the chip configuration, which
    also starts the testing procedure:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个文件命名为`4001.ic`，并将更新后的`index.idx`文件（包含新行上的'4001'条目）写入SD卡。为了支持更多的IC，我们只需重复这个模式，使用它们各自的测试序列，并在索引文件中列出它们。最后是芯片配置的处理程序，它也启动了测试过程：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We start by asking the user for the name of the IC, as printed out earlier
    by the `index` command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先询问用户IC的名称，如之前由`index`命令打印出来的：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We attempt to open the file with the IC details, continuing with reading out
    the file contents, starting with the name and description of the IC that we are
    testing:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试打开IC详细信息的文件，继续读取文件内容，从正在测试的IC的名称和描述开始：
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After displaying the name and description of this IC, we read out the line
    that contains the instructions on how to connect the IC to the headers of our
    Mega board:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了这个IC的名称和描述后，我们读取包含如何将IC连接到Mega板标头的指令的行：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we ask the user for confirmation on whether to start testing the IC. Any
    command beyond `start` will abort the test and return to the central command loop.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们询问用户是否确认开始测试IC。除了`start`命令之外的任何命令都将中止测试并返回到中央命令循环。
- en: 'Upon receiving `start` as a command, the testing begins:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 收到`start`命令后，测试开始：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the first step, we read out the next line in the IC file, which should contain
    the first test. The first section contains the input pin settings, with the section
    after the equal sign containing the IC's output pin and its expected value for
    this test.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们读取IC文件中的下一行，该行应包含第一个测试。第一部分包含输入引脚设置，等号后的部分包含IC的输出引脚及其在此测试中的预期值。
- en: 'We print out the board header number that the result pin is connected to and
    the expected value. Next, we set the result pin to be an input pin so that we
    can read it out after the test has finished:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出了连接到结果引脚的板头编号和预期值。接下来，我们将结果引脚设置为输入引脚，以便在测试完成后读取它：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For the actual test, we use the first String we read out from the file for this
    test, parsing it to get the values for the input pins. For each pin, we first
    get its number, then get the value (`0` or `1`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际测试，我们使用从文件中读取的第一个字符串进行测试，解析它以获取输入引脚的值。对于每个引脚，我们首先获取它的编号，然后获取值（`0`或`1`）。
- en: 'We echo these pin numbers and values to the serial output, before setting the
    pin mode for these pins to output mode and then writing the test value to each
    of them, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些引脚编号和值回显到串行输出之前，我们将这些引脚的模式设置为输出模式，然后将测试值写入到每个引脚，如下所示：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After leaving the inner loop, all of the input values will have been set. We
    just have to wait briefly to ensure that the IC has had time to settle on its
    new output values before we attempt to read out the result value on its output
    pin.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 离开内部循环后，所有输入值都将被设置。我们只需稍等片刻，确保IC有足够的时间来稳定其新的输出值，然后我们尝试读取其输出引脚上的结果值。
- en: IC validation is a simple read on the result pin, after which we compare the
    value we received with the expected value. The result of this comparison is then
    printed to the serial output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: IC验证是对结果引脚的简单读取，然后将接收到的值与预期值进行比较。然后将此比较的结果打印到串行输出。
- en: With the test complete, we close the IC file and return to the central command
    loop to await the next instructions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，我们关闭IC文件并返回到中央命令循环，等待下一步指令。
- en: 'After flashing the program to the Mega board and connecting with it on its
    serial port, we get the following result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序烧录到Mega板上并通过串口连接后，我们得到了以下结果：
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After starting up, we get the message that the SD card was found and successfully
    initialized. We can now read from the SD card. We also see the available commands.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，我们收到了SD卡被找到并成功初始化的消息。我们现在可以从SD卡中读取。我们还看到了可用的命令。
- en: 'Next, we specify the `index` command to get an overview of the available ICs
    we can test:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定`index`命令以获取我们可以测试的可用IC的概述：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With just one IC available to test, we specify the `chip` command to enter the
    IC entry menu, after which we enter the IC's specifier.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个IC可用于测试，我们指定`chip`命令进入IC条目菜单，然后输入IC的规范。
- en: This loads the file we put on the SD card and prints the first three lines.
    It then waits to give us time to hook up the chip, following the header numbers
    on the Mega board and the pin designations for the IC as provided by its datasheet.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载我们放在SD卡上的文件并打印前三行。然后等待我们连接芯片，按照Mega板上的标头编号和IC的引脚指示来进行。
- en: 'After checking that we didn''t get any of our wires crossed, we type `start`
    and confirm. This starts the test:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 确认我们没有搞错任何接线后，我们输入`start`并确认。这启动了测试：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For each of the four identical OR gates in the chip, we run through the same
    truth table, testing each input combination. This specific IC passed with flying
    colors and can be safely used in a project.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于芯片中的四个相同的或门，我们通过相同的真值表运行，测试每个输入组合。这个特定的IC通过了测试，并可以安全地用于项目中。
- en: This kind of testing device would be useful for testing any kind of 5V-level
    IC, including 74 and 4000 logic chips. It would also be possible to adapt the
    design to use the PWM, ADC, and other pins to test ICs that aren't strictly digital
    in their inputs and outputs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试设备对于测试任何类型的5V电平IC都是有用的，包括74和4000逻辑芯片。还可以适应设计，使用PWM、ADC和其他引脚来测试输入输出不严格为数字的IC。
- en: ESP8266 development with Sming
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sming进行ESP8266开发
- en: For ESP8266-based development, no official development tools exist from its
    creator (Espressif) beyond a bare-metal and RTOS-based SDK. Open source projects
    including Arduino then provide a more developer-friendly framework to develop
    applications with. The C++ alternative to Arduino on ESP8266 is Sming ([https://github.com/SmingHub/Sming](https://github.com/SmingHub/Sming)),
    which is an Arduino-compatible framework, similar to Nodate for AVR, which we
    looked at in the previous section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于ESP8266的开发，其创建者（Espressif）没有提供官方的开发工具，除了一个裸机和基于RTOS的SDK。包括Arduino在内的开源项目提供了一个更加开发者友好的框架来开发应用程序。在ESP8266上，C++的替代品是Sming（[https://github.com/SmingHub/Sming](https://github.com/SmingHub/Sming)），它是一个与Arduino兼容的框架，类似于我们在前一节中看到的AVR的Nodate。
- en: In the next chapter ([Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*) we will take an in-depth look at
    developing with this framework on the ESP8266.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例-带Wi-Fi的土壤湿度监测器*）中，我们将深入研究在ESP8266上使用这个框架进行开发。
- en: ARM MCU development
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM MCU开发
- en: Developing for ARM MCU platforms isn't significantly different from developing
    for AVR MCUs, except that C++ is far better supported, and there exists a wide
    range of toolchains to choose from, as we saw at the beginning of this chapter
    with just the list of popular IDEs. The list of available RTOSes for Cortex-M
    is much larger than for AVR or ESP8266 as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与为AVR MCU开发并没有太大的不同，除了C++得到了更好的支持，还有各种工具链可供选择，就像我们在本章开头看到的那样，有许多流行的IDE。对于Cortex-M的RTOS，可用的列表比AVR或ESP8266要大得多。
- en: Using a free and open source compiler including GCC and LLVM to target a wide
    range of ARM MCU architectures (Cortex-M-based and similar) is where developing
    for ARM MCUs offers a lot of freedom, along with easy access to the full C++ STL
    (though one might want to hold off on exceptions).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包括GCC和LLVM在内的免费开源编译器来针对广泛的ARM MCU架构（基于Cortex-M和类似的架构）进行开发，这就是为ARM MCU开发提供了很大自由度的地方，同时可以轻松访问完整的C++
    STL（尽管可能需要暂时放弃异常）。
- en: 'When doing bare-metal development for Cortex-M MCUs, one may have to add this
    linker flag to provide basic stubs for some functionality that is normally provided
    by the OS:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Cortex-M MCU进行裸机开发时，可能需要添加这个链接器标志来提供一些通常由操作系统提供的基本存根功能：
- en: '[PRE27]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One thing that makes ARM MCUs less attractive is that there are far fewer *standard*
    boards and MCUs, such as with what one sees with AVR in the form of the Arduino
    boards. Although the Arduino foundation at one point made the Arduino Due board
    based around a SAM3X8E Cortex-M3 MCU, this board uses the same form factor and
    roughly same pin layout (just being 3.3V I/O-based instead of 5V) as the ATmega2560-based
    Arduino Mega board.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使得ARM MCU不那么吸引人的一点是，标准的板和MCU要少得多，就像AVR的Arduino板一样。尽管Arduino基金会曾经推出了基于SAM3X8E
    Cortex-M3 MCU的Arduino Due板，但这个板使用了与基于ATmega2560的Arduino Mega板相同的形式因子和大致相同的引脚布局（只是基于3.3V
    I/O而不是5V）。
- en: Because of this design choice a lot of the functionality of the MCU has not
    been broken out and is inaccessible unless one is very handy with a soldering
    iron and thin wires. This functionality includes the Ethernet connection, tens
    of GPIO (digital) pins, and so on. This same lack of breaking out all pins also
    happens with the Arduino Mega (ATmega2560) board, but on this Cortex-M MCU it
    becomes even more noticeable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种设计选择，MCU的许多功能没有被拆分出来，除非一个人非常擅长用焊接铁和细线，否则是无法访问的。这些功能包括以太网连接、数十个GPIO（数字）引脚等等。同样，Arduino
    Mega（ATmega2560）板也存在同样的问题，但在这个Cortex-M MCU上更加明显。
- en: The result of this is that as a development and prototyping board, there aren't
    any obvious generic picks. One might be tempted to just use the relatively cheap
    and plentiful prototyping boards like those provided by STMicroelectronics for
    their range of Cortex-M-based MCUs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是作为开发和原型板，没有明显的通用选择。人们可能会倾向于只使用相对便宜且丰富的原型板，比如STMicroelectronics为其一系列基于Cortex-M的MCU提供的原型板。
- en: RTOS usage
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS的使用
- en: With the limited resources available on the average MCU, and the generally fairly
    straightforward process loop in the applications that run on them, it is hard
    to make a case for using an RTOS on these MCUs. It's not until one has to do complicated
    resource and task management that it becomes attractive to use an RTOS in order
    to save development time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在平均MCU上可用的资源有限，而在运行在它们上的应用程序中，通常都是相当简单的处理循环，很难说服人在这些MCU上使用RTOS。直到一个人不得不进行复杂的资源和任务管理时，才会有吸引人使用RTOS以节省开发时间的情况。
- en: The benefit of using an RTOS thus lies mostly in preventing one from having
    to reinvent the wheel. This is however something that has to be decided on a case-by-case
    basis. For most projects, having to integrate an RTOS into the development toolchain
    is more likely than an unrealistic idea that would add more to the workload than
    it would lighten it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此使用RTOS的好处主要在于避免重复造轮子。然而，这是一个需要根据具体情况决定的事情。对于大多数项目来说，需要将RTOS集成到开发工具链中的可能性更大，而不是一个不切实际的想法，它会增加工作量而不会减轻工作量。
- en: For projects where one is, for example, trying to balance CPU time and system
    resources between different communication and storage interfaces, as well as a
    user interface, the use of an RTOS might make a lot of sense, however.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于一些项目，例如试图在不同的通信和存储接口以及用户界面之间平衡CPU时间和系统资源的项目，使用RTOS可能是有意义的。
- en: As we saw in this chapter, a lot of embedded development uses a simple loop
    (super-loop) along with a number of interrupts to handle real-time tasks. When
    sharing data between an interrupt function and the super-loop, it is the responsibility
    of the developer to ensure that it is done safely.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，许多嵌入式开发使用简单循环（超级循环）以及许多中断来处理实时任务。在中断函数和超级循环之间共享数据时，开发人员有责任确保安全地进行。
- en: Here, an RTOS would offer a scheduler and even the ability to run tasks (processes)
    that are isolated from each other (especially on MCUs that have a **Memory Management
    Unit** (**MMU**)). On a multi-core MCU, an RTOS easily allows one to make effective
    use of all cores without having to do one's own scheduling.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，RTOS将提供调度程序，甚至可以运行相互隔离的任务（进程）（特别是在具有内存管理单元（MMU）的MCU上）。在多核MCU上，RTOS可以轻松地允许用户有效地利用所有核心，而无需自行进行调度。
- en: As with all things, the use of an RTOS isn't just a collection of advantages.
    Even ignoring the increase in ROM and RAM space requirements that will likely
    result from adding an RTOS to one's project, it will also fundamentally change
    some system interactions and may (paradoxically) result in interrupt latency increasing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有事物一样，使用RTOS并不仅仅是一系列优势的集合。即使忽略了将RTOS添加到项目中可能导致的ROM和RAM空间需求的增加，它也将从根本上改变一些系统交互，并可能导致中断延迟的增加。
- en: This is why, although the name has *real-time* in it, it is very hard to get
    more real-time than to use a simple execution loop and a handful of interrupts.
    The benefit of an RTOS, thus, is absolutely something about which no blanket statements
    can be made, especially when a support library or framework for bare-metal programming
    (such as the Arduino-compatible ones addressed in this chapter) is already available
    to make prototyping and developing for production as simple as tying a number
    of existing libraries together.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，尽管名称中有“实时”，但很难比使用简单的执行循环和一些中断更实时。因此，RTOS的好处绝对不是可以做出一概而论的事情，特别是当支持裸机编程的库或框架（例如本章中提到的与Arduino兼容的库）已经可用于将原型制作和生产开发变得简单，就像将一些现有库绑在一起一样。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at how to select the right MCU for a new project,
    as well as how to add peripherals and deal with Ethernet and serial interface
    requirements in a project. We considered how memory is laid out in a variety of
    MCUs and how to deal with the stack and heap. Finally, we looked at an example
    AVR project, how to develop for other MCU architectures, and whether to use an
    RTOS.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何为新项目选择合适的MCU，以及如何添加外围设备并处理项目中的以太网和串行接口要求。我们考虑了各种MCU中内存的布局以及如何处理堆栈和堆。最后，我们看了一个AVR项目的示例，如何为其他MCU架构开发，并是否使用RTOS。
- en: At this point, the reader is expected to be able to argue why they would pick
    one MCU over another, based on a set of project requirements. They should be capable
    of implementing simple projects using the UART and other peripherals, and understand
    proper memory management as well as the use of interrupts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，读者应该能够根据一组项目要求来论证为什么选择一个MCU而不是另一个。他们应该能够使用UART和其他外围设备来实现简单的项目，并了解适当的内存管理以及中断的使用。
- en: In the next chapter, we will take a good look at how to develop for the ESP8266,
    in the form of an embedded project that will keep track of soil moisture levels
    and control a watering pump when needed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究如何为ESP8266开发嵌入式项目，该项目将跟踪土壤湿度水平并在需要时控制灌溉泵。
