- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Packaging the Project for Sharing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为共享打包项目
- en: In this chapter, we’re going to cover the last major topic of *Minimal CMake*,
    which is packaging. This is the process by which we turn the software we’ve built
    into something that can be shared. Of course, it’s possible to share your software
    without a packaging step, but doing so tends to be quite a manual process. It
    can also be error-prone and not in keeping with the expected platform conventions
    – for example, a Windows GUI installer, macOS disk image (`.dmg`), or Linux (Ubuntu)
    Debian package (`.deb`).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 *Minimal CMake* 的最后一个主要主题——打包。这是将我们构建的软件转化为可以共享的格式的过程。当然，您也可以在没有打包步骤的情况下共享软件，但这样做通常是一个手动过程，容易出错，也不符合平台的预期规范——例如，Windows
    的图形安装程序、macOS 的磁盘映像（`.dmg`）或 Linux（Ubuntu）Debian 包（`.deb`）。
- en: We’re going to see how to use CPack to package our application for macOS, Windows,
    and Linux. We’ll cover the changes we need to make to our `CMakeLists.txt` file
    and the commands needed to create the package. The good news is we’ve already
    done most of the hard work to reach this point, and many of the changes tend to
    be needed to handle platform-specific differences.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用 CPack 来为 macOS、Windows 和 Linux 打包我们的应用程序。我们将介绍需要对 `CMakeLists.txt`
    文件进行的更改以及创建软件包所需的命令。好消息是，我们已经完成了大部分的繁重工作，许多更改通常是为了处理平台特定的差异。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding CPack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CPack
- en: Loading resources relative to the executable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于可执行文件加载资源
- en: Integrating CPack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 CPack
- en: Building a macOS bundle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 macOS 包
- en: Adding CPack presets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 CPack 预设
- en: Other uses for CPack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPack 的其他用途
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, ensure that you meet the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本书的进度，请确保你满足 [*第1章*](B21152_01.xhtml#_idTextAnchor019)《入门》中概述的要求。这些要求包括：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台安装有最新 **操作** **系统**（**OS**）的 Windows、Mac 或 Linux 机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 C/C++ 编译器（如果你还没有，建议使用系统默认的编译器）
- en: 'The code examples in this chapter can be found at this link: [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)。
- en: Understanding CPack
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CPack
- en: '`cpack` from the Terminal. The best way to think of CPack is a tool to create
    a wrapper around CMake install commands. In [*Chapter 8*](B21152_08.xhtml#_idTextAnchor183),
    *Using Super Builds to Simplify Onboarding*, we followed the process of creating
    install commands for our application, meaning we’ve already done the work necessary
    to make packaging our application possible. What CPack does is handle platform-specific
    conventions when it comes to installing software, and it does a respectable job
    of abstracting things so that you don’t have to worry about them.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过终端使用 `cpack`。理解 CPack 最好的方式是把它看作是 CMake 安装命令的封装工具。在 [*第8章*](B21152_08.xhtml#_idTextAnchor183)，《使用超级构建简化入门》中，我们已经完成了为我们的应用程序创建安装命令的过程，也就是说，我们已经做了打包应用程序所需的工作。CPack
    的作用是处理与安装软件相关的特定平台约定，它能很好地抽象化这些工作，使你无需过多担心。
- en: The advantage of packaging things at all is to save our users from having to
    build our software themselves. The topics we’ve previously covered relating to
    running an application from the install tree (the `app/install/bin` folder), copying
    DLLs to the right folder on Windows, and library search paths (the `RPATH` handling
    we performed on Linux/macOS) have prepared us for this, making the packaging step
    much simpler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的优势在于，能够避免让用户自己构建我们的软件。我们之前讨论过的与从安装目录（`app/install/bin` 文件夹）运行应用程序、将 DLL 复制到
    Windows 上正确的文件夹以及库搜索路径（我们在 Linux/macOS 上执行的 `RPATH` 处理）相关的主题，已经为此做好了准备，使打包步骤变得更加简单。
- en: CPack provides multiple package generators, specified similarly to the build
    system generators we pass to CMake using the `-G` command-line option. Some of
    these are platform-specific (for example **Bundle** and **DragNDrop** on macOS),
    and others require additional software to be installed (e.g., **Nullsoft Scriptable
    Install System** (**NSIS**) on Windows); we’ll walk through at least one generator
    for each platform and show you which CPack commands are needed in each case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CPack 提供了多个包生成器，这些生成器的指定方式类似于我们通过 `-G` 命令行选项传递给 CMake 的构建系统生成器。其中一些是特定于平台的（例如，macOS
    上的 **Bundle** 和 **DragNDrop**），其他一些则需要额外的软件安装（例如，Windows 上的 **Nullsoft Scriptable
    Install System**（**NSIS**））；我们将至少介绍每个平台上的一个生成器，并展示每种情况下所需的 CPack 命令。
- en: Loading resources relative to the executable
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对于可执行文件加载资源
- en: Before we look at adding any CPack commands to our `CMakeLists.txt` file, there
    is one final topic we need to cover that we’ve glossed over so far, and that’s
    how to ensure that the resource files we load can be found relative to the executable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向 `CMakeLists.txt` 文件中添加任何 CPack 命令之前，还有一个我们之前忽略的最终话题需要讨论，那就是如何确保我们加载的资源文件可以相对于可执行文件被找到。
- en: Throughout *Minimal CMake*, we’ve almost exclusively been launching our application
    from the terminal, but we’ve had to be careful exactly where we launch the application
    from. Running the application from the `app` folder works (e.g., `./build/multi-ninja/Release/minimal-cmake_game-of-life_window`),
    and changing the directory to the `install/bin` folder and launching the application
    from there also works (this is because we ensure that we copy the shaders to the
    correct relative location in the `install` folder). The problem is that if we
    try and launch the application from another folder (e.g., our home directory),
    the shaders will not load.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Minimal CMake* 中，我们几乎一直从终端启动应用程序，但我们必须非常小心从哪里启动应用程序。从 `app` 文件夹中启动应用程序是可行的（例如，`./build/multi-ninja/Release/minimal-cmake_game-of-life_window`），将目录切换到
    `install/bin` 文件夹并从那里启动应用程序也可以正常工作（这是因为我们确保将着色器复制到 `install` 文件夹中的正确相对位置）。问题是，如果我们尝试从其他文件夹（例如，主目录）启动应用程序，着色器将无法加载。
- en: 'You will be presented with this error message:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下错误信息：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Chances are you have built the shaders (especially after we added the custom
    command to do this for us automatically in [*Chapter 8*](B21152_08.xhtml#_idTextAnchor183),
    *Using Super Builds to Simplify Onboarding*); the problem is that when running
    from our home directory, our application looks for the shaders in `~/shaders/build`,
    not `path/to/app/install/bin/shaders/build`. The situation is a bit more complicated
    on macOS and Linux than on Windows. When launching an application on Windows from
    the GUI, the working directory will default to the folder containing the executable,
    but on macOS and Linux, it will be the user’s home directory (`~/` or `$HOME`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经构建了着色器（特别是在我们在 [*第8章*](B21152_08.xhtml#_idTextAnchor183) 中添加了自定义命令来自动为我们完成此操作之后，*使用超级构建简化入门*）；问题是，当从主目录运行时，我们的应用程序会在
    `~/shaders/build` 中寻找着色器，而不是在 `path/to/app/install/bin/shaders/build` 中。与 Windows
    相比，macOS 和 Linux 上的情况要更复杂一些。在 Windows 上通过图形界面启动应用程序时，工作目录默认会设置为包含可执行文件的文件夹，但在
    macOS 和 Linux 上，工作目录会是用户的主目录（`~/` 或 `$HOME`）。
- en: To fix this, we need to update our application to load resource files relative
    to the executable, not the current working directory. To achieve this, we need
    to query what the current directory of our application is at runtime. There are
    several ways to do this, each different depending on the platform you’re using
    (there’s `_NSGetExecutablePath` on macOS, `readlink` on Linux, and `GetModuleFileName`
    on Windows, as well as other alternatives). Fortunately for us, as we’re using
    SDL 2, we can use a utility function called `SDL_GetBasePath` (see [https://wiki.libsdl.org/SDL2/SDL_GetBasePath](https://wiki.libsdl.org/SDL2/SDL_GetBasePath)
    for more information) to handle all these cross-platform cases for us (it also
    handles differences with macOS-specific bundles too).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要更新我们的应用程序，使其相对于可执行文件加载资源文件，而不是当前工作目录。为了实现这一点，我们需要查询应用程序在运行时的当前目录。根据使用的平台不同，这有多种方法（例如，macOS
    上的 `_NSGetExecutablePath`，Linux 上的 `readlink`，Windows 上的 `GetModuleFileName`，以及其他一些替代方法）。幸运的是，既然我们使用的是
    SDL 2，我们可以使用一个名为 `SDL_GetBasePath` 的工具函数（更多信息请参见 [https://wiki.libsdl.org/SDL2/SDL_GetBasePath](https://wiki.libsdl.org/SDL2/SDL_GetBasePath)），它可以为我们处理所有这些跨平台的情况（它还处理了
    macOS 特定的包的差异）。
- en: We’re going to make a couple of minor changes to our `CMakeLists.txt` file and
    `main.cpp` file to support this. Starting with our `CMakeLists.txt` file in `ch10/part-1/app`,
    we’re going to copy the shaders from their original location to our `build` folder
    to ensure that launching the executable from there works as expected. To make
    things a bit clearer, we’ll drop the `shader/build` folder and just install the
    compiled `bin` files to a folder called `shader`, next to our application (we’ll
    update our `main.cpp` file accordingly shortly).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`CMakeLists.txt`文件和`main.cpp`文件做几个小改动，以支持这一点。从`ch10/part-1/app`中的`CMakeLists.txt`文件开始，我们将把着色器从其原始位置复制到我们的`build`文件夹，以确保从那里启动可执行文件能够按预期工作。为了使事情更加清晰，我们将删除`shader/build`文件夹，并将编译后的`bin`文件安装到一个名为`shader`的新文件夹中，位于应用程序旁边（稍后我们会相应更新`main.cpp`文件）。
- en: 'Afterwards, the folder structure will look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，文件夹结构将如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To achieve this, we need to update the `add_custom_command` call we’re using
    to copy our shared library files (`.dylib`/`.so`/`.dll`) to the build folder,
    by including a step to copy the shader files. This looks as follows (with the
    existing file `copy` commands omitted):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要更新我们正在使用的`add_custom_command`调用，以便将我们的共享库文件（`.dylib`/`.so`/`.dll`）复制到构建文件夹，并包括一个步骤来复制着色器文件。其形式如下（省略现有的`copy`命令）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use the `copy_directory` command to copy the contents of the `shader/build`
    folder to the location of our target, inside a subfolder called `shader`. An edge
    case to be aware of is that the custom command to copy the shaders doesn’t explicitly
    depend on the previous custom command to compile the shaders. This could mean
    that if compiling the shaders fails, this command will still run and have no effect
    (or fail). As discussed in [*Chapter 8*](B21152_08.xhtml#_idTextAnchor183), *Using
    Super Builds to Simplify Onboarding*, we could instead use the `OUTPUT` variant
    of `add_custom_command` for both, using the `DEPENDS` argument to ensure that
    the second `add_custom_command` runs only after the first succeeds. As the `TARGET`
    version is simpler, we’ll continue using it for the remainder of the examples,
    but there are cases where the `OUTPUT` version can be very useful (see [https://cmake.org/cmake/help/latest/command/add_custom_command.html](https://cmake.org/cmake/help/latest/command/add_custom_command.html)
    for more details).To keep things consistent with the install layout, we also need
    to make a slight change to the install command that we created earlier to copy
    our shaders to the install tree. Instead of copying the whole `shader/build` folder,
    we just want to copy the contents to a new folder called `shader`. We can achieve
    this with the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`copy_directory`命令，将`shader/build`文件夹的内容复制到目标位置的子文件夹`shader`中。需要注意的是，复制着色器的自定义命令并没有明确依赖于之前的编译着色器的自定义命令。这可能意味着，如果编译着色器失败，这个命令仍然会执行，但没有效果（或失败）。如[*第8章*](B21152_08.xhtml#_idTextAnchor183)中讨论的，*使用超级构建简化入门*，我们可以使用`add_custom_command`的`OUTPUT`变体，并使用`DEPENDS`参数确保第二个`add_custom_command`仅在第一个成功后运行。由于`TARGET`版本更简单，我们将继续使用它来演示后续的例子，但在某些情况下，`OUTPUT`版本会非常有用（有关更多细节，请参见[https://cmake.org/cmake/help/latest/command/add_custom_command.html](https://cmake.org/cmake/help/latest/command/add_custom_command.html)）。为了保持与安装布局一致，我们还需要稍微修改我们之前创建的安装命令，将我们的着色器复制到安装树中。我们不再复制整个`shader/build`文件夹，而是将内容复制到一个新的名为`shader`的文件夹中。我们可以使用以下命令实现：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: char* base_path = SDL_GetBasePath();
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: char* base_path = SDL_GetBasePath();
- en: std::string vs_shader_full_path;
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: std::string vs_shader_full_path;
- en: vs_shader_full_path.append(base_path);
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: vs_shader_full_path.append(base_path);
- en: vs_shader_full_path.append("shader/vs_vertcol.bin");
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: vs_shader_full_path.append("shader/vs_vertcol.bin");
- en: '...'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: std::vector<char> vs_shader =
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: std::vector<char> vs_shader =
- en: read_file(vs_shader_full_path.c_str());
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: read_file(vs_shader_full_path.c_str());
- en: '...'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: SDL_free(base_path);
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SDL_free(base_path);
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: file INSTALL cannot find
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 INSTALL 无法找到
- en: '"path/to/build/multi-ninja-super/Release/minimal-cmake_game-of-life_window":'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '"path/to/build/multi-ninja-super/Release/minimal-cmake_game-of-life_window":'
- en: No such file or directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这样的文件或目录。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: cpack --config build/multi-ninja-super/--config to provide the path to the CPackConfig.cmake
    file, and then -B to create a new folder called package to store the packaged
    files. Invoking CPack will produce different results per platform in a comparable
    way to CMake, as each platform will have its own default generator (in this case,
    a package generator instead of a build system generator). We can use -G just as
    with CMake to specify the kind of generator to use.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja-super/--config 提供 CPackConfig.cmake 文件的路径，然后使用
    -B 创建一个名为 package 的新文件夹来存储打包后的文件。调用 CPack 将根据平台产生不同的结果，类似于 CMake，因为每个平台都会有自己的默认生成器（在这种情况下，是包生成器而不是构建系统生成器）。我们可以像在
    CMake 中一样使用 -G 来指定使用哪种生成器。
- en: The real complexity with CPack (once the core `install` logic is out of the
    way) comes from configuring the specific generators you care about (running `cpack
    --help` will list all available generators for the platform you’re on). To limit
    the scope of all the various kinds of generators, we’re going to pick one per
    platform that best fits with the expected way that applications are installed
    on that platform. A full working example is presented in `ch10/part-2/app/CMakeLists.txt`,
    along with a new `packaging` folder with package-specific assets and files. We’ll
    first cover the common `CPACK_` variables to set, and then we’ll walk through
    each platform in turn.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CPack 的真正复杂性（在核心 `install` 逻辑完成后）来自于配置你关心的具体生成器（运行 `cpack --help` 将列出你所在平台上所有可用的生成器）。为了限定各种生成器的范围，我们将为每个平台选择一个最适合该平台上应用程序安装方式的生成器。一个完整的工作示例已在
    `ch10/part-2/app/CMakeLists.txt` 中给出，并且包含一个新的 `packaging` 文件夹，里面有特定于包的资产和文件。我们将首先介绍常见的
    `CPACK_` 变量设置，然后依次讲解每个平台。
- en: CPack common properties
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CPack 常见属性
- en: In addition to the `include(CPack)` command, there are many CPack variables
    that can be set to configure various settings for a packaged project. There are
    variables common to all CPack generators (a complete list can be found at [https://cmake.org/cmake/help/latest/module/CPack.html#variables-common-to-all-cpack-generators](https://cmake.org/cmake/help/latest/module/CPack.html#variables-common-to-all-cpack-generators))
    and variables specific to a generator – for example, the CPack Bundle generator
    on macOS begins with `CPACK_BUNDLE_` (a complete list of its variables can be
    found at [https://cmake.org/cmake/help/latest/cpack_gen/bundle.html](https://cmake.org/cmake/help/latest/cpack_gen/bundle.html)).
    It’s not necessarily the case that common CPack variables work with every generator,
    but they will work with more than one (for example, `CPACK_PACKAGE_EXECUTABLES`
    is used by the NSIS, WiX, and Inno Setup generators).
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 `include(CPack)` 命令外，还有许多 CPack 变量可以设置，用来配置打包项目的各种设置。有些变量是所有 CPack 生成器共享的（完整的列表可以在
    [https://cmake.org/cmake/help/latest/module/CPack.html#variables-common-to-all-cpack-generators](https://cmake.org/cmake/help/latest/module/CPack.html#variables-common-to-all-cpack-generators)
    查阅），还有些变量是特定于某个生成器的——例如，macOS 上的 CPack Bundle 生成器以 `CPACK_BUNDLE_` 开头（它的完整变量列表可以在
    [https://cmake.org/cmake/help/latest/cpack_gen/bundle.html](https://cmake.org/cmake/help/latest/cpack_gen/bundle.html)
    查阅）。并非所有通用的 CPack 变量都适用于每个生成器，但它们会适用于多个生成器（例如，`CPACK_PACKAGE_EXECUTABLES` 就被 NSIS、WiX
    和 Inno Setup 生成器使用）。
- en: 'We’ll start with the minimum needed common variables (there are many more that
    are omitted; feel free to experiment with these and add them to your own projects
    in the future). The first we will specify is `CPACK_PACKAGE_NAME`:'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将从最基本的常见变量开始（还有许多其他变量被省略；你可以随意尝试这些变量并将它们添加到你未来的项目中）。我们将首先指定的是 `CPACK_PACKAGE_NAME`：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is important and is used by pretty much all CPack generators. If this is
    omitted, the target name will be used for the package name. In our case, we set
    it to `"minimal-cmake_game-of-life"` (it’s important there are no spaces in this
    name, as installation may fail on certain platforms/generators if there are).
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是非常重要的，并且几乎所有 CPack 生成器都会使用。如果省略此项，目标名称将被用作包名称。在我们的案例中，我们将其设置为 `"minimal-cmake_game-of-life"`（这里要特别注意，名称中不能有空格，因为如果有空格，某些平台/生成器在安装时可能会失败）。
- en: 'The next common variable we will use (which is only needed for our Windows
    NSIS installer) is `CPACK_PACKAGE_EXECUTABLES`:'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用的下一个常见变量（仅用于 Windows NSIS 安装程序）是 `CPACK_PACKAGE_EXECUTABLES`：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: cpack --config build/multi-ninja/CPackConfig.cmake -G package. Running the installer
    will walk us through a set of steps and then copy the install files to C:\Program
    Files\minimal-cmake_game-of-life 0.1.1. Start menu shortcuts are also added to
    C:\ProgramData\Microsoft\Windows\Start Menu\Programs\minimal-cmake_game-of-life
    0.1.1.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja/CPackConfig.cmake -G package。运行安装程序将引导我们完成一系列步骤，然后将安装文件复制到C:\Program
    Files\minimal-cmake_game-of-life 0.1.1。开始菜单快捷方式也会添加到C:\ProgramData\Microsoft\Windows\Start
    Menu\Programs\minimal-cmake_game-of-life 0.1.1。
- en: 'The two initial `CPACK_NSIS_` variables we set are to give the installer’s
    welcome screen a friendly title and ensure that things look crisp on high-DPI
    displays:'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们设置的两个初始`CPACK_NSIS_`变量是为了给安装程序的欢迎屏幕一个友好的标题，并确保在高DPI显示器上显示清晰：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One important thing that we’re missing to make our application look professional
    is an icon (unfortunately, this is what we’ll spend most of our time on in the
    following sections, as icon handling is different per platform).
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个重要的东西我们还缺少，以使我们的应用程序看起来更专业，那就是图标（不幸的是，接下来的章节我们大部分时间都要花在这个上，因为每个平台的图标处理方式不同）。
- en: We first need to create an icon in the format expected by Windows. A great tool
    to perform this is `.ico` file in `ch10/part-2/app/packaging/windows`, called
    `mc_icon.ico`, but it’s helpful to know how to do this for your own icons in the
    future.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先需要创建一个符合Windows预期格式的图标。一个非常棒的工具是`.ico`文件，位于`ch10/part-2/app/packaging/windows`，名为`mc_icon.ico`，但了解如何为自己的图标执行此操作未来会很有帮助。
- en: 'Once this icon file is available, we need to add an NSIS CPack-specific variable
    to refer to it. This CPack option is `CPACK_NSIS_MUI_ICON`:'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦图标文件可用，我们需要添加一个特定于NSIS CPack的变量来引用它。这个CPack选项是`CPACK_NSIS_MUI_ICON`：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will associate the icon we created with the NSIS installer, so when running
    through the installer, we’ll see the icon in the top-left corner of the window
    and the Windows taskbar for the installer. However, this won’t create an icon
    for the application after it’s installed. For that, we need to venture outside
    of CPack briefly and add a small update to our `CMakeLists.txt` file. We must
    also add one more file needed by Windows.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把我们创建的图标与NSIS安装程序关联起来，因此在通过安装程序时，我们将在窗口的左上角和Windows任务栏看到该图标。但是，这不会为安装后的应用程序创建图标。为此，我们需要暂时跳出CPack，并在我们的`CMakeLists.txt`文件中做一个小更新。我们还必须添加一个Windows所需的额外文件。
- en: The file we need to add is called a resource-definition script, ending with
    the `.rc` extension (to learn more about resource files on Windows, go to [https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files](https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files)).
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要添加的文件叫做资源定义脚本，以`.rc`扩展名结尾（要了解更多关于Windows资源文件的信息，请访问[https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files](https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files)）。
- en: 'The file has the following contents:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该文件包含以下内容：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This links the resource-definition script to our generated icon file. The `icon.rc`
    file then needs to be compiled into our executable, which can be achieved by adding
    `icon.rc` to `target_sources`:'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将链接资源定义脚本与我们生成的图标文件。然后，需要将`icon.rc`文件编译到我们的可执行文件中，这可以通过将`icon.rc`添加到`target_sources`来实现。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this change, we’ll see the icon used for our application’s start menu and
    desktop shortcut. There are more CPack NSIS options to further customize the installer
    experience, which we’ll skip for now; for a full list, go to [https://cmake.org/cmake/help/latest/cpack_gen/nsis.html](https://cmake.org/cmake/help/latest/cpack_gen/nsis.html).
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这个更改，我们将看到应用程序的开始菜单和桌面快捷方式使用的图标。有更多的CPack NSIS选项可以进一步自定义安装程序体验，我们暂时跳过这些；完整列表请访问[https://cmake.org/cmake/help/latest/cpack_gen/nsis.html](https://cmake.org/cmake/help/latest/cpack_gen/nsis.html)。
- en: One other small detail to note, which again is slightly outside the scope of
    CPack but falls into the category of getting our application ready for shipping,
    is about hiding the console window that appears when launching our application.
    This is something that might not have been as obvious so far, as we’ve been launching
    the application from the terminal for the most part. One thing you might have
    noticed is that when running from the Windows GUI, a console window will appear
    in the background with the debug console output we’ve added. This can be useful
    during development, but for `Release` builds, it would be better to hide it. This
    can be achieved by passing the `WIN32_EXECUTABLE` property to `set_target_properties`
    and ensuring that this is only set when the CMake configuration is set to `Release`.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个需要注意的小细节，虽然这略微超出了 CPack 的范围，但属于让我们的应用程序准备好发布的范畴，那就是隐藏启动应用程序时出现的控制台窗口。这一点可能之前不太显眼，因为我们大部分时间都是从终端启动应用程序。你可能已经注意到，当从
    Windows GUI 启动时，会在后台出现一个控制台窗口，显示我们添加的调试控制台输出。这个窗口在开发过程中可能很有用，但对于 `Release` 版本来说，最好将其隐藏。可以通过将
    `WIN32_EXECUTABLE` 属性传递给 `set_target_properties` 来实现，并确保只有在 CMake 配置设置为 `Release`
    时才进行设置。
- en: 'This can be done by adding the following to our `CMakeLists.txt` file:'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以通过将以下内容添加到我们的`CMakeLists.txt`文件中完成：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: set(
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: set(
- en: CPACK_NSIS_EXTRA_INSTALL_COMMANDS
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CPACK_NSIS_EXTRA_INSTALL_COMMANDS
- en: '"CreateShortCut ''$DESKTOP\\\\Minimal CMake - Game of Life.lnk'' ''$INSTDIR\\\\bin\\\\${PROJECT_NAME}.exe''")'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"CreateShortCut ''$DESKTOP\\\\Minimal CMake - Game of Life.lnk'' ''$INSTDIR\\\\bin\\\\${PROJECT_NAME}.exe''")'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: cpack --config build/multi-ninja/CPackConfig.cmake -G NSIS64 -B package
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja/CPackConfig.cmake -G NSIS64 -B package
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: set(CPACK_BUNDLE_NAME "Minimal CMake - Game of Life")
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: set(CPACK_BUNDLE_NAME "Minimal CMake - Game of Life")
- en: set(CPACK_BUNDLE_PLIST
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: set(CPACK_BUNDLE_PLIST
- en: '"${CMAKE_SOURCE_DIR}/packaging/macos/info.plist")'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"${CMAKE_SOURCE_DIR}/packaging/macos/info.plist")'
- en: set(CPACK_BUNDLE_ICON
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: set(CPACK_BUNDLE_ICON
- en: '"${CMAKE_SOURCE_DIR}/packaging/macos/gol.icns")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"${CMAKE_SOURCE_DIR}/packaging/macos/gol.icns")'
- en: set(CPACK_BUNDLE_STARTUP_COMMAND
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: set(CPACK_BUNDLE_STARTUP_COMMAND
- en: '"${CMAKE_SOURCE_DIR}/packaging/macos/bundle-run.sh")'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '"${CMAKE_SOURCE_DIR}/packaging/macos/bundle-run.sh")'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: cd "$(dirname "$0")"
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: cd "$(dirname "$0")"
- en: ../Resources/bin/minimal-cmake_game-of-life_window
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ../Resources/bin/minimal-cmake_game-of-life_window
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: cpack --config build/multi-ninja/CPackConfig.cmake -B package -G .dmg file)
    that can be opened, and then the bundled application can be dragged to the Applications
    folder to install it on the system (simply move the application from the Applications
    folder to the macOS Bin to uninstall it).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja/CPackConfig.cmake -B package -G .dmg 文件），该文件可以打开，之后将打包的应用程序拖到“应用程序”文件夹中进行安装（只需将应用程序从“应用程序”文件夹移动到
    macOS Bin 中即可卸载它）。
- en: '![Figure 10.2: A macOS disk image](img/B21152_10_2.jpg)'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.2：macOS 磁盘映像](img/B21152_10_2.jpg)'
- en: 'Figure 10.2: A macOS disk image'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2：macOS 磁盘映像
- en: There are further ways to customize the appearance of the mounted disk image,
    such as creating a custom `.DS_Store` file and using the `CPACK_DMG_DS_STORE`
    variable to refer to it. See `ch10/part-4/app/CMakeLists.txt` and `ch10/part-4/app/packaging/macos/custom_DS_Store`
    for an example of this.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有其他方法可以自定义已挂载磁盘映像的外观，例如创建自定义的 `.DS_Store` 文件，并使用 `CPACK_DMG_DS_STORE` 变量来引用它。请参阅
    `ch10/part-4/app/CMakeLists.txt` 和 `ch10/part-4/app/packaging/macos/custom_DS_Store`
    了解示例。
- en: The CPack Linux Debian package
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CPack Linux Debian 包
- en: We’re now going to review the changes to our `CMakeLists.txt` file in `ch10/part-2/app`
    to understand what additions have been made to support a Debian (`.deb`) installer
    on Linux.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们将回顾 `ch10/part-2/app` 中的 `CMakeLists.txt` 文件的更改，以了解支持 Linux 上 Debian（`.deb`）安装程序所做的添加。
- en: 'The good news is that the changes are limited. The first change is a lot like
    what we had to do on Windows to ensure that we get an icon to appear for our application
    after installing it. This time, we need to add two additional `install` commands
    to copy a Linux `.desktop` file (responsible for our application appearing in
    the Linux GUI) and an associated `.png` image to the install location:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好消息是这些更改是有限的。第一个更改类似于我们在 Windows 上所做的操作，目的是确保安装后应用程序会显示图标。这一次，我们需要添加两个额外的`install`命令，分别用于复制
    Linux `.desktop` 文件（负责应用程序出现在 Linux GUI 中）和相关的 `.png` 图像到安装位置：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first command takes our `.desktop` file and copies it to the data root directory,
    relative to our chosen install folder (by default, this will be `<install-folder>/share`).
    By convention, `.desktop` files can be expected to be found in the `applications`
    folder under `share`, so we append `applications` to `CMAKE_INSTALL_DATAROOTDIR`.
    The icon itself is searched for in `share/icons`, so we need to ensure that we
    copy it there as well.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个命令将我们的`.desktop`文件复制到数据根目录，相对于我们选择的安装文件夹（默认情况下，这是`<install-folder>/share`）。根据惯例，`.desktop`文件通常会位于`share`下的`applications`文件夹中，因此我们将`applications`附加到`CMAKE_INSTALL_DATAROOTDIR`。图标本身会在`share/icons`中查找，因此我们需要确保将其也复制到该位置。
- en: In this example, we’re using the Debian package generator; when we install the
    package, the files will be copied to the platform standard locations (`/usr/share/icons`,
    `/usr/share/applications`, `/usr/bin`, etc.). The good thing about this is we
    don’t need to hardcode absolute paths in our `.desktop` file, as the executable
    and icon can be found in the expected places.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了Debian包生成器；当我们安装包时，文件将被复制到平台标准位置（`/usr/share/icons`、`/usr/share/applications`、`/usr/bin`等）。这样做的好处是，我们不需要在`.desktop`文件中硬编码绝对路径，因为可执行文件和图标可以在预期的位置找到。
- en: 'For completeness, the contents of the `.desktop` file are as follows:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了完整性，`.desktop`文件的内容如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we’re creating a windowed app, we set `Terminal` to `false` and add some
    additional metadata that helps describe the kind of application we built (for
    more information about `.desktop` files, see [https://wiki.archlinux.org/title/Desktop_entries](https://wiki.archlinux.org/title/Desktop_entries)
    for a helpful overview). Note that we do not include the extension when specifying
    the icon; we only need to provide the name.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个窗口化应用程序，我们将`Terminal`设置为`false`，并添加一些额外的元数据，帮助描述我们构建的应用程序类型（有关`.desktop`文件的更多信息，请参见[https://wiki.archlinux.org/title/Desktop_entries](https://wiki.archlinux.org/title/Desktop_entries)以获取有用的概述）。请注意，在指定图标时，我们不包括扩展名；我们只需要提供名称。
- en: 'The only remaining code change we need to make to support a Debian package
    on Linux is to provide a name for the package maintainer. This can be achieved
    with the following command:'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了支持Linux上的Debian包，我们唯一需要做的代码更改是提供包的维护者名称。可以使用以下命令来实现：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a useful way for users to be able to contact package owners/maintainers
    if they encounter an issue or have feedback they wish to pass on. This field must
    be provided; otherwise, CPack will return an error and not produce the Debian
    package.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个有用的方法，用户可以在遇到问题或有反馈时联系包的所有者/维护者。此字段是必须提供的；否则，CPack会返回错误并且不会生成Debian包。
- en: 'With these changes applied to our `CMakeLists.txt` file, we can now run CPack
    and provide the DEB package generator. After building a release configuration
    of the project (e.g., `cmake --build build/multi-ninja --config Release`), simply
    run the following command from `ch10/part-2/app`:'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用这些更改到我们的`CMakeLists.txt`文件后，我们现在可以运行CPack并提供DEB包生成器。在构建项目的发布配置（例如，`cmake --build
    build/multi-ninja --config Release`）之后，只需从`ch10/part-2/app`目录运行以下命令：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: sudo dpkg -i package/minimal-cmake_game-of-life-0.1.1-Linux.deb
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: sudo dpkg -i package/minimal-cmake_game-of-life-0.1.1-Linux.deb
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: sudo dpkg -P minimal-cmake_game-of-life
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: sudo dpkg -P minimal-cmake_game-of-life
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: set_target_properties(
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: ${PROJECT_NAME} PROPERTIES Minimal CMake - Game of Life.app in the build/<preset>/<config>
    folder, instead of the executable file and collection of loose files, including
    libraries and resources, that we’ve seen so far. The truth is that the .app file
    is just a folder holding all these files; the only difference is that it’s presented
    in a slightly neater package. From Finder, if you right-click the .app file and
    click CMakeLists.txt file (see ch10/part-3/app/CMakeLists.txt for the full example).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME} PROPERTIES Minimal CMake - Game of Life.app位于build/<preset>/<config>文件夹中，而不是我们迄今为止看到的可执行文件和松散的文件集合，包括库和资源。事实上，`.app`文件只是一个包含所有这些文件的文件夹；唯一的区别是它以一个稍微整洁的包的形式呈现。从Finder中，如果右键点击`.app`文件并点击CMakeLists.txt文件（查看ch10/part-3/app/CMakeLists.txt以查看完整示例）。
- en: 'The executable itself ends up in a folder called `MacOS`, and our shared libraries
    (`.dylib` files) are added to a folder called `Frameworks`. Finally, our shaders
    (and `.icns` file) are added to a folder called `Resources`. This layout is standard
    for macOS applications, and CMake makes it relatively easy to support. A change
    worth mentioning is a small update to the `set_target_properties` `INSTALL_RPATH`
    command, to include `Frameworks` in the search path:'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可执行文件最终会被放入一个名为 `MacOS` 的文件夹中，我们的共享库（`.dylib` 文件）会被添加到名为 `Frameworks` 的文件夹中。最后，我们的着色器（以及
    `.icns` 文件）会被添加到一个名为 `Resources` 的文件夹中。这个布局是 macOS 应用程序的标准布局，CMake 使得支持它相对容易。值得一提的改动是对
    `set_target_properties` 的 `INSTALL_RPATH` 命令进行了小的更新，将 `Frameworks` 添加到搜索路径中：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: add_custom_target(
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: add_custom_target(
- en: create_frameworks_directory ALL
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: create_frameworks_directory ALL
- en: COMMAND
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND
- en: ${CMAKE_COMMAND} -E make_directory
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_COMMAND} -E make_directory
- en: $<TARGET_FILE_DIR:${PROJECT_NAME}>/../Frameworks
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: $<TARGET_FILE_DIR:${PROJECT_NAME}>/../Frameworks
- en: COMMENT "Creating Frameworks directory")
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: COMMENT "创建 Frameworks 目录")
- en: add_dependencies(
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: add_dependencies(
- en: ${PROJECT_NAME} create_frameworks_directory)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME} create_frameworks_directory)
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: install(TARGETS ${PROJECT_NAME} if(APPLE) block. We use the CMake set_source_files_properties
    command to set the package location for various files (this includes our shader
    files, vs_vertcol.bin and fs_vertcol.bin, and a new gol.icns file). These are
    copied to the Resources/shader folder and the Resources folder inside the bundle’s
    Contents folder (.app file).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: install(TARGETS ${PROJECT_NAME} if(APPLE) block. 我们使用 CMake 的 set_source_files_properties
    命令来设置各种文件的包位置（这包括我们的着色器文件，vs_vertcol.bin 和 fs_vertcol.bin 以及新的 gol.icns 文件）。这些文件被复制到
    Resources/shader 文件夹和包内 Contents 文件夹中的 Resources 文件夹（.app 文件）。
- en: 'The following snippet shows how this is achieved:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何实现这一点：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: target_sources(
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: target_sources(
- en: ${PROJECT_NAME} PRIVATE shader/build/vs_vertcol.bin
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME} PRIVATE shader/build/vs_vertcol.bin
- en: MACOSX_BUNDLE to TRUE), instead of creating our own Info.plist, CMake will use
    an Info.plist template file called MacOSXBundleInfo.plist.in, located in /Applications/CMake.app/Contents/share/cmake-3.28/Modules,
    (the CMAKE_MODULE_PATH). It’s then possible to use set_target_properties to provide
    several MACOSX_BUNDLE_ properties to override these values (for a complete list,
    see https://cmake.org/cmake/help/latest/prop_tgt/MACOSX_BUNDLE_INFO_PLIST.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 MACOSX_BUNDLE 为 TRUE 后，CMake 将使用位于 /Applications/CMake.app/Contents/share/cmake-3.28/Modules（CMAKE_MODULE_PATH）中的一个名为
    MacOSXBundleInfo.plist.in 的 Info.plist 模板文件，而不是我们自己创建 Info.plist 文件。然后可以使用 set_target_properties
    提供多个 MACOSX_BUNDLE_ 属性来覆盖这些值（完整列表请参见 https://cmake.org/cmake/help/latest/prop_tgt/MACOSX_BUNDLE_INFO_PLIST.html）。
- en: 'In our case, we set a handful of properties that are generally useful; for
    our purposes, `MACOSX_BUNDLE_ICON_FILE` is the most notable, which ensures that
    our application receives a distinctive appearance. A subset of the command is
    shown here:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们设置了一些通常有用的属性；对于我们的用途，`MACOSX_BUNDLE_ICON_FILE` 是最显著的，它确保我们的应用程序具有独特的外观。下面展示了部分命令：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It’s also possible to override the template by providing a custom `Info.plist`
    file and using `MACOSX_BUNDLE_INFO_PLIST` to refer to it from our `CMakeLists.txt`
    file.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也可以通过提供一个自定义的 `Info.plist` 文件并使用 `MACOSX_BUNDLE_INFO_PLIST` 从我们的 `CMakeLists.txt`
    文件中引用它，来覆盖模板。
- en: 'The only remaining change is the removal of our `set(CPACK_BUNDLE_...` calls
    from our `CMakeLists.txt` file, as they’re no longer required. With these changes,
    we can build our application as a macOS bundle, and when we come to package our
    application, instead of using the `Bundle` generator as we did before, we can
    use the `DragNDrop` generator. An example is shown here:'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一剩下的变化是从我们的 `CMakeLists.txt` 文件中移除了 `set(CPACK_BUNDLE_...` 调用，因为它们不再需要。通过这些更改，我们可以将应用程序构建为
    macOS 包，并且在打包应用程序时，不再使用之前的 `Bundle` 生成器，而是可以使用 `DragNDrop` 生成器。这里展示了一个示例：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: cpack --config build/multi-ninja/CPackConfig.cmake -B package -G Bundle
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja/CPackConfig.cmake -B package -G Bundle
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: cpack –preset macos
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: cpack –preset macos
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '"packagePresets": ['
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '"packagePresets": ['
- en: '{'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "base",'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "base",'
- en: '"configurePreset": "multi-ninja-super",'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '"configurePreset": "multi-ninja-super",'
- en: '"packageDirectory": "${sourceDir}/package",'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '"packageDirectory": "${sourceDir}/package",'
- en: '"hidden": true'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"hidden": true'
- en: '},'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "macos",'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "macos",'
- en: '"condition": {'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '"condition": {'
- en: '"type": "equals",'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "equals",'
- en: '"lhs": "${hostSystemName}",'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '"lhs": "${hostSystemName}",'
- en: '"rhs": "Darwin"'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"rhs": "Darwin"'
- en: '},'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"generators": ["Bundle"],'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '"generators": ["Bundle"],'
- en: '"inherits": ["base"]'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '"inherits": ["base"]'
- en: '},'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '...'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '{'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "multi-ninja-super-package-linux",'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super-package-linux",'
- en: '"steps": ['
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '"steps": ['
- en: '{'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "configure",'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "configure",'
- en: '"name": "multi-ninja-super"'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super"'
- en: '},'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "build",'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "build",'
- en: '"name": "multi-ninja-super"'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super"'
- en: '},'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "package",'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "package",'
- en: '"name": "linux"'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "linux"'
- en: '}'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: cmake --workflow --preset \
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --workflow --preset \
- en: multi-ninja-super-package-linux
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: multi-ninja-super-package-linux
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: set(CPACK_SOURCE_IGNORE_FILES
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: set(CPACK_SOURCE_IGNORE_FILES
- en: '"build.*\/"'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '"build.*\/"'
- en: '"package.*\/"'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"package.*\/"'
- en: '"install\/"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"install\/"'
- en: '"\.git\/"'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '"\.git\/"'
- en: '"\.gitignore"'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '"\.gitignore"'
- en: '"\.vscode"'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"\.vscode"'
- en: )
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: cpack --config build/multi-ninja-super/CPackSourceConfig.cmake -G TGZ -B package-source
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: cpack --config build/multi-ninja-super/CPackSourceConfig.cmake -G TGZ -B package-source
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '{'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "source",'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "source",'
- en: '"generators": ["ZIP"],'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '"generators": ["ZIP"],'
- en: '"packageDirectory": "${sourceDir}/package-source",'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"packageDirectory": "${sourceDir}/package-source",'
- en: '"configFile": "CPackSourceConfig.cmake",'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '"configFile": "CPackSourceConfig.cmake",'
- en: '"inherits": ["base"]'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"inherits": ["base"]'
- en: '}'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
