- en: Jungle Jump (Platformer)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丛林跳跃（平台游戏）
- en: 'In this chapter, you''ll build a classic *platform*, style game in the tradition
    of *Super Mario Bros.* Platform games are a very popular genre, and understanding
    how they work can help you make a variety of different game styles. The physics
    of platformers can be deceptively complex, and you''ll see how Godot''s `KinematicBody2D`
    physics node has features to help you implement the character controller features
    you need for a satisfying experience. Take a look at the following screenshot:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将构建一个经典的*平台*风格游戏，遵循*超级马里奥兄弟*的传统。平台游戏是一个非常受欢迎的游戏类型，了解它们的工作原理可以帮助您制作各种不同的游戏风格。平台游戏中的物理可能具有欺骗性的复杂性，您将看到Godot的`KinematicBody2D`物理节点具有帮助您实现所需的角色控制器功能的特性。请查看以下截图：
- en: '![](img/fe628371-e6f4-4732-a422-8822890627da.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe628371-e6f4-4732-a422-8822890627da.png)'
- en: 'In this project, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将了解：
- en: Using the `KinematicBody2D` physics node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`KinematicBody2D`物理节点
- en: Combining animations and user input to produce complex character behavior
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将动画和用户输入结合以产生复杂的角色行为
- en: Creating an infinitely scrolling background using ParallaxLayers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ParallaxLayers创建无限滚动的背景
- en: Organizing your project and planning for expansion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织您的项目并规划扩展
- en: Project setup
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'Create a new project. Before you download the assets from the link that follows,
    you need to prepare the import settings for the game art. The art assets for this
    project use a *pixel art* style, which means they look best when not filtered,
    which is Godot''s default setting for textures. **Filtering** is a method by which
    the pixels of an image are smoothed. It can improve the look of some art, but
    not pixel-based images:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目。在您从以下链接下载资源之前，您需要为游戏艺术准备导入设置。本项目使用的艺术资源采用*像素艺术*风格，这意味着它们在没有过滤时看起来最好，这是Godot为纹理的默认设置。“过滤”是一种通过平滑图像像素的方法。它可以改善某些艺术作品的外观，但不能改善基于像素的图像：
- en: '![](img/2e2488db-691b-43fb-ad11-aef65d2434e0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e2488db-691b-43fb-ad11-aef65d2434e0.png)'
- en: 'It''s inconvenient to have to disable this for every image, so Godot allows
    you to customize the default import settings. Click on the `icon.png` file in
    the FileSystem dock, then click the Import tab next to the Scene tab on the right.
    This window allows you to change the import settings for the file you''ve selected.
    Uncheck the Filter property, then click Preset and choose Set as Default for ''Texture''.
    This way, all images will be imported with filtering disabled. Refer to the following
    screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都要为每张图片禁用这个功能是不方便的，因此Godot允许您自定义默认的导入设置。在FileSystem窗口中点击`icon.png`文件，然后点击右侧场景标签旁边的导入标签。此窗口允许您更改所选文件的导入设置。取消选择“过滤器”属性，然后点击预设并选择将“纹理”设置为默认。这样，所有图像都将导入时禁用过滤器。请参考以下截图：
- en: '![](img/7e223219-3c2a-40c8-972f-0641e3406563.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e223219-3c2a-40c8-972f-0641e3406563.png)'
- en: If you've already imported images, their import settings won't be updated automatically.
    After changing the default, you'll have to reimport any existing images. You can
    select multiple files in the FileSystem dock and click the Reimport button to
    apply the settings to many files at once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经导入图像，它们的导入设置不会自动更新。更改默认设置后，您必须重新导入任何现有图像。您可以在FileSystem窗口中选择多个文件，然后点击重新导入按钮，一次性应用设置到多个文件。
- en: Now, you can download the game assets from the following link and unzip them
    in your project folder. Godot will import all the images with the new default
    settings, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从以下链接下载游戏资源，并将其解压缩到您的项目文件夹中。Godot将使用新的默认设置导入所有图像，[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)
- en: Next, open Project | Project Settingsand under Rendering/Quality, set Use Pixel
    Snap to `On`. This will ensure that all images will be aligned properly—something
    that will be very important when you're designing your game's levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开“项目”|“项目设置”，在渲染/质量下，将“使用像素捕捉”设置为“开启”。这将确保所有图像都将正确对齐——这在您设计游戏关卡时将非常重要。
- en: While you have the settings window open, go to the Display/Window section and
    change Stretch/Mode to `2d` and Aspect to `expand`. These settings will allow
    the user to resize the game window while preserving the image's quality. Once
    the project has been completed, you'll be able to see the effects of this setting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开设置窗口时，转到显示/窗口部分，将拉伸/模式改为 `2d` 并将纵横比改为 `expand`。这些设置将允许用户在保持图像质量的同时调整游戏窗口的大小。一旦项目完成，你将能够看到此设置的效果。
- en: 'Next, set up the collision layer names so that it will be more convenient to
    set up collisions between different types of objects. Go to Layer Names/2d Physics and
    name the first four layers like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置碰撞层名称，以便更方便地设置不同类型对象之间的碰撞。转到层名称/2d物理，并将前四个层命名为如下：
- en: '![](img/4a6614f2-4f23-466f-a8bb-49b4d6fbe579.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a6614f2-4f23-466f-a8bb-49b4d6fbe579.png)'
- en: 'Finally, add the following actions for the player controls in the Input Map
    tab under Project | Project Settings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目 | 项目设置下的输入映射选项卡中添加以下动作以供玩家控制：
- en: '| **Action Name** | **Key(s)** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **动作名称** | **按键** |'
- en: '| right | D, → |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 向右 | D, → |'
- en: '| left | A, ← |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 向左 | A, ← |'
- en: '| jump | Space |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 跳跃 | 空间 |'
- en: '| crouch | S, ↓ |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 蹲下 | S, ↓ |'
- en: '| climb | W, ↑ |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 爬升 | W, ↑ |'
- en: Introducing kinematic bodies
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍运动学体
- en: A platform game requires gravity, collisions, jumping, and other physics behavior,
    so you might think that `RigidBody2D` would be the perfect choice to implement
    the character's movement. In practice, however, you'll find that the *realistic*
    physics of the rigid body are not desirable for a platform character. To the player,
    realism is less important than responsive control and an *action* feel. As the
    developer, you therefore want to have precise control over the character's movements
    and collision response. For this reason, a kinematic body is usually the better
    choice for a platform character.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 平台游戏需要重力、碰撞、跳跃和其他物理行为，因此你可能认为 `RigidBody2D` 是实现角色移动的完美选择。然而，在实践中，你会发现刚体的 *真实*
    物理特性对于平台角色来说并不理想。对于玩家来说，现实感不如响应控制和 *动作感* 重要。因此，作为开发者，你希望对角色的移动和碰撞响应有精确的控制。因此，对于平台角色来说，通常使用运动学体是一个更好的选择。
- en: The `KinematicBody2D` node is designed for implementing bodies that are to be
    controlled directly by the user or via code. These nodes detect collisions with
    other bodies when moving, but are not affected by global physics properties like
    gravity or friction. This doesn't mean that a kinematic body can't be affected
    by gravity and other forces, just that you must calculate those forces and their
    effects in code; the engine will not move a kinematic body automatically.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`KinematicBody2D` 节点是为了实现那些需要由用户或通过代码直接控制的身体而设计的。这些节点在移动时检测与其他身体的碰撞，但不受全局物理属性（如重力或摩擦）的影响。这并不意味着运动学体不能受到重力和其他力的作用，只是你必须通过代码计算这些力和它们的效果；引擎不会自动移动运动学体。'
- en: When moving `KinematicBody2D`, as with `RigidBody2D`, you should not set its
    `position` directly. Instead, you use either the `move_and_collide()` or `move_and_slide()` methods.
    These methods move the body along a given vector and instantly stop if a collision
    is detected with another body. After `KinematicBody2D` has collided, any *collision
    response* must be coded manually.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动 `KinematicBody2D` 时，与 `RigidBody2D` 类似，你不应该直接设置其 `position`。相反，你应该使用 `move_and_collide()`
    或 `move_and_slide()` 方法。这些方法沿着给定的向量移动身体，并在检测到与其他身体的碰撞时立即停止。在 `KinematicBody2D`
    发生碰撞后，任何 *碰撞响应* 都必须手动编码。
- en: Collision response
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞响应
- en: After a collision, you may want the body to bounce, to slide along a wall, or
    to alter the properties of the object it hit. The way you handle collision response
    depends on which method you used to move the body.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在碰撞后，你可能希望身体弹跳、沿墙壁滑动或改变它撞击物体的属性。你处理碰撞响应的方式取决于你用来移动身体的方法。
- en: move_and_collide
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: move_and_collide
- en: When using `move_and_collide()`, the function returns a `KinematicCollision2D`
    object upon collision. This object contains information about the collision and
    the colliding body. You can use this information to determine the response. Note
    that the function returns `null` when the movement was completed successfully
    with no collision.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `move_and_collide()` 时，在碰撞发生时，函数返回一个 `KinematicCollision2D` 对象。此对象包含有关碰撞和碰撞体的信息。你可以使用这些信息来确定响应。请注意，当移动成功完成且没有碰撞时，函数返回
    `null`。
- en: 'For example, if you want the body to bounce off of the colliding object, you
    could use the following script:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想使身体从碰撞物体上弹跳，可以使用以下脚本：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: move_and_slide
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: move_and_slide
- en: Sliding is a very common option for collision response. Imagine a player moving
    along walls in a top-down game or running up and down slopes in a platformer.
    While it's possible to code this response yourself after using `move_and_collide()`,
    `move_and_slide()` provides a convenient way to implement sliding movement. When
    using this method, the body will automatically slide along the colliding surface.
    In addition, sliding collisions allow you to use methods like `is_on_floor()`
    to detect the orientation of the colliding surface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动是碰撞响应中一个非常常见的选项。想象一下，在俯视游戏中玩家沿着墙壁移动或在平台游戏中上下跑斜坡。虽然在使用 `move_and_collide()`
    后可以自己编写此响应的代码，但 `move_and_slide()` 提供了一种方便的方式来实现滑动移动。当使用此方法时，身体将自动沿着碰撞表面滑动。此外，滑动碰撞还允许你使用
    `is_on_floor()` 等方法来检测碰撞表面的方向。
- en: Since this project will require not just moving along the ground, but also running
    up and down slopes, `move_and_slide()` is going to play a large role in your player's
    movement. You'll see how it works as you build up the player object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目不仅需要在地面上移动，还需要在斜坡上跑上跑下，因此 `move_and_slide()` 在玩家移动中扮演着重要角色。当你构建玩家对象时，你将看到它是如何工作的。
- en: Player scene
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家场景
- en: Open a new scene and add a `KinematicBody2D` object named `Player` as the root
    and save the scene (don't forget to click the Make children unselectable button).
    When saving the `Player` scene, you should also create a new folder to contain
    it. This will help keep your project folder organized as you add more scenes and
    scripts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的场景，并将名为 `Player` 的 `KinematicBody2D` 对象作为根对象添加，然后保存场景（别忘了点击“使子对象不可选择”按钮）。在保存
    `Player` 场景时，你还应该创建一个新的文件夹来包含它。这将有助于你在添加更多场景和脚本时保持项目文件夹的整洁。
- en: As you've done in other projects, you'll include all the nodes that the player
    character needs to function in the `Player` scene. For this game, that means handling
    collisions with various game objects, including platforms, enemies, and collectibles;
    displaying animations for actions, such as running or jumping; and a camera to
    follow the player around the level.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在其他项目中做的那样，你将在 `Player` 场景中包含玩家角色需要以正常工作所需的所有节点。对于这个游戏，这意味着处理与各种游戏对象的碰撞，包括平台、敌人和可收集物品；显示跑步或跳跃等动作的动画；以及一个跟随玩家在关卡中移动的摄像头。
- en: Scripting the various animations can quickly become unmanageable, so you'll
    use a *finite state machine* to manage and track the player's state. See [Chapter
    3](f24a8958-bb32-413a-97ae-12c9e7001c2c.xhtml), *Escape the Maze*, to review how
    the simplified FSM was built. You'll follow a similar pattern for this project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编写各种动画的脚本可能会很快变得难以管理，因此你将使用一个 *有限状态机* 来管理和跟踪玩家的状态。参见 [第 3 章](f24a8958-bb32-413a-97ae-12c9e7001c2c.xhtml)，*逃离迷宫*，回顾如何构建简化的
    FSM。你将遵循类似的项目模式。
- en: Collision Layer/Mask
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞层/遮罩
- en: A body's collision layer property sets what layer(s) the body is found on. `Player` needs
    to be assigned to the player layer you named in Project Settings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 身体的碰撞层属性设置身体所在的层。`Player` 需要分配到在项目设置中命名的玩家层。
- en: 'The Collision/Mask property allows you to set what types of objects the body
    will detect. Set the Player layer to `player` and its mask to environment, enemies,
    and collectibles (`1`, `3`, and `4`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞/遮罩属性允许你设置身体将检测哪些类型的对象。将 `Player` 层设置为 `player`，并将其遮罩设置为环境、敌人和可收集物品（`1`、`3`
    和 `4`）：
- en: '![](img/b5cc9f1d-67d7-4e60-8e64-0749e8feaae9.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5cc9f1d-67d7-4e60-8e64-0749e8feaae9.png)'
- en: Sprite
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sprite
- en: 'Add a Sprite node to `Player`. Drag the `res://assets/player_sheet.png` file
    from the FileSystem dock and drop it in the Texture property of the `Sprite`.
    The player animation is saved in the form of a sprite sheet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Sprite 节点添加到 `Player` 中。从 FileSystem 选项卡拖动 `res://assets/player_sheet.png`
    文件并将其放入 `Sprite` 的 Texture 属性中。玩家动画以精灵图集的形式保存：
- en: '![](img/91acf832-e5d4-4420-9dea-627f6b0aae6f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91acf832-e5d4-4420-9dea-627f6b0aae6f.png)'
- en: 'You''ll use `AnimationPlayer` to handle the animations, so in the Animation properties
    of `Sprite`, set Vframes to `1` and Hframes to `19`. Set Frame to `7` to begin,
    as this is the frame that shows the character standing still (it''s the first
    frame of the `idle` animation):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `AnimationPlayer` 来处理动画，因此在 `Sprite` 的动画属性中，将 Vframes 设置为 `1`，将 Hframes
    设置为 `19`。将 Frame 设置为 `7` 以开始，因为这个帧显示了角色静止不动（它是 `idle` 动画的第一个帧）：
- en: '![](img/0c780e74-c4b2-4960-851a-3ddc565a24d5.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0c780e74-c4b2-4960-851a-3ddc565a24d5.png)'
- en: Collision shape
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞形状
- en: As with other physics bodies, `KinematicBody2D` needs a shape assigned to define
    its collision bounds. Add a `CollisionShape2D` object and create a new `RectangleShape2D` object
    inside it. When sizing the rectangle, you want it to reach the bottom of the image
    but not be quite as wide. In general, making the collision shape a bit smaller
    than the image will result in a better *feel* when playing, avoiding the experience
    of hitting something that looks like it wouldn't result in a collision.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他物理体一样，`KinematicBody2D` 需要一个形状来定义其碰撞边界。添加一个 `CollisionShape2D` 对象，并在其中创建一个新的
    `RectangleShape2D` 对象。在调整矩形大小时，您希望它达到图像的底部，但不要那么宽。一般来说，使碰撞形状比图像略小，在播放时会有更好的 *感觉*，避免击中看起来不会导致碰撞的东西的体验。
- en: 'You''ll also need to offset the shape a small amount to make it fit. Setting Position to
    `(0, 5)` works well. When you''re done, it should look approximately like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要稍微偏移形状以使其适合。将位置设置为 `(0, 5)` 效果很好。完成时，它应该看起来大约是这样的：
- en: '![](img/a6494b7a-3f21-4d56-a093-dae24dda9edd.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6494b7a-3f21-4d56-a093-dae24dda9edd.png)'
- en: Shapes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形状
- en: 'Some developers prefer a capsule shape over a rectangle shape for sidescrolling
    characters. A capsule is a pill-shaped collision that''s rounded on both ends:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者更喜欢胶囊形状而不是矩形形状用于横版滚动角色。胶囊是一种两端圆润的药片形状碰撞体：
- en: '![](img/2f968bf9-92a8-468a-9309-4082c72de89e.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f968bf9-92a8-468a-9309-4082c72de89e.png)'
- en: However, while this shape might seem to *cover* the sprite better, it can lead
    to difficulties when implementing platformer-style movement. For example, when
    standing too near the edge of a platform, the character may slide off due to the
    rounded bottom, which can be very frustrating for the player.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这个形状可能看起来能更好地 *覆盖* 精灵，但在实现平台式移动时可能会带来困难。例如，当站在平台边缘太近时，由于底部的圆润，角色可能会滑落，这对玩家来说可能非常令人沮丧。
- en: In some cases, depending on the complexity of your character and its interactions
    with other objects, you may want to add multiple shapes to the same object. You
    might have one shape at the character's feet to detect ground collisions, another
    on its body to detect damage (sometimes called a hurtbox), and yet another covering
    the player's front to detect contact with walls.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据角色的复杂性和与其他对象的交互，您可能希望向同一对象添加多个形状。您可能有一个在角色脚下的形状来检测地面碰撞，另一个在其身体上检测伤害（有时称为受伤框），还有一个覆盖玩家前方的形状来检测与墙壁的接触。
- en: It's recommended that you stick to `RectangleShape2D`, as shown in the preceding
    screenshot, for this character. However, once you've finished the project, you
    should try changing the player's collision shape to `CapsuleShape2D` and observing
    the resulting behavior. If you like it better, feel free to use it instead.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您坚持使用如图所示的前一个屏幕截图中的 `RectangleShape2D`，对于此角色。然而，一旦您完成项目，您应该尝试将玩家的碰撞形状更改为 `CapsuleShape2D`
    并观察产生的行为。如果您更喜欢它，请随意使用它。
- en: Animations
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: 'Add an `AnimationPlayer` node to the `Player` scene. You''ll use this node
    to change the Frame property on `Sprite` to display the character''s animations.
    Start by making a new animation named `idle`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `AnimationPlayer` 节点添加到 `Player` 场景中。您将使用此节点来更改 `Sprite` 上的帧属性以显示角色的动画。首先创建一个新的动画名为
    `idle`：
- en: '![](img/23491cf3-4dc5-40f9-a9d2-c933650555c1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23491cf3-4dc5-40f9-a9d2-c933650555c1.png)'
- en: 'Set Length to `0.4` seconds and keep Step at `0.1` seconds. Change the Frame of `Sprite`
    to `7` and click the Add keyframe button next to the Frame property to create
    a new animation track, then press it again, noting that it automatically increments
    the Frame property:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Length` 设置为 `0.4` 秒，并保持 `Step` 为 `0.1` 秒。将 `Sprite` 的帧更改为 `7`，然后点击帧属性旁边的添加关键帧按钮以创建一个新的动画轨道，然后再次点击它，注意它会自动增加帧属性：
- en: '![](img/ada536c1-e847-4e17-9661-cce98de7c9c8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ada536c1-e847-4e17-9661-cce98de7c9c8.png)'
- en: 'Continue pressing it until you have frames `7` through `10`. Finally, click
    the Enable/Disable looping button to enable looping and then press Play to view
    your animation. Your animation setup should look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 持续按住它，直到您有帧 `7` 到 `10`。最后，点击启用/禁用循环按钮以启用循环，然后按播放查看您的动画。您的动画设置应该看起来像这样：
- en: '![](img/22e338b2-66da-43ea-8436-070672dcf5c0.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/22e338b2-66da-43ea-8436-070672dcf5c0.png)'
- en: 'Now you need to repeat the process for the other animations. See the following
    table for a list of settings:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要为其他动画重复此过程。以下表格列出了设置列表：
- en: '| **name** | **length** | **frames** | **looping** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **长度** | **帧数** | **循环** |'
- en: '| `idle` | `0.4` | `7, 8, 9 ,10` | on |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `空闲` | `0.4` | `7, 8, 9 ,10` | 开启 |'
- en: '| `run` | `0.5` | `13, 14, 15, 16, 17, 18` | on |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `run` | `0.5` | `13, 14, 15, 16, 17, 18` | 开启 |'
- en: '| `hurt` | `0.2` | `5, 6` | on |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `hurt` | `0.2` | `5, 6` | 开启 |'
- en: '| `jump_up` | `0.1` | `11` | off |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `jump_up` | `0.1` | `11` | 关闭 |'
- en: '| `jump_down` | `0.1` | `12` | 0ff |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `jump_down` | `0.1` | `12` | 关闭 |'
- en: Finishing up the scene tree
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成场景树
- en: Add `Camera2D` to the `Player` scene. This node will keep the game window centered
    on the player as it moves around the level. You can also use it to zoom in on
    the player, since the pixel art is relatively small. Remember, since you set filtering
    off in the import settings, the player's texture will remain pixelated and blocky
    when zoomed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Camera2D` 添加到 `Player` 场景中。这个节点会在玩家在关卡中移动时保持游戏窗口在玩家中心。你也可以用它来放大玩家，因为像素艺术相对较小。记住，由于你在导入设置中关闭了过滤，当放大时，玩家的纹理将保持像素化和块状。
- en: To enable the camera, click the Current property to `On`, then set the Zoom property
    to `(0.4, 0.4)`. Values smaller than one zoom the camera in, while larger values
    zoom it out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用相机，点击当前属性设置为 `开启`，然后将缩放属性设置为 `(0.4, 0.4)`。小于一的值会放大相机，而大于一的值会缩小相机。
- en: Player states
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家状态
- en: The player character has a wide variety of behaviors, such as jumping, running,
    and crouching. Coding such behaviors can become very complex and hard to manage.
    One solution is to use Boolean variables (`is_jumping` or `is_running`, for example),
    but this leads to possibly confusing states (what if `is_crouching` and `is_jumping`
    are both `true`?) and quickly leads to spaghetti code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色有多种行为，如跳跃、奔跑和蹲下。编写这样的行为可能会变得非常复杂且难以管理。一个解决方案是使用布尔变量（例如 `is_jumping` 或 `is_running`），但这可能导致可能令人困惑的状态（如果
    `is_crouching` 和 `is_jumping` 都为 `true` 会怎样？）并且很快就会导致代码混乱。
- en: A better solution to this problem is to use a state machine to handle the player's
    current state and control the transitions to other states. Finite state machines
    were discussed in [Chapter 3](f24a8958-bb32-413a-97ae-12c9e7001c2c.xhtml), *Escape
    the Maze*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更好方法是使用状态机来处理玩家的当前状态和控制到其他状态的转换。有限状态机在 [第 3 章](f24a8958-bb32-413a-97ae-12c9e7001c2c.xhtml)，*逃离迷宫*
    中进行了讨论。
- en: 'Here is a diagram of the player''s states and the transitions between them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是玩家状态及其之间转换的图示：
- en: '![](img/56fdfa26-eb80-44d2-9668-008c1eb70178.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56fdfa26-eb80-44d2-9668-008c1eb70178.png)'
- en: As you can see, state machine diagrams can become quite complex, even with a
    relatively small number of states.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，状态机图可能会变得相当复杂，即使状态数量相对较少。
- en: Note that while the spritesheet contains animations for them, the CROUCH and
    CLIMB animations are not included here. This is to keep the number of states manageable
    at the beginning of the project. Later, you'll have the opportunity to add them
    to the player's state machine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然精灵表包含它们的动画，但蹲下和攀爬动画不包括在内。这是为了在项目开始时保持状态数量可管理。稍后，你将有机会将它们添加到玩家的状态机中。
- en: Player script
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: 'Attach a new script to the `Player` node. Add the following code to create
    the player''s state machine:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的脚本附加到 `Player` 节点上。添加以下代码以创建玩家的状态机：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once again, you''re using `enum` to list the allowed states for the system.
    When you want to change the player''s state, you''ll call `change_state()`, for
    example: `change_state(IDLE)`. For now, the script only changes the animation
    value, but you''ll add more state functionality later.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，你正在使用 `enum` 来列出系统允许的状态。当你想要改变玩家的状态时，你会调用 `change_state()`，例如：`change_state(IDLE)`。目前，脚本只改变动画值，但之后你将添加更多状态功能。
- en: You may be asking, *why not just play the animation when the state changes?
    Why this new_anim business?* This is because when you call `play()` on `AnimationPlayer`,
    it starts the animation from the beginning. If you did that while running, for
    example, you'd only see the first frame of the run animation as it restarted every
    frame. By using the `new_anim` variable, you can let the current animation continue
    to play smoothly until you want it to change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么不只是在状态改变时播放动画？为什么要引入新的动画业务？这是因为当你对 `AnimationPlayer` 调用 `play()` 时，它会从动画的开始处开始播放。如果你在奔跑时这样做，例如，你将只能看到奔跑动画的第一帧，因为每一帧都会重新开始。通过使用
    `new_anim` 变量，你可以让当前动画继续平滑播放，直到你想要改变它。
- en: Player movement
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家移动
- en: 'The player needs three controls—left, right, and jump. The combination of the
    current state plus which keys are pressed will trigger a state change if the transition
    is allowed by the state rules. Add the `get_input()` function to process the inputs
    and determine the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要三个控制键——左、右和跳跃。当前状态与按下的键的组合将触发状态变化，如果状态规则允许转换的话。将 `get_input()` 函数添加到处理输入并确定结果：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the jump check is using `is_action_just_pressed()` rather than `is_action_pressed()`.
    While the latter always returns `true` as long as the key is held down, the former
    is only `true` in the frame after the key was pressed. This means that the player
    must press the jump key each time they want to jump.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，跳跃检查使用的是 `is_action_just_pressed()` 而不是 `is_action_pressed()`。后者只要按键被按下就会始终返回
    `true`，而前者只有在按键被按下后的那一帧才会返回 `true`。这意味着玩家必须每次想要跳跃时都按下跳跃键。
- en: 'Now, call this function from `_physics_process()`, add the pull of gravity
    to the player''s `velocity`, and call the `move_and_slide()` method to move the
    body:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 `_physics_process()` 中调用这个函数，将重力拉力添加到玩家的 `velocity` 中，并调用 `move_and_slide()`
    方法来移动身体：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second parameter of `move_and_slide()` is a *normal* vector, indicating
    what surface direction the engine should consider to be the ground. In physics
    and geometry, a *normal* is a vector perpendicular to a surface, defining the
    direction a surface is facing. Using `(0, -1)`, which is a vector pointing upwards,
    the top of a horizontal surface will be considered as ground. Refer to the following
    screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_and_slide()` 的第二个参数是一个 *法线* 向量，指示引擎应考虑哪个表面方向为地面。在物理和几何学中，*法线* 是垂直于表面的向量，定义了表面的朝向方向。使用
    `(0, -1)`，这是一个指向上方的向量，水平表面的顶部将被认为是地面。参考以下截图：'
- en: '![](img/abf9056e-21c3-4fc9-adac-766f03248aca.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abf9056e-21c3-4fc9-adac-766f03248aca.png)'
- en: 'After moving with `move_and_slide()`, the physics engine will use this information
    to set the value of the `is_on_floor()`, `is_on_wall()` and `is_on_ceiling` methods.
    You can use this fact to detect when the jump ends by adding this after the move:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `move_and_slide()` 移动后，物理引擎将使用这些信息来设置 `is_on_floor()`, `is_on_wall()` 和
    `is_on_ceiling` 方法的值。你可以利用这个事实，在移动后添加以下代码来检测跳跃何时结束：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the jump will look better if the animation switches from `jump_up`
    to `jump_down` when falling:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果动画在下落时从 `jump_up` 切换到 `jump_down`，跳跃看起来会更好：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, it would be a good idea to test out the movement and make sure
    everything is working. You can't just run the player scene though, because the
    player will just start falling without a surface to stand on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，测试移动并确保一切正常工作是个好主意。你不能只是运行玩家场景，因为玩家会因为没有立足之地而开始下落。
- en: 'Create a new scene and add a `Node` called `Main` (later, this will become
    your real main scene). Add an instance of the `Player`, then add a `StaticBody2D`
    with a rectangular `CollisionShape2D`. Stretch the collision shape horizontally
    so that it''s wide enough to walk back and forth on (like a platform) and place
    it below the character:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为 `Main` 的 `Node`（稍后，这将成为你的真实主场景）。添加一个 `Player` 实例，然后添加一个带有矩形
    `CollisionShape2D` 的 `StaticBody2D`。将碰撞形状水平拉伸，使其足够宽，可以来回走动（就像一个平台），并将其放置在角色下方：
- en: '![](img/2f2a6248-e308-4ff1-ad50-d7c4b91ce010.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f2a6248-e308-4ff1-ad50-d7c4b91ce010.png)'
- en: Press Play Scene and you should see the player stop falling and run the `idle`
    animation when it hits the static body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按下“播放场景”，你应该会看到玩家在碰到静态体时停止下落并运行 `idle` 动画。
- en: Before moving on, make sure that all the movement and animations are working
    correctly. Run and jump in all directions and check that the correct animations
    are playing whenever the state changes. If you find any problems, review the previous
    sections and make sure you didn't miss a step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，确保所有的移动和动画都正常工作。在所有方向上跑和跳，并检查状态改变时是否播放了正确的动画。如果你发现任何问题，请回顾前面的部分，确保你没有错过任何步骤。
- en: 'Later, once the level is complete, the player will be passed a spawn location.
    To handle this, add this function to the `Player.gd` script:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一旦关卡完成，玩家将会接收到一个出生位置。为了处理这个问题，将以下函数添加到 `Player.gd` 脚本中：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Player health
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家健康
- en: Eventually, the player is going to encounter danger, so you should add a damage
    system. The player will start with three *hearts* and lose one each time they
    are damaged.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，玩家会遇到危险，因此你应该添加一个伤害系统。玩家初始有三颗心，每次受到伤害就会失去一颗。
- en: 'Add the following to the top of the script:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到脚本顶部：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `life_changed` signal will be emitted whenever the value of `life` changes,
    notifying the display to update. `dead` will be emitted when `life` reaches `0`.
    Add these two lines to the `start()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `life` 的值发生变化时，`life_changed` 信号将被发出，通知显示更新。当 `life` 达到 `0` 时，将发出 `dead`。将以下两行添加到
    `start()` 函数中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two possible ways for the player to be hurt: running into a *spike*
    object in the environment, or being hit by an enemy. In either event, the following
    function can be called:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家受伤有两种可能的方式：在环境中撞到 *spike* 对象，或者被敌人击中。在任何一种情况下，都可以调用以下函数：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is being nice to the player: if they''re already hurt, they can''t get
    hurt again (at least for the brief time until the *hurt* animation has stopped
    playing).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对玩家友好：如果他们已经受伤，他们就不能再次受伤（至少在 *hurt* 动画停止播放的短暂时间内）。
- en: 'There are several things to do when the state changes to `HURT` in `change_state()`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `change_state()` 中的状态变为 `HURT` 时，有一些事情要做：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Not only does does the player lose a life, but they are also bounced up and
    away from the damaging object. After a short time, the state changes back to `IDLE`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家会失去生命，他们还会被弹起并远离造成伤害的对象。经过一段时间后，状态会变回 `IDLE`。
- en: 'Also, input will be disabled while the player is in the `HURT` state. Add this
    to the beginning of `get_input()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当玩家处于 `HURT` 状态时，输入将被禁用。将此添加到 `get_input()` 的开头：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the player is ready to take damage once the rest of the game is set up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当游戏的其他部分设置好后，玩家就可以开始承受伤害了。
- en: Collectible items
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集物品
- en: 'Before you start making the level, you need to create some pickups for the
    player to collect, since those will be part of the level as well. The `assets/sprites`
    folder contains sprite sheets for two types of collectibles: cherries and gems.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始制作关卡之前，你需要为玩家创建一些可以收集的拾取物，因为那些也将是关卡的一部分。`assets/sprites` 文件夹包含两种类型收集物的精灵图集：樱桃和宝石。
- en: 'Rather than make separate scenes for each type of item, you can use a single
    scene and merely swap out the sprite sheet texture. Both objects will have the
    same behavior: animating in place and disappearing (that is, being collected)
    when contacted by the player. You can also add a `Tween` animation for the pickup
    (see [Chapter 1](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml), *Introduction*,
    for an example).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每种类型的物品制作单独的场景，你可以使用一个单独的场景，只需交换精灵图集纹理。这两个对象将具有相同的行为：在原地动画并消失（即被收集）当被玩家接触时。你还可以为拾取物添加一个
    `Tween` 动画（参见 [第 1 章](fee8a22d-c169-454d-be5e-cf6c0bc78ddb.xhtml)，*简介*，以获取示例）。
- en: Collectible scene
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集场景
- en: Start the new scene with an `Area2D` and name it `Collectible`. An area is a
    good choice for these objects because you want to detect when the player contacts
    them (using the `body_entered` signal), but you don't need collision response
    from them. In the Inspector, set the Collision/Layer to collectibles (layer 4)
    and the Collision/Mask to player (layer 2). This will ensure that only the `Player`
    node will be able to collect an item while the enemies will pass right through.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Area2D` 开始新的场景，并将其命名为 `Collectible`。选择区域作为这些对象是因为你想要检测玩家接触它们时的情况（使用 `body_entered`
    信号），但你不需要从它们那里获得碰撞响应。在检查器中，将碰撞/层设置为收集物（层 4）和碰撞/掩码设置为玩家（层 2）。这将确保只有 `Player` 节点能够收集物品，而敌人将直接穿过。
- en: 'Add three child nodes: `Sprite`, `CollisionShape2D`, and `AnimationPlayer`,
    then drag the `res://assets/cherry.png` Sprite sheet into the Sprite''s Texture.
    Set the Vframes to `1` and Hframes to `5`. Add a rectangle shape to `CollisionShape2D`
    and size it appropriately.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加三个子节点：`Sprite`、`CollisionShape2D` 和 `AnimationPlayer`，然后将 `res://assets/cherry.png`
    精灵图集拖放到 Sprite 的纹理中。将 Vframes 设置为 `1`，Hframes 设置为 `5`。向 `CollisionShape2D` 添加一个矩形形状，并适当地调整其大小。
- en: As a general rule, you should size your objects' collision shapes so that they
    benefit the player. This means that enemy hitboxes should generally be a little
    smaller than the image while the hitboxes of beneficial items should be slightly
    oversized. This reduces player frustration and results in a better gameplay experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该调整你对象的碰撞形状，以便它们对玩家有益。这意味着敌人的击中框应该通常比图像略小，而有益物品的击中框应该略大。这减少了玩家的挫败感，并导致更好的游戏体验。
- en: Add a new animation to `AnimationPlayer` (you only need one, so you can just
    name it `anim`). Set the Length to `1.6` seconds and the Step to `0.2` seconds.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `AnimationPlayer` 添加一个新的动画（你只需要一个，所以你可以直接命名为 `anim`）。将长度设置为 `1.6` 秒，步长设置为
    `0.2` 秒。
- en: 'Set the Sprite''s Frame property to `0` and click the keyframe button to create
    the track. When you reach frame number four, start reversing the order back down
    to `1`. The full sequence of keyframes should be:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将精灵的帧属性设置为`0`并点击关键帧按钮以创建轨迹。当你达到帧编号四时，开始反向顺序回到`1`。完整的关键帧序列应该是：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Enable looping and press the Play button. Now, you have a nicely animated cherry!
    Drag `res://assets/gem.png` into the texture and check that it animates as well.
    Finally, click the Autoplay on Load button to ensure the animation will play automatically
    when the scene begins. Refer to the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启用循环并按播放按钮。现在，你有一个很棒的樱桃动画！将`res://assets/gem.png`拖入纹理并检查它是否也动画。最后，点击自动播放按钮以确保动画在场景开始时自动播放。参见图表：
- en: '![](img/000f2f26-a3f7-44ee-854a-3f2b6b2e6391.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/000f2f26-a3f7-44ee-854a-3f2b6b2e6391.png)'
- en: Collectible script
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集品脚本
- en: 'The Collectible''s script needs to do two things:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 收集品的脚本需要做两件事：
- en: Set the start conditions (`texture` and `position`)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始条件（`texture`和`position`）
- en: Detect when the player enters the area
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测玩家进入区域
- en: 'For the first part, add the following code to the new script:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一部分，将以下代码添加到新脚本中：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `pickup` signal will be emitted when the player collects the item. In the
    `textures` dictionary, you have a list of the item types and their corresponding
    texture locations. Note that you can quickly paste those file paths by right-clicking
    on the file in the FileSystem dock and choosing Copy Path:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家收集物品时，将发出`pickup`信号。在`textures`字典中，你有一个物品类型及其对应纹理位置的列表。注意，你可以通过在文件系统窗口中右键单击文件并选择复制路径来快速粘贴这些文件路径：
- en: '![](img/89e5faff-b388-4b81-88e3-a6c2e26ae3e4.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89e5faff-b388-4b81-88e3-a6c2e26ae3e4.png)'
- en: Next, you have an `init()` function that sets the `texture` and `position` to
    the given values. The level script will use this function to spawn all the collectibles
    that you add to your level map.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将有一个`init()`函数，该函数将`texture`和`position`设置为给定的值。关卡脚本将使用此函数来生成你添加到关卡地图中的所有可收集物品。
- en: 'Finally, you need the object to detect when it''s been picked up. Click on
    the `Area2D` and connect its `body_entered` signal. Add the following code to
    the created function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要对象检测它何时被拾起。点击`Area2D`并连接其`body_entered`信号。将以下代码添加到创建的函数中：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Emitting the signal will allow the game's script to react appropriately to the
    item pickup. It can add to the score, increase the player's speed, or whatever
    other effect you want the item to apply.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 发出信号将允许游戏脚本适当地对物品拾取做出反应。它可以增加分数、提高玩家的速度，或者产生你希望物品产生的任何其他效果。
- en: Designing the level
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计关卡
- en: It wouldn't be a platformer without jumps. For most readers, this section will
    take up the largest chunk of time. Once you start designing a level, you'll find
    it's a lot of fun to lay out all the pieces, creating challenging jumps, secret
    paths, and dangerous encounters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有跳跃，那就不是平台游戏。对于大多数读者来说，这部分将占用最多的时间。一旦你开始设计关卡，你会发现布置所有部件、创建挑战性跳跃、秘密路径和危险遭遇非常有趣。
- en: First, you'll create a generic `Level` scene containing all the nodes and code
    that is common to all levels. You can then create any number of level scenes that
    inherit from this master level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将创建一个通用的`Level`场景，其中包含所有级别共有的节点和代码。然后你可以创建任意数量的级别场景，这些场景将继承自这个主级别。
- en: TileSet configuration
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片集配置
- en: 'In the `assets` folder you downloaded at the beginning of the project is a
    `tilesets` folder. It contains three ready-made `TileSet` resources using the
    16x16 art for the game:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时下载的`assets`文件夹中有一个`tilesets`文件夹。它包含三个使用16x16艺术风格的现成`TileSet`资源：
- en: '`tiles_world.tres`: Ground and platform tiles'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_world.tres`：地面和平台瓦片'
- en: '`tiles_items.tres`: Decorative items, foreground objects, and collectibles'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_items.tres`：装饰物品、前景对象和可收集物品'
- en: '`tiles_spikes.tres`: Danger items'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tiles_spikes.tres`：危险物品'
- en: It is recommended that you use these tile sets to create the levels for this
    project. However, if you would rather make them yourself, the original art is
    in `res://assets/environment/layers`. See [Chapter 2](a56e3c2d-5d7f-41d6-98c4-c1d95e17fc31.xhtml),
    *Coin Dash*, to review how to create a `TileSet` resource.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你使用这些瓦片集来创建本项目的关卡。然而，如果你更愿意自己制作，原始艺术作品在`res://assets/environment/layers`中。参见[第2章](a56e3c2d-5d7f-41d6-98c4-c1d95e17fc31.xhtml)，*Coin
    Dash*，以复习如何创建`TileSet`资源。
- en: Base-level setup
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设置
- en: Create a new scene and add a `Node2D` named `Level`. Save the scene in a new
    folder called `levels`. This is where you'll save any other levels you create,
    after inheriting from `Level.tscn`. The node hierarchy will be the same for all
    levels—only the layout will be different.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为 `Level` 的 `Node2D`。将场景保存在一个名为 `levels` 的新文件夹中。这是你保存任何其他从 `Level.tscn`
    继承而来的关卡的地方。所有关卡中的节点层次结构都将相同——只有布局会有所不同。
- en: 'Next, add a `TileMap` and set its Cell/Size to `(16, 16)`, then duplicate it
    three times (press *Ctrl* + *D* to duplicate a node). These will be the layers
    of your level, holding different tiles and information about the layout. Name
    the four `TileMap` instances as follows and drag-and-drop the corresponding `TileSet`
    into the Tile Set property of each. Refer to the following table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `TileMap` 并将其 Cell/Size 设置为 `(16, 16)`，然后将其复制三次（按 *Ctrl* + *D* 来复制一个节点）。这些将成为你的关卡层，持有不同的瓦片和布局信息。以下是对四个
    `TileMap` 实例的命名和将相应的 `TileSet` 拖放到每个的 Tile Set 属性中的说明。参考以下表格：
- en: '| **TileMap** | **Tile Set** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **TileMap** | **Tile Set** |'
- en: '| `World` | `tiles_world.tres` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `World` | `tiles_world.tres` |'
- en: '| `Objects` | `tiles_items.tres` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Objects` | `tiles_items.tres` |'
- en: '| `Pickups` | `tiles_items.tres` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `拾取物` | `tiles_items.tres` |'
- en: '| `Danger` | `tiles_spikes.tres` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `Danger` | `tiles_spikes.tres` |'
- en: It's a good idea to press the Lock button on your `TileMap` nodes to prevent
    accidentally moving them while you're working on your map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在你工作在地图上时，按下你的 `TileMap` 节点的锁定按钮是个好主意，以防止意外移动它们。
- en: 'Next, add an instance of the `Player` scene and a `Position2D` named `PlayerSpawn`.
    Click the hide button on the `Player`—you''ll use `show()` in the level script
    to make the player appear when it starts. Your scene tree should now look like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `Player` 的 `Player` 场景和一个名为 `PlayerSpawn` 的 `Position2D`。点击 `Player`
    上的隐藏按钮——你将在关卡脚本中使用 `show()` 来使玩家在开始时出现。你的场景树现在应该看起来像这样：
- en: '![](img/b630e32e-b24c-4bba-b472-2cbb11d4b4ce.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b630e32e-b24c-4bba-b472-2cbb11d4b4ce.png)'
- en: 'Attach a script to the `Level` node:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本附加到 `Level` 节点上：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Later, you'll be scanning the `Pickups` map to spawn collectible items in the
    designated locations. This map layer itself shouldn't be seen, but rather than
    set it as hidden in the scene tree, which is easy to forget before you run the
    game, you can make sure it's always hidden during gameplay by doing so in `_ready()`.
    Because there will be many references to the node, storing the result of `$Pickups`
    in the `pickups` variable will cache the result. (Remember, `$NodeName` is the
    same as writing `get_node("NodeName")`.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将扫描 `Pickups` 地图以在指定位置生成可收集物品。这个地图层本身不应该被看到，但与其在场景树中将它设置为隐藏，这很容易在运行游戏前忘记，你可以在
    `_ready()` 中确保它在游戏过程中始终隐藏。这样做可以缓存结果，因为会有许多对节点的引用。（记住，`$NodeName` 与写入 `get_node("NodeName")`
    相同。）
- en: Designing the first level
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计第一个关卡
- en: Now, you're ready to start drawing the level! Click Scene | New Inherited Scene
    and choose `Level.tscn`. Name the new node `Level01` and save it (still in the
    `levels` folder).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好开始绘制关卡了！点击场景 | 新继承场景并选择 `Level.tscn`。将新节点命名为 `Level01` 并保存（仍在 `levels`
    文件夹中）。
- en: Start with the `World` map and be creative. Do you like lots of jumps, or twisty
    tunnels to explore? Long runs, or careful upward climbs?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `World` 地图开始，发挥创意。你喜欢有很多跳跃，还是曲折的隧道去探索？是长跑，还是小心翼翼的向上攀登？
- en: Before going too far in your design, experiment with jump distance. You can
    change the Player's `jump_speed`, `run_speed`, and `gravity` properties to alter
    how high and how far they can jump. Set up some different gap sizes and run the
    scene to try them out. Don't forget to drag the `PlayerSpawn` node to the place
    you want the character to start.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的设计深入之前，尝试跳跃距离。你可以通过改变玩家的 `jump_speed`、`run_speed` 和 `gravity` 属性来改变他们能跳多高和多远。设置一些不同的间隙大小并运行场景来尝试它们。别忘了将
    `PlayerSpawn` 节点拖到你想让角色开始的地方。
- en: 'For example, can the player make this jump? Take a look at the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，玩家能完成这个跳跃吗？看看下面的截图：
- en: '![](img/a9e809ba-1ebf-4170-aef8-eb8e7de47bdc.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9e809ba-1ebf-4170-aef8-eb8e7de47bdc.png)'
- en: How you set the player's movement properties will have a big impact on how your
    level should be laid out. Make sure you're happy with your settings before spending
    too much time on the full design.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何设置玩家的移动属性将对你的关卡布局产生重大影响。在花费太多时间在设计之前，请确保你对你的设置感到满意。
- en: Once you have the `World` layer set up, use the `Objects` layer to place decorations
    and accents like plants, rocks, and vines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了 `World` 层，就使用 `Objects` 层来放置装饰和点缀，如植物、岩石和藤蔓。
- en: 'Use the `Pickups` layer to mark the locations you''ll spawn collectible items
    at. There are two kinds: gems and cherries. The tiles that spawn them are drawn
    with a magenta background to make them stand out. Remember, they''ll be replaced
    at runtime by the actual items and the tiles themselves won''t be seen.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Pickups` 层标记您将生成可收集物品的位置。有两种类型：宝石和樱桃。生成它们的瓦片以洋红色背景绘制，以便突出显示。记住，它们将在运行时被实际物品替换，而瓦片本身将不会被看到。
- en: 'Once you have your level laid out, you can limit the horizontal scrolling of
    the player camera to match the size of the map (plus a 5 tile buffer on each end):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您布置好关卡，您可以将玩家摄像机的水平滚动限制为与地图大小匹配（每端加 5 个瓦片缓冲区）：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The script also needs to scan the `Pickups` layer and look for the item markers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还需要扫描 `Pickups` 层并查找物品标记：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function uses `get_used_cells()` to get an array of the tiles that are
    in use on the `Pickups` map. The `TileMap` sets each tile's value to an `id` that
    references the individual tile object in the `TileSet`. You can then query the
    `TileSet` for the tile's name using `tile_set.tile_get_name()`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用 `get_used_cells()` 获取 `Pickups` 地图上正在使用的瓦片数组。`TileMap` 将每个瓦片的值设置为 `id`，该
    `id` 引用 `TileSet` 中的单个瓦片对象。然后，您可以使用 `tile_set.tile_get_name()` 查询 `TileSet` 以获取瓦片的名称。
- en: 'Add `spawn_pickups()` to `_ready()` and add the following at the top of the
    script:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_ready()` 中添加 `spawn_pickups()` 并在脚本顶部添加以下内容：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try running your level and you should see your gems and/or cherries appear where
    you placed them. Also check that they disappear when you run into them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行您的关卡，您应该会看到您放置的宝石和/或樱桃出现在它们所在的位置。同时检查它们在您遇到它们时是否会消失。
- en: Scrolling background
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动背景
- en: 'There are two background images in the `res://assets/environment/layers` folder:
    `back.png` and `middle.png`, for the far and near background, respectively. By
    placing these images behind the tilemap and scrolling them at different speeds
    relative to the camera, you can create an attractive illusion of depth in the
    background.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `res://assets/environment/layers` 文件夹中有两个背景图像：`back.png` 和 `middle.png`，分别用于远背景和近背景。通过将这些图像放置在瓦片地图后面并以相对于摄像机的不同速度滚动，您可以在背景中创建一个吸引人的深度错觉。
- en: To start, add a `ParallaxBackground` node to the `Level` scene. This node works
    automatically along with the camera to create a scrolling effect. Drag this node
    to the top of the scene tree so that it will be drawn behind the rest of the nodes.
    Next, add a `ParallaxLayer` node as a child—`ParallaxBackground` can have any
    number of `ParallaxLayer` as children, allowing you to make many independently
    scrolling layers. Add a `Sprite` node as a child to the `ParallaxLayer` and drag
    the `res://assets/environment/layers/back.png` image into the Texture. Important—uncheck
    the box next to the Centered property of the Sprite.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `ParallaxBackground` 节点添加到 `Level` 场景中。此节点与摄像机自动协同工作以创建滚动效果。将此节点拖动到场景树顶部，以便它将在其余节点之后绘制。接下来，添加一个
    `ParallaxLayer` 节点作为子节点——`ParallaxBackground` 可以有任意数量的 `ParallaxLayer` 子节点，允许您创建多个独立滚动的层。将一个
    `Sprite` 节点添加到 `ParallaxLayer` 作为子节点，并将 `res://assets/environment/layers/back.png`
    图像拖动到纹理中。重要提示——取消选中 Sprite 的 `Centered` 属性旁边的框。
- en: The background image is a little small, so set the Sprite's Scale to `(1.5,
    1.5)`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 背景图像有点小，因此将 Sprite 的缩放设置为 `(1.5, 1.5)`。
- en: On the `ParallaxLayer`, set the Motion/Scale to `(0.2, 1)`. This setting controls
    how fast the background scrolls in relation to the camera. By setting it to a
    low number, the background will only move a small amount as the player moves left
    and right.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ParallaxLayer` 上，将运动/缩放设置为 `(0.2, 1)`。此设置控制背景相对于摄像机的滚动速度。通过将其设置为低数值，背景将在玩家左右移动时仅移动一小段距离。
- en: Next, you want to be sure the image repeats if your level is very wide, so set
    Mirroring to `(576, 0)`. This is exactly the width of the image (`384` times `1.5`),
    so the image will be repeated when it has moved by that amount.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您要确保如果您的关卡非常宽，则图像会重复，因此将镜像设置为 `(576, 0)`。这正是图像的宽度（`384` 乘以 `1.5`），因此当图像移动了这么多距离时，它将重复。
- en: Note that this background is best for wide rather than tall levels. If you jump
    too high, you'll reach the top of the background image and suddenly see the grey
    emptiness again. You can fix this by setting the top limit of the camera. If you
    haven't moved it, the upper-left corner of the image will be at `(0, 0)`, so you
    can set the Top limit on the camera to `0`. If you've moved the `ParallaxLayer`,
    you can find the correct value by looking at the `y` value of the node's Position.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个背景最适合宽而不是高的关卡。如果你跳得太高，你会到达背景图像的顶部，然后突然看到灰色的空白。你可以通过设置摄像机的顶部限制来修复这个问题。如果你没有移动它，图像的左上角将位于`(0,
    0)`，所以你可以将摄像机的顶部限制设置为`0`。如果你已经移动了`ParallaxLayer`，你可以通过查看节点的位置`y`值来找到正确的值。
- en: Now, add another `ParallaxLayer` (as a sibling of the first) for the middle
    background layer and give it a `Sprite` child. This time, use the `res://assets/environment/layers/middle.png`
    texture. This texture is much narrower than the cloud/sky image, so you'll need
    to do a little extra adjustment to make it repeat properly. This is because the
    `ParallaxBackground` needs to have images that are at least as big as the viewport
    area.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为中间背景层添加另一个`ParallaxLayer`（作为第一个层的兄弟），并给它一个`Sprite`子项。这次，使用`res://assets/environment/layers/middle.png`纹理。这个纹理比云/天空图像窄得多，所以你需要做一些额外的调整来正确重复它。这是因为`ParallaxBackground`需要具有至少与视口区域一样大的图像。
- en: 'First, click on the texture in the FileSystem dock and select the Import tab.
    Change the Repeat property to Mirrored, and check `On` for Mipmaps. Press Reimport.
    Now, the texture can be repeated to fill the screen (and the parallax system will
    repeat it after that):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在FileSystem窗口中点击纹理，并选择导入标签页。将重复属性更改为镜像，并勾选Mipmaps的`On`选项。按重新导入。现在，纹理可以被重复以填充屏幕（并且透视系统将在之后重复它）：
- en: '![](img/05f28d13-c2a1-4865-87e9-8fff4d24c5c3.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05f28d13-c2a1-4865-87e9-8fff4d24c5c3.png)'
- en: 'The image''s original size is `176x368`, and it needs to be repeated horizontally.
    In the `Sprite` properties, click On for Region Enabled. Next, set the Rect property
    to `(0, 0, 880, 368)` (880 is 176 times 5, so you should now see five repetitions
    of the image). Move the `ParallaxLayer` so that the image overlaps the bottom
    half of the ocean/cloud image:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的原始大小是`176x368`，需要水平重复。在`Sprite`属性中，点击启用区域。接下来，将矩形属性设置为`(0, 0, 880, 368)`（880是176的5倍，所以你现在应该看到五次图片的重复）。移动`ParallaxLayer`，使图像重叠在海洋/云图像的下半部分：
- en: 'Set the `ParallaxLayer` Motion/Scale to `(0.6, 1)` and the Mirroring to `(880,
    0)`. Using a higher scale factor means this layer will scroll a little faster
    than the cloud layer behind it, giving a satisfying effect of depth, as shown
    in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ParallaxLayer`的移动/缩放设置为`(0.6, 1)`，镜像设置为`(880, 0)`。使用更高的缩放因子意味着这个层将比其后的云层滚动得更快，从而产生令人满意的深度效果，如以下截图所示：
- en: '![](img/dcaf7196-4bce-4ead-b030-97d9556707de.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcaf7196-4bce-4ead-b030-97d9556707de.png)'
- en: Once you're sure everything is working, try adjusting the Scale value for both
    layers and see how it changes. For example, try a value of `(1.2, 1)` on the middle
    layer for a much different visual effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定一切正常工作，尝试调整两个层的缩放值，看看它如何变化。例如，尝试在中间层使用`(1.2, 1)`的值，以获得不同的视觉效果。
- en: 'Your main scene''s tree should now look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你的主场景树现在应该看起来像这样：
- en: '![](img/878b5297-8c6e-4fed-b435-5dbd13a6f3c7.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/878b5297-8c6e-4fed-b435-5dbd13a6f3c7.png)'
- en: Dangerous objects
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 危险物体
- en: The Danger map layer is meant to hold the spike objects that will harm the player
    if they're touched. Try placing a few of them on your map where you can easily
    test running into them. Note that because of the way TileMaps work, colliding
    with *any* tile on this layer will cause damage to the player!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 危险地图层旨在存放那些如果被触碰会对玩家造成伤害的尖刺物体。尝试在你的地图上放置几个这样的物体，以便你可以轻松测试碰撞。请注意，由于TileMaps的工作方式，与该层上的任何**任何**瓷砖发生碰撞都会对玩家造成伤害！
- en: About slide collisions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于滑动碰撞
- en: When a `KinematicBody2D` is moved with `move_and_slide()`, it may collide with
    more than one object in a given frame. For example, when running into a corner,
    the character may hit the wall and the floor at the same time. You can use the
    `get_slide_count()` method to find out how many collisions occurred, and then
    get information about each collision with `get_slide_collision()`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`move_and_slide()`移动`KinematicBody2D`时，它可能在给定帧中与多个对象发生碰撞。例如，当撞到角落时，角色可能会同时撞到墙和地板。你可以使用`get_slide_count()`方法来找出发生了多少次碰撞，然后使用`get_slide_collision()`获取每次碰撞的信息。
- en: 'In the case of the `Player`, you want to detect when a collision occurs against
    the Danger `TileMap` object. You can do this just after using `move_and_slide()`
    in `Player.gd`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Player`，你想要检测当与 `Danger` `TileMap` 对象发生碰撞时。你可以在 `Player.gd` 中的 `move_and_slide()`
    使用后做这件事：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Before checking for a collision with `Danger`, you can check whether the player
    is already in the `HURT` state and skip checking if it is. Next, you must use
    `get_slide_count()` to iterate through any collisions that may have occurred.
    For each, you can check whether the `collider.name` is `Danger`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查与 `Danger` 的碰撞之前，你可以检查玩家是否已经处于 `HURT` 状态，如果是，则跳过检查。接下来，你必须使用 `get_slide_count()`
    来遍历可能发生的任何碰撞。对于每一个，你可以检查 `collider.name` 是否为 `Danger`。
- en: Run the scene and try running into one of the spike objects. Just like you wrote
    in the `hurt()` function previously, you should see the player change to the `HURT`
    state for a brief time before returning to `IDLE`. After three hits, the player
    enters the `DEAD` state, which currently sets the visibility to hidden.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景，并尝试撞到其中一个刺状物体。就像你之前在 `hurt()` 函数中写的，你应该看到玩家在短暂地变为 `HURT` 状态后返回到 `IDLE`。经过三次打击后，玩家进入
    `DEAD` 状态，目前这会将可见性设置为隐藏。
- en: Enemies
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人
- en: Currently, the map is very lonely, so it's time to add some enemies to liven
    things up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，地图非常冷清，所以是时候添加一些敌人来活跃气氛了。
- en: There are many different behaviors you could create for an enemy. For this project,
    the enemy will walk along a platform in a straight line and reverse direction
    when hitting an obstacle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为敌人创建许多不同的行为。对于这个项目，敌人将沿着平台直线行走，并在碰到障碍物时改变方向。
- en: Scene setup
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'Start with `KinematicBody2D` with three children: `Sprite`, `AnimationPlayer`,
    and `CollisionShape2D`. Save the scene as `Enemy.tscn` in a new folder called
    `enemies`. If you decide to add more enemy types to the game, you can save them
    all here.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `KinematicBody2D` 开始，有三个子节点：`Sprite`、`AnimationPlayer` 和 `CollisionShape2D`。将场景保存为
    `enemies` 文件夹中的 `Enemy.tscn`，在名为 `enemies` 的新文件夹中。如果你决定为游戏添加更多敌人类型，你都可以在这里保存。
- en: Set the body's collision layer to `enemies` and its collision masks to `environment`,
    `player`, and `enemies`. It's also useful to group the enemies, so click on the
    Node tab and add the body to a group called `enemies`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将身体的碰撞层设置为 `enemies`，其碰撞掩码设置为 `environment`、`player` 和 `enemies`。将敌人分组也很有用，因此点击节点标签，并将身体添加到名为
    `enemies` 的组中。
- en: 'Add the `res://assets/opossum.png` sprite sheet to the Sprite''s Texture. Set
    Vframes to `1` and Hframes to `6`. Add a rectangular collision shape that covers
    most (but not all) of the image, making sure that the bottom of the collision
    shape is aligned with the bottom of the image''s feet:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `res://assets/opossum.png` 精灵图集添加到精灵的纹理中。将 Vframes 设置为 `1`，Hframes 设置为 `6`。添加一个矩形碰撞形状，覆盖图像的大部分（但不是全部），确保碰撞形状的底部与图像脚部的底部对齐：
- en: '![](img/e9769599-59d2-4ea3-8959-b7aa09d935b9.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9769599-59d2-4ea3-8959-b7aa09d935b9.png)'
- en: Add a new animation to the `AnimationPlayer` called `walk`. Set the Length to
    `0.6` seconds and the Step to `0.1` seconds. Turn on Looping and Autoplay.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `AnimationPlayer` 添加一个新的动画，名为 `walk`。将长度设置为 `0.6` 秒，步长设置为 `0.1` 秒。开启循环和自动播放。
- en: 'The `walk` animation will have two tracks: one that sets the Texture property
    and one that changes the Frame property. Click the Add keyframe button next to
    Texture once to add the first track, then click the one next to Frame and repeat
    until you have frames `0` through `5`. Press Play and verify that the walk animation
    is playing correctly. The Animation panel should look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk` 动画将有两个轨道：一个设置纹理属性，一个改变帧属性。点击 Texture 旁边的添加关键帧按钮一次以添加第一个轨道，然后点击 Frame
    旁边的按钮并重复，直到你有帧 `0` 到 `5`。按播放并验证行走动画是否正确播放。动画面板应该看起来像这样：'
- en: '![](img/29c8b6f3-b0ae-4b7c-a79c-830c57652f34.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/29c8b6f3-b0ae-4b7c-a79c-830c57652f34.png)'
- en: Script
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Add the following script:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下脚本：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this script, the `facing` variable tracks the direction of movement (`1`
    or `-1`). As with the player, when moving, you iterate through the slide collisions.
    If the colliding object is the `Player`, you call its `hurt()` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`facing` 变量跟踪移动方向（`1` 或 `-1`）。与玩家一样，在移动时，你遍历滑动碰撞。如果碰撞的对象是 `Player`，你调用它的
    `hurt()` 函数。
- en: Next, you can check whether the colliding body's normal vector has an `x` component
    that isn't `0`. This means it points to the left or right (that is, it is a wall,
    crate, or other obstacle). The direction of the *normal* is used to set the new
    facing. Finally, giving the body a small upward velocity will make the reverse
    transition look more appealing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以检查碰撞体的法线向量是否有非`0`的`x`分量。这意味着它指向左边或右边（即它是一堵墙、一个箱子或其他障碍物）。法线的方向用于设置新的朝向。最后，给身体一个小的向上速度会使反向过渡看起来更吸引人。
- en: Lastly, if, for some reason, the enemy does fall off a platform, you don't want
    the game to have to track it falling forever, so delete any enemy whose *y* coordinate
    becomes too big.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果由于某种原因，敌人从平台上掉落，你不想让游戏无限期地跟踪它的掉落，因此删除任何**y**坐标变得太大的敌人。
- en: Set Speed to `50` and Gravity to `900` in the Inspector, and then create an
    `Enemy` in your level scene. Make sure it has an obstacle on either side, and
    play the scene. Check that the enemy walks back and forth between the obstacles.
    Try putting the player in its path and verify that the player's `hurt()` method
    is getting called.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中设置速度为`50`和重力为`900`，然后在你的关卡场景中创建一个`Enemy`。确保它两侧都有一个障碍物，并播放场景。检查敌人是否在障碍物之间来回走动。尝试将玩家放在它的路径上，并验证玩家的`hurt()`方法是否被调用。
- en: Damaging the enemy
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 损害敌人
- en: It's not fair if the player can't strike back, so in the tradition of Super
    Mario Bros., jumping on top of the enemy will defeat it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家不能反击，那就显得不公平了，所以按照《超级马里奥兄弟》的传统，跳到敌人的上方可以击败它。
- en: Start by adding a new animation to the `AnimationPlayer` of the `Enemy` and
    name it `death`. Set the Length to `0.3` seconds and the Step to `0.05`. *Don't*
    turn on looping for this animation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先向`Enemy`的`AnimationPlayer`添加一个新的动画，命名为`death`。将长度设置为`0.3`秒，步长设置为`0.05`。**不要**为这个动画开启循环。
- en: This animation will also set the Texture and Frame. This time, drag the `res://assets/enemy-death.png` image
    into the Sprite's Texture before adding the keyframe for that property. As before,
    keyframe all the `Frame` values from `0` through `5`. Press Play to see the death
    animation run.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画还会设置纹理和帧。这次，在为该属性添加关键帧之前，将`res://assets/enemy-death.png`图像拖到Sprite的纹理中。和之前一样，将所有从`0`到`5`的`Frame`值都设置为关键帧。按播放键查看死亡动画的运行。
- en: 'Add the following code to the Enemy''s script:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Enemy`的脚本中：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the `Player` hits the `Enemy` under the right conditions, it will call
    `take_damage()`, which plays the `death` animation. It also disables collision
    and movement for the duration of the animation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Player`在合适的条件下击中`Enemy`时，它会调用`take_damage()`函数，播放`death`动画。同时，在动画持续期间禁用碰撞和移动。
- en: 'When the `death` animation finishes, it''s OK to remove the enemy, so connect
    the `animation_finished()` signal of `AnimationPlayer`. This signal is called
    every time an animation finishes, so you need to check that it''s the correct
    one:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当`death`动画结束时，可以移除敌人，因此连接`AnimationPlayer`的`animation_finished()`信号。这个信号在每次动画结束时都会被调用，所以你需要检查它是否是正确的：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To complete the process, go to the `Player.gd` script and add the following
    to the collision checks in the `_physics_process()` method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个过程，转到`Player.gd`脚本，并在`_physics_process()`方法中的碰撞检查中添加以下内容：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code checks the *y* coordinate of the player's feet (that is, the bottom
    of its collision shape) against the enemy's *y* coordinate. If the player is higher,
    the enemy is hurt; otherwise, the player is.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查玩家脚下的**y**坐标（即碰撞形状的底部）与敌人的**y**坐标。如果玩家更高，敌人会受到伤害；否则，玩家会受到伤害。
- en: Run the level and try jumping on the enemy to make sure all is working as expected.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 运行关卡，并尝试跳到敌人身上以确保一切按预期工作。
- en: HUD
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HUD
- en: The purpose of the HUD is to display the information the player needs to know
    during gameplay. Collecting items will increase the player's score, so that information
    needs to be displayed. The player also needs to see their remaining life value,
    which will be displayed as a series of hearts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: HUD（用户界面）的作用是在游戏过程中显示玩家需要知道的信息。收集物品会增加玩家的分数，因此需要显示这一信息。玩家还需要看到他们剩余的生命值，这将以一系列心形图案显示。
- en: Scene setup
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'Create a new scene with a `MarginContainer` node. Name it `HUD` and save in
    the `ui` folder. Set the Layout to Top Wide. In the Custom Constants section of
    Inspector, set the following values:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，使用`MarginContainer`节点。将其命名为`HUD`并保存在`ui`文件夹中。将布局设置为顶部宽。在检查器的`Custom
    Constants`部分，设置以下值：
- en: 'Margin Right: `50`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧边距：`50`
- en: 'Margin Top: `20`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部边距：`20`
- en: 'Margin Left: `50`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧边距：`50`
- en: 'Margin Bottom: `20`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部边距：`20`
- en: 'Add an `HBoxContainer`. This node will contain all the UI elements and keep
    them aligned. It will have two children:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`HBoxContainer`。此节点将包含所有UI元素并保持它们对齐。它将有两个子节点：
- en: '`Label`: `ScoreLabel`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`: `得分标签`'
- en: '`HBoxContainer`: `LifeCounter`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HBoxContainer`: `生命计数器`'
- en: On the `ScoreLabel`, set the Text property to `1`, and under Size Flags, set
    Horizontal to Fill and Expand. Add a custom `DynamicFont` using `res://assets/Kenney
    Thick.ttf` from the `assets` folder, with a font size of `48`. In the Custom Colors section,
    set the Font Color to `white` and the Font Color Shadow to `black`. Finally, under
    Custom Constants, set Shadow Offset X, Shadow Offset Y, and Shadow As Outline all
    to `5`. You should see a large white 1 with a black outline.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScoreLabel`上，将文本属性设置为`1`，在大小标志下，将水平设置为填充和扩展。从`assets`文件夹中添加一个自定义的`DynamicFont`，使用`res://assets/Kenney
    Thick.ttf`，字体大小为`48`。在自定义颜色部分，将字体颜色设置为`白色`，字体颜色阴影设置为`黑色`。最后，在自定义常量下，将阴影偏移X、阴影偏移Y和阴影轮廓都设置为`5`。你应该看到一个带有黑色轮廓的大白色1。
- en: 'For the `LifeCounter`, add a `TextureRect` and name it `L1`. Drag `res://assets/heart.png` into
    its Textureand set Stretch Mode to `Keep Aspect Centered`. Click on the node and
    press *Ctrl* + *D* four times so that you have a row of five hearts:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`LifeCounter`，添加一个`TextureRect`并将其命名为`L1`。将`res://assets/heart.png`拖入其纹理中，并将拉伸模式设置为`保持纵横比居中`。点击节点并按*Ctrl*
    + *D*四次，以便得到一排五个心形：
- en: '![](img/110efd8f-ca68-4a52-b9ba-9ad22b519888.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/110efd8f-ca68-4a52-b9ba-9ad22b519888.png)'
- en: 'When finished, your HUD should look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的HUD应该看起来像这样：
- en: '![](img/1941405b-71ea-4c2b-bc8d-e485da4a2c77.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1941405b-71ea-4c2b-bc8d-e485da4a2c77.png)'
- en: Script
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Here is the script for the `HUD`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`HUD`的脚本：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, you make an array of references to the five heart indicators. Then, in
    `_on_Player_life_changed()`, which will be called when the player gets hurt or
    healed, you calculate how many hearts to display by setting `visible` to `false`
    if the number of the heart is less than the life amount.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个指向五个心形指示器的引用数组。然后，在`_on_Player_life_changed()`中，当玩家受伤或治愈时将被调用，你通过将心形数量设置为小于生命值的`false`来计算要显示的心形数量。
- en: '`_on_score_changed()` is similar, changing the value of the `ScoreLabel` when
    called.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_score_changed()`类似，在调用时更改`ScoreLabel`的值。'
- en: Attaching the HUD
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加HUD
- en: Open `Level.tscn` (the base-level scene, *not* your `Level01` scene) and add
    a `CanvasLayer` node. Instance the `HUD` scene as a child of this `CanvasLayer`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Level.tscn`（基础关卡场景，*不是*你的`Level01`场景）并添加一个`CanvasLayer`节点。将`HUD`场景作为此`CanvasLayer`的子节点实例化。
- en: 'Click on the `Player` node and connect its `life_changed` signal to the HUD''s
    `_on_Player_life_changed()` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`Player`节点，将其`life_changed`信号连接到HUD的`_on_Player_life_changed()`方法：
- en: '![](img/238d3a25-9ecc-4643-b79a-2826c566ac7f.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/238d3a25-9ecc-4643-b79a-2826c566ac7f.png)'
- en: Next, do the same with the `score_changed` signal of the `Level` node, connecting
    it to the HUD's `_on_score_changed`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对`Level`节点的`score_changed`信号做同样的操作，将其连接到HUD的`_on_score_changed`。
- en: '**Alternative method: **Note that if you don''t want to use the scene tree
    to connect the signals, or if you find the signal connection window confusing,
    you can accomplish the same thing in code by adding these two lines to the `_ready()`
    function of `Level.gd`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代方法：**注意，如果你不想使用场景树来连接信号，或者如果你觉得信号连接窗口令人困惑，你可以在`Level.gd`的`_ready()`函数中通过添加这两行代码来在代码中完成相同的事情：'
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run your level and verify that you gain points when collecting items and lose
    hearts when getting hurt.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的关卡并验证在收集物品时获得分数，在受伤时失去心形。
- en: Title screen
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题屏幕
- en: The title screen is the first scene the player will see. When the player dies,
    the game will return to this scene and allow you to restart.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕是玩家将看到的第一个场景。当玩家死亡时，游戏将返回到这个场景并允许你重新开始。
- en: Scene setup
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start with a `Control` node and set the Layout to Full Rect.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个`Control`节点开始，并将布局设置为全矩形。
- en: Add a `TextureRect`. Set its Texture to `res://assets/environment/layers/back.png`,
    Layout to Full Rect, and Stretch Mode to Keep Aspect Covered.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TextureRect`。将其纹理设置为`res://assets/environment/layers/back.png`，布局设置为全矩形，拉伸模式设置为`保持纵横比覆盖`。
- en: Add another `TextureRect`, this time with the Texture using `res://assets/environment/layers/middle.png` and
    the Stretch Mode set to Tile. Drag the width of the rectangle until it's wider
    than the screen and arrange it so it covers the bottom half of the screen.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个`TextureRect`，这次使用`res://assets/environment/layers/middle.png`作为纹理，并将拉伸模式设置为平铺。拖动矩形的宽度，直到它比屏幕宽，并调整它以覆盖屏幕的下半部分。
- en: 'Next, add two `Label` nodes (`Title` and `Message`) and set their Custom Font settings
    using the same options you used earlier for the score label. Set their Text properties
    to Jungle Jump and Press Space to Play, respectively. When you''re finished, the
    screen should look like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加两个`Label`节点（`Title`和`Message`），并使用之前为分数标签使用的相同选项设置它们的自定义字体设置。将它们的文本属性分别设置为Jungle
    Jump和按空格键开始游戏。完成时，屏幕应如下所示：
- en: '![](img/9e1e4a3a-9f03-4141-8249-b15a3ab77852.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e1e4a3a-9f03-4141-8249-b15a3ab77852.png)'
- en: To make the title screen a bit more interesting, add an `AnimationPlayer` node
    and create a new animation. Name it `anim` and set it to autoplay. In this animation,
    you can animate the various components of the screen to make them move, appear,
    fade in, or any other effect you like.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使标题屏幕更有趣，添加一个`AnimationPlayer`节点并创建一个新的动画。将其命名为`anim`并设置为自动播放。在这个动画中，你可以动画化屏幕的各种组件，使它们移动、出现、淡入或任何你喜欢的效果。
- en: Drag the Title label to a position above the top of the screen and add a keyframe.
    Then, drag it back (or manually type the values in Position) and set another keyframe
    at around `0.5` seconds. Feel free to add tracks that are animating the other
    nodes' properties.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题标签拖动到屏幕顶部的上方并添加一个关键帧。然后，将其拖回（或手动输入位置值）并在大约`0.5`秒处设置另一个关键帧。你可以自由地添加动画其他节点属性的轨迹。
- en: 'For example, here is an animation that drops the title down, fades in the two
    textures, and then makes the message appear (note the names of the properties
    that are modified by each track):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个动画，将标题向下移动，淡入两个纹理，然后使消息出现（注意每个轨迹修改的属性名称）：
- en: '![](img/eddd2404-eb55-4507-8a54-85f3a515f4c7.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eddd2404-eb55-4507-8a54-85f3a515f4c7.png)'
- en: Main scene
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主场景
- en: 'Delete the extra nodes you added to your temporary `Main.tscn` (the `Player`
    instance and the test `StaticBody2D`). This scene will now be responsible for
    loading the current level. Before it can do that, however, you need an Autoload
    script to track the game state: variables such as `current_level` and other data
    that needs to be carried from scene to scene.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 删除你添加到临时`Main.tscn`（`Player`实例和测试`StaticBody2D`）中的额外节点。现在，这个场景将负责加载当前级别。然而，在它能够这样做之前，你需要一个自动加载脚本来跟踪游戏状态：例如`current_level`和其他需要在场景间传递的数据。
- en: 'Add a new script called `GameState.gd` in the Script editor and add the following
    code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本编辑器中添加一个名为`GameState.gd`的新脚本，并添加以下代码：
- en: '[PRE26]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that you should set `num_levels` to the number of levels you've made in
    the `levels` folder. Make sure to name them consistently (`Level01.tscn`, `Level02.tscn`,
    and so on) and then you can automatically load the next one in the sequence.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你应该将`num_levels`设置为你在`levels`文件夹中创建的级别数量。确保它们命名一致（`Level01.tscn`、`Level02.tscn`等等），然后你可以自动加载序列中的下一个。
- en: 'Add this script in the AutoLoad tab of Project Settings, and add this script
    to `Main`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置的自动加载选项卡中添加此脚本，并将此脚本添加到`Main`中：
- en: '[PRE27]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, whenever the `Main` scene is loaded, it will load the level scene corresponding
    to `GameState.current_level`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当加载`Main`场景时，它将加载与`GameState.current_level`对应的级别场景。
- en: 'The title screen needs to transition to the game scene, so attach this script
    to the `TitleScreen` node:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕需要转换到游戏场景，因此将此脚本附加到`TitleScreen`节点：
- en: '[PRE28]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also call the restart function when the player dies by adding it to
    the method in `Level.gd`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将重启函数添加到`Level.gd`中的方法来在玩家死亡时调用它：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Level transitions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 能级转换
- en: Your levels now need a way to transition from one to the next. In the `res://assets/environment/layers/props.png` sprite
    sheet, there is an image of a door that you can use for your level's exit. Finding
    and walking into the door will result in the player moving to the next level.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你的级别现在需要一种从一级转换到下一级的方式。在`res://assets/environment/layers/props.png`精灵图集中，有一个你可以用于你级别出口的门图像。找到并走进门会导致玩家移动到下一级。
- en: Door scene
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 门场景
- en: Make a new scene with an `Area2D` named `Door` and save it in the `items` folder.
    Add a `Sprite` and use the `res://assets/environment/layers/props.png` sprite
    sheet along with the *Region* setting to select the door image, then attach a
    rectangular `CollisionShape2D`. This scene doesn't need a script, because you're
    just going to use the area's `body_entered` signal.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`items`文件夹中创建一个新的场景，命名为`Door`，并保存。添加一个`Sprite`，使用`res://assets/environment/layers/props.png`精灵图集，并使用`Region`设置来选择门图像，然后附加一个矩形`CollisionShape2D`。这个场景不需要脚本，因为你只是将要使用区域的`body_entered`信号。
- en: Put the door on the `collectibles` layer and set its mask to only scan the `player`
    layer.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 将门放在 `collectibles` 层上，并设置其遮罩只扫描 `player` 层。
- en: 'Instance this door scene in your first level and put it somewhere that the
    player can reach. Click on the `Door` node and connect the `body_entered` signal
    to the `Level.gd` script where you can add this code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一个关卡中实例化这个门场景，并将其放置在玩家可以到达的地方。点击 `Door` 节点，将 `body_entered` 信号连接到 `Level.gd`
    脚本，你可以在那里添加以下代码：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the game and try running into the door to check that it immediately transfers
    to the next level.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，尝试撞上门以检查它是否立即转移到下一个关卡。
- en: Finishing touches
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Now that you've completed the structure of the game, you can consider some additions
    so that you can add more game features, more visual effects, additional enemies,
    or other ideas you might have. In this section, there are a few suggested features—add
    them as-is or adjust them to your liking.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了游戏的结构，你可以考虑添加一些内容，以便你可以添加更多游戏功能、更多视觉效果、额外的敌人，或者你可能有的其他想法。在本节中，有一些建议的功能——你可以直接添加它们，或者根据你的喜好进行调整。
- en: Sound effects
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音效
- en: 'As with the previous projects, you can add audio effects and music to improve
    the gameplay experience. In the `res://assets/audio` folder, you''ll find a number
    of files you can use for various game events, such as player jump, enemy hit and
    pickup. There are also two music files: Intro Theme for the title screen and Grasslands
    Theme for the level scenes.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你可以添加音效和音乐来改善游戏体验。在 `res://assets/audio` 文件夹中，你可以找到可用于各种游戏事件（如玩家跳跃、敌人击中和拾取）的多个文件。还有两个音乐文件：标题屏幕的Intro
    Theme和关卡场景的Grasslands Theme。
- en: 'Adding these to the game will be left to you, but here are a few tips:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些添加到游戏中将由你来决定，但这里有一些小贴士：
- en: Make sure the sound effects have Loop set to Off while the music files have
    it On in the Import settings tab.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在导入设置选项卡中，音效的 Loop 设置为关闭，而音乐文件的 Loop 设置为开启。
- en: You may find it helpful to adjust the volume of individual sounds. This can
    be set with the Volume Db property. Setting a negative value will reduce the sound's
    volume.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能发现调整单个声音的音量很有帮助。这可以通过 `Volume Db` 属性设置。设置负值将降低声音的音量。
- en: You can attach music to the master `Level.tscn` and that music will be used
    for all levels (set the `AudioStreamPlayer` to Autoplay).
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将音乐附加到主 `Level.tscn`，并且该音乐将用于所有关卡（将 `AudioStreamPlayer` 设置为自动播放）。
- en: You an also attach separate music to individual levels if you want to set a
    certain mood.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要为单个关卡设置特定的氛围，你也可以为它们附加单独的音乐。
- en: Infinite falling
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限坠落
- en: 'Depending on how you''ve designed your levels, it may be possible for the player
    to fall off the level entirely. Typically, you want to design things so that this
    isn''t possible by using walls that are too high to jump, spikes at the bottom
    of pits, and so on. However, in case it does happen, add the following code to
    the player''s `_physics_process()` method:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你如何设计你的关卡，玩家可能完全掉出关卡。通常，你希望通过使用太高而无法跳跃的墙壁、坑底的尖刺等方式来设计，这样就不会发生这种情况。但是，如果确实发生了，请将以下代码添加到玩家的
    `_physics_process()` 方法中：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that if you've designed a level that extends below a `y` of `1000`, you'll
    need to increase the value to prevent accidental death.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你设计的关卡延伸到 `y` 坐标 `1000` 以下，你需要增加该值以防止意外死亡。
- en: Double jump
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双重跳跃
- en: Double-jumps are a popular platforming feature. The player gets a second, usually
    smaller, upwards boost if they press the jump key a second time while in the air.
    To implement this feature, you need to add a few things to the player script.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 双重跳跃是流行的平台游戏功能。如果玩家在空中按下跳跃键第二次，他们将获得第二次，通常是较小的向上推力。要实现此功能，你需要向玩家脚本中添加一些内容。
- en: 'First, you will need two variables to track the state:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要两个变量来跟踪状态：
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When entering the `JUMP` state, reset the number of jumps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入 `JUMP` 状态时，重置跳跃次数：
- en: '[PRE33]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, in `get_input()`, allow the jump if it meets the conditions:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `get_input()` 函数中，如果满足条件则允许跳跃：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that this makes the second jump 2/3 the upward speed of the normal jump.
    You can adjust this according to your preferences.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这会使第二次跳跃的速度是正常跳跃的2/3。你可以根据你的喜好进行调整。
- en: Dust particles
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰尘颗粒
- en: Dust particles at the character's feet are a low-effort effect that can add
    a lot of character to your player's movements. In this section, you'll add a small
    puff of dust to the player's feet that is emitted whenever they land on the ground.
    This adds a sense of weight and impact to the player's jumps.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 角色脚下的尘埃粒子是一种低成本的特效，可以为玩家的动作增添许多特色。在本节中，你将为玩家的脚部添加一小股尘埃，每当他们落地时都会发射。这为玩家的跳跃增添了重量感和冲击感。
- en: 'Add a `Particles2D` node and name it `Dust`. Note the warning that a process
    material must be added. First, however, set the properties of the `Dust` node:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Particles2D`节点并将其命名为`Dust`。注意必须添加处理材质的警告。首先，设置`Dust`节点的属性：
- en: '| **Property** | **Value** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值** |'
- en: '| Amount | `20` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | `20` |'
- en: '| Lifetime | `0.45` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 生命周期 | `0.45` |'
- en: '| One Shot | `On` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 单次发射 | `On` |'
- en: '| Speed Scale | `2` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 速度缩放 | `2` |'
- en: '| Explosiveness | `0.7` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 爆炸性 | `0.7` |'
- en: '| Local Coords | `Off` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 本地坐标 | `Off` |'
- en: '| Position | `(-2, 15)` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `(-2, 15)` |'
- en: '| Rotation | `-90` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | `-90` |'
- en: 'Now, under Process Material, add a new `ParticlesMaterial`. Click on it and
    you''ll see all the particle settings. Here are the ones you need for the dust
    effect:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“处理材质”下添加一个新的`ParticlesMaterial`。点击它，你会看到所有的粒子设置。以下是实现尘埃效果所需的设置：
- en: '| **Particle Property** | **Value** |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **粒子属性** | **值** |'
- en: '| Emission Shape | `Box` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 发射形状 | `Box` |'
- en: '| Box Extents | `(1, 6, 1)` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 箱体范围 | `(1, 6, 1)` |'
- en: '| Gravity | `(0, 0, 0)` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 重力 | `(0, 0, 0)` |'
- en: '| Initial Velocity | `10` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 初始速度 | `10` |'
- en: '| Velocity Random | `1` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 速度随机 | `1` |'
- en: '| Scale | `5` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 尺度 | `5` |'
- en: '| Scale Random |  `1` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 尺度随机 | `1` |'
- en: The default particle color is white, but the dust effect will look better as
    a tan shade. It should also fade away so that it appears to dissipate. This can
    be accomplished with a `ColorRamp`. Next to Color Ramp, click on New GradientTexture.
    In the `GradientTexture` properties, choose a new `Gradient`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认粒子颜色为白色，但尘埃效果作为浅棕色看起来会更好。它还应该逐渐消失，看起来像是消散。这可以通过`ColorRamp`实现。在颜色渐变旁边，点击“新建渐变纹理”。在`GradientTexture`属性中，选择一个新的`Gradient`。
- en: 'The `Gradient` has two colors: a start color on the left and an end color on
    the right. These are selected by the small rectangles at the ends of the gradient.
    Clicking on the square on the right allows you to set the color:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`梯度`有两种颜色：左侧的起始颜色和右侧的结束颜色。这些颜色由梯度两端的矩形选择。点击右侧的方块可以设置颜色：'
- en: '![](img/0ee3193e-e971-45cf-8fc2-ce575dbc6680.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ee3193e-e971-45cf-8fc2-ce575dbc6680.png)'
- en: Set the start color to a tan shade, and set the end color to the same color,
    but with the alpha value set to `0` (transparent). You can test how it looks by
    checking the Emitting box in the Inspector. Because the node is set to One Shot,
    there will only be one puff of particles and you have to check the box again to
    emit them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将起始颜色设置为浅棕色，并将结束颜色设置为相同的颜色，但将alpha值设置为`0`（透明）。你可以通过检查检查器中的“发射”框来测试其外观。因为节点设置为单次发射，所以只有一个粒子团，你必须再次检查框来发射它们。
- en: 'Feel free to alter the properties from what is listed here. Experimenting with
    `Particles2D` settings can be great fun, and often you''ll stumble on to a very
    nice effect just by tinkering. Once you''re happy with the appearance, add the
    following to the Player''s `_physics_process()` code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 随意调整此处列出的属性。实验`Particles2D`设置可以非常有趣，而且你可能会通过调整得到一个非常棒的效果。一旦你对外观满意，将以下内容添加到玩家的`_physics_process()`代码中：
- en: '[PRE35]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the game and every time your character lands on the ground, a small puff
    of dust will appear.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，每次你的角色落地时，都会出现一小股尘埃。
- en: Crouching state
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蹲伏状态
- en: 'The crouching state is useful if you have enemies or projectiles that the player
    needs to dodge by ducking under them. The sprite sheet contains a two-frame animation
    for this state:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 蹲伏状态在玩家需要通过蹲下躲避敌人或投射物时很有用。精灵图包含该状态的二帧动画：
- en: '![](img/0e3f5fc6-edf5-44c7-adb2-643b7ab74ca1.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e3f5fc6-edf5-44c7-adb2-643b7ab74ca1.png)'
- en: Add a new animation called crouch to the player's `AnimationPlayer`. Set its
    Length to `0.2` and add a track for the Frame property that changes the value
    from `3` to `4`. Set the animation to loop.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的动画命名为crouch并添加到玩家的`AnimationPlayer`中。将其长度设置为`0.2`并为`Frame`属性添加一个轨道，将值从`3`变为`4`。将动画设置为循环。
- en: 'In the player''s script, add the new state to the `enum` and state change:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家的脚本中，将新的状态添加到`enum`和状态转换中：
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `get_input()` method, you need to handle the various state transitions.
    When on the ground, the down input should transition to `CROUCH`. When in `CROUCH`,
    releasing the down input should transition to `IDLE`. Finally, if in the `CROUCH`
    state and left or right is pressed, the state should change to `RUN`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_input()` 方法中，你需要处理各种状态转换。当在地面时，向下输入应转换为 `CROUCH`。当处于 `CROUCH` 状态时，释放向下输入应转换为
    `IDLE`。最后，如果在 `CROUCH` 状态并且按下左右键，状态应更改为 `RUN`：
- en: '[PRE38]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You also need to change this line:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改这一行：
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里：
- en: '[PRE40]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it! Run the game and try out your new animation state.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！运行游戏并尝试你的新动画状态。
- en: Climbing ladders
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬梯子
- en: 'The player animation also includes frames for a *climbing* action, and the
    tileset contains ladders. Currently, the ladder tiles do nothing: in the TileSet,
    they do not have any collision shape assigned. That''s fine, because you don''t
    want the player to collide with the ladders; you want to be able to move up and
    down on them.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家动画还包括爬升动作的帧，而瓦片集包含梯子。目前，梯子瓦片没有任何作用：在瓦片集中，它们没有分配任何碰撞形状。这是可以的，因为你不希望玩家与梯子碰撞；你希望能够在上面上下移动。
- en: Player code
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家代码
- en: Start by clicking on the player's `AnimationPlayer` and adding a new animation
    named `climb`. Its Length should be set to `0.4` seconds and the Frame values
    for the `Sprite` are `0, 1, 0, 2`. Set the animation to loop.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 首先点击玩家的 `AnimationPlayer` 并添加一个名为 `climb` 的新动画。其长度应设置为 `0.4` 秒，`Sprite` 的帧值是
    `0, 1, 0, 2`。将动画设置为循环。
- en: 'Now, go to `Player.gd` and add a new state, `CLIMB`, to the state enum. In
    addition, add two new variables to the declarations at the top:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `Player.gd` 并在状态枚举中添加一个新的状态，`CLIMB`。此外，在顶部声明中添加两个新变量：
- en: '[PRE41]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`is_on_ladder` will be used to tell if the player is on a ladder or not. Using
    this, you can decide whether the up arrow should have any effect. In the Inspector,
    set Climb Speed to `50`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_on_ladder` 将用于判断玩家是否在梯子上。使用这个功能，你可以决定向上箭头是否应该有任何效果。在检查器中，将爬升速度设置为 `50`。'
- en: 'In `change_state()`, add a condition for the new state:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `change_state()` 中，为新的状态添加一个条件：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, in `_get_input()`, you need to add the `climb` input action and add the
    code to determine when to trigger the new state. Add the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `_get_input()` 中，你需要添加 `climb` 输入动作，并添加代码以确定何时触发新状态。添加以下内容：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you have three new conditions to check. First, if the player is not in
    the `CLIMB` state, but is on a ladder, then pressing up should start make the
    player start climbing. Next, if the player is climbing, then up and down should
    move them accordingly, but halt movement if no keys are pressed. Finally, if the
    player leaves the ladder while climbing, it will leave the `CLIMB` state.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你有三个新的条件需要检查。首先，如果玩家不在 `CLIMB` 状态，但站在梯子上，那么按下向上键应该开始让玩家开始爬升。接下来，如果玩家正在爬升，那么上下键应该相应地移动他们，但如果没有按键则停止移动。最后，如果玩家在爬升时离开梯子，它将离开
    `CLIMB` 状态。
- en: 'The one remaining issue is you need gravity to stop pulling the player downwards
    when climbing. Add the following condition to the gravity code in `_physics_process()`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的一个问题是你需要让重力在爬升时停止向下拉扯玩家。在 `_physics_process()` 中的重力代码中添加以下条件：
- en: '[PRE44]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, the player is ready, and you can add some ladders to your level map.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家已经准备好了，你可以在关卡地图中添加一些梯子。
- en: Level code
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关卡代码
- en: 'Place a few ladder tiles somewhere on your map, then add a Ladder `Area2D`
    to the level scene. Give this node a `CollisionShape2D` with a rectangular shape.
    The best way to size the area is to use grid snapping. Turn this on via the menu
    and use Configure Snap... to set the grid step to `(4, 4)`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的地图上某个地方放置一些梯子瓦片，然后向关卡场景添加一个 Ladder `Area2D`。给这个节点一个具有矩形形状的 `CollisionShape2D`。最佳的方式是使用网格吸附。通过菜单打开它，并使用
    Configure Snap... 将网格步长设置为 `(4, 4)`：
- en: '![](img/26c24151-386c-4645-aa4e-23e8a5a89843.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26c24151-386c-4645-aa4e-23e8a5a89843.png)'
- en: Adjust the collision shape so that it covers the center portion of the ladder
    from top to bottom. If you make the shape fully as wide as the ladder, the player
    will still count as climbing even when hanging off the side. You may find that
    this looks a bit odd, so making the shape a bit smaller than the width of the
    ladder will prevent this.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 调整碰撞形状，使其覆盖从上到下的梯子中心部分。如果你使形状与梯子宽度完全相同，那么即使玩家悬挂在侧面，也会被视为正在爬升。你可能觉得这看起来有点奇怪，所以将形状做得比梯子宽度小一些，可以防止这种情况发生。
- en: 'Connect the `body_entered` and `body_exited` signals of the `Ladder` and add
    the following code to have them set the Player''s ladder variable:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Ladder` 的 `body_entered` 和 `body_exited` 信号连接起来，并添加以下代码以使它们设置玩家的梯子变量：
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now you can give it a try. You should be able to walk to the ladder and climb
    up and down it. Note that if you are at the top of a ladder and step onto it,
    you'll fall to the bottom rather than climb down (although pressing up as you
    fall will grab the ladder). If you prefer to automatically transition to the climbing
    state, you can add an additional falling check in `_physics_process()`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以试一试了。你应该能够走到梯子旁边，上下爬梯。注意，如果你站在梯子的顶部并踩上去，你会掉到最下面而不是爬下来（尽管在掉落时按上键可以抓住梯子）。如果你希望自动过渡到攀爬状态，你可以在
    `_physics_process()` 中添加一个额外的掉落检查。
- en: Moving platforms
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平台
- en: 'Make a new scene with a `KinematicBody2D` root node. Add a `Sprite` child and
    use the `res://assets/environment/layers/tileset.png` sprite sheet as the Texture
    with Region enabled so you can choose one particular tile. You probably want your
    platform to be wider than one tile, so duplicate the `Sprite` as many times as
    you like. Turn grid snapping on so that the sprites can be aligned in a row:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并使用 `KinematicBody2D` 作为根节点。添加一个 `Sprite` 子节点，并使用 `res://assets/environment/layers/tileset.png`
    精灵图集作为纹理，启用区域功能以便你可以选择一个特定的瓦片。你可能希望你的平台比一个瓦片宽，所以你可以根据需要多次复制 `Sprite`。打开网格吸附，以便精灵可以按行对齐：
- en: '![](img/f98f167d-2d4f-4335-bc83-d53cfb958a72.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f98f167d-2d4f-4335-bc83-d53cfb958a72.png)'
- en: 'A grid setting of `(8, 8)` works well for aligning the tiles. Add a rectangular
    `CollisionShape2D` that covers the image:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`(8, 8)` 的网格设置对于对齐瓦片非常有效。添加一个覆盖图像的矩形 `CollisionShape2D`：'
- en: '![](img/ff85015d-8bc9-42ac-9a7c-fcef6ab09c7a.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff85015d-8bc9-42ac-9a7c-fcef6ab09c7a.png)'
- en: Platform movement can be made very complex (following paths, changing speeds,
    and so on), but this example will stick with a platform that moves horizontally
    back and forth between two objects.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 平台运动可以变得非常复杂（跟随路径、改变速度等），但这个例子将坚持使用在两个对象之间来回移动的水平平台。
- en: 'Here is the platform''s script:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这是平台的脚本：
- en: '[PRE46]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This time, you''re using `move_and_collide()` to move the kinematic body. This
    is a better choice since the platform shouldn''t slide when it collides with another
    wall. Instead, it bounces off the colliding body. As long as your collision shapes
    are rectangular (as the `TileMap` bodies are), this method will work fine. If
    you have a rounded object, the bounce may send the platform off in a strange direction,
    in which case you should use something like the following to keep the motion horizontal:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你使用 `move_and_collide()` 来移动刚体。这是一个更好的选择，因为平台在与其他墙壁碰撞时不应该滑动。相反，它应该从碰撞体上弹开。只要你的碰撞形状是矩形的（就像
    `TileMap` 中的刚体一样），这种方法就会很好用。如果你有一个圆形物体，弹跳可能会将平台推向奇怪的方向，在这种情况下，你应该使用以下类似的方法来保持运动水平：
- en: '[PRE47]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Set the *Velocity* in the Inspector to `(50, 0)`, then go to your level scene
    and instance one of these objects somewhere in your level. Make sure it is between
    two objects so that it can move back and forth between them.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中将 *速度* 设置为 `(50, 0)`，然后转到你的关卡场景并在你的关卡中的某个位置实例化这些对象之一。确保它位于两个对象之间，这样它就可以在它们之间来回移动。
- en: Run the scene and try jumping on the moving platform. Since the Player is using
    `move_and_slide()`, they will automatically move along with the platform if you
    stand on it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景并尝试跳到移动平台上。由于玩家使用 `move_and_slide()`，如果你站在平台上，他们会自动与平台一起移动。
- en: Add as many of these objects as you like to your level. They will even bounce
    off each other, so you can make chains of moving platforms that cover a large
    distance and require careful timing of the player's jumps.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的关卡中添加任意数量的这些对象。它们甚至可以相互弹跳，因此你可以制作覆盖大距离并需要玩家仔细跳跃时机的移动平台链。
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to use the `KinematicBody2D` node to create
    arcade-style physics. You also used the `AnimationPlayer` to create a variety
    of animations for character behavior, and made extensive use of what you learned
    in earlier projects to tie everything together. Hopefully, by this point, you
    have a good grasp of the scene system and how a Godot project is structured.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用 `KinematicBody2D` 节点创建街机风格的物理效果。你还使用了 `AnimationPlayer` 来创建各种角色行为的动画，并广泛使用了你在早期项目中学到的知识来整合一切。希望到这一点，你已经很好地掌握了场景系统以及
    Godot 项目的结构。
- en: Remember the Stretch Mode and Aspect properties you set in the Project Settings at
    the beginning? Run the game and observe what happens when you resize the game
    window. These settings are the best for this style of game, but try changing the Stretch
    Mode to Viewport instead, then make your game window very wide or tall. Experiment
    with the other settings to see the effect of the different resizing options.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你在项目设置中最初设置的 “拉伸模式” 和 “视角” 属性吗？运行游戏，观察当你调整游戏窗口大小时会发生什么。这些设置最适合这种类型的游戏，但尝试将 “拉伸模式” 改为 “视口”，然后让你的游戏窗口变得非常宽或高。尝试调整其他设置，看看不同调整选项的效果。
- en: Once again, before moving on, take a few moments to play your game and look
    through its various scenes and scripts to review how you built it. Review any
    sections of this chapter that you found particularly tricky.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，在继续前进之前，花几分钟时间玩玩你的游戏，浏览其各种场景和脚本，回顾你是如何构建它的。回顾一下你发现特别棘手的章节内容。
- en: In the next chapter, you'll make the jump to 3D!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将进入3D世界！
