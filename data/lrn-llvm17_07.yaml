- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: IR Generation for High-Level Language Constructs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级语言构造的 IR 生成
- en: High-level languages today usually make use of aggregate data types and **object-oriented
    programming** (**OOP**) constructs. LLVM IR has some support for aggregate data
    types, and OOP constructs such as classes must be implemented on their own. Adding
    aggregate types raises the question of how the parameters of an aggregate type
    are passed. Different platforms have different rules, and this is also reflected
    in the IR. Complying with the calling convention also ensures that system functions
    can be called.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的高级语言通常使用聚合数据类型和 **面向对象编程** （**OOP**） 构造。LLVM IR 对聚合数据类型有一些支持，并且必须自行实现类等 OOP
    构造。添加聚合类型会引发聚合类型参数如何传递的问题。不同的平台有不同的规则，这也在 IR 中得到体现。遵守调用约定也确保了可以调用系统函数。
- en: In this chapter, you will learn how to translate aggregate data types and pointers
    to LLVM IR and how to pass parameters to a function in a system-compliant way.
    You will also learn how to implement classes and virtual functions in LLVM IR.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将聚合数据类型和指针转换为 LLVM IR，以及如何以系统兼容的方式向函数传递参数。您还将学习如何在 LLVM IR 中实现类和虚函数。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Working with arrays, structs, and pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组、结构和指针
- en: Getting the **application binary interface** **(****ABI)** right
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '正确获取 **应用程序二进制接口** **(ABI)** '
- en: Creating IR code for classes and virtual functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类和虚函数创建 IR 代码
- en: By the end of the chapter, you will have acquired the knowledge to create LLVM
    IR for aggregate data types and OOP constructs. You will also know how to pass
    aggregate data types according to the rules of the platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将掌握创建 LLVM IR 用于聚合数据类型和面向对象（OOP）构造的知识。您还将了解如何根据平台的规则传递聚合数据类型。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在 [https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05](https://github.com/PacktPublishing/Learn-LLVM-17/tree/main/Chapter05)
    找到。
- en: Working with arrays, structs, and pointers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组、结构和指针
- en: For almost all applications, basic types such as `INTEGER` are not sufficient.
    For example, to represent mathematical objects such as a matrix or a complex number,
    you must construct new data types based on existing ones. These new data types
    are generally known as **aggregate** or **composite**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有应用程序，基本类型如 `INTEGER` 是不够的。例如，为了表示数学对象，如矩阵或复数，您必须基于现有类型构造新的数据类型。这些新数据类型通常被称为
    **聚合** 或 **复合**。
- en: '`tinylang` type `ARRAY [10] OF INTEGER` or the C type `long[10]` is expressed
    in IR as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`tinylang` 类型 `ARRAY [10] OF INTEGER` 或 C 类型 `long[10]` 在 IR 中的表示如下：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Structures are composites of different types. In programming languages, they
    are often expressed with named members. For example, in `tinylang`, a structure
    is written as `RECORD x: REAL; color: INTEGER; y: REAL; END;` and the same structure
    in C is `struct { float x; long color; float y; };`. In LLVM IR, only the type
    names are listed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '结构是不同类型的组合。在编程语言中，它们通常使用命名成员表示。例如，在 `tinylang` 中，结构被写成 `RECORD x: REAL; color:
    INTEGER; y: REAL; END;`，而在 C 中相同的结构是 `struct { float x; long color; float y; };`。在
    LLVM IR 中，只列出类型名称：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To access a member, a numerical index is used. Like arrays, the first element
    has an index number of `0`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问成员，使用数值索引。就像数组一样，第一个元素的索引号为 `0`。
- en: The members of this structure are arranged in memory according to the specification
    in the data layout string. For more information regarding the data layout string
    within LLVM, [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068), *Basics of IR Code
    Generation*, describes these details.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的成员根据数据布局字符串中的规范在内存中排列。有关 LLVM 中数据布局字符串的更多信息，请参阅 [*第 4 章*](B19561_04.xhtml#_idTextAnchor068)，*IR
    代码生成基础*，其中描述了这些细节。
- en: 'Furthermore, if necessary, unused padding bytes are inserted. If you need to
    take control of the memory layout, then you can use a packed structure in which
    all elements have a 1-byte alignment. Within C, we utilize the `__packed__` attribute
    in the struct in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果需要，可以插入未使用的填充字节。如果您需要控制内存布局，则可以使用所有元素具有 1 字节对齐的打包结构。在 C 中，我们使用以下方式在结构中利用
    `__packed__` 属性：
- en: '`struct __attribute__((__packed__)) { float x; long long color; float` `y;
    }`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct __attribute__((__packed__)) { float x; long long color; float y; }`'
- en: 'Likewise, the syntax within LLVM IR is slightly different and looks like the
    following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，LLVM IR中的语法略有不同，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Loaded into a register, arrays, and structs are treated as a unit. It is not
    possible to refer to a single element of array-valued register `%x` as `%x[3]`,
    for example. This is due to the SSA form because it is not possible to tell if
    `%x[i]` and `%x[j]` refer to the same element or not. Instead, we need special
    instructions to extract and insert single-element values into an array. To read
    the second element, we use the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组、结构和寄存器加载为单元。不可能像`%x[3]`那样引用数组值寄存器`%x`的单个元素。这是由于SSA形式，因为无法判断`%x[i]`和`%x[j]`是否引用相同的元素。相反，我们需要特殊的指令来提取和插入数组中的单个元素值。要读取第二个元素，我们使用以下指令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also update an element such as the first one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以更新一个元素，例如第一个元素：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both instructions work on structures, too. For example, to access the `color`
    member from register `%pt`, you write the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令也适用于结构体。例如，要从寄存器`%pt`访问`color`成员，你可以编写以下内容：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There exists an important limitation on both instructions: the index must be
    a constant. For structures, this is easily explainable. The index number is only
    a substitute for the name, and languages such as C have no notion of dynamically
    computing the name of a struct member. For arrays, it is simply that it can’t
    be implemented efficiently. Both instructions have value in specific cases when
    the number of elements is small and known. For example, a complex number could
    be modeled as an array of two floating-point numbers. It’s reasonable to pass
    this array around, and it is always clear which part of the array must be accessed
    during a computation.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令都存在一个重要的限制：索引必须是常量。对于结构体，这很容易解释。索引数字只是名称的替代品，像C这样的语言没有动态计算结构体成员名称的概念。对于数组，这仅仅是因为它无法高效实现。当元素数量小且已知时，这两条指令在特定情况下都有价值。例如，复数可以被建模为一个包含两个浮点数的数组。传递这个数组是合理的，并且在计算过程中始终可以清楚地知道必须访问数组的哪个部分。
- en: 'For general use in the front end, we have to resort to pointers to memory.
    All global values in LLVM are expressed as pointers. Let’s declare a `@arr` global
    variable as an array of eight `i64` elements. This is the equivalent of the `long
    arr[8]` C declaration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端的一般使用中，我们必须求助于内存指针。LLVM中的所有全局值都表示为指针。让我们声明一个名为`@arr`的全局变量，它是一个包含八个`i64`元素的数组。这相当于C语言中的`long
    arr[8]`声明：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To access the second element of the array, an address calculation must be performed
    to determine the address of the indexed element. Then the value can then be loaded
    from that address and put into a function `@second`, this looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组的第二个元素，必须执行地址计算以确定索引元素的地址。然后可以从该地址加载值并将其放入一个名为`@second`的函数中，这看起来是这样的：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `getelementptr` instruction is the workhorse for address calculations.
    As such, it needs some more explanation. The first operand, `[8 x i64]`, is the
    base type the instruction is operating on. The second operand, `ptr @arr`, specifies
    the base pointer. Please note the subtle difference here: we declared an array
    of eight elements, but because all global values are treated as pointers, we have
    a pointer to the array. In C syntax, we really work with `long (*arr)[8]`! The
    consequence is that we first have to dereference the pointer before we can index
    the element, such as `arr[0][1]` in C. The third operand, `i64 0`, dereferences
    the pointer, and the fourth operand, `i64 1`, is the element index. The result
    of this computation is the address of the indexed element. Please note that no
    memory is touched by this instruction.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`getelementptr`指令是地址计算的工作马。因此，它需要更多的解释。第一个操作数`[8 x i64]`是指令操作的基类型。第二个操作数`ptr
    @arr`指定了基指针。请注意这里的微妙区别：我们声明了一个包含八个元素的数组，但由于所有全局值都被视为指针，所以我们有一个指向数组的指针。在C语法中，我们实际上与`long
    (*arr)[8]`一起工作！结果是，我们必须先取消引用指针，然后才能索引元素，例如C中的`arr[0][1]`。第三个操作数`i64 0`取消引用指针，第四个操作数`i64
    1`是元素索引。这个计算的结果是索引元素的地址。请注意，此指令不会触及任何内存。'
- en: 'Except for structs, the index parameters do not need to be constant. Therefore,
    the `getelementptr` instruction can be used in a loop to retrieve the elements
    of an array. Structs are treated differently here: only constants can be used,
    and the type must be `i32`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结构体之外，索引参数不需要是常量。因此，可以使用`getelementptr`指令在循环中检索数组的元素。在这里，结构体的处理方式不同：只能使用常量，并且类型必须是`i32`。
- en: 'With this knowledge, arrays are easily integrated into the code generator from
    [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068), *Basics of IR Code Generation*.
    The `convertType()` method must be extended to create the type. If the `Arr` variable
    holds the type denoter of an array, and assuming the number of elements within
    an array is an integer literal, we then can add the following to the `convertType()`
    method to handle arrays:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，数组可以很容易地从[*第4章*](B19561_04.xhtml#_idTextAnchor068)，*IR代码生成基础*中集成到代码生成器中。必须扩展`convertType()`方法来创建类型。如果`Arr`变量持有数组的类型表示符，并且假设数组中的元素数量是一个整数字面量，那么我们就可以在`convertType()`方法中添加以下内容来处理数组：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This type can be used to declare global variables. For local variables, we
    need to allocate memory for the array. We do this in the first basic block of
    the procedure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型可以用来声明全局变量。对于局部变量，我们需要为数组分配内存。我们在过程的第一个基本块中这样做：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To read and write an element, we have to generate the `getelementptr` instruction.
    This is added to the `emitExpr()` (reading a value) and `emitStmt()` (writing
    a value) methods. To read an element of an array, the value of the variable is
    read first. Then, the selectors of the variable are processed. For each index,
    the expression is evaluated and the value is stored. Based on this list, the address
    of the referenced element is calculated and the value is loaded:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取和写入一个元素，我们必须生成`getelementptr`指令。这个指令被添加到`emitExpr()`（读取值）和`emitStmt()`（写入值）方法中。为了读取数组中的一个元素，首先读取变量的值。然后，处理变量的选择器。对于每个索引，计算表达式并存储值。基于这个列表，计算引用元素的地址并加载值：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Writing to an array element uses the same code, with the exception that you
    do not generate a `load` instruction. Instead, you use the pointer as the target
    in a `store` instruction. For records, you use a similar approach. The selector
    for a record member contains the constant field index, named `Idx`. You convert
    this constant into a constant LLVM value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组元素写入使用相同的代码，只是不生成`load`指令。相反，你使用指针作为`store`指令的目标。对于记录，使用类似的方法。记录成员的选择器包含常量字段索引，命名为`Idx`。你将这个常量转换为常量LLVM值：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then you can use value in the `Builder.CreateGEP()` methods as in for arrays.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在`Builder.CreateGEP()`方法中使用值，就像数组一样。
- en: Now, you should know how to translate aggregate data types to LLVM IR. Passing
    values of those types in a system-compliant way requires some care, and you will
    learn to implement it correctly in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该知道如何将聚合数据类型转换为LLVM IR。以系统兼容的方式传递这些类型的值需要一些注意，你将在下一节中学习如何正确实现它。
- en: Getting the application binary interface right
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确获取应用程序二进制接口
- en: 'With the addition of arrays and records to the code generator, you can note
    that sometimes, the generated code does not execute as expected. The reason is
    that we have ignored the calling conventions of the platform so far. Each platform
    defines its own rules on how one function can call another function in the same
    program or library. These rules are summarized in the ABI documentation. Typical
    information includes the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数组和记录添加到代码生成器后，你可以注意到有时生成的代码并不像预期那样执行。原因是到目前为止，我们已经忽略了平台的调用约定。每个平台都定义了自己的一套规则，即一个函数如何在同一个程序或库中调用另一个函数。这些规则总结在ABI文档中。典型信息包括以下内容：
- en: Are machine registers used for parameter passing? If yes, which ones?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用机器寄存器进行参数传递？如果是，是哪些？
- en: How are aggregates such as arrays and structs passed to a function?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将聚合类型（如数组和结构体）传递给函数？
- en: How are return values handled?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理返回值？
- en: There is a wide variety in use. On some platforms, aggregates are always passed
    indirectly, meaning that a copy of the aggregate is placed on the stack and only
    a pointer to the copy is passed as a parameter. On other platforms, a small aggregate
    (say 128 or 256 bit wide) is passed in registers, and only above that threshold
    is indirect parameter passing used. Some platforms also use floating-point and
    vector registers for parameter passing, while others demand that floating-point
    values be passed in integer registers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上存在很大的差异。在某些平台上，聚合类型总是间接传递，这意味着聚合类型的一个副本被放置在栈上，并且只传递副本的指针作为参数。在其他平台上，小聚合类型（例如128位或256位宽）在寄存器中传递，并且只有超过这个阈值才使用间接参数传递。一些平台还使用浮点数和向量寄存器进行参数传递，而其他平台则要求浮点值在整数寄存器中传递。
- en: Of course, this is all interesting low-level stuff. Unfortunately, it leaks
    into LLVM IR. At first, this is surprising. After all, we define the types of
    all parameters of a function in LLVM IR! It turns out that this is not enough.
    To understand this, let’s consider complex numbers. Some languages have built-in
    data types for complex numbers. For example, C99 has `float _Complex` (among others).
    Older versions of C do not have complex number types, but you can easily define
    `struct Complex { float re, im; }` and create arithmetic operations on this type.
    Both types can be mapped to the `{ float, float }` LLVM IR type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些都是有趣的底层内容。不幸的是，它们会泄露到 LLVM IR 中。起初，这让人惊讶。毕竟，我们在 LLVM IR 中定义了函数所有参数的类型！结果证明这还不够。为了理解这一点，让我们考虑复数。一些语言有内置的复数数据类型。例如，C99
    有 `float _Complex`（以及其他类型）。较老的 C 版本没有复数类型，但你可以轻松地定义 `struct Complex { float re,
    im; }` 并在这个类型上创建算术运算。这两种类型都可以映射到 `{ float, float }` LLVM IR 类型。
- en: If the ABI now states that values of a built-in, complex-number type are passed
    in two floating-point registers, but user-defined aggregates are always passed
    indirectly, then the information given with the function is not enough for LLVM
    to decide how to pass this particular parameter. The unfortunate consequence is
    that we need to provide more information to LLVM, and this information is highly
    ABI-specific.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 ABI 现在声明内置复数类型的值是通过两个浮点寄存器传递的，但用户定义的聚合类型总是通过间接方式传递，那么函数中给出的信息对于 LLVM 来说不足以决定如何传递这个特定的参数。不幸的后果是我们需要向
    LLVM 提供更多信息，并且这些信息高度依赖于 ABI。 '
- en: 'There are two ways to specify this information to LLVM: parameter attributes
    and type rewriting. What you need to use depends on the target platform and the
    code generator. The most commonly used parameter attributes are the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以将此信息指定给 LLVM：参数属性和类型重写。你需要使用哪种方式取决于目标平台和代码生成器。最常用的参数属性如下：
- en: '`inreg` specifies that the parameter is passed in a register'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inreg` 指定参数是通过寄存器传递的'
- en: '`byval` specifies that the parameter is passed by value. The parameter must
    be a pointer type. A hidden copy is made of the pointed-to data, and this pointer
    is passed to the called function.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byval` 指定参数是通过值传递的。参数必须是指针类型。对指向的数据创建一个隐藏的副本，并将这个指针传递给被调用的函数。'
- en: '`zeroext` and `signext` specify that the passed integer value should be zero
    or sign extended.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zeroext` 和 `signext` 指定传递的整数值应该是零扩展或符号扩展。'
- en: '`sret` specifies that this parameter holds a pointer to memory which is used
    to return an aggregate type from the function.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sret` 指定此参数包含指向内存的指针，该内存用于从函数返回聚合类型。'
- en: 'While all code generators support `zeroext`, `signext`, and `sret` attributes,
    only some support `inreg` and `byval`. An attribute can be added to the argument
    of a function with the `addAttr()` method. For example, to set the `inreg` attribute
    on argument `Arg`, you call the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有代码生成器都支持 `zeroext`、`signext` 和 `sret` 属性，但只有一些支持 `inreg` 和 `byval`。可以使用
    `addAttr()` 方法将属性添加到函数的参数上。例如，要将 `inreg` 属性设置在参数 `Arg` 上，你可以调用以下代码：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To set multiple attributes, you can use the `llvm::AttrBuilder` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置多个属性，可以使用 `llvm::AttrBuilder` 类。
- en: 'The other way to provide additional information is to use type rewriting. With
    this approach, you disguise the original types. You can do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提供额外信息的另一种方式是使用类型重写。使用这种方法，你可以伪装原始类型。你可以做以下操作：
- en: Split the parameter. For example, instead of passing one complex argument, you
    can pass two floating-point arguments.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分割参数。例如，你不必传递一个复数参数，而是可以传递两个浮点参数。
- en: Cast the parameter into a different representation, such as passing a floating-point
    value through an integer register.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将参数转换为不同的表示，例如通过整数寄存器传递浮点值。
- en: 'To cast between types without changing the bits of the value, you use the `bitcast`
    instruction. The `bitcast` instruction can operate on simple data types such as
    integers and floating-point values. When floating-point values are passed via
    an integer register, the floating-point value must be cast to an integer. In LLVM,
    a 32-bit floating-point value is expressed as `float`, and a 32-bit bit integer
    is expressed as `i32`. The floating point value can be bitcasted to an integer
    in the following way:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不改变值位的情况下在类型之间进行转换，你使用 `bitcast` 指令。`bitcast` 指令可以操作简单数据类型，如整数和浮点值。当浮点值通过整数寄存器传递时，浮点值必须转换为整数。在
    LLVM 中，32 位浮点值表示为 `float`，32 位位整数表示为 `i32`。浮点值可以按以下方式转换为整数：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Additionally, the `bitcast` instruction requires that both types have the same
    size.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`bitcast` 指令要求两种类型具有相同的大小。
- en: Adding attributes to an argument or changing the type is not complicated. But
    how do you know what you need to implement? First of all, you should get an overview
    of the calling convention used on your target platform. For example, the ELF ABI
    on Linux is documented for each supported CPU platform, so you can look up the
    document and make yourself comfortable with it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 向参数添加属性或更改类型并不复杂。但你怎么知道你需要实现什么？首先，你应该了解目标平台使用的调用约定。例如，Linux 上的 ELF ABI 为每个支持的
    CPU 平台进行了文档记录，因此你可以查阅文档并让自己熟悉它。
- en: There is also documentation about the requirements of the LLVM code generators.
    The source of information is the clang implementation, which you can find at [https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp).
    This single file contains the ABI-specific actions for all supported platforms,
    and it is also where all information is collected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些关于 LLVM 代码生成器要求的文档。信息来源是 clang 实现，你可以在 [https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp](https://github.com/llvm/llvm-project/blob/main/clang/lib/CodeGen/TargetInfo.cpp)
    找到。这个单独的文件包含了所有支持平台的所有 ABI 特定操作，并且也是收集所有信息的地方。
- en: In this section, you learned to generate the IR for function calls to be compliant
    with the ABI of your platform. The next section covers the different ways to create
    IR for classes and virtual functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何生成符合平台 ABI 的函数调用 IR。下一节将介绍创建类和虚拟函数 IR 的不同方法。
- en: Creating IR code for classes and virtual functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为类和虚拟函数创建 IR 代码
- en: Many modern programming languages support object orientation using classes.
    A **class** is a high-level language construct, and in this section, we will explore
    how we can map a class construct into LLVM IR.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言通过类支持面向对象。**类**是一种高级语言构造，在本节中，我们将探讨如何将类构造映射到 LLVM IR。
- en: Implementing single inheritance
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单继承
- en: 'A class is a collection of data and methods. A class can inherit from another
    class, potentially adding more data fields and methods, or overriding existing
    virtual methods. Let’s illustrate this with classes in Oberon-2, which is also
    a good model for `tinylang`. A `Shape` class defines an abstract shape with a
    color and an area:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类是数据和方法的集合。一个类可以继承自另一个类，可能添加更多的数据字段和方法，或者覆盖现有的虚拟方法。让我们用 Oberon-2 中的类来举例说明，Oberon-2
    也是一个很好的 `tinylang` 模型。一个 `Shape` 类定义了一个具有颜色和面积的抽象形状：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `GetColor` method only returns the color number:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetColor` 方法只返回颜色编号：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The area of an abstract shape cannot be calculated, so this is an abstract
    method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象形状的面积无法计算，因此这是一个抽象方法：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Shape` type can be extended to represent a `Circle` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape` 类型可以扩展以表示 `Circle` 类：'
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For a circle, the area can be calculated:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于圆形，面积可以计算：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The type can also be queried at runtime. If the shape is a variable of type
    `Shape`, then we can formulate a type test in this way:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类型也可以在运行时查询。如果形状是类型为 `Shape` 的变量，那么我们可以这样进行类型测试：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The different syntax aside, this works much like it does in C++. One notable
    difference to C++ is that the Oberon-2 syntax makes the implicit `this` pointer
    explicit, calling it the receiver of a method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不同的语法之外，这和 C++ 中的用法非常相似。与 C++ 的一个显著区别是，Oberon-2 语法使隐式的 `this` 指针显式化，称其为方法的接收者。
- en: 'The basic problems to solve are how to lay out a class in memory and how to
    implement the dynamic call of methods and run time-type checking. For the memory
    layout, this is quite easy. The `Shape` class has only one data member, and we
    can map it to a corresponding LLVM structure type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的基本问题是如何在内存中布局一个类以及如何实现方法的动态调用和运行时类型检查。对于内存布局来说，这相当简单。`Shape`类只有一个数据成员，我们可以将其映射到相应的LLVM结构类型：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Circle` class adds another data member. The solution is to append the
    new data member at the end:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类添加了另一个数据成员。解决方案是在末尾追加新的数据成员：'
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The reason is that a class can have many sub-classes. With this strategy, the
    data member of the common base class always has the same memory offset and also
    uses the same index to access the field via the `getelementptr` instruction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于一个类可以有多个子类。采用这种策略，公共基类的数据成员总是具有相同的内存偏移量，并且使用相同的索引通过`getelementptr`指令访问字段。
- en: To implement the dynamic call of a method, we must further extend the LLVM structure.
    If the `Area()` function is called on a `Shape` object, then the abstract method
    is called, causing the application to halt. If it is called on a `Circle` object,
    then the corresponding method to calculate the area of a circle is called. On
    the other hand, the `GetColor()` function can be called for objects of both classes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现方法的动态调用，我们必须进一步扩展LLVM结构。如果在一个`Shape`对象上调用`Area()`函数，则调用抽象方法，导致应用程序停止。如果在一个`Circle`对象上调用，则调用相应的计算圆面积的函数。另一方面，`GetColor()`函数可以用于两个类的对象。
- en: 'The basic idea to implement this is to associate a table with function pointers
    with each object. Here, a table would have two entries: one for the `GetColor()`
    method and one for the `Area()` function. The `Shape` class and the `Circle` class
    each have such a table. The tables differ in the entry for the `Area()` function,
    which calls different code depending on the type of the object. This table is
    called the **virtual method table**, often abbreviated as **vtable**.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的基本思路是将一个与函数指针关联的表与每个对象关联起来。在这里，表将有两个条目：一个用于`GetColor()`方法，一个用于`Area()`函数。`Shape`类和`Circle`类各自都有一个这样的表。这些表在`Area()`函数的条目上有所不同，它根据对象的类型调用不同的代码。这个表被称为**虚方法表**，通常缩写为**vtable**。
- en: 'The vtable alone is not useful. We must connect it with an object. To do so,
    we always add a pointer to the vtable as the first data member to the structure.
    At the LLVM level, this is what becomes of the `@``Shape` type:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: vtable本身并没有什么用处。我们必须将其与一个对象连接起来。为此，我们总是在结构中添加一个指向vtable的指针作为第一个数据成员。在LLVM级别，这就是`@Shape`类型变成的样子：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `@Circle` type is similarly extended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Circle`类型也被相应地扩展。'
- en: 'The resulting memory structure is shown in *Figure 5**.1*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的内存结构如*图5.1*所示。1*：
- en: '![Figure 5.1 – Memory layout of the classes and the virtual method tables](img/B19561_05_1.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 类和虚方法表的内存布局](img/B19561_05_1.jpg)'
- en: Figure 5.1 – Memory layout of the classes and the virtual method tables
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 类和虚方法表的内存布局
- en: 'In terms of LLVM IR, the vtable for the `Shape` class can be visualized as
    the following, where the two pointers correspond to the `GetColor()` and `GetArea()`
    methods, as represented in *Figure 5**.1*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM IR方面，`Shape`类的vtable可以表示如下，其中两个指针分别对应于*图5.1*中表示的`GetColor()`和`GetArea()`方法。1*：
- en: '`@ShapeVTable = constant { ptr, ptr } { GetColor(),` `Area() }`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ShapeVTable = constant { ptr, ptr } { GetColor(), Area() }`'
- en: Furthermore, LLVM does not have void pointers. Pointers to bytes are used instead.
    With the introduction of the hidden `vtable` field, there is now also the need
    to have a way to initialize it. In C++, this is part of calling the constructor.
    In Oberon-2, the field is initialized automatically when the memory is allocated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，LLVM没有空指针。而是使用字节指针。随着隐藏的`vtable`字段的引入，现在还需要有一种初始化它的方法。在C++中，这是调用构造函数的一部分。在Oberon-2中，字段在内存分配时自动初始化。
- en: 'A dynamic call to a method is then executed with the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 方法动态调用的执行步骤如下：
- en: Calculate the offset of the vtable pointer via the `getelementptr` instruction.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`getelementptr`指令计算vtable指针的偏移量。
- en: Load the pointer to the vtable.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载vtable的指针。
- en: Calculate the offset of the function in the vtable.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算vtable中函数的偏移量。
- en: Load the function pointer.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载函数指针。
- en: Indirectly call the function via the pointer with the `call` instruction.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`call`指令通过指针间接调用函数。
- en: 'We can visualize the dynamic call to a virtual method, such as `Area()`, within
    LLVM IR, as well. First, we load a pointer from the corresponding designated location
    of the `Shape` class. The following load represents loading the pointer to the
    actual vtable for `Shape`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在LLVM IR中可视化对虚拟方法的动态调用，例如`Area()`。首先，我们从`Shape`类的指定位置加载一个指针。下面的加载表示加载`Shape`的实际vtable的指针：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Following this, a `getelementptr` gets to the offset to call the `Area()` method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`getelementptr`获取调用`Area()`方法的偏移量：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we load the function pointer to `Area()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们加载`Area()`函数的指针：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, the `Area()` function is called through the pointer with the call,
    similar to the general steps that are highlighted previously:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过指针调用`Area()`函数，与之前突出显示的一般步骤相似：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, even in the case of a single inheritance, the LLVM IR that is
    generated can appear to be very verbose. Although the general procedure of generating
    a dynamic call to a method does not sound very efficient, most CPU architectures
    can perform this dynamic call with just two instructions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使在单继承的情况下，生成的LLVM IR看起来也可能非常冗长。尽管生成动态方法调用的通用过程听起来不是很高效，但大多数CPU架构只需两条指令就可以执行这个动态调用。
- en: Moreover, to turn a function into a method, a reference to the object’s data
    is required. This is implemented by passing the pointer to the data as the first
    parameter of the method. In Oberon-2, this is the explicit receiver. In languages
    similar to C++, it is the implicit `this` pointer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要将函数转换为方法，需要对象的引用。这是通过将数据指针作为方法的第一个参数传递来实现的。在Oberon-2中，这是显式的接收者。在类似于C++的语言中，这是隐式的`this`指针。
- en: With the vtable, we have a unique address in memory for each class. Does this
    help with the *runtime-type test*, too? The answer is that it helps only in a
    limited way. To illustrate the problem, let’s extend the class hierarchy with
    an `Ellipse` class, which inherits from the `Circle` class. This is not the classical
    *is-a* relationship in the mathematical sense.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vtable，我们为每个类在内存中有一个唯一的地址。这也有助于*运行时类型测试*吗？答案是，它只以有限的方式有帮助。为了说明问题，让我们通过一个继承自`Circle`类的`Ellipse`类扩展类层次结构。这在数学意义上不是经典的概念。
- en: If we have a `shape` variable of the `Shape` type, then we could implement the
    `shape IS Circle` type test as a comparison of the vtable pointer stored in the
    `shape` variable with the vtable pointer of the `Circle` class. This comparison
    only results in true if `shape` has the exact `Circle` type. However, if `shape`
    is indeed of the `Ellipse` type, then the comparison returns false, even if an
    object of the `Ellipse` type can be used in all places where only an object of
    the `Circle` type is required.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`shape`变量，其类型为`Shape`，那么我们可以将`shape IS Circle`类型测试实现为比较存储在`shape`变量中的vtable指针与`Circle`类的vtable指针。这种比较只有在`shape`具有确切的`Circle`类型时才会返回true。然而，如果`shape`确实是`Ellipse`类型，那么即使`Ellipse`类型的对象可以在只需要`Circle`类型对象的所有地方使用，比较也会返回false。
- en: 'Clearly, we need to do more. The solution is to extend the virtual method table
    with runtime-type information. How much information you need to store depends
    on the source language. To support the runtime-type check, it is enough to store
    a pointer to the vtable of the base class, which then looks like in *Figure 5**.2*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要做更多。解决方案是扩展虚拟方法表以包含运行时类型信息。你需要存储多少信息取决于源语言。为了支持运行时类型检查，存储基类vtable的指针就足够了，它看起来就像*图5.2*所示：
- en: '![Figure 5.2 – Class and vtable layout supporting simple type tests](img/B19561_05_2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 支持简单类型测试的类和vtable布局](img/B19561_05_2.jpg)'
- en: Figure 5.2 – Class and vtable layout supporting simple type tests
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 支持简单类型测试的类和vtable布局
- en: If the test fails as described earlier, then the test is repeated with the pointer
    to the vtable of the base class. This is repeated until the test yields true or,
    if there is no base class, false. In contrast to calling a dynamic function, the
    type test is a costly operation because, in the worst-case scenario, the inheritance
    hierarchy is walked up to the root class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试如前所述失败，则测试会使用基类的vtable指针重复进行。这会一直重复，直到测试返回true，或者如果没有基类，则返回false。与调用动态函数相比，类型测试是一个昂贵的操作，因为在最坏的情况下，继承层次结构会遍历到根类。
- en: 'If you know the whole class hierarchy, then an efficient approach is possible:
    you number each member of the class hierarchy in a depth-first order. Then, the
    type test becomes compare-against-a-number or an interval, which can be done in
    constant time. In fact, that is the approach of LLVM’s own runtime-type test,
    which we learned about in the previous chapter.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道整个类层次结构，那么可以采取一种有效的方法：以深度优先的顺序给类层次结构中的每个成员编号。然后，类型测试变成与数字或区间的比较，这可以在常数时间内完成。实际上，这正是我们在上一章中学到的LLVM自己的运行时类型测试的方法。
- en: To couple runtime-type information with the vtable is a design decision, either
    mandated by the source language or just as an implementation detail. For example,
    if you need detailed runtime-type information because the source language supports
    reflection at runtime, and you have data types without a vtable, then coupling
    both is not a good idea. In C++, the coupling results in the fact that a class
    with virtual functions (and therefore no vtable) has no runtime-type data attached
    to it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将运行时类型信息与虚表结合是一个设计决策，要么是由源语言强制规定的，要么只是作为一个实现细节。例如，如果你需要详细的运行时类型信息，因为源语言支持运行时反射，并且你有没有虚表的数据类型，那么将两者结合不是一个好主意。在C++中，这种结合导致了一个事实，即具有虚函数（因此没有虚表）的类没有附加的运行时类型数据。
- en: Often, programming languages support interfaces which are a collection of virtual
    methods. Interfaces are important because they add a useful abstraction. We will
    look at possible implementations of interfaces in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编程语言支持接口，这些接口是一系列虚拟方法。接口很重要，因为它们增加了一个有用的抽象。我们将在下一节中探讨接口的可能实现。
- en: Extending single inheritance with interfaces
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用接口扩展单继承
- en: Languages such as **Java** support interfaces. An interface is a collection
    of abstract methods, comparable to a base class with no data members and only
    abstract methods defined. Interfaces pose an interesting problem because each
    class implementing an interface can have the corresponding method at a different
    position in the vtable. The reason is simply that the order of function pointers
    in the vtable is derived from the order of the functions in the class definition
    in the source language. The definition of the interface is independent of this,
    and different orders are the norm.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于**Java**这样的语言支持接口。接口是一系列抽象方法的集合，相当于一个没有数据成员且只定义了抽象方法的基本类。接口提出了一个有趣的问题，因为每个实现接口的类都可以在虚表中的不同位置有相应的方法。原因很简单，虚表中的函数指针顺序是从源语言中类定义中函数的顺序派生出来的。接口的定义独立于这一点，不同的顺序是常态。
- en: 'Because the methods defined in an interface can have a different order, we
    attach a table for each implemented interface to the class. For each method of
    the interface, this table can specify either the index of the method in the vtable
    or a copy of the function pointer stored in the vtable. If a method is called
    on the interface, then the corresponding vtable of the interface is searched,
    the pointer to the function is fetched, and the method is called. Adding two `I1`
    and `I2` interfaces to the `Shape` class results in the following layout:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口中定义的方法可以有不同的顺序，我们将每个实现的接口的表附加到类上。对于接口的每个方法，这个表可以指定方法在虚表中的索引或虚表中存储的函数指针的副本。如果在接口上调用一个方法，那么将搜索接口的相应虚表，获取函数指针，并调用该方法。将两个`I1`和`I2`接口添加到`Shape`类中会导致以下布局：
- en: '![Figure 5.3 – Layout of vtables for interfaces](img/B19561_05_3.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 接口虚表的布局](img/B19561_05_3.jpg)'
- en: Figure 5.3 – Layout of vtables for interfaces
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 接口虚表的布局
- en: 'The caveat lies in the fact that we have to find the right vtable. We can use
    an approach similar to the runtime-type test: we can perform a linear search through
    the list of interface vtables. We can assign a unique number to each interface
    (for example, a memory address) and identify this vtable using this number. The
    disadvantage of this scheme is obvious: calling a method through an interface
    takes much more time than calling the same method on the class. There is no easy
    mitigation for this problem.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意之处在于我们必须找到正确的虚表。我们可以使用类似于运行时类型测试的方法：我们可以通过接口虚表的列表进行线性搜索。我们可以给每个接口分配一个唯一的数字（例如，一个内存地址），并使用这个数字来识别这个虚表。这种方案的缺点很明显：通过接口调用方法比在类上调用相同的方法花费更多的时间。这个问题没有简单的缓解方法。
- en: A good approach is to replace the linear search with a hash table. At compilation
    time, the interface that a class implements is known. Therefore, we can construct
    a perfect hash function, which maps the interface number to the vtable for the
    interface. A known unique number identifying an interface may be needed for the
    construction, so memory does not help, but there are other ways to compute a unique
    number. If the symbol names in the source are unique, then it is always possible
    to compute a cryptographic hash such as `MD5` of the symbol, and use the hash
    as the number. The calculation occurs at compile time and therefore has no runtime
    cost.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的方法是使用哈希表来替换线性搜索。在编译时，一个类实现的接口是已知的。因此，我们可以构造一个完美的哈希函数，将接口编号映射到接口的虚函数表。构建接口的唯一标识符可能需要一个已知的唯一数字，因此内存无法帮助，但还有其他方法来计算一个唯一数字。如果源代码中的符号名称是唯一的，那么总是可以计算符号的加密哈希，如`MD5`，并使用哈希作为数字。这个计算发生在编译时，因此没有运行时成本。
- en: The result is much faster than the linear search and only takes constant time.
    Still, it involves several arithmetic operations on a number and is slower than
    the method call of a class type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果比线性搜索快得多，并且只需要常数时间。尽管如此，它涉及到对数字的几个算术运算，并且比类类型的方法调用慢。
- en: Usually, interfaces also take part in runtime-type tests, making the list search
    even longer. Of course, if the hash-table approach is implemented, then it can
    also be used for the runtime-type test.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，接口也参与运行时类型测试，这使得列表搜索更长。当然，如果实现了哈希表方法，那么它也可以用于运行时类型测试。
- en: Some languages allow for more than one parent class. This has some interesting
    challenges for the implementation, and we will master this in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许有多个父类。这给实现带来了一些有趣的挑战，我们将在下一节中掌握这一点。
- en: Adding support for multiple inheritance
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加多重继承支持
- en: Multiple inheritance adds another challenge. If a class inherits from two or
    more base classes, then we need to combine the data members in such a way that
    they are still accessible from the methods. Like in the single inheritance case,
    the solution is to append all data members, including the hidden vtable pointers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承增加了另一个挑战。如果一个类从两个或更多基类继承，那么我们需要以这种方式组合数据成员，使得它们仍然可以从方法中访问。就像在单继承的情况下，解决方案是附加所有数据成员，包括隐藏的虚函数表指针。
- en: 'The `Circle` class is not only a geometric shape but also a graphic object.
    To model this, we let the `Circle` class inherit from the `Shape` class and the
    `GraphicObj` class. In the class layout, the fields from the `Shape` class come
    first. Then, we append all fields of the `GraphicObj` class, including the hidden
    vtable pointer. After that, we add the new data members of the `Circle` class,
    resulting in the overall structure shown in *Figure 5**.4*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类不仅是一个几何形状，也是一个图形对象。为了建模这一点，我们让`Circle`类继承自`Shape`类和`GraphicObj`类。在类布局中，`Shape`类的字段首先出现。然后，我们附加`GraphicObj`类的所有字段，包括隐藏的虚函数表指针。之后，我们添加`Circle`类的新数据成员，从而形成如*图5.4*所示的总体结构。4*：'
- en: '![Figure 5.4 - Layout of classes and vtables with multiple inheritance](img/B19561_05_4.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 - 多重继承的类和虚函数表布局](img/B19561_05_4.jpg)'
- en: Figure 5.4 - Layout of classes and vtables with multiple inheritance
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 多重继承的类和虚函数表布局
- en: This approach has several implications. There can now be several pointers to
    the object. A pointer to the `Shape` or `Circle` class points to the top of the
    object, while a pointer to a `GraphicObj` class points to inside this object,
    the beginning of the embedded `GraphicObj` object. This has to be taken into account
    when comparing pointers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有几个影响。现在可以有指向对象的多个指针。指向`Shape`或`Circle`类的指针指向对象的顶部，而指向`GraphicObj`类的指针指向这个对象的内部，指向嵌入的`GraphicObj`对象的开始。在比较指针时必须考虑到这一点。
- en: 'Calling a virtual method is also affected. If a method is defined in the `GraphicObj`
    class, then this method expects the class layout of the `GraphicObj` class. If
    this method is not overridden in the `Circle` class, then there a two possibilities.
    The easy case is if the method call is done with a pointer to a `GraphicObj` instance:
    in this case, you look up the address of the method in the vtable of the `GraphicObj`
    class and call the function. The more complicated case is if you call the method
    with a pointer to the `Circle` class. Again, you can look up the address of the
    method in the vtable of the `Circle` class. The called method expects a `this`
    pointer to be an instance of the `GraphicObj` class, so we have to adjust that
    pointer, too. We can do this because we know the offset of the `GraphicObj` class
    inside the `Circle` class.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用虚方法也会受到影响。如果方法在 `GraphicObj` 类中定义，那么这个方法期望 `GraphicObj` 类的类布局。如果这个方法在 `Circle`
    类中没有重写，那么有两种可能性。简单的情况是如果使用指向 `GraphicObj` 实例的指针进行方法调用：在这种情况下，你在 `GraphicObj` 类的
    vtable 中查找方法的地址并调用该函数。更复杂的情况是如果你使用指向 `Circle` 类的指针调用该方法。同样，你可以在 `Circle` 类的 vtable
    中查找方法的地址。被调用的方法期望 `this` 指针是一个 `GraphicObj` 类的实例，因此我们也必须调整该指针。我们可以这样做，因为我们知道 `GraphicObj`
    类在 `Circle` 类中的偏移量。
- en: 'If a `GrapicObj` method is overridden in the `Circle` class, then nothing special
    needs to be done if the method is called through a pointer to the `Circle` class.
    However, if the method is called through a pointer to a `GraphicObj` instance,
    then we need to make another adjustment because the method needs a `this` pointer
    pointing to a `Circle` instance. At compilation time, we cannot compute this adjustment
    because we do not know whether or not this `GraphicObj` instance is part of a
    multiple inheritance hierarchy. To solve this, we store the adjustment we need
    to make to the `this` pointer before calling the method together with each function
    pointer in the vtable, as in *Figure 5**.5*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `Circle` 类中重写了 `GrapicObj` 方法，那么如果通过 `Circle` 类的指针调用该方法，则不需要做任何特殊处理。然而，如果通过
    `GraphicObj` 实例的指针调用该方法，那么我们需要进行另一个调整，因为该方法需要一个指向 `Circle` 实例的 `this` 指针。在编译时，我们无法计算这个调整，因为我们不知道这个
    `GraphicObj` 实例是否是多重继承层次结构的一部分。为了解决这个问题，我们在调用方法之前，将需要调整的 `this` 指针与 vtable 中的每个函数指针一起存储，如图
    *5**.5* 所示：
- en: '![Figure 5.5 – vtable with adjustments to the this pointer](img/B19561_05_5.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 调整 this 指针的 vtable](img/B19561_05_5.jpg)'
- en: Figure 5.5 – vtable with adjustments to the this pointer
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 调整 this 指针的 vtable
- en: 'A method call now becomes the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的方法调用变为以下：
- en: Look up the function pointer in the vtable.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 vtable 中查找函数指针。
- en: Adjust the `this` pointer.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整 `this` 指针。
- en: Call the method.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法。
- en: This approach can also be used for implementing interfaces. As an interface
    only has methods, each implemented interface adds a new vtable pointer to the
    object. This is easier to implement and most likely faster, but it adds overhead
    to each object instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以用于实现接口。由于接口只有方法，每个实现的接口都会为对象添加一个新的 vtable 指针。这更容易实现，并且可能更快，但它为每个对象实例增加了开销。
- en: 'In the worst case, if your class has a single 64-bit data field but implements
    10 interfaces, then your object requires 96 bytes in memory: eight bytes for the
    vtable pointer of the class itself, eight bytes for the data member, and 10 *
    8 bytes for the vtable pointers of each interface.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，如果你的类有一个 64 位数据字段，但实现了 10 个接口，那么你的对象在内存中需要 96 字节：8 字节用于类本身的 vtable 指针，8
    字节用于数据成员，以及 10 * 8 字节用于每个接口的 vtable 指针。
- en: To support meaningful comparisons to objects and to perform runtime-type tests,
    we need to normalize a pointer to an object first. If we add an additional field
    to the vtable, containing an offset to the top of the object, then we can always
    adjust the pointer to point to the real object. In the vtable of the `Circle`
    class, this offset is 0, but not in the vtable of the embedded `GraphicObj` class.
    Of course, whether this needs to be implemented depends on the semantics of the
    source language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持对对象的有意义比较以及执行运行时类型测试，我们首先需要将对象指针规范化。如果我们向 vtable 添加一个额外的字段，包含对象顶部的偏移量，那么我们总能调整指针以指向实际的对象。在
    `Circle` 类的 vtable 中，这个偏移量是 0，但在内嵌的 `GraphicObj` 类的 vtable 中不是。当然，是否需要实现这取决于源语言的语义。
- en: LLVM itself does not favor a special implementation of object-oriented features.
    As seen in this section, we can implement all approaches with the available LLVM
    data types. Additionally, as we have seen an example of LLVM IR with single inheritance,
    it is also worth noting that the IR can become more verbose when multiple inheritance
    is involved. If you want to try a new approach, then a good way is to do a prototype
    in C first. The required pointer manipulations are quickly translated to LLVM
    IR, but reasoning about the functionality is easier in a higher-level language.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 本身并不倾向于特殊实现面向对象特性。正如本节所示，我们可以使用可用的 LLVM 数据类型实现所有方法。此外，正如我们已经看到的单继承的 LLVM
    IR 示例，当涉及多重继承时，IR 可能会变得更加冗长。如果你想尝试一种新的方法，那么一个好的方式是首先用 C 语言做一个原型。所需的指针操作可以快速转换为
    LLVM IR，但在高级语言中推理功能更容易。
- en: With the knowledge acquired in this section, you can implement the lowering
    of all OOP constructs commonly found in programming languages into LLVM IR in
    your own code generator. You have recipes on how to represent single inheritance,
    single inheritance with interface, or multiple inheritance in memory, and also
    how to implement type tests and how to look up virtual functions, which are the
    core concepts of OOP languages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本节获得的知识，你可以在自己的代码生成器中实现将编程语言中常见的所有面向对象构造转换为 LLVM IR。你有了如何表示单继承、具有接口的单继承或内存中的多重继承的食谱，以及如何实现类型测试和查找虚函数的方法，这些都是面向对象语言的核心概念。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to translate aggregate data types and pointers
    to LLVM IR code. You also learned about the intricacies of the application binary
    interface. Finally, you learned about the different approaches to translating
    classes and virtual functions to LLVM IR. With the knowledge of this chapter,
    you will be able to create an LLVM IR code generator for most real programming
    languages.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将聚合数据类型和指针转换为 LLVM IR 代码。你还了解了应用程序二进制接口的复杂性。最后，你学习了将类和虚函数转换为 LLVM
    IR 的不同方法。通过本章的知识，你将能够为大多数真实编程语言创建一个 LLVM IR 代码生成器。
- en: In the next chapter, you will learn some advanced techniques regarding IR generation.
    Exception handling is fairly common in modern programming languages, and LLVM
    has some support for it. Attaching type information to pointers can help with
    certain optimizations, so we will add this, too. Last but not least, the ability
    to debug an application is essential for many developers, so we will also add
    the generation of debugging metadata to our code generator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习一些关于 IR 生成的先进技术。异常处理在现代编程语言中相当常见，LLVM 对此也有一些支持。将类型信息附加到指针可以帮助进行某些优化，因此我们也会添加这一点。最后但同样重要的是，调试应用程序的能力对于许多开发者来说至关重要，因此我们还将添加调试元数据的生成到我们的代码生成器中。
