- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Getting Started with Multiplayer Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人基础入门
- en: In the previous chapter, we completed the SuperSideScroller game and used 1D
    Blend Spaces, animation blueprints, and animation montages. In this chapter, we’re
    going to build on that knowledge and learn how to add multiplayer functionality
    to a game using Unreal Engine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们完成了 SuperSideScroller 游戏，并使用了 1D 混合空间、动画蓝图和动画蒙太奇。在本章中，我们将在此基础上构建知识，并学习如何使用
    Unreal Engine 为游戏添加多人功能。
- en: 'Multiplayer games have grown quite a lot in the last decade. Games such as
    Fortnite, League of Legends, Rocket League, Overwatch, and Counter-Strike: Global
    Offensive have gained a lot of popularity in the gaming community and have had
    great success. Nowadays, almost all games need to have some kind of multiplayer
    experience to be more relevant and successful.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年中，多人游戏已经发展得相当大。像《堡垒之夜》、《英雄联盟》、《火箭联盟》、《守望先锋》和《反恐精英：全球攻势》这样的游戏在游戏社区中获得了巨大的流行，并取得了巨大的成功。如今，几乎所有的游戏都需要某种多人游戏体验才能更加相关和成功。
- en: The reason for this is it adds a new layer of possibilities on top of the existing
    gameplay, such as being able to remotely play with friends in cooperative mode
    (also known as online co-op) or against people from all around the world, which
    greatly increases the longevity and value of a game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于它为现有的游戏玩法增加了一层新的可能性，例如能够以合作模式（也称为在线合作）远程与朋友一起玩，或者与世界各地的玩家对战，这大大增加了游戏的生命力和价值。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to multiplayer basics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多人基础介绍
- en: Understanding the server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务器
- en: Understanding the client
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解客户端
- en: Packaging the project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目打包
- en: Exploring connections and ownership
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索连接和所有权
- en: Getting to know roles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解角色
- en: Understanding variable replication
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量复制
- en: Exploring 2D Blend Spaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索二维混合空间
- en: Transforming (modifying) bones
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换（修改）骨骼
- en: By the end of this chapter, you’ll know basic multiplayer concepts such as the
    server-client architecture, connections, actor ownership, roles and variable replication
    so that you can create a multiplayer game of your own. You’ll also be able to
    make a 2D Blend Space, which allows you to blend between animations laid out in
    a 2D grid. Finally, you’ll learn how to use Transform (Modify) Bone nodes to control
    Skeletal Mesh bones at runtime.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解基本的多人游戏概念，例如服务器-客户端架构、连接、演员所有权、角色和变量复制，这样你就可以创建自己的多人游戏。你还将能够制作二维混合空间，这允许你在二维网格中混合动画。最后，你将学习如何使用变换（修改）骨骼节点来控制骨骼网格在运行时的骨骼。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following technical requirements:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要以下技术要求：
- en: Unreal Engine 5 installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Unreal Engine 5
- en: Visual Studio 2019 installed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装 Visual Studio 2019
- en: 'The project for this chapter can be found in the `Chapter16` folder of the
    code bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的 `Chapter16` 文件夹中找到，可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: In the next section, we will discuss the basics of multiplayer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论多人游戏的基础知识。
- en: Introduction to multiplayer basics
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人基础介绍
- en: You may have heard the term multiplayer a lot while gaming, but what does it
    mean for game developers? Multiplayer, in reality, is just a set of instructions
    sent through the network (internet or local area network) between the server and
    its connected clients to give players the illusion of a shared world.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，你可能经常听到多人游戏这个术语，但对于游戏开发者来说，它意味着什么呢？实际上，多人游戏只是一组通过网络（互联网或局域网）从服务器发送到其连接客户端的指令，以给玩家营造一个共享世界的错觉。
- en: For this to work, the server needs to be able to talk to clients, but also the
    other way around (client to server). This is because clients are typically the
    ones that affect the game world, so they need a way to be able to inform the server
    of their intentions while playing the game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，服务器需要能够与客户端通信，但同时也需要反过来（客户端到服务器）。这是因为客户端通常是影响游戏世界的角色，因此它们需要一种方式来告知服务器在游戏中的意图。
- en: 'An example of this back and forth communication between the server and a client
    is when a player tries to fire a weapon during a game. Have a look at the following
    diagram, which shows a client-server interaction:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端之间这种来回通信的一个例子是当玩家在游戏中尝试开火时。看看以下图表，它显示了客户端-服务器交互：
- en: '![Figure 16.1 – Client-server interaction when firing a weapon ](img/Figure_16..01_B18531.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1 – 开火时客户端-服务器交互](img/Figure_16..01_B18531.jpg)'
- en: Figure 16.1 – Client-server interaction when firing a weapon
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 开火时客户端-服务器交互
- en: 'Let’s understand the preceding diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的图表：
- en: The player holds the left mouse button down and the client of that player tells
    the server that it wants to fire a weapon.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家按下左鼠标按钮，该玩家的客户端告诉服务器它想要开火。
- en: 'The server validates whether the player can fire the weapon by checking the
    following:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过检查以下内容来验证玩家是否可以开火：
- en: If the player is alive
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家还活着
- en: If the player has the weapon equipped
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家装备了武器
- en: If the player has enough ammo
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家弹药充足
- en: 'If all of the conditions are valid, then the server will do the following:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有条件都有效，则服务器将执行以下操作：
- en: Run the logic to deduct ammo.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行逻辑以扣除弹药。
- en: Spawn the projectile actor on the server, which is automatically sent to all
    of the clients.
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上生成投射物演员，该演员会自动发送到所有客户端。
- en: Play the fire animation on that character instance in all of the clients to
    ensure synchronicity between all of them, which helps to sell the idea that it’s
    the same world, even though it’s not.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有客户端上播放该角色实例的射击动画，以确保它们之间的同步性，这有助于传达这是一个相同世界的想法，即使实际上并非如此。
- en: 'If any of the conditions fail, then the server tells the specific client what
    to do:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何条件失败，则服务器会告诉特定的客户端该做什么：
- en: 'The player is dead: Don’t do anything.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家已死亡：不要做任何事情。
- en: 'The player doesn’t have the weapon equipped: Don’t do anything.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家没有装备武器：不要做任何事情。
- en: 'The player doesn’t have enough ammo: Play an empty click sound.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家弹药不足：播放一个空点击声音。
- en: Remember, if you want your game to support multiplayer, then it’s highly recommended
    that you do that as soon as possible in your development cycle. If you try to
    run a single-player project with multiplayer enabled, you’ll notice that some
    functionalities might just work, but probably most of them won’t be working properly
    or as expected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你想你的游戏支持多人模式，那么在开发周期中尽早这样做是非常推荐的。如果你尝试运行一个已启用多人模式的单人项目，你会发现一些功能可能只是部分工作，但很可能大多数功能都不会正常或如预期地工作。
- en: The reason for that is when you execute the game in single-player, the code
    runs locally and instantly, but when you add multiplayer into the equation, you
    are adding external factors such as an authoritative server that talks to clients
    on a network with latency, as you saw in *Figure 16.1*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当你以单人模式执行游戏时，代码在本地立即运行，但当你添加多人模式时，你正在添加外部因素，例如一个权威服务器，它与网络上的客户端进行通信，具有延迟，正如你在*图16.1*中看到的。
- en: 'To get everything working properly, you need to break the existing code into
    the following components:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切正常工作，你需要将现有代码分解成以下组件：
- en: Code that only runs on the server
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在服务器上运行的代码
- en: Code that only runs on the client
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在客户端运行的代码
- en: Code that runs on both the server and the client
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和客户端上运行的代码
- en: To add multiplayer support to games, UE5 comes with a very powerful and bandwidth-efficient
    network framework already built in that uses an authoritative server-client architecture.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要为游戏添加多人支持，UE5已经内置了一个非常强大且带宽高效的网络框架，该框架使用权威服务器-客户端架构。
- en: 'Here is a diagram of how it works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何工作的图表：
- en: '![Figure 16.2 – Server-client architecture in UE5 ](img/Figure_16..02_B18531.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2 – UE5中的服务器-客户端架构](img/Figure_16..02_B18531.jpg)'
- en: Figure 16.2 – Server-client architecture in UE5
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – UE5中的服务器-客户端架构
- en: Here, you can see how the server-client architecture works in UE5\. Each player
    controls a client that communicates with the server using a two-way connection.
    The server runs a specific level with a game mode (that only exists in the server)
    and controls the flow of information so that the clients can see and interact
    with each other in the game world.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到UE5中服务器-客户端架构是如何工作的。每个玩家控制一个客户端，该客户端通过双向连接与服务器通信。服务器运行一个特定级别的游戏模式（该模式仅存在于服务器）并控制信息流，以便客户端可以在游戏世界中相互看到并交互。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Multiplayer can be a very advanced topic, so these next few chapters will serve
    as an introduction to help you understand the essentials, but it will not be an
    in-depth look. For that reason, some concepts might be omitted for the sake of
    simplicity.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏可以是一个非常高级的话题，所以接下来的几章将作为介绍，帮助你理解基本概念，但不会进行深入探讨。因此，为了简化，可能会省略一些概念。
- en: At this point, you have an idea of how multiplayer basics work. Now, let’s dive
    in and see how servers work and what their responsibilities are.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经对多人游戏的基本工作原理有了了解。现在，让我们深入探讨服务器的工作原理以及它们的职责。
- en: Understanding the server
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务器
- en: The server is the most critical part of the architecture since it’s responsible
    for handling most of the work and making important decisions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是架构中最关键的部分，因为它负责处理大部分工作并做出重要决策。
- en: 'Here is an overview of the main responsibilities of a server:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是服务器主要职责的概述：
- en: '**Creating and managing the shared world instance**: The server runs its instance
    of the game in a specific level and game mode (this will be covered in [*Chapter
    18*](B18531_18.xhtml#_idTextAnchor404), *Using Gameplay Framework Classes in Multiplayer*),
    which will serve as the shared world between all of the connected clients. The
    level being used can be changed at any point in time and, if applicable, the server
    can bring along all of the connected clients with it automatically.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建和管理共享世界实例**：服务器在其特定的关卡和游戏模式中运行其游戏实例（这将在[*第18章*](B18531_18.xhtml#_idTextAnchor404)，*在多人游戏中使用游戏框架类)中，这将作为所有连接客户端之间的共享世界。正在使用的关卡可以在任何时间点更改，如果适用，服务器可以自动将所有连接的客户端一起带走。'
- en: '**Handling client join and leave requests**: If a client wants to connect to
    a server, it needs to ask for permission. To do this, the client sends a join
    request to the server, through a direct IP connection (explained in the next section)
    or an online subsystem such as Steam. Once the join request reaches the server,
    it will perform some validations to determine whether the request is accepted
    or rejected.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理客户端加入和离开请求**：如果客户端想要连接到服务器，它需要请求许可。为此，客户端向服务器发送加入请求，通过直接IP连接（下一节将解释）或在线子系统（如Steam）。一旦加入请求到达服务器，它将执行一些验证以确定请求是否被接受或拒绝。'
- en: Some of the most common reasons why the server rejects a request are if the
    server is already at full capacity and can’t take any more clients or if the client
    is using an out-of-date version of the game. If the server accepts the request,
    then a player controller with a connection is assigned to the client and the `PostLogin`
    function in the game mode is called. From that point on, the client will enter
    the game and is now part of the shared world, where the player will be able to
    see and interact with other clients. If a client disconnects at any point in time,
    then all of the other clients will be notified and the `Logout` function in the
    game mode will be called.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器拒绝请求的一些最常见原因包括：如果服务器已经达到最大容量，无法再接受更多客户端，或者如果客户端正在使用过时的游戏版本。如果服务器接受请求，则将为客户端分配一个具有连接的玩家控制器，并调用游戏模式中的`PostLogin`函数。从那时起，客户端将进入游戏，现在成为共享世界的一部分，玩家将能够看到并与其他客户端互动。如果客户端在任何时候断开连接，则所有其他客户端都将收到通知，并调用游戏模式中的`Logout`函数。
- en: '**Spawning the actors that all of the clients need to know about**: If you
    want to spawn an actor that exists in all of the clients, then you need to do
    that on the server. The reason for this is that the server has the authority and
    is the only one that can tell each client to create an instance of that actor.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成所有客户端都需要了解的行为者**：如果你想在所有客户端中生成一个存在的行为者，那么你需要在服务器上完成这个操作。原因是服务器拥有权威，并且是唯一一个可以告诉每个客户端创建该行为者实例的实体。'
- en: This is the most common way of spawning actors in multiplayer since most actors
    need to exist in all of the clients. An example of this would be with a power-up,
    which is something that all clients can see and interact with.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在多人游戏中生成行为者的最常见方式，因为大多数行为者都需要存在于所有客户端中。一个例子是增益效果，这是所有客户端都可以看到并与之互动的东西。
- en: '**Running critical gameplay logic**: To make sure that the game is fair to
    all of the clients, the critical gameplay logic needs to be executed on the server
    only. If the clients were responsible for handling the deduction of health, it
    would be very exploitable, because a player could use a tool to change the current
    value of health to 100% all the time in memory, so the player would never die
    in the game.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行关键游戏逻辑**：为了确保游戏对所有客户端都是公平的，关键游戏逻辑必须在服务器上执行。如果客户端负责处理健康值的扣除，那么这将非常容易被利用，因为玩家可以使用工具在内存中更改当前健康值到100%，因此玩家在游戏中永远不会死亡。'
- en: '**Handling variable replication**: If you have a replicated variable (covered
    in the *Understanding variable replication* section), then its value should only
    be changed on the server. This will ensure that all of the clients will have the
    value updated automatically. You can still change the value on the client, but
    it will always be replaced with the latest value from the server to prevent cheating
    and to make sure all of the clients are in sync.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理变量复制**：如果你有一个复制的变量（在*理解变量复制*部分介绍），那么其值应该只在服务器上更改。这将确保所有客户端都将自动更新值。你仍然可以在客户端更改值，但它将始终被服务器上的最新值替换，以防止作弊并确保所有客户端保持同步。'
- en: '**Handling RPCs from the client**: The server needs to process the **remote
    procedure calls** (**RPCs**) (covered in [*Chapter 17*](B18531_17.xhtml#_idTextAnchor386),
    *Using Remote Procedure Calls*) that are sent from the clients.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理来自客户端的 RPC**：服务器需要处理来自客户端的**远程过程调用**（RPC）（在[*第17章*](B18531_17.xhtml#_idTextAnchor386)，*使用远程过程调用*）。'
- en: Now that you know what a server does, we can talk about the two different ways
    of creating a server in UE5.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了服务器的作用，我们可以讨论在 UE5 中创建服务器的两种不同方式。
- en: Dedicated server
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用服务器
- en: The dedicated server only runs the server logic, so you won’t see the typical
    window with the game running where you control a character as a normal player.
    This means that all the clients will connect to this server and its only job is
    to coordinate them and execute the critical gameplay logic. Additionally, if you
    run the dedicated server with the `-log` command prompt, you’ll have a console
    window that logs relevant information about what is happening on the server, such
    as if a client has connected or disconnected, and so on. You, as a developer,
    can also log your information by using the `UE_LOG` macro.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 专用服务器只运行服务器逻辑，因此你不会看到典型的运行游戏并控制角色的窗口，就像普通玩家一样。这意味着所有客户端都将连接到这个服务器，它的唯一任务是协调它们并执行关键的游戏逻辑。此外，如果你使用
    `-log` 命令提示符运行专用服务器，你将有一个控制台窗口，它会记录有关服务器上发生的事情的相关信息，例如客户端是否已连接或断开连接等。作为开发者，你也可以通过使用
    `UE_LOG` 宏来记录你的信息。
- en: Using dedicated servers is a very common way of creating servers for multiplayer
    games, and since it’s more lightweight than a listen server (covered in the next
    section), you could just host it on a server stack and leave it running. Another
    advantage of dedicated servers is that it will make the game fairer for all players
    because the network conditions will be the same for everyone, and also because
    none of the clients has authority, so the possibility of a hack is reduced.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用服务器是创建多人游戏服务器的非常常见方式，并且由于它比监听服务器（下一节中介绍）更轻量级，你可以在服务器堆栈上托管它并让它运行。专用服务器的另一个优点是它将使游戏对所有玩家都更加公平，因为每个人的网络条件都将相同，而且由于没有客户端具有权限，因此黑客的可能性降低。
- en: 'To start a dedicated server in UE5, you can use the following command arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 UE5 中启动专用服务器，你可以使用以下命令参数：
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符运行以下命令以在编辑器内启动专用服务器：
- en: '[PRE0]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s an example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a packaged dedicated server requires a build of the project that’s
    been built specifically to serve as a dedicated server.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建打包专用服务器需要构建专门作为专用服务器构建的项目。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find out more about setting up a packaged dedicated server at [https://docs.unrealengine.com/5.0/en-US/InteractiveExperiences/Networking/HowTo/DedicatedServers/](https://docs.unrealengine.com/5.0/en-US/InteractiveExperiences/Networking/HowTo/DedicatedServers/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unrealengine.com/5.0/en-US/InteractiveExperiences/Networking/HowTo/DedicatedServers/](https://docs.unrealengine.com/5.0/en-US/InteractiveExperiences/Networking/HowTo/DedicatedServers/)了解更多关于设置打包专用服务器的信息。
- en: The listen server
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听服务器
- en: The listen server acts as a server and client at the same time, so you’ll also
    have a window where you can play the game as a client with this server type. It
    also has the advantage of being the quickest way of getting a server running in
    a packaged build, but it’s not as lightweight as a dedicated server, so the number
    of clients that can be connected at the same time will be limited.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 监听服务器同时充当服务器和客户端，因此你还将有一个窗口，你可以使用这种服务器类型作为客户端玩游戏。它还有优点是它是将服务器快速运行在打包构建中的最快方式，但它不如专用服务器轻量，因此同时可以连接的客户端数量将受到限制。
- en: 'To start a listen server, you can use the following command arguments:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动监听服务器，你可以使用以下命令参数：
- en: 'Run the following command to start a listen server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行以下命令通过快捷方式或命令提示符在编辑器内启动监听服务器：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using a packaged development build through a shortcut or Command Prompt:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符使用打包的开发构建：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that you know about the two different types of servers you have in Unreal
    Engine, we can now move on to its counterpart – the client and its responsibilities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在Unreal Engine中有两种不同类型的服务器，我们可以继续讨论其对应物——客户端及其职责。
- en: Understanding the client
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解客户端
- en: The client is the simplest part of the architecture because most of the actors
    will have the authority on the server, so in those cases, the work will be done
    on the server and the client will just obey its orders.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是架构中最简单的部分，因为大多数参与者都将拥有服务器的权限，所以在这些情况下，工作将在服务器上完成，而客户端只需服从其命令。
- en: 'Here is an overview of the main responsibilities of a client:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是客户端主要职责的概述：
- en: '**Enforcing variable replication from the server**: The server typically has
    authority over all of the actors that the client knows, so when the value of a
    replicated variable is changed on the server, the client needs to enforce that
    value as well.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行从服务器复制变量的强制操作**：服务器通常对客户端所知的所有参与者拥有权限，因此当复制的变量值在服务器上更改时，客户端需要强制执行该值。'
- en: '**Handling RPCs from the server**: The client needs to process the RPCs (covered
    in [*Chapter 17*](B18531_17.xhtml#_idTextAnchor386), *Using Remote Procedure Calls*)
    that are sent from the server.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理来自服务器的RPC**：客户端需要处理从服务器发送的RPC（在第17章[*使用远程过程调用*](B18531_17.xhtml#_idTextAnchor386)中介绍），*使用远程过程调用*。'
- en: '**Predicting movement when simulating**: When a client is simulating an actor
    (covered in the *Getting to know roles* section), it needs to locally predict
    where it’s going to be based on the actor’s velocity.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在模拟时预测移动**：当客户端模拟一个参与者（在*了解角色*部分中介绍）时，它需要根据参与者的速度本地预测它将去哪里。'
- en: '**Spawning the actors that only a client needs to know about**: If you want
    to spawn an actor that only exists on a client, then you need to do it on that
    specific client.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成客户端需要了解的参与者**：如果你想生成一个仅在客户端存在的参与者，那么你需要在该特定客户端上执行。'
- en: This is the least common way of spawning actors since there are fewer cases
    where you want an actor to only exist on a client. An example of this is the placement
    preview actor you see in multiplayer survival games, where the player controls
    a semi-transparent version of a wall that other players can’t see until it’s placed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成参与者最不常见的方式，因为很少需要让参与者仅在客户端存在。这种例子是多玩家生存游戏中你看到的放置预览参与者，玩家控制一个半透明的墙壁版本，其他玩家在放置之前看不到它。
- en: 'A client can join a server in a couple of different ways. Here is a list of
    the most common methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以通过几种不同的方式加入服务器。以下是最常见的方法列表：
- en: 'By opening the UE5 console (by default, this can be done with the `` ` `` key)
    in a development build and typing the following:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在开发构建中打开UE5控制台（默认情况下，可以使用`` ` ``键）并输入以下内容：
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s an example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the `Execute Console Command` Blueprint node. An example is as follows:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Execute Console Command`蓝图节点。以下是一个例子：
- en: '![Figure 16.3 – Joining a server with an example IP with the Execute Console
    Command node ](img/Figure_16..03_B18531.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3 – 使用执行控制台命令节点连接具有示例IP的服务器](img/Figure_16..03_B18531.jpg)'
- en: Figure 16.3 – Joining a server with an example IP with the Execute Console Command
    node
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 使用执行控制台命令节点连接具有示例IP的服务器
- en: 'Using the `ConsoleCommand` function in `APlayerController`, as follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`APlayerController`中使用`ConsoleCommand`函数，如下所示：
- en: '[PRE8]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the editor executable through a shortcut or Command Prompt:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符使用编辑器可执行文件：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using a packaged development build through a shortcut or Command Prompt:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符使用打包的开发构建：
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the following exercise, we will test the **Third Person** template that comes
    with UE5 in multiplayer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将测试UE5附带的多人**第三人称**模板。
- en: Exercise 16.01 – Testing the Third Person template in multiplayer
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.01 – 在多人模式下测试第三人称模板
- en: In this exercise, we’re going to create a **Third Person** template project
    and play it in multiplayer.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个**第三人称**模板项目并在多人模式下播放它。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new `TestMultiplayer` and save it to a location of your choosing.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`TestMultiplayer`并将其保存到您选择的地点。
- en: Once the project has been created, it should open the editor. Now, let’s test
    the project in multiplayer to see how it behaves.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，它应该会打开编辑器。现在，让我们在多人模式下测试项目，看看它的表现如何。
- en: 'In the editor, to the right of the **Play** button, you have a button with
    three vertical dots. Click on it and you should see a list of options. Under the
    **Multiplayer Options** section, you can configure how many clients you want and
    specify the net mode, which has the following options:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，**播放**按钮的右侧有一个带三个垂直点的按钮。单击它，您应该会看到一个选项列表。在**多人选项**部分，您可以配置您想要的客户端数量并指定网络模式，它有以下选项：
- en: '**Play Standalone**: Runs the game in single player'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立运行游戏**：以单玩家模式运行游戏'
- en: '**Play As Listen Server**: Runs the game with a listen server'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为监听服务器运行游戏**：以监听服务器运行游戏'
- en: '**Play As Client**: Runs the game with a dedicated server'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为客户端运行游戏**：以专用服务器运行游戏'
- en: Make sure the `3`, and click on **New Editor Window (PIE)**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择`3`，然后单击**新建编辑器窗口（PIE**）。
- en: 'You should see three windows on top of each other representing the three clients:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到三个重叠的窗口，代表三个客户端：
- en: '![Figure 16.4 – Launching three client windows with a listen server ](img/Figure_16..04_B18531.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4 – 使用监听服务器启动三个客户端窗口](img/Figure_16..04_B18531.jpg)'
- en: Figure 16.4 – Launching three client windows with a listen server
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 使用监听服务器启动三个客户端窗口
- en: As you can see, the server window is bigger than the client windows, so let’s
    change its size. Press *Esc* on your keyboard to stop playing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，服务器窗口比客户端窗口大，所以让我们改变它的大小。按键盘上的*Esc*键停止播放。
- en: Once again, click on the button with the three vertical dots next to the **Play**
    button and pick the last option, **Advanced Settings**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击位于**播放**按钮旁边的带三个垂直点的按钮，并选择最后一个选项，**高级设置**。
- en: Search for the `640x480` and close the **Editor Preferences** tab.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`640x480`并关闭**编辑器首选项**选项卡。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This option will only change the size of the server window. If you want to change
    the size of the client window, you can modify the value of the **Multiplayer Viewport
    Size** option, which you can find by scrolling down a bit more in the same menu.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项只会更改服务器窗口的大小。如果您想更改客户端窗口的大小，可以修改**多人视角大小**选项的值，您可以在同一菜单中向下滚动一点找到它。
- en: 'Play the game again; you should see the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次玩游戏；你应该会看到以下内容：
- en: '![Figure 16.5 – Launching three client windows using a 640x480 resolution with
    a listen server  ](img/Figure_16..05_B18531.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 – 使用640x480分辨率和监听服务器启动三个客户端窗口](img/Figure_16..05_B18531.jpg)'
- en: Figure 16.5 – Launching three client windows using a 640x480 resolution with
    a listen server
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 使用640x480分辨率和监听服务器启动三个客户端窗口
- en: Once you start playing, you’ll notice that the title bars of the windows say
    **Server**, **Client 1**, and **Client 2**. Since you can control a character
    in the **Server** window, that means we’re running a listen server, where you
    have the server and a client running in the same window. When that happens, you
    should interpret the window title as **Server + Client 0** instead of just **Server**
    to avoid confusion.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏后，你会注意到窗口的标题栏上写着**服务器**、**客户端 1**和**客户端 2**。由于您可以在**服务器**窗口中控制一个角色，这意味着我们正在运行一个监听服务器，其中服务器和客户端在同一窗口中运行。当这种情况发生时，您应该将窗口标题解释为**服务器
    + 客户端 0**而不是仅仅**服务器**，以避免混淆。
- en: By completing this exercise, you have a setup where you have a server and three
    clients running (**Client 0**, **Client 1**, and **Client 2**).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您将有一个服务器和三个客户端运行（**客户端 0**、**客户端 1**和**客户端 2**）的设置。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When you have multiple windows running at the same time, you’ll notice that
    you can only have input focus on one window at a time. To shift the focus to another
    window, just press *Shift* + *F1* to lose the current input focus, and then click
    on the new window you want to focus on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你同时运行多个窗口时，你会注意到你一次只能有一个窗口获得输入焦点。要将焦点转移到另一个窗口，只需按*Shift* + *F1*来失去当前输入焦点，然后点击你想要聚焦的新窗口。
- en: If you play the game in one of the windows, you’ll notice that you can move
    around and jump. When you do those actions the other clients will also be able
    to see that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个窗口中玩游戏，你会注意到你可以移动和跳跃。当你执行这些动作时，其他客户端也会看到这些动作。
- en: The reason why everything works is because the character movement component,
    which comes with the character class, replicates the location, rotation, and falling
    state (used to determine whether you are in the air or not) for you automatically.
    If you want to add a custom behavior such as an attack animation, you can’t just
    tell the client to play an animation locally when a key is pressed, because that
    will not work on the other clients. That’s why you need the server – to serve
    as an intermediary and tell all the clients to play the animation when one client
    presses the key.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都工作得很好，原因是因为与角色类一起提供的角色移动组件会自动为你复制位置、旋转和下落状态（用于确定你是否在空中）。如果你想添加一个自定义行为，例如攻击动画，你不能只是告诉客户端在按键时在本地播放动画，因为这不会在其他客户端上工作。这就是为什么你需要服务器——作为中介并告诉所有客户端在某个客户端按下键时播放动画。
- en: In this exercise, we’ve learned how to test multiplayer in the editor. Now,
    let’s learn how to do the same on a packaged build.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何在编辑器中测试多人游戏。现在，让我们学习如何在打包构建中做同样的事情。
- en: Packaging the project
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包项目
- en: Once you’ve finished the project, it’s good practice to package it so that you
    have a pure standalone version that doesn’t use the Unreal Engine editor. This
    will run faster and be more lightweight.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成项目，打包它是一个好习惯，以便你有一个不使用虚幻引擎编辑器的纯独立版本。这将运行得更快，更轻量。
- en: 'Follow these steps to create the packaged version of the file in *Exercise
    16.01 – Testing the Third Person template in multiplayer*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建*练习16.01 – 测试第三人称模板在多人游戏中的*打包版本：
- en: Go to **Platforms** (to the right of the **Play** button) | **Windows** | **Package
    Project**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**平台**（位于**播放**按钮右侧）| **Windows** | **打包项目**。
- en: Pick a folder to place the packaged build and wait for it to finish.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个文件夹来放置打包构建，并等待其完成。
- en: Once it has finished, go to the selected folder and open the `Windows` folder
    inside it.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，转到所选文件夹并打开其中的`Windows`文件夹。
- en: Right-click on **TestMultiplayer.exe** and pick **Create Shortcut**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**TestMultiplayer.exe**并选择**创建快捷方式**。
- en: Rename the new shortcut **Run Server**.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新快捷方式重命名为**Run Server**。
- en: Right-click on it and pick **Properties**.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它并选择**属性**。
- en: 'On the target, append `ThirdPersonMap?Listen -server`, which will create a
    listen server using `ThirdPersonMap`. You should end up with this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`ThirdPersonMap?Listen -server`，这将使用`ThirdPersonMap`创建一个监听服务器。你应该得到这个：
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click **OK** and run the shortcut.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**并运行快捷方式。
- en: You should get a Windows Firewall prompt; allow it.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会收到Windows防火墙提示；允许它。
- en: Leave the server running, go back to the folder (using ALT+TAB or pressing the
    Windows Key and selecting another window from the taskbar), and create another
    shortcut from **TestMultiplayer.exe**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让服务器继续运行，回到文件夹（使用ALT+TAB或按Windows键并从任务栏中选择另一个窗口），然后从**TestMultiplayer.exe**创建另一个快捷方式。
- en: Rename it `Run Client`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`Run Client`。
- en: Right-click on it and pick **Properties**.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它并选择**属性**。
- en: On the target, append `127.0.0.1`, which is the IP of your local server. You
    should end up with `"<Packaged Path>\Windows\TestMultiplayer.exe" 127.0.0.1`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`127.0.0.1`，这是你的本地服务器的IP。你应该得到`"<打包路径>\Windows\TestMultiplayer.exe" 127.0.0.1`。
- en: Click **OK** and run the shortcut.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**并运行快捷方式。
- en: You are now connected to the listen server, which means you can see each other’s
    characters. Every time you click on the **Run Client** shortcut, you’ll add a
    new client to the server so that you can have a few clients running on the same
    machine.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经连接到监听服务器，这意味着你可以看到彼此的角色。每次你点击**Run Client**快捷方式时，你都会向服务器添加一个新客户端，这样你就可以在同一台机器上运行几个客户端。
- en: Once you are done testing the packaged build, you can hit ALT+F4 to close each
    window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成打包构建的测试，你可以按ALT+F4关闭每个窗口。
- en: Now that we know how to test our packaged project in multiplayer, let’s take
    a look at connections and ownership, which allow us to have a two-way communication
    line between the server and the client.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何在多玩家中测试我们的打包项目，让我们看看连接和所有权，这允许我们在服务器和客户端之间建立双向通信线路。
- en: Exploring connections and ownership
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索连接和所有权
- en: When using multiplayer in Unreal Engine, an important concept to understand
    is that of a connection. When a client joins a server, it will get a new Player
    Controller with a connection associated with it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚幻引擎的多玩家功能时，一个需要理解的重要概念是连接。当一个客户端加入服务器时，它将获得一个新的与连接关联的玩家控制器。
- en: If an actor doesn’t have a valid connection with the server, then it won’t be
    able to do replication operations such as variable replication (covered in the
    *Understanding variable replication* section) or call RPCs (covered in [*Chapter
    17*](B18531_17.xhtml#_idTextAnchor386), *Using Remote Procedure Calls*).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个演员与服务器没有有效的连接，那么它将无法执行复制操作，例如变量复制（在*理解变量复制*部分介绍）或调用RPCs（在[*第17章*](B18531_17.xhtml#_idTextAnchor386)，*使用远程过程调用*）。
- en: If the Player Controller is the only actor that holds a connection, then does
    that mean that it’s the only place you can do replication operations? No, and
    that’s where the `GetNetConnection` function, defined in `AActor`, comes into
    play.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家控制器是唯一持有连接的演员，那么这意味着它是唯一可以进行复制操作的地方吗？不，这就是`GetNetConnection`函数发挥作用的地方，该函数在`AActor`中定义。
- en: When doing replication operations (such as variable replication or calling RPCs)
    on an actor, the network framework will get the actor’s connection by calling
    the `GetNetConnection()` function on it. If the connection is valid, then the
    replication operation will be processed; if it’s not, nothing will happen. The
    most common implementations of `GetNetConnection()` are from `APawn` and `AActor`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在对演员执行复制操作（如变量复制或调用RPCs）时，网络框架将通过在演员上调用`GetNetConnection()`函数来获取演员的连接。如果连接有效，复制操作将被处理；如果无效，则不会发生任何事情。`GetNetConnection()`函数最常见的实现来自`APawn`和`AActor`。
- en: 'Let’s take a look at how the `APawn` class implements the `GetNetConnection()`
    function, which is typically used for characters:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`APawn`类是如何实现`GetNetConnection()`函数的，这个函数通常用于角色：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding implementation, which is part of the UE5 source code, will first
    check whether the pawn has a valid controller. If the controller is valid, then
    it will use its connection. If the controller is not valid, then it will use the
    parent implementation of the `GetNetConnection()` function, which is on `AActor`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的实现，它是UE5源代码的一部分，首先会检查演员是否有有效的控制器。如果控制器有效，它将使用其连接。如果控制器无效，它将使用`GetNetConnection()`函数的父实现，该实现位于`AActor`：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding implementation, which is also part of the UE5 source code, will
    check if the actor has a valid owner. If it does, it will use the owner’s connection;
    if it doesn’t, it will return an invalid connection. So, what is this `Owner`
    variable? Every actor has a variable called `Owner` (where you can set its value
    by calling the `SetOwner` function) that stores which actor owns it, so you can
    think of it as its parent actor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的实现，同样是UE5源代码的一部分，会检查演员是否有有效的所有者。如果有，它将使用所有者的连接；如果没有，它将返回一个无效的连接。那么，这个`Owner`变量是什么？每个演员都有一个名为`Owner`的变量（你可以通过调用`SetOwner`函数来设置其值），它存储了拥有它的演员，所以你可以将其视为其父演员。
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a listen server, the connection for the character that’s controlled by its
    client will always be invalid. This is because that client is already a part of
    the server and therefore doesn’t need a connection.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听服务器中，由客户端控制的角色的连接始终是无效的。这是因为该客户端已经是服务器的一部分，因此不需要连接。
- en: 'Using the owner’s connection in this implementation of `GetNetConnection()`
    will work like a hierarchy. If, while going up the hierarchy of owners, it finds
    an owner that is a Player Controller or is being controlled by one, then it will
    have a valid connection and will be able to process replication operations. Have
    a look at the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetNetConnection()`函数的这个实现中，使用所有者的连接将像层次结构一样工作。如果在向上遍历所有者层次结构的过程中，它找到一个所有者是玩家控制器或者被一个玩家控制器控制，那么它将有一个有效的连接，并且能够处理复制操作。看看下面的例子：
- en: Imagine that a weapon actor was placed in the world and it’s just sitting there.
    In that situation, the weapon won’t have an owner, so if the weapon tries to do
    any replication operations, such as variable replication or calling RPCs, nothing
    will happen.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，一个武器演员被放置在世界上，它就那样静静地坐着。在这种情况下，武器将没有所有者，因此如果武器尝试执行任何复制操作，例如变量复制或调用RPC，将不会发生任何事。
- en: However, if a client picks up the weapon and calls `SetOwner` on the server
    with the value of the character, then the weapon will now have a valid connection.
    The reason for this is because the weapon is an actor, so to get its connection,
    it will use the `AActor` implementation of `GetNetConnection()`, which returns
    the connection of its owner. Since the owner is the client’s character, it will
    use the implementation of `GetNetConnection()` of `APawn`. The character has a
    valid Player Controller, so that is the connection returned by the function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果客户端捡起武器并在服务器上调用带有角色值的`SetOwner`，那么武器现在将有一个有效的连接。这是因为武器是一个演员，所以为了获取其连接，它将使用`AActor`的`GetNetConnection()`实现，该实现返回其所有者的连接。由于所有者是客户端的角色，它将使用`APawn`的`GetNetConnection()`实现。角色有一个有效的玩家控制器，因此这是函数返回的连接。
- en: 'Here is a diagram to help you understand this logic:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表来帮助您理解这个逻辑：
- en: '![Figure 16.6 – Connections and ownership example of a weapon actor ](img/Figure_16..06_B18531.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – 武器演员的连接和所有权示例](img/Figure_16..06_B18531.jpg)'
- en: Figure 16.6 – Connections and ownership example of a weapon actor
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 武器演员的连接和所有权示例
- en: 'If the weapon has an invalid owner, then this is what will happen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果武器有一个无效的所有者，那么会发生以下情况：
- en: '`AWeapon` doesn’t override the `GetNetConnection` function, so it will call
    the first implementation found in the class hierarchy, which is `AActor::GetNetConnection`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有重写`GetNetConnection`函数，所以它将调用类层次结构中找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since there is no owner, the connection is invalid.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现会调用其所有者的`GetNetConnection`。由于没有所有者，连接是无效的。'
- en: 'If the weapon has an valid owner, then this is what will happen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果武器有一个有效的所有者，那么会发生以下情况：
- en: '`AWeapon` doesn’t override the `GetNetConnection` function, so it will call
    the first implementation found in the class hierarchy, which is `AActor::GetNetConnection`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有重写`GetNetConnection`函数，所以它将调用类层次结构中找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since the owner of the weapon is the character that picked it up, then
    it will call `GetNetConnection` on it.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现会调用其所有者的`GetNetConnection`。由于武器的所有者是捡起它的角色，因此它将调用其上的`GetNetConnection`。'
- en: '`ACharacter` doesn’t override the `GetNetConnection` function, so it will call
    the first implementation found in the class hierarchy, which is `APawn::GetNetConnection`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACharacter`没有重写`GetNetConnection`函数，所以它将调用类层次结构中找到的第一个实现，即`APawn::GetNetConnection`。'
- en: The implementation of `APawn::GetNetConnection` uses the connection from the
    owning player controller. Since the owning player controller is valid, then it
    will use that connection for the weapon.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APawn::GetNetConnection`的实现使用了拥有者的连接。由于拥有者控制器是有效的，因此它将为武器使用该连接。'
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For `SetOwner` to work as intended, it needs to be executed on the authority,
    which, in most cases, means the server. If you execute `SetOwner` on a game instance
    that is not the authority, it won’t be able to execute replication operations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`SetOwner`按预期工作，它需要在授权者处执行，在大多数情况下，这意味着服务器。如果你在一个不是授权者的游戏实例上执行`SetOwner`，它将无法执行复制操作。
- en: In this section, we learned how connections and ownership allow the server and
    client to communicate in both directions. Next, we’re going to learn about the
    concept of the roles of an actor, which tells us the version of the actor that
    is executing the code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了连接和所有权如何使服务器和客户端双向通信。接下来，我们将学习关于演员角色的概念，它告诉我们正在执行代码的演员版本。
- en: Getting to know roles
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解角色
- en: When an actor is spawned on the server, it will create a version on the server,
    as well as one on each client. Since there are different versions of the same
    actor on different instances of the game (`Server`, `Client 1`, `Client 2`, and
    so on), it is important to know which version of the actor is which. This will
    allow us to know what logic can be executed in each of these instances.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当演员在服务器上生成时，它将在服务器上创建一个版本，以及在每个客户端上创建一个版本。由于在游戏的各个实例（`服务器`、`客户端 1`、`客户端 2` 等）上存在相同演员的不同版本，因此知道哪个版本是哪个版本非常重要。这将使我们能够知道在每个这些实例中可以执行什么逻辑。
- en: 'To help with this situation, every actor has the following two variables:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助这种情况，每个演员都有以下两个变量：
- en: '`GetLocalRole()` function.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetLocalRole()` 函数。'
- en: '`GetRemoteRole()` function.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRemoteRole()` 函数。'
- en: 'The return type of the `GetLocalRole()` and `GetRemoteRole()` functions is
    `ENetRole`, which is an enumeration that can have the following possible values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLocalRole()` 和 `GetRemoteRole()` 函数的返回类型是 `ENetRole`，这是一个枚举，可以有以下可能的值：'
- en: '`ROLE_None`: The actor doesn’t have a role because it’s not being replicated.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_None`：演员没有角色，因为它没有被复制。'
- en: '`ROLE_SimulatedProxy`: The current game instance doesn’t have authority over
    the actor and it’s not being controlled by a Player Controller. This means that
    its movement will be simulated/predicted by using the last value of the actor’s
    velocity.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_SimulatedProxy`：当前游戏实例没有对演员的权限，并且它没有被玩家控制器控制。这意味着它的运动将通过使用演员速度的最后一个值来模拟/预测。'
- en: '`ROLE_AutonomousProxy`: The current game instance doesn’t have authority over
    the actor, but it’s being controlled by a Player Controller. This means that we
    can send more accurate movement information to the server, based on the player’s
    inputs, instead of just using the last value of the actor’s velocity.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_AutonomousProxy`：当前游戏实例没有对演员的权限，但它被玩家控制器控制。这意味着我们可以根据玩家的输入向服务器发送更精确的运动信息，而不是仅仅使用演员速度的最后一个值。'
- en: '`ROLE_Authority`: The current game instance has complete authority over the
    actor. This means that if the actor is on the server, the changes that are made
    to its replicated variables will be treated as the value that every client needs
    to enforce through variable replication.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_Authority`：当前游戏实例对演员拥有完全的权限。这意味着如果演员在服务器上，对其复制变量的更改将被视为每个客户端需要通过变量复制强制执行的值。'
- en: 'Let’s have a look at the following example code snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码片段：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code snippet will store the values of the local role and remote
    role in `MyLocalRole` and `MyRemoteRole`, respectively. After that, it will print
    different messages on the screen, depending on whether that version of the actor
    is the authority or whether it’s being controlled by a player on its client.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将分别将本地角色和远程角色的值存储在 `MyLocalRole` 和 `MyRemoteRole` 中。之后，它将根据该演员的版本是否是权威版本或是否由客户端上的玩家控制，在屏幕上打印不同的消息。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand that if an actor has a local role of `ROLE_Authority`,
    it doesn’t mean that it’s on the server; it means that it’s on the game instance
    that originally spawned it and therefore has authority over it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，如果一个演员具有 `ROLE_Authority` 的本地角色，并不意味着它在服务器上；这意味着它在最初产生它的游戏实例上，因此对其拥有权限。
- en: If a client spawns an actor, even though the server and the other clients won’t
    know about it, its local role will still be `ROLE_Authority`. Most of the actors
    in a multiplayer game will be spawned by the server; that’s why it’s easy to misunderstand
    that the authority is always referring to the server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端生成一个演员，即使服务器和其他客户端不知道它，它的本地角色仍然会是 `ROLE_Authority`。大多数多人游戏中的演员都是由服务器生成的；这就是为什么很容易误解权限总是指服务器。
- en: 'Here is a table to help you understand the roles that an actor will have in
    different scenarios:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个表格，可以帮助您了解演员在不同场景中会扮演的角色：
- en: '![Figure 16.7 – Roles that an actor can have in different scenarios ](img/Figure_16..07_B18531.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – 演员在不同场景中可以扮演的角色](img/Figure_16..07_B18531.jpg)'
- en: Figure 16.7 – Roles that an actor can have in different scenarios
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 演员在不同场景中可以扮演的角色
- en: In the preceding table, you can see the roles that an actor will have in different
    scenarios.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，您可以看到演员在不同场景中会扮演的角色。
- en: We’ll analyze each scenario and explain why the actor has that role in the following
    sections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中分析每个场景，并解释演员为什么会有那个角色。
- en: Actor spawned on the server
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器上生成的演员
- en: The actor spawns on the server, so the server’s version of that actor will have
    the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    For the client’s version of that actor, its local role will be `ROLE_SimulatedProxy`
    and the remote role will be `ROLE_Authority`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 行为体在服务器上生成，因此该行为体的服务器版本将具有本地角色 `ROLE_Authority` 和远程角色 `ROLE_SimulatedProxy`。对于该行为体的客户端版本，其本地角色将是
    `ROLE_SimulatedProxy`，远程角色将是 `ROLE_Authority`。
- en: Actor spawned on the client
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端生成的行为体
- en: The actor was spawned on the client, so the client’s version of that actor will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the actor wasn’t spawned on the server, then it will only exist on the client
    that spawned it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 行为体是在客户端生成的，因此该行为体的客户端版本将具有本地角色 `ROLE_Authority` 和远程角色 `ROLE_SimulatedProxy`。由于行为体没有在服务器上生成，因此它只存在于生成它的客户端上。
- en: Player-owned pawn spawned on the server
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器上生成的玩家拥有的行为体
- en: The pawn was spawned on the server, so the server’s version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_AutonomousProxy`.
    For the client’s version of that pawn, its local role will be `ROLE_AutonomousProxy`,
    because it’s being controlled by a Player Controller, and the remote role of `ROLE_Authority`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 行为体是在服务器上生成的，因此该行为体的服务器版本将具有本地角色 `ROLE_Authority` 和远程角色 `ROLE_AutonomousProxy`。对于该行为体的客户端版本，其本地角色将是
    `ROLE_AutonomousProxy`，因为它是由玩家控制器控制的，远程角色是 `ROLE_Authority`。
- en: Player-owned pawn spawned on the client
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端上生成的玩家拥有的行为体
- en: The pawn was spawned on the client, so the client’s version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the pawn wasn’t spawned on the server, then it will only exist on the client
    that spawned it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 行为体是在客户端生成的，因此该行为体的客户端版本将具有本地角色 `ROLE_Authority` 和远程角色 `ROLE_SimulatedProxy`。由于行为体没有在服务器上生成，因此它只存在于生成它的客户端上。
- en: Exercise 16.02 – Implementing ownership and roles
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 16.02 – 实现所有权和角色
- en: 'In this exercise, we’re going to create a **C++** project that uses the **Third
    Person** template as a base and make it do the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用 **C++** 作为基础并基于 **第三人称** 模板的 **C++** 项目，并使其执行以下操作：
- en: Create a new actor called `EditAnywhere` variable called `OwnershipRadius`)
    and will set that character as its owner. When no character is within the radius,
    then the owner will be `nullptr`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的行为体，名为 `EditAnywhere`，并创建一个名为 `OwnershipRadius` 的变量，并将该角色设置为所有者。当没有角色在半径内时，所有者将是
    `nullptr`。
- en: Display its local role, remote role, owner, and connection.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示其本地角色、远程角色、所有者和连接。
- en: Edit **OwnershipRolesCharacter** and override the **Tick** function so that
    it displays its local role, remote role, owner, and connection.*   Add a macro
    called `ENetRole` into an `FString` value that can be printed on the screen.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 **OwnershipRolesCharacter** 并重写 **Tick** 函数，以便显示其本地角色、远程角色、所有者和连接。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new **Third Person** template project using **C++** called **OwnershipRoles**
    and save it to a location of your liking.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `ENetRole` 的宏添加到可以打印在屏幕上的 `FString` 值中。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建项目后，它应该同时打开编辑器和 Visual Studio 解决方案。
- en: Using the editor, create a new C++ class called `Actor`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个新的 C++ 类，名为 `Actor`。
- en: Once it finishes compiling, Visual Studio should pop up with the newly created
    `.h` and `.cpp` files.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，Visual Studio 应该会弹出新创建的 `.h` 和 `.cpp` 文件。
- en: Close the editor and go back to Visual Studio.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并返回 Visual Studio。
- en: 'In Visual Studio, open the `OwnershipRoles.h` file and add the following macro:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，打开 `OwnershipRoles.h` 文件并添加以下宏：
- en: '[PRE18]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This macro will be used to convert the `ENetRole` enumeration that we get from
    the `GetLocalRole()` function and `GetRemoteRole()` into an `FString`. The way
    it works is by finding the `ENetRole` enumeration type through Unreal Engine’s
    reflection system. From there, it converts the `Value` parameter into an `FString`
    variable so that it can be printed on the screen.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏将用于将我们从 `GetLocalRole()` 函数和 `GetRemoteRole()` 函数获得的 `ENetRole` 枚举转换为 `FString`。其工作方式是通过
    Unreal Engine 的反射系统找到 `ENetRole` 枚举类型。从那里，它将 `Value` 参数转换为 `FString` 变量，以便可以在屏幕上打印。
- en: 'Now, open the `OwnershipTestActor.h` file and declare the protected variables
    for the static mesh component and the ownership radius, as shown in the following
    code snippet:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.h`文件并声明静态网格组件和所有权半径的受保护变量，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code snippet, we declared the static mesh component and the
    `OwnershipRadius` variable, which allows you to configure the radius of the ownership.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了静态网格组件和`OwnershipRadius`变量，这允许你配置所有权的半径。
- en: Next, delete the declaration of `BeginPlay` and move the constructor and the
    `Tick` function declarations to the protected area.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除`BeginPlay`的声明并将构造函数和`Tick`函数的声明移动到受保护区域。
- en: 'Now, open the `OwnershipTestActor.cpp` file and add the required header files,
    as shown in the following code snippet:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.cpp`文件并添加所需的头文件，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code snippet, we included `OwnershipRoles.h`, `OwnershipRolesCharacter.h`,
    and `GameplayStatics.h` because we’ll be calling the `GetAllActorsOfClass` function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们包含了`OwnershipRoles.h`、`OwnershipRolesCharacter.h`和`GameplayStatics.h`，因为我们将会调用`GetAllActorsOfClass`函数。
- en: 'In the constructor definition, create the static mesh component and set it
    as the root component:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数定义中，创建静态网格组件并将其设置为根组件：
- en: '[PRE21]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still in the constructor, set `bReplicates` to `true` to tell Unreal Engine
    that this actor replicates and should also exist in all of the clients:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在构造函数中，将`bReplicates`设置为`true`以告诉Unreal Engine这个actor可以复制并且也应该存在于所有客户端：
- en: '[PRE22]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Delete the `BeginPlay` function definition.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`BeginPlay`函数定义。
- en: 'In the `Tick` function, draw a debug sphere to help visualize the ownership
    radius, as shown in the following code snippet:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`函数中，绘制一个调试球体以帮助可视化所有权半径，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Still in the `Tick` function, create the authority-specific logic that will
    get the closest `AOwnershipRolesCharacter` within the ownership radius. If it’s
    different from the current one, set it as the owner:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，创建获取所有权半径内最近的`AOwnershipRolesCharacter`的权限特定逻辑。如果它与当前的不同，将其设置为所有者：
- en: '[PRE24]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code is for demonstration purposes only, because running `GetAllActorsOfClass`
    on the `Tick` function every frame will take a big toll on performance. Ideally,
    you should execute this code only once (on `BeginPlay`, for example) and store
    the values so that we can query them in `Tick`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码仅用于演示目的，因为每帧在`Tick`函数上运行`GetAllActorsOfClass`会对性能造成很大影响。理想情况下，你应该只执行此代码一次（例如在`BeginPlay`中）并将值存储起来，以便我们可以在`Tick`中查询它们。
- en: 'Still in the `Tick` function, convert the values for the local/remote roles
    (using the `ROLE_TO_STRING` macro we created earlier), the current owner, and
    the connection into strings:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏）以及当前所有者和连接转换为字符串：
- en: '[PRE25]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To finalize the `Tick` function, use `DrawDebugString` to print the strings
    we converted in the previous step on the screen:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了最终化`Tick`函数，使用`DrawDebugString`在屏幕上打印我们在上一步转换的字符串：
- en: '[PRE26]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of constantly using `GetLocalRole() == ROLE_Authority` to check whether
    the actor has authority, you can use the `HasAuthority()` helper function, defined
    in `AActor`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用在`AActor`中定义的`HasAuthority()`辅助函数，而不是不断使用`GetLocalRole() == ROLE_Authority`来检查actor是否有权限，而不是不断使用`GetLocalRole()
    == ROLE_Authority`来检查actor是否有权限：
- en: 'Next, open `OwnershipRolesCharacter.h` and declare the `Tick` function as protected:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`OwnershipRolesCharacter.h`并声明`Tick`函数为受保护：
- en: '[PRE27]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, open `OwnershipRolesCharacter.cpp` and include `OwnershipRoles.h`, as
    shown in the following code snippet:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipRolesCharacter.cpp`并包含`OwnershipRoles.h`，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the `Tick` function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Tick`函数：
- en: '[PRE29]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside of the Tick function, convert the values for the local/remote roles
    (using the `ROLE_TO_STRING` macro we created earlier), the current owner, and
    the connection into strings:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`函数内部，将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏）以及当前所有者和连接转换为字符串：
- en: '[PRE30]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Use `DrawDebugString` to print the strings we converted in the previous step
    on the screen:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DrawDebugString`在屏幕上打印我们在上一步转换的字符串：
- en: '[PRE31]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, we can test the project.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试项目。
- en: Run the code and wait for the editor to fully load.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Create a new Blueprint called `OwnershipTestActor_BP` in the `Content` folder
    that derives from `OwnershipTestActor`. Set `Mesh` to use a cube mesh, and drop
    an instance of it in the world.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中创建一个新的蓝图`OwnershipTestActor_BP`，它继承自`OwnershipTestActor`。将`Mesh`设置为使用立方体网格，并在世界中放置其实例。
- en: Go to `Multiplayer Options`, set `2`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Multiplayer Options`，设置`2`。
- en: Set the window size to `800x600`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`。
- en: Play using **New Editor Window (PIE)**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**新编辑器窗口 (PIE**)进行游戏。
- en: 'You should get the following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 16.8 – Expected result on the Server and Client 1 windows ](img/Figure_16..08_B18531.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.8 – 服务器和客户端 1 窗口的预期结果](img/Figure_16..08_B18531.jpg)'
- en: Figure 16.8 – Expected result on the Server and Client 1 windows
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8 – 服务器和客户端 1 窗口的预期结果
- en: By completing this exercise, you’ll have a better understanding of how connections
    and ownership work. These are important concepts to know as everything related
    to replication is dependent on them.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你会更好地理解连接和所有权的工作原理。这些是重要的概念，因为与复制相关的一切都依赖于它们。
- en: The next time you see that an actor is not doing replication operations, you’ll
    know that you need to check whether it has a valid connection and an owner.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当你看到某个角色没有进行复制操作时，你会知道你需要检查它是否有一个有效的连接和所有者。
- en: Now, let’s analyze the values that are displayed in the server and client windows.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析服务器和客户端窗口中显示的值。
- en: Note
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The two figures for the server and client window will have three text blocks
    that say `Server Character`, `Client 1 Character`, and `Ownership Test Actor`,
    but that was added to the original screenshot to help you understand which character
    and actor are which.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端窗口的这两个图将包含三个文本块，分别写着`Server Character`、`Client 1 Character`和`Ownership
    Test Actor`，但这是添加到原始截图中的，以帮助你理解哪个角色和角色是什么。
- en: Output for the Server window
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口的输出
- en: 'Have a look at the following output screenshot of the **Server** window from
    the previous exercise:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下**服务器**窗口的输出屏幕截图：
- en: '![Figure 16.9 – The Server window ](img/Figure_16..09_B18531.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.9 – 服务器窗口](img/Figure_16..09_B18531.jpg)'
- en: Figure 16.9 – The Server window
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 – 服务器窗口
- en: In the preceding screenshot, you can see **Server Character**, **Client 1 Character**,
    and the **Ownership Test** cube actor.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到**服务器角色**、**客户端 1 角色**和**所有权测试**立方体角色。
- en: First, let’s analyze the values for **Server Character**.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析**服务器角色**的值。
- en: Server Character
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server is controlling. The values associated
    with this character are as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: This character was spawned on the server, which
    is the current game instance.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`: 这个角色是在服务器上生成的，即当前游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: Because this character was spawned on the
    server, the other clients should only simulate it.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`: 因为这个角色是在服务器上生成的，其他客户端应该只模拟它。'
- en: '`Owner = PlayerController_0`: This character is being controlled by the client
    of the listen server, which uses the first `PlayerController` instance called
    `PlayerController_0`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_0`: 这个角色由监听服务器的客户端控制，该客户端使用第一个`PlayerController`实例，称为`PlayerController_0`。'
- en: '`Connection = Invalid Connection`: Because we’re the client of the listen server,
    there is no need for a connection.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Invalid Connection`: 因为我们是监听服务器的客户端，所以不需要连接。'
- en: Next, we are going to look at **Client 1 Character** in the same window.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看同一窗口中的**客户端 1 角色**。
- en: Client 1 Character
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端 1 角色
- en: 'This is the character that **Client 1** is controlling. The values associated
    with this character are as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**客户端 1**正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: This character was spawned on the server, which
    is the current game instance.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`: 这个角色是在服务器上生成的，即当前游戏实例。'
- en: '`RemoteRole = ROLE_AutonomousProxy`: Because this character was spawned on
    the server, but it’s being controlled by another client.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_AutonomousProxy`: 因为这个角色是在服务器上生成的，但它是由另一个客户端控制的。'
- en: '`Owner = PlayerController_1`: This character is being controlled by another
    client, which uses the second `PlayerController` instance called `PlayerController_1`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_1`: 这个角色由另一个客户端控制，该客户端使用第二个`PlayerController`实例，称为`PlayerController_1`。'
- en: '`Connection = Valid Connection`: Because this character is being controlled
    by another client, so a connection to the server is required.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Valid Connection`: 因为这个角色由另一个客户端控制，所以需要连接到服务器。'
- en: Next, we are going to look at the **OwnershipTest** actor in the same window.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看同一窗口中的**OwnershipTest**角色。
- en: The OwnershipTest actor
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有权测试角色
- en: 'This is the cube actor that will set its owner to the closest character within
    a certain ownership radius. The values associated with this actor are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将所有者设置为一定拥有半径内最近角色的立方体演员。与此演员相关的值如下：
- en: '`LocalRole = ROLE_Authority`: This actor was placed in the level and spawned
    on the server, which is the current game instance.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`: 这个演员被放置在关卡中并在服务器上生成，这是当前的游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: This actor was spawned in the server, but
    it’s not being controlled by any client.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`: 这个演员在服务器上生成，但不是由任何客户端控制的。'
- en: '`Owner` and `Connection`: They will have their values based on the closest
    character. If there isn’t a character inside the ownership radius, then they will
    have the values of `No Owner` and `Invalid Connection`, respectively.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner`和`Connection`：它们的值将基于最近的角色。如果没有角色在拥有半径内，则它们将分别具有`No Owner`和`Invalid
    Connection`的值。'
- en: Now, let’s analyze the values that are displayed in the `Client 1` window.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析`Client 1`窗口中显示的值。
- en: Output for the Client 1 window
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Client 1`窗口的输出'
- en: 'Have a look at the following output screenshot of the `Client 1` window from
    the previous exercise:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下之前练习中`Client 1`窗口的输出截图：
- en: '![Figure 16.10 – The Client 1 window ](img/Figure_16..10_B18531.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – `Client 1`窗口](img/Figure_16..10_B18531.jpg)'
- en: Figure 16.10 – The Client 1 window
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – `Client 1`窗口
- en: The values for the `Client 1` window will be the same as those for the `Server`
    window, except the values of `LocalRole` and `RemoteRole` will be reversed because
    they are always relative to the game instance that you are in.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client 1`窗口的值将与`Server`窗口的值相同，除了`LocalRole`和`RemoteRole`的值将相反，因为它们始终相对于你所在的游戏实例。'
- en: Another exception is that the server character has no owner and the other connected
    clients won’t have a valid connection. The reason for that is that clients don’t
    store player controllers and connections of other clients, only the server does,
    but this will be covered in more depth in [*Chapter 18*](B18531_18.xhtml#_idTextAnchor404),
    *Using Gameplay Framework Classes in Multiplayer*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例外是服务器角色没有所有者，其他连接的客户端将没有有效的连接。原因是客户端不存储其他客户端的玩家控制器和连接，只有服务器才这样做，但这将在[*第18章*](B18531_18.xhtml#_idTextAnchor404)中更深入地讨论，*在多人游戏中使用游戏框架类*。
- en: In this section, we’ve covered how roles are used to know which version of the
    actor the code is executing, which we can leverage to run specific code. In the
    next section, we will look at variable replication, which is one of the techniques
    that’s used by the server to keep the clients synchronized.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用角色来知道代码正在执行哪个演员的版本，我们可以利用这一点来运行特定的代码。在下一节中，我们将探讨变量复制，这是服务器用来保持客户端同步的技术之一。
- en: Understanding variable replication
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量复制
- en: One of the ways the server can keep the clients synchronized is by using variable
    replication. The way it works is that every specific number of times per second
    (defined per actor in the `AActor::NetUpdateFrequency` variable, which is also
    exposed to blueprints) the variable replication system in the server will check
    whether there are any replicated variables (explained in the next section) in
    the client that need to be updated with the latest value.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以通过使用变量复制来保持客户端同步的一种方式。其工作原理是，每秒特定次数（由`AActor::NetUpdateFrequency`变量定义，该变量也暴露给蓝图）服务器中的变量复制系统将检查客户端中是否有任何需要更新为最新值的复制变量（下一节将解释）。
- en: If the variable meets all of the replication conditions, then the server will
    send an update to the client and enforce the new value.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量满足所有复制条件，则服务器将向客户端发送更新并强制执行新值。
- en: For example, if you have a replicated `Health` variable and the client on its
    end uses a hacking tool to set the value of the variable from `10` to `100`, then
    the replication system will enforce the real value from the server and change
    it back to `10`, which nullifies the hack.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个复制的`Health`变量，并且客户端在其端使用黑客工具将变量的值从`10`设置为`100`，那么复制系统将强制执行来自服务器的真实值并将其改回`10`，从而抵消了黑客行为。
- en: 'Variables are only sent to the client to be updated in the following situations:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，变量才会发送到客户端进行更新：
- en: The variable is set to replicate.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量被设置为复制。
- en: The value was changed on the server.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器上的值已更改。
- en: The value on the client is different on the server.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端上的值与服务器上的值不同。
- en: The actor has replication enabled.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该演员启用了复制功能。
- en: The actor is relevant and meets all of the replication conditions.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该演员相关且满足所有复制条件。
- en: One important thing to take into consideration is that the logic that determines
    whether a variable should be replicated or not is only executed `Actor::NetUpdateFrequency`
    times a second. In other words, the server doesn’t send an update request to a
    client immediately after you change the value of a variable on the server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要考虑的重要事项是，确定变量是否应该被复制的逻辑只会在每秒 `Actor::NetUpdateFrequency` 次执行。换句话说，服务器不会在你更改服务器上变量的值后立即向客户端发送更新请求。
- en: An example of this would be if you had an integer replicated variable called
    `Test` that has a default value of `5`. If you call a function on the server that
    sets `Test` to `3` and in the next line changes it to `8`, then only the latter
    change would send an update request to the clients. The reason for this is these
    two changes were made in-between the `NetUpdateFrequency` interval, so when the
    variable replication system executes, the current value is `8`, and because that
    is different from the value stored on the clients (which is still `5`), it will
    update them. If instead of setting it to `8`, you set it back to `5`, then no
    changes would be sent to the clients because the values haven’t changed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是，如果你有一个默认值为 `5` 的整数复制变量 `Test`。如果你在服务器上调用一个函数将 `Test` 设置为 `3`，然后在下一行将其更改为
    `8`，那么只有后者的更改会向客户端发送更新请求。这是因为这两个更改是在 `NetUpdateFrequency` 间隔之间进行的，所以当变量复制系统执行时，当前值是
    `8`，并且因为这与客户端上存储的值不同（仍然是 `5`），它会更新它们。如果你不是将其设置为 `8`，而是将其设置回 `5`，那么不会向客户端发送任何更改，因为值没有变化。
- en: In the following sections, we are going to cover how to replicate variables
    by using the `Replicated` and `ReplicatedUsing` specifiers, as well as the `DOREPLIFETIME`
    and `DOREPLIFETIME_CONDITION` macros.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将介绍如何使用 `Replicated` 和 `ReplicatedUsing` 指定器以及 `DOREPLIFETIME` 和 `DOREPLIFETIME_CONDITION`
    宏来复制变量。
- en: Replicated variables
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制变量
- en: In Unreal Engine, almost any variable type that can use the `UPROPERTY` macro
    can be set to replicate, and you can use two specifiers to do that. We will look
    at them in the following sections.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 中，几乎任何可以使用 `UPROPERTY` 宏的变量类型都可以设置为复制，你可以使用两个指定器来完成此操作。我们将在以下章节中查看它们。
- en: Replicated
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制
- en: If you just want to say that a variable is replicated, then you can use the
    `Replicated` specifier.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想说明一个变量是复制的，那么你可以使用 `Replicated` 指定器。
- en: 'Have a look at the following example:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code snippet, we declared a float variable called `Health`,
    as we normally do. The difference is that we added `UPROPERTY(Replicated)` to
    let Unreal Engine know that the `Health` variable will be replicated.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `Health` 的浮点变量，就像我们通常做的那样。不同之处在于我们添加了 `UPROPERTY(Replicated)`
    以让 Unreal Engine 知道 `Health` 变量将被复制。
- en: ReplicatedUsing
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReplicatedUsing
- en: 'If you want to say that a variable is replicated and should call a function
    every time it’s updated, then you can use the `ReplicatedUsing=<Function Name>`
    specifier. Have a look at the following example:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想说明一个变量是复制的，并且每次更新时都应该调用一个函数，那么你可以使用 `ReplicatedUsing=<函数名>` 指定器。请看以下示例：
- en: '[PRE33]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, we declared a float variable called `Health`.
    The difference is that we added `UPROPERTY(ReplicatedUsing=OnRep_Health)` to let
    Unreal Engine know that this variable will be replicated and should call the `OnRep_Health`
    function every time it’s updated, which, in this specific case, calls a function
    to update the HUD.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为 `Health` 的浮点变量。不同之处在于我们添加了 `UPROPERTY(ReplicatedUsing=OnRep_Health)`
    以让 Unreal Engine 知道这个变量将被复制，并且每次更新时都应该调用 `OnRep_Health` 函数，在这个特定情况下，它会调用一个更新 HUD
    的函数。
- en: Typically, the naming scheme for the callback function is `OnRep_<Variable Name>`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，回调函数的命名方案为 `OnRep_<变量名>`。
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function that’s used in the `ReplicatedUsing` specifier needs to be marked
    as `UFUNCTION()`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReplicatedUsing` 指定器中使用的函数需要标记为 `UFUNCTION()`。
- en: GetLifetimeReplicatedProps
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GetLifetimeReplicatedProps
- en: Besides marking the variable as replicated, you’ll also need to implement the
    `GetLifetimeReplicatedProps` function in the actor’s `cpp` file. One thing to
    take into consideration is that this function is automatically declared internally
    once you have at least one replicated variable, so you shouldn’t declare it in
    the actor’s header file. The purpose of this function is for you to tell how each
    replicated variable should replicate. You can do this by using the `DOREPLIFETIME`
    macro and its variants on every variable that you want to replicate.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将变量标记为复制之外，你还需要在演员的`cpp`文件中实现`GetLifetimeReplicatedProps`函数。需要考虑的一点是，一旦你至少有一个复制变量，该函数就会自动内部声明，因此你不需要在演员的头文件中声明它。此函数的目的是让你告诉每个复制变量应该如何复制。你可以通过在每个你想复制的变量上使用`DOREPLIFETIME`宏及其变体来实现这一点。
- en: DOREPLIFETIME
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOREPLIFETIME
- en: This macro specifies that the replicated variable in a class (entered as arguments)
    will replicate to all the clients, without an extra condition.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏指定了类中的复制变量（作为参数输入）将复制到所有客户端，而不需要额外的条件。
- en: 'Here’s its syntax:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的语法：
- en: '[PRE34]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have a look at the following example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE35]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, we used the `DOREPLIFETIME` macro to tell the
    replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate without an extra condition.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`DOREPLIFETIME`宏来告诉复制系统，`AVariableReplicationActor`类中的`Health`变量将无条件复制。
- en: DOREPLIFETIME_CONDITION
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOREPLIFETIME_CONDITION
- en: This macro specifies that the replicated variable in a class (entered as arguments)
    will replicate only to the clients that meet the condition (entered as an argument).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏指定了类中的复制变量（作为参数输入）将仅复制到满足条件（作为参数输入）的客户端。
- en: 'Here’s the syntax:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的语法：
- en: '[PRE36]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The condition parameter can be one of the following values:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 条件参数可以是以下值之一：
- en: '`COND_InitialOnly`: The variable will only replicate once, with the initial
    replication.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOnly`: 该变量将仅在初始复制时复制一次。'
- en: '`COND_OwnerOnly`: The variable will only replicate to the owner of the actor.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_OwnerOnly`: 该变量将仅复制到演员的所有者。'
- en: '`COND_SkipOwner`: The variable won’t replicate to the owner of the actor.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SkipOwner`: 该变量不会复制到演员的所有者。'
- en: '`COND_SimulatedOnly`: The variable will only replicate to actors that are simulating.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOnly`: 该变量将仅复制到正在模拟的演员。'
- en: '`COND_AutonomousOnly`: The variable will only replicate to autonomous actors.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_AutonomousOnly`: 该变量将仅复制到自主演员。'
- en: '`COND_SimulatedOrPhysics`: The variable will only replicate to actors that
    are simulating or to actors with `bRepPhysics` set to true.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOrPhysics`: 该变量将仅复制到正在模拟或`bRepPhysics`设置为true的演员。'
- en: '`COND_InitialOrOwner`: The variable will only replicate once, with the initial
    replication or to the owner of the actor.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOrOwner`: 该变量将仅在初始复制或演员的所有者处进行一次复制。'
- en: '`COND_Custom`: The variable will only replicate if its `SetCustomIsActiveOverride`
    Boolean condition (used in the `AActor::PreReplication` function) is true.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_Custom`: 只有当其`SetCustomIsActiveOverride`布尔条件（在`AActor::PreReplication`函数中使用）为true时，该变量才会复制。'
- en: 'Have a look at the following example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的示例：
- en: '[PRE37]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code snippet, we used the `DOREPLIFETIME_CONDITION` macro to
    tell the replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate only for the owner of this actor.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了`DOREPLIFETIME_CONDITION`宏来告诉复制系统，`AVariableReplicationActor`类中的`Health`变量将仅对演员的所有者进行复制。
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are more `DOREPLIFETIME` macros available, but they won’t be covered in
    this book. To see all of the variants, please check the `UnrealNetwork.h` file
    from the UE5 source code at [https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Engine/Public/Net/UnrealNetwork.h](https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Engine/Public/Net/UnrealNetwork.h).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多的`DOREPLIFETIME`宏可用，但本书不会涵盖它们。要查看所有变体，请检查UE5源代码中的`UnrealNetwork.h`文件，网址为[https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Engine/Public/Net/UnrealNetwork.h](https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Source/Runtime/Engine/Public/Net/UnrealNetwork.h)。
- en: Now that you have an idea of how variable replication works, let’s complete
    an exercise that uses the `Replicated` and `ReplicatedUsing` specifiers, as well
    as the `DOREPLIFETIME` and `DOREPLIFETIME_CONDITION` macros.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了变量复制的工作原理，让我们完成一个练习，使用`Replicated`和`ReplicatedUsing`指定符，以及`DOREPLIFETIME`和`DOREPLIFETIME_CONDITION`宏。
- en: Exercise 16.03 – Replicating variables using Replicated, ReplicatedUsing, DOREPLIFETIME,
    and DOREPLIFETIME_CONDITION
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 16.03 – 使用 Replicated、ReplicatedUsing、DOREPLIFETIME 和 DOREPLIFETIME_CONDITION
    复制变量
- en: 'In this exercise, we’re going to create a **C++** project that uses the **Third
    Person** template as a base and add two variables to the character that replicate
    in the following way:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个 **C++** 项目，以 **第三人称** 模板为基础，并为角色添加两个变量，其复制方式如下：
- en: Variable `A` is a float that will use the `Replicated` specifier and the `DOREPLIFETIME`
    macro.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `A` 是一个浮点数，将使用 `Replicated` 指定符和 `DOREPLIFETIME` 宏。
- en: Variable `B` is an integer that will use the `ReplicatedUsing` specifier and
    the `DOREPLIFETIME_CONDITION` macro.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `B` 是一个整数，将使用 `ReplicatedUsing` 指定符和 `DOREPLIFETIME_CONDITION` 宏。
- en: The Tick function of the character should increment A and B by 1 every frame,
    if it has authority, and call `DrawDebugString` to display theirs values on the
    location of the character.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果角色具有权限，则字符的 `Tick` 函数应每帧将 A 和 B 增加 1，并调用 `DrawDebugString` 在角色的位置显示它们的值。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new `VariableReplication` and save it to a location of your choosing.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `VariableReplication` 并将其保存到您选择的任何位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，它应该会打开编辑器以及 Visual Studio 解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并返回 Visual Studio。
- en: 'Open the `VariableReplicationCharacter.h` file and declare the protected `A`
    and `B` variables as `UPROPERTY` using their respective replication specifiers:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `VariableReplicationCharacter.h` 文件并使用各自的复制指定符将受保护的 `A` 和 `B` 变量声明为 `UPROPERTY`：
- en: '[PRE38]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Declare the `Tick` function as protected:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Tick` 函数声明为受保护的：
- en: '[PRE39]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since we’ve declared the `B` variable as `ReplicatedUsing = OnRepNotify_B`,
    we also need to declare the protected `OnRepNotify_B` callback function as `UFUNCTION`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将 `B` 变量声明为 `ReplicatedUsing = OnRepNotify_B`，因此我们还需要将受保护的 `OnRepNotify_B`
    回调函数声明为 `UFUNCTION`：
- en: '[PRE40]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, open the `VariableReplicationCharacter.cpp` file and include the `UnrealNetwork.h`
    header file, which contains the definition of the `DOREPLIFETIME` macros that
    we’re going to use:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `VariableReplicationCharacter.cpp` 文件并包含 `UnrealNetwork.h` 头文件，该文件包含我们将要使用的
    `DOREPLIFETIME` 宏的定义：
- en: '[PRE41]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Implement the `GetLifetimeReplicatedProps` function:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数 `GetLifetimeReplicatedProps`：
- en: '[PRE42]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let the replication system know that the `A` variable won’t have any extra
    replication conditions:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让复制系统知道 `A` 变量不会有任何额外的复制条件：
- en: '[PRE43]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let the replication system know that the `B` variable will only replicate to
    the owner of this actor:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让复制系统知道 `B` 变量只会复制到该角色的所有者：
- en: '[PRE44]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the `Tick` function:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数 `Tick`：
- en: '[PRE45]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, run the authority-specific logic that adds `1` to `A` and `B`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行特定于权限的逻辑，将 `1` 添加到 `A` 和 `B`：
- en: '[PRE46]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since this character will be spawned on the server, only the server will execute
    this logic.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此角色将在服务器上生成，因此只有服务器将执行此逻辑。
- en: 'Display the values of `A` and `B` on the location of the character:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的位置显示 `A` 和 `B` 的值：
- en: '[PRE47]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Implement the `RepNotify` function for the `B` variable, which displays a message
    on the screen saying that the `B` variable was changed to a new value:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `B` 变量实现 `RepNotify` 函数，该函数在屏幕上显示一条消息，说明 `B` 变量已更改为新值：
- en: '[PRE48]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, you can test the project.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以测试项目。
- en: Run the code and wait for the editor to fully load.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Go to `Multiplayer Options`, set `2`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `多人选项`，设置 `2`。
- en: Set the window size to `800x600`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为 `800x600`。
- en: Play using `New Editor Window (PIE)`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `新编辑器窗口 (PIE)` 进行播放。
- en: By completing this exercise, you will be able to play on each client and you’ll
    notice that the characters are displaying their respective values for `A` and
    `B`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您将能够在每个客户端进行游戏，并且您会注意到角色正在显示它们各自的 `A` 和 `B` 值。
- en: Now, let’s analyze the values that are displayed in the `Server` and `Client
    1` windows.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析在 `Server` 和 `Client 1` 窗口中显示的值。
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The two figures for the server and client window will have two text blocks that
    say `Server Character` and `Client 1 Character`, but that was added to the original
    screenshot to help you understand which character is which.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器窗口和客户端窗口的这两个图示将包含两个文本块，分别显示 `Server Character` 和 `Client 1 Character`，但这是添加到原始截图中的，以帮助您理解哪个角色是哪个。
- en: Output for the Server window
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口的输出
- en: 'In the **Server** window, you have the values for **Server Character**, which
    is the character controlled by the server, while in the background, you have the
    values for **Client 1 Character**:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **服务器** 窗口中，你有 **服务器角色** 的值，这是由服务器控制的角色，而在背景中，你有 **客户端 1 角色** 的值：
- en: '![Figure 16.11 – The Server window ](img/Figure_16..11_B18531.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.11 – 服务器窗口](img/Figure_16..11_B18531.jpg)'
- en: Figure 16.11 – The Server window
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11 – 服务器窗口
- en: 'The outputs that can be observed are as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到的输出如下：
- en: '`A = 651.00 B = 551`'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A = 651.00 B = 551`'
- en: '`A = 592.00 B = 492`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A = 592.00 B = 492`'
- en: At this specific point in time, `651` for `A` and `551` for `B`. The reason
    why `A` and `B` have different values is that `A` starts at `100` and `B` starts
    at `0`, which is the correct value after `551` ticks of `A++` and `B++`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的时间点，`A` 为 `651`，`B` 为 `551`。`A` 和 `B` 有不同值的原因是 `A` 从 `100` 开始，`B` 从 `0`
    开始，这是 `A++` 和 `B++` 滴答 `551` 后的正确值。
- en: '`59` ticks of `A++` and `B++`.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`A++` 和 `B++` 的 `59` 个滴答。'
- en: Next, we will look at the **Client 1** window.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 **客户端 1** 窗口。
- en: Output for the Client 1 window
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端 1 窗口的输出
- en: 'In the **Client 1** window, you have the values for **Client 1 Character**,
    which is the character controlled by **Client 1**, while in the background, you
    have the values for **Server Character**:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **客户端 1** 窗口中，你有 **客户端 1 角色** 的值，这是由 **客户端 1** 控制的角色，而在背景中，你有 **服务器角色** 的值：
- en: '![Figure 16.12 – The Client 1 window ](img/Figure_16..12_B18531.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.12 – 客户端 1 窗口](img/Figure_16..12_B18531.jpg)'
- en: Figure 16.12 – The Client 1 window
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12 – 客户端 1 窗口
- en: 'The outputs that can be observed are as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到的输出如下：
- en: '`A = 651.00 B = 0`'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A = 651.00 B = 0`'
- en: '`A = 592.00 B = 492`'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A = 592.00 B = 492`'
- en: '`A` is `651`, which is correct, but `B` is `0`. The reason for this is that
    `A` is using `DOREPLIFETIME`, which doesn’t add any additional replication conditions,
    so it will replicate the variable and keep the client up to date every time the
    variable is changed on the server.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 的值是 `651`，这是正确的，但 `B` 的值是 `0`。原因是 `A` 使用了 `DOREPLIFETIME`，它不会添加任何额外的复制条件，所以每次在服务器上更改变量时，它都会复制变量并保持客户端更新。'
- en: The `B` variable, on the other hand, uses `DOREPLIFETIME_CONDITION` with `COND_OwnerOnly`,
    and since `0`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`B` 变量使用 `DOREPLIFETIME_CONDITION` 与 `COND_OwnerOnly`，并且由于 `0`。
- en: If you go back to the code and change the replication condition of `B` to use
    `COND_SimulatedOnly` instead of `COND_OwnerOnly`, you’ll notice that the results
    will be reversed in the `B` will be replicated for **Server Character**, but it
    won’t replicate for its own character.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到代码中，将 `B` 的复制条件更改为使用 `COND_SimulatedOnly` 而不是 `COND_OwnerOnly`，你会注意到结果在
    `B` 将为 **服务器角色** 复制，但不会为其自己的角色复制。
- en: Note
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why the `RepNotify` message is showing in the **Server** window instead
    of the **Client** window is that, when playing in the editor, both windows share
    the same process, so printing text on the screen won’t be accurate. To get the
    correct behavior, you’ll need to run the packaged version of the game.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepNotify` 消息显示在 **服务器** 窗口中而不是 **客户端** 窗口中的原因是，在编辑器中播放时，两个窗口共享同一个进程，所以屏幕上打印的文本将不准确。为了获得正确的行为，你需要运行游戏的打包版本。'
- en: Exploring 2D Blend Spaces
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 2D 混合空间
- en: In [*Chapter 2*](B18531_02.xhtml#_idTextAnchor043), *Working with Unreal Engine*,
    we created a 1D Blend Space to blend between the movement states (idle, walk,
    and run) of a character based on the value of the `Speed` axis. For that specific
    example, it worked pretty well because you only needed one axis, but if we wanted
    the character to also be able to strafe, then we couldn’t do that.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B18531_02.xhtml#_idTextAnchor043)，*使用虚幻引擎*，我们创建了一个 1D 混合空间，用于根据
    `Speed` 轴的值混合角色的移动状态（空闲、行走和奔跑）。对于那个特定的例子，它工作得相当好，因为你只需要一个轴，但如果我们想让角色也能侧滑，那么我们就无法做到这一点。
- en: To contemplate that case, Unreal Engine allows you to create 2D Blend Spaces.
    The concept is almost the same; the only difference is that you have an extra
    axis for animations, so you can blend between them not only horizontally, but
    also vertically.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了考虑这种情况，虚幻引擎允许你创建 2D 混合空间。概念几乎相同；唯一的区别是你有一个额外的动画轴，因此你可以在它们之间进行混合，不仅水平混合，还可以垂直混合。
- en: Let’s apply our knowledge of 1D Blend Spaces to the next exercise, where we
    will create a 2D Blend Space for the movement of a character that can also strafe.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们对 1D 混合空间的知识应用到下一个练习中，我们将创建一个用于角色移动的 2D 混合空间，该角色还可以侧滑。
- en: Exercise 16.04 – Creating a movement 2D Blend Space
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 16.04 – 创建移动 2D 混合空间
- en: In this exercise, we’re going to create a Blend Space that uses two axes instead
    of one. The vertical axis will be `Speed`, which will be between `0` and `200`.
    The horizontal axis will be `Direction`, which represents the relative angle (`-180
    to 180`) between the velocity and the rotation/forward vector of the pawn.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用两个轴而不是一个轴的混合空间。垂直轴将是`速度`，其范围在`0`到`200`之间。水平轴将是`方向`，它表示速度与pawn的旋转/前进向量的相对角度（`-180到180`）。
- en: 'The following diagram will help you calculate the direction in this exercise:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表将帮助您计算这个练习中的方向：
- en: '![Figure 16.13 – Direction values based on the angle between the forward vector
    and the velocity ](img/Figure_16..13_B18531.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13 – 前进向量与速度之间的角度基于的方向值](img/Figure_16..13_B18531.jpg)'
- en: Figure 16.13 – Direction values based on the angle between the forward vector
    and the velocity
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 – 前进向量与速度之间的角度基于的方向值
- en: The preceding diagram shows how the direction will be calculated. The forward
    vector represents the direction that the character is currently facing, while
    the numbers represent the angle that the forward vector would make with the velocity
    vector if it was pointing in that direction. If the character was looking in a
    certain direction and you pressed a key to move the character to the right, then
    the velocity vector would be perpendicular to the forward vector. This would mean
    that the angle would be 90º, so that would be our direction.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了方向是如何计算的。前进向量代表角色当前面对的方向，而数字代表如果前进向量指向那个方向，它将与速度向量形成的角度。如果角色朝向某个方向，并且您按下一个键将角色向右移动，那么速度向量将与前进向量垂直。这意味着角度将是90º，因此这就是我们的方向。
- en: If we set up our 2D Blend Space with that logic in mind, we can use the correct
    animation based on the character’s movement angle.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑到这个逻辑来设置2D混合空间，我们可以根据角色的运动角度使用正确的动画。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: Create a new `Blendspace2D` and save it to a location of your choosing.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Blendspace2D`并将其保存到您选择的地点。
- en: Once the project has been created, it should open the editor.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建项目，它应该会打开编辑器。
- en: Next, you will be importing the movement animations. In the editor, go to the
    **Content\Characters\Mannequins\Animations** folder.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将导入运动动画。在编辑器中，转到**Content\Characters\Mannequins\Animations**文件夹。
- en: Click on the **Import** button.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**导入**按钮。
- en: Go to the `fbx` files, and hit the **Open** button.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`fbx`文件，并点击**打开**按钮。
- en: In the import dialog, make sure you pick the `SK_Mannequin` skeleton and hit
    the **Import All** button.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入对话框中，确保您选择了`SK_Mannequin`骨骼并点击**导入所有**按钮。
- en: Save all of the new files in the `Assets` folder.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有新文件保存在`Assets`文件夹中。
- en: If you open any of the new animations, you will notice that the mesh is quite
    stretched on the *Z*-axis. So, let’s fix that by adjusting the skeleton retargeting
    settings.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开任何新的动画，您会注意到网格在*Z*-轴上相当拉伸。所以，让我们通过调整骨骼重定向设置来修复它。
- en: Go to **Content/Characters/Mannequins/Meshes/SK_Mannequin**. On the left, you
    should see the list of bones.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Content/Characters/Mannequins/Meshes/SK_Mannequin**。在左侧，您应该看到骨骼列表。
- en: Click on the cog icon to the right of the search box on the top and enable **Show
    Retargeting Options**.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击搜索框右侧的齿轮图标并启用**显示重定向选项**。
- en: '*Right-click* on the `root` bone and pick **Recursively Set Translation Retargeting
    Skeleton**.'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`根`骨骼并选择**递归设置翻译重定向骨骼**。
- en: Finally, pick **Animation** from the drop-down for the **root** and **pelvis**
    bones.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从下拉菜单中选择**动画**以设置**根**和**骨盆**骨骼。
- en: Save and close **SK_Mannequin**.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭**SK_Mannequin**。
- en: Once that’s done, open the **Content Browser** area, click on the **Add** button,
    and pick **Animation | Blend Space**.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，打开**内容浏览器**区域，点击**添加**按钮，并选择**动画 | 混合空间**。
- en: Next, select the **SK_Mannequin** skeleton.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**SK_Mannequin**骨骼。
- en: Rename the Blend Space **BS_Movement** and open it.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将混合空间重命名为**BS_Movement**并打开它。
- en: 'Set the horizontal `(-180 to 180)` and the vertical `(0 to 200)`, and make
    sure that you turn on `Snap to Grid` on both. You should end up with the following
    settings:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置水平`(-180到180)`和垂直`(0到200)`，并确保在两者上都开启`Snap to Grid`。您应该得到以下设置：
- en: '![Figure 16.14 – 2D Blend Space – Axis Settings ](img/Figure_16..14_B18531.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14 – 2D混合空间 – 轴设置](img/Figure_16..14_B18531.jpg)'
- en: Figure 16.14 – 2D Blend Space – Axis Settings
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 – 2D混合空间 – 轴设置
- en: Drag the `0` and `-180`, `0`, and `180`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`0`和`-180`，`0`和`180`。
- en: Drag the `200` and `0`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`200`和`0`。
- en: Drag the `200` and `-90`.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`200`和`-90`。
- en: Drag the `200` and `90`.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`200`和`90`。
- en: Drag the `200` and `180` and `180`.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动`200`、`180`和`180`。
- en: You should end up with a Blend Space that can be previewed by holding *Ctrl*
    and moving the mouse.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到一个可以通过按住*Ctrl*并移动鼠标预览的Blend Space。
- en: Now, on the `5` to make the interpolation faster.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`5`改为使插值更快。
- en: Save and close the Blend Space.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭Blend Space。
- en: Now, let’s update the animation Blueprint so that it uses the new Blend Space.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更新动画蓝图，使其使用新的Blend Space。
- en: Go to **Content\Characters\Mannequins\Animations** and open **ABP_Manny**.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Content\Characters\Mannequins\Animations**，并打开**ABP_Manny**。
- en: Next, go to the event graph and create a new float variable called `Direction`.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，前往事件图，创建一个新的浮点变量，命名为`Direction`。
- en: 'Add a new pin to the sequence and set the value of `-180` to 1`80`) between
    the character’s **velocity** and **rotation**:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向序列中添加一个新的引脚，并将`-180`设置为`180`，在角色的**速度**和**旋转**之间：
- en: '![Figure 16.15 – Calculating the direction to use on the 2D Blend Space ](img/Figure_16..15_B18531.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![图16.15 – 在2D Blend Space上计算使用方向](img/Figure_16..15_B18531.jpg)'
- en: Figure 16.15 – Calculating the direction to use on the 2D Blend Space
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 – 在2D Blend Space上计算使用方向
- en: In `0.0` to disable the automatic feet adjustment.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.0`中禁用自动脚部调整。
- en: 'Go to the **Walk / Run** state inside the **Locomotion** state machine where
    the old 1D Blend Space is being used, as shown in the following screenshot:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Locomotion**状态机中的**Walk / Run**状态，在此状态下使用旧的1D Blend Space，如图所示：
- en: '![Figure 16.16 – The Walk / Run state in the AnimGraph ](img/Figure_16..16_B18531.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16 – AnimGraph中的Walk / Run状态](img/Figure_16..16_B18531.jpg)'
- en: Figure 16.16 – The Walk / Run state in the AnimGraph
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 – AnimGraph中的Walk / Run状态
- en: 'Replace that Blend Space with **BS_Movement** and use the **Direction** variable,
    like so:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该Blend Space替换为**BS_Movement**，并使用**Direction**变量，如下所示：
- en: '![Figure 16.17 – The 1D Blend Space has been replaced with the new 2D Blend
    Space ](img/Figure_16..17_B18531.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17 – 1D Blend Space已被新的2D Blend Space替换](img/Figure_16..17_B18531.jpg)'
- en: Figure 16.17 – The 1D Blend Space has been replaced with the new 2D Blend Space
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 – 1D Blend Space已被新的2D Blend Space替换
- en: Go to the `Idle` state inside the **Locomotion** state machine and change the
    animation to use **Idle_Rifle_Ironsights** instead.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Locomotion**状态机中的**Idle**状态，并将动画更改为使用**Idle_Rifle_Ironsights**。
- en: Save and close the animation Blueprint. Now, you need to update the character.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭动画蓝图。现在，您需要更新角色。
- en: Go to the **Content\ThirdPerson\Blueprints** folder and open **BP_ThirdPersonCharacter**.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**Content\ThirdPerson\Blueprints**文件夹，并打开**BP_ThirdPersonCharacter**。
- en: On the `Yaw` rotation always face the control rotation’s `Yaw`.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Yaw`旋转中始终面向控制旋转的`Yaw`。
- en: Go to the character movement component and set `200`.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往角色移动组件，并将`200`设置为`200`。
- en: Set `false`, which will prevent the character from rotating toward the direction
    of the movement.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`false`，这将防止角色朝向移动方向旋转。
- en: Select the `Mesh` component and on the **Details** panel, pick the **ABP_Manny**
    animation blueprint and the **SKM_Manny_Simple** skeletal mesh.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Mesh`组件，在**Details**面板中，选择**ABP_Manny**动画蓝图和**SKM_Manny_Simple**骨骼网格。
- en: Save and close the character Blueprint.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭角色蓝图。
- en: 'If you play the game now with two clients and move the character, it will walk
    forward and backward, but it will also strafe, as shown in the following screenshot:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在用两个客户端玩游戏并移动角色，它将向前和向后走，但也会侧移，如图所示：
- en: '![Figure 16.18 – Expected output on the Server and Client 1 windows ](img/Figure_16..18_B18531.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图16.18 – 服务器和客户端1窗口上的预期输出](img/Figure_16..18_B18531.jpg)'
- en: Figure 16.18 – Expected output on the Server and Client 1 windows
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18 – 服务器和客户端1窗口上的预期输出
- en: By completing this exercise, you have improved your understanding of how to
    create 2D Blend Spaces, how they work, and the advantages they provide compared
    to just using a regular 1D Blend Space.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您已经提高了对如何创建2D Blend Spaces、它们的工作原理以及与仅使用常规1D Blend Space相比所提供的优势的理解。
- en: In the next section, we will learn how to transform a character’s bone so that
    we can rotate the torso of the player up and down based on the camera’s pitch.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何变换角色的骨骼，以便我们可以根据摄像机的俯仰旋转来上下旋转玩家的躯干。
- en: Transforming (modifying) bones
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换（修改）骨骼
- en: There is a very useful node that you can use in **AnimGraph** called the **Transform
    (Modify) Bone** node, which allows you to translate, rotate, and scale a bone
    of a skeleton at runtime.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的节点，您可以在 **AnimGraph** 中使用，称为 **变换（修改）骨骼** 节点，它允许您在运行时对骨骼的骨骼进行平移、旋转和缩放。
- en: You can add it to `transform modify`, and picking the node from the list. If
    you click on the **Transform (Modify) Bone** node, you’ll have quite a few options
    on the **Details** panel.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其添加到 `transform modify`，并从列表中选择节点。如果您点击 **变换（修改）骨骼** 节点，您将在 **详细信息** 面板中看到很多选项。
- en: 'Here’s an explanation of what the most relevant options do:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对最相关选项的解释：
- en: '**Bone to Modify**: This option will tell the node what bone is going to be
    transformed.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要修改的骨骼**: 此选项将告诉节点将要变换的骨骼。'
- en: 'Slightly below that option, you have three sections representing each transform
    operation (**Translation**, **Rotation**, and **Scale**). In each section, you
    can do the following:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在该选项稍下方，有三个部分代表每个变换操作（**平移**、**旋转**和**缩放**）。在每一部分中，您可以执行以下操作：
- en: '**Translation**, **Rotation**, **Scale**: This option will tell the node how
    much of that specific transform operation you want to apply. The final result
    will depend on the mode you have selected (covered in the next section).'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平移**、**旋转**、**缩放**：此选项将告诉节点您想要应用该特定变换操作的程度。最终结果将取决于您选择的模式（下一节将介绍）。'
- en: 'There are four ways you can set this value:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置此值的方式有四种：
- en: Setting a constant value such as (`X=0.0,Y=0.0,Z=0.0`).
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个常量值，例如 (`X=0.0,Y=0.0,Z=0.0`）。
- en: Binding it to a function or a variable, by clicking on the drop-down on the
    right-hand side and picking one of the functions or variables available from the
    list.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击右侧的下拉菜单并从列表中选择一个函数或变量将其绑定到函数或变量。
- en: Using a dynamic value that can be set from a function, even if it’s not exposed
    as a pin.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可以由函数设置的动态值，即使它没有作为引脚公开。
- en: 'Using a variable so that it can be changed at runtime. To enable this, you
    need to perform the following steps (this example is for `Expose As Pin`. Once
    you do that, the text boxes for the constant value will disappear:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量以便它在运行时可以更改。要启用此功能，您需要执行以下步骤（此示例为 `Expose As Pin`。一旦您这样做，常量值的文本框将消失：
- en: '![Figure 16.19 – Selecting Expose As Pin ](img/Figure_16..19_B18531.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.19 – 选择“作为引脚公开”](img/Figure_16..19_B18531.jpg)'
- en: Figure 16.19 – Selecting Expose As Pin
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19 – 选择“作为引脚公开”
- en: 'The **Transform (Modify) Bone** node will add an input so that you can plug
    in your variable:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变换（修改）骨骼** 节点将添加一个输入，以便您可以插入您的变量：'
- en: '![Figure 16.20 – Variable used as an input on the Transform (Modify) Bone node
    ](img/Figure_16..20_B18531.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.20 – 变量用作变换（修改）骨骼节点的输入](img/Figure_16..20_B18531.jpg)'
- en: Figure 16.20 – Variable used as an input on the Transform (Modify) Bone node
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.20 – 在变换（修改）骨骼节点上用作输入的变量
- en: '**Setting the mode**'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置模式**'
- en: 'This will tell the node what to do with the value. You can pick from one of
    these three options:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉节点如何处理该值。您可以从以下三个选项中选择一个：
- en: '**Ignore**: Don’t do anything with the supplied value.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略**: 对提供的值不执行任何操作。'
- en: '**Add to Existing**: Grab the current value of the bone and add the supplied
    value to it.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加到现有**: 获取骨骼的当前值，并将提供的值添加到其中。'
- en: '**Replace Existing**: Replace the current value of the bone with the supplied
    value.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换现有**: 用提供的值替换骨骼的当前值。'
- en: '**Setting the space**'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置空间**'
- en: 'This will define the space where the node should apply the transform. You can
    pick from one of these four options:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义节点应用变换的空间。您可以从以下四个选项中选择一个：
- en: '**World Space**: The transform will happen in the world space.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界空间**: 变换将在世界空间中发生。'
- en: '**Component Space**: The transform will happen in the skeletal mesh component
    space.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件空间**: 变换将在骨骼网格组件空间中发生。'
- en: '**Parent Bone Space**: The transform will happen in the parent bone’s space
    of the selected bone.'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父骨骼空间**: 变换将在所选骨骼的父骨骼空间中发生。'
- en: '**Bone Space**: The transform will happen in the space of the selected bone.'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼空间**: 变换将在所选骨骼的空间中发生。'
- en: '**Alpha**'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Alpha**'
- en: 'This option allows you to control the amount of transform that you want to
    apply. As an example, if you have the `Alpha` value as a float, then you’ll have
    the following behavior with different values:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许您控制要应用多少变换。例如，如果您将 `Alpha` 值作为浮点数，那么您将根据不同的值有以下行为：
- en: If `Alpha` is `0.0`, then no transform will be applied.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `Alpha` 为 `0.0`，则不会应用任何变换。
- en: If `Alpha` is `0.5`, then it will only apply half of the transform.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Alpha`是`0.5`，则只应用变换的一半。
- en: If `Alpha` is `1.0`, then it will apply the entire transform.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Alpha`是`1.0`，则将应用整个变换。
- en: In the next exercise, we will use the **Transform (Modify) Bone** node to enable
    the character from *Exercise 16.04 – creating a movement 2D Blend Space*, to look
    up and down based on the camera’s rotation.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用**变换（修改）骨骼**节点，使*练习16.04 – 创建2D混合空间移动*中的角色能够根据摄像机的旋转上下看。
- en: Exercise 16.05 – Creating a character that looks up and down
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.05 – 创建上下看的角色
- en: In this exercise, we’re going to use the project from *Exercise 16.04 – Creating
    a movement 2D Blend Space*, and enable the character to look up and down based
    on the camera’s rotation. To achieve this, we’re going to use the **Transform
    (Modify) Bone** node to rotate the **spine_03** bone in the component space based
    on the pitch of the camera.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用*练习16.04 – 创建2D混合空间移动*的项目，并使角色能够根据摄像机的旋转上下看。为了实现这一点，我们将使用**变换（修改）骨骼**节点，根据摄像机的俯仰角度在组件空间中旋转**spine_03**骨骼。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: First, you need to open the project from *Exercise 16.04 – Creating a movement
    2D Blend Space*.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要从*练习16.04 – 创建2D混合空间移动*打开项目。
- en: Go to **Content\Characters\Mannequins\Animations** and open **ABP_Manny**.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**内容\角色\人体模型\动画**并打开**ABP_Manny**。
- en: Go to **Event Graph** and create a float variable called **Pitch**.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**事件图**并创建一个名为**俯仰角度**的浮点变量。
- en: 'Add a new pin to the sequence and set the value of **Pitch** with the subtraction
    (or delta) between the character’s **rotation** and **base aim rotation**, as
    shown here:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在序列中添加一个新的销钉，并设置**俯仰角度**的值为角色**旋转**和**基础目标旋转**之间的减法（或增量），如下所示：
- en: '![Figure 16.21 – Calculating the Pitch ](img/Figure_16..21_B18531.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21 – 计算俯仰角度](img/Figure_16..21_B18531.jpg)'
- en: Figure 16.21 – Calculating the Pitch
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 – 计算俯仰角度
- en: This will allow you to get the value of **Pitch** from the rotator, which is
    the only part of the delta rotation that we are interested in.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您从旋转器中获取**俯仰角度**的值，这是我们唯一感兴趣的部分增量旋转。
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Break Rotator** node allows you to separate a **Rotator** variable into
    three float variables that represent **Pitch**, **Yaw**, and **Roll**. This is
    useful when you want to access the value of each component or if you only want
    to work with one or two components, and not with the whole rotation.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**断开旋转器**节点允许您将**旋转器**变量分离成三个浮点变量，分别代表**俯仰角度**、**偏航角度**和**翻滚角度**。当您想访问每个组件的值或只想处理一个或两个组件而不是整个旋转时，这很有用。'
- en: As an alternative to using the **Break Rotator** node, you can right-click on
    **Return Value** and pick **Split Struct Pin**. Take into consideration that the
    **Split Struct Pin** option will only appear if **Return Value** is not connected
    to anything. Once you do the split, it will create three separate wires for **Roll,
    Pitch**, and **Yaw,** just like a break but without the extra node.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用**断开旋转器**节点的替代方案，您可以在**返回值**上右键单击并选择**Split Struct Pin**。请注意，**Split Struct
    Pin**选项仅在**返回值**未连接到任何内容时才会出现。一旦进行拆分，它将创建三个单独的线，分别用于**翻滚角度**、**俯仰角度**和**偏航角度**，就像断开一样，但没有额外的节点。
- en: 'You should end up with the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终应该得到以下结果：
- en: '![Figure 16.22 – Calculating the Pitch to look up using the Split Struct Pin
    option ](img/Figure_16..22_B18531.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22 – 使用Split Struct Pin选项计算向上看的俯仰角度](img/Figure_16..22_B18531.jpg)'
- en: Figure 16.22 – Calculating the Pitch to look up using the Split Struct Pin option
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 – 使用Split Struct Pin选项计算向上看的俯仰角度
- en: 'This logic uses the rotation of the pawn and subtracts it from the camera’s
    rotation to get the difference in **Pitch**, as shown in the following diagram:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑使用棋子的旋转，并将其从摄像机的旋转中减去，以获得**俯仰角度**的差异，如下所示：
- en: '![Figure 16.23 – How to calculate the delta Pitch ](img/Figure_16..23_B18531.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23 – 如何计算俯仰角度的增量](img/Figure_16..23_B18531.jpg)'
- en: Figure 16.23 – How to calculate the delta Pitch
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 – 如何计算俯仰角度的增量
- en: Note
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can double-click on a wire to create a reroute node, which allows you to
    bend the wire so that it doesn’t overlap with other nodes, which makes the code
    easier to read.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以双击一根线来创建一个重路由节点，这允许您弯曲线，使其不与其他节点重叠，从而使代码更容易阅读。
- en: 'Next, go to `Bone` node with the following settings:'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到具有以下设置的**骨骼**节点：
- en: '![Figure 16.24 – Settings for the Transform (Modify) Bone node ](img/Figure_16..24_B18531.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图16.24 – 变换（修改）骨骼节点的设置](img/Figure_16..24_B18531.jpg)'
- en: Figure 16.24 – Settings for the Transform (Modify) Bone node
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24 – 变换（修改）骨骼节点的设置
- en: In the preceding screenshot, we’ve set **Bone to Modify** to **spine_03** because
    that is the bone that we want to rotate. We’ve also set **Rotation Mode** to **Add
    to Existing** because we want to keep the original rotation from the animation
    and add an offset to it. We can set the rest of the options to **Ignore** and
    remove **Expose As Pin** from the dropdown.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们将**要修改的骨骼**设置为**spine_03**，因为我们想要旋转的就是这个骨骼。我们还设置了**旋转模式**为**添加到现有**，因为我们想保留动画中的原始旋转并添加一个偏移量。我们可以将其他选项设置为**忽略**，并从下拉菜单中移除**暴露为引脚**。
- en: 'Connect the **Transform (Modify) Bone** node to **Control Rig** and the **Output
    Pose**, as shown in the following screenshot:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**变换（修改）骨骼**节点连接到**控制骨架**和**输出姿态**，如下面的截图所示：
- en: '![Figure 16.25 – The Transform (Modify) Bone node connected to Output Pose
    ](img/Figure_16..25_B18531.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![图16.25 – 连接到输出姿态的变换（修改）骨骼节点](img/Figure_16..25_B18531.jpg)'
- en: Figure 16.25 – The Transform (Modify) Bone node connected to Output Pose
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25 – 连接到输出姿态的变换（修改）骨骼节点
- en: In the preceding screenshot, you can see the **AnimGraph**, which will allow
    the character to look up and down by rotating the **spine_03** bone based on the
    camera’s pitch. To connect the **Control Rig** node to the **Transform** (**Modify**)
    **Bone** node, we need to convert from local to component space. After the **Transform**
    (**Modify**) **Bone** node is executed we need to convert back to local space
    to be able to connect to the **Output Pose** node.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到**动画图**，它将允许角色通过根据相机的俯仰旋转**spine_03**骨骼来上下看。为了将**控制骨架**节点连接到**变换**（**修改**）**骨骼**节点，我们需要从局部空间转换为组件空间。在**变换**（**修改**）**骨骼**节点执行后，我们需要将其转换回局部空间，以便能够连接到**输出姿态**节点。
- en: Note
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We connect the **Pitch** variable to **Roll** because that bone in the skeleton
    is internally rotated that way. You can use **Split Struct Pin** on input parameters
    as well, so you don’t have to add a **Make Rotator** node.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**俯仰**变量连接到**翻滚**，因为骨骼内部旋转就是那样的方式。你还可以在输入参数上使用**分割结构引脚**，这样你就不需要添加**制作旋转器**节点。
- en: 'If you test the project with two clients and move the mouse up and down on
    one of the characters, you’ll notice that it will pitch up and down, as shown
    in the following screenshot:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用两个客户端测试项目，并在其中一个角色上上下移动鼠标，你会注意到它会上下倾斜，如下面的截图所示：
- en: '![Figure 16.26 – Characters looking up and down, based on the camera rotation
    ](img/Figure_16..26_B18531.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![图16.26 – 基于相机旋转的角色上下看](img/Figure_16..26_B18531.jpg)'
- en: Figure 16.26 – Characters looking up and down, based on the camera rotation
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26 – 基于相机旋转的角色上下看
- en: By completing this final exercise, you should understand how to modify bones
    at runtime using the **Transform (Modify) Bone** node in an animation blueprint.
    This node can be used in various scenarios, so it may prove useful for you.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个最终练习，你应该了解如何使用动画蓝图中的**变换（修改）骨骼**节点在运行时修改骨骼。此节点可用于各种场景，因此可能对你很有用。
- en: In the next activity, you’re going to put everything you’ve learned to the test
    by creating the character we’re going to use for our multiplayer FPS project.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，你将通过创建我们将用于我们的多玩家FPS项目的角色来测试你所学的一切。
- en: Activity 16.01 – Creating the character for the multiplayer FPS project
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动16.01 – 为多玩家FPS项目创建角色
- en: 'In this activity, you’ll create the character for the multiplayer FPS project
    that we’re going to build in the next few chapters. The character will have a
    few different mechanics, but for this activity, you just need to create a character
    that walks, jumps, looks up/down, and has two replicated stats: health and armor.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建我们将要在下一章中构建的多玩家FPS项目的角色。这个角色将有一些不同的机制，但在这个活动中，你只需要创建一个可以行走、跳跃、上下看，并且有两个复制的属性：生命值和护甲的角色。
- en: 'Follow these steps to complete this activity:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Create a `MultiplayerFPS` without the starter content.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个不带起始内容的`MultiplayerFPS`。
- en: Import the skeletal mesh and the animations from the `Activity16.01\Assets`
    folder and place them in the **Content\Player\Mesh** and **Content\Player\Animations**
    folders, respectively.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity16.01\Assets`文件夹导入骨骼网格和动画，分别放置在**Content\Player\Mesh**和**Content\Player\Animations**文件夹中。
- en: 'Import the following sounds from the `Activity16.01\Assets` folder into `Content\Player\Sounds`:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity16.01\Assets`文件夹导入以下声音到`Content\Player\Sounds`：
- en: '`Jump.wav`: Play this sound on the `Jump_From_Stand_Ironsights` animation with
    a `Play Sound` anim notify.'
  id: totrans-581
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jump.wav`：在`Jump_From_Stand_Ironsights`动画中使用`Play Sound`动画通知播放此声音。'
- en: '`Footstep.wav`: Play this sound every time a foot is on the floor in every
    walk animation by using the `Play Sound` anim notify.'
  id: totrans-582
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Footstep.wav`：在每次步行动画中，当脚落在地板上时，使用`Play Sound`动画通知播放此声音。'
- en: '`Spawn.wav`: Use this on the `SpawnSound` variable in the character.'
  id: totrans-583
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spawn.wav`：在角色的`SpawnSound`变量中使用此声音。'
- en: Set up the skeletal mesh by retargeting its bones and creating a socket called
    `Camera` that is a child of the head bone and has a `Relative Location` of (`X=7.88,
    Y=4.73, Z=-10.00`).
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过重新定位骨骼和创建一个名为`Camera`的插槽来设置骨骼网格，该插槽是头骨的子节点，并且具有`相对位置`(`X=7.88, Y=4.73, Z=-10.00`)。
- en: Create a 2D Blend Space in `5`.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`5`中创建一个2D混合空间。
- en: 'Create the input actions using the knowledge you acquired in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099),
    *Getting Started with Player Input*:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您在[*第4章*](B18531_04.xhtml#_idTextAnchor099)，“开始使用玩家输入”中获得的技能创建输入动作。
- en: '`W`, `S`, `A`, `D`'
  id: totrans-587
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W`，`S`，`A`，`D`'
- en: '`Mouse X`, `Mouse Y`'
  id: totrans-588
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mouse X`，`Mouse Y`'
- en: '`Spacebar`'
  id: totrans-589
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spacebar`'
- en: Add the new input actions to a new input mapping context called **IMC_Player**.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的输入动作添加到一个名为**IMC_Player**的新输入映射上下文中。
- en: Create a C++ class called `Armor Absorption`, which is the percentage of how
    much damage the armor absorbs.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Armor Absorption`的C++类，它是装甲吸收伤害的百分比。
- en: Has a constructor that initializes the camera, disables ticking, and sets `800`
    and `600`.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个构造函数，用于初始化摄像机，禁用计时，并设置`800`和`600`。
- en: 'On `Armor Absorption` variable and changes the damage value based on the following
    formula:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Armor Absorption`变量上，并根据以下公式更改伤害值：
- en: '`Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);`'
- en: 'Create an animation Blueprint in `Content\Player\Animations` called `ABP_Player`
    that has a `State Machine` with the following states:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Player\Animations`中创建一个名为`ABP_Player`的动画蓝图，它具有以下状态：
- en: '`Idle/Run`: Uses `BS_Movement` with the `Speed` and `Direction` variables.'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Idle/Run`：使用`BS_Movement`，并使用`Speed`和`Direction`变量。'
- en: '`Jump`: Plays the jump animation and transitions from the `Idle/Run` states
    when the `Is Jumping` variable is `true`.'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jump`：当`Is Jumping`变量为`true`时，播放跳跃动画并从`Idle/Run`状态转换。'
- en: It also uses `Transform (Modify) Bone` to make the character look up and down
    based on the camera’s pitch.
  id: totrans-598
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还使用`Transform (Modify) Bone`来根据摄像机的俯仰角使角色上下看。
- en: 'Create a `UMG` widget in `Content\UI` called `WBP_HUD` that displays the `Health`
    and `Armor` properties of the character in the `Health: 100` and `Armor: 100`
    formats using the knowledge you acquired in [*Chapter 15*](B18531_15.xhtml#_idTextAnchor322),
    *Exploring Collectibles, Power-Ups, and Pickups*.'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`Content\UI`中创建一个名为`WBP_HUD`的`UMG`小部件，使用您在[*第15章*](B18531_15.xhtml#_idTextAnchor322)，“探索可收集物品、增强物品和拾取物品”中获得的技能，以`Health:
    100`和`Armor: 100`的格式显示角色的`Health`和`Armor`属性。'
- en: 'Create a Blueprint in `Content\Player` called `BP_Player` that derives from
    `FPSCharacter`:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Player`中创建一个名为`BP_Player`的蓝图，它继承自`FPSCharacter`：
- en: 'Set up the mesh component so that it has the following values:'
  id: totrans-601
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置网格组件，使其具有以下值：
- en: '`Content\Player\Mesh\SK_Mannequin`'
  id: totrans-602
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Mesh\SK_Mannequin`'
- en: '`Content\Player\Animations\ABP_Player`'
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Animations\ABP_Player`'
- en: '`(X=0.0, Y=0.0, Z=-88.0)`'
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.0, Y=0.0, Z=-88.0)`'
- en: '`(X=0.0, Y=0.0, Z=-90.0)`'
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X=0.0, Y=0.0, Z=-90.0)`'
- en: '`Content\Player\Inputs\IA_Move`'
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Move`'
- en: '`Content\Player\Inputs\IA_Look`'
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Look`'
- en: '`Content\Player\Inputs\IA_Jump`'
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content\Player\Inputs\IA_Jump`'
- en: On the `Begin Play` event, it needs to create a widget instance of `WBP_HUD`
    and add it to the viewport.
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Begin Play`事件上，它需要创建`WBP_HUD`小部件实例并将其添加到视图中。
- en: Create a Blueprint in `BP_GameMode` that derives from `BP_Player` as the **DefaultPawn**
    class.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_GameMode`中创建一个继承自`BP_Player`的蓝图作为**默认Pawn**类。
- en: Create a test map in **Content\Maps** called **DM-Test** and set it as the default
    map in **Project Settings**.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Content\Maps**中创建一个名为**DM-Test**的测试地图，并将其设置为**项目设置**中的默认地图。
- en: '**Expected output**:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出**:'
- en: The result should be a project where each client will have a first-person character
    that can move, jump, and look around. These actions will also be replicated so
    that each client will be able to see what the other client’s character is doing.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，其中每个客户端都将有一个第一人称角色，该角色可以移动、跳跃和四处张望。这些动作也将被复制，以便每个客户端都能看到其他客户端角色的动作。
- en: 'Each client will also have a HUD that displays the health and the armor values:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端还将有一个显示健康和装甲值的HUD：
- en: '![Figure 16.27 – Expected output ](img/Figure_16..27_B18531.jpg)'
  id: totrans-615
  prefs: []
  type: TYPE_IMG
  zh: '![图16.27 – 预期输出](img/Figure_16..27_B18531.jpg)'
- en: Figure 16.27 – Expected output
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27 – 预期输出
- en: Note
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).
- en: By completing this activity, you should have a good idea of how the server-client
    architecture, variable replication, roles, 2D Blend Spaces, and the **Transform
    (Modify) Bone** node work.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，你应该对服务器-客户端架构、变量复制、角色、2D混合空间以及**变换（修改）骨骼**节点的工作原理有一个很好的了解。
- en: Summary
  id: totrans-620
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about some critical multiplayer concepts, such as
    how the server-client architecture works, the responsibilities of the server and
    the client, how the listen server is quicker to set up than a dedicated server
    but not as lightweight, ownership and connections, roles, and variable replication.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些关键的多玩家概念，例如服务器-客户端架构的工作原理，服务器和客户端的责任，监听服务器比专用服务器设置更快但并不轻量级，所有权和连接，角色以及变量复制。
- en: We also learned about some useful techniques for animation, such as how to use
    2D Blend Spaces, which allow you to have a two-axis grid to blend between animations,
    and the `Transform (Modify) Bone` node, which can modify the bones of a skeletal
    mesh at runtime. To finish off this chapter, we created a first-person multiplayer
    project where you have characters that can walk, look, and jump around. This will
    be the foundation of the multiplayer first-person shooter project that we will
    be working on for the next few chapters.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了一些动画的有用技术，例如如何使用2D混合空间，它允许你有一个两轴网格在动画之间进行混合，以及`变换（修改）骨骼`节点，它可以在运行时修改骨骼网格的骨骼。为了完成本章，我们创建了一个第一人称多人项目，其中包含可以行走、四处张望和跳跃的角色。这将是我们将在下一章中工作的多人第一人称射击项目的基础。
- en: In the next chapter, we’ll learn how to use RPCs, which allows clients and servers
    to execute functions on each other. We’ll also cover how to use enumerations in
    the editor and how to use array index wrapping to iterate an array in both directions
    and loop around when you go beyond its limits.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用RPCs，这允许客户端和服务器在彼此上执行函数。我们还将介绍如何在编辑器中使用枚举以及如何使用数组索引包装在两个方向上迭代数组并在超出其限制时循环。
