- en: Chapter 1. Look and Feel Customization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 外观和感觉定制
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using style sheets with Qt Designer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt Designer中使用样式表
- en: Basic style sheet customization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本样式表定制
- en: Creating a login screen using style sheets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式表创建登录界面
- en: Using resources in style sheets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在样式表中使用资源
- en: Customizing properties and sub-controls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义属性和子控件
- en: Styling in QML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML中的样式
- en: Exposing QML object pointer to C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将QML对象指针暴露给C++
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Qt allows us to easily design our program's user interface through a method
    that most people are familiar with. Qt not only provides us with a powerful user
    interface toolkit called Qt Designer, which enables us to design our user interface
    without writing a single line of code, but it also allows advanced users to customize
    their user interface components through a simple scripting language called Qt
    Style Sheets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Qt允许我们通过大多数人熟悉的方法轻松设计程序的用户界面。Qt不仅为我们提供了一个强大的用户界面工具包Qt Designer，使我们能够在不写一行代码的情况下设计用户界面，而且还允许高级用户通过一种简单的脚本语言Qt样式表来自定义他们的用户界面组件。
- en: Use style sheets with Qt Designer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中使用样式表
- en: In this example, we will learn how to change the look and feel of our program
    and make it look more professional by using style sheets and resources. Qt allows
    you to decorate your **Graphical User Interfaces** (**GUIs**) using a style sheet
    language called Qt Style Sheets, which is very similar to **Cascading Style Sheets**
    (**CSS**) used by web designers to decorate their websites.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将学习如何通过使用样式表和资源来改变程序的外观和感觉，使其看起来更专业。Qt允许你使用一种名为Qt样式表的样式表语言来装饰你的**图形用户界面**（**GUI**），这与网页设计师使用的**层叠样式表**（**CSS**）非常相似，用于装饰他们的网站。
- en: How to do it…
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The first thing we need to do is open up Qt Creator and create a new project.
    If this is the first time you have used Qt Creator, you can either click the big
    button that says **New Project** with a **+** sign, or simply go to **File** |
    **New File or New Project**.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是打开Qt Creator并创建一个新项目。如果这是你第一次使用Qt Creator，你可以点击上面写着**New Project**和一个**+**号的大按钮，或者简单地转到**File**
    | **New File or New Project**。
- en: Then, select **Application** under the **Project** window and select **Qt Widgets
    Application**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**项目**窗口下选择**Application**，并选择**Qt Widgets Application**。
- en: After that, click the **Choose** button at the bottom. A window will then pop
    out and ask you to insert the project name and its location.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，点击底部的**Choose**按钮。然后会弹出一个窗口，要求你输入项目名称和位置。
- en: Once you're done with that, click **Next** several times and click the **Finish**
    button to create the project. We will just stick to all the default settings for
    now. Once the project has been created, the first thing you will see is the panel
    with tons of big icons on the left side of the window that is called the **Mode
    Selector** panel; we will discuss this more later in the *How it works...* section.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**Next**几次，然后点击**Finish**按钮创建项目。现在我们将坚持使用所有默认设置。项目创建完成后，你会看到窗口左侧有一个名为**Mode
    Selector**的面板，上面有很多大图标；我们稍后将在*How it works...*部分详细讨论这一点。
- en: Then, you will also see all your source files listed on the **Side Bar** panel
    which is located right next to the **Mode Selector** panel. This is where you
    can select which file you want to edit, which, in this case, is `mainwindow.ui`
    because we are about to start designing the program's UI!
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你还会看到所有源文件都列在位于**Mode Selector**面板旁边的**Side Bar**面板上。这是你可以选择要编辑的文件的地方，在这种情况下是`mainwindow.ui`，因为我们即将开始设计程序的UI！
- en: Double-click `mainwindow.ui` and you will see an entirely different interface
    appearing out of nowhere. Qt Creator actually helped you to switch from the script
    editor to the UI editor (Qt Designer) because it detected the `.ui` extension
    on the file you're trying to open.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `mainwindow.ui`，你会看到一个完全不同的界面突然出现。Qt Creator实际上帮助你从脚本编辑器切换到UI编辑器（Qt Designer），因为它检测到你要打开的文件具有`.ui`扩展名。
- en: You will also notice that the highlighted button on the **Mode Selector** panel
    has changed from the **Edit** button to the **Design** button. You can switch
    back to the script editor or change to any other tools by clicking one of the
    buttons located in the upper half of the **Mode Selector** panel.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还会注意到**Mode Selector**面板上高亮显示的按钮已经从**Edit**按钮变成了**Design**按钮。你可以通过点击**Mode
    Selector**面板上半部分的按钮之一，切换回脚本编辑器或切换到其他工具。
- en: Let's go back to the Qt Designer and look at the `mainwindow.ui` file. This
    is basically the main window of our program (as the filename implies) and it's
    empty by default, without any widget on it. You can try to compile and run the
    program by pressing the **Run** button (green arrow button) at the bottom of the
    **Mode Selector** panel, and you will see an empty window popping up once the
    compilation is complete:![How to do it…](img/B02820_01_01.jpg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到Qt Designer，看看`mainwindow.ui`文件。这基本上是我们程序的主窗口（如文件名所示），默认情况下是空的，没有任何小部件。你可以尝试通过点击**Mode
    Selector**面板底部的**Run**按钮（绿色箭头按钮）来编译和运行程序，一旦编译完成，你会看到一个空窗口弹出来：![如何做…](img/B02820_01_01.jpg)
- en: Now, let's add a push button to our program's UI by clicking on the `Push Button`
    item in the widget box (under the **Buttons** category) and dragging it to your
    main window in the form editor. Then, keep the push button selected, and now you
    will see all the properties of this button inside the property editor on the right
    side of your window. Scroll down to somewhere around the middle and look for a
    property called **styleSheet**. This is where you apply styles to your widget,
    which may or may not inherit to its children or grandchildren recursively depending
    on how you set your style sheet. Alternatively, you can also right-click on any
    widget in your UI at the form editor and select **Change Style Sheet** from the
    pop-up menu.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过单击小部件框中的`Push Button`项目（在**按钮**类别下）并将其拖动到表单编辑器中的主窗口，向我们的程序UI添加一个按钮。然后，保持按钮选定状态，现在您将在窗口右侧的属性编辑器中看到此按钮的所有属性。向下滚动到中间左右某处，查找名为**styleSheet**的属性。这是您向小部件应用样式的地方，这些样式可能会根据您设置样式表的方式递归地继承到其子代或孙代。或者，您还可以右键单击表单编辑器中的任何小部件，并从弹出菜单中选择**更改样式表**。
- en: You can click on the input field of the **styleSheet** property to directly
    write the style sheet code, or click on the **…** button besides the input field
    to open up the **Edit Style Sheet** window which has a bigger space for writing
    longer style sheet code. At the top of the window you can find several buttons,
    such as **Add Resource**, **Add Gradient**, **Add Color**, and **Add Font**, that
    can help you to kick-start your coding if you can't remember the properties' names.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以单击**styleSheet**属性的输入字段，直接编写样式表代码，或单击输入字段旁边的**...**按钮，打开**编辑样式表**窗口，该窗口具有更大的空间，用于编写更长的样式表代码。在窗口顶部，您可以找到几个按钮，例如**添加资源**、**添加渐变**、**添加颜色**和**添加字体**，这些按钮可以帮助您启动编码，如果您记不住属性的名称。
- en: Let's try to do some simple styling with the **Edit Style Sheet** window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用**编辑样式表**窗口进行一些简单的样式设置。
- en: Click **Add Color** and choose color.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**添加颜色**并选择颜色。
- en: Pick a random color from the color picker window, let's say, a pure red color.
    Then click **OK**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从颜色选择器窗口中选择一个随机颜色，比如纯红色。然后单击**确定**。
- en: 'Now, you will see a line of code has been added to the text field on the **Edit
    Style Sheet** window, which in my case is as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将看到一行代码已添加到**编辑样式表**窗口上的文本字段中，例如：
- en: '`color: rgb(255, 0, 0);`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`color: rgb(255, 0, 0);`'
- en: Click the **OK** button and now you will see the text on your push button has
    changed to a red color.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**确定**按钮，现在您将看到按钮上的文本已更改为红色。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s take a bit of time to get ourselves familiar with Qt Designer''s interface
    before we start learning how to design our own UI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始学习如何设计自己的UI之前，让我们花点时间熟悉Qt Designer的界面：
- en: '![How it works...](img/B02820_01_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_01_02.jpg)'
- en: '**Menu bar:** The menu bar houses application-specific menus that provide easy
    access to essential functions such as create new projects, save files, undo, redo,
    copy, paste, and so on. It also allows you to access development tools that come
    with Qt Creator, such as the compiler, debugger, profiler, and so on.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**菜单栏：**菜单栏包含特定于应用程序的菜单，可轻松访问诸如创建新项目、保存文件、撤消、重做、复制、粘贴等基本功能。它还允许您访问随Qt Creator一起提供的开发工具，例如编译器、调试器、分析器等。'
- en: '**Widget box:** This is where you can find all the different types of widget
    provided by Qt Designer. You can add a widget to your program''s UI by clicking
    one of the widgets from the widget box and dragging it to the form editor.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**小部件框：**这是您可以找到Qt Designer提供的所有不同类型的小部件的地方。您可以通过单击小部件框中的一个小部件并将其拖动到表单编辑器中，向程序UI添加一个小部件。'
- en: '**Mode selector:** The mode selector is a side panel that places shortcut buttons
    for easy access to different tools. You can quickly switch between the script
    editor and form editor by clicking the **Edit** or **Design** buttons on the mode
    selector panel which is very useful for multitasking. You can also easily navigate
    to the debugger and profiler tools in the same speed and manner.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式选择器：**模式选择器是一个侧面面板，其中放置了用于轻松访问不同工具的快捷按钮。您可以通过单击模式选择器面板上的**编辑**或**设计**按钮快速在脚本编辑器和表单编辑器之间切换，这对于多任务处理非常有用。您还可以以相同的速度和方式轻松导航到调试器和分析器工具。'
- en: '**Build shortcuts:** The build shortcuts are located at the bottom of the mode
    selector panel. You can build, run, and debug your project easily by pressing
    the shortcut buttons here.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建快捷键：**构建快捷键位于模式选择器面板的底部。您可以通过按快捷按钮轻松构建、运行和调试项目。'
- en: '**Form editor:** Form editor is where you edit your program''s UI. You can
    add different widgets to your program by selecting a widget from the widget box
    and dragging it to the form editor.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表单编辑器：**表单编辑器是您编辑程序UI的地方。您可以从小部件框中选择一个小部件，并将其拖动到表单编辑器中，从而向程序添加不同的小部件。'
- en: '**Form toolbar:** From here, you can quickly select a different form to edit,
    click the drop-down box located above the widget box and select the file you want
    to open with Qt Designer. Beside the drop-down box are buttons for switching between
    different modes for the form editor and also buttons for changing the layout of
    your UI.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表单工具栏：**从这里，您可以快速选择要编辑的不同表单，单击位于小部件框上方的下拉框，并选择要在Qt Designer中打开的文件。在下拉框旁边是用于在表单编辑器的不同模式之间切换的按钮，还有用于更改UI布局的按钮。'
- en: '**Object inspector:** The object inspector lists all the widgets within your
    current `.ui` file. All the widgets are arranged according to its parent-child
    relationship in the hierarchy. You can select a widget from the object inspector
    to display its properties in the property editor.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对象检视器：**对象检视器列出了当前`.ui`文件中的所有小部件。所有小部件按照它们在层次结构中的父子关系进行排列。您可以从对象检视器中选择一个小部件，以在属性编辑器中显示其属性。'
- en: '**Property editor:** Property editor will display all the properties of the
    widget you selected either from the object inspector window or the form editor
    window.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**属性编辑器：**属性编辑器将显示您从对象检视器窗口或表单编辑器窗口中选择的小部件的所有属性。'
- en: '**Action Editor and Signals & Slots Editor:** This window contains two editors,
    **Action Editor** and the **Signals & Slots Editor**, which can be accessed from
    the tabs below the window. The action editor is where you create actions that
    can be added to a menu bar or toolbar in your program''s UI.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**操作编辑器和信号与槽编辑器：** 此窗口包含两个编辑器，**操作编辑器**和**信号与槽编辑器**，可以从窗口下方的选项卡中访问。操作编辑器是您创建可以添加到程序UI的菜单栏或工具栏中的操作的地方。'
- en: '**Output panes:** Output panes consist of several different windows that display
    information and output messages related to script compilation and debugging. You
    can switch between different output panes by pressing the buttons that carry a
    number before them, such as **1**-**Issues**, **2**-**Search Results**, **3**-**Application
    Output**, and so on.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**输出窗格：** 输出窗格由几个不同的窗口组成，显示与脚本编译和调试相关的信息和输出消息。您可以通过按带有数字的按钮（例如**1**-**Issues**，**2**-**Search
    Results**，**3**-**Application Output**等）来在不同的输出窗格之间切换。'
- en: There's more…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the previous section, we discussed how to apply style sheets to Qt widgets
    through C++ coding. Although that method works really well, most of the time the
    person who is in charge of designing the program's UI is not the programmer, but
    a UI designer who specializes in designing user-friendly UI. In this case, it's
    better to let the UI designer design the program's layout and style sheet with
    a different tool and not mess around with the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了如何通过C++编码将样式表应用到Qt小部件。虽然这种方法非常有效，但大多数时候负责设计程序UI的人不是程序员，而是专门设计用户友好UI的UI设计师。在这种情况下，最好让UI设计师使用不同的工具设计程序的布局和样式表，而不要在代码中乱搞。
- en: Qt provides an all-in-one editor called Qt Creator. Qt Creator consists of several
    different tools, such as script editor, compiler, debugger, profiler, and UI editor.
    The UI editor, which is also called Qt Designer, is the perfect tool for designers
    to design their program's UI without writing any code. This is because Qt Designer
    adopted the What-You-See-Is-What-You-Get approach by providing accurate visual
    representation of the final result, which means whatever you design with Qt Designer
    will turn out exactly the same when the program is compiled and run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了一个名为Qt Creator的多合一编辑器。Qt Creator包括几种不同的工具，如脚本编辑器、编译器、调试器、分析器和UI编辑器。UI编辑器，也称为Qt
    Designer，是设计师设计其程序UI而无需编写任何代码的完美工具。这是因为Qt Designer采用了所见即所得的方法，通过提供最终结果的准确视觉表示，意味着您在Qt
    Designer中设计的任何内容在编译和运行程序时都会完全相同。
- en: 'The similarities between Qt Style Sheets and CSS are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Qt样式表和CSS之间的相似之处如下：
- en: '**CSS**: `h1 { color: red; background-color: white;}`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS**：`h1 { color: red; background-color: white;}`'
- en: '**Qt Style Sheets**: `QLineEdit { color: red; background-color: white;}`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt样式表**：`QLineEdit { color: red; background-color: white;}`'
- en: As you can see, both of them contain a selector and a declaration block. Each
    declaration contains a property and a value, separated by a colon.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，它们都包含选择器和声明块。每个声明包含一个属性和一个值，由冒号分隔。
- en: 'In Qt, a style sheet can be applied to a single widget by calling `QObject::setStyleSheet()`
    function in C++ code, for example:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt中，可以通过在C++代码中调用`QObject::setStyleSheet()`函数将样式表应用于单个小部件，例如：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will turn the text of a button with the variable name `myPushButton`
    to a `blue` color. You can also achieve the same result by writing the declaration
    in the style sheet property field in Qt Designer. We will discuss more about Qt
    Designer in the next section.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码将将变量名为`myPushButton`的按钮的文本颜色更改为`蓝色`。您也可以通过在Qt Designer的样式表属性字段中编写声明来实现相同的结果。我们将在下一节中更多地讨论Qt
    Designer。
- en: 'Qt Style Sheets also supports all the different types of selectors defined
    in CSS2 standard, including Universal selector, Type selector, Class selector,
    ID selector, and so on, which allows us to apply styling to a very specific individual
    or group of widgets. For instance, if we want to change the background color of
    a specific line edit widget with the object name `usernameEdit`, we can do this
    by using an ID selector to refer to it:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt样式表还支持CSS2标准中定义的所有不同类型的选择器，包括通用选择器、类型选择器、类选择器、ID选择器等，这使我们能够将样式应用于非常具体的单个或一组小部件。例如，如果我们想要更改具有对象名称`usernameEdit`的特定行编辑小部件的背景颜色，我们可以使用ID选择器来引用它：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn about all the selectors available in CSS2 (which are also supported
    by Qt Style Sheets), please refer to this document: [http://www.w3.org/TR/REC-CSS2/selector.html](http://www.w3.org/TR/REC-CSS2/selector.html).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解CSS2中所有选择器的详细信息（这些选择器也被Qt样式表支持），请参考此文档：[http://www.w3.org/TR/REC-CSS2/selector.html](http://www.w3.org/TR/REC-CSS2/selector.html)。
- en: Basic style sheet customization
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本样式表定制
- en: In the previous example, you learned how to apply a style sheet to a widget
    with Qt Designer. Let's go crazy and push things further by creating a few other
    types of widgets and change their style properties to something bizarre for the
    sake of learning. This time, however, we will not apply the style to every single
    widget one by one, but we will learn to apply the style sheet to the main window
    and let it inherit down the hierarchy to all the other widgets so that the style
    sheet is easier to manage and maintain in long run.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您学会了如何在Qt Designer中将样式表应用于小部件。让我们疯狂一下，进一步推动事情，创建一些其他类型的小部件，并将它们的样式属性更改为一些奇怪的东西以便学习。但是这一次，我们不会逐个将样式应用于每个小部件，而是学会将样式表应用于主窗口，并让它在整个层次结构中继承到所有其他小部件，以便更容易地管理和维护样式表。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First of all, let's remove the style sheet from the push button by selecting
    it and clicking the small arrow button besides the `styleSheet` property. This
    button will revert the property to the default value, which in this case is the
    empty style sheet.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过选择它并单击`styleSheet`属性旁边的小箭头按钮来从按钮中删除样式表。这个按钮将将属性恢复到默认值，在这种情况下是空的样式表。
- en: Then, add a few more widgets to the UI by dragging them one by one from the
    widget box to the form editor. I've added a line edit, combo box, horizontal slider,
    radio button, and a check box.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过将它们一个接一个地从小部件框拖动到表单编辑器中，向UI添加几个小部件。我添加了一个行编辑、组合框、水平滑块、单选按钮和复选框。
- en: For the sake of simplicity, delete the menu bar, main toolbar, and the status
    bar from your UI by selecting them from the object inspector, right click, and
    choose **Remove**. Now your UI should look similar to this:![How to do it…](img/B02820_01_03.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简单起见，通过从对象检查器中选择它们，右键单击并选择**删除**，从您的UI中删除菜单栏、主工具栏和状态栏。现在您的UI应该看起来类似于这样：![如何做...](img/B02820_01_03.jpg)
- en: Select the main window either from the form editor or the object inspector,
    then right click and choose **Change Stylesheet** to open up the **Edit Style
    Sheet**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从表单编辑器或对象检查器中选择主窗口，然后右键单击并选择**更改样式表**以打开**编辑样式表**。
- en: 'Insert the following style sheet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 插入以下样式表：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now what you will see is a completely bizarre-looking UI with everything covered
    in yellow with a thick border. This is because the preceding style sheet does
    not have a selector, which means the style will apply to the children widgets
    of the main window all the way down the hierarchy. To change that, let''s try
    something different:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您将看到一个完全奇异的UI，所有内容都被涂成黄色，带有厚厚的边框。这是因为前面的样式表没有选择器，这意味着样式将应用于主窗口的所有子小部件，一直到层次结构的底部。为了改变这一点，让我们尝试一些不同的东西：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time, only the push button will get the style described in the preceding
    code, and all other widgets will return to the default styling. You can try to
    add a few more push buttons to your UI and they will all look the same:![How to
    do it…](img/B02820_01_04.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一次，只有按钮将获得前面代码中描述的样式，所有其他小部件将返回到默认样式。您可以尝试向您的UI添加几个按钮，它们将看起来都一样：![如何做...](img/B02820_01_04.jpg)
- en: 'This happens because we specifically tell the selector to apply the style to
    all the widgets with the class called `QPushButton`. We can also apply the style
    to just one of the push buttons by mentioning its name in the style sheet, like
    so:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为我们明确告诉选择器将样式应用于所有具有名为`QPushButton`的类的小部件。我们还可以通过在样式表中提及其名称来仅将样式应用于其中一个按钮，如下所示：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you understand this method, we can add the following code to the style
    sheet :'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您理解了这种方法，我们可以将以下代码添加到样式表中：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What it does is basically change the style of all the push buttons as well as
    some properties of a specific button named `pushButton_2`. We keep the style sheet
    of `pushButton_3` as it is. Now the buttons will look like this:![How to do it…](img/B02820_01_05.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的作用基本上是更改所有按钮的样式，以及更改名为`pushButton_2`的特定按钮的一些属性。我们保留`pushButton_3`的样式表。现在按钮将看起来像这样：![如何做...](img/B02820_01_05.jpg)
- en: The first set of style sheet will change all widgets of `QPushButton` type to
    a white rectangular button with no border and red text. Then the second set of
    style sheet changes only the border of a specific `QPushButton` widget called
    `pushButton_2`. Notice that the background color and text color of `pushButton_2`
    remain white and red respectively because we didn't override them in the second
    set of style sheet, hence it will return to the style described in the first set
    of style sheet since it's applicable to all `QPushButton` widgets. Do notice that
    the text of the third button has also changed to red because we didn't describe
    the color property in the third set of style sheet.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一组样式表将把所有`QPushButton`类型的小部件更改为白色的矩形按钮，没有边框，红色文本。然后第二组样式表仅更改名为`pushButton_2`的特定`QPushButton`小部件的边框。请注意，`pushButton_2`的背景颜色和文本颜色仍然分别为白色和红色，因为我们没有在第二组样式表中覆盖它们，因此它将返回到第一组样式表中描述的样式，因为它适用于所有`QPushButton`小部件。请注意，第三个按钮的文本也变为了红色，因为我们没有在第三组样式表中描述颜色属性。
- en: 'After that, create another set of style using the universal selector, like
    so:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用通用选择器创建另一组样式，如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The universal selector will affect all the widgets regardless of their type.
    Therefore, the preceding style sheet will apply a nice gradient color to all the
    widgets' background as well as setting their text as white and giving them a one-pixel
    solid outline which is also in white. Instead of writing the name of the color
    (that is, white), we can also use the `rgb` function (`rgb(255, 255, 255)`) or
    hex code (`#ffffff`) to describe the color value.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用选择器将影响所有小部件，而不考虑它们的类型。因此，前面的样式表将为所有小部件的背景应用漂亮的渐变颜色，并将它们的文本设置为白色，并给它们一个白色的一像素实线轮廓。我们可以使用`rgb`函数（`rgb(255,
    255, 255)`）或十六进制代码（`#ffffff`）来描述颜色值，而不是写颜色的名称（即白色）。
- en: Just as before, the preceding style sheet will not affect the push buttons because
    we have already given them their own styles which will override the general style
    described in the universal selector. Just remember that in Qt, the style that
    is more specific will ultimately be used when there is more than one style having
    influence on a widget. This is how the UI will look now:![How to do it…](img/B02820_01_06.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像以前一样，前面的样式表不会影响按钮，因为我们已经为它们提供了自己的样式，这将覆盖通用选择器中描述的一般样式。请记住，在Qt中，更具体的样式最终将在对小部件产生影响的多个样式中使用。这是现在UI的外观：![如何做...](img/B02820_01_06.jpg)
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you are ever involved in web development using HTML and CSS, Qt's style sheet
    works exactly the same way as CSS. Style sheets provide the definitions for describing
    the presentation of the widgets – what the colors are for each element in the
    widget group, how thick the border should be, and so on and so forth.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经参与使用HTML和CSS进行Web开发，Qt的样式表的工作方式与CSS完全相同。样式表提供了描述小部件呈现方式的定义 - 小部件组中每个元素的颜色是什么，边框应该有多厚等等。
- en: If you specify the name of the widget to the style sheet, it will change the
    style of a particular push button widget with the name you provide. None of the
    other widgets will be affected and will remain as the default style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将小部件的名称指定给样式表，它将更改具有你提供的名称的特定推按钮小部件的样式。其他小部件都不会受到影响，仍将保持默认样式。
- en: To change the name of a widget, select the widget either from the form editor
    or the object inspector and change the property called `objectName` in the property
    window. If you have used the ID selector previously to change the style of the
    widget, changing its object name will break the style sheet and lose the style.
    To fix this problem, simply change the object name in the style sheet as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改小部件的名称，从表单编辑器或对象检查器中选择小部件，并在属性窗口中更改名为`objectName`的属性。如果之前使用了ID选择器来更改小部件的样式，更改其对象名称将破坏样式表并丢失样式。要解决这个问题，只需在样式表中也更改对象名称。
- en: Creating a login screen using style sheets
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式表创建登录界面
- en: Next, we will learn how to put all the knowledge we learned in the previous
    example together and create a fake graphical login screen for an imaginary operating
    system. Style sheets are not the only thing you need to master in order to design
    a good UI. You will also need to learn how to arrange the widgets neatly using
    the layout system in Qt Designer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将我们在之前示例中学到的所有知识结合起来，为一个想象中的操作系统创建一个虚假的图形登录界面。样式表并不是你需要掌握的唯一东西，以设计良好的UI。你还需要学会如何使用Qt
    Designer中的布局系统整齐地排列小部件。
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: The first thing we need to do is design the layout of the graphical login screen
    before we start doing anything. Planning is very important in order to produce
    good software. The following is a sample layout design I made to show you how
    I imagine the login screen will look. Just a simple line drawing like this is
    sufficient as long as it conveys the message clearly:![How to do it…](img/B02820_01_07.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在开始任何操作之前设计图形登录界面的布局。规划对于制作良好的软件非常重要。以下是我制作的一个示例布局设计，以展示我想象中的登录界面将会是什么样子。只要能清晰地传达信息，像这样的简单线条图就足够了：![操作步骤…](img/B02820_01_07.jpg)
- en: Now that we know exactly how the login screen should look, let's go back to
    Qt Designer again.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了登录界面应该是什么样子，让我们再次回到Qt Designer。
- en: We will be placing the widgets at the top panel first, then the logo and the
    login form below it.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先放置顶部面板上的小部件，然后放置标志和登录表单。
- en: Select the main window and change its width and height from 400 and 300 to 800
    and 600 respectively because we'll need a bigger space in which to place all the
    widgets in a moment.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择主窗口，并将其宽度和高度从400和300分别更改为800和600，因为我们将需要更大的空间来放置所有的小部件。
- en: Click and drag a label under the **Display Widgets** category from the widget
    box to the form editor.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从小部件框中的**显示小部件**类别下拖动一个标签到表单编辑器中。
- en: Change the `objectName` property of the label to `currentDateTime` and change
    its `Text` property to the current date and time just for display purposes, such
    as `Monday, 25-10-2015 3:14 PM`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签的`objectName`属性更改为`currentDateTime`，并将其`Text`属性更改为当前日期和时间，仅用于显示目的，例如`星期一，2015年10月25日
    下午3:14`。
- en: Click and drag a push button under the **Buttons** category to the form editor.
    Repeat this process one more time because we have two buttons on the top panel.
    Rename the two buttons `restartButton` and `shutdownButton` respectively.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**按钮**类别下拖动一个推按钮到表单编辑器中。重复此过程一次，因为顶部面板上有两个按钮。将这两个按钮分别重命名为`restartButton`和`shutdownButton`。
- en: Next, select the main window and click the small icon button on the form toolbar
    that says **Lay Out Vertically** when you mouse-over it. Now you will see the
    widgets are being automatically arranged on the main window, but it's not exactly
    what we want yet.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择主窗口并单击表单工具栏上的小图标按钮，当鼠标悬停在上面时，它会显示**垂直布局**。现在你会看到小部件被自动排列在主窗口上，但还不是我们想要的。
- en: Click and drag a horizontal layout widget under the **Layouts** category to
    the main window.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**布局**类别下拖动一个水平布局小部件到主窗口中。
- en: Click and drag the two push buttons and the text label into the horizontal layout.
    Now you will see the three widgets being arranged in a horizontal row, but vertically
    they are located in the middle of the screen. The horizontal arrangement is almost
    correct, but the vertical position is totally off.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并将两个按钮和文本标签拖放到水平布局中。现在你会看到这三个小部件被水平排列，但在垂直方向上它们位于屏幕中间。水平排列几乎是正确的，但垂直位置完全不对。
- en: Click and drag a vertical spacer from the **Spacers** category and place it
    below the horizontal layout we created previously (below the red rectangular outline).
    Now you will see all the widgets are being pushed to the top by the spacer.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并从**间隔器**类别下拖动一个垂直间隔器，并将其放置在我们之前创建的水平布局下方（红色矩形轮廓下方）。现在你会看到所有的小部件都被间隔器推到了顶部。
- en: Now, place a horizontal spacer between the text label and the two buttons to
    keep them apart. This will make the text label always stick to the left and the
    buttons align to the right.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在文本标签和两个按钮之间放置一个水平间隔器，使它们保持分开。这将使文本标签始终保持在左侧，按钮对齐到右侧。
- en: Set both the `Horizontal Policy` and `Vertical Policy` properties of the two
    buttons to `Fixed` and set the `minimumSize` property to `55x55`. Then, set the
    `text` property of the buttons to empty as we will be using icons instead of text.
    We will learn how to place an icon in the button widgets in the following section.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮的`水平策略`和`垂直策略`属性都设置为`固定`，并将`minimumSize`属性设置为`55x55`。然后，将按钮的`text`属性设置为空，因为我们将使用图标而不是文本。我们将在下一节学习如何在按钮小部件中放置图标。
- en: Now your UI should look similar to this:![How to do it…](img/B02820_01_08.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你的UI应该看起来类似于这样：![操作步骤…](img/B02820_01_08.jpg)
- en: 'Next, we will be adding the logo by using the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过以下步骤添加标志：
- en: Add a horizontal layout between the top panel and the vertical spacer to serve
    as a container for the logo.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部面板和垂直间隔器之间添加一个水平布局，作为标志的容器。
- en: After adding the horizontal layout, you will find the layout is way too thin
    in height to be able to add any widgets to it. This is because the layout is empty
    and it's being pushed by the vertical spacer below it into zero height. To solve
    this problem, we can set its vertical margin (either `layoutTopMargin` or `layoutBottomMargin`)
    to be temporarily bigger until a widget is added to the layout.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加水平布局后，您会发现布局的高度太瘦，无法添加任何小部件。这是因为布局是空的，并且被下方的垂直间隔推到零高度。为解决这个问题，我们可以将其垂直边距（“layoutTopMargin”或“layoutBottomMargin”）临时设置得更大，直到向布局添加小部件为止。
- en: Next, add a label to the horizontal layout that you just created and rename
    it `logo`. We will learn more about how to insert an image into the label to use
    it as a logo in the next section. For now, just empty out the `text` property
    and set both its `Horizontal Policy` and `Vertical Policy` properties to `Fixed`.
    Then, set the `minimumSize` property to `150x150`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您刚刚创建的水平布局中添加一个标签，并将其重命名为“logo”。我们将在下一节中学习如何将图像插入标签以将其用作徽标。目前，只需清空“text”属性，并将其“Horizontal
    Policy”和“Vertical Policy”属性都设置为“Fixed”。然后，将“minimumSize”属性设置为“150x150”。
- en: Set the vertical margin of the layout back to zero if you haven't done so.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请将布局的垂直边距设置回零。
- en: 'The logo now looks invisible, so we will just place a temporary style sheet
    to make it visible until we add an image to it in the next section. The style
    sheet is really simple:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在徽标看起来是不可见的，因此我们将添加一个临时样式表使其可见，直到在下一节中为其添加图像。样式表非常简单：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now your UI should look similar to this:![How to do it…](img/B02820_01_09.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的UI应该看起来类似于这样：![操作步骤…](img/B02820_01_09.jpg)
- en: 'Now let''s create the login form by using the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照以下步骤创建登录表单：
- en: Add a horizontal layout between the logo's layout and the vertical spacer. Just
    as we did previously, set the `layoutTopMargin` property to a bigger number (that
    is, 100) so that you can add a widget to it more easily.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在徽标的布局和垂直间隔之间添加一个水平布局。就像之前一样，将“layoutTopMargin”属性设置为更大的数字（例如100），以便更轻松地向其中添加小部件。
- en: After that, add a vertical layout inside the horizontal layout you just created.
    This layout will be used as a container for the login form. Set its `layoutTopMargin`
    to a number lower than that of the horizontal layout (that is, 20) so that we
    can place widgets in it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在您刚刚创建的水平布局中添加一个垂直布局。该布局将用作登录表单的容器。将其“layoutTopMargin”设置为比水平布局低的数字（例如20），以便我们可以在其中放置小部件。
- en: Next, right click the vertical layout you just created and choose **Morph into
    -> QWidget**. The vertical layout is now being converted into an empty widget.
    This step is essential because we will be adjusting the width and height of the
    container for the login form. A layout widget does not contain any properties
    for width and height, but only margins, due to the fact that a layout will expand
    toward the empty space surrounding it, which does make sense, considering that
    it does not have any size properties. After you have converted the layout to a
    `QWidget` object, it will automatically inherit all the properties from the widget
    class, and so we are now able to adjust its size to suit our needs.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击您刚刚创建的垂直布局，然后选择**Morph into -> QWidget**。垂直布局现在被转换为一个空小部件。这一步是必不可少的，因为我们将调整登录表单的容器的宽度和高度。布局小部件不包含宽度和高度的任何属性，而只包含边距，因为布局将向其周围的空白空间扩展，这是有道理的，考虑到它没有任何大小属性。将布局转换为“QWidget”对象后，它将自动继承小部件类的所有属性，因此我们现在可以调整其大小以满足我们的需求。
- en: Rename the `QWidget` object, which we just converted from the layout, to `loginForm`
    and change both its `Horizontal Policy` and `Vertical Policy` properties to `Fixed`.
    Then, set the `minimumSize` to `350x200`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚从布局转换的“QWidget”对象重命名为“loginForm”，并将其“Horizontal Policy”和“Vertical Policy”属性都设置为“Fixed”。然后，将“minimumSize”设置为“350x200”。
- en: Since we already placed the `loginForm` widget inside the horizontal layout,
    we can now set its `layoutTopMargin` property back to zero.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将“loginForm”小部件放入了水平布局中，现在可以将其“layoutTopMargin”属性设置回零。
- en: 'Add the same style sheet as the logo to the `loginForm` widget to make it visible
    temporarily, except this time we need to add an ID selector in front so that it
    will only apply the style to `loginForm` and not its children widgets:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与徽标相同的样式表添加到“loginForm”小部件中，以使其暂时可见，但这次我们需要在前面添加一个ID选择器，以便仅将样式应用于“loginForm”，而不是其子小部件：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now your UI should look something like this:![How to do it…](img/B02820_01_10.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的UI应该看起来类似于这样：![操作步骤…](img/B02820_01_10.jpg)
- en: 'We are not done with the login form yet. Now that we have created the container
    for the login form, it''s time to put more widgets into the form:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成登录表单。现在我们已经为登录表单创建了容器，是时候向表单中添加更多小部件了：
- en: Place two horizontal layouts into the login form container. We need two layouts
    as one for the username field and another for the password field.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个水平布局放入登录表单容器中。我们需要两个布局，一个用于用户名字段，另一个用于密码字段。
- en: Add a label and a line edit to each of the layouts you just added. Change the
    `text` property of the upper label to `Username:` and the one below as `Password:`.
    Then, rename the two line edits as `username` and `password` respectively.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您刚刚添加的每个布局中添加一个标签和一个行编辑。将上方标签的“text”属性更改为“用户名：”，下方标签更改为“密码：”。然后，分别将两个行编辑重命名为“username”和“password”。
- en: Add a push button below the password layout and change its `text` property to
    `Login`. After that, rename it as `loginButton`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密码布局下方添加一个按钮，并将其“text”属性更改为“登录”。然后，将其重命名为“loginButton”。
- en: You can add a vertical spacer between the password layout and the login button
    to distance them slightly. After the vertical spacer has been placed, change its
    `sizeType` property to `Fixed` and change the `Height` to `5`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在密码布局和登录按钮之间添加一个垂直间隔以稍微拉开它们之间的距离。放置垂直间隔后，将其“sizeType”属性更改为“Fixed”，并将“Height”更改为“5”。
- en: Now, select the `loginForm` container and set all its margins to 35\. This is
    to make the login form look better by adding some space to all its sides.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择`loginForm`容器，并将其所有边距设置为35。这是为了通过在所有边缘添加一些空间来使登录表单看起来更好。
- en: You can also set the `Height` property of the `username`, `password`, and `loginButton`
    widgets to 25 so that they don't look so cramped.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以将`username`、`password`和`loginButton`小部件的`Height`属性设置为25，以使它们看起来不那么拥挤。
- en: Now your UI should look something like this:![How to do it…](img/B02820_01_11.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的用户界面应该看起来像这样：![操作步骤…](img/B02820_01_11.jpg)
- en: 'We''re not done yet! As you can see, the login form and the logo are both sticking
    to the top of the main window due to the vertical spacer below them. The logo
    and the login form should be placed at the center of the main window instead of
    the top. To fix this problem, use the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！正如您所看到的，由于它们下方的垂直间隔器，登录表单和标志都紧贴主窗口顶部。标志和登录表单应该放在主窗口的中心，而不是顶部。要解决这个问题，请按照以下步骤操作：
- en: Add another vertical spacer between the top panel and the logo's layout. This
    way it will counter the spacer at the bottom which balances out the alignment.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部面板和标志布局之间添加另一个垂直间隔器。这样它将抵消底部的间隔器，从而平衡对齐。
- en: If you think that the logo is sticking too close to the login form, you can
    also add a vertical spacer between the logo's layout and the login form's layout.
    Set its `sizeType` property to `Fixed` and the `Height` property to `10`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您认为标志与登录表单太过紧密，还可以在标志布局和登录表单布局之间添加一个垂直间隔器。将其`sizeType`属性设置为`Fixed`，将`Height`属性设置为`10`。
- en: Right click the top panel's layout and choose **Morph into -> QWidget**. Then,
    rename it `topPanel`. The reason why the layout has to be converted into `QWidget`
    is that, we cannot apply style sheets to a layout, as it doesn't have any properties
    other than margins.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击顶部面板的布局，然后选择**Morph into -> QWidget**。然后，将其重命名为`topPanel`。布局必须转换为`QWidget`的原因是，我们无法对布局应用样式表，因为它除了边距之外没有任何属性。
- en: Currently you can see there is a little bit of margin around the edges of the
    main window – we don't want that. To remove the margins, select the `centralWidget`
    object from the object inspector window, which is right under the `MainWindow`
    panel, and set all the margin values to zero.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，您可以看到主窗口的边缘周围有一点边距 - 我们不希望出现这种情况。要删除边距，请从对象检查器窗口中选择`centralWidget`对象，该对象位于`MainWindow`面板的正下方，并将所有边距值设置为零。
- en: At this point, you can run the project by clicking the **Run** button (with
    the green arrow icon) to see what your program looks like now. If everything went
    well, you should see something like this:![How to do it…](img/B02820_01_12.jpg)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，您可以通过单击**Run**按钮（带有绿色箭头图标）来运行项目，以查看您的程序现在的外观。如果一切顺利，您应该看到类似于这样的东西：![操作步骤…](img/B02820_01_12.jpg)
- en: After we've done the layout, it's time for us to add some fanciness to the UI
    using style sheets! Since all the important widgets have been given an object
    name, it's easier for us to apply the style sheets to it from the main window,
    since we will only write the style sheets to the main window and let them inherit
    down the hierarchy tree.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局完成后，是时候为用户界面添加一些花哨的样式表了！由于所有重要的小部件都被赋予了对象名称，因此我们可以更容易地从主窗口为其应用样式表，因为我们只会将样式表写到主窗口，然后让它们在层次树中继承下来。
- en: Right click on **MainWindow** from the object inspector window and choose **Change
    Stylesheet**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对象检查器窗口中右键单击**MainWindow**，然后选择**Change Stylesheet**。
- en: 'Add the following code to the style sheet:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到样式表中：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now you will see that the background of the main window changes its color. We
    will learn how to use an image for the background in the next section, so the
    color is just temporary.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您会看到主窗口的背景颜色发生了变化。我们将在下一节中学习如何使用图像作为背景，因此颜色只是临时的。
- en: In Qt, if you want to apply styles to the main window itself, you must apply
    it to its central widget instead of the main window itself because the window
    is just a container.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt中，如果要对主窗口本身应用样式，必须将其应用到其中央小部件，而不是主窗口本身，因为窗口只是一个容器。
- en: 'Then, we will add a nice gradient color to the top panel:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为顶部面板添加一个漂亮的渐变颜色：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, we will apply black color to the login form and make it look semi-transparent.
    After that, we will also make the corners of the login form container slightly
    rounded by setting the `border-radius` property:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将为登录表单应用黑色，并使其看起来半透明。之后，我们还将通过设置`border-radius`属性使登录表单容器的角略微圆润：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After we''re done applying styles to the specific widgets, we will apply styles
    to the general types of widgets instead:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成对特定小部件应用样式之后，我们将对一般类型的小部件应用样式：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding style sheets will change all the labels' texts to a white color,
    which includes the text on the widgets as well because, internally, Qt uses the
    same type of label on the widgets that have text on it. Also, we made the corners
    of the line edit widgets slightly rounded.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述样式表将把所有标签的文本更改为白色，这包括小部件上的文本，因为在内部，Qt使用相同类型的标签来标记带有文本的小部件。此外，我们使线编辑小部件的角稍微圆润。
- en: 'Next, we will apply style sheets to all the push buttons on our UI:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为用户界面上的所有推按钮应用样式表：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding style sheet changes the text of all the buttons to a white color,
    then sets its background color to blue, and makes its corners slightly rounded
    as well.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述样式表将把所有按钮的文本更改为白色，然后将其背景颜色设置为蓝色，并且还使其角稍微圆润。
- en: 'To push things even further, we will change the color of the push buttons when
    we mouse-over it, using the keyword `hover`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更进一步推动事情，我们将使用关键字`hover`来在鼠标悬停时更改推按钮的颜色。
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding style sheet will change the background color of the push buttons
    to green when we mouse-over them. We will talk more about this in the following
    section.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述样式表将在鼠标悬停时将推按钮的背景颜色更改为绿色。我们将在下一节中详细讨论这个问题。
- en: You can further adjust the size and margins of the widgets to make them look
    even better. Remember to remove the border line of the login form by removing
    the style sheet that we applied directly to it earlier.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以进一步调整小部件的大小和边距，使它们看起来更好。记得通过删除我们之前直接应用到登录表单的样式表来删除登录表单的边框线。
- en: Now your login screen should look something like this:![How to do it…](img/B02820_01_13.jpg)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您的登录屏幕应该看起来像这样：![如何做…](img/B02820_01_13.jpg)
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This example focuses more on the layout system of Qt. The Qt layout system provides
    a simple and powerful way of automatically arranging child widgets within a widget
    to ensure that they make good use of the available space.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例更多地关注Qt的布局系统。Qt布局系统提供了一种简单而强大的方式，自动安排小部件在一个小部件内，以确保它们充分利用可用的空间。
- en: The spacer items used in the preceding example help to push the widgets contained
    in a layout outward to create spacing along the width of the spacer item. To locate
    a widget to the middle of the layout, put two spacer items to the layout, one
    on the left side of the widget and another on the right side of the widget. The
    widget will then be pushed to the middle of the layout by the two spacers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中使用的间隔项有助于推动布局中包含的小部件向外推动，以创建间距。要将小部件定位到布局的中间，请将两个间隔项放到布局中，一个放在小部件的左侧，另一个放在小部件的右侧。然后，这两个间隔器将把小部件推到布局的中间。
- en: Using resources in style sheets
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在样式表中使用资源
- en: Qt provides us with a platform-independent resource system which allows us to
    store any type of files in our program's executable for later use. There is no
    limit to the types of files we can store in our executable—images, audio, video
    HTML, XML, text files, binary files, and so on, are all permitted. This is useful
    if your application always needs a certain set of files (icons, translation files,
    and so on) and you don't want to run the risk of losing the files. To achieve
    this, we must tell Qt which files we want to add to its resource system in the
    `.qrc` file and Qt will handle the rest during the build process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为我们提供了一个平台无关的资源系统，允许我们将任何类型的文件存储在程序的可执行文件中以供以后使用。我们可以在可执行文件中存储任何类型的文件，如图像、音频、视频、HTML、XML、文本文件、二进制文件等。如果您的应用程序始终需要一定的文件集（图标、翻译文件等），并且您不希望丢失这些文件，这将非常有用。为了实现这一点，我们必须告诉Qt我们想要将哪些文件添加到其资源系统中的`.qrc`文件，并且Qt将在构建过程中处理其余部分。
- en: How to do it
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: To add a new `.qrc` file to our project, go to **File** | **New File or Project**.
    Then, select **Qt** under the **Files and Classes** category and select **Qt Resources
    File**. After that, give it a name (that is, `resources`) and click the **Next**
    button followed by the **Finish** button. The `.qrc` file will not be created
    and automatically opened by Qt Creator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要向项目添加新的`.qrc`文件，请转到**文件** | **新建文件或项目**。然后，在**文件和类别**类别下选择**Qt**，然后选择**Qt资源文件**。之后，给它取一个名字（即`resources`），然后单击**下一步**，接着单击**完成**。`.qrc`文件将被创建并由Qt
    Creator自动打开。
- en: You don't have to edit the `.qrc` file directly in the XML format as Qt Creator
    provides you the user interface to manage your resources. To add images and icons
    to your project, first you need to make sure that the images and icons are being
    placed in your project's directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必直接在XML格式中编辑`.qrc`文件，因为Qt Creator为您提供了用户界面来管理资源。要向项目添加图像和图标，首先需要确保图像和图标被放置在项目的目录中。
- en: 'While the `.qrc` file is opened in Qt Creator, click the **Add** button followed
    by **Add Prefix** button. The prefix is used to categorize your resources so that
    it can be better managed when you have a ton of resources in your project:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Creator中打开`.qrc`文件后，单击**添加**按钮，然后单击**添加前缀**按钮。前缀用于对资源进行分类，以便在项目中有大量资源时更好地进行管理：
- en: Rename the prefix you just created `/icons`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名您刚创建的前缀为`/icons`。
- en: Then, create another prefix by clicking **Add** followed by **Add Prefix**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过单击**添加**，然后单击**添加前缀**来创建另一个前缀。
- en: Rename the new prefix `/images`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名新的前缀为`/images`。
- en: After that, select the `/icon` prefix and click **Add** followed by **Add Files**.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，选择`/icon`前缀，然后单击**添加**，接着单击**添加文件**。
- en: A file selection window will appear; use that to select all the icon files.
    You can select multiple files at a time by holding the *Ctrl* key on your keyboard
    while clicking on the files to select them. Click **Open** once you're done.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现文件选择窗口；使用它来选择所有图标文件。您可以通过在键盘上按住*Ctrl*键并单击文件来选择多个文件。完成后，单击**打开**。
- en: Then, select the `/images` prefix and click the **Add** button followed by the
    **Add Files** button. The file selection window will pop up again, and this time
    we will select the background image.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择`/images`前缀，然后单击**添加**按钮，接着单击**添加文件**按钮。文件选择窗口将再次弹出，这次我们将选择背景图像。
- en: Repeat the preceding steps, but this time we will add the logo image to the
    `/images` prefix.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上述步骤，但这次我们将把徽标图像添加到`/images`前缀。
- en: 'Don''t forget to save once you''re done by pressing *Ctrl* + *S*. Your `.qrc`
    file should now look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后不要忘记按*Ctrl* + *S*保存。您的`.qrc`文件现在应该是这样的：
- en: '![How to do it](img/B02820_01_14.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![如何做](img/B02820_01_14.jpg)'
- en: After that, open back to our `mainwindow.ui` file; we will now make use of the
    resources we have just added to our project. First, we will select the restart
    button located on the top panel. Then, scroll down the property editor until you
    see the `icon` property. Click the little button with a drop-down arrow icon and
    click **Choose Resources** from its menu.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开我们的`mainwindow.ui`文件；我们现在将使用刚刚添加到项目中的资源。首先，我们将选择位于顶部面板上的重新启动按钮。然后，向下滚动属性编辑器，直到看到`icon`属性。单击带有下拉箭头图标的小按钮，然后从其菜单中单击**选择资源**。
- en: The **Select Resource** window will then pop up. Click on the `icons` prefix
    on the left panel and then select the restart icon on the right panel. After that,
    press **OK**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将弹出**选择资源**窗口。在左侧面板上单击`icons`前缀，然后在右侧面板上选择重新启动图标。之后，按**确定**。
- en: You will now see a tiny icon appearing on the button. The icon looks very tiny
    because the default icon size is set at `16x16`. Change the `iconSize` property
    to `50x50` and you will see the icon appear bigger now.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您会看到一个小图标出现在按钮上。图标看起来非常小，因为默认图标尺寸设置为`16x16`。将`iconSize`属性更改为`50x50`，您会看到图标现在变大了。
- en: Repeat the preceding steps for the shutdown button, except this time we will
    choose the shutdown icon instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关闭按钮，重复上述步骤，只是这次我们将选择关闭图标。
- en: Once you're done, the two buttons should now look like this:![How to do it](img/B02820_01_15.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，两个按钮现在应该看起来像这样：![如何做](img/B02820_01_15.jpg)
- en: Next, we will use the image we added to the resource file as our logo. First,
    select the logo widget and remove the style sheet that we added earlier to render
    its outline.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用添加到资源文件中的图像作为我们的标志。首先，选择标志小部件，并删除我们先前添加的样式表，以渲染其轮廓。
- en: Scroll down the property editor until you see the `pixmap` property.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动属性编辑器，直到看到`pixmap`属性。
- en: Click the little drop-down button behind the `pixmap` property and select **Choose
    Resources** from the menu. After that, select the logo image and click **OK**.
    You will now see the logo size no longer follow the dimension you set previously
    and follow the actual dimension of the image instead. We cannot change its dimension
    because this is simply how `pixmap` works.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`pixmap`属性后面的小下拉按钮，并从菜单中选择**选择资源**。之后，选择标志图像并单击**确定**。现在，您会看到标志的大小不再遵循您先前设置的尺寸，而是遵循图像的实际尺寸。我们无法更改其尺寸，因为这就是`pixmap`的工作原理。
- en: 'If you want more control over the logo''s dimension, you can remove the image
    from the `pixmap` property and use a style sheet instead. You can use the following
    code to apply an image to the icon container:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想对标志的尺寸有更多控制，可以从`pixmap`属性中删除图像，并改用样式表。您可以使用以下代码将图像应用到图标容器：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To obtain the path of the image, right click the image name on the file list
    window and choose **Copy path**. The path will be saved to your operating system
    clipboard and now you can just paste it to the preceding style sheet. Using this
    method will ensure that the image fits exactly the dimension of the widget that
    you applied the style to. Your logo should now appear like so:![How to do it](img/B02820_01_16.jpg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取图像的路径，请右键单击文件列表窗口上的图像名称，然后选择**复制路径**。路径将保存到您的操作系统剪贴板中，现在您可以将其粘贴到前面的样式表中。使用这种方法将确保图像完全适合您应用样式的小部件的尺寸。您的标志现在应该看起来像这样：![如何做](img/B02820_01_16.jpg)
- en: 'Lastly, we will apply the wallpaper image to the background using a style sheet.
    Since the background dimension will change according to the window size, we cannot
    use `pixmap` in this case. Instead, we will use the `border-image` property in
    a style sheet to achieve this. Right click the main window and select **Change
    styleSheet** to open up the **Edit Style Sheet** window. We will add a new line
    under the style sheet of the central widget:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用样式表将壁纸图像应用到背景上。由于背景尺寸会根据窗口大小而改变，所以在这种情况下我们不能使用`pixmap`。相反，我们将使用样式表中的`border-image`属性来实现这一点。右键单击主窗口，选择**更改样式表**以打开**编辑样式表**窗口。我们将在中央小部件的样式表下添加一行新的样式表：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's really that simple and easy! Your login screen should now look like this:![How
    to do it](img/B02820_01_17.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这真的很简单和容易！您的登录界面现在应该看起来像这样：![如何做](img/B02820_01_17.jpg)
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理…
- en: 'The resource system in Qt stores binary files, such as images, translation
    files, and so on, in the executable when it gets compiled. It reads the resource
    collection files (`.qrc`) in your project to locate the files that need to be
    stored in the executable and include them into the build process. A `.qrc` file
    looks something like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的资源系统将二进制文件（如图像、翻译文件等）存储在编译后的可执行文件中。它读取项目中的资源集合文件（`.qrc`）来定位需要存储在可执行文件中的文件，并将它们包含到构建过程中。`.qrc`文件看起来像这样：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It uses XML format to store the paths of the resource files which are relative
    to the directory containing it. Do note that the listed resource files must be
    located in the same directory as the `.qrc` file, or one of its sub-directories.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用XML格式存储资源文件的路径，这些路径是相对于包含它的目录的。请注意，列出的资源文件必须位于与`.qrc`文件相同的目录中，或者其子目录之一。
- en: Customizing properties and sub-controls
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义属性和子控件
- en: Qt's style sheet system enables us to create stunning and professional-looking
    UIs with ease. In this example, we will learn how to set custom properties to
    our widgets and use them to switch between different styles.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的样式表系统使我们能够轻松创建令人惊叹和专业的UI。在这个例子中，我们将学习如何为我们的小部件设置自定义属性，并使用它们在不同样式之间切换。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's try out the scenario described in the preceding paragraph by creating
    a new Qt project. I have prepared the UI for this purpose. The UI contains three
    buttons on the left side and a tab widget with three pages located at the right
    side, as shown in the following screenshot:![How to do it…](img/B02820_01_18.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下上述段落中描述的情景，创建一个新的Qt项目。我已经为此准备了UI。UI在左侧包含三个按钮，在右侧有一个包含三个页面的选项卡小部件，如下截图所示：![如何做…](img/B02820_01_18.jpg)
- en: 'The three buttons are blue in color because I''ve added the following style
    sheet to the main window (not to the individual button):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个按钮是蓝色的，因为我已将以下样式表添加到主窗口（而不是单独的按钮）：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, I will explain to you what pseudo states are in Qt by adding the following
    style sheet to the main window, which you might be familiar with:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我将通过向主窗口添加以下样式表来向您解释Qt中的伪状态，您可能已经熟悉：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We used the preceding style sheet in the previous tutorial to make the buttons
    change color when there is a mouse-over. This is made possible by Qt Style Sheet''s
    pseudo state, which in this case is the word `hover` separated from the `QPushButton`
    class by a colon. Every widget has a set of generic pseudo states, such as `active`,
    `disabled`, `enabled`, and so on, and also a set of pseudo states which are applicable
    to their widget type. For example, states such as `open` and `flat` are available
    for `QPushButton`, but not for `QLineEdit`. Let''s add the `pressed` pseudo state
    to change the buttons'' color to yellow when the user clicks on it:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一个教程中使用了前面的样式表，使按钮在鼠标悬停时更改颜色。这是由Qt样式表的伪状态实现的，在这种情况下，是单词`hover`与`QPushButton`类之间用冒号分隔。每个小部件都有一组通用伪状态，例如`active`、`disabled`、`enabled`等，还有一组适用于其小部件类型的伪状态。例如，`QPushButton`可用`open`和`flat`等状态，但`QLineEdit`不行。让我们添加`pressed`伪状态以在用户单击时将按钮的颜色更改为黄色：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Pseudo states allow the users to load a different set of style sheet based on
    the condition that applies to it. Qt pushes this concept further by implementing
    dynamic properties in Qt Style Sheets. This allows us to change the style sheet
    of a widget when a custom condition has been met. We can make use of this feature
    to change the style sheet of our buttons based on a custom condition that we can
    set using custom properties in Qt.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伪状态允许用户根据适用于它的条件加载不同的样式表。Qt通过在Qt样式表中实现动态属性进一步推动了这一概念。这使我们能够在满足自定义条件时更改小部件的样式表。我们可以利用此功能根据Qt中的自定义属性设置来更改按钮的样式表。
- en: 'First, we will add this style sheet to our main window:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的主窗口添加此样式表：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What it does is basically change the push button''s background color to red
    if the property called `pagematches` returns `true`. Obviously, this property
    does not exist in the `QPushButton` class. However, we can add it to our buttons
    by using `QObject::setProperty()`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的基本作用是，如果名为`pagematches`的属性返回`true`，则将推按钮的背景颜色更改为红色。显然，`QPushButton`类中不存在此属性。但是，我们可以通过使用`QObject::setProperty()`将其添加到我们的按钮中：
- en: 'In your `MainWindow.cpp` source code, add the following code right after `ui->setupUi(this)`;:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的`MainWindow.cpp`源代码中，在`ui->setupUi(this)`之后添加以下代码：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code will add a custom property called `pagematches` to the first
    button and set its value as `true`. This will make the first button turn red by
    default.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的代码将向第一个按钮添加一个名为`pagematches`的自定义属性，并将其值设置为`true`。这将使第一个按钮默认变为红色。
- en: 'After that, right click on the tab widget and choose **Go to slot**. A window
    will then pop up; select the **currentChanged(int)** option from the list and
    click **Ok**. Qt will generate a `slot` function for you, which looks something
    like this:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在选项卡小部件上右键单击，选择**转到槽**。然后会弹出一个窗口；从列表中选择**currentChanged(int)**选项，然后单击**确定**。Qt将为您生成一个`slot`函数，看起来像这样：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `slot` function will be called whenever we change page of the tab widget.
    We can then decide what we want it to do by adding our code into the `slot` function.
    To do that, open up `mainwindow.cpp` and you will see the function''s declaration
    there. Let''s add some code to the function:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们更改选项卡小部件的页面时，将调用`slot`函数。然后，我们可以通过将代码添加到`slot`函数中来决定我们希望它执行的操作。要做到这一点，请打开`mainwindow.cpp`，您将在那里看到函数的声明。让我们向函数添加一些代码：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code basically does this: when the tab widget switches its current
    page, it sets the `pagematches` properties of all three buttons to `false`. Just
    be sure to reset everything before we decide which button should change to red.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码基本上是这样的：当选项卡小部件切换到当前页面时，它将所有三个按钮的`pagematches`属性设置为`false`。在我们决定哪个按钮应该变为红色之前，请确保重置所有内容。
- en: Then, check the `index` variable supplied by the event signal, which will tell
    you the index number of the current page. Set the `pagematches` property of one
    of the buttons to `true` based on the index number.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查事件信号提供的`index`变量，它将告诉您当前页面的索引号。根据索引号将一个按钮的`pagematches`属性设置为`true`。
- en: Lastly, refresh the style of all three buttons by calling `polish()`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`polish()`来刷新所有三个按钮的样式。
- en: 'Then, build and run the project. You should now see the three buttons changing
    their color to red whenever you switch the tab widget to a different page. Also,
    the buttons will change color to green when there is a mouse-over, as well as
    change their color to yellow when you click on them:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，构建并运行项目。现在，每当您将选项卡小部件切换到不同页面时，您应该会看到三个按钮的颜色变为红色。此外，当鼠标悬停时，按钮将变为绿色，当您单击它们时，它们的颜色将变为黄色：
- en: '![How to do it…](img/B02820_01_19.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/B02820_01_19.jpg)'
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt provides users the freedom of adding their own custom properties to any type
    of widget. Custom properties are very useful if you want to change a particular
    widget when a special condition is met, where Qt doesn't provide such a context
    by default. This allows the user to extend the usability of Qt and makes it a
    flexible tool for customized solutions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Qt为用户提供了向任何类型的小部件添加自定义属性的自由。如果您想在满足特殊条件时更改特定小部件，而Qt默认情况下不提供这样的上下文，那么自定义属性非常有用。这使用户能够扩展Qt的可用性，并使其成为定制解决方案的灵活工具。
- en: For example, if we have a row of buttons on our main window and we need one
    of them to change its color depending on which page the tab widget is currently
    showing, then there is no way the buttons would know when they should change their
    color, because Qt itself has no built-in context for this type of situation. To
    solve this issue, Qt provides us a method to add our own properties to the widgets,
    which is using a generic function called `QObject::setProperty()`. To read the
    custom property, we can use another function called `QObject::property()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在主窗口上有一排按钮，并且我们需要其中一个根据选项卡小部件当前显示的页面而更改其颜色，则按钮不会知道它们何时应更改其颜色，因为Qt本身没有针对这种情况的内置上下文。为了解决这个问题，Qt为我们提供了一种方法来向小部件添加自己的属性，即使用一个名为`QObject::setProperty()`的通用函数。要读取自定义属性，我们可以使用另一个名为`QObject::property()`的函数。
- en: Next, we will talk about sub-controls in Qt Style Sheets. It's actually quite
    self-explanatory by looking at the term sub-controls. Often, a widget is not just
    a single object but a combination of more than one object or control in order
    to form a more complex widget, and such objects are called sub-controls.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Qt样式表中的子控件。通过观察子控件这个术语，实际上是相当不言自明的。通常，一个小部件不仅仅是一个单一的对象，而是由多个对象或控件组合而成，以形成一个更复杂的小部件，这些对象被称为子控件。
- en: 'For example, a spin box widget contains an input field, a down button, an up
    button, an up arrow, and a down arrow, which is quite complicated compared to
    some other widgets. In this case, Qt grants us more flexibility by allowing us
    to change every single sub-control using a style sheet, if we wanted to. We can
    do so by specifying the name of the sub-control behind the widget''s class name,
    separated by a double colon. For instance, if I want to change the image of the
    down button in a spin box, I can write my style sheet like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个微调框小部件包含一个输入字段、一个向下按钮、一个向上按钮、一个向上箭头和一个向下箭头，与其他一些小部件相比相当复杂。在这种情况下，Qt允许我们通过样式表更灵活地改变每个子控件，如果我们想的话。我们可以通过在小部件类名后面指定子控件的名称，用双冒号分隔来实现。例如，如果我想改变微调框中向下按钮的图像，我可以这样写我的样式表：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That will only apply the image to the down button of my spin box, and not to
    any other parts of the widget.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只将图像应用于我的微调框的向下按钮，而不是小部件的任何其他部分。
- en: By combining custom properties, pseudo states, and sub-controls, Qt provides
    us with a very flexible method to customize our user interface.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合自定义属性、伪状态和子控件，Qt为我们提供了一种非常灵活的方法来自定义我们的用户界面。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visit the following link to learn more about pseudo states and sub-controls
    in Qt:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接了解更多关于Qt中伪状态和子控件的信息：
- en: '[http://doc.qt.io/qt-4.8/stylesheet-reference.html](http://doc.qt.io/qt-4.8/stylesheet-reference.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://doc.qt.io/qt-4.8/stylesheet-reference.html](http://doc.qt.io/qt-4.8/stylesheet-reference.html)'
- en: Styling in QML
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在QML中进行样式设置
- en: '**Qt Meta Language** or **Qt Modeling Language** (**QML**) is a Javascript-inspired
    user interface mark-up language used by Qt for designing user interfaces. Qt provides
    you with Qt Quick components (widgets powered by the QML technology) to easily
    design touch-friendly UI without C++ programming. We will learn more about how
    to use QML and Qt Quick components to design our program''s UI by following the
    steps given in the following section.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt Meta Language**或**Qt Modeling Language**（**QML**）是Qt使用的一种类似于Javascript的用户界面标记语言，用于设计用户界面。Qt为您提供了Qt
    Quick组件（由QML技术提供支持的小部件），可以轻松设计触摸友好的UI，无需C++编程。我们将通过按照以下部分给出的步骤来学习如何使用QML和Qt Quick组件来设计我们程序的UI。'
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Create a new project by going to **File** | **New File or Project**. Select
    **Application** under **Project** category and choose **Qt Quick Application**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件**|**新建文件或项目**来创建一个新项目。在**项目**类别下选择**应用程序**，然后选择**Qt Quick应用程序**。
- en: Press the **Choose** button, and that will bring you to the next window. Insert
    a name for your project and click the **Next** button again.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选择**按钮，这将带您到下一个窗口。输入项目名称，然后再次点击**下一步**按钮。
- en: Another window will now appear and ask you to choose a minimum required Qt version.
    Pick the latest version installed on your computer and click **Next**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将出现另一个窗口，询问您选择所需的最低Qt版本。选择计算机上安装的最新版本，然后点击**下一步**。
- en: After that, click **Next** again followed by **Finish**. Qt Creator will now
    create a new project for you.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，再次点击**下一步**，然后点击**完成**。Qt Creator现在将为您创建一个新项目。
- en: 'Once the project is being created, you will see there are some differences
    compare to a C++ Qt project. You will see two `.qml` files, namely `main.qml`
    and `MainForm.ui.qml`, inside the project resource. These two files are the UI
    description files using the QML mark-up language. If you double click `main.qml`
    file, Qt Creator will open up the script editor and you will see something like
    this:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，您会发现与C++ Qt项目相比有一些不同。您会在项目资源中看到两个`.qml`文件，分别是`main.qml`和`MainForm.ui.qml`。这两个文件是使用QML标记语言的UI描述文件。如果您双击`main.qml`文件，Qt
    Creator将打开脚本编辑器，您会看到类似于这样的内容：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This file basically tells Qt to create a window and insert a set of UI called
    `MainForm` which is actually from the other `.qml` file called `MainForm.ui.qml`.
    It also tells Qt that when the user clicks on the **mouseArea** widget, the entire
    program should be terminated.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个文件基本上告诉Qt创建一个窗口，并插入一个名为`MainForm`的UI集，实际上是来自另一个名为`MainForm.ui.qml`的`.qml`文件。它还告诉Qt，当用户点击**mouseArea**小部件时，整个程序应该被终止。
- en: Now, try to open the `MainForm.ui.qml` file by double-clicking on it. This time,
    Qt Designer (UI editor) will be opened instead, and you will see a completely
    different UI editor compared to the C++ project we did previously. This editor
    is also called the Qt Quick Designer, specially designed for editing QML-based
    UI only.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试双击打开`MainForm.ui.qml`文件。这次，Qt Designer（UI编辑器）将被打开，您会看到一个与我们之前做的C++项目完全不同的UI编辑器。这个编辑器也被称为Qt
    Quick Designer，专门用于编辑基于QML的UI。
- en: 'If you open up the `main.cpp` file in your project, you will see this line
    of code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在项目中打开`main.cpp`文件，你会看到这行代码：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code basically tells Qt's QML engine to load the `main.qml` file
    when the program starts. If you want to load the other `.qml` file instead of
    `main.qml`, you know where to look for the code.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码基本上告诉Qt的QML引擎在程序启动时加载`main.qml`文件。如果你想加载其他`.qml`文件而不是`main.qml`，你知道在哪里找代码了。
- en: When `main.qml` is loaded by the QML engine, it will also import `MainForm.ui.qml`
    into the UI, since `MainForm` is being called in the `main.qml` file. Qt will
    check if `MainForm` is a valid UI by searching for its `.qml` file based on the
    naming convention. Basically the concept is similar to the C++ project we did
    in the previous section, whereby the `main.qml` file acts like the `main.cpp`
    file and `MainForm.ui.qml` acts like the `MainWindow` class. You can also create
    other UI templates and use them in `main.qml`. Hopefully this comparison will
    make it easier to understand how QML works.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`main.qml`被QML引擎加载时，它还将`MainForm.ui.qml`导入到UI中，因为`MainForm`在`main.qml`文件中被调用。Qt将通过搜索其`.qml`文件来检查`MainForm`是否是有效的UI，这是基于命名约定的。基本上，这个概念类似于我们在上一节中做的C++项目，其中`main.qml`文件就像`main.cpp`文件，`MainForm.ui.qml`就像`MainWindow`类。您还可以创建其他UI模板并在`main.qml`中使用它们。希望这种比较能让您更容易理解QML的工作原理。
- en: 'Now let''s open up `MainForm.ui.qml`. You should see three items listed on
    the navigator window: **Rectangle**, **mouseArea**, and **Text**. When these items
    are interpreted by the QML engine, it produces the following result on the canvas:![How
    to do it…](img/B02820_01_21.jpg)'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打开`MainForm.ui.qml`。您应该在导航窗口上看到列出了三个项目：**Rectangle**、**mouseArea**和**Text**。当QML引擎解释这些项目时，它会在画布上产生以下结果：![操作步骤…](img/B02820_01_21.jpg)
- en: 'The **Rectangle** item is basically the base layout of the window, which cannot
    be deleted. It is similar to the `centralWidget` we used in the previous section.
    The **mouseArea** item is an invincible item that gets triggered when the mouse
    is clicking on it, or when a finger is touching it (for mobile platforms). The
    mouse area is also used in a button component, which we will be using in a while.
    The **Text** component is self-explanatory: it is a label that displays a block
    of text on the application.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Rectangle**项目基本上是窗口的基本布局，无法删除。它类似于我们在上一节中使用的`centralWidget`。**mouseArea**项目是一个无形项目，当鼠标点击它或手指触摸它（适用于移动平台）时会触发它。鼠标区域也用于按钮组件，我们一会儿会用到。**Text**组件是不言自明的：它是一个在应用程序上显示文本块的标签。'
- en: On the **Navigator** window, we can hide or show an item by clicking on the
    icon besides the item which resembles an eye. When an item is hidden, it will
    not show on the canvas nor the compiled application. Just like the widgets in
    a C++ Qt project, Qt Quick components are arranged in a hierarchy based on the
    parent-child relationship. All the children items will be placed below the parent
    item with an indented position. In our case, you can see the **mouseArea** and
    **Text** items are all positioned slightly to the right compared to the **Rectangle**
    item, because they are both the children of the **Rectangle** item. We can re-arrange
    the parent-child relationship as well as their position in the hierarchy by using
    a click-and-drag method from the navigator window. You can try clicking on the
    **Text** item and dragging it on top of **mouseArea**. You will then see the **Text**
    item changes its position and is now located below the **mouseArea** with a wider
    indentation:![How to do it…](img/B02820_01_22.jpg)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航**窗口上，我们可以通过单击类似于眼睛图标的项目旁边的图标来隐藏或显示项目。当项目被隐藏时，它将不会显示在画布上，也不会显示在编译后的应用程序中。就像C++
    Qt项目中的小部件一样，Qt Quick组件是根据父子关系的层次结构排列的。所有子项目将放置在具有缩进位置的父项目下方。在我们的情况下，您可以看到**mouseArea**和**Text**项目都相对于**Rectangle**项目略微向右放置，因为它们都是**Rectangle**项目的子项目。我们可以通过从导航窗口使用单击和拖动的方法重新排列父子关系以及它们在层次结构中的位置。您可以尝试单击**Text**项目并将其拖动到**mouseArea**上方。然后，您将看到**Text**项目改变了位置，现在位于**mouseArea**下方，并且缩进更宽：![操作步骤…](img/B02820_01_22.jpg)
- en: We can also re-arrange them by using the arrow buttons located on top of the
    navigator window, as shown in the preceding screenshot. Anything that happens
    to the parent item will also affect all its children, such as moving the parent
    item, hide and show the parent item, and so on.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用位于导航窗口顶部的箭头按钮来重新排列它们，如前面的屏幕截图所示。发生在父项上的任何事情也会影响到其所有子项，例如移动父项、隐藏和显示父项等。
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can pan around the canvas view by holding the middle mouse button (or mouse
    scroll) while moving your mouse around. You can also zoom in and out by scrolling
    your mouse while holding the *Ctrl* key on your keyboard. By default, scrolling
    your mouse will move the canvas view up and down. However, if your mouse cursor
    is on top of the horizontal scroll bar of the canvas, scrolling the mouse will
    move the view to the left and right.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按住鼠标中键（或鼠标滚轮）并移动鼠标来在画布视图中移动。您还可以在按住键盘上的*Ctrl*键的同时滚动鼠标来放大和缩小。默认情况下，滚动鼠标会上下移动画布视图。但是，如果您的鼠标光标位于画布的水平滚动条上方，滚动鼠标将使视图向左和向右移动。
- en: Next, delete both the **mouseArea** and **Text** items as we will be learning
    how to create a user interface from scratch using QML and Qt Quick.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除**mouseArea**和**Text**项目，因为我们将学习如何使用QML和Qt Quick从头开始创建用户界面。
- en: After you've done, let's set the **Rectangle** item's size to `800x600`, as
    we're going to need a bigger space for the widgets.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，让我们将**Rectangle**项目的大小设置为`800x600`，因为我们将需要更大的空间来放置小部件。
- en: 'Open up `main.qml` and remove these lines of code:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.qml`并删除以下代码：
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is because the **mouseArea** item no longer exists and it will cause an
    error when compiling.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为**mouseArea**项目不再存在，当编译时会导致错误。
- en: 'After that, remove the following code from `MainForm.ui.qml`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，从`MainForm.ui.qml`中删除以下代码：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is removed for the same reason as the previous code, because the **mouseArea**
    item no longer exists.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**mouseArea**项目不再存在，因此出于相同的原因，此内容已被删除。
- en: Then, copy the images we used in the previous C++ project over to the QML project's
    folder, because we are going re-create the same login screen, with QML!
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将我们在之前的C++项目中使用的图像复制到QML项目的文件夹中，因为我们要使用QML重新创建相同的登录界面！
- en: Add the images to the resource file so that we can use them for our UI.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像添加到资源文件中，以便我们可以在UI中使用它们。
- en: Once you're done with that, open up Qt Quick Designer again and switch to the
    resource window. Click and drag the background image directly to the canvas. Then,
    switch over to the **Layout** tab on the properties pane and click the fill anchor
    button marked in red circle. This will make the background image always stick
    to the window size:![How to do it…](img/B02820_01_23.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，再次打开Qt Quick Designer，并切换到资源窗口。直接点击并拖动背景图像到画布上。然后，切换到属性窗格上的**布局**选项卡，并点击红色圆圈标记的填充锚点按钮。这将使背景图像始终固定在窗口大小上：![操作步骤…](img/B02820_01_23.jpg)
- en: Next, click and drag a **Rectangle** component from the library window to the
    canvas. We will use this as the top panel for our program.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从库窗口中点击并拖动一个**矩形**组件到画布上。我们将使用这个作为程序的顶部面板。
- en: For the top panel, enable top anchor, left anchor, and right anchor so that
    it sticks to the top of the window and follow its width. Make sure all the margins
    are set to zero.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顶部面板，启用顶部锚点、左锚点和右锚点，使其固定在窗口顶部并跟随其宽度。确保所有边距都设置为零。
- en: Then, go to the `Color` property of the top panel and select **Gradient** mode.
    Set the first color to `#805bcce9` and the second color to `#80000000`. This will
    create a half-transparent panel with a blue gradient.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到顶部面板的`Color`属性，并选择**Gradient**模式。将第一种颜色设置为`#805bcce9`，第二种颜色设置为`#80000000`。这将创建一个半透明的面板，带有蓝色的渐变。
- en: After that, add a text widget to the canvas and make it a child of the top panel.
    Set its text property to the current date and time (for example, Monday, 26-10-2015
    3:14 PM) for display purposes. Then, set the text color to white.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将一个文本小部件添加到画布上，并将其设置为顶部面板的子级。将其文本属性设置为当前日期和时间（例如，星期一，2015年10月26日下午3:14），以供显示目的。然后，将文本颜色设置为白色。
- en: Switch over to the **Layout** tab and enable top anchor and left anchor so that
    the text widget will always stick to the top left corner of the screen.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**布局**选项卡，启用顶部锚点和左锚点，以便文本小部件始终固定在屏幕的左上角。
- en: Next, add a mouse area to the screen and set its size to `50x50`. Then, make
    it a child of the top panel by dragging it on top of the top panel in the navigator
    window.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在屏幕上添加一个鼠标区域，并将其大小设置为`50x50`。然后，通过将其拖动到导航窗口中的顶部面板上，使其成为顶部面板的子级。
- en: Set the color of the mouse area to blue (`#27a9e3`) and set its radius to `2`
    to make its corners slightly rounded. Then, enable top anchor and right anchor
    to make it stick to the top right corner of the window. Set the top anchor's margin
    to `8` and right anchor's margin to `10` to give out some space.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标区域的颜色设置为蓝色（`#27a9e3`），并将其半径设置为`2`，使其角落略微圆润。然后，启用顶部锚点和右锚点，使其固定在窗口的右上角。将顶部锚点的边距设置为`8`，右锚点的边距设置为`10`，以留出一些空间。
- en: After that, open up the resources window and drag the shutdown icon to the canvas.
    Then, make it a child of the mouse area item we created a moment ago. Then, enable
    the fill anchor to make it fit the size of the mouse area.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，打开资源窗口，并将关闭图标拖动到画布上。然后，将其设置为我们刚刚创建的鼠标区域项的子级。然后，启用填充锚点，使其适应鼠标区域的大小。
- en: Phew, that's a lot of steps! Now your items should be arranged like this on
    the **Navigator** window:![How to do it…](img/B02820_01_24.jpg)
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哦，这是很多步骤！现在你的项目应该在**导航**窗口上排列如下：![操作步骤…](img/B02820_01_24.jpg)
- en: The parent-child relationship and the layout anchors are both very important
    to keep the widgets in the correct positions when the main window changes its
    size.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当主窗口改变大小时，父子关系和布局锚点都非常重要，以保持小部件在正确的位置。
- en: At this point, your top panel should look something like this:![How to do it…](img/B02820_01_25.jpg)
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，你的顶部面板应该看起来像这样：![操作步骤…](img/B02820_01_25.jpg)
- en: Next, we will be working on the login form. First, add a new rectangle to the
    canvas by dragging it from the **Library** window. Resize the rectangle to `360x200`
    and set its radius to `15`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将开始处理登录表单。首先，通过从**库**窗口中拖动矩形到画布上，添加一个新的矩形。将矩形的大小调整为`360x200`，并将其半径设置为`15`。
- en: Then, set its color to `#80000000`, which will change it to black with `50%`
    transparency.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其颜色设置为`#80000000`，这将使其变为黑色，透明度为`50%`。
- en: After that, enable the vertical center anchor and the horizontal center anchor
    to make it always align to the center of the window. Then, set the margin of the
    vertical center anchor to `100` so that it moves slightly lower to the bottom
    to give space to the logo. The following screenshot illustrates the settings of
    the anchors:![How to do it…](img/B02820_01_26.jpg)
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，启用垂直中心锚点和水平中心锚点，使其始终与窗口中心对齐。然后，将垂直中心锚点的边距设置为`100`，使其稍微向下移动到底部，为标志留出空间。以下截图展示了锚点的设置：![操作步骤…](img/B02820_01_26.jpg)
- en: Add the text widgets to the canvas. Make them the children of the login form
    (rectangle widget) and set their text property to `Username:` and `Password:`
    respectively. Then, change their text color to white and position them accordingly.
    We don't need to set a margin this time because they will follow the rectangle's
    position.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本小部件添加到画布上。将它们设置为登录表单（矩形小部件）的子级，并将它们的文本属性分别设置为`用户名：`和`密码：`。然后，将它们的文本颜色设置为白色，并相应地定位它们。这次我们不需要设置边距，因为它们将跟随矩形的位置。
- en: Next, add two text input widgets to the canvas and place them next to the text
    widgets we created just now. Make sure the text inputs are also the children of
    the login form. Since the text inputs don't contain any background color property,
    we need to add two rectangles to the canvas to use as their background.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在画布上添加两个文本输入小部件，并将它们放置在我们刚刚创建的文本小部件旁边。确保文本输入也是登录表单的子级。由于文本输入不包含任何背景颜色属性，我们需要在画布上添加两个矩形作为它们的背景。
- en: Add two rectangles to the canvas and make each of them a child of one of the
    text inputs we created just now. Then, set the radius property to `5` to give
    them some rounded corners. After that, enable fill anchors on both of the rectangles
    so that they will follow the size of the text input widgets.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加两个矩形，并将它们分别设置为我们刚刚创建的文本输入的子级。然后，将半径属性设置为`5`，使它们具有一些圆角。之后，在两个矩形上启用填充锚点，以便它们将跟随文本输入小部件的大小。
- en: After that, we're going to create the login button below the password field.
    First, add a mouse area to the canvas and make it a child of the login form. Then,
    resize it to your preferred dimension and move it into place.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将在密码字段下方创建登录按钮。首先，在画布上添加一个鼠标区域，并将其设置为登录表单的子级。然后，将其调整为所需的尺寸并移动到指定位置。
- en: Since the mouse area also does not contain any background color property, we
    need to add a rectangle widget and make it a child of the mouse area. Set the
    color of the rectangle to blue (`#27a9e3`) and enable the fill anchor so that
    it fits nicely with the mouse area.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于鼠标区域也不包含任何背景颜色属性，我们需要添加一个矩形小部件，并将其设置为鼠标区域的子级。将矩形的颜色设置为蓝色（`#27a9e3`），并启用填充锚点，使其与鼠标区域完美匹配。
- en: Next, add a text widget to the canvas and make it a child of the login button.
    Change its text color to white and set its text property to `Login`. Finally,
    enable the horizontal center anchor and the vertical center anchor to align it
    to the center of the button.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在画布上添加一个文本小部件，并将其设置为登录按钮的子级。将其文本颜色设置为白色，并将其文本属性设置为`登录`。最后，启用水平居中锚点和垂直居中锚点，使其与按钮居中对齐。
- en: You will now get a login form that looks pretty similar to the one we made in
    the C++ project:![How to do it…](img/B02820_01_27.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您将获得一个看起来与我们在C++项目中制作的登录表单非常相似的登录表单：![如何做...](img/B02820_01_27.jpg)
- en: After we have done the login form, it's time to add the logo. It's actually
    very simple. First, open up the resources window and drag the logo image to the
    canvas.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成登录表单后，是时候添加标志了。实际上非常简单。首先，打开资源窗口，然后将标志图像拖放到画布中。
- en: Make it a child of the login form and set its size to `512x200`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为登录表单的子级，并将其大小设置为`512x200`。
- en: Position it above the login form and you're done!
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其定位在登录表单上方，然后完成！
- en: This is what the entire UI look like when compiled. We have successfully re-created
    the login screen from the C++ project, but this time we did it with QML and Qt
    Quick!![How to do it…](img/B02820_01_28.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是编译后整个UI的样子。我们已经成功地用QML和Qt Quick重新创建了C++项目中的登录界面！[如何做...](img/B02820_01_28.jpg)
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Qt Quick editor uses a very different approach for placing widgets in the application
    compared to the form editor. It's entirely up to the user which method is best
    suited for him/her.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick编辑器在将小部件放置在应用程序中的方法上与表单编辑器有很大不同。用户可以自行决定哪种方法最适合他/她。
- en: 'The following screenshot shows what the Qt Quick Designer looks like:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Qt Quick Designer的外观：
- en: '![How it works...](img/B02820_01_20.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B02820_01_20.jpg)'
- en: 'We will now look at the various elements of the editor''s UI:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下编辑器UI的各个元素：
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file as a tree structure. It''s similar to the object operator window in the other
    Qt Designer we used in previous section.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导航器**：**导航器**窗口以树形结构显示当前QML文件中的项目。它类似于我们在上一节中使用的其他Qt Designer中的对象操作器窗口。'
- en: '**Library**: The **Library** window displays all the Qt Quick Components or
    Qt Quick Controls available in QML. You can click and drag it to the canvas window
    to add to your UI. You can also create your own custom QML components and display
    it here.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**库**：**库**窗口显示所有可用的QML组件或Qt Quick控件。您可以单击并将其拖放到画布窗口中以添加到您的UI中。您还可以创建自定义的QML组件并在此处显示。'
- en: '**Resources**: The **Resources** window displays all the resources in a list
    which can then be used in your UI design.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资源**：**资源**窗口以列表形式显示所有资源，然后可以在UI设计中使用。'
- en: '**Imports**: The **Imports** window allows you to import different QML modules
    into your current QML file, such as a bluetooth module, webkit module, positioning
    module, and so on, to add additional functionality to your QML project.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导入**：**导入**窗口允许您将不同的QML模块导入到当前的QML文件中，例如蓝牙模块、webkit模块、定位模块等，以为您的QML项目添加额外的功能。'
- en: '**State pane**: Stat pane displays the different states in the QML project
    which typically describe UI configurations, such as the UI controls, their properties
    and behavior, and the available actions.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**状态窗格**：状态窗格显示QML项目中的不同状态，通常描述UI配置，例如UI控件、其属性和行为以及可用的操作。'
- en: '**Properties pane**: Similar to the property editor we used in previous section,
    this properties pane in QML Designer displays the properties of the selected item.
    You can also change the properties of the items in the code editor as well.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**属性窗格**：与我们在上一节中使用的属性编辑器类似，QML Designer中的属性窗格显示所选项目的属性。您也可以在代码编辑器中更改项目的属性。'
- en: '**Canvas**: Canvas is the working area where you create QML components and
    design applications.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**画布**：画布是您创建QML组件和设计应用程序的工作区。'
- en: Exposing QML object pointer to C++
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将QML对象指针暴露给C++
- en: Sometimes we want to modify the properties of a QML object through C++ scripting,
    such as changing the text of a label, hiding/showing the widget, changing its
    size, and so on. Qt's QML engine allows you to register your QML objects to C++
    types which automatically exposes all its properties.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望通过C++脚本修改QML对象的属性，例如更改标签的文本、隐藏/显示小部件、更改其大小等。Qt的QML引擎允许您将QML对象注册为C++类型，从而自动公开其所有属性。
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to create a label in QML and change its text occasionally. In order
    to expose the label object to C++, we can do the following steps. First, create
    a C++ class called `MyLabel` that extends from `QObject` class:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在QML中创建一个标签，并偶尔更改其文本。为了将标签对象暴露给C++，我们可以执行以下步骤。首先，创建一个名为`MyLabel`的C++类，它继承自`QObject`类：
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `mylabel.cpp` source file, define a function called `SetMyObject()`
    to save the object pointer. This function will later be called in QML:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mylabel.cpp`源文件中，定义一个名为`SetMyObject()`的函数来保存对象指针。稍后将在QML中调用此函数：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, in `main.cpp`, include `MyLabel` header and register it to QML
    engine using the function `qmlRegisterType()`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`main.cpp`中，包括`MyLabel`头文件，并使用`qmlRegisterType()`函数将其注册到QML引擎中：
- en: '[PRE32]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that there are four parameters you need to declare in `qmlRegisterType()`.
    Besides declaring your class name (`MyLabel`), you also need to declare your library
    name (`MyLabelLib`) and its version (`1.0`), which will be used for importing
    your class to QML later on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`qmlRegisterType()`中需要声明四个参数。除了声明您的类名（`MyLabel`）之外，还需要声明您的库名称（`MyLabelLib`）和其版本（`1.0`），这将用于以后将您的类导入到QML中。
- en: Now that the QML engine is fully aware of our custom label class, we can then
    map it to our label object in QML and import the class library we defined earlier
    by calling import `MyLabelLib 1.0` in our QML file. Notice that the library name
    and its version number have to match with the one you declared in `main.cpp`,
    otherwise it will throw you an error.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在QML引擎已经完全了解我们的自定义标签类，我们可以将其映射到QML中的标签对象，并通过在我们的QML文件中调用`import MyLabelLib
    1.0`来导入我们之前定义的类库。请注意，库名称及其版本号必须与您在`main.cpp`中声明的相匹配，否则将会抛出错误。
- en: 'After declaring `MyLabel` in QML and setting its ID as `mylabels`, call `mylabel.SetMyObject(myLabel)`
    to expose its pointer to C/C++ right after the label is being initialized:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在QML中声明`MyLabel`并将其ID设置为`mylabels`后，立即调用`mylabel.SetMyObject(myLabel)`将其指针暴露给C/C++，在标签初始化后：
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please be aware that you need to wait until the label is fully initiated before
    exposing its pointer to C/C++, otherwise you may cause the program to crash. To
    make sure it's fully initiated, call `SetMyObject()` within `Component.onCompleted`
    and not any other places.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您需要等待标签完全初始化后，才能将其指针暴露给C/C++，否则可能会导致程序崩溃。为了确保它完全初始化，调用`SetMyObject()`在`Component.onCompleted`中，而不是其他任何地方。
- en: 'Now that the QML label has been exposed to C/C++, we can change any of its
    properties by calling `setProperty()` function. For instance, we can set its visibility
    to `true` and change its text to `Bye bye world!`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在QML标签已经暴露给C/C++，我们可以通过调用`setProperty()`函数来更改其任何属性。例如，我们可以将其可见性设置为`true`，并将其文本更改为`再见世界！`：
- en: '[PRE34]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Besides changing the properties, we can also call its functions by calling
    `QMetaObject::invokeMethod()`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改属性，我们还可以通过调用`QMetaObject::invokeMethod()`来调用其函数：
- en: '[PRE35]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or simply, we can call the `invokedMethod()` function with only two parameters
    if we do not expect any values to be returned from it:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地，如果我们不希望从中返回任何值，我们可以只使用两个参数调用`invokedMethod()`函数：
- en: '[PRE36]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: QML is designed to be easily extensible through C++ code. The classes in the
    Qt QML module enable QML objects to be loaded and manipulated from C++, and the
    nature of the QML engine's integration with Qt's meta object system enables C++
    functionality to be invoked directly from QML. To provide some C++ data or functionality
    to QML, it must be made available from a QObject-derived class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: QML旨在通过C++代码轻松扩展。Qt QML模块中的类使得可以从C++加载和操作QML对象，而QML引擎与Qt的元对象系统的集成性质使得可以直接从QML调用C++功能。要将一些C++数据或功能提供给QML，必须从QObject派生类中提供。
- en: QML object types can be instantiated from C++ and inspected in order to access
    their properties, invoke their methods, and receive their signal notifications.
    This is possible due to the fact that all QML object types are implemented using
    QObject-derived classes, enabling the QML engine to dynamically load and introspect
    objects through the Qt meta object system.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: QML对象类型可以从C++中实例化和检查，以便访问它们的属性，调用它们的方法，并接收它们的信号通知。这是可能的，因为所有QML对象类型都是使用QObject派生类实现的，使得QML引擎能够通过Qt元对象系统动态加载和内省对象。
