- en: Chapter 4. Layout, Elements, and Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。布局、元素和控件
- en: The last chapter discussed XAML, a neutral language used to create objects and
    set up their properties. But XAML is just a tool—the content is what matters.
    Building an effective user interface involves at least selecting the best elements
    and controls to achieve the usability and required user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论了XAML，这是一种中立的语言，用于创建对象并设置它们的属性。但是XAML只是一个工具，内容才是最重要的。构建有效的用户界面至少涉及选择最佳的元素和控件，以实现可用性和所需的用户体验。
- en: In this chapter, we'll take a look at the WinRT layout system and discuss the
    major elements and controls that comprise most user interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍WinRT布局系统，并讨论构成大多数用户界面的主要元素和控件。
- en: Introducing layout
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍布局
- en: Layout is the process of element placement and their size and position changes
    in face of user interactions or content changes. In the Win32/MFC world layout
    is mostly very simple and limited. Controls are placed using distance from the
    top-left point of a window and their size is explicitly specified. This model
    has very limited flexibility; if a control's content changes (for example, becomes
    bigger), the control can't compensate automatically. Other similar changes have
    no effect on the UI layout.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是元素放置和它们的大小和位置在用户交互或内容更改时发生变化的过程。在Win32/MFC世界中，布局通常非常简单和有限。控件是使用距离窗口左上角的距离放置的，并且它们的大小是明确指定的。这种模型的灵活性非常有限；如果控件的内容发生变化（例如变得更大），控件无法自动补偿。其他类似的变化对UI布局没有影响。
- en: WinRT, on the other hand, provides a much more flexible model based around a
    set of layout panels that provide different ways to lay out elements. By combining
    those panels in various ways, complex and adaptive layouts can be created.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，WinRT提供了一个基于一组布局面板的更灵活的模型，这些面板提供了不同的布局元素的方式。通过以各种方式组合这些面板，可以创建复杂和自适应的布局。
- en: Layout is a two-step process. First, the layout container asks each of its children
    for their desired size. In the second step, it uses whatever logic is applicable
    (for that panel type) to determine at what position and what size each child element
    be, and places each child in that rectangular area.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是一个两步过程。首先，布局容器询问每个子元素它们所需的大小。在第二步中，它使用适用的任何逻辑（对于该面板类型）来确定每个子元素的位置和大小，并将每个子元素放置在该矩形区域中。
- en: 'Each element indicates to its parent its size requirements. The following figure
    summarizes the most important properties related to these requirements:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素向其父元素指示其大小要求。以下图总结了与这些要求相关的最重要的属性：
- en: '![Introducing layout](img/5022_04_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Introducing layout](img/5022_04_01.jpg)'
- en: 'Here''s a quick breakdown of these important properties:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些重要属性的快速概述：
- en: '`Width`/`Height` – the width and height of the element in question. This is
    not typically set (unset value being the default value—`"Auto"`—in XAML; more
    on that in a moment), meaning the element would like to be as big as it needs
    to be. Nevertheless, these may be set if needed. The actual (rendered) width and
    height of an element is available using the `FrameworkElement::ActualWidth` and
    `ActualHeight` read-only properties.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Width`/`Height` – 所讨论的元素的宽度和高度。通常不设置（在XAML中未设置值为默认值—`"Auto"`—更多内容稍后会介绍），这意味着元素希望尽可能大。但是，如果需要，这些可以设置。元素的实际（渲染）宽度和高度可以使用`FrameworkElement::ActualWidth`和`ActualHeight`只读属性获得。'
- en: '`MinWidth`/`MaxWidth`/`MinHeight`/`MaxHeight` – the minima and maxima for the
    element size (not shown in the figure). Default values are `0` for the minima,
    and infinite for the maxima.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinWidth`/`MaxWidth`/`MinHeight`/`MaxHeight` – 元素大小的最小值和最大值（图中未显示）。默认值为最小值为`0`，最大值为无穷大。'
- en: '`Margin` – a "breathing space" around the element. This is of type `Thickness`
    that has four fields (`Left`, `Top`, `Right`, and `Bottom`) that determine the
    amount of space around the element. It can be specified in XAML using four values
    (left, top, right, bottom), two values (the first is left and right, the second
    top and bottom), or a single number (the same distance in all four directions).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Margin` – 元素周围的“呼吸空间”。这是`Thickness`类型，有四个字段（`Left`、`Top`、`Right`和`Bottom`），用于确定元素周围的空间量。它可以在XAML中使用四个值（左、上、右、下）、两个值（第一个是左和右，第二个是上和下）或一个单一数字（四个方向上的相同距离）来指定。'
- en: '`Padding` – same idea as `Margin`, but determines the space between the outer
    edge of the element and its content (if any). This is typed as `Thickness` as
    well, and is defined by the `Control` base class and some other special elements,
    such as `Border` and `TextBlock`.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Padding` – 与`Margin`相同的概念，但确定元素的外边缘与其内容（如果有）之间的空间。这也被定义为`Thickness`，并由`Control`基类和一些其他特殊元素（如`Border`和`TextBlock`）定义。'
- en: '`HorizontalAlignment`/`VerticalAlignment` – specifies how to align the element
    against its parent if extra space is available. Possible values are `Left`, `Center`,
    `Right`, and `Stretch` (for `HorizontalAlignment`) and `Top`, `Center`, `Bottom`,
    and `Stretch` for `VerticalAlignment`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalAlignment`/`VerticalAlignment` – 指定元素相对于其父元素对齐的方式（如果有额外的空间）。可能的值是`Left`、`Center`、`Right`和`Stretch`（对于`HorizontalAlignment`），以及`Top`、`Center`、`Bottom`和`Stretch`（对于`VerticalAlignment`）。'
- en: '`HorizontalContentAlignment`/`VerticalContentAlignment` (not shown in the figure)
    – same idea as `Horizontal`/`VerticalAlignment`, but for the `Content` of the
    element (if any).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HorizontalContentAlignment`/`VerticalContentAlignment`（图中未显示）– 与`Horizontal`/`VerticalAlignment`相同的概念，但用于元素的`Content`（如果有）。'
- en: '`FlowDirection` – can be used to switch the layout direction from the default
    (`LeftToRight`) to `RightToLeft`, suitable for right to left languages, such as
    Hebrew or Arabic. This effectively turns every "left" to "right" and vice versa.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FlowDirection` – 可用于将布局方向从默认值（`LeftToRight`）切换到`RightToLeft`，适用于从右到左的语言，如希伯来语或阿拉伯语。这实际上将每个“左”变为“右”，反之亦然。'
- en: After the layout panel collects the required size of each child element (by
    calling `UIElement::Measure` on each one), it moves on to the second stage of
    the layout—arranging. In this stage, the panel calculates the final positions
    and sizes of its child elements based on the element's desired size (`UIElement::DesiredSize`
    read-only property) and whatever algorithm is appropriate for that panel and informs
    each element of the resulting rectangle by calling `UIElement::Arrange`. This
    procedure can go on recursively, because an element can be a layout panel in itself,
    and so on. The result is known as a visual tree.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局面板收集每个子元素所需的大小（通过对每个元素调用`UIElement::Measure`）之后，它进入布局的第二阶段——排列。在这个阶段，面板根据元素的期望大小（`UIElement::DesiredSize`只读属性）和适合该面板的任何算法来计算其子元素的最终位置和大小，并通过调用`UIElement::Arrange`通知每个元素所得到的矩形。这个过程可以递归进行，因为一个元素本身可以是一个布局面板，依此类推。结果被称为可视树。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested readers may be wondering how to specify the `"Auto"` XAML value for,
    for example, `Width` in code, given that this is a `double` value. This is done
    by including `<limits>` and then using the expression `std::numeric_limits<double>::quiet_NaN()`.
    Similarly, to specify an infinite value, use `std::numeric_limits<double>::infinity()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可能想知道如何在代码中为`Width`（例如）指定`"Auto"`XAML值，因为这是一个`double`值。这是通过包括`<limits>`，然后使用表达式`std::numeric_limits<double>::quiet_NaN()`来完成的。类似地，要指定无限值，请使用`std::numeric_limits<double>::infinity()`。
- en: Layout panels
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局面板
- en: All layout panels must derive from the `Windows::UI::Xaml::Controls::Panel`
    class, itself deriving from `FrameworkElement`. The main addition `Panel` is the
    `Children` property (also its `ContentProperty` for easier XAML authoring), which
    is a collection of elements implementing the `IVector<UIElement>` interface. By
    using the `Children` property, elements can be dynamically added or removed from
    a `Panel`. WinRT provides a bunch of specific panels, each with its own layout
    logic, providing flexibility in creating the layout. In the following sections,
    we'll take a look at some of the built-in layout panels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有布局面板都必须派生自`Windows::UI::Xaml::Controls::Panel`类，它本身派生自`FrameworkElement`。主要的附加`Panel`是`Children`属性（也是它的`ContentProperty`，用于更容易的XAML编写），它是实现`IVector<UIElement>`接口的元素集合。通过使用`Children`属性，可以动态地向`Panel`添加或删除元素。WinRT提供了一堆特定的面板，每个面板都有自己的布局逻辑，提供了创建布局的灵活性。在接下来的章节中，我们将看一些内置的布局面板。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All panel classes, as well as elements and controls described later, are assumed
    to exist in the `Windows::UI::Xaml::Controls` namespace, unless noted otherwise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有面板类，以及稍后描述的元素和控件，都假定存在于`Windows::UI::Xaml::Controls`命名空间中，除非另有说明。
- en: StackPanel
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StackPanel
- en: '`StackPanel` is one of the simplest layout panels. It lays out its children
    in a *stack*, one after the other, horizontally or vertically, based on the `Orientation`
    property (`Vertical` being the default).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel`是最简单的布局面板之一。它根据`Orientation`属性（`Vertical`是默认值）在*堆栈*中水平或垂直地布置其子元素。'
- en: 'When used for vertical layout, each element gets the height it wants and all
    the available width, and vice versa. Here''s an example of `StackPanel` with some
    elements:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于垂直布局时，每个元素都会得到它想要的高度和所有可用的宽度，反之亦然。这是`StackPanel`与一些元素的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is how it looks at runtime (after some text is entered):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时的样子（在输入一些文本后）：
- en: '![StackPanel](img/5022_04_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![StackPanel](img/5022_04_02.jpg)'
- en: '`StackPanel` is useful for small layout tasks, as part of other, more complex
    layout panels.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackPanel`对于小型布局任务很有用，作为其他更复杂的布局面板的一部分。'
- en: Grid
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grid
- en: '`Grid` is probably the most useful layout panel because of its flexibility.
    It creates a table-like layout of cells. Elements can occupy single or multiple
    cells, and cell size is customizable. We''ve used `Grid` to create the calculator
    layout from the previous chapter. Here''s another `Grid` example (wrapped in a
    `Border` element), a piece of markup for a login page:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`可能是最有用的布局面板，因为它很灵活。它创建了一个类似表格的单元格布局。元素可以占据单个或多个单元格，单元格大小是可定制的。我们已经使用`Grid`来创建了上一章中的计算器布局。这里是另一个`Grid`示例（包装在`Border`元素中），一个登录页面的标记：'
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how it looks at runtime:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时的样子：
- en: '![Grid](img/5022_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Grid](img/5022_04_03.jpg)'
- en: The number of rows and columns is not specified by simple properties. Instead,
    it's specified using `RowDefinition` objects (for rows) and `ColumnDefinition`
    objects (for columns). The reason has to do with the size and behavior that can
    be specified on a row and/or column basis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 行数和列数不是通过简单的属性来指定的。而是使用`RowDefinition`对象（对于行）和`ColumnDefinition`对象（对于列）来指定。原因在于可以根据行和/或列的大小和行为来指定。
- en: '`RowDefinition` has a `Height` property, while `ColumnDefintion` has a `Width`
    property. Both are of type `GridLength`. There are three options for setting `GridLength`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowDefinition`有一个`Height`属性，而`ColumnDefintion`有一个`Width`属性。两者都是`GridLength`类型。有三种设置`GridLength`的选项：'
- en: A specific length
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定长度
- en: A star-based (relative) factor (this is the default, and factor equals 1)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于星号的（相对）因子（这是默认值，因子等于1）
- en: Automatic length
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动长度
- en: Setting `Height` (of a `RowDefintion`) or `Width` (of a `ColumnDefinition`)
    to a specific number makes that row/column that particular size. In code it's
    equivalent to `ref new GridLength(len)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Height`（`RowDefintion`）或`Width`（`ColumnDefinition`）设置为特定数字会使该行/列具有特定的大小。在代码中，它相当于`ref
    new GridLength(len)`。
- en: Setting `Height` or `Width` to `"Auto"` (in XAML) makes the row/column as high/wide
    as it needs to be based on the tallest/widest element placed within that row/column.
    In code, it's equivalent to the static property `GridLength::Auto`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在XAML中将`Height`或`Width`设置为`"Auto"`会使行/列的高度/宽度根据放置在该行/列中的最高/最宽元素的需要而定。在代码中，它相当于静态属性`GridLength::Auto`。
- en: 'The last option (which is the default) is setting `Height`/`Width` to `n*`
    in XAML, where *n* is a number (`1` if omitted). This sets up a relationship with
    other rows/columns that have a "star" length. For example, here are three rows
    of a `Grid`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项（默认情况下）是在XAML中将`Height`/`Width`设置为`n*`，其中*n*是一个数字（如果省略则为`1`）。这将与具有“星号”长度的其他行/列建立关系。例如，这是`Grid`的三行：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that the first row is twice as tall as the second row (`Height="*"`).
    The last row is three times taller than the second row, and is one-and-a-half
    times taller than the first row. These relations are maintained, even if the `Grid`
    is dynamically resized due to layout changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第一行的高度是第二行的两倍（`Height="*"`）。最后一行比第二行高三倍，比第一行高一倍半。即使`Grid`由于布局更改而动态调整大小，这些关系也会保持不变。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The value for the "star" factor need not be a whole number; it can be a floating
    point value as well. The ratio is what matters, not the actual numbers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “星号”因子的值不必是整数；它也可以是浮点数值。重要的是比例，而不是实际数字。
- en: Elements are placed in specific grid cells using the attached `Grid.Row` and
    `Grid.Column` properties (both default to zero, meaning the first row and column).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用附加的`Grid.Row`和`Grid.Column`属性将元素放置在特定的网格单元格中（两者默认为零，意味着第一行和第一列）。
- en: Elements occupy one cell by default. This can be changed by using the `Grid.RowSpan`
    and `Grid.ColumnSpan` properties (this was set for the first `TextBlock` in the
    previous XAML).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元素默认情况下占用一个单元格。可以通过使用`Grid.RowSpan`和`Grid.ColumnSpan`属性来更改这一点（在先前的XAML中为第一个`TextBlock`设置了这个属性）。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's ok to specify `ColumnSpan` or `RowSpan` with a large number to ensure an
    element will occupy all cells in a given direction. The `Grid` automatically will
    use the actual row/column count.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用大数字指定`ColumnSpan`或`RowSpan`以确保元素将占据给定方向上的所有单元格。`Grid`将自动使用实际的行/列计数。
- en: Canvas
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布
- en: '`Canvas` models the classic Win32/MFC layout – exact positioning. This type
    of layout is useful if exact coordinates are required, such as the case with graphs,
    animations, graphic games, and other complex drawings. `Canvas` is the fastest
    layout panel, just because it does very little layout (in fact almost none at
    all).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`模拟了经典的Win32/MFC布局——精确定位。如果需要精确坐标，例如图形、动画、图形游戏和其他复杂绘图的情况下，这种布局很有用。`Canvas`是最快的布局面板，因为它几乎没有布局（实际上几乎没有）。'
- en: 'Here''s an example of `Canvas` hosting some shapes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Canvas`托管一些形状的示例：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is shown as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Canvas](img/5022_04_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Canvas](img/5022_04_04.jpg)'
- en: The placement coordinates are set using the `Canvas.Left` and `Canvas.Top` attached
    properties (both default to zero, meaning the top-left corner of the `Canvas`).
    The only other attached property that `Canvas` defines is `ZIndex`. This specifies
    the relative order of rendering the elements inside the `Canvas`, where a large
    value places the element on top. By default, elements defined later in XAML are
    higher in the Z-order.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Canvas.Left`和`Canvas.Top`附加属性设置放置坐标（两者默认为零，意味着`Canvas`的左上角）。`Canvas`定义的唯一其他附加属性是`ZIndex`。这指定了在`Canvas`内部渲染元素的相对顺序，其中大值将元素放置在顶部。默认情况下，XAML中后定义的元素在Z顺序中更高。
- en: 'As a more complex example, suppose we wanted to allow the user to drag the
    shapes around the `Canvas` using the mouse or a finger. First, we''ll add event
    handlers for pointer pressing, releasing, and movement:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更复杂的示例，假设我们想要允许用户使用鼠标或手指在`Canvas`上拖动形状。首先，我们将为指针按下、释放和移动添加事件处理程序：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of "pointer" replaces the "mouse" event names that may be familiar
    from Win32/MFC/WPF/Silverlight; pointer is generic, representing any pointing
    device, be it a mouse, stylus, or a finger.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “指针”的概念取代了可能熟悉的来自Win32/MFC/WPF/Silverlight的“鼠标”事件名称；指针是通用的，代表任何指针设备，无论是鼠标、触控笔还是手指。
- en: The pointer-related events use the bubbling strategy, meaning any pressing on
    elements (such as the shapes used) will raise `PointerPressed` on that shape first,
    and if unhandled (as in this case), bubble up to its parent (the `Canvas`) where
    it does get handled.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针相关的事件使用冒泡策略，这意味着对元素（例如使用的形状）的任何按压都会首先引发该形状上的`PointerPressed`事件，如果未处理（在这种情况下），则会冒泡到其父级（`Canvas`）上，那里会得到处理。
- en: 'The `PointerPressed` event may be handled like so:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`PointerPressed`事件可以这样处理：'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since this event fires on the `Canvas`, even though the original elements are
    the children of one of the `Canvas`, how do we get to that child element? The
    sender argument is the actual object that sent the event—the `Canvas` in this
    case. The child element is indicated by the `PointerRoutedEventArgs::OriginalSource`
    property (inherited from `RoutedEventArgs`). First, a check is made to see if
    the pointer pressing is in fact on the `Canvas` itself. If so, the method returns
    immediately.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此事件在`Canvas`上触发，即使原始元素是`Canvas`的子元素，我们如何才能到达该子元素？发送者参数是实际发送事件的对象——在这种情况下是`Canvas`。子元素由`PointerRoutedEventArgs::OriginalSource`属性指示（从`RoutedEventArgs`继承）。首先，检查是否按下指针实际上在`Canvas`本身上。如果是，该方法立即返回。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With the preceding `Canvas`, this will never happen. The reason is that the
    default `Background` of the `Canvas` (or any other `Panel` for that matter) is
    `nullptr`, so that no events can register on it—they propagate to its parent.
    If events on the `Canvas` itself are desirable, `Background` must be some non-`nullptr`
    `Brush`; using `ref new SolidColorBrush(Colors::Transparent)` is good enough if
    the parent's background `Brush` is to show through.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Canvas`中，这是不可能发生的。原因是`Canvas`的默认`Background`（或者任何其他`Panel`）是`nullptr`，因此无法在其上注册事件——它们会传播到其父级。如果需要`Canvas`本身上的事件，`Background`必须是一些非`nullptr`的`Brush`；如果父级的背景`Brush`需要显示，使用`ref
    new SolidColorBrush(Colors::Transparent)`就足够了。
- en: Next, the position of the press is extracted in two steps, first using `PointerRoutedEventArgs::GetCurrentPointer()`
    (this is a `PointerPoint` object) and second, with the `PointerPoint::Position`
    property (of type `Windows::Foundation::Point`). Then the point is adjusted to
    become the offset of the pressing point to the top-left corner position of the
    element, this helps in making the later movement accurate.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过两个步骤提取按压的位置，首先使用`PointerRoutedEventArgs::GetCurrentPointer()`（这是一个`PointerPoint`对象），然后使用`PointerPoint::Position`属性（类型为`Windows::Foundation::Point`）。然后调整该点，使其成为按压点到元素左上角位置的偏移量，这有助于使后续移动准确。
- en: Capturing the pointer (`UIElement::CapturePointer`) ensures the `Canvas` continues
    to receive pointer-related events no matter where the pointer is. Setting `PointerRoutedEventArgs::Handled`
    to `true` prevents further bubbling (as there's no need here), and a flag indicating
    movement should occur from now on, until the pointer released is set (another
    private member variable).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获指针（`UIElement::CapturePointer`）确保`Canvas`继续接收指针相关事件，无论指针在何处。将`PointerRoutedEventArgs::Handled`设置为`true`可以防止进一步的冒泡（因为这里没有必要），并且设置一个标志，指示从现在开始应该发生移动，直到释放指针（另一个私有成员变量）。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pointer capturing is similar in concept to mouse capturing that exists in other
    UI technologies (Win32/MFC/WPF/Silverlight).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 指针捕获与其他UI技术（Win32/MFC/WPF/Silverlight）中存在的鼠标捕获概念类似。
- en: 'When the pointer moves, the element in question needs to move as well, as long
    as the pointer has not yet been released:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针移动时，相关元素也需要移动，只要指针尚未释放：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main idea here is moving the element by setting the attached `Canvas` properties
    `Canvas.Left` and `Canvas.Top` (using the static `Canvas::SetLeft` and `Canvas::SetTop`
    methods).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要思想是通过设置附加的“Canvas”属性“Canvas.Left”和“Canvas.Top”（使用静态的“Canvas::SetLeft”和“Canvas::SetTop”方法）来移动元素。
- en: 'When the pointer is finally released, we just need to do some cleaning up:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针最终释放时，我们只需要进行一些清理工作：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete code is in a project called `CanvasDemo` , part of the downloadable
    code for this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在一个名为“CanvasDemo”的项目中，是本章可下载代码的一部分。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pointer-related methods may seem more complex than needed, but they're not.
    Since touch input is (more often than not) multi-touch, what happens if two fingers
    press on two different elements at the same time, trying to move them? Multiple
    `PointerPressed` events may trigger, and there should be a way to distinguish
    one finger from another. The previous code is implemented while assuming only
    one finger is used at a time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 指针相关的方法可能看起来比需要的更复杂，但实际上并非如此。由于触摸输入通常是多点触控，如果两根手指同时按在两个不同的元素上并尝试移动它们会发生什么？可能会触发多个“PointerPressed”事件，因此需要一种方法来区分一个手指和另一个手指。先前的代码是在假设一次只使用一个手指的情况下实现的。
- en: Adding children to a panel dynamically
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态向面板添加子元素
- en: 'The `Panel::Children` property can be manipulated programmatically (for any
    `Panel` type). For example, using a `Canvas` as a drawing surface, we can use
    the previous pointer events to add `Line` elements that connect to each other
    to create a drawing. When the pointer is moving (after being pressed), `Line`
    objects may be added with code like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “Panel::Children”属性可以通过编程方式进行操作（适用于任何“Panel”类型）。例如，使用“Canvas”作为绘图表面，我们可以使用先前的指针事件来添加连接到彼此的“Line”元素以创建绘图。当指针移动（在按下后），可以使用以下代码添加“Line”对象：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A `Line` object is constructed, its properties set as appropriate, and finally
    it's added to the `Children` collection of the `Canvas`. Without this last step,
    the `Line` object is not attached to anything and simply dies out when its reference
    goes out of scope. `_paintBrush` is a `Brush` field maintained by the hosting
    page (not shown).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构造了一个“Line”对象，设置了适当的属性，最后将其添加到“Canvas”的“Children”集合中。如果没有这最后一步，那么“Line”对象将不会附加到任何东西上，并且当其引用超出范围时，它将被销毁。`_paintBrush`是由托管页面维护的`Brush`字段（未显示）。
- en: 'The complete source is in a project called `SimpleDraw`, part of the downloadable
    code for this chapter. Here''s a sample drawing done with this application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码在一个名为“SimpleDraw”的项目中，是本章可下载代码的一部分。以下是使用此应用程序完成的示例绘图：
- en: '![Adding children to a panel dynamically](img/5022_04_05.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![动态向面板添加子元素](img/5022_04_05.jpg)'
- en: VariableSizedWrapGrid
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VariableSizedWrapGrid
- en: '`StackPanel`, `Grid`, and `Canvas` are fairly straightforward; they are not
    much different from their counterparts in WPF or Silverlight. WinRT has some more
    interesting panels, starting with `VariableSizedWrapGrid`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: “StackPanel”、“Grid”和“Canvas”都非常直观；它们与WPF或Silverlight中的对应物几乎没有什么不同。WinRT有一些更有趣的面板，从“VariableSizedWrapGrid”开始。
- en: As its name suggests, it's essentially a grid, where items are arranged in rows
    or columns (depending on the `Orientation` property). When space runs out, or
    if the number of items in a row/column reaches the limit set by the `MaximumRowsOrColumns`
    property, the layout continues on the next row/column.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它本质上是一个网格，其中的项目按行或列排列（取决于“Orientation”属性）。当空间不足时，或者如果一行/列中的项目数量达到了“MaximumRowsOrColumns”属性设置的限制，布局将继续到下一行/列。
- en: 'A final twist with `VariableSizedWrapGrid` is that it is available with two
    attached properties, `RowSpan` and `ColumnSpan`, that can change the size of an
    item to take up more than one cell. Here''s an example `VariableSizedWrapGrid`
    with a bunch of `Rectangle` elements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个关于“VariableSizedWrapGrid”的技巧是，它有两个附加属性，“RowSpan”和“ColumnSpan”，可以改变一个项目的大小，使其占据多个单元格。以下是一个带有一堆“Rectangle”元素的“VariableSizedWrapGrid”示例：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the result:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![VariableSizedWrapGrid](img/5022_04_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![VariableSizedWrapGrid](img/5022_04_06.jpg)'
- en: Panel virtualization
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面板虚拟化
- en: All the previously discussed panels create their child elements as soon as they
    are added. For most scenarios, this is acceptable. However, if the item count
    is very high (hundreds or more), the panel's performance may degrade, as many
    elements need to be created and managed, taking up memory and wasting CPU cycles
    upon creation, or when layout changes occur. A virtualizing panel does not create
    all the elements up front for items it holds; instead, it only creates actual
    elements that are currently visible. If the user scrolls to see more data, elements
    are created as needed. Elements that scroll out of view may be destroyed. This
    scheme conserves memory and CPU time (at creation time).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前讨论的面板在添加时都会创建它们的子元素。对于大多数情况，这是可以接受的。但是，如果项目数量非常多（数百个或更多），面板的性能可能会下降，因为需要创建和管理许多元素，占用内存并在创建时浪费CPU周期，或在布局更改时发生。虚拟化面板不会一次性创建它所持有的项目的所有元素；相反，它只会创建当前可见的实际元素。如果用户滚动以查看更多数据，则会根据需要创建元素。滚出视图的元素可能会被销毁。这种方案节省了内存和CPU时间（在创建时）。
- en: The `VirtualizingPanel` class is an abstract base class for all virtualization
    panel implementations in WinRT. A further refinement of `VirtualizingPanel` is
    `OrientedVirtualizingPanel`, indicating a panel with an inherent orientation.
    WinRT provides the three virtualizing panels, as we'll see in a moment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualizingPanel`类是WinRT中所有虚拟化面板实现的抽象基类。`VirtualizingPanel`的进一步细化是`OrientedVirtualizingPanel`，表示具有固有方向的面板。WinRT提供了三种虚拟化面板，我们将在稍后看到。'
- en: All virtualizing panels have one more interesting trait, they can only be used
    to customize the panel used for controls based on `ItemsControl` (typically with
    data binding); they cannot be used as normal panels are used—by placing items
    inside them (in XAML or programmatically). Full discussion of `ItemsControl` and
    its derivatives is reserved for a later part of this chapter; for now we'll take
    a quick look at the way the existing virtualizing panels work; we'll see examples
    of usage later, when `ItemsControl` is discussed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有虚拟化面板都有一个更有趣的特点，它们只能用于自定义基于`ItemsControl`（通常使用数据绑定）的控件面板；它们不能像正常面板一样使用——在其中放置项目（在XAML或以编程方式）。`ItemsControl`及其派生类的完整讨论将在本章的后面部分进行；现在我们将快速查看现有虚拟化面板的工作方式；当讨论`ItemsControl`时，我们将在稍后看到使用示例。
- en: Virtualizing panels
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟化面板
- en: The easiest virtualizing panel to understand is `VirtualizingStackPanel` . It
    acts just like a regular `StackPanel`, but it virtualizes elements that are currently
    not visible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解的虚拟化面板是`VirtualizingStackPanel`。它的行为就像常规的`StackPanel`，但它会虚拟化当前不可见的元素。
- en: '`WrapGrid` is similar to `VariableSizedWrapGrid` , but without the "variable"
    part (it has no attached properties that can change an individual element''s size).
    It''s used in a `GridView` as the default panel (`GridView` is one of the many
    types derived from `ItemsControl`). It can be customized with properties such
    as `Orientation`, `ItemHeight`, `ItemWidth`, and `MaximumRowsOrColumns`, which
    are mostly self-explanatory.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`WrapGrid`类似于`VariableSizedWrapGrid`，但没有“可变”部分（它没有可以更改单个元素大小的附加属性）。它在`GridView`中用作默认面板（`GridView`是从`ItemsControl`派生的许多类型之一）。它可以通过属性进行自定义，例如`Orientation`，`ItemHeight`，`ItemWidth`和`MaximumRowsOrColumns`，这些属性大多是不言自明的。'
- en: '`CarouselControl` is similar to `VirtualizingStackPanel`, with the added capability
    to roll over to the first item when the last one is reached. It''s used as the
    default panel for a `ComboBox` and, in fact, cannot be used by other control,
    making it pretty useless generally.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarouselControl`类似于`VirtualizingStackPanel`，还具有在达到最后一个项目时滚动到第一个项目的功能。它被用作`ComboBox`的默认面板，并且实际上不能被其他控件使用，因此通常没有什么用处。'
- en: Working with elements and controls
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与元素和控件一起工作
- en: The difference between "elements" and "controls" is not that important in practice,
    but it is useful to understand the distinction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: “元素”和“控件”之间的区别在实践中并不那么重要，但了解这种区别是有用的。
- en: '**Elements** derive from `FrameworkElement` (directly or indirectly), but not
    from `Control`. They have some look and provide some functionality that is customizable
    mostly by changing properties. For example, `Ellipse` is an element. There''s
    no way to change the fundamental appearance of an `Ellipse` (and it would be illogical
    to be able to turn an `Ellipse` into, for example, a rectangle). It can still
    be customized in some ways using properties such as `Stroke`, `StrokeThickness`,
    `Fill`, and `Stretch`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素**从`FrameworkElement`（直接或间接）派生，但不是从`Control`派生。它们具有一些外观并提供一些可通过更改属性进行自定义的功能。例如，`Ellipse`是一个元素。没有办法改变`Ellipse`的基本外观（并且能够将`Ellipse`变成矩形是不合逻辑的）。但是可以使用诸如`Stroke`，`StrokeThickness`，`Fill`和`Stretch`等属性以某种方式进行自定义。'
- en: '**Controls**, on the other hand, derive (directly or indirectly) from the `Control`
    class. `Control` adds a bunch of properties, of which the most significant is
    the `Template` property. This allows for completely changing the control''s appearance
    without affecting its behavior. Furthermore, all that can be achieved with XAML
    alone, without code or any class derivation. We''ll discuss control templates
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**控件**从`Control`类（直接或间接）派生。`Control`添加了一堆属性，其中最重要的是`Template`属性。这允许完全更改控件的外观而不影响其行为。此外，所有这些都可以仅使用XAML实现，无需代码或任何类派生。我们将在[第6章](ch06.html
    "第6章。组件，模板和自定义元素")中讨论控件模板，*组件，模板和自定义元素*。
- en: 'The following class diagram shows some of the fundamental element-related classes
    in WinRT:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了WinRT中一些基本的与元素相关的类：
- en: '![Working with elements and controls](img/5022_04_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![与元素和控件一起工作](img/5022_04_07.jpg)'
- en: In the following sections, we'll go over the various groups of elements and
    controls (based on derivation and usage categories), studying their main features
    and usage. In each group, we'll look at some of the more useful or unique controls.
    These sections are by no means complete (and are not intended as such); further
    information can be found in the official MSDN documentation and samples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论各种元素和控件的组（基于派生和使用类别），研究它们的主要特点和用法。在每个组中，我们将查看一些更有用或独特的控件。这些部分并不完整（也不打算如此）；更多信息可以在官方MSDN文档和示例中找到。
- en: Content controls
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容控件
- en: 'Content controls derive from the `ContentControl` class (itself deriving from
    `Control`). `ContentControl` adds two important properties: `Content` (also its
    `ContentProperty` attribute, making it easy to set in XAML) and `ContentTemplate`.
    A simple example of a `ContentControl` is `Button`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 内容控件派生自`ContentControl`类（它本身派生自`Control`）。`ContentControl`添加了两个重要属性：`Content`（也是其`ContentProperty`属性，使其在XAML中易于设置）和`ContentTemplate`。`ContentControl`的一个简单示例是`Button`：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `Content` property may seem like a string, but in fact it's typed as `Platform::Object^`,
    meaning it can be anything at all.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“Content”属性可能看起来像一个字符串，但实际上它的类型是`Platform::Object^`，意味着它可以是任何东西。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may seem odd that "anything" is specified using `Platform::Object`; after
    all, WinRT is based on COM, so there must be an interface behind this. And there
    is, `Platform::Object` is, in fact, a projected replacement for the `IInspectable`
    interface pointer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “Platform::Object”指定“任何内容”似乎有些奇怪；毕竟，WinRT是基于COM的，所以肯定有一个接口在后面。实际上，`Platform::Object`就是`IInspectable`接口指针的投影替代品。
- en: 'A type derived from `ContentControl` renders its `Content` using the following
    rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ContentControl`派生的类型使用以下规则呈现其“Content”：
- en: If it's a string, `TextBlock` is rendered with its `Text` set to the string
    value.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个字符串，将呈现`TextBlock`，其“Text”设置为字符串值。
- en: If it derives from `UIElement`, it's rendered as is.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是从`UIElement`派生的，它将按原样呈现。
- en: Otherwise (`Content` does not derive from `UIElement` and is not a string),
    if `ContentTemplate` is `nullptr`, then the content is rendered as a `TextBlock`
    with its `Text` set to a string representation of the `Content`. Otherwise, the
    supplied `DataTemplate` is used for rendering.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则（“Content”不是从“UIElement”派生的，也不是字符串），如果“ContentTemplate”是“nullptr”，那么内容将呈现为一个`TextBlock`，其“Text”设置为“Content”的字符串表示。否则，提供的`DataTemplate`用于呈现。
- en: 'The preceding rules are used for any type derived from `ContentControl`. In
    the case of the previous button, the first rule is used, as the `Content` of the
    `Button` is the string **Login**. Here''s an example that uses the second rule:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 前述规则适用于任何从`ContentControl`派生的类型。在前面的按钮的情况下，使用第一条规则，因为`Button`的“Content”是字符串**Login**。以下是使用第二条规则的示例：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The resulting button is shown as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的按钮如下所示：
- en: '![Content controls](img/5022_04_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_08.jpg)'
- en: The resulting control is still a button, but its `Content` is set to a type
    derived from `UIElement` (in this case a `StackPanel`).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的控件仍然是一个按钮，但其“Content”设置为从`UIElement`派生的类型（在本例中是`StackPanel`）。
- en: 'The third rule is the most interesting. Suppose we have a simple data object
    implemented like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条规则是最有趣的。假设我们有一个简单的数据对象实现如下：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Given this implementation, let''s create a `Book` instance in XAML as a resource:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个实现，让我们在XAML中创建一个“Book”实例作为资源：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To make this compile without errors, `#include "book.h"` must be added to `MainPage.xaml.h`.
    The reason for that will become clear in the next chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其编译不出错，必须在`MainPage.xaml.h`中添加`#include "book.h"`。这样做的原因将在下一章中变得清晰。
- en: 'Now, we can set the `Content` of a type derived from the `ContentControl` (such
    as `Button`) to that `Book` object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将从`ContentControl`（如`Button`）派生的类型的“Content”设置为该“Book”对象：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the application shows the following result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序显示以下结果：
- en: '![Content controls](img/5022_04_09.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_09.jpg)'
- en: The result is simply the fully qualified type name of the class (including namespace);
    this is not always the case, it depends on the default control template of the
    control in question. In any case, it's obvious it's not usually what we want.
    To get custom rendering for the object, a `DataTemplate` is needed, plugged into
    the `ContentTemplate` property.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果只是类的完全限定类型名称（包括命名空间）；这并不总是这样，这取决于所讨论的控件的默认控件模板。无论如何，显然这通常不是我们想要的。要为对象获取自定义呈现，需要一个`DataTemplate`，并将其插入到`ContentTemplate`属性中。
- en: 'Here''s an example that creates a `DataTemplate` for use within the `Button`
    in question:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个为在问题中的`Button`中使用的`DataTemplate`的示例：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few things to note here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点需要注意：
- en: A `DataTemplate` can contain a single element (typically a `Panel`—`Grid` in
    this example), and can build any required UI.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataTemplate`可以包含一个单一元素（通常是一个`Panel`—在本例中是`Grid`），并且可以构建任何所需的UI。'
- en: Using the properties of the actual content is done via data binding expressions,
    expressed with the `{Binding}` markup extension, with the property name. A complete
    treatment of data binding is found in the next chapter.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实际内容的属性是通过数据绑定表达式完成的，使用`{Binding}`标记扩展和属性名称。有关数据绑定的完整处理在下一章中找到。
- en: 'To make the properties work with a data object (a `Book` in this case), the
    class (`Book`) must be decorated with the `Bindable` attribute like so:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使属性与数据对象（在本例中是`Book`）一起工作，必须像这样用`Bindable`属性装饰类（`Book`）：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result looks like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Content controls](img/5022_04_10.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![内容控件](img/5022_04_10.jpg)'
- en: Data templates are powerful tools for visualizing data objects; we'll encounter
    more of those later. For now, it's important to realize that every type deriving
    from `ContentControl` has that customization ability.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模板是可视化数据对象的强大工具；我们以后会遇到更多。现在，重要的是要意识到每个从`ContentControl`派生的类型都具有这种自定义能力。
- en: In the following sections, we'll discuss some of the common `ContentControl`-derived
    types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论一些常见的`ContentControl`派生类型。
- en: Buttons
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮
- en: 'As we''ve already seen, the classic `Button` control is a `ContentControl`,
    meaning it can have any content, but still act like a button. Most of the functionality
    of the `Button` is derived from its abstract base class, `ButtonBase`. `ButtonBase`
    declares the ubiquitous `Click` event, along with some other useful properties:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，经典的`Button`控件是一个`ContentControl`，这意味着它可以拥有任何内容，但仍然像一个按钮一样工作。`Button`的大部分功能都是从它的抽象基类`ButtonBase`派生出来的。`ButtonBase`声明了无处不在的`Click`事件，以及一些其他有用的属性：
- en: '`ClickMode` – indicates what constitutes a "click": `Release`, `Press`, or
    `Hover`. Naturally, this is mostly applicable to a mouse.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClickMode` - 指示什么构成“点击”：`Release`，`Press`或`Hover`。自然地，这主要适用于鼠标。'
- en: '`Command` – indicates which command (if any) to invoke when the button is clicked
    (commands will be discussed in the next chapter).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command` - 指示在按钮被点击时要调用哪个命令（如果有的话）（命令将在下一章中讨论）。'
- en: '`CommandParameter` – an optional parameter that is sent with the invoked command.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandParameter` - 与调用的命令一起发送的可选参数。'
- en: Button derives from `ButtonBase` and adds nothing in terms of members, except
    being concrete, rather than abstract.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Button派生自`ButtonBase`，在成员方面没有任何添加，除了具体化，而不是抽象化。
- en: Another `ButtonBase` derivative is `HyperlinkButton`. It renders as a web hyperlink
    by default, and adds a `NavigationUri` property that causes automatic navigation
    to the specified URI; the `Click` event is typically not handled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`ButtonBase`的派生类是`HyperlinkButton`。它默认呈现为一个网页超链接，并添加了一个`NavigationUri`属性，导致自动导航到指定的URI；`Click`事件通常不会被处理。
- en: '`RepeatButton` (in the `Windows::UI::Xaml::Controls::Primitives` namespace)
    is another `ButtonBase` derivative. It raises the `Click` event, as long as the
    button is pressed; the rate of `Click` events can be specified using the `Delay`
    (first `Click` event) and `Interval` (period of `Click` event raises) properties.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatButton`（在`Windows::UI::Xaml::Controls::Primitives`命名空间中）是另一个`ButtonBase`的派生类。只要按钮被按下，它就会引发`Click`事件；可以使用`Delay`（第一个`Click`事件）和`Interval`（`Click`事件引发的时间间隔）属性来指定`Click`事件的速率。'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`RepeatButton` is less useful by itself; it''s mostly useful as a building
    block of other, more complex, controls. This is hinted by placing the control
    in the `Primitives` subnamespace. As an example, `RepeatButton` composes several
    parts of a `ScrollBar` (in itself in the `Primitives` namespace).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatButton`本身不太有用；它主要作为其他更复杂的控件的构建块。这可以通过将控件放置在`Primitives`子命名空间中来暗示。例如，`RepeatButton`组成了`ScrollBar`的几个部分（它本身在`Primitives`命名空间中）。'
- en: Two other useful button controls are `CheckBox` and `RadioButton` . Both derive
    from a common base, `ToggleButton` . `ToggleButton` defines the `IsChecked` property,
    which can have three values (`true`, `false`, or `nullptr`). The later indicates
    an indeterminate state, supported by `CheckBox` (but not by `RadioButton`). `ToggleButton`
    also declares the `IsThreeState` property, to indicate whether the third state
    should be allowed. Finally, it defines three events, `Checked`, `Unchecked`, and
    `Indeterminate`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的按钮控件是`CheckBox`和`RadioButton`。两者都派生自一个共同的基类`ToggleButton`。`ToggleButton`定义了`IsChecked`属性，它可以有三个值（`true`，`false`或`nullptr`）。后者表示一个不确定的状态，由`CheckBox`支持（但不由`RadioButton`支持）。`ToggleButton`还声明了`IsThreeState`属性，以指示是否应允许第三种状态。最后，它定义了三个事件，`Checked`，`Unchecked`和`Indeterminate`。
- en: '`CheckBox` adds nothing to `ToggleButton` except becoming concrete. `RadioButton`
    adds just one property, `GroupName` (a string). This allows grouping of `RadioButton`
    controls, to be used as an exclusion group. By default, all `RadioButton` controls
    under the same immediate parent become a group (only one in that group can have
    the `IsChecked` property set to `true` at a time). If `GroupName` is specified,
    all `RadioButtons` with the same `GroupName` are considered a group.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckBox`除了变得具体之外，对`ToggleButton`没有任何添加。`RadioButton`只添加了一个属性`GroupName`（一个字符串）。这允许对`RadioButton`控件进行分组，以用作排他性组。默认情况下，同一直接父级下的所有`RadioButton`控件都成为一组（该组中只能有一个`IsChecked`属性设置为`true`）。如果指定了`GroupName`，则所有具有相同`GroupName`的`RadioButtons`被视为一组。'
- en: 'Here''s a simple example that uses `CheckBox` and `RadioButton` controls:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，使用了`CheckBox`和`RadioButton`控件：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting display, after some selections, is shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些选择后，得到的显示如下：
- en: '![Buttons](img/5022_04_11.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Buttons](img/5022_04_11.jpg)'
- en: ScrollViewer
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ScrollViewer
- en: '`ScrollViewer` is a content control that hosts a single child (its `Content`
    property, just like any other `ContentControl`) and uses a pair of `ScrollBar`
    controls to support scrolling. The most important properties are `VerticalScrollBarVisibility`
    and `HorizontalScrollBarVisibility`, which indicate the way scrolling should work
    and the way the scroll bars present themselves. There are four options (`ScrollBarVisibility`
    enumeration):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollViewer`是一个内容控件，它承载一个子元素（就像任何其他`ContentControl`的`Content`属性一样），并使用一对`ScrollBar`控件来支持滚动。最重要的属性是`VerticalScrollBarVisibility`和`HorizontalScrollBarVisibility`，它们指示滚动的方式和滚动条的呈现方式。有四个选项（`ScrollBarVisibility`枚举）：'
- en: '`Visible` – the scroll bar is always visible. If the content does not require
    scrolling, the scroll bar is disabled.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Visible` - 滚动条始终可见。如果内容不需要滚动，滚动条将被禁用。'
- en: '`Auto` – the scroll bar appears if needed and disappears if not needed.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Auto` - 如果需要，滚动条会出现，如果不需要，它会消失。'
- en: '`Hidden` – the scroll bar is not shown, but scrolling is still possible using
    the keyboard, touch, or programmatically.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hidden` - 滚动条不显示，但仍然可以使用键盘、触摸或编程方式进行滚动。'
- en: '`Disabled` – the scroll bar is hidden and no scrolling is possible. The `ScrollViewer`
    does not give more space than it has to the content (in that dimension).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disabled` - 滚动条被隐藏，无法滚动。`ScrollViewer`不会给内容提供比它在该维度上拥有的更多的空间。'
- en: The default values are `Visible` for `VerticalScrollBarVisibility` and `Disabled`
    for `HorizontalScrollBarVisibility`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`VerticalScrollBarVisibility`的默认值为`Visible`，`HorizontalScrollBarVisibility`的默认值为`Disabled`。'
- en: Another useful feature of the `ScrollViewer` is its ability to allow zooming
    in or out for the `Content` with a zoom/pinch touch gestures. This is controlled
    through the `ZoomMode` property (`Enabled` or `Disabled`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollViewer`的另一个有用功能是它能够通过缩放/捏触手势来允许`Content`进行放大或缩小。这是通过`ZoomMode`属性（`Enabled`或`Disabled`）来控制的。'
- en: 'The `HorizontalScrollBarVisibility`, `VerticalScrollBarVisibility`, and `ZoomMode`
    properties are exposed as attached properties as well, so they are relevant to
    other controls that internally use a `ScrollViewer`, such as `ListBox` or `GridView`.
    Here''s a simple example that changes the way a horizontal scroll bar is presented
    in a `ListBox`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalScrollBarVisibility`、`VerticalScrollBarVisibility`和`ZoomMode`属性也作为附加属性公开，因此它们与内部使用`ScrollViewer`的其他控件相关，例如`ListBox`或`GridView`。以下是一个简单的示例，它改变了`ListBox`中水平滚动条的呈现方式：'
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Other content controls to note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他需要注意的内容控件
- en: The following is a brief description of some of the other `ContentControl`-derived
    types in WinRT.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是WinRT中一些其他`ContentControl`派生类型的简要描述。
- en: AppBar
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AppBar
- en: '`AppBar` is a `ContentControl` that is used for the application bar, typically
    appearing at the bottom (sometimes at the top) if the user swipes from the bottom
    (or top) or right clicks the mouse. It typically hosts a horizontal `StackPanel`
    with buttons for various options. Here''s an example from the Weather app that
    is available with any Windows 8 installation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppBar`是一个用于应用栏的`ContentControl`，通常出现在底部（有时在顶部），如果用户从底部（或顶部）滑动或右键单击鼠标。它通常托管一个水平的`StackPanel`，其中包含各种选项的按钮。以下是一个来自天气应用程序的示例，该应用程序可在任何Windows
    8安装中使用：'
- en: '![AppBar](img/5022_04_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![AppBar](img/5022_04_12.jpg)'
- en: Frame
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Frame
- en: '`Frame` is a `ContentControl` that''s used for navigation among controls derived
    from `Page`. Calling the `Navigate` method with a `Page` type "navigates" to that
    page, by creating an instance and calling some virtual methods: `OnNavigatedFrom`
    on the old page (if any) and `OnNavigatedTo` on the new page. By default, the
    application wizard creates a `Frame` object in the `App::OnLaunched` method (event
    handler for the `Lanuched` event), and then quickly navigates to the `MainPage`
    with the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame`是用于在派生自`Page`的控件之间进行导航的`ContentControl`。使用`Navigate`方法与`Page`类型“导航”到该页面，通过创建一个实例并调用一些虚拟方法：在旧页面上调用`OnNavigatedFrom`（如果有的话），在新页面上调用`OnNavigatedTo`。默认情况下，应用程序向导在`App::OnLaunched`方法（`Lanuched`事件的事件处理程序）中创建一个`Frame`对象，然后快速导航到`MainPage`，代码如下：'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second parameter to `Navigate` is an optional context argument available
    in the `OnNavigatedTo` override (in `NavigationEventArgs::Parameter`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Navigate`的第二个参数是一个可选的上下文参数，在`OnNavigatedTo`重写中可用（在`NavigationEventArgs::Parameter`中）。'
- en: The `Frame` object maintains a back stack of pages which can be navigated using
    methods such as `GoBack` and `GoForward`. The `CanGoBack` and `CanGoForward` read-only
    properties can help maintain state on buttons that serve navigation purposes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame`对象维护着一个页面的后退堆栈，可以使用`GoBack`和`GoForward`等方法进行导航。`CanGoBack`和`CanGoForward`只读属性可以帮助维护用于导航目的的按钮的状态。'
- en: Navigating to previously visited pages can create new instances of those pages
    or reuse instances. The `CacheSize` property enables setting a maximum number
    of cached pages that are retained in memory during navigation. To enable any kind
    of caching for a particular `Page` instance, its `Page::NavigationCacheMode` property
    must be set to `Enabled` or `Required` (`Disabled` being the default). `Enabled`
    works with the cache, while `Required` always maintains the page state in memory
    (the `Required` setting does not count against the `Frame::CacheSize` value).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到先前访问的页面可以创建这些页面的新实例或重用实例。`CacheSize`属性可以设置在导航期间在内存中保留的最大缓存页面数。要为特定的`Page`实例启用任何类型的缓存，必须将其`Page::NavigationCacheMode`属性设置为`Enabled`或`Required`（`Disabled`是默认值）。`Enabled`与缓存一起工作，而`Required`始终在内存中保持页面状态（`Required`设置不计入`Frame::CacheSize`值）。
- en: SelectorItem
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SelectorItem
- en: '`SelectorItem` is an abstract base class for items that may be selectable in
    `ItemsControl` controls (see the next section for a description of `ItemsControl`).
    It adds just one property: `IsSelected`. Derived types are containers for items
    in their respective collection-based control: `ListBoxItem` (in a `ListBox`),
    `GridViewItem` (in a `GridView`), `ListViewItem` (in a `ListView`), and so on.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectorItem`是可在`ItemsControl`控件中选择的项目的抽象基类（有关`ItemsControl`的描述，请参见下一节）。它只添加了一个属性：`IsSelected`。派生类型是其各自基于集合的控件中项目的容器：`ListBoxItem`（在`ListBox`中）、`GridViewItem`（在`GridView`中）、`ListViewItem`（在`ListView`中）等。'
- en: Collection-based controls
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于集合的控件
- en: The following sections discuss controls that hold more than one data item. These
    all derive from the `ItemsControl` class that provides the basic structure of
    all derived types.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节讨论了持有多个数据项的控件。这些都派生自提供所有派生类型的基本结构的`ItemsControl`类。
- en: The `Items` read-only property is the collection of objects hosted in this `ItemsControl`
    (of type `ItemCollection`, also its `ContentProperty`). Objects can be added with
    the `Append` and `Insert` methods, and removed with the `Remove` and `RemoveAt`
    methods (any kind of object can be part of the `ItemsControl`). Although this
    may sound appealing, this is not the typical way of working with an `ItemsControl`
    or its derived types; usually a collection of objects is set to the `ItemsSource`
    property (typically with a data binding expression) and that automatically uses
    the `Items` property behind the scenes to populate the control. We'll see this
    in action in [Chapter 5](ch05.html "Chapter 5. Data Binding"), *Data Binding*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items`只读属性是托管在此`ItemsControl`中的对象的集合（类型为`ItemCollection`，也是其`ContentProperty`）。对象可以使用`Append`和`Insert`方法添加，使用`Remove`和`RemoveAt`方法移除（任何类型的对象都可以成为`ItemsControl`的一部分）。尽管这听起来很吸引人，但这不是与`ItemsControl`或其派生类型一起工作的典型方式；通常会将对象集合设置为`ItemsSource`属性（通常使用数据绑定表达式），并且自动使用`Items`属性在幕后填充控件。我们将在[第5章](ch05.html
    "第5章。数据绑定")*数据绑定*中看到这一点。'
- en: 'The `ItemsPanel` property allows changing the default `Panel` hosting the items
    in the particular `ItemsControl`. For example, a `ListView` uses a vertical `VirtualizingStackPanel`
    as its default `Panel`. This can be changed to `WrapGrid` with the following XAML
    snippet inside the `ListView` element:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsPanel`属性允许更改特定`ItemsControl`中托管项目的默认`Panel`。例如，`ListView`使用垂直`VirtualizingStackPanel`作为其默认`Panel`。这可以通过`ListView`元素内的以下XAML片段更改为`WrapGrid`：'
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ItemTemplate` property may be set to a `DataTemplate` , as a way to show
    an object that is part of the collection. `ItemTemplate` has the same purpose
    and rules as `ContentControl::ContentTemplate`, but is applicable to each and
    every object in the `ItemsControl`. We'll see examples of `ItemTemplate` usage
    in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemTemplate`属性可以设置为`DataTemplate`，以显示集合中的对象。`ItemTemplate`具有与`ContentControl::ContentTemplate`相同的目的和规则，但适用于`ItemsControl`中的每个对象。我们将在下一章中看到`ItemTemplate`的用法示例。'
- en: '`DisplayMemberPath` is a `String` property that may be used if `ItemTemplate`
    is `nullptr` to show some property (or subproperty) of objects in this `ItemsControl`.
    As an example, suppose we use the following `Book` class (defined earlier):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayMemberPath`是一个`String`属性，如果`ItemTemplate`为`nullptr`，则可以用来显示此`ItemsControl`中对象的某个属性（或子属性）。例如，假设我们使用以下`Book`类（之前定义）：'
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating an array of such `Book` objects and placing it in the `ItemsControl::ItemsSource`
    property (or adding them manually through `Items->Append` method calls), would
    show, by default, the `Book` type name (assuming no `ItemTemplate` has been set).
    Setting `DisplayMemberPath` to `"BookName"` would show every object's `BookName`
    within the `ItemsControl`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的`Book`对象数组，并将其放置在`ItemsControl::ItemsSource`属性中（或通过`Items->Append`方法手动添加它们），默认情况下会显示`Book`类型名称（假设没有设置`ItemTemplate`）。将`DisplayMemberPath`设置为`"BookName"`将在`ItemsControl`中显示每个对象的`BookName`。
- en: The `ItemContainerStyle` property may be used to place a `Style` on the particular
    container item for this `ItemsControl`. For example, a `ListView` setting its
    `ItemContainerStyle` property affects the `ListViewItem` controls, each holding
    the data object in question (based on the usual rules for content).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemContainerStyle`属性可用于在此`ItemsControl`的特定容器项上放置`Style`。例如，设置`ItemContainerStyle`属性的`ListView`会影响`ListViewItem`控件，每个控件都包含所讨论的数据对象（根据内容的通常规则）。'
- en: 'We''ll see some more properties of `ItemsControl` in the next chapter. The
    following sections discuss briefly some of the common types derived from `ItemsControl`.
    Technically, there''s just one such class: `Selector`, adding the notion of selection
    with the `SelectedItem` (the actual data object) and `SelectedIndex` (an integer
    index) properties. The `SelectedValue` property indicates the "value" of the selected
    item, based on the `SelectedValuePath` property. For example, if the control holds
    `Book` objects, as shown previously, and `SelectedValuePath` is `"BookName"`,
    then `SelectedValue` will hold the actual book name for the `SelectedItem` (which
    holds the entire `Book` object).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到`ItemsControl`的更多属性。以下部分简要讨论了一些从`ItemsControl`派生的常见类型。从技术上讲，只有一个这样的类：`Selector`，添加了`SelectedItem`（实际数据对象）和`SelectedIndex`（整数索引）属性的选择概念。`SelectedValue`属性根据`SelectedValuePath`属性指示所选项目的“值”。例如，如果控件保存`Book`对象，如前所示，并且`SelectedValuePath`为`"BookName"`，那么`SelectedValue`将保存`SelectedItem`的实际书名（`SelectedItem`保存整个`Book`对象）。
- en: '`Selector` also defines a single event, `SelectionChanged`, fired when the
    selected item changes.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Selector`还定义了一个事件`SelectionChanged`，当选定的项目发生变化时触发。'
- en: ListBox and ComboBox
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ListBox和ComboBox
- en: '`ListBox` and `ComboBox` are the WinRT versions of the classic Windows controls.
    `ListBox` shows a collection of objects (vertically, by default), with scroll
    bars if necessary. `ListBox` also adds the notion of multiple selected items with
    the `SelectedItems` property and a `SelectionMode` property (`Single`, `Multiple`—each
    click/touch selects/deselects items, and `Extended`—pressing *Shift* selects multiple
    consecutive objects and *Ctrl* for nonadjacent group selection).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListBox`和`ComboBox`是经典Windows控件的WinRT版本。`ListBox`显示对象的集合（默认情况下是垂直的），如果需要，会有滚动条。`ListBox`还添加了多个选定项目的概念，具有`SelectedItems`属性和`SelectionMode`属性（`Single`，`Multiple`——每次单击/触摸都会选择/取消选择项目，以及`Extended`——按下*Shift*会选择多个连续对象，按下*Ctrl*会选择非相邻的组）。'
- en: '`ComboBox` shows just one item, selected from a drop-down list. Usage of both
    these controls is discouraged in Store apps, because their touch behavior is not
    as good as it should be, and they have no interesting visual transitions, making
    them a bit dull; that said, they still may be useful at times, particularly the
    `ComboBox`, which has no similar alternative.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComboBox`只显示一个从下拉列表中选择的项目。在商店应用中不鼓励使用这两个控件，因为它们的触摸行为不如应该的好，而且它们没有有趣的视觉过渡，使它们有点乏味；尽管如此，它们有时仍然可能有用，特别是`ComboBox`，它没有类似的替代品。'
- en: ListView and GridView
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ListView和GridView
- en: '`ListView` and `GridView` both derive from `ListViewBase` (that derives from
    `Selector`), and they''re the preferred controls for hosting multiple items. `ListView`
    and `GridView` add nothing to `ListViewBase` – they just have different defaults
    for their `ItemsPanel` property and some other tweaks.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`和`GridView`都派生自`ListViewBase`（派生自`Selector`），它们是托管多个项目的首选控件。`ListView`和`GridView`对`ListViewBase`没有任何添加——它们只是具有不同的`ItemsPanel`属性默认值和一些其他调整。'
- en: 'Both have been designed with a lot of thought for touch input, transition animations
    and the like; these are the workhorses for showing collections of objects. In
    fact, Visual Studio has some project templates that build sample `ListView` and
    `GridView` controls to help developers get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都经过深思熟虑地设计，以适应触摸输入、过渡动画等；它们是显示对象集合的工作马。事实上，Visual Studio有一些项目模板，用于构建示例`ListView`和`GridView`控件，以帮助开发人员入门：
- en: '![ListView and GridView](img/5022_04_13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![ListView和GridView](img/5022_04_13.jpg)'
- en: FlipView
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FlipView
- en: 'The `FlipView` control adds nothing to `Selector`, but has a somewhat unique
    appearance, showing just one (selected) item at a time (similar to a `ComboBox`),
    but allows "flipping" through the items by swiping left or right, or by clicking
    two arrows on its sides. The classic example being flipping through image objects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlipView`控件对`Selector`没有任何添加，但具有一种独特的外观，一次只显示一个（选定的）项目（类似于`ComboBox`），但允许通过向左或向右滑动或单击两侧的箭头来“翻转”项目。经典示例是翻转图像对象：'
- en: '![FlipView](img/5022_04_14.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![FlipView](img/5022_04_14.jpg)'
- en: Text-based elements
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于文本的元素
- en: 'Text is an all important part of any user interface. Naturally, WinRT provides
    several elements and controls that have text as their main visual appearance.
    With text, font-related properties are typically involved. These include:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是任何用户界面的重要部分。自然地，WinRT提供了几个具有文本作为其主要视觉外观的元素和控件。通常涉及与字体相关的属性。这些包括：
- en: '`FontSize` – the size of the text (a `double` value).'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontSize` - 文本的大小（`double`值）。'
- en: '`FontFamily` – the font family name (such as "Arial" or "Verdana"). This can
    include fallback font families (separated by commas) in case that particular font
    is unavailable.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontFamily` - 字体系列名称（如"Arial"或"Verdana"）。这可以包括备用字体系列（用逗号分隔），以防该特定字体不可用。'
- en: '`FontStretch` – indicates stretch characteristics for the font, such as `Condensed`,
    `Normal` (the default), `ExtraCondensed`, `Expanded`, and so on.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontStretch` - 指示字体的拉伸特性，如`Condensed`，`Normal`（默认值），`ExtraCondensed`，`Expanded`等。'
- en: '`FontWeight` – indicates the font weight, such as `Bold`, `ExtraBold`, `Medium`,
    `Thin`, and so on (all taken from the static properties of the `FontWeights` class).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontWeight` - 指示字体重量，如`Bold`，`ExtraBold`，`Medium`，`Thin`等（都取自`FontWeights`类的静态属性）。'
- en: '`FontStyle` – one of `Normal`, `Oblique` or `Italic`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontStyle` - `Normal`，`Oblique`或`Italic`之一。'
- en: 'All font-related properties have one notable attribute, they set a "default"
    font for all elements that exist as children of the element in question (direct
    or indirect). This means that setting a font-related property on the `Page` object
    effectively sets the default font for all elements in the page (barring two exceptions:
    font properties set by a control template explicitly and a local font property
    set by a particular element; both override the default font settings).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与字体相关的属性都有一个显着的属性，它们为存在为元素的子元素（直接或间接）设置了一个“默认”字体。这意味着在`Page`对象上设置与字体相关的属性实际上为页面中的所有元素设置了默认字体（除了两个例外：由控件模板显式设置的字体属性和特定元素设置的本地字体属性；两者都会覆盖默认字体设置）。
- en: Another property that is common to most text elements is `Foreground`. This
    sets the `Brush` that draws the actual text. There are several `Brush` types,
    `SolidColorBrush` is the simplest, but there are others, such as `LinearGradientBrush`
    and `TileBrush`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文本元素共有的另一个属性是`Foreground`。这设置绘制实际文本的`Brush`。有几种`Brush`类型，`SolidColorBrush`是最简单的，但还有其他类型，如`LinearGradientBrush`和`TileBrush`。
- en: Other text-related properties common to most text-related elements include `TextAlignment`
    (`Left`, `Right`, `Center`, `Justify`), `TextTrimming` (`None` and `WordEllipsis`),
    and `TextWrapping` (`NoWrap` and `Wrap`), all pretty self-explanatory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与文本相关的元素共有的其他文本相关属性包括`TextAlignment`（`Left`，`Right`，`Center`，`Justify`），`TextTrimming`（`None`和`WordEllipsis`），和`TextWrapping`（`NoWrap`和`Wrap`），都相当容易理解。
- en: Using custom fonts
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义字体
- en: 'Custom fonts can be used with WinRT. This involves adding a font file to the
    project (with a `.TTF` extension), and making sure its **Content** property in
    Visual Studio is set to **Yes**:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在WinRT中使用自定义字体。这涉及将字体文件添加到项目中（带有`.TTF`扩展名），并确保在Visual Studio中其**Content**属性设置为**Yes**：
- en: '![Using custom fonts](img/5022_04_16.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义字体](img/5022_04_16.jpg)'
- en: 'All that''s needed now is to use the `FontFamily` property with a special value,
    consisting of the font URI (filename and any logical folder it''s in), a hash
    (#) and the font name itself, visible when double-clicking the font file in Windows.
    Here''s an example of two lines using a standard font and a custom font:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的就是使用`FontFamily`属性和特殊值，包括字体URI（文件名和任何逻辑文件夹），一个井号（#）和字体名称本身，当在Windows中双击字体文件时可见。以下是使用标准字体和自定义字体的两行示例：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result is shown as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Using custom fonts](img/5022_04_15.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![使用自定义字体](img/5022_04_15.jpg)'
- en: The following sections discuss some of the common text-related elements and
    controls.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分讨论了一些常见的与文本相关的元素和控件。
- en: TextBlock
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextBlock
- en: '`TextBlock` is probably the most useful text-related element. It displays text
    that cannot be changed by the user interactively (only programmatic changes are
    possible). This is useful for showing static text, which should not be edited
    by the user.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBlock`可能是最有用的与文本相关的元素。它显示用户无法交互更改的文本（只能进行编程更改）。这对于显示静态文本非常有用，用户不应该编辑它。'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although text cannot be edited in a `TextBlock`, it can still be selected by
    the user (and even copied by pressing *Ctrl* + *C*) if `IsTextSelectionEnabled`
    is `true`. In case it is, other properties can be used, namely `SelectedText`,
    `SelectionStart`, and `SelectionEnd` (the later returns `TextPointer` objects).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文本无法在`TextBlock`中编辑，但用户仍然可以选择它（甚至可以通过按下*Ctrl* + *C*进行复制），如果`IsTextSelectionEnabled`为`true`。如果是这样，还可以使用其他属性，即`SelectedText`，`SelectionStart`和`SelectionEnd`（后者返回`TextPointer`对象）。
- en: The most straightforward way of working with a `TextBlock` is by setting the
    `Text` property (a `String`) and the font-related properties if needed. As an
    alternative to `Text`, `TextBlock` supports a collection of objects called inlines
    (through the `Inlines` property, which is also its `ContentProperty` for XAML
    purposes), that allow the building a more complex `TextBlock`, but still uses
    just one element (the `TextBlock`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TextBlock`最直接的方法是设置`Text`属性（一个`String`）和必要时的与字体相关的属性。作为`Text`的替代，`TextBlock`支持一组称为inlines的对象（通过`Inlines`属性，这也是它的`ContentProperty`用于XAML目的），允许构建一个更复杂的`TextBlock`，但仍然只使用一个元素（`TextBlock`）。
- en: Inlines include (all deriving from `Inline`) `Span`, `Run`, `LineBreak`, and
    `InlineUIContainer` (all in the `Windows::UI::Xaml::Documents` namespace). `Span`
    is a container for more inlines with the same properties set by `Span`. `Run`
    has a `Text` property and adds a `FlowDirection`. `LineBreak` is exactly that.
    `InlineUIContainter` can't be used in a `TextBlock`, but only in a `RichTextBlock`
    (discussed later).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 内联包括（都派生自`Inline`）`Span`，`Run`，`LineBreak`和`InlineUIContainer`（都在`Windows::UI::Xaml::Documents`命名空间中）。`Span`是具有相同属性的更多内联的容器。`Run`具有`Text`属性并添加`FlowDirection`。`LineBreak`就是那样。`InlineUIContainter`不能在`TextBlock`中使用，只能在`RichTextBlock`中使用（稍后讨论）。
- en: 'Here''s an example `TextBlock`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`TextBlock`的例子：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result is shown as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![TextBlock](img/5022_04_17.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![TextBlock](img/5022_04_17.jpg)'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the `Text` property is used along with inlines, `Text` wins and the inlines
    are not displayed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Text`属性与内联一起使用，`Text`优先，内联不会显示。
- en: TextBox
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TextBox
- en: '`TextBox` is the classic text-entering control and provides all the expected
    capabilities of such a control. Common properties include (in addition to the
    font properties and others discussed at the beginning of this section):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`是经典的文本输入控件，并提供了所有预期的控件功能。常见属性包括（除了字体属性和其他在本节开头讨论的属性）：'
- en: '`Text` – the actual text shown or edited by the user.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text` - 用户实际显示或编辑的文本。'
- en: '`MaxLength` – the maximum character length allowed for user input (this setting
    is not used when programmatically manipulating the `Text` in the `TextBox`).'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxLength` - 用户输入的最大字符长度（在通过编程方式操作`TextBox`中的`Text`时不使用此设置）。'
- en: '`SelectedText`, `SelectedLength`, `SelectionStart`, `SelectionEnd` – selection
    related properties (self-explanatory).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedText`，`SelectedLength`，`SelectionStart`，`SelectionEnd` - 选择相关的属性（不言自明）。'
- en: '`IsReadOnly` – indicates whether text can actually be edited (default is `false`).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsReadOnly` - 指示文本是否实际可编辑（默认为`false`）。'
- en: '`AcceptsReturn` – if `true`, indicates a multiple line `TextBox` (default is
    `false`).'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AcceptsReturn` - 如果为`true`，表示多行`TextBox`（默认为`false`）。'
- en: '`InputScope` – indicates what kind of virtual keyboard should pop up on a touch-based
    device that is not using a physical keyboard. This can help with text entering.
    Values (from the `InputScopeNameValue` enumeration) include: `Url`, `Number`,
    `EmailSmtpAddress` (e-mail address), and others. Here is a keyboard screenshot
    for `InputScope` of `Number`:![TextBox](img/5022_04_22.jpg)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InputScope` - 指示在不使用物理键盘的触摸设备上应该弹出什么样的虚拟键盘。这可以帮助输入文本。值（来自`InputScopeNameValue`枚举）包括：`Url`，`Number`，`EmailSmtpAddress`（电子邮件地址）等。这是`Number`的`InputScope`的键盘截图：![TextBox](img/5022_04_22.jpg)'
- en: 'This is the keyboard for `InputScope` of `Url`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`InputScope`为`Url`的键盘的例子：
- en: '![TextBox](img/5022_04_23.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![TextBox](img/5022_04_23.jpg)'
- en: 'This one is for `InputScope` of `EmailSmtpAddress`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`EmailSmtpAddress`的`InputScope`的一个例子：
- en: '![TextBox](img/5022_04_24.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![TextBox](img/5022_04_24.jpg)'
- en: '`TextBox` defines several events, `TextChanged` being the most useful.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`定义了几个事件，其中`TextChanged`是最有用的。'
- en: PasswordBox
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PasswordBox
- en: '`PasswordBox` is used for entering passwords (no surprise here). The text is
    shown with a single repeating character, that can be changed with the `PasswordChar`
    property (default is `''*''` appearing as a circle). The `Password` property is
    the actual password, typically read in code.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasswordBox`用于输入密码（毫不意外）。文本显示为单个重复字符，可以使用`PasswordChar`属性更改（默认为`''*''`，显示为圆圈）。`Password`属性是实际密码，通常在代码中读取。'
- en: A nice feature of `PasswordBox` is a "reveal" button that can show the actual
    password when the button is pressed, useful to make sure entered password is what
    was intended; this feature can be turned off by setting `IsPasswordRevealButtonEnabled`
    to `false`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasswordBox`的一个很好的功能是一个“显示”按钮，当按下按钮时可以显示实际密码，有助于确保输入的密码是预期的；通过将`IsPasswordRevealButtonEnabled`设置为`false`可以关闭此功能。'
- en: RichTextBlock and RichEditBox
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RichTextBlock和RichEditBox
- en: The "rich" versions of `TextBlock` and `TextBox` provide richer formatting capabilities
    with respect to their "poor" counterpart. For example, it's possible to set font-related
    properties to any text within the control.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBlock`和`TextBox`的“丰富”版本提供了更丰富的格式化功能。例如，可以将字体相关属性设置为控件内的任何文本。'
- en: For `RichTextBlock`, the actual content of the controls is in a collection of
    block objects (`Blocks` property), with just one derived type – `Paragraph`. `Paragraph`
    has its own formatting properties and can host `Inline` objects (similar to a
    `TextBlock`); the `InlineUIContainer` inline is supported by `RichTextBlock`,
    providing the ability to embed elements (such as images, or anything else for
    that matter) as part of the text.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RichTextBlock`，控件的实际内容在块对象的集合中（`Blocks`属性），只有一个派生类型 - `Paragraph`。`Paragraph`有自己的格式化属性，并且可以承载`Inline`对象（类似于`TextBlock`）；`RichTextBlock`支持`InlineUIContainer`内联，可以嵌入元素（例如图像，或其他任何内容）作为文本的一部分。
- en: '`RichEditBox` allows for richer editing capabilities that can embed *rich*
    content, such as hyperlinks. The `Document` property (of type `ITextDocument`)
    provides the gateway to the object model behind the `RichEditBox`. This object
    model supports saving and loading the document in text and rich text (RTF) formats,
    multiple undo/redo capability, and other features.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`RichEditBox`允许更丰富的编辑功能，可以嵌入*丰富*内容，例如超链接。`Document`属性（类型为`ITextDocument`）提供了`RichEditBox`背后的对象模型的入口。此对象模型支持以文本和富文本（RTF）格式保存和加载文档，多次撤消/重做功能等其他功能。'
- en: Images
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像
- en: 'Images can be displayed with the `Image` element. The `Source` property indicates
    what should be displayed. The simplest possibility is an image added to the project
    as content:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以使用`Image`元素显示。`Source`属性指示应显示什么。最简单的可能性是将图像添加到项目作为内容：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `Source` property is of type `ImageSource`; this markup works only because
    a type converter exists to turn the relative URI into a type derived from `ImageSource`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Source`属性是`ImageSource`类型；此标记仅起作用是因为存在类型转换器，可以将相对URI转换为从`ImageSource`派生的类型。'
- en: The simplest derived type is `BitmapImage` (actually derives from `BitmapSource`
    that derives from `ImageSource`). `BitmapImage` can be initialized from a URI
    (with the `UriSource` property), which is exactly what happens with the type converter
    used in the preceding XAML.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的派生类型是`BitmapImage`（实际上是从`BitmapSource`派生的，而`BitmapSource`又是从`ImageSource`派生的）。`BitmapImage`可以从URI（使用`UriSource`属性）初始化，这正是在前面的XAML中使用的类型转换器所发生的。
- en: A more interesting type is `WriteableBitmap` (derives from `BitmapSource` as
    well), that exposes the ability to change the bitmap bits dynamically.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的类型是`WriteableBitmap`（也是从`BitmapSource`派生的），它公开了动态更改位图位的能力。
- en: 'To create a `WriteableBitmap`, we need to specify its dimensions in pixels,
    as the following code demonstrates:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`WriteableBitmap`，我们需要指定其像素尺寸，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`_bitmap` is a `WriteableBitmap` reference. Next, we set it as the `Source`
    property of an `Image` element:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`_bitmap`是一个`WriteableBitmap`引用。接下来，我们将其设置为`Image`元素的`Source`属性：'
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To access the actual bits, we''ll need to use a native interface with WRL.
    First, two `includes` and a using statement:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问实际的位，我们需要使用WRL的本机接口。首先，两个`includes`和一个using语句：
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`robuffer.h` defines the `IBufferByteAccess` interface, used with the `WriteableBitmap::PixelBuffer`
    property like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`robuffer.h`定义了`IBufferByteAccess`接口，与`WriteableBitmap::PixelBuffer`属性一起使用，如下所示：'
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, the bits can be used. Here''s a simple example that draws the first
    line in the bitmap with a random color:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用这些位。以下是一个简单的示例，用随机颜色绘制位图中的第一行：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `WriteableBitmap::Invalidate` is necessary, ensuring the bitmap
    is redrawn, and so connected `Image` elements are updated.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`WriteableBitmap::Invalidate`是必要的，确保位图被重绘，从而连接的`Image`元素得到更新。
- en: The Stretch property
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Stretch属性
- en: 'The `Image::Stretch` property sets the way the `ImageSource` is stretched given
    the size of the `Image` element. Here''s how the `Stretch` property affects displayed
    images:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image::Stretch`属性设置`ImageSource`根据`Image`元素的大小进行拉伸的方式。以下是`Stretch`属性如何影响显示的图像：'
- en: '![The Stretch property](img/5022_04_18.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![Stretch属性](img/5022_04_18.jpg)'
- en: With `Stretch=None`, the image is displayed in its original size. In the shown
    image, the penguins are clipped because the image is too big to fit. `Uniform`
    and `UniformToFill` preserve the aspect ratio (the original image width divided
    by the height), while `Fill` simply stretches the image to fill the available
    space for the `Image`. `UniformToFill` may cut out content if the available space
    has a different aspect ratio than the original.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Stretch=None`，图像以其原始大小显示。在所示的图像中，企鹅被裁剪，因为图像太大而无法适应。`Uniform`和`UniformToFill`保留了纵横比（原始图像宽度除以高度），而`Fill`只是简单地拉伸图像以填充`Image`的可用空间。如果可用空间的纵横比与原始图像不同，`UniformToFill`可能会切掉内容。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse `Image` with `ImageSource`. `Image` is an element, so can be
    placed somewhere in the visual tree. An `ImageSource` is the actual data, an `Image`
    element simply shows the image data in some way. The original image data (`ImageSource`)
    is unchanged.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆`Image`和`ImageSource`。`Image`是一个元素，因此可以放置在可视树的某个位置。`ImageSource`是实际数据，`Image`元素只是以某种方式显示图像数据。原始图像数据（`ImageSource`）保持不变。
- en: The SemanticZoom control
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义缩放控件
- en: 'The `SemanticZoom` control deserves a section for itself, as it''s pretty unique.
    It combines two views in one control, one as a "zoomed out" view and another as
    a "zoomed in" view. The idea behind `SemanticZoom` is two related views – one
    more general (zoomed out) and the other more specific (zoomed in). The classic
    example is the Start screen. Doing the pinch/zoom touch gesture (or holding *Ctrl*
    and scrolling the mouse wheel) changes between the two views. The following is
    the zoomed in view:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemanticZoom`控件值得单独一节，因为它非常独特。它将两个视图合并到一个控件中，一个作为“缩小”视图，另一个作为“放大”视图。`SemanticZoom`背后的理念是两个相关的视图——一个更一般（缩小），另一个更具体（放大）。经典示例是开始屏幕。进行捏/缩放触摸手势（或按住*Ctrl*并滚动鼠标滚轮）在两个视图之间切换。以下是放大的视图：'
- en: '![The SemanticZoom control](img/5022_04_20.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![语义缩放控件](img/5022_04_20.jpg)'
- en: 'This is the zoomed out view:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是缩小的视图：
- en: '![The SemanticZoom control](img/5022_04_19.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![语义缩放控件](img/5022_04_19.jpg)'
- en: The `ZoomedInView` and `ZoomedOutView` properties hold the views—typically `ListView`
    or `GridView`, but technically anything that implements the `ISemanticZoomInformation`
    interface.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZoomedInView`和`ZoomedOutView`属性保存视图——通常是`ListView`或`GridView`，但在技术上可以是任何实现`ISemanticZoomInformation`接口的东西。'
- en: '`SemanticZoom` is an effective way to handle mater/detail scenarios in an easily
    accessible and intuitive way.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemanticZoom`是处理易于访问和直观的主/细节场景的有效方式。'
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Building an effective and addictive user interface is an art in itself, and
    is beyond the scope of this book. The modern design guidelines, as they relate
    to Windows Store apps are relatively new, but a lot of information can be found
    on the web, on Microsoft websites and others.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个有效且引人入胜的用户界面本身就是一门艺术，超出了本书的范围。与Windows Store应用相关的现代设计指南相对较新，但可以在网上、微软网站和其他地方找到大量信息。
- en: This chapter's goal was to introduce the C++ developer to the UI landscape,
    making it a more comfortable zone. Even if eventually the C++ developer will be
    more concerned with the application logic, infrastructure, and other low-level
    activities, it's still useful to understand the landscape of user experience and
    user interface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向C++开发人员介绍UI景观，使其成为一个更舒适的区域。即使最终C++开发人员将更关注应用程序逻辑、基础设施和其他低级活动，了解用户体验和用户界面的景观仍然是有用的。
- en: In the next chapter, we'll tie user interface and data via data binding to create
    robust and scalable applications, at least where UI and data are concerned.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过数据绑定将用户界面和数据联系起来，以创建健壮且可扩展的应用程序，至少在涉及用户界面和数据方面是这样。
