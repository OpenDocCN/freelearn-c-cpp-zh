- en: Chapter 11. Working with the System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。与系统一起工作
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Listing files in a directory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目录中的文件
- en: Erasing and creating files and directories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除和创建文件和目录
- en: Passing data quickly from one process to another
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速从一个进程传递到另一个进程的数据
- en: Syncing interprocess communications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步进程间通信
- en: Using pointers in shared memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在共享内存中使用指针
- en: The fastest way to read files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件的最快方式
- en: Coroutines – saving the state and postponing the execution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程 - 保存状态和推迟执行
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Each operating system has many system calls doing almost the same things in
    slightly different ways. Those calls differ in performance and differ from one
    operating system to another. Boost provides portable and safe wrappers around
    those calls. Knowledge of those wrappers is essential for writing good programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有许多系统调用，以略微不同的方式执行几乎相同的事情。这些调用在性能上有所不同，并且在不同操作系统之间有所不同。Boost为这些调用提供了可移植和安全的包装器。了解这些包装器对于编写良好的程序至关重要。
- en: This chapter is devoted to working with the operating system. We have seen how
    to deal with network communications and signals in [Chapter 6](ch06.html "Chapter 6. Manipulating
    Tasks"), *Manipulating Tasks*. In this chapter, we'll take a closer look at the
    filesystem and creating and deleting files. We'll see how data can be passed between
    different system processes, how to read files at maximum speed, and how to perform
    other tricks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于操作系统的工作。我们在[第6章](ch06.html "第6章。操作任务")“操作任务”中看到了如何处理网络通信和信号。在本章中，我们将更深入地研究文件系统以及创建和删除文件。我们将了解数据如何在不同的系统进程之间传递，如何以最大速度读取文件，以及如何执行其他技巧。
- en: Listing files in a directory
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出目录中的文件
- en: There are STL functions and classes to read and write data to files. But there
    are no functions to list files in a directory, to get the type of a file, or to
    get access rights for a file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有STL函数和类可以读取和写入文件中的数据。但没有函数可以列出目录中的文件，获取文件类型，或获取文件访问权限。
- en: Let's see how such iniquities can be fixed using Boost. We'll be creating a
    program that lists names, write accesses, and types of files in the current directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost来修复这样的不公正。我们将创建一个程序，列出当前目录中的文件名、写访问权限和文件类型。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some basics of C++ would be more than enough to use this recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本的C++知识就足够使用此配方了。
- en: This recipe requires linking against the `boost_system` and `boost_filesystem`
    libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要链接到`boost_system`和`boost_filesystem`库。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe and the next one are about portable wrappers for working with a
    filesystem:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方和下一个配方是关于用于处理文件系统的可移植包装器：
- en: 'We need to include the following two headers:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下两个头文件：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we need to specify a directory:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在需要指定一个目录：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After specifying the directory, loop through its content:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定目录后，遍历其内容：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is getting the file info:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是获取文件信息：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now output the file info:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输出文件信息：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final step would be to output the filename:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将是输出文件名：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s it. Now, if we run the program, it will output something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，如果我们运行程序，它将输出类似以下内容：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Functions and classes of `Boost.Filesystem` just wrap around system-specific
    functions to work with files.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Filesystem`的函数和类只是围绕系统特定的函数来处理文件。'
- en: Note the usage of `/` in step 2\. POSIX systems use a slash to specify paths;
    Windows, by default, uses backslashes. However, Windows understands forward slashes
    too, so `./` will work on all of the popular operating systems, and it means "the
    current directory".
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第2步中`/`的使用。POSIX系统使用斜杠来指定路径；默认情况下，Windows使用反斜杠。然而，Windows也理解正斜杠，所以`./`在所有流行的操作系统上都会工作，它表示“当前目录”。
- en: Take a look at step 3, where we are default constructing the `boost::filesystem::directory_iterator`
    class. It works just as a `std::istream_iterator` class, which acts as an `end`
    iterator when default constructed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第3步，我们正在默认构造`boost::filesystem::directory_iterator`类。它就像一个`std::istream_iterator`类，在默认构造时充当`end`迭代器。
- en: 'Step 4 is a tricky one, not because this function is hard to understand, but
    because lots of conversions are happening. Dereferencing the `begin` iterator
    returns `boost::filesystem::directory_entry`, which is implicitly converted to
    `boost::filesystem::path`, which is used as a parameter for the `boost::filesystem::status`
    function. Actually, we can do much better:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步有点棘手，不是因为这个函数难以理解，而是因为发生了许多转换。取消引用 `begin` 迭代器返回 `boost::filesystem::directory_entry`，它被隐式转换为
    `boost::filesystem::path`，用作 `boost::filesystem::status` 函数的参数。实际上，我们可以做得更好：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Read the reference documentation carefully to avoid unrequired implicit conversions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读参考文档以避免不必要的隐式转换。
- en: 'Step 5 is obvious, so we are moving to step 6 where implicit conversion to
    the path happens again. A better solution would be the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步很明显，所以我们正在转向第6步，在那里再次发生隐式路径转换。一个更好的解决方案将是以下：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `begin->path()` returns a const reference to the `boost::filesystem::path`
    variable that is contained inside `boost::filesystem::directory_entry`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`begin->path()` 返回一个对包含在 `boost::filesystem::directory_entry` 中的 `boost::filesystem::path`
    变量的常量引用。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, `Boost.Filesystem` is not a part of C++11, but it is proposed
    for inclusion in the next C++ standard. `Boost.Filesystem` currently misses support
    for rvalue references, but still remains one of the simplest and most portable
    libraries to work with a filesystem.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`Boost.Filesystem` 不是 C++11 的一部分，但它被提议包含在下一个 C++ 标准中。`Boost.Filesystem`
    目前缺少对右值引用的支持，但仍然是最简单和最可移植的文件系统交互库之一。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The *Erasing and creating files and directories* recipe will show another example
    of the usage of `Boost.Filesystem`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除和创建文件及目录* 菜谱将展示 `Boost.Filesystem` 的另一个使用示例。'
- en: 'Read Boost''s official documentation for `Boost.Filesystem` to get more info
    about its abilities; it is available at the following link:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取Boost的官方文档以获取关于`Boost.Filesystem`更多功能的信息；它可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm).'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm)。'
- en: The `Boost.Filesystem` library is proposed for inclusion in C++1y. The draft
    is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.h).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Filesystem` 库被提议包含在 C++1y 中。草案可在 [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3399.h)
    找到。'
- en: Erasing and creating files and directories
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除和创建文件及目录
- en: 'Let''s consider the following lines of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码行：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In these lines, we attempt to write something to `file.txt` in the `dir/subdir`
    directory. This attempt will fail if there is no such directory. The ability to
    work with filesystems is necessary for write a good working code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们尝试在 `dir/subdir` 目录中的 `file.txt` 写入一些内容。如果没有这样的目录，这个尝试将会失败。与文件系统交互的能力对于编写良好的工作代码是必要的。
- en: In this recipe we'll construct a directory and a subdirectory, write some data
    to a file, and try to create `symlink`, and if the symbolic link's creation fails,
    erase the created file. We will also avoid using exceptions as a mechanism of
    error reporting, preferring some form of return codes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将构建一个目录和子目录，将一些数据写入文件，并尝试创建`symlink`，如果创建符号链接失败，将删除创建的文件。我们还将避免使用异常作为错误报告的机制，而更倾向于使用某种形式的返回代码。
- en: Let's see how that can be done in an elegant way using Boost.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Boost 以优雅的方式做到这一点。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and the `std::ofstream` class is required for this recipe.
    `Boost.Filesystem` is not a header-only library, so code in this recipe requires
    linking against the `boost_system` and `boost_filesystem` libraries.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个菜谱，需要具备 C++ 和 `std::ofstream` 类的基本知识。`Boost.Filesystem` 不是一个仅包含头文件的库，因此这个菜谱中的代码需要链接到
    `boost_system` 和 `boost_filesystem` 库。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We continue to deal with portable wrappers for a filesystem, and in this recipe
    we''ll see how to modify the directory content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续处理文件系统的可移植包装，在这个菜谱中，我们将看到如何修改目录内容：
- en: 'As always, we''ll need to include some headers:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要包含一些头文件：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need a variable to store errors (if any):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个变量来存储错误（如果有）：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will also create directories, if required, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，我们还将创建目录，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we will write data to the file:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将向文件写入数据：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need to attempt to create `symlink`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要尝试创建 `symlink`：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we need to check that the file is accessible through `symlink`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要检查文件是否可以通过`symlink`访问：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or remove the created file, if `symlink` creation failed:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果`symlink`创建失败，则删除创建的文件：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We saw `boost::system::error_code` in action in almost all of the recipes in
    , *Manipulating Tasks*. It can store information about errors and is widely used
    throughout the Boost libraries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在几乎所有关于*操作任务*的配方中看到了`boost::system::error_code`的使用。它可以存储有关错误的信息，并在Boost库中得到广泛使用。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not provide an instance of `boost::system::error_code` to the `Boost.Filesystem`
    functions, the code will compile well, but when an error occurs, an exception
    will be thrown. Usually a `boost::filesystem::filesystem_error` exception is thrown
    unless you are having trouble with allocating memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有向`Boost.Filesystem`函数提供一个`boost::system::error_code`实例，代码将编译良好，但发生错误时，将抛出异常。通常，除非你在分配内存方面遇到问题，否则会抛出`boost::filesystem::filesystem_error`异常。
- en: Take a careful look at step 3\. We used the `boost::filesystem::create_directories`
    function, not `boost::filesystem::create_directory`, because the latter cannot
    create subdirectories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看第3步。我们使用了`boost::filesystem::create_directories`函数，而不是`boost::filesystem::create_directory`，因为后者不能创建子目录。
- en: The remaining steps are trivial to understand and should not cause any trouble.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余步骤很容易理解，不应引起任何麻烦。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::system::error_code` class is a part of C++11 and can be found in
    the `<system_error>` header in the `std::` namespace. The classes of `Boost.Filesystem`
    are not a part of C++11, but they are proposed for inclusion in C++1y, which will
    probably be ready in 2014.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::system::error_code`类是C++11的一部分，可以在`std::`命名空间中的`<system_error>`头文件中找到。`Boost.Filesystem`的类不是C++11的一部分，但它们被提议包含在C++1y中，预计将在2014年准备好。'
- en: Finally, a small recommendation for those who are going to use `Boost.Filesystem`;
    when the errors occurring during filesystem operations are routine, use `boost::system::error_codes`.
    Otherwise, catching exceptions is preferable and more reliable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对那些将要使用`Boost.Filesystem`的人有一个小建议；当文件系统操作中发生的错误是常规的，使用`boost::system::error_codes`。否则，捕获异常更可取且更可靠。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Listing files in a directory* recipe also contains information about `Boost.Filesystem`.
    Read Boost's official documentation to get more information and examples at [http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列出目录中的文件*配方还包含有关`Boost.Filesystem`的信息。阅读Boost的官方文档以获取更多信息及示例，请访问[http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/index.htm)。'
- en: Passing data quickly from one process to another
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速从一个进程传递数据到另一个进程
- en: Sometimes we write programs that will communicate with each other a lot. When
    programs are run on different machines, using sockets is the most common technique
    for communication. But if multiple processes run on a single machine, we can do
    much better!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们编写的程序将大量相互通信。当程序在不同的机器上运行时，使用套接字是通信最常见的技术。但如果多个进程在单个机器上运行，我们可以做得更好！
- en: Let's take a look at how to make a single memory fragment available from different
    processes using the `Boost.Interprocess` library.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Boost.Interprocess`库使单个内存片段在不同进程间可用。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe. Knowledge of atomic variables
    is also required (take a look at the *See also* section for more information about
    atomics). Some platforms require linking against the runtime library.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要具备C++的基本知识。还需要了解原子变量（有关原子变量的更多信息，请参阅*另请参阅*部分）。某些平台需要链接到运行时库。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this example we''ll be sharing a single atomic variable between processes,
    making it increment when a new process starts and decrement when the process terminates:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将在进程间共享一个单一的原子变量，使其在新的进程启动时增加，在进程终止时减少：
- en: 'We''ll need to include the following header for interprocess communications:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含以下头文件以进行进程间通信：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following the header, `typedef` and a check will help us make sure that atomics
    are usable for this example:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件、`typedef`和检查之后，将帮助我们确保原子变量可用于此示例：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create or get a shared segment of memory:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或获取共享内存段：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Get or construct an `atomic` variable:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取或构造一个`原子`变量：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Work with the `atomic` variable in the usual way:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式处理`原子`变量：
- en: '[PRE21]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Destroy the `atomic` variable:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁`原子`变量：
- en: '[PRE22]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's all! Now if we run multiple instances of this program simultaneously,
    we'll see that each new instance increments its index value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！现在如果我们同时运行这个程序的多实例，我们会看到每个新的实例都会增加它的索引值。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main idea of this recipe is to get a segment of memory that is visible to
    all processes, and place some data in it. Let's take a look at step 3, where we
    retrieve such a segment of memory. Here, `shm-cache` is the name of the segment
    (different segments differ in name); you can give any names you like to the segments.
    The first parameter is `boost::interprocess::open_or_create`, which says that
    `boost::interprocess::managed_shared_memory` will open an existing segment with
    the name `shm-cache`, or it will construct it. The last parameter is the size
    of the segment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的核心理念是获取一个对所有进程可见的内存段，并在其中放置一些数据。让我们看看第3步，我们在这里检索这样一个内存段。在这里，`shm-cache`是段的名称（不同的段名称不同）；你可以给段起任何你喜欢的名字。第一个参数是`boost::interprocess::open_or_create`，这意味着`boost::interprocess::managed_shared_memory`将打开一个名为`shm-cache`的现有段，或者如果不存在，则构造它。最后一个参数是段的尺寸。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size of the segment must be big enough to fit the `Boost.Interprocess` library-specific
    data in it. That's why we used `1024` and not `sizeof(atomic_t)`. But it does
    not really matter, because the operating system will round this value to the nearest
    larger supported value, which is usually equal to or larger than 4 kilobytes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分段的尺寸必须足够大，以便能够容纳`Boost.Interprocess`库特定的数据。这就是为什么我们使用了`1024`而不是`sizeof(atomic_t)`。但实际上这并不重要，因为操作系统会将这个值四舍五入到最近的更大的支持值，这通常等于或大于4千字节。
- en: Step 4 is a tricky one as we are doing multiple tasks at the same time here.
    In part `2` of this step, we will find or construct a variable with the name `shm-counter`
    in the segment. In part `3` of step 4, we will provide a parameter, which will
    be used for the initialization of a variable if it has not been found in step
    2\. This parameter will be used only if the variable is not found and must be
    constructed, otherwise it is ignored. Take a closer look at the second line (part
    `1`). See the call to the dereference operator `*`. We are doing it because `segment.find_or_construct<atomic_t>`
    returns a pointer to `atomic_t`, and working with bare pointers in C++ is a bad
    style.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步是一个棘手的部分，因为我们在这里同时执行多个任务。在这一步的`2`部分，我们将在段中查找或构造一个名为`shm-counter`的变量。在第4步的`3`部分，我们将提供一个参数，如果它在第2步中没有找到，这个参数将被用来初始化变量。只有在变量没有找到并且需要构造时，这个参数才会被使用，否则它将被忽略。仔细看看第二行（`1`部分）。看到对解引用操作符`*`的调用。我们这样做是因为`segment.find_or_construct<atomic_t>`返回一个指向`atomic_t`的指针，而在C++中使用裸指针是一种不良风格。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are using atomic variables in shared memory! This is required,
    because two or more processes can simultaneously work with the same `shm-counter`
    atomic variable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用共享内存中的原子变量！这是必需的，因为两个或多个进程可以同时操作同一个`shm-counter`原子变量。
- en: You must be very careful when working with objects in shared memory; do not
    forget to destroy them! In step 6, we are destroying the object and segment using
    their names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与共享内存中的对象一起工作时，你必须非常小心；不要忘记销毁它们！在第6步，我们正在使用它们的名称销毁对象和段。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a closer look at step 2 where we are checking for `BOOST_ATOMIC_INT_LOCK_FREE
    != 2`. We are checking that `atomic_t` won't use mutexes. This is very important,
    because usually, mutexes won't work in shared memory. So if `BOOST_ATOMIC_INT_LOCK_FREE`
    is not equal to `2`, we'll get an undefined behavior.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看第2步，我们在这里检查`BOOST_ATOMIC_INT_LOCK_FREE != 2`。我们检查`atomic_t`不会使用互斥锁。这非常重要，因为通常互斥锁在共享内存中不会工作。所以如果`BOOST_ATOMIC_INT_LOCK_FREE`不等于`2`，我们将得到未定义的行为。
- en: Unfortunately, C++11 has no interprocess classes, and as far as I know, `Boost.Interprocess`
    is not proposed for inclusion in C++1y.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++11没有提供跨进程类，据我所知，`Boost.Interprocess`没有被提议包含在C++1y中。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once a managed segment is created, it cannot increase in size! Make sure that
    you are creating segments big enough for your needs, or take a look at the *See
    also* section for information about increasing managed segments.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个管理段，它就不能增加大小！确保你创建的段足够大以满足你的需求，或者查看`*另请参阅*`部分以获取有关增加管理段的信息。
- en: Shared memory is the fastest way for processes to communicate, and works for
    processes that can share memory. That usually means that the processes must run
    on the same host or on a **symmetric multiprocessing** (**SMP**) cluster.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存是进程间通信最快的方式，适用于可以共享内存的进程。这通常意味着这些进程必须在同一主机上运行或在**对称多处理**（**SMP**）集群上运行。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Syncing interprocess communications* recipe will tell you more about shared
    memory, interprocess communications, and syncing access to resources in shared
    memory
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步进程间通信*配方将向您介绍更多关于共享内存、进程间通信以及同步访问共享内存中的资源。'
- en: See the *Fast access to common resource using atomics* recipe in Chapter 5,
    Multithreading for more information about atomics
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第5章，多线程中的*使用原子操作快速访问公共资源*配方，以获取有关原子的更多信息。
- en: Boost's official documentation for `Boost.Interprocess` may also help; it is
    available at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档`Boost.Interprocess`也可能有所帮助；它可在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)找到。
- en: How to increase managed segments is described at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin)[g_managed_memory](http://g_managed_memory)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增加管理段在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess/managed_memory_segments.html#interprocess.managed_memory_segments.managed_memory_segment_advanced_features.growin)[g_managed_memory](http://g_managed_memory)中描述。
- en: Syncing interprocess communications
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步进程间通信
- en: In the previous recipe, we saw how to create shared memory and how to place
    some objects in it. Now it's time to do something useful. Let's take an example
    from the *Creating a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, and make it work for multiple processes. At the end of this
    example, we'll get a class that can store different tasks and pass them between
    processes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们看到了如何创建共享内存以及如何将一些对象放入其中。现在是我们做一些有用的事情的时候了。让我们从一个例子开始，这个例子来自第5章的*创建work_queue类*配方，*多线程*，并使其适用于多个进程。在这个例子的最后，我们将得到一个可以存储不同任务并在进程间传递它们的类。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses techniques from the previous one. You will also need to read
    the *Creating a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, and get its main idea. The example requires linking against
    the runtime library on some platforms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方使用前一个配方中的技术。您还需要阅读第5章的*创建work_queue类*配方，*多线程*，并理解其主要思想。这个例子需要在某些平台上链接到运行时库。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: It is considered that spawning separate subprocesses instead of threads makes
    a program more reliable, because termination of a subprocess won't terminate the
    main process. We won't argue with that assumption here, and just see how data
    sharing between processes can be implemented.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是在线程之外创建单独的子进程而不是线程可以使程序更可靠，因为子进程的终止不会终止主进程。我们不会对这个假设进行争论，只是看看进程间数据共享如何实现。
- en: 'A lot of headers are required for this recipe:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本配方需要很多头文件：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we need to define our structure, `task_structure`, which will be used to
    store tasks:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义我们的结构，`task_structure`，它将被用来存储任务：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s start writing the `work_queue` class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始编写`work_queue`类：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write the members of `work_queue` as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编写`work_queue`的成员：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Initialization of members should look like the following:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员的初始化应如下所示：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We need to make some minor changes to the member functions of `work_queue`,
    such as using `scoped_lock_t` instead of the original unique locks:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对`work_queue`的成员函数做一些小的修改，例如使用`scoped_lock_t`而不是原始的唯一锁：
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we are doing almost exactly the same things as in the *Creating
    a work_queue class* recipe in [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, but when we allocate the data in shared memory, additional care
    must be taken when doing memory allocations or using synchronization primitives.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们几乎与第5章中“创建工作队列类”菜谱中做的是完全相同的事情，即*多线程*，但是在我们在共享内存中分配数据时，进行内存分配或使用同步原语时必须格外小心。
- en: Take additional care when storing shared memory objects that have pointers or
    references as member fields. We'll see how to cope with pointers in the next recipe.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储具有指针或引用作为成员字段的共享内存对象时，请格外小心。我们将在下一菜谱中看到如何处理指针。
- en: Take a look at step 2\. We did not use `boost::function` as a task type because
    it has pointers in it, so it won't work in shared memory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 看看步骤2。我们没有使用`boost::function`作为任务类型，因为它包含指针，所以在共享内存中不会工作。
- en: Step 3 is interesting because of `allocator_t`. It is a type of allocator that
    all containers must use to allocate elements. It is a stateful allocator, which
    means that it will be copied along with the container. Also, it cannot be default
    constructed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步之所以有趣，是因为`allocator_t`。它是一种所有容器都必须用来分配元素的分配器类型。它是一个有状态的分配器，这意味着它将与容器一起复制。此外，它不能被默认构造。
- en: If memory is not allocated from the shared memory segment, it won't be available
    to other processes; that's why a specific allocator for containers is required.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有从共享内存段分配内存，它将不可用于其他进程；这就是为什么需要一个特定于容器的分配器的原因。
- en: Step 4 is pretty trivial, except that we have only references to `tasks_`, `mutex_`,
    and `cond_`. This is done because objects themselves are constructed in the shared
    memory. So, `work_queue` can only store references to them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步相当简单，除了我们只有对`tasks_`、`mutex_`和`cond_`的引用。这样做是因为对象本身是在共享内存中构建的。因此，`work_queue`只能存储它们的引用。
- en: In step 5 we are initializing members. This code will be familiar to you; we
    were doing exactly the same things in the previous recipe. Note that we are providing
    an instance of allocator to `tasks_` while constructing it. That's because `allocator_t`
    cannot be constructed by the container itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们正在初始化成员。这段代码对你来说很熟悉；我们在前一个菜谱中做了完全相同的事情。请注意，我们在构建时向`tasks_`提供了一个分配器实例。这是因为`allocator_t`不能由容器本身构造。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shared memory is not destructed at the exit event of a process, so we can run
    the program once, post the tasks to a work queue, stop the program, start some
    other program, and get tasks stored by the first instance of the program. Shared
    memory will be destroyed only at restart, or if you explicitly call `segment.deallocate("work-queue");`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存不会在进程的退出事件中被销毁，因此我们可以运行程序一次，将任务发布到工作队列中，停止程序，启动其他程序，并获取由程序的第一实例存储的任务。共享内存只有在重启时或显式调用`segment.deallocate("work-queue");`时才会被销毁。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As was mentioned in the previous recipe, C++11 has no classes from `Boost.Interprocess`.
    Moreover, you must not use C++11 or C++03 containers in shared memory segments.
    Some of those containers may work, but that behavior is not portable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个菜谱中提到的，C++11没有`Boost.Interprocess`中的类。此外，你不得在共享内存段中使用C++11或C++03容器。其中一些容器可能可以工作，但这种行为是不可移植的。
- en: 'If you look inside some of the `<boost/interprocess/containers/*.hpp>` headers,
    you''ll find that they just use containers from the `Boost.Containers` library:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一些`<boost/interprocess/containers/*.hpp>`头文件，你会发现它们只是使用了`Boost.Containers`库中的容器：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Containers of `Boost.Interprocess` have all of the benefits of the `Boost.Containers`
    library, including rvalue references and their emulation on older compilers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Interprocess`的容器具有`Boost.Containers`库的所有优点，包括右值引用及其在较旧编译器上的模拟。'
- en: '`Boost.Interprocess` is the fastest solution for communication between processes
    that are running on the same machine.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Interprocess`是同一台机器上运行的进程之间通信的最快解决方案。'
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using pointers in shared memory* recipe
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用共享内存中的指针*菜谱'
- en: Read [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*, for
    more information about synchronization primitives and multithreading
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关同步原语和多线程的更多信息，请参阅[第5章](ch05.html "Chapter 5. Multithreading")，*多线程*。
- en: 'Refer to Boost''s official documentation for the `Boost.Interprocess` library
    for more examples and information; it is available at the following link:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Boost官方文档中的`Boost.Interprocess`库以获取更多示例和信息；它可在以下链接中找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)'
- en: Using pointers in shared memory
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在共享内存中使用指针
- en: 'It is hard to imagine writing some C++ core classes without pointers. Pointers
    and references are everywhere in C++, and they do not work in shared memory! So
    if we have a structure like this in shared memory and assign the address of some
    integer variable in shared memory to `pointer_`, we won''t get the correct address
    in the other process that will attempt to use `pointer_` from that instance of
    `with_pointer`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象在不使用指针的情况下编写一些C++核心类。指针和引用在C++中无处不在，它们在共享内存中不起作用！所以如果我们有一个这样的结构在共享内存中，并将共享内存中某个整数的地址赋给`pointer_`，我们不会在尝试从`with_pointer`的这个实例使用`pointer_`的其他进程中得到正确的地址：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How can we fix that?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何修复这个问题？
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The previous recipe is required for understanding this one. The example requires
    linking against the runtime system library on some platforms.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方是理解这个配方所必需的。示例在某些平台上需要链接到运行时系统库。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Fixing it is very simple; we need only to replace the pointer with `offset_ptr<>`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 修复它非常简单；我们只需要用`offset_ptr<>`替换指针：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we are free to use it as a normal pointer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像使用普通指针一样使用它：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We cannot use pointers in shared memory because when a piece of shared memory
    is mapped into the address space of a process, its address is valid only for that
    process. When we are getting the address of a variable, it is just a local address
    for that process; other processes will map shared memory to a different base address,
    and as a result the variable address will differ.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在共享内存中使用指针，因为当一块共享内存被映射到进程的地址空间时，其地址仅对该进程有效。当我们获取变量的地址时，它只是该进程的一个局部地址；其他进程将共享内存映射到不同的基本地址，因此变量地址将不同。
- en: '![How it works...](img/4880OS_11_01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_11_01.jpg)'
- en: So how can we work with an address that is always changing? There is a trick!
    As the pointer and structure are in the same shared memory segment, the distance
    between them does not change. The idea behind `boost::interprocess::offset_ptr`
    is to remember that distance, and on dereference, add the distance value to the
    process-dependent address of the `offset_ptr` variable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何处理一个始终变化的地址呢？有一个技巧！因为指针和结构在同一个共享内存段中，它们之间的距离不会改变。`boost::interprocess::offset_ptr`背后的想法是记住这个距离，在解引用时，将距离值添加到`offset_ptr`变量的进程相关地址。
- en: The offset pointer imitates the behavior of pointers, so it is a drop-in replacement
    that can be applied fast.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移指针模仿指针的行为，因此它是一个可以快速应用的即插即用替换品。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not place classes that may have pointers or references into shared memory!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将可能包含指针或引用的类放入共享内存！
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An offset pointer works slightly slower than the usual pointer because on each
    dereference, it is required to compute the address. But this difference is not
    usually sufficient to bother you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移指针比常规指针稍微慢一些，因为每次解引用时都需要计算地址。但这种差异通常不足以让你烦恼。
- en: C++11 has no offset pointers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有偏移指针。
- en: See also
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Boost's official documentation contains many examples and more advanced `Boost.Interprocess`
    features; it is available at [http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了大量示例和更高级的`Boost.Interprocess`功能；它可在[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html)找到。
- en: The *fastest way to read files* recipe contains information about some nontraditional
    usage of the `Boost.Interprocess` library
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “*最快读取文件*”配方中包含了关于`Boost.Interprocess`库一些非传统用法的信息。
- en: The fastest way to read files
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最快读取文件的方法
- en: 'All around the Internet, people are asking "What is the fastest way to read
    files?". Let''s make our task for this recipe even harder: "What is the fastest
    and most portable way to read binary files?"'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个互联网上，人们都在问“最快读取文件的方法是什么？”。让我们使这个配方的任务更加困难：“最快且最便携的读取二进制文件的方法是什么？”
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and the `std::fstream` containers is required for this
    recipe.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个配方，需要具备C++和`std::fstream`容器的基本知识。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The technique from this recipe is widely used by applications critical to input
    and output performance.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 来自这个配方的技术被许多对输入输出性能至关重要的应用程序广泛使用。
- en: 'We''ll need to include two headers from the `Boost.Interprocess` library:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含来自`Boost.Interprocess`库的两个头文件：
- en: '[PRE33]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need to open a file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要打开一个文件：
- en: '[PRE34]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The main part of this recipe is mapping all of the files to memory:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个菜谱的主要部分是将所有文件映射到内存中：
- en: '[PRE35]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Getting a pointer to the data in the file:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件中数据的指针：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That''s it! Now we can work with a file just as with normal memory:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以像使用正常内存一样处理文件：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All popular operating systems have the ability to map a file to processes' address
    space. After such mapping is done, the process can work with those addresses just
    as with normal memory. The operating system will take care of all of the file
    operations, such as caching and read-ahead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流行的操作系统都具有将文件映射到进程地址空间的能力。完成此类映射后，进程可以像使用正常内存一样使用这些地址。操作系统将负责所有的文件操作，例如缓存和预读。
- en: Why is it faster than traditional read/writes? That's because in most cases
    read/write is implemented as memory mapping and copying data to a user-specified
    buffer. So read usually does more work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它比传统的读写操作更快？那是因为在大多数情况下，读写操作被实现为内存映射和将数据复制到用户指定的缓冲区。所以读取通常要做更多的工作。
- en: Just as in the case of STL, we must provide an open mode when opening a file.
    See step 2 where we provided the `boost::interprocess::read_only` mode.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如STL的情况一样，我们在打开文件时必须提供一个打开模式。请参阅第2步，其中我们提供了`boost::interprocess::read_only`模式。
- en: See step 3 where we mapped a whole file at once. This operation is actually
    really fast, because the OS does not read data from the disk, but waits for the
    requests to be a part of the mapped region. After a part of the mapped region
    was requested, the OS loads that part of the file from the disk. As we can see,
    memory mapping operations are lazy, and the size of the mapped region does not
    affect performance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第3步，其中我们一次性映射了整个文件。这个操作实际上非常快，因为操作系统不会从磁盘读取数据，而是等待请求成为映射区域的一部分。在请求映射区域的一部分后，操作系统将从磁盘加载该部分的文件。正如我们所见，内存映射操作是懒加载的，映射区域的大小不会影响性能。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, a 32-bit OS cannot memory-map large files, so you'll need to map them
    in pieces. POSIX (Linux) operating systems require `_FILE_OFFSET_BITS=64` to be
    defined for the whole project to work with large files on a 32-bit platform. Otherwise,
    the OS won't be able to map parts of the file that are beyond 4 GB.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，32位操作系统无法内存映射大文件，因此您需要分块映射它们。POSIX（Linux）操作系统要求定义`_FILE_OFFSET_BITS=64`，以便整个项目能够在32位平台上处理大文件。否则，操作系统将无法映射超过4GB的文件部分。
- en: 'Now it''s time to measure the performance:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测量性能了：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Just as expected, memory-mapped files are slightly faster than traditional reads.
    We can also see that pure C methods have the same performance as that of the C++
    `std::ifstream` class, so please do not use functions related to `FILE*` in C++.
    They are just for C, not for C++!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，内存映射文件比传统的读取操作略快。我们还可以看到，纯C方法与C++的`std::ifstream`类的性能相同，所以请勿在C++中使用与`FILE*`相关的函数。这些函数仅适用于C，不适用于C++！
- en: 'For optimal performance of `std::ifstream`, do not forget to open files in
    binary mode and read data by blocks:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`std::ifstream`的最佳性能，请务必以二进制模式打开文件并按块读取数据：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Unfortunately, classes for memory mapping files are not part of C++11, and it
    looks like they won't be in C++14 either.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，内存映射文件的类不是C++11的一部分，而且看起来它们也不会在C++14中出现。
- en: Writing to memory-mapped regions is also a very fast operation. The OS will
    cache the writes and won't flush modifications to the disc immediately. There
    is a difference between the OS and the `std::ofstream` data caching. If the `std::ofstream`
    data is cached by an application and it terminates, the cached data can be lost.
    When data is cached by the OS, termination of the application won't lead to data
    loss. Power failures and system crashes lead to data loss in both cases.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 向内存映射区域写入也是一种非常快速的操作。操作系统将缓存写入操作，并且不会立即将修改刷新到磁盘。操作系统和`std::ofstream`数据缓存之间有一个区别。如果`std::ofstream`数据被应用程序缓存并且应用程序终止，那么缓存的数据可能会丢失。当数据被操作系统缓存时，应用程序的终止不会导致数据丢失。电源故障和系统崩溃在这两种情况下都会导致数据丢失。
- en: If multiple processes map a single file, and one of the processes modifies the
    mapped region, the changes are immediately visible to the other processes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个进程映射同一个文件，并且其中一个进程修改了映射区域，那么这些更改将立即对其他进程可见。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The `Boost`.`Interprocess` library contains a lot of useful features to work
    with the system; not all of them are covered in this book. You can read more about
    this great library at the official site:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost`.`Interprocess`库包含了许多与系统一起工作的有用功能；本书并未涵盖所有这些功能。您可以在官方网站上了解更多关于这个伟大库的信息：'
- en: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interproces)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/doc/html/interprocess.html](http://www.boost.org/doc/libs/1_53_0/doc/html/interproces)'
- en: Coroutines – saving the state and postponing the execution
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程 – 保存状态和推迟执行
- en: Nowadays, plenty of embedded devices still have only a single core. Developers
    write for those devices, trying to squeeze maximum performance out of them. Using
    `Boost.Threads` or some other thread library for such devices is not effective;
    the OS will be forced to schedule threads for execution, manage resources, and
    so on, as the hardware cannot run them in parallel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多嵌入式设备仍然只有单核。开发者为这些设备编写代码，试图从中榨取最大性能。对于这样的设备使用`Boost.Threads`或其他线程库并不有效；操作系统将被迫调度线程以执行，管理资源等等，因为硬件无法并行运行它们。
- en: So how can we make a program switch to the execution of a subprogram while waiting
    for some resource in the main part?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在主程序等待某些资源时切换程序到子程序的执行？
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and templates is required for this recipe. Reading some
    recipes about `Boost.Function` may also help.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个配方，需要具备C++和模板的基本知识。阅读一些关于`Boost.Function`的配方也可能有所帮助。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: This recipe is about coroutines, subroutines that allow multiple entry points.
    Multiple entry points give us an ability to suspend and resume the execution of
    a program at certain locations, switching to/from other subprograms.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是关于协程，允许有多个入口点的子程序。多个入口点使我们能够在特定位置暂停和恢复程序的执行，切换到/从其他子程序。
- en: 'The `Boost.Coroutine` library will take care of almost everything. We just
    need to include its header:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Boost.Coroutine`库将负责几乎所有的事情。我们只需要包含其头文件：'
- en: '[PRE40]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make a coroutine type with the required signature:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所需的签名创建一个协程类型：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Make a coroutine:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个协程：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can execute the subprogram while waiting for an event in the main program:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以执行子程序，同时在主程序中等待事件：
- en: '[PRE43]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The coroutine method should look like this:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程方法应该看起来像这样：
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: At step 2, we are describing the signature of our subprogram using the function
    signature `std::string& (std::size_t)` as a template parameter. This means that
    the subprogram accepts `std::size_t` and returns a reference to a string.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步，我们使用函数签名`std::string& (std::size_t)`作为模板参数来描述我们的子程序签名。这意味着子程序接受`std::size_t`并返回一个字符串的引用。
- en: Step 3 is interesting because of the `coroutine_task` signature. Note that this
    signature is common for all coroutine tasks. `caller` is the variable that will
    be used to get parameters from the caller and to return the result of the execution
    back.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步之所以有趣，是因为`coroutine_task`的签名。请注意，这个签名适用于所有协程任务。`caller`是用于从调用者获取参数并将执行结果返回给调用者的变量。
- en: Step 3 requires additional care because the constructor of `corout_t` will automatically
    start the coroutine execution. That's why we call `caller(result)` at the beginning
    of the coroutine task (it returns us to the `main` method).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步需要额外的注意，因为`corout_t`的构造函数将自动启动协程执行。这就是为什么我们在协程任务开始时调用`caller(result)`（它将我们带回到`main`方法）。
- en: When we call `coroutine(10)` in step 4, we are causing a coroutine program to
    execute. Execution will jump to step 5 right after the first `caller(result)`
    method, where we'll get a value `10` from `caller.get()` and will continue our
    execution until `caller(result)`. After that, execution will return to step 4,
    right after the `coroutine(10)` call. Next, a call to `coroutine(10)` or `coroutine(300)`
    will continue the execution of the subprogram from the place right after the second
    `caller(result)` method at step 5.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第4步中调用`coroutine(10)`时，我们正在导致协程程序执行。执行将在第一个`caller(result)`方法之后跳转到第5步，在那里我们将从`caller.get()`获取一个值`10`并继续我们的执行，直到`caller(result)`。之后，执行将返回到第4步，紧随`coroutine(10)`调用之后。接下来，对`coroutine(10)`或`coroutine(300)`的调用将继续从第5步中第二个`caller(result)`方法之后的地点继续子程序的执行。
- en: '![How it works...](img/4880OS_11_02.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4880OS_11_02.jpg)'
- en: Take a look at `std::string& s = coroutine.get()` in step 4\. Here, we'll be
    getting a reference to the `std::string` result from the beginning of `coroutine_task`
    described in step 5\. We can even modify it, and `coroutine_task` will see the
    modified value. Let me describe the main difference between coroutines and threads.
    When a coroutine is executed, the main task does nothing. When the main task is
    executed, the coroutine task does nothing. You have no such guarantee with threads.
    With coroutines, you explicitly specify when to start a subtask and when to finish
    it. In a single core environment, threads can switch at any moment of time; you
    cannot control that behavior.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中查看`std::string& s = coroutine.get()`。在这里，我们将从第5步中描述的`coroutine_task`的开始获取`std::string`的结果。我们甚至可以修改它，`coroutine_task`将看到修改后的值。让我描述一下协程和线程之间的主要区别。当一个协程执行时，主任务什么都不做。当主任务执行时，协程任务什么都不做。你无法对线程有这种保证。使用协程，你可以明确指定何时开始子任务以及何时结束它。在单核环境中，线程可以在任何时刻切换；你无法控制这种行为。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use thread's local storage and do not call `boost::coroutines::coroutine<>::operator()`
    from inside the same coroutine; do not call `boost::coroutines::coroutine<>::get()`
    when a coroutine task is finished. These operations lead to undefined behavior.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用线程的局部存储，不要在同一协程内部调用`boost::coroutines::coroutine<>::operator()`；当协程任务完成时，不要调用`boost::coroutines::coroutine<>::get()`。这些操作会导致未定义的行为。
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While switching threads, the OS does a lot of work, so it is not a very fast
    operation. However, with coroutines, you have full control over switching tasks;
    moreover, you do not need to do any OS-specific internal kernel work. Switching
    coroutines is much faster than switching threads, however, it's not as fast as
    calling `boost::function`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换线程时，操作系统会做很多工作，因此这不是一个很快的操作。然而，使用协程，你可以完全控制任务切换；此外，你不需要执行任何特定于操作系统的内核工作。切换协程比切换线程要快得多，但它的速度不如调用`boost::function`。
- en: The `Boost.Coroutine` library will take care of calling a destructor for variables
    in a coroutine task, so there's no need to worry about leaks.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Coroutine`库将负责调用协程任务中的变量的析构函数，因此无需担心泄漏。'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Coroutines use the `boost::coroutines::detail::forced_unwind` exception to free
    resources that are not derived from `std::exception`. You must take care not to
    catch that exception in coroutine tasks.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 协程使用`boost::coroutines::detail::forced_unwind`异常来释放非`std::exception`派生的资源。你必须注意不要在协程任务中捕获该异常。
- en: C++11 has no coroutines. But coroutines use features of C++11 when possible,
    and even emulate rvalue references on C++03 compilers. You cannot copy `boost::coroutines::coroutine<>`,
    but you can move them using `Boost.Move`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有协程。但协程尽可能使用C++11的特性，甚至在C++03编译器上模拟右值引用。你不能复制`boost::coroutines::coroutine<>`，但你可以使用`Boost.Move`来移动它们。
- en: See also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Boost''s official documentation contains more examples, performance notes,
    restrictions, and use cases for the `Boost.Coroutines` library; it is available
    at the following link:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost的官方文档包含了`Boost.Coroutines`库的更多示例、性能注释、限制和使用案例；它可在以下链接找到：
- en: '[http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm](http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.htm)'
- en: Take a look at recipes from [Chapter 3](ch03.html "Chapter 3. Managing Resources"),
    *Managing Resources*, and [Chapter 5](ch05.html "Chapter 5. Multithreading"),
    *Multithreading*, to get the difference between the `Boost.Coroutine`, `Boost.Thread`,
    and `Boost.Function` libraries
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看第3章（[Chapter 3. Managing Resources](ch03.html "Chapter 3. Managing Resources")）的食谱，*Managing
    Resources*，以及第5章（[Chapter 5. Multithreading](ch05.html "Chapter 5. Multithreading")）的*Multithreading*，以了解`Boost.Coroutine`、`Boost.Thread`和`Boost.Function`库之间的区别
