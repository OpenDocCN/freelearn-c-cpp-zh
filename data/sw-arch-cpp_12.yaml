- en: Continuous Integration and Continuous Deployment
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成和持续部署
- en: In one of the previous chapters on building and packaging, we learned about
    different build systems and different packaging systems that our application can
    use. **Continuous Integration** (**CI**) and **Continuous Deployment** (**CD**)
    allow us to use knowledge of building and packaging to improve service quality
    and the robustness of the application we are developing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的一章中，我们学习了关于不同构建系统和不同打包系统的知识，我们的应用程序可以使用。持续集成（CI）和持续部署（CD）允许我们利用构建和打包的知识来提高服务质量和我们正在开发的应用程序的健壮性。
- en: Both CI and CD rely on good test coverage. CI uses mostly unit tests and integration
    tests, whereas CD depends more on smoke tests and end-to-end tests. You learned
    more about the different aspects of testing in [Chapter 8](160259bc-b601-4854-9aa9-cabe2c4fd691.xhtml),
    *Writing Testable Code*. With this knowledge, you are ready to build a CI/CD pipeline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: CI和CD都依赖于良好的测试覆盖率。CI主要使用单元测试和集成测试，而CD更依赖于冒烟测试和端到端测试。您在《第8章》《编写可测试的代码》中了解了测试的不同方面。有了这些知识，您就可以构建CI/CD流水线了。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding CI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CI
- en: Reviewing code changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查代码更改
- en: Exploring test-driven automation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索测试驱动的自动化
- en: Managing deployment as code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将部署管理为代码
- en: Building deployment code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建部署代码
- en: Building a CD pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建CD流水线
- en: Using immutable infrastructure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变基础设施
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The sample code of this chapter can be found at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter09)找到。
- en: 'To understand the concepts explained in this chapter, you''ll require the following
    installations:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解本章中解释的概念，您需要进行以下安装：
- en: A free GitLab account
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的GitLab账户
- en: Ansible version 2.8+
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible版本2.8+
- en: Terraform version 0.12+
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform版本0.12+
- en: Packer version 1.4+
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer版本1.4+
- en: Understanding CI
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CI
- en: CI is the process of shortening the integration cycles. Whereas in traditional
    software, many different features could have been developed separately and only
    integrated prior to release, in projects developed with CI, integration can occur
    several times a day. Usually, each change a developer makes is tested and integrated
    at the same time as it is committed to the central repository.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CI是缩短集成周期的过程。在传统软件中，许多不同的功能可能是分开开发的，只有在发布之前才进行集成，而在CI项目中，集成可以每天发生多次。通常，开发人员进行的每个更改都会在提交到中央代码库时进行测试和集成。
- en: Since testing occurs just after development, the feedback loop is much quicker.
    This lets developers fix bugs more easily (as they usually still remember what
    was changed). In contrast to the traditional approach of testing just prior to
    release, CI saves a lot of work and improves the quality of software.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试发生在开发之后，反馈循环要快得多。这使得开发人员更容易修复错误（因为他们通常还记得做了什么改动）。与传统的在发布之前进行测试的方法相比，CI节省了大量工作，并提高了软件的质量。
- en: Release early, release often
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽早发布，经常发布
- en: Have you ever heard the saying "release early, release often"? This is a software
    development philosophy that emphasizes the importance of short release cycles.
    Short release cycles, in turn, provide a much shorter feedback loop between planning,
    development, and validation. When something breaks, it should break as early as
    possible so that the costs of fixing the problem are relatively small.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否听说过“尽早发布，经常发布”的说法？这是一种强调短周期发布的软件开发理念。而短周期的发布循环则在规划、开发和验证之间提供了更短的反馈循环。当出现问题时，应该尽早出现，以便修复问题的成本相对较小。
- en: This philosophy was popularized by Eric S. Raymond (also known as ESR) in his
    1997 essay entitled *The* *Cathedral and the Bazaar*. There's also a book with
    the same title that contains this and other essays by the author. Considering
    ESR's activity within open source movements, the "release early, release often"
    mantra became synonymous with how open source projects operated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这一理念是由埃里克·S·雷蒙德（也被称为ESR）在他1997年的文章《大教堂与集市》中推广的。还有一本同名的书，其中包含了作者的这篇文章和其他文章。考虑到ESR在开源运动中的活动，"尽早发布，经常发布"的口号成为了开源项目运作方式的代名词。
- en: Some years later, the same principle moved beyond just open source projects.
    With the rising interest in Agile methodologies, such as Scrum, the "release early,
    release often" mantra became synonymous with development sprints that end with
    a product increment. This increment is, of course, a software release, but usually,
    there are many other releases that happened during the sprint.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，同样的原则不仅仅适用于开源项目。随着对敏捷方法学（如Scrum）日益增长的兴趣，“尽早发布，经常发布”的口号成为了以产品增量结束的开发冲刺的代名词。当然，这个增量是软件发布，但通常在冲刺期间会有许多其他发布。
- en: How can you achieve such short release cycles? One answer is to rely on automation
    as much as possible. Ideally, every commit to the code repository should end as
    a release. Whether this release ends up facing the customers is another matter.
    What's important is that every code change can result in a usable product.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这样的短周期发布循环？一个答案是尽可能依赖自动化。理想情况下，代码库的每次提交都应该以发布结束。这个发布是否面向客户是另一回事。重要的是，每次代码变更都可能导致可用的产品。
- en: Of course, building and releasing every single commit to the public would be
    a tedious job for any developer. Even when everything is scripted, this can add
    unnecessary overhead to the usual chores. This is why you would want to set up
    a CI system to automate the releases for you and your development team.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为每个提交构建和发布到公共环境对于任何开发人员来说都是一项繁琐的工作。即使一切都是脚本化的，这也会给通常的琐事增加不必要的开销。这就是为什么您希望设置一个CI系统来自动化您和您的开发团队的发布。
- en: Merits of CI
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI的优点
- en: 'CI is the concept of integrating the work of several developers, at least daily.
    As already discussed, sometimes it can mean several times a day. Every commit
    that enters the repository is integrated and validated separately. The build system
    checks whether the code can be built without errors. The packaging system may
    create a package that is ready to be saved as an artifact or even deployed later
    on when CD is used. Finally, the automated tests check that no known regression
    occurred in relation to the change. Let''s now see its merits in detail:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CI是将几个开发人员的工作至少每天集成在一起的概念。正如已经讨论过的，有时它可能意味着每天几次。进入存储库的每个提交都是单独集成和验证的。构建系统检查代码是否可以无错误地构建。打包系统可以创建一个准备保存为工件的软件包，甚至在使用CD时稍后部署。最后，自动化测试检查是否与更改相关的已知回归没有发生。现在让我们详细看看它的优点：
- en: CI allows for the rapid solving of problems. If one of the developers forgot
    a semicolon at the end of the line, the compiler on the CI system will catch that
    error right away before this incorrect code reaches other developers, thereby
    impeding their work. Of course, developers should always build the changes and
    test them before committing the code, but minor typos can go unnoticed on the
    developer's machine and enter the shared repository anyway.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI允许快速解决问题。如果其中一个开发人员在行末忘记了一个分号，CI系统上的编译器将立即捕捉到这个错误，这样错误的代码就不会传播给其他开发人员，从而阻碍他们的工作。当然，开发人员在提交代码之前应该构建更改并对其进行测试，但是在开发人员的机器上可能会忽略一些小错误，并且这些错误可能会进入共享存储库。
- en: Another benefit of using CI is that it prevents the common "works on my machine"
    excuse. If a developer forgets to commit a necessary file, the CI system will
    fail to build the changes, yet again preventing them from spreading further and
    causing mischief to the whole team. The special configuration of one developer's
    environment also stops being an issue. If a change builds on two machines, the
    developer's computer and the CI system, we are safe to assume that it should build
    on other machines as well.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CI的另一个好处是，它可以防止常见的“在我的机器上可以运行”的借口。如果开发人员忘记提交必要的文件，CI系统将无法构建更改，再次阻止它们进一步传播并对整个团队造成麻烦。一个开发人员环境的特殊配置也不再是问题。如果一个更改在两台机器上构建，即开发人员的计算机和CI系统，我们可以安全地假设它也应该在其他机器上构建。
- en: Gating mechanism
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门控机制
- en: If we want CI to bring value beyond simply building packages for us, we need
    a gating mechanism. This gating mechanism will allow us to discern good code changes
    from bad ones, thus keeping our application safe from modifications that would
    render it useless. For this to happen, we need a comprehensive suite of tests.
    Such a suite allows us to automatically recognize when a change is problematic,
    and we're able to do it quickly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望CI能够为我们带来价值，而不仅仅是为我们构建软件包，我们需要一个门控机制。这个门控机制将允许我们区分好的代码更改和坏的代码更改，从而使我们的应用程序免受使其无用的修改。为了实现这一点，我们需要一个全面的测试套件。这样的套件使我们能够自动识别何时更改有问题，并且我们能够迅速做到这一点。
- en: For individual components, unit tests play the role of a gating mechanism. A
    CI system can discard any changes that do not pass unit tests or any changes that
    do not reach a certain code coverage threshold. At the time of building individual
    components, a CI system may also use integration tests to further ensure that
    the changes are stable, not only by themselves but also are acting properly together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个组件，单元测试起到了门控机制的作用。CI系统可以丢弃任何未通过单元测试的更改，或者任何未达到一定代码覆盖率阈值的更改。在构建单个组件时，CI系统还可以使用集成测试来进一步确保更改是稳定的，不仅仅是它们自己，而且它们在一起的表现也是正常的。
- en: Implementing the pipeline with GitLab
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GitLab实施流水线
- en: Throughout this chapter, we will use popular open source tools to build a full
    CI/CD pipeline consisting of gating mechanisms, automated deployment, and also
    showing the concepts of infrastructure automation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用流行的开源工具构建一个完整的CI/CD流水线，其中包括门控机制、自动部署，并展示基础设施自动化的概念。
- en: 'The first such tool is GitLab. You may have heard about it as a Git hosting
    solution, but in reality, it''s much more than that. GitLab comes in several distributions,
    namely, the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个这样的工具是GitLab。您可能听说过它作为一个Git托管解决方案，但实际上，它远不止于此。GitLab有几个版本，即以下版本：
- en: An open source solution that you can host on your own premises
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种开源解决方案，您可以在自己的设施上托管
- en: Self-hosted paid versions that offer additional features over the open source
    community edition
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供额外功能的自托管付费版本，超过开源社区版
- en: And finally, a **Software-as-as-Service** (**SaaS**) managed offer hosted under
    [https://gitlab.com](https://gitlab.com)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个**软件即服务**（**SaaS**）托管在[https://gitlab.com](https://gitlab.com)下的托管服务
- en: For the requirements of this book, each of the distributions has all the necessary
    features. We will, therefore, focus on the SaaS version, as this requires the
    least amount of preparation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的要求，每个版本都具备所有必要的功能。因此，我们将专注于SaaS版本，因为这需要最少的准备工作。
- en: Although [https://gitlab.com](https://gitlab.com) is mainly targeted at open
    source projects, you can also create private projects and repositories if you
    don't feel like sharing your work with the entire world. This allows us to create
    a new private project in GitLab and populate it with the code we have already
    demonstrated in [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml), *Building
    and Packaging*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[https://gitlab.com](https://gitlab.com)主要针对开源项目，但如果您不想与整个世界分享您的工作，您也可以创建私有项目和存储库。这使我们能够在GitLab中创建一个新的私有项目，并用我们已经在[第7章](7f997c01-2634-4584-be95-0b068f448312.xhtml)中演示的代码填充它，*构建和打包*。
- en: A lot of modern CI/CD tools could work instead of GitLab CI/CD. Examples include
    GitHub Actions, Travis CI, CircleCI, and Jenkins. We've chosen GitLab as it can
    be used both in SaaS form and on-premises, so should accommodate a lot of different
    use cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代CI/CD工具可以代替GitLab CI/CD。例如GitHub Actions、Travis CI、CircleCI和Jenkins。我们选择了GitLab，因为它既可以作为SaaS形式使用，也可以在自己的设施上使用，因此应该适应许多不同的用例。
- en: 'We will then use our previous build system to create a simple CI pipeline in
    GitLab. These pipelines are described in the YAML file as a series of steps and
    metadata. An example pipeline building all the requirements, as well as the sample
    project from [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml), *Building
    and Packaging*, would look like the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用之前的构建系统在GitLab中创建一个简单的CI流水线。这些流水线在YAML文件中被描述为一系列步骤和元数据。一个构建所有要求的示例流水线，以及来自[第7章](7f997c01-2634-4584-be95-0b068f448312.xhtml)的示例项目，*构建和打包*，将如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Saving the preceding file as `.gitlab-ci.yml` in the root directory of your
    Git repository will automatically enable CI in GitLab and run the pipeline with
    each subsequent commit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述文件保存为`.gitlab-ci.yml`，放在Git存储库的根目录中，将自动在GitLab中启用CI，并在每次提交时运行流水线。
- en: Reviewing code changes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查代码更改
- en: Code reviews can be used both with CI systems and without them. Their main purpose
    is to double-check each change introduced to the code to make sure that it is
    correct, that it fits the application's architecture, and that it follows the
    project's guidelines and best practices.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以在有CI系统和没有CI系统的情况下使用。它们的主要目的是对引入代码的每个更改进行双重检查，以确保其正确性，符合应用程序的架构，并遵循项目的指南和最佳实践。
- en: When used without CI systems, it is often the reviewer's task to test the change
    manually and verify it is working as expected. CI reduces this burden, letting
    software developers focus on the logical structure of the code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有CI系统时，通常是审阅者的任务手动测试更改并验证其是否按预期工作。CI减轻了这一负担，让软件开发人员专注于代码的逻辑结构。
- en: Automated gating mechanisms
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化的门控机制
- en: Automated tests are only one example of a gating mechanism. When their quality
    is high enough, they can guarantee the code works according to design. But there's
    still a difference between code that works correctly and good code. As you've
    learned from this book so far, code can be considered good if it fulfills several
    values. Being functionally correct is just one of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试只是门控机制的一个例子。当它们的质量足够高时，它们可以保证代码按照设计工作。但正确工作的代码和好的代码之间仍然存在差异。从本书到目前为止，您已经了解到，如果代码满足了几个价值观，那么它可以被认为是好的。功能上的正确性只是其中之一。
- en: There are other tools that can help achieve the desired standard of your code
    base. Some of them have been covered in previous chapters, so we won't go into
    the details. Keep in mind that using linters, code formatters, and static analysis
    in your CI/CD pipeline is a great practice. While static analysis can act as a
    gating mechanism, you can apply linting and formatting to each commit that enters
    the central repository to make it consistent with the rest of the code base. You
    will find more on linters and formatters in the appendix.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具可以帮助实现代码基准的期望标准。其中一些在前几章中已经涵盖，所以我们不会详细介绍。请记住，在CI/CD流水线中使用代码检查器、代码格式化程序和静态分析是一个很好的做法。虽然静态分析可以作为一个门控机制，但你可以将代码检查和格式化应用到进入中央存储库的每个提交，以使其与代码库的其余部分保持一致。附录中会有更多关于代码检查器和格式化程序的内容。
- en: Ideally, this mechanism will only have to check whether the code has already
    been formatted, as the formatting step should be done by developers before pushing
    the code to the repository. When using Git as a version control system, the mechanism
    of Git Hooks can prevent committing code without running the necessary tools on
    it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这个机制只需要检查代码是否已经被格式化，因为在将代码推送到存储库之前，开发人员应该完成格式化步骤。当使用Git作为版本控制系统时，Git Hooks机制可以防止在没有运行必要工具的情况下提交代码。
- en: But automated analysis can only get you so far. You can check that the code
    is functionally complete, that it is free of known bugs and vulnerabilities, and
    that it fits within the coding standard. This is where manual inspection comes
    in.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但自动化分析只能帮你解决一部分问题。你可以检查代码是否功能完整，是否没有已知的错误和漏洞，并且是否符合编码标准。这就是手动检查的作用。
- en: Code review – the manual gating mechanism
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查-手动门控机制
- en: Manual inspection of a code change is often known as a code review. The aim
    of the code review is to identify problems, both with the implementation of specific
    subsystems and adherence to the overall architecture of the application. Automated
    performance tests may or may not discover potential problems with a given function.
    Human eyes, on the other hand, can usually spot a sub-optimal solution to the
    problem. Whether it is the wrong data structure or an algorithm with unnecessarily
    high computational complexity, a good architect should be able to pinpoint the
    problem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码更改的手动检查通常被称为代码审查。代码审查的目的是识别问题，包括特定子系统的实现以及对应用程序整体架构的遵循。自动化性能测试可能会或可能不会发现给定功能的潜在问题。另一方面，人眼通常可以发现问题的次优解决方案。无论是错误的数据结构还是计算复杂度过高的算法，一个好的架构师应该能够找出问题所在。
- en: But it isn't just the architect's role to perform code reviews. Peer reviews,
    that is, code reviews performed by peers of the author, also have their place
    in the development process. Such reviews are valuable not just because they allow
    colleagues to find bugs in each other's code. The more important aspect is the
    fact that many teammates are suddenly aware of what everybody else is doing. This
    way, when there is an absence in the team (whether because of a long meeting,
    vacation, or job rotation), another team member can substitute for the missing
    one. Even if they're not an expert on the topic, every other member at least knows
    where the interesting code is located and everyone should be able to remember
    the last changes to the code. This means both the time when they happened and
    the scope and content of those changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但执行代码审查并不仅仅是架构师的角色。同行审查，也就是由作者的同行进行的代码审查，在开发过程中也有其作用。这样的审查之所以有价值，不仅因为它们允许同事发现彼此代码中的错误。更重要的方面是许多队友突然意识到其他人正在做什么。这样，当团队中有人缺席（无论是因为长时间会议、度假还是工作轮换），另一名团队成员可以替补缺席者。即使他们不是该主题的专家，每个成员至少知道有趣的代码位于何处，每个人都应该能够记住代码的最后更改。这意味着它们发生的时间、范围和内容。
- en: With more people aware of how the insides of your application appear, it is
    also more probable that they can figure out a correlation between recent changes
    in one component and a freshly discovered bug. Even though every person on your
    team probably has different experience, they can pool their resources when everyone
    knows the code quite thoroughly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多人意识到应用程序内部的情况，他们更有可能发现一个组件最近的变化和一个新发现的错误之间的关联。即使团队中的每个人可能有不同的经验，但当每个人都非常了解代码时，他们可以共享资源。
- en: So code reviews can check whether the change fits within the desired architecture
    and whether its implementation is correct. We call such a code review an architectural
    review, or an expert's review.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码审查可以检查更改是否符合所需的架构，以及其实现是否正确。我们称这样的代码审查为架构审查或专家审查。
- en: Another type of code review, the peer review, not only helps uncover bugs, but
    also raises awareness within the team about what other members are working on.
    If necessary, you can also perform a different kind of expert review when dealing
    with changes that integrate with external services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的代码审查，同行审查，不仅有助于发现错误，还提高了团队对其他成员正在做什么的意识。如果需要，您还可以在处理与外部服务集成的更改时执行不同类型的专家审查。
- en: As each interface is a source of potential problems, changes close to the interface
    level should be treated as especially dangerous. We advise you to supplement the
    usual peer review with an expert coming from the other side of the interface.
    For example, if you are writing a producer's code, ask a consumer for a review.
    This way, you ensure you won't miss some vital use case that you may consider
    very improbable, but that the other side uses constantly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个接口都是潜在问题的源头，接近接口级别的更改应被视为特别危险。我们建议您将通常的同行审查与来自接口另一侧的专家的审查相结合。例如，如果您正在编写生产者的代码，请向消费者请求审查。这样，您可以确保不会错过一些您可能认为非常不太可能的重要用例，但另一方却经常使用。
- en: Different approaches to a code review
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查的不同方法
- en: You will most often conduct code reviews asynchronously. This means that the
    communication between the author of the change under review and the reviewers
    does not happen in real time. Instead, each of the actors posts their comments
    and suggestions at any given time. Once there are no more comments, the author
    reworks the original change and once again puts it under review. This can take
    as many rounds as necessary until everyone agrees that no further corrections
    are necessary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常会进行异步代码审查。这意味着正在审查的更改的作者和审阅者之间的通信不是实时发生的。相反，每个参与者都可以在任何时间发表他们的评论和建议。一旦没有更多的评论，作者会重新修改原始更改，然后再次进行审查。这可能需要多轮，直到每个人都同意不需要进一步的更正为止。
- en: When a change is particularly controversial and an asynchronous code review
    takes too much time, it is beneficial to conduct a code review synchronously.
    This means a meeting (in-person or remotely) to resolve any opposing views on
    the way forward. This will happen in particular when a change contradicts one
    of the initial decisions due to the new knowledge acquired while implementing
    the change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个更改特别有争议并且异步代码审查需要太长时间时，进行同步代码审查是有益的。这意味着举行一次会议（面对面或远程），解决对未来方向的任何相反意见。这将在特定情况下发生，当一个更改与最初的决定之一相矛盾，因为在实施更改时获得了新的知识。
- en: 'There are some dedicated tools aimed solely at code reviews. More often, you
    will want to use a tool that is built into your repository server, which includes
    services such as the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门针对代码审查的工具。更常见的是，您会希望使用内置到存储库服务器中的工具，其中包括以下服务：
- en: GitHub
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Bitbucket
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bitbucket
- en: GitLab
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab
- en: Gerrit
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gerrit
- en: All of the preceding offer both Git hosting and code review. Some of them go
    even further, providing a whole CI/CD pipeline, issue management, wiki, and much
    more.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都提供Git托管和代码审查。其中一些甚至提供整个CI/CD流水线、问题管理、wiki等等。
- en: When you use the combined package of code hosting and code review, the default
    workflow is to push the changes as a separate branch and then ask the project's
    owner to merge the changes in a process known as a pull request (or a merge request).
    Despite the fancy name, the pull request or merge request informs the project
    owner that you have code that you wish to merge with the main branch. This means
    that the reviewers should review your changes to make sure everything is in order.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用代码托管和代码审查的综合包时，默认工作流程是将更改推送为单独的分支，然后要求项目所有者合并更改，这个过程称为拉取请求（或合并请求）。尽管名字很花哨，但拉取请求或合并请求通知项目所有者，您有代码希望与主分支合并。这意味着审阅者应该审查您的更改，以确保一切都井井有条。
- en: Using pull requests (merge requests) for a code review
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用拉取请求（合并请求）进行代码审查
- en: 'Creating pull requests or merge requests with systems such as GitLab is very
    easy. First of all, when we push a new branch to the central repository from the
    command line, we can observe the following message:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitLab等系统创建拉取请求或合并请求非常容易。首先，当我们从命令行推送新分支到中央存储库时，我们可以观察到以下消息：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you previously had CI enabled (by adding the `.gitlab-ci.yml` file), you'll
    also see that the newly pushed branch has been subjected to the CI process. This
    occurs even before you open a merge request, and it means you can postpone tagging
    your colleagues until you get information from CI that every automated check has
    passed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已启用CI（通过添加`.gitlab-ci.yml`文件），您还会看到新推送的分支已经经过了CI流程。这甚至发生在您打开合并请求之前，这意味着您可以在从CI获得每个自动检查都通过的信息之前推迟通知同事。
- en: 'The two main ways to open a merge request are as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 打开合并请求的两种主要方式如下：
- en: By following the link mentioned in the push message
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按照推送消息中提到的链接
- en: By navigating to merge requests in the GitLab UI and selecting the Create merge
    request button or the New merge request button
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在GitLab UI中导航到合并请求并选择“创建合并请求”按钮或“新合并请求”按钮
- en: When you submit the merge request, having completed all the relevant fields,
    you will see that the status of the CI pipeline is also visible. If the pipeline
    fails, merging the change wouldn't be possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您提交合并请求并填写完所有相关字段时，您会看到CI流水线的状态也是可见的。如果流水线失败，将无法合并更改。
- en: Exploring test-driven automation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索测试驱动的自动化
- en: CI mainly focuses on the integration part. It means building the code of different
    subsystems and making sure it works together. While tests are not strictly required
    to achieve this purpose, running CI without them seems like a waste. CI without
    automated tests makes it easier to introduce subtle bugs to code while giving
    a false sense of security.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: CI主要侧重于集成部分。这意味着构建不同子系统的代码并确保它们可以一起工作。虽然测试不是严格要求实现此目的，但在没有测试的情况下运行CI似乎是一种浪费。没有自动化测试的CI使得更容易向代码引入微妙的错误，同时给人一种虚假的安全感。
- en: That's one of the reasons why CI often goes hand in hand with continuous testing,
    which we'll cover in this next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么CI经常与持续测试紧密结合的原因之一，我们将在下一节中介绍。
- en: Behavior-driven development
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: So far, we have managed to set up a pipeline that we can call continuous building.
    Each change we make to the code ends up being compiled, but we don't test it any
    further. Now it's time to introduce the practice of continuous testing. Testing
    on a low level will also act as a gating mechanism to automatically reject all
    the changes that do not satisfy requirements.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设立了一个可以称之为持续构建的流水线。我们对代码所做的每一次更改最终都会被编译，但我们不会进一步测试它。现在是时候引入持续测试的实践了。在低级别进行测试也将作为一个门控机制，自动拒绝所有不满足要求的更改。
- en: How can you check whether a given change satisfies requirements? This is best
    achieved by writing tests based on these requirements. One of the ways to do this
    is by following **Behavior-Driven Development** (**BDD**). The concept of BDD
    is to encourage deeper collaboration between the different actors in an Agile
    project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何检查给定的更改是否满足要求？最好的方法是根据这些要求编写测试。其中一种方法是遵循**行为驱动开发**（**BDD**）。BDD的概念是鼓励敏捷项目中不同参与者之间更深入的协作。
- en: 'Unlike the traditional approach, where tests are written either by developers
    or the QA team, with BDD, the tests are created collaboratively by the following
    individuals:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统方法不同，传统方法要么由开发人员编写测试，要么由QA团队编写测试，而BDD中，测试是由以下个人共同创建的：
- en: Developers
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员
- en: QA engineers
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA工程师
- en: Business representatives.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务代表。
- en: The most common way to specify tests for BDD is to use the Cucumber framework,
    which uses plain English phrases to describe the desired behavior of any part
    of the system. These sentences follow a specific pattern that can then be turned
    into working code, integrating with the testing framework of choice.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 指定BDD测试的最常见方式是使用Cucumber框架，该框架使用简单的英语短语来描述系统的任何部分的期望行为。这些句子遵循特定的模式，然后可以转换为可工作的代码，与所选的测试框架集成。
- en: 'There is official support for C++ in the Cucumber framework and it''s based
    on CMake, Boost, GTest, and GMock. After specifying the desired behavior in the
    cucumber format (which uses a domain-specific language known as Gherkin), we also
    need to provide the so-called step definitions. Step definitions are the actual
    code corresponding to the actions described in the cucumber specification. For
    example, consider the following behavior expressed in Gherkin:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber框架中有对C++的官方支持，它基于CMake、Boost、GTest和GMock。在以cucumber格式指定所需行为（使用称为Gherkin的领域特定语言）之后，我们还需要提供所谓的步骤定义。步骤定义是与cucumber规范中描述的操作相对应的实际代码。例如，考虑以下以Gherkin表达的行为：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can save it as a `sum.feature` file. In order to generate a valid C++ code
    with tests, we would use the appropriate step definitions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其保存为`sum.feature`文件。为了生成带有测试的有效C++代码，我们将使用适当的步骤定义：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When building an application from scratch, it's a good idea to follow the BDD
    pattern. This book aims to show the best practices you can use in such a greenfield
    project. But it doesn't mean you can't try our examples in an existing project.
    CI and CD can be added at any given time during the life cycle of the project.
    Since it's always a good idea to run your tests as often as possible, using a
    CI system just for the purpose of continuous testing is almost always a good idea.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在从头开始构建应用程序时，遵循BDD模式是一个好主意。本书旨在展示您可以在这样的绿地项目中使用的最佳实践。但这并不意味着您不能在现有项目中尝试我们的示例。在项目的生命周期中的任何时间都可以添加CI和CD。由于尽可能经常运行测试总是一个好主意，因此几乎总是一个好主意仅出于持续测试目的使用CI系统。
- en: If you don't have behavior tests, you shouldn't need to worry. You can add them
    later and, for the moment, just focus on those tests you already have. Whether
    they are unit tests or end-to-end tests, anything that helps you assess the state
    of your application is a good candidate for the gating mechanism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有行为测试，你不需要担心。你可以稍后添加它们，目前只需专注于你已经有的那些测试。无论是单元测试还是端到端测试，任何有助于评估你的应用程序状态的东西都是一个很好的门控机制的候选者。
- en: Writing tests for CI
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为CI编写测试
- en: For CI, it's best to focus on unit tests and integration tests. They work on
    the lowest possible level, which means they're usually quick to execute and have
    the smallest requirements. Ideally, all unit tests should be self-contained (no
    external dependencies like a working database) and able to run in parallel. This
    way, when the problem appears on the level where unit tests are able to catch
    it, the offending code would be flagged in a matter of seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CI来说，最好专注于单元测试和集成测试。它们在可能的最低级别上工作，这意味着它们通常执行速度快，要求最小。理想情况下，所有单元测试应该是自包含的（没有像工作数据库这样的外部依赖）并且能够并行运行。这样，当问题出现在单元测试能够捕捉到的级别时，有问题的代码将在几秒钟内被标记出来。
- en: There are some people who say that unit tests only make sense in interpreted
    languages or languages with dynamic typing. The argument goes that C++ already
    has testing built-in by means of the type system and the compiler checking for
    erroneous code. While it's true that type checking can catch some bugs that would
    require separate tests in dynamically typed languages, this shouldn't be used
    as an excuse not to write unit tests. After all, the purpose of unit tests isn't
    to verify that the code can execute without any problems. We write unit tests
    to make sure our code not only executes, but also fulfills all the business requirements
    we have.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人说单元测试只在解释性语言或动态类型语言中才有意义。论点是C++已经通过类型系统和编译器检查内置了测试。虽然类型检查可以捕捉一些在动态类型语言中需要单独测试的错误，但这不应该成为不编写单元测试的借口。毕竟，单元测试的目的不是验证代码能够无问题地执行。我们编写单元测试是为了确保我们的代码不仅执行，而且还满足我们所有的业务需求。
- en: 'As an extreme example, take a look at the following two functions. Both of
    them are syntactically correct and they use proper typing. However, just by looking
    at them, you can probably guess which one is correct and which isn''t. Unit tests
    help to catch this kind of misbehavior:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个极端的例子，看一下以下两个函数。它们都在语法上是正确的，并且使用了适当的类型。然而，仅仅通过看它们，你可能就能猜出哪一个是正确的，哪一个是错误的。单元测试有助于捕捉这种行为不当：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding function returns a sum of the two arguments provided. The following
    one returns just the value of the first argument:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回提供的两个参数的总和。下一个函数只返回第一个参数的值：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though the types match and the compiler won't complain, this code wouldn't
    perform its task. To distinguish useful code from erroneous code, we use tests
    and assertions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使类型匹配，编译器不会抱怨，这段代码也不能执行其任务。为了区分有用的代码和错误的代码，我们使用测试和断言。
- en: Continuous testing
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续测试
- en: 'Having already established a simple CI pipeline, it is very easy to extend
    it with testing. Since we are already using CMake and CTest for the building and
    testing process, all we need to do is add another step to our pipeline that will
    execute the tests. This step may look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 已经建立了一个简单的CI流水线，非常容易通过测试来扩展它。由于我们已经在构建和测试过程中使用CMake和CTest，我们所需要做的就是在我们的流水线中添加另一个步骤来执行测试。这一步可能看起来像这样：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An entire pipeline will therefore appear as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个流水线将如下所示：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This way, each commit will not only be subjected to the build process, but also
    to testing. If one of the steps fails, we will be notified which one was the source
    of the failure and we could see in the dashboard which steps were successful.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个提交不仅会经历构建过程，还会经历测试。如果其中一个步骤失败，我们将收到通知，知道是哪一个步骤导致了失败，并且可以在仪表板上看到哪些步骤成功了。
- en: Managing deployment as code
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理部署作为代码
- en: With changes tested and approved, now it's time to deploy them to one of the
    operating environments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 经过测试和批准的更改，现在是将它们部署到一个操作环境的时候了。
- en: There are many tools to help with deployment. We decided to provide examples
    with Ansible as this doesn't require any setup on the target machines besides
    a functional Python installation (which the majority of UNIX systems already have
    anyway). Why Ansible? It is very popular in the configuration management space
    and it's backed up by a trustworthy open source company (Red Hat).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以帮助部署。我们决定提供Ansible的示例，因为这不需要在目标机器上进行任何设置，除了一个功能齐全的Python安装（大多数UNIX系统已经有了）。为什么选择Ansible？它在配置管理领域非常流行，并且由一个值得信赖的开源公司（红帽）支持。
- en: Using Ansible
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible
- en: Why not use something that's already available, such as Bourne shell script
    or PowerShell? For simple deployments, shell scripts may be a better approach.
    But as our deployment process becomes more complex, it is much harder to handle
    every possible initial state using the shell's conditional statements.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用已经可用的东西，比如Bourne shell脚本或PowerShell？对于简单的部署，shell脚本可能是一个更好的方法。但是随着我们的部署过程变得更加复杂，使用shell的条件语句来处理每种可能的初始状态就变得更加困难。
- en: Dealing with differences between initial states is actually something Ansible
    is especially good at. Unlike traditional shell scripts, which use the imperative
    form (move this file, edit that file, run a particular command), Ansible playbooks,
    as they are called, use the declarative form (make sure the file is available
    in this path, make sure the file contains specified lines, make sure the program
    is running, make sure the program completes successfully).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 处理初始状态之间的差异实际上是Ansible特别擅长的。与使用命令式形式（移动这个文件，编辑那个文件，运行特定命令）的传统shell脚本不同，Ansible
    playbook（它们被称为）使用声明式形式（确保文件在这个路径上可用，确保文件包含指定的行，确保程序正在运行，确保程序成功完成）。
- en: This declarative approach also helps to achieve idempotence. Idempotence is
    a feature of a function that means applying the function several times over will
    have exactly the same results as a single application. If the first run of an
    Ansible playbook introduces some changes to the configuration, each subsequent
    run will already start in the desired state. This prevents Ansible from performing
    any additional changes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明性的方法也有助于实现幂等性。幂等性是函数的一个特性，意味着多次应用该函数将产生与单次应用完全相同的结果。如果Ansible playbook的第一次运行引入了对配置的一些更改，每次后续运行都将从所需状态开始。这可以防止Ansible执行任何额外的更改。
- en: 'In other words, when you invoke Ansible, it will first assess the current state
    of all the machines you wish to configure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当您调用Ansible时，它将首先评估您希望配置的所有机器的当前状态：
- en: If any of them requires any changes, Ansible will only run the tasks required
    to achieve the desired state.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中任何一个需要进行任何更改，Ansible将只运行所需的任务以实现所需的状态。
- en: If there's no need to modify a particular thing, Ansible won't touch it. Only
    when the desired and actual states differ will you see Ansible taking action to
    converge the actual state toward the desired one described by the contents of
    the playbook.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有必要修改特定的内容，Ansible将不会触及它。只有当所需状态和实际状态不同时，您才会看到Ansible采取行动将实际状态收敛到playbook内容描述的所需状态。
- en: How Ansible fits with the CI/CD pipeline
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible如何与CI/CD流水线配合
- en: Ansible's idempotence makes it a great target to use in CI/CD pipelines. After
    all, there's no risk in running the same Ansible playbook multiple times even
    if nothing changes between the two runs. If you use Ansible for your deployment
    code, creating a CD is just a matter of preparing appropriate acceptance tests
    (such as smoke tests or end-to-end tests).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的幂等性使其成为CI/CD流水线中的一个很好的目标。毕竟，即使两次运行之间没有任何更改，多次运行相同的Ansible playbook也没有风险。如果您将Ansible用于部署代码，创建CD只是准备适当的验收测试（例如冒烟测试或端到端测试）的问题。
- en: The declarative approach may require changing the way you think about deployments,
    but the gains are well worth it. Besides running playbooks, you can also use Ansible
    to perform one-off commands on remote machines, but we won't cover this use case
    as it doesn't really help with deployments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性方法可能需要改变您对部署的看法，但收益是非常值得的。除了运行playbooks，您还可以使用Ansible在远程机器上执行一次性命令，但我们不会涵盖这种用例，因为它实际上对部署没有帮助。
- en: Everything you can do with a shell you can do with Ansible's `shell` module.
    That's because, in the playbooks, you write tasks specifying which modules they
    use and their respective parameters. One such module is the aforementioned `shell`
    module, which simply executes the provided parameters in a shell on a remote machine.
    But what makes Ansible not only convenient but also cross-platform (at least when
    different UNIX distributions are concerned) is the availability of modules to
    manipulate common concepts such as user administration, package management, and
    similar instances.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Ansible的`shell`模块执行与shell相同的操作。这是因为在playbooks中，您编写指定使用哪些模块及其各自参数的任务。其中一个模块就是前面提到的`shell`模块，它只是在远程机器上执行提供的参数。但是，使Ansible不仅方便而且跨平台（至少在涉及不同的UNIX发行版时）的是可以操作常见概念的模块的可用性，例如用户管理、软件包管理和类似实例。
- en: Using components to create deployment code
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件创建部署代码
- en: In addition to the regular modules provided in the standard library, there are
    also third-party components to allow for code reuse. You can test such components
    individually, which also makes your deployment code more robust. Such components
    are called roles. They contain a set of tasks to make a machine fit to take on
    a specific role, such as `webserver`, `db`, or `docker`. While some roles prepare
    the machine to provide particular services, other roles may be more abstract,
    such as the popular `ansible-hardening` role. This has been created by the OpenStack
    team and it makes it much harder to break into a machine secured by using this
    role.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准库中提供的常规模块外，还有第三方组件允许代码重用。您可以单独测试这些组件，这也使您的部署代码更加健壮。这些组件称为角色。它们包含一组任务，使机器适合承担特定角色，例如`webserver`、`db`或`docker`。虽然一些角色准备机器提供特定服务，其他角色可能更抽象，例如流行的`ansible-hardening`角色。这是由OpenStack团队创建的，它使使用该角色保护的机器更难被入侵。
- en: When you start to understand the language Ansible uses, all the playbooks cease
    to be just the scripts. In turn, they will become the documentation of the deployment
    process. You can either use them verbatim by running Ansible, or you can read
    the described tasks and perform all the operations manually, for example, on an
    offline machine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始理解Ansible使用的语言时，所有的playbooks都不再只是脚本。反过来，它们将成为部署过程的文档。您可以通过运行Ansible直接使用它们，或者您可以阅读描述的任务并手动执行所有操作，例如在离线机器上。
- en: There is one risk related to using Ansible for deployment in your team. Once
    you start using it, you have to make sure that everyone on the team is able to
    use it and modify the relevant tasks. DevOps is a practice the whole team has
    to follow; it cannot be implemented only partially. When the application's code
    changes considerably, requiring appropriate changes on the deployment side, the
    person responsible for changes in the application should also supply the changes
    in the deployment code. Of course, this is something that your tests can verify,
    so the gating mechanism can reject the changes that are incomplete.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible进行团队部署的一个风险是，一旦开始使用，您必须确保团队中的每个人都能够使用它并修改相关的任务。DevOps是整个团队必须遵循的一种实践；它不能只部分实施。当应用程序的代码发生相当大的变化，需要在部署方面进行适当的更改时，负责应用程序更改的人也应提供部署代码的更改。当然，这是您的测试可以验证的内容，因此门控机制可以拒绝不完整的更改。
- en: 'One noteworthy aspect of Ansible is that it can run both in a push and pull
    model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的一个值得注意的方面是它可以在推送和拉取模型中运行：
- en: The push model is when you run Ansible on your own machine or in the CI system.
    Ansible then connects to the target machine, for example, over an SSH connection,
    and performs the necessary steps on the target machine.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送模型是当您在自己的机器上或在CI系统中运行Ansible时。然后，Ansible连接到目标机器，例如通过SSH连接，并在目标机器上执行必要的步骤。
- en: In the pull model, the whole process is initiated by the target machine. Ansible's
    component, `ansible-pull`, runs directly on the target machine and checks the
    code repository to establish whether there's been any update to the particular
    branch. After refreshing the local playbook, Ansible performs all the steps as
    usual. This time, both the controlling component and the actual execution happen
    on the same machine. Most of the time, you will want to run `ansible-pull` periodically,
    for example, from within a cron job.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拉模型中，整个过程由目标机器发起。Ansible的组件`ansible-pull`直接在目标机器上运行，并检查代码存储库以确定特定分支是否有任何更新。刷新本地playbook后，Ansible像往常一样执行所有步骤。这一次，控制组件和实际执行都发生在同一台机器上。大多数情况下，您会希望定期运行`ansible-pull`，例如，从cron作业中运行。
- en: Building deployment code
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建部署代码
- en: 'In its simplest form, deployment with Ansible may consist of copying a single
    binary to the target machine and then running that binary. We can achieve this
    with the following Ansible code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，使用Ansible进行部署可能包括将单个二进制文件复制到目标机器，然后运行该二进制文件。我们可以使用以下Ansible代码来实现这一点：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Every single task starts with a hyphen. For each of the tasks, you need to specify
    the module it uses (such as the `copy` module or the `shell` module), along with
    its parameters (if applicable). A task may also have a `name` parameter, which
    makes it easier to reference the task individually.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都以连字符开头。对于每个任务，您需要指定它使用的模块（例如`copy`模块或`shell`模块），以及它的参数（如果适用）。任务还可以有一个`name`参数，这样可以更容易地单独引用任务。
- en: Building a CD pipeline
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CD管道
- en: We have reached the point when we can safely build a CD pipeline using the tools
    we learned about in this chapter. We already know how CI operates and how it helps
    to reject changes that are unsuitable for release. The section on test automation
    presented different ways of making the rejection process more robust. Having smoke
    tests or end-to-end tests allows us to go beyond CI and to check whether the whole
    deployed service satisfies requirements. And with deployment code, we can not
    only automate the process of deployment, but also prepare a rollback when our
    tests begin to fail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到了可以安全地使用本章学到的工具构建CD管道的地步。我们已经知道CI是如何运作的，以及它如何帮助拒绝不适合发布的更改。测试自动化部分介绍了使拒绝过程更加健壮的不同方法。拥有冒烟测试或端到端测试使我们能够超越CI，并检查整个部署的服务是否满足要求。并且有了部署代码，我们不仅可以自动化部署过程，还可以在我们的测试开始失败时准备回滚。
- en: Continuous deployment and continuous delivery
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署和持续交付
- en: By a funny coincidence, the abbreviation CD can mean two different things. The
    concepts of continuous delivery and Continuous deployment are pretty similar,
    but they have some subtle differences. Throughout the book, we are focusing on
    the concept of continuous deployment. This is the automated process that originates
    when a person pushes a change into the central repository and finishes with the
    change successfully deployed to the production environment with all the tests
    passing. We can therefore say that this is an end-to-end process as the developer's
    work travels all the way to the customer without manual intervention (following
    the code review, of course). You may have heard the term GitOps to relate to such
    an approach. As all operations are automated, pushing to a specified branch in
    Git triggers the deployment scripts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 出于有趣的巧合，CD的缩写可以有两种不同的含义。持续交付和持续部署的概念非常相似，但它们有一些细微的差异。在整本书中，我们专注于持续部署的概念。这是一个自动化的过程，当一个人将更改推送到中央存储库时开始，并在更改成功部署到生产环境并通过所有测试时结束。因此，我们可以说这是一个端到端的过程，因为开发人员的工作可以在没有手动干预的情况下一直传递到客户那里（当然，要经过代码审查）。您可能听说过GitOps这个术语来描述这种方法。由于所有操作都是自动化的，将更改推送到Git中的指定分支会触发部署脚本。
- en: Continuous delivery doesn't go that far. Like CD, it features a pipeline able
    to release the final product and test it, but the final product is never automatically
    delivered to the customers. It can be delivered to the QA first or to the business
    for internal use. Ideally, the delivered artifact is ready to be deployed in the
    production environment as soon as the internal clients accept it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付并不会走得那么远。与CD一样，它具有能够发布最终产品并对其进行测试的管道，但最终产品永远不会自动交付给客户。它可以首先交付给QA或用于内部业务。理想情况下，交付的构件准备好在内部客户接受后立即部署到生产环境中。
- en: Building an example CD pipeline
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个示例CD管道
- en: Let's put all of these skills together once again using the GitLab CI as an
    example to build our pipeline. Following the testing step, we will add two more
    steps, one that creates the package and another one that uses Ansible to deploy
    this package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次将所有这些技能结合起来，以GitLab CI作为示例来构建我们的管道。在测试步骤之后，我们将添加另外两个步骤，一个用于创建包，另一个用于使用Ansible部署此包。
- en: 'All we need for the packaging step is the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打包步骤所需的全部内容如下：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we add the package step containing artifacts definitions, we'll be able
    to download them from the dashboard.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加包含构件定义的包步骤时，我们将能够从仪表板下载它们。
- en: 'With this, we can invoke Ansible as part of the deployment step:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以将Ansible作为部署步骤的一部分来调用：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final pipeline would then look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的管道将如下所示：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To see the whole example, go to the repository from the *Technical requirements*
    section for the original sources.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看整个示例，请转到原始来源的*技术要求*部分的存储库。
- en: Using immutable infrastructure
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变基础设施
- en: If you are sufficiently confident with your CI/CD pipeline, you may go one step
    further. Instead of deploying artifacts of the application, you can deploy artifacts
    of the *system*. What's the difference? We will come to know about this in the
    following sections.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对CI/CD流水线足够自信，您可以再走一步。您可以部署*系统*的构件，而不是应用程序的构件。有什么区别？我们将在以下部分了解到。
- en: What is immutable infrastructure?
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是不可变基础设施？
- en: Previously, we focused on how to make your application's code deployable on
    the target infrastructure. The CI system created software packages (such as containers)
    and those packages were then deployed by the CD process. Each time the pipeline
    ran, the infrastructure stayed the same, but the software differed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们关注的是如何使应用程序的代码可以部署到目标基础设施上。CI系统创建软件包（如容器），然后CD流程部署这些软件包。每次流水线运行时，基础设施保持不变，但软件不同。
- en: The point is, if you are using cloud computing, you can treat infrastructure
    just like any other artifact. Instead of deploying a container, you can deploy
    an entire **Virtual Machine** (**VM**), for example, as an AWS EC2 instance. You
    can build such a VM image upfront as yet another element of your CI process. This
    way, versioned VM images, as well as the code required to deploy them, become
    your artifacts, and not the containers themselves.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是，如果您使用云计算，您可以将基础设施视为任何其他构件。例如，您可以部署整个**虚拟机**（**VM**），作为AWS EC2实例的构件，而不是部署容器。您可以预先构建这样的VM镜像作为CI流程的另一个构件。这样，版本化的VM镜像以及部署它们所需的代码成为您的构件，而不是容器本身。
- en: 'There are two tools, both authored by HashiCorp, that deal with precisely this
    scenario. Packer helps to create VM images in a repeatable way, storing all the
    instructions as code, usually in the form of a JSON file. Terraform is an Infrastructure
    as Code tool, which means it''s used to provision all the necessary infrastructure
    resources. We will use the output from Packer as input for Terraform. This way,
    Terraform will create an entire system consisting of the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个工具，都由HashiCorp编写，处理这种情况。Packer帮助以可重复的方式创建VM镜像，将所有指令存储为代码，通常以JSON文件的形式。Terraform是一个基础设施即代码工具，这意味着它用于提供所有必要的基础设施资源。我们将使用Packer的输出作为Terraform的输入。这样，Terraform将创建一个包含以下内容的整个系统：
- en: Instance groups
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例组
- en: Load balancers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: VPCs
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPC
- en: Other cloud elements while using the VMs containing our own code
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他云元素，同时使用包含我们自己代码的VM
- en: The title of this section may confuse you. Why is it called **immutable infrastructure**
    while we are clearly advocating to change the entire infrastructure after every
    commit? The concept of immutability may be clearer to you if you've studied functional
    languages.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的标题可能会让您感到困惑。为什么它被称为**不可变基础设施**，而我们明显是在提倡在每次提交后更改整个基础设施？如果您学过函数式语言，不可变性的概念可能对您更清晰。
- en: 'A mutable object is one whose state we can alter. In infrastructure, this is
    pretty easy to understand: you can log in to the VM and download a more recent
    version of the code. The state is no longer the same as it was prior to your intervention.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象是其状态可以改变的对象。在基础设施中，这很容易理解：您可以登录到虚拟机并下载更近期的代码。状态不再与您干预之前相同。
- en: An immutable object is one whose state we cannot alter. It means we have no
    means of logging in to the machines and changing things. Once we deploy a VM from
    an image, it stays like that until we destroy it. This may sound terribly cumbersome,
    but in fact, it solves a few problems of software maintenance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象是其状态我们无法改变的对象。这意味着我们无法登录到机器上并更改东西。一旦我们从镜像部署了虚拟机，它就会保持不变，直到我们销毁它。这听起来可能非常麻烦，但实际上，它解决了软件维护的一些问题。
- en: The benefits of immutable infrastructure
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变基础设施的好处
- en: 'First of all, immutable infrastructure makes the concept of configuration drift
    obsolete. There is no configuration management so there can also be no drift.
    The upgrade is much safer as well because we cannot end up in a half-baked state.
    That is the state that''s neither the previous version nor the next version, but
    something in between. The deployment process provides binary information: either
    the machine is created and operational or it isn''t. There''s no other way.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不可变基础设施使配置漂移的概念过时。没有配置管理，因此也不会有漂移。升级也更安全，因为我们不会陷入一个半成品状态。这是既不是上一个版本也不是下一个版本，而是介于两者之间的状态。部署过程提供了二进制信息：机器要么被创建并运行，要么没有。没有其他方式。
- en: 'For immutable infrastructure to work without affecting uptime, you also need
    the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使不可变基础设施在不影响正常运行时间的情况下工作，您还需要以下内容：
- en: Load balancing
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Some degree of redundancy
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定程度的冗余
- en: After all, the upgrade process consists of taking down an entire instance. You
    cannot rely on this machine's address or anything that's particular to that one
    machine. Instead, you need to have at least a second one that will handle the
    workload while you replace the other one with the more recent version. When you
    finish upgrading the one machine, you can repeat the same process with another
    one. This way, you will have two upgraded instances without losing the service.
    Such a strategy is known as the rolling upgrade.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，升级过程包括关闭整个实例。您不能依赖于这台机器的地址或任何特定于该机器的东西。相反，您需要至少有第二个机器来处理工作负载，同时用更近期的版本替换另一个机器。当您完成升级一个机器后，您可以重复相同的过程。这样，您将有两个升级的实例而不会丢失服务。这种策略被称为滚动升级。
- en: As you can realize from the process, immutable infrastructure works best when
    dealing with stateless services. When your service has some form of persistence,
    things become tougher to implement properly. In that case, you usually have to
    split the persistence level into a separate object, for example, an NFS volume
    containing all of the application data. Such volumes can be shared across all
    the machines in an instance group and each new machine that comes up can access
    the common state left by the previous running applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个过程中，您可以意识到，当处理无状态服务时，不可变基础架构效果最佳。当您的服务具有某种持久性时，正确实施变得更加困难。在这种情况下，通常需要将持久性级别拆分为一个单独的对象，例如，包含所有应用程序数据的NFS卷。这些卷可以在实例组中的所有机器之间共享，并且每个新机器上线时都可以访问之前运行应用程序留下的共同状态。
- en: Building instance images with Packer
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Packer构建实例镜像
- en: Considering our example application is already stateless, we can proceed with
    building an immutable infrastructure on top of it. Since the artifacts Packer
    generates are VM images, we have to decide on the format and the builder we would
    like to use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的示例应用程序已经是无状态的，我们可以继续在其上构建一个不可变的基础架构。由于Packer生成的工件是VM镜像，我们必须决定要使用的格式和构建器。
- en: 'Let''s focus our example on Amazon Web Services, while keeping in mind that
    a similar approach will also work with other supported providers. A simple Packer
    template may look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于Amazon Web Services的示例，同时牢记类似的方法也适用于其他支持的提供者。一个简单的Packer模板可能如下所示：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code will build an image for Amazon Web Services using the EBS
    builder. The image will reside in `eu-central-1` region and will be based on `ami-5900cc36`,
    which is a Debian Jessie image. We want the builder to be a `t2.micro` instance
    (that's a VM size in AWS). To prepare our image, we run the two `apt-get` commands.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使用EBS构建器为Amazon Web Services构建一个镜像。该镜像将驻留在`eu-central-1`地区，并将基于`ami-5900cc36`，这是一个Debian
    Jessie镜像。我们希望构建器是一个`t2.micro`实例（这是AWS中的VM大小）。为了准备我们的镜像，我们运行两个`apt-get`命令。
- en: 'We can also reuse the previously defined Ansible code and, instead of using
    Packer to provision our application, we can substitute Ansible as the provisioner.
    Our code will appear as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以重用先前定义的Ansible代码，而不是使用Packer来配置我们的应用程序，我们可以将Ansible替换为provisioner。我们的代码将如下所示：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The changes are in the `provisioners` block and also a new block, `post-processors`,
    is added. This time, instead of shell commands, we are using a different provisioner
    that runs Ansible for us. The post-processor is here to produce the results of
    the build in a machine-readable format. Once Packer finishes building the desired
    artifact, it returns its ID and also saves it in `manifest.json`. For AWS, this
    would mean an AMI ID that we can then feed to Terraform.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 更改在`provisioners`块中，还添加了一个新的块`post-processors`。这一次，我们不再使用shell命令，而是使用一个运行Ansible的不同的provisioner。后处理器用于以机器可读的格式生成构建结果。一旦Packer完成构建所需的工件，它会返回其ID，并将其保存在`manifest.json`中。对于AWS来说，这意味着一个AMI
    ID，然后我们可以将其提供给Terraform。
- en: Orchestrating the infrastructure with Terraform
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Terraform编排基础架构
- en: Creating an image with Packer is the first step. After that, we would like to
    deploy the image to use it. We can build an AWS EC2 instance based on the image
    from our Packer template using Terraform.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Packer创建镜像是第一步。之后，我们希望部署该镜像以使用它。我们可以使用Terraform基于我们的Packer模板中的镜像构建一个AWS EC2实例。
- en: 'Example Terraform code would look like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例Terraform代码如下所示：
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a key pair and an EC2 instance using this key pair. The EC2 instance
    is based on AMI provided as a variable. When calling Terraform, we will set this
    variable to point to the image generated by Packer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个密钥对和一个使用此密钥对的EC2实例。EC2实例基于作为变量提供的AMI。在调用Terraform时，我们将设置此变量指向Packer生成的镜像。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: By now, you should have learned how implementing CI at the beginning of the
    project can help you save time in the long run. It can also reduce work in progress,
    especially when paired with CD. In this chapter, we've presented useful tools
    that can help you implement both of the processes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经了解到，在项目开始阶段实施CI如何帮助您节省长期时间。尤其是与CD配对时，它还可以减少工作进展。在本章中，我们介绍了一些有用的工具，可以帮助您实施这两个过程。
- en: We've shown how GitLab CI allows us to write pipelines in YAML files. We've
    discussed the importance of code review and explained the differences between
    the various forms of code review. We've introduced Ansible, which assists in configuration
    management and the creation of deployment code. Finally, we tried Packer and Terraform
    to move our focus from creating applications to creating systems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了GitLab CI如何让我们在YAML文件中编写流水线。我们已经讨论了代码审查的重要性，并解释了各种形式的代码审查之间的区别。我们介绍了Ansible，它有助于配置管理和部署代码的创建。最后，我们尝试了Packer和Terraform，将我们的重点从创建应用程序转移到创建系统。
- en: 'The knowledge in this chapter is not unique to the C++ language. You can use
    it in projects written in any language using any technology. The important thing
    that you should keep in mind is this: all applications require testing. A compiler
    or a static analyzer is not enough to validate your software. As an architect,
    you would also have to take into account not only your project (the application
    itself), but also the product (the system your application will work in). Delivering
    working code is no longer sufficient. Understanding the infrastructure and the
    process of deployment is crucial as they are the new building blocks of modern
    systems.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的知识并不局限于C++语言。您可以在使用任何技术编写的任何语言的项目中使用它。您应该牢记的重要事情是：所有应用程序都需要测试。编译器或静态分析器不足以验证您的软件。作为架构师，您还必须考虑的不仅是您的项目（应用程序本身），还有产品（您的应用程序将在其中运行的系统）。仅交付可工作的代码已不再足够。了解基础架构和部署过程至关重要，因为它们是现代系统的新构建模块。
- en: The next chapter is focused on the security of the software. We will cover the
    source code itself, the operating system level, and the possible interactions
    with external services as well as with end users.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于软件的安全性。我们将涵盖源代码本身、操作系统级别以及与外部服务和最终用户的可能交互。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In what ways does CI save time during development?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI在开发过程中如何节省时间？
- en: Do you require separate tools to implement CI and CD?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您是否需要单独的工具来实施CI和CD？
- en: When does it make sense to perform a code review in a meeting?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在会议中进行代码审查有何意义？
- en: What tools can you use to assess the quality of your code during CI?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CI期间，您可以使用哪些工具来评估代码的质量？
- en: Who participates in specifying the BDD scenarios?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁参与指定BDD场景？
- en: When would you consider using immutable infrastructure? When would you rule
    it out?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下会考虑使用不可变基础设施？在什么情况下会排除它？
- en: How would you characterize the differences between Ansible, Packer, and Terraform?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何描述Ansible、Packer和Terraform之间的区别？
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Continuous integration/continuous deployment/continuous delivery:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成/持续部署/持续交付：
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/hands-continuous-integration-and-delivery)'
- en: '[https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery](https://www.packtpub.com/virtualization-and-cloud/cloud-native-continuous-integration-and-delivery)'
- en: 'Ansible:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible：
- en: '[https://www.packtpub.com/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/virtualization-and-cloud/mastering-ansible-third-edition)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/mastering-ansible-third-edition](https://www.packtpub.com/virtualization-and-cloud/mastering-ansible-third-edition)'
- en: '[https://www.packtpub.com/application-development/hands-infrastructure-automation-ansible-video](https://www.packtpub.com/application-development/hands-infrastructure-automation-ansible-video)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/hands-infrastructure-automation-ansible-video](https://www.packtpub.com/application-development/hands-infrastructure-automation-ansible-video)'
- en: 'Terraform:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform：
- en: '[https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition](https://www.packtpub.com/networking-and-servers/getting-started-terraform-second-edition)'
- en: '[https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video](https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video](https://www.packtpub.com/big-data-and-business-intelligence/hands-infrastructure-automation-terraform-aws-video)'
- en: 'Cucumber:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄瓜：
- en: '[https://www.packtpub.com/web-development/cucumber-cookbook](https://www.packtpub.com/web-development/cucumber-cookbook)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/web-development/cucumber-cookbook](https://www.packtpub.com/web-development/cucumber-cookbook)'
- en: 'GitLab:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab：
- en: '[https://www.packtpub.com/virtualization-and-cloud/gitlab-quick-start-guide](https://www.packtpub.com/virtualization-and-cloud/gitlab-quick-start-guide)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/virtualization-and-cloud/gitlab-quick-start-guide](https://www.packtpub.com/virtualization-and-cloud/gitlab-quick-start-guide)'
- en: '[https://www.packtpub.com/application-development/hands-auto-devops-gitlab-ci-video](https://www.packtpub.com/application-development/hands-auto-devops-gitlab-ci-video)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/hands-auto-devops-gitlab-ci-video](https://www.packtpub.com/application-development/hands-auto-devops-gitlab-ci-video)'
