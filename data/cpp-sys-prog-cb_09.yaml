- en: Dealing with Time Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时间接口
- en: 'Time is used in several forms in operating systems and applications. Typically, applications
    need to deal with the following **categories** of time:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 时间在操作系统和应用程序中以多种形式使用。通常，应用程序需要处理以下**时间类别**：
- en: '**Clock**: The actual time and date, as you would read on your watch'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟**：实际的时间和日期，就像您手表上读到的那样'
- en: '**Time point**: Processing time taken to profile, monitor, and troubleshoot
    an application''s usage (for example, a processor or resource in general)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间点**：用于对应用程序的使用情况（例如处理器或资源）进行分析、监视和故障排除所花费的处理时间'
- en: '**Duration**: Monotonic time, that is, the elapsed time for a certain event'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续时间**：单调时间，即某个事件的经过时间'
- en: In this chapter, we'll deal with all these aspects from both a C++ and POSIX
    point of view in order so that you have more tools available in your toolbox.
    The recipes in this chapter will teach you how to measure an event by using time
    points and why you should use a steady clock for that, as well as when the time
    overruns and how to mitigate it. You'll learn how to implement these concepts
    with both POSIX and C++ `std::chrono`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将从C++和POSIX的角度处理所有这些方面，以便您在工具箱中有更多可用的工具。本章的示例将教您如何使用时间点来测量事件，以及为什么应该使用稳定的时钟，以及时间超出限制的情况以及如何减轻它。您将学习如何使用POSIX和C++
    `std::chrono`来实现这些概念。
- en: 'This chapter will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Learning about the C++ time interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习C++时间接口
- en: Using the C++20 calendar and time zone
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++20日历和时区
- en: Learning about Linux timing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Linux时间
- en: Dealing with time sleep and overruns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间休眠和超出限制
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To try out the programs in this chapter immediately, we've set up a Docker image that
    contains all the tools and libraries we'll need throughout this book. It is based
    on Ubuntu 19.04.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要立即尝试本章中的程序，我们已经设置了一个包含本书所需的所有工具和库的Docker镜像。它基于Ubuntu 19.04。
- en: 'In order to set it up, follow these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，按照以下步骤进行：
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](https://www.docker.com/)下载并安装Docker Engine。
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像现在应该可用。输入以下命令查看镜像：`docker images`。
- en: You should have the following image: `kasperondocker/system_programming_cookbook`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该有以下镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell with the help of the `docker
    run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash` command.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`命令以交互式shell运行Docker镜像。
- en: The shell on the running container is now available. Go to `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that will be developed in this book.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。转到`root@39a5a8934370/# cd /BOOK/`以获取本书中将开发的所有程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow **GDB** (short for **GNU
    Project Debugger**) to set breakpoints, which Docker doesn't allow by default.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--cap-add sys_ptrace`参数以允许**GDB**（GNU项目调试器的缩写）设置断点，Docker默认情况下不允许。
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：C++20标准已经在二月底的布拉格的WG21会议上获得批准（即技术上已经最终确定）。这意味着本书使用的GCC编译器版本8.3.0不包括（或者对C++20的新功能支持非常有限）。因此，Docker镜像不包括C++20示例代码。GCC将最新功能的开发保留在分支中（您必须使用适当的标志，例如`-std=c++2a`）；因此，鼓励您自行尝试。因此，请克隆并探索GCC合同和模块分支，并尽情享受。'
- en: Learning about the C++ time interface
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习C++时间接口
- en: The C++11 standard really marks an important step regarding time. Before that
    (C++ standard 98 and before), system and application developers had to rely on
    implementation-specific APIs (that is, POSIX) or external libraries (for example, `boost`)
    to manipulate **time**, which means less portable code. This recipe will teach
    you how to write C++ code by using the standard time manipulation library.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准确实标志着时间方面的重要进展。在此之前（C++标准98及之前），系统和应用程序开发人员必须依赖于特定于实现的API（即POSIX）或外部库（例如`boost`）来操作**时间**，这意味着代码的可移植性较差。本示例将教您如何使用标准时间操作库编写C++代码。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s write a program to learn about the concepts of **clock**, **time point**,
    and **duration**, as supported in the C++ standards:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来学习C++标准中支持的**时钟**、**时间点**和**持续时间**的概念：
- en: 'Create a new file and call it `chrono_01.cpp`. We need a few includes first:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其命名为`chrono_01.cpp`。首先我们需要一些包含：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `main` part, we need something to measure, so let''s populate an `std::vector`
    with some integers:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`部分，我们需要一些东西来测量，所以让我们用一些整数填充一个`std::vector`：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the two time points, `start` and `end`, let''s calculate the
    difference (that is, duration) and print it to see how long it took:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了两个时间点`start`和`end`，让我们计算差异（即持续时间）并打印出来看看花了多长时间：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we want to print the `start` variable in another format; for example,
    in the format of calendar local time with `ctime`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想以另一种格式打印`start`变量；例如，以`ctime`的日历本地时间格式：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program uses a few of the `std::chrono` features, such as `system_clock`,
    `time_point`, and duration available in the Standard Library, and has done since
    version 11 of the C++ standard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用了一些`std::chrono`的特性，比如标准库中可用的`system_clock`、`time_point`和持续时间，并且自C++标准的第11版以来一直在使用。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '*Step 1* takes care of including the headers we''ll need later: `<iostream>`
    for the standard output and `<vector>` and `<chrono>` for the time.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*负责包含我们稍后需要的头文件：`<iostream>`用于标准输出，`<vector>`和`<chrono>`用于时间。'
- en: '*Step 2* defines a vector of **int called elements**. Due to this, we can call
    the `now()` method on the `system_clock` class in the `chrono` namespace to get
    the current time. Although we used `auto`, this method returns a `time_point`
    object representing a point in time. Then, we looped over 100 million times to
    populate the `elements` array in order to highlight that we used the new C++14
    feature to represent *100,000,000*, which improves the readability of the code.
    At the end, we took another point in time by calling the `now()` method and storing
    the `time_point` object in the `end` variable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*定义了一个名为`elements`的**int类型的向量**。由于这个，我们可以在`chrono`命名空间中的`system_clock`类上调用`now()`方法来获取当前时间。虽然我们使用了`auto`，这个方法返回一个表示时间点的`time_point`对象。然后，我们循环了1亿次来填充`elements`数组，以突出我们使用了新的C++14特性来表示*100,000,000*，这提高了代码的可读性。最后，我们通过调用`now()`方法并将`time_point`对象存储在`end`变量中来获取另一个时间点。'
- en: 'In *step 3*, we looked at how long it took to execute the loop. To calculate
    this, we instantiated a `duration` object, which is a template class that needs
    two parameters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们看了执行循环需要多长时间。为了计算这个时间，我们实例化了一个`duration`对象，它是一个需要两个参数的模板类：
- en: '**The representation**: A type representing the number of ticks.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示**：表示滴答数的类型。'
- en: '**The period**: This can be (among other things) `std::nano`, `std:micro`,
    `std::milli`, and so on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期**：这可以是（等等）`std::nano`、`std:micro`、`std::milli`等。'
- en: The default value for the period is `std::seconds`. Then, we just write `diff.cout()` on
    the standard output, which represents the number of milliseconds between `start`
    and `end`. An alternative way of calculating this difference is by using `duration_cast`;
    for example, `std::chrono::duration_cast<std::chrono::milliseconds> (end-start).count()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 周期的默认值是`std::seconds`。然后，我们只需在标准输出上写`diff.cout()`，它表示`start`和`end`之间的毫秒数。计算这种差异的另一种方法是使用`duration_cast`；例如，`std::chrono::duration_cast<std::chrono::milliseconds>
    (end-start).count()`。
- en: In *step 4,* we print the `start` and `end` `time_point` variables in calendar
    `localtime` representation (note that the container time might not be in sync
    with the host container). To do this, we need to convert them into `time_t` by
    using the `to_time_t()` static variable of the `system_clock` class and then pass
    them to the `std::ctime` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们以日历`localtime`表示打印`start`和`end`的`time_point`变量（注意，容器时间可能与主机容器不同步）。为了做到这一点，我们需要通过使用`system_clock`类的`to_time_t()`静态变量将它们转换为`time_t`，然后将它们传递给`std::ctime`方法。
- en: 'Now, let''s build and run this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行这个：
- en: '![](img/b733171a-695f-4db6-b3ae-eab79b55b5d8.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b733171a-695f-4db6-b3ae-eab79b55b5d8.png)'
- en: We'll learn a bit more about this recipe in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更多地了解这个示例。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The program we developed uses the `system_clock` class. There are three clock
    classes in the `chrono` namespace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的程序使用了`system_clock`类。在`chrono`命名空间中有三个时钟类：
- en: '`system_clock`: This represents the so-called **wall clock time***.* It can
    be adjusted at any moment, such as when an additional imprecision is introduced
    through a leap second or the user has just set it. Its epoch (that is, its starting
    point), in most implementations, uses UNIX time, which means the start counts
    from 1^(st) January 1970.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_clock`：这代表了所谓的**挂钟时间**。它可以在任何时刻被调整，比如当通过闰秒引入额外的不精确性或用户刚刚设置它时。在大多数实现中，它的纪元（即其起点）使用UNIX时间，这意味着起点从1970年1月1日开始计数。'
- en: '`steady_clock`: This represents the so-called **monotonic clock**. It''ll never
    be adjusted. It remains steady. In most implementations, its starting point is
    the time when the machine boots. For calculating the elapsed time of a certain
    event, you should consider using this type of clock.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steady_clock`：这代表了所谓的**单调时钟**。它永远不会被调整。它保持稳定。在大多数实现中，它的起点是机器启动时的时间。为了计算某个事件的经过时间，你应该考虑使用这种类型的时钟。'
- en: '`high_resolution_clock`: This is the clock with the shortest tick available.
    It might just be an alias for the `system_clock` or `steady_clock` or a completely
    different implementation. It is implementation-defined.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`high_resolution_clock`：这是可用最短滴答的时钟。它可能只是`system_clock`或`steady_clock`的别名，或者是一个完全不同的实现。这是由实现定义的。'
- en: A second aspect to keep in mind is that the C++20 standard includes `time_of_day`,
    calendar, and time zone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要记住的方面是，C++20标准包括了`time_of_day`、日历和时区。
- en: See also
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning the Linux timing* recipe for a brief comparison
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Linux时间*的简要比较'
- en: '*A Tour of C++, Second Edition,* by Bjarne Stroustrup'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bjarne Stroustrup的《C++之旅，第二版》*'
- en: Using the C++20 calendar and time zone
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++20日历和时区
- en: The C++20 standard has enriched the `std::chrono` namespace with calendar features.
    They include all the typical features you would expect, plus a more idiomatic
    and intuitive way of playing with it. This recipe will teach you about some of
    the most important features and how simple it is to interact with the calendar
    section of the `std::chrono` namespace.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准丰富了`std::chrono`命名空间的日历功能。它们包括你所期望的所有典型功能，以及一种更成语化和直观的玩法。这个示例将教你一些最重要的功能，以及如何与`std::chrono`命名空间的日历部分交互是多么简单。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look at some code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些代码：
- en: 'Create a new file, ensuring that you include `<chrono>` and `<iostream>`. We
    have a date and we want to know what day of the week `bday` will fall on:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，确保你包含了`<chrono>`和`<iostream>`。我们有一个日期，我们想知道`bday`会在星期几。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There''s a whole set of classes that allow you to play with the calendar. Let''s
    take a look at some of them:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一整套类可以让您玩转日历。让我们来看看其中一些：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s play with the time zone and print a list of times for different time
    zones:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们玩玩时区，并打印不同时区的时间列表：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One feature that''s used often is used to find the difference between two time
    zones:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个经常使用的功能是用于找到两个时区之间的差异：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's go a little deeper into the `std::chrono` calendar section to learn more
    about this recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`std::chrono`日历部分，以了解更多关于这个示例的内容。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a lot of calendar and time zone helper functions available in the
    new C++20 standard. This recipe just scratched the surface, but still gives us
    an understanding of how easy it is to deal with time. A reference for all the
    `std::chrono` calendar and time zone capabilities can be found at [https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的C++20标准中有许多日历和时区辅助函数可用。这个示例只是触及了表面，但仍然让我们了解了处理时间是多么容易。`std::chrono`日历和时区功能的参考可以在[https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono)上找到。
- en: '*Step 1* uses the `weekday` method to get the day of the week (using the Gregorian
    calendar). Before calling the `weekday` method, we need to get a specific day
    and with C++20, we can just set `auto bday = January/30/2021`, which represents
    a date. Now, we can pass it to the `weekday` method to get the specific day of
    the week, which in our case is Saturday. One useful property is that we can compare
    dates, just like we can compare between the `bday` and `anotherDay` variables.
    `weekday`, as well as all the other `std::chrono` calendar methods, handles leap
    seconds.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*使用`weekday`方法来获取一周的日期（使用公历）。在调用`weekday`方法之前，我们需要获取一个特定的日期，使用C++20，我们可以直接设置`auto
    bday = January/30/2021`，这代表一个日期。现在，我们可以将其传递给`weekday`方法来获取特定的一周日期，在我们的例子中是星期六。一个有用的属性是我们可以比较日期，就像我们可以在`bday`和`anotherDay`变量之间进行比较。`weekday`以及所有其他`std::chrono`日历方法都处理闰秒。'
- en: '*Step 2* shows the use of the `year_month_day` and `year_month_day_last` methods.
    The library contains a whole set of classes similar to these two, for example, `month_day`
    and `month_day_lat`, and so on. They clearly have a different scope, but their
    principles remain the same. In this step, we''re interested in knowing the last
    day of February. We set the current date in the `today` variable with the `year_month_day{
    floor<days>(system_clock::now()) }` and then we pass `today` to the `year_month_day_last`
    method, which will return something like `2020/02/last`, which we store in the
    `ymdl` variable. We can use the `year_month_day` method again to get the last
    day of February. We can skip a few steps and call the `year_month_day_last` method
    directly. We performed this step for educational purposes.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*展示了`year_month_day`和`year_month_day_last`方法的使用。该库包含了一整套类似于这两个方法的类，例如`month_day`和`month_day_lat`等等。它们显然有不同的范围，但原则仍然相同。在这一步中，我们对二月的最后一天感兴趣。我们使用`year_month_day{
    floor<days>(system_clock::now()) }`将当前日期设置在`today`变量中，然后将`today`传递给`year_month_day_last`方法，它将返回类似`2020/02/last`的内容，我们将其存储在`ymdl`变量中。我们可以再次使用`year_month_day`方法来获取二月的最后一天。我们可以跳过一些步骤，直接调用`year_month_day_last`方法。我们进行这一步是为了教育目的。'
- en: '*Step 3* moves into the scope of time zones. The snippet of code in this step
    prints a list of time zones by iterating over the `zone_names` array. Here, we
    got the `localtime` first by looping over each time zone identified by a string.
    Then, we converted the `localtime` into the time zone that was identified by the
    `name` variable using the `zoned_time` method.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*进入时区范围。此步骤中的代码片段通过迭代`zone_names`数组打印出一个时区列表。在这里，我们首先通过循环遍历每个由字符串标识的时区来获取`localtime`。然后，我们使用`zoned_time`方法将`localtime`转换为由`name`变量标识的时区。'
- en: 'In *step 4*, we covered an interesting and recurrent problem: finding the time
    difference between two time zones. The principle doesn''t change; we still use
    the `zoned_time` method to get the local time of the two time zones, which in
    this case are `"America/New_York"` and `"Europe/London"`. Then, we subtract the
    two local times to get the difference.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们涵盖了一个有趣且经常发生的问题：找到两个时区之间的时间差。原则没有改变；我们仍然使用`zoned_time`方法来获取两个时区的本地时间，这些时区在这种情况下是`"America/New_York"`和`"Europe/London"`。然后，我们减去两个本地时间以获取差异。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `std::chrono` calendar offers a wide variety of methods that you are invited
    to explore. A complete list is available at [https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono`日历提供了各种各样的方法，欢迎您去探索。完整的列表可以在[https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono)上找到。'
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*A Tour of C++, Second Edition*, by Bjarne Stroustrup, *Chapter 13.7, Time*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++之旅，第二版》，作者Bjarne Stroustrup，第13.7章，时间
- en: Learning the Linux timing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Linux时间。
- en: Before C++11, the Standard Library did not contain any direct time-management support,
    so system developers had to use *external* sources. By external, we mean either
    an external library (for example, Boost ([https://www.boost.org/](https://www.boost.org/))) or
    OS-specific APIs. We believe it's necessary that a system developer understands
    the concept of time in terms of Linux. This recipe will help you master concepts
    such as **clock**, **time point**, and **duration** by using the POSIX standard.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，标准库没有包含任何直接的时间管理支持，因此系统开发人员必须使用*外部*来源。所谓外部，指的是外部库（例如Boost ([https://www.boost.org/](https://www.boost.org/)））或特定于操作系统的API。我们认为系统开发人员有必要了解Linux中的时间概念。这个示例将帮助您掌握**时钟**、**时间点**和**持续时间**等概念，使用POSIX标准。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a program so that we can learn about the concepts
    of **clock**, **time point**, and **duration** in terms of Linux. Let''s get started:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个程序，以便我们可以学习关于Linux中**时钟**、**时间点**和**持续时间**的概念。让我们开始吧：
- en: 'In a shell, create a new file named `linux_time_01.cpp` and add the following
    includes and function prototype:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell中，创建一个名为`linux_time_01.cpp`的新文件，并添加以下包含和函数原型：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we want to see the difference between `CLOCK_REALTIME` and `CLOCK_MONOTONIC`
    on the `clock_gettime` call. We need to define two `struct timespec` variables:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要看到`clock_gettime`调用中`CLOCK_REALTIME`和`CLOCK_MONOTONIC`之间的差异。我们需要定义两个`struct
    timespec`变量：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we need to print the contents of the `tsRealTime` and `tsMonoliticStart`
    variables to see the difference:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要打印`tsRealTime`和`tsMonoliticStart`变量的内容以查看它们之间的差异：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need a task to monitor, so we''ll use a `for` loop to populate an `std::vector`.
    After that, we immediately get a time point in the `tsMonotonicEnd` variable:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个任务来监视，所以我们将使用`for`循环来填充一个`std::vector`。之后，我们立即在`tsMonotonicEnd`变量中获取一个时间点：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we want to print the task''s duration. To do this, we call `timespec_diff`
    (helper method) to calculate the difference between `tsMonotonicEnd` and `tsMonotonicStart`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要打印任务的持续时间。为此，我们调用`timespec_diff`（辅助方法）来计算`tsMonotonicEnd`和`tsMonotonicStart`之间的差异：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we need to implement a helper method to calculate the time difference
    (that is, duration) between the times represented by the `start` and `stop` variables:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要实现一个辅助方法来计算`start`和`stop`变量表示的时间之间的时间差（即持续时间）：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding program shows how to gather time points to calculate the duration
    of an event. Now, let's deep dive into the details of this program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序展示了如何收集时间点以计算事件的持续时间。现在，让我们深入了解该程序的细节。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First of all, let''s compile and execute the program:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编译并执行程序：
- en: '![](img/f4a8718b-5a8b-46ac-a1d0-cd3365395fdf.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4a8718b-5a8b-46ac-a1d0-cd3365395fdf.png)'
- en: We can immediately notice that the real-time clock (seconds) is way bigger than
    the monotonic clock (seconds). By doing some math, you'll notice that the first
    is about 49 years and the latter is about 12 hours. Why is that? The second observation
    is that our code took `1 second` and `644348500` nanoseconds to populate a vector
    of 100 million items. Let's gather some insights to explain this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即注意到，实时时钟（秒）远远大于单调时钟（秒）。通过一些数学运算，您会注意到第一个大约是49年，而后者大约是12小时。为什么会这样？第二个观察是我们的代码花费了`1秒`和`644348500`纳秒来填充1亿个项目的向量。让我们收集一些见解来解释这一点。
- en: '*Step 1* just adds some includes and the prototype we''ve written to calculate
    the time difference.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*只是添加了一些包含和我们编写的原型，用于计算时间差。'
- en: '*Step 2* defined two variables, `struct timespec tsRealTime` and `struct timespec tsMonotonicStart`,
    that will be used to store the two time points. Then, we called the `clock_gettime()`
    method twice by passing `CLOCK_REALTIME` and the `tsRealTime` variable. We did
    this a second time by passing `CLOCK_MONOTONIC` with the `tsMonotonicStart` variable.
    `CLOCK_REALTIME` and `CLOCK_MONOTONIC` are both of the `clockid_t` type. When
    `clock_gettime()` is called with `CLOCK_REALTIME`, the time that we get will be
    the `wall-clock` time (or real time).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*定义了两个变量，`struct timespec tsRealTime`和`struct timespec tsMonotonicStart`，它们将用于存储两个时间点。然后，我们两次调用`clock_gettime()`方法，一次传递`CLOCK_REALTIME`和`tsRealTime`变量。我们再次传递`CLOCK_MONOTONIC`和`tsMonotonicStart`变量。`CLOCK_REALTIME`和`CLOCK_MONOTONIC`都是`clockid_t`类型。当使用`CLOCK_REALTIME`调用`clock_gettime()`时，我们得到的时间将是`挂钟`时间（或实时时间）。'
- en: This time point has the same issues that `std::chrono::SYSTEM_CLOCK` does, which
    we looked at in the *Learning about the C++ time interface* recipe. It can be
    adjusted (for example, if the system clock is synced with NTP), so this isn't
    suitable for calculating the elapsed time (or the duration) of an event. When
    `clock_gettime()` is called with the `CLOCK_MONOTONIC` parameter, the time does
    not adjust and most implementations make it start right from the boot of the system
    (that is, by counting the clock tick from the start of the machine). This is very
    suitable for event duration calculations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时间点有与我们在*学习C++时间接口*中看到的`std::chrono::SYSTEM_CLOCK`相同的问题。它可以被调整（例如，如果系统时钟与NTP同步），因此不适合计算事件的经过时间（或持续时间）。当使用`CLOCK_MONOTONIC`参数调用`clock_gettime()`时，时间不会调整，大多数实现会从系统启动开始计时（即从机器启动开始计算时钟滴答）。这非常适合事件持续时间的计算。
- en: '*Step 3* just prints the results of the time points, that is, `tsRealTime`
    and `tsMonotonicStart`. We can see that the first one contains the seconds since
    1^(st) January 1970 (about 49 years), while the latter contains the seconds since
    my machine has booted (about 12 hours).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*只是打印时间点的结果，即`tsRealTime`和`tsMonotonicStart`。我们可以看到第一个包含自1970年1月1日以来的秒数（大约49年），而后者包含自我的机器启动以来的秒数（大约12小时）。'
- en: '*Step 4* just adds 100 million items in an `std::vector` and then gets another
    time point in `tsMonotonicEnd`, which will be used to calculate the duration of
    this event.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*只是在`std::vector`中添加了1亿个项目，然后在`tsMonotonicEnd`中获取了另一个时间点，这将用于计算此事件的持续时间。'
- en: '*Step 5* calculates the difference between `tsMonotonicStart` and `tsMonotonicEnd`
    and stores the result in the `duration` variable by calling the `timespec_diff()` helper
    method.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤5*计算了`tsMonotonicStart`和`tsMonotonicEnd`之间的差异，并通过调用`timespec_diff()`辅助方法将结果存储在`duration`变量中。'
- en: '*Step 6* implements the `timespec_diff()` method, which logically calculates
    (`tsMonotonicEnd - tsMonotonicStart`).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤6*实现了`timespec_diff()`方法，逻辑上计算(`tsMonotonicEnd - tsMonotonicStart`)。'
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For the `clock_gettime()` method, we used POSIX as the counterpart set method: `clock_settime()`.
    The same is valid for `gettimeofday()`: `settimeofday()`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`clock_gettime()`方法，我们使用POSIX作为对应的设置方法：`clock_settime()`。对于`gettimeofday()`也是如此：`settimeofday()`。
- en: It's worth highlighting that `gettimeofday()` is an extension of `time()` that
    returns a `struct timeval` (that is, seconds and microseconds). The issue with
    this method is that it can be adjusted. What does this mean? Let's imagine you
    use `usegettimeofday()` to get a time point before the event to measure, and then
    you get another time point after the event to measure. Here, you would calculate
    the difference between the two time points thinking everything is fine. What issues
    may occur here? Imagine that, between the two time points you've taken, the **Network
    Time Protocol** (**NTP**) server demands the local machine to adjust the local
    clock to get it in sync with the time server. The duration that's calculated won't
    be accurate since the time point that's taken after the event is affected by the
    NTP sync. NTP is just an example of this. The local clock can be adjusted in other
    ways too.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，`gettimeofday()`是`time()`的扩展，返回一个`struct timeval`（即秒和微秒）。这种方法的问题在于它可以被调整。这是什么意思？让我们想象一下，您使用`usegettimeofday()`在事件之前获取一个时间点来测量，然后在事件之后获取另一个时间点来测量。在这里，您会计算两个时间点之间的差异，认为一切都很好。这里可能会出现什么问题？想象一下，在您获取的两个时间点之间，**网络时间协议**（**NTP**）服务器要求本地机器调整本地时钟以使其与时间服务器同步。由于受到NTP同步的影响，计算出的持续时间将不准确。NTP只是一个例子。本地时钟也可以以其他方式进行调整。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learning about the C++ time interface* recipe for comparison with C++
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与C++时间接口进行比较的*了解C++时间接口*配方
- en: '*Linux System Programming, Second Edition*,* by *Robert Love'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux系统编程，第二版*，作者*Robert Love'
- en: Dealing with time sleep and overruns
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时间休眠和超时
- en: Time, in a system programming context, doesn't only involve the act of measuring
    the duration of an event or reading the clock. It's also possible to put a process
    to sleep for a certain amount of time. This recipe will teach you how to put a
    process to sleep by using the seconds*-*based API, the microseconds-based API,
    and the `clock_nanosleep()` method, which has nanosecond resolution. Furthermore,
    we'll see what time overruns are and how we can minimize them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程的上下文中，时间不仅涉及测量事件持续时间或读取时钟的行为。还可以将进程置于休眠状态一段时间。这个配方将教你如何使用基于秒的API、基于微秒的API和具有纳秒分辨率的`clock_nanosleep()`方法来使进程进入休眠状态。此外，我们将看到时间超时是什么，以及如何最小化它们。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write a program to learn how to put a program to sleep
    by using the different POSIX APIs that are available. We''ll also look at the
    C++ alternative:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将编写一个程序，学习如何使用不同的POSIX API来使程序进入休眠状态。我们还将看看C++的替代方法：
- en: 'Open a shell and create a new file called `sleep.cpp`. We need to add some
    headers that we''ll need later:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个shell并创建一个名为`sleep.cpp`的新文件。我们需要添加一些稍后需要的头文件：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll put the program to sleep for `1` second by using the `sleep()` method
    and the `std::chrono::steady_clock` class as time points to calculate the duration
    at the end:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`sleep()`方法和`std::chrono::steady_clock`类作为时间点，将程序置于休眠状态`1`秒，以计算持续时间：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s look at how `nanosleep()` works. We still use `std::chrono::steady_clock`
    to calculate the duration, but we need a `struct timespec`. We''ll make the process
    sleep for about `100` milliseconds:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`nanosleep()`是如何工作的。我们仍然使用`std::chrono::steady_clock`来计算持续时间，但我们需要一个`struct
    timespec`。我们将使进程休眠约`100`毫秒：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A more advanced way of putting a process to sleep is by using `clock_nanosleep()`,
    which allows us to specify some interesting parameters (see the next section for
    more details):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将进程置于休眠状态的更高级方法是使用`clock_nanosleep()`，它允许我们指定一些有趣的参数（更多细节请参见下一节）：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s look at how we can put the current thread to sleep by using the
    C++ Standard Library (through the `std::this_thread::sleep_for` template method):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用C++标准库（通过`std::this_thread::sleep_for`模板方法）将当前线程置于休眠状态：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's go over these steps in more detail.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地了解这些步骤。
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The program will be put to sleep in four different ways. Let''s take a look
    at the runtime:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将以四种不同的方式进入休眠状态。让我们来看看运行时间：
- en: '![](img/a3c3be5d-eca0-4e1b-97a5-1d4492bd48a0.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3c3be5d-eca0-4e1b-97a5-1d4492bd48a0.png)'
- en: '*Step 1* just contains the headers we need: `<iostream>` for the standard output
    and standard error (`cout` and `cerr`), `<chrono>` for the time points that will
    be used to measure the actual sleep, `<thread>` for the `sleep_for` method, `<unistd>`
    for `sleep()`, and `<time.h>` for `nanosleep()` and `clock_nanosleep()`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*只包含我们需要的头文件：`<iostream>`用于标准输出和标准错误（`cout`和`cerr`），`<chrono>`用于将用于测量实际休眠的时间点，`<thread>`用于`sleep_for`方法，`<unistd>`用于`sleep()`，`<time.h>`用于`nanosleep()`和`clock_nanosleep()`。'
- en: '*Step 2* puts the process to sleep for `1` second by using the `sleep()` method.
    We use `steady_clock::now()` to get the time points and `duration_cast` to cast
    the difference and get the actual duration. To be precise, `sleep()` returns `0`
    if the process has successfully slept for at least the amount of time specified,
    but it can return a value between 0 and the seconds specified, which would represent
    the time **not** slept.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*使用`sleep()`方法使进程休眠`1`秒。我们使用`steady_clock::now()`来获取时间点，使用`duration_cast`来转换差异并获取实际持续时间。要精确，`sleep()`返回`0`，如果进程成功休眠至少指定时间量，但它可以返回一个介于0和指定秒数之间的值，这代表了**未**休眠的时间。'
- en: '*Step 3* shows how to put a process to sleep by using `nanosleep()`. We decided
    to use this method since `usleep()` has been deprecated on Linux. `nanosleep()`
    has an advantage over `sleep()` since it has nanosecond resolution and `POSIX.1b` is
    standardized. `nanosleep()` returns `0` on success and `-1` in the case of an
    error. It does this by setting the `errno` global variable to the specific error
    that occurred. The `struct timespec` variable contains `tv_sec` and `tv_nsec`
    (seconds and nanoseconds).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤3*展示了如何使用`nanosleep()`使进程进入睡眠状态。我们决定使用这种方法，因为在Linux上已经弃用了`usleep()`。`nanosleep()`比`sleep()`更有优势，因为它具有纳秒分辨率，并且`POSIX.1b`是标准化的。`nanosleep()`在成功时返回`0`，在错误时返回`-1`。它通过将`errno`全局变量设置为发生的特定错误来实现这一点。`struct
    timespec`变量包含`tv_sec`和`tv_nsec`（秒和纳秒）。'
- en: '*Step 4* uses a more sophisticated `clock_nanosleep()`. This method contains
    two parameters we haven''t looked at yet. The first parameter is `clock_id` and
    accepts, among other things, `CLOCK_REALTIME` and `CLOCK_MONOTONIC`, which we
    looked at in the previous recipes. As a rule of thumb, you want to use the first
    if you''re sleeping until an absolute time (wall-clock time) and the second if
    you''re sleeping until a relative time value. This makes sense based on what we
    saw in the previous recipe.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤4*使用了一个更复杂的`clock_nanosleep()`。这种方法包含了我们尚未看到的两个参数。第一个参数是`clock_id`，接受，除其他外，`CLOCK_REALTIME`和`CLOCK_MONOTONIC`，我们在前面的配方中已经看过了。作为一个经验法则，如果你要睡到绝对时间（挂钟时间），你应该使用第一个，如果你要睡到相对时间值，你应该使用第二个。根据我们在前面的配方中看到的，这是有道理的。'
- en: The second parameter is a flag; it can be `TIME_ABSTIME` or `0`. If the first
    one is passed, the `reqClockSleep` variable will be treated as absolute, but if
    `0` is passed, then it'll be treated as relative. To clarify the concept of absolute
    time further, it might come from a previous call of `clock_gettime()` that stores
    an absolute time point in a variable, say `ts`. By adding `2` seconds to it, we
    can pass `&ts` (that is, the address of the variable `ts`) to `clock_nanosleep()`,
    which will wait until that specific absolute time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个标志；它可以是`TIME_ABSTIME`或`0`。如果传递第一个，那么`reqClockSleep`变量将被视为绝对时间，但如果传递`0`，那么它将被视为相对时间。为了进一步澄清绝对时间的概念，它可能来自前一次调用`clock_gettime()`，它将绝对时间点存储在一个变量中，比如`ts`。通过向其添加`2`秒，我们可以将`&ts`（即变量`ts`的地址）传递给`clock_nanosleep()`，它将等待到那个特定的绝对时间。
- en: '*Step 5* puts the current thread of the process to sleep (in this case, the
    current thread is the main thread, so the whole process will sleep) for 1.5 seconds
    (1,500 milliseconds = 1.5 seconds). `std::this_thread::sleep_for` is simple and
    effective. It is a template method that takes in one parameter as input; that
    is, the `duration`, which needs the representation type and the period (`_Rep` and
    `_Period`), as we saw in the *Learning the C++ time interface* recipe. In this
    case, we only passed the period in milliseconds and left the representation in
    its default state.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤5*让当前线程的进程进入睡眠状态（在这种情况下，当前线程是主线程，所以整个进程将进入睡眠状态）1.5秒（1,500毫秒=1.5秒）。`std::this_thread::sleep_for`简单而有效。它是一个模板方法，接受一个参数作为输入；也就是说，`duration`，它需要表示类型和周期（`_Rep`和`_Period`），正如我们在*学习C++时间接口*配方中看到的。在这种情况下，我们只传递了毫秒的周期，并将表示保留在其默认状态。'
- en: 'There is an issue we should be aware of here: the **time** **overrun**. All
    the interfaces we''ve used in this recipe guarantee that the process will sleep
    *at least as long as requested*. They''ll return an error otherwise. They might
    sleep for a time slightly longer than the time we requested for different reasons.
    One reason might be due to the scheduler that selects a different task to run.
    This problem occurs when the granularity of the timer is greater than the time
    that was requested. Think, for example, about the time that''s shown by the timer
    (`10msec`) and that the sleep time is `5 msec`. We might have a case where the
    process has to wait `5` milliseconds more than expected, which is 100% longer.
    Time overrun can be mitigated by using methods that support high-precision time
    sources, such as `clock_nanosleep()`, `nanosleep()`, and `std::this_thread::sleep_for()`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题我们应该注意：**时间超出**。我们在这个配方中使用的所有接口都保证进程将至少睡眠*所请求的时间*。否则它们会返回错误。它们可能会因为不同的原因而睡眠时间略长于我们请求的时间。一个原因可能是由于选择了不同的任务来运行的调度程序。当计时器的粒度大于所请求的时间时，就会出现这个问题。例如，考虑一下计时器显示的时间（`10msec`）和睡眠时间为`5msec`。我们可能会遇到一个情况，进程必须等待比预期多`5`毫秒，这是100%的增加。时间超出可以通过使用支持高精度时间源的方法来减轻，例如`clock_nanosleep()`、`nanosleep()`和`std::this_thread::sleep_for()`。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We didn't explicitly mention the thread implications for `nanosleep()` and `clock_nanosleep()`.
    Both methods cause the current thread to sleep. Sleep on Linux means that the
    thread (or the process, if it is a single-threaded application) will enter a **Not
    Runnable** state so that the CPU can continue with other tasks (remember that
    Linux does not differentiate between threads and processes).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有明确提到`nanosleep()`和`clock_nanosleep()`的线程影响。这两种方法都会导致当前线程进入睡眠状态。在Linux上，睡眠意味着线程（或者如果是单线程应用程序，则是进程）将进入**不可运行**状态，以便CPU可以继续执行其他任务（请记住，Linux不区分线程和进程）。
- en: See also
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*The Learning the C++ time interface* recipe for a review of the `std::chrono::duration<>` template
    class'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习C++时间接口*的一篇评论，审查`std::chrono::duration<>`模板类'
- en: The *Learning the Linux timing* recipe for a review of the concepts of **REALTIME**
    and **MONOTONIC**
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Linux时间*的一篇评论，审查**REALTIME**和**MONOTONIC**的概念'
