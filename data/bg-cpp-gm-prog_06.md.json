["```cpp\nclass Paddle \n{ \n   private: \n\n      // Length of the pong paddle \n      int m_Length = 100;  \n\n      // Height of the pong paddle \n      int m_Height = 10; \n\n      // Location on x axis \n      int m_XPosition;       \n\n      // Location on y axis \n      int m_YPosition;       \n\n   public: \n\n      void moveRight(); \n      void moveLeft(); \n}; \n\n```", "```cpp\nclass Paddle \n{ \n\n}; \n\n```", "```cpp\n// Length of the pong paddle \nint m_Length = 100;  \n\n// Length of the pong paddle \nint m_Height = 10; \n\n// Location on x axis \nint m_XPosition;       \n\n// Location on x axis \nint m_YPosition;       \n\n```", "```cpp\nprivate: \n   // more code here \n\npublic: \n   // More code here \n\n```", "```cpp\nvoid moveRight(); \nvoid moveLeft(); \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Paddle.h\" \n\nvoid Paddle::moveRight() \n{ \n   // Move the paddle a pixel to the right \n   m_XPosition ++; \n} \n\nvoid Paddle::moveLeft() \n{ \n   // Move the paddle a pixel to the left \n   m_XPosition --; \n} \n\n```", "```cpp\nclass Paddle \n{ \n   private: \n\n      // Length of the pong paddle \n      int m_Length = 100;  \n\n      // Height of the pong paddle \n      int m_Height = 10; \n\n      // Location on x axis \n      int m_XPosition;       \n\n      // Location on x axis \n      int m_YPosition;       \n\n   public: \n\n      void Paddle::moveRight() \n      { \n         // Move the paddle a pixel to the right \n         m_XPosition ++; \n      } \n\n      void Paddle::moveLeft() \n      { \n         // Move the paddle a pixel to the left \n         m_XPosition --; \n      } \n\n}; \n\n```", "```cpp\nPaddle paddle; \n\n```", "```cpp\npaddle.moveLeft(); \n\n```", "```cpp\npaddle.moveRight(); \n\n```", "```cpp\nPaddle paddle; \nPaddle paddle2;\n\n```", "```cpp\nprivate: \n\n   // Length of a pong paddle \n   int m_Length = 100;  \n\n   // Height of a pong paddle \n   int m_Height = 10; \n\n   // Location on x axis \n   int m_XPosition;       \n\n   // Location on x axis \n   int m_YPosition;      \n\n // Of course we will need a sprite   \n   Sprite m_Sprite;  \n\n   // And a texture   \n   Texture m_Texture;\n\n```", "```cpp\npublic: \n\n   void moveRight(); \n   void moveLeft(); \n\n // Send a copy of the sprite to main   \n   Sprite getSprite();\n\n```", "```cpp\npublic: \n\n // The constructor   \n   Paddle(); \n\n   void moveRight(); \n   void moveLeft(); \n\n   // Send a copy of the sprite to main \n   Sprite getSprite(); \n\n```", "```cpp\n// The constructor \nPaddle::Paddle() \n{ \n   // Code assumes paddle.png is a real image \n   m_Texture.loadFromFile(\"graphics/paddle.png\"); \n\n   // Associate a texture with the sprite \n   m_Sprite.setTexture(m_Texture); \n} \n\n// Return a copy of the sprite to main \nSprite Paddle::getSprite() \n{ \n   return m_Sprite; \n} \n\n```", "```cpp\nwindow.draw(paddle.getSprite()); \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Paddle \n{ \n   private: \n\n      // Length of a pong paddle \n      int m_Length = 100;  \n      // Height of a pong paddle \n      int m_Height = 10; \n      // Location on x axis \n      int m_XPosition;       \n      // Location on y axis \n      int m_YPosition;       \n\n      // Of course we will need a sprite \n      Sprite m_Sprite; \n\n      // And a texture \n      Texture m_Texture; \n\n   public:   \n\n      // The constructor \n      Paddle(); \n\n      void moveRight(); \n      void moveLeft(); \n\n      // Send a copy of the sprite to main \n      Sprite getSprite(); \n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Paddle.h\" \n\n// The constructor \nPaddle::Paddle() \n{ \n   // Code assumes paddle.png is a real image \n   m_Texture.loadFromFile(\"graphics/paddle.png\"); \n\n   // Associate a texture with the sprite \n   m_Sprite.setTexture(m_Texture); \n} \n\n// Return a copy of the sprite to main \nSprite Paddle::getSprite() \n{ \n   return m_Sprite; \n} \n\nvoid Paddle::moveRight() \n{ \n   // Move the paddle a pixel to the right \n   m_XPosition ++; \n} \n\nvoid Paddle::moveLeft() \n{ \n   // Move the paddle a pixel to the left \n   m_XPosition --; \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Player \n{ \n\n}; \n\n```", "```cpp\nclass Player \n{ \nprivate:   \n  const float START_SPEED = 200;   \n  const float START_HEALTH = 100; \n\n  // Where is the player   \n  Vector2f m_Position;   \n\n  // Of course we will need a sprite   \n  Sprite m_Sprite;   \n\n  // And a texture   \n  // !!Watch this space!!   \n  Texture m_Texture;   \n\n  // What is the screen resolution   \n  Vector2f m_Resolution;   \n\n  // What size is the current arena   \n  IntRect m_Arena;   \n\n  // How big is each tile of the arena   \n  int m_TileSize;   \n\n  // Which directions is the player currently moving in   \n  bool m_UpPressed;   \n  bool m_DownPressed;   \n  bool m_LeftPressed;   \n  bool m_RightPressed;   \n\n  // How much health has the player got?   \n  int m_Health;   \n\n  // What is the maximum health the player can have   \n  int m_MaxHealth;   \n\n  // When was the player last hit   \n  Time m_LastHit;   \n\n  // Speed in pixels per second   \n  float m_Speed;\n\n  // All our public functions will come next \n}; \n\n```", "```cpp\n// All our public functions will come next \npublic:   \n  Player();\n  void spawn(IntRect arena, Vector2f resolution, int tileSize);   \n\n  // Call this at the end of every game   \n  void resetPlayerStats();   \n\n  // Handle the player getting hit by a zombie   \n  bool hit(Time timeHit);   \n\n  // How long ago was the player last hit   \n  Time getLastHitTime();   \n\n  // Where is the player   \n  FloatRect getPosition();   \n\n  // Where is the center of the player   \n  Vector2f getCenter();   \n\n  // Which angle is the player facing   \n  float getRotation();   \n\n  // Send a copy of the sprite to main   \n  Sprite getSprite();   \n\n  // The next four functions move the player   \n  void moveLeft();   \n\n  void moveRight();   \n\n  void moveUp();   \n\n  void moveDown();   \n\n  // Stop the player moving in a specific direction   \n  void stopLeft();   \n\n  void stopRight();   \n\n  void stopUp();   \n\n  void stopDown();   \n\n  // We will call this function once every frame   \n  void update(float elapsedTime, Vector2i mousePosition);   \n\n  // Give player a speed boost   \n  void upgradeSpeed();   \n\n  // Give the player some health   \n  void upgradeHealth();   \n\n  // Increase the maximum amount of health the player can have   \n  void increaseHealthLevel(int amount);   \n\n  // How much health has the player currently got?   \n  int getHealth(); \n}; \n\n```", "```cpp\nwindow.draw(player.getSprite()); \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"player.h\" \n\nPlayer::Player() \n{ \n   m_Speed = START_SPEED; \n   m_Health = START_HEALTH; \n   m_MaxHealth = START_HEALTH; \n\n   // Associate a texture with the sprite \n   m_Texture.loadFromFile(\"graphics/player.png\"); \n   m_Sprite.setTexture(m_Texture); \n\n   // Set the origin of the sprite to the centre,  \n   // for smooth rotation \n   m_Sprite.setOrigin(25, 25); \n} \n\n```", "```cpp\nPlayer player;\n```", "```cpp\nvoid Player::spawn(IntRect arena, Vector2f resolution, int tileSize) \n{ \n   // Place the player in the middle of the arena \n   m_Position.x = arena.width / 2; \n   m_Position.y = arena.height / 2; \n\n   // Copy the details of the arena to the player's m_Arena \n   m_Arena.left = arena.left; \n   m_Arena.width = arena.width; \n   m_Arena.top = arena.top; \n   m_Arena.height = arena.height; \n\n   // Remember how big the tiles are in this arena \n   m_TileSize = tileSize; \n\n   // Store the resolution for future use \n   m_Resolution.x = resolution.x; \n   m_Resolution.y = resolution.y; \n\n} \n\n```", "```cpp\nvoid Player::resetPlayerStats() \n{ \n   m_Speed = START_SPEED; \n   m_Health = START_HEALTH; \n   m_MaxHealth = START_HEALTH; \n} \n\n```", "```cpp\nTime Player::getLastHitTime() \n{ \n   return m_LastHit; \n} \n\nbool Player::hit(Time timeHit) \n{ \n   if (timeHit.asMilliseconds() - m_LastHit.asMilliseconds() > 200) \n   { \n      m_LastHit = timeHit; \n      m_Health -= 10; \n      return true; \n   } \n   else \n   { \n      return false; \n   } \n\n} \n\n```", "```cpp\nFloatRect Player::getPosition() \n{ \n   return m_Sprite.getGlobalBounds(); \n} \n\nVector2f Player::getCenter() \n{ \n   return m_Position; \n} \n\nfloat Player::getRotation() \n{ \n   return m_Sprite.getRotation(); \n} \n\nSprite Player::getSprite() \n{ \n   return m_Sprite; \n} \n\nint Player::getHealth() \n{ \n   return m_Health; \n} \n\n```", "```cpp\nvoid Player::moveLeft() \n{ \n   m_LeftPressed = true; \n} \n\nvoid Player::moveRight() \n{ \n   m_RightPressed = true; \n} \n\nvoid Player::moveUp() \n{ \n   m_UpPressed = true; \n} \n\nvoid Player::moveDown() \n{ \n   m_DownPressed = true; \n} \n\nvoid Player::stopLeft() \n{ \n   m_LeftPressed = false; \n} \n\nvoid Player::stopRight() \n{ \n   m_RightPressed = false; \n} \n\nvoid Player::stopUp() \n{ \n   m_UpPressed = false; \n} \n\nvoid Player::stopDown() \n{ \n   m_DownPressed = false; \n} \n\n```", "```cpp\nvoid Player::update(float elapsedTime, Vector2i mousePosition) \n{ \n   if (m_UpPressed) \n   { \n      m_Position.y -= m_Speed * elapsedTime; \n   } \n\n   if (m_DownPressed) \n   { \n      m_Position.y += m_Speed * elapsedTime; \n   } \n\n   if (m_RightPressed) \n   { \n      m_Position.x += m_Speed * elapsedTime; \n   } \n\n   if (m_LeftPressed) \n   { \n      m_Position.x -= m_Speed * elapsedTime; \n   } \n\n   m_Sprite.setPosition(m_Position); \n\n   // Keep the player in the arena \n   if (m_Position.x > m_Arena.width - m_TileSize) \n   { \n      m_Position.x = m_Arena.width - m_TileSize; \n   } \n\n   if (m_Position.x < m_Arena.left + m_TileSize) \n   { \n      m_Position.x = m_Arena.left + m_TileSize; \n   } \n\n   if (m_Position.y > m_Arena.height - m_TileSize) \n   { \n      m_Position.y = m_Arena.height - m_TileSize; \n   } \n\n   if (m_Position.y < m_Arena.top + m_TileSize) \n   { \n      m_Position.y = m_Arena.top + m_TileSize; \n   } \n\n   // Calculate the angle the player is facing \n   float angle = (atan2(mousePosition.y - m_Resolution.y / 2, \n      mousePosition.x - m_Resolution.x / 2) \n      * 180) / 3.141; \n\n   m_Sprite.setRotation(angle); \n} \n\n```", "```cpp\nif (m_Position.x > m_Arena.width - m_TileSize) \n{ \n   m_Position.x = m_Arena.width - m_TileSize; \n} \n\n```", "```cpp\nvoid Player::upgradeSpeed() \n{ \n   // 20% speed upgrade \n   m_Speed += (START_SPEED * .2); \n} \n\nvoid Player::upgradeHealth() \n{ \n   // 20% max health upgrade \n   m_MaxHealth += (START_HEALTH * .2); \n\n} \n\nvoid Player::increaseHealthLevel(int amount) \n{ \n   m_Health += amount; \n\n   // But not beyond the maximum \n   if (m_Health > m_MaxHealth) \n   { \n      m_Health = m_MaxHealth; \n   } \n\n```", "```cpp\n// Create a view to fill a 1920 x 1080 monitor \nView mainView(sf::FloatRect(0, 0, 1920, 1080)); \n\n// Create a view for the HUD \nView hudView(sf::FloatRect(0, 0, 1920, 1080)); \n\n```", "```cpp\n// In the update part of the game \n// There are lots of things you can do with a View \n\n// Make the view centre around the player           \nmainView.setCenter(player.getCenter()); \n\n// Rotate the view 45 degrees \nmainView.rotate(45) \n\n// Note that hudView is totally unaffected by the previous code \n\n```", "```cpp\n// Set the current view \nwindow.setView(mainView); \n\n```", "```cpp\n// Do all the drawing for this view \nwindow.draw(playerSprite); \nwindow.draw(otherGameObject); \n// etc \n\n```", "```cpp\n// Switch to the hudView \nwindow.setView(hudView); \n\n// Do all the drawing for the HUD \nwindow.draw(scoreText); \nwindow.draw(healthBar); \n// etc \n\n```", "```cpp\nwindow.display(); \n\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include \"Player.h\" \n\nusing namespace sf; \n\nint main() \n{ \n\n   return 0; \n} \n\n```", "```cpp\nint main() \n{ \n // The game will always be in one of four states   \n   enum class State \n   { \n     PAUSED, LEVELING_UP, GAME_OVER, PLAYING \n   };\n\n   // Start with the GAME_OVER state\n   State state = State::GAME_OVER;\n\n   // Get the screen resolution and create an SFML window\n   Vector2f resolution;\n   resolution.x = VideoMode::getDesktopMode().width;\n   resolution.y = VideoMode::getDesktopMode().height;\n\n   RenderWindow window(VideoMode(resolution.x, resolution.y),\n     \"Zombie Arena\", Style::Fullscreen);\n\n   // Create a an SFML View for the main action\n   View mainView(sf::FloatRect(0, 0, resolution.x, resolution.y));\n   // Here is our clock for timing everything\n   Clock clock;\n\n   // How long has the PLAYING state been active\n   Time gameTimeTotal;\n\n   // Where is the mouse in relation to world coordinates\n   Vector2f mouseWorldPosition;   \n\n   // Where is the mouse in relation to screen coordinates\n   Vector2i mouseScreenPosition;\n\n   // Create an instance of the Player class\n   Player player;\n\n   // The boundaries of the arena\n   IntRect arena;\n\n   // The main game loop\n   while (window.isOpen())\n   {\n\n   } \n\n   return 0; \n} \n\n```", "```cpp\n// The game will always be in one of four states \nenum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING }; \n// Start with the GAME_OVER state \nState state = State::GAME_OVER; \n\n```", "```cpp\n// Get the screen resolution and create an SFML window \nVector2f resolution; \nresolution.x = VideoMode::getDesktopMode().width; \nresolution.y = VideoMode::getDesktopMode().height; \nRenderWindow window(VideoMode(resolution.x, resolution.y),  \n   \"Zombie Arena\", Style::Fullscreen); \n\n```", "```cpp\n// Create a an SFML View for the main action \nView mainView(sf::FloatRect(0, 0, resolution.x, resolution.y)); \n\n```", "```cpp\n// Here is our clock for timing everything \nClock clock; \n// How long has the PLAYING state been active \nTime gameTimeTotal; \n\n```", "```cpp\n// Where is the mouse in relation to world coordinates \nVector2f mouseWorldPosition; \n// Where is the mouse in relation to screen coordinates \nVector2i mouseScreenPosition; \n\n```", "```cpp\n// Create an instance of the Player class \nPlayer player; \n\n```", "```cpp\n// The boundaries of the arena \nIntRect arena; \n\n```", "```cpp\n// The main game loop \nwhile (window.isOpen()) \n{ \n\n} \n\n```", "```cpp\n// The main game loop \nwhile (window.isOpen()) \n{ \n /*\n   ************\n   Handle input\n   ************\n   */   \n\n   // Handle events by polling   \n   Event event;\n   while (window.pollEvent(event))\n   {\n     if (event.type == Event::KeyPressed)\n     {\n        // Pause a game while playing\n        if (event.key.code == Keyboard::Return &&\n           state == State::PLAYING)\n        {\n           state = State::PAUSED;\n        }\n        // Restart while paused\n        else if (event.key.code == Keyboard::Return &&\n           state == State::PAUSED)\n        {\n           state = State::PLAYING;\n           // Reset the clock so there isn't a frame jump\n           clock.restart();\n        }\n        // Start a new game while in GAME_OVER state\n        else if (event.key.code == Keyboard::Return &&\n           state == State::GAME_OVER)\n        {\n           state = State::LEVELING_UP;\n        }\n        if (state == State::PLAYING)\n        {\n        }\n     }\n   }// End event polling \n\n}// End game loop \n\n```", "```cpp\n   }// End event polling \n\n // Handle the player quitting\n   if (Keyboard::isKeyPressed(Keyboard::Escape))\n   {\n     window.close();\n   }\n\n   // Handle WASD while playing\n   if (state == State::PLAYING)\n   {\n     // Handle the pressing and releasing of the WASD keys\n     if (Keyboard::isKeyPressed(Keyboard::W))\n     {\n        player.moveUp();\n     }\n     else\n     {\n        player.stopUp();\n     }\n     if (Keyboard::isKeyPressed(Keyboard::S))\n     {\n        player.moveDown();\n     }\n     else\n     {\n        player.stopDown();\n     }\n     if (Keyboard::isKeyPressed(Keyboard::A))\n     {\n        player.moveLeft();\n     }\n     else\n     {\n        player.stopLeft();\n     }\n     if (Keyboard::isKeyPressed(Keyboard::D))\n     {\n        player.moveRight();\n     }\n     else\n     {\n        player.stopRight();\n     }\n   }// End WASD while playing \n\n}// End game loop \n\n```", "```cpp\n   }// End WASD while playing \n\n // Handle the LEVELING up state\n   if (state == State::LEVELING_UP)\n   {\n     // Handle the player LEVELING up\n     if (event.key.code == Keyboard::Num1)\n     {\n        state = State::PLAYING;\n     }\n\n     if (event.key.code == Keyboard::Num2)\n     {\n        state = State::PLAYING;\n     }\n\n     if (event.key.code == Keyboard::Num3)\n     {\n        state = State::PLAYING;\n     }\n\n     if (event.key.code == Keyboard::Num4)\n     {\n        state = State::PLAYING;\n     }\n\n     if (event.key.code == Keyboard::Num5)\n     {\n        state = State::PLAYING;\n     }\n\n     if (event.key.code == Keyboard::Num6)\n     {\n        state = State::PLAYING;\n     }\n\n     if (state == State::PLAYING)\n     {\n        // Prepare the level\n        // We will modify the next two lines later\n        arena.width = 500;\n        arena.height = 500;\n        arena.left = 0;\n        arena.top = 0;\n\n        // We will modify this line of code later\n        int tileSize = 50;\n\n        // Spawn the player in the middle of the arena\n        player.spawn(arena, resolution, tileSize);\n\n        // Reset the clock so there isn't a frame jump\n        clock.restart();\n     }\n   }// End LEVELING up \n\n}// End game loop \n\n```", "```cpp\n   }// End LEVELING up \n\n /*\n   ****************\n   UPDATE THE FRAME\n   ****************\n   */\n   if (state == State::PLAYING)\n   {\n     // Update the delta time\n     Time dt = clock.restart();\n\n     // Update the total game time\n     gameTimeTotal += dt;\n\n     // Make a decimal fraction of 1 from the delta time\n     float dtAsSeconds = dt.asSeconds();\n\n     // Where is the mouse pointer\n     mouseScreenPosition = Mouse::getPosition();\n\n     // Convert mouse position to world coordinates of mainView\n     mouseWorldPosition = window.mapPixelToCoords(\n        Mouse::getPosition(), mainView);\n\n     // Update the player\n     player.update(dtAsSeconds, Mouse::getPosition());\n\n     // Make a note of the players new position\n     Vector2f playerPosition(player.getCenter());\n\n     // Make the view centre around the player\n     mainView.setCenter(player.getCenter());\n   }// End updating the scene \n\n}// End game loop \n\n```", "```cpp\n// Update the delta time \nTime dt = clock.restart(); \n\n```", "```cpp\n// Update the total game time \ngameTimeTotal += dt; \n\n```", "```cpp\n      }// End updating the scene \n\n /*\n     **************\n     Draw the scene\n     **************\n     */\n     if (state == State::PLAYING)\n     {\n        window.clear();\n\n        // set the mainView to be displayed in the window\n        // And draw everything related to it\n        window.setView(mainView);\n\n        // Draw the player\n        window.draw(player.getSprite());\n     }\n\n     if (state == State::LEVELING_UP)\n     {\n     }\n     if (state == State::PAUSED)\n     {\n     }\n     if (state == State::GAME_OVER)\n     {\n     }\n     window.display(); \n\n   }// End game loop \n\n   return 0; \n} \n\n```"]