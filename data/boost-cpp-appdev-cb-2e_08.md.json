["```cpp\n#include <boost/mpl/aux_/na.hpp>\n\n// boost::mpl::na == n.a. == not available\ntemplate <\n    class T0 = boost::mpl::na,\n    class T1 = boost::mpl::na,\n    class T2 = boost::mpl::na,\n    class T3 = boost::mpl::na,\n    class T4 = boost::mpl::na,\n    class T5 = boost::mpl::na,\n    class T6 = boost::mpl::na,\n    class T7 = boost::mpl::na,\n    class T8 = boost::mpl::na,\n    class T9 = boost::mpl::na\n    >\nstruct variant;\n```", "```cpp\n#include <boost/mpl/vector.hpp>\n\ntemplate <\n    class T0, class T1, class T2, class T3, class T4,\n    class T5, class T6, class T7, class T8, class T9\n>\nstruct variant {\n    typedef boost::mpl::vector<\n        T0, T1, T2, T3, T4, T5, T6, T7, T8, T9\n    > types;\n};\n```", "```cpp\n#include <string>\nstruct declared{ unsigned char data[4096]; };\nstruct non_declared;\n\ntypedef variant<\n    volatile int, \n    const int, \n    const long, \n    declared, \n    non_declared, \n    std::string\n>::types types;\n```", "```cpp\n#include <boost/static_assert.hpp> \n#include <boost/mpl/empty.hpp> \n\nBOOST_STATIC_ASSERT((!boost::mpl::empty<types>::value)); \n```", "```cpp\n#include <boost/mpl/at.hpp>\n#include <boost/type_traits/is_same.hpp>\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    non_declared, \n    boost::mpl::at_c<types, 4>::type\n>::value));\n```", "```cpp\n#include <boost/mpl/back.hpp>\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::mpl::back<types>::type,\n    std::string\n>::value));\n```", "```cpp\n#include <boost/mpl/transform.hpp>\n#include <boost/type_traits/remove_cv.hpp>\n\ntypedef boost::mpl::transform<\n    types,\n    boost::remove_cv<boost::mpl::_1>\n>::type noncv_types;\n```", "```cpp\n#include <boost/mpl/unique.hpp>\n\ntypedef boost::mpl::unique<\n    noncv_types, \n    boost::is_same<boost::mpl::_1, boost::mpl::_2>\n>::type unique_types;\n```", "```cpp\n#include <boost/mpl/size.hpp>\n\nBOOST_STATIC_ASSERT((boost::mpl::size<unique_types>::value == 5));\n```", "```cpp\n// Without this we'll get an error:\n// \"use of undefined type 'non_declared'\"\nstruct non_declared{};\n\n#include <boost/mpl/sizeof.hpp>\ntypedef boost::mpl::transform<\n    unique_types, \n    boost::mpl::sizeof_<boost::mpl::_1>\n>::type sizes_types;\n```", "```cpp\n#include <boost/mpl/max_element.hpp>\n\ntypedef boost::mpl::max_element<sizes_types>::type max_size_type;\n```", "```cpp\n  BOOST_STATIC_ASSERT(max_size_type::type::value == sizeof(declared)); \n```", "```cpp\ntypedef boost::mpl::transform<\n    types,\n    boost::remove_cv<boost::mpl::_1>\n>::type noncv_types;\n```", "```cpp\nstd::vector<type> t; // 't' stands for 'types'. \nstd::unique(t.begin(), t.end(), boost::bind(std::equal_to<type>(), _1, _2)); \n```", "```cpp\nstruct boost::mpl::vector<\n    struct boost::mpl::size_t<4>,\n    struct boost::mpl::size_t<4>,\n    struct boost::mpl::size_t<4096>,\n    struct boost::mpl::size_t<1>,\n    struct boost::mpl::size_t<32> \n>\n```", "```cpp\n// Make unsigned.\nstruct unsigne; // Not a typo: `unsigned` is a keyword, we can not use it.\n\n// Make constant.\nstruct constant;\n\n// Otherwise we do not change type.\nstruct no_change;\n```", "```cpp\n// We'll need this at step 3.\n#include <boost/mpl/size.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/static_assert.hpp>\n\n// We'll need this at step 4.\n#include <boost/mpl/if.hpp>\n#include <boost/type_traits/make_unsigned.hpp>\n#include <boost/type_traits/add_const.hpp>\n\n// We'll need this at step 5.\n#include <boost/mpl/transform.hpp>\n```", "```cpp\ntemplate <class Types, class Modifiers>\nstruct do_modifications {\n```", "```cpp\n    BOOST_STATIC_ASSERT((boost::is_same<\n        typename boost::mpl::size<Types>::type, \n        typename boost::mpl::size<Modifiers>::type \n    >::value));\n```", "```cpp\n    typedef boost::mpl::if_<\n        boost::is_same<boost::mpl::_2, unsigne>,\n        boost::make_unsigned<boost::mpl::_1>,\n        boost::mpl::if_<\n            boost::is_same<boost::mpl::_2, constant>,\n            boost::add_const<boost::mpl::_1>,\n            boost::mpl::_1\n        >\n    > binary_operator_t;\n```", "```cpp\n    typedef typename boost::mpl::transform<\n        Types,\n        Modifiers,\n        binary_operator_t\n    >::type type;\n};\n```", "```cpp\n#include <boost/mpl/vector.hpp>\n#include <boost/mpl/at.hpp>\n\ntypedef boost::mpl::vector<\n    unsigne, no_change, constant, unsigne\n> modifiers;\n\ntypedef boost::mpl::vector<\n    int, char, short, long\n> types;\n\ntypedef do_modifications<types, modifiers>::type result_type;\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::mpl::at_c<result_type, 0>::type,\n    unsigned int\n>::value));\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::mpl::at_c<result_type, 1>::type,\n    char\n>::value));\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::mpl::at_c<result_type, 2>::type,\n    const short\n>::value));\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::mpl::at_c<result_type, 3>::type,\n    unsigned long\n>::value));\n```", "```cpp\n    BOOST_STATIC_ASSERT((\n        boost::mpl::size<Types>::type::value\n        ==\n        boost::mpl::size<Modifiers>::type::value\n    ));\n```", "```cpp\nvoid boost_mpl_transform_pseoudo_code() {\n    vector result;\n    for (std::size_t i = 0; i < Types.size(); ++i) {\n        result.push_back(\n            binary_operator_t(Types[i], Modifiers[i])\n        );\n    }\n    return result;\n}\n```", "```cpp\n    typedef boost::mpl::if_<\n        boost::is_same<boost::mpl::_2, unsigne>,\n        boost::make_unsigned<boost::mpl::_1>,\n        boost::mpl::if_<\n            boost::is_same<boost::mpl::_2, constant>,\n            boost::add_const<boost::mpl::_1>,\n            boost::mpl::_1\n        >\n    > binary_operator_t;\n```", "```cpp\n>::type binary_operator_t; // INCORRECT! \n```", "```cpp\nbinary_operator_t foo; \n// Attempt to call binary_operator_t::operator() without parameters, \n// when it has only two parameters overloads. \nfoo(); \n```", "```cpp\ntemplate <class... T> \nstruct vt_example { \n    typedef typename boost::mpl::vector<T...> type; \n}; \n\nBOOST_STATIC_ASSERT((boost::is_same< \n    boost::mpl::at_c<vt_example<int, char, short>::type, 0>::type, \n    int \n>::value)); \n```", "```cpp\ntemplate <class T1, class T2>\nauto my_function_cpp11(const T1& v1, const T2& v2)\n    -> decltype(v1 + v2)\n{\n    return v1 + v2;\n}\n```", "```cpp\n#include <cassert>\n\nstruct s1 {};\nstruct s2 {};\nstruct s3 {};\n\ninline s3 operator + (const s1& /*v1*/, const s2& /*v2*/) {\n    return s3();\n}\n\ninline s3 operator + (const s2& /*v1*/, const s1& /*v2*/) {\n    return s3();\n}\n\nint main() {\n    s1 v1;\n    s2 v2;\n\n    s3 res0 = my_function_cpp11(v1, v2);\n    assert(my_function_cpp11('\\0', 1) == 1);\n}\n```", "```cpp\n#include <boost/type_traits/common_type.hpp>\n```", "```cpp\nnamespace result_of {\n\n    template <class T1, class T2>\n    struct my_function_cpp03 {\n        typedef typename boost::common_type<T1, T2>::type type;\n    };\n```", "```cpp\n    template <> \n    struct my_function_cpp03<s1, s2> {\n        typedef s3 type;\n    };\n\n    template <>\n    struct my_function_cpp03<s2, s1> {\n        typedef s3 type;\n    };\n} // namespace result_of\n```", "```cpp\ntemplate <class T1, class T2>\ntypename result_of::my_function_cpp03<T1, T2>::type\n    my_function_cpp03(const T1& v1, const T2& v2)\n{\n    return v1 + v2;\n}\n```", "```cpp\nint main() {\n    s1 v1;\n    s2 v2;\n\n    s3 res1 = my_function_cpp03(v1, v2);\n    assert(my_function_cpp03('\\0', 1) == 1);\n}\n```", "```cpp\ntemplate <class T1, class T2>\ntypename result_of::my_function_cpp03<T1, T2>::type\n    my_function_cpp03(const T1& v1, const T2& v2);\n```", "```cpp\ntypedef void(*function_t)(int);\n\nfunction_t higher_order_function1();\nvoid higher_order_function2(function_t f);\nfunction_t higher_order_function3(function_t f); f); \n```", "```cpp\ntemplate <class Param1, class Param2, class Func1, class Func2>\nstruct coalesce;\n```", "```cpp\n#include <boost/mpl/apply.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/type_traits/is_same.hpp>\n```", "```cpp\ntemplate <class Param1, class Param2, class Func1, class Func2>\nstruct coalesce {\n    typedef typename boost::mpl::apply<Func1, Param1>::type type1;\n    typedef typename boost::mpl::apply<Func2, Param2>::type type2;\n```", "```cpp\n    typedef typename boost::mpl::if_<\n        boost::is_same< boost::mpl::false_, type1>,\n        type2,\n        type1\n    >::type type;\n};\n```", "```cpp\n#include <boost/static_assert.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/next.hpp>\n\nusing boost::mpl::_1;\nusing boost::mpl::_2;\n\ntypedef coalesce<\n    boost::mpl::true_,\n    boost::mpl::int_<5>,\n    boost::mpl::not_<_1>,\n    boost::mpl::next<_1>\n>::type res1_t;\nBOOST_STATIC_ASSERT((res1_t::value == 6));\n\ntypedef coalesce<\n    boost::mpl::false_,\n    boost::mpl::int_<5>,\n    boost::mpl::not_<_1>,\n    boost::mpl::next<_1>\n>::type res2_t;\nBOOST_STATIC_ASSERT((res2_t::value));\n```", "```cpp\nstruct fallback;\n\ntemplate <\n        class Func,\n        class Param,\n        class Cond,\n        class Fallback = fallback>\nstruct apply_if; \n```", "```cpp\n#include <boost/mpl/apply.hpp>\n#include <boost/mpl/eval_if.hpp>\n#include <boost/mpl/identity.hpp>\n```", "```cpp\ntemplate <class Func, class Param, class Cond, class Fallback>\nstruct apply_if {\n    typedef typename boost::mpl::apply<\n        Cond, Param\n    >::type condition_t;\n```", "```cpp\n    typedef boost::mpl::apply<Func, Param> applied_type; \n```", "```cpp\n    typedef typename boost::mpl::eval_if_c<\n        condition_t::value,\n        applied_type,\n        boost::mpl::identity<Fallback>\n    >::type type;\n};\n```", "```cpp\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/is_integral.hpp>\n#include <boost/type_traits/make_unsigned.hpp>\n#include <boost/type_traits/is_same.hpp>\n\nusing boost::mpl::_1;\nusing boost::mpl::_2;\n\ntypedef apply_if<\n    boost::make_unsigned<_1>,\n    int,\n    boost::is_integral<_1>\n>::type res1_t;\n\nBOOST_STATIC_ASSERT((\n    boost::is_same<res1_t, unsigned int>::value\n));\n\ntypedef apply_if<\n    boost::make_unsigned<_1>,\n    float,\n    boost::is_integral<_1>\n>::type res2_t;\n\nBOOST_STATIC_ASSERT((\n    boost::is_same<res2_t, fallback>::value\n));\n```", "```cpp\n// Will fail with static assertion somewhere deeply in the implementation\n// of boost::make_unsigned<_1> if we do not evaluate the function lazily.\ntypedef apply_if<\n    boost::make_unsigned<_1>,\n    float,\n    boost::is_integral<_1>\n>::type res2_t;\n\nBOOST_STATIC_ASSERT((\n    boost::is_same<res2_t, fallback>::value\n));\n```", "```cpp\ntemplate <class Func, class Param, class Cond, class Fallback>\nstruct apply_if {\n    typedef typename boost::mpl::apply<\n        Cond, Param\n    >::type condition_t;\n\n    // Incorrect: metafunction is evaluated when `::type` called.\n    typedef typename boost::mpl::apply<Func, Param>::type applied_type;\n\n    typedef typename boost::mpl::if_c<\n        condition_t::value,\n        applied_type,\n        boost::mpl::identity<Fallback>\n    >::type type;\n};\n```", "```cpp\ntemplate<bool C, typename F1, typename F2>\nstruct eval_if_c {\n    typedef typename if_c<C,F1,F2>::type f_;\n    typedef typename f_::type type; // call `::type` only for one parameter\n};\n```", "```cpp\ntemplate <class T> \nstruct identity { \n    typedef T type; \n}; \n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <boost/noncopyable.hpp>\n\nstruct stringize_functor: boost::noncopyable {\nprivate:\n    std::string& result;\n\npublic:\n    explicit stringize_functor(std::string& res)\n        : result(res)\n    {}\n\n    template <class T>\n    void operator()(const T& v) const {\n        result += boost::lexical_cast<std::string>(v);\n    }\n};\n```", "```cpp\n#include <boost/fusion/include/for_each.hpp>\n\ntemplate <class Sequence>\nstd::string stringize(const Sequence& seq) {\n    std::string result;\n    boost::fusion::for_each(seq, stringize_functor(result));\n    return result;\n}\n```", "```cpp\n#include <iostream>\n#include <boost/fusion/include/vector.hpp>\n#include <boost/fusion/adapted/boost_tuple.hpp>\n#include <boost/fusion/adapted/std_pair.hpp>\n#include <boost/fusion/adapted/boost_array.hpp>\n\nstruct cat{};\n\nstd::ostream& operator << (std::ostream& os, const cat& ) {\n    return os << \"Meow! \";\n}\n\nint main() {\n    boost::fusion::vector<cat, int, std::string> tup1(cat(), 0, \"_0\");\n    boost::tuple<cat, int, std::string> tup2(cat(), 0, \"_0\");\n    std::pair<cat, cat> cats;\n    boost::array<cat, 10> many_cats;\n\n    std::cout << stringize(tup1) << '\\n' \n        << stringize(tup2) << '\\n'\n        << stringize(cats) << '\\n'\n        << stringize(many_cats) << '\\n';\n}\n```", "```cpp\n Meow! 0_0\n Meow! 0_0\n Meow! Meow! \n Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow!\n```", "```cpp\n#include <boost/fusion/adapted/boost_tuple.hpp> \n#include <boost/fusion/adapted/std_pair.hpp> \n#include <boost/fusion/adapted/boost_array.hpp> \n```", "```cpp\n#include <string>\n#include <cassert>\n\n#include <boost/tuple/tuple.hpp>\n\n#include <boost/fusion/include/vector.hpp>\n#include <boost/fusion/include/at_c.hpp>\n\nvoid tuple_example() {\n    boost::tuple<int, int, std::string> tup(1, 2, \"Meow\");\n    assert(boost::get<0>(tup) == 1);\n    assert(boost::get<2>(tup) == \"Meow\");\n}\n\nvoid fusion_tuple_example() {\n    boost::fusion::vector<int, int, std::string> tup(1, 2, \"Meow\");\n    assert(boost::fusion::at_c<0>(tup) == 1);\n    assert(boost::fusion::at_c<2>(tup) == \"Meow\");\n}\n```", "```cpp\n    functor(boost::fusion::at_c<0>(tup2));\n    functor(boost::fusion::at_c<1>(tup2));\n    functor(boost::fusion::at_c<2>(tup2));\n```", "```cpp\n#include <utility>\n#include <tuple>\n\ntemplate <class Tuple, class Func, std::size_t... I>\nvoid stringize_cpp11_impl(const Tuple& t, const Func& f, std::index_sequence<I...>) {\n    // Oops. Requires C++17 fold expressions feature.\n    // (f(std::get<I>(t)), ...);\n\n    int tmp[] = { 0, (f(std::get<I>(t)), 0)... };\n    (void)tmp; // Suppressing unused variable warnings.\n}\n\ntemplate <class Tuple>\nstd::string stringize_cpp11(const Tuple& t) {\n    std::string result;\n    stringize_cpp11_impl(\n        t,\n        stringize_functor(result),\n        std::make_index_sequence< std::tuple_size<Tuple>::value >()\n    );\n    return result;\n}\n```", "```cpp\ntemplate <class Tuple>\nstd::string stringize_cpp20(const Tuple& t) {\n    std::string result;\n    for constexpr(const auto& v: t) {\n        result += boost::lexical_cast<std::string>(v);\n    }\n    return result;\n}\n```", "```cpp\n#include <boost/fusion/include/remove_if.hpp>\n#include <boost/type_traits/is_arithmetic.hpp>\n```", "```cpp\ntemplate <class Sequence>\ntypename boost::fusion::result_of::remove_if<\n    const Sequence, \n    boost::is_arithmetic<boost::mpl::_1> \n>::type get_nonarithmetics(const Sequence& seq) \n{\n    return boost::fusion::remove_if< \n        boost::is_arithmetic<boost::mpl::_1> \n    >(seq);\n}\n```", "```cpp\ntemplate <class Sequence>\ntypename boost::fusion::result_of::remove_if<\n    const Sequence, \n    boost::mpl::not_< boost::is_arithmetic<boost::mpl::_1> >\n>::type get_arithmetics(const Sequence& seq) \n{\n    return boost::fusion::remove_if< \n        boost::mpl::not_< boost::is_arithmetic<boost::mpl::_1> >\n    >(seq);\n}\n```", "```cpp\n#include <boost/fusion/include/vector.hpp>\n#include <cassert>\n#include <boost/fusion/include/at_c.hpp>\n#include <boost/blank.hpp>\n\nint main() {\n    typedef boost::fusion::vector<\n        int, boost::blank, boost::blank, float\n    > tup1_t;\n    tup1_t tup1(8, boost::blank(), boost::blank(), 0.0);\n\n    boost::fusion::vector<boost::blank, boost::blank> res_na\n        = get_nonarithmetics(tup1);\n    boost::fusion::vector<int, float> res_a = get_arithmetics(tup1);\n    assert(boost::fusion::at_c<0>(res_a) == 8);\n}\n```", "```cpp\ntypename boost::fusion::result_of::remove_if<\n    const Sequence, \n    boost::is_arithmetic<boost::mpl::_1> \n>::type\n```", "```cpp\n    return boost::fusion::remove_if< \n        boost::is_arithmetic<boost::mpl::_1> \n    >(seq);\n```", "```cpp\n#include <boost/fusion/include/mpl.hpp>\n#include <boost/mpl/transform.hpp>\n#include <boost/type_traits/remove_const.hpp>\n\ntemplate <class Sequence>\nstruct make_nonconst: boost::mpl::transform<\n    Sequence,\n    boost::remove_const<boost::mpl::_1>\n> {};\n\ntypedef boost::fusion::vector<\n    const int, const boost::blank, boost::blank\n> type1;\ntypedef make_nonconst<type1>::type nc_type;\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::fusion::result_of::value_at_c<nc_type, 0>::type,\n    int\n>::value));\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::fusion::result_of::value_at_c<nc_type, 1>::type,\n    boost::blank\n>::value));\n\nBOOST_STATIC_ASSERT((boost::is_same<\n    boost::fusion::result_of::value_at_c<nc_type, 2>::type,\n    boost::blank\n>::value));\n```", "```cpp\n#include <boost/hana/traits.hpp>\n```", "```cpp\nconstexpr auto is_arithmetic_ = [](const auto& v) {\n    auto type = boost::hana::typeid_(v);\n    return boost::hana::traits::is_arithmetic(type);\n};\n```", "```cpp\n#include <boost/hana/remove_if.hpp>\n\ntemplate <class Sequence>\nauto get_nonarithmetics(const Sequence& seq)  {\n    return boost::hana::remove_if(seq, [](const auto& v) {\n        return is_arithmetic_(v);\n    });\n}\n```", "```cpp\n#include <boost/hana/filter.hpp>\n\nconstexpr auto get_arithmetics = [](const auto& seq) {\n    return boost::hana::filter(seq, is_arithmetic_);\n};\n```", "```cpp\n#include <boost/hana/tuple.hpp>\n#include <boost/hana/integral_constant.hpp>\n#include <boost/hana/equal.hpp>\n#include <cassert>\n\nstruct foo {\n    bool operator==(const foo&) const { return true; }\n    bool operator!=(const foo&) const { return false; }\n};\n\nint main() {\n    const auto tup1\n        = boost::hana::make_tuple(8, foo{}, foo{}, 0.0);\n\n    const auto res_na = get_nonarithmetics(tup1);\n    const auto res_a = get_arithmetics(tup1);\n\n    using boost::hana::literals::operator \"\"_c;\n    assert(res_a[0_c] == 8);\n\n    const auto res_na_expected = boost::hana::make_tuple(foo(), foo());\n    assert(res_na == res_na_expected);\n}\n```", "```cpp\nauto type = boost::hana::typeid_(v);\n```", "```cpp\nconstexpr auto is_arithmetic_ = [] (const auto& v) {\n    assert(false);\n    auto type = boost::hana::typeid_(v);\n    return boost::hana::traits::is_arithmetic(type);\n};\n```", "```cpp\n    using boost::hana::literals::operator \"\"_c;\n    assert(res_a[0_c] == 8);\n```"]