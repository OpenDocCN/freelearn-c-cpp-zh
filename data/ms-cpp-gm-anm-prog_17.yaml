- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Adding Simple Navigation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加简单导航
- en: Welcome to *Chapter 13*! In the previous chapter, we created a separate octree
    to enhance collision detection, allowing us to detect collisions between instances
    and level geometry in a quick and computationally cheap way. Then we added simple
    gravity to the application to keep the instances on the ground of the map, eventually
    resulting in the instances walking on the level floor and small hills. Finally,
    we used inverse kinematics on the feet of the instances to keep both feet on the
    ground when climbing hills or sloped areas of a map.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 *第 13 章*！在前一章中，我们创建了一个单独的八叉树来增强碰撞检测，使我们能够快速且计算成本低廉地检测实例与关卡几何之间的碰撞。然后我们向应用程序添加了简单的重力，以使实例保持在地图的地面上，最终导致实例在关卡地板和小山上行走。最后，我们使用逆运动学在实例的脚上，以保持两脚在爬坡或地图斜坡区域时都保持在地面。
- en: In this chapter, we will add pathfinding and navigation. We start with a brief
    overview of methods used for navigation in computer games, followed by an exploration
    and the implementation of the A* path-finding algorithm. Next, we will add navigation
    targets to the application, enabling a simple way to place path destinations in
    the virtual world. At the end of the chapter, we will implement the navigation
    toward the waypoints, allowing the instances to walk or run toward a defined target.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加路径查找和导航功能。我们首先简要概述计算机游戏中用于导航的方法，然后探索并实现 A* 路径查找算法。接下来，我们将导航目标添加到应用程序中，使得在虚拟世界中放置路径目的地变得简单。本章的最后，我们将实现向航点导航，使得实例能够向定义的目标行走或奔跑。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of different ways to navigate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同导航方式的概述
- en: The A* path-finding algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A* 路径查找算法
- en: Adding navigation targets to the map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将导航目标添加到地图中
- en: Navigating instances to a target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实例导航到目标
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code for this chapter is available in the `chapter13` folder, in
    the `01_opengl_navigation` subfolder for OpenGL and the `02_vulkan_navigation`
    subfolder for Vulkan.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于 `chapter13` 文件夹中，对于 OpenGL 在 `01_opengl_navigation` 子文件夹中，对于 Vulkan
    在 `02_vulkan_navigation` 子文件夹中。
- en: An overview of different ways to navigate
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同导航方式的概述
- en: Pathfinding and navigation have been used in video games for much longer than
    one might think. Let’s explore a couple of navigation methods.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找和导航在视频游戏中被使用的时间比人们想象的要长。让我们探索几种导航方法。
- en: Distance-based navigation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于距离的导航
- en: One of the oldest games using a simple algorithm to mimic intelligent behavior
    for enemies is **Pac-Man** by **Namco**. Each of the four ghosts (Blinky, Pinky,
    Inky, and Clyde) has a slightly different kind of “character,” created only by
    the target point of the ghost’s movement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单算法来模拟敌人智能行为的最早游戏之一是 **Namco** 的 **Pac-Man**。四个幽灵（Blinky、Pinky、Inky 和 Clyde）中的每一个都有一种略有不同的“性格”，仅由幽灵移动的目标点创建。
- en: While the red ghost (Blinky) is chasing Pac-Man directly, the pink ghost (Pinky)
    and the blue ghost (Inky) will try to get in front of Pac-Man, effectively trying
    to surround the player. The fourth ghost (the orange Clyde) has “a mind of its
    own” and switches between chasing the player and running away.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当红色幽灵（Blinky）直接追逐 Pac-Man 时，粉红色幽灵（Pinky）和蓝色幽灵（Inky）会试图在 Pac-Man 前面，实际上是在试图包围玩家。第四个幽灵（橙色的
    Clyde）有“自己的想法”，在追逐玩家和逃跑之间切换。
- en: 'The decision about the new path to choose is made only at the intersections
    in the game’s maze and is based entirely on the distance to the target tile for
    all possible ways at the intersection. The game does not use more advanced look-ahead
    path planning, sometimes leading to a bad decision. *Figure 13.1* shows such a
    decision situation at an intersection:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择新路径的决定仅发生在游戏迷宫的交叉路口，并且完全基于交叉路口所有可能路径到目标格子的距离。游戏没有使用更高级的预览路径规划，有时会导致不良决策。*图
    13.1* 展示了交叉路口的一个这样的决策情况：
- en: '![](img/B22428_13_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_01.png)'
- en: 'Figure 13.1: Navigation decision of the red ghost in Pac-Man'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：Pac-Man 中红色幽灵的导航决策
- en: In *Figure 13.1*, the green box is the field triggering a decision to go left
    or right and the two dashed green lines are the direct distances to the red-outlined
    target tile. Even though the right path is shorter, the left path will be chosen
    due to the shorter decision distance on the left, creating erratic behavior of
    the ghost. A link is available in the *Additional resources* section with in-depth
    information about the internals of ghost navigation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.1*中，绿色方框是触发向左或向右决策的区域，两条虚线绿色线是到红色轮廓目标格子的直接距离。尽管右边的路径更短，但由于左边的决策距离更短，所以会选择左边的路径，从而产生幽灵的随机行为。在*附加资源*部分提供了一个链接，提供了关于幽灵导航内部深入信息的链接。
- en: Simple distance-based navigation is still used in games today, for instance,
    to find the spot where an enemy could intercept the player, based on the speed
    and direction of both entities. Planning the path to the player is then done with
    a graph-based navigation algorithm.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的基于距离的导航至今仍在游戏中使用，例如，根据两个实体的速度和方向，找到敌人可能拦截玩家的位置。然后使用基于图的导航算法规划到玩家的路径。
- en: Graph-based navigation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于图的导航
- en: In a graph, search algorithms use the nodes of a graph to describe locations
    on a game map and the edges to describe the connections between the nodes. By
    building a graph of the map, the shortest path between two locations can be found
    in an organized manner.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，搜索算法使用图的节点来描述游戏地图上的位置，使用边来描述节点之间的连接。通过构建地图的图，可以以有组织的方式找到两个位置之间的最短路径。
- en: 'Several graph algorithms are used in navigation. The most common ones are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在导航中使用了多个图算法。最常见的是：
- en: '**Depth-First Search** (**DFS**)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度优先搜索**（**DFS**）'
- en: '**Breadth-First Search** (**BFS**)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广度优先搜索**（**BFS**）'
- en: Dijkstra’s algorithm
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法
- en: A* (pronounced “A star”)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A*（发音为“A star”）
- en: DFS and BFS algorithms
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DFS和BFS算法
- en: 'Both of these are simple algorithms. While DFS traverses the graph “depth-first,”
    from the start node to the most distant node, BFS visits the nearest nodes first,
    advancing in “rings” to the next nodes. *Figure 13.2* shows an example graph made
    of six nodes named A to F:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是简单的算法。虽然DFS遍历图“深度优先”，从起始节点到最远的节点，但BFS首先访问最近的节点，然后以“环”的形式前进到下一个节点。*图13.2*显示了由六个节点A到F组成的示例图：
- en: '![](img/B22428_13_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_13_02.png)'
- en: 'Figure 13.2: BFS and DFS'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：BFS和DFS
- en: The BFS algorithm on the left side of *Figure 13.2* starts with the closest
    nodes (B, C, and D) after the root node (A) and then traverses to nodes E and
    F. The DFS algorithm on the right side of *Figure 13.2* traverses child node D
    and D’s child node (F) first, advancing to nodes C and E, and, finally, to node
    B.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.2*的左侧，BFS算法从根节点（A）之后的最近节点（B、C和D）开始，然后遍历到节点E和F。在*图13.2*的右侧，DFS算法首先遍历子节点D和D的子节点（F），然后前进到节点C和E，最后到节点B。
- en: Dijkstra’s algorithm
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法
- en: Dijkstra’s algorithm adds weights to the edges of a graph. The weights can be
    seen as costs or distances to travel from one node to another, depending on the
    problem to solve. Dijkstra’s algorithm traverses the entire graph, building a
    table containing the shortest paths from a start node to all other nodes of the
    graph.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 迪杰斯特拉算法为图的边添加权重。权重可以看作是从一个节点到另一个节点的成本或距离，具体取决于要解决的问题。迪杰斯特拉算法遍历整个图，构建一个包含从起始节点到图中所有其他节点的最短路径的表。
- en: '*Figure 13.3* shows the starting graph and the result after all steps of the
    algorithm:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.3*显示了算法所有步骤后的起始图和结果：'
- en: '![](img/B22428_13_03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_13_03.png)'
- en: 'Figure 13.3: A graph and the shortest distances from A to all other nodes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：一个图和从A到所有其他节点的最短距离
- en: By using Dijkstra’s algorithm, any weighted graph can be traversed to find the
    paths with the lowest costs (or distances) from one node to all other nodes, but
    the algorithm must be rerun for every start node. For a full description of the
    algorithm, a link in the *Additional resources* section is provided showing the
    steps of finding the shortest distances for the graph in *Figure 13.3*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用迪杰斯特拉算法，任何加权图都可以遍历以找到从节点到所有其他节点的最低成本（或距离）路径，但算法必须为每个起始节点重新运行。关于算法的完整描述，在*附加资源*部分提供了一个链接，展示了在*图13.3*中找到图的最短距离的步骤。
- en: A* algorithm
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A*算法
- en: 'A* uses Dijkstra’s algorithm as a basis, but two additions are made:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法以迪杰斯特拉算法为基础，但增加了两个改进：
- en: A so-called **heuristic** is added to each node, stating the estimated distance
    from each node to the target node.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个节点都添加了一个所谓的**启发式**，表示从每个节点到目标节点的估计距离。
- en: The algorithm searches from a start node to a specified target node and usually
    terminates when the target node has been reached.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法从起始节点搜索到指定的目标节点，通常在目标节点被到达时终止。
- en: By combining the distance from the start node to a node and the estimated distance
    from the same node to the target node and using the shortest sum while traversing
    to the next node, A* does a directed search toward the target node. So, instead
    of doing an undirected search like BFS or DFS, A* always heads in the direction
    of the target node. We will discuss A* in depth in the *The A* path-finding algorithm*
    section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合从起始节点到节点的距离和从同一节点到目标节点的估计距离，并在遍历到下一个节点时使用最短总和，A*进行有向搜索以到达目标节点。因此，与BFS或DFS这样的无向搜索不同，A*始终朝向目标节点的方向前进。我们将在*A*路径查找算法*部分深入讨论A*。
- en: One drawback of the algorithms in this section is that they have to recreate
    the entire path if the target is not static. For dynamic targets, algorithms like
    LPA*, D*, or D*-Lite could deliver better results. Also, several other path-finding
    algorithms have been created since the introduction of A*, aiming for special
    environments like in robotics, or to further optimize the outcome path-finding
    process, like in Theta*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节算法的一个缺点是，如果目标是动态的，它们必须重新创建整个路径。对于动态目标，LPA*、D*或D*-Lite等算法可能能提供更好的结果。此外，自A*算法引入以来，还创建了其他几种路径查找算法，旨在针对特殊环境，如机器人技术，或进一步优化路径查找过程，如Theta*。
- en: Before exploring A*, let’s look at another popular navigation type in video
    games, using triangles or other polygons to describe the walkable area for bots
    and NPCs, and also take a short look at machine learning as an alternative version
    to create navigation data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索A*之前，让我们看看视频游戏中另一种流行的导航类型，使用三角形或其他多边形来描述机器人和NPC的可行走区域，并简要了解一下机器学习作为创建导航数据的替代版本。
- en: Mesh-based navigation
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格导航
- en: Simple games like Pac-Man and many strategy games use distance-based navigation
    by dividing the world into a grid, usually built from rectangular or hexagonal
    structures. But the needs of three-dimensional games (like an open world) or first-
    and third-person exploration and fighting games are different. Due to overlapping
    parts of the virtual world, a three-dimensional structure is needed to be able
    to guide computer-controlled characters through the map.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的游戏，如Pac-Man和许多策略游戏，通过将世界划分为网格（通常由矩形或六边形结构构建）来使用基于距离的导航。但三维游戏（如开放世界）或第一人称和第三人称探索和战斗游戏的需求不同。由于虚拟世界的重叠部分，需要一个三维结构来引导计算机控制的角色通过地图。
- en: Most games with three-dimensional maps use either navigation meshes, area awareness,
    or a combination of both.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用三维地图的游戏要么使用导航网格，要么使用区域感知，或者两者结合使用。
- en: Navigation meshes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航网格
- en: '**Navigation meshes** (also called **NavMeshes**) were introduced in games
    around the year 2000\. A navigation mesh is an additional data structure made
    of polygons (triangles in most implementations), overlaying the level geometry.
    The polygons in a navigation mesh mark the walkable area of a level, omitting
    any objects and structures a computer-controlled character could collide with.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航网格**（也称为**NavMeshes**）大约在2000年左右在游戏中被引入。导航网格是由多边形（大多数实现中为三角形）组成的一个附加数据结构，覆盖在关卡几何之上。导航网格中的多边形标记了关卡的可行走区域，省略了计算机控制的角色可能与之碰撞的任何对象和结构。'
- en: 'By using a navigation mesh, a bot or NPC can walk around in the virtual world
    while avoiding costly collision checks with static level geometry if the character
    stays on the navigation mesh. Only if the character can leave the navigation mesh
    are collision checks required. In combination with a graph-based algorithm like
    A*, fine-grained control of the behavior of computer-controlled characters is
    possible. A link to a comprehensive introduction to pathfinding with navigation
    meshes is available in the *Additional resources* section. *Figure 13.4* shows
    a simple example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用导航网格，机器人或NPC可以在虚拟世界中行走，如果角色保持在导航网格上，则无需进行昂贵的与静态关卡几何的碰撞检查。只有当角色可以离开导航网格时，才需要进行碰撞检查。与基于图的算法（如A*）结合使用时，可以实现计算机控制角色的精细行为控制。在*附加资源*部分中有一个关于使用导航网格进行路径查找的全面介绍链接。*图13.4*展示了简单的一个例子：
- en: '![](img/B22428_13_04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_04.png)'
- en: 'Figure 13.4: Navigation mesh with start (green), target (red), and path from
    start to target'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：带有起点（绿色）、目标（红色）和从起点到目标路径的导航网格
- en: In *Figure 13.4*, the top picture shows the shortest possible path from the
    starting triangle (green) to the target triangle (red) by using the next vertex
    in a line of sight to the next sharp corner of the mesh.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.4*中，顶部图片显示了从起始三角形（绿色）到目标三角形（红色）的最短路径，该路径通过使用视线中的下一个顶点到网格下一个尖锐角的下一点。
- en: In comparison, the path in the middle picture uses the triangle centers as graph
    nodes for the path-finding algorithm, and the bottom picture uses the inner triangle
    edges as graph nodes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，中间图片中的路径使用三角形中心作为路径查找算法的图节点，而底部图片使用内部三角形边作为图节点。
- en: The path’s quality depends on the mesh and which part or parts of a triangle
    will be used for the graph node. Combinations of the methods in *Figure 13.4*
    are possible, so both the center and the middle of triangle edges could be used
    as graph nodes. The resulting path can also be smoothed by skipping to the next
    directly visible node and by using splines for the curves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的质量取决于网格以及将用于图节点的是三角形的哪一部分或几部分。*图13.4*中所示方法的组合是可能的，因此三角形的中心和边的中点都可以用作图节点。生成的路径还可以通过跳到下一个直接可见的节点和使用样条曲线进行平滑处理。
- en: Be aware that if the edge navigation mesh is too close to walls or borders in
    a narrow passage, an instance may collide with the walls, generating additional
    movement corrections or leading to an impassable part of the mesh. Static obstacles
    in a level should also be bypassed at a safe distance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果边缘导航网格在狭窄通道的墙壁或边界附近太近，实例可能会与墙壁碰撞，产生额外的运动校正，或者导致网格的一部分无法通行。层级中的静态障碍物也应保持在安全距离之外。
- en: As a rule of thumb, use the distance between the edges and the center of the
    axis-aligned bounding box of an instance as the minimum distance between the edges
    of the navigation mesh and the adjacent level geometry. By keeping the instance
    away from walls at any time, no collision can occur during normal navigation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照经验法则，使用实例的边缘和轴对齐边界框中心之间的距离作为导航网格边缘和相邻层级几何之间的最小距离。通过在任何时候将实例远离墙壁，可以在正常导航期间避免碰撞。
- en: Generating a navigation mesh from level data
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从层级数据生成导航网格
- en: Usually, a navigation mesh will be created by hand and added to the level data.
    But we need a solution for levels found on the internet, so we will do a shortcut
    in the code and use the same upward-facing triangles as “possibly walkable ground”
    that are used for the detection if the instance collides with the level ground.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，导航网格会手动创建并添加到层级数据中。但我们需要一个解决方案来处理在互联网上找到的层级，因此我们将在代码中采取捷径，并使用与检测实例是否与层级地面碰撞时相同的向上三角形作为“可能可通行地面”。
- en: In combination with adjacency relations between all ground triangles, an estimation
    of the walkable area in the level can be achieved. A couple of enhancements to
    the ground area creation code are available as tasks in the *Practical sessions*
    section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结合所有地面三角形之间的相邻关系，可以估算出层级中的可通行区域。在*实践课程*部分中，有几个用于地面区域创建代码的改进作为任务提供。
- en: 'By using navigation meshes, two kinds of navigation are possible: free roaming
    through the virtual world and patrolling between waypoints.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用导航网格，可以实现两种类型的导航：在虚拟世界中自由漫游和在路点之间巡逻。
- en: Free navigation
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自由导航
- en: With free navigation, any point on a map can be a target point for the start
    and destination. Moving from one part of the level to another may be costly to
    calculate; in the worst case, the entire mesh must be checked during pathfinding.
    Also, the path of the character may be entirely different between two path plannings,
    depending on the exact position of the start and target.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在自由导航中，地图上的任何一点都可以作为起点和目的地的目标点。从一个层级的一部分移动到另一部分可能需要计算成本；在最坏的情况下，必须在路径查找过程中检查整个网格。此外，根据起点和目标的确切位置，两次路径规划之间的角色路径可能完全不同。
- en: Waypoint navigation
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路点导航
- en: A better approach for mesh-based navigation is to define waypoints on the navigation
    mesh that are visible to each other. For instance, every door in a group of rooms
    will be a waypoint or every fork in the road. When a bot moves through the virtual
    world, a waypoint is set as the next target after reaching the desired waypoint.
    If the player is spotted and then lost, the bot can return to the nearest waypoint.
    By making sure that the computer-controlled character can always “see” at least
    one waypoint, path planning to that next waypoint becomes cheap and easy to calculate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于网格的导航，更好的方法是在导航网格上定义彼此可见的航点。例如，每个房间组中的每扇门都会是一个航点，或者每条道路的每个分叉点。当一个机器人穿过虚拟世界时，在达到期望的航点后，将设置航点作为下一个目标。如果玩家被发现然后失踪，机器人可以返回到最近的航点。通过确保计算机控制的角色总能“看到”至少一个航点，到下一个航点的路径规划变得便宜且易于计算。
- en: Area awareness system
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区域感知系统
- en: In 1999, **id Software** used a system called **area awareness** in **Quake
    III Arena**. Instead of two-dimensional graphs, a simplified three-dimensional
    representation of the levels was created, containing all information about the
    level structure, other bots, and the player.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年，**id Software**在**Quake III Arena**中使用了名为**区域感知**的系统。它不是使用二维图表，而是创建了一个简化的三维水平表示，其中包含有关水平结构、其他机器人和玩家的所有信息。
- en: The bots can traverse the awareness areas not only by walking, jumping, or swimming
    but also by using a teleporter, a jump pad, or even by doing a rocket jump. With
    such a large repertoire of actions, a bot can easily follow the player around
    in the level or try to cut off the player’s path.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人不仅可以通过行走、跳跃或游泳穿越感知区域，还可以使用传送门、跳跃垫，甚至火箭跳跃。有了这样丰富的动作库，机器人可以轻松地跟随玩家在水平中移动，或者试图切断玩家的路径。
- en: A full description of the area awareness system is available in a link to a
    PDF document in the *Additional resources* section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*附加资源*部分的PDF文档链接中可以找到区域感知系统的完整描述。
- en: Using machine learning to generate navigation data
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用机器学习生成导航数据
- en: A more recent way to create navigation data for computer-controlled characters
    is machine learning, mostly in the form of so-called **reinforced learning**.
    During reinforced learning, an agent representing the character explores the virtual
    world on its own in a large amount of “trial-and-error” style rounds, but with
    added rewards for achieving a defined task or a punishment for failing to complete
    the task.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为计算机控制的角色创建导航数据的一种更近的方法是机器学习，主要是所谓的**强化学习**。在强化学习过程中，代表角色的代理在大量“尝试错误”风格的回合中自行探索虚拟世界，但会因完成定义的任务而获得奖励，或因未能完成任务而受到惩罚。
- en: Such a task could be something like “Reach a defined target point with maximum
    health,” “Don’t fall off the level,” or “Complete the level in minimum time.”
    By taking the rewards and punishments of previous explorations into account, the
    agent optimizes its behavior to maximize rewards and minimize punishments. When
    the data generated by these agents is used in games, the enemies can utilize the
    strategies from machine learning to appear even more natural when moving around
    in the virtual world.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的任务可能类似于“以最大健康值到达定义的目标点”，“不要从水平掉落”，或者“以最短时间完成水平”。通过考虑先前探索的奖励和惩罚，代理优化其行为以最大化奖励并最小化惩罚。当这些代理生成数据用于游戏时，敌人可以利用机器学习中的策略，在虚拟世界中移动时显得更加自然。
- en: 'Two challenges of machine learning are making the usage time- and cost-expensive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习的两个挑战是使使用时间成本高昂：
- en: Goals, rewards, and punishments must be clearly defined and adjusted during
    the calculations. Even if we humans think that the goals and rewards are well-defined,
    the machine learning algorithm could find unexpected ways to maximize rewards.
    A failure in the setup may result in discarding the data and doing a complete
    restart of the entire machine learning cycle.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标、奖励和惩罚必须在计算过程中明确定义和调整。即使我们认为目标和奖励已经定义得很好，机器学习算法也可能找到意想不到的方式来最大化奖励。设置失败可能会导致丢弃数据，并重新启动整个机器学习周期。
- en: Since machine learning is exploring the virtual world by trial and error, progress
    is non-deterministic and may happen only in insignificant amounts. Even for simple
    tasks, thousands of game rounds must be played to achieve the desired results
    while the game is running. Creating a complex AI that explores big levels of the
    game may need a significant amount of computational resources, leading to excessive
    development costs.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于机器学习是通过试错探索虚拟世界，因此其进展是非确定性的，并且可能只以微不足道的数量发生。即使是简单的任务，在游戏运行期间也必须玩数千轮游戏才能达到期望的结果。创建一个探索游戏大级别的复杂AI可能需要大量的计算资源，从而导致过高的开发成本。
- en: Even though machine learning may produce better results than algorithm-based
    navigation, it is recommended to check the trade-offs between possible improvements
    and additional costs. A link to a video showing the progress of letting a machine
    learn how to drive a car is available in the *Additional resources* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于机器学习的导航可能比基于算法的导航产生更好的结果，但建议检查可能改进和额外成本之间的权衡。在*附加资源*部分有一个视频展示了让机器学习如何驾驶汽车的进展。
- en: After the short round-up of navigation methods, let’s dive into the A* algorithm
    next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要回顾了导航方法之后，让我们接下来深入探讨A*算法。
- en: The A* path-finding algorithm
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A*路径查找算法
- en: The A* algorithm was published in 1968 in the earlier days of computing. A*
    is the result of the path planning for an AI-controlled mobile robot called **Shakey**.
    The robot was developed at the Stanford Research Institute. Its software included
    computer vision and natural language processing, and it was able to do simple
    tasks like driving to a place in the lab on its own, without describing every
    single action in advance. A link is available in the *Additional resources* section
    with more details about the project and the robot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法是在1968年计算机的早期阶段发表的。A*算法是针对一个名为**Shakey**的由人工智能控制的移动机器人的路径规划的结果。该机器人是在斯坦福研究学院开发的。其软件包括计算机视觉和自然语言处理，并且它能够执行简单的任务，比如在没有提前描述每个单独动作的情况下，自己驾驶到实验室的某个地方。在*附加资源*部分有一个链接，提供了更多关于项目和机器人的详细信息。
- en: But what makes A* different from Dijkstra’s algorithm?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么让A*算法与迪杰斯特拉算法（Dijkstra’s algorithm）不同呢？
- en: Estimating the distance to the target
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 估算目标距离
- en: While Dijkstra’s algorithm only uses the weights between nodes, A* adds a heuristic
    value to every node. The heuristic function calculates an estimated cost of the
    cheapest path from every node to the selected target. In many cases, such as for
    large worlds and many nodes, calculating the minimal costs between every pair
    of nodes is computationally expensive, so an “educated guess” for the costs is
    cheaper to calculate and also good enough.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然迪杰斯特拉算法只使用节点之间的权重，但A*算法给每个节点添加一个启发式值。启发式函数计算从每个节点到所选目标的最低成本路径的估计成本。在许多情况下，例如对于大型世界和许多节点，计算每对节点之间的最小成本是计算上昂贵的，因此对成本的“有根据的猜测”更容易计算，并且也足够好。
- en: 'For the heuristics function, any distance calculation function can be used.
    In most cases, either the so-called **L1 norm** will be used, known as the **Manhattan
    distance**, or the **L2 norm**, known as the **Euclidean distance**. *Figure 13.5*
    shows the idea behind both distance calculations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于启发式函数，可以使用任何距离计算函数。在大多数情况下，要么使用所谓的**L1范数**，也称为**曼哈顿距离**，要么使用**L2范数**，也称为**欧几里得距离**。*图13.5*展示了这两种距离计算背后的思想：
- en: '![](img/B22428_13_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_05.png)'
- en: 'Figure 13.5: Manhattan and Euclidean distances from start to target'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：从起点到目标的曼哈顿和欧几里得距离
- en: The Manhattan distance is modeled after the path of a taxicab in Manhattan.
    The streets are organized in parallel lines, crossing at an angle of 90 degrees.
    Like a cab in Manhattan, the blue paths in *Figure 13.5* can only use the grid
    lines between the start and the target. It also does not matter whether we use
    straight, direct lines, as in the dark blue path, or a staircase version, like
    the light blue path; the distance for both paths is identical.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 曼哈顿距离是模仿曼哈顿的出租车路线。街道组织成平行的线条，以90度角相交。就像曼哈顿的出租车一样，*图13.5*中的蓝色路径只能使用起点和目标之间的网格线。我们使用直线、直接线条，如深蓝色路径，或者楼梯式版本，如浅蓝色路径，都没有关系；两条路径的距离是相同的。
- en: In contrast, the Euclidean distance for the green path in *Figure 13.5* is calculated
    by using the Pythagorean theorem. This means squaring the lengths of the distances
    in both directions, summing up the squares, and calculating the square root of
    the sum.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，*图13.5*中绿色路径的欧几里得距离是通过使用勾股定理计算的。这意味着将两个方向上距离的长度的平方相加，然后计算总和的平方根。
- en: Whether Manhattan distance, Euclidean distance, or any other distance calculation
    will be used for the heuristics function of A* heavily depends on the needs of
    the application. For instance, obstacles, hills, or enemies in a game map may
    need to be considered when estimating the distances. An intuitive way to find
    the best function is by drawing the paths for every heuristic function and a set
    of combinations for the start and target node and comparing the results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于A*算法的启发式函数，是使用曼哈顿距离、欧几里得距离还是其他距离计算，这严重取决于应用的需求。例如，在游戏地图中，可能需要考虑障碍物、丘陵或敌人来估计距离。找到最佳函数的一种直观方法是绘制每个启发式函数以及起始节点和目标节点的一组组合路径，并比较结果。
- en: By using the heuristic value to the target node, A* tries to minimize the costs
    of the path to the target for every iteration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用目标节点的启发式值，A*算法试图在每次迭代中使到达目标节点的路径成本最小化。
- en: Minimizing path costs
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化路径成本
- en: In every iteration, A* uses the sum of the known costs of the path *from the
    start* node and the estimated costs *to the target* node for every neighbor of
    the current node to calculate the minimal costs to reach the target node. Then,
    the algorithm chooses the neighboring node with the minimum costs, makes that
    neighboring node the current node, and starts the next iteration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，A*算法使用从起始节点到当前节点所有邻居的已知路径成本和估计成本的总和来计算到达目标节点的最小成本。然后，算法选择具有最小成本的邻居节点，将该邻居节点设为当前节点，并开始下一次迭代。
- en: In addition, A* saves a reference to the current node in each visited neighboring
    node if the overall cost from the start to the target over this neighbor is minimal
    among all neighboring nodes. Storing the parent node in a node allows backtracking
    to the best path from target to source after the target node has been reached.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果从起始节点到目标节点的总成本在所有邻居节点中是最小的，A*算法会在每个访问的邻居节点中保存当前节点的引用。在节点中存储父节点允许在到达目标节点后回溯到从目标到源的最佳路径。
- en: To visualize the algorithm, let’s step through a small example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化算法，让我们逐步通过一个小例子。
- en: Exploring the A*algorithm
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索A*算法
- en: '*Figure 13.6* shows a graph with nodes A, B, C, and D, plus the heuristics
    table from every node to the desired target node, D. The start node, in this case,
    is node A.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13.6*显示了一个包含节点A、B、C和D的图，以及从每个节点到目标节点D的启发式表。在这个例子中，起始节点是节点A。'
- en: '![](img/B22428_13_06.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_06.png)'
- en: 'Figure 13.6: A graph to traverse plus estimated distances to the target node,
    D'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：用于遍历的图以及到目标节点D的估计距离
- en: 'We can immediately see the shortest path from node A to node D: ABCD. But for
    the computer, the A* algorithm must walk through the nodes to find this path.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即看到从节点A到节点D的最短路径：ABCD。但对于计算机来说，A*算法必须遍历节点来找到这条路径。
- en: 'For the first iteration, we visit the neighbors of node A, as shown in *Figure
    13.7*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次迭代，我们访问节点A的邻居，如图*图13.7*所示：
- en: '![](img/B22428_13_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_07.png)'
- en: 'Figure 13.7: Visiting nodes B and C'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：访问节点B和C
- en: Here, we calculate the estimated distance as the sum of the known distance from
    A and the heuristic value of each node. The sum for node B is lower, so we proceed
    to node B. We also remember the parent node for B since A is the direct predecessor
    of B.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们计算估计距离为从A到已知的距离加上每个节点的启发式值。节点B的总和较低，所以我们继续到节点B。我们还记录了B的父节点，因为A是B的直接前驱。
- en: 'Then, we look at all neighbors of node B, as shown in *Figure 13.8*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看节点B的所有邻居，如图*图13.8*所示：
- en: '![](img/B22428_13_08.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_08.png)'
- en: 'Figure 13.8: Visiting nodes C and D'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：访问节点C和D
- en: We do the same calculations for node C and sum up the costs from A to B, B to
    C, and the heuristic from C to D. In an optimized version of A*, our search could
    be already over since we reached the target node, D.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对节点C进行相同的计算，并将从A到B、B到C的成本以及从C到D的启发式值相加。在A*算法的优化版本中，我们的搜索可能已经结束，因为我们已经到达了目标节点D。
- en: 'But we continue here by checking the remaining neighbors of node D in case
    there is an even shorter path available. So, we update the parent node of nodes
    C and D, and visit node C as the last yet unvisited neighbor of node D, as shown
    in *Figure 13.9*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里继续检查节点 D 的剩余邻居，以防有更短的路径可用。因此，我们更新了节点 C 和 D 的父节点，并访问节点 C 作为节点 D 的最后一个未访问的邻居，如图
    *图 13.9* 所示：
- en: '![](img/B22428_13_09.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_09.png)'
- en: 'Figure 13.9: The shortest path from A to D is ABCD'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9：从 A 到 D 的最短路径是 ABCD
- en: Indeed, the path to node D via nodes B and C is much shorter than the path via
    B. So, we set node C as the new parent node for node D. After all the neighboring
    nodes of the target node D have been visited, A* has fulfilled its job to find
    a path from node A to node D.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，通过节点 B 和 C 到节点 D 的路径比通过 B 的路径要短得多。因此，我们将节点 C 设置为节点 D 的新父节点。在访问了目标节点 D 的所有相邻节点之后，A*
    已经完成了从节点 A 到节点 D 的路径查找工作。
- en: 'By backtracking the parent nodes, we get the path from the target to the start.
    By reversing the node order, we now have the shortest path from the start to the
    target: ABCD.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回溯父节点，我们得到从目标到起点的路径。通过反转节点顺序，我们现在有了从起点到目标的最近路径：ABCD。
- en: As you can see, even in this very simple example, A* cares about the total estimated
    costs to the target when choosing the node to proceed with. If the algorithm learns
    about a shorter distance while working on a node, the parent node used to backtrack
    the best path is also updated. In the *Additional resources* section, a link to
    a website with a deep dive into A* is available.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使在这样一个非常简单的例子中，A* 在选择要处理的节点时，也会关注到达目标的总估计成本。如果在处理节点时算法了解到更短的路径，则用于回溯最佳路径的父节点也会更新。在
    *附加资源* 部分中，有一个链接到深入探讨 A* 的网站。
- en: After an overview of the algorithm, let’s add the path-finding code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在概述了算法之后，让我们添加路径查找代码。
- en: Implementing A*-based navigation
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基于 A* 的导航
- en: Since we will not have a simple two-dimensional terrain in most maps, a two-dimensional
    grid for navigation cannot be used. Instead, we will use a navigation mesh to
    find a path from a source object to a target object in the virtual world.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的大多数地图中都不会有简单的二维地形，因此不能使用二维网格进行导航。相反，我们将使用导航网格在虚拟世界中从源对象到目标对象查找路径。
- en: As already stated in the *Navigation meshes* section, creating the meshes is
    at least a partially manual job, depending on the editor used to create the game
    map. Some editors can create a navigation mesh based on the map’s elements, but
    in most cases, the generated mesh must be corrected manually. The navigation mesh
    must be stored on the same map as the rest of the level data or in a separate
    data file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *导航网格* 部分所述，创建网格至少是部分手动工作，这取决于用于创建游戏地图的编辑器。一些编辑器可以根据地图元素创建导航网格，但在大多数情况下，生成的网格必须手动进行修正。导航网格必须存储在包含其余关卡数据的同一张地图上或在单独的数据文件中。
- en: To support both in-map and separate navigation mesh, the path-finding class
    is kept modular when it comes to the walkable ground meshes. For instance, if
    your navigation mesh is saved with a special name in the map file, you could import
    the navigation polygons and their adjacency properties into the path-finding class.
    You also have to import the navigation triangles into a separate triangle octree
    and do an additional ray-to-triangle intersection to find both the ground-level
    triangle and the navigation mesh triangle. The A* path-finding algorithm has also
    been implemented as a separate method, allowing you to easily add other algorithms
    or a different heuristics function.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持地图内和独立的导航网格，当涉及到可通行地面网格时，路径查找类保持模块化。例如，如果您的导航网格在地图文件中以特殊名称保存，则可以将导航多边形及其相邻属性导入路径查找类。您还必须将导航三角形导入一个单独的三角形八叉树，并进行额外的光线到三角形的交点检测，以找到地面级别的三角形和导航网格三角形。A*
    路径查找算法也已作为单独的方法实现，允许您轻松添加其他算法或不同的启发式函数。
- en: In the example code in this chapter, we will use the same idea as for the ground-level
    detection and use the normal of each mesh triangle to decide whether it is walkable
    or not. This method will result in having all upward-facing triangles in the navigation
    mesh, even if the triangles may be unreachable by any instance. But to demonstrate
    the general idea of pathfinding and navigation in a game map, creating a navigation
    mesh from the ground triangles of the map is sufficient and delivers reasonable
    results.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例代码中，我们将使用与地面检测相同的思想，并使用每个网格三角形的法线来判断它是否可通行。这种方法会导致导航网格中所有朝上的三角形，即使这些三角形可能无法通过任何实例到达。但为了展示在游戏地图中路径查找和导航的一般思想，从地图的地面三角形创建导航网格是足够的，并且可以得到合理的结果。
- en: We will use the Euclidean distance to calculate the distance between nodes and
    for the heuristic function, as the triangles in the map are most probably not
    arranged in a rectangular grid. To speed up the distance calculations, we will
    extend the mesh triangle data structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用欧几里得距离来计算节点之间的距离，以及用于启发式函数，因为地图中的三角形最可能不是按矩形网格排列的。为了加快距离计算，我们将扩展网格三角形数据结构。
- en: Preparing the mesh triangles
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备网格三角形
- en: 'The `MeshTriangle` struct is defined in the `OGLRenderData.h` file for OpenGL
    and in the `VkRenderData.h` file for Vulkan. At the end of the `MeshTriangle`
    struct, we add the two new arrays, `edges` and `edgeLengths`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`MeshTriangle`结构体定义在`OGLRenderData.h`文件中，用于OpenGL，在`VkRenderData.h`文件中，用于Vulkan。在`MeshTriangle`结构体的末尾，我们添加了两个新的数组，`edges`和`edgeLengths`：'
- en: '[PRE0]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `edges` array, we store the three edges of each triangle. We order the
    edges by using the same winding as the original triangles. As we will need the
    lengths of the edges during the calculation of any adjacent triangles, we store
    the length of each edge in the corresponding `edgeLengths` element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`edges`数组中，我们存储每个三角形的三个边。我们按照与原始三角形相同的顺序来排序边。由于在计算任何相邻三角形时我们需要边的长度，因此我们将每条边的长度存储在相应的`edgeLengths`元素中。
- en: Now we can jump directly into the implementation of the path-finding class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接进入路径查找类的实现。
- en: Adding the path-finding class
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加路径查找类
- en: The path-finding class (named `PathFinder`) will reside in the `tools` folder
    where all other helper classes created in the previous chapters are stored, like
    `AABB` or `IKSolver`. To keep the naming consistent, the header file is named
    `PathFinder.h` and the implementation will go into the `PathFinder.cpp` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找类（命名为`PathFinder`）将驻留在`tools`文件夹中，其中存储了之前章节中创建的所有其他辅助类，如`AABB`或`IKSolver`。为了保持命名的一致性，头文件命名为`PathFinder.h`，实现将放入`PathFinder.cpp`文件中。
- en: 'On top of the `PathFinder.h` header, right after all the `#include` directives,
    we add two `struct` entries. The first new struct is named `NavTriangle`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PathFinder.h`头文件中，在所有`#include`指令之后，我们添加了两个`struct`条目。第一个新的结构体命名为`NavTriangle`：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We don’t reuse `MeshTriangle` here as we need a couple of different variables.
    While `index`, the `points` array, and the `normal` vector are the same, we also
    need to store the world position of the center of each triangle in the `center`
    variable and the surrounding triangles in `neighborTris`. The instance will navigate
    from one triangle center to the next, and the triangles stored in `neighborTris`
    are used to find the triangle with the shortest distance to the target.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不重用`MeshTriangle`，因为我们需要几个不同的变量。虽然`index`、`points`数组和`normal`向量是相同的，但我们还需要在`center`变量中存储每个三角形的中心的世界位置，以及在`neighborTris`中存储周围的三角形。实例将从三角形中心导航到下一个三角形，而存储在`neighborTris`中的三角形用于找到距离目标最近的三角形。
- en: For the neighbor triangles, `std::unordered_set` has been chosen over a plain
    `std::vector` to have an automatic removal for duplicate entries.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相邻三角形，我们选择使用`std::unordered_set`而不是普通的`std::vector`，以便自动删除重复条目。
- en: 'The second struct is called `NavData` and contains the data for the A* algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个结构体称为`NavData`，包含A*算法的数据：
- en: '[PRE2]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the `triIndex` variable, we store the triangle index of the corresponding
    `NavTriangle`. By using the index, we can do a simple lookup to find triangle
    data like position or neighbor triangles. As soon as we visit a neighboring node
    of a triangle, we add the index of the triangle with the shortest path so far
    to `prevTriIndex`, allowing us to backtrack the shortest path at the end of the
    pathfinding run.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`triIndex`变量中，我们存储对应`NavTriangle`的三角形索引。通过使用索引，我们可以进行简单的查找以找到三角形数据，如位置或相邻三角形。一旦我们访问到三角形的相邻节点，我们就将迄今为止最短路径的三角形索引添加到`prevTriIndex`中，这样我们就可以在路径查找运行结束时回溯最短路径。
- en: The remaining three variables (`distanceFromSource`, `heuristicToDest`, and
    `distanceToDest`) are the workhorses of the A* algorithm. Here we store the aggregated
    distance from the source to the current node, the result of the heuristic function
    for the distance between the current node and the target, and the sum of both
    distances. By comparing the values of `distanceToDest` for all neighboring nodes,
    A* chooses the next node toward the target node.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的三个变量（`distanceFromSource`、`heuristicToDest`和`distanceToDest`）是A*算法的功臣。在这里，我们存储从源到当前节点的聚合距离，当前节点和目标之间启发式函数的结果，以及这两个距离的总和。通过比较所有相邻节点的`distanceToDest`值，A*选择向目标节点移动的下一个节点。
- en: 'After the two new structs, the `PathFinder` class is declared, starting with
    the two public methods, `generateGroundTriangles()` and `findPath()`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个新的结构体之后，声明了`PathFinder`类，从两个公共方法`generateGroundTriangles()`和`findPath()`开始：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By calling `generateGroundTriangles()`, all upward-facing triangles in the triangle
    octree are located and the neighbor information for each “walkable” triangle is
    created. Once the ground data is ready, `findPath()` can be used to find a path
    from the start triangle to the target triangle. The result of `findPath()` is
    the path found by A* as a vector of triangle indices to step on, ordered from
    the start triangle to the target triangle, or an empty vector if no valid path
    exists.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`generateGroundTriangles()`，在三角形八叉树中找到所有向上面对的三角形，并为每个“可通行”三角形创建相邻信息。一旦地面数据准备就绪，就可以使用`findPath()`从起始三角形找到目标三角形。`findPath()`的结果是A*找到的路径，以三角形索引的向量形式表示，按从起始三角形到目标三角形的顺序排列，或者如果不存在有效路径，则为空向量。
- en: 'Also in the `PathFinder` class is the `private` member called `mNavTriangles`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PathFinder`类中还有一个名为`mNavTriangles`的`private`成员：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We store the calculated ground triangles in the `mNavTriangles` map. A mapping
    between the index and the triangle data is used for fast access by using the triangle
    index, also stored as part of a `NavData` element.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算出的地面三角形存储在`mNavTriangles`映射中。通过使用三角形索引（也作为`NavData`元素的一部分存储）进行索引和三角形数据的映射，以实现快速访问。
- en: Let’s step through the ground triangle generation code next.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来逐步分析地面三角形生成代码。
- en: Generating ground triangles
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成地面三角形
- en: The ground triangles are generated by utilizing the triangle octree generated
    by the renderer. Since we will make a lot of requests to the triangle octree,
    it will be given as the second parameter in the `generateGroundTriangles()` method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 地面三角形是通过利用渲染器生成的三角形八叉树生成的。由于我们将对三角形八叉树进行大量请求，它将作为`generateGroundTriangles()`方法的第二个参数提供。
- en: 'After clearing any previously generated navigation triangles, we get all triangles
    from the octree by a query with the world boundaries given as the third parameter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除之前生成的任何导航三角形后，我们通过使用作为第三个参数提供的世界边界进行查询，从八叉树中获取所有三角形：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then we loop over all level triangles to find the subset of upward-facing triangles:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们遍历所有级别三角形以找到向上面对的三角形子集：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Comparing the dot product of a triangle’s normal and an upward-facing vector
    with the cosine of the `rdMaxLevelGroundSlopeAngle` value is known from the collision
    detection in [*Chapter 12*](Chapter_12.xhtml). If the current triangle fulfills
    the check, we add it to the `groundTris` vector.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较三角形法向量和向上面对向量的点积与`rdMaxLevelGroundSlopeAngle`值的余弦，我们可以从[*第12章*](Chapter_12.xhtml)中的碰撞检测中得知。如果当前三角形满足检查条件，我们就将其添加到`groundTris`向量中。
- en: 'Next to the ground triangles in `groundTris`, we fill the `NavTriangle` named
    `navTri` with minimal data and add `navTri` to the `mNavTriangles` map:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`groundTris`中的地面三角形旁边，我们用最少的数据填充名为`navTri`的`NavTriangle`，并将`navTri`添加到`mNavTriangles`映射中：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use different sets of data in the `groundTris` vector and the `mNavTriangles`
    map here since a query to the triangle octree returns a vector of `MeshTriangles`
    but we maintain a better fitting map of `NavTriangles` for the ground triangles.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`groundTris`向量和`mNavTriangles`映射中使用不同的数据集，因为对三角形八叉树的查询返回一个`MeshTriangles`向量，但我们维护一个更适合地面三角形的`NavTriangles`映射。
- en: 'Now we can iterate over all ground triangles and query the triangle octree
    for all colliding triangles in the level:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历所有地面三角形，并查询该级别的三角形八叉树以获取所有碰撞的三角形：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This query works well as, in [*Chapter 12*](Chapter_12.xhtml), we had to make
    the bounding box of every triangle in the `generateLevelOctree()` method of the
    renderer classes `OGLRenderer` or `VkRenderer` a bit bigger to avoid a size of
    zero in any of the three dimensions. With this minimal size change, the bounding
    boxes of adjacent triangles in the level data are colliding now, and the triangle
    octree returns all neighbor triangles.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询工作得很好，因为在[*第12章*](Chapter_12.xhtml)中，我们不得不将渲染类`OGLRenderer`或`VkRenderer`的`generateLevelOctree()`方法中每个三角形的边界框稍微放大，以避免三个维度中的任何一个尺寸为零。通过这种最小尺寸的变化，级别数据中相邻三角形的边界框现在发生了碰撞，三角形八叉树返回所有相邻三角形。
- en: 'Then we get a reference to the same ground triangle in the `mNavTriangles`
    map and iterate over all triangles reported by the octree query:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取`mNavTriangles`映射中相同地面三角形的引用，并遍历八叉树查询报告的所有三角形：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using a reference for the ground triangle is important because we will update
    the neighbor triangles directly on the `NavTriangle` object in the map.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地面三角形的引用很重要，因为我们将在映射中的`NavTriangle`对象上直接更新相邻三角形。
- en: 'And even though these two nested loops look awful, the overall computation
    time is still small because the octree query reports only a small number of neighbor
    triangles. We can even sort out more triangles by simple checks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个嵌套循环看起来很糟糕，但整体计算时间仍然很小，因为八叉树查询只报告少量相邻三角形。我们甚至可以通过简单的检查排除更多的三角形：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The query for colliding triangles may also report the ground triangle we are
    currently inspecting, so we return immediately if we find it in the results. We
    also remove all triangles not facing upward from the list of possible neighbors
    as we are only interested in adjacent ground triangles.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 查询碰撞三角形时，也可能报告我们目前正在检查的地面三角形，因此如果我们发现它在结果中，我们将立即返回。我们还从可能的邻居列表中删除所有不面向上方的三角形，因为我们只对相邻地面三角形感兴趣。
- en: 'In case of triangulation errors made by `Assimp`, we also need to check if
    the peer triangle is in `mNavTriangles`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Assimp`生成的三角剖分错误的情况下，我们还需要检查相邻三角形是否在`mNavTriangles`中：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we find a valid neighbor triangle, we get the neighbor triangle from the
    `mNavTriangles` map:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个有效的相邻三角形，我们就从`mNavTriangles`映射中获取相邻三角形：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we can do a loop over all three vertices of both triangles to check
    for adjacency:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以遍历两个三角形的所有三个顶点来检查相邻性：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the loop, we calculate the distance of every vertex from the edges of
    the other triangle:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们计算每个顶点到另一个三角形边的距离：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: By calculating the distance from all vertices to every edge of the other triangle,
    we can detect if the triangles share a vertex or a side, or if a vertex of one
    triangle is on the edge of the other triangle.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过计算所有顶点到另一个三角形每条边的距离，我们可以检测三角形是否共享一个顶点或一条边，或者一个三角形的顶点是否位于另一个三角形的边上。
- en: 'If the distance is small enough, we add the index of the current peer triangle
    to the set of neighbor triangles of the currently inspected ground triangle:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离足够小，我们将当前检查的地面三角形的索引添加到该地面三角形的相邻三角形集合中：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the `generateGroundTriangles()` method has finished the calculations,
    the `mNavTriangles` map contains all possibly “walkable” ground triangles, and
    for every triangle, a list of triangles sharing at least a side or a vertex.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`generateGroundTriangles()`方法完成计算后，`mNavTriangles`映射包含所有可能“可通行”的地面三角形，并且对于每个三角形，都有一个至少共享一条边或一个顶点的三角形列表。
- en: A note on the navigation mesh quality
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于导航网格质量的说明
- en: 'The quality of the generated ground triangle mesh heavily depends on the map:
    Since the upward-facing triangles in the map may not form a perfect triangle mesh
    that shares vertices between triangles, the generated ground triangles in the
    `mNavTriangles` map may contain more neighbors than a separate navigation mesh
    would have. More triangles in a level usually also bring better quality here.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的地面三角形网格的质量很大程度上取决于地图：由于地图中向上的三角形可能不会形成一个完美的三角形网格，这些三角形之间共享顶点，因此在`mNavTriangles`映射中生成的地面三角形可能比单独的导航网格有更多的邻居。在级别中通常更多的三角形也会带来更好的质量。
- en: With a navigation mesh of ground triangles at hand, we can go for the A* algorithm.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在手头有地面三角形导航网格后，我们可以进行A*算法。
- en: Finding a path between two ground triangles
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在两个地面三角形之间寻找路径
- en: The implementation of the `findPath()` method follows the A* algorithm and should
    be easy to understand.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`findPath()`方法的实现遵循A*算法，应该容易理解。'
- en: Preparing the data
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备数据
- en: 'We start by extracting the center points of the target and start triangles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提取目标和起点的中心点：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will need the center point to calculate the distances between the nodes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要中心点来计算节点之间的距离。
- en: 'Next, we create two sets called `navOpenList` and `navClosedList` and a map
    named `navPoints`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建两个集合`navOpenList`和`navClosedList`以及一个名为`navPoints`的映射：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `navOpenList` variable, we store all neighbors of nodes that are candidates
    for the next iteration, and in `navClosedList`, we save all nodes that were already
    fully explored. The `navPoints` map contains data about all known nodes, like
    the distances and the parent node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`navOpenList`变量中，我们存储所有候选节点的邻居，在`navClosedList`中保存所有已经完全探索的节点。`navPoints`映射包含有关所有已知节点的数据，如距离和父节点。
- en: 'Prior to the first iteration of the A* algorithm, we set the `currentIndex`
    variable to the start triangle and create the navigation data for the start triangle:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在A*算法的第一次迭代之前，我们将`currentIndex`变量设置为起点三角形，并为起点三角形创建导航数据：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The distance to the target point is calculated as Euclidean distance by using
    a call to `glm::distance` and the distance to the start point is set to zero as
    we are still at the start point. We also add the start node to both the list of
    open nodes and the map containing the navigation data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目标点的距离通过调用`glm::distance`计算为欧几里得距离，而起点到起点的距离设置为零，因为我们仍然处于起点。我们还将起点节点添加到开放节点列表和包含导航数据的映射中。
- en: Running the main loop
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行主循环
- en: 'For the main loop of the A* algorithm, we start a `while` loop that ends if
    we hit the target triangle. The loop is *not* guaranteed to end at some point
    in time (for instance, if the target triangle is outside of the reachable mesh),
    so we will need to add an exit condition at the end of the loop:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于A*算法的主循环，我们启动一个`while`循环，该循环在遇到目标三角形时结束。循环不保证在某个时间点结束（例如，如果目标三角形位于可到达的网格之外），因此我们需要在循环末尾添加一个退出条件：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For every loop iteration, we extract the current triangle from the `mNavTriangles`
    map and get the center point in world coordinates and the neighbor triangles.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次循环迭代，我们从`mNavTriangles`映射中提取当前三角形，并获取世界坐标中的中心点和相邻三角形。
- en: 'Next, we loop over all neighbor triangles and extract the center point of the
    triangle:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历所有相邻的三角形，并提取三角形的中心点：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the neighboring node is not fully explored and not even visited yet, we
    continue inside the two `if` conditions and add the node to the open list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相邻的节点尚未完全探索甚至尚未访问，我们继续在两个`if`条件内部，并将该节点添加到开放列表中：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a reminder, the closed list contains all fully explored nodes, and the open
    list contains all known neighbors but not yet fully explored nodes of any of the
    nodes (even already closed nodes). At this point, we know that this is a new node
    to visit, so we create new navigation data:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，关闭列表包含所有已完全探索的节点，开放列表包含所有已知邻居但尚未完全探索的任何节点的所有邻居（即使是已经关闭的节点）。在此阶段，我们知道这是一个新的要访问的节点，因此我们创建新的导航数据：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the distance calculation, we get the distance from the current index (our
    parent node) and add the distance between the two nodes to the distance from the
    source:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于距离计算，我们从当前索引（我们的父节点）获取距离，并将两个节点之间的距离添加到源距离中：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As the last step of the code block, we add the new navigation data to the `navPoints`
    map that contains data about all currently known nodes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 作为代码块的最后一个步骤，我们将新的导航数据添加到包含有关所有当前已知节点的`navPoints`映射中。
- en: 'If the neighboring node is already in the list of open nodes, we check if we
    need to update the existing navigation data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相邻节点已经在开放节点的列表中，我们检查是否需要更新现有的导航数据：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we get a reference to the navigation data to be able to update the information
    in place. For the existing navigation point, we calculate the new estimated distance
    from the known distance to the source and the heuristic value to the target:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取导航数据的引用，以便能够就地更新信息。对于现有的导航点，我们计算从已知距离到源点和到目标点的启发式值的新估计距离：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the new path through this node is shorter than the previously known path,
    we update the navigation data to reflect the new, shorter path:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过此节点的新路径比之前已知路径短，我们更新导航数据以反映新的、较短的路径：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After all neighboring nodes have been checked, we add the current node to the
    closed list, marking it as fully explored:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查完所有相邻节点之后，我们将当前节点添加到封闭列表中，并标记为已完全探索：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If our open list becomes empty, we return an empty vector:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的开放列表变为空，我们返回一个空向量：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We check for an empty open list before going on since the next step involves
    a loop over all elements of the open list.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一步之前，我们检查开放列表是否为空，因为下一步涉及到遍历开放列表的所有元素。
- en: Extracting the best node
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取最佳节点
- en: Once we have collected all the new nodes and updated the distances of all existing
    nodes, we need to find the node with the shortest combined distance from start
    to target. We will use a priority queue here to minimize the costs to access the
    node having the smallest distance. The priority queue will sort all nodes according
    to a comparison function into a tree structure and allow accessing the largest
    or smallest node as the topmost element.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集了所有新节点并更新了所有现有节点的距离，我们需要找到从起点到目标的最短组合距离的节点。在这里，我们将使用优先队列来最小化访问具有最小距离的节点的成本。优先队列将根据比较函数将所有节点排序成树结构，并允许访问最大或最小节点作为最顶层元素。
- en: 'First, we create the comparison function for the priority queue:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为优先队列创建比较函数：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By default, a priority uses `std::less` as a comparison function, resulting
    in a queue with the maximum value as the top element. But by using the `cmp` function,
    we will have the minimum distance to the destination as the top element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，优先队列使用`std::less`作为比较函数，导致最大值作为顶层元素。但通过使用`cmp`函数，我们将具有最小距离到目的地的元素作为顶层元素。
- en: 'Now we can fill the queue by pushing all triangles in the open list:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过将开放列表中的所有三角形推入队列来填充队列：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we declare an empty navigation data variable and extract the index with
    the minimum distance from the queue by a call to `top()`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个空的导航数据变量，并通过调用`top()`从队列中提取具有最小距离的索引：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The new triangle index will be used for the next loop of `while`, looping until
    the target triangle has been found as the triangle with the minimal distance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 新的三角形索引将用于下一个`while`循环的迭代，循环直到找到目标三角形作为具有最小距离的三角形。
- en: 'As a final step for the A* algorithm, we erase the node from the open list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为A*算法的最终步骤，我们从开放列表中删除该节点：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once we have found the target triangle, the outer `while` loop ends, and we
    can collect and return the shortest path
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到目标三角形，外部的`while`循环结束，我们可以收集并返回最短路径
- en: Backtracking the shortest path
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追溯最短路径
- en: Since we have saved the parent node with the shortest distance so far in the
    navigation data for every triangle, we just need to follow the chain along the
    parent nodes, starting from the target node until we hit the start node. The start
    node is marked by a parent node of `-1`, so we know when to stop.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为每个三角形在导航数据中保存了到目前为止具有最短距离的父节点，我们只需沿着父节点链追踪，从目标节点开始，直到遇到起始节点。起始节点由父节点`-1`标记，因此我们知道何时停止。
- en: 'First, we create a new vector named `foundPath` and store `currentIndex` in
    it:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`foundPath`的新向量，并将`currentIndex`存储在其中：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main `while` loop ends when `currentIndex` is identical to the requested
    `targetIndex`, so we could use any of the two variables here.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当`currentIndex`与请求的`targetIndex`相同，主要的`while`循环结束，因此我们可以使用这两个变量中的任何一个。
- en: 'Then, we get the navigation data of the current triangle and loop over all
    parents until we hit the start triangle:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取当前三角形的导航数据，并遍历所有父节点，直到遇到起始三角形：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we started the backtracking at the target triangle and ended on the start
    triangle, the order of the triangles in `foundPath` is also from target to start.
    To fix the order, we reverse the vector:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从目标三角形开始回溯，并在起始三角形结束，因此`foundPath`中三角形的顺序也是从目标到起始。为了修正顺序，我们反转了向量：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we return the reversed path:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回反转的路径：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can call `findPath()` now with any combination of start and target triangles
    and get a path back if such a path exists. If no path from start to target exists,
    `findPath()` returns an empty vector by the check for the empty open list.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用任何组合的起始和目标三角形调用`findPath()`，如果存在这样的路径，则会返回一条路径。如果没有从起始点到目标点的路径，`findPath()`通过检查空开放列表返回一个空向量。
- en: The starting point of the pathfinding is known; it’s the instance. But what
    about the target? Let’s add some configurable navigation targets to the virtual
    world.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找的起点是已知的；它是实例。但目标呢？让我们在虚拟世界中添加一些可配置的导航目标。
- en: Adding navigation targets to the map
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向地图添加导航目标
- en: 'Before we start, let us imagine which properties a possible navigation target
    must have:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们想象一下可能的导航目标必须具备哪些属性：
- en: It should come in any shape and number.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以以任何形状和数量出现。
- en: It should be easy to select and move around.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该容易选择和移动。
- en: It can be placed anywhere on the ground.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以放置在地面上任何位置。
- en: Ideally, it should be able to move by itself.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，它应该能够自行移动。
- en: So, our ideal target is a model instance! And since we already have all the
    ingredients for this list, implementing navigation targets becomes easy.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的理想目标是模型实例！既然我们已经有这个列表的所有成分，实现导航目标就变得容易了。
- en: Adjusting model and instance
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整模型和实例
- en: 'First, we add a new Boolean variable named `msUseAsNavigationTarget` to the
    `ModelSettings` struct:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`ModelSettings`结构体中添加了一个名为`msUseAsNavigationTarget`的新布尔变量：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `AssimpModel` class also needs two simple `public` methods named `setAsNavigationTarget()`
    and `isNavigationTarget()` to set and query the new variable:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpModel`类也需要两个简单的`public`方法，名为`setAsNavigationTarget()`和`isNavigationTarget()`，用于设置和查询新变量：'
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `UserInterface` class, a checkbox will be added to set the state of
    a model with a simple mouse click. *Figure 13.10* shows the **Models** layout
    with the new checkbox:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserInterface`类中，将添加一个复选框，通过简单的鼠标点击设置模型的状态。*图13.10*显示了带有新复选框的**模型**布局：
- en: '![](img/B22428_13_10.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_10.png)'
- en: 'Figure 13.10: The Models part of the UI with the new navigation target checkbox'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：UI的模型部分，带有新的导航目标复选框
- en: By setting the **Use as NavTarget** checkbox in *Figure 13.10*, we can control
    whether or not a model should be used as a navigation target.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在*图13.10*中设置**用作导航目标**复选框，我们可以控制模型是否应该用作导航目标。
- en: 'For the instances, we add the five variables to the `InstanceSettings` struct:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例，我们将五个变量添加到`InstanceSettings`结构体中：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To control the navigation on a per-instance basis, `isNavigationEnabled` is
    used. The two variables `isPathTargetInstance` and `isPathToTarget` should not
    need an explanation; their names state what they are for. In `isPathStartTriangleIndex`,
    the index of the triangle is saved where the instance currently resides, and `isPathTargetTriangleIndex`
    is filled with the triangle index of the target instance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了按实例控制导航，使用`isNavigationEnabled`。两个变量`isPathTargetInstance`和`isPathToTarget`不需要解释；它们的名称说明了它们的作用。在`isPathStartTriangleIndex`中，保存了实例当前所在的三角形的索引，而`isPathTargetTriangleIndex`则填充了目标实例的三角形索引。
- en: 'In the `AssimpInstance` class, simple `public` setter and getter methods for
    the new variables are added:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AssimpInstance`类中，添加了新变量的简单`public`设置器和获取器方法：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the **Instances** collapsing header of the `UserInterface` class, a couple
    of new controls are added too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserInterface`类的**实例**折叠标题中，也添加了一些新的控件：
- en: '![](img/B22428_13_11.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22428_13_11.png)'
- en: 'Figure 13.11: New navigation controls for the instances'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11：实例的新导航控件
- en: When checking the **Enable Navigation** checkbox, the remaining parts of the
    navigation controls are enabled. If any navigation target model exists, the **Nav
    Targets** combo box is populated with the indices of the instances, allowing us
    the set the instance number to use as the target. In the case that a target was
    set, **Nav Target** shows the index of the current target, or `-1` if no target
    was selected. To find the target without switching instances, `Center Target`
    can be pressed, centering the target in the middle of the screen.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查 **启用导航** 复选框时，导航控制的其余部分被启用。如果存在任何导航目标模型，**导航目标** 组合框将填充实例的索引，允许我们设置要使用的实例编号作为目标。如果已设置目标，**导航目标**
    将显示当前目标的索引，或如果未选择任何目标，则显示 `-1`。要找到目标而无需切换实例，可以按 `Center Target`，将目标居中在屏幕中间。
- en: 'For the combo box with the navigation targets, a callback named `getNavTargetsCallback`
    will be added to the `Callbacks.h` file:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有导航目标的组合框，将在 `Callbacks.h` 文件中添加一个名为 `getNavTargetsCallback` 的回调：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The corresponding method in the renderer class files `OGLRenderer.cpp` and
    `VkRenderer.cpp` is called `getNavTargets()` and collects the indices of all instances
    from models enabled as navigation targets:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染类文件 `OGLRenderer.cpp` 和 `VkRenderer.cpp` 中的对应方法称为 `getNavTargets()`，并收集所有启用为导航目标的模型的索引：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We loop over all models, and if the model is not a navigation target, we continue
    with the next model. If the model is marked as a navigation target, we store all
    indices in a vector named `targets` and return the vector:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历所有模型，如果模型不是导航目标，则继续下一个模型。如果模型标记为导航目标，我们将所有索引存储在一个名为 `targets` 的向量中，并返回该向量：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To place the targets on the ground, we also need gravity to apply.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将目标放置在地面上，我们还需要应用重力。
- en: Adding gravity for non-animated instances
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为非动画实例添加重力
- en: Gravity is currently only affecting any animated instances since we needed them
    to stay on the ground for collision detection and inverse kinematics in [*Chapter
    12*](Chapter_12.xhtml). Thanks to keeping the code for animated and non-animated
    models mostly similar, adding gravity for non-animated instances is done with
    only a couple of small changes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要动画实例保持在地面进行碰撞检测和逆运动学，因此重力目前仅影响任何动画实例。由于动画和非动画模型的代码保持大部分相似，因此为非动画实例添加重力只需进行几个小的更改。
- en: 'First, copy the entire code block with the `mLevelCollisionTimer.start()` and
    `mLevelCollisionTimer()` calls below the call that adds the current instance to
    the instance octree, as shown in the following code block:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，复制包含 `mLevelCollisionTimer.start()` 和 `mLevelCollisionTimer()` 调用的整个代码块，并将其放置在将当前实例添加到实例八叉树调用下方，如下面的代码块所示：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, add a call to `updateInstancePosition()` below the new code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在新代码下方添加对 `updateInstancePosition()` 的调用：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, move the retrieval of the matrix containing the world transforms from
    the start of the block after the instance position update:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将包含世界变换矩阵的检索从实例位置更新后的代码块开始处移动：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That’s all!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了！
- en: Now the gravity and ground collisions are also calculated for non-animated instances,
    the instance position is updated, and the most recent world transforms are collected
    and added to the `mWorldPosMatrices` array, which is then uploaded to a Shader
    Storage Buffer Object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重力和非动画实例的地面碰撞也被计算，实例位置被更新，最近的世界变换被收集并添加到 `mWorldPosMatrices` 数组中，然后上传到着色器存储缓冲区对象。
- en: Saving and loading the new model and instance data
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载新的模型和实例数据
- en: Storing the new values in the YAML configuration file and restoring the settings
    should need no further explanation. The Boolean to use a model as a navigation
    target is stored in the `ModelSettings` struct and all new path-finding and navigation
    variables for the instance are stored in the `InstanceSettings` struct. Adding
    the new values to the YAML emitter and parser is only a matter of copying and
    pasting. The YAML configuration version should be updated, too, to reflect the
    new values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值存储在 YAML 配置文件中并恢复设置无需进一步解释。使用模型作为导航目标的布尔值存储在 `ModelSettings` 结构体中，所有新的路径查找和导航变量存储在
    `InstanceSettings` 结构体中。将新值添加到 YAML 发射器和解析器中只需复制粘贴即可。YAML 配置版本也应更新，以反映新值。
- en: We have ground triangles, a path-finding algorithm, and the start and target
    points of a path. What’s left is the logic to make an instance follow the path.
    So, let’s add the last part now.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有地面三角形、路径查找算法以及路径的起始和目标点。剩下的就是让实例跟随路径的逻辑。所以，现在让我们添加最后一部分。
- en: Navigating instances to a target
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将实例导航到目标
- en: To calculate or update the path to the target instance, we need to add more
    code to the renderer. We start by adding the code to compute the actual path from
    an instance to the target position.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算或更新到达目标实例的路径，我们需要向渲染器添加更多代码。我们首先添加从实例到目标位置的路径计算代码。
- en: Calculating the path to the target
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算到达目标路径
- en: The best place for the path update code is in the loop over all animated instances
    in the `draw()` call of the renderer class `OGLRenderer.cpp` or `VKRenderer.cpp`,
    right after the ground and collision detection code that was just copied for the
    non-animated instances. We have the final world position of the instance available,
    including any gravity updates, and can use this position as the starting point
    of the path-finding algorithm.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 路径更新代码的最佳位置是在渲染类`OGLRenderer.cpp`或`VKRenderer.cpp`的`draw()`调用中所有动画实例的循环中，紧接在为非动画实例复制的地面和碰撞检测代码之后。我们有实例的最终世界位置可用，包括任何重力更新，并可以使用这个位置作为路径查找算法的起点。
- en: 'First, we check if navigation is enabled for the instance and get the instance
    index of the target:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查实例是否启用了导航，并获取目标实例的索引：
- en: '[PRE47]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we do a sanity check of the target instance to avoid a crash when accessing
    the `micAssimpInstances` vector:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对目标实例进行合理性检查，以避免在访问`micAssimpInstances`向量时崩溃：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, extract the index of the triangle the target is currently on plus the
    world position of the target:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，提取目标当前所在三角形的索引以及目标的世界位置：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As the target instance may move by itself or may be moved by the user, the target
    triangle index must be retrieved before every path update. This triangle index
    update ensures that the instance is following the target, regardless of the target
    being a static waypoint or another instance that roams around in the level.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目标实例可能自行移动或被用户移动，必须在每次路径更新之前检索目标三角形索引。这个三角形索引更新确保实例在跟随目标，无论目标是一个静态的航标点还是在该级别周围游荡的另一个实例。
- en: 'Now we check if both the current instance and the target instance have a valid
    ground triangle and if we or the target moved away from the saved triangle. Only
    if all conditions are met do we recalculate the path at all, avoiding costly computations
    when no changes to the source or target occurred:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查当前实例和目标实例是否都有一个有效的地面三角形，以及我们或目标是否已经远离了保存的三角形。只有当所有条件都满足时，我们才重新计算路径，避免在源或目标没有变化时进行昂贵的计算：
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the case of any changes, we adjust the start and the target triangle of
    the current instance. With the most recent data for the triangles, we can call
    `findPath()`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何变化的情况下，我们调整当前实例的起始和目标三角形。有了三角形的最最新数据，我们可以调用`findPath()`：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The result may be empty if no valid path has been found. In that case, we disable
    the navigation of the instance and invalidate the target instance by setting it
    to `-1`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到有效的路径，结果可能为空。在这种情况下，我们禁用实例的导航，并通过将其设置为`-1`使目标实例无效：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the path was valid, we set the path indices in the instance.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径有效，我们在实例中设置路径索引。
- en: 'Since the path will only update on changes, we get the saved or just updated
    path of the instance now:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路径仅在变化时更新，我们现在获取实例保存的或刚刚更新的路径：
- en: '[PRE53]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To avoid awkward movement when starting or ending the path to a target, we
    remove the start and target triangles from the instance path:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在开始或结束路径到目标时出现尴尬的运动，我们从实例路径中删除起始和目标三角形：
- en: '[PRE54]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The path is created between the center of the ground triangle the instance is
    currently standing on to the ground triangle the target resides. If the instance
    is already closer than the triangle center, the path would point backward, and
    the instance may never leave the current ground triangle. We could also remove
    the elements in the `PathFinder` class, but if we want to use the data generated
    in `findPath()` anywhere else, the triangles may be needed. So, we cut off the
    triangle indices here.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是在实例当前站立的地形三角形的中心与目标所在的地形三角形之间创建的。如果实例已经比三角形中心更近，路径将指向后方，实例可能永远不会离开当前的地形三角形。我们也可以从`PathFinder`类中删除元素，但如果我们要在其他地方使用`findPath()`生成的数据，可能需要三角形。因此，我们在这里截断三角形索引。
- en: 'As the last step for pathfinding, we rotate the instance toward the next path
    point or the target, depending on whether we have a path left in `pathToTarget`
    or not:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 作为路径查找的最后一步，我们将实例旋转到下一个路径点或目标，具体取决于我们是否在`pathToTarget`中还有路径：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The call to `getTriangleCenter()` of the `PathFinder` class returns the center
    of the requested triangle in world coordinates. This center point is then fed
    into the `rotateTo()` method of the instance, so let’s look at the implementation
    of the rotation method next.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathFinder`类的`getTriangleCenter()`调用返回请求三角形在世界坐标中的中心。然后，这个中心点被输入到实例的`rotateTo()`方法中，所以接下来让我们看看旋转方法的实现。'
- en: Rotating the instance to reach the target
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实例旋转到目标位置
- en: The new `public` method called `rotateTo()` must be added to the `AssimpInstance`
    class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在`AssimpInstance`类中添加一个名为`rotateTo()`的新`public`方法。
- en: 'First, we check if the instance walks or runs right now. Rotating the instance
    while standing idle on the ground may look strange:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查实例现在是否在行走或奔跑。如果实例在地面静止时旋转，可能会显得很奇怪：
- en: '[PRE56]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we get the rotation vector of the current instance and the vector from
    our position toward the target position:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取当前实例的旋转向量和从我们的位置指向目标位置的向量：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are only interested in a rotation around the Y axis, so we use the two-dimensional
    rotation vector of the instance and reduce the vector to the target and also to
    the values of the X and Z dimensions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对围绕Y轴的旋转感兴趣，因此我们使用实例的二维旋转向量，并将向量减少到目标和X、Z维度的值。
- en: 'By using the two vectors `myRotation` and `toTarget`, we can calculate the
    angle between the two vectors via the dot product:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个向量`myRotation`和`toTarget`，我们可以通过点积计算出两个向量之间的角度：
- en: '[PRE58]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we calculate a quaternion containing the rotation between the two
    vectors, extract the Euler angles, and use the `y` element of the angle to rotate
    the instance:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算包含两个向量之间旋转的四元数，提取欧拉角，并使用角度的`y`元素来旋转实例：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The multiplication with `deltaTime` makes the instance rotation smooth since
    the angle in every frame is small. The initial comparison of the `angleDiff` value
    makes sure we have a small “dead zone” left, leading to fewer rotations if the
    path is nearly straight and avoiding oscillations in case the rotation oversteers
    a bit.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与`deltaTime`的乘法使得实例旋转变得平滑，因为每一帧的角度都很小。`angleDiff`值的初始比较确保我们留下一个小“死区”，如果路径几乎直线，则会导致旋转次数减少，并避免旋转过度时的振荡。
- en: If the target is moving around in the level, the dead zone also reduces the
    number of corrections when the path of the instance is recreated. By carefully
    tuning the amount of oversteering and the dead zone angle, a chasing instance
    will behave more naturally since both parameters could reduce the number of directional
    changes while following the target.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标在关卡中移动，当路径实例被重新创建时，死区也会减少校正次数。通过仔细调整过度转向量和死区角度，追逐实例的行为将更加自然，因为这两个参数都可以在跟随目标时减少方向变化次数。
- en: To make the calculated path visible, we should also add a visual output for
    the renderer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计算出的路径可见，我们还应该为渲染器添加一个可视化输出。
- en: Adding debug lines for the path
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为路径添加调试线条
- en: Drawing the path to the screen is astonishingly easy. Next to adding a control
    Boolean named `rdDrawInstancePaths` to the `OGLRenderData` struct for OpenGL,
    respective to the `VkRenderData` struct for Vulkan, a new line mesh in the renderer
    and a checkbox in the `UserInterface` class, creating the lines between all path
    points is easy. The best place for the new code is after the code added in the
    *Calculating the path to the target* section.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 将路径绘制到屏幕上非常简单。除了在`OGLRenderData`结构体中添加一个名为`rdDrawInstancePaths`的控制布尔值，对于OpenGL，相应地，在`VkRenderData`结构体中添加一个新行网格在渲染器中，以及在`UserInterface`类中添加一个复选框，创建所有路径点之间的线条很容易。新代码的最佳位置是在*计算到达目标路径*部分添加的代码之后。
- en: 'First, we check if we should create the lines at all and if we have a valid
    target:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否需要创建线条，以及是否有有效的目标：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we set the desired color and a height offset for the path and create
    a vertex to draw the line:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为路径设置所需的颜色和高度偏移，并创建一个顶点来绘制线条：
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we add the world position of the current instance as the starting point
    for the lines:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将当前实例的世界位置作为线条的起始点：
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we have a valid path, we extract the world position of the first triangle
    center of the path as the second point for the first line. Since we already removed
    the starting triangle, the line will be drawn to the next triangle in the path:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有有效的路径，我们将提取路径的第一个三角形中心的世界位置作为第一条线的第二个点。由于我们已经移除了起始三角形，因此线条将绘制到路径中的下一个三角形：
- en: '[PRE63]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, we create a new temporary line mesh and retrieve the vertices of the
    path segments by calling `getAsLineMesh()` of the `PathFinder` class:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的临时线网格，并通过调用`PathFinder`类的`getAsLineMesh()`方法检索路径段的多边形顶点：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The helper method `getAsLineMesh()` just extracts the center points of the ground
    triangles on the path, adds the desired offset to the world position of the vertices,
    and creates lines from the vertices.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法`getAsLineMesh()`仅提取路径上地面三角形的中点，将所需的偏移量添加到顶点的世界位置，并从顶点创建线条。
- en: 'Now, we add the last position as a possible starting point for the last line:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将最后一个位置添加为最后一条线的可能起始点：
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As a final step for the line creation, we add the world position of the target:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 作为创建线条的最后一步，我们添加目标的世界位置：
- en: '[PRE66]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the path is empty after removing the first and/or last element, we skip the
    code inside the `if` condition and draw only a line from our own position to the
    target. This happens only if we have a valid target, and the start and target
    triangles are directly next to each other. If an error occurs during pathfinding
    and the path is empty, we reset the target instance, and the line is no longer
    drawn.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在移除第一个和/或最后一个元素后路径为空，我们将跳过`if`条件内的代码，并只从我们的位置画到目标的一条线。这仅在我们有一个有效的目标，并且起始和目标三角形直接相邻时发生。如果在路径寻找过程中发生错误且路径为空，我们将重置目标实例，并且不再绘制线条。
- en: 'To draw the created lines, a new `private` method called `drawInstancePaths()`
    is created in the renderer class `OGLRendere.cpp` or `VkRender.cpp` that just
    sends the lines to the shader. After enabling the navigation debug draw by enabling
    the **Enable Navigation** checkbox under the **Navigation** header and the **Draw
    Instance Path** checkbox under the **Levels** header, navigation paths for the
    instances will be drawn as green lines, similar to *Figure 13.12*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制创建的线条，在渲染器类`OGLRendere.cpp`或`VkRender.cpp`中创建一个新的`private`方法`drawInstancePaths()`，该方法仅将线条发送到着色器。通过在**导航**标题下启用**启用导航**复选框以及在**级别**标题下启用**绘制实例路径**复选框来启用导航调试绘制后，实例的导航路径将以绿色线条绘制，类似于*图13.12*：
- en: '![](img/B22428_13_12.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22428_13_12.png)'
- en: 'Figure 13.12: Debug lines showing the path of the instances'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12：显示实例路径的调试线条
- en: In *Figure 13.12*, the model of a traffic cone was added and marked as a navigation
    target. Then, the instances were instructed to walk to their desired targets.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.12*中，添加了交通锥体的模型并将其标记为导航目标。然后，指示实例走向它们的目标。
- en: The jagged paths between the instances and the targets are a result of large
    ground triangles in the selected level map. Since the instances are moving from
    triangle center to triangle center, the paths have larger angles as the distances
    between the center points are quite large. A level with smaller ground triangles
    will have much smoother paths for the instances.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 实例和目标之间锯齿状的路径是所选级别地图中大型地面三角形的结果。由于实例是从三角形中心移动到三角形中心，因此随着中心点之间距离的增大，路径的角度也更大。具有较小地面三角形的级别将为实例提供更平滑的路径。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a simple path-finding navigation. After an overview
    of methods to allow computer-controlled instances to navigate in a game map, we
    explored and implemented the A* path-finding algorithm, supported by a custom
    navigation mesh creation. Then, we modified models to use them as navigation targets
    in the virtual world and enabled instances to use instances of the special models
    as path targets. As the last step, we added navigation to the instances, allowing
    them to walk or run toward a random target.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一种简单的路径寻找导航。在概述了允许计算机控制的实例在游戏地图中导航的方法之后，我们探讨了并实现了A*路径寻找算法，该算法由自定义导航网格创建支持。然后，我们修改了模型，以便在虚拟世界中将其用作导航目标，并使实例能够使用特殊模型的实例作为路径目标。作为最后一步，我们为实例添加了导航功能，允许它们走向或跑向一个随机目标。
- en: In the next and last chapter of the book, we will take a step back from the
    implementation side and take a look at different ways to enhance immersion and
    visual quality. We will start with the audible side and discuss methods and tools
    to add sound effects and music to the application. Then, we will check out ideas
    to fill the world with more life, followed by a discussion about ideas to enhance
    the visuals in the virtual world. We will look at quests and interactions between
    instances and, finally, explore the impact of daytime and weather changes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将从实现方面退后一步，看看不同的方法来增强沉浸感和视觉质量。我们将从可听方面开始，讨论向应用程序添加音效和音乐的方法和工具。然后，我们将探讨使世界充满更多生命力的想法，接着讨论增强虚拟世界视觉效果的创意。我们将研究任务和实例之间的交互，最后探索白天和天气变化的影响。
- en: Practical sessions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的内容：
- en: Smooth the path even with large ground triangles.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是大型地面三角形，也要平滑路径。
- en: By looking up the next couple of path segments, it may be possible to create
    an average of the segments. For sharper turns, the transitions between the triangles
    could be smoothed by using splines.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查找接下来的几个路径段，可能可以创建这些段落的平均值。对于更尖锐的转弯，可以通过使用样条曲线来平滑三角形之间的过渡。
- en: Clean up the generated triangle neighbor list.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理生成的三角形邻接列表。
- en: Right now, the list of adjacent triangles is quite large. This fact can be seen
    when the neighbor mesh debug drawing for a level is activated. Try to find a solution
    to include only triangles sharing parts of an edge.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，相邻三角形的列表相当大。这一点可以在激活级别邻接网格调试绘图时看到。尝试找到一种解决方案，只包括共享部分边界的三角形。
- en: Add a minimum distance between walls and path lines.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在墙壁和路径线之间添加最小距离。
- en: For the generated ground triangles, some of the center positions may be so close
    to a wall that the instance will collide when following the path. In some cases,
    the paths even go through edges of level geometry when the triangles are seen
    as adjacent. When creating the ground triangles, try to find the outlines of the
    mesh and reduce the size by a configurable amount.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成的地面三角形，一些中心位置可能非常接近墙壁，以至于在跟随路径时实例会发生碰撞。在某些情况下，当三角形被视为相邻时，路径甚至会穿过水平几何体的边缘。在创建地面三角形时，尝试找到网格的轮廓，并通过可配置的数量减小其大小。
- en: Use the instance AABB to detect narrow passages.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实例 AABB 来检测狭窄的通道。
- en: Some maps may have passages where the navigation needs to be exact. In the absence
    of a real navigation mesh, you could try to use the bounding box of the instance
    along the path to find possible collisions and adjust the path to avoid a collision
    with the level structures.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一些地图可能有需要精确导航的通道。在没有真实导航网格的情况下，你可以尝试使用沿路径的实例边界框来寻找可能的碰撞，并调整路径以避免与级别结构发生碰撞。
- en: 'Advanced difficulty: Create a navigation mesh in an editor and load that mesh.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级难度：在一个编辑器中创建导航网格并将其加载。
- en: If you are confident working with a tool like Blender, you could try to create
    a navigation mesh as a separate mesh of a level, or even as a separate file, saved
    next to the level file. Then, load the navigation mesh into the `PathFinder` class
    to have a collision-free ground for the instances.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 Blender 这样的工具，你可以尝试创建一个作为级别单独网格的导航网格，甚至作为一个单独的文件，保存在级别文件旁边。然后，将导航网格加载到
    `PathFinder` 类中，以便为实例提供一个无碰撞的地面。
- en: Additional resources
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'Ghost navigation in Pac-Man: [https://gameinternals.com/understanding-pac-man-ghost-behavior](https://gameinternals.com/understanding-pac-man-ghost-behavior)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pac-Man 中的幽灵导航：[https://gameinternals.com/understanding-pac-man-ghost-behavior](https://gameinternals.com/understanding-pac-man-ghost-behavior)
- en: 'Dijkstra’s algorithm: [https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/](https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dijkstra 算法：[https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/](https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/)
- en: 'Quake III Arena’s area awareness system: [http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf](http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quake III Arena 的区域感知系统：[http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf](http://www.kbs.twi.tudelft.nl/docs/MSc/2001/Waveren_Jean-Paul_van/thesis.pdf)
- en: 'Navigation meshes: [https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/](https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航网格：[https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/](https://www.gamedev.net/tutorials/programming/artificial-intelligence/navigation-meshes-and-pathfinding-r4880/)
- en: 'Shakey the Robot: [https://www.sri.com/hoi/shakey-the-robot/](https://www.sri.com/hoi/shakey-the-robot/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shakey 机器人：[https://www.sri.com/hoi/shakey-the-robot/](https://www.sri.com/hoi/shakey-the-robot/)
- en: 'Introduction to A*: [https://www.redblobgames.com/pathfinding/a-star/introduction.html](https://www.redblobgames.com/pathfinding/a-star/introduction.html)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A* 简介：[https://www.redblobgames.com/pathfinding/a-star/introduction.html](https://www.redblobgames.com/pathfinding/a-star/introduction.html)
- en: 'Using A* with navigation meshes: [https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 A* 与导航网格：[https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)
- en: 'Navigation meshes in Unreal Engine: [https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unreal Engine 中的导航网格：[https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine](https://dev.epicgames.com/documentation/en-us/unreal-engine/basic-navigation-in-unreal-engine)
- en: 'Implementing A* in an Unreal Engine project: [https://www.youtube.com/watch?v=xakl29fupCA](https://www.youtube.com/watch?v=xakl29fupCA)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unreal Engine 项目中实现 A*：[https://www.youtube.com/watch?v=xakl29fupCA](https://www.youtube.com/watch?v=xakl29fupCA)
- en: 'Training an unbeatable AI in Trackmania: [https://www.youtube.com/watch?v=Dw3BZ6O_8LY](https://www.youtube.com/watch?v=Dw3BZ6O_8LY)'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Trackmania 中训练无敌的 AI：[https://www.youtube.com/watch?v=Dw3BZ6O_8LY](https://www.youtube.com/watch?v=Dw3BZ6O_8LY)
- en: 'Recast Navigation: [https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Recast Navigation：[https://github.com/recastnavigation/recastnavigation](https://github.com/recastnavigation/recastnavigation)
- en: 'Optimization for Smooth Paths: [https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf](https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平滑路径优化：[https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf](https://www.gameaipro.com/GameAIPro3/GameAIPro3_Chapter20_Optimization_for_Smooth_Paths.pdf)
- en: 'Toward More Realistic Pathfinding: [https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding](https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向更真实的寻路方法迈进：[https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding](https://www.gamedeveloper.com/programming/toward-more-realistic-pathfinding)
- en: Join our community on Discord
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI 生成的内容可能不正确。](img/QR_code_Discord.png)'
