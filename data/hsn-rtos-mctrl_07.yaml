- en: Selecting an IDE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择IDE
- en: An **integrated development environment** (**IDE**) has the ability to greatly
    help or hinder development. Depending on the specific goals of a project, an IDE
    could prove extremely easy to integrate into a workflow or simply get in the way.
    IDEs are designed to have a small learning curve and will often offer an easy
    way to build solutions from existing drivers and middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成开发环境**（**IDE**）有能力极大地帮助或阻碍开发。根据项目的具体目标，IDE可能非常容易集成到工作流程中，或者简单地成为障碍。IDE旨在具有较小的学习曲线，并且通常会提供一种简单的方法来从现有的驱动程序和中间件构建解决方案。'
- en: In this chapter, we'll be discussing how to select an IDE, taking a look at
    the different types of IDEs, and selecting one to use to create all of the source
    code you'll find in the code pack used in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何选择IDE，探讨不同类型的IDE，并选择一个用于创建本书中使用的代码包中所有源代码的IDE。
- en: 'Here''s a quick list of the main topics we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们将涵盖的主要主题的快速列表：
- en: The IDE selection criteria
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想中的IDE选择标准
- en: Platform-abstracted IDEs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台抽象化IDE
- en: Open source/free IDEs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源/免费IDE
- en: Proprietary IDEs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有IDE
- en: Selecting the IDE for this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择本书的IDE
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no software or hardware requirements for this chapter (software will
    be installed toward the end).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有软件或硬件要求（软件将在最后安装）。
- en: The IDE selection criteria
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理想中的IDE选择标准
- en: The decision to select an IDE can take place at many different levels of an
    organization. A single engineer may be using the IDE for just one project. In
    this case, they're likely to simply select whatever they're familiar with or whatever
    happens to ship with the **microcontroller unit** (**MCU**) for that project.
    At the other end of the spectrum, an entire department could be integrating the
    IDE into their development workflow. In this case, the decision could affect dozens
    of engineers and address multiple target platforms for years down the road.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择IDE的决定可以在组织的许多不同层面上进行。单个工程师可能只使用IDE来完成一个项目。在这种情况下，他们可能会简单地选择他们熟悉的东西，或者该项目附带的东西是**微控制器单元**（**MCU**）。在光谱的另一端，整个部门可能会将IDE集成到他们的开发工作流程中。在这种情况下，这个决定可能会影响数十名工程师，并在未来几年内解决多个目标平台。
- en: Some engineers prefer no IDE at all—instead, they'll pull together their favourite
    text editor and a command-line compiler or linker (such as GCC or Clang), handcraft
    some makefiles, and set off with coding. This is a perfectly valid approach, too—it
    will result in a great amount of flexibility and less dependence on proprietary
    tools and should certainly be considered.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些工程师根本不需要IDE——相反，他们会使用他们最喜欢的文本编辑器和命令行编译器或链接器（例如GCC或Clang），手工制作一些makefile，然后开始编码。这也是一种完全可行的做法——这将带来极大的灵活性，减少对专有工具的依赖，当然应该加以考虑。
- en: 'The list of IDEs in the following sections is not meant to be exhaustive. The
    list is presented in order to provide examples of the wide variety of IDEs available
    and the different focal points of each. Here are some quick points to consider:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节中列出的IDE列表并非详尽无遗。列表的目的是提供各种IDE的广泛示例以及每个IDE的不同焦点。以下是一些需要考虑的快速要点：
- en: '**Language support**: Not everything on an embedded MCU is written in C99 (or
    assembly) anymore; there are many language options out there.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言支持**：现在嵌入式MCU上的代码不再全部使用C99（或汇编）；有许多语言选项可供选择。'
- en: '**Debugging support**: Unless you plan on context-switching to a different
    tool each time, debugging is necessary. Your IDE should have some debugging capability.
    Many IDEs will rely on the **GNU Debugger** (**GDB**) for the underlying debug
    protocol, which means they should be compatible with any debug hardware that supports
    a GDB interface.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试支持**：除非你计划每次都切换到不同的工具，否则调试是必要的。你的IDE应该具备一些调试能力。许多IDE将依赖于**GNU调试器**（**GDB**）作为底层调试协议，这意味着它们应该与支持GDB接口的任何调试硬件兼容。'
- en: '**Thread-aware debugging**: Ideally, the IDE will have thread-aware debug capability.
    Remember, each task has its own stack. By default, most debug capabilities will
    only show the stack associated with the current program counter, which becomes
    problematic when attempting to analyze any task that isn''t currently running.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程感知调试**：理想情况下，IDE将具有线程感知调试功能。记住，每个任务都有自己的堆栈。默认情况下，大多数调试功能只会显示与当前程序计数器关联的堆栈，当尝试分析当前未运行的任何任务时，这会成为一个问题。'
- en: '**Device support**: Pick an IDE that can be made aware of hardware registers
    in your device (unless you won''t be debugging with it).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备支持**：选择一个可以识别您设备中硬件寄存器的IDE（除非您不会用它进行调试）。'
- en: '**The platform OS**: That is, Windows, Linux, or macOS—you can always run a
    virtual machine, but it is generally more convenient to run the IDE natively on
    your preferred OS.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台操作系统**：即Windows、Linux或macOS——您始终可以运行虚拟机，但通常在您首选的操作系统上本地运行IDE更为方便。'
- en: '**Cost**: The initial cost of a tool should take into account both the monetary
    price and the amount of time it would take to integrate the tool into your team''s
    workflow. This initial cost is tightly coupled with the current state of an organization/individual.
    For example, the cost (in time) of getting a familiar IDE up and running is generally
    very low, but this cost is dependent on what is familiar to the team. A high total
    cost of ownership can be caused by a number of different factors. Some IDEs are
    freely available but have volatile availability (vendor-supplied IDEs often fall
    into this category). If an IDE has many bugs, the cost of ownership may be high
    because of lost productivity. Finally, paid proprietary solutions often require
    annual maintenance agreements for support, updates for the latest hardware, and
    new versions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：工具的初始成本应考虑货币价格和将其集成到团队工作流程中所需的时间量。这个初始成本与组织/个人的当前状态紧密相关。例如，将熟悉的IDE设置起来并运行所需的时间（成本）通常非常低，但这种成本取决于团队熟悉的内容。高总拥有成本可能由许多不同的因素引起。一些IDE是免费提供的，但可用性波动（供应商提供的IDE通常属于此类）。如果IDE有很多错误，由于生产力下降，拥有成本可能会很高。最后，付费的专有解决方案通常需要年度维护协议以获得支持、最新硬件的更新和新版本。 '
- en: '**Integration with other tools**: There are many components that make up developing
    an embedded system. Having an IDE that integrates as much as possible is helpful,
    but some of the items to consider are the target hardware, test fixtures, debugging
    hardware, RTOS firmware, user firmware, target middleware, ancillary host software
    to help configure hardware (that is, STM32Cube), software to help you analyze
    and debug code (that is, static analysis tools), and testing frameworks.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他工具的集成**：开发嵌入式系统由许多组件组成。拥有尽可能集成的IDE是有帮助的，但需要考虑的一些项目包括目标硬件、测试夹具、调试硬件、RTOS固件、用户固件、目标中间件、辅助主机软件以帮助配置硬件（即STM32Cube）、帮助您分析和调试代码的软件（即静态分析工具），以及测试框架。'
- en: '**Usability**: Ideally, an IDE will provide a pleasant environment to code
    in and boost productivity by making code creation easier through automating cross-references
    (such as IntelliSense).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：理想情况下，IDE将提供一个愉快的编码环境，并通过自动化交叉引用（如IntelliSense）使代码创建更容易，从而提高生产力。'
- en: '**Availability**: In a perfect world, the original IDE would be available,
    fully supported, and provide updates to make the most of new hardware targets
    throughout the entire lifetime of a product or project. For long-term projects,
    it is a good idea to check the history (and licensing model) of the IDE you are
    planning to use. If the IDE is only available via subscription (with no perpetual
    licensing option), there could come a day when it is simply no longer available.
    Ensuring a perpetual license is always on hand enables you to run the IDE indefinitely
    and gives you the assurance that you''ll always be able to reproduce binaries
    from source code.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：在一个完美的世界里，原始IDE应该是可用的、完全受支持的，并提供更新以充分利用整个产品或项目生命周期中的新硬件目标。对于长期项目，检查您计划使用的IDE的历史（以及许可模式）是一个好主意。如果IDE仅通过订阅提供（没有永久许可选项），那么总有一天它可能不再可用。确保始终有永久许可在手，可以使您无限期地运行IDE，并确保您始终能够从源代码重新生成二进制文件。'
- en: '**The eco-system**: Most IDEs come with more than just the IDE itself. They''ll
    have plugins, middleware, forums, and sometimes entire communities of developers
    with them.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生态系统**：大多数IDE不仅包含IDE本身，还包括插件、中间件、论坛，有时甚至还有与之相关的整个开发者社区。'
- en: 'In the next sections, we''ll cover a few different conceptual groups of IDEs.
    Grouping IDEs in this way isn''t especially rigid, but it does help to frame expectations
    of what their motivations and use cases are. Sometimes, an IDE can be placed into
    more than one group, which is also perfectly acceptable. The groups we''ll use
    to categorize the IDEs are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍几个不同的IDE概念组。以这种方式对IDE进行分组并不特别严格，但它确实有助于设定对它们的动机和用例的期望。有时，一个IDE可以放入多个组中，这也是完全可以接受的。我们将用来分类IDE的组如下：
- en: Free MCU vendor IDEs and hardware-centric IDEs
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费微控制器供应商IDE和以硬件为中心的IDEs
- en: Platform-abstracted IDEs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台抽象化IDEs
- en: Open source/free IDEs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源/免费IDEs
- en: Proprietary IDEs
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有集成开发环境（IDEs）
- en: The example IDEs presented in this chapter date to 2019\. While embedded system
    firmware development tools don't change quite as quickly as other software disciplines,
    expect the landscape to look a bit different over time!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的示例IDE追溯到2019年。虽然嵌入式系统固件开发工具的变化速度并不像其他软件学科那么快，但预计随着时间的推移，这个领域的外观会有所不同！
- en: Free MCU vendor IDEs and hardware-centric IDEs
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 免费微控制器供应商IDEs和以硬件为中心的IDEs
- en: These days, larger MCU manufacturers will generally provide access to a free
    IDE to help lower the barriers to entry for potential developers. Historically,
    these IDEs didn't offer much more than a compiler and were generally pretty terrible
    to work with if you were using them daily. However, in the past few years, there's
    been a shift to higher quality vendor-supplied IDEs, as chip manufacturers try
    to differentiate themselves from their competitors. Sometimes, they have extra
    features integrated that will help configure hardware and/or vendor-supplied drivers,
    which can be helpful during hardware development, initial board bring-up, and
    early firmware development, where hardware peripherals are being exercised and
    integrated with the rest of the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，较大的微控制器制造商通常会提供免费IDE的访问权限，以帮助降低潜在开发者的入门门槛。从历史上看，这些IDE提供的功能并不多，如果你每天使用它们，通常很难使用。然而，在过去的几年里，由于芯片制造商试图与竞争对手区分开来，IDE的质量有了提升。有时，它们集成了额外的功能，可以帮助配置硬件和/或供应商提供的驱动程序，这在硬件开发、初始板级启动和早期固件开发期间很有帮助，此时硬件外设正在被锻炼并与系统其他部分集成。
- en: Since these tools aren't the core business concern of a hardware manufacturer,
    they will often be changed on a whim. This makes vendor IDEs a risky choice for
    long-running projects.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些工具不是硬件制造商的核心业务关注点，它们经常会随意更改。这使得供应商IDE成为长期项目的风险选择。
- en: 'Almost to prove this point, STM changed their IDE offerings while this book
    was being written. All of the examples needed to be imported into the new software:
    STM32CubeIDE.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎为了证明这一点，STM在撰写本书时更改了他们的IDE产品。所有示例都需要导入到新的软件中：STM32CubeIDE。
- en: Since we'll be using an STM32 MCU for our target, we'll take a look at the IDE
    supplied by STM (at the time of writing, this is STM32CubeIDE). For each of the
    different MCU vendors, you could consider their proprietary IDE—for example, if
    you were developing on NXP MCUs, you would likely consider MCUXpresso.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是使用STM32微控制器，我们将查看STM提供的IDE（截至撰写本文时，这是STM32CubeIDE）。对于不同的微控制器供应商，你可以考虑他们的专有IDE——例如，如果你在NXP微控制器上进行开发，你可能会考虑MCUXpresso。
- en: STM32CubeIDE
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32CubeIDE
- en: In the case of STM, there are multiple IDEs offered by the same MCU vendor.
    Sometime after acquiring Atollic, STM rolled in a fully-customized version of
    Atollic TrueStudio with their STMCubeMX application, resulting in STM32CubeIDE.
    Although Atollic TrueStudio is still available, it is deprecated and not recommended
    for new designs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM的情况下，同一微控制器供应商提供了多个IDE。在收购Atollic之后不久，STM将Atollic TrueStudio的完全定制版本整合到他们的STMCubeMX应用程序中，从而产生了STM32CubeIDE。尽管Atollic
    TrueStudio仍然可用，但它已被弃用，不推荐用于新设计。
- en: 'Here are the quick stats for STM32CubeIDE:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是STM32CubeIDE的快速统计数据：
- en: '| **Website** | [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html)
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html)
    |'
- en: '| **Host OS** | Windows, Linux, or macOS |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、Linux或macOS |'
- en: '| **Debugger support** | GDB, STLink, JLink, JTrace, and more |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | GDB、STLink、JLink、JTrace等 |'
- en: '| **IDE framework** | Eclipse |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Eclipse |'
- en: '| **Compiler** | GCC, extensible |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC、可扩展 |'
- en: '| **Cost** | Free |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | Proprietary—freeware |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | 专有——免费软件 |'
- en: 'Now that we''ve looked at the IDEs designed with only one MCU in mind, we''ll
    take a look at the polar opposite to vendor-supplied IDEs: platform-abstracted
    IDEs.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了仅针对一个微控制器设计的集成开发环境（IDEs），接下来我们将看看与供应商提供的 IDEs 极为相反的：平台抽象化的 IDEs。
- en: Platform-abstracted IDEs
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台抽象化的 IDEs
- en: The combination of increasingly complex MCUs, ballooning expectations of device
    functionality, and shrinking development cycles has pushed many software tooling
    companies to focus on creating abstractions above the hardware, which is meant
    to make the development of complex devices easier and faster. The most successful
    platforms and abstractions tend to take on a life of their own after a few years
    on the market. Mbed and Arduino both have extensive user communities, with many
    user-created websites and blogs dedicated to each platform.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越复杂的微控制器（MCUs）的融合、对设备功能的期望不断膨胀以及开发周期的缩短，许多软件开发工具公司不得不专注于在硬件之上创建抽象，目的是使复杂设备的开发更加容易和快速。在市场上经过几年的发展后，最成功的平台和抽象往往能够独立生存。Mbed
    和 Arduino 都拥有庞大的用户社区，许多用户创建的网站和博客都致力于每个平台。
- en: Because platform consistency is paramount for ease of use, implementations will
    often include many features that focus on ease of use, sometimes at the expense
    of performance and good design practice. For example, some hardware targets will
    expose an API for something such as a PWM output, even though the underlying MCU
    hardware has no peripheral that supports that functionality. This creates a faster
    prototyping experience across many different hardware targets, since the API will
    seamlessly map the functionality to a software routine. However, device performance
    can be negatively impacted as a result. Sometimes the programmer isn't even aware
    of the complex trade-offs that are being made underneath the simple API calls
    they're making.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平台一致性对于易用性至关重要，实现时通常会包括许多专注于易用性的功能，有时可能会牺牲性能和良好的设计实践。例如，一些硬件目标会暴露一个 API，例如
    PWM 输出，尽管底层微控制器硬件没有支持该功能的外围设备。这为许多不同的硬件目标提供了更快的原型设计体验，因为 API 将无缝地将功能映射到软件例程。然而，这可能会对设备性能产生负面影响。有时程序员甚至没有意识到他们简单
    API 调用背后所做出的复杂权衡。
- en: There are many different contributing factors that determine whether or not
    it is a good idea to base a project around a platform.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的因素决定了围绕平台进行项目是否是一个好主意。
- en: 'Designing on top of a platform could be good in the following cases:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，在平台上进行设计可能是好的：
- en: '**The platform has nearly everything you''ll need included with it**: If the
    platform already has all the major pieces, there is little uncertainty; all that
    is required is some domain-specific code.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台几乎包含了您所需的所有功能**：如果平台已经包含了所有主要部分，那么不确定性很小；所需的就是一些特定领域的代码。'
- en: '**Your intended target device has a development board that meets your exact
    requirements**: This results in less uncertainty than attempting to add many missing
    subcircuits and properly integrate them with existing platform code.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您打算目标设备有一个满足您确切要求的开发板**：这比尝试添加许多缺失的子电路并将其正确集成到现有平台代码中要减少许多不确定性。'
- en: '**Most engineers on the team already have deep experience with the platform**: *Deep*
    experience means they have added capability similar to any customizations the
    project requires.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队中的大多数工程师都已经对该平台有深入的经验**：**深入**的经验意味着他们已经添加了与项目所需定制类似的功能。'
- en: 'Designing on top of a platform could be bad in the following cases:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，在平台上进行设计可能会出现问题：
- en: '**Few team members have experience with the desired platform**: Some are more
    complex than others—not having someone with first-hand experience can be risky.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**很少有团队成员有使用所需平台的经验**：有些平台比其他平台更复杂——没有第一手经验可能会存在风险。'
- en: '**The MCU you intend to use is not already supported by the platform**: There
    are often many ancillary requirements for adding MCU support to a platform that
    add no value to your project. Adding support for a new device to an existing complex
    platform will require more effort for a very simple project than creating the
    project on top of bare metal or with minimal vendor-supplied libraries.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您打算使用的微控制器尚未被平台支持**：通常有许多辅助要求需要添加微控制器支持到平台中，这些要求对您的项目没有价值。将新设备支持添加到现有的复杂平台中，对于一个非常简单的项目来说，比在裸金属或使用最小供应商提供的库上创建项目需要更多的努力。'
- en: '**Black box debugging is difficult**: As an embedded engineer moves further
    away from hardware, it becomes increasingly difficult to understand why the system
    is behaving the way it is, especially when there are multiple layers of **other
    people''s code** (**OPC**) to dig through.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒调试困难**：随着嵌入式工程师越来越远离硬件，理解系统为何以这种方式运行变得越来越困难，尤其是在需要挖掘多层**他人代码**（OPC）的情况下。'
- en: A young, real-time embedded engineer's professional development can be severely
    hampered by investing too much time and energy into platforms early on. With all
    of this additional complexity, there is additional risk and uncertainty around
    whether deadlines will be met reliably in a real-time system. Digging into a complex
    code base to try and track down a complex intermittent bug can be a real challenge.
    This challenge becomes even larger when a solid foundation of low-level knowledge
    isn't there to draw upon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个年轻的实时嵌入式工程师的专业发展可能会因为早期过多地投入时间和精力到平台上而受到严重影响。随着所有这些额外复杂性的增加，在实时系统中可靠地满足截止日期的风险和不确定性也随之增加。深入复杂的代码库以尝试追踪复杂的间歇性错误确实是一个挑战。如果没有坚实的基础的低级知识可以借鉴，这个挑战会变得更加严峻。
- en: In the next couple of sections, we'll cover a few options for platform-abstracted
    IDEs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将介绍一些平台抽象化IDE的选项。
- en: ARM Mbed Studio
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM Mbed Studio
- en: ARM Mbed is an IoT-focused platform that provides a very large middleware library
    and a consistent development environment across many different hardware vendors.
    Originally, the Mbed platform was only available through a website, but they have
    now added Mbed Studio—an offline IDE available for Windows and macOS.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ARM Mbed是一个专注于物联网的平台，提供非常庞大的中间件库和跨许多不同硬件供应商的一致开发环境。最初，Mbed平台仅通过网站提供，但现在他们已经增加了Mbed
    Studio——一个适用于Windows和macOS的离线IDE。
- en: 'Here are the quick stats for ARM Mbed Studio:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是ARM Mbed Studio的简要统计信息：
- en: '| **Website** | [https://os.mbed.com/studio/](https://os.mbed.com/studio/)
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://os.mbed.com/studio/](https://os.mbed.com/studio/) |'
- en: '| **Host OS** | Windows, macOS, or online (Mbed online) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows，macOS，或在线（Mbed在线） |'
- en: '| **Debugger support** | pyOCD for limited graphical debugging or GDB (console
    only) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | pyOCD用于有限的图形调试或GDB（仅控制台） |'
- en: '| **IDE framework** | Theia |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Theia |'
- en: '| **Compiler** | ARM Compiler 6, GCC, and IAR |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | ARM Compiler 6，GCC，和 IAR |'
- en: '| **Cost** | Free |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | Apache 2.0 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | Apache 2.0 |'
- en: Since Mbed is platform-oriented, projects can be set up with the Mbed IDE, then
    exported to various offline IDEs, such as ARM Keil uVision, or makefile based
    projects, which import to Eclipse and Visual Studio Code. If your project requires
    the functionality provided by the included middleware and it is well implemented,
    not needing to re-invent the wheel can be a serious timesaver.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Mbed是面向平台的，项目可以使用Mbed IDE设置，然后导出到各种离线IDE，例如ARM Keil uVision，或者基于makefile的项目，这些项目可以导入到Eclipse和Visual
    Studio Code。如果你的项目需要包含的中间件提供的功能，并且实现良好，那么不需要重新发明轮子可以节省大量时间。
- en: Arduino IDE
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino IDE
- en: The Arduino platform is an extremely pervasive platform with a huge ecosystem
    of hardware and software. Generally used to introduce newcomers to electronics
    and programming, the Arduino IDE uses strictly structured libraries that expose
    a dialect of C/C++ for users to write sketches. The goal of Arduino is to make
    prototyping quick and easy for non-programmers. As such, it hides as many details
    about the underlying hardware as possible inside libraries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino平台是一个极其普及的平台，拥有庞大的硬件和软件生态系统。通常用于向新入门者介绍电子和编程，Arduino IDE使用严格结构的库，为用户提供了C/C++方言来编写草图。Arduino的目标是让非程序员能够快速、轻松地进行原型设计。因此，它尽可能在库中隐藏了底层硬件的细节。
- en: 'Here are the quick stats for the Arduino IDE:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Arduino IDE的简要统计信息：
- en: '| **Website** | [https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software)
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.arduino.cc/en/main/software](https://www.arduino.cc/en/main/software)
    |'
- en: '| **Host OS** | Windows, macOS, Linux, and online |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows，macOS，Linux，和在线 |'
- en: '| **Debugger support** | None |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | 无 |'
- en: '| **IDE framework** | Proprietary Java, processing |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | 专有Java，处理 |'
- en: '| **Compiler** | avg-gcc, board-specific |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | avg-gcc，板级特定 |'
- en: '| **Cost** | Free |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | GNU |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | GNU |'
- en: There are also many more non-Arudino supplied IDEs that can be used to program
    the Arduino platform. Some will have additional capabilities and expose more of
    the underlying C/C++ implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他非Arduino提供的IDE可以用来编程Arduino平台。其中一些将具有额外的功能，并暴露更多底层C/C++实现。
- en: Now that we've covered fully abstracted IDEs, we'll move on to more traditionally
    oriented IDEs that are open source and/or freely available.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了完全抽象的IDE，我们将转向更传统导向的IDE，这些IDE是开源的和/或免费提供的。
- en: Open source/free IDEs
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源/免费IDE
- en: Since IBM created the Eclipse foundation to promote an open source, highly extensible
    IDE, many Eclipse-based IDEs have popped up. We'll take a look at two such IDEs
    in this section. In recent years, Microsoft has started to focus heavily on open
    source projects, creating the freely available, open source Visual Studio Code
    text editor, which is also covered in this section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自从IBM创建了Eclipse基金会以推广一个开源、高度可扩展的IDE以来，许多基于Eclipse的IDE已经出现。在本节中，我们将探讨其中两个这样的IDE。近年来，微软开始高度重视开源项目，创建了免费的开源Visual
    Studio Code文本编辑器，该编辑器也包含在本节中。
- en: AC6 System Workbench for STM32 (S4STM32)
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AC6 System Workbench for STM32 (S4STM32)
- en: AC6 is a consulting firm that has contributed an Eclipse-based IDE that targets
    STM32 MCUs. System Workbench adds some support for STM-based discovery boards
    to help get projects set up quickly. AC6 also offers System Workbench for Linux,
    which can be useful if you are developing an application with one of the multi-core
    devices (from the STM32MP1 family).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AC6是一家咨询公司，它贡献了一个针对STM32微控制器的基于Eclipse的IDE。System Workbench添加了一些对基于STM的发现板的支持，以帮助快速设置项目。AC6还提供了适用于Linux的System
    Workbench，如果你正在使用STM32MP1系列的多核设备之一开发应用程序，这可能很有用。
- en: 'Here are the quick stats for AC6 System Workbench for STM32:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是AC6 System Workbench for STM32的快速统计数据：
- en: '| **Website** | [http://ac6-tools.com/content.php/content_SW4MCU.xphp](http://ac6-tools.com/content.php/content_SW4MCU.xphp)
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [http://ac6-tools.com/content.php/content_SW4MCU.xphp](http://ac6-tools.com/content.php/content_SW4MCU.xphp)
    |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger support** | GDB |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | GDB |'
- en: '| **IDE framework** | Eclipse |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Eclipse |'
- en: '| **Compiler** | GCC |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC |'
- en: '| **Cost** | Free |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | Proprietary free |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **许可证类型** | 商业免费 |'
- en: Another alternative to System Workbench is to start with a bare Eclipse CDT
    install.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: System Workbench的另一个替代方案是从裸Eclipse CDT安装开始。
- en: Eclipse CDT and GCC
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse CDT 和 GCC
- en: You can also choose to roll your own Eclipse-based IDE from scratch. Eclipse
    CDT is the de facto standard for C/C++ development. You'll also need to provide
    a compiler. ARM provides a full GCC site for cross-compiling to ARM Cortex-M devices
    from Windows, Linux, and macOS. It can be found at [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择从头开始自己构建基于Eclipse的IDE。Eclipse CDT是C/C++开发的既定标准。你还需要提供一个编译器。ARM提供了一个完整的GCC网站，用于从Windows、Linux和macOS交叉编译到ARM
    Cortex-M设备。它可以在[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm)找到。
- en: 'Here are the quick stats for Eclipse CDT:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Eclipse CDT的快速统计数据：
- en: '| **Website** | [https://www.eclipse.org/cdt/](https://www.eclipse.org/cdt/)
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.eclipse.org/cdt/](https://www.eclipse.org/cdt/) |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger support** | GDB |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | GDB |'
- en: '| **IDE framework** | Eclipse |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Eclipse |'
- en: '| **Compiler** | GCC |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC |'
- en: '| **Cost** | Free |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | **Eclipse Public License** (**EPL**) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **许可证类型** | **Eclipse公共许可证** (**EPL**) |'
- en: 'For those that don''t care for the Eclipse IDE, another alternative exists
    and is becoming increasingly popular: Visual Studio Code.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不关心Eclipse IDE的人来说，另一个替代方案存在，并且越来越受欢迎：Visual Studio Code。
- en: Microsoft Visual Studio Code
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio Code
- en: In 2015, Microsoft released Visual Studio Code, which is a text editor that
    provides the ability to add extensions. While this sounds fairly straightforward
    on the surface, there are enough extensions available to give a very respectable
    IDE experience, including IntelliSense and full debug capability. If you're used
    to Visual Studio-based IntelliSense and debugging, then this environment will
    be very familiar.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，微软发布了Visual Studio Code，这是一个提供添加扩展功能的文本编辑器。虽然表面上听起来相当直接，但可用的扩展足够多，可以提供非常令人尊重的IDE体验，包括IntelliSense和完整的调试功能。如果你习惯了基于Visual
    Studio的IntelliSense和调试，那么这个环境将会非常熟悉。
- en: 'Here are the quick stats for Visual Studio Code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Visual Studio Code的快速统计数据：
- en: '| **Website** | [https://code.visualstudio.com/](https://code.visualstudio.com/)
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://code.visualstudio.com/](https://code.visualstudio.com/)
    |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger support** | GDB, ST-Link, and others |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | GDB、ST-Link和其他 |'
- en: '| **IDE framework** | Visual Studio Code |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Visual Studio Code |'
- en: '| **Compiler** | Many |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | 许多 |'
- en: '| **Cost** | Free |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费 |'
- en: '| **License type** | MIT |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | MIT |'
- en: 'Similar to Eclipse CDT, Visual Studio Code will need GCC installed, as well
    as an extension. In order to get Visual Studio properly set up, follow these steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eclipse CDT类似，Visual Studio Code将需要安装GCC以及一个扩展。为了正确设置Visual Studio，请按照以下步骤操作：
- en: To install GCC for Cortex-M, go to [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm).
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Cortex-M的GCC，请访问[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm)。
- en: To install the JLink tools (used to connect to the debug probe), go to [https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装JLink工具（用于连接调试探针），请访问[https://www.segger.com/downloads/jlink](https://www.segger.com/downloads/jlink)。
- en: To install the `cortex-debug` extension, go to [https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug](https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装`cortex-debug`扩展，请访问[https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug](https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug)。
- en: So far, all of the IDEs we have covered have been free of charge (and in some
    cases, open source). The next section includes IDEs that cost money and are largely
    closed source. *Why would anyone want such a thing?,* you ask. Read on and find
    out what these solutions have to offer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有IDE都是免费的（在某些情况下，是开源的）。下一节将包括需要付费且主要闭源的IDE。你可能会问：“为什么有人会想要这样的东西？”继续阅读，了解这些解决方案能提供什么。
- en: Proprietary IDEs
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专有IDE
- en: Once the norm for cross-compiling applications for MCUs, paid proprietary IDEs
    are starting to be outnumbered by free, open source solutions. However, the mere
    existence of free options doesn't immediately render paid options obsolete. The
    selling point of proprietary IDEs is that they provide the widest range of device
    support and require the least amount of attention from the developer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一度是用于为MCU交叉编译应用程序的规范，付费的专有IDE开始被免费的开源解决方案所超越。然而，免费选项的存在并不立即使付费选项过时。专有IDE的卖点在于它们提供了最广泛的设备支持，并且需要开发者最少关注。
- en: 'Designed to work out of the box, the paid professional-grade solutions'' claim
    to fame is saving developers time. These time savings will typically come in three
    main forms: unified environments for setting up an MCU, unified debugging environments,
    and vendor-supplied middleware, common across multiple MCU vendors.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 设计即用即装，付费的专业级解决方案的卖点在于节省开发者时间。这些时间节省通常以三种主要形式出现：用于设置MCU的统一环境、统一的调试环境以及多个MCU供应商通用的供应商提供的中间件。
- en: Getting an MCU up and running is easier now than it ever has been, but once
    a project gets advanced enough that it starts defining specific memory regions
    in RAM and ROM or adding additional executable space in Quad-SPI-based flash,
    some additional configuration will be required. The best professional IDEs will
    provide some help (via GUIs), which makes these configurations a bit easier than
    needing to dive into scatter files and assembly-based start-up code (although
    these are *excellent* skills to have!)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让MCU启动运行比以往任何时候都要容易，但一旦项目足够高级，开始定义RAM和ROM中的特定内存区域或在基于Quad-SPI的闪存中添加额外的可执行空间时，就需要进行一些额外的配置。最好的专业IDE将提供一些帮助（通过GUI），这使得这些配置比需要深入研究scatter文件和基于汇编的启动代码要容易一些（尽管这些是**优秀**的技能！）
- en: Similar to the ability to quickly configure an MCU via a GUI, debugger support
    in pro-grade IDEs will also typically be very straightforward, generally limited
    to selecting the debugger from a drop-down list and possibly fine-tuning some
    settings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过GUI快速配置MCU的能力相似，专业级IDE中的调试器支持通常也非常简单，通常限于从下拉列表中选择调试器，并可能微调一些设置。
- en: If you read through all of the options that different MCUs could possess, it
    probably comes as no surprise that the same MCU won't be a great fit for every
    project you undertake. Being able to quickly move between MCU families (and even
    vendors) while maintaining a unified interface is an excellent advantage. However,
    getting locked into a platform-based approach, where hardware interfaces start
    to become defined (as well as firmware APIs), can be limiting, too (that is, Arduino
    or MBed hardware definitions).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读了不同MCU可能拥有的所有选项，那么相同的MCU可能不会适合您进行的每一个项目，这也许并不令人惊讶。能够在保持统一界面的同时快速在MCU系列（甚至供应商）之间切换是一个巨大的优势。然而，陷入基于平台的方法，其中硬件接口开始被定义（以及固件API），也可能有所限制（即Arduino或MBed硬件定义）。
- en: Using well-written middleware from an established company breaks you free from
    the tendency of hardware-oriented platforms focusing on only the day-lighted peripherals.
    It moves the focus from accessing a particular platform's pins to accessing properly
    abstracted MCU peripherals. This distinction is subtle but quite important when
    it comes to design flexibility. Well-written middleware will provide consistent
    abstractions of MCU peripherals, as well as more sophisticated middleware.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用知名公司的精心编写的中间件可以让你摆脱硬件平台只关注日间外围设备的倾向。它将重点从访问特定平台的引脚转移到访问正确抽象的MCU外围设备。这种区别虽然微妙但非常重要，尤其是在设计灵活性方面。精心编写的中间件将提供一致的MCU外围设备抽象，以及更复杂的中间件。
- en: The downside to paid tooling is the monetary cost, which needs to be evaluated
    against the development time, labor, and opportunity costs of a delayed product
    launch. Do you have an idea of the amount of time you can save by using middleware
    instead of reinventing that firmware wheel? What about the amount of time gained
    by having an IDE that works consistently for any processor you choose? Some basic
    **return-on-investment** (**ROI**) calculations comparing the cash outlay against
    *honest* *and accurate* estimates of the developer's time will typically tip the
    scales toward bought-in middleware for moderately complex projects. That is, of
    course, assuming cash is available to purchase software tooling.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用付费工具的缺点是货币成本，这需要与延迟产品发布的开发时间、劳动力和机会成本进行评估。您是否有使用中间件而不是重新发明固件轮子所能节省的时间的想法？拥有一个对任何您选择的处理器都能一致工作的IDE能节省多少时间？一些基本的**投资回报率**（**ROI**）计算，将现金支出与开发者时间的**诚实**和**准确**估计进行比较，通常会将中等复杂项目的天平倾向于购买中间件。当然，这是假设有现金购买软件工具。
- en: ARM/Keil uVision
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM/Keil uVision
- en: Keil originally developed one of the first C compilers for the 8-bit 8051 architecture
    back in the 1980s. The company moved on to support other cores and was eventually
    acquired by ARM. They currently offer one of the most efficient compilers for
    ARM Cortex-M devices (Clang/LLVM). A free version of the uVision IDE is available
    but is limited to 32 KB code space. Various tiers of the IDE are available in
    several licensing options (such as perpetual, subscription-based, and so on).
    Modules of code are added through *software packs*, which simplifies rapidly setting
    up projects. A very fully featured middleware stack is available as a top-tier
    offering, which comes abstractions for different RTOSes as well as a uniform API
    on top of all of the supported MCUs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Keil最初在20世纪80年代开发了第一个针对8位8051架构的C编译器。公司后来转向支持其他核心，并最终被ARM收购。他们目前提供ARM Cortex-M设备中最高效的编译器之一（Clang/LLVM）。uVision
    IDE的免费版本可用，但代码空间限制为32 KB。IDE的各个级别可通过多种许可选项（如永久许可、基于订阅的许可等）获得。通过*软件包*添加代码模块，这简化了快速设置项目的过程。作为顶级产品，提供了一套非常全面的中间件堆栈，其中包括对不同实时操作系统的抽象以及所有支持的微控制器上的统一API。
- en: 'Here are the quick stats for uVision:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是uVision的快速统计数据：
- en: '| **Website** | [http://www2.keil.com/mdk5/uvision/](http://www2.keil.com/mdk5/uvision/)
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [http://www2.keil.com/mdk5/uvision/](http://www2.keil.com/mdk5/uvision/)
    |'
- en: '| **Host OS** | Windows |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **宿主操作系统** | Windows |'
- en: '| **Debugger support** | Many |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | 许多 |'
- en: '| **IDE framework** | Proprietary |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | 专有 |'
- en: '| **Compiler** | armcc, armClang, GCC |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | armcc, armClang, GCC |'
- en: '| **Cost** | free-$$$ |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 免费-$$$ |'
- en: '| **License type** | Proprietary |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | 专有 |'
- en: FreeRTOS task-aware debugging is not available—Keil uVision has elaborate support
    for their own freely available CMSIS RTX RTOS instead. The code editor in uVision
    MDK is also overdue a facelift.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS任务感知调试不可用——Keil uVision对其免费提供的CMSIS RTX RTOS有详尽的支撑。uVision MDK中的代码编辑器也亟需更新。
- en: Similar to Keil uVision, IAR Embedded Workbench is another long-standing IDE
    for embedded work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与Keil uVision类似，IAR嵌入式工作台是另一个长期存在的嵌入式IDE。
- en: IAR Embedded Workbench
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IAR嵌入式工作台
- en: In general, IAR Embedded Workbench has a very similar feature set to Keil uVision.
    One major difference is that IAR doesn't have the advanced capability of incorporating
    modular software packs. Advanced debugging features are a bit more easily accessible
    and intuitive in IAR versus uVision. The code editor is equally disappointing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IAR嵌入式工作台与Keil uVision具有非常相似的功能集。一个主要区别是IAR没有集成模块化软件包的高级功能。与uVision相比，IAR的高级调试功能更容易访问和直观。代码编辑器同样令人失望。
- en: 'Here are the quick stats for IAR Embedded Workbench:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是IAR嵌入式工作台的快速统计数据：
- en: '| **Website** | [https://www.iar.com/iar-embedded-workbench/](https://www.iar.com/iar-embedded-workbench/)
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.iar.com/iar-embedded-workbench/](https://www.iar.com/iar-embedded-workbench/)
    |'
- en: '| **Host OS** | Windows |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **宿主操作系统** | Windows |'
- en: '| **Debugger support** | Many |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | 许多 |'
- en: '| **IDE framework** | Proprietary |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | 专有 |'
- en: '| **Compiler** | Proprietary |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | 专有 |'
- en: '| **Cost** | $$–$$$ |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | $$–$$$ |'
- en: '| **License type** | Proprietary |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | 专有 |'
- en: Now that we've covered the old standbys, we'll get into the more recently available
    offerings, starting with Rowley CrossWorks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了老牌产品，接下来我们将探讨最近可用的产品，从Rowley CrossWorks开始。
- en: Rowley CrossWorks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rowley CrossWorks
- en: Rowley Crossworks is a slightly lower priced entry point than Keil and IAR.
    Middleware is licensed separately from the IDE. FreeRTOS-aware task-based debugging
    is not available from within the IDE; instead, support is available for the **CrossWorks
    Tasking Library** (**CTL**) RTOS solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Rowley Crossworks是比Keil和IAR略便宜的入门级产品。中间件许可与IDE分开。IDE内部不支持FreeRTOS感知的任务调试；相反，支持**CrossWorks任务库**（**CTL**）RTOS解决方案。
- en: 'Here are the quick stats for CrossWorks:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是CrossWorks的快速统计数据：
- en: '| **Website** | [https://www.rowley.co.uk/](https://www.rowley.co.uk/) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.rowley.co.uk/](https://www.rowley.co.uk/) |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **宿主操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger support** | Many |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | 许多 |'
- en: '| **IDE framework** | Proprietary |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | 专有 |'
- en: '| **Compiler** | GCC, LLVM |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC, LLVM |'
- en: '| **Cost** | $–$$$ |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | $–$$$ |'
- en: '| **License type** | Proprietary |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **许可类型** | 专有 |'
- en: 'Next up is an IDE created by a company known for its debugging hardware: SEGGER
    Embedded Studio.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个由以调试硬件闻名的公司创建的IDE：SEGGER嵌入式工作室。
- en: SEGGER Embedded Studio
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SEGGER嵌入式工作室
- en: SEGGER—the manufacturer of the debug probe we'll be using—also offers many software
    products, including their own IDE (and RTOS). It is available free of charge for
    non-commercial use, with no limitations. They also have a full middleware stack
    available, which is licensed separately from the IDE. FreeRTOS-aware debugging
    is available directly in the IDE, with the appropriate plugin.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SEGGER——我们将使用的调试探针制造商——也提供许多软件产品，包括他们自己的IDE（和RTOS）。它对非商业用途免费提供，没有任何限制。他们还提供完整的中间件堆栈，该堆栈的许可证是独立于IDE的。FreeRTOS感知调试可以直接在IDE中通过适当的插件进行。
- en: 'Here are the quick stats for Embedded Studio:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是嵌入式工作室的快速统计数据：
- en: '| **Website** | [https://www.segger.com/products/development-tools/embedded-studio/](https://www.segger.com/products/development-tools/embedded-studio/)
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://www.segger.com/products/development-tools/embedded-studio/](https://www.segger.com/products/development-tools/embedded-studio/)
    |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger Support** | SEGGER |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | SEGGER |'
- en: '| **IDE framework** | Proprietary |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | 专有 |'
- en: '| **Compiler** | GCC, LLVM |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC、LLVM |'
- en: '| **Cost** | Free for noncommercial use or $$-$$$ |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | 非商业用途免费或$$-$$$ |'
- en: '| **License type** | Proprietary, JLink as a license dongle |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **许可证类型** | 专有，JLink作为许可证狗 |'
- en: 'We''ll end the list of paid IDEs on a curious note: SysProgs Visual GDB.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个有趣的观点结束付费IDE的列表：SysProgs Visual GDB。
- en: SysProgs Visual GDB
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SysProgs Visual GDB
- en: Visual GDB isn't actually an IDE. It is a plugin for Microsoft Visual Studio
    and Visual Studio Code. It has been in existence for quite some time (since 2012).
    The main purpose of Visual GDB is to provide a consistent UI (Visual Studio) for
    interacting with GDB-enabled debuggers and GNU make utilities. Its main target
    user is programmers that are familiar with Visual Studio as a development environment
    and would like to continue that environment in their embedded work.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Visual GDB实际上不是一个IDE。它是Microsoft Visual Studio和Visual Studio Code的插件。它已经存在了一段时间（自2012年以来）。Visual
    GDB的主要目的是为与GDB启用调试器和GNU make实用程序交互提供一个一致的UI（Visual Studio）。其主要目标用户是熟悉Visual Studio作为开发环境并希望在嵌入式工作中继续使用该环境的程序员。
- en: 'Here are the quick stats for Visual GDB:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Visual GDB的快速统计数据：
- en: '| **Website** | [https://sysprogs.com/](https://sysprogs.com/) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **网站** | [https://sysprogs.com/](https://sysprogs.com/) |'
- en: '| **Host OS** | Windows, macOS, or Linux |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **主机操作系统** | Windows、macOS或Linux |'
- en: '| **Debugger support** | Yes |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **调试器支持** | 是 |'
- en: '| **IDE framework** | Visual Studio, Visual Studio Code |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **IDE框架** | Visual Studio、Visual Studio Code |'
- en: '| **Compiler** | GCC, ARM |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **编译器** | GCC、ARM |'
- en: '| **Multi-core debug** | Yes |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **多核调试** | 是 |'
- en: '| **Cost** | $ |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **成本** | $ |'
- en: '| **License type** | Proprietary |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **许可证类型** | 专有 |'
- en: Visual GDB offers integration with a graphical configuration utility—STM Cube—as
    well as Arduino projects, so migrating from different development frameworks may
    be a bit easier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Visual GDB提供与图形配置实用程序STM Cube以及Arduino项目的集成，因此从不同的开发框架迁移可能更容易一些。
- en: Next, we'll select an IDE specifically for our use case, which is developing
    the coding exercises.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选择一个专门用于我们用例的IDE，即开发编码练习。
- en: Selecting the IDE used in this book
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择本书中使用的IDE
- en: Now that we've categorized several different IDEs, it's time to consider which
    one will be used for the example code covered in the remainder of this book. In
    keeping with the low-cost theme in order to reduce the barriers to entry, we're
    going to focus on the IDEs that don't require any monetary investment—anything
    that is freely available for non-professional use (without time or code limits)
    can be considered. This immediately eliminates Keil uVision, IAR Embedded Workbench,
    and SysProgs Visual GDB. Keil has a free version that is code-limited to 32 KB,
    but we might use that up quickly, depending on how much middleware we elect to
    include in the examples.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对几个不同的IDE进行了分类，是时候考虑哪一种将被用于本书剩余部分涵盖的示例代码了。为了保持低成本的主题，以降低入门门槛，我们将关注那些不需要任何货币投资的IDE——任何免费提供给非专业使用（无时间或代码限制）的东西都可以考虑。这立即排除了Keil
    uVision、IAR嵌入式工作台和SysProgs Visual GDB。Keil有一个免费版本，但代码限制在32 KB，但我们可能会很快用完，这取决于我们选择在示例中包含多少中间件。
- en: Since a large part of this book also covers debugging with a J-Link probe, we'd
    like to have an IDE that supports either J-Link or GDB, as well. In a perfect
    world, the IDE would also support task-aware FreeRTOS debugging, live variable
    watches, and so on. The FreeRTOS kernel-aware debugging isn't a deal-breaker,
    as we'll see in the next chapter, because SEGGER Ozone includes this capability.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的大部分内容也涵盖了使用 J-Link 探针进行调试，我们希望有一个支持 J-Link 或 GDB 的 IDE，在理想的世界里，IDE 还应支持任务意识
    FreeRTOS 调试、实时变量监视等。FreeRTOS 内核意识调试并不是决定性的，正如我们将在下一章中看到的，因为 SEGGER Ozone 包含这一功能。
- en: 'Finally, the IDE should be multi-platform to promote ease of adoption for anyone
    brave enough to make the journey. Given this set of criteria, we''re left with
    a limited number of options, as shown:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，IDE 应该是跨平台的，以促进任何勇敢尝试这段旅程的人的易于采用。考虑到这一套标准，我们只剩下有限的选择，如下所示：
- en: '| Potential IDE | Monetarily free  version available | No code size limits
    | SEGGER J-Link supported | FreeRTOS kernel-aware debug | Multi-platform |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 潜在的 IDE | 可用免费版本 | 无代码大小限制 | 支持 SEGGER J-Link | FreeRTOS 内核意识调试 | 跨平台 |'
- en: '| Keil uVision | ✓ | X | ✓ | X | X |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Keil uVision | ✓ | X | ✓ | X | X |'
- en: '| IAR | X | N/A | ✓ | ✓ | X |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| IAR | X | N/A | ✓ | X |'
- en: '| Visual GDB | X | N/A | ✓ | ✓ | ✓ |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Visual GDB | X | N/A | ✓ | ✓ | ✓ |'
- en: '| Rowley CrossWorks | X | N/A | ✓ | ✓ | ✓ |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Rowley CrossWorks | X | N/A | ✓ | ✓ | ✓ |'
- en: '| VS Code | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| VS Code | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| Eclipse CDT | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| Eclipse CDT | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| AC6 S4STM32 | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| AC6 S4STM32 | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| Arduino IDE | ✓ | ✓ | ✓ | X | ✓ |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| Arduino IDE | ✓ | ✓ | ✓ | X | ✓ |'
- en: '| ARM MBed Studio | ✓ | ✓ | ✓ | X | ✓ |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| ARM MBed Studio | ✓ | ✓ | ✓ | X | ✓ |'
- en: '| STM32CubeIDE | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| STM32CubeIDE | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: '| SEGGER Embedded Studio | ✓ | ✓ | ✓ | ✓ | ✓ |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| SEGGER Embedded Studio | ✓ | ✓ | ✓ | ✓ | ✓ |'
- en: So, what are the main points we can derive from this table and the previous
    observations?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以从这张表和之前的观察中得出哪些主要观点？
- en: Eclipse CDT is a potential candidate, but it is slightly less desirable because
    of the additional setup required compared to some of the other solutions.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse CDT 是一个潜在的选择，但由于与其他解决方案相比需要额外的设置，因此它稍微不那么受欢迎。
- en: VS Code is an extensible code editor (out of the box), similar to Eclipse. Additional
    plug-ins will be needed.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 是一个可扩展的代码编辑器（开箱即用），类似于 Eclipse。需要额外的插件。
- en: STM32But IDE promises professional-grade debug capability and multi-task RTOS
    aware debugging.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32But IDE 承诺提供专业级的调试能力和多任务 RTOS 意识的调试。
- en: SEGGER Embedded Studio promises a very similar feature set to STM32CubeIDE.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER Embedded Studio 承诺提供与 STM32CubeIDE 非常相似的功能集。
- en: We'll be using STM32CubeIDE for the code examples. Since STM32CubeIDE also contains
    code generators for the STM32 line of MCUs, let's take a look at some of the advantages
    of using a code generation tool, as well as the tradeoffs to be made.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 STM32CubeIDE 进行代码示例。由于 STM32CubeIDE 还包含 STM32 系列微控制器的代码生成器，让我们看看使用代码生成工具的一些优点，以及需要做出的权衡。
- en: Considering STM32Cube
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑 STM32Cube
- en: STM32CubeIDE is the merger of two components—IDE and the STMCubeMX graphical
    configuration and code generation utility for STM32 MCUs. The *CubeMX* component
    can be useful in a few different points in the development cycle. Let's talk about
    the relevant phases of the development cycle, identify how CubeMX can help, and
    what the trade-offs are.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: STM32CubeIDE 是两个组件的合并——IDE 和 STM32 微控制器的 STMCubeMX 图形配置和代码生成工具。*CubeMX* 组件在开发周期的几个不同点可能很有用。让我们谈谈相关的开发周期阶段，确定
    CubeMX 如何帮助，以及权衡是什么。
- en: Device selection
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备选择
- en: Most modern MCUs have the option of mapping peripherals to several different
    pins. However, each pin is usually shared between several different peripherals.
    So, it is possible, on a pin-constrained device, to have the required peripherals *available *(present
    on the MCU) but not *accessible* (able to be mapped to a physical pin). Hardware
    designers can quickly evaluate whether or not individual models of an STM32 MCU
    break out the necessary combinations of peripherals that are required for a given
    application. Having the ability to quickly and accurately perform these evaluations
    across multiple chips can be a major time saver. Usually, designers need to become
    intimately familiar with datasheets for each chip before making such decisions.
    CubeMX is by no means a substitute for proper due diligence, but it does help
    to quickly narrow the field of potential devices.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代微控制器（MCU）都有将外设映射到多个不同引脚的选项。然而，每个引脚通常由几个不同的外设共享。因此，在一个引脚受限的设备上，可能存在所需的外设*可用*（存在于微控制器上），但不可*访问*（无法映射到物理引脚）。硬件设计师可以快速评估STM32微控制器的各个型号是否提供了特定应用所需的必要外设组合。能够在多个芯片上快速准确地执行这些评估可以节省大量时间。通常，设计师在做出此类决定之前需要熟悉每个芯片的数据表。CubeMX绝对不能替代适当的尽职调查，但它确实有助于快速缩小潜在设备的范围。
- en: Each peripheral on STM32 MCUs can be individually turned off, which saves power.
    With the current proliferation of battery-powered (and energy-harvesting) IoT
    devices, minimizing power consumption is a hot topic. Another way to reduce power
    is to clock the chip at a lower frequency. CubeMX allows engineers to quickly
    calculate how much power the chip will draw under specific configurations. Speed
    and accuracy are both important when investigating potential MCUs for a project.
    Getting an accurate power consumption estimate by entering a peripheral/clock
    configuration into CubeMX is much faster compared to perusing the datasheet and
    creating a spreadsheet from scratch.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: STM32微控制器上的每个外设都可以单独关闭，这可以节省电力。随着电池供电（以及能量收集）物联网设备的普及，降低功耗是一个热门话题。降低功耗的另一种方法是降低芯片的时钟频率。CubeMX允许工程师快速计算芯片在特定配置下的功耗。在调查潜在微控制器时，速度和准确性都很重要。通过在CubeMX中输入外设/时钟配置来获取准确的功耗估计，比翻阅数据表并从头创建电子表格要快得多。
- en: Once a target MCU has been selected and the custom hardware has been manufactured,
    it is time to *bring up* that new piece of hardware.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了目标微控制器并制造了定制硬件，就到了启动那块新硬件的时候了。
- en: Hardware bring-up
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件启动
- en: Hardware *bring-up* is the act of first powering on a custom-designed piece
    of hardware and performing some level of verification on it. Custom hardware will
    often have many differences compared to a development/evaluation board (it is
    custom, after all!). One area that may differ is clock hardware. STM32 clock trees
    are fairly complex—a single clock source feeds many different subsystems. The
    clock frequencies get modified along the way by multipliers and dividers. CubeMX
    contains a graphical wizard to help properly configure the STM32 clock tree and
    generate initialization code to get the chip up and running quickly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件*启动*是指首次开启定制设计的硬件，并在其上进行一定程度的验证。与开发/评估板相比，定制硬件通常会有很多不同之处（毕竟它是定制的！）。可能不同的一个领域是时钟硬件。STM32的时钟树相当复杂——单个时钟源为许多不同的子系统供电。时钟频率在过程中通过乘法和除法器被修改。CubeMX包含一个图形向导，可以帮助正确配置STM32时钟树并生成初始化代码，以便快速启动芯片。
- en: Early firmware effort will also be required to verify the hardware is operational.
    It is always a good idea to double-check whether the MCU can be configured to
    access all required off-chip circuitry that is present on the board. Often, it
    is in everyone's best interest to quickly evaluate the viability of the hardware,
    rather than wait until all aspects of firmware are fully fleshed out.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要早期的固件工作来验证硬件是否正常工作。始终检查微控制器是否可以配置为访问板上存在的所有所需的外部电路是一个好主意。通常，快速评估硬件的可行性比等待固件的所有方面都完全完善更有利于每个人。
- en: When it is time to make use of the complex peripherals included on STM32 MCUs,
    CubeMX can be used to quickly set up pin mapping from the internal peripheral
    to the external pins of the MCU. It also contains simple, menu-driven interfaces
    for selecting how the peripheral should be configured. Initialization code is
    automatically generated, which uses STM's **Hardware Abstraction Layer** (**HAL**)
    drivers. The relevant peripheral interrupts are also configured and stubbed out
    for the user. This enables an embedded engineer to get through verification as
    quickly as possible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要使用STM32微控制器上包含的复杂外设时，CubeMX可以用来快速设置从内部外设到微控制器外部引脚的引脚映射。它还包含简单的菜单驱动界面，用于选择外设应该如何配置。初始化代码会自动生成，使用STM的**硬件抽象层**（**HAL**）驱动程序。相关外设中断也会被配置和为用户提供占位符。这使得嵌入式工程师能够尽可能快地完成验证。
- en: After all of the hardware is proven, it will be time to add in the additional
    layers of firmware (middleware) that will live between the low-level drivers and
    the application firmware.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有硬件都经过验证之后，将是时候添加位于底层驱动程序和应用固件之间的额外固件层（中间件）了。
- en: Middleware setup
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件设置
- en: STM has partnered with many different middleware providers over the years to
    make bringing in additional functionality more straightforward for their customers.
    For example, FreeRTOS primitives can be selected with a few drop-down menus in
    CubeMX. A FAT file system can be set up, as well as a TCP/IP stack, libraries
    for JPEG images, and Mbed TLS. Make no mistake, the tool won't perform advanced
    configuration like a well-versed programmer, but as a bare minimum, it provides
    a solid start for evaluating unfamiliar libraries. Some engineers may find the
    initial configurations to fit their requirements directly, which means more time
    to focus on other portions of their solution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: STM多年来与许多不同的中间件提供商合作，使客户引入额外功能的过程更加直接。例如，在CubeMX中可以通过几个下拉菜单选择FreeRTOS原语。可以设置FAT文件系统，以及TCP/IP堆栈、JPEG图像库和Mbed
    TLS。不要误解，这个工具不会像熟练的程序员那样执行高级配置，但作为最低限度，它为评估不熟悉的库提供了一个坚实的起点。一些工程师可能会发现初始配置直接符合他们的需求，这意味着有更多时间专注于解决方案的其他部分。
- en: So, now that we've got a device selected, hardware verified, and some middleware
    stacks in place, it must be time to move on to coding the final application! Well...
    not quite. Using all of this code as supplied comes with some gotchas—let's take
    a look.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经选定了设备，验证了硬件，并设置了某些中间件堆栈，那么现在应该是时候开始编写最终应用程序的代码了！嗯……还不完全是。使用提供的所有这些代码会带来一些问题——让我们来看看。
- en: Code generation trade-offs
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码生成权衡
- en: While all of these features sound incredible in theory, developers have had
    mixed feelings regarding CubeMX and its use in real-world applications. Most of
    these concerns and trade-offs involve how the tool fits into a workflow; other
    times, the challenges stem from usability issues.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些功能在理论上听起来都很令人难以置信，但开发人员对CubeMX及其在现实世界中的应用有着混合的感觉。这些担忧和权衡大多涉及工具如何融入工作流程；有时，挑战源于可用性问题。
- en: From a usability standpoint, CubeMX *generally* works well; other times, it
    generates invalid code that simply won't work as intended. This seems to have
    been more of an issue when it was first released. Occasionally, versions would
    ship that would create projects that didn't even compile. However, as a minimum,
    it has always provided an excellent reference point for the configuration of the
    advanced peripherals available on the newer STM32 devices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用性的角度来看，CubeMX**通常**工作得很好；有时，它会生成无效的代码，根本无法按预期工作。这似乎是在它最初发布时更多的问题。偶尔，会发货的版本会创建无法编译的项目。然而，作为最低限度，它始终为配置较新STM32设备上可用的高级外设提供了一个出色的参考点。
- en: The challenges engineers face when integrating CubeMX to their workflow are
    typical of any utility that generates code that tightly couples with user code.
    Initially, the tool can be used to create a large code base that can be quickly
    stood up and provide a large portion of the required functionality. However, as
    the project progresses, tweaks will be almost inevitable; it can become cumbersome
    keeping the custom user code separate from the auto-generated CubeMX code. You
    may find yourself in a copy-paste loop, continually copying pieces of working
    code from one peripheral to another. This is a practice that proliferates in our
    industry. Embedded firmware engineers desperately need to break out of the copy-paste
    infinite loop. [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml), *Tips
    for Creating Well-Abstracted Architecture*, covers what tradeoffs are being made
    when adopting these types of workflows. It also has some suggestions on how to
    set up your code base for long-term growth, rather than rot.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师在将CubeMX集成到工作流程中时面临的挑战，是任何生成与用户代码紧密耦合的代码的实用工具的典型问题。最初，该工具可以用来创建一个庞大的代码库，可以快速搭建并提供所需功能的大部分。然而，随着项目的进展，调整几乎是不可避免的；将自定义用户代码与自动生成的CubeMX代码分开可能会变得很麻烦。您可能会发现自己陷入复制粘贴的循环，不断地从一边复制到另一边的有效代码片段。这是我们行业中的一个普遍做法。嵌入式固件工程师迫切需要摆脱复制粘贴的无穷循环。[第12章](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)，*创建良好抽象架构的技巧*，讨论了在采用这些类型的工作流程时正在做出哪些权衡。它还提供了一些关于如何设置代码库以实现长期增长的建议，而不是腐烂。
- en: With all of that being said, portions of code used in our examples will be implemented
    using STMCubeMX-generated code as a starting point. STM32 HAL is widely used in
    the industry, so anyone that has programmed STM32 before is likely to be familiar
    with it. Keep in mind that the example code in this book is meant to be easy to
    grasp. It is designed to highlight how to implement RTOS concepts, rather than
    serve as an extensible foundation for future additions. The primary intent of
    using code that is close to what STM32 CubeMX generates is to make it easier for
    you to start experimenting on your own.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上面所说的，我们示例中使用的代码部分将使用STMCubeMX生成的代码作为起点进行实现。STM32 HAL在行业中广泛使用，因此之前编写过STM32的人很可能熟悉它。请记住，本书中的示例代码旨在易于理解。它旨在突出如何实现RTOS概念，而不是作为未来扩展的基础。使用接近STM32
    CubeMX生成的代码的主要目的是让您更容易开始自己的实验。
- en: Setting up our IDE
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的IDE
- en: STM32CubeIDE needs to be installed and the source repository will need to be
    imported in order to compile and run the example code in the following chapters.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和运行以下章节中的示例代码，需要安装STM32CubeIDE并将源代码库导入。STM32CubeIDE需要安装，源代码库也需要导入。
- en: Installing STM32CubeIDE
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装STM32CubeIDE
- en: 'To install STM32CubeIDE, follow these two simple steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装STM32CubeIDE，请遵循以下两个简单步骤：
- en: Download STM32CubeIDE from [https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html).
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.st.com/en/development-tools/stm32cubeide.html](https://www.st.com/en/development-tools/stm32cubeide.html)下载STM32CubeIDE。
- en: Install it using the default options.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认选项进行安装。
- en: Now that STM32CubeIDE is installed, we will need to import the source tree.
    Let's see how to do this.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在STM32CubeIDE已经安装，我们需要导入源树。让我们看看如何做。
- en: Importing the source tree into STM32CubeIDE
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将源树导入STM32CubeIDE
- en: 'After installing STM32CubeIDE, you''ll need to import the source tree into
    the Eclipse workspace. A workspace is the Eclipse term for a collection of related
    projects:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装STM32CubeIDE后，您需要将源树导入到Eclipse工作区。工作区是Eclipse术语，用于表示相关项目的集合：
- en: Since STM32CubeIDE is based on the Eclipse IDE, you'll find the following instructions
    familiar if you've used Eclipse in the past.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于STM32CubeIDE基于Eclipse IDE，如果您以前使用过Eclipse，您会发现以下说明很熟悉。
- en: 'Download or clone the GitHub repository from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers):'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers)下载或克隆GitHub仓库：
- en: It is best practice to keep the path to the repo short with no spaces; that
    is, `c:\projects`.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好的做法是将仓库的路径保持得尽可能短，不要有空格；即，`c:\projects`。
- en: The base git path used in the examples is `c:\projects\packBookRTOS`.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例中使用的基git路径是`c:\projects\packBookRTOS`。
- en: Open STM32CubeIDE.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STM32CubeIDE。
- en: 'Import the entire repo:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入整个仓库：
- en: 'Go to Menu: File | Import.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到菜单：文件 | 导入。
- en: Select General | Existing Projects Into Workspace | Next.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“通用”|“将现有项目导入工作区”|“下一步”。
- en: 'Browse for and select the folder containing the repo, (`c:\projects\packBookRTOS `),
    which should look similar to the following after selection:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览并选择包含仓库的文件夹（`c:\projects\packBookRTOS`），选择后应类似于以下内容：
- en: '![](img/4ed3ecc0-3ff3-4f3b-994a-e5229d63fae6.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ed3ecc0-3ff3-4f3b-994a-e5229d63fae6.png)'
- en: Click Finish. The Next button is always gray.
  id: totrans-249
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击完成。下一步按钮始终是灰色。
- en: 'At this point, the Project Explorer panel will show all of the imported chapters
    (the following screenshot only shows code for [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml), *Selecting
    an IDE,* and [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml), *Debugging
    Tools for Real-Time Systems, *since they are the only examples currently written):'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，项目资源管理器面板将显示所有导入的章节（以下截图仅显示[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*和[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*的代码，因为它们是目前唯一编写的示例）：
- en: '![](img/d9bf3eb6-eab6-45f2-aca2-1ca290115d1c.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9bf3eb6-eab6-45f2-aca2-1ca290115d1c.png)'
- en: 'To ensure everything is installed correctly, right-click on `Chapter5_6` and
    select Build. The output in the Console window should look similar to the following:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切安装正确，右键点击`Chapter5_6`并选择构建。控制台窗口中的输出应类似于以下内容：
- en: '![](img/13b8f7b8-ccb3-4ca9-b871-d7789e37775d.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13b8f7b8-ccb3-4ca9-b871-d7789e37775d.png)'
- en: Congratulations! You should now be able to build the FreeRTOS example projects
    included with this book!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您应该能够构建本书中包含的FreeRTOS示例项目了！
- en: You might have noticed that the Eclipse project doesn't include folders in exactly
    the same way that they are organized on the disk (that is, Drivers and Middleware
    aren't subfolders of Chapter5_6 on the filesystem). This is done deliberately
    to allow reuse of common code across projects/chapters. This concept is covered
    in more depth in [Chapter 12](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml), Tips
    on Creating Well-Abstracted Architecture.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，Eclipse项目并不完全以与磁盘上组织方式相同的方式包含文件夹（即，驱动程序和中间件不是文件系统上Chapter5_6的子文件夹）。这是故意为之，以便在项目/章节之间重用通用代码。这一概念在[第12章](8e78a49a-1bcd-4cfe-a88f-fb86a821c9c7.xhtml)，《创建良好抽象架构的建议》中有更深入的介绍。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the concept of an IDE and why you might choose
    to use one. A list of considerations was presented, along with categories of IDEs
    and suggestions for when it is best to use them. All of this material was put
    to use as we selected the IDE used in this book. Finally, we took a look at STMCubeMX
    and discussed how it can be used in different stages of a project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了IDE的概念以及为什么您可能选择使用它。我们列出了一些考虑因素，以及IDE的分类和最佳使用建议。所有这些材料都用于选择本书中使用的IDE。最后，我们审视了STMCubeMX，并讨论了它在项目不同阶段的使用。
- en: Having a good understanding of the trade-offs to be made when designing a workflow
    (which includes choosing software tools) for your embedded system's code development
    will help you to make informed decisions, which can make a huge impact on productivity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计嵌入式系统代码开发的工作流程（包括选择软件工具）时，对可能做出的权衡有良好的理解，将帮助您做出明智的决定，这可以极大地影响生产力。
- en: In the next chapter, we'll continue looking at tools for increasing productivity
    on FreeRTOS-based embedded firmware projects. The next set of tools allows you
    to actually *see* how your code is behaving in an extremely convenient way.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨用于提高基于FreeRTOS的嵌入式固件项目生产力的工具。下一组工具允许您以极其方便的方式实际*看到*您的代码是如何运行的。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'There is one IDE that is best for each MCU/language combination:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个MCU/语言组合，都有一个最佳的IDE：
- en: 'True'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: 'Paid IDEs are a must for professional-grade work:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专业级工作必须使用付费IDE：
- en: 'True'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: 'Vendor-supplied IDEs are always the best IDEs to use for that vendor''s hardware:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 供应商提供的IDE总是用于该供应商硬件的最佳IDE：
- en: 'True'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: 'Software-generated code is always better than human-crafted code:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软件生成的代码总是优于人工编写的代码：
- en: 'True'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: 'The IDE selected in this book was chosen because it has the best long-term
    availability and widest device compatibility:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书所选的IDE是因为它具有最佳的长久可用性和最广泛的设备兼容性：
- en: 'True'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的
- en: 'False'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假的
- en: Name three stages of development where STMCubeMX is helpful.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个STMCubeMX在开发过程中有帮助的发展阶段。
- en: Further reading
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The STM32CubeIDE user guide can be found at[ https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf](https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE用户指南可在[ https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf](https://www.st.com/resource/en/user_manual/dm00598966-stm32cubeide-quick-start-guide-stmicroelectronics.pdf)找到。
