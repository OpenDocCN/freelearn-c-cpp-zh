- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: There Are No Libraries For Modern Programming in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C++ 中没有现代编程的库
- en: '*Or maybe there are too many and they are not* *easily available?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者也许有太多，而且它们并不* *容易获得？*'
- en: C++ is the oldest language used in modern software development. Despite many
    attempts to replace it, it stayed up in both preference and usefulness. However,
    this legacy comes with its own challenges. The development style has evolved over
    time to include constructs that are easier to understand by developers, that solve
    problems with less code, or that sometimes just look nicer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是现代软件开发中使用最古老的语言。尽管有多次尝试取代它，但它仍然在偏好和实用性方面保持领先。然而，这种遗产也带来了自己的挑战。开发风格随着时间的推移而演变，包括更容易被开发者理解的结构，用更少的代码解决问题，或者有时看起来更美观。
- en: A big part of the ecosystem of any technology is the list of libraries available
    to it, including and complementing the standard library. Since C++ has been around
    for a long time, it has libraries. However, how do they compare with the experience
    of developers using other technologies? Do they match the needs and expectations
    of a modern developer, who is perhaps looking at the alternative solutions available
    in the marketplace of ideas?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 任何技术生态系统中的一部分是可用的库列表，包括并补充标准库。由于 C++ 已经存在很长时间，它有库。然而，它们与其他技术使用者的体验相比如何？它们是否满足现代开发者的需求和期望，这些开发者可能正在考虑市场上可用的替代解决方案？
- en: These are a few of the questions we will examine next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们接下来将要探讨的一些问题。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: A modern developer experience
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代开发者体验
- en: Common needs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见需求
- en: Compatibility
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性
- en: Supply chain security
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应链安全
- en: How can we tell?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何判断？
- en: When pondering a question such as the title of this chapter, we are faced with
    the big challenge of selection. The choice of libraries for any project is completely
    contextual, and it fully depends on what the project is trying to solve. Of course,
    there are some features that are needed no matter what the project does, such
    as logging or unit testing, but what should we pick beyond these?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当思考像本章标题这样的问题时，我们面临着选择的大挑战。任何项目的库选择完全取决于上下文，完全取决于项目试图解决的问题。当然，有些功能无论项目做什么都是需要的，比如日志记录或单元测试，但除了这些之外我们应该选择什么？
- en: After all, it seems deeply unfair to compare web development in C++ with web
    development in Java, as it is to compare systems programming in C++ with systems
    programming in Java. Neither is C++ used for web development extensively, nor
    is Java for systems programming. In fact, C++ has had its own niche for a long
    time, and while it has been slowly eroded by Java, C#, Rust, and Python, it still
    holds the fort for use cases such as game development, firmware, high-frequency
    trading, engineering applications, automotive, systems programming, and probably
    others. The other languages have little traction in these domains, for very good
    reasons related to C++’s flexibility, performance, and control.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 C++ 中的 Web 开发与 Java 中的 Web 开发进行比较似乎非常不公平，就像将 C++ 中的系统编程与 Java 中的系统编程进行比较一样。C++
    并没有广泛用于 Web 开发，Java 也没有用于系统编程。事实上，C++ 很早就有了自己的细分市场，尽管它已经被 Java、C#、Rust 和 Python
    慢慢侵蚀，但它仍然在游戏开发、固件、高频交易、工程应用、汽车、系统编程以及可能的其他用例中占据着阵地。其他语言在这些领域几乎没有影响力，这有很多很好的原因，与
    C++ 的灵活性、性能和控制力有关。
- en: Another problem is the sheer number of libraries that exist for the aforementioned
    languages, particularly C++. An advantage of the venerable C++ is that programmers
    have had time to develop behemoth libraries such as Boost, which has no equal
    in the worlds of Java or C# (excluding the standard libraries), and absolutely
    no contender in the world of Python. We could argue that JavaScript has something
    similar to React and its surrounding ecosystem. However, in terms of the volume
    of available libraries, C++ looks dominant.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是为上述语言（尤其是 C++）存在的库的数量。值得尊敬的 C++ 的一个优点是程序员有足够的时间开发像 Boost 这样的巨无霸库，它在 Java
    或 C# 的世界中（不包括标准库）没有对手，在 Python 的世界中绝对没有竞争对手。我们可以争论说，JavaScript 有类似 React 及其周围生态系统的类似东西。然而，在可用的库数量方面，C++
    看起来占主导地位。
- en: 'These observations leave us with one characteristic that we need to account
    for: how modern is the set of libraries? What would we want from a modern programming
    language and its ecosystem? Where does C++ stand from this perspective? Let’s
    examine these questions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观察让我们意识到一个需要考虑的特征：这些库集合有多现代？我们希望从一门现代编程语言及其生态系统中得到什么？从这一角度来看，C++处于什么位置？让我们来探讨这些问题。
- en: A modern developer’s experience
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代开发者的体验
- en: Let’s step, for a moment, outside the C++ world and turn into a fly on the wall
    that looks at the experience of a developer using another technology. We will
    be with them as they are starting a new project, and later when they add new people
    to the team. The likely first step is that they will launch an IDE and create
    a new project or a project structure. The IDE is likely to be from Microsoft,
    such as Visual Studio .NET or Visual Studio Code, or from JetBrains, such as IntelliJ
    IDEA for Java, PyCharm for Python, or Rider for C#/.NET. A small set of strange
    programmers, such as myself, will use the command line and neovim. Even stranger
    programmers will use Emacs. I kid, of course; we all know that real programmers
    use changes in atmospheric electricity to manipulate the bits directly, as shown
    by a famous xkcd comic called *Real Programmers* ( [https://xkcd.com/378/](https://xkcd.com/378/)
    ). However, let’s go back to our story.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时跳出C++的世界，变成一个观察其他技术使用者的“旁观者”。我们将陪伴他们从开始一个新项目，到后来向团队添加新成员。可能的第一步是他们将启动一个IDE，创建一个新项目或项目结构。IDE可能是来自微软的，如Visual
    Studio .NET或Visual Studio Code，或者是来自JetBrains的，如Java的IntelliJ IDEA，Python的PyCharm，或C#/.NET的Rider。一小部分像我这样的奇怪程序员会使用命令行和neovim。更奇怪的程序员甚至会使用Emacs。我当然是在开玩笑；我们都知道真正的程序员会利用大气电的变化来直接操纵位，正如著名的xkcd漫画《真正的程序员》（[https://xkcd.com/378/](https://xkcd.com/378/)）所展示的那样。然而，让我们回到我们的故事。
- en: Upon creating a new project, the IDE will suggest a few integrations and libraries
    to install. Once created, the project is ready to run, although it won’t do a
    lot of useful things. During the creation, a source control repository will be
    selected, likely an existing one based on git. The project can then be committed
    locally and pushed to the shared repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目时，IDE会建议安装一些集成和库。一旦创建，项目就可以运行，尽管它不会做很多有用的事情。在创建过程中，将选择一个源代码控制仓库，很可能是基于git的现有仓库。然后可以在本地提交项目并将其推送到共享仓库。
- en: 'After these steps, any member of the team will have a few things to do: fire
    up the IDE, clone the repository locally, and let the IDE do its thing to get
    the necessary dependencies, as specified in the project configuration.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些步骤之后，团队成员将有一些事情要做：启动IDE，在本地克隆仓库，并让IDE按照项目配置获取必要的依赖项。
- en: It’s likely that, at this point, the project will already include a logging
    and unit testing library. Let’s pause for a moment to examine the libraries used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，项目可能已经包含了日志记录和单元测试库。让我们暂停一下，来检查所使用的库。
- en: Python has logging in its standard library, while Java has the open source Log4J
    and .NET uses either the Microsoft-built Microsoft.Extensions.Logging or the open
    source Log4Net. For unit testing, Python offers a standard implementation for
    both unit testing and mocking, but programmers tend to prefer open-source extensions
    such as pytest ( [https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)
    ). Java requires a unit testing library, usually JUnit or TestNG, and a mocking
    library, usually Mockito or JMock. Finally, .NET provides a standard framework
    for testing but knowledgeable tech leads will most likely select NUnit or xUnit
    instead, along with Moq.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python在其标准库中提供了日志记录功能，而Java有开源的Log4J，.NET则使用微软构建的Microsoft.Extensions.Logging或开源的Log4Net。对于单元测试，Python提供了单元测试和模拟的标准实现，但程序员往往更喜欢像pytest这样的开源扩展（[https://docs.pytest.org/en/stable/](https://docs.pytest.org/en/stable/)）。Java需要单元测试库，通常是JUnit或TestNG，以及模拟库，通常是Mockito或JMock。最后，.NET提供了一个标准的测试框架，但知识渊博的技术负责人更有可能选择NUnit或xUnit，以及Moq。
- en: Where does C++ stand here? Well, there’s no shortage of logging libraries in
    C++, which shouldn’t be a surprise since logging systems have matured at the same
    time as C++. We can say that logging libraries are quasi-standardized, having
    very similar behavior and features with small variations in the API. It’s almost
    too difficult to choose a logging library for C++ unless you are using a technology
    that already comes with logging. I imagine that many projects use Boost and the
    logging that comes with it. A quick glance at GitHub shows that the **spdlog**
    library ( [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)
    ) has 24k stars, although it only supports C++ 11.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: C++在这里处于什么位置呢？嗯，C++中日志库的选择并不少，这并不令人惊讶，因为日志系统与C++同时成熟。我们可以认为日志库几乎是标准化的，它们在API上有着非常相似的行为和功能，只有细微的差别。除非你正在使用自带日志功能的技术，否则选择一个C++的日志库几乎是一件非常困难的事情。我想，许多项目都使用Boost及其内置的日志功能。快速浏览GitHub可以发现，**spdlog**库（[https://github.com/gabime/spdlog](https://github.com/gabime/spdlog)）有24k个星标，尽管它只支持C++
    11。
- en: What about unit testing? This is an interesting topic. Unit testing libraries
    exist for C++ in many forms. There’s GTest and GMock, the two libraries started
    by Google, with the usual feature set. Similarly, CppTest follows the standard
    xUnit structure for unit tests. Then there’s **doctest** ( [https://github.com/doctest/doctest](https://github.com/doctest/doctest)
    ), a single header library with no dependencies, which is why I prefer it for
    examples and the code accompanying this book. Finally, it’s worth mentioning **Cpputest**
    ( [http://cpputest.github.io](http://cpputest.github.io) ) because it allows embedded
    development, due to its small footprint and its features for identifying memory
    management problems. For mocking, **FakeIt** ( [https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt)
    ) is another single header framework that is very easy to integrate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试怎么样呢？这是一个有趣的话题。C++中存在多种形式的单元测试库。有Google启动的GTest和GMock，这两个库具有通常的功能集。同样，CppTest遵循标准的xUnit结构进行单元测试。然后是**doctest**（[https://github.com/doctest/doctest](https://github.com/doctest/doctest)），这是一个无依赖的单头库，这也是为什么我更喜欢用它来展示示例和本书伴随的代码。最后，值得一提的是**Cpputest**（[http://cpputest.github.io](http://cpputest.github.io)），因为它允许嵌入式开发，这得益于它的小型足迹和识别内存管理问题的功能。对于模拟，**FakeIt**（[https://github.com/eranpeer/FakeIt](https://github.com/eranpeer/FakeIt)）是另一个非常容易集成的单头框架。
- en: All these libraries would likely be set up through a package manager that stores
    the list of dependencies in a text file that’s either plain text, a markup format,
    or a script. This file gets pushed to the central repository and can be used to
    recreate the dependencies, including the dependencies required by the installed
    libraries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库都可能会通过包管理器来设置，该管理器将依赖项列表存储在一个文本文件中，该文件可以是纯文本、标记格式或脚本。这个文件会被推送到中央仓库，并可用于重新创建依赖项，包括安装的库所需的依赖项。
- en: 'If, during the development, the team needs an additional library, they can
    simply add it to the dependencies. This process is a bit more restricted for enterprise
    environments due to security concerns: perhaps a pre-approved list of packages
    is available and provided from an internal source, perhaps each package requires
    approval, or perhaps only specific people can add a dependency.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，如果团队需要额外的库，他们可以简单地将其添加到依赖项中。由于安全考虑，这个过程在企业环境中可能更为受限：可能有一个预先批准的包列表，可能每个包都需要获得批准，或者可能只有特定的人可以添加依赖项。
- en: Either way, when a new developer comes in, they will clone the central repository
    and run the installation commands, usually by just loading the project in the
    IDE and letting it do its thing, and everything should work fine. That’s the end
    of our fly story.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，当新开发者加入时，他们都会克隆中央仓库并运行安装命令，通常是通过在IDE中加载项目并让它自行处理，一切应该都会顺利。这就是我们飞行的故事的结尾。
- en: 'Let’s dive into more details about what happens behind the scenes if you use
    a package manager. Since I often use the command line in combination with neovim
    to program in Ubuntu Linux, I know a little bit more about the process in each
    of these technologies. For Python, a virtual environment is recommended so that
    the OS is not polluted with all the libraries required. A tool called **pipenv**
    combines the **pip** package manager and the **venv** virtual environment, both
    provided by the standard library, to allow for easy setup. The command line steps
    would be as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如果您使用包管理器时幕后发生的事情。由于我经常在 Ubuntu Linux 上结合使用命令行和 neovim 进行编程，我对这些技术中的每个技术的处理过程都有一些了解。对于
    Python，建议使用虚拟环境，这样操作系统就不会被所有所需的库所污染。一个名为 **pipenv** 的工具结合了标准库提供的 **pip** 包管理器和
    **venv** 虚拟环境，以便于轻松设置。命令行步骤如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a new environment, you can simply run the following to install all the dependencies:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在新环境中，你可以简单地运行以下命令来安装所有依赖项：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Java and .NET have similar workflows, minus the virtual environment. They both
    use open source package managers; for Java, Maven or Gradle are used, and for
    .NET, it’s NuGet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java 和 .NET 有类似的流程，只是没有虚拟环境。它们都使用开源的包管理器；对于 Java，使用 Maven 或 Gradle，对于 .NET，则是
    NuGet。
- en: 'For all these three technologies, a central place for all the libraries exists:
    Pypi ( [https://pypi.org/](https://pypi.org/) ) for Python, Maven Central ( [https://mvnrepository.com/repos/central](https://www.mvnrepository.com/repos/central)
    ) for Maven and the NuGet site ( [https://www.nuget.org/](https://www.nuget.org/)
    ) for NuGet. As mentioned earlier, it’s likely that large companies will pay more
    attention to the libraries used, and require more thorough security checks before
    using third-party code in their systems. These companies tend to provide their
    own repositories, for example, using Artifactory in Java ( [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)
    ).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这三项技术，都存在一个所有库的中心位置：Python 的 Pypi（[https://pypi.org/](https://pypi.org/)），Maven
    的 Maven Central（[https://mvnrepository.com/repos/central](https://www.mvnrepository.com/repos/central)），以及
    NuGet 网站（[https://www.nuget.org/](https://www.nuget.org/)）。如前所述，大型公司可能会更加关注所使用的库，并在将第三方代码用于其系统之前进行更彻底的安全检查。这些公司往往提供自己的仓库，例如，在
    Java 中使用 Artifactory（[https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)）。
- en: It is therefore very easy to search for libraries, update them, and install
    them in a new environment, with de facto standard tools available to any developer
    using that technology.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用事实上的标准工具，任何使用该技术的开发者都可以轻松地搜索库、更新它们并在新环境中安装它们。
- en: C++ has gone a long way since I was a junior C++ programmer in the 2000s. Back
    then, adding a new library required either downloading the binaries for the required
    targets or, more likely, compiling it yourself, which posed its own set of challenges.
    Nowadays, C++ is closing the gap through Conan and vcpkg, and it’s likely that
    many programmers have a similar experience in C++ to the one I’ve described above
    for Java, Python, and .NET. Programmers in large companies are most likely to
    recognize it, since the organization provides a Conan or vspkg repository with
    approved libraries that can be found and installed easily. Adding a new library
    to the whitelist can be a bit of a pain and can take a long time, but that’s understandable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我在 2000 年代初成为 C++ 程序员以来，C++ 已经走了很长的路。当时，添加一个新的库需要下载所需目标的二进制文件，或者更可能的是，自己编译它，这本身也带来了一系列挑战。如今，C++
    通过 Conan 和 vcpkg 正在缩小差距，许多程序员在 C++ 上的体验可能与我在 Java、Python 和 .NET 上描述的类似。大型公司的程序员最有可能认识到这一点，因为组织提供了一个包含经过批准的库的
    Conan 或 vspkg 仓库，可以轻松找到并安装。将新的库添加到白名单可能有些麻烦，可能需要很长时间，但这是可以理解的。
- en: 'It’s not as easy without that piece of infrastructure. The libraries are not
    available in a single location, and the tools don’t seem to work as well. At least
    this was my experience: Conan gave me a bunch of errors when I tried to use it
    on a simple project and I had no idea how to fix them. While I dislike Maven because
    it inexplicably downloads a lot of packages even for the simplest of setups, it
    works consistently and reliably, which is what we need from package managers.
    So, I’m afraid I will have to say this: while there are attempts to bring C++
    package management on par with other technologies, it doesn’t feel mature yet.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个基础设施，事情并不容易。库不是在单一位置提供的，工具似乎也不太好用。至少这是我的经验：当我尝试在一个简单的项目中使用Conan时，它给出了一堆错误，而我不知道如何修复它们。虽然我不喜欢Maven，因为它在设置最简单的情况下也会无端下载很多包，但它始终如一且可靠，这正是我们从包管理器中需要的。所以，我恐怕不得不这么说：尽管有尝试将C++包管理与其他技术相提并论，但它仍然感觉还不够成熟。
- en: With this being said, I’m sure many developers working in large companies won’t
    feel any of these issues. So, we’ll assume that the package manager works fine.
    What will we do next? Depending on the project and the technology, we will need
    more libraries to help us. Let’s look next at a few categories.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我相信许多在大公司工作的开发者不会感受到这些问题。因此，我们假设包管理器运行良好。接下来我们该做什么呢？根据项目和技术的不同，我们可能需要更多的库来帮助我们。接下来，让我们看看几个类别。
- en: Common needs
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见需求
- en: 'Here are some needs that many developers have, in no particular order:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些许多开发者都有，但顺序并不重要：
- en: Database connection, reading, and writing
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接、读取和写入
- en: CSV file processing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV文件处理
- en: Compression, for example, **gzip**
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩，例如，**gzip**
- en: Date/time enhancements
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期/时间增强
- en: 'Various computations, for example: matrices, imaginary numbers, math equation
    solving, and so on'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种计算，例如：矩阵、复数、数学方程求解等
- en: UI, for desktop and mobile applications
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI，用于桌面和移动应用
- en: HTTP client
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端
- en: HTTP server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: Asynchronous programming
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程
- en: Image processing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像处理
- en: PDF processing
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDF处理
- en: Background jobs
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台任务
- en: Cryptography
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学
- en: Networking
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络通信
- en: Serialization
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化
- en: Email sending
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: JSON processing
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON处理
- en: 'Configuration file read and write: **ini** , **yaml** , and so on'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件读取和写入：**ini**、**yaml**等
- en: 'It’s safe to say that there are C++ libraries for all of these. Let’s pick
    just a few random ones:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定的是，对于这些需求，都有相应的C++库。让我们随机挑选几个：
- en: '**zlib** for **zip** and **gzip** compression'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zlib** 用于 **zip** 和 **gzip** 压缩'
- en: Rapidcsv ( [https://github.com/d99kris/rapidcsv](https://github.com/d99kris/rapidcsv)
    ) for CSV processing
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rapidcsv ([https://github.com/d99kris/rapidcsv](https://github.com/d99kris/rapidcsv))
    用于CSV处理
- en: For database access, an ORM such as TinyORM ( [https://www.tinyorm.org/](https://www.tinyorm.org/)
    ) or SQLPP1 ( [https://github.com/rbock/sqlpp11](https://github.com/rbock/sqlpp11)
    ) for type-safe DSL queries and results
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据库访问，可以使用ORM如TinyORM ([https://www.tinyorm.org/](https://www.tinyorm.org/))
    或SQLPP1 ([https://github.com/rbock/sqlpp11](https://github.com/rbock/sqlpp11))，用于类型安全的DSL查询和结果
- en: Poco libraries ( [https://pocoproject.org/](https://pocoproject.org/) ) contain
    a lot of utilities for networking, sending emails, database access, JSON, OpenSSL,
    and so on
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Poco库 ([https://pocoproject.org/](https://pocoproject.org/)) 包含大量用于网络、发送电子邮件、数据库访问、JSON、OpenSSL等的实用工具
- en: UI libraries include Qt, GTK, wxWidgets, or Dear ImGui
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI库包括Qt、GTK、wxWidgets或Dear ImGui
- en: HTTP clients are implemented in Boost, Curl++, or cpp-netlib
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端由Boost、Curl++或cpp-netlib实现
- en: To implement a web application, Crow ( [https://crowcpp.org/master/](https://crowcpp.org/master/)
    ) is inspired by Python’s Flask, while Oat++ ( [https://oatpp.io/](https://oatpp.io/)
    ) and Drogon ( [https://drogon.org/](https://drogon.org/) ) offer fast solutions
    for web APIs and microservices
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实现Web应用，Crow ([https://crowcpp.org/master/](https://crowcpp.org/master/))
    受Python的Flask启发，而Oat++ ([https://oatpp.io/](https://oatpp.io/)) 和Drogon ([https://drogon.org/](https://drogon.org/))
    为Web API和微服务提供了快速解决方案
- en: 'We could go on, but I think we’ve made our point: *C++ has libraries* . It
    has *a lot of libraries* . Some of them have inspired the implementations of other
    technologies, while others took inspiration from the best solutions used by the
    alternatives. The advantages of the C++ implementations are obvious in terms of
    speed and low memory footprint. Some of these libraries pack many features into
    a few hundred kBs. It’s also impressive how many header-only implementations exist,
    allowing for portability and simplicity.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续说，但我认为我们已经表达了我们的观点：*C++ 有库*。它有 *很多库*。其中一些库启发了其他技术的实现，而另一些则从替代方案的最佳解决方案中汲取了灵感。在速度和低内存占用方面，C++
    实现的优势是显而易见的。其中一些库将许多功能打包到几百 KB 中。而且，存在许多仅包含头文件的实现，这使得它们具有可移植性和简单性。
- en: 'C++ also has frameworks. We already mentioned a few and we can add others:
    GTK, QT, Boost, POCO, WxWidgets, and Unreal Engine, for example. Lists of libraries
    and frameworks are maintained on the internet, the best one I’ve found being **awesome-cpp**
    ( [https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp)
    ).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 也有框架。我们之前已经提到了一些，我们还可以添加其他一些：GTK、QT、Boost、POCO、WxWidgets 和 Unreal Engine，例如。库和框架的列表在网上有维护，我找到的最好的是
    **awesome-cpp**（[https://github.com/fffaraz/awesome-cpp](https://github.com/fffaraz/awesome-cpp)）。
- en: 'Even niche programming styles and practices have their libraries:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是细分编程风格和实践也有它们的库：
- en: Immutable collections? Use Immer ( [https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)
    ).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变集合？使用 Immer（[https://github.com/arximboldi/immer](https://github.com/arximboldi/immer)）。
- en: Reactive Programming? Use RxCpp ( [https://github.com/ReactiveX/RxCpp](https://github.com/ReactiveX/RxCpp)
    ).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程？使用 RxCpp（[https://github.com/ReactiveX/RxCpp](https://github.com/ReactiveX/RxCpp)）。
- en: Microservices? Sure, CppMicroServices ( [https://github.com/CppMicroServices/CppMicroServices](https://github.com/CppMicroServices/CppMicroServices)
    ) can help (no, microservices are not niche, but they’re rarely implemented in
    C++).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务？当然，CppMicroServices（[https://github.com/CppMicroServices/CppMicroServices](https://github.com/CppMicroServices/CppMicroServices)）可以帮忙（不，微服务不是细分领域，但它们很少用
    C++ 实现）。
- en: Web Assembly? Yes, there’s Emscripten ( [https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten)
    ) is a good choice.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络汇编？是的，有 Emscripten（[https://github.com/emscripten-core/emscripten](https://github.com/emscripten-core/emscripten)），这是一个不错的选择。
- en: Serverless? There’s **aws-lambda-cpp** ( [https://github.com/awslabs/aws-lambda-cpp](https://github.com/awslabs/aws-lambda-cpp)
    ).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器？有 **aws-lambda-cpp**（[https://github.com/awslabs/aws-lambda-cpp](https://github.com/awslabs/aws-lambda-cpp)）。
- en: I think it’s obvious by now that we’d be hard-pressed to find any domain in
    which C++ lacks a library or framework. However, can we use them?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在很明显，我们很难找到一个领域，C++ 在其中没有库或框架。然而，我们能使用它们吗？
- en: Compatibility
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容性
- en: Let’s assume that you find a very promising library and decide to add it to
    your project. Does it work? How *well* will it work?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你找到一个非常有前途的库，并决定将其添加到你的项目中。它是否工作？它会 *如何* 工作？
- en: 'Here’s where the fragmentation of C++ shows its ugly side. The chance of any
    of the following undesirable things to happen is non-zero:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 C++ 分裂展现其丑陋一面的地方。以下任何不希望发生的事情都有可能发生：
- en: The library uses a newer C++ version than your code and you can’t compile it
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库使用的 C++ 版本比你的代码新，并且你无法编译它
- en: The library uses an older C++ version than your code
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图书馆使用的 C++ 版本比你的代码旧
- en: You get a lot of warnings for different reasons
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会因各种原因收到很多警告
- en: The library compiles well with your version of C++, but its interface uses older
    constructs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库与你的 C++ 版本兼容，但其接口使用较旧的构造
- en: The library doesn’t work on all platforms your project targets
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库在你的项目目标的所有平台上都不工作
- en: The library is incompatible with your compiler
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库与你的编译器不兼容
- en: The library is incompatible with your compilation process
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库与你的编译过程不兼容
- en: The library is compatible with all platforms your project targets, but it has
    different behavior or performance issues or bugs on specific platforms
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该库与你的项目目标的所有平台兼容，但在特定平台上存在不同的行为或性能问题或错误
- en: 'I hope you never encounter any of the preceding problems. Also, it’s worth
    saying that you’d be much less likely to have them in the technologies we use
    as a comparison: Python, Java, and .NET have none of these issues. Well, almost
    none; it’s possible, for example, to create Python programs that use C++ modules
    and face the same issues. Or you could create a Java program that uses OS primitives
    and has different issues on different OSs. In general, though, there’s a continuous
    effort for consistency in these worlds.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您永远不要遇到上述任何问题。此外，值得一提的是，在我们使用的比较技术中，您不太可能遇到这些问题：Python、Java和.NET都没有这些问题。嗯，几乎都没有；例如，创建使用C++模块的Python程序可能会遇到相同的问题。或者，您可能创建了一个使用操作系统原语的Java程序，它在不同的操作系统上会有不同的问题。总的来说，在这些领域，人们一直在努力实现一致性。
- en: To be fair, mature C++ frameworks and libraries such as Boost or **zlib** made
    the same effort and provided consistent behavior. It’s just easier to create consistent
    libraries in languages that use virtual machines.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，成熟的C++框架和库，如Boost或**zlib**，也做出了同样的努力，并提供了一致的行为。只是在使用虚拟机的语言中创建一致的库要容易得多。
- en: 'Let’s say that your library works fine: no warnings, no weird issues, and it
    plays well with your code and toolkit. There’s one last question: can we trust
    it?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的库运行良好：没有警告，没有奇怪的问题，并且它与你的代码和工具集很好地协同工作。最后一个问题是：我们能信任它吗？
- en: Supply chain security
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应链安全
- en: It should be obvious to anyone paying attention that software has always had
    a security problem. This problem is getting worse since software usage continues
    to increase and cover more and more areas of our daily lives.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关注的人来说，软件一直存在安全问题应该是显而易见的。随着软件使用的持续增加，它覆盖了我们日常生活的更多领域，这个问题正在变得越来越严重。
- en: 'There are two parts to improving security: the cybersecurity experts, who can
    find vulnerabilities and build protection tools, and the software developers,
    who need to find security issues before release and manage the accompanying risks.
    We know there’s no perfectly secure software, but we also know that things can
    get much better.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 提高安全性的两个方面包括：网络安全专家，他们可以找到漏洞并构建保护工具，以及软件开发者，他们需要在发布前找到安全问题并管理相关的风险。我们知道没有绝对安全的软件，但我们也知道事情可以变得更好。
- en: 'A specific area of this increased protection is managing the potential vulnerabilities
    that come with the libraries we use. There are two situations: either vulnerabilities
    were introduced unknowingly, or they were injected on purpose by a malicious actor.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增加保护的具体领域是管理我们使用的库可能带来的潜在漏洞。有两种情况：要么漏洞是无意中引入的，要么是由恶意行为者故意注入的。
- en: 'In all fairness, this can happen to any technology, and many of the high-profile
    C++ libraries are reviewed for security by large companies that use them. Moreover,
    if you’re working in a large company, you have teams dealing with all these concerns.
    However, not all development is done in large companies, and not all libraries
    are treated the same, as we’ll see with the **xz backdoor case** . Let’s discuss
    the second case for a moment. A malicious actor can inject vulnerabilities in
    several ways:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 客观地说，任何技术都可能发生这种情况，许多知名的C++库都由使用它们的大型公司进行安全审查。此外，如果您在大型公司工作，您有团队处理所有这些关注点。然而，并非所有开发都在大型公司进行，并非所有库都受到同等对待，正如我们将通过**xz后门案例**所看到的那样。让我们暂时讨论第二种情况。恶意行为者可以通过多种方式注入漏洞：
- en: They can do this through a contribution to the code of an open source project.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以通过向开源项目的代码做出贡献来实现这一点。
- en: They can also fork an open source project and add vulnerabilities among useful
    features.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们还可以分叉开源项目，并在有用的功能中添加漏洞。
- en: They can also sometimes get away with becoming the maintainer of an open source
    project and then injecting vulnerabilities among useful features. See the story
    of the xz backdoor, which I commented on at length, at [https://mozaicworks.com/blog/xz-backdoor-and-other-news](https://mozaicworks.com/blog/xz-backdoor-and-other-news)
    .
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们有时甚至可以逃脱成为开源项目维护者的角色，然后在有用的功能中注入漏洞。请参阅我在[https://mozaicworks.com/blog/xz-backdoor-and-other-news](https://mozaicworks.com/blog/xz-backdoor-and-other-news)上详细评论的xz后门故事。
- en: They can also replace the binary with a vulnerable version, for example, by
    offering it on another website than the original or managing to hijack the publishing
    process.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们还可以用有漏洞的版本替换二进制文件，例如，通过在另一个网站而不是原始网站上提供它或成功劫持发布过程。
- en: They may also attempt hijacking the download, for example, through a DNS attack.
    Imagine a potential attacker managing to modify your local host’s file to point
    the URL of your repository to another IP address on the internet.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们也可能尝试劫持下载，例如，通过DNS攻击。想象一下一个潜在的攻击者成功修改了你的本地主机文件，将你的仓库URL指向互联网上的另一个IP地址。
- en: All of the items in the preceding list are serious problems. In large companies,
    the security departments and IT/Ops tend to worry about them, but in smaller companies,
    it’s likely that you’ll need to pay extra attention. The solution we know is to
    validate all binaries with their digital signature or hash. While the package
    managers for programming languages and Linux do this automatically, manually downloading
    a binary from GitHub requires manual validation of the signature, hopefully provided
    along with the library file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中的所有项目都是严重问题。在大公司中，安全部门和IT/Ops通常会担心这些问题，但在小公司中，你可能需要额外注意。我们知道的解决方案是验证所有二进制文件与其数字签名或哈希值。虽然编程语言和Linux的包管理器会自动执行此操作，但手动从GitHub下载二进制文件需要手动验证签名，希望签名与库文件一起提供。
- en: The first situation is even more complicated. How do you know whether a library
    has vulnerabilities? For open source code, the general belief is that many eyes
    look at the code and find all issues. However, that’s very dependent on the number
    of contributors and their expertise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况甚至更复杂。你怎么知道一个库是否有漏洞？对于开源代码，普遍的看法是，许多眼睛查看代码就能发现所有问题。然而，这非常依赖于贡献者的数量和他们的专业知识。
- en: The xz backdoor case mentioned is chilling, especially since the issue was found
    by a developer, Andres Freund, who got suspicious by the fact that **sshd** was
    using too much CPU during a micro-benchmark ( [https://mastodon.social/@AndresFreundTec/112180406142695845](https://mastodon.social/@AndresFreundTec/112180406142695845)
    ). This made the issue of overworked maintainers for open source libraries visible,
    only for it to return to obscurity soon after.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的xz后门案例令人毛骨悚然，特别是问题是由开发者Andres Freund发现的，他通过微基准测试期间**sshd**使用过多的CPU而产生了怀疑（[https://mastodon.social/@AndresFreundTec/112180406142695845](https://mastodon.social/@AndresFreundTec/112180406142695845)）。这使得开源库过度工作的维护者问题变得明显，但很快又回到了隐秘状态。
- en: Let’s assume that most open source libraries are not attacked by a malicious
    actor who gains maintainer status. It’s still possible for vulnerabilities to
    escape, and more so in C++ since it has its own challenges in terms of security.
    A small team will need to stay informed of the reported vulnerabilities for the
    libraries they use, or license security tools that automatically do it for them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设大多数开源库不会被获得维护者状态的恶意行为者攻击。漏洞仍然可能逃逸，尤其是在C++中，因为它在安全性方面有自己的挑战。一个小团队需要了解他们使用的库报告的漏洞，或者许可自动为他们执行此操作的许可证安全工具。
- en: Assuming that everything works fine, it’s still best to store the list of libraries
    used in an application, so that the ops people know to periodically check for
    vulnerabilities in all the libraries used. The recommended practice in this area
    is to create what’s called the **Software Bill of Materials** ( **SBOM** ) for
    your product. An SBOM contains the list of all the libraries and their dependencies.
    Specific tools are available to create the SBOM and to scan for vulnerabilities
    based on them; however, most of them work with docker containers. For example,
    consider Grype ( [https://github.com/anchore/grype](https://github.com/anchore/grype)
    and its companion tool Syft [https://github.com/anchore/syft](https://github.com/anchore/syft)
    ).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切正常，仍然最好将应用程序中使用的库列表存储起来，这样运维人员就知道定期检查所有库中的漏洞。在这个领域，推荐的实践是为你的产品创建所谓的**软件物料清单**（**SBOM**）。SBOM包含所有库及其依赖关系的列表。有特定的工具可以创建SBOM并基于它们扫描漏洞；然而，大多数工具都与docker容器一起工作。例如，考虑Grype（[https://github.com/anchore/grype](https://github.com/anchore/grype)）及其配套工具Syft
    [https://github.com/anchore/syft](https://github.com/anchore/syft)）。
- en: This leads us to the conclusion of this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了本章的结论。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen in this chapter that C++ has a lot of libraries and frameworks
    that cover everything we might need. Compared to other technologies, the process
    of obtaining them is not as simple. They are not as easily discoverable since
    they are not in a central place, and they might bring additional issues such as
    incompatibility with the compiler or older code styles. We learned this in this
    chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到C++拥有众多库和框架，涵盖了我们所可能需要的所有功能。与其他技术相比，获取它们的过程并不简单。由于它们不在一个中心位置，因此它们并不容易被发现，并且可能带来额外的麻烦，例如与编译器或旧代码风格的不兼容性。我们在这章中学到了这一点。
- en: Similarly, like other technologies, the C++ libraries are prone to having vulnerabilities
    and are exposed to supply chain attacks. To protect against them, teams need to
    stay up to date with the stream of vulnerabilities discovered and authenticate
    the binaries upon download. Additional audits and scans are always useful, as
    we learned in this chapter. Thus, larger organizations have a security advantage
    since they have dedicated teams looking at these issues, at the cost of flexibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，与其他技术一样，C++库容易存在漏洞，并可能受到供应链攻击。为了防范这些攻击，团队需要跟上发现的漏洞流，并在下载时验证二进制文件。正如我们在本章所学，额外的审计和扫描总是很有用的。因此，大型组织在安全性方面具有优势，因为它们有专门的团队来关注这些问题，但这是以灵活性为代价的。
- en: So, are there libraries for modern programming in C++? Yes, definitely. They
    are just harder to find and less compatible than in other widely used technologies.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，C++中是否有现代编程的库呢？当然有，只是它们更难找到，并且与其他广泛使用的技术相比兼容性较差。
- en: In the next chapter, we’ll look at whether C++ is backward compatible... with
    itself and beyond.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C++是否与其自身以及更广泛的技术向后兼容。
