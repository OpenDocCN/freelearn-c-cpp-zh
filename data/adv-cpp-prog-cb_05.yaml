- en: Concurrency and Synchronization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和同步
- en: In this chapter, we will learn how to properly handle concurrency, synchronization,
    and parallelism in C++. Here, it is essential that you have a general knowledge
    of C++ and C++ threads. This chapter is important because working with C++ typically
    requires the use of shared resources, which can easily become corrupt if thread-safety
    is not implemented properly. We will start with an extensive overview of `std::mutexes`,
    which provides a means to synchronizing C++ threads. We will then look at atomic
    data types, which provide another mechanism for handling parallelism safely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何正确处理C++中的并发、同步和并行。在这里，您需要对C++和C++线程有一般的了解。本章很重要，因为在处理C++时通常需要使用共享资源，如果没有正确实现线程安全，这些资源很容易变得损坏。我们将首先对`std::mutexes`进行广泛的概述，它提供了一种同步C++线程的方法。然后我们将研究原子数据类型，它提供了另一种安全处理并行性的机制。
- en: This chapter has recipes that demonstrate how to handle different scenarios
    while working with C++ threads, including handling `const &`, thread-safety wrapping,
    blocking versus asynchronous programming, and C++ promises and futures. This is
    important, as this knowledge is critical when working with multiple threads of
    execution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了演示如何处理C++线程的不同场景的示例，包括处理`const &`、线程安全包装、阻塞与异步编程以及C++ promises和futures。这是很重要的，因为在处理多个执行线程时，这些知识是至关重要的。
- en: 'The following recipes are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下示例：
- en: Working with mutexes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: Using atomic data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子数据类型
- en: Understanding what `const &` mutable mean in the context of multiple threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在多个线程的上下文中`const &` mutable的含义
- en: Making a class thread-safe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使类线程安全
- en: Synchronization wrappers and how to implement them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步包装器及其实现方法
- en: Blocking operations versus asynchronous programming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞操作与异步编程
- en: Working with promises and futures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用promises和futures
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理权限的计算机运行Ubuntu 18.04，并具有正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此软件安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Working with mutexes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁
- en: In this recipe, we will learn why and how to use a mutex in C++. When working
    with multiple threads in C++, it is common to establish resources that are shared
    between threads. As we will demonstrate in this recipe, attempting to use these
    shared resources simultaneously leads to race conditions that are capable of corrupting
    the resource.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习为什么以及如何在C++中使用互斥锁。在C++中使用多个线程时，通常会建立线程之间共享的资源。正如我们将在本示例中演示的那样，尝试同时使用这些共享资源会导致可能损坏资源的竞争条件。
- en: A mutex (in C++, this is written as `std::mutex`) is an object that is used
    to guard a shared resource, ensuring that more than one thread can access a shared
    resource in a controlled manner. This prevents it from becoming corrupt.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁（在C++中写作`std::mutex`）是一个用于保护共享资源的对象，确保多个线程可以以受控的方式访问共享资源。这可以防止资源损坏。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的正确工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试此示例：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例教授的课程的关系。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we will learn how to use `std::mutex` to protect a shared resource
    from becoming corrupt. To start, let''s first review how a resource could become
    corrupt when more than one thread is accessing it at the same time:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何使用`std::mutex`来保护共享资源，防止其损坏。首先，让我们首先回顾一下当多个线程同时访问资源时资源如何变得损坏：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When executed, we get the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '![](img/01192c95-b3c1-4df5-a5a4-b94be4b18090.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01192c95-b3c1-4df5-a5a4-b94be4b18090.png)'
- en: In the preceding example, we create a function that outputs to `stdout` in an
    endless loop. We then create two threads, with each thread executing the previously
    defined function. As you can see, when both threads execute, the resulting output
    becomes corrupt. This is because while one thread is in the middle of outputting
    its text to `stdout`, the other thread outputs to `stdout` at the same time, resulting
    in the output from one thread being mixed with the output of the other thread.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个在无限循环中输出到`stdout`的函数。然后我们创建了两个线程，每个线程执行先前定义的函数。正如您所看到的，当两个线程同时执行时，结果输出变得损坏。这是因为当一个线程正在将其文本输出到`stdout`时，另一个线程同时输出到`stdout`，导致一个线程的输出与另一个线程的输出混合在一起。
- en: To deal with this issue, we must ensure that, once one of the threads attempts
    to output its text to `stdout`, it should be allowed to finish its output before
    the other thread is able to output. In other words, each thread must take turns
    outputting to `stdout`. While one thread is outputting, the other thread must
    wait its turn. To do this, we will leverage an `std::mutex` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们必须确保一旦其中一个线程尝试将其文本输出到`stdout`，在另一个线程能够输出之前，它应该被允许完成输出。换句话说，每个线程必须轮流输出到`stdout`。当一个线程输出时，另一个线程必须等待轮到它。为了做到这一点，我们将利用一个`std::mutex`对象。
- en: std::mutex
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::mutex
- en: A mutex is an object that is used to guard a shared resource to ensure the use
    of the shared resource does not result in corruption. To accomplish this, `std::mutex`
    has a `lock()` function and an `unlock()` function. The lock function *acquires*
    access to a shared resource (sometimes referred to as a critical section). `unlock()` *releases*
    this previously acquired access. Any attempt to execute the `lock()` function
    after another thread has already executed `lock()` will result in the thread having
    to wait until the `unlock()` function is executed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁是一个用来保护共享资源的对象，以确保对共享资源的使用不会导致损坏。为了实现这一点，`std::mutex`有一个`lock()`函数和一个`unlock()`函数。`lock()`函数*获取*对共享资源的访问（有时称为临界区）。`unlock()`*释放*先前获取的访问。任何尝试在另一个线程已经执行`lock()`之后执行`lock()`函数的操作都将导致线程必须等待，直到执行`unlock()`函数为止。
- en: How `std::mutex` is implemented depends on the CPU's architecture and the operating
    system; however, in general, a mutex can be implemented with a simple integer.
    If the integer is `0`, the `lock()` function will set the integer to `1` and return,
    which tells the mutex that it is acquired. If the integer is `1`, meaning the
    mutex is already acquired, the `lock()` function will wait (that is, block) until
    the integer becomes `0`, and then it will set the integer to `1` and return. How
    this wait is implemented depends on the operating system. For example, the `wait()`
    function can loop forever until the integer becomes `0`, which is called a **spinlock**,
    or it can execute a `sleep()` function and wait for a period of time, allowing
    other threads and processes to execute while the mutex is locked. The release
    function always sets the integer to `0`, meaning the mutex is no longer acquired.
    The trick to ensuring the mutex works properly is to ensure the integer is read/written
    using atomic operations. If non-atomic operations are used, the integer itself
    would suffer the same shared resource corruption the mutex is trying to prevent.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::mutex`的实现取决于CPU的架构和操作系统；但是，一般来说，互斥锁可以用一个简单的整数来实现。如果整数为`0`，`lock()`函数将把整数设置为`1`并返回，这告诉互斥锁它已被获取。如果整数为`1`，意味着互斥锁已经被获取，`lock()`函数将等待（即阻塞），直到整数变为`0`，然后它将把整数设置为`1`并返回。如何实现这种等待取决于操作系统。例如，`wait()`函数可以循环直到整数变为`0`，这被称为**自旋锁**，或者它可以执行`sleep()`函数并等待一段时间，允许其他线程和进程在互斥锁被锁定时执行。释放函数总是将整数设置为`0`，这意味着互斥锁不再被获取。确保互斥锁正常工作的诀窍是确保使用原子操作读/写整数。如果使用非原子操作，整数本身将遭受与互斥锁试图防止的相同的共享资源损坏。'
- en: 'For example, consider the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情况：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This example, when run, outputs the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例运行时输出以下内容：
- en: '![](img/a74a32c8-e166-46cc-b84f-774e905f34cb.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a74a32c8-e166-46cc-b84f-774e905f34cb.png)'
- en: In the preceding example, we create the same function that outputs to `stdout`.
    The difference is, before we output to `stdout`, we acquire `std::mutex` by executing
    the `lock()` function. Once we are done outputting to `stdout`, we release the
    mutex by executing the `unlock()` function. The code in between the `lock()` and
    `unlock()` functions is called the **critical region**. Any code in the critical
    region can only be executed by one thread at any given time, ensuring our use
    of `stdout` does not become corrupt.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个输出到`stdout`的相同函数。不同之处在于，在我们输出到`stdout`之前，我们通过执行`lock()`函数来获取`std::mutex`。一旦我们完成了对`stdout`的输出，我们通过执行`unlock()`函数来释放互斥锁。在`lock()`和`unlock()`函数之间的代码称为**临界区**。临界区中的任何代码只能由一个线程在任何给定时间执行，确保我们对`stdout`的使用不会变得损坏。
- en: Ensuring shared resources do not become corrupt by controlling access to the
    shared resource (for example, using a mutex) is called **synchronization**. Although
    the majority of scenarios where thread synchronization is needed are not complicated,
    some scenarios can result in thread synchronization schemes that require an entire
    college course to cover. For this reason, thread synchronization is considered
    an extremely difficult paradigm in computer science to program correctly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制对共享资源的访问（例如使用互斥锁）来确保共享资源不会变得损坏称为**同步**。尽管大多数需要线程同步的情况并不复杂，但有些情况可能导致需要整个大学课程来覆盖的线程同步方案。因此，线程同步被认为是计算机科学中极其困难的范式，需要正确编程。
- en: 'In this recipe, we will cover some of these scenarios. To start, let''s discuss
    something called a **deadlock**. A deadlock occurs when a thread enters an endless
    wait state when calling the `lock()` function. A deadlock is often extremely difficult
    to debug and is the result of several reasons, including the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将涵盖其中一些情况。首先，让我们讨论一下**死锁**。当一个线程在调用`lock()`函数时进入无休止的等待状态时，就会发生死锁。死锁通常非常难以调试，是由于几个原因造成的，包括以下原因：
- en: A thread never calling `unlock()` due to programmer error or the thread that
    acquired the mutex crashing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于程序员错误或获取互斥锁的线程崩溃，导致线程从未调用`unlock()`
- en: The same thread calling the `lock()` function more than once before it calls
    `unlock()`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个线程在调用`unlock()`之前多次调用`lock()`函数
- en: Each thread locking more than one mutex in a different order
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程以不同的顺序锁定多个互斥锁
- en: 'To demonstrate this, let''s look at the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们看一下以下例子：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we create two threads, both of which attempt to lock
    the mutex but never call `unlock()`. As a result, the first thread acquires the
    mutex and then returns without releasing it. When the second thread attempts to
    acquire the mutex, it is forced to wait for the first thread to execute `unlock()`,
    which it never does, resulting in a deadlock (that is, the program never returns).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个线程，它们都试图锁定互斥量，但从未调用`unlock()`。结果，第一个线程获取了互斥量，然后返回而没有释放它。当第二个线程尝试获取互斥量时，它被迫等待第一个线程执行`unlock()`，但第一个线程从未执行，导致死锁（即程序永远不会返回）。
- en: 'Deadlock, in this example, is simple to identify and correct; however, in real-world
    scenarios, identifying deadlock is a lot more complicated. Let''s look at the
    following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，死锁很容易识别和纠正；然而，在现实场景中，识别死锁要复杂得多。让我们看下面的例子：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we wrote a function that returns an element in an
    array, given an index. In addition, we acquire a mutex that guards the array and
    releases the mutex just before returning. The challenge here is that we have to
    `unlock()` the mutex where the function can return, which includes not only every
    possible branch that returns from the function, but all possible scenarios where
    an exception could be thrown. In the preceding example, if the index that is provided
    is larger than the array, the `std::array` object will throw an exception, resulting
    in the function returning before the function has a chance to call `unlock()`,
    which would result in deadlock if another thread is sharing this array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们编写了一个函数，根据索引返回数组中的元素。此外，我们获取了保护数组的互斥量，并在返回之前释放了互斥量。挑战在于我们必须在函数可以返回的地方`unlock()`互斥量，这不仅包括从函数返回的每种可能分支，还包括抛出异常的所有可能情况。在前面的例子中，如果提供的索引大于数组大小，`std::array`对象将抛出异常，导致函数在调用`unlock()`之前返回，如果另一个线程正在共享此数组，将导致死锁。
- en: std::lock_guard
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::lock_guard
- en: Instead of littering your code with `try`/`catch` blocks to prevent deadlock,
    which assumes the programmer is even capable of determining every possible scenario
    where this could occur without making a mistake, C++ provides an `std::lock_guard` object
    to simplify the use of the `std::mutex` object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了`std::lock_guard`对象来简化对`std::mutex`对象的使用，而不是在代码中到处使用`try`/`catch`块来防止死锁，这假设程序员甚至能够确定每种可能发生死锁的情况而不出错。
- en: 'For example, consider the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When executed, we see the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们看到以下结果：
- en: '![](img/948ff65e-fbca-4f22-98f2-85b33fe28cea.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/948ff65e-fbca-4f22-98f2-85b33fe28cea.png)'
- en: As shown in the preceding example, `std::lock_guard` is used when we would normally
    call `lock()` on the mutex. `std::lock_guard` calls the `lock()` function on the
    mutex when it is created and then calls `unlock()` on the mutex when it is destroyed
    (an idiom called **Resource Acquisition Is Initialization** or **RAII**). No matter
    how the function returns (either from a normal return or an exception), the mutex
    will always be released, ensuring deadlock is not possible, preventing the programmer
    from having to accurately determine every possible scenario where the function
    could return.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，当我们通常在互斥量上调用`lock()`时，使用`std::lock_guard`。`std::lock_guard`在创建时调用互斥量的`lock()`函数，然后在销毁时调用互斥量的`unlock()`函数（一种称为**资源获取即初始化**或**RAII**的习惯用法）。无论函数如何返回（无论是正常返回还是异常），互斥量都将被释放，确保死锁不可能发生，避免程序员必须准确确定函数可能返回的每种可能情况。
- en: Although `std::lock_guard` is capable of preventing deadlock in cases where
    `unlock()` is never called, it is not capable of preventing deadlock from occurring
    in cases where `lock()` is called by the same thread more than once prior to `unlock()`
    being called. To handle this scenario, C++ provides `std::recursive_mutex`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`std::lock_guard`能够防止在从未调用`unlock()`的情况下发生死锁，但它无法防止在调用`lock()`多次之后再调用`unlock()`之前发生死锁的情况。为了处理这种情况，C++提供了`std::recursive_mutex`。
- en: std::recursive_mutex
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::recursive_mutex
- en: A recursive mutex increments the integer stored inside the mutex each time the
    same thread calls the `lock()` function without causing the `lock()` function
    to wait. For example, if the mutex is released (that is, the integer in the mutex
    is `0`), when thread `#1` calls the `lock()` function, the integer in the mutex
    is set to `1`. Normally, if thread `#1` calls the `lock()` function again, the
    `lock()` function would see that the integer is `1` and enter a wait state until
    the integer is set to `0`. Instead, a recursive mutex will determine which thread
    is calling the `lock()` function, and, if the thread that acquired the mutex is
    the same thread calling the `lock()` function, the integer in the mutex is incremented
    again (now resulting in `2`) using an atomic operation. For the mutex to be released,
    the thread must call `unlock()`, which decrements the integer using an atomic
    operation, until the integer in the mutex is `0`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 递归互斥量每次同一线程调用`lock()`函数时都会增加互斥量内部存储的整数，而不会导致`lock()`函数等待。例如，如果互斥量被释放（即，互斥量中的整数为`0`），当线程`#1`调用`lock()`函数时，互斥量中的整数被设置为`1`。通常情况下，如果线程`#1`再次调用`lock()`函数，`lock()`函数会看到整数为`1`并进入等待状态，直到整数被设置为`0`。相反，递归互斥量将确定调用`lock()`函数的线程，并且如果获取互斥量的线程与调用`lock()`函数的线程相同，则使用原子操作再次增加互斥量中的整数（现在结果为`2`）。要释放互斥量，线程必须调用`unlock()`，这将使用原子操作递减整数，直到互斥量中的整数为`0`。
- en: The recursive mutex allows the same thread to call the `lock()` function as
    many times as it wants, preventing multiple calls to the `lock()` function and
    resulting in deadlock at the expense that the `lock()` and `unlock()` functions
    must include an added function call to get the thread's `id()` instance, so that
    the mutex can determine which thread is calling `lock()` and `unlock()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 递归互斥锁允许同一个线程调用`lock()`函数多次，防止多次调用`lock()`函数并导致死锁，但代价是`lock()`和`unlock()`函数必须包括一个额外的函数调用来获取线程的`id()`实例，以便互斥锁可以确定是哪个线程在调用`lock()`和`unlock()`。
- en: 'For example, consider the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding example results in the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子会导致以下结果：
- en: '![](img/fef09e3b-fb6a-479b-a600-6c482d4c8b94.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fef09e3b-fb6a-479b-a600-6c482d4c8b94.png)'
- en: In the preceding example, we define a function that calls the `lock()` function
    for a recursive mutex twice, outputs to `stdout`, and then calls the `unlock()`
    function twice. We then create two threads that execute this function, resulting
    in no corruption to `stdout` and no deadlock.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个函数，该函数调用递归互斥锁的`lock()`函数两次，输出到`stdout`，然后再调用`unlock()`函数两次。然后我们创建两个执行此函数的线程，结果是`stdout`没有腐败，也没有死锁。
- en: std::shared_mutex
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::shared_mutex
- en: Up until this point, our synchronization primitives have serialized access to
    our shared resource. That is, each thread must execute one at a time when accessing
    the critical region. Although this ensures corruption is not possible, it is inefficient
    for certain types of scenarios. To better understand this, we must examine what
    causes corruption in the first place.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 直到这一点，我们的同步原语已经对共享资源进行了序列化访问。也就是说，每个线程在访问临界区时必须一次执行一个。虽然这确保了腐败是不可能的，但对于某些类型的场景来说效率不高。为了更好地理解这一点，我们必须研究是什么导致了腐败。
- en: 'Let''s consider an integer variable that is incremented by two threads simultaneously.
    The process for incrementing an integer variable is as follows: `i = i + 1`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个整数变量，它被两个线程同时增加。增加整数变量的过程如下：`i = i + 1`。
- en: 'Let''s write this as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其写成如下形式：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To prevent corruption, we use a mutex to ensure that if two threads increment
    the integer, they do so synchronously:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止腐败，我们使用互斥锁来确保两个线程同步地增加整数：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Corruption occurs when these operations mix (that is, when both operations
    execute simultaneously in different threads). For example, consider this code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些操作混合在一起时（也就是说，当两个操作在不同的线程中同时执行时），就会发生腐败。例如，考虑以下代码：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of the integer being `2`, it is `1`, because the integer is read before
    the first increment is allowed to finish. This scenario is possible because both
    threads are attempting to write to the same shared resource. We call these types
    of threads **producers**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数为`2`不同，它是`1`，因为在第一个增量允许完成之前整数被读取。这种情况是可能的，因为两个线程都试图写入同一个共享资源。我们称这些类型的线程为**生产者**。
- en: What if, however, we create a million threads that read the shared resource
    simultaneously. Since the integer never changes, no matter what order the threads
    execute in, they will all read the same value, and therefore corruption is not
    possible. We call these threads **consumers**. If we only ever have consumers,
    we do not need thread synchronization as corruption is not possible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们创建了100万个同时读取共享资源的线程会发生什么。由于整数永远不会改变，无论线程以什么顺序执行，它们都会读取相同的值，因此腐败是不可能的。我们称这些线程为**消费者**。如果我们只有消费者，我们就不需要线程同步，因为腐败是不可能的。
- en: Finally, what happens if we have the same 1 million consumers, but we add a
    single producer to the mix? Now, we must use thread synchronization because it
    is possible that while the producer is in the middle of attempting to write a
    value to the integer that a consumer attempts to read, it will result in a corrupt
    result. To prevent this, we must use a mutex to guard the integer. If we use `std::mutex`,
    however, all 1 million consumers would have to wait on each other, even though
    the consumers themselves can safely execute simultaneously without the fear of
    corruption. It is only when the producer attempts to execute that we must be worried.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们有相同的100万个消费者，但是我们在其中添加了一个生产者会发生什么？现在，我们必须使用线程同步，因为可能在生产者试图将一个值写入整数的过程中，消费者也试图读取，这将导致腐败的结果。为了防止这种情况发生，我们必须使用互斥锁来保护整数。然而，如果我们使用`std::mutex`，那么所有100万个消费者都必须互相等待，即使消费者们自己可以在不担心腐败的情况下同时执行。只有当生产者尝试执行时，我们才需要担心。
- en: 'To handle this obvious performance problem, C++ provides the `std::shared_mutex`
    object. For example, consider this code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个明显的性能问题，C++提供了`std::shared_mutex`对象。例如，考虑以下代码：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we create a producer function (called the `reader`
    function) and a consumer function (called the `writer` function). The producer
    locks the mutex using `std::unique_lock()`, while the consumer locks the mutex
    using `std::shared_lock()`. Whenever the mutex is locked using `std::unique_lock()`,
    all other threads must wait (producer and consumer alike). If, however, the mutex
    is locked using `std::shared_lock()`, additional attempts to lock the mutex using
    `std::shared_lock()` do not result in the thread waiting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个生产者函数（称为`reader`函数）和一个消费者函数（称为`writer`函数）。生产者使用`std::unique_lock()`锁定互斥锁，而消费者使用`std::shared_lock()`锁定互斥锁。每当使用`std::unique_lock()`锁定互斥锁时，所有其他线程都必须等待（无论是生产者还是消费者）。然而，如果使用`std::shared_lock()`锁定互斥锁，使用`std::shared_lock()`再次尝试锁定互斥锁不会导致线程等待。
- en: It's only when `std::unique_lock()` is called that a wait must occur. This allows
    the consumers to execute without waiting on each other. It's only when the producer
    attempts to execute that the consumers must wait, preventing the consumers from
    serializing each other, ultimately resulting in better performance (especially
    if the number of consumers is 1 million).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在调用`std::unique_lock()`时才需要等待。这允许消费者在不等待彼此的情况下执行。只有当生产者尝试执行时，消费者必须等待，防止消费者相互串行化，最终导致更好的性能（特别是如果消费者的数量是100万）。
- en: It should be noted that we use the `const` keyword to ensure that a consumer
    is not a producer. This simple trick ensures that the programmer doesn't accidentally
    think they have programmed a consumer when, in fact, they have created a producer,
    as the compiler would warn the programmer if this occurred.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，我们使用`const`关键字来确保消费者不是生产者。这个简单的技巧确保程序员不会在不经意间认为他们已经编写了一个消费者，而实际上他们已经创建了一个生产者，因为如果发生这种情况，编译器会警告程序员。
- en: std::timed_mutex
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::timed_mutex
- en: Finally, we have not dealt with the scenario where a thread that acquired a
    mutex crashed. In this scenario, any thread that attempts to acquire the same
    mutex would enter a deadlock state as the thread that crashed never gets a chance
    to call `unlock()`. One way to prevent this issue is to use `std::timed_mutex`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还没有处理线程获取互斥锁后崩溃的情况。在这种情况下，任何尝试获取相同互斥锁的线程都会进入死锁状态，因为崩溃的线程永远没有机会调用`unlock()`。预防这种问题的一种方法是使用`std::timed_mutex`。
- en: 'For example, consider the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When this is executed, we get the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个时，我们得到以下结果：
- en: '![](img/a606b9bb-6ef7-4885-93e6-344fc3bc06e7.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a606b9bb-6ef7-4885-93e6-344fc3bc06e7.png)'
- en: In the preceding example, we tell C++ that the thread is only allowed to wait
    for 1 second. If the mutex is already acquired and it is not released after 1
    second, the `try_lock_for()` function will exit and return false, allowing the
    thread to gracefully exit and handle the error without entering a deadlock.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们告诉C++线程只允许等待1秒。如果互斥锁已经被获取，并且在1秒后没有被释放，`try_lock_for()`函数将退出并返回false，允许线程优雅地退出并处理错误，而不会进入死锁状态。
- en: Using atomic data types
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子数据类型
- en: In this recipe, we will learn how to use atomic data types in C++. Atomic data
    types provide the ability to read and write simple data types (that is, a Boolean
    or integer) without the need for thread synchronization (that is, the use of `std::mutex`
    and friends). To accomplish this, atomic data types are implemented using special
    CPU instructions that ensure when an operation is executed, it is done so as a
    single, atomic operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在C++中使用原子数据类型。原子数据类型提供了读写简单数据类型（即布尔值或整数）的能力，而无需线程同步（即使用`std::mutex`和相关工具）。为了实现这一点，原子数据类型使用特殊的CPU指令来确保当执行操作时，它是作为单个原子操作执行的。
- en: 'For example, incrementing an integer can be written as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，递增一个整数可以写成如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An atomic data type ensures that this increment is executed such that no other
    attempts to increment the integer simultaneously can interleave, and therefore result
    in corruption. How this is done by the CPU is out of the scope of this book. That's
    because this is extremely complicated in modern, super-scalar, pipelined CPUs
    that support the execution of instructions in parallel, out-of-order, and speculatively
    on multiple cores and sockets.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 原子数据类型确保这个递增是以这样的方式执行的，即没有其他尝试同时递增整数的操作可以交错，并因此导致损坏。CPU是如何做到这一点的超出了本书的范围。这是因为在现代的超标量、流水线化的CPU中，支持在多个核心和插槽上并行、乱序和推测性地执行指令，这是非常复杂的。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行此食谱中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个食谱：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To compile the source code, run the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行这个食谱中的每个示例：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we will learn how to use C++'s atomic data types. Atomic data
    types are limited to simple data types such as integers, and since these data
    types are extremely complicated to implement, the only operations that are supported
    are simple operations such as add, subtract, increment, and decrement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用C++的原子数据类型。原子数据类型仅限于简单的数据类型，如整数，由于这些数据类型非常复杂，只支持简单的操作，如加法、减法、递增和递减。
- en: 'Let''s take a look at a simple example that not only demonstrates how to use
    an atomic data type in C++, but also demonstrates why atomic data types are so
    important:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，不仅演示了如何在C++中使用原子数据类型，还演示了为什么原子数据类型如此重要：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When this code is executed, we get the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这段代码时，我们得到以下结果：
- en: '![](img/216f9a16-1893-4c5f-b259-da1e2d0b4bc0.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/216f9a16-1893-4c5f-b259-da1e2d0b4bc0.png)'
- en: In the preceding example, we have two integers. The first integer is a normal
    C/C++ integer type, while the second is an atomic data type (of type integer).
    We then define a function that loops until the atomic data type is `1000`. Finally,
    we execute this function from two threads, which means our global integers are
    incremented by two threads simultaneously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有两个整数。第一个整数是普通的C/C++整数类型，而第二个是原子数据类型（整数类型）。然后，我们定义一个循环，直到原子数据类型为`1000`为止。最后，我们从两个线程中执行这个函数，这意味着我们的全局整数会被两个线程同时增加。
- en: 'As you can see, the output of this simple test shows that the simple C/C++
    integer data type is not the same value as the atomic data type, yet both are
    incremented the same number of times. The reason for this can be seen in the assembly
    of this function (on an Intel CPU), as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个简单测试的输出显示，简单的C/C++整数数据类型与原子数据类型的值不同，但两者都增加了相同次数。这个原因可以在这个函数的汇编中看到（在Intel
    CPU上），如下所示：
- en: '![](img/b1e3de9e-b754-49b6-a53a-d4e0bfd9cc2f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1e3de9e-b754-49b6-a53a-d4e0bfd9cc2f.png)'
- en: To increment an integer (without optimizations enabled), the compiler must move
    the contents of memory into a register, add `1` to the register, and then write
    the results of the register back to memory. Since this code is executing simultaneously
    in two different threads, this code interleaves, resulting in corruption. The
    atomic data type does not suffer this same problem. This is because the process
    of incrementing the atomic data type occurs in a single, special instruction that
    the CPU ensures to execute, without interleaving its internal state with the same
    internal state of other instructions, on other CPUs.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要增加一个整数（未启用优化），编译器必须将内存内容移动到寄存器中，将`1`添加到寄存器中，然后将寄存器的结果写回内存。由于这段代码同时在两个不同的线程中执行，这段代码交错执行，导致损坏。原子数据类型不会遇到这个问题。这是因为增加原子数据类型的过程发生在一个单独的特殊指令中，CPU确保执行，而不会将其内部状态与其他指令的相同内部状态交错在一起，也不会在其他CPU上交错。
- en: Atomic data types are typically used to implement synchronization primitives
    such as `std::mutex` (although, in practice, `std::mutex` is implemented using
    test and set instructions, which use a similar principle but oftentimes execute
    faster than atomic instructions). These data types can also be used to implement
    special data structures called lock-free data structures, which are capable of
    operating in multithreaded environments without the need for `std::mutex`. The
    benefit of lockless data structures is that there are no wait states when dealing
    with thread synchronization at the expense of more complicated CPU hardware and
    other types of performance penalties (most CPU optimizations provided by the hardware
    have to be temporarily disabled when the CPU encounters an atomic instruction).
    So, like anything in computer science, they have their time and place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原子数据类型通常用于实现同步原语，例如`std::mutex`（尽管在实践中，`std::mutex`是使用测试和设置指令实现的，这些指令使用类似的原理，但通常比原子指令执行得更快）。这些数据类型还可以用于实现称为无锁数据结构的特殊数据结构，这些数据结构能够在多线程环境中运行，而无需`std::mutex`。无锁数据结构的好处是在处理线程同步时没有等待状态，但会增加更复杂的CPU硬件和其他类型的性能惩罚（当CPU遇到原子指令时，大多数由硬件提供的CPU优化必须暂时禁用）。因此，就像计算机科学中的任何东西一样，它们都有其时机和地点。
- en: Understanding what const & mutable mean in the context of multiple threads
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多线程的上下文中理解const & mutable的含义
- en: In this recipe, we will learn how to deal with objects that are labeled `const`,
    but contain `std::mutex` that must be used to ensure thread synchronization. This
    recipe is important because it is useful to store `std::mutex` as a private member
    of a class, but, as soon as you do this, passing an instance of this object as
    a constant reference (that is, `const &`) will result in a compiler error. In
    this recipe, we will demonstrate why this occurs and how to overcome it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何处理被标记为`const`的对象，但包含必须使用`std::mutex`来确保线程同步的对象。这个示例很重要，因为将`std::mutex`存储为类的私有成员是很有用的，但是，一旦你这样做了，将这个对象的实例作为常量引用（即`const
    &`）传递将导致编译错误。在这个示例中，我们将演示为什么会发生这种情况以及如何克服它。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中示例的正确工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端中，运行以下命令来下载源代码：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To compile the source code, run the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will learn how to add `std::mutex` to a class's private members
    while still being able to handle `const` scenarios. Generally speaking, there
    are two ways to ensure an object is thread-safe. The first method is to place
    `std::mutex` at the global level. Doing this ensures an object can be passed as
    a constant reference or the object itself can have a function marked as `const`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何将`std::mutex`添加到类的私有成员中，同时仍然能够处理`const`情况。一般来说，确保对象是线程安全的有两种方法。第一种方法是将`std::mutex`放在全局级别。这样做可以确保对象可以作为常量引用传递，或者对象本身可以有一个标记为`const`的函数。
- en: 'For this, consider the following code example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请考虑以下代码示例：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we create an object that outputs to `stdout` when
    the `print()` function is executed. The `print()` function is labeled as `const`,
    which tells the compiler that the `print()` function will not modify any class
    members (that is, the function is read-only). Since `std::mutex` is global, the
    const-qualifier of the object is maintained and the code compiles and executes
    without an issue.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当执行`print()`函数时，我们创建了一个对象，该对象输出到`stdout`。`print()`函数被标记为`const`，这告诉编译器`print()`函数不会修改任何类成员（即函数是只读的）。由于`std::mutex`是全局的，对象的const限定符被维持，代码可以编译和执行而没有问题。
- en: The problem with a global `std::mutex` object is that every instance of the
    object must use the same `std::mutex` object. This is fine if the user intends
    this, but what if you want each instance of the object to have its own `std::mutex` object
    (for example, when the same instance of the object might be executed by more than
    one thread)?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`std::mutex`对象的问题在于，对象的每个实例都必须使用相同的`std::mutex`对象。如果用户打算这样做，那没问题，但如果您希望对象的每个实例都有自己的`std::mutex`对象（例如，当对象的相同实例可能被多个线程执行时），该怎么办？
- en: 'For this, let''s take a look at how that happens using the following example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们看看如何使用以下示例发生的情况：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we attempt to compile this, we get the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译这个，我们会得到以下结果：
- en: '![](img/944a6bd9-fba1-4f70-b061-5dc7c7c4afba.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/944a6bd9-fba1-4f70-b061-5dc7c7c4afba.png)'
- en: In the preceding example, all we did was take the previous example and move
    `std::mutex` inside the class as a private member. As a result, when we attempt
    to compile the class, we get a compiler error. This is because the `print()` function
    is marked as `const`, which tells the compiler that the `print()` function will
    not modify any of the class's members. The problem is that when you attempt to
    lock `std::mutex`, you must modify it, resulting in a compiler error.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们所做的只是将前面的例子中的`std::mutex`移动到类内部作为私有成员。结果是，当我们尝试编译类时，我们会得到一个编译器错误。这是因为`print()`函数被标记为`const`，这告诉编译器`print()`函数不会修改类的任何成员。问题在于，当您尝试锁定`std::mutex`时，您必须对其进行修改，从而导致编译器错误。
- en: To overcome this, we must tell the compiler to ignore this error by marking
    `std::mutex` as mutable. Marking a member as mutable tells the compiler that the
    member is allowed to be modified, even when the object is passed as a constant
    reference or when the object defines a constant function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们必须告诉编译器忽略这个错误，方法是将`std::mutex`标记为mutable。将成员标记为mutable告诉编译器允许修改该成员，即使对象被作为常量引用传递或对象定义了常量函数。
- en: 'For example, this is how the code appears on `const` marked as `mutable`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是`const`标记为`mutable`的代码示例：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see in the preceding example, once we mark `std::mutex` as mutable,
    the code compiles and executes as we would expect. It should be noted that `std::mutex`
    is one of the few examples for which the use of mutable is acceptable. The mutable
    keyword can easily be abused, resulting in code that doesn't compile or operate
    as expected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，一旦我们将`std::mutex`标记为mutable，代码就会像我们期望的那样编译和执行。值得注意的是，`std::mutex`是少数几个可以接受mutable使用的例子之一。mutable关键字很容易被滥用，导致代码无法编译或操作不符合预期。
- en: Making a class thread-safe
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使类线程安全
- en: 'In this recipe, we will learn how to make a class thread-safe (that is, how
    to ensure a class''s public member functions can be called at any time, by any
    number of threads simultaneously). Most classes, especially those provided by
    the C++ standard library are not thread-safe and, instead, assume the user will
    add thread-synchronization primitives such as an `std::mutex` object as needed.
    The problem with this approach is that every object has two instances that must
    be tracked in code: the class itself and its `std::mutex`. The user must also
    wrap each of the object''s functions with custom versions that protect the class
    using `std::mutex`, resulting in not only two objects that must be managed, but
    also a bunch of C-style wrapper functions.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习如何使一个类线程安全（即如何确保一个类的公共成员函数可以随时被任意数量的线程同时调用）。大多数类，特别是由C++标准库提供的类，都不是线程安全的，而是假设用户会根据需要添加线程同步原语，如`std::mutex`对象。这种方法的问题在于，每个对象都有两个实例，必须在代码中进行跟踪：类本身和它的`std::mutex`。用户还必须用自定义版本包装对象的每个函数，以使用`std::mutex`保护类，结果不仅有两个必须管理的对象，还有一堆C风格的包装函数。
- en: This recipe is important because it will demonstrate how to address these issues
    in your code by making a thread-safe class, which combines everything into a single
    class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很重要，因为它将演示如何通过创建一个线程安全的类来解决代码中的这些问题，将所有内容合并到一个单一的类中。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例的正确工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个教程：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To compile the source code, run the following:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它们与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will learn how to make a thread-safe class by implementing
    our own thread-safe stack. The C++ standard library does not provide thread-safe
    data structures, and, as a result, if you wish to use a data structure as a global
    resource across multiple threads, you add thread-safety manually. This can be
    done by implementing wrapper functions, or by creating a wrapper class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何通过实现自己的线程安全栈来制作一个线程安全的类。C++标准库不提供线程安全的数据结构，因此，如果您希望在多个线程中使用数据结构作为全局资源，您需要手动添加线程安全性。这可以通过实现包装函数或创建包装类来实现。
- en: The advantage of creating wrapper functions is that, for global objects, the
    amount of code that is needed is oftentimes smaller and easier to understand,
    while the advantage of a thread-safe class is that you can create multiple instances
    of the class, as `std::mutex` is self-contained.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建包装函数的优势在于，对于全局对象，通常所需的代码量更少，更容易理解，而线程安全类的优势在于，您可以创建类的多个实例，因为`std::mutex`是自包含的。
- en: 'This can be tried with the following code example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以尝试以下代码示例：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, we implement our own stack. This stack has `std::stack`
    and `std::mutex` as member variables. We then reimplement some of the functions
    the `std::stack` provides. Each of these functions first attempts to acquire `std::mutex`
    and then calls the associated function in `std::stack`. In the case of the `push()`
    function, we leverage `std::forward` to ensure the arguments passed to the `push()`
    function are preserved.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们实现了自己的栈。这个栈有`std::stack`和`std::mutex`作为成员变量。然后，我们重新实现了`std::stack`提供的一些函数。这些函数中的每一个首先尝试获取`std::mutex`，然后调用`std::stack`中的相关函数。在`push()`函数的情况下，我们利用`std::forward`来确保传递给`push()`函数的参数被保留。
- en: 'Finally, we can use our custom stack the same way we would use `std::stack`.
    For example, take a look at the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以像使用`std::stack`一样使用我们的自定义栈。例如，看一下以下代码：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the only difference between `std::stack` and our custom stack
    is that our stack is thread-safe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`std::stack`和我们的自定义栈之间唯一的区别是我们的栈是线程安全的。
- en: Synchronization wrappers and how to implement them
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步包装器及其实现方式
- en: In this recipe, we will learn how to make thread-safe synchronization wrappers.
    By default, the C++ standard library is not thread-safe as not all applications
    will need this functionality. One mechanism to ensure the C++ standard library
    is thread-safe is to create a thread-safe class, which adds the data structure
    you wish to use as well as `std::mutex` to the class as private members, and then
    reimplements the data structure's functions to first acquire `std::mutex` and
    then forward the function call to the data structure. The problem with this approach
    is there is a lot of extra code that is added to your program if the data structure
    is a global resource, making the resulting code hard to read and maintain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何制作线程安全的同步包装器。默认情况下，C++标准库不是线程安全的，因为并非所有应用程序都需要这种功能。确保C++标准库是线程安全的一种机制是创建一个线程安全类，它将您希望使用的数据结构以及`std::mutex`作为私有成员添加到类中，然后重新实现数据结构的函数以首先获取`std::mutex`，然后转发函数调用到数据结构。这种方法的问题在于，如果数据结构是全局资源，程序中会添加大量额外的代码，使得最终的代码难以阅读和维护。
- en: This recipe is important because it will demonstrate how to address these issues
    in your code by making thread-safe synchronization wrappers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程很重要，因为它将演示如何通过制作线程安全的同步包装器来解决代码中的这些问题。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个教程：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To compile the source code, run the following:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它们与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we will learn how to create thread-safe synchronization wrappers,
    which allow us to add thread-safety to the C++ standard library data structures,
    which, by default, are not thread-safe.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何创建线程安全的同步包装器，这允许我们向C++标准库数据结构添加线程安全性，而默认情况下这些数据结构是不安全的。
- en: To do this, we will create wrapper functions for each function in the C++ standard
    library that we intend to use. These wrapper functions will first attempt to acquire
    `std::mutex`, before forwarding the same function call to the C++ standard library
    data structure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将为C++标准库中的每个函数创建包装函数。这些包装函数将首先尝试获取`std::mutex`，然后将相同的函数调用转发到C++标准库数据结构。
- en: 'To do this, consider the following code example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请考虑以下代码示例：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding example, we have created a wrapper function for the `push()`,
    `pop()`, and `empty()` functions. These functions attempt to acquire our global
    `std::mutex` object before calling the data structure, which, in this case, is
    a template. The use of a template creates what is called a concept. Our wrapper
    functions can be used by any data structure that implements `push()`, `pop()`,
    and `empty()`. Also, note that we use `std::forward` in our `push()` function
    to ensure the l-valueness and CV qualifiers of the argument being pushed remain
    unchanged.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为`push()`、`pop()`和`empty()`函数创建了一个包装函数。这些函数在调用数据结构之前会尝试获取我们的全局`std::mutex`对象，这里是一个模板。使用模板创建了一个概念。我们的包装函数可以被实现了`push()`、`pop()`和`empty()`的任何数据结构使用。另外，请注意我们在`push()`函数中使用`std::forward`来确保被推送的参数的l-valueness和CV限定符保持不变。
- en: 'Finally, we can use our wrappers the same way we would use the data structure''s
    functions, with the slight difference being that the data structure is passed
    as the first argument. For example, take a look at the following code block:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以像使用数据结构的函数一样使用我们的包装器，唯一的区别是数据结构作为第一个参数传递。例如，看一下以下代码块：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see in the preceding example, the use of our synchronization wrappers
    is simple, while ensuring the stack that we created is now thread-safe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子中所示，使用我们的同步包装器是简单的，同时确保我们创建的堆栈现在是线程安全的。
- en: Blocking operations versus asynchronous programming
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞操作与异步编程
- en: In this recipe, we will learn the difference between a blocking operation and
    an asynchronous operation. This recipe is important because blocking operations
    serialize the execution of each operation on a single CPU. This is typically fine
    if the execution of each operation must be executed in serial order; however,
    if these operations can be executed in parallel, asynchronous programming can
    be a useful optimization, ensuring that, while an operation is waiting, others
    can still execute on the same CPU.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习阻塞操作和异步操作之间的区别。这个示例很重要，因为阻塞操作会使每个操作在单个CPU上串行执行。如果每个操作的执行必须按顺序执行，这通常是可以接受的；然而，如果这些操作可以并行执行，异步编程可以是一个有用的优化，确保在一个操作等待时，其他操作仍然可以在同一个CPU上执行。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new terminal.
    We will use this terminal to download, compile, and run our examples.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To compile the source code, run the following:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，您可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A blocking operation is an operation that must be completed before the next
    operation can take place. Most programs are written serially, meaning each instruction
    must execute before the next instruction. The problem, however, is that some operations
    can be executed in parallel (that is, either concurrently or asynchronously).
    Serializing these operations can, in the best case, lead to poor performance and,
    in some cases, can actually lead to deadlock (the program entering an endless
    wait state) if the operation that is blocking is waiting on another operation
    that is never given a chance to execute.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞操作是指必须在下一个操作发生之前完成的操作。大多数程序是按顺序编写的，这意味着每个指令必须在下一个指令之前执行。然而，问题在于有些操作可以并行执行（即同时或异步执行）。串行化这些操作在最好的情况下可能会导致性能不佳，并且在某些情况下实际上可能会导致死锁（程序进入无休止的等待状态），如果阻塞的操作正在等待另一个从未有机会执行的操作。
- en: 'To demonstrate a blocking operation, let''s examine the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示一个阻塞操作，让我们来看一下以下内容：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code creates a main function with four `std::vector` objects
    of the `int` type. In the following steps, we will use these vectors to demonstrate
    a blocking operation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个主函数，其中有四个`int`类型的`std::vector`对象。在接下来的步骤中，我们将使用这些向量来演示一个阻塞操作。
- en: 'First, we create four vectors that we can store integers in:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建四个可以存储整数的向量：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we fill each array with random numbers using `std::generate`, which results
    in an array with numbers and a random order:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`std::generate`用随机数填充每个数组，结果是一个带有数字和随机顺序的数组：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we sort the array of integers, which is the main goal of this example,
    as this operation takes a while to execute:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们对整数数组进行排序，这是本例的主要目标，因为这个操作需要一段时间来执行：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, we output the last entry in each array, which will usually be `999999`
    (but doesn't have to be since the numbers were generated using a random number
    generator).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们输出每个数组中的最后一个条目，通常会是`999999`（但不一定，因为数字是使用随机数生成器生成的）。
- en: 'The problem with the preceding example is that the operations could be executed
    in parallel because each array is independent. To address this, we can execute
    these operations asynchronously, meaning the arrays will be created, filled, sorted,
    and outputted in parallel. For example, consider the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的问题在于操作可以并行执行，因为每个数组是独立的。为了解决这个问题，我们可以异步执行这些操作，这意味着数组将并行创建、填充、排序和输出。例如，考虑以下代码：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first thing we do is implement a function called `foo()` that creates our
    vector, fills it with random numbers, sorts the list, and returns the last entry
    in the array (which is identical to the preceding example with the exception that
    we only work with one array at a time and not `4`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是实现一个名为`foo()`的函数，该函数创建我们的向量，用随机数填充它，对列表进行排序，并返回数组中的最后一个条目（与前面的示例相同，唯一的区别是我们一次只处理一个数组，而不是`4`个）：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We then use `std::async` to execute this `foo()` function four times, resulting
    in the same four arrays, just like our previous example. The `std::async()` function
    in this example does the same thing as executing four threads manually. The result
    of `std::aync()` is a `std::future` object, which stores the result of the function
    once it has finished executing. The last thing we do in this example is use the
    `get()` function to return the value of the function once it is ready.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`std::async`四次执行这个`foo()`函数，得到与前面示例相同的四个数组。在这个示例中，`std::async()`函数做的事情与手动执行四个线程相同。`std::aync()`的结果是一个`std::future`对象，它在函数执行完成后存储函数的结果。在这个示例中，我们做的最后一件事是使用`get()`函数在函数准备好后返回函数的值。
- en: 'If we time the results of these functions, we can see that the asynchronous
    version is faster than the blocking version. The following code shows this (the
    `real` time is the time to look for):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计时这些函数的结果，我们会发现异步版本比阻塞版本更快。以下代码显示了这一点（`real`时间是查找时间）：
- en: '![](img/46ef0e32-b06c-4bc6-9b92-5984d00d7432.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46ef0e32-b06c-4bc6-9b92-5984d00d7432.png)'
- en: 'The `std::async()` function can also be used to execute our array function
    asynchronously in the same thread. For example, consider the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::async()`函数也可以用来在同一个线程中异步执行我们的数组函数。例如，考虑以下代码：'
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see in the preceding example, we changed the operation from `std::launch::async`
    to `std::launch::deferred`, which results in each function executing once the
    result of the function is needed (that is, when the `get()` function is called).
    This is useful if you are not sure whether the function needs to execute in the
    first place (that is, only execute the function when needed), with the downside
    being that the execution of the program is slower, as threads are not typically
    used as an optimization method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们将操作从`std::launch::async`更改为`std::launch::deferred`，这将导致每个函数在需要函数结果时执行一次（即调用`get()`函数时）。如果不确定函数是否需要执行（即仅在需要时执行函数），这将非常有用，但缺点是程序的执行速度较慢，因为线程通常不用作优化方法。
- en: Working with promises and futures
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺和未来
- en: In this recipe, we will learn how to use C++ promises and futures. C++ `promise`
    is an argument to a C++ thread, while C++ `future` is the return value of the
    thread, and can be used to manually implement the same functionality of an `std::async`
    call. This recipe is important because a call to `std::aync` requires that each
    thread stops execution to get its result, while manually implementing a C++ `promise`
    and **`future`** allows the user to get the return value of a thread while the
    thread is still executing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何使用C++承诺和未来。C++ `promise`是C++线程的参数，而C++ `future`是线程的返回值，并且可以用于手动实现`std::async`调用的相同功能。这个配方很重要，因为对`std::aync`的调用要求每个线程停止执行以获取其结果，而手动实现C++
    `promise`和`future`允许用户在线程仍在执行时获取线程的返回值。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we begin, please ensure that all of the technical requirements are met,
    including installing Ubuntu 18.04 or higher and running the following in a terminal
    window:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new terminal. We will
    use this terminal to download, compile, and run our examples.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本配方中示例所需的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps to try this recipe:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个配方：
- en: 'From a new terminal, run the following to download the source code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To compile the source code, run the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，可以通过运行以下命令来执行本配方中的每个示例：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍每个示例，并解释每个示例程序的作用及其与本配方中所教授的课程的关系。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will learn how to manually use a C++ `promise` and `future`
    to provide a function that is executed in parallel with an argument, as well as
    get the function''s return value. To start, let''s demonstrate how this is done
    in its most simplistic form, with the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将学习如何手动使用C++ `promise`和`future`来提供一个并行执行带有参数的函数，并获取函数的返回值。首先，让我们演示如何以最简单的形式完成这个操作，使用以下代码：
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding example results in the following when executed:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的示例会产生以下结果：
- en: '![](img/5313a9ee-d6f1-449f-90df-069c182a2a80.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5313a9ee-d6f1-449f-90df-069c182a2a80.png)'
- en: As you can see in the preceding code, the C++ `promise` is an argument to the
    function that is threaded. The thread returns its value by setting the `promise`
    argument, which, in turn, sets a C++ `future` that the user can get from the `promise` argument
    it provides to the thread. It should be noted that we use `std::move()` to prevent
    the `promise` argument from being copied (which the compiler will prohibit as
    the C++ `promise` is a move-only class). Finally, we use the `get()` function
    to get the result of the thread, the same way you would get the result of a thread
    executed using `std::async`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的代码中所看到的，C++的`promise`是作为函数的参数进行线程化的。线程通过设置`promise`参数来返回其值，而`promise`又设置了一个C++的`future`，用户可以从提供给线程的`promise`参数中获取。需要注意的是，我们使用`std::move()`来防止`promise`参数被复制（编译器会禁止，因为C++的`promise`是一个只能移动的类）。最后，我们使用`get()`函数来获取线程的结果，就像使用`std::async`执行线程的结果一样。
- en: 'One of the benefits of using `promise` and `future` manually is that you can
    get the result of the thread before it completes, allowing the thread to continue
    to do work. For example, take a look at the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 手动使用`promise`和`future`的一个好处是，可以在线程完成之前获取线程的结果，从而允许线程继续工作。例如，看下面的例子：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This results in the following when executed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下结果：
- en: '![](img/af9f0ada-0fe3-4d17-9c75-52f61975d425.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af9f0ada-0fe3-4d17-9c75-52f61975d425.png)'
- en: In the preceding example, we created the same thread, but we looped forever
    in the thread, meaning the thread will never return. We then created the thread
    the same way, but outputted the result of the C++ `future` as soon as it was ready,
    which we can determine using the `wait()` function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了相同的线程，但在线程中无限循环，意味着线程永远不会返回。然后我们以相同的方式创建线程，但在C++的`future`准备好时立即输出结果，我们可以使用`wait()`函数来确定。
