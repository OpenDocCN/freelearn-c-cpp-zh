- en: 7\. Creating Modern Web Applications with ASP.NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 使用ASP.NET创建现代Web应用
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: There are many types of applications in use nowadays and web apps top the list
    of the most used ones. In this chapter, you will be introduced to ASP.NET, a web
    framework built with C# and the .NET runtime, made to create web apps with ease.
    You will also learn the anatomy of a basic ASP.NET application, web application
    development approaches such as server-side rendering and single-page applications,
    and how C# helps implement these approaches to build safe, performant, and scalable
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多类型的应用程序在使用，Web应用程序位居最常用的应用程序之列。在本章中，您将了解到ASP.NET，这是一个使用C#和.NET运行时构建的Web框架，旨在轻松创建Web应用程序。您还将了解基本ASP.NET应用程序的解剖学，服务器端渲染和单页应用程序等Web应用程序开发方法，以及C#如何帮助实现这些方法来构建安全、高性能和可扩展的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In *Chapter 1*, *Hello C#*, you learned that .NET is what brings C# to life,
    as it contains both a Software Development Kit (SDK) used to build your code and
    a runtime that executes the code. In this chapter, you will learn about ASP.NET,
    which is an open-source and cross-platform framework embedded within the .NET
    runtime. It is used for building applications for both frontend and backend applications
    for web, mobile, and IoT devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*你好C#*中，您了解到.NET是如何使C#生动起来的，因为它包含了用于构建代码的软件开发工具包（SDK）和执行代码的运行时。在本章中，您将了解ASP.NET，它是嵌入在.NET运行时中的开源跨平台框架。它用于构建Web、移动和物联网设备的前端和后端应用程序。
- en: It is a complete toolbox for these kinds of development, as it provides several
    built-in features, such as lightweight and customizable HTTP pipelines, dependency
    injection, and support for modern hosting technologies, such as containers, web
    UI pages, routing, and APIs. A well-known example is Stack Overflow; its architecture
    is built entirely on top of ASP.NET.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这类开发的完整工具箱，因为它提供了几个内置功能，如轻量级和可定制的HTTP管道、依赖注入以及对现代托管技术的支持，如容器、Web UI页面、路由和API。一个著名的例子是Stack
    Overflow；它的架构完全建立在ASP.NET之上。
- en: The focus of this chapter is to acquaint you with the fundamentals of ASP.NET
    and to give you both an introduction and an end-to-end overview of web application
    development with Razor Pages, a built-in toolbox included in ASP.NET to build
    web apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是让您熟悉ASP.NET的基础知识，并为您提供关于使用Razor Pages构建Web应用程序的介绍和全面概述，Razor Pages是ASP.NET中包含的内置工具箱。
- en: Anatomy of an ASP.NET Web App
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Web应用程序的解剖学
- en: You'll begin this chapter by creating a new Razor Pages application with ASP.NET.
    It is just one of the various types of apps that can be created with ASP.NET but
    will be an effective starting point as it shares and showcases a lot of commonalities
    with other web application types that can be built with the framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过使用ASP.NET创建一个新的Razor Pages应用程序来开始本章。这只是ASP.NET可以创建的各种类型应用程序之一，但作为起点是非常有效的，因为它与框架可以构建的其他Web应用程序类型共享并展示了许多共同点。
- en: 'To create a new Razor Pages app, enter the following commands in the CLI:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的Razor Pages应用程序，在CLI中输入以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here you are creating a to-do list application with Razor Pages. Once the preceding
    command is executed, you will see a folder with the following structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将使用Razor Pages创建一个待办事项列表应用程序。一旦执行了前面的命令，您将看到一个具有以下结构的文件夹：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the root folder in Visual Studio Code.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开根文件夹。
- en: 'There are some files inside these folders that will be covered in the upcoming
    sections. For now, consider this structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹中有一些文件将在接下来的部分中介绍。现在，考虑这个结构：
- en: '`bin` is the folder where the final binaries go after the application is built.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`是应用程序构建后最终二进制文件所在的文件夹。'
- en: '`obj` is the folder where the compiler places intermediate outputs during the
    build process.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj`是编译器在构建过程中放置中间输出的文件夹。'
- en: '`Pages` is the folder where the application Razor Pages will be placed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages`是应用程序Razor Pages将被放置的文件夹。'
- en: '`Properties` is a folder containing the `launchSettings.json` file, a file
    where the run configurations are placed. In this file, you can define some configuration
    for local run i.e., environment variables and application ports.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Properties`是一个包含`launchSettings.json`文件的文件夹，该文件用于放置运行配置。在此文件中，您可以定义一些本地运行的配置，例如环境变量和应用程序端口。'
- en: '`wwwroot` is the folder where all the static files of the application go.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wwwroot`是应用程序的所有静态文件所在的文件夹。'
- en: '`appsettings.json` is a configuration file.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json`是一个配置文件。'
- en: '`appsettings.Development.json` is a configuration file for the Development
    environment.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.Development.json`是用于开发环境的配置文件。'
- en: '`Program.cs` is the program class that you have seen since *Chapter 1*, *Hello
    C#*. It is the entry point of an application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.cs`是您自*第1章*，*你好C#*以来看到的程序类。它是应用程序的入口点。'
- en: Now that you know that in .NET 6.0, it is the `Program.cs` file, created at
    the root of the folder, that brings a `WebApplication` to life, you can begin
    to explore `Program.cs` in greater depth in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道在.NET 6.0中，是`Program.cs`文件，在文件夹的根目录创建，给`WebApplication`带来了生命，你可以在下一节深入探索`Program.cs`。
- en: Program.cs and the WebApplication
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Program.cs和WebApplication
- en: 'As mentioned earlier, `Program.cs` is the entry point of any C# application.
    In this section, you will see how a typical `Program` class is structured for
    an ASP.NET app. Consider the following example of `Program.cs`, which describes
    a very simple ASP.NET application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Program.cs`是任何C#应用程序的入口点。在本节中，您将看到一个典型的ASP.NET应用程序的`Program`类是如何构建的。考虑下面描述一个非常简单的ASP.NET应用程序的`Program.cs`的示例：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing done here is the creation of a `WebApplicationBuilder` object.
    This object contains everything that's needed to bootstrap a basic Web Application
    in ASP.NET—Configuration, Logging, DI, and Service Registration, Middlewares,
    and other Host configurations. This Host is the one responsible for the lifetime
    management of a web application; they set up a web server and a basic HTTP pipeline
    to process HTTP requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里做的第一件事是创建一个`WebApplicationBuilder`对象。这个对象包含了在ASP.NET中引导基本Web应用程序所需的一切——配置、日志、DI和服务注册、中间件和其他主机配置。这个主机负责Web应用程序的生命周期管理；它们设置了一个Web服务器和一个基本的HTTP管道来处理HTTP请求。
- en: As you can see, it is quite impressive how, in a few lines of code, so many
    things can be done that enable you to run a well-structured web application. ASP.NET
    does all of that so that you can focus on providing value through the functionalities
    you will build.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，用几行代码就可以完成许多事情，使您能够运行一个结构良好的Web应用程序。ASP.NET完成了所有这些工作，以便您可以专注于通过您将构建的功能提供价值。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bootstrap is a CSS library for the beautification of web content. You can know
    more about it at the official website.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是用于美化Web内容的CSS库。您可以在官方网站上了解更多信息。
- en: Middlewares
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Think of middleware as small pieces of applications that connect to each other
    to form a pipeline for handling HTTP requests and responses. Each piece is a component
    that can do some work either before or after another component is executed on
    the pipeline. They are also linked to each other through a `next()` call, as shown
    in *Figure 7.1*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间件视为连接在一起形成处理HTTP请求和响应的管道的小型应用程序片段。每个片段都是一个组件，可以在另一个组件在管道上执行之前或之后执行一些工作。它们也通过`next()`调用连接在一起，如*图7.1*所示：
- en: '![Figure 7.1: The Middleware for an HTTP pipeline'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：HTTP管道的中间件'
- en: '](img/B16835_07_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_01.jpg)'
- en: 'Figure 7.1: The Middleware for an HTTP pipeline'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：HTTP管道的中间件
- en: 'Middleware is a whole universe unto itself. The following list defines the
    salient features for building a web application:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件本身就是一个完整的宇宙。以下列表定义了构建Web应用程序的显著特点：
- en: The order in which the middleware is placed matters. As they are chained one
    after another, the placement of each component impacts the way the pipeline is processed.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件的放置顺序很重要。因为它们一个接一个地链接在一起，每个组件的放置方式都会影响管道的处理方式。
- en: The `before` logic, as shown in *Figure 7.1*, is executed until the endpoint
    is finally reached. Once the endpoint is reached, the pipeline continues to process
    the response using the `after` logic.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`逻辑，如*图7.1*所示，直到最终到达终点。一旦到达终点，管道将继续使用`after`逻辑处理响应。'
- en: '`next()` is a method call that will execute the next middleware in the pipeline,
    before executing the `after` logic of the current middleware.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()`是一个方法调用，将执行管道中的下一个中间件，然后执行当前中间件的`after`逻辑。'
- en: In ASP.NET applications, middleware can be defined in the `Program.cs` file
    after the `WebApplicationBuilder` calls the `Build` method with a `WebApplication?`
    object as a result of this operation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET应用程序中，中间件可以在`Program.cs`文件中定义，之后`WebApplicationBuilder`调用`Build`方法并使用`WebApplication?`对象作为此操作的结果。
- en: The application you created in the *Program.cs and the WebApplication* section,
    already contains a set of middlewares placed for new boilerplate Razor Pages applications
    that will be called sequentially when an **HTTP request** arrives.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Program.cs和WebApplication*部分创建的应用程序已经包含了一组中间件，用于新的样板Razor Pages应用程序，当**HTTP请求**到达时将按顺序调用。
- en: This is easily configurable because the `WebApplication` object contains a generic
    `UseMiddleware<T>` method. This method allows you to create middleware to embed
    into the HTTP pipeline for requests and responses. When used within the `Configure`
    method, each time the application receives an incoming request, this request will
    go through all the middleware in the order the requests are placed within the
    `Configure` method. By default, ASP.NET provides basic error handling, `autoredirection`
    to HTTPS, and serves static files, along with some basic routing and authorization.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易配置，因为`WebApplication`对象包含一个通用的`UseMiddleware<T>`方法。这个方法允许您创建中间件，嵌入到HTTP管道中处理请求和响应。当在`Configure`方法中使用时，每次应用程序接收到传入请求时，该请求将按照在`Configure`方法中放置请求的顺序经过所有中间件。默认情况下，ASP.NET提供基本的错误处理、自动重定向到HTTPS，并提供静态文件，以及一些基本的路由和授权。
- en: 'However, you might notice in your `Program.cs` file, of the *Program.cs and
    the WebApplication* section, there are no `UseMiddleware<>` calls. That''s because
    you can write extension methods to give a more concise name and readability to
    the code, and the ASP.NET framework already does it by default for some built-in
    middlewares. For instance, consider the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会注意到在您的`Program.cs`文件中，*Program.cs和WebApplication*部分中没有`UseMiddleware<>`调用。这是因为您可以编写扩展方法，为代码提供更简洁的名称和可读性，ASP.NET框架已经默认为一些内置中间件提供了这样的方法。例如，考虑以下示例：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, a sample of the built-in `UseHttpsRedirection` extension method is used
    for enabling a redirect middleware.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用了内置的`UseHttpsRedirection`扩展方法的示例，用于启用重定向中间件。
- en: Logging
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志
- en: Logging might be understood as the simple process of writing everything that
    is done by an application to an output. This output might be the console application,
    a file, or even a third-party logging monitor application, such as the ELK Stack
    or Grafana. Logging has an important place in assimilating the behavior of an
    application, especially with regard to error tracing. This makes it an important
    concept to learn.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 日志可能被理解为将应用程序执行的所有操作写入输出的简单过程。这个输出可以是控制台应用程序、文件，甚至是第三方日志监视应用程序，比如ELK Stack或Grafana。日志在吸收应用程序行为方面有重要地位，特别是在错误跟踪方面。这使得它成为一个重要的概念需要学习。
- en: One thing that enables ASP.NET to be an effective platform for enterprise applications
    is its modularity. Since it is built on top of abstractions, any new implementation
    can be easily done without loading too much into the framework. The **logging**
    abstractions are some of these.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使ASP.NET成为企业应用程序的有效平台之一的因素之一是其模块化。由于它是建立在抽象之上的，任何新的实现都可以很容易地完成，而不会对框架造成太大的负担。**日志**抽象就是其中之一。
- en: By default, the `WebApplication` object created in `Program.cs` adds some logging
    providers on top of these logging abstractions, which are `Console`, `Debug`,
    `EventSource`, and `EventLog`. The latter—`EventLog`—is an advanced feature specific
    to the Windows OS only. The focus here will be the `Console` logging provider.
    As the name suggests, this provider will output all the logged information to
    your application console. You'll learn more about it later in this section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在`Program.cs`中创建的`WebApplication`对象会在这些日志抽象之上添加一些日志提供程序，包括`Console`、`Debug`、`EventSource`和`EventLog`。后者——`EventLog`——是仅适用于Windows操作系统的高级功能。这里的重点将是`Console`日志提供程序。顾名思义，这个提供程序将把所有记录的信息输出到您的应用程序控制台。您将在本节的后面学到更多关于它的知识。
- en: 'As logs basically write everything your application does, you might wonder
    whether these logs will end up being huge, especially for large-scale apps. They
    might be, but an important thing while writing application logs is to grasp the
    **severity** of the log. There might be some information that is crucial to log,
    such as an unexpected exception. There might also be information that you would
    only like to log to a development environment, to know some behaviors better.
    That said, a log in .NET has seven possible log levels, which are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志基本上记录了应用程序的所有操作，您可能会想知道这些日志是否会变得非常庞大，特别是对于大型应用程序。它们可能会，但在编写应用程序日志时一个重要的事情是要理解日志的**严重性**。可能有一些需要记录的关键信息，比如意外异常。也可能有一些信息，您只想在开发环境中记录，以更好地了解一些行为。也就是说，在.NET中，日志有七个可能的级别，它们是：
- en: '`Trace` = 0'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`跟踪` = 0'
- en: '`Debug` = 1'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调试` = 1'
- en: '`Information` = 2'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信息` = 2'
- en: '`Warning` = 3'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告` = 3'
- en: '`Error` = 4'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误` = 4'
- en: '`Critical` = 5'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关键` = 5'
- en: '`None` = 6'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无` = 6'
- en: 'Which level is output to the provider is defined via variables set either as
    environment variables or via the `appSettings.json` file in the `Logging:LogLevel`
    section, as in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到提供程序的级别是通过设置环境变量或通过`appSettings.json`文件中的`Logging:LogLevel`部分来定义的，如下例所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this file, there are log categories, which are either the `Default` category
    or part of the namespace of the type that wants to set the log. That is exactly
    why these namespaces exist. For instance, you could set two different levels of
    logging for files inside the namespace.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，有日志类别，它们要么是`默认`类别，要么是想要设置日志的类型的命名空间的一部分。这正是这些命名空间存在的原因。例如，您可以为命名空间内的文件设置两个不同级别的日志记录。
- en: In the preceding example configuration, the entire `ToDoListApp` is a set namespace
    to write logs only with `LogLevel` equal to or higher than `Warning`. You are
    also specifying that, for the `ToDoListApp.Pages` category/ namespace, the application
    will write all logs with a level equal to or higher than `Information`. This means
    that the changes on a more specific namespace override the settings that were
    set at a higher level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例配置中，整个`ToDoListApp`是一个设置命名空间，只有`LogLevel`等于或高于`Warning`时才会写日志。您还指定了对于`ToDoListApp.Pages`类别/命名空间，应用程序将写入所有级别等于或高于`Information`的日志。这意味着更具体的命名空间上的更改会覆盖在更高级别设置的设置。
- en: This section showed you how to configure log levels for an application. With
    this knowledge, you can now grasp the concept of DI, as discussed in the following section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示了如何为应用程序配置日志级别。有了这个知识，您现在可以理解下一节中讨论的DI的概念。
- en: Dependency Injection
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency Injection (DI) is a technique supported natively by the ASP.NET framework.
    It is a form of achieving a famous concept in object-oriented programming called
    Inversion of Control (IoC).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是ASP.NET框架本身支持的一种技术。它是实现面向对象编程中著名概念控制反转（IoC）的一种形式。
- en: Any component that an object requires to function can be termed a dependency.
    In the case of a class, this might refer to parameters that need to be constructed.
    In the case of a method, it might be the method that parameters need for the execution.
    Using IoC with dependencies means delegating the responsibility of creating a
    class to the framework, instead of doing everything manually.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对象需要的任何组件都可以称为依赖关系。对于类来说，这可能指的是需要构造的参数。对于方法来说，可能是执行所需的方法。使用IoC与依赖关系意味着将创建类的责任委托给框架，而不是手动完成所有操作。
- en: 'In *Chapter 2*, *Building Quality Object-Oriented Code*, you learned about
    interfaces. Interfaces are basically a common form of establishing a contract.
    They allow you to focus on what the outcome is of a call, rather than how it is
    executed. When you use IoC, your dependencies can now be interfaces instead of
    concrete classes. This allows your classes or methods to focus on the contracts
    established by these interfaces, instead of implementation details. This brings
    the following advantages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*构建高质量的面向对象的代码*中，您学习了关于接口的知识。接口基本上是一种建立合同的常见形式。它们允许您专注于调用的结果，而不是它是如何执行的。当您使用IoC时，您的依赖关系现在可以是接口，而不是具体的类。这使得您的类或方法可以专注于这些接口建立的合同，而不是实现细节。这带来了以下优势：
- en: You can easily replace implementations without affecting any class that depends
    on the contracts.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松地替换实现，而不会影响任何依赖于合同的类。
- en: It decouples the application boundaries and modules, as the contracts usually
    do not need any hardened dependencies.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解耦了应用程序的边界和模块，因为合同通常不需要任何硬性依赖。
- en: It makes testing easier, allowing you to create these explicit dependencies
    as mocks, or fakes, and focus on behavior instead of real implementation details.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得测试变得更容易，允许您创建这些显式依赖关系作为模拟，或者伪造，并专注于行为而不是真正的实现细节。
- en: Imagine now that to create the middleware of your application, you need to construct
    each of their dependencies, and you have a lot of middleware chained to each other
    on the constructor. Clearly, this would be a cumbersome process. Also, testing
    any of this middleware would be a tedious process, as you would need to rely on
    every single concrete implementation to create an object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，要创建应用程序的中间件，您需要构造它们的每个依赖项，并且您在构造函数上有很多中间件链接在一起。显然，这将是一个繁琐的过程。此外，测试任何这些中间件都将是一个繁琐的过程，因为您需要依赖于每个具体的实现来创建一个对象。
- en: By injecting dependencies, you tell the compiler how to construct a class that
    has its dependencies declared on the constructor. The DI mechanism does this at
    runtime. This is equivalent to telling the compiler that whenever it finds a dependency
    of a certain type, it should resolve it using the appropriate class instance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入依赖项，您告诉编译器如何构造一个在构造函数上声明了其依赖项的类。DI 机制在运行时执行此操作。这相当于告诉编译器，每当它找到某种类型的依赖项时，它应该使用适当的类实例来解析它。
- en: ASP.NET provides a native DI container, which stores the information pertaining
    to how a type should be resolved. You'll next learn how to store this information
    in the container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 提供了一个本地的 DI 容器，它存储有关如何解析类型的信息。接下来，您将学习如何将此信息存储在容器中。
- en: In the `Program.cs` file, you'll see the call `builder.Services.AddRazorPages()`.
    The `Services` property is of type `IServiceCollection` and it holds the entire
    set of dependencies—also known as services—that is injected into the container.
    A lot of the required dependencies for an ASP.NET application to run are already
    injected in the `WebApplication.CreateBuilder(args)` method called at the top
    of the `Program.cs` file. This is true, for instance, for some native logging
    dependencies as you will see in the next exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，您将看到调用`builder.Services.AddRazorPages()`。`Services`属性是`IServiceCollection`类型，并且它保存了整套依赖项（也称为服务），这些依赖项被注入到容器中。用于
    ASP.NET 应用程序运行的许多所需依赖项已经在`Program.cs`文件顶部调用的`WebApplication.CreateBuilder(args)`方法中注入。例如，对于一些本地日志记录依赖项，您将在下一个练习中看到这一点。
- en: 'Exercise 7.01: Creating Custom Logging Middleware'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：创建自定义日志记录中间件
- en: In this exercise, you will create custom logging middleware that will output
    the details and the duration of an HTTP request to the console. After creating
    it, you will place it in the HTTP pipeline so that it is called by every request
    your application receives. The purpose is to give you a first practical introduction
    to the concepts of middleware, logging, and DI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建自定义的日志记录中间件，以便将 HTTP 请求的详细信息和持续时间输出到控制台。创建完成后，将其放置在 HTTP 管道中，以便它被应用程序接收到的每个请求调用。目的是让您对中间件、日志记录和
    DI 的概念有一个初步的实际介绍。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Create a new folder called `Middlewares`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Middlewares`的新文件夹。
- en: Inside this folder, create a new class named `RequestLoggingMiddleware`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中，创建一个名为`RequestLoggingMiddleware`的新类。
- en: 'Create a new private readonly field named `RequestDelegate` and initialize
    this field inside the constructor:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`RequestDelegate`的新私有只读字段，并在构造函数中初始化该字段：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the reference that ASP.NET gathers as the next middleware to be executed
    on the HTTP pipeline. By initializing this field, you can call the next registered
    middleware.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ASP.NET 收集的作为 HTTP 管道上要执行的下一个中间件的引用。通过初始化此字段，您可以调用下一个注册的中间件。
- en: 'Add a `using` statement to the `System.Diagnostics` namespace so that a special
    class named `Stopwatch` can be added It will be used to measure the request time
    length:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`using`语句到`System.Diagnostics`命名空间，以便可以添加一个名为`Stopwatch`的特殊类，它将用于测量请求的时间长度：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a private `readonly ILogger` field. The `ILogger` interface is the default
    interface provided by .NET to manually log information.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个私有的`readonly ILogger`字段。`ILogger`接口是.NET提供的手动记录信息的默认接口。
- en: After that, place a second parameter inside the constructor for the `ILoggerFactory`
    type. This interface is another one provided by .NET that allows you to create
    `ILogger` objects.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在构造函数中为`ILoggerFactory`类型添加第二个参数。这个接口是.NET提供的另一个接口，允许您创建`ILogger`对象。
- en: 'Use the `CreateLogger<T>` method from this factory to create a logger object:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此工厂的`CreateLogger<T>`方法创建一个记录器对象：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `T` is a generic parameter that refers to a type, which is the log category,
    as seen in the *Logging* section. In this case, the category will be the type
    of the class where the logging will be done that is, the `RequestLoggingMiddleware`
    class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`T`是一个泛型参数，指的是日志类别，如*Logging*部分所示。在这种情况下，类别将是进行日志记录的类的类型，即`RequestLoggingMiddleware`类。
- en: 'Once the fields have been initialized, create a new method with the following signature:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段初始化完成后，创建一个具有以下签名的新方法：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside this method, declare a variable called `Stopwatch` and assign the `Stopwatch.StartNew()`
    value to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法中，声明一个名为`Stopwatch`的变量，并将`Stopwatch.StartNew()`的值赋给它：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Stopwatch` class is a helper that measures the execution time from the
    moment the .`StartNew()` method is called.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch`类是一个辅助类，用于测量从调用`.StartNew()`方法开始的执行时间。'
- en: 'After this variable, write a `try-catch` block with code to call the next request
    as well as a call to the `.Stop()` method from the `stopwatch` to measure the
    elapsed time that the `_next()` call took:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此变量之后，编写一个带有代码的`try-catch`块，用于调用下一个请求，以及调用`stopwatch`的`.Stop()`方法来测量`_next()`调用所花费的时间：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also deal with a possible exception here. So, it is better to wrap these
    two calls inside a `try-catch` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在这里处理可能的异常。因此，最好将这两个调用包装在`try-catch`方法中。
- en: 'In the `Program.cs` file, call the custom middleware by placing the declaration
    as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，通过以下方式放置声明来调用自定义中间件：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Write it in the line right below where the `app` variable is assigned.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将其写在分配`app`变量的下一行。
- en: 'Finally, in the `Program.cs` file, place a `using` statement to `ToDoListApp.Middlewares`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Program.cs`文件中，添加一个`using`语句到`ToDoListApp.Middlewares`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To see the application running on your web browser and its output in the Visual
    Studio Code, type the following command at the address bar:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Web浏览器上看到应用程序运行和在Visual Studio Code中看到其输出，可以在地址栏中输入以下命令：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here `####` represents the port number. This would be different for different
     systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`####`代表端口号。这对于不同的系统来说是不同的。
- en: 'After pressing enter, the following screen gets displayed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下回车后，会显示以下屏幕：
- en: '![Figure 7.2: Application running on the browser'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2：应用程序在浏览器上运行'
- en: '](img/B16835_07_02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_02.jpg)'
- en: 'Figure 7.2: Application running on the browser'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：应用程序在浏览器上运行
- en: Perform *Step 13* each time after executing the exercise/ activity in VS Code.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中执行练习/活动后，每次执行*步骤13*。
- en: Press `Control+C` inside the VS code terminal to break the task before executing
    another exercise/ activity.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行另一个练习/活动之前，在VS Code终端内按下`Control+C`来中断任务。
- en: 'After executing the application in your browser, you''ll see a similar output
    in the Visual Studio Code terminal:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中执行应用程序后，您将在Visual Studio Code终端中看到类似的输出：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will observe that the output on the console logs messages with an elapsed
    time of HTTP requests coming in the middleware pipelines. Since you've declared
    it with your methods, it should take the execution time considering all the pipeline
    chains.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到控制台上的输出记录了中间件管道中HTTP请求的经过时间。由于您已经在方法中声明了它，它应该考虑所有管道链的执行时间。
- en: In this exercise, you created your first middleware—the `RequestLoggingMiddleware`.
    This middleware measures the execution time of an HTTP request, in your HTTP pipeline.
    By placing it right before all other middlewares, you will be able to measure
    the entire execution time of a request that goes through the entire middleware
    pipeline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了您的第一个中间件——`RequestLoggingMiddleware`。这个中间件测量了HTTP请求在您的HTTP管道中的执行时间。通过将它放在所有其他中间件之前，您将能够测量通过整个中间件管道的请求的整个执行时间。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/i04Iq](https://packt.link/i04Iq).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/i04Iq](https://packt.link/i04Iq)找到此练习使用的代码。
- en: Now imagine you have 10 to 20 middleware for the HTTP pipeline, each has its
    own dependencies, and you must manually instantiate each middleware. IoC comes
    in handy in such cases by delegating to ASP.NET the instantiation of these classes,
    as well as injecting their dependencies. You have already seen how to create custom
    middleware that uses the native ASP.NET logging mechanism with DI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您有10到20个中间件用于HTTP管道，每个中间件都有自己的依赖项，您必须手动实例化每个中间件。在这种情况下，IoC非常方便，通过委托给ASP.NET来实例化这些类，并注入它们的依赖项。您已经看到了如何创建使用本机ASP.NET日志机制和DI的自定义中间件。
- en: 'In ASP.NET, logging and DI are powerful mechanisms that allow you to create
    very detailed logs for an application. This is possible, as you''ve seen, through
    `logger` injection via constructors. For these loggers, you can create an object
    of a log category in two ways:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET中，日志记录和DI是强大的机制，允许您为应用程序创建非常详细的日志。正如您所见，通过构造函数注入`logger`实现了这一点。对于这些记录器，您可以通过两种方式创建一个日志类别的对象：
- en: As shown in the exercise, one way is the injection of `ILoggerFactory`. You
    could call the `CreateLogger(categoryName)` method, which receives a string as
    an argument. You could also call the `CreateLogger<CategoryType>()` method, which
    receives a generic type. This approach is preferable as it sets the category for
    the `logger` as the full name of the type (including the namespace).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如练习所示，一种方式是注入`ILoggerFactory`。您可以调用`CreateLogger(categoryName)`方法，该方法接收一个字符串作为参数。您还可以调用`CreateLogger<CategoryType>()`方法，该方法接收一个泛型类型。这种方法更可取，因为它将`logger`的类别设置为类型的完整名称（包括命名空间）。
- en: 'Another way would be through the injection of `ILogger<CategoryType>`. In this
    case, the category type is usually the type of the class where you are injecting
    the logger, as seen in the previous exercise. In the previous exercise, you could
    replace the injection of `ILoggerFactory` with `ILogger<RequestLoggingMiddleware>`
    and assign this new injected dependency directly to the `ILogger` private field
    as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方式是通过注入`ILogger<CategoryType>`。在这种情况下，类别类型通常是您注入记录器的类的类型，就像在上一个练习中看到的那样。在上一个练习中，您可以用`ILogger<RequestLoggingMiddleware>`替换`ILoggerFactory`的注入，并将这个新注入的依赖直接分配给`ILogger`私有字段，如下所示：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You now know that logging and DI are powerful mechanisms that allow you to create
    very detailed logs for an application. Before moving to Razor pages, it is important
    to learn about the life cycle of an object within an application. This is called
    the dependency lifetimes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道日志记录和DI是强大的机制，允许您为应用程序创建非常详细的日志。在转向Razor页面之前，了解应用程序中对象的生命周期是很重要的。这被称为依赖生命周期。
- en: Dependency Lifetimes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖生命周期
- en: 'Before moving on to the next and main topic of this chapter, it is important
    to talk about dependency lifetimes. All the dependencies used in the previous
    exercise were injected via the constructor. But the resolution of these dependencies
    was only possible because ASP.NET registers these dependencies beforehand, as
    mentioned in the `Program.cs` section. In the following code, you can see an example
    of code built into ASP.NET that deals with the logging dependency registration,
    by adding the `ILoggerFactory` dependency to the services container:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向本章的下一个主题之前，重要的是要谈论依赖生命周期。在上一个练习中使用的所有依赖项都是通过构造函数注入的。但是这些依赖项的解析之所以可能，是因为ASP.NET事先注册了这些依赖项，就像在`Program.cs`部分中提到的那样。在下面的代码中，您可以看到内置于ASP.NET中处理日志依赖注册的示例，通过向服务容器添加`ILoggerFactory`依赖项：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code is an example from a standard library and built into ASP.NET
    that deals with the logging dependency registration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个标准库和内置于ASP.NET中处理日志依赖注册的示例。
- en: 'A lot is going on here, but the two important things to consider are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做，但需要考虑的两个重要事项如下：
- en: The method here is `TryAdd`, which registers a dependency on the DI container.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的方法是`TryAdd`，它在DI容器中注册依赖项。
- en: The `ServiceDescriptor.Singleton` method is what defines a dependency lifetime.
    This is the final important concept of the *Dependency Injection* section of this
    chapter.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceDescriptor.Singleton`方法定义了依赖项的生命周期。这是本章*依赖注入*部分的最后一个重要概念。'
- en: 'A dependency lifetime describes the life cycle of an object within an application.
    ASP.NET has three default lifetimes that can be used to register a dependency:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项生命周期描述了应用程序中对象的生命周期。ASP.NET有三种默认生命周期可用于注册依赖项：
- en: 'Transient: Objects with this lifetime are created every time they are requested
    and disposed of after use. This is effective for stateless dependencies, which
    are dependencies that do not need to keep the state when they are called. For
    instance, if you need to connect to an HTTP API to request some information, you
    can register a dependency with this lifetime, since HTTP requests are stateless.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 瞬态：具有这种生命周期的对象在每次被请求时都会被创建，并在使用后被处理。这对于无状态依赖项非常有效，这些依赖项在被调用时不需要保持状态。例如，如果需要连接到HTTP
    API请求一些信息，可以使用这种生命周期注册依赖项，因为HTTP请求是无状态的。
- en: 'Scoped: Objects with a scoped lifetime are created once for each client connection.
    For instance, in an HTTP request, a scoped dependency will have the same instance
    for the entire request, no matter how many times it is called. This dependency
    carries some state around for a certain amount of time. At the end of the connection,
    the dependency is disposed of.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scoped：具有作用域生命周期的对象是为每个客户端连接创建一次。例如，在HTTP请求中，作用域依赖项将在整个请求期间具有相同的实例，无论调用多少次。这种依赖项在一定时间内携带一些状态。在连接结束时，依赖项被处理。
- en: 'Singleton: Objects with a singleton lifetime are created once for an entire
    application''s lifetime. Once they are requested, their instance will be carried
    on while the application is running. This kind of lifetime should be considered
    carefully as it might consume a lot of memory.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Singleton：具有单例生命周期的对象是在整个应用程序生命周期中创建一次。一旦它们被请求，它们的实例将在应用程序运行时被携带。这种生命周期应该仔细考虑，因为它可能消耗大量内存。
- en: As mentioned before, the manual registration of these dependencies can be done
    in the `ConfigureServices` method located in the `Startup` class. Every new dependency
    that is not provided and automatically registered by ASP.NET should be manually
    registered there and knowing about these lifetimes is important as they allow
    the application to manage the dependencies in different ways.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些依赖项的手动注册可以在`Startup`类中的`ConfigureServices`方法中完成。任何未由ASP.NET提供和自动注册的新依赖项都应在那里手动注册，了解这些生命周期很重要，因为它们允许应用程序以不同的方式管理依赖项。
- en: You have learned that the resolution of these dependencies was only possible
    because ASP.NET registers three default lifetimes that can be used to register
    a dependency. You will now move on to Razor pages that enable the construction
    of page-based applications with all the capabilities provided and powered by ASP.NET.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了这些依赖项的解析只有因为ASP.NET注册了三种默认的生命周期，可以用来注册依赖项。现在你将继续学习Razor页面，它可以构建基于页面的应用程序，并且具有由ASP.NET提供和支持的所有功能。
- en: Razor Pages
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor页面
- en: Now that you have covered the main aspects pertaining to an ASP.NET application,
    you'll continue to build the application that you started at the beginning of
    the chapter. The goal here is to build a to-do list application, where you can
    easily create and manage a list of tasks on a Kanban-style board.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经涵盖了与ASP.NET应用程序相关的主要方面，你将继续构建在本章开头开始的应用程序。这里的目标是构建一个待办事项列表应用程序，在这个Kanban风格的面板上，你可以轻松地创建和管理任务列表。
- en: Earlier sections have referenced Razor Pages, but what exactly is it? Razor
    Pages is a framework that enables the construction of page-based applications
    with all the capabilities provided and powered by ASP.NET. It was created to enable
    the building of dynamic data-driven applications with a clear separation of concerns
    that is, having each method and class with separate but complementary responsibilities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的部分提到了Razor页面，但它到底是什么？Razor页面是一个框架，可以构建基于页面的应用程序，并具有由ASP.NET提供和支持的所有功能。它被创建用于构建具有明确关注点分离的动态数据驱动应用程序，即每个方法和类具有单独但互补的责任。
- en: Basic Razor Syntax
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的Razor语法
- en: Razor Pages uses Razor syntax, a syntax powered by Microsoft that enables a
    page to have static HTML/ CSS/ JS, C# code, and custom tag helpers, which are
    reusable components that enable the rendering of HTML pieces in pages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Razor页面使用Razor语法，这是由Microsoft提供的一种语法，可以让页面具有静态HTML/CSS/JS、C#代码和自定义标签助手，这些是可重用的组件，可以在页面中渲染HTML片段。
- en: If you look at the `.cshtml` files generated by the `dotnet new` command that
    you ran in the first exercise, you will notice a lot of HTML code and, inside
    this code, some methods, and variables with a `@` prefix. In Razor, as soon as
    you write this symbol, the compiler detects that some C# code will be written.
    You're already aware that HTML is a markup language used to build web pages. Razor
    uses it along with C# to create powerful markup combined with server-rendered
    code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你在第一个练习中运行的`dotnet new`命令生成的`.cshtml`文件，你会注意到大量的HTML代码，以及在这些代码中带有`@`前缀的一些方法和变量。在Razor中，一旦你写下这个符号，编译器就会检测到将写入一些C#代码。你已经知道HTML是一种用于构建网页的标记语言。Razor与C#一起使用，创建强大的标记与服务器渲染的代码结合。
- en: 'If you want to place a block of code, it can be done within brackets like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要放置一块代码，可以用括号括起来，如：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside this block, you are allowed to do basically everything you can do with
    C# syntax, from local variable declarations to loops and more. If you want to
    put a `static @`, you have to escape it by placing two `@` symbols for it to be
    rendered in HTML. That happens, for instance, in email IDs, such as `james@@bond.com`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此块中，您可以做基本上可以使用C#语法做的任何事情，从局部变量声明到循环等等。如果要放置一个`static @`，您必须通过放置两个`@`符号来转义它，以便在HTML中呈现。例如，在电子邮件ID中会发生这种情况，例如`james@@bond.com`。
- en: File Structure
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件结构
- en: 'Razor Pages end with the `.cshtml` extension and might have another file, popularly
    called the `.cshtml.cs` extension. If you go to the root folder of your application
    and navigate to the `Pages` folder, you will see the following structure generated
    upon the creation of a page:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Razor页面以`.cshtml`扩展名结尾，可能还有另一个文件，通常称为`.cshtml.cs`扩展名。如果您转到应用程序的根文件夹并导航到`Pages`文件夹，您将看到在创建页面时生成的以下结构：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Index`, `Privacy`, and `Error` pages are automatically generated after
    project creation. Briefly look at the other files here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index`，`Privacy`和`Error`页面在项目创建后会自动生成。简要查看这里的其他文件。'
- en: 'The `/Shared` folder contains a shared `Layout` page that is used by default
    in the application. This page contains some shared sections, such as navbars,
    headers, footers, and metadata, that repeat in almost every application page:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Shared`文件夹包含一个默认在应用程序中使用的共享`Layout`页面。该页面包含一些共享部分，例如导航栏、标题、页脚和元数据，几乎在每个应用程序页面中都重复出现：'
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Keeping these shared sections in a single file makes reusability and maintainability
    easier. If you look at this `Layout` page generated in your boilerplate, there
    are some things worth highlighting:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些共享部分放在单个文件中使得可重用性和可维护性更容易。如果您查看在您的样板中生成的`Layout`页面，有一些值得注意的地方：
- en: By default, a Razor Pages app is generated using Twitter Bootstrap for design—a
    library used for writing beautiful, simple, and responsive websites—and jQuery
    for basic scripting. This can be customized for each application, as those are
    just static files.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Razor页面应用程序使用Twitter Bootstrap进行设计 - 用于编写美观、简单和响应式网站的库 - 和jQuery进行基本脚本编写。这可以根据每个应用程序进行自定义，因为这些只是静态文件。
- en: There is a special `RenderBody()` method that indicates where the generated
    HTML for the application pages will be placed.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个特殊的`RenderBody()`方法，指示应用程序页面的生成HTML将放置在哪里。
- en: Another method, named `RenderSection()`, is useful for rendering predefined
    sections per page. It is useful, for instance, when some static file, such as
    an image, script, or stylesheet, is needed only for some pages. In this way, you
    can place these files inside specific sections only in the pages where they are
    needed and call the `RenderSection` method at the level of the HTML you want them
    to be rendered. This is done on the `_Layout.cshtml` page.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个名为`RenderSection()`的方法，用于在每个页面上呈现预定义的部分。例如，当某些静态文件，例如图像、脚本或样式表，仅在某些页面上需要时，这是有用的。通过这种方式，您可以将这些文件放置在仅在需要它们的页面中的特定部分，并在您希望它们呈现的HTML级别调用`RenderSection`方法。这是在`_Layout.cshtml`页面上完成的。
- en: 'The `_ViewImports.cshtml` file is another important file; it enables the application
    pages to share common directives and reduces effort by placing these directives
    on every page. It is where all the global using namespaces, tag helpers, and global
    `Pages` namespaces are defined. Some of the directives this file supports are
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ViewImports.cshtml`文件是另一个重要文件；它使应用程序页面可以共享常见指令，并通过在每个页面上放置这些指令来减少工作量。其中定义了所有全局使用的命名空间、标签助手和全局`Pages`命名空间。该文件支持的一些指令如下：'
- en: '`@namespace`: Used to set the base namespace for `Pages`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@namespace`：用于为`Pages`设置基本命名空间。'
- en: '`@inject`: Used to place DI within the page.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inject`：用于在页面中放置依赖注入。'
- en: '`@model`: Includes `PageModel`, a class that will determine what information
    the page will handle.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@model`：包括`PageModel`，一个将确定页面将处理的信息的类。'
- en: '`@using`: Similar to the `.cs` files, this directive allows you to fully qualify
    namespaces at the top level of a Razor page to avoid repeating these namespaces
    throughout the code.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@using`：类似于`.cs`文件，此指令允许您在Razor页面的顶层完全限定命名空间，以避免在整个代码中重复这些命名空间。'
- en: The `_ViewStart.cshtml` file is used to place code that will be executed at
    the start of each page call. On this page, you define the `Layout` property while
    setting the `Layout` page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ViewStart.cshtml`文件用于放置将在每个页面调用开始时执行的代码。在此页面上，您定义`Layout`属性同时设置`Layout`页面。'
- en: Now that you are familiar with the basics of Razor Pages, it is time to start
    working on your application and dive into some more interesting topics. You will
    start by creating the basic structure of the to-do list application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了Razor页面的基础知识，是时候开始在您的应用程序上工作并深入一些更有趣的主题了。您将首先创建待办事项列表应用程序的基本结构。
- en: 'Exercise 7.02: Creating a Kanban Board with Razor'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02：使用Razor创建看板
- en: 'The goal of this exercise will be to start the to-do application creation with
    its first component—a Kanban board. This board is used for controlling workflows,
    where people can divide their work into cards and move these cards between different
    statuses, such as To Do, Doing, and Done. A popular application that uses this
    is Trello. The same `ToDoListApp` project created in the *Exercise 7.01* will
    be used throughout this chapter to learn new concepts and incrementally evolve
    the application, including in this exercise. Perform the following steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是开始创建待办事项应用程序的第一个组件 - 看板。该看板用于控制工作流程，人们可以将他们的工作分成卡片，并在不同状态之间移动这些卡片，例如待办、进行中和已完成。一个使用这种方法的流行应用是Trello。在*练习7.01*中创建的相同`ToDoListApp`项目将在本章中用于学习新概念并逐步发展应用程序，包括本练习。执行以下步骤：
- en: Navigate to the root folder of your application and create a folder named `Models`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到应用程序的根文件夹并创建一个名为`Models`的文件夹。
- en: 'Inside the `Models` folder, create a new `enum` called `ETaskStatus` with the
    `ToDo`, `Doing`, and `Done` options:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹中，创建一个名为`ETaskStatus`的新枚举，其中包括`ToDo`，`Doing`和`Done`选项：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, in the `Models` folder, create a new class called `ToDoTask` that will
    be used to create a new task for your to-do list with the following properties:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在 `Models` 文件夹中创建一个名为 `ToDoTask` 的新类，该类将用于为您的待办事项列表创建一个新任务，具有以下属性：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create two constructors as shown here for the `ToDoTask` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为 `ToDoTask` 类创建两个构造函数：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create one with no parameters to set the default values for the `Id` and `CreatedAt`
    properties, and the other with lowercase-named parameters for the preceding class
    to initialize the `Title` and `Status` properties.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个没有参数的构造函数，为 `Id` 和 `CreatedAt` 属性设置默认值，另一个使用小写命名参数的构造函数，用于初始化 `Title` 和
    `Status` 属性。
- en: The `Pages`/ `Index.cshtml` is automatically generated in your application boilerplate.
    It is this page that will be the entry point of your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages`/ `Index.cshtml` 是在您的应用程序样板中自动生成的。这个页面将是您的应用程序的入口点。'
- en: 'Now, customize it by editing the file `Pages`/ `Index.cshtml.cs` and replacing
    the boilerplate code with the code shown as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过编辑 `Pages`/ `Index.cshtml.cs` 文件并用以下代码替换样板代码来自定义它：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Basically, this code fills your model. Here, the `OnGet` method of `PageModel`
    is used to tell the application that when the page is loaded, it should fill the
    model with the properties assigned to `Task`
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这段代码填充了您的模型。在这里，`PageModel` 的 `OnGet` 方法用于告诉应用程序，当页面加载时，它应该用分配给 `Task` 的属性填充模型。
- en: 'Replace the code within `Pages`/ `Index.cshtml` with the code shown as follows
    in order to create your Kanban board with the task cards:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`Pages`/ `Index.cshtml`中的代码，以创建您的看板并添加任务卡：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This page is your view. It shares the properties from the `Pages`/ `Index.cshtml.cs`
    class (also called the code-behind class). When you assign a value to the `Tasks`
    property in the code-behind class, it becomes visible to the view. With this property,
    you can populate the HTML from the page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面是您的视图。它与 `Pages`/ `Index.cshtml.cs` 类（也称为代码后台类）共享属性。当您在代码后台类中为 `Tasks` 属性分配一个值时，它将对视图可见。通过这个属性，您可以填充页面的
    HTML。
- en: 'Now, run your application with the `dotnet run` command. You will see the following
    on the `Index` page when the application is loaded on the browser:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `dotnet run` 命令运行您的应用程序。当应用程序在浏览器上加载时，您将在 `Index` 页面上看到以下内容：
- en: '![Figure 7.3: Displaying your first application, the Kanban board'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：显示您的第一个应用程序，看板'
- en: '](img/B16835_07_03.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_03.jpg)'
- en: 'Figure 7.3: Displaying your first application, the Kanban board'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：显示您的第一个应用程序，看板
- en: Notice that, for now, the application does not contain any logic. What you built
    here is simply a UI powered by the `PageModel` data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前应用程序不包含任何逻辑。您在这里构建的只是一个由 `PageModel` 数据驱动的用户界面。
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/1PRdq](https://packt.link/1PRdq).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/1PRdq](https://packt.link/1PRdq)找到此练习中使用的代码。
- en: As you saw in *Exercise 7.02*, for every page created there are two main types
    of files which are a `.cshtml` and a `.cshtml.cs` file. These files form the foundations
    of each Razor page. The next section will detail about this difference in the
    filename suffix and how these two files complement each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*练习7.02*中所见，对于每个创建的页面，都有两种主要类型的文件，即 `.cshtml` 和 `.cshtml.cs` 文件。这些文件构成了每个
    Razor 页面的基础。下一节将详细介绍文件名后缀的区别以及这两个文件如何相互补充。
- en: PageModel
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageModel
- en: In the `Index.cshtml.cs` file that you created in *Exercise 7.02*, you might
    have noticed that the class inside it inherits from the `PageModel` class. Having
    this code-behind class provides some advantages—such as a clear separation of
    concerns between the client and the server—and this makes maintenance and development
    easier. It also enables you to create both unit and integration tests for the
    logic placed on the server. You will learn more about testing in *Chapter 10*,
    *Automated Testing*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在*练习7.02*中创建的 `Index.cshtml.cs` 文件中，您可能已经注意到其中的类继承自 `PageModel` 类。拥有这个代码后台类提供了一些优势——比如客户端和服务器之间的关注点清晰分离——这使得维护和开发更容易。它还使您能够为放置在服务器上的逻辑创建单元测试和集成测试。您将在*第10章*
    *自动化测试*中了解更多关于测试的内容。
- en: A `PageModel` may contain some properties that are bound to the view. In *Exercise
    7.02*, the `IndexModel` page has a property that is a `List<ToDoTask>`. This property
    is then populated when the page loads on the `OnGet()` method. So how does populating
    happen? The next section will discuss the life cycle of populating properties
    and using them within `PageModel`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageModel` 可能包含一些绑定到视图的属性。在*练习7.02*中，`IndexModel` 页面有一个 `List<ToDoTask>` 类型的属性。当页面在
    `OnGet()` 方法上加载时，这个属性就会被填充。那么填充是如何发生的呢？下一节将讨论填充属性的生命周期以及在 `PageModel` 中使用它们。'
- en: The Life Cycle with Page Handlers
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有页面处理程序的生命周期
- en: Handler methods are a core feature of Razor Pages. These methods are automatically
    executed when the server receives a request from the page. In *Exercise 7.02*,
    for instance, the `OnGet` method will be executed each time the page receives
    a `GET` request.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序方法是 Razor 页面的一个核心特性。当服务器接收到页面的请求时，这些方法会自动执行。例如，在*练习7.02*中，`OnGet` 方法将在每次页面接收到
    `GET` 请求时执行。
- en: By convention, the handler methods will answer according to the HTTP verb of
    the request. So, for instance, if you wanted something to be executed after a
    `POST` request, you should have an `OnPost` method. Also, after a `PUT` request,
    you should have an `OnPut` method. Each of these methods has an asynchronous equivalent,
    which changes the method's signature; an `Async` suffix is added to the method
    name, and it returns a `Task` property instead of `void`. This also makes the
    `await` functionality available for the method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照约定，处理程序方法将根据请求的 HTTP 动词进行响应。例如，如果您希望在 `POST` 请求之后执行某些操作，您应该有一个 `OnPost` 方法。同样，在
    `PUT` 请求之后，您应该有一个 `OnPut` 方法。每个方法都有一个异步等效方法，它改变了方法的签名；方法名称后面添加了 `Async` 后缀，并且返回一个
    `Task` 属性而不是 `void`。这也使得 `await` 功能对该方法可用。
- en: 'There is, however, one tricky scenario in which you may want a form to perform
    multiple actions with the same HTTP verb. In that case, you could perform some
    confusing logic on the backend to handle different inputs. Razor Pages, however,
    provides you with a functionality right out of the box called `asp-page-handler`
    that allows you to specify the name of the handler being called on the server.
    Tag helpers will be discussed in the next section, but for now, consider the following
    code as an example. The code contains an HTML form containing two submit buttons,
    to perform two different actions—one for creating an order, and the other for
    canceling an order:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种棘手的情况，您可能希望一个表单执行相同的HTTP动词进行多个操作。在这种情况下，您可能需要在后端执行一些混乱的逻辑来处理不同的输入。然而，Razor
    Pages为您提供了一个名为`asp-page-handler`的功能，允许您指定在服务器上调用的处理程序的名称。标签助手将在下一节中讨论，但现在，请将以下代码视为示例。该代码包含一个HTML表单，其中包含两个提交按钮，用于执行两个不同的操作——一个用于创建订单，另一个用于取消订单。
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the server side, you only need to have two handlers, one for each action,
    as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您只需要有两个处理程序，一个用于每个操作，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the code behind the page matches the value of the `form` method and the
    `asp-page-handler` tag on the `.cshtml` file to the method name on the code-behind
    file. That way, you can have multiple actions for the same HTTP verb in the same
    form.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，页面的代码与`.cshtml`文件上的`form`方法和`asp-page-handler`标签的值匹配到代码后台文件上的方法名称。这样，您可以在同一个表单中为相同的HTTP动词拥有多个操作。
- en: 'A final note on this subject is that in this case, the method name on the server
    should be written as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的最后一点是，在这种情况下，服务器上的方法名称应该写成：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is written with or without the `Async` suffix. In the previous example,
    the `OnPostPlaceOrderAsync` method is the `PlaceOrder` handler for the `PlaceOrder`
    button, and `OnPostCancelOrderAsync` is the handler for the `CancelOrder` button.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有或不带有`Async`后缀的。在前面的示例中，`OnPostPlaceOrderAsync`方法是`PlaceOrder`按钮的`PlaceOrder`处理程序，`OnPostCancelOrderAsync`是`CancelOrder`按钮的处理程序。
- en: Rendering Reusable Static Code with Tag Helpers
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签助手渲染可重用的静态代码
- en: One thing you might have noticed is that the HTML written previously is lengthy.
    You created Kanban cards, lists, and a board to wrap it all. If you take a closer
    look at the code, it has the same pattern repeated all the way through. That raises
    one major problem, maintenance. It is hard to imagine having to handle, maintain,
    and evolve all this plain text.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到以前编写的HTML很长。您创建了看板卡、列表和一个包装所有内容的看板。如果您仔细查看代码，会发现整个代码都是重复的相同模式。这带来了一个主要问题，即维护。很难想象要处理、维护和演变所有这些纯文本。
- en: Fortunately, tag helpers can be immensely useful in this regard. They are basically
    components that render static HTML code. ASP.NET has a set of built-in tag helpers
    with custom server-side attributes, such as anchors, forms, and images. Tag helpers
    are a core feature that helps make advanced concepts easy to handle, such as model
    binding, which will be discussed a little further ahead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标签助手在这方面可以极大地帮助。它们基本上是渲染静态HTML代码的组件。ASP.NET具有一组内置的标签助手，具有自定义服务器端属性，如锚点、表单和图像。标签助手是一个核心功能，有助于处理高级概念，如模型绑定，稍后将进一步讨论。
- en: Besides the fact that they add rendering capabilities to built-in HTML tags,
    they are also an impressive way to achieve reusability on static and repetitive
    code. In the next exercise, you will learn how to create a customized tag helper.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们为内置HTML标签添加了渲染功能之外，它们还是实现静态和重复代码可重用的一种令人印象深刻的方式。在下一个练习中，您将学习如何创建自定义标签助手。
- en: 'Exercise 7.03: Creating Reusable Components with Tag Helpers'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：使用标签助手创建可重用组件
- en: In this exercise, you are going to improve upon your work in the previous one.
    The improvement here will be to simplify the HTML code by moving part of this
    code that could be reused to custom tag helpers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将改进之前的工作。这里的改进将是通过将可重用的部分移动到自定义标签助手来简化HTML代码。
- en: 'To do so, perform the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请执行以下步骤：
- en: Open the `_ViewImports.cshtml` file, which was created with your application.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的应用程序创建的`_ViewImports.cshtml`文件。
- en: 'Add the following lines to the end with the content to define custom tag helpers
    `@addTagHelper` directive:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在末尾添加以下行来定义自定义标签助手的内容`@addTagHelper`指令：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, you added all the custom tag helpers that exist within
    this namespace using the asterisk (`*`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您使用星号（`*`）添加了此命名空间中存在的所有自定义标签助手。
- en: Now, create a new folder under the project's root (`ToDoApp`) called `TagHelpers`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录（`ToDoApp`）下创建一个名为`TagHelpers`的新文件夹。
- en: Create a new class inside this folder called `KanbanListTagHelper.cs`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内创建一个名为`KanbanListTagHelper.cs`的新类。
- en: 'Make this class inherit from the `TagHelper` class:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使这个类继承自`TagHelper`类：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This inheritance is what allows ASP.NET to identify both built-in and custom
    tag helpers.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种继承是ASP.NET识别内置和自定义标签助手的关键。
- en: 'Now place a `using` statement for the `Microsoft.AspNetCore.Razor.TagHelpers`
    namespace:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为`Microsoft.AspNetCore.Razor.TagHelpers`命名空间添加一个`using`语句：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For the `KanbanListTagHelper` class, create two string properties, called `Name`
    and `Size`, with getters and setters:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`KanbanListTagHelper`类，创建两个名为`Name`和`Size`的字符串属性，带有getter和setter：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Override the base asynchronous `ProcessAsync (TagHelperContext context`, `TagHelperOutput)`
    output method with the following code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码覆盖基本的异步`ProcessAsync（TagHelperContext context`，`TagHelperOutput）`输出方法：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Every tag helper has a standard HTML tag as an output. That is why, at the beginning
    of your methods, the `TagName` property was called from the `TagHelperOutput`
    object to specify the HTML tag that will be used as output. Additionally, you
    can set the attributes for this HTML tag by calling the `Attributes` property
    and its `SetAttribute` method from the `TagHelperOutput` object. That is what
    you did right after specifying the HTML output tag.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签助手都有一个标准的HTML标签作为输出。这就是为什么在你的方法开始时，从`TagHelperOutput`对象中调用`TagName`属性来指定将用作输出的HTML标签。此外，您可以通过从`TagHelperOutput`对象调用`Attributes`属性和其`SetAttribute`方法来设置此HTML标签的属性。这就是在指定HTML输出标签之后你所做的。
- en: 'Now, create another class named `KanbanCardTagHelper.cs` with the same inheritance
    and namespace using a statement such as the previous one:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个名为`KanbanCardTagHelper.cs`的类，使用相同的继承和命名空间，使用类似于之前的语句：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For this class, create a `string` property with public getters and setters named `Task.`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，创建一个具有公共getter和setter的`string`属性，名为`Task`。
- en: 'In this new class, override the base synchronous `Process(TagHelperContext
    context, TagHelperOutput output)` method. Within this method, write the following
    code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新类中，重写基本的同步`Process(TagHelperContext context, TagHelperOutput output)`方法。在这个方法中，编写以下代码：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An important concept to know about is how the HTML content is placed within
    the tag helper. As you can see, the code uses three different properties from
    the `TagHelperOutput` object to place the content:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的概念是要知道HTML内容如何放置在标签助手中。正如你所看到的，代码使用了`TagHelperOutput`对象的三个不同属性来放置内容：
- en: '`PreContent`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreContent`'
- en: '`Content`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`'
- en: '`PostContent`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostContent`'
- en: The pre-and post-properties are useful to set the content right before and after
    that you want to generate. A use case for them is when you want to set up fixed
    content as `div` containers, headers, and footers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 预和后属性对于设置生成的内容之前和之后非常有用。它们的一个用例是当您想要设置固定内容作为`div`容器、标题和页脚时。
- en: Another thing you did here was set how the tag helper will be rendered through
    the `Mode` property. You used `TagMode.StartTagAndEndTag` as a value because you
    used a `div` container as a tag output for the tag helper, and `div` elements
    have both start and end tags in HTML. If the output tag were some other HTML element,
    such as email, which is self-closing, you would use `TagMode.SelfClosing` instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里做的另一件事是设置标签助手将通过`Mode`属性呈现的方式。您使用了`TagMode.StartTagAndEndTag`作为值，因为您使用`div`容器作为标签助手的输出标签，并且`div`元素在HTML中既有开始标签又有结束标签。如果输出标签是其他HTML元素，例如email，它是自闭合的，那么您将使用`TagMode.SelfClosing`。
- en: 'Finally, go to the `Index.cshtml` file under the Pages folder and replace the
    HTML created in *Exercise 7.02* with the tag helpers to make your code concise:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，转到Pages文件夹下的`Index.cshtml`文件，并用标签助手替换*练习7.02*中创建的HTML，使您的代码更加简洁：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now run the application with the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下命令运行应用程序：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In your browser, navigate to the localhost:#### address provided by the Visual
    Studio console output just like you did in the last exercise:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中，导航到Visual Studio控制台输出提供的localhost:####地址，就像您在上一个练习中所做的那样：
- en: '![Figure 7.4: The frontend displayed in the browser'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：浏览器中显示的前端'
- en: '](img/B16835_07_04.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_04.jpg)'
- en: 'Figure 7.4: The frontend displayed in the browser'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：浏览器中显示的前端
- en: You will see the same result at the frontend that you had before, as shown in
    *Figure 7.3*. The improvement is in the fact that even though the output is the
    same, you have now a much more modular and concise code to maintain and evolve.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在前端看到与之前相同的结果，如*图7.3*所示。改进之处在于，即使输出相同，您现在有一个更模块化和简洁的代码来维护和发展。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/YEdiU](https://packt.link/YEdiU).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/YEdiU](https://packt.link/YEdiU)找到此练习中使用的代码。
- en: In this exercise, you used tag helpers to create reusable components that generate
    static HTML code. You can see now that the HTML code is much cleaner and more
    concise. The next section will detail about creating interactive pages by linking
    what's on the Code Behind with your HTML view using the concept of model binding.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用标签助手创建了可重用的组件，生成静态HTML代码。现在您可以看到HTML代码更加清晰和简洁。下一节将详细介绍通过将Code Behind上的内容与HTML视图链接起来，使用模型绑定的概念来创建交互式页面。
- en: Model Binding
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型绑定
- en: 'So far, you have covered concepts that helped create a foundation for the to-do
    app. As a quick recap, the main points are as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经涵盖了帮助创建待办事项应用程序的基础概念。简要回顾一下，主要要点如下：
- en: '`PageModel` is used to add data to a page.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageModel`用于向页面添加数据。'
- en: Tag helpers add custom static rendering to the HTML generated by the server.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签助手为服务器生成的HTML添加了自定义静态呈现。
- en: Handler methods define the way a page interacts with an HTTP request.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序方法定义了页面与HTTP请求交互的方式。
- en: One final overarching concept that is central to building Razor Pages applications
    is model binding. The data used as arguments in handler methods and passed through
    the page model is rendered through this mechanism. It consists of extracting data
    in key/ value pairs from HTTP requests and placing them in either the client-side
    HTML or the server-side code, depending on the direction of the binding that is,
    whether the data is moving from client to server or from server to client.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Razor Pages应用程序的一个最终的概念是模型绑定。在处理程序方法中使用的数据以及通过页面模型传递的数据都是通过这种机制呈现的。它包括从HTTP请求中提取数据的键/值对，并将它们放置在客户端HTML或服务器端代码中，具体取决于绑定的方向，即数据是从客户端到服务器还是从服务器到客户端。
- en: This data might be placed in routes, forms, or query strings and is binding
    to .NET types, either primitive or complex. *Exercise 7.04* will help clarify
    how the model binding works when coming from the client to the server.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可能放置在路由、表单或查询字符串中，并绑定到.NET类型，可以是原始的或复杂的。*练习7.04*将帮助澄清模型绑定是如何从客户端到服务器的工作的。
- en: 'Exercise 7.04: Creating a New Page to Submit Tasks'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.04：创建一个新页面来提交任务
- en: 'The goal of this exercise is to create a new page. It will be used to create
    new tasks that will be displayed on the Kanban board. Perform the following steps
    to complete this exercise:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目标是创建一个新页面。它将用于创建新的任务，这些任务将显示在看板上。执行以下步骤来完成这个练习：
- en: 'Inside the project root folder, run the following commands:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根文件夹中，运行以下命令：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At the root of the project, create a new folder named `Data` with a `ToDoDbContext`
    class inside it. This class will inherit from Entity Framework's `DbContext` and
    will be used to access the database.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下，创建一个名为`Data`的新文件夹，并在其中放置一个`ToDoDbContext`类。这个类将继承自Entity Framework的`DbContext`，并将用于访问数据库。
- en: 'Now add the following code in it:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在其中添加以下代码：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Update your `Program.cs` file to match the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`Program.cs`文件以匹配以下内容：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This change will register the `DbContext` dependencies within the DI container,
    as well as sets up the database access.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将在DI容器中注册`DbContext`依赖项，并设置数据库访问。
- en: 'Run the following commands on the terminal to install the `dotnet ef` tool.
    This is a CLI tool that will help you to iterate with database helpers, such as
    schema creation and update:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上运行以下命令以安装`dotnet ef`工具。这是一个CLI工具，将帮助您与数据库助手进行迭代，例如模式创建和更新：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, build the application and run the following commands on the terminal:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建应用程序并在终端上运行以下命令：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These commands will create a new migration that will create the schema from
    your database and apply this migration to your database.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将创建一个新的迁移，该迁移将从您的数据库创建模式，并将此迁移应用到您的数据库。
- en: After the migration has run and the database is updated, create a new folder
    called `Tasks` inside the `Pages` folder.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移运行并且数据库更新后，在`Pages`文件夹内创建一个名为`Tasks`的新文件夹。
- en: Move the Index page files—`index.cshtml` and `index.cshtml.cs`—to the `Tasks`
    folder.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Index页面文件`index.cshtml`和`index.cshtml.cs`移动到`Tasks`文件夹中。
- en: 'Next, replace the `AddRazorPages` call in the `Program.cs` with the following call:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Program.cs`中用以下调用替换`AddRazorPages`调用：
- en: '[PRE49]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will add a convention for the page routes to be called.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加一个页面路由的约定。
- en: 'Replace the header tag inside the `_Layout.cshtml` file (under `Pages/Shared/`)
    to create a shared `navbar` for the application:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换`_Layout.cshtml`文件（在`Pages/Shared/`下）中的标题标签，以创建应用程序的共享`navbar`：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `navbar` will allow you to access the newly created page.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`navbar`将允许您访问新创建的页面。
- en: 'Create the `Create.cshtml` page (under `Pages/Tasks/`) and add the following
    code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Create.cshtml`页面（在`Pages/Tasks/`下）并添加以下代码：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This should contain a form that will use a `PageModel` class to create the new
    tasks. For each form input field, an `asp-for` attribute is used inside the `input`
    tag helper. This attribute is responsible for filling the HTML input with a proper
    value in the `name` attribute.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该包含一个表单，将使用`PageModel`类来创建新的任务。对于每个表单输入字段，在`input`标签助手内部使用`asp-for`属性。该属性负责在`name`属性中填充HTML输入的正确值。
- en: 'Since you are binding to a complex property inside the page model named `Task`,
    the name value is generated with the following syntax:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在绑定到页面模型内的复杂属性`Task`，因此名称值是使用以下语法生成的：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here `PREFIX` is the complex object name on the `PageModel`. So, for an ID of
    a task, an input with `name="Task_Id"` is generated on the client-side and the
    input is populated with the `value` attribute having the `Task.Id` property value
    that comes from the server. In the case of the page, as you are creating a new
    task, the field does not come previously populated. That is because with the `OnGet`
    method you assigned a new object to the `Task` property of the `PageModel` class.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`PREFIX`是`PageModel`上的复杂对象名称。因此，对于任务的ID，客户端会生成一个带有`name="Task_Id"`的输入，并且该输入会使用`value`属性填充，该属性具有来自服务器的`Task.Id`属性值。在页面的情况下，由于您正在创建一个新任务，该字段不会预先填充。这是因为在`OnGet`方法中，您为`PageModel`类的`Task`属性分配了一个新对象。
- en: 'Now, create the code-behind page, named `CreateModel.cshtml.cs` (placed in
    `Pages/Tasks/`):'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建名为`CreateModel.cshtml.cs`的代码后台页面（放在`Pages/Tasks/`中）：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When posting a form, all the values inside the form are placed in the incoming
    `HttpRequest`. The call to `TryUpdateModelAsync` tries to populate an object with
    these values that the request brought from the client-side. Since the form is
    created with the `name` attribute in the input element with the format that has
    been explained previously, this method knows how to extract these values and bind
    them to the object. Put simply, that is the magic behind model binding.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 提交表单时，表单中的所有值都放在传入的`HttpRequest`中。对`TryUpdateModelAsync`的调用尝试使用这些值填充对象，该对象是请求从客户端带来的。由于表单是使用输入元素中的`name`属性创建的，该方法知道如何提取这些值并将它们绑定到对象。简而言之，这就是模型绑定背后的魔力。
- en: 'Now, replace the code of `Index.cshtml` (under `Pages/Tasks/`) with the following:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换`Index.cshtml`（在`Pages/Tasks/`下）的代码：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code adds a section that introduces an alert to be displayed if there is
    an entry with the `SuccessMessage` key in the `TempData` dictionary.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个部分，如果`TempData`字典中存在`SuccessMessage`键的条目，则会显示一个警报。
- en: 'Finally, add some display and validation rules via data annotations to the
    `Models/ToDoTask.cs` class properties:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过数据注释为`Models/ToDoTask.cs`类的属性添加一些显示和验证规则：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here the `Required` data annotation over the property is to ensure that this
    property is set with a valid value. In this exercise, you added persistence with
    Entity Framework Core and SQLite and created a new page that creates a task for
    the to-do application, finally saving it into the database.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对属性使用`Required`数据注释是为了确保该属性设置为有效值。在这个练习中，您使用Entity Framework Core和SQLite添加了持久性，并创建了一个为待办应用程序创建任务的新页面，最终将其保存到数据库中。
- en: Now run the code in VS Code.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在VS Code中运行代码。
- en: 'To see the output on your web browser, type the following command on the address
    bar:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Web浏览器中查看输出，请在地址栏中键入以下命令：
- en: '[PRE60]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here `####` represents the port number. This would be different for different systems.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`####`代表端口号。这对不同的系统来说是不同的。
- en: 'After pressing enter, the following screen is displayed:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键后，将显示以下屏幕：
- en: '![Figure 7.5: Home page with Create Task button in the navigation bar'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：导航栏中带有创建任务按钮的主页'
- en: '](img/B16835_07_05.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_05.jpg)'
- en: 'Figure 7.5: Home page with Create Task button in the navigation bar'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：导航栏中带有创建任务按钮的主页
- en: 'Click on the `Create Task` button, and you''ll see the page you just created
    to insert new cards into your Kanban Board:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`创建任务`按钮，您将看到刚刚创建的页面，可以在其中向您的看板添加新卡片：
- en: '![Figure 7.6: The Create Task page'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：创建任务页面'
- en: '](img/B16835_07_06.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_06.jpg)'
- en: 'Figure 7.6: The Create Task page'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：创建任务页面
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/3FPaG](https://packt.link/3FPaG).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/3FPaG](https://packt.link/3FPaG)找到此练习中使用的代码。
- en: Now, you'll take a deep dive into how model binding brings it all together,
    enabling you to transport data back and forth between the client and the server.
    You will also know more about validations in the next section.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将深入了解模型绑定如何将所有内容整合在一起，使您能够在客户端和服务器之间传输数据。您还将在下一节中了解更多关于验证的内容。
- en: Validation
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Validating data is something you will often need to do while developing an application.
    Validating a field may either mean that it is a required field or that it should
    follow a specific format. An important thing you may have noticed in the final
    part of the previous exercise is that you placed some `[Required]` attributes
    on top of some model properties in the final step of the last exercise. Those
    attributes are called data annotations and are used to create server-side validations.
    Moreover, you can add some client-side validation combined with this technique.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 验证数据是您在开发应用程序时经常需要执行的操作。验证字段可能意味着它是一个必填字段，或者它应该遵循特定格式。您可能已经注意到在上一个练习的最后部分中，您在最后一步中的某些模型属性顶部放置了一些`[Required]`属性。这些属性称为数据注释，用于创建服务器端验证。此外，您可以结合此技术添加一些客户端验证。
- en: Note that in *Step 10* of *Exercise 7.04*, the frontend has some span tag helpers
    with an `asp-validation-for` attribute pointing to the model properties. There
    is one thing that binds this all together—the inclusion of the `_ValidationScriptsPartial.cshtml`
    partial page. Partial pages are a subject discussed in the next section, but for
    now, it is enough to know that they are pages that can be reused inside other
    ones. The one just mentioned includes default validation for the pages.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*练习7.04*的*步骤10*中，前端具有一些span标签助手，其中`asp-validation-for`属性指向模型属性。有一件事将所有这些联系在一起——包含`_ValidationScriptsPartial.cshtml`部分页面。部分页面是下一节讨论的主题，但目前只需知道它们是可以在其他页面内重用的页面。刚才提到的页面包含页面的默认验证。
- en: With those three placed together (that is, the required annotation, the `asp-validation-for`
    tag helper, and the `ValidationScriptsPartial` page), validation logic is created
    on the client-side that prevents the form from being submitted with invalid values.
    If you want to perform the validation on the server, you could use the built-in
    `TryValidateModel` method, passing the model to be validated.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个元素放在一起（即必需注释、`asp-validation-for`标签助手和`ValidationScriptsPartial`页面），就在客户端创建了验证逻辑，防止使用无效值提交表单。如果要在服务器上执行验证，可以使用内置的`TryValidateModel`方法，将要验证的模型传递给它。
- en: Dynamic Behavior with Partial Pages
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态行为与部分页面
- en: So far, you have built a board to display tasks and a way to create and edit
    them. Still, there is one major feature for a to-do application that needs adding—a
    way to move tasks across the board. You can start as simple as moving one way
    only—from to-do to doing, and from doing to done.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经构建了一个显示任务和创建和编辑任务的看板。但是，对于待办事项应用程序来说，还有一个重要功能需要添加——一种在看板上移动任务的方法。您可以从简单的一种方式开始——从待办到进行中，从进行中到已完成。
- en: Until now, your task cards were built using tag helpers. However, tag helpers
    are rendered as `static` components and do not allow any dynamic behavior to be
    added during rendering. You could add tag helpers directly to your page, but you
    would have to repeat it for every board list. That is exactly where a major Razor
    Pages feature comes into play and that is Partial Pages. They allow you to create
    reusable page code snippets in smaller pieces. That way, you can share the base
    page dynamic utilities and still avoid duplicate code in your application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的任务卡是使用标签助手构建的。但是，标签助手被呈现为`静态`组件，并且在呈现过程中不允许添加任何动态行为。您可以直接将标签助手添加到页面，但是您必须为每个看板列表重复此操作。这正是Razor
    Pages的一个重要功能发挥作用的地方，即部分页面。它们允许您以较小的片段创建可重用的页面代码片段。这样，您可以共享基本页面动态实用程序，同时避免在应用程序中重复代码。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本节的理论部分。在下一节中，您将通过练习将其付诸实践。
- en: 'Exercise 7.05: Refactoring a Tag Helper to a Partial Page with Custom Logic'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.05：将标签助手重构为具有自定义逻辑的部分页面
- en: 'In this exercise, you will create a partial page to replace `KanbanCardTagHelper`
    and add some dynamic behavior to your task''s cards, such as changing content
    based on custom logic. You will see how partial pages help in reducing duplicate
    code and make it more easily reusable. Perform the following steps to complete
    this exercise:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您将创建一个部分页面来替换`KanbanCardTagHelper`，并为您的任务卡添加一些动态行为，例如根据自定义逻辑更改内容。您将看到部分页面如何帮助减少重复代码并使其更容易重用。执行以下步骤以完成此练习：
- en: 'Inside the `Pages/Tasks` folder, create a new file called `_TaskItem.cshtml`
    with the following content:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pages/Tasks`文件夹中，创建一个名为`_TaskItem.cshtml`的新文件，内容如下：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `_TaskItem.cshtml` is basically a partial page that contains the `.cshtml`
    code of a card from the Kanban board.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`_TaskItem.cshtml`基本上是一个包含看板卡片的`.cshtml`代码的部分页面。'
- en: 'Now, replace the code within the `Index.cshtml.cs` file with the following
    code that can read the saved tasks from the database and place the actions you
    created on the partial page:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下代码替换`Index.cshtml.cs`文件中的代码，该代码可以从数据库中读取保存的任务，并将您在部分页面上创建的操作放置在其中：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code creates handler methods for the three HTTP requests—a GET request
    and two POST requests. It also places the logic to be executed on these handlers.
    You will read values from the database with GET and save them back with POST.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了三个HTTP请求的处理程序方法——一个GET请求和两个POST请求。它还放置了要在这些处理程序上执行的逻辑。您将从数据库中读取值并用POST将其保存回去。
- en: 'Finally, update the `Index.cshtml` page with the following code to replace
    the use of tag helpers by the partial Razor page with your Kanban cards:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下代码更新`Index.cshtml`页面，以替换标记助手的使用，使用您的看板卡的部分Razor页面：
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Doing so, you'll notice how much duplicate code gets eliminated.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，您将注意到有多少重复代码被消除了。
- en: 'Now run the application with the following command:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下命令运行应用程序：
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next click at the Create Task button and fill the form. After a Task is created,
    you'll see a confirmation message, as shown in *Figure 7.7*.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来点击“创建任务”按钮并填写表单。创建任务后，您将看到确认消息，如*图7.7*所示。
- en: '![Figure 7.7: The Home screen after a Task creation'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：创建任务后的主屏幕'
- en: '](img/B16835_07_07.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_07.jpg)'
- en: 'Figure 7.7: The Home screen after a Task creation'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：创建任务后的主屏幕
- en: Note
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have created some tasks in the previous screen, the screen display might
    be different on your system.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在上一个屏幕上创建了一些任务，则您的系统上的屏幕显示可能会有所不同。
- en: In this exercise, you created an almost fully functional to-do application in
    which you can create tasks and save them to the database, and even log your requests
    to see how long they take.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了一个几乎完全功能的待办事项应用程序，您可以在其中创建任务并将其保存到数据库中，甚至记录您的请求以查看它们花费了多长时间。
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/VVT4M](https://packt.link/VVT4M).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/VVT4M](https://packt.link/VVT4M)找到此练习使用的代码。
- en: Now, it is time to work on an enhanced feature through an activity.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过一个活动来增强功能了。
- en: 'Activity 7.01: Creating a Page to Edit an Existing Task'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：创建页面以编辑现有任务
- en: Now it's time to enhance the previous exercise with a new and fundamental feature
    that is, to move tasks across the Kanban board. You must build this application
    using the concepts covered in this chapter such as model binding, tag helpers,
    partial pages, and DI.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过一个新的基本功能来增强之前的练习，即在看板上移动任务。您必须使用本章涵盖的概念构建此应用程序，例如模型绑定、标记助手、部分页面和DI。
- en: 'To complete this activity, you need to add a page to edit the tasks. The following
    steps will help you complete this activity:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，您需要添加一个页面来编辑任务。以下步骤将帮助您完成此活动：
- en: Create a new file called `Edit.cshtml` with the same form as `Create.cshtml`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Edit.cshtml`的新文件，其表单与`Create.cshtml`相同。
- en: Change the route at the page directive to receive `"/tasks/{id}"`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面指令中的路由更改为接收`"/tasks/{id}"`。
- en: Create the code-behind file that loads a task by the `OnGet ID` from the `DbContext`
    schema. If the ID does not return a task, redirect it to the `Create` page.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建代码后端文件，通过`DbContext`模式的`OnGet ID`加载任务。如果ID没有返回任务，则将其重定向到`Create`页面。
- en: On the Post form, recover the task from the database, update its values, send
    a success message, and redirect to the Index view afterward.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Post表单上，从数据库中恢复任务，更新其值，发送成功消息，然后重定向到Index视图。
- en: 'The output of a page is displayed as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的输出如下所示：
- en: '![Figure 7.8: The Edit Task Page as output to the activity'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：作为活动输出的编辑任务页面'
- en: '](img/B16835_07_08.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_08.jpg)'
- en: 'Figure 7.8: The Edit Task Page as output to the activity'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：作为活动输出的编辑任务页面
- en: Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: With the examples and activity so far, you now know how to develop pages with
    Razor. In the next section, you will learn how to work with a tool that has an
    even smaller scope of isolated and reusable logic called view components.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迄今为止的示例和活动，您现在知道如何使用Razor开发页面。在下一节中，您将学习如何使用一个具有更小范围的隔离和可重用逻辑的工具，即视图组件。
- en: View Components
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图组件
- en: So far, you have seen two ways of creating reusable components to provide better
    maintenance and reduce the amount of code and that is tag helpers and partial
    pages. While a tag helper produces mainly static HTML code (as it translates a
    custom tag into an existing HTML tag with some content inside it), a `partial
    page` is a small Razor page inside another Razor page that shares the page data-binding
    mechanism and can perform some actions such as form submission. The only downside
    to `partial pages` is that the dynamic behavior relies on the page that contains
    it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了两种创建可重用组件的方法，以提供更好的维护并减少代码量，即标记助手和部分页面。虽然标记助手主要生成静态HTML代码（因为它将自定义标记转换为带有一些内容的现有HTML标记），但`部分页面`是另一个Razor页面，它共享页面数据绑定机制，并且可以执行一些操作，例如表单提交。`部分页面`唯一的缺点是其动态行为依赖于包含它的页面。
- en: This section is about another tool that allows you to create reusable components
    that is, view components. View components are somewhat similar to partial pages,
    as they also allow you to provide dynamic functionality and have logic on the
    backend. However, they are even more powerful as they are self-contained. This
    self-containment allows them to be developed independently of the page and be
    fully testable on their own.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了另一种工具，允许您创建可重用组件，即视图组件。视图组件与部分页面有些相似，因为它们也允许您提供动态功能并在后端具有逻辑。但是，它们更加强大，因为它们是自包含的。这种自包含性使它们能够独立于页面开发，并且可以完全在其自身上进行测试。
- en: 'There are several requirements for creating view components, as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图组件有几个要求，如下所示：
- en: The custom component class must inherit from `Microsoft.AspNetCore.Mvc.ViewComponent`.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件类必须继承自`Microsoft.AspNetCore.Mvc.ViewComponent`。
- en: It must either have the `ViewComponent` suffix in the class name or be decorated
    with the `[ViewComponent]` attribute.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在类名中具有“ViewComponent”后缀，或者用“[ViewComponent]”属性进行修饰。
- en: This class must implement either a `IViewComponentResult Invoke()` synchronous
    method or a `Task<IViewComponentResult> InvokeAsync()` asynchronous method (when
    you need to call async methods from within).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类必须实现一个`IViewComponentResult Invoke()`同步方法或一个`Task<IViewComponentResult> InvokeAsync()`异步方法（当您需要从中调用异步方法时）。
- en: The result of both previous methods is typically the `View(model)` method with
    the view component model as an argument. On the frontend, the default view filename
    should, by convention, be called `Default.cshtml`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两种方法的结果通常是`View(model)`方法，其中视图组件模型作为参数。在前端，默认视图文件名应按照惯例称为`Default.cshtml`。
- en: For the view to be rendered, it must be located in either `Pages/Components/{MY_COMPONENT_NAME}/Default.cshtml`
    or `/Views/Shared/Components/{MY_COMPONENT_NAME}/Default.cshtml`.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了渲染视图，它必须位于`Pages/Components/{MY_COMPONENT_NAME}/Default.cshtml`或`/Views/Shared/Components/{MY_COMPONENT_NAME}/Default.cshtml`中。
- en: If not located in any of the preceding paths, the location of the view must
    be explicitly passed as an argument on the `View` method returned in the `Invoke`
    or `InvokeAsync` methods.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不位于前述路径中的任何位置，则必须在`Invoke`或`InvokeAsync`方法中返回的`View`方法的参数中显式传递视图的位置。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本节的理论部分。在接下来的部分中，您将通过一个练习将这些理论付诸实践。
- en: 'Exercise 7.06: Creating a View Component to Display Task Statistics'
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.06：创建一个视图组件来显示任务统计
- en: 'In this exercise, you will create a view component that allows you to display
    some statistics regarding delayed tasks on the navbar of the application. Working
    through this exercise, you will learn the basic syntax of view components and
    how to place them in Razor Pages. Perform the following steps to do so:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个视图组件，允许您在应用程序的导航栏上显示有关延迟任务的一些统计信息。通过完成这个练习，您将学习视图组件的基本语法以及如何将它们放置在Razor页面中。执行以下步骤来完成：
- en: Under the root of the `ToDoListApp` project, create a new folder called `ViewComponents`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToDoListApp`项目的根目录下，创建一个名为`ViewComponents`的新文件夹。
- en: 'Inside this folder, create a new class called `StatsViewComponent`:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹内，创建一个名为`StatsViewComponent`的新类：
- en: '[PRE68]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Again, inside the `ViewComponents` folder, create a new class named `StatsViewModel`
    with two public `int` properties, named `Delayed` and `DueToday`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在`ViewComponents`文件夹内，创建一个名为`StatsViewModel`的新类，具有两个名为`Delayed`和`DueToday`的公共`int`属性。
- en: '[PRE69]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Edit the `StatsViewComponent` class to inherit from the `ViewComponent` class
    that is contained in the `Microsoft.AspNetCore.Mvc` namespace:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`StatsViewComponent`类，使其继承自`Microsoft.AspNetCore.Mvc`命名空间中包含的`ViewComponent`类：
- en: '[PRE70]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inject `ToDoDbContext` via a constructor initializing a `private readonly` field:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造函数注入`ToDoDbContext`，初始化一个`private readonly`字段：
- en: '[PRE71]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Place the proper `using` namespaces.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 放置正确的`using`命名空间。
- en: 'Create a method named `InvokeAsync` with the following signature and content:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`InvokeAsync`的方法，具有以下签名和内容：
- en: '[PRE72]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This method will use `ToDoDbContext` to query the database and retrieve the
    delayed tasks, as well as the ones that are due on the current day.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将使用`ToDoDbContext`来查询数据库并检索延迟的任务，以及当天到期的任务。
- en: Now under the `Pages` folder, create a new folder called `Components`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Pages`文件夹下，创建一个名为`Components`的新文件夹。
- en: Under it make another folder called `Stats`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下创建一个名为`Stats`的文件夹。
- en: 'Then, inside the `Stats` folder, create a new file called `default.cshtml`
    with the following content:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Stats`文件夹内，创建一个名为`default.cshtml`的新文件，内容如下：
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `default.cshtml` will contain the view part of the view component class.
    Here, you are basically creating a `.cshtml` file based on a model specified.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`default.cshtml`将包含视图组件类的视图部分。在这里，您基本上是根据指定的模型创建了一个`.cshtml`文件。'
- en: 'Finally, in `_Layout.cshtml` (under `Pages/Shared/`), add a call to the `ViewComponent`
    by adding the `<vc:stats></vc:stats>` tag inside your navbar. Replace the page
    code with the following:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`_Layout.cshtml`（在`Pages/Shared/`下），通过在导航栏内添加`<vc:stats></vc:stats>`标签来调用`ViewComponent`。用以下代码替换页面代码：
- en: '[PRE75]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the application to see your navbar as shown in *Figure 7.8*:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，查看您的导航栏，如*图7.8*所示：
- en: '![Figure 7.9: The Task stats view component'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.9：任务统计视图组件'
- en: '](img/B16835_07_09.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_09.jpg)'
- en: 'Figure 7.9: The Task stats view component'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：任务统计视图组件
- en: In this exercise, you created your first view component which is a task stat
    displayed right on your navbar. As you may have noticed, one efficient thing about
    view components that distinguishes them from partial pages is that they are independent
    of the page they are displayed on. You build both your frontend and backend all
    self-contained inside the component, with no external dependencies on the page.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了您的第一个视图组件，它是一个显示在导航栏上的任务统计。正如您可能已经注意到的那样，关于视图组件的一个高效的事情是，它们与显示在上面的页面是独立的。您可以在组件内部构建前端和后端，而不依赖于页面上的外部依赖。
- en: Note
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/j9eLW](https://packt.link/j9eLW).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/j9eLW](https://packt.link/j9eLW)找到此练习中使用的代码。
- en: This exercise covered view components, which allow you to display some statistics
    regarding delayed tasks on the navbar of the application. With this knowledge,
    you will now complete an activity wherein you will work in a view component to
    show a log history.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习涵盖了视图组件，它允许您在应用程序的导航栏上显示有关延迟任务的一些统计信息。有了这些知识，您现在将完成一个活动，在其中您将在一个视图组件中工作以显示日志历史记录。
- en: 'Activity 7.02: Writing a View Component to Display Task Log'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.02：编写一个视图组件来显示任务日志
- en: As the final step of this chapter, this activity will be based on a common task
    in real-world applications—to have a log of user activities. In this case, you
    will write every change the user does to a field to the database and display it
    in a view. To do so, you would need to use a view component.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一步，这个活动将基于现实世界应用中的常见任务——记录用户活动日志。在这种情况下，您将把用户对字段所做的每一次更改写入数据库，并在视图中显示出来。为此，您需要使用一个视图组件。
- en: 'The following steps will help you complete this activity:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: 'Create a new class under the `Models` folder named `ActivityLog`. This class
    should have the following properties: `Guid Id`, `String EntityId`, `DateTime`
    `Timestamp`, `String Property`, `String OldValue`, and `String NewValue`.'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹下创建一个名为`ActivityLog`的新类。该类应具有以下属性：`Guid Id`、`String EntityId`、`DateTime`
    `Timestamp`、`String Property`、`String OldValue`和`String NewValue`。
- en: Create a new `DbSet<ActivityLog>` property for this model under `ToDoDbContext`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此模型在`ToDoDbContext`下创建一个新的`DbSet<ActivityLog>`属性。
- en: Under your `DbContext`, create a method to generate activity logs for the modified
    properties of `Entries` under the Entity Framework's `ChangeTracker` with `EntityState.Modified`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`DbContext`下，创建一个方法，为Entity Framework的`ChangeTracker`下的`Entries`的修改属性生成活动日志。
- en: Override `SaveChangesAsync()` in `DbContext`, by adding the generated logs to
    `DbSet` right before calling the `base` method.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DbContext`中覆盖`SaveChangesAsync()`，在调用`base`方法之前将生成的日志添加到`DbSet`中。
- en: Create a new Entity Framework Core migration and update the database to support
    this migration.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Entity Framework Core迁移，并更新数据库以支持此迁移。
- en: Create the `ViewComponent` class, which should load all logs for a given `taskId`
    passed on the invocation and return them to the `ViewComponent`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ViewComponent`类，应在调用时加载给定`taskId`的所有日志，并将它们返回给`ViewComponent`。
- en: Create the `ViewComponent` view, which should take a collection of `ActivityLog`
    as a model and display them in a Bootstrap table, if any exists. If no logs are
    recorded, show an alert saying that no logs are available.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ViewComponent`视图，应以`ActivityLog`的集合作为模型，并在Bootstrap表中显示它们（如果存在）。如果没有记录日志，则显示一个警报，说明没有可用的日志。
- en: Add the view component to the `Edit` page, passing the `taskId` property.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图组件添加到“编辑”页面，传递“taskId”属性。
- en: Run the application and check the final output by opening a task's details.
    You will see a box on the right with your activity logs or a message with no logs,
    if there are no activity logs recorded, for that task yet.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并通过打开任务的详细信息来检查最终输出。您将在右侧看到一个框，其中包含您的活动日志，或者如果尚未记录该任务的任何活动日志，则显示一个没有日志的消息。
- en: '![Figure 7.10: The Activity log being displayed with no logs'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：显示没有日志的活动日志'
- en: '](img/B16835_07_10.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_07_10.jpg)'
- en: 'Figure 7.10: The Activity log being displayed with no logs'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：显示没有日志的活动日志
- en: In this activity, you were able to create an isolated view component with completely
    new functionality that's decoupled from a page, allowing it to work on a single
    feature at a time.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您能够创建一个独立的视图组件，具有全新的功能，与页面解耦，使其能够一次处理一个功能。
- en: Note
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到此活动的解决方案。
- en: Summary
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the foundations of building a modern web application
    with C# and Razor Pages. You focused on important concepts at the beginning of
    the chapter, such as middleware, logging, DI, and configuration. Next, you used
    Razor Pages to create CRUD models along with Entity Framework and used some more
    advanced features, such as custom tag helpers, partial pages, and view components,
    which enable you to create more easily maintainable application features.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了使用C#和Razor Pages构建现代Web应用程序的基础知识。您在本章的开头专注于重要概念，如中间件、日志记录、DI和配置。接下来，您使用Razor
    Pages创建了CRUD模型，还使用了一些更高级的功能，如自定义标签助手、部分页面和视图组件，这些功能使您能够创建更易于维护的应用程序功能。
- en: Finally, you saw how ASP.NET model binding works so that there can be a two-way
    data binding between the client and the server. By now, you should have an effective
    foundation for building modern web applications with ASP.NET and Razor Pages on
    your own.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您了解了ASP.NET模型绑定的工作原理，以便在客户端和服务器之间实现双向数据绑定。到目前为止，您应该已经具备了使用ASP.NET和Razor Pages构建现代Web应用程序的有效基础。
- en: Over the next two chapters, you will learn about building and communicating
    with APIs.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，您将学习有关构建和与API进行通信的内容。
