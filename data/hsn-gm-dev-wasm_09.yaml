- en: Improved Particle Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进的粒子系统
- en: The *particle system* we developed in the previous chapter was a good start,
    but the effects you can create with it are rather bland. Our particles do not
    rotate or scale, they are not animated, and they are relatively consistent in
    the way they look over time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中开发的*粒子系统*是一个很好的开始，但您可以使用它创建的效果相当单调。我们的粒子不会旋转或缩放，它们不会动画，它们在外观上相对一致。
- en: 'For this chapter, you will need to include several images in your build to
    make this project work. Make sure that you include the `/Chapter09/sprites/` folder
    from this project''s GitHub repository. If you would like to build the particle
    system tool from GitHub, the source for the tool is located in the `/Chapter09/advanced-particle-tool/`
    folder. If you haven''t downloaded the GitHub project yet, you can get it online
    here: [https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要在构建中包含几个图像，以使该项目正常工作。确保您包含了此项目的GitHub存储库中的`/Chapter09/sprites/`文件夹。如果您想要从GitHub构建粒子系统工具，该工具的源代码位于`/Chapter09/advanced-particle-tool/`文件夹中。如果您还没有下载GitHub项目，可以在此处在线获取：[https://github.com/PacktPublishing/Hands-On-Game-Develop](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'If we want the most out of our particle system, we are going to need to add
    more features to it. In this chapter, we will be adding the following additional
    features:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望从我们的粒子系统中获得最大的效果，我们需要为其添加更多功能。在本章中，我们将添加以下附加功能：
- en: Particle scale over its lifetime
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子在其生命周期内的比例
- en: Particle rotation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子旋转
- en: Animated particles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画粒子
- en: Color change over time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时间改变颜色
- en: Support for particle bursts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持粒子爆发
- en: Support for looping and non-looping emitters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持循环和非循环发射器
- en: Modifying our HTML shell file
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改我们的HTML外壳文件
- en: 'The first thing we need to do is add some new inputs into the HTML shell file.
    We are going to copy the `basic_particle_shell.html` file to a new shell file
    that we will call `advanced_particle_shell.html`. We will be adding a second container
    class `div` element and a lot of new inputs to the HTML portion of the shell file
    between the original container and the `canvas` element. Here is what that new
    container element looks like:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在HTML外壳文件中添加一些新的输入。我们将复制`basic_particle_shell.html`文件到一个新的外壳文件，我们将称之为`advanced_particle_shell.html`。我们将在原始容器和`canvas`元素之间的外壳文件的HTML部分中添加第二个容器类`div`元素和许多新的输入。以下是新容器元素的样子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Scaling values
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放值
- en: Scaling a sprite means modifying that sprite's size by some multiple of its
    original size. For example, if we scale a 16 x 16 sprite by a scaling value of
    `2.0`, the sprite will render to the canvas as a 32 x 32 image. This new container
    starts with four input elements, as well as their labels, which tell the particle
    system how to scale the particles over their lifetimes. The `min_starting_scale`
    and `max_starting_scale` elements are the starting range scale of the particles.
    If you want the particle to always start with a scale of `1.0` (1 to 1 scale with
    the `.png` image size), you should put `1.0` in both of these fields. The actual
    starting scale value will be a randomly chosen value that falls between the two
    values you put in those fields. We haven't added any checks in this interface
    to verify that `max` is larger than `min`, so make sure that `max` is the same
    value or larger than the `min` value or this will break the emitter. The next
    two `input` elements are `min_end_scale` and `max_end_scale`. Like the starting
    scale values, the actual ending scale will be a randomly chosen value that falls
    between the two values we put in these fields. At any given point in a particle's
    lifetime, it will have a scale that is a value interpolated between the scale
    value assigned to the start of that particle's lifetime and the scale value at
    the end. So, if I start with a scale value of `1.0` and end with a scale value
    of `3.0`, when the lifetime of the particle is half over, the scale value of the
    particle will be `2.0`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放精灵意味着通过其原始大小的某个倍数修改该精灵的大小。例如，如果我们使用缩放值`2.0`来缩放一个16 x 16的精灵，那么该精灵将呈现为画布上的32
    x 32图像。这个新容器以四个输入元素开始，以及它们的标签，告诉粒子系统如何在其生命周期内缩放粒子。`min_starting_scale`和`max_starting_scale`元素是粒子的起始范围缩放。如果您希望粒子始终以`1.0`的比例（与`.png`图像大小的1比1比例）开始，您应该在这两个字段中都放入`1.0`。实际的起始比例值将是在这些字段中放入的两个值之间随机选择的值。我们还没有在此界面中添加任何检查来验证`max`是否大于`min`，因此请确保`max`与`min`值相同或大于`min`值，否则这将破坏发射器。接下来的两个`input`元素是`min_end_scale`和`max_end_scale`。与起始比例值一样，实际的结束比例将是在这些字段中放入的两个值之间随机选择的值。在粒子的生命周期中的任何给定点，它将具有一个比例，该比例是在该粒子生命周期开始时分配的比例值和结束时的比例值之间插值的值。因此，如果我从`1.0`的比例值开始，然后以`3.0`的比例值结束，当粒子的生命周期过了一半时，粒子的比例值将是`2.0`。
- en: 'Here is what those elements look like in the HTML file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML文件中这些元素的样子：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Color-blending values
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色混合值
- en: SDL has a function called `SDL_SetTextureColorMod` that is capable of modifying
    the red, green, and blue color channels of a texture. This function can only reduce
    color channel values, so using these values works best on grayscale images. The
    next two inputs in the HTML are `start_color` and `end_color`. These values will
    be used to modify the color channels of the particle over its lifetime. Each color
    channel (red, green, and blue) interpolated over the lifetime of the particle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SDL有一个名为`SDL_SetTextureColorMod`的函数，能够修改纹理的红色、绿色和蓝色通道。这个函数只能减少颜色通道值，所以在灰度图像上使用这些值效果最好。HTML中的下两个输入是`start_color`和`end_color`。这些值将用于修改粒子在其生命周期内的颜色通道。每个颜色通道（红色、绿色和蓝色）在粒子的生命周期内进行插值。
- en: 'Here is what those elements look like in the HTML file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML文件中这些元素的样子：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Particle burst
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子爆发
- en: Up until this point, the particle systems we have worked with have emitted a
    consistent stream of particles. We may want a point in time within the lifetime
    of our particle system when a burst of particles is emitted all at once. The next
    two input elements are `burst_time` and `burst_particles`. The `burst_time` element
    allows values from `0.0` to `1.0`. This number represents the portion of the way
    through the particle emitter's lifetime at which the burst will occur. A value
    of `0.0` would mean that the burst would happen at the very beginning of the emitter's
    life cycle, `1.0` would occur at the very end, and `0.5` would occur halfway between.
    After the `burst_time` element is the `burst_particles` element. This element
    contains the number of particles that are emitted in the burst. Before adjusting
    this so that it's a large number, make sure that you set the `max_particles` input
    element to a value that can accommodate the burst. For instance, if you have a
    particle emitter that emits `20` particles per second and you have a maximum number
    of particles that is also `20` particles, adding a burst of any size will not
    be noticeable because there will not be enough inactive particles left in the
    particle pool for the burst to use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所使用的粒子系统都发射一致的粒子流。在粒子系统的生命周期内，我们可能希望在某个时间点突发发射一大批粒子。接下来的两个输入元素是`burst_time`和`burst_particles`。`burst_time`元素允许值从`0.0`到`1.0`。这个数字代表粒子发射器生命周期中爆发将发生的时间点。`0.0`表示爆发将在发射器生命周期的开始时发生，`1.0`表示在结束时发生，`0.5`表示在中间时发生。在`burst_time`元素之后是`burst_particles`元素。该元素包含爆发时发射的粒子数量。在调整此值为较大值之前，请确保将`max_particles`输入元素设置为可以容纳爆发的值。例如，如果你有一个每秒发射`20`个粒子的粒子发射器，并且你的最大粒子数也是`20`个粒子，那么添加任何大小的爆发都不会被注意到，因为粒子池中没有足够的非活动粒子供爆发使用。
- en: 'Here is what those elements look like in the HTML file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML文件中这些元素的外观：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Looping the emitter
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环发射器
- en: Some emitters execute for a fixed time and then stop when that time has expired.
    An example of this kind of emitter is an explosion. Once an explosion effect has
    finished, we want it to end. A different type of emitter might loop, it would
    continue to execute until some other code stops the emitter. An example of this
    kind of emitter is our spaceship's engine exhaust. As long as our spaceship is
    accelerating, we would like to see a trail of particles being emitted out of the
    back of it. The next element in the HTML is a loop checkbox element. If clicked,
    the emitter will continue emitting, even after its lifetime is over. If there
    is a burst associated with this emitter, that burst will occur each time the emitter
    passes through that part of its loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些发射器在固定时间内执行，然后在时间到期时停止。这种发射器的例子是爆炸。一旦爆炸效果完成，我们希望它结束。另一种类型的发射器可能会循环，它会继续执行，直到其他代码停止发射器。这种发射器的例子是我们飞船的引擎排气口。只要我们的飞船在加速，我们希望看到一串粒子从它的后面排放出来。HTML中的下一个元素是一个循环复选框元素。如果点击，发射器将继续发射，即使其寿命已经结束。如果与此发射器相关联的是一次性爆发，那么每次发射器通过循环的那部分时，爆发都会发生。
- en: 'Here is what the input element will look like in the HTML:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML中输入元素的外观：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Aligning particle rotation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐粒子旋转
- en: '*Rotation* can improve many particle effects. We are forced to pick and choose
    the values we want to use for the particle system in our project because, frankly,
    I could write an entire book on particle systems. Instead of having rotation value
    ranges, like we did earlier for the particle''s scale, we are going to have a
    single flag that allows the user to choose whether the particle system is going
    to align its rotation with the emission velocity vector. I find this to be a pleasant
    effect. The user will make this decision with an `id="align_rotation"` checkbox.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*旋转*可以改善许多粒子效果。由于我们在项目中被迫选择要在粒子系统中使用的值，因此，坦率地说，我可以写一本关于粒子系统的整本书。与之前为粒子的比例所做的旋转值范围不同，我们将有一个单一的标志，允许用户选择粒子系统是否将其旋转与发射速度矢量对齐。我发现这是一个愉快的效果。用户将通过`id="align_rotation"`复选框做出这个决定。'
- en: 'Here is what the HTML code looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML代码的外观：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Emission time
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射时间
- en: The *emission time* is the amount of time in milliseconds that our particle
    emitter will run for before it stops running, or loops if the user has ticked
    the loop checkbox. If the particle system loops, this value will only be noticeable
    for particle systems with a burst. This will cause the burst to happen each time
    the particle system goes through the loop.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*发射时间*是我们的粒子发射器在停止运行之前运行的毫秒数，或者如果用户已经选中循环复选框，则循环。如果粒子系统循环，这个值只对具有突发的粒子系统才会有影响。这将导致每次粒子系统通过循环时都会发生爆发。'
- en: 'The HTML code is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: HTML代码如下：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Animation frames
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画帧
- en: If we want to create a particle with a multi-frame animation, we can add the
    number of frames here. This feature assumes a *horizontal strip sprite sheet*
    and will divide the loaded image file evenly on the *x* axis. When this value
    is `1`, there is no animation because there is only a single frame. The frame
    time for the animation will be evenly divided across the individual particle's
    time to live. In other words, if you have a ten-frame animation and the particle
    lifetime is 1,000 milliseconds, each frame of the animation will display for 100
    milliseconds (1,000/10).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个具有多帧动画的粒子，我们可以在这里添加帧数。此功能假定*水平条形精灵表*，并将加载的图像文件均匀分割在*x*轴上。当这个值为`1`时，没有动画，因为只有一个单独的帧。动画的帧时间将均匀分配到单个粒子的存活时间上。换句话说，如果你有一个十帧动画，粒子寿命为1,000毫秒，那么动画的每一帧将显示100毫秒（1,000/10）。
- en: 'Here are the HTML elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTML元素：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have defined our HTML, let's take a look at the JavaScript portion
    of our code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了HTML，让我们来看看代码的JavaScript部分。
- en: Modifying the JavaScript
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改JavaScript
- en: The tool we are creating operates outside of the game we have been working on
    for several chapters now. Because of this, we are working on a new HTML shell
    file, and we will be writing a lot of JavaScript to integrate our user interface
    with the WebAssembly classes we will drop into our game later. Let's take the
    time to walk through all of the JavaScript functions we will need to add to our
    new HTML shell file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的工具是在我们已经进行了几章工作的游戏之外运行的。因此，我们正在修改一个新的HTML外壳文件，并且我们将编写大量的JavaScript代码，以便将用户界面与稍后将放入游戏中的WebAssembly类集成起来。让我们花点时间来逐步了解我们需要添加到新的HTML外壳文件中的所有JavaScript函数。
- en: The JavaScript UpdateClick function
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript UpdateClick函数
- en: After we have modified the HTML, the next thing we need to do is modify the
    `UpdateClick()` JavaScript function to allow it to grab the new values out of
    the HTML elements and pass those values into the `Module.ccall` function call
    to `update_emitter`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改了HTML之后，我们需要做的下一件事是修改`UpdateClick()` JavaScript函数，以便它可以从HTML元素中获取新值，并将这些值传递给`Module.ccall`函数调用`update_emitter`。
- en: 'Here is the new version of the `UpdateClick` function in its entirety:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的`UpdateClick`函数的新版本：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, we have added new local variables into this JavaScript function
    that will store the values that we take from our new HTML elements. Retrieving
    the scaling values and coercing them into numbers to pass into `update_emitter`
    should look pretty familiar by now. Here is that code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在这个JavaScript函数中添加了新的本地变量，用于存储我们从新的HTML元素中获取的值。检索缩放值并将其强制转换为数字以传递给`update_emitter`现在应该看起来非常熟悉。以下是该代码：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Coercing color values
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制转换颜色值
- en: In JavaScript, variable coercion is the process of turning one variable type
    into a different variable type. Because JavaScript is a weakly typed language,
    coercion is a little different from typecasting, which is analogous to variable
    coercion in strongly typed languages such as C and C++.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，变量强制转换是将一个变量类型转换为另一个变量类型的过程。由于JavaScript是一种弱类型语言，强制转换与类型转换有所不同，后者类似于强类型语言（如C和C++）中的变量强制转换。
- en: The process of coercing our color values into `Integer` values is a two-step
    process. The values in these elements are strings that start with the `*#*` character,
    followed by a six-digit hexadecimal number. The first thing we need to do is remove
    that starting `#` character, as it will prevent us from parsing that string into
    an integer. We do this with a simple `substr` to get a substring (part of a string)
    of the value inside of the element.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的颜色值强制转换为`Integer`值是一个两步过程。这些元素中的值是以`*#*`字符开头的字符串，后面跟着一个六位十六进制数。我们需要做的第一件事是删除该起始的`#`字符，因为它将阻止我们将该字符串解析为整数。我们可以通过简单的`substr`来实现这一点，以获取元素内部值的子字符串（字符串的一部分）。
- en: 'Here is what that looks like for `start_color`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`start_color`的代码：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We know that the string will always be seven characters long, but we only want
    the last six characters. We now have a hexadecimal representation of the starting
    color, but it is still a string variable. Now, we need to coerce this into an
    `Integer` value, and we have to tell the `parseInt` function to use base 16 (hexadecimal),
    so we will pass the value `16` into `parseInt` as a second parameter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道字符串的长度始终为七个字符，但我们只想要最后的六个字符。现在，我们已经得到了起始颜色的十六进制表示，但它仍然是一个字符串变量。现在，我们需要将其强制转换为一个`Integer`值，并且我们必须告诉`parseInt`函数使用十六进制（base
    16），因此我们将值`16`作为第二个参数传递给`parseInt`：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have coerced `start_color` into an integer, we will do the same
    for `end_color`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将`start_color`强制转换为整数，我们将对`end_color`执行相同的操作：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Additional variable coercions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的变量强制转换
- en: After the `start_color` and `end_color` coercions, the remaining coercions we
    must perform should feel familiar. We coerce the values in `burst_time`, `burst_particles`,
    `emit_time`, and `animation_frames` into `Number` variables. We coerce the checked
    values from `loop` and `align_rotation` into Boolean variables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start_color`和`end_color`强制转换之后，我们必须执行的其余强制转换应该感觉很熟悉。我们将`burst_time`、`burst_particles`、`emit_time`和`animation_frames`中的值强制转换为`Number`变量。我们将从`loop`和`align_rotation`中检查的值强制转换为布尔变量。
- en: 'Here is the remainder of the coercion code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是强制转换代码的其余部分：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we need to add the variable types and the new variables into our `Module.ccall`
    call to `update_emitter` in our WebAssembly module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将变量类型和新变量添加到我们的`Module.ccall`调用中，以便在我们的WebAssembly模块中调用`update_emitter`：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Modifying the handleFiles function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改handleFiles函数
- en: 'The last changes we need to make to our HTML shell file are modifications to
    the `handleFiles` function. These modifications effectively mirror the changes
    to the `UpdateClick` function. As you step through the code, you will see the
    same coercion replicated inside of `handleFiles`, and the `Module.ccall` to `add_emitter`
    will be updated with the same new parameter types and parameters. Here is the
    code for the latest version of the `handleFiles` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对HTML外壳文件进行的最后更改是修改`handleFiles`函数。这些修改实际上与`UpdateClick`函数的更改相同。当您逐步执行代码时，您将看到`handleFiles`中复制的相同强制转换，并且`Module.ccall`到`add_emitter`将使用相同的新参数类型和参数进行更新。以下是最新版本的`handleFiles`函数的代码：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have our JavaScript code, we can begin making our changes to the
    WebAssembly module.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了JavaScript代码，我们可以开始对WebAssembly模块进行修改。
- en: Modifying the Particle class
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Particle类
- en: Now that we have added the changes to our HTML shell file, we need to make some
    changes to our WebAssembly module to support these new parameters. We are going
    to work our way from the bottom up, starting with the `Particle` class. This class
    is not only useful for the tool we are building to design particle systems, but
    it is one of a few classes that, once we have completed it, we will be able to
    pull into our game, allowing us to add some beautiful looking effects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对HTML外壳文件进行了更改，我们需要对WebAssembly模块进行一些更改，以支持这些新参数。我们将从下往上逐步进行工作，从`Particle`类开始。这个类不仅对我们正在构建的设计粒子系统的工具有用，而且是我们完成后将能够引入我们的游戏中的几个类之一，这将使我们能够添加一些美丽的效果。
- en: 'Here is what the particle class definition looks like inside the `game.hpp`
    file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`game.hpp`文件中粒子类定义的样子：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: New attributes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新属性
- en: We are going to walk through the new attributes that were added to the `Particle`
    class definition and briefly discuss what each new attribute does. The first attribute
    that we added was `bool m_color_mod`. In our HTML, we don't have a checkbox for
    this value, so you may be wondering why there is one here. The reason is performance.
    If the user doesn't want a color modification, a call to `SDL_SetTextureColorMod`
    is a waste. If we have two white values passed into the `Particle` object, no
    interpolation or call to modify the value is necessary. We could check the start
    and end color each time to see if their values are `0xffffff`, but I felt that
    adding this flag would make the check clearer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍已添加到`Particle`类定义中的新属性，并简要讨论每个新属性的作用。我们添加的第一个属性是`bool m_color_mod`。在我们的HTML中，我们没有为这个值添加复选框，所以您可能会想知道为什么这里有一个。原因是性能。如果用户不想要颜色修改，调用`SDL_SetTextureColorMod`就是浪费。如果我们将两个白色值传递给`Particle`对象，就不需要进行插值或调用修改值。我们可以每次检查开始和结束颜色，看它们的值是否为`0xffffff`，但我觉得添加这个标志会使检查更清晰。
- en: Aligning rotation attributes
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐旋转属性
- en: 'The `m_align_rotation` flag that follows is simply the flag we passed in from
    the checkbox. If this value is `true`, the particle will rotate itself to point
    in the direction it is moving. The `m_rotation` floating-point variable follows
    that. The attribute variable that holds the angle of the particle will be rotated
    based on the direction in which the particle is moving. Here is what these values
    look like in our code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来跟随的`m_align_rotation`标志只是我们从复选框中传递的标志。如果这个值为`true`，粒子将自行旋转以指向它移动的方向。接下来是浮点变量`m_rotation`。这个属性变量保存粒子的角度，将根据粒子移动的方向进行旋转。以下是这些值在我们的代码中的样子：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Color attributes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色属性
- en: 'The color mod flag I mentioned earlier makes the check on the next set of values
    a lot easier. Our hexadecimal color value that represented the red, green, and
    blue values in our HTML needed to be passed in as an integer so that it could
    be broken down into three 8-bit channels. Here is what those 8-bit color variables
    look like in the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到的颜色mod标志使得对下一组值的检查变得更容易。我们在HTML中表示红色、绿色和蓝色值的十六进制颜色值需要作为整数传递，以便它可以被分解为三个8位通道。以下是代码中这些8位颜色变量的样子：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You will notice that these are all 8-bit unsigned integer variables that are
    declared with `Uint8`. When SDL performs color modification, it doesn't take in
    RGB values as a single variable; instead, it takes the values broken down into
    three 8-bit variables representing each of the individual channels. The `m_start_(color)`
    variable and the `m_end_(color)` variable will be interpolated based on the particle
    lifetime to get the `m_current_(color)` variable, which will be passed in as the
    channels to SDL when we do the color modification. Because we will be passing
    these values in as a single color variable from the JavaScript, the `Particle`
    constructor and the `Update` functions will need to perform bitwise operations
    to set these individual channel variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这些都是声明为`Uint8`的8位无符号整数变量。当SDL执行颜色修改时，它不会将RGB值作为单个变量传入；相反，它会将这些值分解为三个表示每个单独通道的8位变量。`m_start_(color)`变量和`m_end_(color)`变量将根据粒子寿命进行插值，得到`m_current_(color)`变量，这将作为通道传递给SDL进行颜色修改。因为我们将这些值作为单个颜色变量从JavaScript传递，所以`Particle`构造函数和`Update`函数需要执行位操作来设置这些单独的通道变量。
- en: Animation attributes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画属性
- en: 'The next set of new attributes are all related to the new frame animation functionality
    in our `Particle`. Here are those attributes in the code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组新属性都与`Particle`中新的帧动画功能有关。以下是代码中的这些属性：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first attribute, `m_animation_frames`, is the value that's passed indirectly
    from the JavaScript. It tells the `Particle` class how many frames are in the
    sprite texture when it renders that texture to the canvas. The second attribute,
    `m_current_frame`, is used by the `Particle` class to keep track of which frame
    it should currently be rendering. The final attribute variable, `m_next_frame_ms`,
    tells the particle how many milliseconds are left before it must increment its
    current frame to display the next frame in the sequence.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性`m_animation_frames`是间接从JavaScript传递的值。它告诉`Particle`类在将纹理渲染到画布时有多少帧。第二个属性`m_current_frame`由`Particle`类用于跟踪它当前应该渲染的帧。最后一个属性变量`m_next_frame_ms`告诉粒子在必须增加当前帧以显示序列中的下一帧之前还有多少毫秒。
- en: Size and scale attributes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小和比例属性
- en: 'The next batch of attributes have to do with the size and scale of our particle.
    In the previous version of this code, we handled width and height in the `m_dest`
    rectangle. That is no longer practical, because the width and height (`w` and
    `h`) attributes of this rectangle will need to be modified to account for our
    current scale. Here are the new variables as they appear in the code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来一批属性与粒子的大小和比例有关。在此代码的先前版本中，我们在`m_dest`矩形中处理了宽度和高度。这已不再实际，因为这个矩形的宽度和高度（`w`和`h`）属性需要被修改以适应我们当前的比例。以下是这些新变量在代码中的样子：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `m_width` and `m_height` attributes are now required to keep track of the
    original width and height of the particle, which haven been adjusted by the scale.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_width`和`m_height`属性现在是必需的，以跟踪粒子的原始宽度和高度，这些宽度和高度已经通过比例调整。'
- en: The `m_start_scale` and `m_end_scale` attributes are values that are randomly
    picked between the `max` and `min` values we defined in the JavaScript.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_start_scale`和`m_end_scale`属性是在JavaScript中定义的`max`和`min`值之间随机选择的值。'
- en: The `m_current_scale` attribute is the current scale that's used when calculating
    the `m_dest.w` and `m_dest.h` values when we render the particle. The current
    scale will be a value interpolated between the `m_start_scale` and `m_end_scale`
    attributes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_current_scale`属性是在渲染粒子时用于计算`m_dest.w`和`m_dest.h`值的当前比例。当前比例将是在`m_start_scale`和`m_end_scale`属性之间插值的值。'
- en: The source rectangle attribute
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源矩形属性
- en: 'In the previous version of the code, we didn''t have frame-animated particles.
    Because of this, we didn''t need to declare a source rectangle. If you want to
    render the entire texture to the canvas, you can pass in `NULL` in place of a
    source rectangle in the call to `SDL_RenderCopy`, which was what we were doing.
    Now that we have frame animations, we will pass in the location and the dimension
    of the part of the texture we render to the canvas. Because of this, we need to
    define a source rectangle attribute:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前版本的代码中，我们没有帧动画粒子。因此，我们不需要声明源矩形。如果要将整个纹理渲染到画布上，可以在调用`SDL_RenderCopy`时传入`NULL`，这就是我们所做的。现在我们有了帧动画，我们将传入纹理渲染到画布的位置和尺寸。因此，我们需要定义一个源矩形属性：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Additional constructor parameters
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的构造函数参数
- en: 'Now that we have walked through all the new attributes, we will briefly discuss
    the changes that are required by the signatures of our functions. The `Particle`
    class constructor must add some new parameters that will support our align rotation,
    color modification, and frame animation functionality. Here is what the new signature
    for the constructor looks like:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有新属性，我们将简要讨论我们的函数签名所需的更改。`Particle`类构造函数必须添加一些新参数，以支持我们的对齐旋转、颜色修改和帧动画功能。构造函数的新签名如下：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `boolean` value called `align_rotation` tells the constructor to align the
    particle's rotation with the direction it is moving in. The `start_color` and
    `end_color` parameters are the color modification values if we are using the new
    color modification feature of our particle system. The last parameter, `animation_frames`,
    tells the particle system whether or not it is using a frame animation system,
    and if so, how many frames it will use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`align_rotation`的布尔值告诉构造函数将粒子的旋转与其移动方向对齐。`start_color`和`end_color`参数是颜色修改值，如果我们使用粒子系统的新颜色修改功能。最后一个参数`animation_frames`告诉粒子系统是否正在使用帧动画系统，如果是，它将使用多少帧。
- en: The Update function's parameters
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Update`函数的参数'
- en: The modifications to the signature for the `Update` function mirrors the changes
    we need to make to the constructor. There are a total of four new parameters that
    are used to influence the align rotation, the color modification system, and the
    frame animation system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Update`函数签名的修改反映了我们需要对构造函数进行的更改。一共有四个新参数，用于影响对齐旋转、颜色修改系统和帧动画系统。
- en: 'Here is what the new `Update` function signature looks like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Update`函数签名如下：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Spawn function's parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Spawn`函数的参数'
- en: 'The last function signature that will need to be modified is the `Spawn` function.
    New values will be required to allow the `Emitter` to set the scale and rotation
    values when we spawn an individual particle. The `float start_scale` and `float
    end_scale` parameters are used to set the starting and ending scale multipliers
    when we generate the particle. The last parameter that''s added is `float rotation`,
    which represents the angle the particle is moving based on the *x* and *y* velocities
    of this particular particle. The following is the new version of the function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要修改的函数签名是`Spawn`函数。需要新值来允许`Emitter`在生成单个粒子时设置比例和旋转值。`float start_scale`和`float
    end_scale`参数用于设置生成粒子时的起始和结束比例乘数。添加的最后一个参数是`float rotation`，表示基于这个特定粒子的*x*和*y*速度的角度。以下是函数的新版本：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Changes to particle.cpp
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对particle.cpp的更改
- en: The next set of changes we need to make to our `Particle` class are all changes
    to the functions we defined in the `particle.cpp` file. It is challenging to keep
    track of the changes made to these functions, so rather than discuss these changes,
    I will walk you through everything that is happening in each of the functions
    we discuss.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`Particle`类进行的下一组更改都是对我们在`particle.cpp`文件中定义的函数进行的更改。跟踪对这些函数所做的更改是具有挑战性的，因此我将带领您了解我们讨论的每个函数中所发生的一切，而不是讨论这些更改。
- en: Particle constructor logic
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子构造函数逻辑
- en: 'The logic in the new `Particle` constructor adds a lot of code to set the stage
    for our new features. Here is what the latest version of the function looks like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`Particle`构造函数中的逻辑添加了大量代码，为我们的新功能设置了舞台。函数的最新版本如下：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first large batch of this code is used to set up the 8-bit color channels
    at the beginning and the end of our particle''s lifetime. If either the starting
    color or the ending color is not `0xffffff` (white), we will set up the starting
    and ending color channels using the `>>` operator (bit shift). Here is the code
    that sets the starting channels:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的第一大批用于设置粒子生命周期开始和结束时的8位颜色通道。如果起始颜色或结束颜色不是`0xffffff`（白色），我们将使用`>>`运算符（位移）设置起始和结束颜色通道。以下是设置起始通道的代码：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you aren''t familiar with the right bit shift operator `>>`, it takes an
    integer on the left-hand side of the operator and shifts the number of bits on
    the right-hand side of the operator. For example, a binary value of 15 (0000 1111)
    that''s shifted to the right by two bits will return a new value of 3 (0000 0011).
    When we shift to the right, any bits shifted to the right-hand side are lost,
    and bits with a value of 0 are moved in from the left-hand side:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉右移位运算符`>>`，它会将左侧的整数向右移动右侧的位数。例如，一个二进制值为15（0000 1111）向右移动两位将返回一个新值3（0000
    0011）。当我们向右移动时，向右移的任何位都会丢失，并且值为0的位会从左侧移入：
- en: '![](img/67ed6961-92c2-4974-9df7-1b89a8846928.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ed6961-92c2-4974-9df7-1b89a8846928.png)'
- en: 'Figure 9.1: Example of a right bit shift'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：右位移的示例
- en: 'If we have an RGB integer that comes in, each channel takes up 1 byte or 8
    bits. So, if R = **9**, G = **8**, and B = **7**, our integer value in hexadecimal
    would look like this: ff090807\. If we want to get to the R-value, we need to
    shift off the two bytes on the right-hand side of this 4 byte integer. Each byte
    is 8 bits, so we would take our RGB and use the `>>` operator to shift it by 16
    bits. We would then have the value `09`, which we could use to set our 8 bit red
    channel. When we do the green channel, we want the second byte from the right
    so that we can shift off 8 bits. Now, in our 4 byte integer, we would have 00000908\.
    Because we are moving this into an 8 bit integer, all the data not in the rightmost
    byte is lost in the assignment, so we end up with `08` in our green channel. Finally,
    the blue channel value is already in the rightmost byte. All we need to do with
    that is cast it to an 8 bit integer, so we lose all of the data that is not in
    the blue channel. The following is a diagram of the 32 bit color:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个RGB整数，每个通道占用1字节或8位。因此，如果R = **9**，G = **8**，B = **7**，我们的十六进制整数值看起来像这样：ff090807\.
    如果我们想得到R值，我们需要移除这个4字节整数右侧的两个字节。每个字节是8位，所以我们会取出我们的RGB并使用`>>`运算符将其向右移动16位。然后我们会得到值`09`，我们可以用它来设置我们的8位红色通道。当我们处理绿色通道时，我们希望从右侧取出第二个字节，以便我们可以移除8位。现在，在我们的4字节整数中，我们会有00000908\.
    因为我们将其移入一个8位整数，所有不在最右侧字节中的数据在赋值时都会丢失，所以我们最终得到绿色通道中的`08`。最后，蓝色通道的值已经在最右侧字节中。我们只需要将其转换为8位整数，因此我们会丢失不在蓝色通道中的所有数据。以下是32位颜色的图示：
- en: '![](img/df4baba9-146f-4ce0-af07-995d2c162b92.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df4baba9-146f-4ce0-af07-995d2c162b92.png)'
- en: 'Figure 9.2: Color bits in a 32-bit integer'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：32位整数中的颜色位
- en: 'We have to perform this same bit of magic on the end color channels:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对结束颜色通道执行相同的操作：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last thing we will do is set the current color channels to the starting
    color channels. We do this to create our particles with the colors' starting values.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们要做的是将当前颜色通道设置为起始颜色通道。我们这样做是为了使用颜色的起始值创建我们的粒子。
- en: 'If both the starting and ending colors are white, we want to set the color
    mod flag to `false`, so we will not attempt to modify the color on this particle.
    We will initialize all the color channels to `255`. Here is the code that does
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果起始颜色和结束颜色都是白色，我们希望将颜色修改标志设置为`false`，这样我们就不会尝试修改这个粒子的颜色。我们将所有颜色通道初始化为`255`。以下是执行此操作的代码：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After the code for managing the color modification is some initialization code,
    which sets the attribute variables in this object from the parameters passed into
    the constructor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理颜色修改的代码之后是一些初始化代码，它从构造函数中传入的参数设置了这个对象的属性变量：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we set the source and destination rectangles based on the height and
    width passed in, as well as the number of animation frames for the particle:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据传入的高度和宽度以及粒子的动画帧数设置源矩形和目标矩形：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The last two lines of code initialize the current frame to `0` and our active
    flag to `false`. All animations start on frame `0`, and a new particle is not
    active until it's spawned.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后两行将当前帧初始化为`0`，并将我们的活动标志初始化为`false`。所有动画都从第`0`帧开始，直到生成新的粒子才会变为活动状态。
- en: 'Here are the last few lines of code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的最后几行：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Particle Update logic
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子更新逻辑
- en: 'The `Particle` class'' `Update` function is run on each of the particles that
    were created by a previous PNG file upload. This function updates most of the
    values set in the constructor. The only exception is that the width and height
    dimensions of the particle must stay the same. This is because the constructor
    set these values based on the dimensions of the image file that was uploaded.
    I don''t feel the need to step through each part of this function, because of
    how similar it is to the constructor that we just walked through. Take a moment
    to look over the code to see how similar it is:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`类的`Update`函数在之前通过PNG文件上传创建的每个粒子上运行。这个函数更新了构造函数中设置的大部分值。唯一的例外是粒子的宽度和高度尺寸必须保持不变。这是因为构造函数根据上传的图像文件的尺寸设置了这些值。我不觉得有必要逐步介绍这个函数的每个部分，因为它与我们刚刚讨论过的构造函数非常相似。花点时间看一下代码，看看它有多相似：'
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Particle Spawn function
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子生成函数
- en: 'The `Particle` class'' `Spawn` function is run by the `Emitter` whenever it
    needs to emit a new particle. When the emitter hits its next particle emission
    time, it searches through the particle pool, looking for a particle that is marked
    as not active. If it finds a particle, it calls the `Spawn` function on that particle,
    which activates the particle and sets several values specific to its run. All
    of the values that are passed into `Spawn` are changed by the `Emitter` every
    time the particle is emitted. Here is what the code for this function looks like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`类的`Spawn`函数由`Emitter`在需要发射新粒子时运行。当发射器达到下一个粒子发射时间时，它会在粒子池中寻找一个标记为非活动的粒子。如果找到一个粒子，它会调用该粒子的`Spawn`函数，激活粒子并设置其运行时的几个值。每次粒子被发射时，`Emitter`都会改变传递给`Spawn`的所有值。以下是这个函数的代码：'
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Almost everything that's done in this function is initialization and is pretty
    straightforward. The first four lines initialize the position attribute (`m_position`),
    as well as the position with the destination rectangle (`m_dest`). Then, the velocity
    is set. The alpha always begins at `255`. The particle is activated, the time
    to live variable is activated, and the rotation is set. Color channels are reinitialized,
    the scale is initialized, and the current frame and the time to the next frame
    are set.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中几乎所有的操作都是初始化，非常直接。前四行初始化了位置属性（`m_position`），以及与目标矩形相关的位置（`m_dest`）。然后设置了速度。Alpha始终从`255`开始。粒子被激活，生存时间变量被激活，旋转被设置。颜色通道被重新初始化，比例被初始化，当前帧和下一帧的时间被设置。
- en: Particle Move function
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子移动函数
- en: 'The `Particle` class'' `Move` function is the function that not only changes
    the render position of the particle, but also adjusts all of the interpolated
    values between the beginning and the end of the particle''s life. Let''s step
    through the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Particle`类的`Move`函数是一个不仅改变粒子渲染位置，还调整粒子生命周期开始和结束之间所有插值数值的函数。让我们逐步看一下代码：'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first line of the `Move` function calculates `time_pct`. That is a floating-point
    value that ranges from `0.0` - `1.0`. This variable starts with a value of `0.0`
    when the particle has just been spawned and hits `1.0` when the particle is ready
    to be deactivated. It gives us a floating-point value indicating where we are
    in the lifespan of this particle:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move`函数的第一行计算`time_pct`。这是一个浮点值，范围从`0.0`到`1.0`。当粒子刚刚生成时，该变量的值为`0.0`，当粒子准备停用时，该值为`1.0`。它给我们一个浮点值，指示我们在这个粒子的寿命中的位置：'
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `m_ttl` attribute is the time to live for this particle in milliseconds,
    and `m_life_time` is the total lifespan of the particle. This value is useful
    for doing all of our interpolated value calculations inside of this `Move` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_ttl`属性是粒子在毫秒内的存活时间，`m_life_time`是粒子的总寿命。这个值对于在`Move`函数内进行所有插值计算非常有用。'
- en: 'The following line returns the current frame, based on the value that is in
    `time_pct`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行根据`time_pct`中的值返回当前帧：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, several lines adjust the x and y velocity of the particle based
    on the acceleration value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，几行代码根据加速度值调整粒子的x和y速度：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to set the `acc_adjusted` variable to a modified version of the `m_acceleration`
    variable based on the fraction of a second (`delta_time`) that has elapsed. After
    changing the `m_velocity` values, we need to use those velocity values to modify
    the position of the particle:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`acc_adjusted`变量设置为`m_acceleration`变量的修改版本，根据已经过去的秒数（`delta_time`）来调整。在改变`m_velocity`值后，我们需要使用这些速度值来修改粒子的位置：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the `m_alpha_fade` variable is `true`, the code will modify the alpha value,
    interpolating it to `0` by the time the `time_pct` value becomes `1.0`. If the
    `m_alpha_fade` flag is not set, the alpha value is set to `255` (full opacity).
    Here is the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_alpha_fade`变量为`true`，代码将修改alpha值，使其在`time_pct`值变为`1.0`时插值为`0`。如果`m_alpha_fade`标志未设置，alpha值将设置为`255`（完全不透明）。以下是代码：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the `m_color_mod` flag is `true`, we need to use `time_pct` to interpolate
    between the starting channel color value and the ending channel color value in
    order to find the current channel color value:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`m_color_mod`标志为`true`，我们需要使用`time_pct`来在起始通道颜色值和结束通道颜色值之间进行插值，以找到当前通道颜色值：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After finding the interpolated value for each of the color channels, we need
    to use `time_pct` to interpolate the current scale. Then, we set our destination
    width and destination height based on that current scale value, and the dimensions
    of the source rectangle:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 找到每个颜色通道的插值值后，我们需要使用`time_pct`来插值当前比例。然后，我们根据当前比例值和源矩形的尺寸设置目标宽度和目标高度：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last thing we will do is decrease the `m_ttl` variable (time to live) by
    `diff_time` (time since the previous frame render). If the time to live drops
    to or below `0`, we deactivate the particle, make it available in the particle
    pool, and stop it from rendering. If there is still some time to live, we set
    the `m_src.x` (source rectangle *x* value) to the proper location for the frame
    we want to render:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做的最后一件事是减少`m_ttl`变量（存活时间）的值，减去`diff_time`（自上一帧渲染以来的时间）。如果存活时间降至或低于`0`，我们将停用粒子，使其在粒子池中可用，并停止渲染。如果还有一些存活时间，我们将`m_src.x`（源矩形*x*值）设置为我们要渲染的帧的正确位置：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Particle Render function
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子渲染函数
- en: 'The final function in our `Particle` class is the `Render` function. The `Emitter`
    class calls this function for every active particle in the particle pool. The
    function sets the alpha and color channel values on the sprite texture used by
    the particle. It then checks the `m_align_rotation` flag to see if the texture
    needs to be copied to the back buffer using `SDL_RenderCopy` or `SDL_RederCopyEx`.
    The difference between these two render calls is that `SDL_RenderCopyEx` allows
    the copy to be rotated or flipped. Both of these functions use the `m_src` rectangle
    to determine a rectangle inside of the texture to copy. Both use the `m_dest`
    rectangle to determine the destination in the back buffer, where we copy our texture
    data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Particle`类中的最后一个函数是`Render`函数。`Emitter`类为粒子池中的每个活动粒子调用此函数。该函数在粒子使用的精灵纹理上设置alpha和颜色通道值。然后，它检查`m_align_rotation`标志，看看纹理是否需要使用`SDL_RenderCopy`或`SDL_RederCopyEx`复制到后台缓冲区。这两个渲染调用之间的区别在于`SDL_RenderCopyEx`允许复制进行旋转或翻转。这两个函数都使用`m_src`矩形来确定要复制的纹理内的矩形。两者都使用`m_dest`矩形来确定后台缓冲区中的目的地，我们在那里复制我们的纹理数据：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the next section, we will discuss how to modify our `Emitter` class to accommodate
    our improvements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论如何修改我们的`Emitter`类以适应我们的改进。
- en: Modifying the Emitter class
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改`Emitter`类
- en: As I mentioned earlier, when we discussed the `Emitter` class, it manages and
    emits particles. In a typical particle system, you may have many emitters. In
    our game, we will eventually allow for multiple emitters, but in this tool, we
    will keep to a single emitter for simplicity. We have four functions defined in
    the `Emitter` class, and we will be changing three of them. The only function
    that will not require a change is the `GetFreeParticle` function. If you don't
    remember, `GetFreeParticle` loops through `m_particle_pool` (the particle pool
    attribute) looking for particles that are not marked as active (`particle->m_active
    == false`). If it finds one, it returns that particle. If not, it returns `null`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，在讨论`Emitter`类时，它管理和发射粒子。在典型的粒子系统中，可能会有许多发射器。在我们的游戏中，最终会允许多个发射器，但在这个工具中，为了简单起见，我们将保持单个发射器。`Emitter`类中定义了四个函数，我们将更改其中的三个。唯一不需要更改的函数是`GetFreeParticle`函数。如果你不记得，`GetFreeParticle`循环遍历`m_particle_pool`（粒子池属性），寻找未标记为激活的粒子（`particle->m_active
    == false`）。如果找到，它返回该粒子。如果没有找到，它返回`null`。
- en: The Emitter constructor function
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器构造函数
- en: 'The code for the `Emitter` constructor will need to change to allow us to set
    the attributes that are required to support the new particle system functionality.
    The following is the code for the new `Emitter` constructor:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`构造函数的代码将需要更改，以便我们可以设置支持新粒子系统功能所需的属性。以下是新`Emitter`构造函数的代码：'
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Enough of this code has changed that I feel it makes sense to walk through the
    entire function. The first two lines set the `color` attribute, and then activate
    the emitter by setting `m_active` to `true`. We set this active flag to `true`
    when an emitter is created or updated. If it is a looping emitter, the active
    flag will remain on indefinitely. If `Emitter` does not loop, the emitter will
    stop emitting when it reaches the end of its emit time, as set by the `emit_time_ms`
    parameter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码已经改变了很多，我觉得有必要逐步讲解整个函数。前两行设置了`color`属性，然后通过将`m_active`设置为`true`来激活发射器。当发射器被创建或更新时，我们将此激活标志设置为`true`。如果是循环发射器，激活标志将一直保持激活状态。如果`Emitter`不循环，当它达到由`emit_time_ms`参数设置的发射时间结束时，发射器将停止发射。
- en: 'The next thing we do is set the minimum and maximum starting velocities. We
    have a little code in `Emitter` that makes sure that `max_starting_velocity` is
    greater than `min_starting_velocity`, but when we move this code into the game,
    we may choose to just set the values to whatever works well. Here is the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是设置最小和最大起始速度。我们在`Emitter`中有一些代码，确保`max_starting_velocity`大于`min_starting_velocity`，但当我们将这段代码移到游戏中时，我们可能选择将值设置为任何有效的值。以下是代码：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After we set the velocities, an SDL surface is created using a `sprite_file`
    string, which is the location of the file we have loaded into the WebAssembly
    virtual filesystem. If that file is not in the virtual filesystem, we print out
    an error message and exit the constructor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置速度后，使用`sprite_file`字符串创建一个SDL表面，这是我们加载到WebAssembly虚拟文件系统中的文件的位置。如果该文件不在虚拟文件系统中，我们会打印出错误消息并退出构造函数：
- en: '[PRE46]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After creating the surface from the image file, we use that surface to create
    an SDL texture called `m_sprite_texture`, and then we use `SDL_FreeSurface` to
    destroy the memory that was used by the surface because it is no longer needed
    now that we have a texture. Then, we call `SDL_QueryTexture` to retrieve the width
    and the height of the sprite texture and use them to set the `Emitter` attributes
    `m_sprite_width` and `m_sprite_height`. Here is the code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在从图像文件创建表面后，我们使用该表面创建一个名为`m_sprite_texture`的SDL纹理，然后我们使用`SDL_FreeSurface`来销毁表面使用的内存，因为现在我们已经有了纹理，表面就不再需要了。然后，我们调用`SDL_QueryTexture`来检索精灵纹理的宽度和高度，并使用它们来设置`Emitter`的属性`m_sprite_width`和`m_sprite_height`。以下是代码：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The next thing we need to do is set the `m_max_particles` attribute and use
    that variable to initialize the particle pool. A `for` loop is used to push new
    particles to the back of the `std::vector` variable, `m_particle_pool`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要设置`m_max_particles`属性，并使用该变量初始化粒子池。使用`for`循环将新粒子推送到`std::vector`变量`m_particle_pool`的末尾：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After setting up the particle pool, we use the parameters to set the emitter''s
    attributes for the old and the new particle system values:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好粒子池后，我们使用参数设置了旧和新粒子系统值的发射器属性：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Emitter update logic
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器更新逻辑
- en: 'The `Update` function of `Emitter` is similar to the constructor, but runs
    when `Emitter` already exists and needs to be updated. This function begins by
    setting all of the attribute variables on our `Emitter`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`的`Update`函数类似于构造函数，但在`Emitter`已经存在且需要更新时运行。此函数首先设置`Emitter`上的所有属性变量：'
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After we set the attribute variables, we may need to either increase or decrease
    the size of the `m_particle_pool` vector (the particle pool). If the number of
    particles in our pool is greater than the new maximum number of particles, we
    can shrink the particle pool with a simple resize. If the particle pool is too
    small, we will need to loop over the code that creates new particles and adds
    those particles to the pool. We do this until the size of the pool matches the
    new maximum number of particles. Here is the code that does that:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置属性变量后，我们可能需要增加或减少`m_particle_pool`向量（粒子池）的大小。如果我们的粒子池中的粒子数量大于新的最大粒子数量，我们可以通过简单的调整大小来缩小粒子池。如果粒子池太小，我们需要循环遍历创建新粒子并将这些粒子添加到池中的代码。我们一直这样做，直到池的大小与新的最大粒子数量匹配。以下是执行此操作的代码：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now that we have resized the particle pool, we need to loop over every particle
    inside of that pool and run the `Update` function on each particle to make sure
    that every particle updates with the new attribute values. Here is the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调整了粒子池的大小，我们需要循环遍历该池中的每个粒子，并对每个粒子运行`Update`函数，以确保每个粒子都使用新的属性值进行更新。以下是代码：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Emitter Move function
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射器移动函数
- en: 'The final emitter function we need to update is the `Emitter::Move` function.
    This function determines whether it emits any new particles this frame, and if
    so, how many. It also uses randomization to pick many of the starting values of
    these particles, within the ranges passed in from our HTML. After spawning any
    new particles, the function will loop over the particle pool, moving and rendering
    any particles that are currently active. Here is the full code for this function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新的最后一个发射器函数是`Emitter::Move`函数。这个函数确定本帧是否发射任何新粒子，以及如果是，有多少。它还使用随机化来选择这些粒子的许多起始值，这些值在我们的HTML中传递的范围内。在生成任何新粒子后，函数将循环遍历粒子池，移动和渲染当前处于活动状态的任何粒子。以下是这个函数的完整代码：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will break this code into two parts to make it easier to understand. The
    first part of the `Move` function is responsible for spawning new particles when
    necessary. The second portion is responsible for moving and rendering any existing
    active particles. The particle spawning portion of this code is only run if `m_active`
    (the active flag) is `true`. The second part will run either way. When an emitter
    is deactivated, we don't want all of the particles that have been spawned by the
    emitter to disappear suddenly. Instead, we would like all the particles to continue
    to be moved and rendered until they have all been deactivated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这段代码分成两部分，以便更容易理解。`Move`函数的第一部分负责在必要时生成新粒子。第二部分负责移动和渲染任何已激活的粒子。只有当`m_active`（活动标志）为`true`时，才会运行这段代码的粒子生成部分。第二部分无论如何都会运行。当发射器停用时，我们不希望由发射器生成的所有粒子突然消失。相反，我们希望所有粒子继续移动和渲染，直到它们全部被停用。
- en: 'We are now going to walk through the code in smaller chunks to explain everything:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐步解释代码中的每个部分：
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This first chunk of code checks the `m_active` attribute variable to make sure
    that the emitter is currently active. If it isn't, we can skip over the part of
    this function that spawns new particles. The next thing we do is subtract `diff_time`
    from the `m_next_emission` attribute. When the `m_next_emission` attribute hits
    or goes below `0`, another particle will spawn. We also subtract `diff_time` from
    `m_ttl`, which is the time to live attribute. Immediately after subtracting from
    `m_ttl`, we check the value in `m_ttl` to see if it is less than or equal to `0`.
    If time to live drops below `0`, we need to check to see whether this is a looping
    emitter by looking at the `m_loop` attribute. If it is a looping emitter, we reset
    the time to live variable, and we set the `m_has_burst` flag to `false`. If this
    is not a looping emitter, we deactivate the emitter by setting `m_active` to `false`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先检查`m_active`属性变量，以确保发射器当前处于活动状态。如果不是，我们可以跳过生成新粒子的部分。接下来我们要做的是从`m_next_emission`属性中减去`diff_time`。当`m_next_emission`属性达到或低于`0`时，将生成另一个粒子。我们还从`m_ttl`中减去`diff_time`，这是存活时间属性。在从`m_ttl`中减去后，我们立即检查`m_ttl`中的值，看它是否小于或等于`0`。如果存活时间低于`0`，我们需要检查`m_loop`属性，看这是否是一个循环发射器。如果是循环发射器，我们重置存活时间变量，并将`m_has_burst`标志设置为`false`。如果这不是一个循环发射器，我们通过将`m_active`设置为`false`来停用发射器。
- en: 'The following chunk of code has to do with emitting bursts of particles using
    the new burst feature:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块涉及使用新的爆发功能发射粒子的部分：
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The burst particle feature is new to our *advanced particle system*. We are
    using a nested `if` statement here. We could have put `&&` on the end of the first
    `if` and done this with one `if` statement, but I wanted to separate conditions
    to make it easier to understand. The outer `if` statement first checks to see
    if the `m_burst_particles` attribute (the number of burst particles) is greater
    than `0`. If it is, then this emitter uses the burst system and will need to create
    a burst of particles at the proper burst time. The next check in this outer `if`
    statement is to check if the burst has already run in this emitter. Because of
    the way we have designed this burst system, there can only be one burst per emission
    loop. So, if the `m_has_burst` attribute is `true`, then a burst will not run.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 爆发粒子功能是我们*高级粒子系统*的新功能。我们在这里使用了嵌套的`if`语句。我们本可以在第一个`if`的末尾加上`&&`，用一个`if`语句完成，但我想分开条件以便更容易理解。外部`if`语句首先检查`m_burst_particles`属性（爆发粒子的数量）是否大于`0`。如果是，那么这个发射器使用爆发系统，并需要在适当的爆发时间创建一波粒子。这个外部`if`语句中的下一个检查是检查爆发是否已经在这个发射器中运行过。由于我们设计了这个爆发系统的方式，每次发射循环只能有一个爆发。因此，如果`m_has_burst`属性为`true`，则不会运行爆发。
- en: Moving on to the inner loop, we need to check to see whether we have passed
    the burst time for our emission. The `m_burst_time_pct` attribute holds a value
    between `0.0` and `1.0` that represents the decimal percentage of time through
    the emission at which the particle burst happens. The `m_ttl` variable holds the
    time to live in milliseconds for the emitter. If we divide `m_ttl` by `m_emit_loop_ms`
    (the emit time in milliseconds), we get an emit time countdown from `1.0` to `0.0`,
    where `0.0` means the emission is complete. The `m_burst_time_pct` variable goes
    in the other direction. A value of `0.6` means that the burst happens 60% of the
    way through our emission. Because the other side of this `if` statement is a countdown
    and the burst time counts up, we need to subtract `m_burst_time_pct` from `1.0`
    to make a proper comparison. If `(float)m_ttl / (float)m_emit_loop_ms` is less
    than `1.0 - m_burst_time_pct`, then we are ready for the burst. To make the burst
    happen, we first set `m_has_burst = true`. This will prevent the burst from happening
    multiple times in the same emission. We then subtract the number of burst particles,
    multiplied by the emission time in milliseconds, from `m_next_emission`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 继续内部循环，我们需要检查是否已经超过了发射的爆发时间。`m_burst_time_pct`属性保存了一个值，介于`0.0`和`1.0`之间，表示粒子爆发发生的时间百分比。`m_ttl`变量保存了发射器的存活时间（以毫秒为单位）。如果我们将`m_ttl`除以`m_emit_loop_ms`（以毫秒为单位的发射时间），我们得到一个从`1.0`到`0.0`的发射时间倒计时，其中`0.0`表示发射完成。`m_burst_time_pct`变量则相反。值为`0.6`表示爆发发生在我们发射的60%处。因为这个`if`语句的另一侧是一个倒计时，而爆发时间是递增的，我们需要从`1.0`中减去`m_burst_time_pct`来进行适当的比较。如果`(float)m_ttl
    / (float)m_emit_loop_ms`小于`1.0 - m_burst_time_pct`，那么我们准备好进行爆发。为了进行爆发，我们首先设置`m_has_burst
    = true`。这将防止在同一次发射中多次发生爆发。然后，我们从`m_next_emission`中减去爆发粒子的数量，乘以以毫秒为单位的发射时间。
- en: 'The following few lines of code enter a `while` loop that emits particles as
    long as the next emission time is less than `0`. In the previous version of this
    code, we had an `if` statement here instead of a loop. This limited our particle
    system to emit no more than one particle per frame. That may work for some simple
    particle systems without a burst mode, but once you add a burst, you need to be
    able to emit many particles in a single frame. Let''s take a look at this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行代码进入一个`while`循环，只要下一个发射时间小于`0`，就会发射粒子。在这段代码的先前版本中，我们在这里有一个`if`语句而不是一个循环。这限制了我们的粒子系统每帧只能发射一个粒子。这对一些简单的没有爆发模式的粒子系统可能有效，但一旦添加了爆发，就需要能够在单帧中发射许多粒子。让我们来看看这个：
- en: '[PRE56]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `while` loop checks to see whether `m_next_emission` is less than or equal
    to `0`. The line immediately after that adds `m_emission_time_ms` to the next
    emission. The effect of this is that if we had subtracted a large number from
    `m_next_emission` (like we did in our burst), this loop would allow us to emit
    multiple particles in a single run of our `Move` function. This means we can emit
    numerous particles in a single frame. What we do immediately after the addition
    to `m_next_emission` is get a free particle from our particle pool by making a
    call to `GetFreeParticle`. If we make the maximum number of particles too small,
    `GetFreeParticle` might run out of particles we can use and return `NULL`. If
    this is the case, we need to skip all of the steps that emit a new particle, which
    is why there is the `if` statement, which checks for a `NULL` particle.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环检查`m_next_emission`是否小于或等于`0`。紧接着的一行将`m_emission_time_ms`添加到下一个发射时间。这样做的效果是，如果我们从`m_next_emission`中减去了一个大数（就像我们在爆发中做的那样），这个循环将允许我们在`Move`函数的单次运行中发射多个粒子。这意味着我们可以在单帧中发射许多粒子。在添加到`m_next_emission`后，我们立即从粒子池中获取一个空闲粒子，通过调用`GetFreeParticle`。如果我们将最大粒子数设置得太小，`GetFreeParticle`可能会用尽我们可以使用的粒子并返回`NULL`。如果是这种情况，我们需要跳过所有发射新粒子的步骤，这就是为什么有`if`语句来检查`NULL`粒子的原因。'
- en: Once we know that we can spawn a particle, we need to grab a bunch of random
    values inside of the ranges we set in the HTML file. The C/C++ `rand()` function
    returns a random integer number. Most of the values we need are floating points.
    We will need to write a simple function called `get_random_float`. This function
    gets a random floating-point number with three decimal precision that falls between
    a min and a max value passed into it. We chose three-decimal precision based on
    our needs for this game. The function can be modified for higher precision if
    that is necessary later.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们可以生成一个粒子，我们需要在HTML文件中设置的范围内获取一堆随机值。C/C++的`rand()`函数返回一个随机整数。我们需要的大多数值都是浮点数。我们需要编写一个简单的名为`get_random_float`的函数。这个函数获取一个随机的浮点数，保留三位小数，落在传入的最小值和最大值之间。我们根据这个游戏的需求选择了三位小数的精度。如果以后有必要，这个函数可以修改为更高的精度。
- en: 'Here is the code that gets random values for use with the newly spawned particle:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为新生成的粒子获取随机值的代码：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The random values we get here are the distance from our emitter at which we
    will generate the particle, the velocity of the particle, the particle directional
    angle, and the starting and ending scale values. Because we would like the particle
    that is spawned at a given angle from the center of our emitter to also have the
    same directional velocity, we have assigned a random number to only the *x* values
    of `spawn_point` and `velocity_point`. We are going to use the same angle we generated
    randomly earlier to rotate both of those points. Here is the rotation code for
    those points:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里得到的随机值是我们将生成粒子的发射器距离，粒子的速度，粒子的方向角以及起始和结束的比例值。因为我们希望从我们的发射器中心生成的粒子也具有相同的方向速度，所以我们只给`spawn_point`和`velocity_point`的*x*值分配了一个随机数。我们将使用之前随机生成的相同角度来旋转这两个点。这是这些点的旋转代码：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We generate the spawn points with a position relative to an origin of `0,0`.
    Because our emitter is probably not at `0,0`, we need to adjust the position of
    the spawn point by the values in the `m_position` point. Here is the code we use
    to do that:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相对于`0,0`原点的位置生成生成点。因为我们的发射器可能不在`0,0`，所以我们需要通过`m_position`点的值来调整生成点的位置。这是我们用来做到这一点的代码：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last thing we do is spawn the particle with the values we randomly generated:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一件事是使用我们随机生成的值生成粒子：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that the function has completed spawning the particles for the current
    frame, the function will need to loop over the particle pool looking for active
    particles to move and render:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数已经完成了为当前帧生成粒子，函数需要循环遍历粒子池，寻找活跃的粒子进行移动和渲染：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the next section, we will update the C++/WebAssembly functions we are calling
    from our JavaScript.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新从JavaScript调用的C++/WebAssembly函数。
- en: External functions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部函数
- en: The *advanced particle system* we are writing has two external functions that
    can be called from the JavaScript in our app. These functions, `add_emitter`,
    and `update_emitter`, are called to either insert or modify the particle system
    in the WebAssembly module. The `advanced_particle.cpp` file contains these functions,
    as well as the `main` function, which is called when the `Module` is loaded, and
    the `show_emission` function, which is called once per frame render. We will not
    need to modify the `main` and the `show_emission` functions from what we created
    for the basic particle system earlier in this chapter. We will, however, need
    to add the additional parameters we put into our JavaScript code to `add_emitter`
    and `update_emitter`. Also, we have created a utility function called `get_random_float`,
    which we use when spawning particles. Because this file contains all of our other
    C-style functions, I feel that `advanced_particle.cpp` is the best place to put
    this function as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写的*高级粒子系统*具有两个可以从我们应用程序的JavaScript中调用的外部函数。这些函数`add_emitter`和`update_emitter`用于在WebAssembly模块中插入或修改粒子系统。`advanced_particle.cpp`文件包含这些函数，以及`main`函数，当加载`Module`时调用，以及`show_emission`函数，每帧渲染调用一次。我们不需要修改`main`和`show_emission`函数，因为我们在本章前面为基本粒子系统创建了这些函数。但是，我们需要将我们在JavaScript代码中放入的附加参数添加到`add_emitter`和`update_emitter`中。此外，我们创建了一个名为`get_random_float`的实用函数，我们在生成粒子时使用它。因为这个文件包含了我们的其他所有C风格函数，我觉得`advanced_particle.cpp`是放置这个函数的最佳位置。
- en: Random floating-point numbers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机浮点数
- en: 'Let''s start by discussing the new `get_random_float` function. Here is the
    code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论新的`get_random_float`函数。以下是代码：
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `%` (modulo operator) is used to make the random integer value between 0
    and whatever value you use after `%`. The modulo operator is a remainder operator.
    It returns the remainder of a division operation. For example, `13 % 10` would
    return 3, as would `23 % 10`. Taking `% 10` of any number will always result in
    a number between 0 and 9\. Modulo is useful in conjunction with `rand()` because
    it will result in a random number between 0 and the value after `%`. So, `rand()
    % 10` will result in a random number between 0 and 9.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`％`（取模运算符）用于使随机整数值在`％`后使用的任何值之间的0和值之间。取模运算符是一个余数运算符。它返回除法运算的余数。例如，`13％10`将返回3，`23％10`也将返回3。对任何数字取`％10`将始终得到0到9之间的数字。取模与`rand()`结合使用很有用，因为它将导致在`％`后的值之间的随机数。因此，`rand()％10`将导致在0和9之间的随机数。'
- en: 'The `get_random_float` function takes in a minimum and maximum float value
    and generates a random number within that range. The first two lines take those
    float values, multiply them by 1,000, and cast them to an integer. Because `rand()`
    only works with integers, we need to simulate a precision value. Multiplying by
    1,000 gives us three-decimal precision. If, for instance, we want to generate
    a random number between 1.125 and 1.725, both of those values would be multiplied
    by 1,000, and we would use `rand()` to generate a random value between 1,125 and
    1,175:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_random_float`函数接受最小和最大浮点值，并在该范围内生成随机数。前两行获取这些浮点值，将它们乘以1,000，并将它们转换为整数。因为`rand()`只能使用整数，所以我们需要模拟一个精度值。乘以1,000给我们三位小数的精度。例如，如果我们想在1.125和1.725之间生成一个随机数，那么这两个值都将乘以1,000，我们将使用`rand()`在1,125和1,175之间生成一个随机值：'
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once again, `rand()` only generates random integers, and using the `%` (modulo
    operator) alongside `rand()` will give you a number between `0` and the number
    that follows `%`. Because of this, we want to know the difference between our
    `int_min` and `int_max` values. If we subtract `int_min` from `int_max`, we will
    get a number that is this difference. We could potentially be thrown off if the
    calling code accidentally passes in a value for max that is smaller than the value
    for `int_min`, so we need a little bit of code to check whether `max` is smaller
    than `min`, and if it is, we need to switch those two values. Here is that `if`
    statement code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`rand()`只生成随机整数，并且与`rand()`一起使用`％`（取模运算符）将给出`0`和`％`后面的数字之间的数字。因此，我们想知道`int_min`和`int_max`值之间的差异。如果我们从`int_min`中减去`int_max`，我们将得到这个差异的数字。如果调用代码意外地传递了一个比`int_min`的值更小的值，我们可能会被扔掉，因此我们需要一点代码来检查`max`是否小于`min`，如果是，我们需要交换这两个值。以下是`if`语句代码：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can go ahead and get the difference between the two:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续获取两者之间的差异。
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the following line of code, we get a random value between 0 and the value
    in `int_diff`. We are using the `?:` (ternary operator) to make sure that `int_diff`
    is not 0 before we execute `rand() % int_diff`. The reason for this is that `%`
    is a division remainder operator, so, like dividing by 0, executing `% 0` results
    in an exception. If there is no difference between our minimum and maximum values,
    we will return the minimum value. So, by using the ternary operator, we can set
    `int_rand` to 0 if `int_diff` is 0\. Here''s the code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们获取0和`int_diff`值之间的随机值。我们使用`?:`（三元运算符）来确保在执行`rand() % int_diff`之前，`int_diff`不为0。这样做的原因是`%`是一个除法余数运算符，所以，就像除以0一样，执行`%
    0`会导致异常。如果我们的最小值和最大值之间没有差异，我们将返回最小值。因此，通过使用三元运算符，如果`int_diff`为0，我们可以将`int_rand`设置为0。以下是代码：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, we add `int_min` to `int_rand`, and we have a random value between the
    `int_min` and `int_max` values:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`int_min`添加到`int_rand`，这样我们就得到了`int_min`和`int_max`值之间的随机值：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The last thing we need to do is cast `int_rand` to a `float` and divide it
    by `1000.0`. This will return a floating-point value that falls between the `min`
    and `max` floating-point values that are passed into the function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是将`int_rand`转换为`float`并除以`1000.0`。这将返回一个浮点值，介于传入函数的`min`和`max`浮点值之间。
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Adding an emitter
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个发射器
- en: 'The `add_emitter` function is a pass-through that checks to see if there is
    an existing emitter and deletes it if there is. It then creates a new `Emitter`
    object, passing in all of the values we set in our HTML and passed through in
    JavaScript. The changes we need to make include adding the new parameters into
    the signature of the `add_emitter` function, and adding those same new parameters
    into the call to the `Emitter` constructor. In both the function signature and
    the constructor call, we will add a `/* new parameters */` comment that shows
    where old parameters end and the new ones begin. Here is the new code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_emitter`函数是一个通过函数，用于检查是否存在发射器，如果存在则删除它。然后创建一个新的`Emitter`对象，传入我们在HTML中设置并通过JavaScript传递的所有值。我们需要做的更改包括将新参数添加到`add_emitter`函数的签名中，并将这些新参数添加到`Emitter`构造函数的调用中。在函数签名和构造函数调用中，我们将添加一个`/*
    new parameters */`注释，显示旧参数的结束和新参数的开始位置。以下是新代码：'
- en: '[PRE69]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Updating an emitter
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新发射器
- en: 'The changes we made to the `update_emitter` function mirror those made in the
    `add_emitter` function. The primary differences between `add_emitter` and `update_emitter`
    are that `update_emitter` will not run if there is not an existing emitter, and
    instead of calling the `Emitter` constructor to create a new `Emitter`, it calls
    an existing emitter''s `Update` function. The `Update` function passes in all
    of the new values and most of the old ones (except for `char* file_name`). Just
    like with the changes we made to the `add_emitter` function, we have placed a
    `/* new parameters */` comment in the function signature and the call to the emitter
    `Update` function to show where the new parameters have been added. Here is the
    code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`update_emitter`函数所做的更改与`add_emitter`函数中所做的更改相似。`add_emitter`和`update_emitter`之间的主要区别在于，如果没有现有的发射器，`update_emitter`将不会运行，而不是调用`Emitter`构造函数来创建新的`Emitter`，它调用现有发射器的`Update`函数。`Update`函数传入所有新值和大部分旧值（除了`char*
    file_name`）。就像我们对`add_emitter`函数所做的更改一样，我们在函数签名和发射器`Update`函数的调用中放置了一个`/* new
    parameters */`注释，以显示新参数已添加的位置。以下是代码：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the next section, we will configure our *advance particle system tool* to
    create a new *particle emitter*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将配置我们的*高级粒子系统工具*来创建一个新的*粒子发射器*。
- en: Configuring the particle emitter
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置粒子发射器
- en: At this point, you may be wondering when we are going to get back to writing
    the game. We built this *particle emitter configuration tool* for a few reasons.
    First of all, it is difficult to configure a particle system in compiled code.
    If we wanted to test a configuration for an emitter, we would need to recompile
    our values with every test, or we would need to write a data loader, and rerun
    the game after making configuration changes. Creating a tool that allows us to
    test different emitter configurations allows for faster (and more interesting)
    particle system creation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能想知道我们何时会回到编写游戏。我们构建这个*粒子发射器配置工具*有几个原因。首先，在编译代码中配置粒子系统是很困难的。如果我们想测试发射器的配置，我们需要在每次测试时重新编译我们的值，或者我们需要编写一个数据加载程序，并在进行配置更改后重新运行游戏。创建一个允许我们测试不同发射器配置的工具可以加快（并且更有趣）粒子系统的创建。
- en: HTML shell and WebAssembly module interaction
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML外壳和WebAssembly模块交互
- en: I also had an ulterior motive for creating a particle system configuration tool.
    It is possible that some of you may not be reading this book to learn game programming,
    per se. You may have purchased this book as a fun way to learn more about WebAssembly.
    Writing this tool was a fun way to learn more about the interaction between a
    WebAssembly module and the HTML and JavaScript that drives that module.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建粒子系统配置工具还有一个别有用心的动机。有可能你们中的一些人并不是为了学习游戏编程而阅读这本书。您可能购买这本书是为了以一种有趣的方式了解更多关于WebAssembly。编写这个工具是一种有趣的方式来了解WebAssembly模块与驱动该模块的HTML和JavaScript之间的交互。
- en: Compiling and running the new tool
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和运行新工具
- en: Now that we have all the parameters we would like, it is time to recompile the
    updated version of the configuration tool and start designing some particle systems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有我们想要的参数，是时候重新编译更新版本的配置工具并开始设计一些粒子系统了。
- en: If you are building this from the GitHub project, you will need to run this
    compile command from the `/Chapter09/advanced-particle-tool/` directory.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从GitHub项目构建的，您需要从`/Chapter09/advanced-particle-tool/`目录运行编译命令。
- en: 'First, run the following on the command line to compile the new configuration
    tool:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在命令行上运行以下命令来编译新的配置工具：
- en: '[PRE71]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Open the web page in `emrun` or a web browser (if you are running a web server).
    It will look something like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`emrun`中打开网页或者在Web浏览器中打开（如果您正在运行Web服务器）。它会看起来像这样：
- en: '![](img/a987a969-a6ae-4290-98c9-c7285611d17f.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a987a969-a6ae-4290-98c9-c7285611d17f.png)'
- en: 'Figure 9.3: Screenshot of our particle system configuration tool'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：我们的粒子系统配置工具的屏幕截图
- en: 'We are going to start with a simple exhaust emitter. Make the following changes
    to the HTML values and click the Upload .png button:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的排气发射器开始。对HTML值进行以下更改，然后点击“上传.png”按钮：
- en: 'min angle: -10'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小角度：-10
- en: 'max angle: 10'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大角度：10
- en: 'max particles: 500'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大粒子数：500
- en: 'emission rate: 50'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射速率：50
- en: 'radius: 0.5'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径：0.5
- en: 'min start vel: 100.0'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小起始速度：100.0
- en: 'max start vel: 150.0'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大起始速度：150.0
- en: 'burst time: 0.7'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆发时间：0.7
- en: 'burst particles: 40'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆发粒子数：40
- en: 'animation frames: 6'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画帧数：6
- en: When you have clicked the Upload .png button, navigate to the `ProjectileExpOrange.png`
    file in the image directory and open it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击“上传.png”按钮后，转到图像目录中的“ProjectileExpOrange.png”文件并打开它。
- en: 'Here is a screenshot of what the config tool looks like with our exhaust particle
    emitter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置工具与我们的排气粒子发射器的屏幕截图：
- en: '![](img/0cbb0c41-5fb0-470b-a355-bd404fc6df29.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cbb0c41-5fb0-470b-a355-bd404fc6df29.png)'
- en: 'Figure 9.4: Engine exhaust configuration'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：引擎排气配置
- en: I would encourage you to play around with the values until you get something
    you like. Whenever you change the values on the left-hand side of the page, you
    will need to click the Update Emitter button to see that new value reflected in
    the particle system on the right-hand side of the web page.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您尝试不同的值，直到您得到满意的效果。每当您更改页面左侧的值时，您需要点击“更新发射器”按钮，以查看新值在网页右侧的粒子系统中的反映。
- en: Creating a particle emitter
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建粒子发射器
- en: Now that we have an exhaust particle system, we are going to start adding the
    particle system code into the game to add some nice particle effects. I would
    like to have a particle system for the player and enemy ship exhaust. I would
    also like to add a particle system effect on top of the animated explosion we
    have to make it stand out.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个排气粒子系统，我们将开始将粒子系统代码添加到游戏中，以添加一些漂亮的粒子效果。我想为玩家和敌人的飞船排气口添加一个粒子系统。我还想在我们的动画爆炸上添加一个粒子系统效果，使其更加突出。
- en: The first thing we are going to do is copy the `particle.cpp` and `emitter.cpp`
    files into the main `Chapter09` directory. After that, we will need to add those
    class definitions to the `game.hpp` file, as well as to the `get_random_float`
    function prototype.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是将`particle.cpp`和`emitter.cpp`文件复制到主`Chapter09`目录中。之后，我们需要将这些类定义添加到`game.hpp`文件，以及`get_random_float`函数原型。
- en: Changes to game.hpp
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对game.hpp的更改
- en: 'The first set of changes we need to make are to the `game.hpp` file. We need
    to add an `Emitter` class definition, a `Particle` class definition, and an external
    function prototype for `get_random_float`. We also need to add some new attributes
    to the `Ship` class. Here is the line we must add for the `get_random_float` prototype:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一组更改是对`game.hpp`文件。我们需要添加一个`Emitter`类定义，一个`Particle`类定义，以及一个`get_random_float`的外部函数原型。我们还需要向`Ship`类添加一些新属性。这是我们必须添加的`get_random_float`原型的行：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Adding the Particle class definition
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Particle类定义
- en: 'The definition for the `Particle` class that we must add to `game.hpp` is the
    same definition that we have for our advanced configuration tool. Because it is
    the same, we will not walk through what everything in the class does. If you don''t
    remember, please feel free to go back to the previous chapter as a reference.
    Here is the class definition code for `Particle` that we''ll be adding to `game.hpp`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须添加到`game.hpp`的`Particle`类的定义与我们的高级配置工具相同。因为它是相同的，我们不会逐一介绍类中的每个内容。如果您不记得，请随时返回到上一章作为参考。这是我们将添加到`game.hpp`的`Particle`类定义代码：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Emitter class definition
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emitter类定义
- en: 'The `Emitter` class has a few additional attributes we have added that help
    the `Emitter` position itself relative to the game objects. There is a `Run` function
    that we do not need in the particle emitter configuration tool, but we will need
    it in the game code so that we can trigger the `Emitter` at any time. The `Update`
    function inside of `Emitter` and `Particle` are not necessary inside of the game,
    but we are going to leave them in there in order to not complicate the changes.
    The Emscripten dead code elimination logic should remove that code when it compiles
    the game anyway. Here is the new code for the `Emitter` class definition that
    we need to add to `games.hpp`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Emitter`类有一些额外的属性，我们已经添加了这些属性，这些属性帮助`Emitter`相对于游戏对象定位。有一个`Run`函数，我们在粒子发射器配置工具中不需要，但在游戏代码中需要，这样我们就可以随时触发`Emitter`。`Emitter`和`Particle`内部的`Update`函数在游戏中并不是必需的，但我们将它们保留在那里，以免复杂化更改。Emscripten死代码消除逻辑应该在编译游戏时删除该代码。这是我们需要添加到`games.hpp`的`Emitter`类定义的新代码：'
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The code we added to the particle system configuration tool is surrounded by
    comments labeled `added`. Let me walk through what each of these new attributes
    and the new function does. Here are the first two added attributes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到粒子系统配置工具的代码被标记为“添加”的注释所包围。让我逐一介绍每个新属性和新函数的作用。以下是前两个添加的属性：
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'These two values are adjustments, and are used to modify the position at which
    the emitter spawns particles. These variables are useful for small adjustments
    to particle positions relative to the position of an object the emitter is following.
    Here are the following three attributes that we have added:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值是调整值，用于修改发射器产生粒子的位置。这些变量对于相对于发射器跟随的对象位置的粒子位置进行小的调整非常有用。以下是我们添加的三个属性：
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: These are pointers to the x, y, and rotational attributes of a parent object.
    If we set `Emitter->m_parent_rotation_ptr = &m_Rotation`, for instance, that pointer
    will point to the rotation of our parent object, and we will be able to access
    that value inside of our `Emitter` to adjust the rotation. The same holds true
    for `m_parent_x_ptr` and `m_parent_y_ptr`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是父对象的x、y和旋转属性的指针。例如，如果我们设置`Emitter->m_parent_rotation_ptr = &m_Rotation`，那么该指针将指向我们父对象的旋转，我们将能够在我们的`Emitter`中访问该值以调整旋转。对于`m_parent_x_ptr`和`m_parent_y_ptr`也是如此。
- en: 'Finally, we have added a `Run` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个`Run`函数：
- en: '[PRE77]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This function allows a particle emitter, that is not looping, to be restarted.
    We will be using this for the `Explosion` emitter that we added to the `Ship`
    class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数允许一个不循环的粒子发射器重新启动。我们将在`Ship`类中使用这个函数来使用我们添加的`Explosion`发射器。
- en: Changes to emitter.cpp
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: emitter.cpp的更改
- en: Now that we have walked through the changes that we need to make to `game.hpp`,
    we are going to walk through all of the changes that we will make to the `emitter.cpp`
    file, function by function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们需要对`game.hpp`进行的更改，我们将逐个函数地了解我们将对`emitter.cpp`文件进行的所有更改。
- en: Changes to the constructor function
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的更改
- en: 'There are two changes to be made to the constructor function. First, we''ll
    add some initialization at the top that initializes all of the new pointers to
    `NULL`. We do not need these pointers in every emitter, so we can check against
    `NULL` to see when they are or are not used. Further down, we will modify the
    values that are passed into the constructors from degrees to radians. Here is
    what the function looks like:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要做两个更改。首先，我们将在顶部添加一些初始化，将所有新指针初始化为`NULL`。我们不需要在每个发射器中使用这些指针，所以我们可以检查`NULL`来查看它们何时被使用。在更下面，我们将修改传递给构造函数的值，从角度改为弧度。函数如下所示：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The first changes are at the very top of this function, and set our new pointer
    attributes to `NULL`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首次更改是在函数的顶部，将我们的新指针属性设置为`NULL`：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Later, we will check to see if these pointers are `NULL`, and if not, we will
    use `m_parent_rotation_ptr` to adjust the rotation angle of this emitter. We will
    use `m_parent_x_ptr` to change the x coordinate of the emitter, and we will use
    `m_parent_y_ptr` to adjust the y coordinate of this emitter. After that, we have
    the code that modifies the passed in minimum and maximum angles from degrees to
    radians:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将检查这些指针是否为`NULL`，如果不是，我们将使用`m_parent_rotation_ptr`来调整该发射器的旋转角度。我们将使用`m_parent_x_ptr`来改变发射器的x坐标，我们将使用`m_parent_y_ptr`来调整该发射器的y坐标。之后，我们有修改传入的最小和最大角度从角度到弧度的代码：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The real reason we need to do this is that we are hardcoding the values we pass
    into the emitter. If we created a data loader, we could have done this conversion
    when the data loaded up. But, because we are taking these values straight out
    of our *particle emitter configuration tool* and hardcoding the values right into
    the call to the new emitter, we will either have to remember to do the conversion
    ourselves every time we change these values, or we will have to do it from within
    the constructor and the `Update` function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做的真正原因是，我们正在将传递给发射器的值硬编码。如果我们创建了一个数据加载器，我们可以在数据加载时进行转换。但是，因为我们直接从*粒子发射器配置工具*中取出这些值，并将这些值硬编码到对新发射器的调用中，我们要么必须记住每次更改这些值时自己进行转换，要么必须在构造函数和`Update`函数中进行转换。
- en: Changes to the Update function
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新函数的更改
- en: 'The `Update` function is not likely to ever be called inside our game. Emscripten''s
    dead code removal process should eliminate it. However, we haven''t removed it
    from the `Emitter` class. If you think you may ever call this, you might want
    to change the `m_min_angle` and `m_max_angle` initialization to convert from degrees
    into radians, like we did in the constructor:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update`函数不太可能在我们的游戏中被调用。Emscripten的死代码删除过程应该会将其消除。但是，我们还没有从`Emitter`类中删除它。如果你认为可能会调用它，你可能想要将`m_min_angle`和`m_max_angle`的初始化改为从角度转换为弧度，就像我们在构造函数中所做的那样。'
- en: '[PRE81]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Adding a Run function
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Run函数
- en: 'In the particle system configuration tool, we didn''t need a `Run` function
    because calling the `Update` function would run `Emitter`. The `Update` function
    is far too cumbersome to use inside our game. It uses a large number of configuration
    variables that we may not have access to when we call the function. All we want
    to do is set the emitter to active, reset the time to live, and the burst flag.
    Instead of calling `Update`, we create a small `Run` function to do what we need:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子系统配置工具中，我们不需要`Run`函数，因为调用`Update`函数将运行`Emitter`。`Update`函数在我们的游戏中使用起来太过繁琐。它使用了大量的配置变量，当我们调用函数时可能无法访问。我们只想设置发射器为活动状态，重置生存时间和爆发标志。我们创建了一个小的`Run`函数来做我们需要的事情：
- en: '[PRE82]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Setting `m_active` to true makes the emitter active so that it can spawn new
    particles when calling the `Move` function. Resetting `m_ttl` to `m_emit_loop_ms`
    makes sure that the time to live does not automatically shut the emitter down
    the next time it calls the `Move` function. Setting `m_has_burst = false` makes
    sure that, if there is a particle burst that must occur somewhere in the emission,
    it will run.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 将`m_active`设置为true会使发射器处于活动状态，这样在调用`Move`函数时就可以生成新的粒子。将`m_ttl`重置为`m_emit_loop_ms`可以确保生存时间不会在下一次调用`Move`函数时自动关闭发射器。将`m_has_burst
    = false`确保了，如果在发射中必须发生粒子爆发，它将运行。
- en: Changes to the Move function
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Move函数的更改
- en: 'The new version of the `Move` function will need to be able to modify its position
    based on a parent position and rotate its defined position based on the parent''s
    rotation. It will also need to be able to make minor adjustments using `m_x_adjustment`
    and `m_y_adjustment`. Here is the new version of `Move` in its entirety:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move`函数的新版本需要能够根据父位置修改其位置，并根据父旋转旋转其定义的位置。它还需要能够使用`m_x_adjustment`和`m_y_adjustment`进行微小调整。以下是`Move`的新版本：'
- en: '[PRE83]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Most of this code is the same as it was in earlier versions. Let''s walk through
    the differences. First, we need to rotate this entire particle system if there
    is a rotated parent object. We will use this for the exhaust particle system that
    we will be adding to the spaceship objects. This exhaust has to be positioned
    relative to the spaceship. To do that, we need to take the position and rotate
    it. We also need to add the parent''s rotation to the existing emission angle.
    Here is the new code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码与早期版本相同。让我们来看看其中的不同之处。首先，如果有旋转的父对象，我们需要旋转整个粒子系统。我们将用于将排气粒子系统添加到飞船对象的这一功能。这个排气必须相对于飞船进行定位。为此，我们需要获取位置并进行旋转。我们还需要将父对象的旋转添加到现有的发射角度。以下是新代码：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'At the top, we create a new `Point` object called `rotated_position`. If the
    `m_parent_rotation_ptr` is not `NULL`, we add that value to the emission angle
    we calculated earlier. We will copy the values of `m_position` into `rotated_position`
    and `Rotate` that position by the parent''s rotation. Later, we will check whether
    `m_parent_rotation_ptr` is not `NULL`, and if not, we will use `rotated_position`
    relative to the parent object''s position to calculate the location of the emitter.
    The following is an `if` statement that checks whether `m_parent_rotation_ptr
    == NULL`. If it is null, the first part of this `if` block does what would have
    been done earlier. Here is the code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们创建了一个名为“rotated_position”的新“Point”对象。如果“m_parent_rotation_ptr”不为“NULL”，我们将该值添加到我们之前计算的发射角度上。我们将“m_position”的值复制到“rotated_position”中，并通过父对象的旋转对该位置进行旋转。稍后，我们将检查“m_parent_rotation_ptr”是否不为“NULL”，如果不是，我们将使用“rotated_position”相对于父对象的位置来计算发射器的位置。以下是一个检查“m_parent_rotation_ptr
    == NULL”的“if”语句。如果它为空，该“if”块的第一部分将执行之前的操作。以下是代码：
- en: '[PRE85]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Because the `if` statement was checking whether `m_parent_rotation_ptr == NULL`,
    we don''t want to use the rotated version of the particle system''s position.
    That block defaulted to using the `m_position` attribute unmodified. If `m_parent_rotation_ptr`
    is not `NULL`, we will run the following `else` block:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 因为“if”语句是在检查“m_parent_rotation_ptr == NULL”，我们不想使用粒子系统位置的旋转版本。该块默认使用未修改的“m_position”属性。如果“m_parent_rotation_ptr”不为“NULL”，我们将运行以下“else”块：
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This code uses a rotated version of `m_position`. Next, we want to see whether
    `m_parent_x_ptr` and `m_parent_y_ptr` are not `NULL`. If they aren''t, then we
    need to add the parent''s position to the `spawn_point` using these values. Here
    is that piece of code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了“m_position”的旋转版本。接下来，我们要查看“m_parent_x_ptr”和“m_parent_y_ptr”是否不为“NULL”。如果不是，“spawn_point”将使用这些值添加父对象的位置。以下是这段代码：
- en: '[PRE87]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The final piece of code we will add to the `Move` function is the micro adjustment
    to the spawn point. Sometimes, particle systems need a little bit of tweaking
    before rotation to have them look just right. Therefore, we add the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“Move”函数中添加的最后一段代码是对生成点进行微调。有时，粒子系统在旋转之前需要进行一些微调，以使它们看起来更加完美。因此，我们添加以下内容：
- en: '[PRE88]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The values of `m_x_adjustment` and `m_y_adjustment` default to `0`, so if you
    want to use these values, they will need to be set sometime after creating the
    emitter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: “m_x_adjustment”和“m_y_adjustment”的值默认为“0”，因此如果要使用这些值，它们需要在创建发射器后的某个时候进行设置。
- en: Changes to ship.cpp
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对ship.cpp的更改
- en: The next thing we are going to do is modify the `ship.cpp` file to make use
    of two new particle emitters. We want a particle emitter for the ship's exhaust,
    and one to improve the ship's explosion. We are going to need to make changes
    to the `Ship` class' constructor, the `Ship` class' `Acceleration` function, and
    the `Ship` class' `Render` function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要修改“ship.cpp”文件，以使用两个新的粒子发射器。我们需要一个用于飞船排气的粒子发射器，以及一个用于改善飞船爆炸效果的粒子发射器。我们需要对“Ship”类的构造函数、加速函数和渲染函数进行更改。
- en: The Ship class' constructor function
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ship类的构造函数
- en: 'The `Ship` class'' constructor function has changed most of the functions inside
    of the `Ship` class. We are not only initializing new attributes – we also need
    to set the parent and adjustment values on the emitters. Here is the new code
    for the constructor:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: “Ship”类的构造函数已更改了“Ship”类内的大部分函数。我们不仅初始化了新属性，还需要在发射器上设置父对象和调整值。以下是构造函数的新代码：
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The first several lines haven''t changed from the old version. The new changes
    start when we initialize `m_Accelerating` to `false`. After that, we set up the
    exhaust emitter, first creating a new emitter, then setting the parent values
    and the adjustment values, and finally, we set it to inactive:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行与旧版本相同。新更改从将“m_Accelerating”初始化为“false”开始。之后，我们设置排气发射器，首先创建一个新的发射器，然后设置父对象值和调整值，最后将其设置为非活动状态：
- en: '[PRE90]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'All of those values that are passed into the `Emitter` function come straight
    from the *particle system configuration tool*. We have to add them manually into
    our function call. If we were working on a large project, this would not be very
    scalable. We would probably have the configuration tool create some sort of data
    file (for example, JSON or XML). But for expediency, we have simply hardcoded
    these values based on what we had inside of the configuration tool. Unfortunately,
    the values are not in the same order that they appear inside of the tool. You
    will need to look at the signature of the `Emitter` constructor to make sure that
    you put the values in the right place:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 所有传入“Emitter”函数的值都直接来自*粒子系统配置工具*。我们需要手动将它们添加到我们的函数调用中。如果我们在一个大型项目上工作，这种方法就不太可扩展。我们可能会让配置工具创建某种数据文件（例如JSON或XML）。但出于迅速的目的，我们只是根据配置工具中的内容硬编码了这些值。不幸的是，这些值的顺序与工具中的顺序不同。您需要查看“Emitter”构造函数的签名，以确保将值放在正确的位置：
- en: '[PRE91]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The first parameter, `sprite_file`, is the location of your file in the virtual
    filesystem. That file is not automatically included in your project. You will
    need to make sure that it is in the right location. We put the file in the `sprites`
    directory and use the following flag when we run Emscripten:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`sprite_file`是虚拟文件系统中文件的位置。该文件不会自动包含在项目中。您需要确保它在正确的位置。我们将文件放在`sprites`目录中，并在运行Emscripten时使用以下标志：
- en: '[PRE92]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'After creating our `Exhaust` emitter, we create an `Explosion` emitter with
    the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Exhaust`发射器后，我们使用以下代码创建`Explosion`发射器：
- en: '[PRE93]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The creation of the `m_Explode` emitter is similar to the `m_Exhaust` emitter,
    but we have different values that we pass into the emitter based on what we created
    in the *particle emitter configuration tool*:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`m_Explode`发射器类似于`m_Exhaust`发射器，但我们根据在*粒子发射器配置工具*中创建的内容传递不同的值给发射器：
- en: '![](img/803f6bd8-9791-4cb1-aa82-2aaff1deb10f.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/803f6bd8-9791-4cb1-aa82-2aaff1deb10f.png)'
- en: 'Figure 9.5: Explosion configuration'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：爆炸配置
- en: As with the `m_Exhaust` emitter, we will need to set all of the parent pointer
    variables and deactivate the emitter. Unlike `m_Exhaust`, we won't need to make
    fine adjustments using the `m_x_adjustment` and `m_y_adjustment` attributes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与`m_Exhaust`发射器一样，我们需要设置所有父指针变量并停用发射器。不像`m_Exhaust`，我们不需要使用`m_x_adjustment`和`m_y_adjustment`属性进行微调。
- en: The Ship class' Acceleration function
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞船类的加速函数
- en: 'We want to run the exhaust emitter only when the ship is accelerating. To do
    this, we will need to set a flag inside of our ship''s `Accelerate` function.
    Here is the new version of the acceleration function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想在飞船加速时运行排气发射器。为此，我们需要在飞船的`Accelerate`函数内设置一个标志。以下是加速函数的新版本：
- en: '[PRE94]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The only change is the addition of the line at the beginning, which sets `m_Accelerating`
    to `true`. When we are rendering the ship, we can check this flag and start or
    stop the emitter based on the value inside it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是在开头添加了一行，将`m_Accelerating`设置为`true`。当我们渲染飞船时，我们可以检查这个标志，并根据其中的值启动或停止发射器。
- en: The Ship class' Render function
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞船类的渲染函数
- en: 'The final changes to the `Ship` class are in the ship''s `Render` function.
    Inside this function, we will need to add code that moves and renders the two
    new particle systems, as well as code that will turn the exhaust on if the ship
    is accelerating, and off if it isn''t. Here is the new version of the function:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Ship`类的最终更改在飞船的`Render`函数中。在这个函数内部，我们需要添加移动和渲染两个新的粒子系统的代码，以及在飞船加速时打开排气的代码，以及在飞船不加速时关闭排气的代码。以下是函数的新版本：
- en: '[PRE95]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Take a look at the first block of added code, near the top:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下添加的第一个代码块，靠近顶部：
- en: '[PRE96]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The call to the `Move` function on an emitter both moves and renders all of
    the particles inside of the particle system. It also spawns new particles if it
    is time for the emitter to do that. At the very end of the function, there is
    code to handle the exhaust emitter:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在发射器上调用`Move`函数会移动和渲染粒子系统中的所有粒子。如果是发射器执行生成新粒子的时间，它也会生成新粒子。在函数的最后，有处理排气发射器的代码：
- en: '[PRE97]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This code checks to see if the `m_Accelerating` flag is `false`. If it is, we
    deactivate the exhaust emitter. If the ship is accelerating, we set the `m_active`
    flag to `true`. We don't make a call to the `Run` function, because we are doing
    this every frame, and we don't want to start the *time to live* over on that emitter
    every time we loop. The last line sets `m_Accelerating` to `false`. We do this
    because we don't have anywhere in our code that detects when a ship stops accelerating.
    If the ship is accelerating, that flag will be set back to `true` before we get
    to this point in the code. If not, it will stay set to `false`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查`m_Accelerating`标志是否为`false`。如果是，我们就停用排气发射器。如果飞船正在加速，我们将`m_active`标志设置为`true`。我们不调用`Run`函数，因为我们每帧都在做这个操作，我们不希望每次循环都重新开始*存活时间*。最后一行将`m_Accelerating`设置为`false`。我们这样做是因为我们的代码中没有检测飞船停止加速的地方。如果飞船正在加速，该标志将在代码的这一点之前被设置为`true`。如果没有，它将保持为`false`。
- en: Changes to projectile_pool.cpp
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对projectile_pool.cpp的更改
- en: 'We don''t need to change a lot inside of the `ProjectilePool` class. In fact,
    we only need to make two changes to one function. The `MoveProjectiles` function
    inside of the `ProjectilePool` class performs all of the collision detection between
    projectiles and our two ships. If a ship is destroyed, we run the `m_Explode`
    particle emitter on that ship. That will require two new lines of code inside
    of the hit test condition for each of the ships. Here is the new version of the
    `MoveProjectiles` function:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在`ProjectilePool`类内部做太多改动。实际上，我们只需要对一个函数进行两次更改。`ProjectilePool`类内的`MoveProjectiles`函数执行所有的项目和我们的两艘飞船之间的碰撞检测。如果一艘飞船被摧毁，我们就会在那艘飞船上运行`m_Explode`粒子发射器。这将需要在每艘飞船的碰撞检测条件内添加两行新代码。以下是`MoveProjectiles`函数的新版本：
- en: '[PRE98]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The two lines of code I have added are for the calls to `player->m_Explode->Run();`
    and `enemy->m_Explode->Run();`. These lines execute when the player's ship or
    the enemy ship collides with one of the projectiles and is destroyed.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加的两行代码是对`player->m_Explode->Run();`和`enemy->m_Explode->Run();`的调用。这些行在玩家飞船或敌方飞船与其中一个抛射物发生碰撞并被摧毁时执行。
- en: Changes to main.cpp
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对main.cpp的更改
- en: 'The last change we need to make in order to add exhaust and explosion particle
    systems is to the `main.cpp` file. This change requires the addition of a single
    function, `get_random_float`. We discussed this function earlier. It is a way
    for our particle emitter to get random floating-point values that fall between
    a minimum and a maximum value. Here is the code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个改变是在`main.cpp`文件中添加排气和爆炸粒子系统。这个改变需要添加一个函数`get_random_float`。我们之前讨论过这个函数。这是我们的粒子发射器获取随机浮点值的方法，这些值介于最小值和最大值之间。以下是代码：
- en: '[PRE99]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Compiling the new particle_system.html file
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译新的particle_system.html文件
- en: Now that we have made all the necessary changes to our files, we can go ahead
    and use Emscripten to compile and test the new version of the game.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对文件进行了所有必要的更改，我们可以继续使用Emscripten来编译和测试游戏的新版本。
- en: If you are building this from the GitHub project, you will need to run this
    compile command from the `/Chapter09/` directory. The previous compile was done
    from inside the `/Chapter09/advanced-particle-tool/` directory, so make sure that
    you are in the right place when you run this command; otherwise, it won't have
    the files it needs to build the game.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从GitHub项目构建此项目，您需要从`/Chapter09/`目录运行此编译命令。之前的编译是在`/Chapter09/advanced-particle-tool/`目录中完成的，因此请确保在运行此命令时您在正确的位置；否则，它将没有构建游戏所需的文件。
- en: 'Execute the following command from the command line:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行以下命令：
- en: '[PRE100]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Taking it further
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步进行
- en: We will not be writing a data export tool for configuration. This chapter is
    too long as it is. When you are creating particle systems, you can spend a near
    infinite amount of time tweaking them to your liking. Particle systems can have
    a tremendous number of configuration parameters. You can even have Bézier curves
    for movement, rotation, and scaling. Some advanced particle systems have particles
    that emit other particles. There is no limit to the complexity that we can add
    to a particle system, but there is a limit to the number of pages I can have in
    this book, so I encourage you to take this system and add to it until you get
    the results you want.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会编写一个用于配置的数据导出工具。这一章已经太长了。当您创建粒子系统时，您可以花费几乎无限的时间来微调它们以满足您的喜好。粒子系统可以有大量的配置参数。您甚至可以使用贝塞尔曲线进行移动、旋转和缩放。一些高级粒子系统可以发射其他粒子。我们可以为粒子系统添加的复杂性没有限制，但是我在这本书中可以添加的页面数量是有限的，因此我鼓励您继续完善这个系统，直到您获得想要的结果。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You have made it through a very long, information-packed chapter.
    In the last two chapters, we discussed what particle systems are and why they
    are used. We learned how to add files to, and how to access, the WebAssembly virtual
    filesystem. We learned how to create more advanced interactions between the HTML
    shell file and the WebAssembly module. We then constructed a more advanced particle
    emitter configuration tool with a lot more functionality. After constructing some
    nice looking particle systems in the tool, we took the data and code and used
    it to construct two new particle emitters inside the game we have been building.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经通过了一个非常漫长、信息丰富的章节。在过去的两章中，我们讨论了粒子系统是什么以及为什么要使用它们。我们学会了如何向WebAssembly虚拟文件系统添加文件以及如何访问它。我们学会了如何在HTML外壳文件和WebAssembly模块之间创建更高级的交互。然后，我们使用更多功能构建了一个更高级的粒子发射器配置工具。在工具中构建了一些漂亮的粒子系统后，我们将数据和代码用于构建了我们一直在构建的游戏中的两个新粒子发射器。
- en: In the next chapter, we will be discussing and building AI for our enemy spaceship.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并构建敌方飞船的人工智能。
