- en: Chapter 3. A Matter of Character
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。角色问题
- en: A video game wouldn't be much fun without characters, and this chapter is all
    about bringing your game characters to life. Games typically have two kinds of
    characters. First, there is the character or characters that you are playing as.
    These are called the player characters. The characters that are controlled by
    the computer are called the non-player characters or NPCs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 没有角色，视频游戏就不会有趣。本章全部关于让您的游戏角色栩栩如生。游戏通常有两种角色。首先，有你扮演的角色或角色。这些被称为玩家角色。由计算机控制的角色被称为非玩家角色或NPC。
- en: 'This chapter will explain how to create characters for your game. Along the
    way we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何为您的游戏创建角色。在这个过程中，我们将涵盖：
- en: '**Sprites**: Sprites are any textures that the player interacts with in the
    game. This includes the player characters, NPCs, and other objects in the game.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小精灵**：小精灵是玩家在游戏中与之交互的任何纹理。这包括玩家角色、NPC和游戏中的其他物体。'
- en: '**Animation**: The art of making an image appear to move is called animation.
    You will learn how to use multiple images to make your textures move on the screen.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：使图像看起来像是在移动的艺术称为动画。您将学习如何使用多个图像使您的纹理在屏幕上移动。'
- en: '**Atlases**: Images can be stored one at a time, or they can be combined into
    single composite texture known as a **sprite sheet** or an **atlas**.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图集**：图像可以逐个存储，也可以组合成单个复合纹理，称为**精灵图集**或**图集**。'
- en: Spritely speaking
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小精灵式地说
- en: Many years ago, a computer geek invented a cool way to render and display small
    images on a computer screen. These images would move around on the screen and
    even collide with other objects. The computer geek called these images sprites,
    and that name has stuck ever since.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，一位计算机爱好者发明了一种酷炫的方法，在计算机屏幕上渲染和显示小图像。这些图像会在屏幕上移动，甚至与其他物体发生碰撞。这位计算机爱好者将这些图像称为小精灵，这个名字一直沿用至今。
- en: Sprites versus non-sprites
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小精灵与无小精灵
- en: A sprite is simply an image that represents an object on the screen. Examples
    of sprites include characters, NPCs, weapons, alien spaceships, and rocks. Anything
    that can move on the screen or be hit by another object in the game is a sprite.
    Objects that don't interact with other objects aren't sprites. Examples might
    include mountains in the background, the ground, and the sky.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 小精灵只是代表屏幕上对象的图像。小精灵的例子包括角色、NPC、武器、外星太空船和岩石。任何可以在屏幕上移动或被游戏中的其他物体击中的对象都是小精灵。不与其他物体交互的对象不是小精灵。例子可能包括背景中的山脉、地面和天空。
- en: Obviously, it takes both sprites and non-sprites to implement a game. Also,
    the distinction is a little arbitrary. Some games implement all of the images
    in the game as sprites because it is more convenient to treat all images in the
    game in a consistent manner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，要实现一个游戏，既需要小精灵也需要无小精灵。此外，这种区分有点任意。有些游戏将游戏中的所有图像都实现为小精灵，因为将游戏中的所有图像以一致的方式处理更为方便。
- en: Flipbook animation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻页动画
- en: Did you ever create a flipbook when you were a kid? To jog your memory, here
    is how it worked. First, you sketched a simple figure on a notepad. Then you went
    to the next page and sketched the same image, but this time something was slightly
    different. You continued sketching images that were slightly different from the
    original on successive pages. When you were done, you flipped the pages at the
    notebook edge and saw what appeared to be a rudimentary movie.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你小时候有没有制作过翻页书？为了唤起你的记忆，这里是如何工作的。首先，你在笔记本上画了一个简单的图形。然后你翻到下一页，画了同样的图像，但这次有一点不同。你继续在连续的页面上画一些与原始图像略有不同的图像。当你完成时，你翻动笔记本边缘的页面，看到了看似是一部原始的电影。
- en: '![Flipbook animation](img/8188OS_03_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![翻页动画](img/8188OS_03_01.jpg)'
- en: Another example is a movie. Movies are recorded on film as frames. The film
    is then run through a projector, which plays the film back one frame at a time.
    The key, as mentioned before, is to play frames back at least 24 frames per second
    to fool the eye into thinking that there is fluid motion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是电影。电影以帧的形式记录在胶片上。然后，胶片通过放映机播放，放映机逐帧播放电影。如前所述，关键是至少以每秒24帧的速度播放帧，以欺骗眼睛，使其认为有流畅的运动。
- en: Framed animation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧动画
- en: 2D sprite animation works much like a flipbook. An artist draws successive versions
    of an image. When the images are rendered one after another, it appears to move.
    Each image in an animation is called a frame. It takes at least 24 or more fps
    to create a convincing animation. Obviously, more frames will create a smoother
    animation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2D精灵动画的工作方式与翻页书类似。艺术家绘制图像的连续版本。当这些图像依次渲染时，它们看起来就像在移动。动画中的每一张图像被称为一帧。至少需要24或更多fps才能创建一个令人信服的动画。显然，更多的帧将创建一个更平滑的动画。
- en: '![Framed animation](img/8188OS_03_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![框架动画](img/8188OS_03_02.jpg)'
- en: The preceding image illustrates a very simple animation using four frames. The
    only thing that changes is the robot's arm position. Played in sequence from **Frame
    1** through **Frame 4**, the arm would appear to swing from the front to the back
    and then forward again. If this was combined with moving the sprite to the right,
    then you would get a very simple animation of a walking robot.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图像展示了一个使用四个帧的非常简单的动画。唯一改变的是机器人的手臂位置。从**帧1**到**帧4**依次播放，手臂看起来会从前面摆动到后面，然后再向前摆动。如果将这个动作与将精灵向右移动结合起来，那么你将得到一个简单的行走机器人的动画。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As the preceding example illustrates, I am not an artist! I am a coder, so the
    art created for this book will be very simple. It is actually common for very
    simple placeholder art to be used in the initial stages of a game. This allows
    the programmers to test features of the game while the art team is working on
    the real art that will be put in the game at a later stage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我并不是一个艺术家！我是一个程序员，所以这本书中创建的艺术将会非常简单。实际上，在游戏的初始阶段，使用非常简单的占位符艺术是很常见的。这允许程序员在艺术团队在后期阶段将真正的艺术作品放入游戏的同时测试游戏的功能。
- en: Creating sprites
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建精灵
- en: Professional 2D artists use programs, such as Adobe Photoshop, to create 2D
    assets for a game. Unfortunately, we can't take the time to teach you how to use
    a program as sophisticated as Photoshop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 专业2D艺术家使用Adobe Photoshop等程序为游戏创建2D资源。不幸的是，我们没有时间教你如何使用像Photoshop这样复杂的程序。
- en: If you want to play around with creating your own assets, then you might try
    the Paint program that comes installed on any Windows based computer. If you really
    want to dig deep into 2D art creation without digging deeply into your bank account,
    then you can download GIMP ([http://www.gimp.org](http://www.gimp.org)), a free,
    full-features 2D image manipulation program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试创建自己的资源，那么你可以尝试在任意基于Windows的电脑上安装的Paint程序。如果你真的想深入挖掘2D艺术创作而不需要深入挖掘你的银行账户，那么你可以下载GIMP
    ([http://www.gimp.org](http://www.gimp.org))，这是一个免费的全功能2D图像处理程序。
- en: Working with PNGs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PNGs
- en: In the previous chapter, we loaded and rendered a bitmap file. It turns out
    that bitmaps aren't the best format to work with sprites because they take more
    file space (and therefore, more memory) than PNGs, and bitmaps do not support
    transparency.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们加载并渲染了一个位图文件。结果发现，位图并不是处理精灵的最佳格式，因为它们比PNGs占用更多的文件空间（因此，更多的内存），并且位图不支持透明度。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before we had image formats that allowed transparency to be directly encoded
    as part of the image, we used a specific background color, and then expected our
    image library to remove that color when it handled the image. Magenta was often
    used as the background because it is a color rarely used in images.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了允许直接将透明度编码为图像一部分的图像格式之前，我们使用特定的背景颜色，并期望我们的图像库在处理图像时移除该颜色。由于洋红色在图像中很少使用，因此经常被用作背景颜色。
- en: Bitmaps are larger in file size than PNGs because they are not stored in a compressed
    format. Compression allows an image to be stored in less space, and this can be
    very important on devices, such as mobile phones.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 位图文件的大小比PNGs大，因为它们不是以压缩格式存储的。压缩允许图像以更小的空间存储，这在设备上，如手机上，可能非常重要。
- en: PNGs are stored using a **lossless** compression algorithm. Lossless means that
    the image quality is not sacrificed to achieve the compression. Other formats,
    such as JPEG, can be stored in a compressed format, but use a **lossy** algorithm
    that degrades the image quality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PNGs使用**无损**压缩算法进行存储。无损意味着为了达到压缩效果，不会牺牲图像质量。其他格式，如JPEG，可以以压缩格式存储，但使用的是**有损**算法，这会降低图像质量。
- en: PNGs also support transparency using an **alpha** channel. In addition to storing
    the red, green, and blue component of each pixel (RGB), PNGs also store each pixel's
    transparency in the alpha channel (RGBA).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PNG还支持使用**alpha**通道进行透明度。除了存储每个像素的红色、绿色和蓝色成分（RGB）外，PNG还存储每个像素的透明度在alpha通道中（RGBA）。
- en: You will recall from the previous chapter that all textures are represented
    as rectangles in a game. However, real shapes aren't rectangular. Trees, cars,
    and robots all have much more complex shapes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得，在前一章中，所有纹理在游戏中都表示为矩形。然而，真实形状并不是矩形的。树木、汽车和机器人都有更复杂的形状。
- en: If we used bitmaps for all of our images, then the full rectangle of the texture
    would be rendered blocking out everything behind the sprite. In the following
    image, our robot is passing in front of a pipe, and part of the pipe is occluded
    by the blank space in the bitmap.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用位图作为所有图像，那么纹理的全矩形将渲染，遮挡掉精灵后面的所有内容。在以下图像中，我们的机器人在管道前通过，管道的一部分被位图的空白区域遮挡。
- en: '![Working with PNGs](img/8188OS_03_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![处理PNG图像](img/8188OS_03_03.jpg)'
- en: 'In a PNG image, we set the blank space to be transparent. In the following
    image, the pipe is no longer occluded by the transparent parts of the image of
    the robot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在PNG图像中，我们将空白区域设置为透明。在以下图像中，管道不再被机器人的图像透明部分遮挡：
- en: '![Working with PNGs](img/8188OS_03_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![处理PNG图像](img/8188OS_03_04.jpg)'
- en: In the previous chapter, we wrote a code to load a BMP file. Normally, we would
    have to write different code to load a PNG file. In fact, we would have to write
    a loader for each different type of image we wanted to work with.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了加载BMP文件的代码。通常，我们不得不编写不同的代码来加载PNG文件。实际上，我们必须为每种我们想要处理的图像类型编写一个加载器。
- en: 'Fortunately, someone has already done all of this work and made it available
    in a library known as **SOIL**: **Simple OpenGL Image Library**. You can download
    your copy from [http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有人已经做了所有这些工作，并将其作为一个名为**SOIL**（**简单OpenGL图像库**）的库提供。您可以从[http://www.lonesock.net/soil.html](http://www.lonesock.net/soil.html)下载您的副本。
- en: 'There are several advantages to using the SOIL library:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SOIL库有几个优点：
- en: We no longer have to worry about writing our own loader for every type of image
    that we want to use. SOIL supports BMP, PNG, and many other formats.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要担心为每种我们想要使用的图像类型编写自己的加载器。SOIL支持BMP、PNG以及许多其他格式。
- en: File loading is not completely abstracted. You don't have to worry about how
    the code works, only that it does.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件加载不是完全抽象的。您不必担心代码是如何工作的，只需知道它确实可以工作。
- en: SOIL has other features that may be useful (such as the ability to write out
    image files).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOIL具有其他可能有用的功能（例如，能够写入图像文件）。
- en: The download comes as a zipped folder. Once you unzip the folder, you will see
    a folder named `Simple OpenGL Image Library`. This folder contains a lot of files,
    but we only need `soil.h`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件以压缩文件夹的形式提供。一旦解压文件夹，您将看到一个名为`Simple OpenGL Image Library`的文件夹。这个文件夹包含很多文件，但我们只需要`soil.h`。
- en: Linking to the SOIL library
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到SOIL库
- en: 'Now, it is time to add the SOIL library to our project:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将SOIL库添加到我们的项目中了：
- en: Find the folder where you unzipped the SOIL code.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您解压SOIL代码的文件夹。
- en: Open the `lib` folder and find `libSOIL.a`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`lib`文件夹，找到`libSOIL.a`。
- en: Copy `libSOIL.a` to the folder that contains the **RoboRacer2D** source code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`libSOIL.a`复制到包含**RoboRacer2D**源代码的文件夹中。
- en: Open the **RoboRacer2D** project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**RoboRacer2D**项目。
- en: Right-click on the **RoboRacer2D** project in the **Solution Explorer** panel
    and choose **Properties**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**面板中右键单击**RoboRacer2D**项目，并选择**属性**。
- en: For the **Configuration** drop-down box, make sure that you select **All Configurations**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**配置**下拉框，请确保您选择了**所有配置**。
- en: Open the **Configuration Properties** branch, then the **Linker** branch.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**配置属性**分支，然后是**链接器**分支。
- en: Select the **Input** option.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**输入**选项。
- en: Click the dropdown for **Additional Dependencies** and choose **<Edit…>**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**附加依赖项**下拉菜单，选择**<编辑…**>。
- en: Enter `opengl32.lib` and `glu32.lib` on separate lines in the dialog window
    and click **OK**.![Linking to the SOIL library](img/8188OS_03_05.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框窗口中分别输入`opengl32.lib`和`glu32.lib`，然后点击**确定**。![链接到SOIL库](img/8188OS_03_05.jpg)
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Library files for Windows usually end in `.lib`, while those written for UNIX
    end in `.a`. The standard SOIL distribution comes with the UNIX library; you need
    to use the Windows library. You can either find `SOIL.lib` online, use the SOIL
    source code to create your own Windows library file, or download SOIL.lib from
    the book's website.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 的库文件通常以 `.lib` 结尾，而为 UNIX 编写的文件以 `.a` 结尾。标准的 SOIL 发行版附带 UNIX 库；您需要使用
    Windows 库。您可以在网上找到 `SOIL.lib`，使用 SOIL 源代码创建自己的 Windows 库文件，或者从本书的网站上下载 SOIL.lib。
- en: Including the SOIL header file
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含 SOIL 头文件
- en: 'Next, we need to copy the SOIL header file into our project and include it
    in our code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 SOIL 头文件复制到我们的项目中，并在代码中包含它：
- en: Find the folder where you unzipped the SOIL code.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您解压 SOIL 代码的文件夹。
- en: Open the `src` folder and find `SOIL.h`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `src` 文件夹并找到 `SOIL.h`。
- en: Copy `SOIL.h` to the folder that contains the **RoboRacer2D** source code.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SOIL.h` 复制到包含 **RoboRacer2D** 源代码的文件夹。
- en: Open the **RoboRacer2D** project.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **RoboRacer2D** 项目。
- en: Open `RoboRacer2D.cpp`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `RoboRacer2D.cpp`。
- en: Add `#include "SOIL.h"` to the list of includes.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `#include "SOIL.h"` 添加到包含列表中。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will notice that there are many other files that were unzipped as part of
    the SOIL package. This includes all of the original source files and several samples
    for how to use the library.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到 SOIL 包中还有许多其他文件被解压出来。这包括所有原始源文件以及几个如何使用库的示例。
- en: Opening an image file
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开图像文件
- en: Now, we are ready to write a function that loads an image file. We will pass
    in the name of the file, and the function will return an integer representing
    a handle on the OpenGL texture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备编写一个加载图像文件的函数。我们将传递文件名，该函数将返回一个表示 OpenGL 纹理句柄的整数。
- en: 'The following lines of code uses SOIL to load an image:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行使用 SOIL 加载图像：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All of the work is done by the call to `SOIL_load_OGL_texture`. The four parameters
    are the most generic settings:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都是由 `SOIL_load_OGL_texture` 调用完成的。这四个参数是最通用的设置：
- en: The first parameter is the path and filename to the image file.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是图像文件的路径和文件名。
- en: The second parameter tells SOIL how to load the image (and in this case, we
    indicate that we want SOIL to figure things out automatically).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数告诉 SOIL 如何加载图像（在这种情况下，我们指示 SOIL 自动解决问题）。
- en: The third parameter tells SOIL to create an OpenGL texture ID for us.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数告诉 SOIL 为我们创建一个 OpenGL 纹理 ID。
- en: The fourth parameter, if used, can be set to several flag bits that tell SOIL
    to perform some custom processing. We are not using this, so we just send a 0.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用，第四个参数可以设置为几个标志位，告诉 SOIL 执行一些自定义处理。我们目前没有使用这个，所以我们只发送一个 `0`。
- en: We will use code, such as this one, to load images into our `sprite` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用代码，例如这个，将图像加载到我们的 `sprite` 类中。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to see all of the options available to you, open `SOIL.h` and read
    the source code comments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看所有可用的选项，请打开 `SOIL.h` 并阅读源代码注释。
- en: Coding a sprite class
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写精灵类代码
- en: In order to easily incorporate sprites into our game, we will create a class
    specifically for dealing with sprites.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松地将精灵集成到我们的游戏中，我们将创建一个专门处理精灵的类。
- en: 'Let''s think about the features that we want:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们想要的功能：
- en: An array of images.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组图像。
- en: An index that represents the current frame.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示当前帧的索引。
- en: A variable that holds the total number of frames.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量，存储总帧数。
- en: Variables to store the current *x* and *y* position of the sprite. For this
    game, this will be the upper-left corner of the image.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量用于存储精灵当前 *x* 和 *y* 位置。对于这个游戏，这将图像的左上角。
- en: A variable that stores the x and y components of the current velocity of the
    sprite (`0` if it isn't moving).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量，存储精灵当前速度的 x 和 y 分量（如果没有移动则为 `0`）。
- en: Variables that store the width and height of the image. Note that if the sprite
    has multiple images, they must all be the same size.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储图像宽度和高度的变量。注意，如果精灵有多个图像，它们必须都是相同的大小。
- en: A Boolean that tells us if this sprite collides with other sprites.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，告诉我们这个精灵是否与其他精灵发生碰撞。
- en: A Boolean that tells us if this sprite should be rendered normal or flipped.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，告诉我们这个精灵应该正常渲染还是翻转。
- en: A Boolean that tells us if this sprite is visible right now.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，告诉我们这个精灵现在是否可见。
- en: A Boolean that tells us if this sprite is active right now.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值，告诉我们这个精灵现在是否是活跃的。
- en: 'In addition to these properties, we would also like to be able to manipulate
    the sprite in several ways. We may add methods to:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些属性外，我们还希望能够以几种方式操作精灵。我们可能需要添加以下方法：
- en: Add an image to the sprite
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向精灵添加图像
- en: Update the position of the sprite
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新精灵的位置
- en: Update the animation frame for the sprite
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新精灵的动画帧
- en: Render the sprite to the screen
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵渲染到屏幕上
- en: Open your game project, and add a new class called `Sprite.cpp` with a header
    file called `Sprite.h`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的游戏项目，并添加一个名为 `Sprite.cpp` 的新类，以及一个名为 `Sprite.h` 的头文件。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Visual Studio, right-click on the **Header Files** filter in the Solution
    Explorer pane. Then choose **Add Class**. Give the class the name `Sprite` and
    click **Add**. Visual Studio will create a template header and source code files
    for you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，在解决方案资源管理器窗格中右键单击 **头文件** 过滤器。然后选择 **添加类**。给类命名为 `Sprite` 并点击
    **添加**。Visual Studio将为您创建模板头文件和源代码文件。
- en: 'Use the following code for `Sprite.h`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码为 `Sprite.h`：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I know, it''s a lot of code! This is a typical object-oriented class, consisting
    of protected properties and public methods. Let''s take a look at the features
    of this class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，代码很多！这是一个典型的面向对象类，由受保护的属性和公共方法组成。让我们看看这个类的功能：
- en: '`#pragma once`: This is a C++ directive telling Visual Studio to only include
    files once if they are included in several source files.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#pragma once`：这是一个C++指令，告诉Visual Studio如果它们在多个源文件中包含，则只包含文件一次。'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'An alternative is to use header guards:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个选择是使用头文件保护：
- en: '[PRE2]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This stops the code from being included if `SPRITE_H` has already been defined.
    Then the header has already been included and will not be included more than once.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `SPRITE_H` 已经被定义，这将阻止代码被包含。那么头文件已经被包含，并且不会重复包含。
- en: We include `gl.h` in this header file because we need access to the standard
    OpenGL variable types.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这个头文件中包含 `gl.h`，因为我们需要访问标准的OpenGL变量类型。
- en: 'Inside the class, we define two very useful structures: point and rect. We
    work with points and rectangles so much that it makes sense to have simple structures
    that hold their values.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在课堂内部，我们定义了两个非常有用的结构：点和矩形。我们与点和矩形打交道如此频繁，以至于拥有简单结构来保存它们的值是有意义的。
- en: 'The member variables are as follows:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员变量如下：
- en: '`m_textures` is a `GLuint` array that will dynamically hold all of the OpenGL
    texture handles that make up this sprite.'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_textures` 是一个 `GLuint` 数组，将动态保存构成这个精灵的所有OpenGL纹理句柄。'
- en: '`m_textureIndex` starts at zero, and is incremented each time a texture is
    added to the sprite.'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_textureIndex` 从零开始，每次向精灵添加纹理时都会递增。'
- en: '`m_currentFrame` starts at zero, and is incremented each time we want to advance
    the frame of the animation.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_currentFrame` 从零开始，每次我们想要前进动画帧时都会递增。'
- en: '`m_numberOfFrames` stores the total number of frames that make up our animation.'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_numberOfFrames` 存储组成我们动画的总帧数。'
- en: '`m_animationDelay` is the number of seconds that we want to pass before the
    animation frame advances. This allows us to control the speed of the animation.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_animationDelay` 是我们想要在动画帧前进之前经过的秒数。这允许我们控制动画的速度。'
- en: '`m_animationElapsed` will hold the amount of time that has elapsed since the
    last animation frame was changed.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_animationElapsed` 将保存自上次动画帧更改以来经过的时间。'
- en: '`m_position` holds the `x` and `y` positions of the sprite.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_position` 保存精灵的 `x` 和 `y` 位置。'
- en: '`m_size` holds the `width` and `height` of the sprite.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_size` 保存精灵的 `width` 和 `height`。'
- en: '`m_velocity` holds the velocity of the sprite. Larger values will cause the
    sprite to move more quickly across the screen.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_velocity` 保存精灵的速度。较大的值将使精灵在屏幕上移动得更快。'
- en: '`m_isCollideable` is a flag that tells us whether or not this sprite collides
    with other objects on the screen. When set to `false`, the sprite will pass through
    other objects on the screen.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_isCollideable` 是一个标志，告诉我们这个精灵是否与屏幕上的其他对象发生碰撞。当设置为 `false` 时，精灵将穿过屏幕上的其他对象。'
- en: '`m_flipHorizontal` is a flag that tells the class whether or not the sprite
    image should be horizontally flipped when it is rendered. This technique can be
    used to save texture memory by reusing a single texture for both right and left
    movement.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_flipHorizontal` 是一个标志，告诉类在渲染时精灵图像是否应该水平翻转。这种技术可以通过重用单个纹理来保存纹理内存，用于左右移动。'
- en: '`m_flipVertical` is a flag that tells the class whether or not the sprite image
    should be vertically flipped when it is rendered.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_flipVertical` 是一个标志，告诉类在渲染时精灵图像是否应该垂直翻转。'
- en: '`m_isVisible` is a flag that indicates whether the sprite is currently visible
    in the game. If this is set to false, then the sprite will not be rendered.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_isVisible` 是一个标志，表示精灵是否当前在游戏中可见。如果设置为 `false`，则精灵将不会被渲染。'
- en: '`m_isActive` is a flag that indicates whether the sprite is currently active.
    If this is set to false, then the sprite animation frame and sprite position will
    not be updated.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_isActive`是一个标志，表示精灵当前是否激活。如果设置为false，则不会更新精灵的动画帧和位置。'
- en: '`m_useTransparency` is a flag that tells the sprite class whether or not to
    use the alpha channel in the sprite. As alpha checking is costly, we set this
    to false for images that don''t have any transparency (such as the game background).'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_useTransparency`是一个标志，它告诉精灵类是否在精灵中使用alpha通道。由于alpha检查成本较高，我们将其设置为false，用于没有透明度（如游戏背景）的图像。'
- en: '`m_isSpriteSheet` is a flat that tells the sprite class if a single texture
    is used to hold all of the frames for this sprite. If set to `true`, then each
    frame is loaded as a separate texture.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_isSpriteSheet`是一个标志，它告诉精灵类是否使用单个纹理来保存此精灵的所有帧。如果设置为`true`，则每个帧都作为单独的纹理加载。'
- en: 'Next, we have the methods:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有以下方法：
- en: '`Sprite` is a constructor that takes a single parameter, `p_numberOfTextures`.
    We have to tell the class the number of textures that will be used when the sprite
    is created so that the correct amount of memory can be allocated for the textures
    dynamic array.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`是一个构造函数，它接受一个参数`p_numberOfTextures`。我们必须告诉类在创建精灵时将使用多少纹理，以便为纹理动态数组分配正确的内存量。'
- en: '`~Sprite` is the class destructor.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~Sprite`是类的析构函数。'
- en: '`Update` will be used to update the current animation frame and the current
    position of the sprite.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用`Update`来更新当前动画帧和精灵的当前位置。
- en: '`Render` will be used to actually display the sprite on the screen.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将使用`Render`来实际在屏幕上显示精灵。
- en: '`AddTexture` is used once the sprite is created to add the required textures.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTexture`在精灵创建后使用，用于添加所需的纹理。'
- en: '`GetCurrentFrame` is used when the sprite is rendered to determine which frame
    of the sprite to render.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当精灵被渲染时，使用`GetCurrentFrame`来确定要渲染的精灵帧。
- en: The remaining methods are simply accessor methods that allow you to modify the
    class properties.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的方法只是访问器方法，允许您修改类属性。
- en: 'Next, let''s start the class implementation. Open `Sprite.cpp` and add the
    following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们开始类的实现。打开`Sprite.cpp`并添加以下代码：
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are some details about the implementation code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现代码的一些细节：
- en: Along with `stdafx.h` and `Sprite.h`, we include `SOIL.h` because this is the
    actual code block that we will use to load textures
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`stdafx.h`和`Sprite.h`，我们还包含了`SOIL.h`，因为这是我们实际用来加载纹理的代码块。
- en: 'The `Sprite` constructor:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`构造函数：'
- en: Dynamically allocates space for the `m_textures` array based on `p_numberOfTextures`.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据给定的`p_numberOfTextures`动态为`m_textures`数组分配空间。
- en: Initializes all of other class properties. Note that most of the Boolean properties
    are set to `false`. The result is that a newly created sprite will not be active
    or visible until we specifically set it to be active and visible.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化所有其他类属性。请注意，大多数布尔属性都设置为`false`。结果是，新创建的精灵将不会激活或可见，直到我们明确将其设置为激活和可见。
- en: The `~Sprite` destructor deallocates the memory used for the `m_textures` array
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~Sprite`析构函数释放了用于`m_textures`数组的内存。'
- en: We will implement the `Update`, `Render`, and `AddTexture` methods next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将接下来实现`Update`、`Render`和`AddTexture`方法。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You probably noticed that I prefix many of the variables in my code with either
    `m_` or `p_`. m_ is always used to prefix the name of class properties (or member
    variables), and `p_` is used to prefix variables used as parameters in functions.
    If a variable does not have a prefix, it is usually a local variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我在代码中的许多变量前都加上了`m_`或`p_`前缀。`m_`总是用来作为类属性（或成员变量）名称的前缀，而`p_`用来作为函数中用作参数的变量的前缀。如果一个变量没有前缀，它通常是一个局部变量。
- en: Creating sprite frames
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建精灵帧
- en: 'We already discussed how 2D animations are created by drawing multiple frames
    of the image with each frame being slightly different. The key points that must
    be remembered are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何通过绘制图像的多个帧来创建2D动画，每个帧都略有不同。必须记住的关键点是：
- en: Each frame must have exactly the same dimensions
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个框架必须具有完全相同的尺寸
- en: The placement of the image within the frame must be consistent
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像在框架中的放置必须保持一致
- en: Only the parts of the image that are supposed to move should change from frame
    to frame
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有图像中应该移动的部分应该从一帧到另一帧发生变化。
- en: Saving each frame
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存每一帧
- en: 'One technique to save your frames is to save each frame as its own image. As
    you will eventually have a lot of sprites and frames to work with, it is important
    to come up with a consistent naming convention for all of your images. For example,
    with our three frame robot animation that were illustrated previously, we might
    use the following filenames:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 保存帧的一个技巧是将每个帧保存为其自己的图像。由于你最终将会有很多精灵和帧需要处理，因此为所有图像制定一个一致的命名约定非常重要。例如，对于之前展示的三个帧的机器人动画，我们可能会使用以下文件名：
- en: '`robot_left_00.png`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_left_00.png`'
- en: '`robot_left_01.png`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_left_01.png`'
- en: '`robot_left_02.png`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_left_02.png`'
- en: '`robot_left_03.png`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_left_03.png`'
- en: '`robot_right_00.png`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_right_00.png`'
- en: '`robot_right_01.png`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_right_01.png`'
- en: '`robot_right_02.png`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_right_02.png`'
- en: '`robot_right_03.png`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`robot_right_03.png`'
- en: Every image in the game should use the same naming mechanism. This will save
    you endless headaches when coding the animation system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的每个图像都应该使用相同的命名机制。这将在编码动画系统时为你节省无尽的麻烦。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should save all of your images in a folder named "resources" which should
    be created in the same folder that holds your source files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将所有图像保存在名为“resources”的文件夹中，该文件夹应与包含源文件的文件夹位于同一位置。
- en: Loading a sprite from individual textures
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从单个纹理加载精灵
- en: 'Let''s take a look the code to load a sprite that has each frame saved as an
    individual file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看加载每个帧都保存为单独文件的精灵的代码：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The important points to notice about the preceding code are:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码的重要点：
- en: We create a new instance of our sprite class to store the information. We have
    to tell the sprite class to allocate space for 4 textures for this sprite.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的精灵类实例来存储信息。我们必须告诉精灵类为这个精灵分配4个纹理的空间。
- en: We first store the width and height of each frame. In this case, this happens
    to be the width and height of each texture that makes up this sprite. As every
    texture that makes up a particular sprite must have the same dimensions, we only
    have to make this call once.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先存储每个帧的宽度和高度。在这种情况下，这恰好是构成这个精灵的每个纹理的宽度和高度。由于构成特定精灵的每个纹理都必须具有相同的尺寸，我们只需要调用一次。
- en: We then store the number of frames in this sprite. This might seem to duplicate
    the number of textures that we specified in the constructor. However, as you will
    see in the next section, the number of textures does not always equal the number
    of frames.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们存储这个精灵中的帧数。这似乎与我们在构造函数中指定的纹理数量重复。然而，正如你将在下一节中看到的，纹理的数量并不总是等于帧的数量。
- en: We now add each texture to the sprite. The sprite class takes care of allocating
    the necessary memory for us.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在将每个纹理添加到精灵中。精灵类会为我们分配必要的内存。
- en: Creating a sprite sheet
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建精灵图
- en: An alternative method to store your sprites is to use a sprite sheet. A sprite
    sheet holds all of the sprites for a particular animation in a single file. The
    sprites are often organized into a strip.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 存储精灵的另一种方法是使用精灵图。精灵图将特定动画的所有精灵存储在一个文件中。精灵通常组织成条带。
- en: '![Creating a sprite sheet](img/8188OS_03_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![创建精灵图](img/8188OS_03_06.jpg)'
- en: As the dimensions of each frame are identical, we can calculate the position
    of each frame in a particular animation as an offset from the first frame in the
    sprite sheet.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个帧的尺寸相同，我们可以将每个帧在特定动画中的位置计算为从精灵图中的第一个帧的偏移量。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can download a cool little program called **GlueIt** at [http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/](http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/).
    This small program allows you to specify several individual images, and then it
    glues them into a sprite sheet for you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/](http://www.varcade.com/blog/glueit-sprite-sheet-maker-download/)下载一个名为**GlueIt**的小程序。这个小程序允许你指定几个单独的图像，然后它会将这些图像粘合到一个精灵图中。
- en: Loading a sprite sheet
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载精灵图
- en: 'The following code loads a sprite that has been stored as a sprite sheet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码加载了一个存储为精灵图的精灵：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is very similar to the code that we used to create a sprite with
    individual textures previously. However, there are important differences:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前用来创建具有单个纹理的精灵的代码非常相似。然而，有一些重要的区别：
- en: We only need to allocate space for one texture because we only load one texture.
    This is the main advantage of using a sprite sheet because it is much more efficient
    to load a single large texture than it is to load several smaller textures.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需要为单个纹理分配空间，因为我们只加载一个纹理。这是使用精灵表的主要优势，因为加载单个大纹理比加载几个小纹理要高效得多。
- en: Again, we set the width and height of each frame. Note that these are the same
    values as when loading individual textures because the important information is
    the width and height of each frame, not the width and height of the texture.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次强调，我们设置每个帧的宽度和高度。请注意，这些值与加载单个纹理时的值相同，因为重要的是每个帧的宽度和高度，而不是纹理的宽度和高度。
- en: Again, we store the number of frames for this sprite. This sprite still has
    four frames, although all of the four frames are stored in a single image.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次，我们存储这个精灵的帧数。这个精灵仍然有四个帧，尽管所有四个帧都存储在一个单独的图像中。
- en: We then add a single image to the sprite.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们然后向精灵添加单个图像。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we get ready to render each frame of the animation, the sprite class will
    take care of calculating exactly which part the sprite strip to render based on
    the current frame and the width of each frame.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好渲染动画的每一帧时，精灵类将负责根据当前帧和每帧的宽度计算渲染精灵条的确切部分。
- en: Loading our sprites
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载我们的精灵
- en: 'The following code shows the full code that we will use to load the sprites
    into our game. Open the **RoboRacer2D** project and open `RoboRacer.cpp`. First
    we need to include the Sprite header:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了我们将用于将精灵加载到游戏中的完整代码。打开 **RoboRacer2D** 项目并打开 `RoboRacer.cpp`。首先我们需要包含
    Sprite 头文件：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need some global variables to hold our sprites. Add this code in the
    variable declarations section of the code (before any functions):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些全局变量来存储我们的精灵。在代码的变量声明部分添加此代码（在所有函数之前）：
- en: '[PRE7]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We created pointers for each sprite that we will need in the game until this
    point:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为游戏直到此点需要的每个精灵创建了指针：
- en: A sprite to move the robot left
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于将机器人向左移动的精灵
- en: A sprite to move the robot right
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于将机器人向右移动的精灵
- en: A sprite for the background
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于背景的精灵
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to make it easy for you to work with both types of sprites, I defined
    two sprites for each robot direction. For example, `robot_left` will define a
    sprite made up of individual textures, while `robot_left_strip` will define a
    sprite made up of a single sprite sheet. Normally, you would not use both in a
    single game!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更容易地处理两种类型的精灵，我为每个机器人方向定义了两个精灵。例如，`robot_left` 将定义由单个纹理组成的精灵，而 `robot_left_strip`
    将定义由单个精灵表组成的精灵。通常情况下，你不会在单个游戏中使用两者！
- en: 'Now, add the `LoadTextures` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加 `LoadTextures` 函数：
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code is exactly the same as the code that I showed you earlier to load
    sprites. It is simply more comprehensive:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前向您展示的加载精灵的代码完全相同。它只是更全面：
- en: '`LoadTexures` loads all of the sprites needed in the game (including duplicate
    *strip* versions so that you can see the difference between using sprite sheets
    versus individual textures).'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadTexures` 加载游戏中需要的所有精灵（包括重复的 *strip* 版本，这样你可以看到使用精灵表与单个纹理之间的区别）。'
- en: '`SetPosition` is used to set the initial position for the robot sprites. Notice
    that we don''t do this for the background sprite because its position starts at
    `(0, 0)`, which is the default.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetPosition` 用于设置机器人精灵的初始位置。请注意，我们不对背景精灵这样做，因为它的位置从 `(0, 0)` 开始，这是默认值。'
- en: '`SetVisible` and `SetActive` are used to set the `background` sprite and the
    `robot_left_strip` sprite as active and visible. All of the other sprites will
    remain inactive and invisible.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetVisible` 和 `SetActive` 用于设置 `background` 精灵和 `robot_left_strip` 精灵为活动状态和可见状态。所有其他精灵都将保持非活动状态和不可见状态。'
- en: 'As the loading of textures only needs to occur once in the game, we will add
    the call to do this to the `StartGame` function. Modify the `StartGame` function
    in `RoboRacer.cpp`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理的加载在游戏中只需要发生一次，我们将添加调用此操作的 `StartGame` 函数。修改 `RoboRacer.cpp` 中的 `StartGame`
    函数：
- en: '[PRE9]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The final step in getting our textures loaded is to implement the `AddTexture`
    method in our sprite class. Open `Sprite.cpp` and add the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 加载纹理的最后一步是在我们的精灵类中实现 `AddTexture` 方法。打开 `Sprite.cpp` 并添加以下代码：
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`AddTexture` is used after a new sprite has been created. It adds the required
    textures to the `m_textures` array. Here''s how it works:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTexture` 在创建新精灵后使用。它将所需的纹理添加到 `m_textures` 数组中。以下是它的工作原理：'
- en: '`p_imageName` holds the name and path of the image to load.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p_imageName` 保存要加载的图像的名称和路径。'
- en: '`p_useTransparency` is used to tell the sprite class whether this image uses
    an alpha channel. As most of our sprites will use transparency, this is coded
    to default to `true`. However, if we set `p_useTransparency` to `false`, then
    any transparency information will be ignored.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p_useTransparency`用于告诉精灵类这个图像是否使用alpha通道。由于我们的大部分精灵都会使用透明度，所以这个值默认设置为`true`。然而，如果我们把`p_useTransparency`设置为`false`，那么任何透明度信息都将被忽略。'
- en: '`SOIL_load_OGL_texture` does all of the work of loading the texture. The parameters
    for this call were described earlier in this chapter. Note that SOIL is smart
    enough to load image types based on the file extension.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOIL_load_OGL_texture`完成了加载纹理的所有工作。这个调用的参数在本章前面已经描述过。请注意，SOIL足够智能，可以根据文件扩展名加载图像类型。'
- en: If the texture was successfully loaded, `SOIL_load_OGL_texture` will return
    an OpenGL texture handle. If not, it will return `0`. Generally, we would test
    this value and use some kind of error handling, or quit if any texture did not
    load correctly.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果纹理成功加载，`SOIL_load_OGL_texture`将返回一个OpenGL纹理句柄。如果没有，它将返回`0`。通常，我们会测试这个值并使用某种错误处理，或者在任何纹理没有正确加载时退出。
- en: As the `m_textures` array is allocated in the constructor, we can simply store
    texture in the `m_textureIndex` slot.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`m_textures`数组是在构造函数中分配的，我们可以简单地将纹理存储在`m_textureIndex`槽中。
- en: We then increment `m_textureIndex`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们增加`m_textureIndex`。
- en: We use a little trick to determine if this sprite uses a sprite sheet or individual
    sprites. Basically, if there is only one texture but many frames, then we assume
    that this sprite uses a sprite sheet and set `m_isSpriteSheet` to `true`.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用一个小技巧来确定这个精灵是否使用精灵表或单个精灵。基本上，如果只有一个纹理但有很多帧，那么我们假设这个精灵使用精灵表，并将`m_isSpriteSheet`设置为`true`。
- en: Finally, we set `m_useTransparency` to the value that was passed in. This will
    be used later in the `Render` method.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将`m_useTransparency`设置为传入的值。这将在`Render`方法中稍后使用。
- en: Rendering
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: We did a lot of work creating our sprites, but nothing is going to show up until
    we actually render the sprites using OpenGL. Rendering is done for every frame
    of the game. First, an `Update` function is called to update the state of the
    game, then everything is rendered to the screen.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建精灵时做了很多工作，但直到我们实际使用OpenGL渲染精灵之前，什么都不会显示出来。渲染是针对游戏每一帧进行的。首先，调用`Update`函数来更新游戏状态，然后一切都会被渲染到屏幕上。
- en: Adding a render to the game loop
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游戏循环中添加渲染
- en: 'Let''s start by adding a call to `Render` in the `GameLoop` RoboRacer.cpp:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`GameLoop` RoboRacer.cpp中添加对`Render`的调用开始：
- en: '[PRE11]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, we are simply calling the main `Render` function (implemented
    in the next section). Every object that can be drawn to the screen will also have
    a `Render` method. In this way, the call to render the game will cascade down
    through every renderable object in the game.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们只是在调用主要的`Render`函数（在下一节中实现）。每个可以绘制到屏幕上的对象也将有一个`Render`方法。这样，渲染游戏的调用将级联到游戏中每个可渲染对象。
- en: Implementing the main Render function
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主渲染函数
- en: 'Now, it is time to implement the main `Render` function. Add the following
    code to `RoboRacer.cpp`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现主要的`Render`函数了。将以下代码添加到`RoboRacer.cpp`中：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that we render the background first. In a 2D game, the objects will be
    rendered in a first come, first rendered basis. This way the robot will always
    render on top of the background.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们首先渲染背景。在2D游戏中，对象将按照先来先渲染的原则进行渲染。这样，机器人总是会渲染在背景之上。
- en: 'Here''s how it works:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作方式：
- en: We always start our render cycle by resetting the OpenGL render pipeline. `glClear`
    sets the entire color buffer to the background color that we chose when initializing
    OpenGL. `glLoadIdentify` resets the rendering matrix.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是通过重置OpenGL渲染管线来开始我们的渲染周期。`glClear`将整个颜色缓冲区设置为我们在初始化OpenGL时选择的背景颜色。`glLoadIdentify`重置渲染矩阵。
- en: Next, we call `Render` for each sprite. We don't care if the sprite is actually
    visible or not. We let the sprite class `Render` method make that decision.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们为每个精灵调用`Render`。我们不在乎精灵是否实际上是可见的。我们让精灵类的`Render`方法做出这个决定。
- en: Once all objects are rendered, we make the call to `SwapBuffers`. This is a
    technique known as double-buffering. When we render our scene, it is actually
    created in a buffer off screen. This way the player doesn't actually see the separate
    images as they are composited to the screen. Then, a single call to `SwapBuffers`
    makes a fast copy of the offscreen buffer to the actual screen buffer. This makes
    the screen render appear much more smoothly.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦所有对象都渲染完毕，我们调用`SwapBuffers`。这是一种称为双缓冲的技术。当我们渲染场景时，它实际上是在屏幕外的缓冲区中创建的。这样玩家就不会看到单独的图像，因为它们被合成为屏幕上的图像。然后，一个单独的`SwapBuffers`调用将离屏缓冲区快速复制到实际屏幕缓冲区。这使得屏幕渲染看起来更加平滑。
- en: Implementing Render in the Sprite class
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在精灵类中实现渲染
- en: 'The last step in our render chain is to add a render method to the `Sprite`
    class. This will allow each sprite to render itself to the screen. Open `Sprite.h`
    and add the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们渲染链的最后一个步骤是在`Sprite`类中添加一个渲染方法。这将允许每个精灵将自己渲染到屏幕上。打开`Sprite.h`并添加以下代码：
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is probably one of the more complex sections of the code because rendering
    has to take many things into consideration. Is the sprite visible? Which frame
    of the sprite are we rendering? Where on screen should the sprite be rendered?
    Do we care about transparency? Let''s walk through the code step by step:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是代码中较为复杂的部分之一，因为渲染需要考虑许多因素。精灵是否可见？我们正在渲染精灵的哪一帧？精灵应该在屏幕上的哪个位置渲染？我们是否关心透明度？让我们一步一步地分析代码：
- en: First, we check to see if `m_visible` is `true`. If not, we bypass the entire
    render.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们检查`m_visible`是否为`true`。如果不是，我们跳过整个渲染过程。
- en: Next, we check to see if this sprite uses transparency. If it does, we have
    to enable transparency. The technical term to implement transparency is blending.
    OpenGL has to blend the current texture with what is already on the screen. `glEnable(GL_BLEND)`
    turns on transparency blending. The call to `glBlendFunc` tells OpenGL exactly
    what type of blending we want to implement. Suffice to say that the `GL_SRC_ALPHA`
    and `GL_ONE_MIUS_SRC_ALPHA` parameters tell OpenGL to allow background images
    to be seen through transparent sections of the sprite.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们检查这个精灵是否使用透明度。如果是，我们必须启用透明度。实现透明度的技术术语是混合。OpenGL必须将当前纹理与屏幕上已有的内容进行混合。`glEnable(GL_BLEND)`打开透明度混合。`glBlendFunc`的调用告诉OpenGL我们想要实现哪种混合类型。简单来说，`GL_SRC_ALPHA`和`GL_ONE_MIUS_SRC_ALPHA`参数告诉OpenGL允许背景图像通过精灵的透明部分可见。
- en: '`glBindTexture` tells OpenGL which texture we want to work with right now.
    The call to `GetCurrentFrame` returns the OpenGL handle of the appropriate texture.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glBindTexture`告诉OpenGL我们现在想要使用哪个纹理。`GetCurrentFrame`的调用返回适当的OpenGL纹理句柄。'
- en: '`glBegin` tells OpenGL that we are ready to render a particular item. In this
    case, we are rendering a quad.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glBegin`告诉OpenGL我们准备渲染特定项目。在这种情况下，我们正在渲染一个四边形。'
- en: The next two lines of code set up the `x` and `y` coordinates for the sprite
    based on the `x` and `y` values stored in `m_position`. These values are used
    in the `glVertex2f` calls to position the sprite.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行代码根据存储在`m_position`中的`x`和`y`值设置精灵的`x`和`y`坐标。这些值在`glVertex2f`调用中使用，以定位精灵。
- en: We will also need the `width` and `height` of the current frame, and the next
    two lines store these as `w` and `h` for convenience.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要当前帧的`width`和`height`，接下来的两行代码将它们存储为`w`和`h`以方便使用。
- en: Finally, we need to know how much of the texture we are going to render. Typically,
    we render the entire texture. However, in the case of a sprite sheet we will only
    want to render a section of the texture. We will discuss how this works in more
    detail later.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要知道我们将要渲染纹理的多少部分。通常，我们会渲染整个纹理。然而，在精灵图的情况下，我们只想渲染纹理的一部分。我们将在稍后更详细地讨论这一点。
- en: Once we have the position, width, and portion of the texture that we want to
    render, we use for pairs of calls to `glTexCoord2f` and `glVertex2f` to map each
    corner of the texture to the quad. This was discussed in great detail in [Chapter
    2](ch02.html "Chapter 2. Your Point of View"), *Your Point of View*.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了要渲染的位置、宽度和纹理部分，我们就使用`glTexCoord2f`和`glVertex2f`的成对调用，将纹理的每个角落映射到四边形上。这一点在[第2章](ch02.html
    "第2章。你的视角")*你的视角*中进行了详细的讨论。
- en: The call to `glEnd` tells OpenGL that we are finished with the current render.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glEnd`的调用告诉OpenGL我们已完成当前渲染。'
- en: As alpha checking is computationally expensive, we turn it off at the end of
    the render with a call to `glDisable(GL_BLEND)`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于alpha检查计算成本较高，我们在渲染结束时通过调用`glDisable(GL_BLEND)`将其关闭。
- en: UV mapping
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UV贴图
- en: UV mapping was covered in detail in [Chapter 2](ch02.html "Chapter 2. Your Point
    of View"), *Your Point of View*. However, we'll do a recap here and see how it
    is implemented in code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: UV贴图在[第2章](ch02.html "第2章. 你的视角") *你的视角*中进行了详细说明。然而，我们在这里将进行回顾，并看看它在代码中的实现方式。
- en: By convention, we assign the left coordinate of the texture to the variable
    **u**, and the top coordinate of the texture to the variable **v**. This technique
    is therefore known as **uv** mapping.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，我们将纹理的左侧坐标分配给变量**u**，将纹理的顶部坐标分配给变量**v**。因此，这种技术被称为**uv**贴图。
- en: OpenGL considers the origin of a texture to be at **uv** coordinates of (0,
    0), and the farthest extent of the texture to be at **uv** coordinates of (1,
    1). So, if we want to render the entire texture, we will map the entire range
    from (0, 0) to (1, 1) the four corners of the quad. However, let's say that we
    only want to render the first half of the image width (but the entire height).
    In this case, we will map the range of **uv** coordinates from (0, 1) to (0.5,
    1) to the four corners of the quad. Hopefully, you can visualize that this will
    only render one-half of the texture.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL将纹理的原点视为**uv**坐标（0, 0），将纹理的最远延伸点视为**uv**坐标（1, 1）。因此，如果我们想渲染整个纹理，我们将从（0,
    0）到（1, 1）映射整个范围到四边形的四个角。但是，假设我们只想渲染图像宽度的一半（但整个高度）。在这种情况下，我们将**uv**坐标的范围从（0, 1）到（0.5,
    1）映射到四边形的四个角。希望你能想象这将只渲染纹理的一半。
- en: So, in order to render our sprite sheets, we first determine how wide each frame
    of the sprite is by dividing `m_textureIndex` by `m_numberOfFrames`. In the case
    of a sprite that has four frames, this will give us a value of 0.25.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了渲染我们的精灵图集，我们首先通过将`m_textureIndex`除以`m_numberOfFrames`来确定每个精灵帧的宽度。对于一个有四个帧的精灵，这将给出0.25的值。
- en: 'Next, we determine which frame we are in. The following table shows the **uv**
    ranges for each frame of a sprite with four frames:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定我们处于哪个帧。以下表格显示了具有四个帧的精灵的每个帧的**uv**范围：
- en: '| Frame | u | v |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 帧 | u | v |'
- en: '| --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0.0 to 0.25 | 0.0 to 1.0 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.0 to 0.25 | 0.0 to 1.0 |'
- en: '| 1 | 0.25 to 0.5 | 0.0 to 1.0 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.25 to 0.5 | 0.0 to 1.0 |'
- en: '| 2 | 0.5 to 0.75 | 0.0 to 1.0 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.5 to 0.75 | 0.0 to 1.0 |'
- en: '| 3 | 0.75 to 1.0 | 0.0 to 1.0 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.75 to 1.0 | 0.0 to 1.0 |'
- en: As our sprite sheets are set up horizontally, we only need to worry about taking
    the correct range of **u** from the whole texture, while the range for **v** stays
    the same.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的精灵图集是水平设置的，我们只需要关注从整个纹理中获取正确的**u**范围，而**v**的范围保持不变。
- en: 'So, here is how our algorithm works:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是我们算法的工作方式：
- en: If the sprite is not a sprite sheet, then each frame uses 100 percent of the
    texture, and we use a range of uv values from (0,0) to (1, 1)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果精灵不是精灵图集，那么每个帧使用100%的纹理，我们使用从（0,0）到（1,1）的uv值范围。
- en: If the sprite is based on a sprite sheet, we determine the width of each frame
    (`texWidth`) by dividing `m_textureIndex` by `m_numberOfFrames`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果精灵基于精灵图集，我们通过将`m_textureIndex`除以`m_numberOfFrames`来确定每个帧的宽度（`texWidth`）。
- en: We determine the starting u value by multiplying `m_currentFrame` by `texWidth`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将`m_currentFrame`乘以`texWidth`来确定起始的**u**值。
- en: We determine the extent of **u** by adding `u` + `texWidth`
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将`u` + `texWidth`来确定**u**的范围。
- en: We map u to the upper-corner of the quad, and `u` + `texWidth` to the lower
    corner of the quad
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将**u**映射到四边形的右上角，并将`u` + `texWidth`映射到四边形的左下角。
- en: '**v** is mapped normally because our sprite sheets use 100 percent of the height
    of the texture'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**v**的映射是正常的，因为我们的精灵图集使用了纹理高度的100%。'
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are having a hard time understanding uv mapping, don't fret. It took
    me years of application to fully understand this concept. You can play around
    with the uv coordinates to see how things work. For example, try settings of .05,
    1, and 1.5 and see what happens!
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很难理解UV贴图，不要担心。我花费了多年的应用实践才完全理解这个概念。你可以尝试调整uv坐标来查看事物是如何工作的。例如，尝试设置.05、1和1.5，看看会发生什么！
- en: One more detail
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个额外的细节
- en: 'We need to take a closer look at the call to `GetCurrentFrame` to make sure
    you understand what this function does. Here is the implementation:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要仔细查看`GetCurrentFrame`的调用，以确保你理解这个函数的作用。以下是其实施方式：
- en: '[PRE14]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is what is happening:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里正在发生的事情：
- en: If the sprite is a sprite sheet, we always return `m_textures[0]` because, by
    definition, there is only one texture at index `0`
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果精灵是精灵图集，我们总是返回`m_textures[0]`，因为根据定义，索引`0`处只有一个纹理。
- en: If the sprite is not a sprite sheet, then we return the texture at index `m_currentFrame`.
    `m_currentFrame` is updated in the sprite update method (defined next)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果精灵不是一个精灵表，那么我们就返回索引 `m_currentFrame` 处的纹理。`m_currentFrame` 在精灵更新方法（定义在下面）中更新。
- en: A moving example
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个移动的例子
- en: The code that we created until this point creates a basic scene with our robot
    and a background. Now, it's time to bring our robot to life using the power of
    animation.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止创建的代码创建了一个包含我们的机器人和背景的基本场景。现在，是时候利用动画的力量让我们的机器人复活了。
- en: Animation actually has two components. First, the sprite itself will appear
    to animate because we will play each frame of the sprite in sequence. If you use
    the stock files that were made for this book, you will see the robot's eyes and
    arms move.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 动画实际上有两个组成部分。首先，由于我们将按顺序播放精灵的每一帧，所以精灵本身将看起来像是在动画。如果你使用为这本书制作的库存文件，你会看到机器人的眼睛和手臂在移动。
- en: The second component is movement across the screen. It is the combination of
    the robot's horizontal movement and body movements that will make a convincing
    animation.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组成部分是屏幕上的移动。这是机器人的水平移动和身体动作的组合，将产生令人信服的动画。
- en: Adding update to the game loop
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将更新添加到游戏循环中
- en: 'As with rendering, we start by adding an `Update` call to the `GameLoop` function.
    Modify the `GameLoop` function in `RoboRacer.cpp`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与渲染一样，我们首先在 `GameLoop` 函数中添加一个 `Update` 调用。修改 `RoboRacer.cpp` 中的 `GameLoop`
    函数：
- en: '[PRE15]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now have two new features:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个新功能：
- en: We added `p_deltaTime` as a parameter. This represents the amount of time that
    has passed in milliseconds since the last frame. We will see how this is calculated
    in the following section.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `p_deltaTime` 作为参数。这代表自上一帧以来经过的毫秒数。我们将在下一节中看到它是如何计算的。
- en: We added a call to the main `Update` function (defined in the following section).
    Every object in the game will also have an `Update` method. In this way, the call
    to update the game will cascade down through every object in the game. We pass
    `p_deltatTime` so that every subsequent call to `Update` will know how much time
    has passed in the game.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了对主 `Update` 函数的调用（定义在下一节）。游戏中的每个对象也将有一个 `Update` 方法。这样，更新游戏的调用将级联通过游戏中的每个对象。我们传递
    `p_deltatTime`，以便后续对 `Update` 的每次调用都知道游戏中经过的时间。
- en: Implementing the main Update call
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主 Update 调用
- en: 'Our first task is to implement the `Update` function in `RoboRacer.cpp`. Add
    the following function to `RoboRacer.cpp`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是实现在 `RoboRacer.cpp` 中的 `Update` 函数。将以下函数添加到 `RoboRacer.cpp` 中：
- en: '[PRE16]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we make an `Update` call to every sprite. At this point, we don't
    care if the sprite really needs to be updated. This decision will be made inside
    the `Sprite` class.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们向每个精灵调用 `Update`。在这个阶段，我们并不关心精灵是否真的需要更新。这个决定将在 `Sprite` 类内部做出。
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a real game, we would probably have an array of sprites, and we would update
    them all by iterating through the array and calling update on each element. As
    this game uses so few sprites, I have coded each sprite individually.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真正的游戏中，我们可能有一个精灵数组，并且我们会通过遍历数组并对每个元素调用更新来更新它们。由于这个游戏使用的精灵很少，所以我为每个精灵单独编写了代码。
- en: Implementing Update in the Sprite class
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在精灵类中实现 Update
- en: 'Now it''s time to implement the `Update` method in our `Sprite` class. This
    method does all of the work required to both position the sprite and update the
    sprite''s internal animation. Add this code to `Sprite.h`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的 `Sprite` 类中实现 `Update` 方法了。这个方法执行了将精灵定位并更新精灵内部动画所需的所有工作。将以下代码添加到 `Sprite.h`
    中：
- en: '[PRE17]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is what this code does:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: We store `p_deltaTime` into a local variable `dt` for convenience. This is useful
    because you sometimes want to hardcode the value of `dt` during testing.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，我们将 `p_deltaTime` 存储到局部变量 `dt` 中。这在测试期间有时需要将 `dt` 的值硬编码时很有用。
- en: Next, we test `m_active`. If this if `false`, then we bypass the entire update.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们测试 `m_active`。如果这个值为 `false`，则跳过整个更新。
- en: We now handle the sprite's internal animation. We first add `dt` to `m_animationElapsed`
    to see how much time has elapsed since the last frame change. If `m_animationElapsed`
    exceeds `m_animationDelay`, then it is time to increment to the next frame. This
    means that the higher the value of `m_animationDelay`, the slower the sprite will
    animate.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在处理精灵的内部动画。我们首先将 `dt` 添加到 `m_animationElapsed` 中，以查看自上次帧变化以来经过的时间。如果 `m_animationElapsed`
    超过 `m_animationDelay`，那么就是切换到下一帧的时候了。这意味着 `m_animationDelay` 的值越高，精灵的动画速度就越慢。
- en: If necessary, we increment `m_currentFrame` making sure that once we have exceeded
    the total number of frame, we reset to `0`.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们增加`m_currentFrame`，确保一旦我们超过了总帧数，就重置为`0`。
- en: If we just did a frame increment, we also want to reset `m_animationElapsed`
    to `0`.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们只是进行帧增量，我们也希望将`m_animationElapsed`重置为`0`。
- en: Now ,we move the sprite based on `m_velocity` and `dt`. Look at the details
    on using delta time to calculate movement in the upcoming sections.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们根据`m_velocity`和`dt`移动精灵。请查看下一节中关于使用delta time计算移动的详细信息。
- en: Character movement
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色移动
- en: In this version of the game, we programmed our robot to move across the screen
    from left to right. The key to making our character move is the **velocity** property.
    The velocity property tells the program how many pixels to move our robot each
    game cycle.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏版本中，我们编程我们的机器人从左到右移动屏幕。使我们的角色移动的关键是**速度**属性。速度属性告诉程序每个游戏周期移动机器人多少像素。
- en: As the frames come pretty fast, the velocity is typically pretty small. For
    example, in a game running at 60 fps, a velocity of 1 would move the robot 60
    pixels each game frame. The sprite would probably be moving too fast to interact
    with.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于帧来得很快，速度通常很小。例如，在一个以60 fps运行的游戏中，速度为1会使机器人在每个游戏帧中移动60像素。精灵可能移动得太快而无法交互。
- en: Using delta time
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用delta time
- en: There is a small problem with setting the velocity as a fixed value. Obviously,
    some computers are faster than other computers. With a fixed velocity, the robot
    will move faster on faster computers. This is a problem because it means that
    people on faster computers will have to be much better at playing the game!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将速度设置为固定值有一个小问题。显然，有些计算机比其他计算机快。使用固定速度，机器人在较快的计算机上会移动得更快。这是一个问题，因为它意味着在较快的计算机上玩游戏的人必须玩得更好！
- en: 'We can use the computer''s clock to solve this problem. The computer keeps
    track of the time that has passed since the start of the previous frame. In game
    terminology, this is called **delta time**, and we assign this to a variable that
    we can access in the `Update` loop:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用计算机的时钟来解决此问题。计算机跟踪自上一帧开始经过的时间。在游戏术语中，这被称为**delta time**，并将其分配给一个我们可以在`Update`循环中访问的变量：
- en: '[PRE18]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding function definition, `deltaTime` is a floating value. Remember,
    our game is typically running at 60 fps, so `deltaTime` is going to be a very
    small number.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数定义中，`deltaTime`是一个浮点值。记住，我们的游戏通常以60 fps运行，所以`deltaTime`将是一个非常小的数字。
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we set up a game to run at 60 fps, it rarely runs at exactly that speed.
    Each frame may take slightly more or less time to finish its calculations. Delta
    time tells us exactly how much time has passed, and we can use that information
    to adjust the timing or speed of events.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置游戏以60 fps运行时，它很少以确切的那个速度运行。每个帧完成其计算所需的时间可能略有不同。delta time告诉我们确切经过的时间，我们可以使用这些信息来调整事件的时间或速度。
- en: 'Let''s take a closer look at how we use velocity to position our sprites:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看我们如何使用速度来定位我们的精灵：
- en: '[PRE19]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We multiply `m_velocity` times `dt`, and then add this to the current position.
    This technique automatically adjusts the velocity based on the amount of time
    that has passed since the last frame. If the last frame took a little less time
    to process, then the robot will move a little less. If the last frame took a little
    longer to process, then our robot will move a little further. The end result is
    that the robot moves consistently now on both faster and slower computers.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`m_velocity`乘以`dt`，然后将这个值加到当前位置。这种技术会根据自上一帧以来经过的时间自动调整速度。如果上一帧处理时间略短，那么机器人会移动得略少。如果上一帧处理时间略长，那么我们的机器人会移动得更远。最终结果是，机器人在更快和更慢的计算机上都能保持一致的移动。
- en: Tip
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For slower computers, this could cause other side effects, especially regarding
    collision detection. If too much time goes by, then the sprite will move farther.
    This could, for example, cause the sprite to go right through a wall before the
    collision detection is checked.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较慢的计算机，这可能会引起其他副作用，特别是关于碰撞检测。如果时间过长，那么精灵会移动得更远。例如，这可能导致精灵在碰撞检测之前穿过墙壁。
- en: As `dt` is a very small number, we will now have to use a larger number for
    our velocity. The current code uses a value of 50\. Of course, in the full game
    this value will change based on what is happening to our robot.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dt`是一个非常小的数字，我们现在将不得不使用一个较大的数字作为速度。当前代码使用的是50。当然，在完整游戏中，这个值将根据我们的机器人发生的情况而变化。
- en: Calculating delta time
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算delta time
- en: 'We already have all of the code in place except the actual code to calculate
    delta time. In order to calculate the time that has elapsed during each frame
    of the game, we must:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了所有代码，除了实际计算delta time的代码。为了计算游戏中每一帧经过的时间，我们必须：
- en: Store the time before the frame.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储帧前的時間。
- en: Store the time after the frame.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储帧后的时间。
- en: Calculate the difference between the two.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两者之间的差异。
- en: 'Open `RoboRacer.cpp` and add the following code right after the call to `StartGame`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RoboRacer.cpp`，并在调用`StartGame`之后直接添加以下代码：
- en: '[PRE20]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we are using `GLUT` to get the current elapsed time. Each call to
    `glutGet(GLUT_ELAPSED_TIME)` will give us the number of milliseconds that have
    elapsed since the game started.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`GLUT`来获取当前经过的时间。每次调用`glutGet(GLUT_ELAPSED_TIME)`都会给我们自游戏开始以来经过的毫秒数。
- en: Tip
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to use GLUT, remember to copy glut.h, glut32.dll, and glut32.lib from
    the OpenGLFun project to the source code folder of RoboRacer2D. include glut.h
    at the top of SpaceRacer2D.cpp.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用GLUT，请记住将OpenGLFun项目中的`glut.h`、`glut32.dll`和`glut32.lib`复制到RoboRacer2D的源代码文件夹中。在SpaceRacer2D.cpp的顶部包含`glut.h`。
- en: 'Next, add the following lines directly above the call to `GameLoop`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在调用`GameLoop`之前直接添加以下行：
- en: '[PRE21]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is what we have done:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们所做的工作：
- en: First, we captured the current elapsed time and stored that in `m_currentTime`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们捕获了当前经过的时间，并将其存储在`m_currentTime`中。
- en: We then calculated the time that elapsed since the last frame by subtracting
    `m_currentTime` from `m_previousTime`. We converted this to seconds to make it
    easier to deal with.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过从`m_previousTime`中减去`m_currentTime`来计算自上一帧以来经过的时间。我们将这个值转换为秒，以便更容易处理。
- en: We then set `previousTime` to equal current time so that we have a benchmark
    for our next calculation.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将`previousTime`设置为等于当前时间，以便我们有下一个计算的基准。
- en: Finally, we modified the call to `GameLoop` to pass the value of `deltaTime`.
    This will subsequently be passed to every `Update` call in the game.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们修改了对`GameLoop`的调用，以传递`deltaTime`的值。这将随后传递到游戏中每个`Update`调用。
- en: Flipping
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻转
- en: Today's games can be created for and played on a wide variety of devices, ranging
    from supercharged PCs to mobile phones. Each of these devices has its own set
    of advantages and disadvantages. However, one rule of thumb is that as the device
    gets smaller its capabilities become more limited.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的游戏可以在各种设备上创建和播放，从超级电脑到移动电话。每个设备都有自己的优点和缺点。然而，一个经验法则是，随着设备变得更小，其功能变得更加有限。
- en: One area where these limitations become critical is texture memory. Texture
    memory is the location in the memory that stores the textures that are being used
    in the game. Mobile devices, in particular, are very limited by the amount of
    available texture memory, and game programmers have to be very careful not to
    exceed this limitation.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制变得至关重要的一个领域是纹理内存。纹理内存是内存中存储正在游戏中使用的纹理的位置。特别是移动设备，其可用的纹理内存非常有限，游戏程序员必须非常小心，不要超过这个限制。
- en: 2D games tend to use a lot of texture memory. This is because each frame of
    every animation has to be stored in the memory to bring the 2D images to life.
    It is typical for a 2D game to have thousands of frames of textures that have
    to be loaded into memory.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 2D游戏往往使用大量的纹理内存。这是因为每个动画的每一帧都必须存储在内存中，以便使2D图像栩栩如生。对于2D游戏来说，典型的情况是拥有数千帧的纹理需要加载到内存中。
- en: One simple way to almost cut the required amount of texture memory in half is
    to utilize texture flipping. Simply put, our robot moving to the left is a mirror
    image of our robot moving to the right. Instead of using one set of textures to
    move to the left and another to move to the right, we can use code to flip the
    texture when it is rendered.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎将所需的纹理内存量减半的一个简单方法是通过利用纹理翻转。简单来说，我们的机器人向左移动是我们机器人向右移动的镜像。而不是使用一组纹理向左移动，另一组纹理向右移动，我们可以在渲染时使用代码翻转纹理。
- en: '![Flipping](img/8188OS_03_07.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![翻转](img/8188OS_03_07.jpg)'
- en: If you want to try it out sometime, flipping would be implemented by changing
    the way you mapped the sprite's **uv** coordinates to the texture.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下，翻转将通过改变将精灵的**uv**坐标映射到纹理的方式来实现。
- en: Scrolling the background
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动背景
- en: You may be wondering why we set up our background as a sprite. After all, we
    defined sprites as objects that the player interacts with in the game, and the
    background is basically ignored by the robot.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们将背景设置为精灵。毕竟，我们定义精灵为玩家在游戏中与之交互的对象，而背景基本上被机器人忽略。
- en: The main reason to set up the background as a sprite is that this allows us
    to handle all of our textures in a uniform manner. The advantage of this is that
    we can then apply the same properties to all of our images. For example, what
    if we decided that we wanted our background to move?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将背景设置为精灵的主要原因是可以让我们以统一的方式处理所有纹理。这种做法的优势在于，我们可以将相同的属性应用到所有图像上。例如，如果我们决定想要我们的背景移动呢？
- en: 'Scrolling backgrounds are used in 2D games to give the impression of a continuously
    changing background. In fact, the 2D side-scrolling game is considered its own
    genre. There are basically two requirements to create a scrolling background:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动背景在2D游戏中用于营造持续变化的背景印象。实际上，2D横版滚动游戏被认为是一个独立的游戏类型。创建滚动背景有两个基本要求：
- en: Create a large texture that is wider than the screen.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个比屏幕更宽的大纹理。
- en: Assign a velocity to the texture so that it moves sideways.![Scrolling the background](img/8188OS_03_08.jpg)
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为纹理分配一个速度，使其向侧面移动。![滚动背景](img/8188OS_03_08.jpg)
- en: The parts of the texture background that exceeds the screen width will not be
    rendered. As the image moves, the background appears to slide either to the left
    or the right. If you set the velocity of the background image to be exactly the
    same as the velocity of the player, you get the illusion of a background that
    is flying by as the robot runs left or right.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 超出屏幕宽度的纹理背景部分将不会被渲染。随着图像的移动，背景看起来像是向左或向右滑动。如果你将背景图像的速度设置为与玩家速度完全相同，那么当机器人向左或向右跑时，你会得到一个背景飞过的错觉。
- en: 'As we already implemented our background image as a sprite, the only thing
    that we have to do to make it scroll is to set its velocity. This was already
    done in the code for `AddTextures`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将背景图像实现为精灵，我们唯一需要做的就是设置其速度。这已经在`AddTextures`的代码中完成了：
- en: '[PRE22]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By setting the background velocity to `-50`, the background scrolls to the left
    as the robot moves to the right.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将背景速度设置为`-50`，当机器人向右移动时，背景向左滚动。
- en: Using an atlas
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图谱
- en: As I have mentioned already, texture memory is one of your core resources. In
    fact, it is common to run out of memory because of all the textures required to
    animate a typical 2D game. It is also time-consuming to load individual textures
    rather than loading on a larger texture. So, we have to come up with methods to
    use texture memory more efficiently.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，纹理内存是你们的核心资源之一。实际上，由于所有纹理都需要为典型的2D游戏动画，内存不足是很常见的情况。与加载单个纹理相比，加载更大的纹理也耗时。因此，我们必须想出更有效地使用纹理内存的方法。
- en: One common technique designed to pack more textures into less space is known
    as **atlasing**. A texture atlas works much like a sprite sheet described earlier
    in this chapter. Instead of storing each texture as its own image, we pack all
    of the textures for the entire game into one or more textures known as **atlases**.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一种旨在将更多纹理压缩到更少空间中的常用技术被称为**图谱化**。纹理图谱的工作方式与本章前面描述的精灵图非常相似。我们不是将每个纹理作为单独的图像存储，而是将整个游戏的所有纹理打包到一个或多个称为**图谱**的纹理中。
- en: 'As the word suggests, an atlas works much like a map. We simply need to know
    the location of any particular image, and we can find and extract it out of the
    atlas. Every atlas consists of two parts:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其词义所示，图谱的工作方式与地图非常相似。我们只需要知道任何特定图像的位置，我们就可以在图谱中找到并提取它。每个图谱都由两部分组成：
- en: The texture that contains all of the images
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含所有图像的纹理
- en: A text file that contains the positions of each image in the atlas
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含每个图像在图谱中位置的文本文件
- en: As you can imagine, efficiently packing thousands of images into an atlas and
    then keeping track of each image's position within the atlas would be almost impossible
    to manage manually. This is why there are programs to do this for us.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，将成千上万的图像高效地打包进图谱，并手动跟踪每个图像在图谱中的位置几乎是不可能的。这就是为什么有程序为我们做这件事。
- en: I use a free texture atlas tool called **Texture Atlas Generator**. You can
    download this at [http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/](http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用一个名为**Texture Atlas Generator**的免费纹理图集工具。你可以从这里下载：[http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/](http://www.gogo-robot.com/2010/03/20/texture-atlas-sprite-sheet-generator/)。
- en: 'A detailed example of atlasing is beyond the scope of this chapter. If you
    want to explore this on your own, here are the steps that you require:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不涉及详细的图集示例。如果你想自己探索，以下是你需要的步骤：
- en: Use a program, such as the one just mentioned, to create your atlas.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个程序，例如刚才提到的程序，来创建你的图集。
- en: Save your data as an XML file.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的数据保存为XML文件。
- en: Write a class to parse the XML saved in the previous step (I suggest **TinyXML**
    at [http://www.grinninglizard.com/tinyxml/](http://www.grinninglizard.com/tinyxml/)
    as a starter).
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类来解析之前步骤中保存的XML（我建议从[http://www.grinninglizard.com/tinyxml/](http://www.grinninglizard.com/tinyxml/)上的**TinyXML**开始）。
- en: Using the code to work with sprite sheets, modify the sprite class to be able
    to handle sub-textures from any arbitrary position in a larger texture.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与精灵图集一起工作的代码，修改精灵类以能够从更大的纹理中的任意位置处理子纹理。
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered a lot of ground. You created a new class specifically
    to work with sprites. Consider this class a huge part of your utility box for
    any game that you will create. This class handles all of the requirements that
    you will need to load, move, and handle textures as objects in your game.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。你创建了一个新的类专门用于处理精灵。将这个类视为你为任何将要创建的游戏的实用工具箱的一个巨大部分。这个类处理了你在游戏中加载、移动和处理纹理作为对象所需的所有要求。
- en: In the next chapter, you will learn how to how to handle input, and actually
    control your robot.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何处理输入，并实际控制你的机器人。
