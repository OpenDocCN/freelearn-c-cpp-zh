- en: Chapter 1. Game Development Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 游戏开发基础
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下食谱：
- en: Installing an IDE on Windows
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上安装一个IDE
- en: Choosing the right source control tool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的源代码控制工具
- en: Using call stacks for memory storage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调用堆栈进行内存存储
- en: Using recursions cautiously
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用递归
- en: Using pointers to store memory addresses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指针存储内存地址
- en: Casting between various datatypes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种数据类型之间进行转换
- en: Managing memory more effectively using dynamic allocation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态分配更有效地管理内存
- en: Using bitwise operations for advanced checks and optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位操作进行高级检查和优化
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will cover the basic concepts that you need to know to kick-start
    your career in game development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍你在游戏开发中需要了解的基本概念。
- en: The first step before a person starts coding is to install an **integrated development
    environment** (**IDE**). Nowadays, there are a few online IDEs that are available,
    but we are going to use an offline standalone IDE, **Visual Studio**. The next
    most important thing that many programmers do not start using at an early stage
    is **revision control software**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个人开始编码之前的第一步是安装一个**集成开发环境**（**IDE**）。现在有一些在线IDE可用，但我们将使用离线独立的IDE，**Visual
    Studio**。许多程序员在早期阶段没有开始使用的下一个最重要的事情是**修订控制软件**。
- en: Revision control software helps to back up the code in one central location;
    it has a historical overview of the changes that are made, which you can access
    and revert to if needed, and it also helps to resolve conflicts between files
    that have been worked on by different programmers at the same time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 修订控制软件有助于将代码备份到一个中心位置；它有对所做更改的历史概述，您可以访问并在需要时恢复，它还有助于解决不同程序员同时对同一文件进行的工作之间的冲突。
- en: The most useful feature of C++, in my opinion, is **memory handling**. It gives
    the developers a lot of control over how memory must be assigned depending on
    the current usage and needs of the program. As a result of this, we can allocate
    memory when there is a need and deallocate it accordingly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，C++最有用的特性是**内存处理**。它让开发人员对内存分配方式有很大的控制，这取决于程序的当前使用和需求。因此，我们可以在需要时分配内存，并相应地释放它。
- en: If we do not de-allocate memory, we might run out of memory very soon, especially
    if we are using recursion. Sometimes there is a need to convert from one datatype
    to another to prevent loss of data, to pass the correct datatype in a function,
    and so on. C++ provides us a few ways by which we can do those castings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不释放内存，我们可能很快就会用完内存，特别是如果我们使用递归。有时需要将一种数据类型转换为另一种，以防止数据丢失，在函数中传递正确的数据类型等。C++提供了一些方法，我们可以通过这些方法进行转换。
- en: The recipes in this chapter will primarily focus on these topics and deal with
    practical ways to implement them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的食谱主要关注这些主题，并处理实现它们的实际方法。
- en: Installing an IDE on Windows
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装一个IDE
- en: In this recipe, we will find out how easy it is to install Visual Studio on
    your Windows machine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将发现在Windows机器上安装Visual Studio有多么容易。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need a machine running Windows. No other
    prerequisites are required.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，你需要一台运行Windows的机器。不需要其他先决条件。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Visual Studio is a powerful IDE in which most professional software is written.
    It has loads of features and plugins to help us write better code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio是一个强大的IDE，大多数专业软件都是用它编写的。它有很多功能和插件，帮助我们写出更好的代码：
- en: Go to [https://www.visualstudio.com](https://www.visualstudio.com).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://www.visualstudio.com](https://www.visualstudio.com)。
- en: Click on **Download Visual Studio Community**.![How to do it…](img/4929_01_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下载Visual Studio Community**。![操作步骤…](img/4929_01_01.jpg)
- en: Download Visual Studio Community
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Visual Studio Community
- en: This should download an `.exe` file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该下载一个`.exe`文件。
- en: After it downloads, double-click on the setup file to start the installation.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，双击安装文件开始安装。
- en: Make sure you have all the updates necessary on your Windows machine.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的Windows机器上有必要的所有更新。
- en: You can also download any version of Visual Studio or Visual C++ Express.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以下载任何版本的Visual Studio或Visual C++ Express。
- en: If the application asks for starting environment settings, select **C++** from
    the available options.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序要求开始环境设置，请从可用选项中选择**C++**。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A few things to note are listed here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要注意的几点：
- en: You need a Microsoft account to install it.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个Microsoft账户来安装它。
- en: There are other free IDEs for C++, such as **NetBeans**, **Eclipse**, and **Code::Blocks**.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他免费的C++ IDE，比如**NetBeans**、**Eclipse**和**Code::Blocks**。
- en: While Visual Studio works only for Windows, Code::Blocks and other such IDEs
    are cross-platform and can work on Mac and Linux as well.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然Visual Studio只适用于Windows，但Code::Blocks和其他跨平台的IDE也可以在Mac和Linux上运行。
- en: For the remainder of this chapter, all code examples and snippets will be provided
    using Visual Studio.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，所有的代码示例和片段都将使用Visual Studio提供。
- en: How it works…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: An IDE is a programming environment. An IDE consists of various functionalities
    that can vary from one IDE to another. However, the most basic functionalities
    that are present in all IDEs are a code editor, a compiler, a debugger, a linker,
    and a GUI builder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: IDE是一个编程环境。IDE包括各种功能，这些功能在一个IDE到另一个IDE可能会有所不同。然而，在所有IDE中都存在的最基本的功能是代码编辑器、编译器、调试器、链接器和GUI构建器。
- en: 'A code editor, or a source code editor as they are otherwise known, is useful
    for editing code written by programmers. They provide features such as auto-correct,
    syntax highlighting, bracket completion and indentation, and so on. An example
    snapshot of the Visual Studio code editor is shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑器，或者另一种称呼为源代码编辑器，对程序员编写的代码进行编辑非常有用。它们提供诸如自动校正、语法高亮、括号补全和缩进等功能。下面是Visual
    Studio代码编辑器的示例快照：
- en: '![How it works…](img/4929_01_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/4929_01_02.jpg)'
- en: A **compiler** is a computer program that converts your C++ code to object code.
    This is necessary in order to create an executable. If you have a file called
    `main.cpp`, it will generate an object code called `main.o`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译器**是一个将您的C++代码转换为目标代码的计算机程序。这是为了创建可执行文件所必需的。如果您有一个名为`main.cpp`的文件，它将生成一个名为`main.o`的目标代码。'
- en: 'A **linker** is a computer program that converts the object code generated
    by the compiler to an executable or a library file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**链接器**是一个将编译器生成的目标代码转换为可执行文件或库文件的计算机程序：'
- en: '![How it works…](img/4929_01_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4929_01_03.jpg)'
- en: Compiler and linker
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和链接器
- en: A **debugger** is a computer program that helps to test and debug computer programs.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试器**是一个帮助测试和调试计算机程序的计算机程序。'
- en: A **GUI builder** helps the designer and programmer to create GUI content or
    widgets easily. It uses a drag and drop **WYSIWYG** tool editor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**GUI构建器**帮助设计师和程序员轻松创建GUI内容或小部件。它使用拖放**所见即所得**工具编辑器。'
- en: Choosing the right source control tool
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的源代码控制工具
- en: In this recipe, we will see how easy it is to take a backup of our code using
    the right version control. The advantages of having a backup to a central server
    is that you will never lose work, can download the code on any machine, and can
    also go back to any of your changes from the past. Imagine it is like a checkpoint
    that we have in games, and you can go back to that checkpoint if you face problems.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将看到使用正确的版本控制来备份我们的代码是多么容易。将备份到中央服务器的优势是您永远不会丢失工作，可以在任何计算机上下载代码，还可以回到过去的任何更改。想象一下，就像我们在游戏中有一个检查点，如果遇到问题，可以回到那个检查点。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To go through this recipe, you will need a machine running Windows. No other
    prerequisites are required.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，您需要一台运行Windows的计算机。不需要其他先决条件。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Choosing a correct version tool is very important as it will save a lot of time
    organizing data. There are a few versioning tools that are available, so it is
    very important that we should be informed about all of them so that we can use
    the correct one based on our needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的版本控制工具非常重要，因为它将节省大量时间来组织数据。有几种版本控制工具可用，因此非常重要的是我们应该了解所有这些工具，这样我们就可以根据自己的需求选择正确的工具。
- en: First analyze the choices that are available to you. The choices primarily include
    **Concurrent Versions System** (**CVS**), **Apache** **Subversion** (**SVN**),
    **Mercurial**, and **GIT**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先分析一下你可以选择的选项。选择主要包括**Concurrent Versions System**（**CVS**），**Apache** **Subversion**（**SVN**），**Mercurial**和**GIT**。
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: CVS has been around for a long time, so there is tons of documentation and help
    available. However, a lack of atomic operations often leads to source corruption
    and it is not well cut out for long-term branching operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: CVS已经存在很长时间了，因此有大量的文档和帮助可用。然而，缺乏原子操作经常导致源代码损坏，不太适合长期分支操作。
- en: SVN was made as an improvement to CVS and it does fix many of its issues relating
    to atomic operations and source corruption. It is free and open source. It has
    lots of plugins for different IDEs. However, one of the major drawbacks of this
    tool is that it is comparatively very slow in its operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SVN是作为对CVS的改进而制作的，它解决了许多与原子操作和源代码损坏有关的问题。它是免费和开源的。它有许多不同IDE的插件。然而，这个工具的一个主要缺点是它在操作中相对非常慢。
- en: GIT was made primarily for Linux but it improves operation speed a lot. It works
    on UNIX systems as well. It has cheap branch operations but it is not totally
    optimized for a single developer and its Windows support is limited compared to
    Linux. However, GIT is extremely popular and many prefer GIT to SVN or CVS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GIT主要是为Linux开发的，但它大大提高了操作速度。它也适用于UNIX系统。它具有廉价的分支操作，但与Linux相比，它对单个开发人员的支持有限。然而，GIT非常受欢迎，许多人更喜欢GIT而不是SVN或CVS。
- en: Mercurial came into existence shortly after GIT. It has node-based operations
    but does not allow the merging of two parent branches.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Mercurial在GIT之后不久出现。它具有基于节点的操作，但不允许合并两个父分支。
- en: So to sum up, use SVN if you want a central repository that others can push
    and pull. Although it has its limitations, it's easy to learn. Use Mercurial or
    GIT if you want a distributed model. In this case, there is a repository on every
    computer, and generally, one of them is regarded as the *official* one. Mercurial
    is often preferred if it is a relatively small team, and it's easier to learn
    than GIT.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总之，如果您想要一个其他人可以推送和拉取的中央存储库，请使用SVN。尽管它有局限性，但很容易学习。如果您想要一个分布式模型，请使用Mercurial或GIT。在这种情况下，每台计算机上都有一个存储库，并且通常有一个被视为*官方*的存储库。如果团队规模相对较小，通常更喜欢Mercurial，并且比GIT更容易学习。
- en: We will look into these in more detail in a separate chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在另一章节中更详细地研究这些内容。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book. Please have a look.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关下载代码包的详细步骤在本书的前言中有提及。请查看。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/C++Game-Development-Cookbook](https://github.com/PacktPublishing/C++Game-Development-Cookbook).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的代码包也托管在GitHub上，网址为[https://github.com/PacktPublishing/C++Game-Development-Cookbook](https://github.com/PacktPublishing/C++Game-Development-Cookbook)。我们还有来自丰富书籍和视频目录的其他代码包，可在[https://github.com/PacktPublishing/](https://github.com/PacktPublishing/)上找到。去看看吧！
- en: Using call stacks for memory storage
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调用堆栈进行内存存储
- en: The main reason why C++ is still the preferred language for most game developers
    is that you handle memory yourself and control the allocation and de-allocation
    of memory to a great extent. For that reason, we need to understand the different
    memory spaces that are provided to us. When data is "pushed" onto the stack, the
    stack grows. As data is "popped" off the stack, the stack shrinks. It is not possible
    to pop a particular piece of data off the stack without first popping off all
    data placed on top of it. Think of this as a series of compartments aligned top
    to bottom. The top of the stack is whatever compartment the stack pointer happens
    to point to (this is a register).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++仍然是大多数游戏开发者首选的语言的主要原因是你可以自己处理内存并且在很大程度上控制内存的分配和释放。因此，我们需要了解为我们提供的不同内存空间。当数据被“推”到堆栈上时，堆栈增长。当数据被“弹”出堆栈时，堆栈缩小。不可能在不先弹出放在其上面的所有数据的情况下弹出堆栈上的特定数据。把这想象成一系列从上到下排列的隔间。堆栈的顶部是堆栈指针指向的任何隔间（这是一个寄存器）。
- en: Each compartment has a sequential address. One of those addresses is kept in
    the stack pointer. Everything below that magic address, known as the top of the
    stack, is considered to be on the stack. Everything above the top of the stack
    is considered to be off the stack. When data is pushed onto the stack, it is placed
    into a compartment above the stack pointer, and then the stack pointer is moved
    to the new data. When data is popped off the stack, the address of the stack pointer
    is changed by moving it down the stack.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个隔间都有一个顺序地址。其中一个地址被保存在堆栈指针中。在那个神奇的地址下面的所有东西，被称为堆栈的顶部，被认为是在堆栈上。在堆栈顶部以上的所有东西被认为是堆栈之外的。当数据被推送到堆栈上时，它被放入堆栈指针上面的一个隔间中，然后堆栈指针被移动到新的数据上。当数据从堆栈上弹出时，堆栈指针的地址通过向下移动来改变。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的Windows机器上安装一个可用的Visual Studio副本。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'C++ is probably one of the best programming languages out there and one of
    the main reasons for that is that it is also a low level language, because we
    can manipulate memory. To understand memory handling, it is very important to
    understand how memory stacks work:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C++可能是目前最好的编程语言之一，而其中一个主要原因是它也是一种低级语言，因为我们可以操纵内存。要理解内存处理，了解内存堆栈的工作方式非常重要：
- en: Open Visual Studio.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名的源文件。
- en: 'Add the following lines of code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you call the function `CountTotalBullets`, the code branches to the called
    function. The parameters are passed in and the body of the function is executed.
    When the function completes, a value is returned and the control returns to the
    calling function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用函数`CountTotalBullets`时，代码会分支到被调用的函数。参数被传递进来，函数体被执行。当函数完成时，一个值被返回，控制返回到调用函数。
- en: But how does it really work from a compiler's point of view? When you begin
    your program, the compiler creates a stack. The **stack** is a special area of
    memory allocated for your program in order to hold the data for each function
    in your program. A stack is a **Last In First Out** (**LIFO**) data structure.
    Imagine a deck of cards; the last card put on the pile will be the first card
    taken out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但从编译器的角度来看，它是如何真正工作的呢？当你开始你的程序时，编译器创建一个堆栈。**堆栈**是为了在你的程序中保存每个函数的数据而分配的内存的一个特殊区域。堆栈是一个**后进先出**（**LIFO**）的数据结构。想象一副牌；放在牌堆上的最后一张牌将是最先拿出的。
- en: 'When your program calls `CountTotalBullets`, a stack frame is established.
    A **stack frame** is an area of the stack set aside to manage that function. This
    is very complex and different on different platforms, but these are the essential
    steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序调用`CountTotalBullets`时，一个堆栈帧被建立。**堆栈帧**是堆栈中专门留出来管理该函数的区域。这在不同的平台上非常复杂和不同，但这些是基本步骤：
- en: The return address of `CountTotalBullets` is put on the stack. When the function
    returns, it will resume executing at this address.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CountTotalBullets`的返回地址被放在堆栈上。当函数返回时，它将在这个地址继续执行。'
- en: Room is made on the stack for the return type you have declared.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你声明的返回类型在堆栈上留出空间。
- en: All arguments to the function are placed on the stack.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有函数参数都被放在堆栈上。
- en: The program branches to your function.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序分支到你的函数。
- en: Local variables are pushed onto the stack as they are defined.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 局部变量在定义时被推送到堆栈上。
- en: Using recursions cautiously
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用递归
- en: Recursions are a form of programming design in which the function calls itself
    multiple times to solve a problem by breaking down a large solutions set into
    multiple small solution sets. The code size definitely shortens. However, if not
    used properly, recursions can fill up the call stack really fast and you can run
    out of memory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种编程设计形式，函数多次调用自身以通过将大型解决方案集拆分为多个小解决方案集来解决问题。代码大小肯定会缩短。然而，如果不正确使用，递归可能会非常快地填满调用堆栈，导致内存耗尽。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with this recipe, you should have some prior knowledge of call
    stacks and how memory is assigned during a function call. You need a Windows machine
    with a working copy of Visual Studio.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用这个方法，你应该对调用堆栈和函数调用期间内存分配有一些先验知识。你需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, you will see how easy it is to use recursions. Recursions are
    very smart to code but also can lead to some serious problems:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，你将看到使用递归是多么容易。递归编程非常聪明，但也可能导致一些严重的问题：
- en: Open Visual Studio.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名的源文件。
- en: 'Add the following lines of code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see from the preceding code, both the functions find the factorial
    of a number. However, when using recursion, the stack size will grow immensely
    with each function call; the stack pointer has to be updated every call and data
    pushed onto the stack. With recursion, as the function calls itself, every time
    a function is called from within itself the stack size will keep on rising until
    it runs out of memory and creates a deadlock or crashes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，这两个函数都可以找到一个数字的阶乘。然而，使用递归时，每次函数调用时堆栈大小都会急剧增长；堆栈指针必须在每次调用时更新，并且数据被推送到堆栈上。使用递归时，由于函数调用自身，每次从内部调用函数时，堆栈大小都会不断增加，直到内存耗尽并创建死锁或崩溃。
- en: Imagine finding the factorial of 1000\. The function will be called within itself
    a very large number of times. This is a recipe for certain disaster and we should
    avoid such coding practices to a great extent.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下找到1000的阶乘。该函数将在自身内部被调用很多次。这是一种导致灾难的方法，我们应该尽量避免这种编码实践。
- en: There's more…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can use a larger datatype than int if you are finding the factorial of a
    number greater than 15, as the resulting factorial will be too large to be stored
    in int.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要找到大于15的数字的阶乘，可以使用比int更大的数据类型，因为得到的阶乘将太大而无法存储在int中。
- en: Using pointers to store memory addresses
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指针存储内存地址
- en: In the previous two recipes, we have seen how not having sufficient memory can
    be a problem to us. However, until now, we have had no control over how much memory
    is assigned and what is assigned to each memory address. Using pointers, we can
    address this issue. In my opinion, pointers are the single most important topic
    in C++. If your concept of C++ has to be clear, and if you are to become a good
    developer in C++, you must be good with pointers. Pointers can seem very daunting
    at first, but once you get the hang of it, pointers are pretty easy to use.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，我们已经看到内存不足可能会成为我们的问题。然而，直到现在，我们对分配多少内存以及分配给每个内存地址的内容没有任何控制。使用指针，我们可以解决这个问题。在我看来，指针是C++中最重要的主题。如果你对C++的概念必须清晰，并且如果你要成为一个优秀的C++开发人员，你必须擅长使用指针。指针一开始可能看起来很可怕，但一旦你掌握了它，指针就很容易使用。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will see how easy it is to work with pointers. Once you
    are comfortable using pointers, we can manipulate memory and store references
    in memory quite easily:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到使用指针有多么容易。一旦你熟悉使用指针，我们就可以很容易地操纵内存并在内存中存储引用：
- en: Open Visual Studio.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名源文件。
- en: 'Add the following lines of code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'One of the most powerful tools of a C++ programmer is to manipulate computer
    memory directly. A **pointer** is a variable that holds a memory address. Each
    variable and object used in a C++ program is stored in a specific place in memory.
    Each memory location has a unique address. Memory addresses will vary depending
    on the operating system used. The amount of bytes taken up depends on the variable
    type: *float = 4 bytes*, *short = 2 bytes*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员最强大的工具之一是直接操作计算机内存。**指针**是一个保存内存地址的变量。C++程序中使用的每个变量和对象都存储在内存的特定位置。每个内存位置都有一个唯一的地址。内存地址将根据所使用的操作系统而变化。所占用的字节数取决于变量类型：*float
    = 4字节*，*short = 2字节*：
- en: '![How it works…](img/4929_01_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/4929_01_04.jpg)'
- en: Pointers and memory storage
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 指针和内存存储
- en: Each location in the memory is 1 byte. The pointer `pfLocalCurrentHealth` holds
    the address of the memory location that has stored `fCurrentHealth`. Hence, when
    we display the contents of the pointer, we get the same address as that of the
    address containing the `fCurrentHealth` variable. We use the `&` operator to get
    the address of the `pfLocalCurrentHealth` variable. When we reference the pointer
    using the `*` operator, we get the value stored at the address. Since the stored
    address is same as the address storing `fCurrentHealth`, we get the value `10`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的每个位置都是1字节。指针`pfLocalCurrentHealth`保存了存储`fCurrentHealth`的内存位置的地址。因此，当我们显示指针的内容时，我们得到的是与包含`fCurrentHealth`变量的地址相同的地址。我们使用`&`运算符来获取`pfLocalCurrentHealth`变量的地址。当我们使用`*`运算符引用指针时，我们得到存储在该地址的值。由于存储的地址与存储`fCurrentHealth`的地址相同，我们得到值`10`。
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let us consider the following declarations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下声明：
- en: '`const float* pfNumber1`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const float* pfNumber1`'
- en: '`float* const pfNumber2`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float* const pfNumber2`'
- en: '`const float* const pfNumber3`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const float* const pfNumber3`'
- en: 'All of these declarations are valid. But what do they mean? The first declaration
    states that `pfNumber1` is a pointer to a constant float. The second declaration
    states that `pfNumber2` is a constant pointer to a float. The third declaration
    states that `pfNumber3` is a constant pointer to a constant integer. The key differences
    between references and these three types of const pointers are listed here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些声明都是有效的。但是它们的含义是什么？第一个声明说明`pfNumber1`是一个指向常量浮点数的指针。第二个声明说明`pfNumber2`是一个指向浮点数的常量指针。第三个声明说明`pfNumber3`是一个指向常量整数的常量指针。引用和这三种const指针之间的关键区别如下：
- en: '`const` pointers can be NULL'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`指针可以是NULL'
- en: A reference does not have its own address, whereas a pointer does
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用没有自己的地址，而指针有
- en: The address of a reference is the actual object's address
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的地址是实际对象的地址
- en: A pointer has its own address and it holds as its value the address of the value
    it points to
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针有自己的地址，并且它的值是它指向的值的地址
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on pointers and references, go to the following link:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关指针和引用的更多信息，请访问以下链接：
- en: '[http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492](http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492](http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in/57492#57492)'
- en: Casting between different datatypes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同数据类型之间进行转换
- en: Casting is a conversion process of changing some data into a different type
    of data. We can convert between built-in types or our own datatypes. Some of the
    conversions are done automatically by the compiler, and the programmer does not
    have to intervene. Such conversions are called **implicit conversions**. Other
    conversions, which have to be directly specified by the programmer, are called
    explicit conversion. Sometimes we may get warnings about *loss of data*. We should
    pay heed to these warnings and think about how this might adversely affect our
    code. Casting is commonly used when the interface expects a particular type, but
    we want to feed it data of a different type. With C, we can cast anything to everything.
    However, C++ provides us with finer controls.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是一种将一些数据转换为不同类型数据的转换过程。我们可以在内置类型或我们自己的数据类型之间进行转换。一些转换是由编译器自动完成的，程序员不必干预。这种转换称为**隐式转换**。其他转换必须由程序员直接指定，称为显式转换。有时我们可能会收到关于*数据丢失*的警告。我们应该注意这些警告，并考虑这可能会对我们的代码产生不利影响。当接口期望特定类型的数据，但我们想要提供不同类型的数据时，通常会使用转换。在C中，我们可以将任何东西转换为任何东西。然而，C++为我们提供了更精细的控制。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，你需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how we can easily cast or convert between various
    datatypes. Usually, a programmer uses C-style casting even in C++, but this is
    not recommended. C++ provides us with its own style of casting for different situations
    which we should use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看到如何在各种数据类型之间轻松转换或转换。通常，程序员即使在C++中也使用C风格的转换，但这是不推荐的。C++为不同情况提供了自己的转换风格，我们应该使用它：
- en: Open Visual Studio.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名的源文件。
- en: 'Add the following lines of code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are four types of casting operators in C++, depending on what we are
    casting: `static_cast`, `const_cast`, `reinterpret_cast`, and `dynamic_cast`.
    Now, we are going to look at `static_cast`. We will look at the remaining three
    casting technique after we discuss dynamic memory and classes. Converting from
    a smaller datatype to a larger type is called promotion and is guaranteed to have
    no data loss. However, conversion from a larger datatype to a smaller one is called
    demotion and may lead to data loss. Compilers will generally give you a warning
    when this happens, and you should pay heed to this.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中有四种类型的转换操作符，取决于我们要转换的内容：`static_cast`、`const_cast`、`reinterpret_cast`和`dynamic_cast`。现在，我们将看看`static_cast`。在讨论动态内存和类之后，我们将看看剩下的三种转换技术。从较小的数据类型转换为较大的类型称为提升，保证不会丢失数据。然而，从较大的数据类型转换为较小的数据类型称为降级，可能会导致数据丢失。当发生这种情况时，编译器通常会给出警告，你应该注意这一点。
- en: Let us look at the previous example. We have initialized an integer with the
    value `5`. Next, we have initialized a floating point variable and stored the
    result of `5` divided by `2`, which is `2.5`. However, when we display the variable
    `fNumber`, we see that the displayed value is `2`. The reason is the C++ compiler
    implicitly casts the result of `5/2` and stores it as an integer. So it is evaluating
    something similar to int (`5/2`) which is int (`2.5`), evaluating to `2`. So to
    achieve our desired result, we have two options. The first method is a C-style
    explicit cast, which is not recommended at all because it does not have a type
    safe check. The format for the C-style cast is (`resultant_data_type`) (`expression`),
    which in this case is something like float (`5/2`). We are explicitly telling
    the compiler to store the result of the expression as a floating point number.
    The second method, and a more C++ style way of doing the cast, is by using the
    `static_cast` operation. This has suitable constructors to dictate that the conversion
    is type safe. The format for a `static_cast` operation is `static_cast<resultant_data_type>
    (expression)`. The compiler checks if the casting conversion is safe and then
    executes the type casting operation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前的例子。我们已经用值`5`初始化了一个整数。接下来，我们初始化了一个浮点变量，并存储了`5`除以`2`的结果，即`2.5`。然而，当我们显示变量`fNumber`时，我们看到显示的值是`2`。原因是C++编译器隐式地将`5/2`的结果转换为整数并存储它。因此，它类似于计算int(`5/2`)，即int(`2.5`)，计算结果为`2`。因此，为了实现我们想要的结果，我们有两个选项。第一种方法是C风格的显式转换，这是不推荐的，因为它没有类型安全检查。C风格转换的格式是(`resultant_data_type`)
    (`expression`)，在这种情况下类似于float (`5/2`)。我们明确告诉编译器将表达式的结果存储为浮点数。第二种方法，更符合C++风格的转换方法，是使用`static_cast`操作。这种方法有适当的构造函数来指示转换是类型安全的。`static_cast`操作的格式是`static_cast<resultant_data_type>
    (expression)`。编译器会检查转换是否安全，然后执行类型转换操作。
- en: Managing memory more effectively using dynamic allocation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更有效地管理内存，使用动态分配
- en: 'Programmers generally deal with five areas of memory: **global namespace**,
    **registers**, **code space**, **stack**, and the **free store**. When an array
    is initialized, the number of elements has to be defined. This leads to lots of
    memory problems. Most of the time, not all elements that we allocated are used,
    and sometimes we need more elements. To help overcome this problem, C++ facilitates
    memory allocation while an `.exe` file is running by using the free store.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员通常处理内存的五个领域：全局命名空间，寄存器，代码空间，堆栈和自由存储区。当数组被初始化时，必须定义元素的数量。这导致了许多内存问题。大多数情况下，我们分配的元素并没有全部被使用，有时我们需要更多的元素。为了帮助解决这个问题，C++通过使用自由存储区在`.exe`文件运行时进行内存分配。
- en: The free store is a large area of memory that can be used to store data, and
    is sometimes referred to as *the heap*. We can request some space on the free
    store, and it will give us an address that we can use to store data. We need to
    keep that address in a pointer. The free store is not cleaned up until your program
    ends. It is the programmer's responsibility to free any free store memory used
    by their program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 自由存储区是一个可以用来存储数据的大内存区域，有时被称为*堆*。我们可以请求一些自由存储区的空间，它会给我们一个地址，我们可以用来存储数据。我们需要将该地址保存在一个指针中。自由存储区直到程序结束才会被清理。程序员有责任释放程序使用的任何自由存储区内存。
- en: The advantage of the free store is that there is no need to preallocate all
    variables. We can decide at runtime when more memory is needed. The memory is
    reserved and remains available until it is explicitly freed. If memory is reserved
    while in a function, it is still available when control returns from that function.
    This is a much better way of coding than global variables. Only functions that
    have access to the pointer can access the data stored in memory, and it provides
    a tightly controlled interface to that data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自由存储区的优势在于不需要预先分配所有变量。我们可以在运行时决定何时需要更多内存。内存被保留并保持可用，直到显式释放为止。如果在函数中保留内存，当控制从该函数返回时，仍然可用。这比全局变量编码要好得多。只有可以访问指针的函数才能访问存储在内存中的数据，并且它为该数据提供了一个严格控制的接口。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will see how easy it is to use dynamic allocation. In games,
    most of the memory is allocated dynamically at runtime as we are never sure how
    much memory we should assign. Assigning an arbitrary amount of memory may result
    in less memory or memory wastage:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到动态分配是多么容易。在游戏中，大部分内存都是在运行时动态分配的，因为我们从来不确定应该分配多少内存。分配任意数量的内存可能导致内存不足或内存浪费：
- en: Open Visual Studio.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名的源文件。
- en: 'Add the following lines of code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE4]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can allocate memory to the free store using the `new` keyword; `new` is
    followed by the type of the variable you want to allocate. This allows the compiler
    to know how much memory will need to be allocated. In our example, we have used
    string. The `new` keyword returns a memory address. This memory address is assigned
    to a pointer, `sNameOfGuns`. We must assign the address to a pointer, otherwise
    the address will be lost. The format for using the `new` operator is `datatype
    * pointer = new datatype`. So in our example, we have used `sNameOfGuns = new
    string[iNumberofGuns]`. If the new allocation fails, it will return a null pointer.
    We should always check whether the pointer allocation has been successful; otherwise
    we will try to access a part of the memory that has not been allocated and we
    may get an error from the compiler, as shown in the following screenshot, and
    your application will crash:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`new`关键字将内存分配给自由存储区；`new`后面跟着您想要分配的变量的类型。这允许编译器知道需要分配多少内存。在我们的示例中，我们使用了string。`new`关键字返回一个内存地址。这个内存地址被分配给一个指针`sNameOfGuns`。我们必须将地址分配给一个指针，否则地址将丢失。使用`new`运算符的格式是`datatype
    * pointer = new datatype`。所以在我们的示例中，我们使用了`sNameOfGuns = new string[iNumberofGuns]`。如果新的分配失败，它将返回一个空指针。我们应该始终检查指针分配是否成功；否则我们将尝试访问未分配的内存的一部分，并且可能会收到编译器的错误，如下面的屏幕截图所示，您的应用程序将崩溃：
- en: '![How it works…](img/4929_01_05.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_01_05.jpg)'
- en: When you are finished with the memory, you must call delete on the pointer.
    Delete returns the memory to the free store. Remember that the pointer is a local
    variable. Where the function that the pointer is declared in goes out of scope,
    the memory on the free store is not automatically deallocated. The main difference
    between static and dynamic memory is that the creation/deletion of static memory
    is handled automatically, whereas dynamic memory must be created and destroyed
    by the programmer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成内存的使用后，必须在指针上调用delete。Delete将内存返回给自由存储区。请记住，指针是一个局部变量。指针声明所在的函数作用域结束时，自由存储区上的内存不会自动释放。静态内存和动态内存的主要区别在于，静态内存的创建/删除是自动处理的，而动态内存必须由程序员创建和销毁。
- en: The `delete[]` operator signals to the compiler that it needs to free an array.
    If you leave the brackets off, only the first element in the array will be deleted.
    This will create a memory leak. Memory leaks are really bad as it means there
    are memory spaces that have not been deallocated. Remember, memory is a finite
    space, so eventually you are going to run into trouble.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete[]`运算符向编译器发出需要释放数组的信号。如果你不加括号，只有数组中的第一个元素会被删除。这将导致内存泄漏。内存泄漏真的很糟糕，因为这意味着有未被释放的内存空间。请记住，内存是有限的空间，所以最终你会遇到麻烦。'
- en: 'When we use `delete[]`, how does the compiler know that it has to free *n*
    number of strings from the memory? The runtime system stores the number of items
    somewhere it can be retrieved only if you know the pointer `sNameOfGuns`. There
    are two popular techniques that do this. Both of these are used by commercial
    compilers, both have tradeoffs, and neither are perfect:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`delete[]`时，编译器如何知道它必须从内存中释放*n*个字符串？运行时系统将项目数存储在某个位置，只有当你知道指针`sNameOfGuns`时才能检索到。有两种流行的技术可以做到这一点。这两种技术都被商业编译器使用，都有权衡，都不是完美的：
- en: 'Technique 1:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术1：
- en: Over-allocate the array and put the number of items just to the left of the
    first element. This is the faster of the two techniques, but is more sensitive
    to the problem of the programmer saying `delete sNameOfGuns`, instead of `delete[]
    sNameOfGuns`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 过度分配数组，并将项目数放在第一个元素的左侧。这是两种技术中较快的一种，但对于程序员错误地使用`delete sNameOfGuns`而不是`delete[]
    sNameOfGuns`更敏感。
- en: 'Technique 2:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术2：
- en: Use an associative array with the pointer as a key and the number of items as
    the value. This is the slower of the two techniques, but is less sensitive to
    the problem of the programmer saying `delete sNameOfGuns`, instead of `delete[]
    sNameOfGuns`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关联数组，以指针作为键，项目数作为值。这是两种技术中较慢的一种，但对于程序员错误地使用`delete sNameOfGuns`而不是`delete[]
    sNameOfGuns`不太敏感。
- en: There's more…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: We can also use a tool called **VLD** to check for memory leaks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用一个名为**VLD**的工具来检查内存泄漏。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Download VLD from [https://vld.codeplex.com/](https://vld.codeplex.com/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://vld.codeplex.com/](https://vld.codeplex.com/)下载VLD。
- en: 'After the setup has downloaded, install VLD on your system. This may or may
    not set up the VC++ directories correctly. If it doesn''t, do it manually by right-clicking
    on the project page and adding the directory of VLD to the field called **Include
    Directories**, as shown in the following figure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，安装VLD到你的系统上。这可能会或可能不会正确设置VC++目录。如果没有，可以通过右键单击项目页面并将VLD目录添加到名为**包含目录**的字段中手动设置，如下图所示：
- en: '![There''s more…](img/4929_01_06.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](img/4929_01_06.jpg)'
- en: After setting up the directories, add the header file `<vld.h>` in your source
    file. After you execute your application and exit it, your output window will
    now show whether there are any memory leaks in your application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 设置目录后，在源文件中添加头文件`<vld.h>`。执行应用程序并退出后，输出窗口将显示应用程序中是否存在任何内存泄漏。
- en: Understanding the error messages
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解错误消息
- en: 'When using the debug build, you may notice the following values in memory during
    debugging:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试构建时，你可能会在调试期间在内存中看到以下值：
- en: '`0xCCCCCCCC`: This refers to values being allocated on the stack, but not yet
    initialized.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xCCCCCCCC`：这指的是在堆栈上分配的值，但尚未初始化。'
- en: '`0xCDCDCDCD`: This means memory has been allocated in the heap, but it is not
    yet initialized (clean memory).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xCDCDCDCD`：这意味着内存已经在堆中分配，但尚未初始化（干净内存）。'
- en: '`0xDDDDDDDD`: This means memory has been released from the heap (dead memory).'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xDDDDDDDD`：这意味着内存已经从堆中释放（死内存）。'
- en: '`0xFEEEFEEE`: This refers to values being deallocated from the free store.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xFEEEFEEE`：这指的是值被从自由存储中释放。'
- en: '`0xFDFDFDFD`: "No man''s land" fences, which are placed at the boundary of
    heap memory in debug mode. These should never be overwritten, and if they are,
    it probably means the program is trying to access memory at an index outside of
    an array''s max size.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xFDFDFDFD`："无人之地"栅栏，它们被放置在调试模式下堆内存的边界上。它们不应该被覆盖，如果被覆盖了，这可能意味着程序正在尝试访问数组最大大小之外的索引处的内存。'
- en: Using bitwise operations for advanced checks and optimization
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位操作进行高级检查和优化
- en: In most cases, a programmer will not need to worry too much about bits unless
    there is a need to write some compression algorithms, and when we are making a
    game, we never know when a situation such as that arises. In order to encode and
    decode files compressed in this manner, you need to actually extract data at the
    bit level. Finally, you can use bit operations to speed up your program or perform
    neat tricks. However, this is not always recommended.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，程序员不需要过多地担心位，除非有必要编写一些压缩算法，当我们制作游戏时，我们永远不知道是否会出现这样的情况。为了以这种方式压缩和解压文件，你需要实际上在位级别提取数据。最后，你可以使用位操作来加速你的程序或执行巧妙的技巧。但这并不总是推荐的。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要一台装有Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will see how easy it is to use bitwise operations to perform
    operations by manipulating memory. Bitwise operations are also a great way to
    optimize code by directly interacting with memory:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到使用位操作通过操作内存执行操作是多么容易。位操作也是通过直接与内存交互来优化代码的好方法：
- en: Open Visual Studio.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Add a source file called `main.cpp` or anything that you want to name the source
    file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`main.cpp`的源文件，或者任何你想要命名的源文件。
- en: 'Add the following lines of code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码行：
- en: '[PRE5]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The left shift operator is the equivalent of moving all the bits of a number
    a specified number of places to the left. In our example, the numbers we are sending
    to the function `Multi_By_Power_2` is `4` and `3`. The binary representation of
    `4` is `100`, so if we shift the most significant bit, which is `1`, three places
    to the left, we get `10000`, which is the binary of `16`. Hence, left shift is
    equivalent to integer division by `2^shift_arg`, that is, `4*2^3`, which is again
    `16`. Similarly, the right shift operation is equivalent to integer division by
    `2^shift_arg`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 左移操作符相当于将数字的所有位向左移动指定的位数。在我们的例子中，我们发送给函数`Multi_By_Power_2`的数字是`4`和`3`。数字`4`的二进制表示是`100`，所以如果我们将最高有效位（1）向左移动三位，我们得到`10000`，这是`16`的二进制。因此，左移等同于整数除以`2^shift_arg`，即`4*2^3`，这又是`16`。类似地，右移操作等同于整数除以`2^shift_arg`。
- en: 'Now let us consider we want to pack data so that the data is compressed. Consider
    the following example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑我们想要打包数据，以便压缩数据。考虑以下示例：
- en: '[PRE6]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are storing the total bullets in a gun; the type of gun, but it can only
    be a rifle or pistol; and the total bullets per round it can fire. Currently we
    are using three integer values to store the data. However, we can compress all
    the preceding data into one single integer and hence compress the data:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在存储枪支的总子弹数；枪支的类型，但只能是步枪或手枪；以及它可以发射的每轮总子弹数。目前我们使用三个整数值来存储数据。然而，我们可以将所有前述数据压缩成一个单一整数，从而压缩数据：
- en: '[PRE7]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we assume the following notations:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设以下符号：
- en: 'TotalAmmon: `A`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总弹药数：`A`
- en: 'Type: `T`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：`T`
- en: 'Rounds: `R`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮数：`R`
- en: 'The final representation in the data would be something like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的最终表示将类似于这样：
- en: '[PRE8]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
