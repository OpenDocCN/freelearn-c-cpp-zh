- en: C++, RAII, and the GSL Refresher
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++，RAII和GSL复习
- en: In this chapter, we will provide an overview of some of the recent advancements
    of C++ that are leveraged in this book. We will start by providing an overview
    of the changes made to C++ in the C++17 specification. We will then briefly cover
    a C++ design pattern called **Resource Acquisition Is Initialization** (**RAII**),
    how it is used by C++, and why it is so important to not only C++ but many other
    languages that leverage the same design pattern. This chapter will conclude with
    an introduction to the **Guideline Support Library** (**GSL**) and how it can
    help to increase the reliability and stability of system programming by helping
    to adhere to the C++ Core Guidelines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述本书中利用的C++的一些最新进展。我们将首先概述C++17规范中对C++所做的更改。然后我们将简要介绍一种名为**资源获取即初始化**（**RAII**）的C++设计模式，以及它在C++中的使用方式以及为什么它对C++以及许多其他利用相同设计模式的语言如此重要。本章将以介绍**指导支持库**（**GSL**）并讨论它如何通过帮助遵守C++核心指南来增加系统编程的可靠性和稳定性而结束。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Discussing the advancements made in C++17
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论C++17中的进展
- en: Outlining RAII
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述RAII
- en: Introducing the GSL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GSL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples and code
    snippets, go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请转到以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter04)。
- en: A brief overview of C++17
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++17的简要概述
- en: The goal of this section is to provide a brief overview of C++17 and the features
    added to C++. For a more comprehensive and in-depth look at C++17, please see
    the *Further reading* section of this chapter, which list additional books from
    Packt Publishing on the topic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是简要概述C++17和添加到C++的功能。要了解更全面和深入的C++17，请参阅本章的*进一步阅读*部分，其中列出了Packt Publishing关于该主题的其他书籍。
- en: Language changes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言变化
- en: There were several changes made to the C++17 language and syntax. The following
    are some examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++17语言和语法进行了几处更改。以下是一些示例。
- en: Initializers in if/switch statements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if/switch语句中的初始化器
- en: 'In C++17, it is now possible to define a variable and initialize it in the
    definition of an `if` and `switch` statement, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，现在可以在`if`和`switch`语句的定义中定义变量并初始化，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the `i` variable is defined and initialized inside
    the `if` statement using a semicolon (`;`) inside the branch itself. This is especially
    useful for C- and POSIX-style functions that return error codes, as the variable
    that stores the error code can be defined in the proper context.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`i`变量在`if`语句内部使用分号（`;`）进行定义和初始化。这对于返回错误代码的C和POSIX风格函数特别有用，因为存储错误代码的变量可以在适当的上下文中定义。
- en: What makes this feature so important and useful is that the variable is only
    defined when the condition is met. That is, in the preceding example, `i` only
    exists if `i` is greater than `0`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性如此重要和有用的原因在于只有在条件满足时才定义变量。也就是说，在前面的示例中，只有当`i`大于`0`时，`i`才存在。
- en: This is extremely helpful in ensuring that variables are available when they
    are valid, helping to reduce the likelihood of working with an invalid variable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这对确保变量在有效时可用非常有帮助，有助于减少使用无效变量的可能性。
- en: 'The same type of initialization can occur with `switch` statements as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句可以发生相同类型的初始化，如下所示：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the `i` variable is created only in the context of
    the `switch` statement. Unlike the `if` statement, the `i` variable exists for
    all cases, meaning the `i` variable is available in the `default` state, which
    could represent the invalid state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`i`变量仅在`switch`语句的上下文中创建。与`if`语句不同，`i`变量存在于所有情况下，这意味着`i`变量在`default`状态中可用，这可能代表无效状态。
- en: Additions to compile-time facilities
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加编译时设施
- en: 'With C++11, `constexpr` was added as a statement to the compiler that a variable,
    function, and so on, can be evaluated at compile time and optimized, reducing
    the complexity of the code at runtime and improving performance overall. In some
    cases, the compiler was smart enough to extend `constexpr` statements to other
    components, including branch statements, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，`constexpr`被添加为一种声明，告诉编译器变量、函数等可以在编译时进行评估和优化，从而减少运行时代码的复杂性并提高整体性能。在某些情况下，编译器足够聪明，可以将`constexpr`语句扩展到其他组件，包括分支语句，例如：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we have created a `constexpr` variable, and we only output
    `Hello World` to `stdout` if `constexpr` is `true`. Since, in this example, it''s
    always true, the compiler will remove the branch from the code entirely, as shown
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`constexpr`变量，并且只有在`constexpr`为`true`时才将`Hello World`输出到`stdout`。由于在这个例子中它总是为真，编译器将完全从代码中删除该分支，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the code loads a couple of registers and calls `std::cout` without
    checking whether `val` is true, since the compiler completely removed the code
    from the resulting binary. The issue with C++11 was that the author could assume
    that this type of optimization was taking place, when in fact it might not be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码加载了一些寄存器并调用`std::cout`，而没有检查`val`是否为真，因为编译器完全从生成的二进制代码中删除了该代码。C++11的问题在于作者可能会假设这种类型的优化正在进行，而实际上可能并没有。
- en: 'To prevent this type of error, C++17 adds a `constexpr` `if` statement, which
    tells the compiler to specifically optimize the branch at compile time. If the
    compiler cannot optimize the `if` statement, an explicit compile-time error will
    occur, telling the user that optimization could not be done, providing the user with
    an opportunity to fix the issue (instead of assuming the optimization was taking
    place when in fact it might not be), for example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种类型的错误，C++17添加了`constexpr` `if`语句，告诉编译器在编译时特别优化分支。如果编译器无法优化`if`语句，将会发生显式的编译时错误，告诉用户无法进行优化，为用户提供修复问题的机会（而不是假设优化正在进行，实际上可能并没有进行），例如：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example, we have a more complicated `if` statement that leverages
    both a compile-time `constexpr` optimization as well as an `if` statement initializer.
    The resulting binary is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个更复杂的`if`语句，它利用了编译时的`constexpr`优化以及`if`语句的初始化器。生成的二进制代码如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the branch has been removed from the resulting binary, and more
    specifically, if the expression was not a constant, the compiler would have thrown
    an error stating that this code could not be compiled as stated.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，结果的二进制代码中已经移除了分支，更具体地说，如果表达式不是常量，编译器会抛出一个错误，说明这段代码无法按照所述进行编译。
- en: It should be noted that this result is not the same binary as previously as
    one might expect. It would appear that GCC 7.3 has some additional improvements
    to make in its optimization engine, as the `constexpr` `i` variable that was defined
    and initialized inside the binary was not removed (as stack space was allocated
    for `i` in this code when it didn't need to be).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到，这个结果并不是之前的相同二进制代码，可能会有人期望的那样。似乎GCC 7.3在其优化引擎中还有一些额外的改进，因为在这段代码中定义和初始化的`constexpr`
    `i`变量没有被移除（当代码中并不需要为`i`分配栈空间时）。
- en: 'Another compile-time change was a different version of the `static_assert`
    compile-time function. In C++11, the following was added:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个编译时的变化是`static_assert`编译时函数的不同版本。在C++11中，添加了以下内容：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The goal of the `static_assert` function is to ensure that certain compile-time
    assumptions are true. This is especially helpful when programming a system to
    do things such as making sure a structure is a specific size in bytes, or that
    a certain code path is taken, depending on the system you''re compiling for. The
    problem with this assert was that it required the addition of a description that
    would be output during compile time, which likely just describes the assertion
    in English without providing any additional information. In C++17, another version
    of this assert was added, which removed the need for the description, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_assert`函数的目标是确保某些编译时的假设是正确的。当编写系统时，这是特别有帮助的，比如确保一个结构体的大小是特定的字节数，或者根据你正在编译的系统来确保某个代码路径被执行。这个断言的问题在于它需要添加一个在编译时输出的描述，这个描述可能只是用英语描述了断言而没有提供任何额外的信息。在C++17中，添加了另一个版本的这个断言，它去掉了对描述的需求，如下所示：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Namespaces
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'A welcome change to C++17 is the addition of nested namespaces. Prior to C++17,
    nested namespaces had to be defined on different lines, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中一个受欢迎的变化是添加了嵌套命名空间。在C++17之前，嵌套命名空间必须在不同的行上定义，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, we define a message that is output to `stdout` in
    a nested namespace. The problem with this syntax is obvious—it takes up a lot
    of space. In C++17, this limitation was removed by giving us the ability to declare
    nested namespaces on the same line, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个在嵌套命名空间中输出到`stdout`的消息。这种语法的问题是显而易见的——它占用了大量的空间。在C++17中，通过在同一行上声明嵌套命名空间来消除了这个限制，如下所示：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we are able to define a nested namespace without the
    need for separate lines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够定义一个嵌套的命名空间，而不需要单独的行。
- en: Structured bindings
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化绑定
- en: 'My favorite addition to C++17 is something called **structured bindings**.
    Prior to C++17, complex structures, such as a struct or `std::pair`, could be
    used to return more than one value as the output of a function, but the syntax
    was cumbersome, for example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我对C++17的一个最喜欢的新增功能是**结构化绑定**。在C++17之前，复杂的结构，比如结构体或`std::pair`，可以用来作为函数输出的多个值，但语法很繁琐，例如：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the `give_me_a_pair()` function returns `std::pair`
    with a `The answer is:` string and an integer of `42`. The result of this function
    is stored in a variable named `p` in the `main` function, and `std::get()` is
    needed to get the first and second portion of `std::pair`. This code is both cumbersome
    and inefficient without aggressive optimizations, as additional function calls
    are needed to retrieve the results of `give_me_a_pair()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`give_me_a_pair()`函数返回一个带有`The answer is:`字符串和整数`42`的`std::pair`。这个函数的结果存储在`main`函数中的一个名为`p`的变量中，需要使用`std::get()`来获取`std::pair`的第一部分和第二部分。这段代码在没有进行积极的优化时既笨拙又低效，因为需要额外的函数调用来获取`give_me_a_pair()`的结果。
- en: 'In C++17, structured bindings provide us with a means to retrieve individual
    fields of a struct or `std::pair`, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，结构化绑定为我们提供了一种检索结构体或`std::pair`的各个字段的方法，如下所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the `give_me_a_pair()` function returns the same `std::pair`
    as before, but this time, we retrieve the results of `give_me_a_pair()` using
    structured bindings. The `msg` and `answer` variables are initialized to the results
    of `std::pair`, providing us with direct access to the results without the need
    for `std::get()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`give_me_a_pair()`函数返回与之前相同的`std::pair`，但这次我们使用了结构化绑定来获取`give_me_a_pair()`的结果。`msg`和`answer`变量被初始化为`std::pair`的结果，为我们提供了直接访问结果的方式，而不需要使用`std::get()`。
- en: 'The same is also possible with structures, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的也适用于结构体，如下所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we create a structure that is returned by `give_me_a_struct()`.
    The results of this function are acquired using structured bindings instead of
    `std::get()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个由`give_me_a_struct()`返回的结构。使用结构化绑定获取此函数的结果，而不是使用`std::get()`。
- en: Inline variables
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联变量
- en: A more controversial addition to C++17 is the inclusion of inline variables.
    As time progresses, more and more header-only libraries are being developed by
    various members of the C++ community. These libraries offer the ability to provide
    complex functionality to C++ without the need to install and link against the
    library (simply include the library and you're done). The issue with these types
    of libraries is that they have to play fancy tricks to include global variables
    in the library itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中更具争议的一个新增功能是内联变量的包含。随着时间的推移，越来越多的仅头文件库由C++社区的各个成员开发。这些库提供了在C++中提供复杂功能的能力，而无需安装和链接到库（只需包含库即可）。这些类型的库的问题在于它们必须在库本身中使用花哨的技巧来包含全局变量。
- en: 'Inline variables remove this issue, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内联变量解决了这个问题，如下所示：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, the `msg` variable is declared as `inline`. This
    type of variable can be defined in a header (that is, a `.h` file) and included
    several times without multiple definitions being defined during linking. It should
    be noted that inline variables also remove the need for the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`msg`变量被声明为`inline`。这种类型的变量可以在头文件（即`.h`文件）中定义，并且可以多次包含而不会在链接期间定义多个定义。值得注意的是，内联变量还消除了对以下内容的需求：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Often, a global variable is needed by multiple source files and the preceding
    pattern is used to expose the variable to all of these source files. The preceding
    code is added to a header file that is included by all of the source files and
    then one source file actually defines the variable, for example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多个源文件需要一个全局变量，并且使用前述模式将变量暴露给所有这些源文件。前面的代码添加到一个由所有源文件包含的头文件中，然后一个源文件实际上定义变量，例如：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although this works, this approach is cumbersome and it's not always clear which
    source file should actually define the variable. Using inline variables removes
    this issue, as the header both defines the variable and exposes the symbol to
    all of the source files that need it, removing the ambiguity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法有效，但它很麻烦，而且并不总是清楚哪个源文件实际上应该定义变量。使用内联变量可以解决这个问题，因为头文件既定义了变量，又将符号暴露给所有需要它的源文件，消除了歧义。
- en: Changes in the library
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的更改
- en: In addition to changes to the language's syntax, some library changes were also
    made. The following are some of the notable changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对语言语法的更改，还对库进行了一些更改。以下是一些显著的更改。
- en: String View
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串视图
- en: As will be discussed in the *GSL* section of this chapter, there is a push within
    the C++ community to remove direct access to both pointers and arrays. Most segfaults
    and vulnerabilities discovered in applications can be attributed to the mishandling
    of pointers and arrays. As programs become more and more complex, and modified
    by multiple people without a complete picture of the application and how it uses
    each and every pointer and/or array, the likelihood of an error being introduced
    increases.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章的*GSL*部分将讨论的那样，C++社区内部正在推动消除对指针和数组的直接访问。在应用程序中发现的大多数段错误和漏洞都可以归因于对指针和数组的处理不当。随着程序变得越来越复杂，并由多人修改而没有完整了解应用程序及其如何使用每个指针和/或数组的情况，引入错误的可能性也会增加。
- en: To address this, the C++ community has adopted the C++ Core Guidelines: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++社区已经采纳了C++核心指南：[https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)。
- en: The goal of the C++ Core Guidelines is to define a set of best practices that
    help to prevent common mistakes that are made when programming with C++, to limit
    the total number of errors that are introduced into a program. C++ has been around
    for years and, although it has a lot of facilities to prevent mistakes, it still
    maintains backward-compatibility, allowing old programs to coexist with new ones.
    The C++ Core Guidelines helps new and expert users navigate the many features
    that are available to help create safer and more robust applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南的目标是定义一组最佳实践，以帮助防止在使用C++编程时出现的常见错误，以限制引入程序的总错误数量。 C++已经存在多年了，尽管它有很多设施来防止错误，但它仍然保持向后兼容性，允许旧程序与新程序共存。
    C++核心指南帮助新用户和专家用户浏览可用的许多功能，以帮助创建更安全和更健壮的应用程序。
- en: 'One of the features that was added to C++17 in support of this effort is the
    `std::string_view{}` class. `std::string_view` is a wrapper around a character
    array, similar to `std::array`, that helps to make working with basic C strings
    safer and easier, for example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中为支持这一努力添加的一个功能是`std::string_view{}`类。`std::string_view`是字符数组的包装器，类似于`std::array`，有助于使使用基本C字符串更安全和更容易，例如：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding example, we create `std::string_view{}` and initialize it
    to an ASCII C string. We then output the string to `stdout` using `std::cout`.
    Like `std::array`, `std::string_view{}` provides accessors to the underlying array,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了`std::string_view{}`并将其初始化为ASCII C字符串。然后使用`std::cout`将字符串输出到`stdout`。与`std::array`一样，`std::string_view{}`提供了对基础数组的访问器，如下所示：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, the `front()` and `back()` functions can be used to
    get the first and last character in the string, while the `at()` function can
    be used to get any character in the string; if the index is out of range (that
    is, the index provided to `at()` is longer than the string itself), an `std::out_of_range{}`
    exception is thrown. Finally, the `data()` function can be used to get direct
    access to the underlying array. Although, this function should be used with care,
    as its use negates the safety benefits of `std::string_view{}`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`front()`和`back()`函数可用于获取字符串中的第一个和最后一个字符，而`at()`函数可用于获取字符串中的任何字符；如果索引超出范围（即，提供给`at()`的索引比字符串本身还长），则会抛出`std::out_of_range{}`异常。最后，`data()`函数可用于直接访问底层数组。不过，应谨慎使用此函数，因为其使用会抵消`std::string_view{}`的安全性好处。
- en: 'In addition to the accessors, the `std::string_view{}` class provides information
    about the size of the string:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问器之外，`std::string_view{}`类还提供了有关字符串大小的信息：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, the `size()` function returns the total number of
    characters in the string, while the `empty()` function returns `true` if `size()
    == 0` and `false` otherwise. `The max_size()` function defines the maximum size
    `std::string_view{}` can hold, which in most cases is unattainable or realistic.
    In the preceding example, the maximum string size is more than a million terabytes
    in size.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`size()`函数返回字符串中的字符总数，而`empty()`函数在`size() == 0`时返回`true`，否则返回`false`。`max_size()`函数定义了`std::string_view{}`可以容纳的最大大小，在大多数情况下是无法实现或现实的。在上面的例子中，最大字符串大小超过一百万兆字节。
- en: 'Unlike a `std::array`, the `std::string_view{}` provides the ability to reduce
    the size of the view of the string by removing characters from the front or back
    of the string, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::array`不同，`std::string_view{}`提供了通过从字符串的前面或后面删除字符来减小字符串视图的能力，如下所示：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the `remove_prefix()` and `remove_suffix()` functions
    are used to remove one character from both the front and back of the string, resulting
    in `ello Worl` being outputted to `stdout`. It should be noted that this simply
    changes the starting character and repositions the ending null character pointer
    without having to reallocate memory. For more advanced functionality, `std::string{}`
    should be used, but it comes with the resulting performance hits of additional
    memory allocations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`remove_prefix()`和`remove_suffix()`函数用于从字符串的前面和后面各删除一个字符，结果是将`ello Worl`输出到`stdout`。需要注意的是，这只是改变了起始字符并重新定位了结束的空字符指针，而无需重新分配内存。对于更高级的功能，应该使用`std::string{}`，但这会带来额外的内存分配性能损失。
- en: 'It is also possible to access substrings, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以按如下方式访问子字符串：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we access the `Hello` substring using the `substr()`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用`substr()`函数访问`Hello`子字符串。
- en: 'It is also possible to compare strings:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以比较字符串：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Like the `strcmp()` function, the compare function returns `0` when the two
    strings are compared, and a difference when they do not.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与`strcmp()`函数类似，比较函数在比较两个字符串时返回`0`，而它们不同时返回差异。
- en: 'Finally, search functions are provided as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，搜索函数如下所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The results of this example are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的结果如下：
- en: The `find()` function returns the location in the string of the first occurrence
    of `Hello` which in this case is `0`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()`函数返回字符串中第一次出现`Hello`的位置，这种情况下是`0`。'
- en: '`rfind()` returns the location of the last occurrence of the provided string,
    which, in this case, is `24`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rfind()`返回提供的字符串的最后出现位置，在这种情况下是`24`。'
- en: '`find_first_of()` and `find_last_of()` find the first and last occurrence of
    any of the characters provided (not the string as a whole). In this case, `H` is
    in the provided string, and `H` is the first character in `msg`, which means `find_first_of()`
    returns `0` since the `0` is the first index in the string.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_first_of()`和`find_last_of()`找到提供的任何字符的第一个和最后一个出现位置（而不是整个字符串）。在这种情况下，`H`在提供的字符串中，而`H`是`msg`中的第一个字符，这意味着`find_first_of()`返回`0`，因为`0`是字符串中的第一个索引。'
- en: In the case of `find_last_of()`, `l` is the last-occurring letter, at position
    `33`.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`find_last_of()`中，`l`是最后出现的字母，位置在`33`。
- en: '`find_first_not_of()` and `find_last_not_of()` are the opposite of `find_first_of()`
    and `find_last_of()`, returning the first and last occurrence of any character
    not in the provided string.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_first_not_of()`和`find_last_not_of()`是`find_first_of()`和`find_last_of()`的相反，返回提供的字符串中任何字符的第一个和最后一个出现位置。'
- en: std::any, std::variant, and std::optional
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::any，std::variant和std::optional
- en: 'Other welcome additions to C++17 are the `std::any{}`, `std::variant{}`, and
    `std::optional{}` classes. `std::any{}` is capable of storing any value at any
    time. Special accessors are needed to retrieve the data in `std::any{}`, but they
    are capable of holding any value in a type-safe manner. To accomplish this, `std::any{}`
    leverages an internal pointer, and memory must be allocated each time the type
    is changed, for example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中的其他受欢迎的新增功能是`std::any{}`，`std::variant{}`和`std::optional{}`类。`std::any{}`能够随时存储任何值。需要特殊的访问器来检索`std::any{}`中的数据，但它们能够以类型安全的方式保存任何值。为了实现这一点，`std::any{}`利用了内部指针，并且每次更改类型时都必须分配内存，例如：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, we create `std::any{}` and set it to an `int` with
    the value of `42`, a double with the value of `4.2`, and a struct with the value
    of `42`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了`std::any{}`并将其设置为具有值`42`的`int`，具有值`4.2`的`double`，以及具有值`42`的`struct`。
- en: '`std::variant` is more like a type-safe union. A union reserves storage space
    for all of the types that are stored within the union at compile time (so no allocations
    is needed, but all of the possible types must be known at compile time). The problem
    with a standard C union is that there is no way to know what type is stored at
    any given time. Storing both an int and a `double` at the same time is problematic,
    since using both simultaneously will lead to corruption. With `std::variant`,
    this type of issue can be avoided, as `std::variant` is aware of what type it
    is currently storing, and attempting to access the data as a different type is
    not allowed (hence, `std::variant` is type-safe), for example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::variant`更像是一个类型安全的联合。联合在编译时为联合中存储的所有类型保留存储空间（因此不需要分配，但是所有可能的类型必须在编译时已知）。标准C联合的问题在于无法知道任何给定时间存储的是什么类型。同时存储int和`double`是有问题的，因为同时使用两者会导致损坏。使用`std::variant`可以避免这种问题，因为`std::variant`知道它当前存储的是什么类型，并且不允许尝试以不同类型访问数据（因此，`std::variant`是类型安全的），例如：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, `std::variant` is used to store both an `integer`
    and a `double`, and we can safely retrieve the data in `std::variant` without
    corruption.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`std::variant`被用来存储`integer`和`double`，我们可以安全地从`std::variant`中检索数据而不会损坏。
- en: '`std::optional` is a nullable value type. A pointer is a nullable reference
    type in which the pointer is either invalid or is valid and stores a value. To
    make a pointer value, memory must be allocated (or at least pointed to). `std::optional`
    is a value type, meaning the memory for `std::optional` doesn''t have to be allocated,
    and under the hood, construction is only performed when the optional is valid,
    removing the overhead of constructing a default value type when it is not actually
    set. For complex objects, this not only provides the ability to determine whether
    an object is valid, it allows us to skip construction in the invalid case, which
    increases performance, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::optional`是一个可空的值类型。指针是一个可空的引用类型，其中指针要么无效，要么有效并存储一个值。要创建一个指针值，必须分配内存（或者至少指向内存）。`std::optional`是一个值类型，这意味着不需要为`std::optional`分配内存，并且在底层，只有在可选项有效时才执行构造，消除了在实际未设置时构造默认值类型的开销。对于复杂对象，这不仅提供了确定对象是否有效的能力，还允许我们在无效情况下跳过构造，从而提高性能，例如：'
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, we create a simple class that stores an `integer`.
    In this class, we output a string to stdout when the class is constructed. We
    then create an instance of this class using `std::optional`. We attempt to access
    this `std::optional` before and after we actually set the class to a valid value.
    As shown, the class is not constructed until we actually set the class to a valid
    value. Since `sts::unique_ptr` used to be the common method for creating optionals,
    it should be no surprise that `std::optional` shares a common interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的类，用于存储一个`integer`。在这个类中，当类被构造时，我们向stdout输出一个字符串。然后我们使用`std::optional`创建了这个类的一个实例。我们尝试在实际设置类为有效值之前和之后访问这个`std::optional`。如所示，只有在我们实际设置类为有效值之后，类才被构造。由于`sts::unique_ptr`曾经是创建optionals的常用方法，因此`std::optional`共享一个常用的接口并不奇怪。
- en: Resource Acquisition Is Initialization (RAII)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源获取即初始化（RAII）
- en: RAII is arguably one of the more notable differences between C and C++. RAII
    sets the foundation and design patterns for the entire C++ library, and has been
    the inspiration for countless other languages. This simple concept provides C++
    with an unmatched level of safety when compared to C, and this concept will be
    leveraged throughout this book when C and POSIX must be used in place of C++ (for
    example, when a C++ alternative either doesn't exist or is incomplete).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RAII可以说是C和C++之间最显著的区别之一。RAII为整个C++库奠定了基础和设计模式，并且已经成为无数其他语言的灵感之源。这个简单的概念为C++提供了无与伦比的安全性，与C相比，这个概念将在本书中被充分利用，当C和POSIX必须用于替代C++时（例如，当C++的替代方案要么不存在，要么不完整时）。
- en: 'The idea behind RAII is simple. If a resource is allocated, it is allocated
    during the construction of an object, and when the object is destroyed, the resource
    is released. To accomplish this, RAII leverages the construction and destruction
    features of C++, for example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: RAII的理念很简单。如果分配了资源，它是在对象构造期间分配的，当对象被销毁时，资源被释放。为了实现这一点，RAII利用了C++的构造和销毁特性，例如：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we create a class that, on construction and destruction,
    outputs to `stdout`. As shown, when the class is instantiated, the class is constructed,
    and when the class loses focus, the class is destroyed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个在构造和销毁时向`stdout`输出的类。如所示，当类被实例化时，类被构造，当类失去焦点时，类被销毁。
- en: 'This simple concept can be leveraged to guard a resource, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的概念可以用来保护资源，如下所示：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, a pointer is allocated when `myclass{}` is constructed,
    and freed when `myclass{}` is destroyed. This pattern provides many advantages:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当`myclass{}`被构造时，分配了一个指针，并且当`myclass{}`被销毁时，指针被释放。这种模式提供了许多优势：
- en: So long as the instance of `myclass{}` is visible (that is, can be accessed),
    the pointer is valid. So, any attempt to access the memory in the class is guaranteed
    to be safe as the deallocation of the memory only occurs when the scope of the
    class is lost, which would result in an inability to access the class (assuming
    pointers and references to the class are not used).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要`myclass{}`的实例可见（即可访问），指针就是有效的。因此，任何尝试访问类中的内存都是安全的，因为只有在类的范围丢失时才会释放内存，这将导致无法访问类（假设没有使用指向类的指针和引用）。
- en: No leaking of memory can occur. If the class is visible, the memory that the
    class allocated will be valid. Once the class is no longer visible (that is, loses
    scope), the memory is freed and no leak occurs.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会发生内存泄漏。如果类可见，类分配的内存将是有效的。一旦类不再可见（即失去范围），内存就会被释放，不会发生泄漏。
- en: Specifically, RAII ensures that the acquisition of a resource occurs at the
    initialization of the object, and the release of the resources occurs when the
    object is no longer needed. As will be shown later on in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*, `std::unique_ptr[]` and `std::shared_ptr{}`
    leverage this exact design pattern (although, these classes go above and beyond
    the preceding example to enforce ownership in addition to acquisition).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，RAII确保在对象初始化时获取资源，并在不再需要对象时释放资源。正如稍后将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中展示的那样，`std::unique_ptr[]`和`std::shared_ptr{}`利用了这种精确的设计模式（尽管，这些类不仅仅是上面的例子，还要求在获取资源的同时确保所有权）。
- en: 'RAII does not just apply to pointers; it can be used for any resource that
    must be acquired and then released, for example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: RAII不仅适用于指针；它可以用于必须获取然后释放的任何资源，例如：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, we create a class that opens a file and stores its
    handle on construction, and then closes the file on destruction and releases the
    handle. In the main function, we create an instance of the class that is both
    constructed and destructed as normal, leveraging RAII to prevent the file from
    leaking.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个在构造时打开文件并存储其句柄，然后在销毁时关闭文件并释放句柄的类。在主函数中，我们创建了一个类的实例，它既被构造又被正常销毁，利用RAII来防止文件泄漏。
- en: In addition to the normal case, we create a second class, which attempts to
    open a file that doesn't exist. In this case, an exception is thrown. The important
    thing to note here is the destructor is not called for this second instance. The
    is because the construction failed and threw an exception. As a result, no resource
    was acquired, thus, no destruction is required. That is, the acquisition of the
    resource is directly tied to the initialization of the class itself, and a failure
    to construct the class safely prevents the destruction of a resource that was
    never allocated in the first place.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常情况外，我们创建了第二个类，试图打开一个不存在的文件。在这种情况下，会抛出异常。这里需要注意的重要一点是，对于这个第二个实例，析构函数不会被调用。这是因为构造失败并抛出了异常。因此，没有获取资源，因此也不需要销毁。也就是说，资源的获取直接与类本身的初始化相关联，而安全地构造类可以防止销毁从未分配的资源。
- en: RAII is a simple yet powerful feature of C++ that is leveraged extensively in
    C++, and this design pattern will be expanded upon in this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是C++的一个简单而强大的特性，在C++中被广泛利用，这种设计模式将在本书中进行扩展。
- en: The Guideline Support Library (GSL)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导支持库（GSL）
- en: 'As stated before, the goal of the C++ Core Guidelines is to provide a set of
    best practices associated with programming C++. The GSL is a library designed
    to assist in maintaining compliance with these guidelines. In general, there are
    some overall themes associated with the GSL:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，C++核心指南的目标是提供与C++编程相关的最佳实践。GSL是一个旨在帮助遵守这些指南的库。总的来说，GSL有一些整体主题：
- en: '**Pointer ownership**: Defining who owns a pointer is a simple way to prevent
    memory leaks and pointer corruption. In general, the best way to define ownership
    is through the use of `std::unique_ptr{}` and  `std::shared_ptr{}`, which will
    be explained in depth in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*, but in some cases, these cannot be
    used and the GSL helps to deal with these edge cases.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指针所有权**：定义谁拥有指针是防止内存泄漏和指针损坏的简单方法。一般来说，定义所有权的最佳方法是通过使用`std::unique_ptr{}`和`std::shared_ptr{}`，这将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中深入解释，但在某些情况下，这些不能使用，GSL有助于处理这些边缘情况。'
- en: '**Expectation management**: The GSL also helps to define what a function should
    expect for input and what it ensures for output, with the goal being to transition
    these concepts to C++ contracts.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**期望管理**：GSL还有助于定义函数对输入的期望和对输出的保证，目标是将这些概念转换为C++合同。'
- en: '**No pointer arithmetic**: Pointer arithmetic is one of the leading causes
    of program instability and vulnerabilities. Removing pointer arithmetic (or at
    least confining pointer arithmetic to well-tested support libraries) is a simple
    way to remove these types of issues.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有指针算术**：指针算术是程序不稳定和易受攻击的主要原因之一。消除指针算术（或者至少将指针算术限制在经过充分测试的支持库中）是消除这些问题的简单方法。'
- en: Pointer ownership
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针所有权
- en: 'Classical C++ doesn''t distinguish between who owns a pointer (that is, the
    code or object responsible for releasing the memory associated with a pointer)
    and who is simply accessing memory using a pointer, for example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的C++不区分谁拥有指针（即负责释放与指针关联的内存的代码或对象）和谁只是使用指针访问内存，例如：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we allocate a pointer to an integer, and then pass
    that pointer to a function called `init()`, which initializes the pointer. Finally,
    we delete the pointer after it has been used by the `init()` function. If the
    `init()` function were located in another file, it would not be clear whether
    the `init()` function should delete the pointer. Although in this simple example
    it might be obvious that this is not the case, in complicated projects with lots
    of code, this intent can be lost. Future modifications to such code can result
    in improper use of pointers whose ownership is not well-defined.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们分配了一个指向整数的指针，然后将该指针传递给一个名为`init()`的函数，该函数初始化指针。最后，在`init()`函数使用完指针后，我们删除了指针。如果`init()`函数位于另一个文件中，就不清楚`init()`函数是否应该删除指针。尽管在这个简单的例子中，这可能是显而易见的，但在有大量代码的复杂项目中，这种意图可能会丢失。对这样的代码进行未来修改可能会导致使用未定义所有权的指针。
- en: 'To overcome this, the GSL provides a `gsl::owner<>{}` decoration that is used
    to document whether a given variable is an owner of the pointer, for example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，GSL提供了一个`gsl::owner<>`修饰，用于记录给定变量是否是指针的所有者，例如：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we document that `p` in the `main` function is the
    owner of the pointer, meaning once `p` is no longer needed, the pointer should
    be released. Another issue with the preceding example is that the `init()` function
    expects the pointer to not be null. If the pointer were null, a null dereference
    would occur.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们记录了`main`函数中的`p`是指针的所有者，这意味着一旦`p`不再需要，指针应该被释放。前面例子中的另一个问题是`init()`函数期望指针不为空。如果指针为空，将发生空指针解引用。
- en: 'There are two common methods for overcoming the possibility of a null dereference.
    The first choice would be to check for a `nullptr` and throw an exception. The
    problem with this approach is you would have to perform this null pointer check
    on every function. These types of checks are costly and clutter code. The other
    option is to use a `gsl::not_null<>{}` class. Like `gsl::owner<>{}`, `gsl::not_null<>{}`
    is a decoration that can be compiled out of the code when debugging is not used.
    However, if debugging is enabled, `gsl::not_null<>{}` will throw an exception,
    `abort()`, or in some cases, refuse to compile if the variable is set to null.
    Using `gsl::not_null<>{}`, it is possible for a function to state explicitly whether
    or not null pointers are allowed and safely handled, for example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常见的方法可以克服空指针解引用的可能性。第一种选择是检查`nullptr`并抛出异常。这种方法的问题在于你必须在每个函数上执行这个空指针检查。这些类型的检查成本高，而且会使代码混乱。另一个选择是使用`gsl::not_null<>{}`类。像`gsl::owner<>{}`一样，`gsl::not_null<>{}`是一个装饰，可以在不使用调试时从代码中编译出来。然而，如果启用了调试，`gsl::not_null<>{}`将抛出异常，`abort()`，或者在某些情况下，如果变量设置为null，拒绝编译。使用`gsl::not_null<>{}`，函数可以明确说明是否允许和安全处理空指针，例如：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding example, we create a pointer using `std::unique_ptr{}`, and
    then pass the resulting pointer to a function called `test()`. The `test()` function
    does not support a null pointer, and therefore states this using `gsl::not_null<>{}`.
    In turn, the `test()` function returns `gsl::not_null<>{}`, telling the user that
    the `test()` function ensures that the result of the function is not null (which
    is why the `test` function doesn't support a null pointer in the first place).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`std::unique_ptr{}`创建了一个指针，然后将得到的指针传递给一个名为`test()`的函数。`test()`函数不支持空指针，因此使用`gsl::not_null<>{}`来表示这一点。反过来，`test()`函数返回`gsl::not_null<>{}`，告诉用户`test()`函数确保函数的结果不为空（这也是为什么`test`函数一开始不支持空指针的原因）。
- en: Pointer arithmetic
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针算术
- en: '**Pointer arithmetic** is a common source of bugs that lead to instability
    and vulnerabilities. For this reason, the C++ Core Guidelines discourages the
    use of this type of arithmetic. Here are some examples of pointer arithmetic:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针算术**是导致不稳定和易受攻击的常见错误源。因此，C++核心指南不鼓励使用这种类型的算术。以下是一些指针算术的例子：'
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last example is likely the most surprising. The subscript operator is,
    in fact, pointer arithmetic, and its use can lead to out-of-range bugs. To overcome
    this, the GSL provides the `gsl::span{}` class, which gives us a safe interface
    for working with pointers, including arrays, for example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子可能是最令人惊讶的。下标运算符实际上是指针算术，其使用可能导致越界错误。为了克服这一点，GSL提供了`gsl::span{}`类，为我们提供了一个安全的接口，用于处理指针，包括数组，例如：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see how the preceding example works:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的例子是如何工作的：
- en: We create an array and initialize it with a set of integers.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个数组，并用一组整数初始化它。
- en: We create a span into that array so that we can interact with the array safely.
    We output the array to `stdout` using a range-based `for` loop (as a span includes
    an iterator interface).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个span，以便可以安全地与数组交互。我们使用基于范围的`for`循环（因为span包括一个迭代器接口）将数组输出到`stdout`。
- en: We output the array a second time to `stdout`, using a traditional index and
    subscript operator (that is, the `[]` operator). The difference with this subscript
    operator is each array access is checked for out-of-range errors. To demonstrate
    this, we attempt to access the array out of bounds and `gsl::span{}` throws a
    `gsl::fail_fast{}` exception. It should be noted that `GSL_THROW_ON_CONTRACT_VIOLATION`
    is used to tell the GSL to throw exceptions, instead of executing `std::terminate`
    or ignoring the bounds checks completely.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用传统的索引和下标运算符（即`[]`运算符）将数组第二次输出到`stdout`。这个下标运算符的不同之处在于每个数组访问都会检查是否越界。为了证明这一点，我们尝试访问数组越界，`gsl::span{}`抛出了一个`gsl::fail_fast{}`异常。应该注意的是，`GSL_THROW_ON_CONTRACT_VIOLATION`用于告诉GSL抛出异常，而不是执行`std::terminate`或完全忽略边界检查。
- en: 'In addition to `gsl::span{}`, the GSL also contains specializations of `gsl::span{}`,
    which help us when working with common types of arrays. For example, the GSL provides
    `gsl::cstring_span{}`, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`gsl::span{}`之外，GSL还包含`gsl::span{}`的特殊化，这些特殊化在处理常见类型的数组时对我们有所帮助。例如，GSL提供了`gsl::cstring_span{}`，如下所示：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`gsl::cstring_span{}` is a `gsl::span{}` that contains a standard C-style string.
    In the preceding example, we load `gsl::cstring_span{}` with a standard C-style
    string, using the `gsl::ensure_z()` function to ensure the string ends in a null
    character before continuing. We then output the standard C-style string using
    a regular `std::cout call`, and also by using a range-based loop.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`gsl::cstring_span{}`是一个包含标准C风格字符串的`gsl::span{}`。在前面的例子中，我们使用`gsl::ensure_z()`函数将`gsl::cstring_span{}`加载到标准C风格字符串中，以确保字符串在继续之前以空字符结尾。然后我们使用常规的`std::cout`调用和使用基于范围的循环输出标准C风格字符串。'
- en: Contracts
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合同
- en: C++ contracts provide the user with a means to state what a function expects
    as input, and what that function ensures as output. Specifically, a C++ contract
    documents a contract between the author of an API and the user of the API, it
    also provides compile-time and runtime validation of that contract.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C++合同为用户提供了一种说明函数期望的输入以及函数确保的输出的方法。具体来说，C++合同记录了API的作者和API的用户之间的合同，并提供了对该合同的编译时和运行时验证。
- en: 'Future versions of C++ will have built-in support for contracts, but until
    then, the GSL provides a library-based implementation of C++ contracts by providing
    the `expects()` and `ensures()` macros, for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的C++版本将内置支持合同，但在此之前，GSL通过提供`expects()`和`ensures()`宏的库实现了C++合同，例如：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, we use the `Expects()` macro and pass it as `false`.
    Like the `assert()` function that is provided by the standard C library, the `Expects()`
    macro fails on `false`. Unlike `assert()`, `Expects()` will execute `std::terminate()`
    even when debugging is disabled, if the expression passed to `Expects()` evaluates
    to `false`. In the preceding example, we state that `Expects()` should throw a
    `gsl::fail_fast{}` exception instead of executing `std::terminate()`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`Expects()`宏并将其传递为`false`。与标准C库提供的`assert()`函数不同，`Expects()`宏在`false`时失败。与`assert()`不同，即使在禁用调试时，如果传递给`Expects()`的表达式求值为`false`，`Expects()`也将执行`std::terminate()`。在前面的例子中，我们声明`Expects()`应该抛出`gsl::fail_fast{}`异常，而不是执行`std::terminate()`。
- en: 'The `Ensures()` macro is the same as `Expects()`, with the only difference
    being the name, which is meant to document the contract''s output instead of its
    input, for example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ensures()`宏与`Expects()`相同，唯一的区别是名称，用于记录合同的输出而不是输入，例如：'
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding example, we create a function that expects the input to be
    greater than or equal to `0` and less than `41`. The function then operates on
    the input and ensures the resulting output is always less than `42`. A properly-written
    function will define its expectations such that the `Ensures()` macros will never
    trigger. Instead, the `Expects()` checks will likely trigger instead, if the input
    would lead to an output that violates the contract.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个函数，该函数期望输入大于或等于`0`且小于`41`。然后函数对输入进行操作，并确保结果输出始终小于`42`。一个正确编写的函数将定义其期望，以便`Ensures()`宏永远不会触发。相反，如果输入导致输出违反合同，则`Expects()`检查可能会触发。
- en: Utilities
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实用程序
- en: 'The GSL also provides some helper utilities that are useful in creating a more
    reliable and readable code. One example of these utilities is the `gsl::finally{}`
    API, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: GSL还提供了一些有用的辅助工具，有助于创建更可靠和可读的代码。其中一个例子是`gsl::finally{}`API，如下：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`gsl::finally{}` provides a simple means to execute code just prior to a function
    exiting, by leveraging a C++ destructor. This is helpful when a function has to
    perform cleanup before exiting. It should be noted that `gsl::finally{}` is most
    useful in the presence of exceptions. Often, cleanup code is forgotten when an
    exception is fired, preventing the cleanup logic from ever executing. The `gsl::finally{}`
    API will always execute, even if an exception is fired, so long as it is defined
    just prior to performing an action that might generate an exception.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`gsl::finally{}`提供了一种简单的方法，在函数退出之前执行代码，利用C++析构函数。当函数必须在退出之前执行清理时，这是有帮助的。应该注意，`gsl::finally{}`在存在异常时最有用。通常，当触发异常时，清理代码被遗忘，导致清理逻辑永远不会执行。`gsl::finally{}`
    API将始终执行，即使发生异常，只要它在执行可能生成异常的操作之前定义。'
- en: In the preceding code, we also include a useful macro that allows the use of
    `___` to define the name of the `gsl::finally{}` to use. Specifically, the user
    of `gsl::finally{}` must store an instance of the `gsl::finally{}` object so that
    the object can be destroyed on exiting the function, but having to name the `gsl::finally{}`
    object is cumbersome and pointless, as there are no APIs to interact with the
    `gsl::finally{}` object (its only purpose is to execute on `exit`). This macro
    provides a simple way of saying, *I don't care what the variable's name is*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们还包括了一个有用的宏，允许使用`___`来定义要使用的`gsl::finally{}`的名称。具体来说，`gsl::finally{}`的用户必须存储`gsl::finally{}`对象的实例，以便在退出函数时销毁该对象，但是必须命名`gsl::finally{}`对象是繁琐且无意义的，因为没有API与`gsl::finally{}`对象交互（它的唯一目的是在`exit`时执行）。这个宏提供了一种简单的方式来表达，“我不在乎变量的名称是什么”。
- en: 'Other utility that the GSL provides are `gsl::narrow<>()` and `gsl::narrow_cast<>()`,
    for example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: GSL提供的其他实用程序包括`gsl::narrow<>()`和`gsl::narrow_cast<>()`，例如：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Both of these APIs are the same as a regular `static_cast<>()`, with the only
    difference being that `gsl::narrow<>()` performs an overflow check while `gsl::narrow_cast<>()`
    is just a synonym for `static_cast<>()`, which documents that a narrowing of an
    integer is taking place (that is, converting an integer with a larger number of
    bits into an integer with fewer bits), for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个API与常规的`static_cast<>()`相同，唯一的区别是`gsl::narrow<>()`执行溢出检查，而`gsl::narrow_cast<>()`只是`static_cast<>()`的同义词，用于记录整数的缩小（即将具有更多位的整数转换为具有较少位的整数）。
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding example, we attempt to convert a 64-bit integer into a 32-bit
    integer using the `gsl::narrow<>()` function, which performs an overflow check.
    Since an overflow does occur, an exception is thrown.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试使用`gsl::narrow<>()`函数将64位整数转换为32位整数，该函数执行溢出检查。由于发生了溢出，抛出了异常。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we provided an overview of some of the recent advancements
    in C++ that are leveraged in this book. We started with an overview of the changes
    made to C++ in the C++17 specification. We then briefly covered a C++ design pattern
    called RAII, and how it is used by C++. Finally, we introduced the GSL and how
    it can help to increase the reliability and stability of system programming by
    helping to adhere to the C++ Core Guidelines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了本书中使用的C++的一些最新进展。我们从C++17规范中对C++所做的更改开始。然后我们简要介绍了一个称为RAII的C++设计模式，以及它如何被C++使用。最后，我们介绍了GSL以及它如何通过帮助遵守C++核心指南来增加系统编程的可靠性和稳定性。
- en: In the next chapter, we will go over UNIX-specific topics such as UNIX processes
    and signals, and a comprehensive overview of the System V specification, which
    is used to define how programs are written for UNIX on Intel CPUs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍UNIX特定的主题，如UNIX进程和信号，以及System V规范的全面概述，该规范用于定义如何在Intel CPU上为UNIX编写程序。
- en: Questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are structured bindings?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是结构化绑定？
- en: What changes did C++17 make to nested namespaces?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++17对嵌套命名空间做了哪些改变？
- en: What changes did C++17 make to the `static_assert()` function?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++17对`static_assert()`函数做了哪些改变？
- en: What is an `if` statement initializer?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`if`语句的初始化器？
- en: What does RAII stand for?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII代表什么？
- en: What is RAII used for?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII用于什么？
- en: What does `gsl::owner<>{}` do?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gsl::owner<>{}`有什么作用？'
- en: What is the purpose of `Expects()` and `Ensures()`?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Expects()`和`Ensures()`的目的是什么？'
- en: Further Reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
