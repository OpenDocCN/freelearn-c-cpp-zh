["```cpp\n    #ifndef SRC_SUMFUNC_H_\n    #define SRC_SUMFUNC_H_\n    int sum(int a, int b);\n    #endif /* SRC_SUMFUNC_H_ */\n    ```", "```cpp\n    #include \"SumFunc.h\"\n    #include <iostream>\n    int sum(int a, int b) {\n    \u00a0\u00a0return a + b;\n    }\n    ```", "```cpp\n    add_executable(CxxTemplate\n    \u00a0\u00a0src/CxxTemplate.cpp\u00a0\u00a0\n    \u00a0\u00a0src/ANewClass.cpp\n    \u00a0\u00a0src/SumFunc.cpp\n    )\n    ```", "```cpp\n    #include \"CxxTemplate.h\"\n    #include \"ANewClass.h\"\n    #include \"SumFunc.h\" //add this line\n    ...\n    CxxApplication::CxxApplication( int argc, char *argv[] ) {\n    \u00a0\u00a0std::cout << \"Hello CMake.\" << std::endl;\n    \u00a0\u00a0ANewClass anew;\n    \u00a0\u00a0anew.run();\n    \u00a0\u00a0std::cout << sum(3, 4) << std::endl; // add this line\n    }\n    ```", "```cpp\n    #ifndef SRC_LINEARMOTION1D_H_\n    #define SRC_LINEARMOTION1D_H_\n    class LinearMotion1D {\n    public:\n    \u00a0\u00a0double position;\n    \u00a0\u00a0double velocity;\n    \u00a0\u00a0void advanceTimeBy(double dt);\n    \u00a0\u00a0LinearMotion1D();\n    \u00a0\u00a0virtual ~LinearMotion1D();\n    };\n    #endif /* SRC_LINEARMOTION1D_H_ */\n    ```", "```cpp\n    #include \"LinearMotion1D.h\"\n    void LinearMotion1D::advanceTimeBy(double dt) {\n    \u00a0\u00a0position += velocity * dt;\n    }\n    LinearMotion1D::LinearMotion1D() {\n    \u00a0\u00a0position = 0;\n    \u00a0\u00a0velocity = 0;\n    }\n    LinearMotion1D::~LinearMotion1D() {\n    }\n    ```", "```cpp\n    #include \"gtest/gtest.h\"\n    #include \"../src/LinearMotion1D.h\"\n    namespace {\n    class LinearMotion1DTest: public ::testing::Test {};\n    TEST_F(LinearMotion1DTest, CanMoveRight) {\n    \u00a0\u00a0LinearMotion1D l;\n    \u00a0\u00a0l.position = 10;\n    \u00a0\u00a0l.velocity = 2;\n    \u00a0\u00a0l.advanceTimeBy(3);\n    \u00a0\u00a0EXPECT_DOUBLE_EQ(16, l.position);\n    }\n    TEST_F(LinearMotion1DTest, CanMoveLeft) {\n    \u00a0\u00a0LinearMotion1D l;\n    \u00a0\u00a0l.position = 10;\n    \u00a0\u00a0l.velocity = -2;\n    \u00a0\u00a0l.advanceTimeBy(3);\n    \u00a0\u00a0EXPECT_DOUBLE_EQ(4, l.position);\n    }\n    }\n    ```", "```cpp\n    add_executable(CxxTemplate\n    \u00a0\u00a0src/CxxTemplate.cpp\u00a0\u00a0\n    \u00a0\u00a0src/ANewClass.cpp\n    \u00a0\u00a0src/SumFunc.cpp\n    \u00a0\u00a0src/LinearMotion1D.cpp # added\n    )\n    ```", "```cpp\n    add_executable(tests \n    \u00a0\u00a0CanTest.cpp \n    \u00a0\u00a0SumFuncTest.cpp \n    \u00a0\u00a0../src/SumFunc.cpp\n    \u00a0\u00a0LinearMotion1DTest.cpp # added\n    \u00a0\u00a0../src/LinearMotion1D.cpp # added\n    )\n    ```", "```cpp\n    \u00a0\u00a0src/LinearMotion1D.cpp\n    \u00a0\u00a0src/SpeedCalculator.cpp # add this line\n    )\n    ```", "```cpp\n    #include \"SpeedCalculator.h\"\n    int main( int argc, char *argv[] ) {\n    \u00a0\u00a0cxxt::CxxApplication app( argc, argv );\n    \u00a0\u00a0// add these three lines\n    \u00a0\u00a0SpeedCalculator speedCalculator;\n    \u00a0\u00a0speedCalculator.initializeData(10);\n    \u00a0\u00a0speedCalculator.calculateAndPrintSpeedData();\n    \u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    for (int i = 0; i < numEntries; ++i) {\n    \u00a0\u00a0double dt = timesInSeconds[i + 1] - timesInSeconds[i];\n    \u00a0\u00a0assert(dt > 0);\n    \u00a0\u00a0double speed = (positions[i + 1] - positions[i]) / dt;\n    \u00a0\u00a0speeds[i] = speed;\n    }\n    for (int i = 0; i < numEntries; ++i) {\n    \u00a0\u00a0double speed = speeds[i];\n    \u00a0\u00a0if (maxSpeed < speed) {\n    \u00a0\u00a0\u00a0\u00a0maxSpeed = speed;\n    \u00a0\u00a0}\n    \u00a0\u00a0if (minSpeed > speed) {\n    \u00a0\u00a0\u00a0\u00a0minSpeed = speed;\n    \u00a0\u00a0}\n    }\n    for (int i = 0; i < numEntries; ++i) {\n    \u00a0\u00a0double speed = speeds[i];\n    \u00a0\u00a0double dt = timesInSeconds[i + 1] - timesInSeconds[i];\n    \u00a0\u00a0if (speed > speedLimit) {\n    \u00a0\u00a0\u00a0\u00a0limitCrossDuration += dt;\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    void SpeedCalculator::calculateAndPrintSpeedData() {\n    \u00a0\u00a0speeds = new double[numEntries]; // add this line\n    \u00a0\u00a0double maxSpeed = 0;\n    ```", "```cpp\n    Hello CMake.\n    Hello from ANewClass.\n    7\n    CxxTemplate: SpeedCalculator.cpp:38: void SpeedCalculator::calculateAndPrintSpeedData(): Assertion `dt > 0' failed.\n    ```", "```cpp\n    void SpeedCalculator::calculateAndPrintSpeedData() {\n    \u00a0\u00a0speeds = new double[numEntries - 1];\n    \u00a0\u00a0double maxSpeed = 0;\n    ...\n    \u00a0\u00a0for (int i = 0; i < numEntries - 1; ++i) {\n    \u00a0\u00a0\u00a0\u00a0double dt = timesInSeconds[i + 1] - timesInSeconds[i];\n    ...\n    \u00a0\u00a0for (int i = 0; i < numEntries - 1; ++i) {\n    \u00a0\u00a0\u00a0\u00a0double speed = speeds[i];\n    ....\n    \u00a0\u00a0for (int i = 0; i < numEntries - 1; ++i) {\n    \u00a0\u00a0\u00a0\u00a0double speed = speeds[i];\n    ```", "```cpp\n    for (int i = 0; i < numEntries - 1; ++i) {\n    \u00a0\u00a0double speed = speeds[i];\n    \u00a0\u00a0if (i == 0 || maxSpeed < speed) { // changed\n    \u00a0\u00a0\u00a0\u00a0maxSpeed = speed;\n    \u00a0\u00a0}\n    \u00a0\u00a0if (i == 0 || minSpeed > speed) { // changed\n    \u00a0\u00a0\u00a0\u00a0minSpeed = speed;\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    \u00a0\u00a0// add these two lines:\n    \u00a0\u00a0timesInSeconds[0] = 0.0;\n    \u00a0\u00a0positions[0] = 0.0;\n    \u00a0\u00a0for (int i = 0; i < numEntries; ++i) {\n    \u00a0\u00a0\u00a0\u00a0positions[i] = positions[i - 1] + (rand() % 500);\n    \u00a0\u00a0\u00a0\u00a0timesInSeconds[i] = timesInSeconds[i - 1] + ((rand() % 10) + 1);\n    \u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0timesInSeconds[0] = 0.0;\n    \u00a0\u00a0positions[0] = 0.0;\n    \u00a0\u00a0for (int i = 1; i < numEntries; ++i) {\n    \u00a0\u00a0\u00a0\u00a0positions[i] = positions[i - 1] + (rand() % 500);\n    \u00a0\u00a0\u00a0\u00a0timesInSeconds[i] = timesInSeconds[i - 1] + ((rand() % 10) + 1);\n    \u00a0\u00a0}\n    ```", "```cpp\n    TEST_F(Point3dTest, DefaultConstructorIsOrigin)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt;\n    \u00a0\u00a0\u00a0\u00a0float expected[4] = {0,0,0,1};\n    \u00a0\u00a0\u00a0\u00a0for(size_t i=0 ; i < 4 ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_NEAR(expected[i], pt(i), Epsilon) << \"cell [\" << i << \"]\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    include <cstddef>\n    class Point3d\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0static constexpr size_t NumberRows{4};\n    \u00a0\u00a0\u00a0\u00a0float operator()(const int index) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_data[index];\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0float m_data[NumberRows];\n    };\n    ```", "```cpp\n    Point3d();\n    ```", "```cpp\n    Point3d::Point3d()\n    {\n    \u00a0\u00a0\u00a0\u00a0for(auto& item : m_data)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0item = 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0m_data[NumberRows-1] = 1;\n    }\n    ```", "```cpp\n    TEST_F(Point3dTest, InitListConstructor3)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt {5.2, 3.5, 6.7};\n    \u00a0\u00a0\u00a0\u00a0float expected[4] = {5.2,3.5,6.7,1};\n    \u00a0\u00a0\u00a0\u00a0for(size_t i=0 ; i < 4 ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_NEAR(expected[i], pt(i), Epsilon) << \"cell [\" << i << \"]\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    #include <initializer_list>\n    ```", "```cpp\n    Point3d(std::initializer_list<float> list);\n    ```", "```cpp\n    Point3d::Point3d(std::initializer_list<float> list)\n    {\n    \u00a0\u00a0\u00a0\u00a0m_data[NumberRows-1] = 1;\n    \u00a0\u00a0\u00a0\u00a0int i{0};\n    \u00a0\u00a0\u00a0\u00a0for(auto it1 = list.begin(); \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i<NumberRows && it1 != list.end();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0++it1, ++i)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i] = *it1;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TEST_F(Point3dTest, InitListConstructor4)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt {5.2, 3.5, 6.7, 2.0};\n    \u00a0\u00a0\u00a0\u00a0float expected[4] = {5.2,3.5,6.7,2.0};\n    \u00a0\u00a0\u00a0\u00a0for(size_t i=0 ; i < 4 ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_NEAR(expected[i], pt(i), Epsilon) << \"cell [\" << i << \"]\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    template<size_t size>\n    void VerifyPoint(Point3d& pt, float (&expected)[size])\n    {\n    \u00a0\u00a0\u00a0\u00a0for(size_t i=0 ; i< size ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_NEAR(expected[i], pt(i), Epsilon) << \"cell [\" << i << \"]\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TEST_F(Point3dTest, InitListConstructor4)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt {5.2, 3.5, 6.7, 2.0};\n    \u00a0\u00a0\u00a0\u00a0float expected[4] = {5.2,3.5,6.7,2.0};\n    \u00a0\u00a0\u00a0\u00a0VerifyPoint(pt, expected);\n    }\n    ```", "```cpp\n    TEST_F(Point3dTest, EqualityOperatorEqual)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt1 {1,3,5};\n    \u00a0\u00a0\u00a0\u00a0Point3d pt2 {1,3,5};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(pt1, pt2);\n    }\n    TEST_F(Point3dTest, EqualityOperatorNotEqual)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt1 {1,2,3};\n    \u00a0\u00a0\u00a0\u00a0Point3d pt2 {1,2,4};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_NE(pt1, pt2);\n    }\n    ```", "```cpp\n    bool operator==(const Point3d& rhs) const;\n    bool operator!=(const Point3d& rhs) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return !operator==(rhs);\n    }\n    ```", "```cpp\n    bool Point3d::operator==(const Point3d& rhs) const\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i=0 ; i<NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_data[i] != rhs.m_data[i])\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    TEST_F(Point3dTest, AccessOperator)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt1;\n    \u00a0\u00a0\u00a0\u00a0Point3d pt2 {1,3,5};\n    \u00a0\u00a0\u00a0\u00a0pt1(0) = 1;\n    \u00a0\u00a0\u00a0\u00a0pt1(1) = 3;\n    \u00a0\u00a0\u00a0\u00a0pt1(2) = 5;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(pt1, pt2);\n    }\n    ```", "```cpp\n    float& operator()(const int index)\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[index];\n    }\n    ```", "```cpp\n    Point3d(const Point3d&) = default;\n    Point3d& operator=(const Point3d&) = default;\n    ```", "```cpp\n    add_executable(graphics point3d.cpp main.cpp matrix3d.cpp)\n    ```", "```cpp\n    SET(SRC_FILES \n    \u00a0\u00a0\u00a0\u00a0../matrix3d.cpp\n    \u00a0\u00a0\u00a0\u00a0../point3d.cpp)\n    SET(TEST_FILES \n    \u00a0\u00a0\u00a0\u00a0matrix3dTests.cpp\n    \u00a0\u00a0\u00a0\u00a0point3dTests.cpp)\n    ```", "```cpp\n    #include \"gtest/gtest.h\"\n    #include \"../matrix3d.hpp\"\n    class Matrix3dTest : public ::testing::Test\n    {\n    public:\n    };\n    TEST_F(Matrix3dTest, DummyTest)\n    {\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(false);\n    }\n    ```", "```cpp\n    class Matrix3d\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0float operator()(const int row, const int column) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_data[row][column];\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0float m_data[4][4];\n    };\n    ```", "```cpp\n    Matrix3d();\n    ```", "```cpp\n    #include \"matrix3d.hpp\"\n    Matrix3d::Matrix3d()\n    {\n    \u00a0\u00a0\u00a0\u00a0for (int i{0} ; i< 4 ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j{0} ; j< 4 ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i][j] = (i==j);\n    }\n    ```", "```cpp\n    #include <cstddef>\u00a0\u00a0\u00a0// Required for size_t definition\n    class Matrix3d\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0static constexpr size_t NumberRows{4};\n    \u00a0\u00a0\u00a0\u00a0static constexpr size_t NumberColumns{4};\n    \u00a0\u00a0\u00a0\u00a0Matrix3d();\n    \u00a0\u00a0\u00a0\u00a0float operator()(const int row, const int column) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0return m_data[row][column];\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0float m_data[NumberRows][NumberColumns];\n    };\n    ```", "```cpp\n    Matrix3d::Matrix3d()\n    {\n    \u00a0\u00a0\u00a0\u00a0for (int i{0} ; i< NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j{0} ; j< NumberColumns ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i][j] = (i==j);\n    }\n    ```", "```cpp\n    TEST_F(Matrix3dTest, InitListConstructor)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat{ {1,2,3,4}, {5,6,7,8},{9,10,11,12}, {13,14,15,16}};\n    \u00a0\u00a0\u00a0\u00a0int expected{1};\n    \u00a0\u00a0\u00a0\u00a0for( int row{0} ; row<4 ; row++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for( int col{0} ; col<4 ; col++, expected++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_FLOAT_EQ(expected, mat(row,col)) << \"cell[\" << row << \"][\" << col << \"]\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    #include <initializer_list>\n    class Matrix3d\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Matrix3d(std::initializer_list<std::initializer_list<float>> list);\n    ```", "```cpp\n    Matrix3d::Matrix3d(std::initializer_list<std::initializer_list<float>> list)\n    {\n    \u00a0\u00a0\u00a0\u00a0int i{0};\n    \u00a0\u00a0\u00a0\u00a0for(auto it1 = list.begin(); i<NumberRows ; ++it1, ++i)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int j{0};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto it2 = it1->begin(); j<NumberColumns ; ++it2, ++j)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i][j] = *it2;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    static constexpr float Epsilon{1e-12};\n    void VerifyMatrixResult(Matrix3d& expected, Matrix3d& actual);\n    ```", "```cpp\n    void Matrix3dTest::VerifyMatrixResult(Matrix3d& expected, Matrix3d& actual)\n    {\n    \u00a0\u00a0\u00a0\u00a0for( int row{0} ; row<4 ; row++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for( int col{0} ; col<4 ; col++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_NEAR(expected(row,col), actual(row,col), Epsilon) \n    << \"cell[\" << row << \"][\" << col << \"]\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TEST_F(Matrix3dTest, MultiplyTwoMatricesGiveExpectedResult)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat1{ {5,6,7,8}, {9,10,11,12}, {13,14,15,16}, {17,18,19,20}};\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat2{ {1,2,3,4}, {5,6,7,8},\u00a0\u00a0\u00a0\u00a0{9,10,11,12},\u00a0\u00a0{13,14,15,16}};\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected{ {202,228,254,280},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{314,356,398,440},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{426,484,542,600},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{538,612,686,760}};\n    \u00a0\u00a0\u00a0\u00a0Matrix3d result = mat1 * mat2;\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, result);\n    }\n    ```", "```cpp\n    Matrix3d& operator*=(const Matrix3d& rhs);\n    ```", "```cpp\n    inline Matrix3d operator*(const Matrix3d& lhs, const Matrix3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d temp(lhs);\n    \u00a0\u00a0\u00a0\u00a0temp *= rhs;\n    \u00a0\u00a0\u00a0\u00a0return temp;\n    }\n    ```", "```cpp\n    Matrix3d& Matrix3d::operator*=(const Matrix3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d temp;\n    \u00a0\u00a0\u00a0\u00a0for(int i=0 ; i<NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j=0 ; j<NumberColumns ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.m_data[i][j] = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int k=0 ; k<NumberRows ; k++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.m_data[i][j] += m_data[i][k] * rhs.m_data[k][j];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0*this = temp;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    void VerifyMatrixIsIdentity(Matrix3d& mat);\n    ```", "```cpp\n    void Matrix3dTest::VerifyMatrixIsIdentity(Matrix3d& mat)\n    {\n    for( int row{0} ; row<4 ; row++)\n    \u00a0\u00a0\u00a0\u00a0for( int col{0} ; col<4 ; col++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int expected = (row==col) ? 1 : 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ASSERT_FLOAT_EQ(expected, mat(row,col)) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< \"cell[\" << row << \"][\" << col << \"]\";\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TEST_F(Matrix3dTest, DefaultConstructorIsIdentity)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat;\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixIsIdentity(mat);\n    }\n    ```", "```cpp\n    TEST_F(Matrix3dTest, IdentityTimesIdentityIsIdentity)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat;\n    \u00a0\u00a0\u00a0\u00a0Matrix3d result = mat * mat;\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixIsIdentity(result);\n    }\n    ```", "```cpp\n    TEST_F(Matrix3dTest, MultiplyMatrixWithPoint)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat { {1,2,3,4}, {5,6,7,8},\u00a0\u00a0\u00a0\u00a0{9,10,11,12},\u00a0\u00a0{13,14,15,16}};\n    \u00a0\u00a0\u00a0\u00a0Point3d pt {15, 25, 35, 45};\n    \u00a0\u00a0\u00a0\u00a0Point3d expected{350, 830, 1310, 1790};\n    \u00a0\u00a0\u00a0\u00a0Point3d pt2 = mat * pt;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(expected, pt2);\n    }\n    ```", "```cpp\n    Point3d operator*(const Matrix3d& lhs, const Point3d& rhs);\n    ```", "```cpp\n    Point3d operator*(const Matrix3d& lhs, const Point3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Point3d pt;\n    \u00a0\u00a0\u00a0\u00a0for(int row{0} ; row<Matrix3d::NumberRows ; row++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float sum{0};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int col{0} ; col<Matrix3d::NumberColumns ; col++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sum += lhs(row, col) * rhs(col);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pt(row) = sum;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return pt;\n    }\n    ```", "```cpp\n    #include <cmath>\n    ```", "```cpp\n    TEST_F(Matrix3dTest, CreateTranslateIsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createTranslationMatrix(-0.5, 2.5, 10.0);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{1.0, 0.0, 0.0, -0.5},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 1.0, 0.0, 2.5},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0, 1.0, 10.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0, 0.0, 1.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateScaleIsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createScaleMatrix(3.0, 2.5, 11.0);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{3.0, 0.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 2.5,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0, 11.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a00.0, 1.0}\n    \u00a0\u00a0\u00a0\u00a0};\t\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateX90IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutX(90.0F);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{1.0, 0.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0, -1.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 1.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a00.0, 1.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateX60IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutX(60.0F);\n    \u00a0\u00a0\u00a0\u00a0float sqrt3_2 = static_cast<float>(std::sqrt(3.0)/2.0);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{1.0, 0.0,\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.5,\u00a0\u00a0\u00a0\u00a0-sqrt3_2, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, sqrt3_2,\u00a0\u00a00.5,\u00a0\u00a0\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0\u00a0\u00a01.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateY90IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutY(90.0F);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{0.0, 0.0,\u00a0\u00a01.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 1.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{-1.0, 0.0, 0.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a00.0, 1.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateY60IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutY(60.0F);\n    \u00a0\u00a0\u00a0\u00a0float sqrt3_2 = static_cast<float>(std::sqrt(3.0)/2.0);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{0.5,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0sqrt3_2,\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.0,\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{-sqrt3_2, 0.0,\u00a0\u00a0\u00a0\u00a00.5,\u00a0\u00a0\u00a0\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a0\u00a0\u00a01.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateZ90IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutZ(90.0F);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{0.0, -1.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{1.0, 0.0,\u00a0\u00a00.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a01.0, 0.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0, 0.0,\u00a0\u00a00.0, 1.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    TEST_F(Matrix3dTest, CreateRotateZ60IsCorrect)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d mat = createRotationMatrixAboutZ(60.0F);\n    \u00a0\u00a0\u00a0\u00a0float sqrt3_2 = static_cast<float>(std::sqrt(3.0)/2.0);\n    \u00a0\u00a0\u00a0\u00a0Matrix3d expected {{0.5,\u00a0\u00a0\u00a0\u00a0\u00a0-sqrt3_2,\u00a0\u00a0\u00a00.0,\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{sqrt3_2,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.5,\u00a0\u00a0\u00a00.0,\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a01.0,\u00a0\u00a00.0},\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{0.0,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00.0,\u00a0\u00a0\u00a00.0,\u00a0\u00a01.0}\n    \u00a0\u00a0\u00a0\u00a0};\n    \u00a0\u00a0\u00a0\u00a0VerifyMatrixResult(expected, mat);\n    }\n    ```", "```cpp\n    Matrix3d createTranslationMatrix(float dx, float dy, float dz);\n    Matrix3d createScaleMatrix(float sx, float sy, float sz);\n    Matrix3d createRotationMatrixAboutX(float degrees);\n    Matrix3d createRotationMatrixAboutY(float degrees);\n    Matrix3d createRotationMatrixAboutZ(float degrees);\n    ```", "```cpp\n    Matrix3d createTranslationMatrix(float dx, float dy, float dz)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d matrix;\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 3) = dx;\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 3) = dy;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 3) = dz;\n    \u00a0\u00a0\u00a0\u00a0return matrix;\n    }\n    Matrix3d createScaleMatrix(float sx, float sy, float sz)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d matrix;\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 0) = sx;\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 1) = sy;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 2) = sz;\n    \u00a0\u00a0\u00a0\u00a0return matrix;\n    }\n    Matrix3d createRotationMatrixAboutX(float degrees)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d matrix;\n    \u00a0\u00a0\u00a0\u00a0double pi{4.0F*atan(1.0F)};\n    \u00a0\u00a0\u00a0\u00a0double radians = degrees / 180.0 * pi;\n    \u00a0\u00a0\u00a0\u00a0float cos_theta = static_cast<float>(cos(radians));\n    \u00a0\u00a0\u00a0\u00a0float sin_theta = static_cast<float>(sin(radians));\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 1) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 2) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 2) = -sin_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 1) =\u00a0\u00a0sin_theta;\n    \u00a0\u00a0\u00a0\u00a0return matrix;\n    }\n    Matrix3d createRotationMatrixAboutY(float degrees)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d matrix;\n    \u00a0\u00a0\u00a0\u00a0double pi{4.0F*atan(1.0F)};\n    \u00a0\u00a0\u00a0\u00a0double radians = degrees / 180.0 * pi;\n    \u00a0\u00a0\u00a0\u00a0float cos_theta = static_cast<float>(cos(radians));\n    \u00a0\u00a0\u00a0\u00a0float sin_theta = static_cast<float>(sin(radians));\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 0) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 2) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 2) =\u00a0\u00a0sin_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(2, 0) = -sin_theta;\n    \u00a0\u00a0\u00a0\u00a0return matrix;\n    }\n    Matrix3d createRotationMatrixAboutZ(float degrees)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d matrix;\n    \u00a0\u00a0\u00a0\u00a0double pi{4.0F*atan(1.0F)};\n    \u00a0\u00a0\u00a0\u00a0double radians = degrees / 180.0 * pi;\n    \u00a0\u00a0\u00a0\u00a0float cos_theta = static_cast<float>(cos(radians));\n    \u00a0\u00a0\u00a0\u00a0float sin_theta = static_cast<float>(sin(radians));\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 0) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 1) =\u00a0\u00a0cos_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(0, 1) = -sin_theta;\n    \u00a0\u00a0\u00a0\u00a0matrix(1, 0) =\u00a0\u00a0sin_theta;\n    \u00a0\u00a0\u00a0\u00a0return matrix;\n    }\n    ```", "```cpp\n    float& operator()(const int row, const int column)\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[row][column];\n    }\n    ```", "```cpp\n    friend std::ostream& operator<<(std::ostream& , const Point3d& );\n    ```", "```cpp\n    inline std::ostream&\n    operator<<(std::ostream& os, const Point3d& pt)\n    {\n    \u00a0\u00a0\u00a0\u00a0const char* sep = \"[ \";\n    \u00a0\u00a0\u00a0\u00a0for(auto value : pt.m_data)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << sep\u00a0\u00a0<< value;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sep = \", \";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0os << \" ]\";\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    //#define ACTIVITY1\n    ```", "```cpp\n    TEST_F(containsTest, DetectNpos)\n    {\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(has_npos_v<std::string>);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(has_npos_v<std::set<int>>);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(has_npos_v<std::vector<int>>);\n    }\n    ```", "```cpp\n    template <class T>\n    auto test_npos(int) -> decltype((void)T::npos, std::true_type{});\n    template <class T>\n    auto test_npos(long) -> std::false_type;\n    template <class T>\n    struct has_npos : decltype(test_npos<T>(0)) {};\n    template< class T >\n    inline constexpr bool has_npos_v = has_npos<T>::value;\n    ```", "```cpp\n    template <class T, class A0>\n    auto test_find(int) -> \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0decltype(void(std::declval<T>().find(std::declval<A0>())), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::true_type{});\n    template <class T, class A0>\n    auto test_find(long) -> std::false_type;\n    template <class T, class A0>\n    struct has_find : decltype(test_find<T,A0>(0)) {};\n    template< class T, class A0 >\n    inline constexpr bool has_find_v = has_find<T, A0>::value;\n    ```", "```cpp\n    TEST_F(containsTest, VectorContains)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> container {1,2,3,4,5};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(contains(container, 5));\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(contains(container, 15));\n    }\n    ```", "```cpp\n    template<class C, class T>\n    auto contains(const C& c, const T& key) -> decltype(std::end(c), true)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::end(c) != std::find(begin(c), end(c), key);\n    }\n    ```", "```cpp\n    TEST_F(containsTest, SetContains)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::set<int> container {1,2,3,4,5};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(contains(container, 5));\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(contains(container, 15));\n    }\n    ```", "```cpp\n    template<class C, class T>\n    auto contains(const C& c, const T& key) -> decltype(std::end(c), true)\n    {\n    \u00a0\u00a0\u00a0\u00a0if constexpr(has_find_v<C, T>)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::end(c) != c.find(key);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::end(c) != std::find(begin(c), end(c), key);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TEST_F(containsTest, StringContains)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::string container{\"This is the message\"};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(contains(container, \"the\"));\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(contains(container, 'm'));\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(contains(container, \"massage\"));\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(contains(container, 'z'));\n    }\n    ```", "```cpp\n    template<class C, class T>\n    auto contains(const C& c, const T& key) -> decltype(std::end(c), true)\n    {\n    \u00a0\u00a0\u00a0\u00a0if constexpr(has_npos_v<C>)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return C::npos != c.find(key);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0if constexpr(has_find_v<C, T>)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::end(c) != c.find(key);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return std::end(c) != std::find(begin(c), end(c), key);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    using namespace acpp::gfx;\n    ```", "```cpp\n    std::unique_ptr<float[]> m_data;\n    ```", "```cpp\n    float operator()(const int row, const int column) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[row][column];\n    }\n    float& operator()(const int row, const int column)\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[row][column];\n    } \n    ```", "```cpp\n    float operator()(const int row, const int column) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[get_index(row,column)];\n    }\n    float& operator()(const int row, const int column)\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_data[get_index(row,column)];\n    }\n    private:\n    size_t get_index(const int row, const int column) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return row * NumberColumns + column;\n    }\n    ```", "```cpp\n    inline Matrix3d operator*(const Matrix3d& lhs, const Matrix3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d temp(lhs);\u00a0\u00a0\u00a0// <=== compiler error \u2013 ill formed copy constructor\n    \u00a0\u00a0\u00a0\u00a0temp *= rhs;\n    \u00a0\u00a0\u00a0\u00a0return temp;\n    }\n    ```", "```cpp\n    Matrix3d(const Matrix3d& rhs);\n    Matrix3d& operator=(const Matrix3d& rhs);\n    ```", "```cpp\n    Matrix3d::Matrix3d() : m_data{new float[NumberRows*NumberColumns]}\n    {\n    \u00a0\u00a0\u00a0\u00a0for (int i{0} ; i< NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j{0} ; j< NumberColumns ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i][j] = (i==j);\n    }\n    Matrix3d::Matrix3d(std::initializer_list<std::initializer_list<float>> list)\n    \u00a0\u00a0\u00a0\u00a0: m_data{new float[NumberRows*NumberColumns]}\n    {\n    \u00a0\u00a0\u00a0\u00a0int i{0};\n    \u00a0\u00a0\u00a0\u00a0for(auto it1 = list.begin(); i<NumberRows ; ++it1, ++i)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int j{0};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto it2 = it1->begin(); j<NumberColumns ; ++it2, ++j)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i][j] = *it2;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    Matrix3d::Matrix3d() : m_data{new float[NumberRows*NumberColumns]}\n    {\n    \u00a0\u00a0\u00a0\u00a0for (int i{0} ; i< NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int j{0} ; j< NumberColumns ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[get_index(i, j)] = (i==j);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <= change here\n    }\n    ```", "```cpp\n    Matrix3d::Matrix3d(std::initializer_list<std::initializer_list<float>> list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: m_data{new float[NumberRows*NumberColumns]}\n    {\n    \u00a0\u00a0\u00a0\u00a0int i{0};\n    \u00a0\u00a0\u00a0\u00a0for(auto it1 = list.begin(); i<NumberRows ; ++it1, ++i)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int j{0};\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto it2 = it1->begin(); j<NumberColumns ; ++it2, ++j)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[get_index(i, j)] = *it2;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <= change here\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    Matrix3d& Matrix3d::operator*=(const Matrix3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Matrix3d temp;\n    \u00a0\u00a0\u00a0\u00a0for(int i=0 ; i<NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(int j=0 ; j<NumberColumns ; j++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.m_data[get_index(i, j)] = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <= change here\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int k=0 ; k<NumberRows ; k++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0temp.m_data[get_index(i, j)] += m_data[get_index(i, k)] \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* rhs.m_data[get_index(k, j)];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// <= change here\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0*this = temp;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    Matrix3d::Matrix3d(const Matrix3d& rhs) : \n    \u00a0\u00a0\u00a0\u00a0m_data{new float[NumberRows*NumberColumns]}\n    {\n    \u00a0\u00a0\u00a0\u00a0*this = rhs;\n    }\n    Matrix3d& Matrix3d::operator=(const Matrix3d& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i=0 ; i< NumberRows*NumberColumns ; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i] = rhs.m_data[i];\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    return std::move(matrix);\n    ```", "```cpp\n    Matrix3d(Matrix3d&& rhs);\n    ```", "```cpp\n    Matrix3d::Matrix3d(Matrix3d&& rhs)\n    {\n    \u00a0\u00a0\u00a0\u00a0//std::cerr << \"Matrix3d::Matrix3d(Matrix3d&& rhs)\\n\";\n    \u00a0\u00a0\u00a0\u00a0std::swap(m_data, rhs.m_data);\n    }\n    ```", "```cpp\n    std::unique_ptr<float[]> m_data;\n    ```", "```cpp\n    inline std::ostream&\n    operator<<(std::ostream& os, const Point3d& pt)\n    {\n    \u00a0\u00a0\u00a0\u00a0const char* sep = \"[ \";\n    \u00a0\u00a0\u00a0\u00a0for(int i{0} ; i < Point3d::NumberRows ; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0os << sep << pt.m_data[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sep = \", \";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0os << \" ]\";\n    \u00a0\u00a0\u00a0\u00a0return os;\n    } \n    ```", "```cpp\n    Point3d::Point3d() : m_data{new float[NumberRows]}\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i{0} ; i < NumberRows-1 ; i++) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_data[i] = 0;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0m_data[NumberRows-1] = 1;\n    }\n    ```", "```cpp\n    Point3d::Point3d(std::initializer_list<float> list)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: m_data{new float[NumberRows]}\n    ```", "```cpp\n    int Day()\u00a0\u00a0\u00a0const {return m_day;}\n    int Month() const {return m_month;}\n    int Year()\u00a0\u00a0const {return m_year;}\n    ```", "```cpp\n    void VerifyDate(const Date& dt, int yearExp, int monthExp, int dayExp) const\n    {\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(dayExp, dt.Day());\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(monthExp, dt.Month());\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(yearExp, dt.Year());\n    }\n    ```", "```cpp\n    Date dt;\n    VerifyDate(dt, 1970, 1, 1);\n    ```", "```cpp\n    TEST_F(DateTest, Constructor1970Jan2)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(2, 1, 1970);\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1970, 1, 2);\n    }\n    ```", "```cpp\n    Date() = default;\n    Date(int day, int month, int year) :\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_year{year}, m_month{month}, m_day{day}\n    {\n    }\n    ```", "```cpp\n    using date_t=int64_t;\n    ```", "```cpp\n    date_t ToDateT() const;\n    ```", "```cpp\n    TEST_F(DateTest, ToDateTDefaultIsZero)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(0, dt.ToDateT());\n    }\n    ```", "```cpp\n    date_t Date::ToDateT() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    TEST_F(DateTest, ToDateT1970Jan2Is1)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(2, 1, 1970);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(1, dt.ToDateT());\n    }\n    ```", "```cpp\n    TEST_F(DateTest, ToDateT1970Dec31Is364)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(31, 12, 1970);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(364, dt.ToDateT());\n    }\n    TEST_F(DateTest, ToDateT1971Jan1Is365)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(1, 1, 1971);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(365, dt.ToDateT());\n    }\n    TEST_F(DateTest, ToDateT1973Jan1Is1096)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(1, 1, 1973);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(365*3+1, dt.ToDateT());\n    }\n    TEST_F(DateTest, ToDateT2019Aug28Is18136)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(18136, dt.ToDateT());\n    }\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0static constexpr int EpochYear = 1970;\n    \u00a0\u00a0\u00a0\u00a0static constexpr int DaysPerCommonYear = 365;\n    \u00a0\u00a0\u00a0\u00a0static constexpr int YearsBetweenLeapYears = 4;\n    private:\n    \u00a0\u00a0\u00a0\u00a0int GetDayOfYear(int day, int month, int year) const;\n    \u00a0\u00a0\u00a0\u00a0bool IsLeapYear(int year) const;\n    \u00a0\u00a0\u00a0\u00a0int CalcNumberLeapYearsFromEpoch(int year) const;\n    ```", "```cpp\n    namespace {\n    int daysBeforeMonth[2][12] =\n    {\n    \u00a0\u00a0\u00a0\u00a0{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 204, 334}, // Common Year\n    \u00a0\u00a0\u00a0\u00a0{ 0, 31, 50, 91, 121, 152, 182, 213, 244, 274, 205, 335}\u00a0\u00a0// Leap Year\n    };\n    }\n    namespace acpp::date\n    {\n    int Date::CalcNumberLeapYearsFromEpoch(int year) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return (year-1)/YearsBetweenLeapYears\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0- (EpochYear-1)/YearsBetweenLeapYears;\n    }\n    int Date::GetDayOfYear(int day, int month, int year) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return daysBeforeMonth[IsLeapYear(year)][month-1] + day;\n    }\n    bool Date::IsLeapYear(int year) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return (year%4)==0;\u00a0\u00a0\u00a0// Not full story, but good enough to 2100\n    }\n    date_t Date::ToDateT() const\n    {\n    \u00a0\u00a0\u00a0\u00a0date_t value = GetDayOfYear(m_day, m_month, m_year) - 1;\n    \u00a0\u00a0\u00a0\u00a0value += (m_year-EpochYear) * DaysPerCommonYear;\n    \u00a0\u00a0\u00a0\u00a0date_t numberLeapYears = CalcNumberLeapYearsFromEpoch(m_year);\n    \u00a0\u00a0\u00a0\u00a0value += numberLeapYears;\n    \u00a0\u00a0\u00a0\u00a0return value;\n    }\n    }\n    ```", "```cpp\n    TEST_F(DateTest, FromDateT0Is1Jan1970)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(0);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(0, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1970, 1, 1);\n    }\n    TEST_F(DateTest, FromDateT1Is2Jan1970)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(1);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(1, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1970, 1, 2);\n    }\n    TEST_F(DateTest, FromDateT364Is31Dec1970)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(364);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(364, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1970, 12, 31);\n    }\n    TEST_F(DateTest, FromDateT365Is1Jan1971)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(365);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(365, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1971, 1, 1);\n    }\n    TEST_F(DateTest, FromDateT1096Is1Jan1973)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(1096);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(1096, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 1973, 1, 1);\n    }\n    TEST_F(DateTest, FromDateT18136Is28Aug2019)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt;\n    \u00a0\u00a0\u00a0\u00a0dt.FromDateT(18136);\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(18136, dt.ToDateT());\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 2019, 8, 28);\n    }\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0void FromDateT(date_t date);\n    private:\n    \u00a0\u00a0\u00a0\u00a0int CalcMonthDayOfYearIsIn(int dayOfYear, bool IsLeapYear) const;\n    ```", "```cpp\n    void Date::FromDateT(date_t date)\n    {\n    \u00a0\u00a0\u00a0\u00a0int number_years = date / DaysPerCommonYear;\n    \u00a0\u00a0\u00a0\u00a0date = date - number_years * DaysPerCommonYear;\n    \u00a0\u00a0\u00a0\u00a0m_year = EpochYear + number_years;\n    \u00a0\u00a0\u00a0\u00a0date_t numberLeapYears = CalcNumberLeapYearsFromEpoch(m_year);\n    \u00a0\u00a0\u00a0\u00a0date -= numberLeapYears;\n    \u00a0\u00a0\u00a0\u00a0m_month = CalcMonthDayOfYearIsIn(date, IsLeapYear(m_year));\n    \u00a0\u00a0\u00a0\u00a0date -= daysBeforeMonth[IsLeapYear(m_year)][m_month-1];\n    \u00a0\u00a0\u00a0\u00a0m_day = date + 1;\n    }\n    int Date::CalcMonthDayOfYearIsIn(int dayOfYear, bool isLeapYear) const\n    {\n    \u00a0\u00a0\u00a0\u00a0for(int i = 1 ; i < 12; i++)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0if ( daysBeforeMonth[isLeapYear][i] > dayOfYear)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return i;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return 12;\n    }\n    ```", "```cpp\n    class Days\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Days() = default;\n    \u00a0\u00a0\u00a0\u00a0Days(int days) : m_days{days}\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0operator int() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_days;\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0int m_days{0};\n    };\n    ```", "```cpp\n    Date& operator+=(const Days& day);\n    ```", "```cpp\n    inline Date operator+(const Date& lhs, const Days& rhs )\n    {\n    \u00a0\u00a0\u00a0\u00a0Date tmp(lhs);\n    \u00a0\u00a0\u00a0\u00a0tmp += rhs;\n    \u00a0\u00a0\u00a0\u00a0return tmp;\n    }\n    ```", "```cpp\n    TEST_F(DateTest, AddZeroDays)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0Days days;\n    \u00a0\u00a0\u00a0\u00a0dt += days;\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 2019, 8, 28);\n    }\n    TEST_F(DateTest, AddFourDays)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0Days days(4);\n    \u00a0\u00a0\u00a0\u00a0dt += days;\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 2019, 9, 1);\n    }\n    ```", "```cpp\n    Date& Date::operator+=(const Days& day)\n    {\n    \u00a0\u00a0\u00a0\u00a0FromDateT(ToDateT()+day);\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    TEST_F(DateTest, AddFourDaysAsInt)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0dt += 4;\n    \u00a0\u00a0\u00a0\u00a0VerifyDate(dt, 2019, 9, 1);\n    }\n    ```", "```cpp\n    explicit Days(int days) : m_days{days}\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    dt += static_cast<Days>(4);\n    ```", "```cpp\n    TEST_F(DateTest, DateDifferences27days)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt1(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0Date dt2(1, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0Days days = dt1 - dt2;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(27, (int)days);\n    }\n    TEST_F(DateTest, DateDifferences365days)\n    {\n    \u00a0\u00a0\u00a0\u00a0Date dt1(28, 8, 2019);\n    \u00a0\u00a0\u00a0\u00a0Date dt2(28, 8, 2018);\n    \u00a0\u00a0\u00a0\u00a0Days days = dt1 - dt2;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_EQ(365, (int)days);\n    }\n    ```", "```cpp\n    Days operator-(const Date& rhs) const;\n    ```", "```cpp\n    inline Days Date::operator-(const Date& rhs) const\n    {\n    \u00a0\u00a0\u00a0\u00a0return Days(ToDateT() - rhs.ToDateT());\n    }\n    ```", "```cpp\n    #define ACTIVITY2\n    ```", "```cpp\n    TEST_F(DelegateTest, BasicDelegate)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate delegate;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_NO_THROW(delegate.Notify(42));\n    }\n    ```", "```cpp\n    class Delegate\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Delegate() = default;\n    \u00a0\u00a0\u00a0\u00a0void Notify(int value) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    ASSERT_NO_THROW(delegate(22));\n    ```", "```cpp\n    void operator()(int value)\n    {\n    \u00a0\u00a0\u00a0\u00a0Notify(value);\n    }\n    ```", "```cpp\n    class DelegateTest : public ::testing::Test\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0void SetUp() override;\n    \u00a0\u00a0\u00a0\u00a0void TearDown() override;\n    \u00a0\u00a0\u00a0\u00a0std::stringstream m_buffer;\n    \u00a0\u00a0\u00a0\u00a0// Save cout's buffer here\n    \u00a0\u00a0\u00a0\u00a0std::streambuf *m_savedBuf{};\n    };\n    void DelegateTest::SetUp()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Save the cout buffer\n    \u00a0\u00a0\u00a0\u00a0m_savedBuf = std::cout.rdbuf();\n    \u00a0\u00a0\u00a0\u00a0// Redirect cout to our buffer\n    \u00a0\u00a0\u00a0\u00a0std::cout.rdbuf(m_buffer.rdbuf());\n    }\n    void DelegateTest::TearDown()\n    {\n    \u00a0\u00a0\u00a0\u00a0// Restore cout buffer to original\n    \u00a0\u00a0\u00a0\u00a0std::cout.rdbuf(m_savedBuf);\n    }\n    ```", "```cpp\n    TEST_F(DelegateTest, SingleCallback)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate delegate;\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (int value) { std::cout << \"value = \" << value; };\n    \u00a0\u00a0\u00a0\u00a0delegate.Notify(42);\n    \u00a0\u00a0\u00a0\u00a0std::string result = m_buffer.str();\n    \u00a0\u00a0\u00a0\u00a0ASSERT_STREQ(\"value = 42\", result.c_str());\n    }\n    ```", "```cpp\n    Delegate& operator+=(const std::function<void(int)>& delegate)\n    {\n    \u00a0\u00a0\u00a0\u00a0m_delegate = delegate;\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::function<void(int)> m_delegate;\n    ```", "```cpp\n    void Notify(int value) const\n    {\n    \u00a0\u00a0\u00a0\u00a0m_delegate(value);\n    }\n    ```", "```cpp\n    void Notify(int value) const\n    {\n    \u00a0\u00a0\u00a0\u00a0if(m_delegate)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_delegate(value);\n    }\n    ```", "```cpp\n    TEST_F(DelegateTest, DualCallbacks)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate delegate;\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (int value) { std::cout << \"1: = \" << value << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (int value) { std::cout << \"2: = \" << value << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate.Notify(12);\n    \u00a0\u00a0\u00a0\u00a0std::string result = m_buffer.str();\n    \u00a0\u00a0\u00a0\u00a0ASSERT_STREQ(\"1: = 12\\n2: = 12\\n\", result.c_str());\n    }\n    ```", "```cpp\n    class Delegate\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Delegate() = default;\n    \u00a0\u00a0\u00a0\u00a0Delegate& operator+=(const std::function<void(int)>& delegate)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_delegates.push_back(delegate);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void Notify(int value) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto& delegate : m_delegates)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delegate(value);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void operator()(int value)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Notify(value);\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::vector<std::function<void(int)>> m_delegates;\n    };\n    ```", "```cpp\n    template<class Arg>\n    class Delegate\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Delegate() = default;\n    \u00a0\u00a0\u00a0\u00a0Delegate& operator+=(const std::function<void(Arg)>& delegate)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_delegates.push_back(delegate);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void Notify(Arg value) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto& delegate : m_delegates)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delegate(value);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void operator()(Arg value)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Notify(value);\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::vector<std::function<void(Arg)>> m_delegates;\n    };\n    ```", "```cpp\n    TEST_F(DelegateTest, DualCallbacksString)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate<std::string&> delegate;\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (std::string value) { std::cout << \"1: = \" << value << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (std::string value) { std::cout << \"2: = \" << value << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0std::string hi{\"hi\"};\n    \u00a0\u00a0\u00a0\u00a0delegate.Notify(hi);\n    \u00a0\u00a0\u00a0\u00a0std::string result = m_buffer.str();\n    \u00a0\u00a0\u00a0\u00a0ASSERT_STREQ(\"1: = hi\\n2: = hi\\n\", result.c_str());\n    }\n    ```", "```cpp\n    template<typename... ArgTypes>\n    class Delegate\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Delegate() = default;\n    \u00a0\u00a0\u00a0\u00a0Delegate& operator+=(const std::function<void(ArgTypes...)>& delegate)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_delegates.push_back(delegate);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void Notify(ArgTypes&&... args) const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for(auto& delegate : m_delegates)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delegate(std::forward<ArgTypes>(args)...);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void operator()(ArgTypes&&... args)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Notify(std::forward<ArgTypes>(args)...);\n    \u00a0\u00a0\u00a0\u00a0}\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::vector<std::function<void(ArgTypes...)>> m_delegates;\n    };\n    ```", "```cpp\n    TEST_F(DelegateTest, DualCallbacksNoArgs)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate delegate;\n    \u00a0\u00a0\u00a0\u00a0delegate += [] () { std::cout << \"CB1\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate += [] () { std::cout << \"CB2\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate.Notify();\n    \u00a0\u00a0\u00a0\u00a0std::string result = m_buffer.str();\n    \u00a0\u00a0\u00a0\u00a0ASSERT_STREQ(\"CB1\\nCB2\\n\", result.c_str());\n    }\n    TEST_F(DelegateTest, DualCallbacksStringAndInt)\n    {\n    \u00a0\u00a0\u00a0\u00a0Delegate<std::string&, int> delegate;\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (std::string& value, int i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"1: = \" << value << \",\" << i << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0delegate += [] (std::string& value, int i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"2: = \" << value << \",\" << i << \"\\n\"; };\n    \u00a0\u00a0\u00a0\u00a0std::string hi{\"hi\"};\n    \u00a0\u00a0\u00a0\u00a0delegate.Notify(hi, 52);\n    \u00a0\u00a0\u00a0\u00a0std::string result = m_buffer.str();\n    \u00a0\u00a0\u00a0\u00a0ASSERT_STREQ(\"1: = hi,52\\n2: = hi,52\\n\", result.c_str());\n    }\n    ```", "```cpp\n    #define ACTIVITY_STEP 27\n    ```", "```cpp\n    #ifndef COMMON_HPP\n    #define COMMON_HPP\n    constexpr size_t CountPeopleInside = 5;\n    #endif // COMMON_HPP\n    ```", "```cpp\n    #ifndef PERSON_HPP\n    #define PERSON_HPP\n    class Person\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Person();\n    \u00a0\u00a0\u00a0\u00a0Person& operator=(Person&);\n    \u00a0\u00a0\u00a0\u00a0Person(Person&&);\n    \u00a0\u00a0\u00a0\u00a0~Person() = default;\n    \u00a0\u00a0\u00a0\u00a0Person(const Person&) = delete;\n    \u00a0\u00a0\u00a0\u00a0Person& operator=(const Person&) = delete;\n    private:\n    \u00a0\u00a0\u00a0\u00a0int m_Id;\n    \u00a0\u00a0\u00a0\u00a0static int m_NextId;\n    };\n    #endif // PERSON_HPP\n    ```", "```cpp\n    #ifndef PERSONS_HPP\n    #define PERSONS_HPP\n    #include \"Person.hpp\"\n    #include <mutex>\n    #include <vector>\n    class Persons\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Persons();\n    \u00a0\u00a0\u00a0\u00a0~Persons() = default;\n    \u00a0\u00a0\u00a0\u00a0void add(Person&& person);\n    \u00a0\u00a0\u00a0\u00a0Person get();\n    \u00a0\u00a0\u00a0\u00a0size_t size() const;\n    \u00a0\u00a0\u00a0\u00a0void removePerson();\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::mutex m_Mutex;\n    \u00a0\u00a0\u00a0\u00a0std::vector<Person> m_Persons;\n    };\n    #endif // PERSONS_HPP\n    ```", "```cpp\n    Persons::Persons()\n    {\n    \u00a0\u00a0\u00a0\u00a0m_Persons.reserve(CountPeopleInside);\n    }\n    ```", "```cpp\n    void Persons::add(Person&& person)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::lock_guard<std::mutex> m_lock(m_Mutex);\n    \u00a0\u00a0\u00a0\u00a0m_Persons.emplace_back(std::move(person));\n    }\n    ```", "```cpp\n    Person Persons::get()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::lock_guard<std::mutex> m_lock(m_Mutex);\n    \u00a0\u00a0\u00a0\u00a0if (m_Persons.empty())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw \"Empty Persons storage\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0Person result = std::move(m_Persons.back());\n    \u00a0\u00a0\u00a0\u00a0m_Persons.pop_back();\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    size_t Persons::size() const\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_Persons.size();\n    }\n    ```", "```cpp\n    void Persons::removePerson()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::lock_guard<std::mutex> m_lock(m_Mutex);\n    \u00a0\u00a0\u00a0\u00a0m_Persons.pop_back();\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Persons | removePerson | removed\" << std::endl;\n    }\n    ```", "```cpp\n    #ifndef PERSON_GENERATOR_HPP\n    #define PERSON_GENERATOR_HPP\n    #include \"Persons.hpp\"\n    #include <condition_variable>\n    #include <thread>\n    class PersonGenerator\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0PersonGenerator(Persons& persons,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable& add_person,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable& remove_person,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& add_lock,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& remove_lock,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& addNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& removeNotified);\n    \u00a0\u00a0\u00a0\u00a0~PersonGenerator();\n    \u00a0\u00a0\u00a0\u00a0PersonGenerator(const PersonGenerator&) = delete;\n    \u00a0\u00a0\u00a0\u00a0PersonGenerator(PersonGenerator&&) = delete;\n    \u00a0\u00a0\u00a0\u00a0PersonGenerator& operator=(const PersonGenerator&) = delete;\n    \u00a0\u00a0\u00a0\u00a0PersonGenerator& operator=(PersonGenerator&&) = delete;\n    private:\n    \u00a0\u00a0\u00a0\u00a0void runCreating();\n    \u00a0\u00a0\u00a0\u00a0void runRemoving();\n    \u00a0\u00a0\u00a0\u00a0void notifyCreated();\n    \u00a0\u00a0\u00a0\u00a0void notifyRemoved();\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::thread m_CreateThread;\n    \u00a0\u00a0\u00a0\u00a0std::thread m_RemoveThread;\n    \u00a0\u00a0\u00a0\u00a0Persons& m_CreatedPersons;\n    \u00a0\u00a0\u00a0\u00a0// to notify about creating new person\n    \u00a0\u00a0\u00a0\u00a0std::condition_variable& m_CondVarAddPerson;\n    \u00a0\u00a0\u00a0\u00a0std::mutex& m_AddLock;\n    \u00a0\u00a0\u00a0\u00a0bool& m_AddNotified;\n    \u00a0\u00a0\u00a0\u00a0// to notify that person needs to be removed\n    \u00a0\u00a0\u00a0\u00a0std::condition_variable& m_CondVarRemovePerson;\n    \u00a0\u00a0\u00a0\u00a0std::mutex& m_RemoveLock;\n    \u00a0\u00a0\u00a0\u00a0bool& m_RemoveNotified;\n    };\n    #endif // PERSON_GENERATOR_HPP\n    ```", "```cpp\n    #include \"PersonGenerator.hpp\"\n    #include <iostream>\n    #include <stdlib.h>\u00a0\u00a0\u00a0\u00a0\u00a0/* srand, rand */\n    #include <time.h>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* time, chrono */\n    #include <ratio>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* std::milli */\n    ```", "```cpp\n    PersonGenerator::PersonGenerator(Persons& persons,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable& add_person,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable& remove_person,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& add_lock,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& remove_lock,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& addNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& removeNotified)\n    \u00a0\u00a0\u00a0\u00a0: m_CreatedPersons(persons)\n    \u00a0\u00a0\u00a0\u00a0, m_CondVarAddPerson(add_person)\n    \u00a0\u00a0\u00a0\u00a0, m_AddLock(add_lock)\n    \u00a0\u00a0\u00a0\u00a0, m_AddNotified(addNotified)\n    \u00a0\u00a0\u00a0\u00a0, m_CondVarRemovePerson(remove_person)\n    \u00a0\u00a0\u00a0\u00a0, m_RemoveLock(remove_lock)\n    \u00a0\u00a0\u00a0\u00a0, m_RemoveNotified(removeNotified)\n    {\n    \u00a0\u00a0\u00a0\u00a0m_CreateThread = std::thread(&PersonGenerator::runCreating, this);\n    \u00a0\u00a0\u00a0\u00a0m_RemoveThread = std::thread(&PersonGenerator::runRemoving, this);\n    }\n    ```", "```cpp\n    PersonGenerator::~PersonGenerator()\n    {\n    \u00a0\u00a0\u00a0\u00a0if (m_CreateThread.joinable())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_CreateThread.join();\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (m_RemoveThread.joinable())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_RemoveThread.join();\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void PersonGenerator::runCreating()\n    {\n    \u00a0\u00a0\u00a0\u00a0using namespace std::chrono_literals;\n    \u00a0\u00a0\u00a0\u00a0srand (time(NULL));\n    \u00a0\u00a0\u00a0\u00a0while(true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::chrono::duration<int, std::milli> duration((rand() % 10 + 1)*1000);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::this_thread::sleep_for(duration);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"PersonGenerator | runCreating | new person:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_CreatedPersons.add(std::move(Person()));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0notifyCreated();\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void PersonGenerator::runRemoving()\n    {\n    \u00a0\u00a0\u00a0\u00a0using namespace std::chrono_literals;\n    \u00a0\u00a0\u00a0\u00a0srand (time(NULL));\n    \u00a0\u00a0\u00a0\u00a0while(true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::chrono::duration<int, std::milli> duration((rand() % 10 + 20)*1000);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::this_thread::sleep_for(duration);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"PersonGenerator | runRemoving | somebody has left the gallery:\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0notifyRemoved();\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void PersonGenerator::notifyCreated()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::unique_lock<std::mutex> lock(m_AddLock);\n    \u00a0\u00a0\u00a0\u00a0m_AddNotified = true;\n    \u00a0\u00a0\u00a0\u00a0m_CondVarAddPerson.notify_all();\n    }\n    void PersonGenerator::notifyRemoved()\n    {\n    \u00a0\u00a0\u00a0\u00a0std::unique_lock<std::mutex> lock(m_RemoveLock);\n    \u00a0\u00a0\u00a0\u00a0m_RemoveNotified = true;\n    \u00a0\u00a0\u00a0\u00a0m_CondVarRemovePerson.notify_all();\n    }\n    ```", "```cpp\n    #ifndef WATCHMAN_HPP\n    #define WATCHMAN_HPP\n    #include <mutex>\n    #include <thread>\n    #include <condition_variable>\n    #include \"Persons.hpp\"\n    class Watchman\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Watchman(std::condition_variable&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons&,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons&);\n    \u00a0\u00a0\u00a0\u00a0~Watchman();\n    \u00a0\u00a0\u00a0\u00a0Watchman(const Watchman&) = delete;\n    \u00a0\u00a0\u00a0\u00a0Watchman(Watchman&&) = delete;\n    \u00a0\u00a0\u00a0\u00a0Watchman& operator=(const Watchman&) = delete;\n    \u00a0\u00a0\u00a0\u00a0Watchman& operator=(Watchman&&) = delete;\n    private:\n    \u00a0\u00a0\u00a0\u00a0void runAdd();\n    \u00a0\u00a0\u00a0\u00a0void runRemove();\n    private:\n    \u00a0\u00a0\u00a0\u00a0std::thread m_ThreadAdd;\n    \u00a0\u00a0\u00a0\u00a0std::thread m_ThreadRemove;\n    \u00a0\u00a0\u00a0\u00a0std::condition_variable& m_CondVarRemovePerson;\n    \u00a0\u00a0\u00a0\u00a0std::condition_variable& m_CondVarAddPerson;\n    \u00a0\u00a0\u00a0\u00a0std::mutex& m_AddMux;\n    \u00a0\u00a0\u00a0\u00a0std::mutex& m_RemoveMux;\n    \u00a0\u00a0\u00a0\u00a0bool& m_AddNotified;\n    \u00a0\u00a0\u00a0\u00a0bool& m_RemoveNotified;\n    \u00a0\u00a0\u00a0\u00a0Persons& m_PeopleInside;\n    \u00a0\u00a0\u00a0\u00a0Persons& m_PeopleInQueue;\n    \u00a0\u00a0\u00a0\u00a0Persons& m_CreatedPeople;\n    };\n    #endif // WATCHMAN_HPP\n    ```", "```cpp\n    #include \"Watchman.hpp\"\n    #include \"Common.hpp\"\n    #include <iostream>\n    ```", "```cpp\n    Watchman::Watchman(std::condition_variable& addPerson,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable& removePerson,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& addMux,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex& removeMux,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& addNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool& removeNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons& peopleInside,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons& peopleInQueue,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons& createdPeople)\n    \u00a0\u00a0\u00a0\u00a0: m_CondVarRemovePerson(removePerson)\n    \u00a0\u00a0\u00a0\u00a0, m_CondVarAddPerson(addPerson)\n    \u00a0\u00a0\u00a0\u00a0, m_AddMux(addMux)\n    \u00a0\u00a0\u00a0\u00a0, m_RemoveMux(removeMux)\n    \u00a0\u00a0\u00a0\u00a0, m_AddNotified(addNotified)\n    \u00a0\u00a0\u00a0\u00a0, m_RemoveNotified(removeNotified)\n    \u00a0\u00a0\u00a0\u00a0, m_PeopleInside(peopleInside)\n    \u00a0\u00a0\u00a0\u00a0, m_PeopleInQueue(peopleInQueue)\n    \u00a0\u00a0\u00a0\u00a0, m_CreatedPeople(createdPeople)\n    {\n    \u00a0\u00a0\u00a0\u00a0m_ThreadAdd = std::thread(&Watchman::runAdd, this);\n    \u00a0\u00a0\u00a0\u00a0m_ThreadRemove = std::thread(&Watchman::runRemove, this);\n    }\n    ```", "```cpp\n    Watchman::~Watchman()\n    {\n    \u00a0\u00a0\u00a0\u00a0if (m_ThreadAdd.joinable())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_ThreadAdd.join();\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (m_ThreadRemove.joinable())\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_ThreadRemove.join();\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Watchman::runAdd()\n    {\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::unique_lock<std::mutex> locker(m_AddMux);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(!m_AddNotified)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Watchman | runAdd | false awakening\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_CondVarAddPerson.wait(locker);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runAdd | new person came\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_AddNotified = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (m_CreatedPeople.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto person = m_CreatedPeople.get();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInside.size() < CountPeopleInside)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runAdd | welcome in our The Art Gallery\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runAdd | Sorry, we are full. Please wait\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInQueue.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch(const std::string& e)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << e << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runAdd | check people in queue\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInQueue.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (m_PeopleInside.size() < CountPeopleInside)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto person = m_PeopleInQueue.get();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runAdd | welcome in our The Art Gallery\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch(const std::string& e)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << e << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Watchman::runRemove()\n    {\n    \u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::unique_lock<std::mutex> locker(m_RemoveMux);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(!m_RemoveNotified)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cerr << \"Watchman | runRemove | false awakening\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_CondVarRemovePerson.wait(locker);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_RemoveNotified = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInside.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.removePerson();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runRemove | good buy\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runRemove | there is nobody in The Art Gallery\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runRemove | check people in queue\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInQueue.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (m_PeopleInside.size() < CountPeopleInside)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto person = m_PeopleInQueue.get();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Watchman | runRemove | welcome in our The Art Gallery\" << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch(const std::string& e)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << e << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int main()\n    {\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable g_CondVarRemovePerson;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::condition_variable g_CondVarAddPerson;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex g_AddMux;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::mutex g_RemoveMux;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool g_AddNotified = false;;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool g_RemoveNotified = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons g_PeopleInside;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons g_PeopleInQueue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Persons g_CreatedPersons;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PersonGenerator generator(g_CreatedPersons, g_CondVarAddPerson, g_CondVarRemovePerson,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_AddMux, g_RemoveMux, g_AddNotified, g_RemoveNotified);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Watchman watchman(g_CondVarAddPerson,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_CondVarRemovePerson,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_AddMux,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_RemoveMux,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_AddNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_RemoveNotified,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_PeopleInside,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_PeopleInQueue,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0g_CreatedPersons);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0char a;\n    \u00a0\u00a0\u00a0\u00a0std::cin >> a;\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #ifndef LOGGERUTILS_HPP_\n    #define LOGGERUTILS_HPP_\n    #include <string>\n    namespace logger\n    {\n    namespace utils\n    {\n    class LoggerUtils\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getDateTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getThreadId();\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getLoggingLevel(const std::string& level);\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getFileAndLine(const std::string& file, const int& line);\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getFuncName(const std::string& func);\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getInFuncName(const std::string& func);\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::string getOutFuncName(const std::string& func);\n    };\n    } // namespace utils\n    } // namespace logger\n    #endif /* LOGGERUTILS_HPP_ */\n    ```", "```cpp\n    #include \"LoggerUtils.hpp\"\n    #include <sstream>\n    #include <ctime>\n    #include <thread>\n    ```", "```cpp\n    std::string LoggerUtils::getDateTime()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0time_t rawtime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0struct tm * timeinfo;\n    \u00a0\u00a0\u00a0\u00a0\u00a0char buffer[80];\n    \u00a0\u00a0\u00a0\u00a0\u00a0time (&rawtime);\n    \u00a0\u00a0\u00a0\u00a0\u00a0timeinfo = localtime(&rawtime);\n    \u00a0\u00a0\u00a0\u00a0\u00a0strftime(buffer,sizeof(buffer),\"%d-%m-%YT%H:%M:%S\",timeinfo);\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"[\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << buffer;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"]\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getThreadId()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"[\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << std::this_thread::get_id();\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"]\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getLoggingLevel(const std::string& level)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"[\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << level;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"]\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getFileAndLine(const std::string& file, const int& line)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \" \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << file;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \":\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << line;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \":\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getFuncName(const std::string& func)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \" --- \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << func;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"()\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getInFuncName(const std::string& func)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \" --> \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << func;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"()\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    std::string LoggerUtils::getOutFuncName(const std::string& func)\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::stringstream ss;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \" <-- \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << func;\n    \u00a0\u00a0\u00a0\u00a0\u00a0ss << \"()\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0return ss.str();\n    }\n    ```", "```cpp\n    #ifndef LOGGERMACROSES_HPP_\n    #define LOGGERMACROSES_HPP_\n    #define DATETIME \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getDateTime()\n    #define THREAD_ID \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getThreadId()\n    #define LOG_LEVEL( level ) \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getLoggingLevel(level)\n    #define FILE_LINE \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getFileAndLine(__FILE__, __LINE__)\n    #define FUNC_NAME \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getFuncName(__FUNCTION__)\n    #define FUNC_ENTRY_NAME \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getInFuncName(__FUNCTION__)\n    #define FUNC_EXIT_NAME \\\n    \u00a0\u00a0\u00a0\u00a0\u00a0logger::utils::LoggerUtils::getOutFuncName(__FUNCTION__)\n    #endif /* LOGGERMACROSES_HPP_ */\n    ```", "```cpp\n    #include \"LoggerMacroses.hpp\"\n    #include \"LoggerUtils.hpp\"\n    #include <sstream>\n    #include <thread>\n    #include <mutex>\n    ```", "```cpp\n    namespace logger\n    {\n    class StreamLogger : public std::ostringstream\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0\u00a0StreamLogger(const std::string logLevel,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string fileLine,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string funcName);\n    \u00a0\u00a0\u00a0\u00a0\u00a0~StreamLogger();\n    private:\n    \u00a0\u00a0\u00a0\u00a0\u00a0static std::mutex m_mux;\n    \u00a0\u00a0\u00a0\u00a0\u00a0const std::string m_logLevel;\n    \u00a0\u00a0\u00a0\u00a0\u00a0const std::string m_fileLine;\n    \u00a0\u00a0\u00a0\u00a0\u00a0const std::string m_funcName;\n    };\n    } // namespace logger\n    ```", "```cpp\n    #include \"StreamLogger.hpp\"\n    #include <iostream>\n    std::mutex logger::StreamLogger::m_mux;\n    namespace logger\n    {\n    StreamLogger::StreamLogger(const std::string logLevel,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string fileLine,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const std::string funcName)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: m_logLevel(logLevel)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, m_fileLine(fileLine)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0, m_funcName(funcName)\n    {}\n    StreamLogger::~StreamLogger()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0std::lock_guard<std::mutex> lock(m_mux);\n    \u00a0\u00a0\u00a0\u00a0\u00a0if (this->str().empty())\n    \u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << DATETIME << THREAD_ID << m_logLevel << m_fileLine << m_funcName << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << DATETIME << THREAD_ID << m_logLevel << m_fileLine << m_funcName << \" | \" << this->str() << std::endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    }\n    ```", "```cpp\n    #ifndef LOGGER_HPP_\n    #define LOGGER_HPP_\n    #include \"StreamLogger.hpp\"\n    #include \"LoggerMacroses.hpp\"\n    #define LOG_TRACE() logger::StreamLogger{LOG_LEVEL(\"Trace\"), FILE_LINE, FUNC_NAME}\n    #define LOG_DEBUG() logger::StreamLogger{LOG_LEVEL(\"Debug\"), FILE_LINE, FUNC_NAME}\n    #define LOG_WARN() logger::StreamLogger{LOG_LEVEL(\"Warning\"), FILE_LINE, FUNC_NAME}\n    #define LOG_TRACE() logger::StreamLogger{LOG_LEVEL(\"Trace\"), FILE_LINE, FUNC_NAME}\n    #define LOG_INFO() logger::StreamLogger{LOG_LEVEL(\"Info\"), FILE_LINE, FUNC_NAME}\n    #define LOG_ERROR() logger::StreamLogger{LOG_LEVEL(\"Error\"), FILE_LINE, FUNC_NAME}\n    #define LOG_TRACE_ENTRY() logger::StreamLogger{LOG_LEVEL(\"Error\"), FILE_LINE, FUNC_ENTRY_NAME}\n    #define LOG_TRACE_EXIT() logger::StreamLogger{LOG_LEVEL(\"Error\"), FILE_LINE, FUNC_EXIT_NAME}\n    #endif /* LOGGER_HPP_ */\n    ```", "```cpp\n    void Watchman::runAdd()\n    {\n    \u00a0\u00a0\u00a0\u00a0\u00a0while (true)\n    \u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::unique_lock<std::mutex> locker(m_AddMux);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while(!m_AddNotified)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_DEBUG() << \"Spurious awakening\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_CondVarAddPerson.wait(locker);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_INFO() << \"New person came\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_AddNotified = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (m_CreatedPeople.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto person = m_CreatedPeople.get();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInside.size() < CountPeopleInside)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_INFO() << \"Welcome in the our Art Gallery\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_INFO() << \"Sorry, we are full. Please wait\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInQueue.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch(const std::string& e)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_ERROR() << e;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_TRACE() << \"Check people in queue\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (m_PeopleInQueue.size() > 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0while (m_PeopleInside.size() < CountPeopleInside)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto person = m_PeopleInQueue.get();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_INFO() << \"Welcome in the our Art Gallery\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_PeopleInside.add(std::move(person));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0catch(const std::string& e)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LOG_ERROR() << e;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    LOG_ERROR() << e;\n    Or\n    LOG_INFO() << \"Welcome in the our Art Gallery\";\n    ```", "```cpp\n    CONFIGURATION_FILE\n    currencyFile = ./CurrencyConversion.txt\n    recordFile = ./RecordFile.txt\n    DatabaseServer = 192.123.41.112\n    UserId = sqluser\n    Password = sqluser \n    RestApiServer = 101.21.231.11\n    LogFilePath = /var/project/logs\n    ```", "```cpp\n    #ifndef __COMMON_HEADER__H\n    #define __COMMON_HEADER__H\n    #include<iostream>\n    #include<cstring>\n    #include<fstream>\n    #include<vector>\n    #include<string>\n    #include<map>\n    #include<sstream>\n    #include<iterator>\n    #include<algorithm>\n    #include<iomanip>\n    using namespace std;\n    // Forward declaration of global variables. \n    extern string configFile;\n    extern string recordFile;\n    extern string currencyFile;\n    extern map<string, float> currencyMap;\n    struct record;\n    extern vector<record>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vecRecord;\n    //Structure to hold Record Data . \n    struct record{\n    \u00a0\u00a0\u00a0\u00a0int\u00a0\u00a0\u00a0\u00a0\u00a0customerId;\n    \u00a0\u00a0\u00a0\u00a0string\u00a0\u00a0firstName;\n    \u00a0\u00a0\u00a0\u00a0string\u00a0\u00a0lastName;\n    \u00a0\u00a0\u00a0\u00a0int\u00a0\u00a0\u00a0\u00a0\u00a0orderId;\n    \u00a0\u00a0\u00a0\u00a0int\u00a0\u00a0\u00a0\u00a0\u00a0productId;\n    \u00a0\u00a0\u00a0\u00a0int\u00a0\u00a0\u00a0\u00a0\u00a0quantity;\n    \u00a0\u00a0\u00a0\u00a0float\u00a0\u00a0\u00a0totalPriceRegional;\n    \u00a0\u00a0\u00a0\u00a0string\u00a0\u00a0currency;\n    \u00a0\u00a0\u00a0\u00a0float\u00a0\u00a0\u00a0totalPriceUsd;\n\n    \u00a0\u00a0\u00a0\u00a0record(vector<string> & in){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0customerId\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= atoi(in[0].c_str());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0firstName\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= in[1];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastName\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= in[2];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0orderId\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= atoi(in[3].c_str());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0productId\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= atoi(in[4].c_str());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0quantity\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= atoi(in[5].c_str());\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalPriceRegional = static_cast<float>(atof(in[6].c_str()));\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currency\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= in[7];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0totalPriceUsd\u00a0\u00a0\u00a0= static_cast<float>(atof(in[8].c_str()));\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    // Declaration of Utility Functions.. \n    string trim (string &);\n    bool isAllNumbers(const string &);\n    bool isDigit(const string &);\n    void parseLine(ifstream &, vector<string> &, char);\n    bool checkFile(ifstream &, string &, string, char, string &);\n    bool parseConfig();\n    bool parseCurrencyParameters( vector<string> &);\n    bool fillCurrencyMap();\n    bool parseRecordFile();\n    bool checkRecord(vector<string> &);\n    void displayCurrencyMap();\n    ostream& operator<<(ostream &, const record &);\n    void displayRecords();\n    #endif\n    ```", "```cpp\n    #include<CommonHeader.h>\n    // Utility function to remove spaces and tabs from start of string and end of string.. \n    string trim (string &str) { // remove space and tab from string.\n    \u00a0\u00a0\u00a0\u00a0string res(\"\");\n    \u00a0\u00a0\u00a0\u00a0if ((str.find(' ') != string::npos) || (str.find(' ') != string::npos)){ // if space or tab found.. \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t begin, end;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ((begin = str.find_first_not_of(\" \\t\")) != string::npos){ // if string is not empty.. \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end = str.find_last_not_of(\" \\t\");\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ( end >= begin )\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = str.substr(begin, end - begin + 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}else{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0res = str; // No space or tab found.. \n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0str = res;\n    \u00a0\u00a0\u00a0\u00a0return res;\n    }\n    ```", "```cpp\n    // Utility function to check if string contains only digits ( 0-9) and only single '.' \n    // eg . 1121.23 , .113, 121\\. are valid, but 231.14.143 is not valid.\n    bool isAllNumbers(const string &str){ // make sure, it only contains digit and only single '.' if any \n    \u00a0\u00a0\u00a0\u00a0return ( all_of(str.begin(), str.end(), [](char c) { return ( isdigit(c) || (c == '.')); }) \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& (count(str.begin(), str.end(), '.') <= 1) );\n    }\n    //Utility function to check if string contains only digits (0-9).. \n    bool isDigit(const string &str){\n    \u00a0\u00a0\u00a0\u00a0return ( all_of(str.begin(), str.end(), [](char c) { return isdigit(c); }));\n    }\n    // Utility function, where single line of file <infile> is parsed using delimiter. \n    // And store the tokens in vector of string. \n    void parseLine(ifstream &infile, vector<string> & vec, char delimiter){\n    \u00a0\u00a0\u00a0\u00a0string line, token;\n    \u00a0\u00a0\u00a0\u00a0getline(infile, line);\n    \u00a0\u00a0\u00a0\u00a0istringstream ss(line);\n    \u00a0\u00a0\u00a0\u00a0vec.clear();\n    \u00a0\u00a0\u00a0\u00a0while(getline(ss, token, delimiter)) // break line using delimiter\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vec.push_back(token);\u00a0\u00a0// store tokens in vector of string\n    }\n    ```", "```cpp\n    // Utility function to check if vector string of 2 strings contain correct \n    // currency and conversion ratio. currency should be 3 characters, conversion ratio\n    // should be in decimal number format. \n    bool parseCurrencyParameters( vector<string> & vec){\n    \u00a0\u00a0\u00a0\u00a0trim(vec[0]);\u00a0\u00a0trim(vec[1]);\n    \u00a0\u00a0\u00a0\u00a0return ( (!vec[0].empty()) && (vec[0].size() == 3) && (!vec[1].empty()) && (isAllNumbers(vec[1])) );\n    }\n    // Utility function, to check if vector of string has correct format for records parsed from Record File. \n    // CustomerId, OrderId, ProductId, Quantity should be in integer format\n    // TotalPrice Regional and USD should be in decimal number format\n    // Currecny should be present in map. \n    bool checkRecord(vector<string> &split){\n    \u00a0\u00a0\u00a0\u00a0// Trim all string in vector\n    \u00a0\u00a0\u00a0\u00a0for (auto &s : split)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0trim(s);\n\n    \u00a0\u00a0\u00a0\u00a0if ( !(isDigit(split[0]) && isDigit(split[3]) && isDigit(split[4]) && isDigit(split[5])) ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Record with customer id:\" << split[0] << \" doesnt have right DIGIT parameter\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if ( !(isAllNumbers(split[6]) && isAllNumbers(split[8])) ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Record with customer id:\" << split[0] << \" doesnt have right NUMBER parameter\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if ( currencyMap.find(split[7]) == currencyMap.end() ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Record with customer id :\" << split[0] << \" has currency :\" << split[7] << \" not present in map\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    // Function to test initial conditions of file.. \n    // Check if file is present and has correct header information. \n    bool checkFile(ifstream &inFile, string &fileName, string parameter, char delimiter, string &error){\n    \u00a0\u00a0\u00a0\u00a0bool flag = true;\n    \u00a0\u00a0\u00a0\u00a0inFile.open(fileName);\n    \u00a0\u00a0\u00a0\u00a0if ( inFile.fail() ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error = \"Failed opening \" + fileName + \" file, with error: \" + strerror(errno);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (flag){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vector<string> split;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Parse first line as header and make sure it contains parameter as first token. \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseLine(inFile, split, delimiter);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (split.empty()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error = fileName + \" is empty\";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if ( split[0].find(parameter) == string::npos ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error = \"In \" + fileName + \" file, first line doesnt contain header \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return flag;\n    }\n    ```", "```cpp\n    // Function to parse Config file. Each line will have '<name> = <value> format\n    // Store CurrencyConversion file and Record File parameters correctly. \n    bool parseConfig() {\n    \u00a0\u00a0\u00a0\u00a0ifstream coffle;\n    \u00a0\u00a0\u00a0\u00a0string error;\n    \u00a0\u00a0\u00a0\u00a0if (!checkFile(confFile, configFile, \"CONFIGURATION_FILE\", '=', error)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: \" << error << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0bool flag = true;\n    \u00a0\u00a0\u00a0\u00a0vector<string> split;\n    \u00a0\u00a0\u00a0\u00a0while (confFile.good()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseLine(confFile, split, '=');\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ( split.size() == 2 ){ \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string name = trim(split[0]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0string value = trim(split[1]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if ( name == \"currencyFile\" )\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currencyFile = value;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if ( name == \"recordFile\")\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recordFile = value;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if ( currencyFile.empty() || recordFile.empty() ){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR : currencyfile or recordfile not set correctly.\" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return flag;\n    }\n    ```", "```cpp\n    // Function to parse CurrencyConversion file and store values in Map.\n    bool fillCurrencyMap() {\n    \u00a0\u00a0\u00a0\u00a0ifstream currFile;\n    \u00a0\u00a0\u00a0\u00a0string error;\n    \u00a0\u00a0\u00a0\u00a0if (!checkFile(currFile, currencyFile, \"Currency\", '|', error)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: \" << error << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0bool flag = true;\n    \u00a0\u00a0\u00a0\u00a0vector<string> split;\n    \u00a0\u00a0\u00a0\u00a0while (currFile.good()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseLine(currFile, split, '|');\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (split.size() == 2){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (parseCurrencyParameters(split)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0currencyMap[split[0]] = static_cast<float>(atof(split[1].c_str())); // make sure currency is valid.\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Processing Currency Conversion file for Currency: \"<< split[0] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (!split.empty()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Processing Currency Conversion , got incorrect parameters for Currency: \" << split[0] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return flag;\n    }\n    ```", "```cpp\n    // Function to parse Record File .. \n    bool parseRecordFile(){\n    \u00a0\u00a0\u00a0\u00a0ifstream recFile;\n    \u00a0\u00a0\u00a0\u00a0string error;\n    \u00a0\u00a0\u00a0\u00a0if (!checkFile(recFile, recordFile, \"Customer Id\", '|', error)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: \" << error << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0bool flag = true;\n    \u00a0\u00a0\u00a0\u00a0vector<string> split;\n    \u00a0\u00a0\u00a0\u00a0while(recFile.good()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseLine(recFile, split, '|');\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (split.size() == 9){ \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (checkRecord(split)){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vecRecord.push_back(split); //Construct struct record and save it in vector... \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}else{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR : Parsing Record, for Customer Id: \" << split[0] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (!split.empty()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"ERROR: Processing Record, for Customer Id: \" << split[0] << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = false;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return flag;\n    }\n    ```", "```cpp\n    void displayCurrencyMap(){\n\n    \u00a0\u00a0\u00a0\u00a0cout << \"Currency MAP :\" << endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto p : currencyMap)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << p.first <<\"\u00a0\u00a0:\u00a0\u00a0\" << p.second << endl;\n    \u00a0\u00a0\u00a0\u00a0cout << endl;\n    }\n    ostream& operator<<(ostream& os, const record &rec){\n    \u00a0\u00a0\u00a0\u00a0os << rec.customerId <<\"|\" << rec.firstName << \"|\" << rec.lastName << \"|\" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< rec.orderId << \"|\" << rec.productId << \"|\" << rec.quantity << \"|\" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< fixed << setprecision(2) << rec.totalPriceRegional << \"|\" << rec.currency << \"|\" \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<< fixed << setprecision(2) << rec.totalPriceUsd << endl;\n    \u00a0\u00a0\u00a0\u00a0return os;\n    }\n    ```", "```cpp\n    void displayRecords(){\n    \u00a0\u00a0\u00a0\u00a0cout << \" Displaying records with '|' delimiter\" << endl;\n    \u00a0\u00a0\u00a0\u00a0for (auto rec : vecRecord){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << rec;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0cout << endl;\n    }\n    ```", "```cpp\n    #include <CommonHeader.h>\n    // Global variables ... \n    string configFile = \"./parse.conf\";\n    string recordFile;\n    string currencyFile;\n    map<string, float>\u00a0\u00a0currencyMap;\n    vector<record>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vecRecord;\n    int main(){\n    \u00a0\u00a0\u00a0\u00a0// Read Config file to set global configuration variables. \n    \u00a0\u00a0\u00a0\u00a0if (!parseConfig()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"Error parsing Config File \" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0// Read Currency file and fill map\n    \u00a0\u00a0\u00a0\u00a0if (!fillCurrencyMap()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"Error setting CurrencyConversion Map \" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (!parseRecordFile()){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cerr << \"Error parsing Records File \" << endl;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0displayCurrencyMap();\n    \u00a0\u00a0\u00a0\u00a0displayRecords();\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\n    #include<gtest/gtest.h>\n    #include\"../CommonHeader.h\"\n    using namespace std;\n    // Global variables ... \n    string configFile = \"./parse.conf\";\n    string recordFile;\n    string currencyFile;\n    map<string, float>\u00a0\u00a0currencyMap;\n    vector<record>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vecRecord;\n    void setDefault(){\n    \u00a0\u00a0\u00a0\u00a0configFile = \"./parse.conf\";\n    \u00a0\u00a0\u00a0\u00a0recordFile.clear();\n    \u00a0\u00a0\u00a0\u00a0currencyFile.clear();\n    \u00a0\u00a0\u00a0\u00a0currencyMap.clear();\n    \u00a0\u00a0\u00a0\u00a0vecRecord.clear();\n    }\n    // Test Cases for trim function ... \n    TEST(trim, empty){\n    \u00a0\u00a0\u00a0\u00a0string str=\"\u00a0\u00a0\u00a0\u00a0\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string());\n    }\n    TEST(trim, start_space){\n    \u00a0\u00a0\u00a0\u00a0string str = \"\u00a0\u00a0\u00a0adas\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"adas\"));\n    }\n    TEST(trim, end_space){\n    \u00a0\u00a0\u00a0\u00a0string str = \"trip\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"trip\"));\n    }\n    TEST(trim, string_middle){\n    \u00a0\u00a0\u00a0\u00a0string str = \"\u00a0\u00a0hdgf\u00a0\u00a0\u00a0\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"hdgf\"));\n    }\n    TEST(trim, single_char_start){\n    \u00a0\u00a0\u00a0\u00a0string str = \"c\u00a0\u00a0\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"c\"));\n    }\n    TEST(trim, single_char_end){\n    \u00a0\u00a0\u00a0\u00a0string str = \"\u00a0\u00a0\u00a0c\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"c\"));\n    }\n    TEST(trim, single_char_middle){\n    \u00a0\u00a0\u00a0\u00a0string str = \"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c\u00a0\u00a0\";\n    \u00a0\u00a0\u00a0\u00a0EXPECT_EQ(trim(str), string(\"c\"));\n    }\n    ```", "```cpp\n    // Test Cases for isAllNumbers function.. \n    TEST(isNumber, alphabets_present){\n    \u00a0\u00a0\u00a0\u00a0string str = \"11.qwe13\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(isAllNumbers(str));\n    }\n    TEST(isNumber, special_character_present){\n    \u00a0\u00a0\u00a0\u00a0string str = \"34.^%3\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(isAllNumbers(str));\n    }\n    TEST(isNumber, correct_number){\n    \u00a0\u00a0\u00a0\u00a0string str = \"54.765\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(isAllNumbers(str));\n    }\n    TEST(isNumber, decimal_begin){\n    \u00a0\u00a0\u00a0\u00a0string str = \".624\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(isAllNumbers(str));\n    }\n    TEST(isNumber, decimal_end){\n    \u00a0\u00a0\u00a0\u00a0string str = \"53.\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(isAllNumbers(str));\n    }\n    ```", "```cpp\n    // Test Cases for isDigit funtion... \n    TEST(isDigit, alphabet_present){\n    \u00a0\u00a0\u00a0\u00a0string str = \"527A\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(isDigit(str));\n    }\n    TEST(isDigit, decimal_present){\n    \u00a0\u00a0\u00a0\u00a0string str = \"21.55\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(isDigit(str));\n    }\n    TEST(isDigit, correct_digit){\n    \u00a0\u00a0\u00a0\u00a0string str = \"9769\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(isDigit(str));\n    }\n    ```", "```cpp\n    // Test Cases for parseCurrencyParameters function\n    TEST(CurrencyParameters, extra_currency_chararcters){\n    \u00a0\u00a0\u00a0\u00a0vector<string> vec {\"ASAA\",\"34.22\"};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(parseCurrencyParameters(vec));\n    }\n    TEST(CurrencyParameters, correct_parameters){\n    \u00a0\u00a0\u00a0\u00a0vector<string> vec {\"INR\",\"1.44\"};\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(parseCurrencyParameters(vec));\n    }\n    ```", "```cpp\n    //Test Cases for checkFile function...\n    TEST(checkFile, no_file_present){\n    \u00a0\u00a0\u00a0\u00a0string fileName = \"./NoFile\";\n    \u00a0\u00a0\u00a0\u00a0ifstream infile; \n    \u00a0\u00a0\u00a0\u00a0string parameter(\"nothing\");\n    \u00a0\u00a0\u00a0\u00a0char delimit =';';\n    \u00a0\u00a0\u00a0\u00a0string err;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(checkFile(infile, fileName, parameter, delimit, err));\n    }\n    TEST(checkFile, empty_file){\n    \u00a0\u00a0\u00a0\u00a0string fileName = \"./emptyFile\";\n    \u00a0\u00a0\u00a0\u00a0ifstream infile; \n    \u00a0\u00a0\u00a0\u00a0string parameter(\"nothing\");\n    \u00a0\u00a0\u00a0\u00a0char delimit =';';\n    \u00a0\u00a0\u00a0\u00a0string err;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(checkFile(infile, fileName, parameter, delimit, err));\n    }\n    TEST(checkFile, no_header){\n    \u00a0\u00a0\u00a0\u00a0string fileName = \"./noHeaderFile\";\n    \u00a0\u00a0\u00a0\u00a0ifstream infile; \n    \u00a0\u00a0\u00a0\u00a0string parameter(\"header\");\n    \u00a0\u00a0\u00a0\u00a0char delimit ='|';\n    \u00a0\u00a0\u00a0\u00a0string err;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(checkFile(infile, fileName, parameter, delimit, err));\n    }\n    TEST(checkFile, incorrect_header){\n    \u00a0\u00a0\u00a0\u00a0string fileName = \"./correctHeaderFile\";\n    \u00a0\u00a0\u00a0\u00a0ifstream infile; \n    \u00a0\u00a0\u00a0\u00a0string parameter(\"header\");\n    \u00a0\u00a0\u00a0\u00a0char delimit ='|';\n    \u00a0\u00a0\u00a0\u00a0string err;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(checkFile(infile, fileName, parameter, delimit, err));\n    }\n    TEST(checkFile, correct_file){\n    \u00a0\u00a0\u00a0\u00a0string fileName = \"./correctHeaderFile\";\n    \u00a0\u00a0\u00a0\u00a0ifstream infile; \n    \u00a0\u00a0\u00a0\u00a0string parameter(\"Currency\");\n    \u00a0\u00a0\u00a0\u00a0char delimit ='|';\n    \u00a0\u00a0\u00a0\u00a0string err;\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(checkFile(infile, fileName, parameter, delimit, err));\n    }\n    ```", "```cpp\n    //Test Cases for parseConfig function...\n    TEST(parseConfig, missing_currency_file){\n    \u00a0\u00a0\u00a0\u00a0setDefault();\n    \u00a0\u00a0\u00a0\u00a0configFile = \"./parseMissingCurrency.conf\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(parseConfig());\n    }\n    TEST(parseConfig, missing_record_file){\n    \u00a0\u00a0\u00a0\u00a0setDefault();\n    \u00a0\u00a0\u00a0\u00a0configFile = \"./parseMissingRecord.conf\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(parseConfig());\n    }\n    TEST(parseConfig, correct_config_file){\n    \u00a0\u00a0\u00a0\u00a0setDefault();\n    \u00a0\u00a0\u00a0\u00a0configFile = \"./parse.conf\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(parseConfig());\n    }\n    ```", "```cpp\n    //Test Cases for fillCurrencyMap function...\n    TEST(fillCurrencyMap, wrong_delimiter){\n    \u00a0\u00a0\u00a0\u00a0currencyFile = \"./CurrencyWrongDelimiter.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(fillCurrencyMap());\n    }\n    TEST(fillCurrencyMap, extra_column){\n    \u00a0\u00a0\u00a0\u00a0currencyFile = \"./CurrencyExtraColumn.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(fillCurrencyMap());\n    }\n    TEST(fillCurrencyMap, correct_file){\n    \u00a0\u00a0\u00a0\u00a0currencyFile = \"./CurrencyConversion.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(fillCurrencyMap());\n    }\n    ```", "```cpp\n    //Test Cases for parseRecordFile function...\n    TEST(parseRecordFile, wrong_delimiter){\n    \u00a0\u00a0\u00a0\u00a0recordFile = \"./RecordWrongDelimiter.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(parseRecordFile());\n    }\n    TEST(parseRecordFile, extra_column){\n    \u00a0\u00a0\u00a0\u00a0recordFile = \"./RecordExtraColumn.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_FALSE(parseRecordFile());\n    }\n    TEST(parseRecordFile, correct_file){\n    \u00a0\u00a0\u00a0\u00a0recordFile = \"./RecordFile.txt\";\n    \u00a0\u00a0\u00a0\u00a0ASSERT_TRUE(parseRecordFile());\n    }\n    ```", "```cpp\n    g++ -c -g -Wall ../Util.cpp -I../\n    g++ -c -g -Wall ParseFileTestCases.cpp \n    g++ -g -Wall Util.o ParseFileTestCases.o -lgtest -lgtest_main -pthread -o ParseFileTestCases\n    ```", "```cpp\n    ./ParseFileTestCases\n    ```", "```cpp\n    set<string> setDict(vecDict.begin(), vecDict.end());\n    ```", "```cpp\n    vector<int> ret;\n    for(int i = 0; i < vecText.size(); ++i)\n    {\n    \u00a0\u00a0const string &s = vecText[i];\n    \u00a0\u00a0if(!setDict.count(s))\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0ret.push_back(i);\n    \u00a0\u00a0}\n    };\n    ```", "```cpp\n    $ g++ -O3 Speller1.cpp Timer.cpp\n    $ ./a.out\n    ```", "```cpp\n    #include <unordered_set>\n    ```", "```cpp\n    unordered_set<string> setDict(vecDict.begin(), vecDict.end());\n    ```", "```cpp\n    $ g++ -O3 Speller2.cpp Timer.cpp\n    $ ./a.out\n    ```", "```cpp\n    const size_t SIZE = 16777215;\n    template<size_t SEED> size_t hasher(const string &s)\n    {\n    \u00a0\u00a0size_t h = 0;\n    \u00a0\u00a0size_t len = s.size();\n    \u00a0\u00a0for(size_t i = 0; i < len; i++)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0h = h * SEED + s[i];\n    \u00a0\u00a0}\n    \u00a0\u00a0return h & SIZE;\n    }\n    ```", "```cpp\n    vector<bool> m_Bloom;\n    m_Bloom.resize(SIZE);\n    for(auto i = vecDict.begin(); i != vecDict.end(); ++i)\n    {\n    \u00a0\u00a0m_Bloom[hasher<131>(*i)] = true;\n    \u00a0\u00a0m_Bloom[hasher<3131>(*i)] = true;\n    \u00a0\u00a0m_Bloom[hasher<31313>(*i)] = true;\n    }\n    ```", "```cpp\n    for(int i = 0; i < vecText.size(); ++i)\n    {\n    \u00a0\u00a0const string &s = vecText[i];\n    \u00a0\u00a0bool hasNoBloom = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!m_Bloom[hasher<131>(s)] \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&&\u00a0\u00a0!m_Bloom[hasher<3131>(s)]\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&&\u00a0\u00a0!m_Bloom[hasher<31313>(s)];\n\n    \u00a0\u00a0if(hasNoBloom)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0ret.push_back(i);\n    \u00a0\u00a0}\n    \u00a0\u00a0else if(!setDict.count(s))\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0ret.push_back(i);\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    $ g++ -O3 Speller3.cpp Timer.cpp\n    $ ./a.out\n    ```"]