- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4  '
- en: Setting Up Your First CMake Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的第一个 CMake 项目
- en: 'We have now gathered enough information to start talking about the core function
    of CMake: *building projects*. In CMake, a **project** contains all the source
    files and the configuration necessary to manage the process of bringing our solutions
    to life. Configuration starts by performing all the checks: verifying if the target
    platform is supported, ensuring the presence of all essential dependencies and
    tools, and confirming the compatibility of the provided compiler with the required
    features.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们已经收集了足够的信息，可以开始讨论 CMake 的核心功能：*构建项目*。在 CMake 中，**项目**包含了所有源文件以及管理将我们的解决方案付诸实践所需的配置。配置开始时需要执行所有的检查：验证目标平台是否受支持，确保所有必要的依赖项和工具都已存在，并确认所提供的编译器是否与所需的功能兼容。  '
- en: Once the preliminary checks are completed, CMake proceeds to generate a buildsystem
    tailored to the selected build tool. Then, the buildsystem is executed, which
    means compiling the source files and linking them together with their respective
    dependencies to create the output artifacts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦初步检查完成，CMake 将生成一个针对所选构建工具量身定制的构建系统。然后，构建系统将被执行，这意味着编译源代码并将其与相关的依赖项链接在一起，生成最终的构件。  '
- en: The resulting artifacts can be distributed to consumers in different ways. They
    can be shared directly with users as binary packages, allowing them to install
    them on their systems using package managers. Alternatively, they can be distributed
    as single-executable installers. Additionally, end-users have the option to create
    the artifacts themselves by accessing projects shared in an open-source repository.
    In this scenario, users can utilize CMake to compile the projects on their own
    machines and subsequently install them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '生成的构件可以通过不同的方式分发给用户。它们可以作为二进制包直接与用户共享，允许用户通过包管理器将其安装到他们的系统中。或者，它们可以作为单个可执行安装程序进行分发。此外，最终用户也可以通过访问开源仓库中的共享项目来自己创建这些构件。在这种情况下，用户可以利用
    CMake 在自己的机器上编译项目，然后再进行安装。  '
- en: Leveraging CMake projects to their fullest extent can significantly enhance
    the development experience and the overall quality of the generated code. By harnessing
    the power of CMake, numerous mundane tasks can be automated, such as executing
    tests after the build and running code coverage checkers, formatters, validators,
    linters, and other tools. This automation not only saves time but also ensures
    consistency and promotes code quality throughout the development process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '充分利用 CMake 项目可以显著提升开发体验以及生成代码的整体质量。通过利用 CMake 的强大功能，许多繁琐的任务可以被自动化，例如构建后执行测试、运行代码覆盖率检查器、格式化工具、验证器、静态分析工具以及其他工具。这种自动化不仅节省了时间，还确保了开发过程中的一致性，并促进了代码质量的提升。  '
- en: 'To unlock the power of CMake projects, we’ll make a few key decisions first:
    how to correctly configure the project as a whole and how to partition it and
    set up the source tree so that all files are neatly organized in the right directories.
    By establishing a coherent structure and organization from the beginning, the
    CMake project can be effectively managed and scaled as it evolves.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '为了充分发挥 CMake 项目的优势，我们首先需要做出一些关键决策：如何正确配置整个项目，如何划分项目以及如何设置源代码树，以确保所有文件都能整齐地组织在正确的目录中。通过从一开始就建立一个连贯的结构和组织，CMake
    项目可以在开发过程中得到有效管理和扩展。  '
- en: Next up, we’ll take a look at the project’s build environment. We’ll find out
    things like the architecture we’re working with, the tools at our disposal, the
    features they support, and the language standard we’re using. To make sure everything
    is in sync, we’ll compile a test C++ file and see if our chosen compiler meets
    the standard requirements we’ve set for our project. It’s all about ensuring a
    smooth fit between our project, the tools we’re using, and the standards we’ve
    chosen.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们将了解项目的构建环境。我们将探讨诸如我们使用的架构、可用的工具、它们支持的功能以及我们正在使用的语言标准等内容。为了确保一切都同步，我们将编译一个测试用的
    C++ 文件，并查看我们选择的编译器是否符合我们为项目设定的标准要求。这一切都旨在确保我们的项目、所使用的工具以及选择的标准能够顺利配合。  '
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将涵盖以下主要内容：  '
- en: Understanding the basic directives and commands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '理解基本的指令和命令  '
- en: Partitioning your project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '划分你的项目  '
- en: Thinking about the project structure
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '思考项目结构  '
- en: Scoping the environment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '确定环境作用域  '
- en: Configuring the toolchain
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '配置工具链  '
- en: Disabling in-source builds
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '禁用源代码内构建  '
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '技术要求  '
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch04](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch04).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中出现的代码文件，链接为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch04](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch04)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符 `<build tree>` 和 `<source tree>` 替换为适当的路径。提醒一下：**build tree** 是目标/输出目录的路径，**source
    tree** 是源代码所在的路径。
- en: Understanding the basic directives and commands
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的指令和命令
- en: 'In *Chapter 1*, *First Steps with CMake*, we already looked at a simple project
    definition. Let’s revisit it. It is a directory with a `CMakeLists.txt` file that
    contains a few commands configuring the language processor:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 1 章*，*CMake 入门*中，我们已经看过了一个简单的项目定义。让我们再来回顾一下。它是一个包含几个配置语言处理器命令的 `CMakeLists.txt`
    文件的目录：
- en: '**chapter01/01-hello/CMakeLists.txt**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**chapter01/01-hello/CMakeLists.txt**'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the same chapter, in the section named *Project files*, we learned about
    a few basic commands. Let’s explain them in depth here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章节中，在名为*项目文件*的部分中，我们学习了一些基本命令。这里我们将深入解释它们。
- en: Specifying the minimum CMake version
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定最低的 CMake 版本
- en: It’s important to use the `cmake_minimum_required()` command at the very top
    of your project files and scripts. This command not only verifies if the system
    has the correct CMake version but also implicitly triggers another command, `cmake_policy(VERSION)`,
    which specifies the policies to be used for the project. These policies define
    how commands behave within CMake, and they have been introduced over the course
    of CMake’s development to accommodate changes and improvements in the supported
    languages and CMake itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件和脚本的最顶部使用 `cmake_minimum_required()` 命令非常重要。该命令不仅验证系统是否具有正确版本的 CMake，还隐式触发另一个命令
    `cmake_policy(VERSION)`，该命令指定用于项目的策略。这些策略定义了 CMake 中命令的行为，它们是在 CMake 发展的过程中引入的，以适应支持的语言和
    CMake 本身的变化和改进。
- en: To keep the language clean and simple, the CMake team introduced policies whenever
    there was a backward-incompatible change. Each policy enables the new behavior
    associated with that change. These policies ensure that projects can adapt to
    the evolving features and functionalities of CMake, while preserving compatibility
    with older codebases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持语言的简洁，CMake 团队每当出现不兼容的更改时，就引入了新的策略。每个策略启用了与该更改相关的新行为。这些策略确保项目能够适应 CMake
    不断发展的特性和功能，同时保持与旧代码库的兼容性。
- en: By calling `cmake_minimum_required()`, we tell CMake that it needs to apply
    the default policies configured at the version provided in the argument. When
    CMake gets upgraded, we don’t need to worry about it breaking our project, as
    the new policies coming with the new version won’t be enabled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `cmake_minimum_required()`，我们告诉 CMake 需要根据参数中提供的版本应用默认策略。当 CMake 升级时，我们无需担心它会破坏我们的项目，因为新版本附带的新策略不会被启用。
- en: Policies can affect every single aspect of CMake, including other important
    commands like `project()`. For that reason, it is important to start your `CMakeLists.txt`
    file by setting the version you’re working with. Otherwise, you will get warnings
    and errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以影响 CMake 的各个方面，包括其他重要命令，如 `project()`。因此，重要的是在 `CMakeLists.txt` 文件中首先设置你正在使用的版本。否则，你将收到警告和错误。
- en: 'Each CMake version introduces numerous policies. However, it’s not necessary
    to delve into details unless you encounter challenges when upgrading older projects
    to the latest CMake version. In such cases, it is recommended to refer to the
    official documentation on policies for comprehensive information and guidance:
    [https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 CMake 版本都会引入大量策略。然而，除非你在将旧项目升级到最新 CMake 版本时遇到问题，否则不必深入了解这些策略的细节。在这种情况下，建议参考官方文档，获取有关策略的全面信息和指导：[https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html)。
- en: Defining languages and metadata
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义语言和元数据
- en: 'It’s recommended to put the `project()` command just after `cmake_minimum_required()`,
    even though it’s technically not. Doing so will ensure that we use the right policies
    when configuring the project. We can use one of its two forms:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从技术上讲，`project()` 命令并不一定要放在 `cmake_minimum_required()` 之后，但建议将其放在该位置。这样做可以确保我们在配置项目时使用正确的策略。我们可以使用它的两种形式之一：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to specify `<PROJECT-NAME>`, but the other arguments are optional.
    Calling this command will implicitly set the following variables:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定 `<PROJECT-NAME>`，但其他参数是可选的。调用此命令将隐式设置以下变量：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What languages are supported? Quite a few. And you can use more than one at
    a time! Here’s a list of language keywords you can use to configure your project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 支持哪些语言？相当多。而且你可以同时使用多个语言！以下是你可以用来配置项目的语言关键字列表：
- en: '`ASM, ASM_NASM, ASM_MASM, ASMMARMASM, ASM-ATT`: Dialects of Assembler'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ASM, ASM_NASM, ASM_MASM, ASMMARMASM, ASM-ATT`: 汇编语言的方言'
- en: '`C`: C'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`: C'
- en: '`CXX`: C++'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX`: C++'
- en: '`CUDA`: Compute Unified Device Architecture by Nvidia'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CUDA`: Nvidia 的统一计算设备架构'
- en: '`OBJC`: Objective-C'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJC`: Objective-C'
- en: '`OBJCXX`: Objective-C++'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJCXX`: Objective-C++'
- en: '`Fortran`: Fortran'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fortran`: Fortran'
- en: '`HIP`: Heterogeneous(-compute) Interface for Portability (for Nvidia and AMD
    platforms)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIP`: 跨平台异构计算接口（适用于 Nvidia 和 AMD 平台）'
- en: '`ISPC`: Implicit SPMD Program Compiler’s language'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISPC`: 隐式 SPMD 程序编译器语言'
- en: '`CSharp`: C#'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSharp`: C#'
- en: '`Java`: Java (requires extra steps, see official documentation)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Java`: Java（需要额外的步骤，请参阅官方文档）'
- en: CMake enables both C and C++ by default, so you may want to explicitly specify
    only `CXX` for your C++ projects. Why? The `project()` command will detect and
    test the available compilers for your chosen language, so stating the required
    ones will allow you to save time during the configuration stage, by skipping any
    checks for unused languages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 默认启用 C 和 C++，所以你可能需要明确指定只使用 `CXX` 来配置你的 C++ 项目。为什么？`project()` 命令会检测并测试你选择的语言所支持的编译器，因此声明所需的语言可以帮助你在配置阶段节省时间，跳过不必要的语言检查。
- en: 'Specifying the `VERSION` keyword will automatically set the variables that
    can be used to configure packages, or exposed in the header files to be consumed
    during the compilation (we’ll cover this in the *Configuring the headers* section
    of *Chapter 7*, *Compiling C++ Sources with CMake*):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 `VERSION` 关键字将自动设置可以用于配置包或在头文件中暴露以供编译期间使用的变量（我们将在 *第7章*，*使用 CMake 编译 C++
    源代码* 的 *配置头文件* 部分中讲解）：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also set `DESCRIPTION` and `HOMEPAGE_URL`, which will set the following
    variables for similar purposes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置 `DESCRIPTION` 和 `HOMEPAGE_URL`，这将为类似的目的设置以下变量：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `cmake_minimum_required()` and `project()` commands will allow us to create
    a basic listfile and initialize an empty project. While the structure may not
    have been a significant concern for the small, single-file projects, it becomes
    crucial as the codebase expands. How do you prepare for that?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake_minimum_required()` 和 `project()` 命令将允许我们创建一个基本的列表文件并初始化一个空项目。虽然对于小型单文件项目，结构可能不那么重要，但随着代码库的扩展，这变得至关重要。你如何为此做准备？'
- en: Partitioning your project
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 划分你的项目
- en: 'As our solutions grow in terms of lines of code and the number of files they
    contain, it becomes apparent that we must address the looming challenge: either
    we begin partitioning the project, or risk being overwhelmed by its complexity.
    There are two ways we can tackle this problem: splitting the CMake code and relocating
    the source files to subdirectories. In both cases, we aim to follow the design
    principle called **separation of concerns**. Put simply, we break down the code
    into smaller parts, grouping together closely related functionality while keeping
    other pieces of code separate to establish clear boundaries.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的解决方案在代码行数和文件数量上的增长，我们很快意识到必须解决一个迫在眉睫的挑战：要么开始划分项目，要么面临被复杂性淹没的风险。我们可以通过两种方式解决这个问题：拆分
    CMake 代码和将源文件移动到子目录中。在这两种情况下，我们的目标都是遵循名为 **关注点分离** 的设计原则。简而言之，我们将代码拆分为更小的部分，将密切相关的功能组合在一起，同时保持其他代码部分分离，以建立清晰的边界。
- en: We talked a bit about partitioning CMake code when discussing listfiles in *Chapter
    1*, *First Steps with CMake*. We spoke about the `include()` command, which allows
    CMake to execute the code from an external file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *第1章*，*CMake 入门* 中谈到了划分 CMake 代码时讨论的列表文件。我们讲解了 `include()` 命令，它允许 CMake
    执行来自外部文件的代码。
- en: This method helps with the separation of concerns, but only a little – specialized
    code is extracted to separate files and can even be shared across unrelated projects,
    but it can still pollute the global variable scope with its internal logic, if
    the author is not careful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有助于关注点分离，但仅仅有一点点——专门的代码被提取到独立的文件中，甚至可以跨不相关的项目共享，但如果作者不小心，它仍然可能污染全局变量作用域，带入其中的内部逻辑。
- en: 'You see, calling `include()` doesn’t introduce any additional scopes or isolations
    beyond what is already defined within the file. Let’s see why this is a potential
    problem by considering an example, a piece of software that supports a small car
    rental company. It will have many source files defining different aspects of the
    software: managing customers, cars, parking spots, long-term contracts, maintenance
    records, employee records, and so on. If we were to put all these files in a single
    directory, finding anything would be a nightmare. Therefore, we create a number
    of directories in the main directory of our project and move the related files
    inside it. Our `CMakeLists.txt` file might look similar to this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，调用`include()`并不会引入任何额外的作用域或隔离，超出文件内已经定义的内容。让我们通过一个例子来看这个潜在问题，假设有一个支持小型汽车租赁公司的软件，它将包含许多源文件，定义软件的不同方面：管理客户、汽车、停车位、长期合同、维修记录、员工记录等等。如果我们将所有这些文件放在一个目录中，查找任何文件都会是一场噩梦。因此，我们在项目的主目录中创建了多个目录，并将相关文件移到其中。我们的`CMakeLists.txt`文件可能看起来像这样：
- en: '**ch04/01-partition/CMakeLists.txt**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/01-partition/CMakeLists.txt**'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s all great, but as you can see, we still have the list of source files
    from the nested directory in a top-level file! To increase the separation of concerns,
    we could extract the list of sources to another listfile and store it in a `sources`
    variable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很好，但正如你所看到的，我们仍然在顶层文件中包含了来自嵌套目录的源文件列表！为了增加关注点分离，我们可以将源列表提取到另一个listfile中，并将其存储在`sources`变量中：
- en: '**ch04/02-include/cars/cars.cmake**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/02-include/cars/cars.cmake**'
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can reference this file with the `include()` command to gain access
    to the `sources` variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`include()`命令引用这个文件，以访问`sources`变量：
- en: '**ch04/02-include/CMakeLists.txt**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/02-include/CMakeLists.txt**'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'CMake would effectively set `sources` in the same scope as `add_executable`,
    filling the variable with all the files. This solution works, but it has a few
    flaws:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CMake实际上会将`sources`设置为与`add_executable`相同的作用域，并将变量填充为所有文件。这个解决方案是可行的，但也有一些缺陷：
- en: '**The variables from the nested directory will pollute the top-level scope
    (and vice versa)**:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套目录中的变量会污染顶层作用域（反之亦然）**：'
- en: While it’s not an issue in a simple example, in more complex, multi-level trees
    with multiple variables used in the process, it can quickly become a hard-to-debug
    problem. What if we have multiple included listfiles that define their `sources`
    variable?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在一个简单的例子中并不是问题，但在更复杂的多级树结构中，尤其是过程中使用了多个变量时，它很容易变成一个难以调试的问题。如果我们有多个包含的 listfile，它们定义了各自的`sources`变量，该怎么办？
- en: '**All of the directories will share the same configuration**:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有目录将共享相同的配置**：'
- en: This issue shows its true colors as projects mature over the years. Without
    any granularity, we have to treat every source file the same, and we cannot specify
    different compilation flags, choose a newer language version for some parts of
    the code, and silence warnings in chosen areas of the code. Everything is global,
    meaning that we need to introduce changes to all of the translation units at the
    same time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的成熟，这个问题会显现出来。如果没有任何粒度控制，我们只能将每个源文件视为相同，无法为某些代码部分指定不同的编译标志，选择更新的语言版本，或在代码的特定区域消除警告。所有内容都是全局的，这意味着我们需要同时对所有翻译单元进行更改。
- en: '**There are shared compilation triggers**:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这里有共享的编译触发器**：'
- en: Any changes to the configuration will mean that all the files will have to be
    recompiled, even if the change is meaningless for some of them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对配置的任何更改都会导致所有文件必须重新编译，即使这些更改对其中一些文件来说毫无意义。
- en: '**All the paths are relative to the top level**:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有路径都是相对于顶层的**：'
- en: Note that in `cars.cmake`, we had to provide a full path to the `cars/car.cpp`
    file. This results in a lot of repeated text ruining the readability and going
    against the **Don’t Repeat Yourself** (**DRY**) principle of clean coding (unnecessary
    repetition leads to mistakes). Renaming a directory would be a struggle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`cars.cmake`中，我们必须提供`cars/car.cpp`文件的完整路径。这导致了大量重复的文本，破坏了可读性，也违反了**不要重复自己**（**DRY**）的干净代码原则（不必要的重复容易导致错误）。重命名一个目录将变得非常困难。
- en: The alternative is to use the `add_subdirectory()` command, which introduces
    a variable scope and more. Let’s take a look.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`add_subdirectory()`命令，它引入了变量作用域等。让我们来看看。
- en: Managing scope with subdirectories
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子目录管理作用域
- en: 'It’s a common practice to structure your project following the natural structure
    of the filesystem, where nested directories represent the discrete elements of
    the application, the business logic, GUI, API, and reporting, and finally, separate
    directories with tests, external dependencies, scripts, and documentation. To
    support this concept, CMake offers the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目结构中，按照文件系统的自然结构来组织项目是一种常见做法，其中嵌套的目录表示应用程序的离散元素，如业务逻辑、图形用户界面（GUI）、API 和报告，最后是单独的测试、外部依赖、脚本和文档目录。为了支持这一概念，CMake
    提供了以下命令：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As already established, this adds a source directory to our build. Optionally,
    we may provide a path that built files will be written to (`binary_dir` or the
    build tree). The `EXCLUDE_FROM_ALL` keyword will disable the automatic building
    of targets defined in the subdirectory (we’ll cover **targets** in the next chapter).
    This may be useful for separating parts of the project that aren’t needed for
    the core functionality (like *examples* or *extensions*).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，这将把源目录添加到我们的构建中。可选地，我们可以提供一个路径，将构建的文件写入该路径（`binary_dir`或构建树）。`EXCLUDE_FROM_ALL`关键字将禁用自动构建子目录中定义的目标（我们将在下一章中讨论**目标**）。这对于将项目中不需要用于核心功能的部分（如*示例*或*扩展*）分离开来非常有用。
- en: '`add_subdirectory()` will evaluate the `source_dir` path (relative to the current
    directory) and parse the `CMakeLists.txt` file in it. This file is parsed within
    the directory scope, eliminating the issues mentioned in the previous method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_subdirectory()`将评估`source_dir`路径（相对于当前目录），并解析其中的`CMakeLists.txt`文件。这个文件将在目录作用域内进行解析，从而消除了前述方法中的问题：'
- en: Variables are isolated to the nested scope.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量被隔离在嵌套的作用域中。
- en: The nested artifacts can be configured independently.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套的产物可以独立配置。
- en: Modifying the nested `CMakeLists.txt` file doesn’t require rebuilding unrelated
    targets.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改嵌套的`CMakeLists.txt`文件不需要重新构建不相关的目标。
- en: Paths are localized to the directory and can be added to the parent **include
    path** if desired.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径是本地化到目录的，如果需要，也可以将其添加到父级**包含路径**中。
- en: 'This is what the directory structure looks like for our `add_subdirectory()`
    example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`add_subdirectory()`示例的目录结构：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we have two `CMakeLists.txt` files. The top-level file will use the nested
    directory, `cars`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个`CMakeLists.txt`文件。顶层文件将使用嵌套目录`cars`：
- en: '**ch04/03-add_subdirectory/CMakeLists.txt**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/03-add_subdirectory/CMakeLists.txt**'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last line is used to link the artifacts from the `cars` directory to the
    `Rental` executable. It is a target-specific command, which we’ll discuss in depth
    in the next chapter: *Chapter 5*, *Working with Targets*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行用于将`cars`目录中的产物链接到`Rental`可执行文件。这是一个特定于目标的命令，我们将在下一章中详细讨论：*第5章*，*与目标一起工作*。
- en: 'Let’s see what the nested listfile looks like:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看嵌套的列表文件长什么样：
- en: '**ch04/03-add_subdirectory/cars/CMakeLists.txt**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/03-add_subdirectory/cars/CMakeLists.txt**'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, I have used `add_library()` to produce a globally visible
    **target** `cars`, and added the `cars` directory to its public **include directories**
    with `target_include_directories()`. This informs CMake where the `cars.h` resides,
    so when `target_link_libraries()` is used, the `main.cpp` file can consume the
    header without providing a relative path:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用了`add_library()`来生成一个全局可见的**目标**`cars`，并通过`target_include_directories()`将`cars`目录添加到其公共**包含目录**中。这告诉
    CMake `cars.h`文件的位置，因此在使用`target_link_libraries()`时，`main.cpp`文件可以直接使用头文件而无需提供相对路径：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see the `add_library()` command in the nested listfile, so did we start
    working with libraries in this example? Actually, no. Since we used the `OBJECT`
    keyword, we’re indicating we’re only interested in producing the **object files**
    (exactly as we did in the previous example). We just grouped them under a single
    logical target (`cars`). You may already have a sense of what a **target** is.
    Hold that thought – we’ll explain the details in the next chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在嵌套列表文件中看到`add_library()`命令，那么在这个示例中我们是否开始使用库了呢？其实没有。因为我们使用了`OBJECT`关键字，我们表示我们只关心生成**目标文件**（就像在之前的示例中那样）。我们只是将它们归类到一个单独的逻辑目标（`cars`）下。你可能已经对**目标**有了初步的了解。保持这个想法——我们将在下一章详细解释。
- en: When to use nested projects
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用嵌套项目
- en: In the previous section, we briefly mentioned the `EXCLUDE_FROM_ALL` argument
    used in the `add_subdirectory()` command to indicate extraneous elements of our
    codebase. The CMake documentation suggests that if we have such parts living inside
    the source tree, they should have their own `project()` commands in their `CMakeLists.txt`
    files so that they can generate their own buildsystems and can be built independently.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们简要提到了 `add_subdirectory()` 命令中使用的 `EXCLUDE_FROM_ALL` 参数，用来标识我们代码库中的附加元素。CMake
    文档建议，如果这些部分存在于源代码树中，它们应该在各自的 `CMakeLists.txt` 文件中有自己的 `project()` 命令，这样它们就可以生成自己的构建系统，并且可以独立构建。
- en: Are there any other scenarios where this would be useful? Sure. For example,
    one scenario would be when you’re working with multiple C++ projects built in
    one **CI**/**CD** pipeline (perhaps when building a framework or a set of libraries).
    Alternatively, maybe you’re porting the buildsystem from a legacy solution, such
    as GNU Make, which uses plain **makefiles**. In such a case, you might want an
    option to slowly break things down into more independent pieces – possibly to
    put them in a separate build pipeline, or just to work on a smaller scope, which
    could be loaded by an IDE such as **CLion**. You can achieve that by adding the
    `project()` command to the listfile in the nested directory. Just don’t forget
    to prepend it with `cmake_minimum_required()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他场景会有用吗？当然。例如，一个场景是在你与多个 C++ 项目合作，它们在一个 **CI**/**CD** 管道中构建（可能是在构建一个框架或一组库时）。或者，可能是你正在将构建系统从一个遗留的解决方案（例如
    GNU Make）迁移过来，它使用普通的 **makefile**。在这种情况下，你可能希望有一个选项，逐步将它们拆解成更独立的部分——可能是将它们放入一个独立的构建管道，或者仅仅是在一个更小的范围内工作，IDE
    如 **CLion** 可以加载它们。你可以通过在嵌套目录中的列表文件中添加 `project()` 命令来实现这一点。只需别忘了在前面加上 `cmake_minimum_required()`。
- en: Since project nesting is supported, could we somehow connect related projects
    that are built side by side?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于支持项目嵌套，我们是否可以以某种方式将并行构建的相关项目连接起来？
- en: Keeping external projects external
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持外部项目为外部项目
- en: 'While it is technically possible to reference the internals of one project
    from another in CMake, it is not a regular or recommended practice. CMake does
    provide some support for this, including the `load_cache()` command to load values
    from another project’s cache. However, using this approach can result in problems
    with cyclical dependencies and project coupling. It’s best to avoid this command
    and make a decision: should our related projects be nested, connected through
    libraries, or merged into a single project?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲，在 CMake 中引用一个项目的内部内容到另一个项目是可能的，但这并不是常规做法，也不推荐这样做。CMake 确实提供了一些支持，包括
    `load_cache()` 命令用于从另一个项目的缓存中加载值。然而，使用这种方法可能会导致循环依赖和项目耦合的问题。最好避免使用这个命令，并做出决定：我们的相关项目应该嵌套在一起，通过库连接，还是合并为一个单独的项目？
- en: 'These are the partitioning tools at our disposal: *including listfiles*, *adding
    subdirectories*, and *nesting projects*. But how should we use them so our projects
    stay maintainable and easy to navigate and extend? To do this, we need a well-defined
    project structure.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使用的分区工具：*包含列表文件*，*添加子目录* 和 *嵌套项目*。那么我们该如何使用它们，才能让我们的项目保持可维护、易于导航和扩展呢？为了做到这一点，我们需要一个明确定义的项目结构。
- en: Thinking about the project structure
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考项目结构
- en: It’s no secret that as a project grows, it becomes harder and harder to find
    things in it – both in listfiles and in the source code. Therefore, it is very
    important to maintain the project hygiene right from the start.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不是什么秘密，随着项目的增长，找到其中的内容会变得越来越困难——无论是在列表文件中还是在源代码中。因此，从一开始就保持项目的清晰性非常重要。
- en: Imagine a scenario where you need to deliver some important, time-sensitive
    changes, and they don’t fit well in either of the two directories in your project.
    Now, you need to additionally push a *cleanup commit* to restructure the file
    hierarchy to fit your changes neatly. Or, worse, you decide to just shove them
    anywhere and add a TODO to deal with the issue later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有这样一个场景，你需要交付一些重要且时间紧迫的变更，而这些变更在项目中的两个目录里都不太适合。现在，你需要额外推送一个 *清理提交*，以重构文件层次结构，使其更适合你的更改。或者，更糟的是，你决定将它们随便放在任何地方，并添加一个
    TODO，计划以后再处理这个问题。
- en: Over the course of the year, these problems accumulate, the technical debt grows,
    and so does the cost of maintaining the code. This becomes extremely troublesome
    when there’s a crippling bug in a live system that needs a quick fix or when people
    unfamiliar with the codebase need to introduce occasional changes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在一年中的过程中，这些问题不断积累，技术债务也在增长，维护代码的成本也随之增加。当在生产环境中出现严重漏洞需要快速修复时，或者当不熟悉代码库的人需要进行偶尔的更改时，这种情况会变得非常麻烦。
- en: 'So, we need a good project structure. But what does this mean? There are a
    few rules that we can borrow from other areas of software development like system
    design. The project should have the following characteristics:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个好的项目结构。那么这意味着什么呢？我们可以借鉴软件开发中其他领域（如系统设计）的一些规则。项目应具有以下特征：
- en: Easy to navigate and extend
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于导航和扩展
- en: Well bounded (project-specific files should be contained to the project directory)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界清晰（项目特定的文件应仅包含在项目目录中）
- en: Individual targets follow the hierarchical tree
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的目标遵循层次树结构
- en: 'There isn’t one definitive solution, but out of the various project structure
    templates available online, I suggest using this one as it is simple and extensible:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有唯一的解决方案，但在各种在线项目结构模板中，我建议使用这个模板，因为它简单且具有可扩展性：
- en: '![](img/B19844_04_01.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_04_01.png)'
- en: 'Figure 4.1: An example of a project structure'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：项目结构示例
- en: 'This project outlines the directories for the following components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目概述了以下组件的目录：
- en: '`cmake`: Shared macros and functions, find_modules, and one-off scripts'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`：共享宏和函数、find_modules，以及一次性脚本'
- en: '`src`: Source and header files for binaries and libraries'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：二进制文件和库的源文件和头文件'
- en: '`test`: Source code for automated tests'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：自动化测试的源代码'
- en: 'In this structure, the `CMakeLists.txt` file should exist in the following
    directories: the top-level project directory, `test`, and `src` and all its subdirectories.
    The main listfile shouldn’t declare any build steps on its own, but instead, it
    should configure the general aspects of the project and delegate the responsibility
    of building to the nested listfiles with the `add_subdirectory()` command. In
    turn, these listfiles may delegate this work to even deeper layers if needed.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，`CMakeLists.txt` 文件应该存在于以下目录中：顶层项目目录、`test`、`src` 以及所有其子目录。主列表文件不应该自己声明任何构建步骤，而是应配置项目的一般设置，并通过
    `add_subdirectory()` 命令将构建责任委托给嵌套的列表文件。这些列表文件如果需要，还可以将工作委托给更深层次的列表文件。
- en: 'Some developers suggest separating the executables from the libraries and creating
    two top-level directories instead of one: `src` and `lib`. CMake treats both artifacts
    the same, and separation at this level doesn’t really matter. Feel free to follow
    that model if it’s your preference.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者建议将可执行文件和库分开，创建两个顶级目录而不是一个：`src` 和 `lib`。CMake 对这两种工件的处理是相同的，在这个层级上的分离其实并不重要。如果你喜欢这种模型，可以随意使用它。
- en: 'Having multiple directories in the `src` directory comes in handy for bigger
    projects. But if you’re building just a single executable or library, you may
    skip them and store your source files directly in `src`. In any case, remember
    to add a `CMakeLists.txt` file there and execute any nested listfiles as well.
    This is how your file tree might look for a single, simple target:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 目录中拥有多个子目录对于大型项目非常有用。但如果你只构建一个单一的可执行文件或库，你可以跳过这些子目录，直接将源文件存储在 `src`
    中。无论如何，记得在那里添加一个 `CMakeLists.txt` 文件，并执行任何嵌套的列表文件。这是你一个简单目标的文件树结构示例：
- en: '![](img/B19844_04_02.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_04_02.png)'
- en: 'Figure 4.2: The directory structure of an executable'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：可执行文件的目录结构
- en: 'In *Figure 4.1*, we see a `CMakeLists.txt` file in the root of the `src` directory
    – it will configure the key project settings and include all listfiles from nested
    directories. The `app1` directory (visible in *Figure 4.2*) contains another `CMakeLists.txt`
    file along with the `.cpp` implementation files: `class_a.cpp` and `class_b.cpp`.
    There’s also the `main.cpp` file with the executable’s entry point. The `CMakeLists.txt`
    file should define a target that uses these sources to build an executable – again,
    we’ll learn how to do that in the next chapter.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.1* 中，我们看到 `src` 目录根目录下有一个 `CMakeLists.txt` 文件 – 它将配置关键的项目设置，并包含所有来自嵌套目录的列表文件。`app1`
    目录（在 *图 4.2* 中可见）包含另一个 `CMakeLists.txt` 文件，以及 `.cpp` 实现文件：`class_a.cpp` 和 `class_b.cpp`。还有一个包含可执行程序入口点的
    `main.cpp` 文件。`CMakeLists.txt` 文件应该定义一个目标，使用这些源文件来构建一个可执行文件 – 接下来的一章中我们将学习如何做到这一点。
- en: Our header files are placed in the `include` directory and can be used to declare
    symbols for other C++ translation units.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的头文件被放置在`include`目录中，可以用于为其他C++翻译单元声明符号。
- en: 'Next, we have a `lib3` directory, which contains a library specific to this
    executable only (libraries used elsewhere in the project or exported externally
    should live in the `src` directory). This structure offers great flexibility and
    allows for easy project extensions. As we continue adding more classes, we can
    conveniently group them into libraries to improve compilation speed. Let’s see
    what a library looks like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`lib3`目录，它包含专门用于该可执行文件的库（在项目其他地方或外部使用的库应该位于`src`目录中）。这种结构提供了极大的灵活性，并且允许轻松扩展项目。当我们继续添加更多类时，我们可以方便地将它们分组到库中，以提高编译速度。让我们看看一个库是怎样的：
- en: '![](img/B19844_04_03.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_04_03.png)'
- en: 'Figure 4.3: The directory structure of a library'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：库的目录结构
- en: 'Libraries should adhere to the same structure as executables, with a minor
    distinction: an optional `lib1` directory is added to the include directory. This
    directory is included when the library is intended for external use beyond the
    project. It contains public header files that other projects will consume during
    compilation. We’ll return to this subject when we start building our own libraries
    in *Chapter 7*, *Compiling C++ Sources with CMake.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 库应遵循与可执行文件相同的结构，但有一个小区别：一个可选的`lib1`目录被添加到包含目录中。当库计划在项目外部使用时，该目录会被包含。它包含其他项目在编译过程中将使用的公共头文件。当我们开始构建自己的库时，我们将在*第7章*，*使用CMake编译C++源文件*中进一步讨论这个话题。
- en: So, we have discussed how files are laid out in a directory structure. Now,
    it’s time to take a look at how individual `CMakeLists.txt` files come together
    to form a single project and what their role is in a bigger scenario.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经讨论了文件在目录结构中的布局方式。现在，是时候看看各个`CMakeLists.txt`文件是如何汇聚在一起形成一个完整的项目，并且它们在更大场景中的作用是什么。
- en: '![](img/B19844_04_04.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_04_04.png)'
- en: 'Figure 4.4: How CMake merges listfiles together in a single project'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：CMake如何在一个项目中合并列表文件
- en: 'In the preceding figure, each box represents a `CMakeLists.txt` listfile residing
    in each directory, while the labels in italics represent the actions executed
    by each file (from top to bottom). Let’s analyze this project once more from CMake’s
    perspective (for all the details, look at the example in the `ch04/05-structure`
    directory):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，每个框表示一个`CMakeLists.txt`列表文件，位于每个目录中，而斜体标签表示每个文件执行的操作（从上到下）。让我们从CMake的角度再次分析这个项目（有关所有详细信息，请查看`ch04/05-structure`目录中的示例）：
- en: The execution starts from the root of the project – that is, from a `CMakeLists.txt`
    listfile residing at the top of the source tree. This file will set the minimum
    required CMake version with the appropriate policies, set the project name, supported
    languages, and global variables, and include the files from the `cmake` directory,
    so that their contents are available globally.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行从项目根目录开始——也就是从位于源代码树顶部的`CMakeLists.txt`列表文件开始。该文件将设置CMake的最低要求版本及适当的策略，设置项目名称、支持的语言和全局变量，并包含`cmake`目录中的文件，以便它们的内容在全局范围内可用。
- en: The next step is to enter the scope of the `src` directory by calling the `add_subdirectory(src
    bin)` command (we’d like to put compiled artifacts in `<binary_tree>/bin` rather
    than `<binary_tree>/src`).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是通过调用`add_subdirectory(src bin)`命令进入`src`目录的范围（我们希望将编译的产物放在`<binary_tree>/bin`而不是`<binary_tree>/src`）。
- en: 'CMake reads the `src/CMakeLists.txt` file and discovers that its only purpose
    is to add four nested subdirectories: `app1`, `app2`, `lib1`, and `lib2`.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake读取`src/CMakeLists.txt`文件，发现它的唯一目的是添加四个嵌套的子目录：`app1`、`app2`、`lib1`和`lib2`。
- en: CMake enters the variable scope of `app1` and learns about another nested library,
    `lib3`, which has its own `CMakeLists.txt` file; then the scope of `lib3` is entered.
    As you may have noticed, this is a depth-first traversal of the directory structure.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake进入`app1`的变量范围，了解另一个嵌套的库`lib3`，它有自己的`CMakeLists.txt`文件；然后进入`lib3`的范围。正如你可能注意到的，这是一个深度优先遍历目录结构。
- en: The `lib3` library adds a static library target with the same name. CMake returns
    to the parent scope of `app1`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lib3`库添加了一个与其同名的静态库目标。CMake返回到`app1`的父范围。'
- en: The `app1` subdirectory adds an executable that depends on `lib3`. CMake returns
    to the parent scope of `src`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app1`子目录添加了一个依赖于`lib3`的可执行文件。CMake返回到`src`的父范围。'
- en: CMake will continue entering the remaining nested scopes and executing their
    listfiles until all `add_subdirectory()` invocations have been completed.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 会继续进入剩余的嵌套作用域并执行它们的 listfiles，直到所有 `add_subdirectory()` 调用完成。
- en: CMake returns to the top-level scope and executes the remaining command `add_subdirectory(test)`.
    Each time, CMake enters the new scope and executes commands from the appropriate
    listfile.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 返回到顶层作用域并执行剩余的命令 `add_subdirectory(test)`。每次，CMake 都会进入新的作用域并执行适当 listfile
    中的命令。
- en: All the targets are collected and checked for their correctness. CMake now has
    all the necessary information to generate a buildsystem.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的目标都被收集并检查其正确性。CMake 现在拥有生成构建系统所需的所有必要信息。
- en: It’s important to note that the previous steps occur in the exact order in which
    we wrote the commands in our listfiles. In some cases, this order is significant,
    while in others, it may not be as crucial. We will delve deeper into this topic
    in the next chapter, *Chapter 5*, *Working with Targets*, to understand its implications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，前面的步骤是按我们在 listfiles 中编写命令的顺序执行的。在某些情况下，这个顺序非常重要，而在其他情况下，它可能不那么关键。我们将在下一章，*第五章*，*与目标工作*
    中深入探讨这个问题，理解它的含义。
- en: So, when is the right time to create the directories to contain all of the elements
    of the project? Should we do it right from the start – create everything needed
    for the future and keep the directories empty – or wait until we actually have
    the files that need to go in their own category? This is a choice – we could follow
    the **Extreme Programming** (**XP**) rule **YAGNI** (**you aren’t gonna need it**),
    or we could try to make our project future-proof and lay good foundations for
    new developers to come.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候是创建包含项目所有元素的目录的合适时机呢？我们应该从一开始就创建所有未来需要的内容并保持目录为空，还是等到我们真正有了需要放入各自类别的文件时再创建？这是一个选择——我们可以遵循**极限编程**（**XP**）规则**YAGNI**（**你不会需要它**），或者我们可以尝试让我们的项目具有未来适应性，为未来的开发者打下良好的基础。
- en: Try to aim for a good balance between these approaches – if you suspect that
    your project might someday need an `extern` directory, then add it (your version
    control system may require an empty `.keep` file to check a directory into the
    repository).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在这些方法之间寻找良好的平衡——如果你怀疑你的项目将来可能需要一个 `extern` 目录，那么就添加它（你的版本控制系统可能需要一个空的 `.keep`
    文件来将目录检查到仓库中）。
- en: 'Another effective approach to guide others in placing their external dependencies
    is by creating a `README` file that outlines the recommended structure. This can
    be particularly beneficial for less experienced programmers who will work on the
    project in the future. You may have observed this yourself: developers are reluctant
    to create directories, especially in the root of the project. If we provide a
    good project structure, others will be inclined to follow it.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有效的方式来引导他人放置外部依赖项是创建一个 `README` 文件，概述推荐的结构。这对于将来将参与项目的经验较少的程序员特别有帮助。你可能自己也观察到过：开发人员往往不愿意创建目录，特别是在项目的根目录下。如果我们提供一个良好的项目结构，其他人会更倾向于遵循它。
- en: Some projects can be built in almost every environment, while others are quite
    particular about their requirements. The top-level listfile is the perfect place
    to determine the appropriate course of action. Let’s see how to do this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目几乎可以在所有环境中构建，而另一些则对其要求非常特定。顶层的 listfile 是确定适当行动方案的理想位置。让我们看看如何做到这一点。
- en: Scoping the environment
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境作用域
- en: CMake provides multiple ways of querying the environment with `CMAKE_` variables,
    `ENV` variables, and special commands. For example, collected information can
    be used to support cross-platform scripts. These mechanisms allow us to avoid
    using platform-specific shell commands that may not be easily portable or differ
    in naming across environments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了多种方式来查询环境，通过 `CMAKE_` 变量、`ENV` 变量和特殊命令。例如，收集到的信息可以用来支持跨平台脚本。这些机制使我们能够避免使用平台特定的
    shell 命令，这些命令可能不容易移植，或者在不同环境中有不同的命名。
- en: For performance-critical applications, it will be useful to know all the features
    of the building platform (for example, instruction sets, CPU core count, and more).
    This information can then be passed to the compiled binaries so that they can
    be tuned to perfection (we’ll learn how to do the passing in the next chapter).
    Let’s explore the native information provided by CMake.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能关键型应用，了解构建平台的所有特性（例如，指令集、CPU 核心数等）会非常有用。然后，这些信息可以传递给编译后的二进制文件，以便它们能够优化到最佳状态（我们将在下一章学习如何进行传递）。让我们来探索
    CMake 提供的本地信息。
- en: Detecting the operating system
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测操作系统
- en: There are many occasions when it is useful to know what the target operating
    system is. Even as mundane a thing as a filesystem differs greatly between Windows
    and Unix in things such as case sensitivity, file path structures, the presence
    of extensions, privileges, and so on. Most commands present on one system won’t
    be available on another; they could be named differently (for example, `ifconfig`
    on Unix and `ipconfig` on Windows) or produce totally different output altogether.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况需要了解目标操作系统是什么。即便是像文件系统这样常见的事情，在 Windows 和 Unix 之间也有很大的不同，例如区分大小写、文件路径结构、扩展名的存在、权限等等。一台系统上可用的大多数命令在另一台系统上都不可用；它们可能会有不同的名称（例如，Unix
    中是`ifconfig`，而 Windows 中是`ipconfig`），或者输出的内容完全不同。
- en: 'If you ever need to support multiple target operating systems with a single
    CMake script, just check the `CMAKE_SYSTEM_NAME` variable so that you can act
    accordingly. Here’s a simple example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在一个 CMake 脚本中支持多个目标操作系统，只需检查`CMAKE_SYSTEM_NAME`变量，以便可以根据需要采取相应的措施。下面是一个简单的示例：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If needed, there’s a variable containing the operating system version: `CMAKE_SYSTEM_VERSION`.
    However, my recommendation is to try and make your solutions as system-agnostic
    as possible and use the built-in CMake cross-platform functionality. Especially
    for operations on filesystems, you should use the `file()` command described in
    the *Appendix*.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以使用一个包含操作系统版本的变量：`CMAKE_SYSTEM_VERSION`。不过，我的建议是尽量使你的解决方案尽可能不依赖于具体系统，并使用内置的
    CMake 跨平台功能。特别是在文件系统操作方面，你应该使用在*附录*中描述的`file()`命令。
- en: Cross-compilation – what are host and target systems?
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉编译 —— 主机和目标系统是什么？
- en: '**Cross-compilation** refers to the process of compiling code on one machine
    to be executed on a different target platform. For example, using the appropriate
    toolset, it is possible to compile applications for Android by running CMake on
    a Windows machine. Although cross-compilation is beyond the scope of this book,
    it’s important to understand how it impacts some parts of CMake.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**交叉编译**是指在一台机器上编译代码，以便在不同的目标平台上执行。例如，使用适当的工具集，您可以通过在 Windows 机器上运行 CMake 来为
    Android 编译应用程序。尽管交叉编译超出了本书的范围，但了解它如何影响 CMake 的某些部分是很重要的。'
- en: One of the necessary steps to allow cross-compilation is setting the `CMAKE_SYSTEM_NAME`
    and `CMAKE_SYSTEM_VERSION` variables to the values appropriate for the operating
    system that you’re compiling for (the CMake documentation refers to it as the
    **target system**). The operating system used to perform the build is called a
    **host system**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 允许交叉编译的必要步骤之一是将`CMAKE_SYSTEM_NAME`和`CMAKE_SYSTEM_VERSION`变量设置为适合你正在编译的操作系统的值（CMake
    文档称其为**目标系统**）。用于执行构建的操作系统被称为**主机系统**。
- en: 'Regardless of the configuration, the information on the host system is always
    accessible in variables with the `HOST` keyword in their name: `CMAKE_HOST_SYSTEM`,
    `CMAKE_HOST_SYSTEM_NAME`, `CMAKE_HOST_SYSTEM_PROCESSOR`, and `CMAKE_HOST_SYSTEM_VERSION`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论配置如何，主机系统的信息始终可以通过名称中包含`HOST`关键字的变量访问：`CMAKE_HOST_SYSTEM`、`CMAKE_HOST_SYSTEM_NAME`、`CMAKE_HOST_SYSTEM_PROCESSOR`
    和 `CMAKE_HOST_SYSTEM_VERSION`。
- en: There are a few more variables with a `HOST` keyword in their name, so just
    keep in mind that they’re explicitly referencing the host system. Otherwise, all
    variables reference the target system (which is normally the host system anyway,
    unless we’re cross-compiling).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些包含`HOST`关键字的变量，记住它们明确引用的是主机系统。否则，所有变量引用的都是目标系统（通常情况下，这也是主机系统，除非我们在进行交叉编译）。
- en: If you’re interested in reading more about cross-compilation, I suggest referencing
    the CMake documentation at [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣深入了解交叉编译，我建议参考 CMake 文档：[https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html)。
- en: Abbreviated variables
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩写变量
- en: 'CMake will predefine a few variables that will provide information about the
    host and target systems. If a specific system is used, an appropriate variable
    will be set to a non-`false` value (that is, `1` or `true`):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会预定义一些变量，这些变量会提供主机和目标系统的信息。如果使用了特定的系统，则会将相应的变量设置为非 `false` 值（即 `1` 或 `true`）：
- en: '`ANDROID, APPLE, CYGWIN, UNIX, IOS, WIN32, WINCE, WINDOWS_PHONE`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID, APPLE, CYGWIN, UNIX, IOS, WIN32, WINCE, WINDOWS_PHONE`'
- en: '`CMAKE_HOST_APPLE, CMAKE_HOST_SOLARIS, CMAKE_HOST_UNIX, CMAKE_HOST_WIN32`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_HOST_APPLE, CMAKE_HOST_SOLARIS, CMAKE_HOST_UNIX, CMAKE_HOST_WIN32`'
- en: The `WIN32` and `CMAKE_HOST_WIN32` variables will be `true` for 32- and 64-bit
    versions of Windows and MSYS (this value is kept for legacy reasons). Also, `UNIX`
    will be `true` for Linux, macOS, and Cygwin.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIN32` 和 `CMAKE_HOST_WIN32` 变量对于 32 位和 64 位版本的 Windows 和 MSYS 为 `true`（此值是为了兼容性保留的）。另外，`UNIX`
    对于 Linux、macOS 和 Cygwin 为 `true`。'
- en: Host system information
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机系统信息
- en: 'CMake could provide more variables, but to save time, it doesn’t query the
    environment for rarely needed information, such as *whether a processor supports
    MMX* or *what the total physical memory is*. That doesn’t mean this information
    isn’t available – you just need to ask for it explicitly with the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 可以提供更多变量，但为了节省时间，它不会查询环境中不常需要的信息，比如 *处理器是否支持 MMX* 或 *总物理内存是多少*。这并不意味着这些信息不可用——你只需要显式地请求它们，方法是使用以下命令：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to provide a target variable and a list of keys we’re interested in.
    If we provide just one key, the variable will contain a single value; otherwise,
    it will be a list of values. We can ask for many details about the environment
    and the OS:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供目标变量和我们感兴趣的键列表。如果只提供一个键，则变量将包含一个值；否则，它将是一个值的列表。我们可以请求关于环境和操作系统的许多详细信息：
- en: '| **Key** | **Description** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **Key** | **描述** |'
- en: '| `HOSTNAME` | Hostname |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `HOSTNAME` | 主机名 |'
- en: '| `FQDN` | Fully qualified domain name |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `FQDN` | 完全限定域名 |'
- en: '| `TOTAL_VIRTUAL_MEMORY` | Total virtual memory in MiB |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `TOTAL_VIRTUAL_MEMORY` | 总虚拟内存（单位：MiB） |'
- en: '| `AVAILABLE_VIRTUAL_MEMORY` | Available virtual memory in MiB |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `AVAILABLE_VIRTUAL_MEMORY` | 可用虚拟内存（单位：MiB） |'
- en: '| `TOTAL_PHYSICAL_MEMORY` | Total physical memory in MiB |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `TOTAL_PHYSICAL_MEMORY` | 总物理内存（单位：MiB） |'
- en: '| `AVAILABLE_PHYSICAL_MEMORY` | Available physical memory in MiB |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `AVAILABLE_PHYSICAL_MEMORY` | 可用物理内存（单位：MiB） |'
- en: '| `OS_NAME` | Output of `uname -s` if this command is present; either `Windows`,
    `Linux`, or `Darwin` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `OS_NAME` | 如果此命令存在，`uname -s` 的输出；可能为 `Windows`、`Linux` 或 `Darwin` |'
- en: '| `OS_RELEASE` | The OS sub-type, such as `on Windows Professional` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `OS_RELEASE` | 操作系统子类型，例如 `on Windows Professional` |'
- en: '| `OS_VERSION` | The OS build ID |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `OS_VERSION` | 操作系统版本 ID |'
- en: '| `OS_PLATFORM` | [`On`](http://On) Windows, `$ENV{PROCESSOR_ARCHITECTURE}`.
    On Unix/macOS, `uname -m` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `OS_PLATFORM` | [`On`](http://On) Windows，`$ENV{PROCESSOR_ARCHITECTURE}`。在
    Unix/macOS 上，使用 `uname -m` |'
- en: 'If needed, we can even query processor-specific information:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们甚至可以查询特定处理器的信息：
- en: '| **Key** | **Description** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **Key** | **描述** |'
- en: '| `NUMBER_OF_LOGICAL_CORES` | Number of logical cores |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `NUMBER_OF_LOGICAL_CORES` | 逻辑核心数量 |'
- en: '| `NUMBER_OF_PHYSICAL_CORES` | Number of physical cores |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `NUMBER_OF_PHYSICAL_CORES` | 物理核心数量 |'
- en: '| `HAS_SERIAL_NUMBER` | `1` if the processor has a serial number |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_SERIAL_NUMBER` | 如果处理器有序列号，则为 `1` |'
- en: '| `PROCESSOR_SERIAL_NUMBER` | Processor serial number |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `PROCESSOR_SERIAL_NUMBER` | 处理器序列号 |'
- en: '| `PROCESSOR_NAME` | Human-readable processor name |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `PROCESSOR_NAME` | 人类可读的处理器名称 |'
- en: '| `PROCESSOR_DESCRIPTION` | Human-readable full processor description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `PROCESSOR_DESCRIPTION` | 人类可读的完整处理器描述 |'
- en: '| `IS_64BIT` | `1` if processor is 64-bit |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `IS_64BIT` | 如果处理器是 64 位的，则为 `1` |'
- en: '| `HAS_FPU` | `1` if processor has floating-point units |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_FPU` | 如果处理器有浮点运算单元，则为 `1` |'
- en: '| `HAS_MMX` | `1` if processor supports MMX instructions |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_MMX` | 如果处理器支持 MMX 指令，则为 `1` |'
- en: '| `HAS_MMX_PLUS` | `1` if processor supports Ext. MMX instructions |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_MMX_PLUS` | 如果处理器支持扩展 MMX 指令，则为 `1` |'
- en: '| `HAS_SSE` | `1` if processor supports SSE instructions |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_SSE` | 如果处理器支持 SSE 指令，则为 `1` |'
- en: '| `HAS_SSE2` | `1` if processor supports SSE2 instructions |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_SSE2` | 如果处理器支持 SSE2 指令，则为 `1` |'
- en: '| `HAS_SSE_FP` | `1` if processor supports SSE FP instructions |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_SSE_FP` | 如果处理器支持 SSE 浮点指令，则为 `1` |'
- en: '| `HAS_SSE_MMX` | `1` if processor supports SSE MMX instructions |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_SSE_MMX` | 如果处理器支持 SSE MMX 指令，则为 `1` |'
- en: '| `HAS_AMD_3DNOW` | `1` if processor supports 3DNow instructions |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_AMD_3DNOW` | 如果处理器支持 3DNow 指令，则为 `1` |'
- en: '| `HAS_AMD_3DNOW_PLUS` | `1` if processor supports 3DNow+ instructions |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_AMD_3DNOW_PLUS` | 如果处理器支持 3DNow+ 指令，则为 `1` |'
- en: '| `HAS_IA64` | `1` if IA64 processor is emulating x86 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `HAS_IA64` | 如果 IA64 处理器正在模拟 x86，则为 `1` |'
- en: Does the platform have 32-bit or 64-bit architecture?
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 该平台是 32 位还是 64 位架构？
- en: In 64-bit architecture, memory addresses, processor registers, processor instructions,
    address buses, and data buses are 64 bits wide. While this is a simplified definition,
    it gives a rough idea of how 64-bit platforms are different from 32-bit platforms.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位架构中，内存地址、处理器寄存器、处理器指令、地址总线和数据总线都是 64 位宽。虽然这是一个简化的定义，但它大致说明了 64 位平台与 32
    位平台的区别。
- en: 'In C++, different architectures mean different bit widths for some fundamental
    data types (`int` and `long`) and pointers. CMake utilizes the pointer size to
    gather information about the target machine. This information is available through
    the `CMAKE_SIZEOF_VOID_P` variable, and it will contain a value of `8` for 64
    bits (because a pointer is 8 bytes wide) and `4` for 32 bits (4 bytes):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，不同的架构意味着一些基本数据类型（`int` 和 `long`）以及指针的位宽不同。CMake 利用指针的大小来收集目标机器的信息。这些信息通过
    `CMAKE_SIZEOF_VOID_P` 变量提供，对于 64 位，它的值为 `8`（因为指针宽度为 8 字节），对于 32 位，值为 `4`（4 字节）：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What is the endianness of the system?
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统的字节序是什么？
- en: Architectures can be categorized as either **big-endian** or **little-endian**
    based on the byte order within a word or the natural unit of data for a processor.
    In a **big-endian** system, the most significant byte is stored at the lowest
    memory address, while the least significant byte is stored at the highest memory
    address. On the other hand, in a **little-endian** system, the byte order is reversed,
    with the least significant byte stored at the lowest memory address and the most
    significant byte at the highest memory address.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 架构可以根据处理器的字节顺序（即数据的自然单位）分为 **大端序** 或 **小端序**。在 **大端序** 系统中，最高有效字节存储在最低的内存地址，而最低有效字节存储在最高的内存地址。另一方面，在
    **小端序** 系统中，字节顺序是反转的，最低有效字节存储在最低内存地址，最高有效字节存储在最高内存地址。
- en: In most cases, **endianness** doesn’t matter, but when you’re writing bit-wise
    code that needs to be portable, CMake will provide you with a `BIG_ENDIAN` or
    `LITTLE_ENDIAN` value stored in the `CMAKE_<LANG>_BYTE_ORDER` variable, where
    `<LANG>` is `C`, `CXX`, `OBJC`, or `CUDA`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，**字节序**并不重要，但当你编写需要便于移植的按位代码时，CMake 会为你提供一个存储在 `CMAKE_<LANG>_BYTE_ORDER`
    变量中的 `BIG_ENDIAN` 或 `LITTLE_ENDIAN` 值，其中 `<LANG>` 可以是 `C`、`CXX`、`OBJC` 或 `CUDA`。
- en: Now that we know how to query the environment, let’s shift our focus to the
    key settings of the project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何查询环境变量，让我们将注意力转向项目的关键设置。
- en: Configuring the toolchain
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置工具链
- en: For CMake projects, a toolchain consists of all the tools used in building and
    running the application – for example, the working environment, the generator,
    the CMake executable itself, and the compilers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CMake 项目，工具链包含了构建和运行应用程序时使用的所有工具——例如工作环境、生成器、CMake 可执行文件本身以及编译器。
- en: Imagine what a less-experienced user feels when your build stops with some mysterious
    compilation and syntax errors. They must dig into the source code and try to understand
    what happened. After an hour of debugging, they discover that the correct solution
    is to update their compiler. Could we provide a better experience for users and
    check if all the required functions are present in the compiler before starting
    the build?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当你的构建因为一些神秘的编译和语法错误停止时，一个经验较少的用户会有什么感受。他们必须深入源代码并尝试理解发生了什么。经过一个小时的调试，他们发现正确的解决方法是更新他们的编译器。我们能否为用户提供更好的体验，在开始构建之前检查编译器是否具备所有必需的功能？
- en: Sure! There are ways to specify these requirements. If the toolchain doesn’t
    support all of the required features, CMake will stop early and show a clear message
    of what happened, asking the user to step in.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！有方法可以指定这些要求。如果工具链不支持所有必需的功能，CMake 会提前停止并显示清晰的错误信息，提示用户介入。
- en: Setting the C++ standard
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 C++ 标准
- en: One of the initial steps we may consider is specifying the required C++ standard
    that the compiler should support for building our project. For new projects, it
    is recommended to set a minimum of C++14, but preferably C++17 or C++20\. Starting
    from CMake 3.20, it is possible to set the required standard to C++23 if the compiler
    supports it. Additionally, since CMake 3.25, there is an option to set the standard
    to C++26, although this is currently a placeholder.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑的初步步骤之一是指定编译器应该支持的所需 C++ 标准，以构建我们的项目。对于新项目，建议至少设置 C++14，但最好是 C++17 或 C++20。从
    CMake 3.20 开始，如果编译器支持，可以将所需标准设置为 C++23。此外，从 CMake 3.25 开始，可以将标准设置为 C++26，尽管这目前只是一个占位符。
- en: It has been over 10 years since the official release of **C++11**, and it is
    no longer considered to be *the modern C++ standard*. It’s not recommended to
    start projects with this version unless your target environment is very old.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自 **C++11** 官方发布以来已经过去了十多年，它不再被视为 *现代 C++ 标准*。除非你的目标环境非常旧，否则不建议使用这个版本来启动项目。
- en: Another reason to stick to old standards is if you are building legacy targets
    that are too hard to upgrade. However, the C++ committee works very hard to keep
    C++ backward compatible, and in most cases, you won’t have any problems bumping
    the standard to a higher version.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持使用旧标准的另一个原因是如果你在构建难以升级的遗留目标。然而，C++ 委员会一直在努力保持 C++ 向后兼容，在大多数情况下，你不会遇到将标准提高到更高版本的任何问题。
- en: 'CMake supports setting the standard on a target-by-target basis (this is useful
    if parts of your codebase are really old), but it’s better to converge to a single
    standard across the project. This can be done by setting the `CMAKE_CXX_STANDARD`
    variable to one of the following values: `98`, `11`, `14`, `17`, `20`, `23`, or
    `26`, like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持在每个目标的基础上设置标准（如果你的代码库的某些部分非常旧，这很有用），但最好是让整个项目趋向于一个统一的标准。可以通过将 `CMAKE_CXX_STANDARD`
    变量设置为以下值之一来完成：`98`、`11`、`14`、`17`、`20`、`23` 或 `26`，方法如下：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will be a default value for all subsequently defined targets (so it’s
    best to set it close to the top of the root listfile). You can override it on
    a per-target basis if needed, like so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将成为所有后续定义的目标的默认值（因此最好将其设置在根列表文件的顶部附近）。如果需要，你可以在每个目标的基础上覆盖它，方法如下：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The second version allows us to specify multiple targets if that’s needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本允许我们在需要时指定多个目标。
- en: Insisting on standard support
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 坚持标准支持
- en: The `CXX_STANDARD` property mentioned in the previous section won’t stop CMake
    from continuing with the build, even if the compiler isn’t supporting the desired
    version – it’s treated as a preference. CMake doesn’t know if our code actually
    uses the brand-new features that aren’t available in the previous compilers, and
    it will try to work with what it has available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的 `CXX_STANDARD` 属性不会阻止 CMake 继续构建，即使编译器不支持所需的版本——它被视为一种偏好设置。CMake 并不知道我们的代码是否实际使用了旧编译器中无法使用的新特性，它会尽力在现有的环境中工作。
- en: 'If we know for certain that this won’t be successful, we can set another variable
    (which is overridable per target in the same manner as the previous one) to explicitly
    require the standard we target:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定这不会成功，可以设置另一个变量（该变量可以像之前的变量一样在每个目标上覆盖）以明确要求我们所需的标准：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this case, if the compiler present in the system doesn’t support the required
    standard, the user will see the following message and the build will stop:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果系统中的编译器不支持所需的标准，用户将看到以下信息，构建将停止：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Asking for C++23 might be a bit excessive, even for a modern environment. But
    C++20 should be fine on up-to-date systems, as it has been generally supported
    in **GCC**/**Clang/MSVC** since 2021/2022.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在现代环境中，要求支持 C++23 可能有些过头。但是，C++20 应该在最新的系统上没有问题，因为自 2021/2022 年以来，**GCC**/**Clang/MSVC**
    都已经普遍支持它。
- en: Vendor-specific extensions
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 厂商特定的扩展
- en: Depending on the policy you implement in your organization, you might be interested
    in allowing or disabling vendor-specific extensions. What are these? Well, let’s
    just say that the C++ standard is moving a bit slow for the needs of some compiler
    producers, so they decided to add their own enhancements to the language – *extensions*,
    if you like. For example, C++ **Technical Report 1** (**TR1**) was a library extension
    that introduced regular expressions, smart pointers, hash tables, and random number
    generators before they became commonplace. To support such plugins released by
    the GNU project, CMake will substitute the compiler flag responsible for standard
    (`-std=c++14`) with `-std=gnu++14`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所在组织实施的政策，你可能会对允许或禁用特定供应商扩展感兴趣。这些扩展是什么呢？我们可以这样说，C++标准的进展对于一些编译器生产商的需求来说有点慢，所以他们决定为语言添加自己的增强功能——如果你喜欢的话，叫做*扩展*。例如，C++
    **技术报告1**（**TR1**）是一个库扩展，它在这些功能普及之前就引入了正则表达式、智能指针、哈希表和随机数生成器。为了支持GNU项目发布的这类插件，CMake会用`-std=gnu++14`替换标准编译器标志（`-std=c++14`）。
- en: 'On the one hand, this may be desired, as it allows for some convenient functionality.
    On the other hand, your code will lose portability as it will fail to build if
    you switch to a different compiler (or if your users do!). This is also a per-target
    property for which there is a default variable, `CMAKE_CXX_EXTENSIONS`. CMake
    is more liberal here, and allows the extensions unless we specifically tell it
    not to:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，这可能是期望的，因为它提供了一些方便的功能。另一方面，如果你切换到不同的编译器（或者你的用户这样做了），你的代码将失去可移植性，无法编译通过。这也是一个按目标设置的属性，存在一个默认变量`CMAKE_CXX_EXTENSIONS`。CMake在这里更为宽容，允许使用扩展，除非我们特别告诉它不要使用：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I recommend doing so, if possible, as this option will insist on having vendor-agnostic
    code. Such code won’t impose any unnecessary requirements on the users. Similarly
    to previous options, you can use `set_property()` to change this value on a per-target
    basis.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我推荐这样做，因为这个选项将坚持使用与供应商无关的代码。这种代码不会给用户带来任何不必要的要求。与之前的选项类似，你可以使用`set_property()`按目标修改这个值。
- en: Interprocedural optimization
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨过程优化
- en: Usually, compilers optimize the code on the level of a single translation unit,
    which means that your `.cpp` file will be preprocessed, compiled, and then optimized.
    The intermediary files generated during these operations are then passed to the
    linker to create a single binary. However, modern compilers have the capability
    of performing **interprocedural optimization** at link time, also known as **link-time
    optimization**. This allows all compilation units to be optimized as a unified
    module, which in principle will achieve better results (sometimes at the cost
    of slower builds and more memory consumption).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器会在单一翻译单元的层面上优化代码，这意味着你的`.cpp`文件会被预处理、编译，然后优化。在这些操作过程中生成的中间文件会被传递给链接器，最终生成一个单一的二进制文件。然而，现代编译器具备在链接时执行**跨过程优化**（interprocedural
    optimization）的能力，也称为**链接时优化**（link-time optimization）。这使得所有编译单元可以作为一个统一的模块进行优化，原则上这将实现更好的结果（有时会以更慢的构建速度和更多的内存消耗为代价）。
- en: 'If your compiler supports interprocedural optimization, it may be a good idea
    to use it. We’ll follow the same method. The variable responsible for this setting
    is called `CMAKE_INTERPROCEDURAL_OPTIMIZATION`. But before we set it, we need
    to make sure it is supported to avoid errors:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器支持跨过程优化，使用它可能是一个不错的主意。我们将采用相同的方法。负责此设置的变量叫做`CMAKE_INTERPROCEDURAL_OPTIMIZATION`。但在设置它之前，我们需要确保它被支持，以避免错误：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, we had to include a built-in module to get access to the `check_ipo_supported()`
    command. This code will fail gracefully, and fall back to default behavior if
    the optimization is not supported.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们需要包含一个内建模块以访问`check_ipo_supported()`命令。如果优化不被支持，这段代码会优雅地失败，并回退到默认行为。
- en: Checking for supported compiler features
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查支持的编译器功能
- en: 'As we discussed earlier, if our build is to fail, it’s best if it fails early,
    so we can provide a clear feedback message to the user and shorten the wait. Sometimes
    we’re specifically interested in which C++ features are supported (and which aren’t).
    CMake will question the compiler during the configuration stage and store a list
    of the available features in the `CMAKE_CXX_COMPILE_FEATURES` variable. We may
    write a very specific check and ask if a certain feature is available:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，如果我们的构建失败了，最好尽早失败，这样我们可以给用户提供清晰的反馈信息并缩短等待时间。有时我们特别关心哪些 C++ 特性受支持（哪些不受支持）。CMake
    会在配置阶段询问编译器，并将可用特性的列表存储在 `CMAKE_CXX_COMPILE_FEATURES` 变量中。我们可以编写一个非常具体的检查，询问是否有某个特性可用：
- en: '**ch04/07-features/CMakeLists.txt**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/07-features/CMakeLists.txt**'
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you may guess, writing one for every feature we use is a daunting task.
    Even the authors of CMake recommend only checking if certain high-level **meta-features**
    are present: `cxx_std_98`, `cxx_std_11`, `cxx_std_14`, `cxx_std_17`, `cxx_std_20`,
    `cxx_std_23`, and `cxx_std_26`. Each **meta-feature** indicates that the compiler
    supports a specific C++ standard. If you wish, you can use them exactly as we
    did in the previous example.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，针对我们使用的每个特性编写测试文件是一项艰巨的任务。即使是 CMake 的作者也建议只检查某些高级的 **元特性** 是否存在：`cxx_std_98`、`cxx_std_11`、`cxx_std_14`、`cxx_std_17`、`cxx_std_20`、`cxx_std_23`
    和 `cxx_std_26`。每个 **元特性** 表示编译器支持特定的 C++ 标准。如果你愿意，可以像我们在前面的例子中那样使用它们。
- en: 'A full list of features known to CMake can be found in the documentation: [https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 已知的特性完整列表可以在文档中找到：[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)。
- en: Compiling a test file
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译测试文件
- en: One particularly interesting scenario occurred to me when I was compiling an
    application with GCC 4.7.x. I had manually confirmed in the compiler’s reference
    that all of the C++11 features we were using were supported. However, the solution
    still didn’t work correctly. The code silently ignored the call to the standard
    `<regex>` header. As it turned out, this specific compiler had a bug, and the
    regex library wasn’t implemented.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用 GCC 4.7.x 编译一个应用程序时，遇到了一个特别有趣的场景。我已经在编译器的参考文档中手动确认了我们使用的所有 C++11 特性都受支持。然而，解决方案仍然无法正常工作。代码默默地忽略了对标准
    `<regex>` 头文件的调用。事实证明，这个特定的编译器存在一个 bug，导致 regex 库未实现。
- en: No single check can protect you from such rare bugs (and you shouldn’t need
    to check for them!), but there’s a chance you may want to use some cutting-edge
    experimental feature of the latest standard, and you’re not sure which compilers
    support it. You can test if your project is going to work by creating a test file
    that uses those specially required features in a small sample that can be quickly
    compiled and executed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何单一的检查可以防止这种罕见的 bug（你也不需要去检查这些 bug！），但你可能想使用最新标准中的一些前沿实验性特性，而且你不确定哪些编译器支持它。你可以通过创建一个测试文件，使用那些特定需求的特性，在一个可以快速编译并执行的小示例中测试你的项目是否能正常工作。
- en: CMake provides two configure-time commands, `try_compile()` and `try_run()`,
    to verify that everything you need is supported on the target platform.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了两个配置时命令，`try_compile()` 和 `try_run()`，用于验证所需的所有内容是否在目标平台上受支持。
- en: 'The `try_run()` command gives you more freedom, as you can ensure that the
    code is not only compiling but that it is also executing correctly (you could
    potentially test if `regex` is working). Of course, this won’t work for cross-compilation
    scenarios (as the host won’t be able to run an executable built for a different
    target). Just remember that the aim of this check is to provide a quick piece
    of feedback to the user if the compilation is working, so it’s not meant to run
    any unit tests or anything complex – keep the file as basic as possible. For example,
    something like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_run()` 命令提供了更多的灵活性，因为它不仅可以确保代码能够编译，还能验证代码是否正确执行（例如，你可以测试 `regex` 是否正常工作）。当然，这对于交叉编译场景来说不起作用（因为主机无法运行为不同目标平台构建的可执行文件）。请记住，这个检查的目的是为用户提供编译是否正常工作的快速反馈，因此它不用于运行单元测试或任何复杂的操作——保持文件尽可能简单。例如，像这样：'
- en: '**ch04/08-test_run/main.cpp**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/08-test_run/main.cpp**'
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calling `try_run()` isn’t very complicated at all. We start by setting the
    required standard, after which we call `try_run()` and print the collected information
    to the user:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`try_run()`其实并不复杂。我们首先设置所需的标准，然后调用`try_run()`并将收集到的信息打印给用户：
- en: '**ch04/08-test_run/CMakeLists.txt**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/08-test_run/CMakeLists.txt**'
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command may seem overwhelming at first, but only a few arguments are actually
    required to compile and run a very basic test file. I additionally used the optional
    `RUN_OUTPUT_VARIABLE` keyword to collect the output from `stdout`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令一开始可能让人觉得有些复杂，但实际上只有几个参数是必需的，用于编译和运行一个非常基础的测试文件。我还额外使用了可选的`RUN_OUTPUT_VARIABLE`关键字来收集来自`stdout`的输出。
- en: The next step is to extend our basic test file by using some of the more modern
    C++ features that we’re going to use throughout the actual project – perhaps by
    adding a variadic template to see if the compiler on the target machine can digest
    it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过使用一些我们将在实际项目中使用的现代C++特性，来扩展我们的基本测试文件——或许可以通过添加一个变参模板，看看目标机器上的编译器是否能够处理它。
- en: Finally, we can check in the conditional blocks if the collected output is meeting
    our expectations and `message(SEND_ERROR <error>)` is printed when something isn’t
    right. Remember that `SEND_ERROR` keyword will allow CMake to continue through
    the configuration stage but will prevent the generation of the buildsystem. This
    is useful to show all the encountered errors before aborting the build. We now
    know how to ensure the compilation can complete in full. Let’s move on to the
    next subject, disabling in-source builds.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在条件块中检查收集到的输出是否符合我们的预期，并且当出现问题时，`message(SEND_ERROR <error>)`会被打印出来。记住，`SEND_ERROR`关键字允许CMake继续配置阶段，但会阻止生成构建系统。这对于在中止构建之前显示所有遇到的错误非常有用。现在我们已经知道如何确保编译可以完全完成。接下来，我们将讨论禁用源代码目录构建的问题。
- en: Disabling in-source builds
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用源代码目录构建
- en: In *Chapter 1*, *First Steps with CMake*, we talked about in-source builds,
    and how it is recommended to always specify the build path to be out of source.
    This not only allows for a cleaner build tree and a simpler `.gitignore` file,
    but it also decreases the chances you’ll accidentally overwrite or delete any
    source files.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*CMake入门*中，我们讨论了源代码目录构建，并且建议始终指定构建路径为源代码之外。这不仅可以让构建树更干净、`.gitignore`文件更简单，还能减少你意外覆盖或删除源文件的风险。
- en: 'To stop the build early you may use the following check:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提前停止构建，可以使用以下检查：
- en: '**ch04/09-in-source/CMakeLists.txt**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch04/09-in-source/CMakeLists.txt**'
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you would like more information about the STR prefix and variable references,
    please revisit *Chapter 2*, *The CMake Language*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于STR前缀和变量引用的信息，请回顾*第2章*，*CMake语言*。
- en: Notice, however, that no matter what you do in the preceding code, it seems
    like CMake will still create a `CMakeFiles/` directory and a `CMakeCache.txt`
    file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，无论你在前面的代码中做什么，似乎CMake仍然会创建一个`CMakeFiles/`目录和一个`CMakeCache.txt`文件。
- en: You might find online suggestions to use undocumented variables to make sure
    that the user can’t write in the source directory under any circumstances. Relying
    on undocumented variables to restrict writing in the source directory is not recommended.
    They may not work in all versions and can be subject to removal or modification
    without warning.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在网上看到一些建议，使用未文档化的变量来确保用户在任何情况下都不能在源目录中写入。依赖于未文档化的变量来限制在源目录中的写入是不推荐的。这些变量可能在所有版本中都不起作用，并且可能在没有警告的情况下被移除或修改。
- en: If you’re worried about users leaving those files in the source directory, add
    them to the `.gitignore` (or equivalent), and change the message to request a
    manual cleanup.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心用户将这些文件留在源代码目录中，可以将它们添加到`.gitignore`（或等效文件）中，并更改提示信息，要求手动清理。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered valuable concepts that lay a strong foundation for
    building robust and future-proof projects. We discussed setting the minimum CMake
    version and configuring essential project aspects like name, languages, and metadata
    fields. Establishing these foundations enables our projects to scale effectively.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了有价值的概念，为构建健壮和具有未来保障的项目奠定了坚实的基础。我们讨论了设置最小CMake版本，以及配置项目的基本方面，如名称、语言和元数据字段。建立这些基础使得我们的项目能够有效地扩展。
- en: We explored project partitioning, comparing the use of basic `include()` with
    `add_subdirectory`, which offers benefits such as scoped variable management,
    simplified paths, and increased modularity. The ability to create nested projects
    and build them separately proved useful in gradually breaking down code into more
    independent units. After understanding the available partitioning mechanisms,
    we delved into creating transparent, resilient, and extensible project structures.
    We examined CMake’s traversal of listfiles and the correct order of configuration
    steps. Next, we studied how we can scope the environment of our target and host
    machines, what the differences are between them, and what kind of information
    about the platform and system is available through different queries. We also
    covered configuring the toolchain, including specifying the required C++ version,
    handling vendor-specific compiler extensions, and enabling important optimizations.
    We learned how to test the compiler for required features and execute sample files
    to test compilation support.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了项目划分，比较了基本的`include()`与`add_subdirectory`的使用，后者带来了诸如作用域变量管理、简化路径和增加模块化等好处。能够创建嵌套项目并分别构建它们，在逐步将代码分解为更独立的单元时证明是有用的。在理解了可用的划分机制之后，我们深入探讨了如何创建透明、弹性和可扩展的项目结构。我们考察了CMake如何遍历listfile以及配置步骤的正确顺序。接下来，我们研究了如何为目标和主机机器设置环境作用域，它们之间的差异是什么，以及通过不同查询可以获得哪些关于平台和系统的信息。我们还介绍了工具链配置，包括指定所需的C++版本、处理特定供应商的编译器扩展以及启用重要的优化。我们学习了如何测试编译器所需的功能，并执行示例文件以测试编译支持。
- en: Although the technical aspects covered so far are essential for a project, they
    are not sufficient to make it truly useful. To increase the project’s utility,
    we need to understand the concept of **targets**. We briefly touched on the topic
    earlier, but now we are ready to approach it in full, as we finally have a solid
    understanding of related fundamentals. Targets, introduced in the next chapter,
    will play a crucial role in further enhancing the functionality and effectiveness
    of our projects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管到目前为止涉及的技术方面对于项目至关重要，但它们不足以使项目真正有用。为了增加项目的实用性，我们需要理解**目标（targets）**的概念。我们之前简要地提到过这一话题，但现在我们已经准备好全面探讨它，因为我们已经充分理解了相关的基础知识。在下一章中将介绍的目标（targets），将在进一步提升项目的功能性和有效性方面发挥关键作用。
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following links:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涉及主题的更多信息，请参阅以下链接：
- en: 'Separation of concerns: [https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离：[https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)
- en: 'Complete CMake variable reference: [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的CMake变量参考：[https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)
- en: '`try_compile` and `try_run` references: [https://cmake.org/cmake/help/latest/command/try_compile.html](https://cmake.org/cmake/help/latest/command/try_compile.html),
    [https://cmake.org/cmake/help/latest/command/try_run.html](https://cmake.org/cmake/help/latest/command/try_run.html)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_compile` 和 `try_run` 参考文献：[https://cmake.org/cmake/help/latest/command/try_compile.html](https://cmake.org/cmake/help/latest/command/try_compile.html),
    [https://cmake.org/cmake/help/latest/command/try_run.html](https://cmake.org/cmake/help/latest/command/try_run.html)'
- en: 'CheckIPOSupported reference: [https://cmake.org/cmake/help/latest/module/CheckIPOSupported.html](https://cmake.org/cmake/help/latest/module/CheckIPOSupported.html)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CheckIPOSupported 参考文献：[https://cmake.org/cmake/help/latest/module/CheckIPOSupported.html](https://cmake.org/cmake/help/latest/module/CheckIPOSupported.html)
- en: Leave a review!
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过在亚马逊留下评论帮助像您一样的读者。扫描下面的二维码，免费获取一本您选择的电子书。
- en: '![](img/Review_Copy.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_Copy.png)'
