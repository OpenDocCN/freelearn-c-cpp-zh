["```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =   Dodgeball, meta = (AllowPrivateAccess = \"true\"))\n    class USphereComponent* SphereComponent;\n    ```", "```cpp\n    #include \"Components/SphereComponent.h\"\n    ```", "```cpp\n    SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT(\"Sphere   Collision\"));\n    ```", "```cpp\n    SphereComponent->SetSphereRadius(35.f);\n    ```", "```cpp\n    SphereComponent->SetCollisionProfileName(FName(\"Dodgeball\"));\n    ```", "```cpp\n    SphereComponent->SetSimulatePhysics(true);\n    ```", "```cpp\n    //Simulation generates Hit events\n    SphereComponent->SetNotifyRigidBodyCollision(true);\n    ```", "```cpp\n        UFUNCTION()\n        void OnHit(UPrimitiveComponent* HitComp, AActor* OtherActor,   UPrimitiveComponent* OtherComp, FVector NormalImpulse, const   FHitResult& Hit);\n        ```", "```cpp\n    void ADodgeballProjectile::OnHit(UPrimitiveComponent *   HitComp, AActor * OtherActor, UPrimitiveComponent *   OtherComp, FVector NormalImpulse, const FHitResult & Hit)\n    {\n    \u00a0\u00a0if (Cast<ADodgeballCharacter>(OtherActor) != nullptr)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0Destroy();\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    #include \"DodgeballCharacter.h\"\n    ```", "```cpp\n    // Listen to the OnComponentHit event by binding it to our   function\n    SphereComponent->OnComponentHit.AddDynamic(this,   &ADodgeballProjectile::OnHit);\n    ```", "```cpp\n    // Set this Sphere Component as the root component,\n    // otherwise collision won't behave properly\n    RootComponent = SphereComponent;\n    ```", "```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =   Dodgeball, meta = (AllowPrivateAccess = \"true\"))\n    class UProjectileMovementComponent* ProjectileMovement;\n    ```", "```cpp\n    #include \"GameFramework/ProjectileMovementComponent.h\"\n    ```", "```cpp\n    ProjectileMovement = CreateDefaultSubobject<UProjectileMovementComponent>(TEXT(\"Pro   jectile Movement\"));\n    ```", "```cpp\n    ProjectileMovement->InitialSpeed = 1500.f;\n    ```", "```cpp\nGetWorld()->SpawnActor<NameOfC++Class>(ClassReference,   SpawnLocation, SpawnRotation);\n```", "```cpp\n    // Change the rotation of the character to face the given   actor\n    // Returns whether the given actor can be seen\n    bool LookAtActor(AActor* TargetActor);\n    ```", "```cpp\n    bool AEnemyCharacter::LookAtActor(AActor * TargetActor)\n    {\n    \u00a0\u00a0if (TargetActor == nullptr) return false;\n    \u00a0\u00a0if (CanSeeActor(TargetActor))\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0FVector Start = GetActorLocation();\n    \u00a0\u00a0\u00a0\u00a0FVector End = TargetActor->GetActorLocation();\n    \u00a0\u00a0\u00a0\u00a0// Calculate the necessary rotation for the Start point to   face the End point\n    \u00a0\u00a0\u00a0\u00a0FRotator LookAtRotation = UKismetMathLibrary::FindLookAtRotation(Start, End);\n    \u00a0\u00a0\u00a0\u00a0//Set the enemy's rotation to that rotation\n    \u00a0\u00a0\u00a0\u00a0SetActorRotation(LookAtRotation);\n    \u00a0\u00a0\u00a0\u00a0return true;\n    \u00a0\u00a0}\n    \u00a0\u00a0return false;\n    }\n    ```", "```cpp\n    //Whether the enemy can see the player this frame\n    bool bCanSeePlayer = false;\n    //Whether the enemy could see the player last frame\n    bool bPreviousCanSeePlayer = false;\n    ```", "```cpp\n    // Look at the player character every frame\n    bCanSeePlayer = LookAtActor(PlayerCharacter);\n    ```", "```cpp\n    bPreviousCanSeePlayer = bCanSeePlayer;\n    ```", "```cpp\n    bCanSeePlayer = LookAtActor(PlayerCharacter);\n    if (bCanSeePlayer != bPreviousCanSeePlayer)\n    {\n    }\n    bPreviousCanSeePlayer = bCanSeePlayer;\n    ```", "```cpp\n    if (bCanSeePlayer != bPreviousCanSeePlayer)\n    {\n    \u00a0\u00a0if (bCanSeePlayer)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0//Start throwing dodgeballs\n    \u00a0\u00a0}\n    \u00a0\u00a0else\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0//Stop throwing dodgeballs\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n        FTimerHandle ThrowTimerHandle;\n        ```", "```cpp\n        float ThrowingInterval = 2.f;\n        ```", "```cpp\n        float ThrowingDelay = 0.5f;\n        ```", "```cpp\n        void ThrowDodgeball();\n        ```", "```cpp\n        #include \"TimerManager.h\"\n        ```", "```cpp\n    GetWorldTimerManager()\n    ```", "```cpp\n        if (bCanSeePlayer)\n        {\n        \u00a0\u00a0//Start throwing dodgeballs\n        \u00a0\u00a0GetWorldTimerManager().SetTimer(ThrowTimerHandle,this,  &AEnemyCharacter::ThrowDodgeball,ThrowingInterval,true,  ThrowingDelay);\n        }\n        ```", "```cpp\n    else\n    {\n    \u00a0\u00a0//Stop throwing dodgeballs\n    \u00a0\u00a0GetWorldTimerManager().ClearTimer(ThrowTimerHandle);\n    }\n    ```", "```cpp\n    //The class used to spawn a dodgeball object\n    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category =   Dodgeball)\n    TSubclassOf<class ADodgeballProjectile> DodgeballClass;\n    ```", "```cpp\n    #include \"DodgeballProjectile.h\"\n    ```", "```cpp\n    void AEnemyCharacter::ThrowDodgeball()\n    {\n    \u00a0\u00a0if (DodgeballClass == nullptr)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0return;\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    FVector ForwardVector = GetActorForwardVector();\n    float SpawnDistance = 40.f;\n    FVector SpawnLocation = GetActorLocation() + (ForwardVector *   SpawnDistance);\n    //Spawn new dodgeball\n    GetWorld()->SpawnActor<ADodgeballProjectile>(DodgeballClass,   SpawnLocation, GetActorRotation());\n    ```", "```cpp\n    void ADodgeballProjectile::BeginPlay()\n    {\n    \u00a0\u00a0Super::BeginPlay();\n\n    \u00a0\u00a0SetLifeSpan(5.f);\n    }\n    ```", "```cpp\n        private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Wall,   meta = (AllowPrivateAccess = \"true\"))\n        class USceneComponent* RootScene;\n        ```", "```cpp\n        AWall::AWall()\n        {\n        \u00a0\u00a0// Set this actor to call Tick() every frame.  You can turn   this off to improve performance if you don't need it.\n        \u00a0\u00a0PrimaryActorTick.bCanEverTick = true;\n        \u00a0\u00a0RootScene = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n        \u00a0\u00a0RootComponent = RootScene;\n        }\n        ```", "```cpp\n        private:\n        UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =   VictoryBox, meta = (AllowPrivateAccess = \"true\"))\n        class USceneComponent* RootScene;\n        ```", "```cpp\n        AVictoryBox::AVictoryBox()\n        {\n        \u00a0\u00a0// Set this actor to call Tick() every frame.  You can turn   this off to improve performance if you don't need it.\n        \u00a0\u00a0PrimaryActorTick.bCanEverTick = true;\n        \u00a0\u00a0RootScene =   CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n        \u00a0\u00a0RootComponent = RootScene;\n        }\n        ```", "```cpp\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category =   VictoryBox, meta = (AllowPrivateAccess = \"true\"))\n    class UBoxComponent* CollisionBox;\n    ```", "```cpp\n    #include \"Components/BoxComponent.h\"\n    ```", "```cpp\n    RootScene = CreateDefaultSubobject<USceneComponent>(TEXT(\"Root\"));\n    RootComponent = RootScene;\n    CollisionBox =   CreateDefaultSubobject<UBoxComponent>(TEXT(\"Collision Box\"));\n    ```", "```cpp\n    CollisionBox->SetupAttachment(RootComponent);\n    ```", "```cpp\n    CollisionBox->SetBoxExtent(FVector(60.0f, 60.0f, 60.0f));\n    ```", "```cpp\n    CollisionBox->SetRelativeLocation(FVector(0.0f, 0.0f,   120.0f));\n    ```", "```cpp\n    UFUNCTION()\n    void OnBeginOverlap(UPrimitiveComponent* OverlappedComp,   AActor* OtherActor, UPrimitiveComponent* OtherComp, int32   OtherBodyIndex, bool bFromSweep, const FHitResult&   SweepResult);\n    ```", "```cpp\n    CollisionBox->OnComponentBeginOverlap.AddDynamic(this,   &AVictoryBox::OnBeginOverlap);\n    ```", "```cpp\n    #include \"DodgeballCharacter.h\" \n    void AVictoryBox::OnBeginOverlap(UPrimitiveComponent *   OverlappedComp, AActor * OtherActor, UPrimitiveComponent *   OtherComp, int32 OtherBodyIndex, bool bFromSweep, const   FHitResult & SweepResult)\n    {\n    \u00a0\u00a0if (Cast<ADodgeballCharacter>(OtherActor))\n    \u00a0\u00a0{\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    #include \"Kismet/KismetSystemLibrary.h\"\n    ```", "```cpp\n    UKismetSystemLibrary::QuitGame(GetWorld(),\n    \u00a0\u00a0nullptr,\n    \u00a0\u00a0EQuitPreference::Quit,\n    \u00a0\u00a0true);\n    ```", "```cpp\n    FORCEINLINE class UProjectileMovementComponent*   GetProjectileMovementComponent() const\n    {\n    \u00a0\u00a0return ProjectileMovement;\n    }\n    ```"]