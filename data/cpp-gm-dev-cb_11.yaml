- en: Chapter 11. Networking in Game Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 游戏开发中的网络
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下配方：
- en: Understanding the different layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同的层
- en: Selecting the appropriate protocol
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择适当的协议
- en: Serializing the packets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化数据包
- en: Using socket programming in games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中使用套接字编程
- en: Sending the data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送数据
- en: Receiving the data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收数据
- en: Dealing with lag
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理延迟
- en: Using synchronized simulation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用同步模拟
- en: Using area of interest filtering
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用感兴趣区域过滤
- en: Using local perception filtering
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地感知过滤
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the modern era of video gaming, networking plays a huge role in the overall
    playability of a game. A single player game offers an average of about 15-20 hours
    of gameplay. However, with the multiplayer (networked) feature, the gameplay time
    increases exponentially, as now the users have to play against other human opponents
    and improve their tactics. Whether it is a PC game, console or mobile, having
    multiplayer capabilities has become a common feature these days. From a freemium
    model for games, where the monetization and revenue model is based around in-app
    purchases and ads, it is necessary for the game to have thousands or millions
    or active users per day. That is the only way the game will make money. When we
    speak about multiplayer, we should not fool ourselves by thinking that this is
    restricted to **PvP** (**player versus player**) in real time. It can also be
    asynchronous multiplayer, where the player competes with the *data* from an active
    player's deck but not with the player themselves. It gives the illusion that the
    player is competing against a real player. Also, with the advent of social media,
    networking also plays a role in helping you compete against your friends. For
    example, in *Candy Crush*, after you finish a level, you are shown how your friends
    fared in the same level and who the next friend to beat is. All this adds to the
    hype around the game and compels you to keep playing it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代视频游戏时代，网络在游戏的整体可玩性中扮演着重要角色。单人游戏提供平均约15-20小时的游戏时间。然而，通过多人游戏（联网）功能，游戏时间呈指数增长，因为现在用户必须与其他人类对手进行游戏并改进他们的战术。无论是PC游戏、游戏机还是移动游戏，具有多人游戏功能如今已成为一种常见特性。对于游戏的免费模式，其中货币化和收入模式基于应用内购买和广告，游戏必须每天拥有数千或数百万活跃用户。这是游戏赚钱的唯一途径。当我们谈论多人游戏时，我们不应该自欺欺人地认为这仅限于实时**PvP**（玩家对玩家）。它也可以是异步多人游戏，玩家与活跃玩家的数据竞争，而不是与玩家本身竞争。它给人一种错觉，即玩家正在与真实玩家竞争。此外，随着社交媒体的出现，网络也在帮助你与朋友竞争。例如，在*Candy
    Crush*中，完成一个关卡后，你会看到你的朋友在同一关卡中的表现以及下一个要击败的朋友是谁。所有这些增加了游戏的热度，并迫使你继续玩下去。
- en: Understanding the different layers
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解不同的层
- en: From a technical point of view, the entire networking model is divided into
    multiple layers. This model is also referred to as the **OSI** (**Open Systems
    Interconnection**) model. Each layer has a special significance and must be understood
    properly to be able to interact with other layers of the topology.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度看，整个网络模型被划分为多个层。这个模型也被称为**OSI**（**开放系统互连**）模型。每一层都有特殊的意义，必须正确理解才能与拓扑的其他层进行交互。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need a machine running Windows.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，您需要一台运行Windows的机器。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to understand the different layers
    of the networking topology. Look at the following diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到理解网络拓扑的不同层有多容易。看看下面的图表：
- en: '![How to do it…](img/4929_11_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/4929_11_01.jpg)'
- en: How it works…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'To understand the OSI model, we have to look at the model from the bottom of
    the stack to the top. The layers of the OSI model are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解OSI模型，我们必须从堆栈的底部向上查看模型。OSI模型的层包括：
- en: '**Physical layer**: This establishes the actual physical connection to the
    network. This is defined by whether we are using copper wire or fiber optics.
    It defines the network topology that is used, ring or bus, and so on. It also
    defines the transmission mode: whether it is simplex, half duplex, or full duplex.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理层**：这建立了与网络的实际物理连接。这取决于我们是使用铜线还是光纤。它定义了所使用的网络拓扑结构，环形或总线等。它还定义了传输模式：是单工、半双工还是全双工。'
- en: '**Data link layer**: This provides the actual link between two connected nodes.
    The data link layer has two sublayers: the **MAC** layer (**Media** **Access Control**)
    and the **LLC** layer (**Logical Link Control**).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据链路层**：这提供了两个连接节点之间的实际链接。数据链路层有两个子层：**MAC**层（**媒体访问控制**）和**LLC**层（**逻辑链路控制**）。'
- en: '**Network layer**: This layers provides the functional means of transfer of
    variable length data called **datagrams**. The transfer happens from one connected
    node to another on the same network. This forms the IP.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络层**：这一层提供了传输可变长度数据（称为**数据报**）的功能手段。传输发生在同一网络上的一个连接节点到另一个连接节点。这形成了IP。'
- en: '**Transport layer**: This layer also provides the functional means of transferring
    data. The data is transferred from a source to a destination, travelling via one
    or more networks. Some of the protocols used here are TCP and UDP. **TCP** is
    the **transfer control protocol** and is a secured connection. **UDP** is the
    **user datagram protocol** and is the less secure one. In video games, we use
    both TCP and UDP protocols. When there is a situation where the user has to log
    in to the server, we use TCP as it is more secure, because the next information
    from the client is not sent unless there is an acknowledgement from the server
    concerning the previous data. It can be slow, however, so if security is more
    important than speed, we use TCP. After the user logs in, the game starts after
    other players have joined. Now we use UDP for the majority of situations, as speed
    is more important than security and a few dropped packets could have a huge impact.
    UDP packets are not always received as there is no acknowledgement.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：这一层还提供了传输数据的功能手段。数据从源传输到目的地，经过一个或多个网络。这里使用的一些协议是TCP和UDP。**TCP**是**传输控制协议**，是一个安全连接。**UDP**是**用户数据报协议**，是不太安全的。在视频游戏中，我们同时使用TCP和UDP协议。当用户需要登录服务器时，我们使用TCP，因为它更安全，因为除非服务器对先前的数据做出确认，否则不会发送来自客户端的下一个信息。然而，它可能会比较慢，所以如果安全性比速度更重要，我们使用TCP。用户登录后，游戏在其他玩家加入后开始。现在我们在大多数情况下使用UDP，因为速度比安全性更重要，而少量丢失的数据包可能会产生巨大影响。UDP数据包并不总是被接收，因为没有确认。'
- en: '**Session layer**: This layer controls the connections between the network
    and the remote computer. This layer is responsible for establishing, managing,
    and terminating a connection.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话层**：这一层控制网络和远程计算机之间的连接。这一层负责建立、管理和终止连接。'
- en: '**Presentation layer**: This layer controls the different semantics that need
    to be established between the connections. All the encryption logic is written
    in this layer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：这一层控制需要在连接之间建立的不同语义。所有加密逻辑都写在这一层。'
- en: '**Application layer**: This layer deals with the communication with the software
    application itself. This is the closest layer from the end user''s point of view.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层**：这一层处理与软件应用程序本身的通信。这是离最终用户最近的一层。'
- en: Selecting the appropriate protocol
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择适当的协议
- en: 'In games, most of the time there is an important decision that must be made:
    whether to use TCP or UDP. The decision often ends up in favor of UDP, but still
    it is important to understand the difference between the two.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，大部分时间都需要做一个重要的决定：使用TCP还是UDP。决定往往会偏向UDP，但了解两者之间的区别仍然很重要。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need a Windows machine. No other prerequisites are required.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一台Windows机器。不需要其他先决条件。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we will find out how easy it is to make a decision on whether
    to use TCP or UDP.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将发现决定使用TCP还是UDP有多么容易。
- en: 'Ask the following questions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 问以下问题：
- en: Does the system require guaranteed delivery?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否需要可靠交付？
- en: Is there a requirement for retransmission?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否需要重传的要求？
- en: Does the system require any handshaking mechanism?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统是否需要任何握手机制？
- en: What kind of congestion control does it need?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要什么样的拥塞控制？
- en: Is speed a consideration in the system?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度是否是系统考虑的因素？
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'TCP and UDP are built on top of the IP layer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP建立在IP层之上：
- en: '![How it works…](img/4929_11_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_11_02.jpg)'
- en: 'A TCP connection is considered reliable because there is a two-way handshake
    system enabled. Once the message is delivered to the endpoint, an acknowledgement
    message is sent out. It supports various other services as well, such as congestion
    control and multiplexing. The fact that TCP is also full duplex makes it quite
    a potent connection to use. The way it handles the reliable transfer of data is
    through byte sequence numbers. It sets a timeout function and, based on timeouts,
    it can decide whether a package has been delivered or not. The following diagram
    shows how the handshaking protocol is established:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接被认为是可靠的，因为启用了双向握手系统。一旦消息传递到终点，就会发送一个确认消息。它还支持各种其他服务，如拥塞控制和多路复用。TCP也是全双工的，使其成为一个相当强大的连接。它通过字节序列号来处理数据的可靠传输。它设置了一个超时函数，并根据超时来决定包是否已经被传递。下图显示了握手协议是如何建立的：
- en: '![How it works…](img/4929_11_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_11_03.jpg)'
- en: Another mechanism for TCP is the sliding window mechanism, which guarantees
    the reliable delivery of data. It ensures that the data packets are delivered
    in a sequential manner and a flow control between the sender and receiver is established.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的另一个机制是滑动窗口机制，它保证了数据的可靠传递。它确保数据包按顺序传递，并在发送方和接收方之间建立了流量控制。
- en: UDP is used when we are not too concerned about the data packets being delivered
    out of order. The main concern is how fast the packets are delivered. There is
    no reliability and no guarantee that the packets will be delivered.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不太关心数据包的顺序交付时，就会使用UDP。主要关注的是数据包的快速交付。没有可靠性，也没有保证数据包会被交付。
- en: Applications that require ordered delivery must restore datagram ordering themselves.
    Datagrams can be written to a target address without knowing if it exists or is
    listening. Messages can also be broadcast to all hosts on a particular subnet.
    *DOOM* did this. Sometimes, if we require minimal reliability, UDP is open to
    adding that functionality. At that point it is also referred to as reliable UDP.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要有序交付的应用程序必须自行恢复数据报的顺序。数据报可以被写入目标地址，而不知道它是否存在或正在监听。消息也可以广播到特定子网上的所有主机。*DOOM*就是这样做的。有时，如果我们需要最小的可靠性，UDP可以添加该功能。在那时，它也被称为可靠UDP。
- en: Serializing the packets
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化数据包
- en: Serialization is a key feature to have in a networking system. The process of
    serialization involves converting a message or data to a format that can be transmitted
    over the network, and then decoding it. There are a variety of ways to serialize
    and deserialize data, and it comes down to a matter of personal choice.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是网络系统中必须具备的一个关键特性。序列化的过程涉及将消息或数据转换为可以在网络上传输的格式，然后进行解码。有各种各样的序列化和反序列化数据的方式，最终取决于个人选择。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working Windows machine and Visual Studio. No other requirements
    are needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个工作的Windows机器和Visual Studio。不需要其他要求。
- en: How to do it…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to serialize data. Create a source
    file and derive it from the serializer class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到序列化数据是多么容易。创建一个源文件，并从序列化类派生它：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As mentioned before, to serialize is to convert the data to a format that can
    be transferred. We can do this by using the Google API, or using the JSON format
    or YAML. In this example, we have used an XML serializer originally written by
    Lothar Perr. The original source can be found at [http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus](http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus).
    The whole idea behind the program is that we convert the data to an XML format.
    In the class serializable data, we publicly derive it from the serializable class.
    We create a constructor to register all the data elements and we create the different
    data elements that we want to be serialized. The data elements are of the type
    `xString` class. In the constructor, we register each of the data elements. Finally,
    from the client side, we assign the correct data to be sent and, using the XML
    serializer class and tinyxml, we generate the required XML. Finally, this XML
    will be sent across the network and on receipt, it will be decoded using the same
    logic. XML can sometimes be considered quite heavy and cumbersome for games.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，序列化是将数据转换为可以传输的格式。我们可以使用Google API，或者使用JSON格式或YAML来实现。在这个示例中，我们使用了最初由Lothar
    Perr编写的XML序列化器。原始源代码可以在[http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus](http://www.codeproject.com/Tips/725375/Tiny-XML-Serialization-for-Cplusplus)找到。程序的整个思想是将数据转换为XML格式。在可序列化数据类中，我们公开地从可序列化类派生它。我们创建一个构造函数来注册所有的数据元素，并创建我们想要序列化的不同数据元素。数据元素是`xString`类的类型。在构造函数中，我们注册每个数据元素。最后，从客户端，我们分配正确的数据进行发送，并使用XML序列化器类和tinyxml生成所需的XML。最后，这个XML将被发送到网络上，并在接收时，将使用相同的逻辑进行解码。XML有时被认为对游戏来说相当沉重和繁琐。
- en: 'In these situations, it is advisable to use JSON. Some modern engines, such
    as Unity3D and Unreal Engine, already have an inbuilt JSON parser which could
    be used to serialize the data. However, XML still continues to be an important
    format. An example of a possible output from our code is shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，建议使用JSON。一些现代引擎，如Unity3D和虚幻引擎，已经内置了可以用来序列化数据的JSON解析器。然而，XML仍然是一个重要的格式。我们的代码可能产生的一个可能的输出示例如下：
- en: '![How it works…](img/4929_11_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4929_11_04.jpg)'
- en: Using socket programming in games
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用套接字编程
- en: Socket programming is one of the earliest mechanisms for transferring data between
    end-to-end connections. Even now, if you are comfortable writing socket programming,
    it is a much better option for a relatively small game than using third party
    solutions, as they add a lot of extra space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字编程是最早用于在端到端连接之间传输数据的机制之一。即使现在，如果你习惯于编写套接字编程，它对于相对较小的游戏来说比使用第三方解决方案要好得多，因为它们会增加很多额外的空间。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要一个Windows机器和安装了Visual Studio的版本。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will find out how easy it is to write sockets:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将发现编写套接字是多么容易：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When two applications are communicating with each other on different machines,
    one end of that communication channel is often described as the socket. It is
    a combination of an IP address and a port. As we use signals or pipes to communicate
    in an inter-process communication environment on different machines, there is
    a need for sockets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个应用程序在不同的机器上进行通信时，通信通道的一端通常被描述为套接字。它是IP地址和端口的组合。当我们在不同的机器上使用信号或管道进行进程间通信时，就需要套接字。
- en: '**Berkley Sockets** (**BSD**) was the first internet socket API developed.
    Developed at the University of Berkley, California, and given freely to all Berkley
    System distributions of UNIX, it is present on all modern operating systems, which
    are UNIX variants, including OS X and Linux. Windows Sockets is based on BSD sockets
    and provides additional functionality to comply with the regular Windows programming
    model. Winsock2 is the newest API.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯克利套接字**（**BSD**）是第一个开发的互联网套接字API。它是在加利福尼亚大学伯克利分校开发的，并免费提供给UNIX的所有伯克利系统发行版，它存在于所有现代操作系统中，包括UNIX变体，如OS
    X和Linux。Windows套接字基于BSD套接字，并提供额外的功能以符合常规的Windows编程模型。Winsock2是最新的API。'
- en: 'Common domains are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的域有：
- en: '**AF UNIX**: This address format is UNIX pathname'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AF UNIX**：这个地址格式是UNIX路径名'
- en: '**AF INET**: This address format is host and port number'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AF INET**：这个地址格式是主机和端口号'
- en: 'The various protocols can be used in the following ways:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 各种协议可以以以下方式使用：
- en: 'TCP/IP (virtual circuits): SOCK_STREAM'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP（虚拟电路）：SOCK_STREAM
- en: 'UDP (datagram): SOCK_DGRAM'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP（数据报）：SOCK_DGRAM
- en: 'These are the steps to set up a simple socket connection:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是建立简单套接字连接的步骤：
- en: Create a socket.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个套接字。
- en: Bind the socket to an address.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字绑定到一个地址。
- en: Wait for input/output to be ready on the socket.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待套接字准备好进行输入/输出。
- en: Read and write to/from the socket.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从套接字读取和写入。
- en: Repeat from step 3 until you are done.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从步骤3直到完成。
- en: Close the socket.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭套接字。
- en: 'These steps are explained here with examples:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在这里通过示例进行了解释：
- en: '`int socket(domain, type, protocol)`:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int socket(domain, type, protocol)`：'
- en: The parameter `domain` should be set to `PF_INET` (protocol family) and the
    `type` is the connection type that it should be using. Use `SOCK_STREAM` for a
    byte stream socket, whereas `SOCK_DGRAM` is used for a datagram (packet) socket.
    `protocol` is the Internet protocol that is in use. `SOCK_STREAM` would normally
    give `IPPROTO_TCP`, and `SOCK_DGRAM` would normally give `IPPROTO_UDP`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`domain`应设置为`PF_INET`（协议族），而`type`是应该使用的连接类型。对于字节流套接字，使用`SOCK_STREAM`，而对于数据报（数据包）套接字，使用`SOCK_DGRAM`。`protocol`是正在使用的Internet协议。`SOCK_STREAM`通常会给出`IPPROTO_TCP`，而`SOCK_DGRAM`通常会给出`IPPROTO_UDP`。
- en: '`int sockfd;`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int sockfd;`'
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `socket()` function returns a socket descriptor for use in later system
    calls or `-1`. When the protocol is set to `0`, the socket chooses the correct
    protocol based on the type specified.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket()`函数返回一个套接字描述符，供以后的系统调用使用，或者返回`-1`。当协议设置为`0`时，套接字会根据指定的类型选择正确的协议。'
- en: '`int bind(int Socket, struct sockaddr *myAddress, int AddressLen )`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int bind(int Socket, struct sockaddr *myAddress, int AddressLen )`'
- en: The function `bind()` ties the socket to a local address. Socket is the socket
    descriptor. `myAddress` is the local IP address and port. The `AddressSize` parameter
    gives the size (in bytes) of the address and `bind()` returns `-1` on error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数将套接字绑定到本地地址。套接字是套接字描述符。`myAddress`是本地IP地址和端口。`AddressSize`参数给出地址的大小（以字节为单位），`bind()`在错误时返回`-1`。'
- en: '`struct sockaddr_in {`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct sockaddr_in {`'
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`struct sockaddr_in` is a parallel structure which makes it easy to reference
    elements of the socket address. `sin_port` and `sin_addr` must be in Network Byte
    Order.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct sockaddr_in`是一个并行结构，它使得引用套接字地址的元素变得容易。`sin_port`和`sin_addr`必须以网络字节顺序表示。'
- en: Sending the data
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送数据
- en: After we have correctly set up the sockets, the next step is to create the correct
    server and client architecture. Sending data is pretty simple and just involves
    a few lines of code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置了套接字之后，下一步是创建正确的服务器和客户端架构。发送数据非常简单，只涉及几行代码。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows with Visual
    Studio installed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要一台安装了Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to send data:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看到发送数据是多么容易：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The function that is used to communicate over the network is called `sendto`.
    This is declared as `int sendto (int sockfd, const void *msg, int len, int flags);`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在网络上通信的函数称为`sendto`。它声明为`int sendto(int sockfd, const void *msg, int len,
    int flags);`。
- en: '`sockfd` is the socket descriptor you want to send data to (returned by `socket()`
    or got from `accept()`), whereas `msg` is a pointer to the data you want to send.
    `len` is the length of that data in bytes. For simplicity, we can set that `flag`
    to `0` for now. `sendto()` returns the number of bytes actually sent (it may be
    less than the number you told it to send) or -`1` on error. By using just this
    function, you are able to send messages or data from one connection point to the
    other. This function can be used to send data across the network using the inbuilt
    Winsock functionality. The `send` function is used for streams of data and hence
    used for TCP. If we are to use datagrams and connectionless protocols, then we
    need to use the `sendto` function.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sockfd`是你想要发送数据的套接字描述符（由`socket()`返回或从`accept()`获得），而`msg`是指向你想要发送的数据的指针。`len`是数据的长度（以字节为单位）。为了简单起见，我们现在可以将`flag`设置为`0`。`sendto()`返回实际发送的字节数（可能少于你告诉它发送的数量），或者在错误时返回`-1`。通过使用这个函数，你可以从一个连接点发送消息或数据到另一个连接点。这个函数可以用于使用内置的Winsock功能在网络上发送数据。`send`函数用于数据流，因此用于TCP。如果我们要使用数据报和无连接协议，那么我们需要使用`sendto`函数。'
- en: Receiving the data
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收数据
- en: After we have correctly set up the sockets and sent the data, the next step
    is to receive the data. Receiving data is pretty simple and just involves a few
    lines of code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确设置了套接字并发送了数据之后，下一步是接收数据。接收数据非常简单，只涉及几行代码。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要一台安装了Visual Studio的Windows机器。
- en: How to do it…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to receive data over the network.
    There are two ways to do it, either by using the `recv` function or by using the
    `recvfrom` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看到如何在网络上接收数据是多么容易。有两种方法可以做到这一点，一种是使用`recv`函数，另一种是使用`recvfrom`函数：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Just like the `send` function, only one function is used to receive the data
    over the network, which can be declared as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`send`函数一样，只有一个函数用于在网络上接收数据，可以声明如下：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`sockfd` is the socket descriptor to read from. The next parameter, `buf`,
    is the buffer to read the information into, whereas `len` is the maximum length
    of the buffer. The next parameter, `recv()`, returns the number of bytes actually
    read into the buffer or `-1` on error. If `recv()` returns `0`, the remote side
    has closed the connection on you.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sockfd`是要从中读取的套接字描述符。下一个参数`buf`是要将信息读入的缓冲区，而`len`是缓冲区的最大长度。下一个参数`recv()`返回实际读入缓冲区的字节数，或者在错误时返回`-1`。如果`recv()`返回`0`，远程端已经关闭了连接。'
- en: Using this line of code, we can receive data over the network. If the data is
    serialized while sending, we have to then take the data and deserialize the data
    at this point. This process will vary based on the method used to serialize the
    data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这行代码，我们可以在网络上接收数据。如果数据在发送时被序列化，那么我们需要在这一点上对数据进行反序列化。这个过程将根据用于序列化数据的方法而有所不同。
- en: Dealing with lag
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理延迟
- en: One of the major problems that occurs in a networked game is latency or lag.
    When two players are playing against each other, and one is on a high-speed network
    and the other is on a very low-speed network, how do we update the data? We need
    to update it in such a way that it looks normal to both players. No player should
    get an undue advantage because of this situation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 网络游戏中经常出现的一个主要问题是延迟或卡顿。当两名玩家互相对战时，一方连接在高速网络上，另一方连接在非常低速的网络上，我们该如何更新数据呢？我们需要以一种方式更新数据，使得对两名玩家来说都看起来正常。没有玩家应该因为这种情况而获得不应有的优势。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，您需要一台运行Windows和Visual Studio的机器。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, you will see a few techniques for countering lag.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将看到一些对抗延迟的技术。
- en: 'Generally, a networked game will have the following update loop. We need to
    figure out, from the loop structure, what is the best way to counter lag:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个网络游戏会有以下更新循环。我们需要从循环结构中找出对抗延迟的最佳方法：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In most computer games, when networking is implemented, a specific type of
    client-server architecture is chosen. Often, an authoritative server is chosen.
    This means the server dictates the time, results, and other factors. The client
    is basically *dumb* and all it does is a simulation based on data from the server.
    Now let us consider that two players are playing a multiplayer FPS game. One of
    them is on a high-speed connection and the other connection is very slow. So,
    if the client is dependent on the server for its updates, it will be very difficult
    to accurately render the positions of the players on the client side. Let''s say
    `UserA` is on a high-speed connection whereas `UserB` is on a low-speed one. `UserA`
    fires a bullet at `UserB`. Note `UserA` and `UserB` are also moving in the world
    space. How do we calculate the position of the bullet and the position of each
    individual player? If we render exactly the information that is coming from the
    server, it will not be accurate as `UserA` would have already moved to a new position
    by the time `UserB` gets an update. To counter this, there are two commonly used
    solution. One is called client-side prediction. The other method is further divided
    into two more techniques: interpolation and extrapolation. Note that the round-trip
    time will be quite acceptable if the computers are connected over LAN. All the
    problems that are being discussed focus on networking over the Internet.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数电脑游戏中，当实施网络功能时，通常会选择特定类型的客户端-服务器架构。通常会选择一个有权威的服务器。这意味着服务器决定时间、结果和其他因素。客户端基本上是“愚蠢”的，它所做的一切都是基于来自服务器的数据进行模拟。现在让我们考虑两名玩家正在玩一款多人FPS游戏。其中一名玩家连接在高速网络上，另一名连接在低速网络上。因此，如果客户端依赖服务器进行更新，准确地在客户端渲染玩家的位置将会非常困难。假设`UserA`连接在高速网络上，而`UserB`连接在低速网络上。`UserA`向`UserB`开火。请注意，`UserA`和`UserB`也在世界空间中移动。我们如何计算子弹的位置和每个玩家的位置呢？如果我们准确地渲染来自服务器的信息，那将不准确，因为`UserA`在`UserB`收到更新之前可能已经移动到了新的位置。为了解决这个问题，通常有两种常用的解决方案。一种称为客户端预测。另一种方法进一步分为两种技术：插值和外推。请注意，如果计算机通过局域网连接，往返时间将是可以接受的。所有讨论的问题都集中在互联网上的网络连接。
- en: In client-side prediction, the *dumb* factor is taken out of the client and
    the client starts predicting, based on previous movement inputs, what the next
    position and animation states will be. Finally, when it gets an update from the
    server, the server will correct the mistakes and the position will be transformed
    to the currently received one. There are loads of problems with this system. If
    the prediction is wrong, there will be a big jitter as the position is changed
    to the right one. Also, let us consider sound and VFX effects. If the client at
    `UserA` predicted that `UserB` was walking and the footsteps sound was played,
    and later the server informed it that `UserB` was actually in water, how do we
    suddenly rectify that mistake? The same goes for VFX effects and states. This
    system was used in a lot of the *Quake* worlds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端预测中，客户端不再是“愚蠢”的，而是开始根据先前的移动输入来预测下一个位置和动画状态。最后，当它从服务器收到更新时，服务器将纠正错误，位置将被转换为当前接收到的位置。这种系统存在很多问题。如果预测错误，位置被更改为正确位置时会出现大的抖动。此外，让我们考虑声音和VFX效果。如果客户端`UserA`预测`UserB`正在行走并播放了脚步声音，后来服务器通知它`UserB`实际上在水中，我们该如何突然纠正这个错误呢？VFX效果和状态也是如此。这种系统在许多*Quake*世界中被使用。
- en: 'The second system has two parts: extrapolation and interpolation. In extrapolation,
    we render ahead of time. This is in some way similar to prediction. It takes the
    last known update from the server and then simulates forward in time. Thus, if
    you are lagging 500 milliseconds behind, and the last update you received was
    that the other player was running 300 units per second perpendicular to your view,
    then the client could assume that in *real time* the player has moved 150 units
    straight ahead from their last known position. The client could then just draw
    the player at that extrapolated position and the local player could still more
    or less aim right at the other player. However, the problem with this system is
    that it will rarely happen like that. The movement of the player may change, the
    state may change and hence this system should be avoided in most cases.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个系统有两个部分：外推和插值。在外推中，我们提前渲染。这在某种程度上类似于预测。它获取来自服务器的最后已知更新，然后在时间上向前模拟。因此，如果您落后500毫秒，并且您收到的最后更新是另一名玩家以每秒300个单位垂直于您的视图方向奔跑，那么客户端可以假设在“实时”中，玩家已经从他们最后已知的位置向前移动了150个单位。然后客户端可以在那个外推位置绘制玩家，本地玩家仍然可以更多或更少地瞄准另一名玩家。然而，这种系统的问题在于它很少会发生这样的情况。玩家的移动可能会改变，状态可能会改变，因此在大多数情况下应该避免使用这种系统。
- en: In interpolation, we always render objects in the past. For instance, if the
    server is sending 25 updates per second (exactly) of the world state, then we
    might impose 40 milliseconds of interpolation delay in our rendering. Then, as
    we render frames, we interpolate the position of the object between the last updated
    position and the position one update over that 40 milliseconds. Interpolation
    can be done by using the inbuilt lerp function in C++. As the object gets to the
    last updated position, we receive a new update from the server (since 25 updates
    per second means that the updates come in every 40 milliseconds) and we can start
    moving toward this new position over the next 40 milliseconds. The following picture
    shows the difference in positions of the hitbox from the server and the client
    side.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在插值中，我们总是渲染过去的对象。例如，如果服务器每秒发送25次世界状态更新（确切地说），那么我们可能会在渲染中施加40毫秒的插值延迟。然后，当我们渲染帧时，我们在最后更新的位置和该位置之后的一个更新之间插值对象的位置。插值可以通过使用C++中的内置lerp函数来完成。当对象到达最后更新的位置时，我们从服务器接收到新的更新（因为每秒25次更新意味着每40毫秒就会有更新），然后我们可以在接下来的40毫秒内开始朝着这个新位置移动。下图显示了来自服务器和客户端的碰撞箱位置的差异。
- en: '![How it works…](img/4929_11_05.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/4929_11_05.jpg)'
- en: If the packet does not arrive after 40 milliseconds, that is, there is a packet
    drop, then we have two options. The first option is to extrapolate using the method
    described above. The other option is to make the player go to an idle state till
    the next packet is received from the server.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据包在40毫秒后没有到达，也就是说，发生了数据包丢失，那么我们有两个选择。第一个选择是使用上面描述的方法进行外推。另一个选择是使玩家进入空闲状态，直到从服务器接收到下一个数据包。
- en: Using synchronized simulation
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用同步模拟。
- en: In a multiplayer game, there may be hundreds or thousands of computers connected
    at the same time. All of the computers will have different configurations. Speed
    will vary on all these computers. So the questions is, how do we synchronize the
    clock over all these systems so that they are all in sync?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在多人游戏中，可能会有数百或数千台计算机同时连接。所有计算机的配置都不同。所有这些计算机的速度也会有所不同。因此，问题是，我们如何同步所有这些系统上的时钟，使它们都同步？
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要一台运行Windows和Visual Studio的机器。
- en: How to do it…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we will look at, from a theoretical perspective, the two ways
    to synchronize clocks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将从理论角度看一下同步时钟的两种方法。
- en: 'Take a look at the following pseudocode:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下伪代码：
- en: Method 1
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法1
- en: Send a message to `UserA`. Note the time till he receives the message.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `UserA` 发送一条消息。记录时间，直到他收到消息。
- en: Send a message to `UserB`. Note the time again.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `UserB` 发送一条消息。再次记录时间。
- en: Calculate the median based on the values to decide an update time for updating
    the clock for both computers.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于值计算中位数，以决定更新时钟的时间，用于更新两台计算机的时钟。
- en: Method 2
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法2
- en: Let the server do most of the calculations.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让服务器进行大部分计算。
- en: Let the client do some local calculations.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让客户端进行一些本地计算。
- en: When the client receives the update from the server, then either correct its
    mistakes or interpolate based on the results.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端从服务器接收更新时，要么纠正错误，要么根据结果进行插值。
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we are trying to synchronize the clock, there are two methods. One method
    is that the server tries to find a median time to synchronize all the clocks.
    To do this, we can include the mechanics in the game design itself. The server
    needs to find out the response time of each client machine, so it has to send
    out messages. These messages can be to press *R* when ready, or a map is loaded
    on the client machine and the server takes a note of the time. Finally, when it
    has got a time from all the machines, it calculates a median and then updates
    the clock for all the machines at that time. The more messages the server sends
    out to the machines to calculate this median, the more accurate it will be. However,
    this in no way guarantees synchronization.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试同步时钟时，有两种方法。一种方法是服务器尝试找到一个中位时间来同步所有时钟。为了做到这一点，我们可以在游戏设计本身中包含机制。服务器需要找出每台客户机的响应时间，因此必须发送消息。这些消息可以是在准备好时按
    *R*，或者在客户机上加载地图并且服务器记录时间。最后，当它从所有机器中获得了时间，它计算一个中位数，然后在那个时间更新所有机器的时钟。服务器发送给机器计算这个中位数的消息越多，它就会越准确。然而，这并不保证同步。
- en: Therefore, a better method is that the server does all the calculations and
    the client does some local calculations as well, using techniques described in
    previous recipes. Finally, when the server sends an update to the client, the
    client can correct itself or interpolate to get the desired result. This is a
    much better result and a much better system to have.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个更好的方法是服务器进行所有计算，客户端也进行一些本地计算，使用之前配方中描述的技术。最后，当服务器向客户端发送更新时，客户端可以纠正自己或进行插值以获得期望的结果。这是一个更好的结果，也是一个更好的系统。
- en: Using area of interest filtering
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用兴趣区域过滤
- en: When we are writing a networking algorithm, we need to decide on the various
    objects or states that need updating to or from the server. The higher the number
    of objects, the more time it will take to serialize and send the data across.
    Therefore, there is a need to prioritize what needs to be updated every frame
    and which objects can wait for a few more cycles to be updated.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写网络算法时，我们需要决定需要向服务器更新或从服务器更新的各种对象或状态。对象的数量越多，序列化和发送数据所需的时间就越长。因此，有必要对每帧需要更新的内容进行优先级排序，以及哪些对象可以等待更多周期进行更新。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要一台运行Windows的机器。
- en: How to do it…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will see how easy it is to create area of interest filtering:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到创建兴趣区域过滤有多么容易：
- en: Create a list of all objects in the scene.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建场景中所有对象的列表。
- en: Add a parameter to each object denoting their priority.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个对象添加一个表示其优先级的参数。
- en: Based on that priority number, pass it on to the update logic of the game.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于优先级数字，将其传递给游戏的更新逻辑。
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In a game, we need to define the objects in a certain priority order. The priority
    order determines whether they should be updated now or at a later time. The objects
    that require prioritization depend a lot on the game design and a bit of research.
    For example, in an FPS game, the objects with high priority would be the person
    that the user is currently shooting at, the ammunition lying nearby, and of course
    the enemies in close proximity and their positions. This may be different in the
    case of an RPG or an RTS, so it definitely varies from one game to another.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们需要按一定的优先级顺序定义对象。优先级顺序决定它们现在是否应该更新或稍后更新。需要优先处理的对象在很大程度上取决于游戏设计和一些研究。例如，在FPS游戏中，具有高优先级的对象将是用户当前瞄准的人物，附近的弹药，当然还有附近的敌人及其位置。在RPG或RTS的情况下可能会有所不同，因此它在不同游戏中肯定是不同的。
- en: After we have tagged each object with a priority number, we can tell the update
    loop to just use the objects that are priority level 1 and 2 for per-frame updates,
    and use objects that are priority level 3 and 4 for late updates. This structure
    can also be modified by creating some sort of priority queue. From the queue,
    objects are popped out based on different update logic. The lower priority objects
    are also synced but at a later time, not in the current frame.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在为每个对象标记了优先级数字之后，我们可以告诉更新循环仅使用优先级为1和2的对象进行每帧更新，并使用优先级为3和4的对象进行延迟更新。这种结构也可以通过创建某种优先级队列来进行修改。从队列中，对象根据不同的更新逻辑弹出。较低优先级的对象也会同步，但在稍后的时间，而不是在当前帧中。
- en: Using local perception filter
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地感知滤波器
- en: This is yet another method to combat lag in networked games. This entire concept
    is mathematically based on the concept of perception. The basis of it is that
    if objects update and render correctly locally to a player, then we can create
    an illusion of realism, hence the name local perception filter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是网络游戏中对抗延迟的另一种方法。整个概念在数学上基于感知的概念。其基础是，如果对象在本地玩家的视图中正确更新和渲染，那么我们可以创造出一种逼真的幻觉，因此称为本地感知滤波器。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need a machine running Windows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，您需要一台运行Windows的计算机。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will understand the theoretical concept of how easy it is
    to implement bullet time. Take a look at the following pseudocode:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解实现子弹时间有多容易的理论概念。看一下以下伪代码：
- en: Calculate the velocity local to the player.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算相对于玩家的本地速度。
- en: Accelerate the bullet when it starts and slow it down as it reaches the remote
    player.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当子弹开始时加速它，并在它到达远程玩家时减速。
- en: From the remote player's point of view, the bullet should appear to have been
    shot at a higher speed than normal speed and then slow down to normal.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程玩家的角度来看，子弹应该看起来以比正常速度更快的速度射出，然后减速到正常速度。
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Local perception filters are also called bullet time, and were used for the
    first time in the movie *The Matrix*. Since then, they have been used in a wide
    range of games. It is quite easy to do in single player mode; however, in multiplayer
    it gets a bit more complex as it involves slowing down the rendering. Essentially,
    the process is to increase and reduce the speed of passive entities when they
    are near local and remote players. It is a method used to hide communication delays
    in networked virtual environments and was introduced in *A local perception filter
    for distributed virtual environments*, *P.M. Sharkey*, (page 242-249). For simplicity,
    we will call local players *p*, remote players *r*, and passive entities, such
    as bullets, *e*. Let us say that *d(i,j)* is delay, *delta(i,j)* is distance,
    and we get the following equations:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本地感知滤波器也称为子弹时间，首次在电影《黑客帝国》中使用。从那时起，它们已经在各种游戏中使用。在单人模式中很容易实现；然而，在多人模式中，由于涉及减慢渲染，它变得更加复杂。基本上，该过程是在本地和远程玩家附近时增加和减少被动实体的速度。这是一种用于隐藏网络虚拟环境中的通信延迟的方法，并在《分布式虚拟环境的本地感知滤波器》中介绍，*P.M.
    Sharkey*，（第242-249页）。为简单起见，我们将本地玩家称为*p*，远程玩家称为*r*，而被动实体，如子弹，称为*e*。假设*d(i,j)*是延迟，*delta(i,j)*是距离，我们得到以下方程：
- en: '![How it works…](img/4929_11_06.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_11_06.jpg)'
- en: In a graphical format, this can be explained by looking at the following graph.
    So with respect to *p*, it goes slow uphill and then fast downhill. With respect
    to *r*, it is faster at the top.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形格式，可以通过查看以下图表来解释这一点。因此，就*p*而言，它在上坡时速度较慢，然后在下坡时速度较快。就*r*而言，它在顶部速度更快。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One major limitation of the method is that this cannot be used for *insta-hit*
    weapons.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的一个主要限制是不能用于*瞬间命中*武器。
- en: '![How it works…](img/4929_11_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_11_07.jpg)'
- en: The problem is that when *e* reaches r, *p*'s view of e is not there yet, but
    *e* will speed up anyway in *p*'s view. To tackle this, we introduce a shadow
    *r*, which buffers *p*'s view of the speedup process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于当*e*到达*r*时，*p*对*e*的视图还没有到位，但是在*p*的视图中*e*会加速。为了解决这个问题，我们引入一个影子*r*，它缓冲了*p*对加速过程的视图。
- en: 'After adding the buffer, we will get the following revised graphs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 添加缓冲后，我们将得到以下修订后的图表：
- en: '![How it works…](img/4929_11_08.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/4929_11_08.jpg)'
- en: 'So at the top, won''t speed up until *r* is reached, and at the bottom it starts
    to show *e* at postion *p*. This can also be viewed as a demo at the following
    URL: [http://mikolalysenko.github.io/local-perception-filter-demo/](http://mikolalysenko.github.io/local-perception-filter-demo/).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在顶部，直到达到*r*之前不会加速，而在底部，它开始在位置*p*显示*e*。这也可以在以下网址查看演示：[http://mikolalysenko.github.io/local-perception-filter-demo/](http://mikolalysenko.github.io/local-perception-filter-demo/)。
