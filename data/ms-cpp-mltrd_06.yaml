- en: Debugging Multithreaded Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多线程代码
- en: Ideally, one's code would work properly the first time around, and contain no
    hidden bugs that are waiting to crash the application, corrupt data, or cause
    other issues. Realistically, this is, of course, impossible. Thus it is that tools
    were developed which make it easy to examine and debug multithreaded applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，自己的代码第一次就能正常工作，并且不包含等待崩溃应用程序、损坏数据或引起其他问题的隐藏错误。当然，这是不可能的。因此，开发了一些工具，使得检查和调试多线程应用程序变得容易。
- en: In this chapter, we will look at a number of them including a regular debugger
    as well as some of the tools which are part of the Valgrind suite, specifically,
    Helgrind and DRD. We will also look at profiling a multithreaded application in
    order to find hotspots and potential issues in its design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究其中一些内容，包括常规调试器以及Valgrind套件的一些工具，特别是Helgrind和DRD。我们还将研究如何对多线程应用程序进行性能分析，以找出设计中的热点和潜在问题。
- en: 'Topics covered in this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括以下内容：
- en: Introducing the Valgrind suite of tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Valgrind工具套件
- en: Using the Helgrind and DRD tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helgrind和DRD工具
- en: Interpreting the Helgrind and DRD analysis results
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Helgrind和DRD分析结果
- en: Profiling an application, and analyzing the results
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析应用程序的性能，并分析结果
- en: When to start debugging
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时开始调试
- en: Ideally, one would test and validate one's code every time one has reached a
    certain milestone, whether it's for a singular module, a number of modules, or
    the application as a whole. It's important to ascertain that the assumptions one
    makes match up with the ultimate functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，每次达到某个里程碑时，无论是针对单个模块、多个模块还是整个应用程序，都应该测试和验证自己的代码。重要的是要确定自己的假设是否与最终功能相匹配。
- en: Especially, with multithreaded code, there's a large element of coincidence
    in that a particular error state is not guaranteed to be reached during each run
    of the application. Signs of an improperly implemented multithreaded application
    may result in symptoms such as seemingly random crashes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在多线程代码中，巧合的因素很大，特定的错误状态不能保证在每次运行应用程序时都会达到。实现不正确的多线程应用程序的迹象可能导致似乎随机崩溃的症状。
- en: Likely the first hint one will get that something isn't correct is when the
    application crashes, and one is left with a core dump. This is a file which contains
    the memory content of the application at the time when it crashed, including the
    stack.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序崩溃时，留下核心转储时，可能会得到的第一个提示是，有些地方不正确。这是一个包含应用程序在崩溃时的内存内容的文件，包括堆栈。
- en: This core dump can be used in almost the same fashion as running a debugger
    with the running process. It is particularly useful to examine the location in
    the code at which we crashed, and in which thread. We can also examine memory
    contents this way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个核心转储可以以几乎与运行进程调试器相同的方式使用。它特别有用的是检查我们崩溃的代码位置以及线程。我们也可以通过这种方式检查内存内容。
- en: One of the best indicators that one is dealing with a multithreading issue is
    when the application never crashes in the same location (different stack trace),
    or when it always crashes around a point where one performs mutual exclusion operations,
    such as manipulating a global data structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多线程问题时最好的指标之一是应用程序从未在相同位置崩溃（不同的堆栈跟踪），或者总是在执行互斥操作的地方崩溃，例如操作全局数据结构。
- en: To start off, we'll first take a more in-depth look at using a debugger for
    diagnosing and debugging before diving into the Valgrind suite of tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将首先更深入地研究使用调试器进行诊断和调试，然后再深入Valgrind工具套件。
- en: The humble debugger
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谦逊的调试器
- en: Of all the questions a developer may have, the question of *why did my application
    just crash?* is probably among the most important. This is also one of the questions
    which are most easily answered with a debugger. Regardless of whether one is live
    debugging a process, or analyzing the core dump of a crashed process, the debugger
    can (hopefully) generate a back trace, also known as a stack trace. This trace
    contains a chronological list of all the functions which were called since the
    application was started as one would find them on the stack (see [Chapter 2](part0026.html#OPEK0-1ab5991b318547348fc444437bdacb24),
    *Multithreading Implementation on the Processor and OS*, for details on how a
    stack works).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能会有的所有问题中，“为什么我的应用程序刚刚崩溃？”这个问题可能是最重要的之一。这也是最容易用调试器回答的问题之一。无论是实时调试进程还是分析崩溃进程的核心转储，调试器都可以（希望）生成回溯，也称为堆栈跟踪。这个跟踪包含自应用程序启动以来调用的所有函数的时间顺序列表，就像它们在堆栈上找到的那样（有关堆栈工作原理的详细信息，请参见[第2章](part0026.html#OPEK0-1ab5991b318547348fc444437bdacb24)，*处理器和操作系统上的多线程实现*）。
- en: The last few entries of this back trace will thus show us in which part of the
    code things went wrong. If the debug information was compiled into the binary,
    or provided to the debugger, we can also see the code at that line along with
    the names of the variables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回溯的最后几个条目将告诉我们代码的哪个部分出了问题。如果调试信息被编译到二进制文件中，或者提供给调试器，我们还可以看到该行的代码以及变量的名称。
- en: Even better, since we're looking at the stack frames, we can also examine the
    variables within that stack frame. This means the parameters passed to the function
    along with any local variables and their values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，因为我们正在查看堆栈帧，我们还可以检查该堆栈帧中的变量。这意味着传递给函数的参数以及任何局部变量及其值。
- en: 'In order to have the debug information (symbols) available, one has to compile
    the source code with the appropriate compiler flags set. For GCC, one can select
    a host of debug information levels and types. Most commonly, one would use the
    `-g` flag with an integer specifying the debug level attached, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使调试信息（符号）可用，必须使用适当的编译器标志编译源代码。对于GCC，可以选择一系列调试信息级别和类型。最常见的是使用`-g`标志，后面附加一个指定调试级别的整数，如下所示：
- en: '`-g0`: produces no debug information (negates `-g`)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g0`：不生成调试信息（否定`-g`）'
- en: '`-g1`: minimal information on function descriptions and external variables'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g1`：函数描述和外部变量的最小信息'
- en: '`-g3`: all information including macro definitions'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g3`：包括宏定义在内的所有信息'
- en: This flag instructs GCC to generate debug information in the native format for
    the OS. One can also use different flags to generate the debug information in
    a specific format; however, this is not necessary for use with GCC's debugger
    (GDB) as well as with the Valgrind tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志指示GCC以OS的本机格式生成调试信息。也可以使用不同的标志以特定格式生成调试信息；但是，这对于GCC的调试器（GDB）以及Valgrind工具并不是必需的。
- en: Both GDB and Valgrind will use this debug information. While it's technically
    possible to use both without having the debug information available, that's best
    left as an exercise for truly desperate times.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GDB和Valgrind都将使用这些调试信息。虽然在没有调试信息的情况下使用两者是技术上可能的，但最好留给真正绝望的时候去练习。
- en: GDB
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDB
- en: One of the most commonly used debuggers for C-based and C++-based code is the
    GNU Debugger, or GDB for short. In the following example, we'll use this debugger
    due to it being both widely used and freely available. Originally written in 1986,
    it's now used with a wide variety of programming languages, and has become the
    most commonly used debugger, both in personal and professional use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用于基于C和C++的代码的最常用的调试器之一是GNU调试器，简称GDB。在下面的示例中，我们将使用这个调试器，因为它被广泛使用并且免费提供。最初于1986年编写，现在与各种编程语言一起使用，并且已成为个人和专业使用中最常用的调试器。
- en: The most elemental interface for GDB is a command-line shell, but it can be
    used with graphical frontends, which also include a number of IDEs such as Qt
    Creator, Dev-C++, and Code::Blocks. These frontends and IDEs can make it easier
    and more intuitive to manage breakpoints, set up watch variables, and perform
    other common operations. Their use is, however, not required.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GDB的最基本接口是命令行shell，但它可以与图形前端一起使用，这些前端还包括一些IDE，如Qt Creator、Dev-C++和Code::Blocks。这些前端和IDE可以使管理断点、设置监视变量和执行其他常见操作变得更加容易和直观。但是，它们的使用并不是必需的。
- en: On Linux and BSD distributions, gdb is easily installed from a package, just
    as it is on Windows with MSYS2 and similar UNIX-like environments. For OS X/MacOS,
    one may have to install gdb using a third-party package manager such as Homebrew.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和BSD发行版上，gdb可以轻松从软件包中安装，就像在Windows上使用MSYS2和类似的类UNIX环境一样。对于OS X/MacOS，可能需要使用Homebrew等第三方软件包管理器安装gdb。
- en: Since gdb is not normally code signed on MacOS, it cannot gain the system-level
    access it requires for normal operation. Here one can either run gdb as root (not
    recommended), or follow a tutorial relevant to your version of MacOS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在MacOS上通常不对gdb进行代码签名，因此它无法获得正常操作所需的系统级访问权限。在这里，可以以root身份运行gdb（不建议），或者按照与您的MacOS版本相关的教程进行操作。
- en: Debugging multithreaded code
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多线程代码
- en: 'As mentioned earlier, there are two ways to use a debugger, either by starting
    the application from within the debugger (or attaching to the running process),
    or by loading a core dump file. Within the debugging session, one can either interrupt
    the running process (with *Ctrl*+*C*, which sends the `SIGINT` signal), or load
    the debug symbols for the loaded core dump. After this, we can examine the active
    threads in this frame:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有两种使用调试器的方法，一种是从调试器内启动应用程序（或附加到运行中的进程），另一种是加载核心转储文件。在调试会话中，可以中断运行进程（使用*Ctrl*+*C*发送`SIGINT`信号），或者加载加载的核心转储的调试符号。之后，我们可以检查此帧中的活动线程：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we can see how after sending the `SIGINT` signal to the
    application (a Qt-based application running on OS X), we request the list of all
    threads which exist at this point in time along with their thread number, ID,
    and the function which they are currently executing. This also shows clearly which
    threads are likely waiting based on the latter information, as is often the case
    of a graphical user interface application like this one. Here we also see that
    the thread which is currently active in the application as marked by the asterisk
    in front of its number (thread 1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到在向应用程序发送`SIGINT`信号后（在OS X上运行的基于Qt的应用程序），我们请求此时存在的所有线程的列表，以及它们的线程编号、ID和它们当前正在执行的函数。根据后者的信息，这也清楚地显示了哪些线程可能正在等待，这在像这样的图形用户界面应用程序中经常发生。在这里，我们还看到当前活动的线程在应用程序中由其编号前的星号标记（线程1）。
- en: We can also switch between threads at will by using the `thread <ID>` command,
    and move `up` and `down` between a thread's stack frames. This allows us to examine
    every aspect of individual threads.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`thread <ID>`命令随意在线程之间切换，并在线程的堆栈帧之间移动`up`和`down`。这使我们能够检查每个线程的每个方面。
- en: When full debug information is available, one would generally also see the exact
    line of code that a thread is executing. This means that during the development
    stage of an application, it makes sense to have as much debug information available
    as possible to make debugging much easier.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当完整的调试信息可用时，通常还会看到线程正在执行的确切代码行。这意味着在应用程序的开发阶段，有尽可能多的调试信息是有意义的，以使调试变得更加容易。
- en: Breakpoints
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断点
- en: 'For the dispatcher code we looked at in [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Threading Synchronization and Communication*, we can set a breakpoint to allow
    us to examine the active threads as well:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在[第4章](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24)中查看的调度器代码，*线程同步和通信*，我们可以设置断点以允许我们检查活动线程：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in the above command line output, we start GDB with the name of
    the application we wish to debug as a parameter, here from a Bash shell under
    Windows. After this, we can set a breakpoint here, using the filename of the source
    file and the line we wish to break at after the (gdb) of the gdb command line
    input. We select the first line after the loop in which the requests get sent
    to the dispatcher, then run the application. This is followed by the list of the
    new threads which are being created by the dispatcher, as reported by GDB.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上面的命令行输出中所看到的，我们使用应用程序的名称作为参数启动GDB，这里是在Windows下的Bash shell中。之后，我们可以在这里设置一个断点，使用源文件的文件名和我们希望在其后中断的行号，然后运行应用程序。接着是由GDB报告的由调度程序创建的新线程的列表。
- en: 'Next, we wait until the breakpoint is hit:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们等待直到断点被触发：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon reaching the breakpoint, an *info threads* command lists the active threads.
    Here we can clearly see the use of condition variables where a thread is waiting
    in `ntdll!ZwWaitForMultipleObjects()`. As covered in [Chapter 3](part0045.html#1AT9A0-1ab5991b318547348fc444437bdacb24),
    *C++ Multithreading APIs*, this is part of the condition variable implementation
    on Windows using its native multithreading API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 达到断点后，*info threads*命令列出了活动线程。在这里，我们可以清楚地看到条件变量的使用，其中一个线程在`ntdll!ZwWaitForMultipleObjects()`中等待。正如[第3章](part0045.html#1AT9A0-1ab5991b318547348fc444437bdacb24)中所介绍的，*C++多线程API*，这是Windows使用其本地多线程API实现条件变量的一部分。
- en: When we create a back trace (`bt` command), we see that the current stack for
    thread 1 (the current thread) is just one frame, only for the main method, since
    we didn't call into another function from this starting point at this line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个回溯（`bt`命令）时，我们可以看到线程1（当前线程）的当前堆栈只有一个帧，只有主方法，因为我们从这个起始点的这一行没有调用其他函数。
- en: Back traces
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回溯
- en: 'During normal application execution, such as with the GUI application we looked
    at earlier, sending `SIGINT` to the application can also be followed by the command
    to create a back trace like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的应用程序执行过程中，比如我们之前看过的GUI应用程序，向应用程序发送`SIGINT`也可以跟随着创建回溯的命令，就像这样：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this preceding code, we can see the execution of thread ID 1 from its creation,
    through the entry point (main). Each subsequent function call is added to the
    stack. When a function finishes, it is removed from the stack. This is both a
    benefit and a disadvantage. While it does keep the back trace nice and clean,
    it also means that the history of what happened before the last function call
    is no longer there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以看到线程ID 1的执行，从创建开始，通过入口点（main）。每个后续的函数调用都被添加到堆栈中。当一个函数结束时，它就会从堆栈中移除。这既是一个好处，也是一个缺点。虽然它确实保持了回溯的干净整洁，但也意味着在最后一个函数调用之前发生的历史已经不复存在。
- en: If we create a back trace with a core dump file, not having this historical
    information can be very annoying, and possibly make one start on a wild goose
    chase as one tries to narrow down the presumed cause of a crash. This means that
    a certain level of experience is required for successful debugging.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用核心转储文件创建一个回溯，没有这些历史信息可能会非常恼人，并且可能会让人在试图缩小崩溃原因的范围时陷入困境。这意味着需要一定水平的经验才能成功调试。
- en: In case of a crashed application, the debugger will start us on the thread which
    suffered the crash. Often, this is the thread with the problematic code, but it
    could be that the real fault lies with code executed by another thread, or even
    the unsafe use of variables. If one thread were to change the information that
    another thread is currently reading, the latter thread could end up with garbage
    data. The result of this could be a crash, or even worse--corruption, later in
    the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序崩溃的情况下，调试器会将我们带到遭受崩溃的线程。通常，这是有问题代码的线程，但也可能是真正的错误在于另一个线程执行的代码，甚至是变量的不安全使用。如果一个线程改变了另一个线程当前正在读取的信息，后者可能会得到垃圾数据。这可能导致崩溃，甚至更糟糕的是，在应用程序的后续过程中出现损坏。
- en: The worst-case scenario consists of the stack getting overwritten by, for example,
    a wild pointer. In this case, a buffer or similar on the stack gets written past
    its limit, thus erasing parts of the stack by filling it with new data. This is
    a buffer overflow, and can both lead to the application crashing, or the (malicious)
    exploitation of the application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是堆栈被覆盖，例如被野指针。在这种情况下，堆栈上的缓冲区或类似的东西被写入超出其限制，从而通过填充新数据来擦除堆栈的部分。这就是缓冲区溢出，可能导致应用程序崩溃，或者（恶意）利用应用程序。
- en: Dynamic analysis tools
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分析工具
- en: 'Although the value of a debugger is hard to dismiss, there are times when one
    needs a different type of tool to answer questions about things such as memory
    usage, leaks, and to diagnose or prevent threading issues. This is where tools
    such as those which are part of the Valgrind suite of dynamic analysis tools can
    be of great help. As a framework for building dynamic analysis tools, the Valgrind
    distribution currently contains the following tools which are of interest to us:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管调试器的价值难以忽视，但有时需要不同类型的工具来回答关于内存使用、泄漏以及诊断或预防线程问题等问题。这就是Valgrind动态分析工具套件中的工具可以提供极大帮助的地方。作为构建动态分析工具的框架，Valgrind发行版目前包含以下我们感兴趣的工具：
- en: Memcheck
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcheck
- en: Helgrind
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helgrind
- en: DRD
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRD
- en: Memcheck is a memory error detector, which allows us to discover memory leaks,
    illegal reads and writes, as well as allocation, deallocation, and similar memory-related
    issues.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck是一种内存错误检测器，它允许我们发现内存泄漏、非法读写，以及分配、释放等与内存相关的问题。
- en: Helgrind and DRD are both thread error detectors. This basically means that
    they will attempt to detect any multithreading issues such as data races and incorrect
    use of mutexes. Where they differ is that Helgrind can detect locking order violations,
    and DRD supports detached threads, while also using less memory than Helgrind.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind和DRD都是线程错误检测器。这基本上意味着它们将尝试检测任何多线程问题，如数据竞争和互斥锁的不正确使用。它们的区别在于Helgrind可以检测锁定顺序的违规，而DRD支持分离的线程，同时使用的内存比Helgrind少。
- en: Limitations
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制
- en: A major limitation with dynamic analysis tools is that they require tight integration
    with the host operating system. This is the primary reason why Valgrind is focused
    on POSIX threads, and does not currently work on Windows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析工具的一个主要限制是它们需要与主机操作系统紧密集成。这是Valgrind专注于POSIX线程的主要原因，目前不适用于Windows。
- en: 'The Valgrind website (at [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html))
    describes the issue as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind网站（[http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html)）描述了该问题如下：
- en: '"Windows is not under consideration because porting to it would require so
    many changes it would almost be a separate project. (However, Valgrind + Wine
    can be made to work with some effort.) Also, non-open-source OSes are difficult
    to deal with; being able to see the OS and associated (libc) source code makes
    things much easier. However, Valgrind is quite usable in conjunction with Wine,
    which means that it is possible to run Windows programs under Valgrind with some
    effort."'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “Windows不在考虑范围之内，因为将其移植到Windows将需要很多更改，几乎可以成为一个单独的项目。（但是，Valgrind + Wine可以通过一些努力来实现。）此外，非开源操作系统很难处理；能够看到操作系统和相关（libc）源代码使事情变得更容易。但是，Valgrind在与Wine一起使用时非常有用，这意味着可以通过一些努力在Valgrind下运行Windows程序。”
- en: Basically, this means that Windows applications can be debugged with Valgrind
    under Linux with some difficulty, but using Windows as the OS won't happen any
    time soon.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这意味着Windows应用程序可以在Linux下使用Valgrind进行调试，但是使用Windows作为操作系统不会很快发生。
- en: Valgrind does work on OS X/macOS, starting with OS X 10.8 (Mountain Lion). Support
    for the latest version of macOS may be somewhat incomplete due to changes made
    by Apple, however. As with the Linux version of Valgrind, it's generally best
    to always use the latest version of Valgrind. As with gdb, use the distro's package
    manager, or a third-party one like Homebrew on MacOS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind在OS X/macOS上可以工作，从OS X 10.8（Mountain Lion）开始。由于苹果公司所做的更改，对最新版本的macOS的支持可能会有些不完整。与Valgrind的Linux版本一样，最好始终使用最新版本的Valgrind。与gdb一样，使用发行版的软件包管理器，或者在MacOS上使用Homebrew等第三方软件包管理器。
- en: Alternatives
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代方案
- en: 'Alternatives to the Valgrind tools on Windows and other platforms include the
    ones listed in the following table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows和其他平台上替代Valgrind工具的选择包括以下表中列出的工具：
- en: '| **Name** | **Type** | **Platforms** | **License** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **类型** | **平台** | **许可证** |'
- en: '| Dr. Memory | Memory checker | All major platforms | Open source |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| Dr. Memory | 内存检查器 | 所有主要平台 | 开源 |'
- en: '| gperftools (Google) | Heap, CPU, and call profiler | Linux (x86) | Open source
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| gperftools（Google） | 堆，CPU和调用分析器 | Linux（x86） | 开源 |'
- en: '| Visual Leak Detector | Memory checker | Windows (Visual Studio) | Open Source
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Visual Leak Detector | 内存检查器 | Windows（Visual Studio） | 开源 |'
- en: '| Intel Inspector | Memory and thread debugger | Windows, Linux | Proprietary
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Intel Inspector | 内存和线程调试器 | Windows，Linux | 专有 |'
- en: '| PurifyPlus | Memory, performance | Windows, Linux | Proprietary |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| PurifyPlus | 内存，性能 | Windows，Linux | 专有 |'
- en: '| Parasoft Insure++ | Memory and thread debugger | Windows, Solaris, Linux,
    AIX | Proprietary |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Parasoft Insure++ | 内存和线程调试器 | Windows，Solaris，Linux，AIX | 专有 |'
- en: Memcheck
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Memcheck
- en: 'Memcheck is the default Valgrind tool when no other tool is specified in the
    parameters to its executable. Memcheck itself is a memory error detector capable
    of detecting the following types of issues:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有在其可执行文件的参数中指定其他工具时，Memcheck是默认的Valgrind工具。 Memcheck本身是一个内存错误检测器，能够检测以下类型的问题：
- en: Accessing memory outside of allocated bounds, overflowing of the stack, and
    accessing previously freed memory blocks
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问已分配边界之外的内存，堆栈溢出以及访问先前释放的内存块
- en: The use of undefined values, which are variables which have not been initialized
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未定义值，即未初始化的变量
- en: Improper freeing of heap memory including repeatedly freeing blocks
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误释放堆内存，包括重复释放块
- en: Mismatched use of C- and C++-style memory allocations as well as array allocators
    and deallocators (`new[]` and `delete[]`)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不匹配使用C和C++风格的内存分配，以及数组分配器和解除分配器（`new[]`和`delete[]`）
- en: Overlapping source and destination pointers in functions such as `memcpy`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在诸如`memcpy`之类的函数中重叠源和目标指针
- en: The passing of an invalid (for example, negative) value as the size parameter
    to `malloc` or similar functions
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将无效值（例如负值）作为`malloc`或类似函数的大小参数传递
- en: Memory leaks; that is, heap blocks without any valid reference to them
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏；即，没有任何有效引用的堆块
- en: Using a debugger or a simple task manager, it's practically impossible to detect
    issues such as the ones given in the preceding list. The value of Memcheck lies
    in being able to detect and fix issues early in development, which otherwise can
    lead to corrupted data and mysterious crashes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试器或简单的任务管理器，几乎不可能检测到前面列表中给出的问题。 Memcheck的价值在于能够在开发的早期检测和修复问题，否则可能会导致数据损坏和神秘崩溃。
- en: Basic use
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Using Memcheck is fairly easy. If we take the demo application we created in
    [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24), *Thread Synchronization
    and Communication*, we know that normally we start it using this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Memcheck非常容易。如果我们使用[第4章](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24)中创建的演示应用程序，*线程同步和通信*，我们知道通常我们使用以下方式启动它：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To run Valgrind with the default Memcheck tool while also logging the resulting
    output to a log file, we would start it as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用默认的Memcheck工具运行Valgrind，并将生成的输出记录到日志文件中，我们将如下启动它：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the preceding command, we will log Memcheck's output to a file called `dispatcher.log`,
    and also enable the full checking of memory leaks, including detailed reporting
    of where these leaks occur, using the available debug information in the binary.
    By also reading the variable information (`--read-var-info=yes`), we get even
    more detailed information on where a memory leak occurred.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述命令，我们将Memcheck的输出记录到一个名为`dispatcher.log`的文件中，并且还启用了对内存泄漏的全面检查，包括详细报告这些泄漏发生的位置，使用二进制文件中可用的调试信息。通过读取变量信息（`--read-var-info=yes`），我们可以获得更详细的关于内存泄漏发生位置的信息。
- en: One cannot log to a file, but unless it's a very simple application, the produced
    output from Valgrind will likely be so much that it probably won't fit into the
    terminal buffer. Having the output as a file allows one to use it as a reference
    later as well as search it using more advanced tools than what the terminal usually
    provides.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不能将日志记录到文件中，但除非是一个非常简单的应用程序，否则Valgrind生成的输出很可能太多，可能无法适应终端缓冲区。将输出作为文件允许我们稍后使用它作为参考，并使用比终端通常提供的更高级的工具进行搜索。
- en: 'After running this, we can examine the produced log file''s contents as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完这个命令后，我们可以按照以下方式检查生成的日志文件的内容：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here we can see that we have a total of three memory leaks. Two are from allocations
    in the `dispatcher` class on lines 38 and 40:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们总共有三个内存泄漏。其中两个是在第38行和第40行的`dispatcher`类中分配的：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And the other one is this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also see a leak from an allocation at line 60 in `main.cpp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了在`main.cpp`的第60行分配的内存泄漏：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although there is nothing wrong with these allocations themselves, if we trace
    them during the application life cycle, we notice that we never call `delete`
    on these objects. If we were to fix these memory leaks, we would need to delete
    those `Request` instances once we're done with them, and clean up the `Worker`
    and `thread` instances in the destructor of the `dispatcher` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些分配本身没有问题，但是如果我们在应用程序生命周期中跟踪它们，我们会注意到我们从未在这些对象上调用`delete`。如果我们要修复这些内存泄漏，我们需要在完成后删除这些`Request`实例，并在`dispatcher`类的析构函数中清理`Worker`和`thread`实例。
- en: Since in this demo application the entire application is terminated and cleaned
    up by the OS at the end of its run, this is not really a concern. For an application
    where the same dispatcher is used in a way where new requests are being generated
    and added constantly, while possibly also dynamically scaling the number of worker
    threads, this would, however, be a real concern. In this situation, care would
    have to be taken that such memory leaks are resolved.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个演示应用程序中，整个应用程序在运行结束时由操作系统终止并清理，所以这并不是一个真正的问题。对于一个应用程序，在这个应用程序中，同一个调度程序以一种不断生成和添加新请求的方式被使用，同时可能还动态地扩展工作线程的数量，这将是一个真正的问题。在这种情况下，必须小心解决这些内存泄漏问题。
- en: Error types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误类型
- en: Memcheck can detect a wide range of memory-related issues. The following sections
    summarize these errors and their meanings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck可以检测到各种与内存相关的问题。以下部分总结了这些错误及其含义。
- en: Illegal read / illegal write errors
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非法读取/非法写入错误
- en: 'These errors are usually reported in the following format:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误通常以以下格式报告：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line in the preceding error message tells one whether it was an invalid
    read or write access. The next few lines will be a back trace detailing the location
    (and possibly, the line in the source file) from which the invalid read or write
    was performed, and from where that code was called.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面错误消息的第一行将告诉我们是无效的读取还是写入访问。接下来的几行将是一个回溯，详细说明了发生无效读取或写入的位置（可能还包括源文件中的行），以及调用该代码的位置。
- en: Finally, the last line will detail the type of illegal access that occurred,
    such as the reading of an already freed block of memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将详细说明发生的非法访问类型，比如读取已经释放的内存块。
- en: This type of error is indicative of writing into or reading from a section of
    memory which one should not have access to. This can happen because one accesses
    a wild pointer (that is, referencing a random memory address), or due to an earlier
    issue in the code which caused a wrong memory address to be calculated, or a memory
    boundary not being respected, and reading past the bounds of an array or similar.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误表明写入或读取一个不应该访问的内存部分。这可能是因为访问了一个野指针（即引用一个随机的内存地址），或者是由于代码中的早期问题导致了错误的内存地址计算，或者是没有尊重内存边界，读取了数组或类似结构的边界之外。
- en: Usually, when this type of error is reported, it should be taken highly seriously,
    as it indicates a fundamental issue which can lead not only to data corruption
    and crashes, but also to bugs which can be exploited by others.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当报告这种类型的错误时，应该非常重视，因为它表明存在一个基本问题，不仅可能导致数据损坏和崩溃，还可能导致其他人可以利用的错误。
- en: Use of uninitialized values
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用未初始化的值
- en: In short, this is the issue where a variable's value is used without the said
    variable having been assigned a value. At this point, it's likely that these contents
    are just whichever bytes were in that part of RAM which just got allocated. As
    a result, this can lead to unpredictable behavior whenever these contents are
    used or accessed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这是一个变量的值在没有被赋值的情况下被使用的问题。在这一点上，很可能这些内容只是刚刚分配的RAM部分中的任意字节。因此，每当使用或访问这些内容时，可能会导致不可预测的行为。
- en: 'When encountered, Memcheck will throw errors similar to these:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到时，Memcheck会抛出类似于这样的错误：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This particular series of errors was caused by the following small bit of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列特定的错误是由以下一小段代码引起的：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see in the preceding code, we never initialize our variable, which
    would be set to just any random value. If one is lucky, it'll be set to zero,
    or an equally (hopefully) harmless value. This code shows just how any of our
    uninitialized variables enter into library code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码中所看到的，我们从未初始化我们的变量，这将被设置为任意的随机值。如果幸运的话，它将被设置为零，或者一个同样（希望如此）无害的值。这段代码展示了我们的任何未初始化的变量如何进入库代码。
- en: Whether or not the use of uninitialized variables is harmful is hard to say,
    and depends heavily on the type of variable and the affected code. It is, however,
    far easier to simply assign a safe, default value than it is to hunt down and
    debug mysterious issues which may be caused (at random) by an uninitialized variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化变量的使用是否有害很难说，这在很大程度上取决于变量的类型和受影响的代码。然而，简单地分配一个安全的默认值要比追踪和调试可能由未初始化变量（随机）引起的神秘问题要容易得多。
- en: For additional information on where an uninitialized variable originates, one
    can pass the `-track-origins=yes` flag to Memcheck. This will tell it to keep
    more information per variable, which will make the tracking down of this type
    of issue much easier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解未初始化变量的来源，可以向Memcheck传递`-track-origins=yes`标志。这将告诉它为每个变量保留更多信息，这将使追踪此类问题变得更容易。
- en: Uninitialized or unaddressable system call values
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未初始化或不可寻址的系统调用值
- en: 'Whenever a function is called, it''s possible that uninitialized values are
    passed as parameters, or even pointers to a buffer which is unaddressable. In
    either case, Memcheck will log this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用一个函数时，可能会传递未初始化的值作为参数，甚至是指向不可寻址的缓冲区的指针。在任何一种情况下，Memcheck都会记录这一点：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding log was generated by this code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的日志是由这段代码生成的：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much like the general use of uninitialized values as detailed in the previous
    section, the passing of uninitialized, or otherwise dodgy, parameters is, at the
    very least, risky, and in the worst case, a source of crashes, data corruption,
    or worse.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一节详细介绍的未初始化值的一般用法类似，传递未初始化或其他可疑的参数，至少是有风险的，最坏的情况下可能导致崩溃、数据损坏或更糟的情况。
- en: Illegal frees
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非法释放
- en: An illegal free or delete is usually an attempt to repeatedly call `free()`
    or `delete()` on an already deallocated block of memory. While not necessarily
    harmful, this would be indicative of bad design, and would absolutely have to
    be fixed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 非法的释放或删除通常是指尝试重复调用`free()`或`delete()`来释放已经释放的内存块。虽然不一定有害，但这表明设计不良，绝对需要修复。
- en: It can also occur when one tries to free a memory block using a pointer which
    does not point to the beginning of that memory block. This is one of the primary
    reasons why one should never perform pointer arithmetic on the original pointer
    one obtains from a call to `malloc()` or `new()`, but use a copy instead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用不指向该内存块开头的指针释放内存块时，也可能会发生这种情况。这是为什么我们永远不应该对从`malloc()`或`new()`调用获得的原始指针进行指针算术运算，而是使用副本的主要原因之一。
- en: Mismatched deallocation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不匹配的释放
- en: Allocation and deallocation of memory blocks should always be performed using
    matching functions. This means that when we allocate using C-style functions,
    we deallocate with the matching function from the same API. The same is true for
    C++-style allocation and deallocation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内存块的分配和释放应该始终使用匹配的函数。这意味着当我们使用C风格函数分配时，我们使用相同API的匹配函数释放。对于C++风格的分配和释放也是如此。
- en: 'Briefly, this means the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着以下内容：
- en: If we allocate using `malloc`, `calloc`, `valloc`, `realloc,` or `memalign`,
    we deallocate with `free`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`malloc`、`calloc`、`valloc`、`realloc`或`memalign`分配，我们使用`free`释放
- en: If we allocate with new, we deallocate with `delete`
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用new分配，我们使用`delete`释放
- en: If we allocate with `new[]`, we deallocate with `delete[]`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用`new[]`分配，我们使用`delete[]`释放
- en: Mixing these up won't necessarily cause problems, but doing so is undefined
    behavior. The latter type of allocating and deallocating is specific to arrays.
    Not using `delete[]` for an array that was allocated with `new[]` likely leads
    to a memory leak, or worse.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆这些不一定会导致问题，但这样做是未定义的行为。后一种类型的分配和释放是特定于数组的。对使用`new[]`分配的数组不使用`delete[]`可能会导致内存泄漏，甚至更糟。
- en: Overlapping source and destination
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重叠的源和目的地
- en: This type of error indicates that the pointers passed for a source and destination
    memory block overlap (based on expected size). The result of this type of bug
    is usually a form of corruption or system crash.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误表明传递给源和目的地内存块的指针重叠（基于预期大小）。这种错误的结果通常是一种形式的损坏或系统崩溃。
- en: Fishy argument values
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可疑的参数值
- en: 'For memory allocation functions, Memcheck validates whether the arguments passed
    to them actually make sense. One example of this would be the passing of a negative
    size, or if it would far exceed a reasonable allocation size: for example, an
    allocation request for a petabyte of memory. Most likely, these values would be
    the result of a faulty calculation earlier in the code.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存分配函数，Memcheck会验证传递给它们的参数是否真的有意义。其中一个例子是传递负大小，或者它将远远超出合理的分配大小：例如，请求分配一百万兆字节的内存。这些值很可能是代码中早期错误计算的结果。
- en: 'Memcheck would report this error like in this example from the Memcheck manual:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck会像Memcheck手册中的这个例子一样报告这个错误：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here it was attempted to pass the value of -3 to `malloc`, which obviously doesn't
    make a lot of sense. Since this is obviously a nonsensical operation, it's indicative
    of a serious bug in the code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尝试将值-3传递给`malloc`，这显然没有多大意义。由于这显然是一个荒谬的操作，这表明代码中存在严重的错误。
- en: Memory leak detection
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏检测
- en: 'The most important thing to keep in mind for Memcheck''s reporting of memory
    leaks is that a lot of reported *leaks* may in fact not be leaks. This is reflected
    in the way Memcheck reports any potential issues it finds, which is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Memcheck报告的内存泄漏，最重要的是，许多报告的*泄漏*实际上可能并不是泄漏。这反映在Memcheck报告它发现的任何潜在问题的方式如下：
- en: Definitely lost
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对丢失
- en: Indirectly lost
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间接丢失
- en: Possibly lost
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能丢失
- en: Of the three possible report types, the **Definitely lost** type is the only
    one where it is absolutely certain that the memory block in question is no longer
    reachable, with no pointer or reference remaining, which makes it impossible for
    the application to ever free the memory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种可能的报告类型中，**绝对丢失**类型是唯一一种绝对确定所涉及的内存块不再可达的情况，没有剩余的指针或引用，这使得应用程序永远无法释放内存。
- en: In case of the **Indirectly lost** type, we did not lose the pointer to these
    memory blocks themselves, but, the pointer to a structure which refers to these
    blocks instead. This could, for example, occur when we directly lose access to
    the root node of a data structure (such as a red/black or binary tree). As a result,
    we also lose the ability to access any of the child nodes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在**间接丢失**类型的情况下，我们并没有丢失这些内存块本身的指针，而是丢失了指向这些块的结构的指针。例如，当我们直接丢失对数据结构的根节点（如红/黑树或二叉树）的访问权限时，就会发生这种情况。结果，我们也失去了访问任何子节点的能力。
- en: Finally, **Possibly lost** is the catch-all type where Memcheck isn't entirely
    certain whether there is still a reference to the memory block. This can happen
    where interior pointers exist, such as in the case of particular types of array
    allocations. It can also occur through the use of multiple inheritance, where
    a C++ object uses self-reference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**可能丢失**是一个综合类型，Memcheck并不完全确定是否仍然有对内存块的引用。这可能发生在存在内部指针的情况下，比如特定类型的数组分配的情况。它也可能通过多重继承的使用发生，其中C++对象使用自引用。
- en: As mentioned earlier in the basic use section for Memcheck, it's advisable to
    always run Memcheck with `--leak-check=full` specified to get detailed information
    on exactly where a memory leak was found.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前在Memcheck的基本用法部分提到的，建议始终使用`--leak-check=full`来运行Memcheck，以获取关于内存泄漏发生的具体位置的详细信息。
- en: Helgrind
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helgrind
- en: The purpose of Helgrind is to detect issues with synchronization implementations
    within a multithreaded application. It can detect wrongful use of POSIX threads,
    potential deadlock issues due to wrong locking order as well as data races--the
    reading or writing of data without thread synchronization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind的目的是检测多线程应用程序中同步实现的问题。它可以检测对POSIX线程的错误使用，由于错误的锁定顺序而导致的潜在死锁问题，以及数据竞争--在没有线程同步的情况下读取或写入数据。
- en: Basic use
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'We start Helgrind on our application in the following manner:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以以下方式启动Helgrind应用程序：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar to running Memcheck, this will run the application and log all generated
    output to a log file, while explicitly using all available debugging information
    in the binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与运行Memcheck类似，这将运行应用程序并将所有生成的输出记录到日志文件中，同时明确使用二进制中所有可用的调试信息。
- en: 'After running the application, we examine the generated log file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序后，我们检查生成的日志文件：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the initial basic information about the application and the Valgrind
    version, we are informed that the root thread has been created:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于应用程序和Valgrind版本的初始基本信息之后，我们被告知根线程已经创建：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thread is created by the dispatcher and logged. Next we get the first
    warning:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程是由调度程序创建并记录的。接下来我们得到了第一个警告：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding warning, we are being told by Helgrind about a conflicting
    read of size 1 between thread IDs 1 and 2\. Since the C++11 threading API uses
    a fair amount of templates, the trace can be somewhat hard to read. The essence
    is found in these lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的警告中，Helgrind告诉我们线程ID 1和2之间发生了大小为1的冲突读取。由于C++11线程API使用了大量模板，跟踪可能有些难以阅读。关键在于以下几行：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This corresponds to the following lines of code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应以下代码行：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: "The only variable of size 1 in these lines of code is the Boolean variable\
    \ `ready`. Since this is a Boolean variable, we know that it is an atomic operation\
    \ (see [\uFEFFChapter 8](part0169.html#515F20-1ab5991b318547348fc444437bdacb24),\
    \ *Atomic Operations - Working with the Hardware*, for details). As a result,\
    \ we can ignore this warning."
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: "这些代码行中唯一大小为1的变量是布尔变量`ready`。由于这是一个布尔变量，我们知道这是一个原子操作（详见[\uFEFF第8章](part0169.html#515F20-1ab5991b318547348fc444437bdacb24)，*原子操作-与硬件一起工作*）。因此，我们可以忽略这个警告。"
- en: 'Next, we get another warning for this thread:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为这个线程得到另一个警告：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the first warning, this also refers to a Boolean variable--here,
    the `running` variable in the `Worker` instance. Since this is also an atomic
    operation, we can again ignore this warning.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个警告类似，这也涉及一个布尔变量--这里是`Worker`实例中的`running`变量。由于这也是一个原子操作，我们可以再次忽略这个警告。
- en: 'Following this warning, we get a repeat of these warnings for other threads.
    We also see this warning repeated a number of times:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个警告之后，我们看到其他线程重复了这些警告。我们还多次看到了这个警告的重复：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This warning is triggered by not having the use of standard output synchronized
    between threads. Even though the logging function of this demo application uses
    a mutex to synchronize the text logged by worker threads, we also write to standard
    output in an unsafe manner in a few locations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告是由于在线程之间没有使用标准输出同步引起的。尽管这个演示应用程序的日志记录函数使用互斥锁来同步工作线程记录的文本，但在一些位置我们也以不安全的方式写入标准输出。
- en: This is relatively easy to fix by using a central, thread-safe logging function.
    Even though it's unlikely to cause any stability issues, it will very likely cause
    any logging output to end up as a garbled, unusable mess.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个中央、线程安全的日志记录函数，这相对容易修复。尽管这不太可能引起任何稳定性问题，但很可能会导致任何日志输出最终变成一团乱七八糟、无法使用的混乱。
- en: Misuse of the pthreads API
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滥用pthreads API
- en: 'Helgrind detects a large number of errors involving the pthreads API, as summarized
    by its manual, and listed next:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Helgrind检测到了大量涉及pthreads API的错误，如其手册所总结的，并列在下面：
- en: Unlocking an invalid mutex
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁无效的互斥锁
- en: Unlocking a not-locked mutex
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁未锁定的互斥锁
- en: Unlocking a mutex held by a different thread
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁由不同线程持有的互斥锁
- en: Destroying an invalid or a locked mutex
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁无效或锁定的互斥锁
- en: Recursively locking a non-recursive mutex
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归锁定非递归互斥锁
- en: Deallocation of memory that contains a locked mutex
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放包含锁定互斥锁的内存
- en: Passing mutex arguments to functions expecting reader-writer lock arguments,
    and vice versa
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将互斥锁参数传递给期望读写锁参数的函数，反之亦然
- en: Failure of a POSIX pthread function fails with an error code that must be handled
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX pthread函数的失败会返回必须处理的错误代码
- en: A thread exits whilst still holding locked locks
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程在仍持有锁定的锁时退出
- en: Calling `pthread_cond_wait` with a not-locked mutex, an invalid mutex, or one
    locked by a different thread
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未锁定的互斥锁、无效的互斥锁或被不同线程锁定的互斥锁调用`pthread_cond_wait`
- en: Inconsistent bindings between condition variables and their associated mutexes
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件变量与其关联的互斥锁之间的不一致绑定
- en: Invalid or duplicate initialization of a pthread barrier
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效或重复初始化pthread屏障
- en: Initialization of a pthread barrier on which threads are still waiting
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仍有线程等待的pthread屏障上进行初始化
- en: Destruction of a pthread barrier object which was never initialized, or on which
    threads are still waiting
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁从未初始化或仍有线程等待的pthread屏障对象
- en: Waiting on an uninitialized pthread barrier
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待未初始化的pthread屏障
- en: In addition to this, if Helgrind itself does not detect an error, but the pthreads
    library itself returns an error for each function which Helgrind intercepts, an
    error is reported by Helgrind as well.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果Helgrind本身没有检测到错误，但pthread库本身对Helgrind拦截的每个函数返回错误，那么Helgrind也会报告错误。
- en: Lock order problems
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定顺序问题
- en: Lock order detection uses the assumption that once a series of locks have been
    accessed in a particular order, that is the order in which they will always be
    used. Imagine, for example, a resource that's guarded by two locks. As we saw
    with the dispatcher demonstration from [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Thread Synchronization and Communication*, we use two mutexes in its Dispatcher
    class, one to manage access to the worker threads, and one to the request instances.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定顺序检测使用的假设是一旦一系列锁以特定顺序被访问，它们将永远以这种顺序使用。例如，想象一下，一个由两个锁保护的资源。正如我们在[第4章](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24)中看到的调度程序演示，*线程同步和通信*，我们在其Dispatcher类中使用两个互斥锁，一个用于管理对工作线程的访问，另一个用于请求实例。
- en: In the correct implementation of that code, we always make sure to unlock one
    mutex before we attempt to obtain the other, as there's a chance that another
    thread already has obtained access to that second mutex, and attempts to obtain
    access to the first, thus creating a deadlock situation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在该代码的正确实现中，我们始终确保在尝试获取另一个互斥锁之前解锁一个互斥锁，因为另一个线程可能已经获得了对第二个互斥锁的访问权，并尝试获取对第一个互斥锁的访问权，从而创建死锁情况。
- en: While useful, it is important to realize that there are some areas where this
    detection algorithm is, as of yet, imperfect. This is mostly apparent with the
    use of, for example, condition variables, which naturally uses a locking order
    that tends to get reported by Helgrind as *wrong*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有用，但重要的是要意识到，在某些领域，这种检测算法目前还不完善。这在使用条件变量时尤为明显，条件变量自然使用的锁定顺序往往会被Helgrind报告为*错误*。
- en: The take-away message here is that one has to examine these log messages and
    judge their merit, but unlike straight misuse of the multithreading API, whether
    or not the reported issue is a false-positive or not is far less clear-cut.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，人们必须检查这些日志消息并判断它们的价值，但与多线程API的直接误用不同，报告的问题是否是误报还不够清晰。
- en: Data races
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据竞争
- en: In essence, a data race is when two more threads attempt to read or write to
    the same resource without any synchronization mechanism in place. Here, only a
    concurrent read and write, or two simultaneous writes, are actually harmful; therefore,
    only these two types of access get reported.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，数据竞争是指两个或更多线程在没有任何同步机制的情况下尝试读取或写入相同的资源。在这里，只有并发读取和写入，或两个同时写入，才会真正有害；因此，只有这两种类型的访问会被报告。
- en: In an earlier section on basic Helgrind usage, we saw some examples of this
    type of error in the log. There it concerned the simultaneous writing and reading
    of a variable. As we also covered in that section, Helgrind does not concern itself
    with whether a write or read was atomic, but merely reports a potential issue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期关于基本Helgrind使用的部分中，我们在日志中看到了这种类型错误的一些示例。这里涉及到对变量的同时写入和读取。正如我们在该部分中也提到的，Helgrind并不关心写入或读取是否是原子的，而只是报告潜在问题。
- en: Much like with lock order problems, this again means that one has to judge each
    data race report on its merit, as many will likely be false-positives.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与锁定顺序问题类似，这意味着人们必须根据每个数据竞争报告的价值来判断，因为许多报告可能是误报。
- en: DRD
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRD
- en: 'DRD is very similar to Helgrind, in that it also detects issues with threading
    and synchronization in the application. The main ways in which DRD differs from
    Helgrind are the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: DRD与Helgrind非常相似，因为它也检测应用程序中的线程和同步问题。DRD与Helgrind的主要区别在于：
- en: DRD uses less memory
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRD使用的内存较少
- en: DRD doesn't detect locking order violations
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRD无法检测锁定顺序违规
- en: DRD supports detached threads
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRD支持分离线程
- en: Generally, one wants to run both DRD and Helgrind to compare the output from
    both with each other. Since a lot of potential issues are highly non-deterministic,
    using both tools generally helps to pinpoint the most serious issues.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们希望同时运行DRD和Helgrind，以便将两者的输出进行比较。由于许多潜在问题非常不确定，使用两种工具通常有助于确定最严重的问题。
- en: Basic use
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'Starting DRD is very similar to starting the other tools--we just have to specify
    our desired tool like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动DRD与启动其他工具非常相似-我们只需指定我们想要的工具，如下所示：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the application finishes, we examine the generated log file's contents.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序完成后，我们检查生成的日志文件内容。
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding summary basically repeats what we saw with the Helgrind log. We
    see the same data race report (conflicting store), which we can safely ignore
    due to atomics. For this particular code at least, the use of DRD did not add
    anything we didn't already know from using Helgrind.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的总结基本上重复了我们在Helgrind日志中看到的内容。我们看到了相同的数据竞争报告（冲突存储），由于原子性，我们可以安全地忽略它。至少对于这个特定的代码，使用DRD并没有增加任何我们从使用Helgrind已经知道的东西。
- en: Regardless, it's always a good idea to use both tools just in case one tools
    spots something which the other didn't.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，最好同时使用两种工具，以防一种工具发现了另一种工具没有发现的问题。
- en: Features
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性
- en: 'DRD will detect the following errors:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: DRD将检测以下错误：
- en: Data races
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争
- en: Lock contention (deadlocks and delays)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁争用（死锁和延迟）
- en: Misuse of the pthreads API
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误使用pthreads API
- en: 'For the third point, this list of errors detected by DRD, according to its
    manual, is very similar to that of Helgrind:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三点，根据DRD手册，DRD检测到的错误列表与Helgrind的非常相似：
- en: Passing the address of one type of synchronization object (for example, a mutex)
    to a POSIX API call that expects a pointer to another type of synchronization
    object (for example, a condition variable)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一种类型的同步对象（例如互斥锁）的地址传递给期望指向另一种类型同步对象（例如条件变量）的POSIX API调用
- en: Attempt to unlock a mutex that has not been locked
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试解锁未被锁定的互斥锁
- en: Attempt to unlock a mutex that was locked by another thread
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试解锁被另一个线程锁定的互斥锁
- en: Attempt to lock a mutex of type `PTHREAD_MUTEX_NORMAL` or a spinlock recursively
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试递归锁定`PTHREAD_MUTEX_NORMAL`类型的互斥锁或自旋锁
- en: Destruction or deallocation of a locked mutex
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁或释放被锁定的互斥锁
- en: Sending a signal to a condition variable while no lock is held on the mutex
    associated with the condition variable
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与条件变量相关的互斥锁未被锁定时向条件变量发送信号
- en: Calling `pthread_cond_wait` on a mutex that is not locked, that is, locked by
    another thread or that has been locked recursively
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未锁定的互斥锁上调用`pthread_cond_wait`，即由另一个线程锁定，或者已被递归锁定
- en: Associating two different mutexes with a condition variable through `pthread_cond_wait`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`pthread_cond_wait`将两个不同的互斥锁与条件变量关联
- en: Destruction or deallocation of a condition variable that is being waited upon
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁或释放正在等待的条件变量
- en: Destruction or deallocation of a locked reader-writer synchronization object
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁或释放被锁定的读写同步对象
- en: Attempt to unlock a reader-writer synchronization object that was not locked
    by the calling thread
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试解锁被调用线程未锁定的读写同步对象
- en: Attempt to recursively lock a reader-writer synchronization object exclusively
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试递归锁定独占的读写同步对象
- en: Attempt to pass the address of a user-defined reader-writer synchronization
    object to a POSIX threads function
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将用户定义的读写同步对象的地址传递给POSIX线程函数
- en: Attempt to pass the address of a POSIX reader-writer synchronization object
    to one of the annotations for user-defined reader-writer synchronization objects
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将POSIX读写同步对象的地址传递给用户定义的读写同步对象的注释之一
- en: Reinitialization of a mutex, condition variable, reader-writer lock, semaphore,
    or barrier
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新初始化互斥锁、条件变量、读写锁、信号量或屏障
- en: Destruction or deallocation of a semaphore or barrier that is being waited upon
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁或释放正在等待的信号量或屏障
- en: Missing synchronization between barrier wait and barrier destruction
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏障等待和屏障销毁之间的同步丢失
- en: Exiting a thread without first unlocking the spinlocks, mutexes, or reader-writer
    synchronization objects that were locked by that thread
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不先解锁由该线程锁定的自旋锁、互斥锁或读写同步对象的情况下退出线程
- en: Passing an invalid thread ID to `pthread_join` or `pthread_cancel`
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`pthread_join`或`pthread_cancel`传递无效的线程ID
- en: As mentioned earlier, helpful here is the fact that DRD also supports detached
    threads. Whether locking order checks are important depends on one's application.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，DRD还支持分离线程，这里有帮助。锁定顺序检查是否重要取决于应用程序。
- en: C++11 threads support
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++11线程支持
- en: The DRD manual contains this section on C++11 threads support.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: DRD手册中包含了关于C++11线程支持的这一部分。
- en: 'If you want to use the `c++11` class `std::thread` you will need to do the
    following to annotate the `std::shared_ptr<>` objects used in the implementation
    of that class:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用`c++11`类`std::thread`，则需要对该类实现中使用的`std::shared_ptr<>`对象进行注释：
- en: 'Add the following code at the start of a common header or at the start of each
    source file, before any C++ header files are included:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在公共头文件的开头或每个源文件的开头添加以下代码，然后再包含任何C++头文件：
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Download the GCC source code and from the source file `libstdc++-v3/src/c++11/thread.cc`,
    copy the implementation of the `execute_native_thread_routine()` and `std::thread::_M_start_thread()`
    functions into a source file that is linked with your application. Make sure that
    also in this source file the `_GLIBCXX_SYNCHRONIZATION_HAPPENS_*()` macros are
    defined properly.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载GCC源代码，从源文件`libstdc++-v3/src/c++11/thread.cc`中复制`execute_native_thread_routine()`和`std::thread::_M_start_thread()`函数的实现到一个与应用程序链接的源文件中。确保在此源文件中也正确定义`_GLIBCXX_SYNCHRONIZATION_HAPPENS_*()`宏。
- en: One might see a lot of false positives when using DRD with an application that
    uses the C++11 threads API, which would be fixed by the preceding *fix*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DRD与使用C++11线程API的应用程序可能会出现许多误报，这将通过前面的*修复*来解决。
- en: However, when using GCC 5.4 and Valgrind 3.11 (possibly, using older versions
    too) this issue does not seem to be present any more. It is, however, something
    to keep in mind when one suddenly sees a lot of false positives in one's DRD output
    while using the C++11 threads API.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用GCC 5.4和Valgrind 3.11（可能也适用于旧版本）时，这个问题似乎不再存在。然而，当使用C++11线程API时，如果突然看到DRD输出中出现大量误报，这是需要记住的事情。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at how to approach the debugging of multithreaded
    applications. We explored the basics of using a debugger in a multithreaded context.
    Next, we saw how to use three tools in the Valgrind framework, which can assist
    us in tracking down multithreading and other crucial issues.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何处理多线程应用程序的调试。我们探讨了在多线程环境中使用调试器的基础知识。接下来，我们看到了如何使用Valgrind框架中的三种工具，这些工具可以帮助我们追踪多线程和其他关键问题。
- en: At this point, we can take applications written using the information in the
    preceding chapters and analyze them for any issues which should be fixed including
    memory leaks and improper use of synchronization mechanisms.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以拿取应用程序，使用前面章节中的信息，并分析它们是否存在需要修复的问题，包括内存泄漏和不正确使用同步机制。
- en: In the next chapter, we will take all that we have learned, and look at some
    best practices when it comes to multithreaded programming and developing in general.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将运用我们所学到的知识，探讨多线程编程和一般开发中的一些最佳实践。
