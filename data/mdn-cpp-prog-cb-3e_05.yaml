- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Standard Library Containers, Algorithms, and Iterators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库容器、算法和迭代器
- en: 'The C++ standard library has evolved a lot with C++11/14/17/20, and now C++23\.
    However, at its core still sit three main pillars: containers, algorithms, and
    iterators. They are all implemented as generic types and general-purpose function
    templates. In this chapter, we’ll look at how they can be employed together to
    achieve various goals.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库随着C++11/14/17/20的演变而发生了很大的变化，现在有C++23。然而，其核心仍然有三个主要支柱：容器、算法和迭代器。它们都是作为泛型类型和通用函数模板实现的。在本章中，我们将探讨它们如何一起使用以实现各种目标。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using `vector` as a default container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vector`作为默认容器
- en: Using `bitset` for fixed-size sequences of bits
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bitset`处理固定大小的位序列
- en: Using `vector<bool>` for variable-size sequences of bits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vector<bool>`处理可变大小的位序列
- en: Using the bit manipulation utilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位操作实用工具
- en: Finding elements in a range
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围内查找元素
- en: Sorting a range
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对范围进行排序
- en: Initializing a range
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个范围
- en: Using set operations on a range
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围内使用集合操作：
- en: Using iterators to insert new elements into a container
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器向容器中插入新元素
- en: Writing your own random-access iterator
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的随机访问迭代器
- en: Container access with non-member functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非成员函数访问容器
- en: Selecting the right standard containers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的标准容器
- en: We’ll begin this chapter by exploring the functionalities of the de facto default
    container in C++, which is `std::vector`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，探讨C++事实上的默认容器`std::vector`的功能。
- en: Using vector as a default container
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用向量作为默认容器
- en: The standard library provides various types of containers that store collections
    of objects; the library includes sequence containers (such as `vector`, `array`,
    and `list`), ordered and unordered associative containers (such as `set` and `map`),
    and container adapters that do not store data but provide an adapted interface
    toward a sequence container (such as `stack` and `queue`). All of them are implemented
    as class templates, which means they can be used with any type (providing it meets
    the container requirements). In general, you should always use the container that
    is the most appropriate for a particular problem, which not only provides good
    performance in terms of speed of inserts, deletes, access to elements, and memory
    usage but also makes the code easy to read and maintain. However, the default
    choice should be `vector`. In this recipe, we will see why `vector` should be
    the preferred choice for a container in many cases and what the most common operations
    with `vector` are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了各种类型的容器，用于存储对象的集合；库包括序列容器（如`vector`、`array`和`list`）、有序和无序关联容器（如`set`和`map`），以及不存储数据但提供对序列容器进行适配的接口的容器适配器（如`stack`和`queue`）。所有这些都被实现为类模板，这意味着它们可以与任何类型一起使用（只要它满足容器的要求）。一般来说，你应该始终使用最适合特定问题的容器，这不仅提供了良好的性能，包括插入、删除、访问元素和内存使用方面的速度，而且使代码易于阅读和维护。然而，默认选择应该是`vector`。在这个食谱中，我们将看到为什么在许多情况下`vector`应该是容器的首选选择，以及`vector`最常见的操作是什么。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you must be familiar with arrays, both statically and dynamically
    allocated. A couple of examples are provided here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你必须熟悉数组，包括静态和动态分配的。这里提供了一些示例：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `vector` class template is available in the `std` namespace in the `<vector>`
    header.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类模板在`<vector>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To initialize an `std::vector` class template, you can use any of the following
    methods, but you are not restricted to only these:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化`std::vector`类模板，你可以使用以下任何一种方法，但你并不局限于仅使用这些：
- en: 'Initialize from an initialization list:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始化列表初始化：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Initialize from an array:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数组初始化：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize from another container:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个容器初始化：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize from a count and a value:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从计数和值初始化：
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To modify the content of `std::vector`, you can use any of the following methods
    (as above, you’re not restricted to just these):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改`std::vector`的内容，你可以使用以下任何一种方法（如上所述，你并不局限于仅使用这些）：
- en: 'Add an element at the end of the vector with `push_back()`:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`push_back()`在向量的末尾添加一个元素：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remove an element from the end of the vector with `pop_back()`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pop_back()`从向量的末尾移除一个元素：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Insert anywhere in the vector with `insert()`:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`insert()`在向量的任何位置插入：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add an element by creating it at the end of the vector with `emplace_back()`:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在向量的末尾创建元素来添加一个元素，使用`emplace_back()`：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Insert an element by creating it anywhere in the vector with `emplace()`:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在向量中的任何位置创建元素来插入一个元素，使用 `emplace()`：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To modify the whole content of the vector, you can use any of the following
    methods, although you’re not restricted to just these:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改向量的整个内容，你可以使用以下任何一种方法，尽管你并不局限于这些：
- en: 'Assign from another vector with `operator=`; this replaces the content of the
    container:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `operator=` 从另一个向量赋值；这替换了容器的内容：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Assign from another sequence defined by a begin and end iterator with the `assign()`
    method; this replaces the content of the container:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `assign()` 方法从由开始和结束迭代器定义的另一个序列赋值；这替换了容器的内容：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Swap the content of two vectors with the `swap()` method:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `swap()` 方法交换两个向量的内容：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remove all the elements with the `clear()` method:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `clear()` 方法删除所有元素：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Remove one or more elements with the `erase()` method (which requires either
    an iterator or a pair of iterators that define the range of elements from the
    vector to be removed):'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `erase()` 方法删除一个或多个元素（这需要迭代器或定义从向量中要删除的元素范围的迭代器对）：
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remove one or more elements that satisfy a predicate with the `std::remove_if()`
    function and the `erase()` method:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::remove_if()` 函数和 `erase()` 方法删除一个或多个满足谓词的元素：
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remove one or more elements that satisfy a predicate with the `std::erase_if()`
    function, introduced in C++20\. A similar `std::erase()` function also exists:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用在 C++20 中引入的 `std::erase_if()` 函数删除一个或多个满足谓词的元素，类似的 `std::erase()` 函数也存在：
- en: '[PRE16]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To get the address of the first element in a vector, usually to pass the content
    of a vector to a C-like API, use any of the following methods:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取向量中第一个元素的地址，通常是为了将向量的内容传递给类似 C 的 API，可以使用以下任何一种方法：
- en: 'Use the `data()` method, which returns a pointer to the first element, providing
    direct access to the underlying contiguous sequence of memory where the vector
    elements are stored; this is only available since C++11:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `data()` 方法，它返回指向第一个元素的指针，提供对存储向量元素的底层连续内存序列的直接访问；这仅从 C++11 开始可用：
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Get the address of the first element:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取第一个元素的地址：
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Get the address of the element referred to by the `front()` method (calling
    this method on an empty vector is undefined behavior):'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 `front()` 方法引用的元素的地址（在空向量上调用此方法是不确定的行为）：
- en: '[PRE19]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Get the address of the element pointed by the iterator returned from `begin()`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取从 `begin()` 返回的迭代器指向的元素的地址：
- en: '[PRE20]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To modify the content of a vector, in C++23, you can also use the following
    range-aware member functions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改向量的内容，在 C++23 中，你也可以使用以下范围感知的成员函数：
- en: 'To replace the elements of a vector with a copy of the elements of a given
    range, use `assign_range()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要用给定范围的元素副本替换向量的元素，使用 `assign_range()`：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To append copies of the elements of a range at the end of a vector (before
    the end iterator), use `append_range()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将范围元素的副本追加到向量的末尾（在末尾迭代器之前），使用 `append_range()`：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To insert copies of the elements of a range before a given iterator of a vector,
    use `insert_range()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要在向量的给定迭代器之前插入范围元素的副本，使用 `insert_range()`：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::vector` class is designed to be the C++ container most similar to
    and inter-operable with arrays. A vector is a variable-sized sequence of elements,
    guaranteed to be stored contiguously in memory, which makes the content of a vector
    easily passable to a C-like function that takes a pointer to an element of an
    array and, usually, a size.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 类被设计成与数组最相似且可互操作的 C++ 容器。向量是一个可变大小的元素序列，保证在内存中连续存储，这使得向量的内容可以轻松传递给接受数组元素指针和通常大小参数的类似
    C 的函数：'
- en: 'There are many benefits of using a vector instead of arrays, and these benefits
    include:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用向量而不是数组的许多好处包括：
- en: No direct memory management is required from the developer as the container
    does this internally, allocating memory, reallocating it, and releasing it.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者不需要直接进行内存管理，因为容器内部完成这项工作，分配内存，重新分配它，并释放它。
- en: Note that a vector is intended for storing object instances. If you need to
    store pointers, do not store raw pointers but smart pointers. Otherwise, you need
    to handle the lifetime management of the pointed objects.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，向量是用来存储对象实例的。如果你需要存储指针，不要存储原始指针，而是智能指针。否则，你需要处理指向对象的生存期管理。
- en: The possibility of modifying the size of the vector.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量大小修改的可能性。
- en: Simple assignment or concatenation of two vectors.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个向量的简单赋值或连接。
- en: Direct comparison of two vectors.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接比较两个向量。
- en: The `vector` class is a very efficient container, with all its implementations
    providing a lot of optimizations that most developers are not capable of doing
    with arrays. Random access to its elements and insertion and removal at the end
    of a vector is a constant *O(1)* operation (provided that reallocation is not
    necessary), while insertion and removal anywhere else is a linear *O(n)* operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector` 类是一个非常高效的容器，其所有实现都提供了许多优化，这些优化大多数开发者都无法用数组完成。对元素进行随机访问以及在向量末尾插入和删除操作是一个常数
    *O(1)* 操作（前提是无需重新分配），而其他任何位置的插入和删除操作是一个线性 *O(n)* 操作。'
- en: 'Compared to other standard containers, the vector has various benefits:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他标准容器相比，向量具有各种优势：
- en: It is compatible with arrays and C-like APIs. If a function takes an array as
    a parameter, the content of other containers (except for `std::array`) needs to
    be copied to a `vector` before being passed as an argument to the function.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与数组和 C 类型的 API 兼容。如果一个函数接受一个数组作为参数，其他容器的内容（除了 `std::array`）需要在传递给函数作为参数之前被复制到一个
    `vector` 中。
- en: It has the fastest access to elements of all containers (but the same as `std::array`).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对所有容器的元素访问速度最快（但与 `std::array` 相同）。
- en: It has no per-element memory overhead for storing elements. This is because
    elements are stored in a contiguous space, like arrays are. Therefore, `vector`
    has a small memory footprint, unlike other containers, such as `list`, which require
    additional pointers to other elements, or associative containers, which require
    hash values.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有为存储元素而设置的每个元素的内存开销。这是因为元素存储在连续的空间中，就像数组一样。因此，`vector` 的内存占用很小，与其他容器不同，例如
    `list`，它需要指向其他元素的额外指针，或者关联容器，它需要哈希值。
- en: '`std::vector` is very similar in semantics to arrays but has a variable size.
    The size of a vector can increase and decrease. There are two properties that
    define the size of a vector:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 在语义上与数组非常相似，但具有可变大小。向量的大小可以增加和减少。有两个属性定义了向量的大小：'
- en: '*Capacity* is the number of elements the vector can accommodate without performing
    additional memory allocations; this is indicated by the `capacity()` method.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容量* 是向量在不进行额外内存分配的情况下可以容纳的元素数量；这由 `capacity()` 方法表示。'
- en: '*Size* is the actual number of elements in the vector; this is indicated by
    the `size()` method.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大小* 是向量中实际元素的数量；这由 `size()` 方法表示。'
- en: Size is always smaller than or equal to capacity. When size is equal to capacity
    and a new element needs to be added, the capacity needs to be modified so that
    the vector has space for more elements. In this case, the vector allocates a new
    chunk of memory and moves the previous content to the new location before freeing
    the previously allocated memory. Though this sounds time-consuming—and it is—implementations
    increase the capacity exponentially by doubling it each time it needs to be changed.
    As a result, on average, each element of the vector only needs to be moved once
    (that is because all the elements of the vector are moved during an increase of
    capacity, but then an equal number of elements can be added without incurring
    more moves, given that insertions are performed at the end of the vector).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大小始终小于或等于容量。当大小等于容量且需要添加新元素时，必须修改容量，以便向量有更多元素的空间。在这种情况下，向量分配一个新的内存块，并将之前的内容移动到新位置，然后再释放之前分配的内存。尽管这听起来很耗时——确实如此——实现通过每次改变时将其加倍来指数级地增加容量。因此，平均而言，每个元素只需要移动一次（这是因为向量中的所有元素都在增加容量的过程中被移动，但之后可以添加相同数量的元素而无需进行更多移动，前提是在向量末尾进行插入操作）。
- en: If you know beforehand how many elements will be inserted in the vector, you
    can first call the `reserve()` method to increase the capacity to at least the
    specified amount (this method does nothing if the specified size is smaller than
    the current capacity) and only then insert the elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您事先知道将要插入向量中的元素数量，可以先调用 `reserve()` 方法将容量增加到至少指定的数量（如果指定的大小小于当前容量，则此方法不执行任何操作），然后才插入元素。
- en: 'On the other hand, if you need to free additional reserved memory, you can
    use the `shrink_to_fit()` method to request this, but it is an implementation
    decision as to whether to free any memory or not. An alternative to this non-binding
    method, available since C++11, is to do a swap with a temporary, empty vector:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您需要释放额外的预留内存，可以使用 `shrink_to_fit()` 方法请求这样做，但这是否释放任何内存是实现决策，而不是一个强制性的方法。自
    C++11 以来，这种非绑定方法的替代方法是使用一个临时的空向量进行交换：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Calling the `clear()` method only removes all the elements from the vector but
    does not free any memory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `clear()` 方法只会从向量中移除所有元素，但不会释放任何内存。
- en: 'It should be noted that the `vector` class implements some operations that
    are specific to other types of containers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`vector` 类实现了针对其他类型容器的特定操作：
- en: '*stack*: With `push_back()` and `emplace_back()` to add at the end and `pop_back()`
    to remove from the end. Keep in mind that `pop_back()` does not return the last
    element that has been removed. You need to access that explicitly, if that is
    necessary, for instance, using the `back()` method before removing the element.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*栈*：使用 `push_back()` 和 `emplace_back()` 在末尾添加元素，使用 `pop_back()` 从末尾移除元素。请注意，`pop_back()`
    不会返回已移除的最后一个元素。如果你需要显式访问该元素，例如在移除元素之前使用 `back()` 方法。'
- en: '*list*: With `insert()` and `emplace()` to add elements in the middle of the
    sequence and `erase()` to remove elements from anywhere in the sequence.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*列表*：使用 `insert()` 和 `emplace()` 在序列中间添加元素，使用 `erase()` 从序列的任何位置移除元素。'
- en: A good rule of thumb for C++ containers is to use `std::vector` as the default
    container unless you have good reasons to use another one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 C++ 容器，一个很好的经验法则是除非你有充分的理由使用其他容器，否则默认使用 `std::vector`。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用位集处理固定大小的位序列*，了解处理固定大小位序列的标准容器'
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type, intended for handling bit
    sequences of variable sizes'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 `vector<bool>` 处理可变大小的位序列*，了解 `std::vector` 对 `bool` 类型的特化，旨在处理可变大小的位序列'
- en: Using bitset for fixed-size sequences of bits
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位集处理固定大小的位序列
- en: It is not uncommon for developers to operate with bit flags. This can be either
    because they work with operating system APIs (usually written in C) that take
    various types of arguments (such as options or styles) in the form of bit flags,
    or because they work with libraries that do similar things, or simply because
    some types of problems are naturally solved with bit flags.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者使用位标志进行操作并不罕见。这可能是因为他们与操作系统 API（通常用 C 语言编写）一起工作，这些 API 以位标志的形式接受各种类型的参数（如选项或样式），或者因为他们与执行类似操作的库一起工作，或者仅仅是因为某些类型的问题自然可以用位标志来解决。
- en: We can think of alternatives to working with bits and bit operations, such as
    defining arrays that have one element for every option/flag, or defining a structure
    with members and functions to model the bit flags, but these are often more complicated;
    and in cases when you need to pass a numerical value representing bit flags to
    a function, you still need to convert the array or the structure to a sequence
    of bits. For this reason, the C++ standard provides a container called `std::bitset`
    for fixed-size sequences of bits.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑使用位和位操作的其他替代方案，例如定义每个选项/标志都有一个元素的数组，或者定义一个具有成员和函数的结构来模拟位标志，但这些通常更复杂；并且在需要将表示位标志的数值传递给函数的情况下，你仍然需要将数组或结构转换为位序列。因此，C++
    标准提供了一个名为 `std::bitset` 的容器，用于固定大小的位序列。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you must be familiar with bitwise operations (AND, OR, XOR,
    NOT, and shifting – moving each digit in a number’s binary representation to the
    left or right). If you need to learn more about these, [https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation)
    is a good starting point.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你必须熟悉位操作（AND、OR、XOR、NOT 和移位 - 将数字的二进制表示中的每个数字向左或向右移动）。如果你需要了解更多关于这些的信息，[https://en.wikipedia.org/wiki/Bitwise_operation](https://en.wikipedia.org/wiki/Bitwise_operation)
    是一个很好的起点。
- en: The `bitset` class is available in the `std` namespace in the `<bitset>` header.
    A bitset represents a fixed-size sequence of bits, with the size defined at compile
    time. For convenience, in this recipe, most examples will be with bitsets of 8
    bits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitset` 类在 `<bitset>` 头文件中的 `std` 命名空间中可用。位集表示一个在编译时定义大小的固定大小的位序列。为了方便起见，在这个菜谱中，大多数示例都将使用
    8 位的位集。'
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To construct an `std::bitset` object, use one of the available constructors:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个 `std::bitset` 对象，请使用以下可用的构造函数之一：
- en: 'An empty bitset with all bits set to `0`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有位都设置为 `0` 的空位集：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A bitset from a numerical value:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数值值创建位集：
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A bitset from a string of `''0''` and `''``1''`:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从由 `'0'` 和 `'1'` 组成的字符串创建位集：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A bitset from a string containing any two characters representing `''0''` and
    `''1''`; in this case, we must specify which character represents a `0` (the fourth
    parameter, `''o''`) and which character represents a `1` (the fifth parameter,
    `''x''`):'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含任意两个字符（代表 `'0'` 和 `'1'`）的字符串中创建位集；在这种情况下，我们必须指定哪个字符代表 `0`（第四个参数，`'o'`）以及哪个字符代表
    `1`（第五个参数，`'x'`）：
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To test individual bits in the set or the entire set for specific values, use
    any of the available methods:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试集合中的单个位或整个集合的特定值，请使用任何可用的方法：
- en: '`count()` to get the number of bits set to `1`:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `count()` 获取设置为 `1` 的位的数量：
- en: '[PRE29]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`any()` to check whether there is at least one bit set to `1`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `any()` 检查是否至少有一个位设置为 `1`：
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`all()` to check whether all the bits are set to `1`:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `all()` 检查是否所有位都设置为 `1`：
- en: '[PRE31]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`none()` to check whether all the bits are set to `0`:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `none()` 检查是否所有位都设置为 `0`：
- en: '[PRE32]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`test()` to check the value of an individual bit (whose position is the only
    argument to the function):'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `test()` 函数来检查单个位的值（该位的位位置是函数的唯一参数）：
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`operator[]` to access and test individual bits:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `operator[]` 来访问和测试单个位：
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To modify the content of a bitset, use any of the following methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改位集的内容，可以使用以下任何一种方法：
- en: 'Member operators `|=`, `&=`, `^=`, and `~` to perform the binary operation
    OR, AND, XOR, and NOT, respectively. Alternatively, use the non-member operators
    `|`, `&`, and `^`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符 `|=`, `&=`, `^=`, 和 `~` 分别执行二进制操作 OR、AND、XOR 和 NOT。或者，可以使用非成员运算符 `|`,
    `&`, 和 `^`：
- en: '[PRE35]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Member operators `<<=`, `<<`, `>>=`, and `>>` to perform shifting operations:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符 `<<=`, `<<`, `>>=`, 和 `>>` 用于执行位移操作：
- en: '[PRE36]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`flip()` to toggle the entire set or an individual bit from `0` to `1` or from
    `1` to `0`:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `flip()` 切换整个集合或单个位从 `0` 到 `1` 或从 `1` 到 `0`：
- en: '[PRE37]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`set()` to change the entire set or an individual bit to `true` or the specified
    value:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `set()` 将整个集合或单个位更改为 `true` 或指定的值：
- en: '[PRE38]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`reset()` to change the entire set or an individual bit to `false`:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `reset()` 将整个集合或单个位更改为 `false`：
- en: '[PRE39]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To convert a bitset to a numerical or string value, use the following methods:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将位集转换为数值或字符串值，请使用以下方法：
- en: '`to_ulong()` and `to_ullong()` to convert to `unsigned long` or `unsigned long
    long`. These operations throw an `std::overflow_error` exception if the value
    cannot be represented in the output type. Refer to the following examples:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `to_ulong()` 和 `to_ullong()` 将其转换为 `unsigned long` 或 `unsigned long long`。如果值无法表示在输出类型中，这些操作会抛出
    `std::overflow_error` 异常。请参考以下示例：
- en: '[PRE40]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`to_string()` to convert to `std::basic_string`. By default, the result is
    a string containing `''0''` and `''1''`, but you can specify a different character
    for these two values:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `to_string()` 将其转换为 `std::basic_string`。默认情况下，结果是包含 `'0'` 和 `'1'` 的字符串，但您可以指定这两个值的不同字符：
- en: '[PRE41]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you’ve ever worked with C or C-like APIs, chances are you have either written
    or at least seen code that manipulates bits to define styles, options, or other
    kinds of values. This usually involves operations such as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 C 或类似 C 的 API，那么你很可能编写过或至少见过操作位以定义样式、选项或其他类型值的代码。这通常涉及以下操作：
- en: Defining the bit flags; these can be enumerations, static constants in a class,
    or macros introduced with `#define` in the C style. Usually, there is a flag representing
    no value (style, option, and so on). Since these are supposed to be bit flags,
    their values are powers of 2.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义位标志；这些可以是枚举、类中的静态常量，或者使用 C 风格的 `#define` 引入的宏。通常，有一个表示无值（样式、选项等）的标志。由于这些是位标志，它们的值是
    2 的幂。
- en: Adding and removing flags from the set (that is, a numerical value). Adding
    a bit flag is done with the bit-or operator (`value |= FLAG`) and removing a bit
    flag is done with the bit-and operator, with the negated flag (`value &= ~FLAG`).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向集合中添加或删除标志（即数值）。添加位标志使用位或运算符（`value |= FLAG`），删除位标志使用位与运算符，并使用取反的标志（`value
    &= ~FLAG`）。
- en: Testing whether a flag is added to the set (`value & FLAG == FLAG`).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是否将标志添加到集合中（`value & FLAG == FLAG`）。
- en: Calling functions with the flags as an argument.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标志作为参数调用函数。
- en: 'The following shows a simple example of flags defining the border style of
    a control that can have a border on the left, right, top, or bottom sides, or
    any combination of these, including no border:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单示例，展示了定义具有左、右、上或下边框的控件边框样式的标志，包括这些边框的组合，以及没有边框的情况：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The standard `std::bitset` class is intended as a C++ alternative to this C-like
    working style with sets of bits. It enables us to write more robust and safer
    code because it abstracts the bit operations with member functions, though we
    still need to identify what each bit in the set is representing:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`std::bitset`类旨在作为C++中类似C风格的位集工作方式的替代。它使我们能够编写更健壮和更安全的代码，因为它通过成员函数抽象了位操作，尽管我们仍然需要识别集合中每个位所代表的含义：
- en: Adding and removing flags is done with the `set()` and `reset()` methods, which
    set the value of a bit indicated by its position to `1` or `0` (or `true` and
    `false`); alternatively, we can use the index operator for the same purpose.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set()`和`reset()`方法添加和移除标志，这些方法将位的位置值设置为`1`或`0`（或`true`和`false`）；或者，我们可以使用索引运算符达到相同的目的。
- en: Testing if a bit is set with the `test()` method.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`test()`方法检查位是否被设置。
- en: Conversion from an integer or a string is done through the constructor, and
    conversion to an integer or string is done with member functions so that the values
    from the bitsets can be used where integers are expected (such as arguments to
    functions).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从整数或字符串的转换是通过构造函数完成的，而将值转换为整数或字符串则是通过成员函数完成的，这样就可以在期望整数的地方使用位集的值（例如函数的参数）。
- en: 'Notice that the constructors that build a `bitset` from a sequence of characters
    – be that a `std::basic_string`, a `const char*` (or any other character type),
    or a `std::basic_string_view` in C++26, may throw exceptions: `std::invalid_argument`,
    if any character is not the zero or one specified values, or `std::out_of_range`,
    if the starting offset into the sequence is beyond the end of the sequence.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从字符序列（无论是`std::basic_string`、`const char*`（或任何其他字符类型）还是C++26中的`std::basic_string_view`）构建`bitset`的构造函数可能会抛出异常：如果任何字符不是指定的零或一，则抛出`std::invalid_argument`异常；如果序列的起始偏移量超出了序列的末尾，则抛出`std::out_of_range`异常。
- en: In addition to these operations, the `bitset` class has additional methods for
    performing bitwise operations on bits, shifting, testing, and others that have
    been shown in the previous section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些操作之外，`bitset`类还有执行位操作、移位、测试和其他在上一节中展示的方法的附加方法。
- en: Conceptually, `std::bitset` is a representation of a numerical value that enables
    you to access and modify individual bits. Internally, however, a `bitset` has
    an array of integer values on which it performs bit operations. The size of a
    `bitset` is not limited to the size of a numerical type; it can be anything, except
    that it is a compile-time constant.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，`std::bitset`是数值的表示，它允许你访问和修改单个位。然而，内部，一个`bitset`有一个整数值的数组，它在这个数组上执行位操作。`bitset`的大小不限于数值类型的大小；它可以是一切，除了它是一个编译时常量。
- en: 'The example of the control border styles from the previous section can be written
    using `std::bitset` in the following manner:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中控制边框样式的示例可以用以下方式使用`std::bitset`编写：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Keep in mind this is only one possible implementation. For instance, the `border_flags`
    class could have been an enumeration. However, using a scoped enumeration would
    require explicit casts to `int`. Different solutions may have advantages and disadvantages.
    You can take it as an exercise to write an alternative solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个可能的实现。例如，`border_flags`类本可以是一个枚举类型。然而，使用范围枚举将需要显式转换为`int`。不同的解决方案可能有优点和缺点。你可以将其作为练习来编写一个替代方案。
- en: There’s more...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A bitset can be created from an integer and can convert its value to an integer
    using the `to_ulong()` or `to_ullong()` methods. However, if the size of the `bitset`
    is larger than the size of these numerical types and any of the bits beyond the
    size of the requested numerical type is set to `1`, then these methods throw an
    `std::overflow_error` exception. This is because the value cannot be represented
    on `unsigned long` or `unsigned long long`. In order to extract all the bits,
    we need to do the following operations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从一个整数创建一个bitset，并可以使用`to_ulong()`或`to_ullong()`方法将其值转换为整数。然而，如果`bitset`的大小大于这些数值类型的大小，并且请求的数值类型大小之外的任何位被设置为`1`，则这些方法会抛出`std::overflow_error`异常。这是因为该值无法在`unsigned
    long`或`unsigned long long`上表示。为了提取所有位，我们需要执行以下操作：
- en: Clear the bits beyond the size of `unsigned long` or `unsigned long long`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除`unsigned long`或`unsigned long long`大小之外的位。
- en: Convert the value to `unsigned long` or `unsigned long long`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值转换为`unsigned long`或`unsigned long long`。
- en: Shift the `bitset` with the number of bits in `unsigned long` or `unsigned long
    long`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unsigned long`或`unsigned long long`中的位数量来移位`bitset`。
- en: Do this until all the bits are retrieved.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续这样做，直到所有位都被检索。
- en: 'These are implemented as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是这样实现的：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To exemplify, let’s take the following `bitset`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑以下`bitset`：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we print its content, we get the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印其内容，我们得到以下结果：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, when we convert this set to a sequence of `unsigned long` values using
    `biset_to_vectorulong()` and print their hexadecimal representation, we get the
    following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用`biset_to_vectorulong()`将此集合转换为`unsigned long`值序列并打印其十六进制表示时，我们得到以下结果：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For cases where the size of the `bitset` cannot be known at compile time, the
    alternative is `std::vector<bool>`, which we will cover in the next recipe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在编译时无法知道`bitset`大小的案例，替代方案是`std::vector<bool>`，我们将在下一个食谱中介绍。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type, which is used for handling
    bit sequences of variable sizes'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`vector<bool>`处理可变大小的位序列*，以了解`std::vector`对`bool`类型的特化，该类型用于处理可变大小的位序列'
- en: '*Using the bit manipulation utilities*, to explore the C++20 set of utility
    functions for bit manipulation from the numeric library'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用位操作实用工具*，以探索来自数值库的C++20位操作函数集'
- en: Using vector<bool> for variable-size sequences of bits
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`vector<bool>`处理可变大小的位序列
- en: In the previous recipe, we looked at using `std::bitset` for fixed-size sequences
    of bits. Sometimes, however, `std::bitset` is not a good choice because you do
    not know the number of bits at compile time, and just defining a set of a large
    enough number of bits is not a good idea. This is because you can get into a situation
    where the number is not actually large enough. The standard alternative for this
    is to use the `std::vector<bool>` container, which is a specialization of `std::vector`
    with space and speed optimizations since implementations do not actually store
    Boolean values, but individual bits for each element.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们探讨了使用`std::bitset`处理固定大小的位序列。有时，`std::bitset`并不是一个好的选择，因为您在编译时不知道位的数量，仅仅定义一个足够大的位集合并不是一个好主意。这是因为您可能会遇到实际上并不足够大的情况。这个标准的替代方案是使用`std::vector<bool>`容器，这是一个针对`std::vector`的空间和速度优化的特化，因为实现实际上并不存储布尔值，而是为每个元素存储单独的位。
- en: For this reason, however, `std::vector<bool>` does not meet the requirements
    of a standard container or sequential container, nor does `std::vector<bool>::iterator`
    meet the requirements of a forward iterator. As a result, this specialization
    cannot be used in generic code where a vector is expected. On the other hand,
    being a vector, it has a different interface from that of `std::bitset` and cannot
    be viewed as a binary representation of a number. There are no direct ways to
    construct `std::vector<bool>` from a number or string, nor to convert it to a
    number or string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这个原因，`std::vector<bool>`不符合标准容器或顺序容器的需求，`std::vector<bool>::iterator`也不符合前向迭代器的需求。因此，这个特化不能用于期望使用向量的泛型代码中。另一方面，作为一个向量，它具有与`std::bitset`不同的接口，不能被视为数字的二进制表示。没有直接的方法可以从数字或字符串构造`std::vector<bool>`，也不能将其转换为数字或字符串。
- en: Getting ready...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: This recipe assumes you are familiar with both `std::vector` and `std::bitset`.
    If you didn’t read the previous recipes, *Using vector as a default container*
    and *Using bitset for fixed-size sequences of bits*, you should read them before
    continuing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您熟悉`std::vector`和`std::bitset`。如果您没有阅读之前的食谱，即*使用vector作为默认容器*和*使用bitset处理固定大小的位序列*，您应该在继续之前阅读它们。
- en: The `vector<bool>` class is available in the `std` namespace in the `<vector>`
    header.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector<bool>`类在`<vector>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To manipulate an `std::vector<bool>`, use the same methods you would use for
    an `std::vector<T>`, as shown in the following examples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作`std::vector<bool>`，使用与操作`std::vector<T>`相同的方法，如下面的示例所示：
- en: 'Creating an empty vector:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空向量：
- en: '[PRE49]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Adding bits to the vector:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向向量中添加位：
- en: '[PRE50]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Setting the values of individual bits:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单个位的值：
- en: '[PRE51]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using generic algorithms:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型算法：
- en: '[PRE52]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Removing bits from the vector:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从向量中移除位：
- en: '[PRE53]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::vector<bool>` is not a standard vector because it is designed to provide
    space optimization by storing a single bit for each element instead of a Boolean
    value. Therefore, its elements are not stored in a contiguous sequence and cannot
    be substituted for an array of Booleans. Due to this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`不是一个标准向量，因为它设计用来通过为每个元素存储一个位而不是布尔值来提供空间优化。因此，其元素不是连续存储的，不能替换为布尔值数组。由于这个原因：'
- en: 'The index operator cannot return a reference to a specific element because
    elements are not stored individually:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引操作符不能返回对特定元素的引用，因为元素不是单独存储的：
- en: '[PRE54]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Dereferencing an iterator cannot produce a reference to `bool` for the same
    reason as mentioned earlier:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于前面提到的原因，解引用迭代器不能产生对`bool`的引用：
- en: '[PRE55]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There is no guarantee that individual bits can be manipulated independently
    at the same time from different threads.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有保证在同一个时间点，不同线程可以独立地操作单个位。
- en: The vector cannot be used with algorithms that require forward iterators, such
    as `std::search()`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量不能与需要前向迭代器的算法一起使用，例如`std::search()`。
- en: The vector cannot be used in some generic code where `std::vector<T>` is expected
    if such code requires any of the operations mentioned in this list.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这样的代码需要本列表中提到的任何操作，则不能在期望`std::vector<T>`的泛型代码中使用向量。
- en: An alternative to `std::vector<bool>` is `std::dequeu<bool>`, which is a standard
    container (a double-ended queue) that meets all container and iterator requirements
    and can be used with all standard algorithms. However, this will not have the
    space optimization that `std::vector<bool>` provides.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`的替代方案是`std::deque<bool>`，这是一个满足所有容器和迭代器要求的标准容器（双端队列），并且可以与所有标准算法一起使用。然而，这不会像`std::vector<bool>`那样提供空间优化。'
- en: There’s more...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `std::vector<bool>` interface is very different from `std::bitset`. If you
    want to be able to write code in a similar manner, you can create a wrapper on
    `std::vector<bool>`, which looks like `std::bitset`, where possible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`的接口与`std::bitset`非常不同。如果你想以类似的方式编写代码，你可以在`std::vector<bool>`上创建一个包装器，使其看起来像`std::bitset`，在可能的情况下。'
- en: 'The following implementation provides members similar to what is available
    in `std::bitset`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现提供了类似于`std::bitset`中可用的成员：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is only a basic implementation, and if you want to use such a wrapper,
    you should add additional methods, such as bit logic operations, shifting, maybe
    reading and writing from and to streams, and so on. However, with the preceding
    code, we can write the following examples:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的实现，如果你想要使用这样的包装器，你应该添加额外的功能，例如位逻辑操作、移位，也许是从和到流的读写，等等。然而，使用前面的代码，我们可以写出以下示例：
- en: '[PRE57]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: These examples are very similar to the examples where `std::bitset` was used.
    This `bitvector` class has an API compatible with `std::bitset` but is useful
    for handling bit sequences of variable sizes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例与使用`std::bitset`的示例非常相似。这个`bitvector`类具有与`std::bitset`兼容的API，但适用于处理可变大小的位序列。
- en: See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*，学习如何使用`std::vector`标准容器'
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用bitset处理固定大小的位序列*，了解处理固定大小位序列的标准容器'
- en: '*Using the bit manipulation utilities*, to explore the C++20 set of utility
    functions for bit manipulation from the numeric library'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用位操作工具*，探索来自数值库的C++20位操作工具函数集'
- en: Using the bit manipulation utilities
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位操作工具
- en: In the previous recipes, we have seen how to use `std::bitset` and `std::vector<bool>`
    to work with fixed and variable sequences of bits. There are, however, situations
    when we need to manipulate or process individual or multiple bits of an unsigned
    integral value. This includes operations such as counting or rotating bits. The
    C++20 standard provides a set of utility functions for bit manipulation as part
    of the numeric library. In this recipe, we will learn what they are and how to
    use these utilities.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们看到了如何使用`std::bitset`和`std::vector<bool>`来处理固定和可变长度的位序列。然而，在某些情况下，我们需要操作或处理无符号整数值的单独或多个位。这包括计数或旋转位等操作。C++20标准在数值库中提供了一套位操作工具函数。在本菜谱中，我们将学习它们是什么以及如何使用这些工具。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The function templates discussed in this recipe are all available in the `std`
    namespace in the new C++20 header `<bit>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中讨论的函数模板都在新的 C++20 头文件 `<bit>` 中的 `std` 命名空间中可用。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Use the following function templates to manipulate bits of unsigned integral
    types:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下函数模板来操作无符号整型类型的位：
- en: 'If you need to perform a circular shift, use `std::rotl<T>()` for left rotation
    and `std::rotr<T>()` for right rotation:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要执行循环移位，请使用 `std::rotl<T>()` 进行左旋转和 `std::rotr<T>()` 进行右旋转：
- en: '[PRE58]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you need to count the number of consecutive `0` bits (that is, until a `1`
    is found), use `std::countl_zero<T>()` to count from left to right (that is, starting
    with the most significant bit) and `std::countr_zero<T>()` to count from right
    to left (that is, starting with the least significant bit):'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要计算连续 `0` 位的数量（即，直到找到一个 `1`），请使用 `std::countl_zero<T>()` 从左到右计算（即，从最高有效位开始）和
    `std::countr_zero<T>()` 从右到左计算（即，从最低有效位开始）：
- en: '[PRE59]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you need to count the number of consecutive `1` bits (that is, until a `0`
    is found), use `std::countl_one<T>()` to count from left to right (that is, starting
    with the most significant bit) and `std::countr_one<T>()` to count from right
    to left (that is, starting with the least significant bit):'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要计算连续 `1` 位的数量（即，直到找到一个 `0`），请使用 `std::countl_one<T>()` 从左到右计算（即，从最高有效位开始）和
    `std::countr_one<T>()` 从右到左计算（即，从最低有效位开始）：
- en: '[PRE60]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you need to count the number of `1` bits, use `std::popcount<T>()`. The
    number of `0` bits is the number of digits used to represent the value (this can
    be determined with `std::numeric_limits<T>::digits`), minus the count of `1` bits:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要计算 `1` 位的数量，请使用 `std::popcount<T>()`。`0` 位的数量是表示该值所使用的数字位数（这可以通过 `std::numeric_limits<T>::digits`
    来确定），减去 `1` 位的数量：
- en: '[PRE61]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you need to check whether a number is a power of two, use `std::has_single_bit<T>()`:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要检查一个数字是否是2的幂，请使用 `std::has_single_bit<T>()`：
- en: '[PRE62]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you need to find the smallest power of two that is greater than or equal
    to a given number, use `std::bit_ceil<T>()`. On the other hand, if you need to
    find the largest power of two that is smaller than or equal to a given number,
    use `std::bit_floor<T>()`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要找到大于或等于给定数字的最小2的幂，请使用 `std::bit_ceil<T>()`。另一方面，如果需要找到小于或等于给定数字的最大2的幂，请使用
    `std::bit_floor<T>()`：
- en: '[PRE63]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you need to determine the smallest number of digits to represent a number,
    use `std::bit_width<T>()`:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要确定表示一个数字所需的最小位数，请使用 `std::bit_width<T>()`：
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you need to reinterpret the object representation of a type `F` as that
    of a type `T`, then use `std::bit_cast<T, F>()`:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要将类型 `F` 的对象表示重新解释为类型 `T` 的表示，请使用 `std::bit_cast<T, F>()`：
- en: '[PRE65]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: All the function templates mentioned in the previous section, with the exception
    of `std::bit_cast<T, F>()` are only available for unsigned integral types. That
    includes the types `unsigned char`, `unsigned short`, `unsigned int`, `unsigned
    long`, and `unsigned long long`, as well as the fixed width unsigned integer types
    (such as `uint8_t`, `uint64_t`, `uint_least8_t`, `uintmax_t`, and so on). These
    functions are simple and should not require a detailed description.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中提到的所有函数模板，除了 `std::bit_cast<T, F>()`，仅适用于无符号整型类型。这包括类型 `unsigned char`、`unsigned
    short`、`unsigned int`、`unsigned long` 和 `unsigned long long`，以及固定宽度的无符号整型类型（例如
    `uint8_t`、`uint64_t`、`uint_least8_t`、`uintmax_t` 等）。这些函数很简单，不需要详细说明。
- en: The function that is different from the rest is `std::bit_cast<T, F>()`. Here,
    `F` is the type that is reinterpreted, and `T` is the type that we interpret to.
    This function template does not require `T` and `F` to be unsigned integral types,
    but both of them must be trivially copyable. Moreover, the `sizeof(T)` must be
    the same as the `sizeof(F)`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他函数不同的函数是 `std::bit_cast<T, F>()`。在这里，`F` 是重新解释的类型，而 `T` 是我们解释到的类型。此函数模板不需要
    `T` 和 `F` 是无符号整型类型，但它们都必须是简单可复制的。此外，`sizeof(T)` 必须与 `sizeof(F)` 相同。
- en: The specification for this function does not mention the value of padding bits
    in the result. On the other hand, if the result value does not correspond to a
    valid value of the type `T`, then the behavior is undefined.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的规范没有提及结果中填充位的值。另一方面，如果结果值不对应于类型 `T` 的有效值，则行为是未定义的。
- en: '`std::bit_cast<T, F>()` can be `constexpr` if `T`, `F`, and the types of all
    their sub-objects are not a union type, a pointer type, a pointer to member type,
    or a volatile-qualified type, and have no non-static data members of a reference
    type.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::bit_cast<T, F>()`可以是`constexpr`，如果`T`、`F`以及它们所有子对象类型的类型不是联合类型、指针类型、成员指针类型或带volatile资格的类型，并且没有非静态数据成员为引用类型。'
- en: See also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using bitset for fixed-size sequences of bits*, to learn about the standard
    container for handling bit sequences of fixed sizes'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用位集处理固定大小的位序列*，了解处理固定大小位序列的标准容器'
- en: '*Using vector<bool> for variable-size sequences of bits*, to learn about the
    specialization of `std::vector` for the `bool` type intended for handling bit
    sequences of variable sizes'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`vector<bool>`处理可变大小的位序列*，了解`std::vector`对`bool`类型的特化，旨在处理可变大小的位序列'
- en: Finding elements in a range
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个范围内查找元素
- en: One of the most common operations we do in any application is searching through
    data. Therefore, it is not surprising that the standard library provides many
    generic algorithms for searching through standard containers, or anything that
    can represent a range and is defined by a start and a past-the-end iterator. In
    this recipe, we will see what these standard algorithms are and how they can be
    used.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，我们最常进行的操作之一是搜索数据。因此，标准库提供许多通用算法来搜索标准容器，或者任何可以表示范围并由开始和结束迭代器定义的东西，并不足为奇。在本食谱中，我们将了解这些标准算法是什么以及如何使用它们。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For all the examples in this recipe, we will use `std::vector`, but all the
    algorithms work with ranges defined by a begin and past-the-end, either input
    or forward iterators, depending on the algorithm (for more information about the
    various types of iterators, see the *Writing your own random access iterator*
    recipe, later in this chapter). All these algorithms are available in the `std`
    namespace in the `<algorithm>` header.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的所有示例中，我们将使用`std::vector`，但所有算法都与由开始和结束迭代器定义的范围一起工作，这些迭代器是输入迭代器或前向迭代器，具体取决于算法（有关各种迭代器的更多信息，请参阅本章后面的*编写自己的随机访问迭代器*食谱）。所有这些算法都在`<algorithm>`头文件中的`std`命名空间中可用。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following is a list of algorithms that can be used for finding elements
    in a range:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用于在范围内查找元素的算法列表：
- en: 'Use `std::find()` to find a value in a range; this algorithm returns an iterator
    to the first element equal to the value:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find()`来查找一个范围内存在的值；此算法返回一个指向第一个等于该值的元素的迭代器：
- en: '[PRE66]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Use `std::find_if()` to find a value in a range that meets a criterion from
    a unary predicate; this algorithm returns an iterator to the first element for
    which the predicate returns `true`:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_if()`来查找一个范围内符合一元谓词准则的值；此算法返回一个指向第一个谓词返回`true`的元素的迭代器：
- en: '[PRE67]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use `std::find_if_not()` to find a value in a range that does not meet a criterion
    from a unary predicate; this algorithm returns an iterator to the first element
    for which the predicate returns `false`:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_if_not()`来查找一个范围内不符合一元谓词准则的值；此算法返回一个指向第一个谓词返回`false`的元素的迭代器：
- en: '[PRE68]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use `std::find_first_of()` to search for the occurrence of any value from a
    range in another range; this algorithm returns an iterator to the first element
    that is found:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_first_of()`在另一个范围内搜索来自一个范围的任何值的出现；此算法返回一个指向找到的第一个元素的迭代器：
- en: '[PRE69]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use `std::find_end()` to find the last occurrence of a subrange of elements
    in a range; this algorithm returns an iterator to the first element of the last
    subrange in the range:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_end()`来查找一个范围内元素子范围的最后出现；此算法返回一个指向最后一个子范围中第一个元素的迭代器：
- en: '[PRE70]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To find the minimum and the maximum elements in a range, use `std::min_element()`
    for the minimum, `std::max_element()` for the maximum, and `std::minmax_element()`
    for both the minimum and the maximum:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在一个范围内找到最小和最大元素，使用`std::min_element()`来获取最小值，`std::max_element()`来获取最大值，以及`std::minmax_element()`来同时获取最小和最大值：
- en: '[PRE71]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use `std::search()` to search for the first occurrence of a subrange in a range;
    this algorithm returns an iterator to the first element of the subrange in the
    range:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::search()`来搜索一个范围内子范围的第一出现；此算法返回一个指向子范围在范围内第一个元素的迭代器：
- en: '[PRE72]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Use `std::search()` with a *searcher*, which is a class that implements a searching
    algorithm and meets some predefined criteria. This overload of `std::search()`
    was introduced in C++17, and available standard searchers implement the *Boyer-Moore*
    and *Boyer-Moore-Horspool* string searching algorithms:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::search()` 与一个 *searcher*，这是一个实现搜索算法并满足某些预定义标准的类。此 `std::search()` 重载是在
    C++17 中引入的，并且可用的标准搜索器实现了 *Boyer-Moore* 和 *Boyer-Moore-Horspool* 字符串搜索算法：
- en: '[PRE73]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use `std::search_n()` to search for *N* consecutive occurrences of a value
    in a range; this algorithm returns an iterator to the first element of the found
    sequence in the range:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::search_n()` 在一个范围内搜索 *N* 个连续出现的值；此算法返回找到的序列在范围内的第一个元素的迭代器：
- en: '[PRE74]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Use `std::adjacent_find()` to find two adjacent elements in a range that are
    equal or satisfy a binary predicate; this algorithm returns an iterator to the
    first element that is found:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::adjacent_find()` 来查找一个范围内相等或满足二元谓词的两个相邻元素；此算法返回找到的第一个元素的迭代器：
- en: '[PRE75]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use `std::binary_search()` to find whether an element exists in a sorted range;
    this algorithm returns a Boolean value to indicate whether the value was found
    or not:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::binary_search()` 来查找一个元素是否存在于有序范围内；此算法返回一个布尔值以指示是否找到了该值：
- en: '[PRE76]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Use `std::lower_bound()` to find the first element in a range not less than
    a specified value; this algorithm returns an iterator to the element:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::lower_bound()` 来查找一个范围内不小于指定值的第一个元素；此算法返回元素的迭代器：
- en: '[PRE77]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use `std::upper_bound()` to find the first element in a range greater than
    a specified value; this algorithm returns an iterator to the element:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::upper_bound()` 来查找一个范围内大于指定值的第一个元素；此算法返回元素的迭代器：
- en: '[PRE78]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use `std::equal_range()` to find a subrange in a range whose values are equal
    to a specified value. This algorithm returns a pair of iterators defining the
    first and the one-past-end iterators to the subrange; these two iterators are
    equivalent to those returned by `std::lower_bound()` and `std::upper_bound()`:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::equal_range()` 在一个值等于指定值的范围内查找子范围。此算法返回一个迭代器对，定义子范围的第一个和超出末尾的迭代器；这两个迭代器等同于由
    `std::lower_bound()` 和 `std::upper_bound()` 返回的迭代器：
- en: '[PRE79]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The way these algorithms work is very similar: they all take, as arguments,
    iterators that define the searchable range and additional arguments that depend
    on each algorithm. With the exception of `std::binary_search()`, which returns
    a Boolean, and `std::equal_range()`, which returns a pair of iterators, they all
    return an iterator to the searched element or to a subrange. These iterators must
    be compared with the end iterator (that is, the past-last-element) of the range
    to check whether the search was successful or not. If the search did not find
    an element or a subrange, then the returned value is the end iterator.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的工作方式非常相似：它们都接受定义可搜索范围的迭代器以及每个算法依赖的附加参数。除了返回布尔值的 `std::binary_search()`
    和返回迭代器对的 `std::equal_range()` 之外，它们都返回搜索到的元素或子范围的迭代器。这些迭代器必须与范围的末尾迭代器（即超出最后一个元素）进行比较，以检查搜索是否成功。如果搜索没有找到元素或子范围，则返回的值是末尾迭代器。
- en: All these algorithms have multiple overloads, but in the *How to do it...* section,
    we only looked at one particular overload to show how the algorithm can be used.
    For a complete reference of all overloads, you should see other sources, such
    as [https://en.cppreference.com/w/cpp/algorithm](https://en.cppreference.com/w/cpp/algorithm).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些算法都有多个重载，但在 *如何做...* 部分中，我们只查看了一个特定的重载来展示算法如何使用。要查看所有重载的完整参考，你应该查看其他来源，例如
    [https://en.cppreference.com/w/cpp/algorithm](https://en.cppreference.com/w/cpp/algorithm)。
- en: In all the preceding examples, we used constant iterators, but all these algorithms
    work the same with mutable iterators and with reverse iterators. Because they
    take iterators as input arguments, they can work with standard containers, arrays,
    or anything that represents a sequence and has iterators available.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的例子中，我们使用了常量迭代器，但所有这些算法都可以与可变迭代器和反向迭代器一起工作。因为它们接受迭代器作为输入参数，所以它们可以与标准容器、数组或任何具有迭代器的序列一起工作。
- en: 'A special note on the `std::binary_search()` algorithm is necessary: the iterator
    parameters that define the range to search in should at least meet the requirements
    of the forward iterators. Regardless of the type of the supplied iterators, the
    number of comparisons is always logarithmic on the size of the range. However,
    the number of iterator increments is different if the iterators are random access,
    in which case the number of increments is also logarithmic, or are not random
    access, in which case it is linear and proportional to the size of the range.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `std::binary_search()` 算法的特别说明是必要的：定义搜索范围的迭代器参数至少应满足前向迭代器的需求。无论提供的迭代器类型如何，比较次数总是与范围大小的对数成正比。然而，如果迭代器是随机访问的，则迭代器增加的次数也是对数的，或者不是随机访问的，在这种情况下，它是线性的，并且与范围的大小成比例。
- en: 'All these algorithms, except for `std::find_if_not()`, were available before
    C++11\. However, some overloads of them have been introduced in the newer standards.
    An example is `std::search()`, which has several overloads that were introduced
    in C++17\. One of these overloads has the following form:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `std::find_if_not()` 之外，所有这些算法在 C++11 之前都是可用的。然而，它们的一些重载在新标准中已被引入。一个例子是 `std::search()`，它在
    C++17 中引入了几个重载。其中之一具有以下形式：
- en: '[PRE80]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This overload searches for the occurrence of a pattern defined by a searcher
    function object for which the standard provides several implementations:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载通过搜索由搜索函数对象定义的模式来查找其发生，标准为此提供了几个实现：
- en: '`default_searcher` basically delegates the searching to the standard `std::search()`
    algorithm.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_searcher` 基本上委托搜索到标准的 `std::search()` 算法。'
- en: '`boyer_moore_searcher` implements the Boyer-Moore algorithm for string searching.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boyer_moore_searcher` 实现了 Boyer-Moore 字符串搜索算法。'
- en: '`boyer_moore_horspool_algorithm` implements the Boyer-Moore-Horspool algorithm
    for string searching.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boyer_moore_horspool_algorithm` 实现了 Boyer-Moore-Horspool 字符串搜索算法。'
- en: Many standard containers have a member function `find()` for finding elements
    in the container. When such a method is available and suits your needs, it should
    be preferred to the general algorithms because these member functions are optimized
    based on the particularities of each container.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准容器都有一个成员函数 `find()` 用于在容器中查找元素。当此类方法可用且满足您的需求时，应优先于通用算法，因为这些成员函数是根据每个容器的特定性进行优化的。
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using vector as a default container*, to see how to use the `std::vector`
    standard container'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*，了解如何使用 `std::vector` 标准容器'
- en: '*Initializing a range*, to explore the standard algorithms for filling a range
    with values'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化一个范围*，探索填充范围值的标准算法'
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内使用集合操作*，了解用于执行排序范围并集、交集或差集的标准算法'
- en: '*Sorting a range*, to learn about the standard algorithms for sorting ranges'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对范围进行排序*，了解排序范围的通用算法'
- en: Sorting a range
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对范围进行排序
- en: In the previous recipe, we looked at the standard general algorithms for searching
    in a range. Another common operation we often need to do is sorting a range because
    many routines, including some of the algorithms for searching, require a sorted
    range. The standard library provides several general algorithms for sorting ranges,
    and in this recipe, we will see what these algorithms are and how they can be
    used.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们研究了在范围内搜索的通用标准算法。我们经常需要执行的其他常见操作之一是对范围进行排序，因为许多例程，包括一些搜索算法，都需要排序的范围。标准库提供了几个用于排序范围的通用算法，在本菜谱中，我们将了解这些算法是什么以及如何使用它们。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The sorting general algorithms work with ranges defined by a start and end iterator
    and, therefore, can sort standard containers, arrays, or anything that represents
    a sequence and has random iterators available. However, all the examples in this
    recipe will use `std::vector`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 排序通用算法与由起始和结束迭代器定义的范围一起工作，因此可以排序标准容器、数组或任何具有随机迭代器的序列。然而，本菜谱中的所有示例都将使用 `std::vector`。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of standard general algorithms for searching a range:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一系列用于搜索范围的通用标准算法：
- en: 'Use `std::sort()` for sorting a range:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::sort()` 对范围进行排序：
- en: '[PRE81]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use `std::stable_sort()` for sorting a range but keeping the order of the equal
    elements:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::stable_sort()` 对范围进行排序，但保持相等元素的顺序：
- en: '[PRE82]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Use `std::partial_sort()` for sorting a part of a range (and leaving the rest
    in an unspecified order):'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::partial_sort()` 对范围的一部分进行排序（并保留其余部分的不确定顺序）：
- en: '[PRE83]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Use `std::partial_sort_copy()` for sorting a part of a range by copying the
    sorted elements to a second range and leaving the original range unchanged:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::partial_sort_copy()` 通过将排序的元素复制到第二个范围来对范围的一部分进行排序，同时保留原始范围不变：
- en: '[PRE84]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Use `std::nth_element()` for sorting a range so that the *N*th element is the
    one that would be in that position if the range was completely sorted, and the
    elements before it are all smaller and the ones after it are all greater, without
    any guarantee that they are also ordered:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::nth_element()` 对范围进行排序，以便第 *N* 个元素是如果范围完全排序时将位于该位置的元素，并且它之前的所有元素都更小，它之后的所有元素都更大，没有任何保证它们也是有序的：
- en: '[PRE85]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use `std::is_sorted()` to check whether a range is sorted:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::is_sorted()` 来检查一个范围是否已排序：
- en: '[PRE86]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Use `std::is_sorted_until()` to find a sorted subrange from the beginning of
    a range:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::is_sorted_until()` 从范围的开头找到一个已排序的子范围：
- en: '[PRE87]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All the preceding general algorithms take random iterators as arguments to
    define the range to be sorted. Some of them also take an output range. They all
    have overloads: one that requires a comparison function for sorting the elements
    and one that does not and uses `operator<` for comparing the elements.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前通用算法都接受随机迭代器作为参数来定义要排序的范围。其中一些还接受一个输出范围。它们都有重载：一个需要比较函数来排序元素，另一个不需要，并使用
    `operator<` 来比较元素。
- en: 'These algorithms work in the following way:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法以以下方式工作：
- en: '`std::sort()` modifies the input range so that its elements are sorted according
    to the default or the specified comparison function; the actual algorithm for
    sorting is an implementation detail.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()` 修改输入范围，使其元素根据默认或指定的比较函数排序；实际的排序算法是实现细节。'
- en: '`std::stable_sort()` is similar to `std::sort()`, but it guarantees to preserve
    the original order of elements that are equal.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stable_sort()` 与 `std::sort()` 类似，但它保证保留相等元素的原始顺序。'
- en: '`std::partial_sort()` takes three iterator arguments indicating the first,
    middle, and last element in a range, where middle can be any element, not just
    the one at the natural middle position. The result is a partially sorted range
    so that the first *middle* – *first* smallest elements from the original range,
    that is, [*first*, *last*), are found in the [*first*, *middle*) subrange and
    the rest of the elements are in an unspecified order in the [*middle*, *last*)
    subrange.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_sort()` 接收三个迭代器参数，表示范围中的第一个、中间和最后一个元素，其中中间可以是任何元素，而不仅仅是自然中间位置的元素。结果是部分排序的范围，使得从原始范围中找到的第一个到中间的最小元素（即
    [*first*, *last*），位于 [*first*, *middle*) 子范围中，其余元素在 [*middle*, *last*) 子范围中以不确定的顺序排列。'
- en: '`std::partial_sort_copy()` is not a variant of `std::partial_sort()`, as the
    name may suggest, but of `std::sort()`. It sorts a range without altering it by
    copying its elements to an output range. The arguments of the algorithm are the
    first and last iterators of the input and output ranges. If the output range has
    a size *M* that is greater than or equal to the size *N* of the input range, the
    input range is entirely sorted and copied to the output range; the first *N* elements
    of the output range are overwritten, and the last *M* – *N* elements are left
    untouched. If the output range is smaller than the input range, then only the
    first *M* sorted elements from the input range are copied to the output range
    (which is entirely overwritten in this case).'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_sort_copy()` 并不是 `std::partial_sort()` 的变体，尽管名称可能暗示，而是 `std::sort()`
    的变体。它通过将元素复制到输出范围而不改变它来对范围进行排序。算法的参数是输入和输出范围的第一个和最后一个迭代器。如果输出范围的大小 *M* 大于或等于输入范围的大小
    *N*，则输入范围完全排序并复制到输出范围；输出范围的前 *N* 个元素被覆盖，最后 *M* – *N* 个元素保持不变。如果输出范围小于输入范围，则仅将输入范围的前
    *M* 个排序元素复制到输出范围（在这种情况下，输出范围被完全覆盖）。'
- en: '`std::nth_element()` is basically an implementation of a selection algorithm,
    which is an algorithm for finding the *N*th smallest element of a range. This
    algorithm takes three iterator arguments representing the first, *N*th, and last
    element, and partially sorts the range so that, after sorting, the *N*th element
    is the one that would be in that position if the range had been entirely sorted.
    In the modified range, all the *N* – 1 elements before the *N*th one are smaller
    than it, and all the elements after the *N*th element are greater than it. However,
    there is no guarantee on the order of these other elements.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::nth_element()` 基本上是选择算法的实现，该算法是寻找范围中第 *N* 个最小元素的算法。此算法接受三个迭代器参数，分别表示第一个、第
    *N* 个和最后一个元素，并部分排序范围，以便在排序后，第 *N* 个元素是如果整个范围都已排序，它将位于该位置的元素。在修改后的范围内，第 *N* 个之前的所有
    *N* – 1 个元素都小于它，而第 *N* 个之后的元素都大于它。然而，对这些其他元素的顺序没有保证。'
- en: '`std::is_sorted()` checks whether the specified range is sorted according to
    the specified or default comparison function and returns a Boolean value to indicate
    that.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_sorted()` 检查指定的范围是否根据指定的或默认的比较函数排序，并返回一个布尔值以指示这一点。'
- en: '`std::is_sorted_until()` finds a sorted subrange of the specified range, starting
    from the beginning, using either a provided comparison function or the default
    `operator<`. The returned value is an iterator representing the upper bound of
    the sorted subrange, which is also the iterator of the one-past-last sorted element.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_sorted_until()` 查找指定范围内的有序子范围，从开始处开始，使用提供的比较函数或默认的 `operator<`。返回的值是一个迭代器，表示有序子范围的upper
    bound，也是最后一个有序元素的下一个迭代器。'
- en: Some standard containers, `std::list` and `std::forward_list`, provide a member
    function, `sort()`, which is optimized for those containers. These member functions
    should be preferred over the general standard algorithm, `std::sort()`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准容器 `std::list` 和 `std::forward_list` 提供了一个成员函数 `sort()`，该函数针对这些容器进行了优化。应优先使用这些成员函数，而不是通用标准算法
    `std::sort()`。
- en: See also
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将向量作为默认容器使用*，了解如何使用 `std::vector` 标准容器。'
- en: '*Initializing a range* to explore the standard algorithms for filling a range
    with values'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化一个范围* 以探索用值填充范围的标准算法'
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内使用集合操作*，了解执行有序范围并集、交集或差集的标准算法'
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内查找元素*，了解搜索值序列的标准算法'
- en: Initializing a range
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化一个范围
- en: In the previous recipes, we explored the general standard algorithms for searching
    in a range and sorting a range. The algorithms library provides many other general
    algorithms, and among them are several that are intended for filling a range with
    values. In this recipe, you will learn what these algorithms are and how they
    should be used.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们探讨了在范围内搜索和排序的一般标准算法。算法库提供了许多其他通用算法，其中一些旨在用值填充范围。在本菜谱中，你将了解这些算法是什么以及如何使用它们。
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the examples in this recipe use `std::vector`. However, like all the general
    algorithms, the ones we will see in this recipe take iterators to define the bounds
    of a range and can therefore be used with any standard container, arrays, or custom
    types representing a sequence that have forward iterators defined.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中的所有示例都使用 `std::vector`。然而，像所有通用算法一样，我们将在本菜谱中看到的算法使用迭代器来定义范围的界限，因此可以使用任何标准容器、数组或具有定义了前向迭代器的自定义类型来表示序列。
- en: Except for `std::iota()`, which is available in the `<numeric>` header, all
    the other algorithms are found in the `<algorithm>` header.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `<numeric>` 头文件中可用的 `std::iota()` 之外，所有其他算法都可在 `<algorithm>` 头文件中找到。
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To assign values to a range, use any of the following standard algorithms:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值分配给范围，可以使用以下任何标准算法：
- en: '`std::fill()` to assign a value to all the elements of a range; the range is
    defined by a first and last forward iterator:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill()` 将值分配给范围的所有元素；范围由一个第一个和最后一个前向迭代器定义：'
- en: '[PRE88]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`std::fill_n()` to assign values to a number of elements of a range; the range
    is defined by a first forward iterator and a counter that indicates how many elements
    should be assigned the specified value:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill_n()` 用于将值赋给一个范围内的若干元素；该范围由一个第一个前向迭代器和计数器定义，该计数器指示应该为多少个元素分配指定的值：'
- en: '[PRE89]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`std::generate()` to assign the value returned by a function to the elements
    of a range; the range is defined by a first and last forward iterator, and the
    function is invoked once for each element in the range:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::generate()` 用于将函数返回的值赋给一个范围内的元素；该范围由一个第一个和最后一个前向迭代器定义，并且对于范围中的每个元素，函数都会被调用一次：'
- en: '[PRE90]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`std::generate_n()` to assign the value returned by a function to a number
    of elements of a range; the range is defined by a first forward iterator and a
    counter that indicates how many elements should be assigned the value from the
    function that is invoked once for each element:'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::generate_n()` 用于将函数返回的值赋给一个范围内的若干元素；该范围由一个第一个前向迭代器和计数器定义，该计数器指示应该从调用的函数中为多少个元素赋值，该函数对于每个元素调用一次：'
- en: '[PRE91]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`std::iota()` to assign sequentially increasing values to the elements of a
    range; the range is defined by a first and last forward iterator, and the values
    are incremented using the prefix `operator++` from an initial specified value:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::iota()` 用于将顺序递增的值赋给一个范围内的元素；该范围由一个第一个和最后一个前向迭代器定义，并且使用从初始指定值开始的 `operator++`
    前缀来递增值：'
- en: '[PRE92]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::fill()` and `std::fill_n()` work similarly but differ in the way the
    range is specified: for the former by a first and last iterator, for the latter
    by a first iterator and a count. The second algorithm returns an iterator, representing
    either the one-past-last assigned element if the counter is greater than zero,
    or an iterator to the first element of the range otherwise.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::fill()` 和 `std::fill_n()` 在工作方式上相似，但在指定范围的方式上有所不同：前者通过第一个和最后一个迭代器，后者通过第一个迭代器和计数器。第二个算法返回一个迭代器，表示如果计数器大于零，则为已分配的最后一个元素之后的一个迭代器，否则为范围的第一个元素的迭代器。'
- en: '`std::generate()` and `std::generate_n()` are also similar, differing only
    in the way the range is specified. The first takes two iterators, defining the
    range’s lower and upper bounds, while the second takes an iterator to the first
    element and a count. Like `std::fill_n()`, `std::generate_n()` also returns an
    iterator, representing either the one-past-last assigned element if the count
    is greater than zero, or an iterator to the first element of the range otherwise.
    These algorithms call a specified function for each element in the range and assign
    the returned value to the element. The generating function does not take any argument,
    so the value of the argument cannot be passed to the function. This is because
    it’s intended as a function to initialize the elements of a range. If you need
    to use the value of the elements to generate new values, you should use `std::transform()`.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::generate()` 和 `std::generate_n()` 也非常相似，只是在指定范围的方式上有所不同。第一个接受两个迭代器，定义范围的上下界，而第二个接受第一个元素的迭代器和计数器。像
    `std::fill_n()` 一样，`std::generate_n()` 也返回一个迭代器，表示如果计数器大于零，则为已分配的最后一个元素之后的一个迭代器，否则为范围的第一个元素的迭代器。这些算法对范围中的每个元素调用指定的函数，并将返回的值赋给该元素。生成函数不接受任何参数，因此无法将参数的值传递给函数。这是因为它被设计为一个用于初始化范围元素的函数。如果您需要使用元素的值来生成新值，应使用
    `std::transform()`。'
- en: '`std::iota()` takes its name from the `ι` (iota) function from the APL programming
    language, and though it was a part of the initial STL, it was only included in
    the standard library in C++11\. This function takes a first and last iterator
    to a range, as well as an initial value that is assigned to the first element
    of the range. These are then used to generate sequentially increasing values using
    the prefix `operator++` for the rest of the elements in the range.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::iota()` 的名字来源于 APL 编程语言中的 `ι` (iota) 函数，尽管它最初是 STL 的一部分，但它仅在 C++11 标准库中包含。此函数接受一个范围的前向迭代器和最后一个迭代器，以及一个分配给范围第一个元素的初始值。然后使用范围中其余元素的
    `operator++` 前缀来生成顺序递增的值。'
- en: '**STL** stands for the **Standard Template Library**. It is a software library
    designed by Alexander Stepanov initially for C++ before the standardization of
    the C++ language. It was later used to model the C++ standard library, providing
    containers, iterators, algorithms, and functions. It should not be confused with
    the C++ standard library, as these two are distinct entities.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**STL** 代表 **Standard Template Library**。它是由 Alexander Stepanov 设计的软件库，最初是为
    C++ 设计的，在 C++ 语言标准化之前。后来它被用来模拟 C++ 标准库，提供容器、迭代器、算法和函数。它不应与 C++ 标准库混淆，因为这两个是不同的实体。'
- en: There’s more…
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The examples we saw in this recipe used integers so they would be easy to follow.
    However, we can also provide a real-life example to help you better understand
    how these algorithms can be used for more complex scenarios.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中看到的示例使用了整数，这样它们就更容易理解。然而，我们也可以提供一个现实生活中的例子，以帮助您更好地理解这些算法如何在更复杂的场景中使用。
- en: 'Let’s consider a function that given two colors generates a series of intermediary
    points, representing a gradient. A color object has three values, one for the
    red, green, and blue channels. We can model it as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个函数，给定两种颜色生成一系列中间点，表示渐变。一个颜色对象有三个值，分别对应红色、绿色和蓝色通道。我们可以将其建模如下：
- en: '[PRE93]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We will write a function that takes the start and end color, as well as the
    number of points to generate, and returns a vector of `color` objects. Internally,
    this uses `std::generate_n()` to generate the values:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个函数，该函数接受起始颜色和结束颜色，以及要生成的点的数量，并返回一个 `color` 对象的向量。内部使用 `std::generate_n()`
    来生成值：
- en: '[PRE94]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can use this function as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用这个函数：
- en: '[PRE95]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Although the output of running this snippet has 256 lines (one for each point),
    we can show an excerpt of it:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行此代码片段的输出有 256 行（每行一个点），但我们可以展示其中的一部分：
- en: '[PRE96]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: See also
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Sorting a range*, to learn about the standard algorithms for sorting ranges'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对范围进行排序*，了解标准算法对范围的排序方法'
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内使用集合操作*，了解用于执行排序范围并集、交集或差集的标准算法'
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内查找元素*，了解标准算法在值序列中的搜索方法'
- en: '*Chapter 2*, *Generating pseudo-random numbers*, to understand the proper ways
    for generating pseudo-random numbers in C++'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*生成伪随机数*，了解在 C++ 中生成伪随机数的正确方法'
- en: '*Chapter 2*, *Initializing all bits of internal state of a pseudo-random number
    generator*, to learn how to properly initialize random number engines'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*初始化伪随机数生成器的内部状态的所有位*，了解如何正确初始化随机数生成器'
- en: Using set operations on a range
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在范围内使用集合操作
- en: The standard library provides several algorithms for set operations that enable
    us to do unions, intersections, or differences of sorted ranges. In this recipe,
    we will see what these algorithms are and how they work.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几个集合操作算法，使我们能够对排序范围执行并集、交集或差集操作。在本配方中，我们将了解这些算法是什么以及它们是如何工作的。
- en: Getting ready
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The algorithms for set operations work with iterators, which means they can
    be used for standard containers, arrays, or any custom type representing a sequence
    that has input iterators available. All the examples in this recipe will use `std::vector`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作的算法与迭代器一起工作，这意味着它们可以用于标准容器、数组或任何具有输入迭代器的自定义类型表示的序列。本配方中的所有示例都将使用 `std::vector`。
- en: 'For all the examples in the next section, we will use the following ranges:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节的全部示例中，我们将使用以下范围：
- en: '[PRE97]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In the following section, we will explore the use of the standard algorithm
    for set operations.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨标准算法在集合操作中的应用。
- en: How to do it...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following general algorithms for set operations:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下通用算法进行集合操作：
- en: '`std::set_union()` to compute the union of two ranges into a third range:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::set_union()` 来计算两个范围合并到第三个范围中：
- en: '[PRE98]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`std::merge()` to merge the content of two ranges into a third one; this is
    similar to `std::set_union()` except that it copies the entire content of the
    input ranges into the output one, not just their union:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::merge()` 将两个范围的内容合并到第三个范围中；这与 `std::set_union()` 类似，但不同之处在于它将输入范围的全部内容复制到输出范围中，而不仅仅是它们的并集：
- en: '[PRE99]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '`std::set_intersection()` to compute the intersection of the two ranges into
    a third range:'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::set_intersection()` 来计算两个范围交集到第三个范围中：
- en: '[PRE100]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`std::set_difference()` to compute the difference of two ranges into a third
    range; the output range will contain elements from the first range, which are
    not present in the second range:'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_difference()` 用于将两个范围的计算差值到第三个范围中；输出范围将包含来自第一个范围，但不在第二个范围中的元素：'
- en: '[PRE101]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '`std::set_symmetric_difference()` to compute a dual difference of the two ranges
    into a third range; the output range will contain elements that are present in
    any of the input ranges, but only in one:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_symmetric_difference()` 用于将两个范围的双向差值计算到第三个范围中；输出范围将包含在任何输入范围中出现的元素，但只在一个范围中：'
- en: '[PRE102]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`std::includes()` to check if one range is a subset of another range (that
    is, all its elements are also present in the other range):'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::includes()` 用于检查一个范围是否是另一个范围（即，其所有元素也存在于另一个范围）的子集：'
- en: '[PRE103]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All the set operations that produce a new range from two input ranges have
    the same interface and work in a similar way:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从两个输入范围生成新范围的集合操作都具有相同的接口并以类似的方式工作：
- en: They take two input ranges, each defined by a first and last input iterator.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们接受两个输入范围，每个范围由一个第一个和最后一个输入迭代器定义。
- en: They take an output iterator to an output range where elements will be inserted.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们接受一个指向输出范围的输出迭代器，其中元素将被插入。
- en: They have an overload that takes an extra argument representing a comparison
    binary function object that must return `true` if the first argument is less than
    the second. When a comparison function object is not specified, `operator<` is
    used.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个重载，接受一个额外的参数，表示一个比较二元函数对象，该对象必须返回 `true` 如果第一个参数小于第二个。当未指定比较函数对象时，使用 `operator<`。
- en: They return an iterator past the end of the constructed output range.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们返回一个指向构造输出范围结束之后的迭代器。
- en: The input ranges must be sorted using either `operator<` or the provided comparison
    function, depending on the overload that is used.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入范围必须使用 `operator<` 或提供的比较函数进行排序，具体取决于使用的重载。
- en: The output range must not overlap any of the two input ranges.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出范围必须与两个输入范围中的任何一个都不重叠。
- en: 'We will demonstrate the way they work with additional examples using vectors
    of a POD type called `Task` that we also used in a previous recipe:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用我们之前也使用过的 `Task` 类型 POD 向量来使用额外的示例演示它们的工作方式：
- en: '[PRE104]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The particular way each algorithm produces the output range is described here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 每个算法产生输出范围的具体方式在此描述：
- en: '`std::set_union()` copies all the elements present in one or both of the input
    ranges to the output range, producing a new sorted range. If an element is found
    *M* times in the first range and *N* times in the second range, then all the *M*
    elements from the first range will be copied to the output range in their existing
    order, and then the *N* – *M* elements from the second range are copied to the
    output range if *N* > *M*, or `0` elements otherwise:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_union()` 将一个或两个输入范围中存在的所有元素复制到输出范围中，生成一个新排序的范围。如果一个元素在第一个范围中找到 *M*
    次，在第二个范围中找到 *N* 次，那么第一个范围中的所有 *M* 个元素将按其现有顺序复制到输出范围中，然后如果 *N* > *M*，则将第二个范围中的
    *N* – *M* 个元素复制到输出范围中，否则复制 `0` 个元素：'
- en: '[PRE105]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`std::merge()` copies all the elements from both the input ranges into the
    output range, producing a new range sorted with respect to the comparison function:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::merge()` 将两个输入范围的所有元素复制到输出范围中，生成一个根据比较函数排序的新范围：'
- en: '[PRE106]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`std::set_intersection()` copies all the elements that are found in both the
    input ranges into the output range, producing a new range sorted with respect
    to the comparison function:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_intersection()` 将两个输入范围中找到的所有元素复制到输出范围中，生成一个根据比较函数排序的新范围：'
- en: '[PRE107]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`std::set_difference()` copies to the output range all the elements from the
    first input range that are not found in the second input range. For equivalent
    elements that are found in both ranges, the following rule applies: if an element
    is found *M* times in the first range and *N* times in the second range, and if
    *M* > *N*, then it is copied *M* – *N* times; otherwise, it is not copied:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_difference()` 将第一个输入范围中未在第二个输入范围中找到的所有元素复制到输出范围中。对于在两个范围中都找到的等效元素，以下规则适用：如果一个元素在第一个范围中找到
    *M* 次，在第二个范围中找到 *N* 次，并且如果 *M* > *N*，则它被复制 *M* – *N* 次；否则，它不被复制：'
- en: '[PRE108]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`std::set_symmetric_difference()` copies to the output range all the elements
    that are found in either of the two input ranges but not in both of them. If an
    element is found *M* times in the first range and *N* times in the second range,
    then if *M* > *N*, the last *M* – *N* of those elements from the first range are
    copied into the output range; otherwise, the last *N* – *M* of those elements
    from the second range will be copied into the output range:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_symmetric_difference()` 将两个输入范围中找到的所有元素复制到输出范围，但不在两个范围中都存在。如果一个元素在第一个范围中找到
    *M* 次，在第二个范围中找到 *N* 次，那么如果 *M* > *N*，则从第一个范围复制最后 *M* – *N* 个这些元素到输出范围；否则，将从第二个范围复制最后
    *N* – *M* 个这些元素到输出范围：'
- en: '[PRE109]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: On the other hand, `std::includes()` does not produce an output range; it only
    checks whether the second range is included in the first range. It returns a Boolean
    value that is `true` if the second range is empty or all its elements are included
    in the first range, or `false` otherwise. It also has two overloads, one of which
    specifies a comparison binary function object.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::includes()` 不会产生输出范围；它只检查第二个范围是否包含在第一个范围中。它返回一个布尔值，如果第二个范围是空的或其所有元素都包含在第一个范围中，则为
    `true`，否则为 `false`。它还有两个重载，其中一个指定了一个比较二元函数对象。
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using vector as a default container*, to learn how to use the `std::vector`
    standard container'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*，了解如何使用 `std::vector` 标准容器'
- en: '*Sorting a range* to learn about the standard algorithms for sorting ranges'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序范围* 以了解排序范围的标准化算法'
- en: '*Using iterators to insert new elements in a container*, to learn how to use
    iterators and iterator adapters to add elements to a range'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用迭代器和迭代器适配器在容器中插入新元素*，了解如何使用迭代器和迭代器适配器向范围添加元素'
- en: '*Finding elements in a range*, to learn about the standard algorithms for searching
    through sequences of values'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内查找元素*，了解搜索值序列的标准化算法'
- en: Using iterators to insert new elements into a container
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器将新元素插入到容器中
- en: When you’re working with containers, it is often useful to insert new elements
    at the beginning, end, or somewhere in the middle. There are algorithms, such
    as the ones we saw in the previous recipe, *Using set operations on a range*,
    that require an iterator to a range to insert into, but if you simply pass an
    iterator, such as the one returned by `begin()`, it will not insert but overwrite
    the elements of the container. Moreover, it’s not possible to insert at the end
    by using the iterator returned by `end()`. In order to perform such operations,
    the standard library provides a set of iterators and iterator adapters that enable
    these scenarios.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与容器一起工作时，通常很有用，可以在开始、末尾或中间某个位置插入新元素。有一些算法，例如我们在上一个食谱中看到的，*在范围上使用集合操作*，需要迭代器来插入，但如果你简单地传递一个迭代器，例如
    `begin()` 返回的迭代器，它将不会插入而是覆盖容器的元素。此外，使用 `end()` 返回的迭代器无法在末尾插入。为了执行此类操作，标准库提供了一套迭代器和迭代器适配器，这些适配器可以支持这些场景。
- en: Getting ready
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The iterators and adapters discussed in this recipe are available in the `std`
    namespace in the `<iterator>` header. If you include headers such as `<algorithm>`,
    you do not have to explicitly include `<iterator>`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中讨论的迭代器和适配器可在 `<iterator>` 头文件中的 `std` 命名空间中找到。如果你包含了如 `<algorithm>` 这样的头文件，你就不必显式地包含
    `<iterator>`。
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the following iterator adapters to insert new elements into a container:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下迭代器适配器将新元素插入到容器中：
- en: '`std::back_inserter()` to insert elements at the end for containers that have
    a `push_back()` method:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_inserter()` 用于向具有 `push_back()` 方法的容器中插入元素到末尾：'
- en: '[PRE110]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`std::front_inserter()` to insert elements at the beginning for containers
    that have a `push_front()` method:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_inserter()` 用于向具有 `push_front()` 方法的容器中插入元素到开始位置：'
- en: '[PRE111]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`std::inserter()` to insert anywhere in a container, for containers that have
    an `insert()` method:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inserter()` 用于向具有 `insert()` 方法的容器中的任何位置插入元素：'
- en: '[PRE112]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::back_inserter()`, `std::front_inserter()`, and `std::inserter()` are
    all helper functions that create iterator adapters of the types `std::back_insert_iterator`,
    `std::front_insert_iterator`, and `std::insert_iterator`. These are all output
    iterators that append, prepend, or insert into the container for which they were
    constructed. Incrementing and dereferencing these iterators does not do anything.
    However, upon assignment, these iterators call the following methods from the
    container:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::back_inserter()`、`std::front_inserter()`和`std::inserter()`都是辅助函数，用于创建`std::back_insert_iterator`、`std::front_insert_iterator`和`std::insert_iterator`类型的迭代器适配器。这些迭代器都是输出迭代器，它们将元素追加到、预置于或插入到它们所构建的容器中。增加和取消引用这些迭代器不会做任何事情。然而，在赋值时，这些迭代器会调用容器中的以下方法：'
- en: '`std::back_insterter_iterator` calls `push_back()`'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_inserter_iterator`调用`push_back()`'
- en: '`std::front_inserter_iterator` calls `push_front()`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_inserter_iterator`调用`push_front()`'
- en: '`std::insert_iterator` calls `insert()`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::insert_iterator`调用`insert()`'
- en: 'The following is the oversimplified implementation of `std::back_inserter_iterator`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`std::back_insert_iterator`的过度简化的实现：
- en: '[PRE113]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Because of the way the assignment operator works, these iterators can only
    be used with some standard containers:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 由于赋值运算符的工作方式，这些迭代器只能与某些标准容器一起使用：
- en: '`std::back_insert_iterator` can be used with `std::vector`, `std::list`, `std::deque`,
    and `std::basic_string`.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_insert_iterator`可以与`std::vector`、`std::list`、`std::deque`和`std::basic_string`一起使用。'
- en: '`std::front_insert_iterator` can be used with `std::list`, `std::forward_list`,
    and `std:deque`.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_insert_iterator`可以与`std::list`、`std::forward_list`和`std:deque`一起使用。'
- en: '`std::insert_iterator` can be used with all the standard containers.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::insert_iterator`可以与所有标准容器一起使用。'
- en: 'The following example inserts three elements with the value `0` at the beginning
    of an `std::vector`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在`std::vector`的开头插入三个值为`0`的元素：
- en: '[PRE114]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `std::inserter()` adapter takes two arguments: the container and the iterator
    where an element is supposed to be inserted. Upon calling `insert()` on the container,
    `std::insert_iterator` increments the iterator, so upon being assigned again,
    it can insert a new element into the next position. Take a look at the following
    snippet:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::inserter()`适配器接受两个参数：容器和应该插入元素的迭代器。在容器上调用`insert()`时，`std::insert_iterator`会增加迭代器，因此再次赋值时，它可以插入新元素到下一个位置。请看以下代码片段：'
- en: '[PRE115]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There’s more...
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'These iterator adapters are intended to be used with algorithms or functions
    that insert multiple elements into a range. They can also be used, of course,
    to insert a single element, but that is rather an anti-pattern, since simply calling
    `push_back()`, `push_front()`, or `insert()` is much simpler and intuitive in
    this case. Consider the following snippets:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代器适配器旨在与算法或函数一起使用，这些算法或函数将多个元素插入到范围中。当然，它们也可以用来插入单个元素，但这并不是一个好的做法，因为在这种情况下简单地调用`push_back()`、`push_front()`或`insert()`要简单直观得多。考虑以下代码片段：
- en: '[PRE116]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The examples shown here, where adaptor iterators are used to insert a single
    element, should be avoided. They do not provide any benefit; they only make the
    code cluttered.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的示例，其中使用适配器迭代器插入单个元素，应该避免。它们没有任何好处；它们只会使代码变得混乱。
- en: See also
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using set operations on a range*, to learn about the standard algorithms used
    to perform union, intersection, or difference of sorted ranges'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内使用集合操作*，了解用于执行排序范围并集、交集或差集的标准算法'
- en: Writing your own random-access iterator
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的随机访问迭代器
- en: In the first chapter, we saw how we can enable range-based for loops for custom
    types by implementing iterators, as well as free `begin()` and `end()` functions
    to return iterators to the first and one-past-the-last element of the custom range.
    You might have noticed that the minimal iterator implementation that we provided
    in that recipe does not meet the requirements for a standard iterator. This is
    because it cannot be copy constructible or assigned and cannot be incremented.
    In this recipe, we will build upon that example and show you how to create a random-access
    iterator that meets all requirements.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们看到了如何通过实现迭代器以及提供`begin()`和`end()`函数来返回自定义范围的第一个和最后一个元素之后的迭代器，从而启用自定义类型的基于范围的for循环。你可能已经注意到，在那个菜谱中提供的最小迭代器实现并不满足标准迭代器的需求。这是因为它不能被复制构造或赋值，也不能被增加。在这个菜谱中，我们将在此基础上构建示例，并展示如何创建一个满足所有要求的随机访问迭代器。
- en: Getting ready
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should know the types of iterators the standard defines
    and how they are different. A good overview of their requirements is available
    at [http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你应该了解标准定义的迭代器类型以及它们之间的区别。关于它们要求的良好概述可在[http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/)找到。
- en: 'To exemplify how to write a random-access iterator, we will consider a variant
    of the `dummy_array` class used in the *Enabling range-based for loops for custom
    types* recipe of *Chapter 1*, *Learning Modern Core Language Features*. This is
    a very simple array concept with no practical value other than serving as a code
    base for demonstrating iterators:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何编写随机访问迭代器，我们将考虑在 *第一章* 的 *学习现代核心语言特性* 菜谱中使用的 `dummy_array` 类的一个变体，即 *启用自定义类型的基于范围的
    for 循环*。这是一个非常简单的数组概念，除了作为演示迭代器的代码库外，没有实际价值：
- en: '[PRE117]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: All the code shown in the next section, the iterator classes, typedefs, and
    the `begin()` and `end()` functions, will be a part of this class.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分中显示的所有代码，包括迭代器类、typedefs 和 `begin()` 以及 `end()` 函数，都将成为本类的一部分。
- en: 'Also, in this recipe, we will look at an example utilizing the following class
    called `Tag`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个菜谱中，我们将查看一个使用以下名为 `Tag` 的类的示例：
- en: '[PRE118]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How to do it...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To provide mutable and constant random-access iterators for the `dummy_array`
    class shown in the previous section, add the following members to the class:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为上一节中所示的 `dummy_array` 类提供可变和常量随机访问迭代器，请向类中添加以下成员：
- en: 'An iterator class template, which is parameterized with the type of elements
    and the size of the array. The class must have the following public typedefs that
    define standard synonyms:'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个迭代器类模板，它以元素类型和数组大小为参数。该类必须具有以下公共 typedefs，以定义标准同义词：
- en: '[PRE119]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Private members for the iterator class—a pointer to the array data and a current
    index into the array:'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的私有成员——指向数组数据的指针和数组中的当前索引：
- en: '[PRE120]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'A private method for the iterator class to check whether two iterator instances
    point to the same array data:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的一个私有方法，用于检查两个迭代器实例是否指向相同的数组数据：
- en: '[PRE121]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'An explicit constructor for the iterator class:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的一个显式构造函数：
- en: '[PRE122]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Iterator class members to meet common requirements for all iterators—copy-constructible,
    copy-assignable, destructible, prefix, and postfix incrementable. In this implementation,
    the post-increment operator is implemented in terms of the pre-increment operator
    to avoid code duplication:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足所有迭代器的通用要求——可复制构造函数、可复制赋值、可析构、前缀和后缀可增量。在此实现中，后增量运算符是用前增量运算符实现的，以避免代码重复：
- en: '[PRE123]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Iterator class members to meet input iterator requirements—test for equality/inequality,
    dereferenceable as `rvalues`:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足输入迭代器要求的迭代器类成员——测试相等/不等，可解引用为 `rvalues`：
- en: '[PRE124]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Iterator class members to meet forward iterator requirements—default constructible:'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足正向迭代器要求的迭代器类成员——默认构造函数：
- en: '[PRE125]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Iterator class members to meet bidirectional iterator requirements—decrementable:'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足双向迭代器要求的迭代器类成员——可减量：
- en: '[PRE126]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Iterator class members to meet random access iterator requirements—arithmetic
    add and subtract, comparable for inequality with other iterators, compound assignments,
    and offset dereferenceable:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足随机访问迭代器要求的迭代器类成员——算术加法和减法，与其他迭代器的不等比较，复合赋值，以及偏移量可解引用：
- en: '[PRE127]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Add typedefs to the `dummy_array` class for mutable and constant iterator synonyms:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `dummy_array` 类添加 typedefs 以获得可变和常量迭代器同义词：
- en: '[PRE128]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Add the public `begin()` and `end()` functions to the `dummy_array` class to
    return the iterators to the first and one-past-last elements in the array:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将公共的 `begin()` 和 `end()` 函数添加到 `dummy_array` 类中，以返回数组中的第一个和最后一个元素之后的迭代器：
- en: '[PRE129]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: How it works...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The standard library defines five categories of iterators:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义了五种迭代器类别：
- en: '**Input iterators**: These are the simplest category and guarantee validity
    only for single-pass sequential algorithms. After being incremented, the previous
    copies may become invalid.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入迭代器**：这是最简单的类别，仅保证单次遍历顺序算法的有效性。在增加后，之前的副本可能变得无效。'
- en: '**Output iterators**: These are basically input iterators that can be used
    to write to the pointed element.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出迭代器**：这些基本上是输入迭代器，可以用来写入指向的元素。'
- en: '**Forward iterators**: These can read (and write) data to the pointed element.
    They satisfy the requirements for input iterators and, in addition, must be default
    constructible and must support multi-pass scenarios without invalidating the previous
    copies.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正向迭代器**：这些可以读取（和写入）指向的元素中的数据。它们满足输入迭代器的需求，并且，此外，必须是默认可构造的，并且必须支持多遍场景而不使之前的副本无效。'
- en: '**Bidirectional iterators**: These are forward iterators that, in addition,
    support decrementing so that they can move in both directions.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向迭代器**：这些是正向迭代器，除此之外，它们还支持递减操作，因此可以双向移动。'
- en: '**Random access iterators**: These support access to any element in the container
    in constant time. They implement all the requirements for bidirectional iterators,
    and, in addition, support arithmetic operations `+` and `-`, compound assignments
    `+=` and `-=`, comparisons with other iterators with `<`, `<=`, `>`, `>=`, and
    the offset dereference operator.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机访问迭代器**：这些支持在常数时间内访问容器中的任何元素。它们实现了双向迭代器的所有要求，并且，此外，支持算术运算`+`和`-`，复合赋值`+=`和`-=`，与其他迭代器的比较操作`<`、`<=`、`>`、`>=`以及偏移量解引用运算符。'
- en: Forward, bidirectional, and random-access iterators that also implement the
    requirements of output iterators are called *mutable iterators*.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 同时实现输出迭代器要求的正向、双向和随机访问迭代器被称为*可变迭代器*。
- en: In the previous section, we saw how to implement random access iterators, with
    a step-by-step walkthrough of the requirements of each category of iterators (as
    each iterator category includes the requirements of the previous category and
    adds new requirements). The iterator class template is common for both constant
    and mutable iterators, and we have defined two synonyms for it called `iterator`
    and `constant_iterator`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何实现随机访问迭代器，通过逐步讲解每个迭代器类别的要求（因为每个迭代器类别都包括前一个类别的要求并添加新的要求）。迭代器类模板对常量和可变迭代器都是通用的，我们为它定义了两个同义词，称为`iterator`和`constant_iterator`。
- en: After implementing the inner iterator class template, we also defined the `begin()`
    and `end()` member functions, which return an iterator to the first and the one-past-last
    element in the array, respectively. These methods have overloads to return mutable
    or constant iterators, depending on whether the `dummy_array` class instance is
    mutable or constant.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现内部迭代器类模板之后，我们还定义了`begin()`和`end()`成员函数，分别返回数组的第一个元素和最后一个元素之后的迭代器。这些方法有重载，可以根据`dummy_array`类实例是否可变返回可变或常量迭代器。
- en: 'With this implementation of the `dummy_array` class and its iterators, we can
    write the following code:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dummy_array`类及其迭代器的这种实现，我们可以编写以下代码：
- en: '[PRE130]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: For more examples, check the source code that accompanies this book.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例，请查看本书附带的源代码。
- en: There’s more...
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Apart from `begin()` and `end()`, a container may have additional methods such
    as `cbegin()`/`cend()` (for constant iterators), `rbegin()`/`rend()` (for mutable
    reverse iterators), and `crbegin()`/ `crend()` (for constant reverse iterators).
    Implementing this is left as an exercise for you.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`begin()`和`end()`之外，容器可能还有其他方法，例如`cbegin()`/`cend()`（用于常量迭代器）、`rbegin()`/`rend()`（用于可变反向迭代器）和`crbegin()`/
    `crend()`（用于常量反向迭代器）。实现这一点留作你的练习。
- en: On the other hand, in modern C++, these functions that return the first and
    last iterators do not have to be member functions but can be provided as non-member
    functions. In fact, this is the topic of the next recipe, *Container access with
    non-member functions*.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在现代C++中，返回第一个和最后一个迭代器的这些函数不必是成员函数，但可以作为非成员函数提供。事实上，这正是下一道菜谱的主题，*使用非成员函数访问容器*。
- en: See also
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 1*, *Enabling range-based for loops for custom types,* to learn to
    execute one or more statements for each element of a collection'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*为自定义类型启用基于范围的for循环*，学习如何对集合中的每个元素执行一个或多个语句'
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*创建类型别名和别名模板*，了解类型别名的知识'
- en: Container access with non-member functions
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非成员函数访问容器
- en: 'Standard containers provide the `begin()` and `end()` member functions for
    retrieving iterators for the first and one-past-last elements of the container.
    There are actually four sets of these functions. Apart from `begin()`/`end()`,
    containers provide `cbegin()`/`cend()` to return constant iterators, `rbegin()`/`rend()`
    to return mutable reverse iterators, and `crbegin()`/`crend()` to return constant
    reverse iterators. In C++11/C++14, all these have non-member equivalents that
    work with standard containers, arrays, and any custom type that specializes them.
    In C++17, even more non-member functions have been added: `std::data()`, which
    returns a pointer to the block of memory containing the elements of the container;
    `std::size()`, which returns the size of a container or array; and `std::empty()`,
    which returns whether the given container is empty. These non-member functions
    are intended for generic code but can be used anywhere in your code. Moreover,
    in C++20, the `std::ssize()` non-member function was introduced to return the
    size of a container or array as a signed integer.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器提供了`begin()`和`end()`成员函数，用于检索容器的第一个和最后一个元素之后的迭代器。实际上，有四组这样的函数。除了`begin()`/`end()`之外，容器还提供了`cbegin()`/`cend()`来返回常量迭代器，`rbegin()`/`rend()`来返回可变反向迭代器，以及`crbegin()`/`crend()`来返回常量反向迭代器。在C++11/C++14中，所有这些都有非成员等效函数，它们与标准容器、数组以及任何专门化它们的自定义类型一起工作。在C++17中，还添加了更多的非成员函数：`std::data()`，它返回指向包含容器元素的内存块的指针；`std::size()`，它返回容器或数组的大小；以及`std::empty()`，它返回给定的容器是否为空。这些非成员函数旨在用于通用代码，但可以在代码的任何地方使用。此外，在C++20中，引入了`std::ssize()`非成员函数，以返回容器或数组的大小作为有符号整数。
- en: Getting ready
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `dummy_array` class and its iterators that we
    implemented in the previous recipe, *Writing your own random-access iterator*,
    as an example. You should read that recipe before continuing with this one.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用我们在之前的菜谱中实现的`dummy_array`类及其迭代器，即*编写自己的随机访问迭代器*，作为一个例子。你应该在继续阅读这个菜谱之前先阅读那个菜谱。
- en: 'Non-member `begin()`/`end()` functions and the other variants, as well as non-member
    `data()`, `size()`, and `empty()` functions are available in the `std` namespace
    in the `<iterator>` header, which is implicitly included with any of the following
    headers: `<array>`, `<deque>`, `<forward_list>`, `<list>`, `<map>`, `<regex>`,
    `<set>`, `<string>`, `<unordered_map>`, `<unordered_set>`, and `<vector>`.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 非成员`begin()`/`end()`函数以及其他变体，以及非成员`data()`、`size()`和`empty()`函数，都包含在`<iterator>`头文件中的`std`命名空间中，该头文件在以下任何头文件中隐式包含：`<array>`、`<deque>`、`<forward_list>`、`<list>`、`<map>`、`<regex>`、`<set>`、`<string>`、`<unordered_map>`、`<unordered_set>`和`<vector>`。
- en: 'In this recipe, we will refer to the `std::begin()`/`std::end()` functions,
    but everything discussed also applies to the other functions: `std::cbegin()`/`std::cend()`,
    `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将参考`std::begin()`/`std::end()`函数，但所讨论的一切也适用于其他函数：`std::cbegin()`/`std::cend()`、`std::rbegin()`/`std::rend()`和`std::crbegin()`/`std::crend()`。
- en: How to do it...
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the non-member `std::begin()`/`std::end()` function and the other variants,
    as well as `std::data()`, `std::size()`, and `std::empty()` with:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非成员`std::begin()`/`std::end()`函数以及其他变体，以及`std::data()`、`std::size()`和`std::empty()`，与以下内容一起使用：
- en: 'Standard containers:'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准容器：
- en: '[PRE136]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Arrays:'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE137]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Custom types that provide the corresponding member functions; that is, `begin()`/`end()`,
    `data()`, `empty()`, or `size()`:'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供相应成员函数的自定义类型；即`begin()`/`end()`、`data()`、`empty()`或`size()`：
- en: '[PRE138]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Generic code where the type of the container is not known:'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知容器类型的通用代码：
- en: '[PRE139]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works...
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'These non-member functions were introduced in different versions of the standard,
    but all of them were modified in C++17 to return `constexpr auto`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非成员函数在标准的不同版本中被引入，但它们都在C++17中被修改为返回`constexpr auto`：
- en: '`std::begin()` and `std::end()` in C++11'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11中的`std::begin()`和`std::end()`
- en: '`std::cbegin()`/`std::cend()`, `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`
    in C++14'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++14中的`std::cbegin()`/`std::cend()`、`std::rbegin()`/`std::rend()`和`std::crbegin()`/`std::crend()`
- en: '`std::data()`, `std::size()`, and `std::empty()` in C++17'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++17中的`std::data()`、`std::size()`和`std::empty()`
- en: '`std::ssize()` in C++20'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20中的`std::ssize()`
- en: 'The `begin()`/`end()` family of functions have overloads for container classes
    and arrays, and all they do is the following:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`/`end()`函数族为容器类和数组提供了重载，它们所做的一切如下：'
- en: Return the results of calling the container-corresponding member function for
    containers
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回调用容器对应成员函数的结果
- en: Return a pointer to the first or one-past-last element of the array for arrays
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数组，返回数组的第一个或最后一个元素之后的指针。
- en: 'The actual typical implementation for `std::begin()`/`std::end()` is as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin()`/`std::end()`的实际典型实现如下：'
- en: '[PRE140]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Custom specialization can be provided for containers that do not have corresponding
    `begin()`/`end()` members but can still be iterated. The standard library actually
    provides such specializations for `std::initializer_list` and `std::valarray`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为没有对应`begin()`/`end()`成员但仍然可以迭代的容器提供自定义特化。标准库实际上为`std::initializer_list`和`std::valarray`提供了这样的特化。
- en: Specializations must be defined in the same namespace where the original class
    or function template has been defined. Therefore, if you want to specialize any
    of the `std::begin()`/`std::end()` pairs, you must do so in the `std` namespace.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 特化必须在原始类或函数模板定义的同一命名空间中定义。因此，如果您想特化任何`std::begin()`/`std::end()`对，您必须在`std`命名空间中这样做。
- en: 'The other non-member functions for container access that were introduced in
    C++17 also have several overloads:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中引入的其他用于容器访问的非成员函数也有几个重载：
- en: '`std::data()` has several overloads; for a class `C` it returns `c.data()`,
    for arrays it returns the `array`, and for `std::initializer_list<T>` it returns
    the `il.begin()`:'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::data()`有几个重载；对于一个类`C`，它返回`c.data()`，对于数组，它返回`array`，对于`std::initializer_list<T>`，它返回`il.begin()`：'
- en: '[PRE141]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`std::size()` has two overloads; for a class `C` it returns `c.size()`, and
    for arrays it returns the size `N`:'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::size()`有两个重载；对于一个类`C`，它返回`c.size()`，对于数组，它返回大小`N`：'
- en: '[PRE142]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`std::empty()` has several overloads; for a class `C` it returns `c.empty()`,
    for arrays it returns `false`, and for `std::initializer_list<T>` it returns `il.size()
    == 0`:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::empty()`有几个重载；对于一个类`C`，它返回`c.empty()`，对于数组，它返回`false`，对于`std::initializer_list<T>`，它返回`il.size()
    == 0`：'
- en: '[PRE143]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In C++20, the `std::ssize()` non-member function was added as a companion to
    `std::size()` to return the number of elements in a given container or an array
    as a signed integer. `std::size()` returns an unsigned integer, but there are
    scenarios where a signed value is desired. For instance, the C++20 class `std::span`,
    which represents a view to a contiguous sequence of objects, has a `size()` member
    function that returns a signed integer, unlike standard library containers where
    the `size()` member function returns an unsigned integer.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中，`std::ssize()`非成员函数被添加为`std::size()`的配套函数，以返回给定容器或数组中的元素数量作为一个有符号整数。`std::size()`返回一个无符号整数，但在某些情况下可能需要一个有符号值。例如，C++20类`std::span`表示对连续对象序列的视图，它有一个返回有符号整数的`size()`成员函数，而标准库容器中的`size()`成员函数返回一个无符号整数。
- en: 'The reason the function `size()` of `std::span` returns a signed integer is
    that the value -1 is supposed to represent a sentinel for types whose size was
    not known at compile time. Performing mixed signed and unsigned arithmetic can
    lead to errors in code that are hard to find. `std::ssize()` has two overloads:
    for a class `C` it returns `c.size()` statically cast to a signed integer (typically
    `std::ptrdiff_t`) and for arrays it returns `N`, the number of elements. Take
    a look at the following code snippets:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`的`size()`函数返回有符号整数的原因是，值-1被用来表示在编译时未知大小的类型的哨兵。执行混合有符号和无符号算术可能导致难以找到错误的代码。`std::ssize()`有两个重载：对于一个类`C`，它返回将`c.size()`静态转换为有符号整数（通常是`std::ptrdiff_t`），对于数组，它返回`N`，即元素的数量。请查看以下代码片段：'
- en: '[PRE144]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The preceding snippets show possible implementations for the `std::ssize()`
    function for containers and arrays.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了为容器和数组中的`std::ssize()`函数可能的实现。
- en: There’s more...
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: These non-member functions are mainly intended for template code where the container
    is not known and can be a standard container, an array, or a custom type. Using
    the non-member version of these functions enables us to write simpler and less
    code that works with all these types of containers.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非成员函数主要适用于模板代码，其中容器是未知的，可以是标准容器、数组或自定义类型。使用这些函数的非成员版本使我们能够编写更简单、更少的代码，这些代码可以与所有这些类型的容器一起工作。
- en: However, the use of these functions is not and should not be limited to generic
    code. Though it is rather a matter of personal preference, it can be a good habit
    to be consistent and use them everywhere in your code. All these methods have
    lightweight implementations that will most likely be inlined by the compiler,
    which means that there will be no overhead at all for using the corresponding
    member functions.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些函数的使用并不应该仅限于通用代码。尽管这更多的是个人偏好的问题，但养成一致性的好习惯，在代码的任何地方都使用它们，可能是一个好习惯。所有这些方法都有轻量级的实现，编译器很可能会内联它们，这意味着使用相应的成员函数将不会有任何开销。
- en: See also
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing your own random-access iterator*, to understand what you need to do
    to write a custom, random-access iterator'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写自己的随机访问迭代器*，以了解编写自定义随机访问迭代器需要做什么'
- en: Selecting the right standard containers
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的标准容器
- en: The standard library contains a variety of containers for meeting multiple and
    various needs. There are sequence containers (in which elements are arranged in
    a certain position), container adapters (that provide a different interface for
    sequential containers), associative containers (in which the order is given by
    a key associated with an element), unordered associative containers (in which
    the elements do not follow a certain order). Selecting the right container for
    a given task is not always straight forward. This recipe will provide guidelines
    to help you decide which one to use for what purpose.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含各种容器，以满足多种和不同的需求。有顺序容器（其中元素按一定位置排列）、容器适配器（为顺序容器提供不同的接口）、关联容器（其中顺序由与元素关联的键给出）、无序关联容器（其中元素不遵循某种顺序）。为特定任务选择正确的容器并不总是直截了当。本食谱将提供指导方针，以帮助您决定为哪种目的使用哪种容器。
- en: How to do it…
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To decide which standard container you should use, consider the following guidelines:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 要决定应该使用哪个标准容器，请考虑以下指导方针：
- en: Use `std::vector` as the default container, when no other specific requirements
    exist.
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::vector` 作为默认容器，当没有其他特定要求时。
- en: Use `std::array` when the length of a sequence is fixed and known at compile
    time.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当序列的长度在编译时已知且固定时，请使用 `std::array`。
- en: Use `std::deque` if you frequently need to add or remove elements at the beginning
    and the end of a sequence.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你经常需要在序列的开始和结束处添加或删除元素，请使用 `std::deque`。
- en: Use `std::list` if you frequently need to add or remove elements in the middle
    of the sequence (that’s anywhere else other than the beginning and end) and bidirectional
    traversing of the sequence is required.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你经常需要在序列的中间添加或删除元素（除了开始和结束之外的其他地方），并且需要序列的双向遍历，请使用 `std::list`。
- en: Use `std::forward_list` if you frequently need to add or remove elements anywhere
    in the sequence but you only need to traverse the sequence in one direction.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你经常需要在序列的任何位置添加或删除元素，但你只需要按一个方向遍历序列，请使用 `std::forward_list`。
- en: Use `std::stack` if you need a sequence with **last-in, first-out** (**LIFO**)
    semantics.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个具有**后进先出**（**LIFO**）语义的序列，请使用 `std::stack`。
- en: Use `std::queue` if you need a sequence with **first-in, first-out** (**FIFO**)
    semantics.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个具有**先进先出**（**FIFO**）语义的序列，请使用 `std::queue`。
- en: Use `std::priority_queue` if you need a sequence with FIFO semantics, but in
    which elements are arranged in a strict weak ordering (the largest – highest priority
    element comes first).
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个具有先进先出（**FIFO**）语义的序列，但其中元素按严格的弱序排列（最大的元素——最高优先级的元素排在第一位），请使用 `std::priority_queue`。
- en: Use `std::unordered_map` if you need to store key-value pairs and the order
    of the elements is not important but keys must be unique.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储键值对，元素的顺序不重要但键必须是唯一的，请使用 `std::unordered_map`。
- en: Use `std::map` if you need to store key-value pairs with unique keys but the
    order of the elements is given by their keys.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储具有唯一键的键值对，但元素的顺序由它们的键给出，请使用 `std::map`。
- en: Use `std::unordered_multimap` if you need to store key-value pairs, the keys
    can be duplicated, and the order of the elements is not important.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储键值对，键可以重复，且元素的顺序不重要，请使用 `std::unordered_multimap`。
- en: Use `std::multimap` if you need to store key-value pairs, the keys can be duplicated,
    and the elements are stored in an order given by their keys.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储键值对，键可以重复，且元素按它们的键的顺序存储，请使用 `std::multimap`。
- en: Use `std::unordered_set` if you need to store unique values but their order
    is not important.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储唯一值但它们的顺序不重要，请使用 `std::unordered_set`。
- en: Use `std::set` if you need to store unique values but the order of the elements
    is important (the lowest elements are stored first).
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要存储唯一值但元素的顺序很重要（最低的元素首先存储），请使用 `std::set`。
- en: Use `std::unordered_multiset` if you want to store non-unique values, although
    their order does not matter, and you want the search capabilities of a set.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要存储非唯一值，尽管它们的顺序不重要，但你想拥有集合的搜索功能，请使用 `std::unordered_multiset`。
- en: Use `std::multiset` if you want to store non-unique value, but the order of
    the elements matter, with those having a lowest key coming first, and you want
    the search capabilities of a set.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要存储非唯一值，但元素的顺序很重要，具有最低键的元素首先存储，并且你想要集合的搜索功能，请使用 `std::multiset`。
- en: How it works…
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Containers are objects that store other objects, internally managing the memory
    used by the stored objects. They provide access to elements and other functionality
    defined by standardized interfaces. There are four categories of containers in
    the standard library:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是存储其他对象的对象，内部管理存储对象的内存。它们通过标准接口提供对元素和其他功能的访问。标准库中有四种容器类别：
- en: '**Sequence containers** store elements in a certain order but this order does
    not depend on the value of the element. Sequence containers are typically implemented
    either as arrays (elements are stored contiguous in memory) or linked lists (elements
    are stored in nodes that point to others). The standard sequence containers are
    `std::array`, `std::vector`, `std::list`, `std::forward_list`, and `std::deque`.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列容器**按照一定顺序存储元素，但这种顺序不依赖于元素的值。序列容器通常实现为数组（元素在内存中连续存储）或链表（元素存储在指向其他元素的节点中）。标准的序列容器包括
    `std::array`、`std::vector`、`std::list`、`std::forward_list` 和 `std::deque`。'
- en: '**Container adaptors** define an adapted interface towards a sequence container.
    These are `std::stack`, `std::queue`, and `std::priority_queue`.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器适配器**定义了对序列容器的适配接口。这些是 `std::stack`、`std::queue` 和 `std::priority_queue`。'
- en: '**Associative containers** store elements in a certain order given by keys
    associated with each element. Although they support insertion and deletion, this
    cannot happen at a specific position but depends on the key. They provide good
    performance for searching elements, a binary search that has logarithmic complexity
    being possible for all containers. The standard associative containers are `std::map`,
    `std::set`, `std::multimap`, and `std::multiset`.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联容器**根据与每个元素关联的键存储元素。尽管它们支持插入和删除，但这不能在特定位置发生，而是取决于键。它们为搜索元素提供良好的性能，所有容器都可能的二分搜索具有对数复杂度。标准的关联容器包括
    `std::map`、`std::set`、`std::multimap` 和 `std::multiset`。'
- en: '**Unordered associative containers** store elements that are not ordered. These
    containers are implemented using hash tables, which makes searching elements a
    constant-time operation. Unlike associated containers, the unordered ones do not
    support binary search. Hash functions must be implemented for the types of the
    elements stored in an unordered associative container. The standard containers
    are `std::unordered_map`, `std::unordered_multimap`, `std::unordered_set`, and
    `std::unordered_multiset`.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无序关联容器**存储无序的元素。这些容器使用哈希表实现，这使得搜索元素成为常数时间操作。与关联容器不同，无序的容器不支持二分搜索。必须为存储在无序关联容器中的元素类型实现哈希函数。标准的容器包括
    `std::unordered_map`、`std::unordered_multimap`、`std::unordered_set` 和 `std::unordered_multiset`。'
- en: 'The `std::vector` container is perhaps the most used one, as the code snippets
    in this book also show. A vector stores its elements sequentially in a contiguous
    memory. A vector can grow and shrink. Although elements can be inserted anywhere
    in the sequence, the most efficient operations are insertions and removals at
    the end of the sequence (with `push_back()` and `pop_back()`):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 容器可能是最常用的一个，正如这本书中的代码片段也显示的那样。向量将其元素顺序存储在连续的内存中。向量可以增长和缩小。尽管元素可以插入到序列中的任何位置，但最有效的操作是在序列的末尾插入和删除（使用
    `push_back()` 和 `pop_back()`）：'
- en: '[PRE145]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Here is a conceptual representation of a vector before and after inserting
    an element at its end:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向量的概念表示，在插入元素到其末尾之前和之后：
- en: '![](img/B21549_05_01.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_05_01.png)'
- en: 'Figure 5.1: Inserting an element at the end of a vector'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：在向量的末尾插入一个元素
- en: 'Inserting or removing elements anywhere other than the end of the sequence
    (with `insert()` and `erase()`) is less performant because all of the elements
    after the insertion/removal position must be moved in memory. If an insert operation
    would determine capacity of the vector (the number of elements that can be stored
    in the allocated memory) to be exceeded, a reallocation must occur. In this case,
    a new, larger contiguous sequence of memory is allocated, and all the stored elements
    are copied to this new buffer, along with the newly added ones, and the old memory
    chunk is deleted:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列的除两端以外的任何位置（使用`insert()`和`erase()`）插入或删除元素性能较低，因为必须在内存中移动插入/删除位置之后的所有元素。如果插入操作会确定向量的容量（在分配的内存中可以存储的元素数量）超过，则必须进行重新分配。在这种情况下，分配一个新的更大的连续内存序列，并将所有存储的元素以及新添加的元素复制到这个新缓冲区中，然后删除旧的内存块：
- en: '[PRE146]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The next diagram shows a conceptual representation of a vector before and after
    inserting a new element in the middle:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了在插入新元素之前和之后向向量中间插入元素的概念表示：
- en: '![](img/B21549_05_02.png)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_05_02.png)'
- en: 'Figure 5.2: Inserting an element in the middle of a vector'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：在向量中间插入元素
- en: 'If frequent insertions or deletion also occur at the beginning of the sequence,
    a better alternative is the `std::deque` container. This allows fast inserts and
    removals at both ends (with `push_front()`/`pop_front()` and `push_back()`/`pop_back()`).
    Removals at the two ends do not invalidate pointers or references to the rest
    of the elements. However, unlike `std::vector`, `std::deque` does not store its
    elements contiguously in memory, but in a sequence of fixed-length arrays that
    require extra management. Although indexing elements involve two levels of pointer
    dereferencing, compared to just one for `std::vector`, expanding a `deque` is
    faster than for `vector`, because it does not require reallocating all the memory
    and copying the existing elements:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果序列的开头也频繁发生插入或删除操作，更好的选择是使用`std::deque`容器。这允许在两端快速插入和删除（使用`push_front()`/`pop_front()`和`push_back()`/`pop_back()`）。在两端进行的删除操作不会使指向其余元素的指针或引用失效。然而，与`std::vector`不同，`std::deque`并不在内存中连续存储其元素，而是在一系列固定长度的数组中，这需要额外的管理。尽管索引元素涉及两级指针解引用，与`std::vector`仅涉及一级相比，扩展`deque`比扩展`vector`更快，因为它不需要重新分配所有内存并复制现有元素：
- en: '[PRE147]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Neither `std::vector` nor `std::deque` have a good performance for insertions
    in the middle of the sequence (middle meaning anywhere other than the ends). A
    container that does offer constant time insertions in the middle is `std::list`.
    This is implemented as a double-linked list, which means elements are not stored
    in contiguous memory. The use cases for `std::list` are not many though. A typical
    one is the situations when you need to do many inserts and removals in the middle,
    more than iterations over the list. You can also use a `std::list` when you have
    one or more sequences that you need to split and join often.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`和`std::deque`在序列中间的插入操作（中间指的是除了两端以外的任何位置）性能都不好。一个提供中间插入常数时间操作的容器是`std::list`。它实现为一个双链表，这意味着元素不是存储在连续的内存中。`std::list`的使用场景并不多。一个典型的情况是在需要频繁在中间进行插入和删除操作，并且这些操作比列表迭代还要多的情况下。你也可以在需要经常拆分和连接一个或多个序列时使用`std::list`。'
- en: 'If you also need to retain the validity of iterators and references to the
    elements of the list even after an insert or removal, then `std::list` is a good
    candidate:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还需要在插入或删除操作后保持列表元素的迭代器和引用的有效性，那么`std::list`是一个不错的选择：
- en: '[PRE148]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The next diagram shows a conceptual representation of a (double-linked) list
    and the insertion of a new element in the middle of it:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了（双链）列表的概念表示以及在其中插入新元素的过程：
- en: '![](img/B21549_05_03.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_05_03.png)'
- en: 'Figure 5.3: Inserting an element in the middle of a list'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：在列表中间插入元素
- en: 'If you want to store values identified by a key, associative containers are
    the appropriate solution. Storing key-value pairs is possible with either `std::map`
    and `std::unordered_map`. These two containers differ significantly:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要存储由键标识的值，关联容器是合适的解决方案。使用`std::map`和`std::unordered_map`都可以存储键值对。这两个容器有显著的不同：
- en: '`std::map` stores the key-value pairs ordered by the key (using a comparison
    function, the default being `std::less`), while `std::unordered_map`, as the name
    implies, does not retain any order.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`按照键的顺序存储键值对（使用比较函数，默认为`std::less`），而`std::unordered_map`，正如其名所示，不保留任何顺序。'
- en: '`std::map` is implemented with self-balancing **binary search trees** (**BST**)
    such as red-back trees, while `std::unordered_map` is implemented with hash tables.
    Since hash tables require more book-keeping data, `std::unordered_map` uses more
    memory than `std::map` to store the same number of elements.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 使用自平衡 **二叉搜索树**（**BST**）如红黑树实现，而 `std::unordered_map` 使用哈希表实现。由于哈希表需要更多的维护数据，因此
    `std::unordered_map` 比存储相同数量元素时的 `std::map` 使用更多的内存。'
- en: '`std::map` provides logarithmic complexity, *O(log(n))*, for search operations,
    and the same plus a rebalancing for inserts and removals, while `std::unordered_map`
    provides constant-time, *O(1)*, on average for inserts, although worst case scenarios
    decrease to linear complexity, *O(n)*, for all search, insert, and remove operations.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map` 为搜索操作提供对数复杂度，*O(log(n))*，并且对于插入和删除操作，相同加上平衡操作，而 `std::unordered_map`
    在平均情况下为插入提供常数时间，*O(1)*，尽管在最坏情况下，所有搜索、插入和删除操作的性能降低到线性复杂度，*O(n)*。'
- en: 'Based on these differences, we can identify typical use cases for each of these
    containers:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些差异，我们可以确定每个这些容器的典型用例：
- en: '`std::map` is recommended when:'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当推荐使用 `std::map` 时：
- en: You need to store the elements ordered in the container, so that they can be
    accessed in their defined order
  id: totrans-612
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要按顺序存储容器中的元素，以便可以按其定义的顺序访问
- en: You need the successor or predecessor of an element
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要元素的后续或前驱
- en: You need to lexicographically compare maps with the `<`, `<=`, `>`, or `>=`
    operators
  id: totrans-614
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要使用 `<`、`<=`、`>` 或 `>=` 操作符进行字典序比较映射
- en: You want to use algorithms such as `binary_search()`, `lower_bound()`, or `upper_bound()`
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想使用 `binary_search()`、`lower_bound()` 或 `upper_bound()` 等算法
- en: '`std::unordered_map` is recommended when:'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当推荐使用 `std::unordered_map` 时：
- en: You don’t need to store the unique objects in a particular order
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要按照特定顺序存储唯一对象
- en: You perform a lot of inserts/removals and searches
  id: totrans-618
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您执行大量的插入/删除和搜索操作
- en: You need to access individual elements and iterating over the entire sequence
    is not required
  id: totrans-619
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要访问单个元素，并且不需要迭代整个序列
- en: In order to use `std::unordered_map`, a hash function (either a specialization
    of `std::hash<T>` or a different implementation) must be defined for the type
    of the stored elements. This is necessary because in an `std::unordered_map`,
    elements are stored in buckets. The bucket to which an element is stored depends
    on the hash value of the key. A good hashing function can prevent collisions,
    allowing all operations to take constant time – *O(1)*. On the other hand, if
    the hashing function is not well crafted, it can lead to collisions that degrade
    searches and inserts/removals to linear complexity – *O(n)*.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `std::unordered_map`，必须为存储元素的类型定义一个哈希函数（可以是 `std::hash<T>` 的特化或不同的实现）。这是必要的，因为在
    `std::unordered_map` 中，元素存储在桶中。元素存储的桶取决于键的哈希值。一个好的哈希函数可以防止冲突，使所有操作都能以常数时间 – *O(1)*
    完成。另一方面，如果哈希函数设计不当，可能会导致冲突，降低搜索和插入/删除操作的复杂度到线性 – *O(n)*。
- en: 'When you want to store unique objects but do not have a key associated with
    each object, the right standard containers are `std::set` and `std::unordered_set`.
    A set is very similar to a map, except that the object is also the key. These
    two containers, `std::set` and `std::unordered_set`, have the same differences
    we saw for `std::map` and `std::unordered_map`:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要存储唯一对象但没有与每个对象关联的键时，正确的标准容器是 `std::set` 和 `std::unordered_set`。集合与映射非常相似，除了对象本身也是键。这两个容器，`std::set`
    和 `std::unordered_set`，与我们在 `std::map` 和 `std::unordered_map` 中看到的不同之处相同：
- en: In a `std::set` objects are ordered, while in a `std::unordered_set` they are
    unordered.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `std::set` 中对象是有序的，而在 `std::unordered_set` 中是无序的。
- en: '`std::set` is implemented with red-black trees, while `std::unordered_set`
    is implemented with hash tables.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set` 使用红黑树实现，而 `std::unordered_set` 使用哈希表实现。'
- en: '`std::set` provides logarithmic complexity, *O(log(n))*, for search operations,
    and the same plus a rebalancing for inserts and removals, while `std::unordered_set`
    provides constant-time, *O(1)*, on average for inserts, although worst case scenarios
    decrease to linear complexity, *O(n)*, for all search, insert, and remove operations.'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set` 为搜索操作提供对数复杂度，*O(log(n))*，并且对于插入和删除操作，相同加上平衡操作，而 `std::unordered_set`
    在平均情况下为插入提供常数时间，*O(1)*，尽管在最坏情况下，所有搜索、插入和删除操作的性能降低到线性复杂度，*O(n)*。'
- en: Taking these differences into consideration and the similarities with the `std::map`/`std::unordered_map`
    containers, we can identify the same use-case scenarios for `std::set` as we did
    for `std::map` and for `std::unordered_set` as we did for `std::unordered_map`.
    Also, for using `std::unordered_set`, a hashing function must be defined for the
    type of the stored objects.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些差异以及与`std::map`/`std::unordered_map`容器的相似性，我们可以为`std::set`识别出与`std::map`相同的使用场景，为`std::unordered_set`识别出与`std::unordered_map`相同的使用场景。此外，为了使用`std::unordered_set`，必须为存储对象的类型定义一个哈希函数。
- en: When you need to store more than one value associated with a key, you can use
    `std::multimap` and `std::unordered_multimap`. These two have the same considerations
    as `std::map` and `std::unordered_map`. We can say that `std::multimap` is to
    `std::map` what `std::unordered_multimap` is to `std::unordered_map`. Similarly,
    `std::multiset` and `std::unordered_multiset` can be used to store duplicates
    in a set.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要存储与一个键关联的多个值时，你可以使用`std::multimap`和`std::unordered_multimap`。这两个容器与`std::map`和`std::unordered_map`有相同的考虑因素。我们可以这样说，`std::multimap`对应于`std::map`，而`std::unordered_multimap`对应于`std::unordered_map`。同样，`std::multiset`和`std::unordered_multiset`可以用来在集合中存储重复项。
- en: 'Considering all the various standard container types and their typical use
    based on their characteristics, we can use the following diagram to select the
    most appropriate container. The following diagram was created by me, based on
    the one created by Mikael Persson and shared on StackOverflow: ([https://stackoverflow.com/a/22671607/648078](https://stackoverflow.com/a/22671607/648078)).'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑所有各种标准容器类型及其基于特性的典型用途，我们可以使用以下图表来选择最合适的容器。以下图表是我根据 Mikael Persson 创建的图表并分享在
    StackOverflow 上的版本制作的：([https://stackoverflow.com/a/22671607/648078](https://stackoverflow.com/a/22671607/648078))。
- en: '![](img/B21549_05_04.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_05_04.png)'
- en: 'Figure 5.4: Flowchart for selecting the right standard container'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：选择正确标准容器的流程图
- en: Although this recipe is intended as a guide for selecting the right standard
    container, it does not cover all containers and all possible considerations. When
    performance is key, the best choice may not be the typical one. In such a situation,
    you should try different implementations with different choices, benchmark them,
    and decide on a solution based on the results of your measurements.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个配方旨在作为选择合适标准容器的指南，但它并不涵盖所有容器和所有可能的考虑因素。当性能是关键时，最佳选择可能并非典型的选择。在这种情况下，你应该尝试使用不同的选择进行不同的实现，对它们进行基准测试，并根据你的测量结果决定解决方案。
- en: See also
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '*Using vector as a default container*, to learn how you can use the `std::vector`
    class'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*，了解如何使用`std::vector`类'
- en: '*Using vector<bool> for variable-size sequences of bits*, to understand how
    this `std::vector` specialization for bool can be used to manipulate sequence
    of bits'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`std::vector<bool>`处理可变长度的位序列*，了解如何使用这个针对布尔类型的`std::vector`特化来操作位序列'
- en: Learn more on Discord
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_05.xhtml)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_05.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
