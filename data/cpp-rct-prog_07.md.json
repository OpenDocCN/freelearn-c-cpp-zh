["```cpp\n////////// \n// First.cpp \n// g++ -I<PathToRxCpplibfoldersrc> First.cpp \n#include \"rxcpp/rx.hpp\" \n#include <ioStream> \nint main() { \n //------------- Create an Observable.. a Stream of numbers \n //------------- Range will produce a sequence from 1 to 12 \n auto observable = rxcpp::observable<>::range(1, 12);\n //------------ Subscribe (only OnNext and OnCompleted Lambda given \n observable.Subscribe(  \n    [](int v){printf(\"OnNext: %dn\", v);}, \n    [](){printf(\"OnCompleted\\n\");}); \n} \n```", "```cpp\n/////////////////////////////////////// \n// Second.cpp \n#include \"rxcpp/rx.hpp\" \n#include <ioStream> \nint main() { \n  auto values = rxcpp::observable<>::range(1, 12). \n      filter([](int v){ return v % 2 ==0 ;}). \n      map([](int x) {return x*x;});  \n  values.subscribe( \n           [](int v){printf(\"OnNext: %dn\", v);}, \n           [](){printf(\"OnCompleted\\n\");}); \n} \n```", "```cpp\n// STLContainerStream.cpp\n#include \"rxcpp/rx.hpp\"\n#include <ioStream>\n#include <array>\nint main() {\n    std::array< int, 3 > a={{1, 2, 3}};\n    auto values = rxcpp::observable<>::iterate(a);\n    values.subscribe([](int v){printf(\"OnNext: %dn\", v);},\n    [](){printf(\"OnCompleted\\n\");});\n}\n```", "```cpp\n// ObserverFromScratch.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \nint main() { \n      auto ints = rxcpp::observable<>::create<int>( \n                  [](rxcpp::subscriber<int> s){ \n                       s.on_next(1); \n                       s.on_next(4); \n                       s.on_next(9); \n                       s.on_completed(); \n                 }); \n    ints.subscribe( [](int v){printf(\"OnNext: %dn\", v);}, \n                             [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//------------- Concactatenate.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \nint main() { \n auto values = rxcpp::observable<>::range(1);  \n auto s1 = values.take(3).map([](int prime) { return 2*prime;);}); \n auto s2 = values.take(3).map([](int prime) { return prime*prime);}); \n s1.concat(s2).subscribe(rxcpp::util::apply_to( \n            []( int p) { printf(\" %dn\", p);})); \n} \n```", "```cpp\n//---------------- Unsubscribe.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <iostream> \nint main() { \n    auto subs = rxcpp::composite_subscription(); \n    auto values = rxcpp::observable<>::range(1, 10); \n    values.subscribe( \n        subs,[&subs](int v){ \n            printf(\"OnNext: %dn\", v); \n            if (v == 6) \n                subs.unsubscribe(); //-- Stop recieving events \n        }, \n        [](){printf(\"OnCompletedn\");}); \n}\n\n```", "```cpp\n//------------------ Map.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \n#include <array> \nint main() { \n    auto ints = rxcpp::observable<>::range(1,10). \n                 map( [] ( int n  ) {return n*n; }); \n    ints.subscribe( \n            [](int v){printf(\"OnNext: %dn\", v);}, \n            [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//----------- Average.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n    auto values = rxcpp::observable<>::range(1, 20).average(); \n    values.subscribe( \n            [](double v){printf(\"average: %lfn\", v);}, \n            [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//----------- Scan.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n    int count = 0; \n    auto values = rxcpp::observable<>::range(1, 20). \n        scan( 0,[&count](int seed, int v){ \n                count++; \n                return seed + v; \n            }); \n    values.subscribe( \n        [&](int v){printf(\"Average through Scan: %fn\", (double)v/count);}, \n        [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//------------------ Map_With_Pipe.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \nnamespace Rx { \nusing namespace rxcpp; \nusing namespace rxcpp::sources; \nusing namespace rxcpp::operators; \nusing namespace rxcpp::util; \n} \nusing namespace Rx; \n#include <ioStream> \nint main() { \n    //---------- chain map to the range using the pipe operator \n    //----------- avoids the use of . notation. \n    auto ints = rxcpp::observable<>::range(1,10) |  \n                 map( [] ( int n  ) {return n*n; }); \n    ints.subscribe( \n            [](int v){printf(\"OnNext: %dn\", v);}, \n            [](){printf(\"OnCompletedn\");}); \n}\n```", "```cpp\n//----------ObserveOn.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \n#include <thread> \nint main(){ \n //---------------- Generate a range of values \n //---------------- Apply Square function \n auto values = rxcpp::observable<>::range(1,4). \n               map([](int v){ return v*v;}); \n //------------- Emit the current thread details \n std::cout  << \"Main Thread id => \"  \n            << std::this_thread::get_id()  \n            << std::endl; \n //---------- observe_on another thread.... \n //---------- make it blocking to  \n //--------- Consult the Rxcpp documentation on observe_on and schedulers\n values.observe_on(rxcpp::synchronize_new_thread()).as_blocking(). \n subscribe( [](int v){  \n                   std::cout << \"Observable Thread id => \"  \n                             << std::this_thread::get_id()  \n                             << \"  \" << v << std::endl ;}, \n                  [](){ std::cout << \"OnCompleted\" << std::endl; }); \n //------------------ Print the main thread details \n std::cout << \"Main Thread id => \"  \n           << std::this_thread::get_id()  \n           << std::endl;   \n} \n```", "```cpp\nMain Thread id => 1 \nObservable Thread id => 2  1 \nObservable Thread id => 2  4 \nObservable Thread id => 2  9 \nObservable Thread id => 2  16 \nOnCompleted \nMain Thread id => 1 \n```", "```cpp\n//---------- SubscribeOn.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \n#include <thread> \n#include <mutex> \n//------ A global mutex for output synch. \nstd::mutex console_mutex; \n//------ Print the Current Thread details \nvoid CTDetails() { \n   console_mutex.lock(); \n   std::cout << \"Current Thread id => \"  \n           << std::this_thread::get_id()  << std::endl;  \n   console_mutex.unlock();  \n} \n//---------- a function to Yield control to other threads \nvoid Yield( bool y ) { \n   if (y) { std::this_thread::yield(); } \n\n} \nint main(){ \n    auto threads = rxcpp::observe_on_event_loop(); \n    auto values = rxcpp::observable<>::range(1); \n    //------------- Schedule it in another thread \n    auto s1 = values.subscribe_on(threads). \n        map([](int prime) {  \n             CTDetails(); Yield(true); return std::make_tuple(\"1:\", prime);}); \n    //-------- Schedule it in Yet another theread \n    auto s2 = values. subscribe_on(threads).  \n        map([](int prime) { \n           CTDetails(); Yield(true) ; return std::make_tuple(\"2:\", prime);}); \n\n    s1.merge(s2). take(6).as_blocking().subscribe(rxcpp::util::apply_to( \n            [](const char* s, int p) { \n                CTDetails(); \n                console_mutex.lock(); \n                printf(\"%s %dn\", s, p); \n                console_mutex.unlock(); \n            })); \n} \n```", "```cpp\n//----------- Flatmap.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nnamespace rxu=rxcpp::util; \n#include <array> \nint main() { \n     std::array< std::string,4 > a={{\"Praseed\", \"Peter\", \"Sanjay\",\"Raju\"}}; \n     //---------- Apply Flatmap on the array of names \n     //---------- Flatmap returns an Observable<T> ( map returns T ) \n     //---------- The First lamda creates a new Observable<T> \n     //---------- The Second Lambda manipulates primary Observable and  \n     //---------- Flatmapped Observable \n     auto values = rxcpp::observable<>::iterate(a).flat_map( \n              [] (std::string v ) { \n                   std::array<std::string,3> salutation= \n                       { { \"Mr.\" ,  \"Monsieur\" , \"Sri\" }}; \n                   return rxcpp::observable<>::iterate(salutation); \n              }, \n              [] ( std::string f , std::string s ) {return s + \" \" +f;}); \n     //-------- As usual subscribe  \n     //-------- Here the value will be interleaved as flat_map merges the  \n     //-------- Two Streams \n     values.subscribe(  \n              [] (std::string f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n      } \n```", "```cpp\nMr. Praseed \nMonsieur Praseed \nMr. Peter \nSri Praseed \nMonsieur Peter \nMr. Sanjay \nSri Peter \nMonsieur Sanjay \nMr. Raju \nSri Sanjay \nMonsieur Raju \nSri Raju \nHello World.. \n```", "```cpp\n//----------- ConcatMap.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nnamespace rxu=rxcpp::util; \n\n#include <array> \nint main() { \n\n     std::array< std::string,4 > a={{\"Praseed\", \"Peter\", \"Sanjay\",\"Raju\"}}; \n     //---------- Apply Concat map on the array of names \n     //---------- Concat Map returns an Observable<T> ( oncat returns T ) \n     //---------- The First lamda creates a new Observable<T> \n     //---------- The Second Lambda manipulates primary Observable and  \n     //---------- Concatenated Observable \n     auto values = rxcpp::observable<>::iterate(a).flat_map( \n              [] (std::string v ) { \n                   std::array<std::string,3> salutation= \n                       { { \"Mr.\" ,  \"Monsieur\" , \"Sri\" }}; \n                   return rxcpp::observable<>::iterate(salutation); \n              }, \n              [] ( std::string f , std::string s ) {return s + \" \" +f;}); \n\n     //-------- As usual subscribe  \n     //-------- Here the value will be interleaved as concat_map concats the  \n     //-------- Two Streams \n     values.subscribe(  \n              [] (std::string f) { std::cout << f <<  std::endl; } ,  \n              [] () {std::cout << \"Hello World..\" << std::endl;} ); \n } \n```", "```cpp\nMr. Praseed \nMonsieur Praseed \nSri Praseed \nMr. Peter \nMonsieur Peter \nSri Peter \nMr. Sanjay \nMonsieur Sanjay \nSri Sanjay \nMr. Raju \nMonsieur Raju \nSri Raju \nHello World.. \n```", "```cpp\n//---------------- Concat.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \n#include <array> \nint main() { \n    auto o1 = rxcpp::observable<>::range(1, 3); \n    auto o3 = rxcpp::observable<>::from(4, 6); \n    auto values = o1.concat(o2); \n    values.subscribe( \n            [](int v){printf(\"OnNext: %dn\", v);},[](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//------------ Merge.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \n#include <array> \nint main() { \n    auto o1 = rxcpp::observable<>::range(1, 3); \n    auto o2 = rxcpp::observable<>::range(4, 6); \n    auto values = o1.merge(o2); \n    values.subscribe( \n            [](int v){printf(\"OnNext: %dn\", v);}, \n             [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//----------- TapExample.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n    //---- Create a mapped Observable \n     auto ints = rxcpp::observable<>::range(1,3). \n                 map( [] ( int n  ) {return n*n; }); \n     //---- Apply the tap operator...The Operator  \n     //---- will act as a filter/debug operator \n     auto values = ints.tap( \n          [](int v)  {printf(\"Tap -       OnNext: %dn\", v);}, \n          [](){printf(\"Tap -       OnCompletedn\"); \n     }); \n     //------- Do some action \n     values.subscribe( \n          [](int v){printf(\"Subscribe - OnNext: %dn\", v);}, \n          [](){printf(\"Subscribe - OnCompletedn\");}); \n } \n```", "```cpp\n//----------- DeferExample.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n    auto observable_factory = [](){ \n         return rxcpp::observable<>::range(1,3). \n                 map( [] ( int n  ) {return n*n; }); \n    }; \n    auto ints = rxcpp::observable<>::defer(observable_factory); \n    ints.subscribe([](int v){printf(\"OnNext: %dn\", v);}, \n            [](){printf(\"OnCompletedn\");}); \n    ints.subscribe( \n            [](int v){printf(\"2nd OnNext: %dn\", v);}, \n            [](){printf(\"2nd OnCompletedn\");}); \n} \n```", "```cpp\n//----------- BufferExample.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n   auto values = rxcpp::observable<>::range(1, 10).buffer(2); \n   values.subscribe( [](std::vector<int> v){ \n                printf(\"OnNext:{\"); \n                std::for_each(v.begin(), v.end(), [](int a){ \n                    printf(\" %d\", a); \n                }); \n                printf(\"}n\"); \n            }, \n            [](){printf(\"OnCompletedn\");}); \n} \n```", "```cpp\n//----------- TimerExample.cpp \n#include \"rxcpp/rx.hpp\" \n#include \"rxcpp/rx-test.hpp\" \n#include <ioStream> \nint main() { \n     auto Scheduler = rxcpp::observe_on_new_thread(); \n     auto period = std::chrono::milliseconds(1); \n     auto values = rxcpp::observable<>::timer(period, Scheduler). \n            finally([](){ \n            printf(\"The final actionn\"); \n        });     \n      values.as_blocking().subscribe( \n         [](int v){printf(\"OnNext: %dn\", v);}, \n         [](){printf(\"OnCompletedn\");}); \n} \n```"]