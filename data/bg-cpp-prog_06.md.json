["```cpp\n    class cartesian_vector \n    { \n    public: \n        double x; \n        double y; \n        // other methods \n        double get_magnitude() { return std::sqrt((x * x) + (y * y)); } \n    };\n```", "```cpp\n    cartesian_vector vec { 3.0, 4.0 }; \n    double len = vec.get_magnitude(); // returns 5.0\n```", "```cpp\n    class cartesian_vector \n    { \n    public: \n        double x; \n        double y; \n        // other methods \n        double get_magnitude() \n        { \n             return std::sqrt((this->x * this->x) + (this->y * this->y)); \n        } \n    };\n```", "```cpp\n    class cartesian_vector \n    { \n    public: \n        double x; \n        double y; \n        reset(double x, double y) { this->x = x; this->y = y; } \n        // other methods \n    };\n```", "```cpp\n    class cartesian_vector \n    { \n    public: \n        double x; \n        double y; \n        // other methods \n        double magnitude(); \n    }; \n\n    double cartesian_vector::magnitude() \n    { \n        return sqrt((this->x * this->x) + (this->y * this->y)); \n    }\n```", "```cpp\n    class cartesian_vector \n    { \n        double x; \n        double y; \n    public: \n        double get_x() { return this->x; } \n        double get_y() { return this->y; } \n        // other methods \n    };\n```", "```cpp\n    void cartesian_vector::set_x(double d) \n    { \n        if (d > -100 && d < 100) this->x = d; \n    }\n```", "```cpp\n    cartesian_vector vec { 10, 10 }; \n    cartesian_vector *pvec = new cartesian_vector { 5, 5 }; \n    // use pvec \n    delete pvec\n```", "```cpp\n    class point \n    { \n    public: \n        int x = 0; \n        int y = 0; \n    };\n```", "```cpp\n    class car \n    { \n    public: \n        double tire_pressures[4] { 25.0, 25.0, 25.0, 25.0 }; \n    };\n```", "```cpp\n    class point \n    { \n        double x; double y; \n    public: \n        point() { x = 0; y = 0; } \n    };\n```", "```cpp\n    point p;   // default constructor called\n```", "```cpp\n    point p();  // compiles, but is a function prototype!\n```", "```cpp\n    point p {};  // calls default constructor\n```", "```cpp\n    point(double x, double y) : x(x), y(y) {}\n```", "```cpp\n    point(double x, double y) : x{x}, y{y} {}\n```", "```cpp\n    point p(10.0, 10.0);\n```", "```cpp\n    point arr[4];\n```", "```cpp\n    class car \n    { \n        array<double, 4> tire_pressures;; \n        double spare; \n    public: \n        car(double front, double back, double s = 25.0)  \n          : tire_pressures{front, front, back, back}, spare{s} {} \n    };\n```", "```cpp\n    car commuter_car(25, 27); \n    car sports_car(26, 28, 28);\n```", "```cpp\n    class car \n    { \n        // data members \n    public: \n        car(double front, double back, double s = 25.0)  \n           : tire_pressures{front, front, back, back}, spare{s} {} \n        car(double all) : car(all, all) {} \n    };\n```", "```cpp\n    point p1(10, 10); \n    point p2(p1); \n    point p3 = p1;\n```", "```cpp\n    class point \n    { \n        int x = 0;int y = 0; \n    public: \n        point(const point& rhs) : x(rhs.x), y(rhs.y) {} \n    };\n```", "```cpp\n    class cartesian_vector \n    { \n        double x; double y;  \n    public: \n        cartesian_vector(const point& p) : x(p.x), y(p.y) {} \n    };\n```", "```cpp\n    point p(10, 10); \n    cartesian_vector v1(p); \n    cartesian_vector v2 { p }; \n    cartesian_vector v3 = p;\n```", "```cpp\n    class cartesian_vector; // forward decalartion \n\n    class point \n    { \n        double x; double y; \n    public: \n        point(double x, double y) : x(x), y(y){} \n        friend class cartesian_point; \n    };\n```", "```cpp\n    ostream& operator<<(ostream& stm, const point& pt) \n    { \n        stm << \"(\" << pt.x << \",\" << pt.y << \")\"; \n        return stm; \n    }\n```", "```cpp\n    friend ostream& operator<<(ostream&, const point&);\n```", "```cpp\n    class mytype  \n    { \n    public: \n        explicit mytype(double x); \n    };\n```", "```cpp\n    mytype t1 = 10.0; // will not compile, cannot convert \n    mytype t2(10.0);  // OK\n```", "```cpp\n    void f(mytype t) // copy created \n    { \n        // use t \n    }   // t destroyed \n\n    void g() \n    { \n        mytype t1; \n        f(t1); \n        if (true) \n        { \n            mytype t2; \n        }   // t2 destroyed \n\n        mytype arr[4]; \n    }  // 4 objects in arr destroyed in reverse order to creation \n       // t1 destroyed\n```", "```cpp\n    mytype get_object() \n    { \n        mytype t;               // default constructor creates t \n        return t;               // copy constructor creates a temporary \n    }                           // t destroyed \n\n    void h() \n    { \n        test tt = get_object(); // copy constructor creates tt \n    }                           // temporary destroyed, tt destroyed\n```", "```cpp\n    void h() \n    { \n        mytype tt = get_object();  \n    }   // tt destroyed\n```", "```cpp\n    mytype *get_object() \n    { \n        return new mytype; // default constructor called \n    } \n\n    void f() \n    { \n        mytype *p = get_object(); \n        // use p \n        delete p;        // object destroyed \n    }\n```", "```cpp\n    buffer a, b, c;              // default constructors called \n    // do something with them \n    a = b = c;                   // make them all the same value \n    a.operator=(b.operator=(c)); // make them all the same value\n```", "```cpp\n    class buffer \n    { \n        // data members \n    public: \n        buffer(const buffer&);            // copy constructor \n        buffer& operator=(const buffer&); // copy assignment \n    };\n```", "```cpp\n    class mytype \n    { \n        int *p; \n    public: \n        mytype(const mytype&) = delete;             // copy constructor \n        mytype& operator= (const mytype&) = delete; // copy assignment \n        mytype&(mytype&&);                          // move constructor \n        mytype& operator=(mytype&&);                // move assignment \n    };\n```", "```cpp\n    mytype::mytype(mytype&& tmp) \n    { \n        this->p = tmp.p; \n        tmp.p = nullptr; \n    }\n```", "```cpp\n    class mytype \n    { \n    public: \n        static void f(){} \n        void g(){ f(); } \n    };\n```", "```cpp\n    mytype c; \n    c.g();       // call the nonstatic method \n    c.f();       // can also call the static method thru an object \n    mytype::f(); // call static method without an object\n```", "```cpp\n    class mytype \n    { \n    public: \n        static int i; \n        static void incr() { i++; } \n    }; \n\n    // in a source file \n    int mytype::i = 42;\n```", "```cpp\n    x = r * cos(theta) \n    y = r * sin(theta)\n```", "```cpp\n    class point \n    { \n        double x; double y; \n    public: \n        point(double x, double y) : x(x), y(y){} \n        static point polar(double r, double th) \n        { \n            return point(r * cos(th), r * sin(th)); \n        } \n    };\n```", "```cpp\n    const double pi = 3.141529; \n    const double root2 = sqrt(2); \n    point p11 = point::polar(root2, pi/4);\n```", "```cpp\n    point point::polar(double r, double th) \n    { \n        point pt; \n        pt.x = r * cos(th); \n        pt.y = r * sin(th); \n        return pt; \n    }\n```", "```cpp\n    class outer \n    { \n    public: \n        class inner  \n        { \n        public: \n            void f(); \n        }; \n\n        inner g() { return inner(); } \n    }; \n\n    void outer::inner::f() \n    { \n         // do something \n    }\n```", "```cpp\n    class point \n    { \n        double x; double y; \n    public: \n        double get_x() { return x; } \n        double get_y() { return y: } \n    };\n```", "```cpp\n    void print_point(const point& p) \n    { \n        cout << \"(\" << p.get_x() << \",\" << p.get_y() << \")\" << endl; \n    }\n```", "```cpp\ncannot convert 'this' pointer from 'const point' to 'point &'\n```", "```cpp\n    double get_x() const { return x; } \n    double get_y() const { return y: }\n```", "```cpp\n    struct point { double x; double y; }; \n    point p { 10.0, 10.0 }; \n    int *pp = &p.x;\n```", "```cpp\n    class cartesian_vector \n    { \n    public: \n        // other items \n        double get_magnitude() const \n        { \n            return std::sqrt((this->x * this->x) + (this->y * this->y)); \n        }  \n    };\n```", "```cpp\n    double (cartesian_vector::*fn)() const = nullptr; \n    fn = &cartesian_vector::get_magnitude;\n```", "```cpp\n    cartesian_vector vec(1.0, 1.0); \n    double mag = (vec.*fn)();\n```", "```cpp\n    cartesian_vector *pvec = new cartesian_vector(1.0, 1.0); \n    double mag = (pvec->*fn)(); \n    delete pvec;\n```", "```cpp\n    // inline in point \n    point operator-() const \n    { \n        return point(-this->x, -this->y); \n    }\n```", "```cpp\n    point p1(-1,1); \n    point p2 = -p1; // p2 is (1,-1)\n```", "```cpp\n    cartesian_vector point::operator-(point& rhs) const \n    { \n        return cartesian_vector(this->x - rhs.x, this->y - rhs.y); \n    }\n```", "```cpp\n    class mytype  \n    { \n    public: \n        mytype& operator++() \n        {  \n            // do actual increment \n            return *this; \n        } \n        mytype operator++(int) \n        { \n            mytype tmp(*this); \n            operator++(); // call the prefix code \n            return tmp; \n        } \n    };\n```", "```cpp\n    class factor \n    { \n        double f = 1.0; \n    public: \n        factor(double d) : f(d) {} \n        double operator()(double x) const { return f * x; }  \n    };\n```", "```cpp\n    factor threeTimes(3);        // create the functor object \n    double ten = 10.0; \n    double d1 = threeTimes(ten); // calls operator(double) \n    double d2 = threeTimes(d1);  // calls operator(double)\n```", "```cpp\n    double d2 = threeTimes.operator()(d1);\n```", "```cpp\n    double multiply_by_3(double d) \n    { \n        return 3 * d;  \n    }\n```", "```cpp\n    void print_value(double d, factor& fn); \n    void print_value(double d, double(*fn)(double));\n```", "```cpp\n    template<typename Fn> \n    void print_value(double d, Fn& fn) \n    { \n        double ret = fn(d); \n        cout << ret << endl; \n    }\n```", "```cpp\n    template<typename Fn>  \n    int compare_vals(vector<double> d1, vector<double> d2, Fn compare) \n    { \n        if (d1.size() > d2.size()) return -1; // error \n        int c = 0; \n        for (size_t i = 0; i < d1.size(); ++i) \n        { \n            if (compare(d1[i], d2[i])) c++; \n        } \n        return c; \n    }\n```", "```cpp\n    vector<double> d1{ 1.0, 2.0, 3.0, 4.0 }; \n    vector<double> d2{ 1.0, 1.0, 2.0, 5.0 }; \n    int c = compare_vals(d1, d2, greater<double>());\n```", "```cpp\n    template<typename Fn>  \n    int compare_vals(vector<double> d, Fn compare) \n    { \n        int c = 0; \n        for (size_t i = 0; i < d.size(); ++i) \n        { \n            if (compare(d[i]) c++; \n        } \n        return c; \n    }\n```", "```cpp\n    using namespace::std::placeholders; \n    int c = compare_vals(d1, bind(greater<double>(), _1, 2.0));\n```", "```cpp\n    int c = compare(d1, bind(greater<double>(), 2.0, _1));\n```", "```cpp\n    class mytype \n    { \n        int i; \n    public: \n        mytype(int i) : i(i) {} \n        explicit mytype(string s) : i(s.size()) {} \n        operator int () const { return i; } \n    };\n```", "```cpp\n    string s = \"hello\"; \n    mytype t = mytype(s); // explicit conversion \n    int i = t;            // implicit conversion\n```", "```cpp\n    class averager \n    { \n        double total; \n        int count; \n    public: \n        averager() : total(0), count(0) {} \n        void operator()(double d) { total += d; count += 1; } \n        operator double() const \n        {        \n            return (count != 0) ? (total / count) : \n                numeric_limits<double>::signaling_NaN(); \n        } \n    };\n```", "```cpp\n    vector<double> vals { 100.0, 20.0, 30.0 }; \n    double avg = for_each(vals.begin(), vals.end(), averager());\n```", "```cpp\n    void f1() \n    { \n       int* p = new int; \n       *p = 42; \n       cout << *p << endl; \n       delete p; \n    }\n```", "```cpp\n    void f2() \n    { \n       unique_ptr<int> p(new int); \n       *p = 42; \n       cout << *p << endl; \n       delete p.release(); \n    }\n```", "```cpp\n    void f3() \n    { \n       unique_ptr<int> p(new int); \n       *p = 42; \n       cout << *p << endl; \n       p.reset(); \n    }\n```", "```cpp\n    template<typename T> struct my_deleter \n    { \n        void operator()(T* ptr)  \n        { \n            cout << \"deleted the object!\" << endl; \n            delete ptr; \n        } \n    };\n```", "```cpp\n    unique_ptr<int, my_deleter<int> > p(new int);\n```", "```cpp\n    void f4() \n    { \n       unique_ptr<int> p(new int); \n       *p = 42; \n       cout << *p << endl; \n    } // memory is deleted\n```", "```cpp\n    void f5() \n    { \n       unique_ptr<int> p = make_unique<int>(); \n       *p = 42; \n       cout << *p << endl; \n    } // memory is deleted\n```", "```cpp\n    void f6() \n    { \n       unique_ptr<point> p = make_unique<point>(1.0, 1.0); \n       p->x = 42; \n       cout << p->x << \",\" << p->y << endl; \n    } // memory is deleted\n```", "```cpp\n    unique_ptr<point[]> points = make_unique<point[]>(4);     \n    points[1].x = 10.0; \n    points[1].y = -10.0;\n```", "```cpp\n    point* p = new point(1.0, 1.0); \n    shared_ptr<point> sp1(p); // Important, do not use p after this! \n    shared_ptr<point> sp2(sp1); \n    p = nullptr; \n    sp2->x = 2.0; \n    sp1->y = 2.0; \n    sp1.reset(); // get rid of one shared pointer\n```", "```cpp\n    shared_ptr<point> sp1 = make_shared<point>(1.0,1.0);\n```", "```cpp\n    shared_ptr<point> sp1 = make_shared<point>(1.0,1.0); \n    weak_ptr<point> wp(sp1); \n\n    // code that may call sp1.reset() or may not \n\n    if (!wp.expired())  { /* can use the resource */} \n\n    shared_ptr<point> sp2 = wp.lock(); \n    if (sp2 != nullptr) { /* can use the resource */} \n\n    try \n    { \n        shared_ptr<point> sp3(wp); \n        // use the pointer \n    } \n    catch(bad_weak_ptr& e) \n    { \n        // dangling weak pointer \n    }\n```", "```cpp\n    template <int N, typename T> class simple_array \n    { \n        T data[N]; \n    public: \n        const T* begin() const { return data; } \n        const T* end() const { return data + N; } \n        int size() const { return N; } \n\n        T& operator[](int idx)  \n        { \n            if (idx < 0 || idx >= N) \n                throw range_error(\"Range 0 to \" + to_string(N)); \n            return data[idx]; \n        }  \n    };\n```", "```cpp\n    simple_array<4, int> four; \n    four[0] = 10; four[1] = 20; four[2] = 30; four[3] = 40; \n    for(int i : four) cout << i << \" \"; // 10 20 30 40 \n    cout << endl; \n    four[4] = -99;            // throws a range_error exception\n```", "```cpp\n    template<int N, typename T> \n    T& simple_array<N,T>::operator[](int idx) \n    { \n        if (idx < 0 || idx >= N) \n            throw range_error(\"Range 0 to \" + to_string(N)); \n        return data[idx]; \n    }\n```", "```cpp\n    template<int N, typename T=int> class simple_array \n    { \n        // same as before \n    };\n```", "```cpp\n    template<int N> class simple_array<N, char> \n    { \n        char data[N]; \n    public: \n        simple_array<N, char>(const char* str)  \n        {  \n            strncpy(data, str, N);  \n        } \n        int size() const { return N; } \n        char& operator[](int idx) \n        { \n            if (idx < 0 || idx >= N) \n                throw range_error(\"Range 0 to \" + to_string(N)); \n            return data[idx]; \n        } \n        operator const char*() const { return data; } \n    };\n```", "```cpp\n    template<> class simple_array<256, char> \n    { \n        char data[256]; \n    public: \n        // etc \n    };\n```", "```cpp\n    #include <iostream> \n    #include <string> \n    #include <io.h> \n    using namespace std;\n```", "```cpp\n    void usage() \n    { \n        cout << \"usage: search pattern\" << endl; \n        cout << \"pattern is the file or folder to search for \" \n             << \"with or without wildcards * and ?\" << endl; \n    } \n\n    int main(int argc, char* argv[]) \n    { \n        if (argc < 2) \n        { \n            usage(); \n            return 1; \n        } \n    }\n```", "```cpp\n    class search_handle \n    { \n        intptr_t handle; \n    public: \n        search_handle() : handle(-1) {} \n        search_handle(intptr_t p) : handle(p) {} \n        void operator=(intptr_t p) { handle = p; } \n        void close()  \n        { if (handle != -1) _findclose(handle); handle = 0; } \n        ~search_handle() { close(); } \n    };\n```", "```cpp\n    void operator=(intptr_t p) { handle = p; } \n search_handle(search_handle& h) = delete; void operator=(search_handle& h) = delete;\n```", "```cpp\n    search_handle(search_handle&& h)  { close(); handle = h.handle; } \n    void operator=(search_handle&& h) { close(); handle = h.handle; }\n```", "```cpp\n    operator bool() const { return (handle != -1); } \n    operator intptr_t() const { return handle; }\n```", "```cpp\n    search_handle handle = /* initialize it */; \n    if (!handle) { /* handle is invalid */ }\n```", "```cpp\n    class file_search \n    { \n        search_handle handle; \n        string search; \n    public: \n        file_search(const char* str) : search(str) {} \n        file_search(const string& str) : search(str) {} \n    };\n```", "```cpp\n    const char* path() const { return search.c_str(); } \n    void close() { handle.close(); }\n```", "```cpp\n    file_search f1(\"\"); \n    file_search f2 = f1;\n```", "```cpp\n error C2280: 'file_search::file_search(file_search &)': attempting to reference a deleted function\n note: compiler has generated 'file_search::file_search' here\n```", "```cpp\n    file_search files(argv[1]); \n    cout << \"searching for \" << files.path() << endl;\n```", "```cpp\n    bool next(string& ret) \n    { \n        _finddata_t find{}; \n        if (!handle) \n        { \n            handle = _findfirst(search.c_str(), &find); \n            if (!handle) return false; \n        } \n        else \n        { \n            if (-1 == _findnext(handle, &find)) return false; \n        } \n\n        ret = find.name; \n        return true; \n    }\n```", "```cpp\n    string file; \n    while (files.next(file)) \n    { \n        cout << file << endl; \n    }\n```", "```cpp\n search Beginning_C++Ch*\n```"]