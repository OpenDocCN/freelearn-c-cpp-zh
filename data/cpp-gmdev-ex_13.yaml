- en: Getting Started with Vulkan
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan入门
- en: In the previous three chapters, we did our rendering using OpenGL. Although
    OpenGL is good for developing prototypes and getting your rendering going faster,
    it does have its weaknesses. For one, OpenGL is very driver-dependent, which makes
    it slower and less predictable when it comes to performance, which is why we prefer
    Vulkan for rendering.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个章节中，我们使用OpenGL进行渲染。虽然OpenGL适合开发原型并快速开始渲染，但它确实有其弱点。首先，OpenGL非常依赖驱动程序，这使得它在性能方面较慢且不可预测，这也是为什么我们更喜欢使用Vulkan进行渲染的原因。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: About Vulkan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Vulkan
- en: Configuring Visual Studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Visual Studio
- en: Vulkan validation layers and extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan验证层和扩展
- en: Vulkan instances
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan实例
- en: The Vulkan Context class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan上下文类
- en: Creating the window surface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建窗口表面
- en: Picking a physical device and creating a logical device
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择物理设备并创建逻辑设备
- en: About Vulkan
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Vulkan
- en: With OpenGL, developers have to depend on vendors such as NVIDIA, AMD, and Intel
    to release appropriate drivers so that they can increase the performance of their
    games before they are released. This is only possible if the developer is working
    closely with the vendor. If not, the vendor will only be able to release optimized
    drivers after the release of the game, and it could take a couple of days to release
    the new drivers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL时，开发者必须依赖NVIDIA、AMD和Intel等厂商发布适当的驱动程序，以便在游戏发布前提高游戏性能。只有当开发者与厂商紧密合作时，这才能实现。如果不是这样，厂商只能在游戏发布后才能发布优化驱动程序，并且发布新驱动程序可能需要几天时间。
- en: Furthermore, if you want to port your PC game to a mobile platform and you are
    using OpenGL as your renderer, you will need to port the renderer to OpenGLES,
    which is a subset of OpenGL, where the ES stands for Embedded Systems. Although
    there are a lot of similarities between OpenGL and OpenGLES, there is still additional
    work to be done to get it to work on other platforms. To alleviate these issues,
    Vulkan was introduced. Vulkan gives the developer more control by reducing driver
    impact and providing explicit developer control to make the game perform better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想要将你的PC游戏移植到移动平台，并且你使用OpenGL作为渲染器，你将需要将渲染器移植到OpenGLES，它是OpenGL的一个子集，其中ES代表嵌入式系统。尽管OpenGL和OpenGLES之间有很多相似之处，但要使其在其他平台上工作，仍然需要做额外的工作。为了减轻这些问题，引入了Vulkan。Vulkan通过减少驱动程序的影响并提供明确的开发者控制来提高游戏性能，从而赋予开发者更多的控制权。
- en: Vulkan has been developed from the ground up and therefore is not backward compatible
    with OpenGL. When using Vulkan, you have complete access to the GPU.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan是从底层开发的，因此与OpenGL不向后兼容。当使用Vulkan时，你可以完全访问GPU。
- en: With complete GPU access, you also have complete responsibility for implementing
    the rendering API. Consequently, the downside of using Vulkan is that you have
    to specify everything when you're developing with it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的GPU访问，你也有完全的责任来实现渲染API。因此，使用Vulkan的缺点在于，当你用它进行开发时，你必须指定一切。
- en: All in all, this makes Vulkan a very verbose API where you have to specify everything.
    However, this also makes it easy to create extensions of the API specifications
    for Vulkan when GPUs add newer features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这使得Vulkan成为一个非常冗长的API，你必须指定一切。然而，这也使得当GPU添加新功能时，很容易为Vulkan的API规范创建扩展。
- en: Configuring Visual Studio
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Visual Studio
- en: 'Vulkan is just a rendering API, so we need to create a window and do math.
    For both, we will use GLFW and GLM, like we did when we created an OpenGL project.
    To do this, follow these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan只是一个渲染API，因此我们需要创建一个窗口并进行数学运算。对于这两者，我们将使用GLFW和GLM，就像我们创建OpenGL项目时一样。为此，请按照以下步骤操作：
- en: Create a new Visual Studio C++ project and call it `VulkanProject`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Visual Studio C++项目，并将其命名为`VulkanProject`。
- en: Copy the `GLFW` and `GLM` folders from the OpenGL project and place them inside
    the `VulkanProject` folder, under a folder named `Dependencies`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将OpenGL项目中的`GLFW`和`GLM`文件夹复制到`VulkanProject`文件夹中，放在名为`Dependencies`的文件夹内。
- en: 'Download the Vulkan SDK. Go to [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home)
    and download the Windows version of the SDK, as shown in the following screenshot:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Vulkan SDK。访问 [https://vulkan.lunarg.com/sdk/home](https://vulkan.lunarg.com/sdk/home)
    并下载SDK的Windows版本，如以下截图所示：
- en: '![](img/b4e84ef1-92b7-4289-99da-003f9c0499aa.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4e84ef1-92b7-4289-99da-003f9c0499aa.png)'
- en: 'Install the SDK, as shown in the following screenshot:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示安装SDK：
- en: '![](img/e0b1f20e-59ef-462b-9a8f-c16a4e217576.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0b1f20e-59ef-462b-9a8f-c16a4e217576.png)'
- en: 'In the `Dependencies` directory, create a new folder called `Vulkan`. Copy
    and paste the `Lib` and include the folder from the Vulkan SDK folder in `C:\
    drive`, as shown in the following screenshot:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Dependencies` 目录中创建一个名为 `Vulkan` 的新文件夹。从 Vulkan SDK 文件夹中复制并粘贴 `Lib` 和包含文件夹到
    `C:\` 驱动器，如图所示：
- en: '![](img/734566c4-d064-467a-abfd-0afc5c4c1435.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/734566c4-d064-467a-abfd-0afc5c4c1435.png)'
- en: In the Visual Studio project, create a new blank `source.cpp` file. Open up
    the Vulkan Project properties and add the `include` directory to C/C+ | General
    | Additional Include Directory.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 项目中，创建一个新的空白 `source.cpp` 文件。打开 Vulkan 项目属性，并将 `include` 目录添加到
    C/C+ | 通用 | 额外包含目录。
- en: 'Make sure that All Configurations and All Platforms are selected in the Configuration
    and Platform drop-down lists, as shown in the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在配置和平台下拉列表中选择了所有配置和所有平台，如图所示：
- en: '![](img/405981b3-65ce-41a2-9cf2-d8a11977c6f4.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/405981b3-65ce-41a2-9cf2-d8a11977c6f4.png)'
- en: 'Add the Library Directories under the Linker | General section, as shown in
    the following screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链接器 | 通用部分下添加库目录，如图所示：
- en: '![](img/4a23c330-5cbd-4ec9-bb32-379484c85e9b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a23c330-5cbd-4ec9-bb32-379484c85e9b.png)'
- en: 'In Linker | Input, set the libraries that you want to use, as shown in the
    following screenshot:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链接器 | 输入中设置您想要使用的库，如图所示：
- en: '![](img/3de238cf-8de9-4f3b-a2d6-b4b1d761aff5.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3de238cf-8de9-4f3b-a2d6-b4b1d761aff5.png)'
- en: 'With this prep work out of the way, let''s check whether our window creation
    works properly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成准备工作后，让我们检查我们的窗口创建是否正常工作：
- en: 'In `source.cpp`, add the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `source.cpp` 中添加以下代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we include `glfw3.h` and ask `GLFW` to include some Vulkan-related headers.
    Then, in the main function, we initialize `GLFW` by calling `glfwInit()`. Then,
    we call the `glfwWindowHint` functions. The first `glfwWindowHint` function doesn't
    create the OpenGL context since it is created by `Glfw` by default. In the next
    function, we disable resizing for the window we are about to create.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含 `glfw3.h` 并让 `GLFW` 包含一些与 Vulkan 相关的头文件。然后，在主函数中，我们通过调用 `glfwInit()`
    初始化 `GLFW`。然后，我们调用 `glfwWindowHint` 函数。第一个 `glfwWindowHint` 函数不会创建 OpenGL 上下文，因为它默认由
    `Glfw` 创建。在下一个函数中，我们禁用了即将创建的窗口的调整大小功能。
- en: Then, we create the 1,280 x 720 window in a similar way to when we created the
    window in the OpenGL project. We create a `while` loop that checks whether the
    window should be closed. If the window doesn't need to be closed, we will poll
    the system events. Once this is done, we will destroy the window, terminate `glfw`,
    and return `0`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以创建 OpenGL 项目中创建窗口的类似方式创建一个 1,280 x 720 的窗口。我们创建一个 `while` 循环来检查窗口是否应该关闭。如果窗口不需要关闭，我们将轮询系统事件。一旦完成，我们将销毁窗口，终止
    `glfw`，并返回 `0`。
- en: 'This should give us a window to work with. Run the application in debug mode
    as an x64 executable to see the window being displayed and saying HELLO VULKAN,
    as shown in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会给我们一个可以工作的窗口。以调试模式作为 x64 可执行文件运行应用程序，以查看显示的窗口和显示的 HELLO VULKAN，如图所示：
- en: '![](img/f8b4a3d5-0065-4d80-91a3-990828b2e507.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f8b4a3d5-0065-4d80-91a3-990828b2e507.png)'
- en: Vulkan validation layers and extensions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan 验证层和扩展
- en: 'Before we jump into creating the Vulkan application, we have to check for application
    validation layers and extensions. Let''s go over these in more detail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建 Vulkan 应用程序之前，我们必须检查应用程序验证层和扩展。让我们更详细地了解一下：
- en: '**Validation layers**: Since so much control is given to developers, it is
    also possible for the developers to implement the Vulkan applications in an incorrect
    manner. The Vulkan validation layers check for such errors and tell the developer
    that they are doing something wrong and need to fix it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证层**：由于给予开发者的控制权很大，开发者也有可能以错误的方式实现 Vulkan 应用程序。Vulkan 验证层会检查这些错误，并告知开发者他们正在做错事，需要修复。'
- en: '**Extensions**: Over the course of the development of the Vulkan API, new features
    may be introduced to newer GPUs. To keep Vulkan up to date, we need to extend
    its functionality by adding extensions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：在 Vulkan API 的开发过程中，可能会为新的 GPU 引入新功能。为了保持 Vulkan 的更新，我们需要通过添加扩展来扩展其功能。'
- en: One example of this is the introduction of Ray Tracing in the RTX series of
    GPUs. In Vulkan, a new extension was created to support this change in the hardware
    by NVIDIA, that is, `Vk_NV_ray_tracing`. If our game uses this extension, we can
    check whether the hardware supports it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这类的一个例子是在RTX系列GPU中引入光线追踪。在Vulkan中，创建了一个新的扩展来支持NVIDIA在硬件上的这一变化，即`Vk_NV_ray_tracing`。如果我们的游戏使用这个扩展，我们可以检查硬件是否支持它。
- en: Similar extensions can be added and checked at the application level as well.
    One such extension is the Debug report extension, which we can generate if something
    goes wrong when we're implementing Vulkan. Our first class will add this functionality
    to the application to check for application validation layers and extensions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的扩展也可以在应用程序级别添加和检查。其中一个这样的扩展是调试报告扩展，当我们在实现Vulkan时出现问题时，我们可以生成这个扩展。我们的第一个类将向应用程序添加此功能，以检查应用程序验证层和扩展。
- en: 'Let''s start creating our first class. Create a new class called `AppValidationLayersAndExtensions`.
    In `AppValidationLayersAndExtensions.h`, add the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的第一个类。创建一个名为`AppValidationLayersAndExtensions`的新类。在`AppValidationLayersAndExtensions.h`中，添加以下代码：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We include `vulkan.h`, `iostream`, `vector`, and `glfw`. Then, we create a
    vector called `requiredValidationLayers`; this is where we pass `VK_LAYER_LUNARG
    _standard_validation`. For our application, we will need the standard validation
    layer, which has all the validation layers in it. If we only need specific validation
    layers, then we can specify them individually as well. Next, we create two functions:
    one for checking the support for validation layers and one for getting the required
    extensions.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`vulkan.h`、`iostream`、`vector`和`glfw`。然后，我们创建一个名为`requiredValidationLayers`的向量；这是我们将`VK_LAYER_LUNARG_standard_validation`传递的地方。对于我们的应用程序，我们需要标准验证层，其中包含所有验证层。如果我们只需要特定的验证层，我们也可以单独指定它们。接下来，我们创建两个函数：一个用于检查验证层的支持，另一个用于获取所需的扩展。
- en: 'To generate a report in case an error occurs, we need a debug callback. We
    will add two functions to it: one to set up the debug callback and one to destroy
    it. These functions will call the `debug`, `create`, and `destroy` functions;
    they will call `vkGetInstanceProcAddr` to get the pointers for the `vkCreateDebugReportCallbackEXT`
    and `vkDestroyDebugReportCallbackEXT` pointer functions so that we can call them.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发生错误时生成报告，我们需要一个调试回调。我们将向其中添加两个函数：一个用于设置调试回调，另一个用于销毁它。这些函数将调用`debug`、`create`和`destroy`函数；它们将调用`vkGetInstanceProcAddr`以获取`vkCreateDebugReportCallbackEXT`和`vkDestroyDebugReportCallbackEXT`指针函数的指针，以便我们可以调用它们。
- en: 'It would be better if it were less confusing to generate a debug report, but
    unfortunately, this is how it must be done. However, we only have to do this once.
    Let''s move on to implementing `AppValidationLayersAndExtentions.cpp`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成调试报告不那么令人困惑会更好，但不幸的是，这就是必须这样做的方式。然而，我们只需要做一次。让我们继续实施`AppValidationLayersAndExtentions.cpp`：
- en: 'First, we add the constructor and destructor, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加构造函数和析构函数，如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To check the supported validation layers, call the `vkEnumerateInstanceLayerProperties`
    function twice. We call it the first time to get the number of validation layers
    that are available. Once we have the count, we call it again to populate it with
    the names of the layers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查支持的验证层，调用`vkEnumerateInstanceLayerProperties`函数两次。我们第一次调用它以获取可用的验证层数量。一旦我们有了计数，我们再次调用它以填充层的名称。
- en: 'We create an `int` called `layerCount` and pass it in the first time we call
    `vkEnumerateInstanceLayerProperties`. The function takes two parameters: the first
    is the count and the second is initially kept `null`. Once the function is called,
    we will know how many validation layers are available. For the names of the layers,
    we create a new vector called `availableLayers` of the `VkLayerProperties` type
    and initialize it with `layerCount`. Then, the function is called again, and this
    time we pass in `layerCount` and the vector as parameters to store the information.
    After, we make a check between the required layers and the available layers. If
    the validation layer was found, the function will return `true`. If not, it will
    return `false`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`layerCount`的`int`，并在第一次调用`vkEnumerateInstanceLayerProperties`时传入它。该函数接受两个参数：第一个是计数，第二个最初保持为`null`。一旦函数被调用，我们将知道有多少验证层可用。对于层的名称，我们创建一个新的名为`availableLayers`的`VkLayerProperties`类型向量，并用`layerCount`初始化它。然后，函数再次被调用，这次我们传入`layerCount`和向量作为参数来存储信息。之后，我们在所需层和可用层之间进行检查。如果找到了验证层，函数将返回`true`。如果没有找到，它将返回`false`。
- en: 'Next, we need to add the `getRequiredInstanceExtentions` function, as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加`getRequiredInstanceExtensions`函数，如下所示：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `getRequiredInstanceExtensions` phrase will get all the extensions that
    are supported by `GLFW`. It takes a Boolean to check whether the validation layers
    are enabled and returns a vector with the names of the supported extensions. In
    this function, we create a `unint32_t` called `glfwExtensionCount` and a `const`
    char for storing the names of the extensions. We call `glfwGetRequiredExtentions`,
    pass in `glfwExtentionCount`, and set it so that it's equal to `glfwExtensions`.
    This will store all the required extensions in `glfwExtensions`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRequiredInstanceExtensions`短语将获取由`GLFW`支持的扩展。它接受一个布尔值来检查验证层是否启用，并返回一个包含支持扩展名称的向量。在这个函数中，我们创建一个名为`glfwExtensionCount`的`unint32_t`和一个用于存储扩展名称的`const`
    char。我们调用`glfwGetRequiredExtensions`，传入`glfwExtensionCount`，并将其设置为等于`glfwExtensions`。这将把所有必需的扩展存储在`glfwExtensions`中。'
- en: We create a new extensions vector and store the `glfwExtention` names. If we
    have enabled the validation layer, then we can add an additional extension layer
    called `VK_EXT_debug_report`, which is the extension for generating a debug report.
    This extension vector is returned at the end of the function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的扩展向量，并存储`glfwExtention`名称。如果我们启用了验证层，则可以添加一个额外的扩展层，称为`VK_EXT_debug_report`，这是用于生成调试报告的扩展。这个扩展向量在函数结束时返回。
- en: 'Then, we add the debug report callback function, which will generate a report
    message whenever there is an error, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加调试报告回调函数，该函数将在出现错误时生成报告消息，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to create the `setupDebugCallback` function, which will call
    the `createDebugReportCallbackExt` function, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建`setupDebugCallback`函数，该函数将调用`createDebugReportCallbackExt`函数，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function takes a Boolean, which will check that the validation layer is
    enabled. It also takes a Vulkan instance, which we will create after this class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个布尔值，用于检查验证层是否启用。它还接受一个Vulkan实例，我们将在本类之后创建它。
- en: When creating a Vulkan object, we usually have to populate a struct with the
    required parameters. So, to create `DebugReportCallback`, we have to populate
    the `VkDebugReportCallbackCreateInfoExt` struct first. In the struct, we pass
    in `sType`, which specifies the structure type. We also pass in any flags for
    error and warning reporting. Finally, we pass in the `callback` function itself.
    Then, we call the `createDebugReportCallbackExt` function and pass in the instance,
    the struct, a null pointer for memory allocation, and the `callback` function. 
    Even though we pass in a null pointer for memory allocation, Vulkan will take
    care of memory allocation by itself. This function is available if you have a
    memory allocation function of your own.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Vulkan对象时，我们通常必须用所需的参数填充一个结构体。因此，要创建`DebugReportCallback`，我们首先必须填充`VkDebugReportCallbackCreateInfoExt`结构体。在这个结构体中，我们传入`sType`，它指定了结构体类型。我们还传入任何用于错误和警告报告的标志。最后，我们传入`callback`函数本身。然后，我们调用`createDebugReportCallbackExt`函数，传入实例、结构体、用于内存分配的空指针和`callback`函数。尽管我们为内存分配传入了一个空指针，但Vulkan将自行处理内存分配。如果你有自己的内存分配函数，此函数是可用的。
- en: 'Now, let''s create the `destroy` function so that we can destroy the debug
    report `callback` function, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`destroy`函数，以便我们可以销毁调试报告`callback`函数，如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Vulkan instances
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan实例
- en: 'To use the `AppValidationLayerAndExtension` class, we have to create a Vulkan
    instance. To do so, follow these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `AppValidationLayerAndExtension` 类，我们必须创建一个 Vulkan 实例。为此，请按照以下步骤操作：
- en: 'We will create another class called `VulkanInstance`. In `VulkanInstance.h`,
    add the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建另一个名为 `VulkanInstance` 的类。在 `VulkanInstance.h` 中，添加以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're including `vulkan.h` and `AppValidationLayersAndExtentions.h` since we
    will need the required validation layers and extensions when we create the Vulkan
    instance. We add the constructor, destructor, and instance of `VkInstance`, as
    well as a function called `ceeateAppAndVkInstance`. This function takes a Boolean
    that checks whether the validation layers are enabled, as well as `AppValidationLayersAndExtensions`.
    That's it for the header.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含 `vulkan.h` 和 `AppValidationLayersAndExtentions.h`，因为我们创建 Vulkan 实例时将需要所需的验证层和扩展。我们添加了构造函数、析构函数以及
    `VkInstance` 的实例，以及一个名为 `ceeateAppAndVkInstance` 的函数。这个函数接受一个布尔值，用于检查验证层是否启用，以及
    `AppValidationLayersAndExtensions`。这就是头文件的内容。
- en: 'In the `.cpp` file, add the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中，添加以下代码：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then add the `createAppAndVkInstance` function, which will allow us to create
    the Vulkan instance, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加 `createAppAndVkInstance` 函数，这将允许我们创建 Vulkan 实例，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding function, we have to populate `VkApplicationInfostruct`, which
    will be required when we create `VkInstance`. Then, we create the `appInfo` struct.
    Here, the first parameter we specify is the `struct` type, which is of the `VK_STRUCTURE_TYPE_APPLICATION_INFO`
    type. The next parameter is the application name itself and is where we specify
    the application version, which is 1.0\. Then, we specify the engine name and version.
    Finally, we specify the Vulkan API version to use.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们必须填充 `VkApplicationInfostruct`，这在创建 `VkInstance` 时是必需的。然后，我们创建 `appInfo`
    结构体。在这里，我们指定的第一个参数是 `struct` 类型，它是 `VK_STRUCTURE_TYPE_APPLICATION_INFO` 类型。下一个参数是应用程序名称本身，我们在这里指定应用程序版本，版本号为
    1.0。然后，我们指定引擎名称和版本。最后，我们指定要使用的 Vulkan API 版本。
- en: Once the application `struct` has been populated, we can create the `vkInstanceCreateInfo`
    struct, which will create the Vulkan instance. In the struct instance we created
    – just like all the structs before this – we have to specify the struct with the
    `struct` type, which is `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序 `struct` 已被填充，我们可以创建 `vkInstanceCreateInfo` 结构体，这将创建 Vulkan 实例。在我们创建的结构体实例中——就像之前的所有结构体一样——我们必须指定具有
    `struct` 类型的结构体，它是 `VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO`。
- en: Then, we have to pass in the application info struct. We have to specify the
    Vulkan extension and validation layers and counts. This information is retrieved
    from the `AppValidationLayersAndExtensions` class. The validation layers are only
    enabled if the class is in debug mode; otherwise, it is not enabled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须传递应用程序信息结构体。我们必须指定 Vulkan 扩展和验证层以及计数。这些信息是从 `AppValidationLayersAndExtensions`
    类中检索的。验证层仅在类处于调试模式时启用；否则，它不会被启用。
- en: 'Now, we can create the Vulkan instance by calling the `vkCreateInstance` function.
    This takes three parameters: the create info instance, an allocator, and the instance
    variable that''s used to store the Vulkan instance. For allocation, we specify
    `nullptr` and let Vulkan take care of memory allocation. If the Vulkan instance
    wasn''t created, a runtime error will be printed to the console to say that the
    function failed to create the Vulkan instance.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用 `vkCreateInstance` 函数来创建 Vulkan 实例。这个函数有三个参数：创建信息实例、分配器和用于存储 Vulkan
    实例的实例变量。对于分配，我们指定 `nullptr` 并让 Vulkan 处理内存分配。如果 Vulkan 实例没有创建，将在控制台打印运行时错误，表示函数未能创建
    Vulkan 实例。
- en: In order to use this `ValidationAndExtensions` class and the Vulkan instance
    class, we will create a new Singleton class called `VulkanContext`. We're doing
    this because we'll need access to some of the Vulkan objects in this class when
    we create our `ObjectRenderer`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个 `ValidationAndExtensions` 类和 Vulkan 实例类，我们将创建一个新的 Singleton 类，名为 `VulkanContext`。我们这样做是因为在创建我们的
    `ObjectRenderer` 时，我们需要访问这个类中的一些 Vulkan 对象。
- en: The Vulkan Context class
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vulkan 上下文类
- en: The Vulkan Context class will include all the functionality we need so that
    we can create our Vulkan renderer. In this class, we will create the validation
    layer, create the Vulkan application and instance, select the GPU we want to use,
    create the swapchain, create render targets, create the render pass, and add the
    command buffers so that we can send our draw commands to the GPU.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan上下文类将包含我们创建Vulkan渲染器所需的所有功能。在这个类中，我们将创建验证层，创建Vulkan应用程序和实例，选择我们想要使用的GPU，创建swapchain，创建渲染目标，创建渲染通道，并添加命令缓冲区，以便我们可以将我们的绘图命令发送到GPU。
- en: We will also add two new functions: `drawBegin` and `drawEnd`. In the `drawBegin`
    function, we will add the functionality for the preparation stages of drawing.
    The `drawEnd` function will be called after we have drawn an object and prepared
    it so that it can be presented to the viewport.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加两个新的函数：`drawBegin`和`drawEnd`。在`drawBegin`函数中，我们将添加绘图准备阶段的函数。`drawEnd`函数将在我们绘制一个对象并准备它以便可以在视口中呈现之后被调用。
- en: 'Create a new `.h` class and `.cpp` file. In the `.h` file, include the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`.h`类文件和`.cpp`文件。在`.h`文件中，包含以下代码：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will create a Boolean called `isValidationLayersEnabled`. This will
    be set to `true` if the application is running in debug mode and `false` if it''s
    running in release mode:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个布尔值`isValidationLayersEnabled`。如果应用程序以调试模式运行，则将其设置为`true`；如果以发布模式运行，则设置为`false`：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we create the class itself, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建类本身，如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `public` section, we create a static instance and the `getInstance`
    variable and function, which sets and gets the instance of this class. We add
    the destructor and add an `initVulkan` function, which will be used to initialize
    the Vulkan context. In the `private` section, we create an instance of the `AppValidationLayersAndExtentions`
    and `VulkanInstance` classes. In the `VulkanContext.cpp` file, we set the instance
    variable to `null`, and, in the `getInstance` function, we check whether the instance
    was created. If it was not created, we create a new instance, return it, and add
    the destructor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public`部分，我们创建一个静态实例和`getInstance`变量和函数，该函数用于设置和获取这个类的实例。我们添加了析构函数并添加了一个`initVulkan`函数，该函数将用于初始化Vulkan上下文。在`private`部分，我们创建了`AppValidationLayersAndExtensions`和`VulkanInstance`类的实例。在`VulkanContext.cpp`文件中，我们将实例变量设置为`null`，并在`getInstance`函数中检查实例是否已创建。如果没有创建，我们创建一个新的实例，返回它，并添加析构函数：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we add the functionality for the `initVulkan` function, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加`initVulkan`函数的功能，如下所示：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we create a new `AppValidationLayersAndExtensions` instance. Then, we
    check whether the validation layers are enabled and check whether the validation
    layers are supported. If `ValidationLayers` is not available, a runtime error
    is sent out, saying that the validation layers are not available.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`AppValidationLayersAndExtensions`实例。然后，我们检查验证层是否启用并检查验证层是否受支持。如果`ValidationLayers`不可用，将发出运行时错误，表示验证层不可用。
- en: If the validation layers are supported, a new instance of the `VulkanInstance`
    class is created and the `createAppAndVkInstance` function is called, which creates
    a new `vkInstance`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证层受支持，将创建一个新的`VulkanInstance`类实例并调用`createAppAndVkInstance`函数，该函数创建一个新的`vkInstance`。
- en: 'Once this is complete, we call the `setupDebugCallBack` function by passing
    in the Boolean and `vkInstance`. In the `source.cpp` file, include the `VulkanContext.h`
    file and call `initVulkan` after the window is created, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们通过传递布尔值和`vkInstance`调用`setupDebugCallBack`函数。在`source.cpp`文件中，包含`VulkanContext.h`文件，并在窗口创建后调用`initVulkan`，如下所示：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Hopefully, you won''t get any errors in the console window when you build and
    run the application. If you do get errors, go through each line of code and make
    sure there are no spelling mistakes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在构建和运行应用程序时不会在控制台窗口中遇到任何错误。如果你遇到错误，请逐行检查代码，确保没有拼写错误：
- en: '![](img/5a01dea9-20d8-4215-824d-c92cbb68c200.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a01dea9-20d8-4215-824d-c92cbb68c200.png)'
- en: Creating the window surface
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建窗口表面
- en: We need an interface for the window we created for the current platform so that
    we can present the images we will render. We use the `VKSurfaceKHR` property to
    get access to the window surface. To store the surface information that the OS
    supports, we will call the `glfw` function, `glfwCreateWindowSurface`, to create
    the surface that's supported by the OS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个针对当前平台创建的窗口的接口，以便我们可以展示我们将要渲染的图像。我们使用`VKSurfaceKHR`属性来获取对窗口表面的访问权限。为了存储操作系统支持的表面信息，我们将调用`glfw`函数`glfwCreateWindowSurface`来创建操作系统支持的表面。
- en: 'In `VulkanContext.h`, add a new variable of the `VkSurfaceKHR` type called
    `surface`, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanContext.h`中，添加一个名为`surface`的新变量，类型为`VkSurfaceKHR`，如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we need access to the window instance we created in `source.cpp`, change
    the `initVulkan` function so that it accepts a `GLFWwindow`, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要访问在`source.cpp`中创建的窗口实例，因此更改`initVulkan`函数，使其接受一个`GLFWwindow`，如下所示：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `VulkanContext.cpp`, change the `initVulkan` implementation as follows and
    call the `glfwCreateWindowSurface` function, which takes in the Vulkan instance
    and the window. Next, pass in `null` for the allocator and the surface to create
    the surface object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VulkanContext.cpp`中，更改`initVulkan`的实现，如下所示，并调用`glfwCreateWindowSurface`函数，该函数接受Vulkan实例和窗口。接下来，传入`null`作为分配器和表面以创建表面对象：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in `source.cpp`, change the `initVulkan` function, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`source.cpp`中更改`initVulkan`函数，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Picking a physical device and creating a logical device
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择物理设备并创建逻辑设备
- en: Now, we will create the `Device` class, which will be used to go through the
    different physical devices we have. We will choose one to render our application.
    To check whether your GPU is compatible with Vulkan, check the compatibility list
    on your GPU vendor's site or go to [https://en.wikipedia.org/wiki/Vulkan_(API)](https://en.wikipedia.org/wiki/Vulkan_(API)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`Device`类，它将用于遍历我们拥有的不同物理设备。我们将选择一个来渲染我们的应用程序。为了检查您的GPU是否与Vulkan兼容，请检查GPU供应商网站上的兼容性列表，或访问[https://en.wikipedia.org/wiki/Vulkan_(API)](https://en.wikipedia.org/wiki/Vulkan_(API))。
- en: 'Basically, any NVIDIA GPU from the Geforce 600 series and AMD GPU from the
    Radeon HD 2000 series and later should be supported. To access the physical device
    and create a logical device, we will create a new class that will allow us to
    access it whenever we want. Create a new class called `Device`. In `Device.h`,
    add the following includes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，任何来自Geforce 600系列以及Radeon HD 2000系列及以后的NVIDIA GPU都应该得到支持。为了访问物理设备并创建逻辑设备，我们将创建一个新的类，这样我们就可以随时访问它。创建一个名为`Device`的新类。在`Device.h`中添加以下包含：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will also add a couple of structs for the sake of convenience. The first
    is called `SwapChainSupportDetails`; it has access to `VkSurfaceCapabilitiesKHR`,
    which contains all the required details about the surface. We'll also add the `surfaceFormats` vector
    of the `VkSurfaceFormatKHR` type, which keeps track of all the different image
    formats the surface supports, and the `presentModes` vector of the `VkPresentModeKHR` type,
    which stores the presentation modes that the GPU supports.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还将添加几个结构体。第一个叫做`SwapChainSupportDetails`；它能够访问`VkSurfaceCapabilitiesKHR`，其中包含有关表面的所有所需详细信息。我们还将添加`VkSurfaceFormatKHR`类型的`surfaceFormats`向量，它跟踪表面支持的所有不同图像格式，以及`VkPresentModeKHR`类型的`presentModes`向量，它存储GPU支持的显示模式。
- en: Rendered images will be sent to the window surface and displayed. This is how
    we are able to see the final rendered image using a renderer, such as OpenGL or
    Vulkan. Now, we can show these images to the window one at a time, which is fine
    if we want to look at a still image forever. However, when we run a game that
    is updated every 16 milliseconds (60 times in a second), there may be cases where
    the image has not been fully rendered, but it would be time to display it. At
    this point, we will see half-rendered images, which leads to screen tearing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的图像将被发送到窗口表面并显示。这就是我们能够使用渲染器（如OpenGL或Vulkan）看到最终渲染图像的原因。现在，我们可以一次显示这些图像，如果我们想永远查看静态图像，这是可以的。然而，当我们运行每16毫秒更新一次（每秒60次）的游戏时，可能会出现图像尚未完全渲染，但需要显示的情况。在这种情况下，我们会看到半渲染的图像，这会导致屏幕撕裂。
- en: 'To avoid this, we use double buffering. This allows us to render the image
    so that it has two different images, known as the front buffer and the back buffer,
    and ping-pong between them. Then, we present the buffer that has finished rendering
    and display it to the viewport while the next frame is still being rendered, as
    shown in the following diagram. There are different ways to present the image
    as well. We will look at these different presentation modes when we create the
    swapchain:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们使用双缓冲。这允许我们渲染图像，使其具有两个不同的图像，称为前缓冲区和后缓冲区，并在它们之间进行ping-pong。然后，我们展示已经完成渲染的缓冲区，并在下一个帧仍在渲染时将其显示到视口中，如下面的图所示。还有不同的方式来展示图像。当我们创建swapchain时，我们将查看这些不同的呈现模式：
- en: '![](img/ee9c08d1-1be2-4404-8aca-76b1e698d73a.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee9c08d1-1be2-4404-8aca-76b1e698d73a.png)'
- en: 'We need to create a struct to track the surface properties, format, and presentation
    modes, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个结构体来跟踪表面属性、格式和呈现模式，如下所示：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A GPU also has what is called `QueueFamilies`. Commands are sent to the GPU
    and then executed using queues. There are separate queues for different kinds
    of work. Render commands are sent to render queues, compute commands are sent
    to compute queues, and there are also presentation queues for presenting images.
    We also need to know which queues the GPU supports and how many of the queues
    are present.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GPU也有被称为`QueueFamilies`的东西。命令被发送到GPU，然后使用队列执行。有针对不同类型工作的单独队列。渲染命令被发送到渲染队列，计算命令被发送到计算队列，还有用于展示图像的呈现队列。我们还需要知道GPU支持哪些队列以及有多少队列存在。
- en: The renderer, compute, and presentation queues can be combined and are known
    as queue families. These queues can be combined in different ways to form a number
    of queue families. This means that there can be a combination of render and presentation
    queues that forms one queue family, while another family may just contain compute
    queues. Therefore, we have to check whether we have at least one queue family
    with graphics and presentation queues. This is because we need a graphics queue
    to pass our rendering commands into and a presentation queue to present the image
    after we render it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器、计算和呈现队列可以组合，并被称为队列家族。这些队列可以以不同的方式组合，形成多个队列家族。这意味着可以组合渲染和呈现队列形成一个队列家族，而另一个家族可能只包含计算队列。因此，我们必须检查我们是否至少有一个包含图形和呈现队列的队列家族。这是因为我们需要一个图形队列来传递我们的渲染命令，以及一个呈现队列在渲染后展示图像。
- en: 'We will add one more struct to check for both, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个结构体来检查这两个方面，如下所示：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will create the `Device` class itself. After creating the class, we
    add the constructor and destructor, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`Device`类本身。在创建类之后，我们添加构造函数和析构函数，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we need to add some variables so that we can store the physical device,
    the `SwapChainSupportDetails`, and the `QueueFamilyIndices`, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一些变量，以便我们可以存储物理设备、`SwapChainSupportDetails`和`QueueFamilyIndices`，如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To create double buffering, we have to check that the device supports it. This
    is done using the `VK_KHR_SWAPCHAIN_EXTENSION_NAME` extension, which checks for
    a swapchain. First, we create a vector of the `char*` const and pass in the extension
    name, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建双缓冲，我们必须检查设备是否支持它。这是通过使用`VK_KHR_SWAPCHAIN_EXTENSION_NAME`扩展来完成的，该扩展检查swapchain。首先，我们创建一个`char*`常量向量，并传入扩展名称，如下所示：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we add the `pickPhysicalDevice` function, which will be selected depending
    on whether the device is suitable. While checking for suitability, we will check
    whether the selected device supports the swapchain extension, get the swapchain
    support details, and get the queue family indices, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了`pickPhysicalDevice`函数，该函数将根据设备是否合适来选择。在检查合适性的过程中，我们将检查所选设备是否支持swapchain扩展，获取swapchain支持详情，以及获取队列家族索引，如下所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will also add a getter function to get the queue families of the current
    device, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个获取器函数来获取当前设备的队列家族，如下所示：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have the physical device we want to use, we will create an instance
    of the logical device. The logical device is an interface for the physical device
    itself. We will use the logical device to create buffers and so on. We will also
    store the current device graphics and present a queue so that we can send the
    graphics and presentation commands. Finally, we will add a `destroy` function,
    which is used to destroy the physical and logical devices we created, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了想要使用的物理设备，我们将创建一个逻辑设备的实例。逻辑设备是物理设备本身的接口。我们将使用逻辑设备来创建缓冲区等。我们还将存储当前设备的图形和呈现队列，以便我们可以发送图形和呈现命令。最后，我们将添加一个`destroy`函数，用于销毁我们创建的物理和逻辑设备，如下所示：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That''s all for the `Device.h` file. Let''s move on to `Device.cpp`. First,
    we include `Device.h` and add the constructor and the destructor, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device.h`文件的内容就到这里。让我们继续到`Device.cpp`。首先，我们包含`Device.h`并添加构造函数和析构函数，如下所示：'
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the real work begins. We need to create the `pickPhysicalDevice` function,
    which takes a Vulkan instance and the `VkSurface`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的任务开始了。我们需要创建一个`pickPhysicalDevice`函数，它接受一个Vulkan实例和`VkSurface`，如下所示：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we are creating an `int32` to store the count of the number of physical
    devices. We get the number of available GPUs using `vkEnumeratePhysicalDevices`
    and pass the Vulkan instance, the count, and `null` for the third parameter. This
    will retrieve the number of available devices. If `deviceCount` is zero, this
    means that there are no GPUs available. Then, we print the available number of
    devices to the console.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个`int32`来存储物理设备的数量。我们使用`vkEnumeratePhysicalDevices`获取可用的GPU数量，并将Vulkan实例、计数和第三个参数的`null`传递过去。这将检索可用的设备数量。如果`deviceCount`为零，这意味着没有可用的GPU。然后，我们将可用的设备数量打印到控制台。
- en: To get the physical devices themselves, we create a vector called `devices`,
    which will store the `VkPhysicalDevice` data type; this will store the devices
    for us. We will call the `vkEnumeratePhysicalDevices` function again, but this
    time – apart from passing in the Vulkan instance and the device count – we will
    also store the device information in the vector that we passed in as the third
    parameter. Then, we will print out the number of devices with the `DEVICE PROPERTIES` heading.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取物理设备本身，我们创建一个名为`devices`的向量，它将存储`VkPhysicalDevice`数据类型；这将为我们存储设备。我们将再次调用`vkEnumeratePhysicalDevices`函数，但这次——除了传递Vulkan实例和设备计数之外——我们还将设备信息存储在我们传递的第三个参数中。然后，我们将打印出带有`DEVICE
    PROPERTIES`标题的设备数量。
- en: To get the properties of the available devices, we will go through the number
    of devices and get their properties using `vkGetPhysicalDeviceProperties` before
    storing them in the variable of the `VkPhysicalDeviceProperties` type.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用设备的属性，我们将遍历设备数量，并使用`vkGetPhysicalDeviceProperties`获取它们的属性，在将它们存储在`VkPhysicalDeviceProperties`类型的变量中之前。
- en: Now, we need to print out the name of the device and call `DeviceSuitable` on
    the device. If the device is suitable, we will store it as a `physicalDevice`
    and break out of the loop. Note that we set the first available device as the
    device we will be using.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要打印出设备的名称，并在设备上调用`DeviceSuitable`。如果设备合适，我们将将其存储为`physicalDevice`并退出循环。请注意，我们将第一个可用的设备设置为我们将要使用的设备。
- en: 'If there is no suitable device, we throw a runtime error to say that a suitable
    device wasn''t found. Let''s take a look at the `DeviceSuitable` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有合适的设备，我们将抛出一个运行时错误，表示未找到合适的设备。让我们看看`DeviceSuitable`函数：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this function, we get the queue family indices by calling `findQueueFamilies`.
    Then, we check whether `VK_KHR_SWAPCHAIN_EXTENSION_NAMEextension` is supported.
    After this, we check for swapchain support on the device. If the surface formats
    and presentation modes are not empty, `swapChainAdequateboolean` is set to `true`.
    Finally, we get the physical device features by calling `vkGetPhysicalDeviceFeatures`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们通过调用`findQueueFamilies`获取队列家族索引。然后，我们检查是否支持`VK_KHR_SWAPCHAIN_EXTENSION_NAMEextension`。之后，我们检查设备上的swapchain支持。如果表面格式和呈现模式不为空，`swapChainAdequateboolean`设置为`true`。最后，我们通过调用`vkGetPhysicalDeviceFeatures`获取物理设备特性。
- en: Finally, we return `true` if the queue families are present, the swapchain extension
    is supported, the swapchain is adequate, and the device supports anisotropic filtering.
    Anisotropic filtering is a mode that makes the pixels in the distance clearer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果队列家族存在，swapchain扩展被支持，swapchain足够，并且设备支持各向异性过滤，我们将返回`true`。各向异性过滤是一种使远处的像素更清晰的模式。
- en: Anisotropic filtering is a mode that, when enabled, helps sharpen textures that
    are viewed from extreme angles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 各向异性过滤是一种模式，当启用时，有助于从极端角度查看的纹理变得更加清晰。
- en: 'In the following example, the image on the right has anisotropic filtering
    enabled and the image on the left has it disabled. In the image on the right,
    the white dashed line is still relatively visible further down the road. However,
    in the image on the left, the dashed line becomes blurry and pixelated. Therefore,
    anisotropic filtering is required:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，右侧的图像启用了各向异性过滤，而左侧的图像未启用。在右侧的图像中，白色虚线在道路下方仍然相对可见。然而，在左侧的图像中，虚线变得模糊且像素化。因此，需要各向异性过滤：
- en: '![](img/b63e98b4-c702-4646-82ba-fd69536d5b56.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b63e98b4-c702-4646-82ba-fd69536d5b56.png)'
- en: (Taken from [https://i.imgur.com/jzCq5sT.jpg](https://i.imgur.com/jzCq5sT.jpg))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （摘自[https://i.imgur.com/jzCq5sT.jpg](https://i.imgur.com/jzCq5sT.jpg))
- en: 'Let''s look at the three functions we called in the previous function. First,
    let''s check out the `findQueueFamilies` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在上一函数中调用的三个函数。首先，让我们看看`findQueueFamilies`函数：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To get the queue family properties, we call the `vkGetPhysicalDeviceQueueFamilyProperties`
    function; then, in the physical device, we pass an `int`, which we use to store
    the number of queue families, and the `null` pointer. This will give us the number
    of queue families that are available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取队列家族属性，我们调用`vkGetPhysicalDeviceQueueFamilyProperties`函数；然后，在物理设备中，我们传递一个`int`，我们用它来存储队列家族的数量，以及`null`指针。这将给我们提供可用的队列家族数量。
- en: Next, for the properties themselves, we create a vector of the `VkQueueFamilyProperties` type,
    called `queueFamilies`, to store the necessary information. Then, we call `vkGetPhysicalDeviceFamilyProperties`
    and pass in the physical device, the count, and `queueFamilies` itself to populate
    it with the required data. We create an `int`, `i`, and initialize it to `0`.
    This will store the index of the graphics and presentation indices.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于属性本身，我们创建了一个`VkQueueFamilyProperties`类型的向量，称为`queueFamilies`，用于存储必要的信息。然后，我们调用`vkGetPhysicalDeviceFamilyProperties`并传递物理设备、计数和`queueFamilies`本身，以填充所需的数据。我们创建一个`int`，`i`，并将其初始化为`0`。这将存储图形和演示索引的索引。
- en: In the `for` loop, we check whether each of the queue families supports a graphics
    queue by looking for `VK_QUEUE_GRAPHICS_BIT`. If they do, we set the graphics
    family index.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，我们检查每个队列家族是否支持图形队列，通过查找`VK_QUEUE_GRAPHICS_BIT`。如果支持，我们设置图形家族索引。
- en: Then, we check for presentation support by passing in the index. This will check
    whether the same family supports presentation as well. If it supports presentation,
    we set `presentFamily` to that index.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过传递索引来检查演示支持。这将检查是否相同的家族也支持演示。如果它支持演示，我们将`presentFamily`设置为该索引。
- en: If the queue family supports graphics and presentation, the graphics and presentation
    index will be the same.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列家族支持图形和演示，图形和演示索引将是相同的。
- en: 'The following screenshot shows the number of queue families by device and the
    number of queues in each queue family:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了按设备划分的队列家族数量以及每个队列家族中的队列数量：
- en: '![](img/b1fb0547-fff6-4569-aaa7-9d19500f67cc.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1fb0547-fff6-4569-aaa7-9d19500f67cc.png)'
- en: There are three queue families on my GPU. The first queue family at the 0^(th)
    index has 16 queues, the second queue family at the 1^(st) index has one queue,
    and the third queue family at the 2^(nd) index has eight queues.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我的GPU上有三个队列家族。第一个队列家族在0^(th)索引处有16个队列，第二个队列家族在1^(st)索引处有一个队列，第三个队列家族在2^(nd)索引处有八个队列。
- en: The `queueFlags` specify the queues in the queue family. The queues that are
    supported could be for graphics, compute, transfer, or sparse binding.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`queueFlags`指定队列家族中的队列。支持的队列可以是图形、计算、传输或稀疏绑定。'
- en: 'After this, we check that both the graphics and presentation indices were found,
    and then we break out of the loop. Finally, we return `queueFamilyIndices`. I
    am running the project on an Intel Iris Plus Graphics 650\. This integrated intel
    GPU has one queue family that supports graphics and the presentation queue. Different
    GPUs have different queue families and each family may support more than one queue
    type. Next, let''s look at the device extension that is supported. We can check
    this by using the `checkDeviceExtensionSupported` function, which takes in a physical
    device, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查是否找到了图形和显示索引，然后退出循环。最后，我们返回`queueFamilyIndices`。我在Intel Iris Plus Graphics
    650上运行项目。这个集成的英特尔GPU有一个支持图形和显示队列的队列家族。不同的GPU有不同的队列家族，每个家族可能支持多种队列类型。接下来，让我们看看支持的设备扩展。我们可以通过使用`checkDeviceExtensionSupported`函数来检查这一点，该函数接受一个物理设备，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We get the number of extensions that are supported by the device by calling
    `vkEnumerateDeviceExtensionProperties` and passing in the physical device, the
    null pointer, an `int` to store the count in it, and `null`. The actual properties
    are stored inside the `availableExtensions` vector, which stores the `VkExtensionProperties` data
    type. By calling `vkEnumerateDeviceExtensionProperties` again, we get the device's
    extension properties.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`vkEnumerateDeviceExtensionProperties`并传递物理设备、空指针、一个用于存储计数的`int`和一个空指针来获取设备支持的扩展数量。实际的属性存储在`availableExtensions`向量中，该向量存储`VkExtensionProperties`数据类型。通过再次调用`vkEnumerateDeviceExtensionProperties`，我们获取设备的扩展属性。
- en: 'We populate the `requiredExtensions` vector with the extension we require.
    Then, we check the available extension vector with the required extensions. If
    the required extension is found, we remove it from the vector. This means that
    the device supports the extension and returns the value from the function, as
    shown in the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所需的扩展添加到`requiredExtensions`向量中。然后，我们使用所需的扩展检查可用的扩展向量。如果找到所需的扩展，我们就从向量中移除它。这意味着设备支持该扩展，并从函数返回值，如下面的代码所示：
- en: '![](img/c7f60c53-6246-4e52-a334-8763320c8bcd.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7f60c53-6246-4e52-a334-8763320c8bcd.png)'
- en: 'The device I am running has 73 available extensions, as shown in the following
    code. You can set a breakpoint and take a look at the device extension properties
    to view the supported extension of the device. The third function we will look
    at is the `querySwapChainSupport` function, which populates the surface capabilities,
    surface formats, and presentation modes that are available:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在我设备上的设备有73个可用的扩展，如下面的代码所示。你可以设置一个断点并查看设备扩展属性以查看设备的支持扩展。我们将要查看的第三个函数是`querySwapChainSupport`函数，它填充了可用的表面功能、表面格式和显示模式：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get the surface capabilities, we call `vkGetPhysicalDeviceSurfaceCapabilitiesKHR`
    and pass in the device, that is, `surface`, to get the surface capabilities. To
    get the surface format and presentation modes, we call `vkGetPhysicalDeviceSurfaceFormatKHR`
    and `vkGetPhysicalDeviceSurfacePresentModeKHR` twice.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取表面功能，我们调用`vkGetPhysicalDeviceSurfaceCapabilitiesKHR`并将设备（即`surface`）传递给它以获取表面功能。要获取表面格式和显示模式，我们分别调用`vkGetPhysicalDeviceSurfaceFormatKHR`和`vkGetPhysicalDeviceSurfacePresentModeKHR`两次。
- en: The first time we call the `vkGetPhysicalDeviceSurfacePresentModeKHR` function,
    we get the number of formats and modes that are present; we call it a second time
    to get the formats and the modes that have been populated and stored in the vectors
    of the struct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`vkGetPhysicalDeviceSurfacePresentModeKHR`函数时，我们获取现有格式和模式的数量；我们第二次调用它以获取已填充并存储在结构体向量的格式和模式。
- en: 'Here are the capabilities of my device surface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的设备表面的功能：
- en: '![](img/c5c9f1c3-30f8-4dea-8b8f-cc6facc73daf.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5c9f1c3-30f8-4dea-8b8f-cc6facc73daf.png)'
- en: 'So, the minimum image count is two, meaning that we can add double buffering.
    These are the surface formats and the color space that my device supports:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最小图像计数是两个，这意味着我们可以添加双缓冲。以下是我的设备支持的表面格式和色彩空间：
- en: '![](img/8887e334-8668-4c48-9e42-8831c766f2b0.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8887e334-8668-4c48-9e42-8831c766f2b0.png)'
- en: 'Here are the presentation modes that are supported by my device:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的设备支持的显示模式：
- en: '![](img/76276022-dd84-42d6-a807-7110aa899c6e.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76276022-dd84-42d6-a807-7110aa899c6e.png)'
- en: 'So, it seems that my device only supports the immediate mode. We will see the
    use of this in the ahead chapters. After getting the physical device properties,
    we set the getter function for the `queueFamiliyIndices`, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我的设备似乎只支持即时模式。我们将在后续章节中看到它的用法。在获取物理设备属性后，我们为`queueFamiliyIndices`设置getter函数，如下所示：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we can create the logical device by using the `createLogicalDevice` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`createLogicalDevice`函数创建逻辑设备。
- en: 'To create the logical device, we have to populate the `VkDeviceCreateInfo`
    struct, which requires the `queueCreateInfo` struct. Let''s get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建逻辑设备，我们必须填充`VkDeviceCreateInfo`结构体，这需要`queueCreateInfo`结构体。让我们开始吧：
- en: Create a vector so that we can store `VkDeviceQueueCreateInfo` and any necessary
    information for the graphics and presentation queues.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个向量，以便我们可以存储`VkDeviceQueueCreateInfo`和图形和呈现队列所需的任何信息。
- en: Create another vector of the `int` type so that we can store the indices of
    the graphics and presentation queues.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`int`类型的向量，以便我们可以存储图形和呈现队列的索引。
- en: 'For each queue family, populate `VkDeviceQueueCreateInfo`. Create a local struct
    and pass in the struct type, the queue family index, the queue count, and priority
    (which is `1`), and then push it into the `queueCreateInfos` vector, as shown
    in the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个队列家族，填充`VkDeviceQueueCreateInfo`。创建一个局部结构体，传入结构体类型、队列家族索引、队列计数和优先级（为`1`），然后将它推入`queueCreateInfos`向量，如下所示：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To create the device, specify the device features that we will be using. For
    the device features, we will create a variable of the `VkPhysicalDeviceFeatures`
    type and set `samplerAnisotropy` to `true`, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建设备，指定我们将使用的设备功能。对于设备功能，我们将创建一个`VkPhysicalDeviceFeatures`类型的变量，并将`samplerAnisotropy`设置为`true`，如下所示：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create the `VkDeviceCreateInfo` struct, which we need in order to create the
    logical device. Set the type to `VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO` and then
    set `queueCreateInfos`, the count, and the device features that are to be enabled.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`VkDeviceCreateInfo`结构体，这是创建逻辑设备所必需的。将类型设置为`VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO`，然后设置`queueCreateInfos`、计数和要启用的设备功能。
- en: 'Set the device extension count and names. If the validation layer is enabled,
    we set the validation layer''s count and names. Create the `logicalDevice` by
    calling `vkCreateDevice` and passing in the physical device, the create device
    information, and `null` for the allocator. Then, create the logical device, as
    shown in the following code. If this fails, then we throw a runtime error:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置设备扩展计数和名称。如果启用了验证层，我们设置验证层的计数和名称。通过调用`vkCreateDevice`并传入物理设备、创建设备信息和`null`分配器来创建`logicalDevice`。然后，创建逻辑设备，如下所示。如果失败，则抛出运行时错误：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Get the device graphics and presentation queue, as shown in the following code.
    We are now done with the `Device` class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取设备图形和呈现队列，如下所示。我们现在完成了`Device`类的操作：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This wraps up the `Device` class. Include the `Device.h` file in `VulkanContext.h`
    and add a new device object of the `Device` type to the `VulkanContext` class''s
    private section, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了`Device`类的封装。在`VulkanContext.h`文件中包含`Device.h`文件，并在`VulkanContext`类的私有部分添加一个新的`Device`类型设备对象，如下所示：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `VulkanContext.cpp` file in the `VulkanInit` function, add the following
    code after creating the surface:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VulkanContext.cpp`文件中的`VulkanInit`函数中，在创建表面之后添加以下代码：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will create a new instance of the `device` class and we choose a device from
    the available physical devices. You will then be able to create the logical device.
    Run the application to see which device the application will run on. On my desktop,
    the following device count and name were found:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建`device`类的新实例，并从可用的物理设备中选择一个设备。然后，你将能够创建逻辑设备。运行应用程序以查看应用程序将在哪个设备上运行。在我的台式机上，找到了以下设备计数和名称：
- en: '![](img/ba1c7ca6-5f59-48e6-81fb-e3ab6cc5abf2.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba1c7ca6-5f59-48e6-81fb-e3ab6cc5abf2.png)'
- en: 'On my laptop, the application found one device with the following device name:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的笔记本电脑上，应用程序找到了以下设备名称的设备：
- en: '![](img/2c89d883-db8b-4d79-97d1-43caacc381a8.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c89d883-db8b-4d79-97d1-43caacc381a8.png)'
- en: Set breakpoints inside `findQueueFamilies`, `checkDeviceExtensionSupport`, and
    `querySwapChainSupport` to check for the number of queue family device extensions
    and for swapchain support for your GPUs.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`findQueueFamilies`、`checkDeviceExtensionSupport`和`querySwapChainSupport`函数内部设置断点，以检查队列家族设备扩展的数量以及GPU对swapchain的支持情况。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are about a quarter of the way through the process of seeing something being
    rendered to the viewport. In this chapter, we set the validation layers and the
    extension that we will need in order to set up Vulkan rendering. We created a
    Vulkan application and instance and then created a device class so that we can
    select the physical device. We also created the logical device so that we can
    interact with the GPU.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了大约四分之一的渲染到视口的过程。在这一章中，我们设置了验证层和我们需要设置的扩展，以便设置Vulkan渲染。我们创建了一个Vulkan应用程序和实例，然后创建了一个设备类，以便我们可以选择物理设备。我们还创建了一个逻辑设备，以便我们可以与GPU交互。
- en: In the next chapter, we will create the swapchain itself so that we can swap
    between buffers, and we will create the render and the depth texture to draw the
    scene. We will create a render pass to set how the render textures are to be used
    and then create the draw command buffers, which will execute our draw commands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建swapchain本身，以便我们可以在缓冲区之间进行交换，并且我们将创建渲染和深度纹理来绘制场景。我们将创建一个渲染通道来设置渲染纹理的使用方式，然后创建绘制命令缓冲区，这些缓冲区将执行我们的绘制命令。
