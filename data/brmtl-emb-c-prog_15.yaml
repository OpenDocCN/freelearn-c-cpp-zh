- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: The Real-Time Clock (RTC)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时时钟（RTC）
- en: In this chapter, we will explore the **Real-Time Clock** (**RTC**) peripheral,
    an essential component for timekeeping in embedded systems. This peripheral is
    crucial for applications that require accurate time and date maintenance, making
    it fundamental for a wide range of embedded applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨实时时钟（RTC）外设，这是嵌入式系统中时间维护的关键组件。这个外设在需要精确时间和日期维护的应用中至关重要，对于广泛的嵌入式应用来说是基本的。
- en: We will start by introducing RTCs and understanding how they function. Following
    this, we will delve into the STM32 RTC module, examining its features and capabilities.
    Next, we will analyze the relevant registers from the STM32 reference manual,
    providing a detailed understanding of the configuration and operation of the RTC.
    Finally, we will apply this knowledge to develop an RTC driver, enabling precise
    timekeeping in your embedded projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍RTC及其工作原理。随后，我们将深入研究STM32 RTC模块，检查其特性和功能。接下来，我们将分析STM32参考手册中的相关寄存器，提供对RTC配置和操作的详细理解。最后，我们将应用这些知识来开发RTC驱动程序，使您能够在嵌入式项目中实现精确的时间维护。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding RTCs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解RTC
- en: The STM32 RTC module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 RTC模块
- en: Some key RTC registers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些关键的RTC寄存器
- en: Developing the RTC driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发RTC驱动程序
- en: By the end of this chapter, you will have a solid understanding of how RTCs
    work and will be equipped with the skills to develop bare-metal RTC drivers, allowing
    you to implement accurate timekeeping in your embedded systems projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对RTC的工作原理有一个扎实的理解，并具备开发裸机RTC驱动程序的能力，这将使您能够在嵌入式系统项目中实现精确的时间维护。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding RTCs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解RTC
- en: In this section, we will enter the world of RTCs, understanding what they are
    and how they work before exploring common use cases through a few interesting
    case studies. Let’s get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进入RTC的世界，了解它们是什么以及它们是如何工作的，然后通过几个有趣的案例研究来探索常见的用例。让我们开始吧！
- en: RTCs are specialized hardware devices found in many microcontrollers and embedded
    systems. Their primary function is to keep track of the current time and date,
    even when the main power supply is turned off. Imagine them as the little timekeepers
    of the digital world, ensuring that the clock never stops ticking, no matter what.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'RTC是许多微控制器和嵌入式系统中发现的专用硬件设备。它们的主要功能是在主电源关闭时跟踪当前的时间和日期。想象一下，它们就像是数字世界中的小时间守护者，确保时钟无论发生什么都不会停止滴答。 '
- en: RTCs are crucial in applications where timekeeping is essential. This includes
    everything from simple alarm clocks to complex data logging systems, where accurate
    timestamps are necessary. An RTC continues to operate on a small battery when
    the main system is powered down, maintaining accurate time and date information.
    Let’s see how they work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RTCs在需要精确时间维护的应用中至关重要。这包括从简单的闹钟到复杂的数据记录系统，在这些系统中，精确的时间戳是必要的。当主系统断电时，RTC会继续在小型电池上运行，保持准确的时间和日期信息。让我们看看它们是如何工作的。
- en: How do RTCs work?
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC是如何工作的？
- en: At the heart of an RTC is a crystal oscillator, which provides a stable clock
    signal. This oscillator typically runs at **32.768 kHz**, a frequency chosen because
    it is easily divisible by powers of two, making it convenient for binary counting.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RTC的核心是一个晶振，它提供稳定的时钟信号。这个振荡器通常运行在**32.768 kHz**，这个频率之所以被选择，是因为它很容易被2的幂次整除，这使得它对二进制计数非常方便。
- en: 'Here’s a simplified breakdown of how an RTC works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简化的RTC工作原理分解：
- en: '**Crystal oscillator**: The RTC contains a crystal oscillator that generates
    a precise clock signal.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晶振**：RTC包含一个晶振，它产生精确的时钟信号。'
- en: '**Counter**: This clock signal drives a counter. The counter increments at
    a rate determined by the oscillator’s frequency.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：这个时钟信号驱动一个计数器。计数器以振荡器频率确定的速率递增。'
- en: '**Time and date registers**: The counter’s value is used to update time and
    date registers, which hold the current time (hours, minutes, seconds) and date
    (day, month, year).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间和日期寄存器**：计数器的值用于更新时间和日期寄存器，这些寄存器存储当前时间（小时、分钟、秒）和日期（日、月、年）。'
- en: '**Battery backup**: To ensure continuous operation, RTCs often have a battery
    backup. This keeps the oscillator running and the counter active even when the
    main power is off.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池备份**：为确保连续运行，RTCs通常具有电池备份。即使在主电源关闭时，这也使振荡器保持运行，计数器保持活跃。'
- en: Let’s consider some common use cases for RTCs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些RTC的常见用途。
- en: Common use cases for RTCs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTCs的常见用途
- en: RTCs are incredibly versatile and are used in a wide variety of applications.
    Let’s explore some of the common use cases through a few case studies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RTCs非常灵活，被广泛应用于各种应用。让我们通过几个案例研究来探索一些常见的用途。
- en: Case study 1 – data logging
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 案例研究 1 – 数据记录
- en: 'One of the most common applications of RTCs is in data logging. Imagine that
    you’re designing a weather station that collects temperature, humidity, and pressure
    data. Accurate timestamps are crucial for analyzing trends and patterns over time.
    Here’s how an RTC plays a vital role in this scenario:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: RTCs最常见的一种应用是在数据记录中。想象一下，你正在设计一个收集温度、湿度和压力数据的气象站。准确的时间戳对于分析随时间变化趋势和模式至关重要。以下是RTCs在这个场景中发挥关键作用的方式：
- en: '**Initialization**: The RTC is initialized and set to the current time and
    date'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化**：RTCs被初始化并设置为当前时间和日期'
- en: '**Data collection**: Every time a sensor reading is taken, the RTC provides
    a timestamp'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据收集**：每次读取传感器数据时，RTCs都提供时间戳'
- en: '**Storage**: The sensor data, along with the timestamp, is stored in memory'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：传感器数据以及时间戳存储在内存中'
- en: '**Analysis**: When the data is retrieved for analysis, the timestamps ensure
    that each reading can be accurately placed on a timeline'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：当数据被检索用于分析时，时间戳确保每个读数可以准确地放置在时间线上'
- en: In this case, the RTC ensures that every piece of data is accurately timestamped,
    making it possible to track changes and trends with precision.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，RTCs确保每条数据都准确标记了时间戳，这使得可以精确跟踪变化和趋势。
- en: Case study 2 – alarm clocks
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 案例研究 2 – 闹钟
- en: 'RTCs are also fundamental in designing alarm clocks. Be it a simple bedside
    alarm clock or a complex scheduling system, the RTC provides the accurate timekeeping
    needed to trigger events at the right moment. Let’s look at a typical alarm clock
    scenario:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实时时钟（RTCs）在设计闹钟时也非常基本。无论是简单的床头闹钟还是复杂的调度系统，RTCs都提供了在正确时刻触发事件所需的精确计时功能。让我们看看一个典型的闹钟场景：
- en: '**Timekeeping**: The RTC keeps track of the current time, continuously updating
    the time registers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计时**：RTCs跟踪当前时间，持续更新时间寄存器。'
- en: '**Alarm setting**: The user sets an alarm for a specific time. This information
    is stored in the RTC alarm registers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟设置**：用户为特定时间设置闹钟。此信息存储在RTCs的闹钟寄存器中。'
- en: '**Alarm trigger**: When the RTC time matches the alarm time, an interrupt is
    triggered, activating the alarm mechanism (such as sounding a buzzer or turning
    on a light).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟触发**：当RTCs的时间与闹钟时间匹配时，会触发中断，激活闹钟机制（如发出蜂鸣声或打开灯光）。'
- en: In this case, the RTC ensures that the alarm goes off at the precise time set
    by the user, making it an essential component for reliable time-based alerts.
    At this point, your next question might be, “*What’s so special* *about RTCs?*”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，RTCs确保闹钟在用户设置的精确时间响起，使其成为可靠基于时间的警报的必要组件。此时，你可能会问，“*RTCs有什么特别之处吗？*”
- en: Why are RTCs important?
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么RTCs很重要？
- en: 'You might be wondering why we can’t just use the system clock or general-purpose
    timers for timekeeping. The answer lies in the RTC’s ability to keep accurate
    time, even when the main system is powered down. Here are some key reasons why
    RTCs are indispensable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不能仅仅使用系统时钟或通用定时器进行计时。答案在于RTCs即使在主系统断电时也能保持准确的时间，以下是RTC不可或缺的一些关键原因：
- en: '**Accuracy**: RTCs use crystal oscillators, which provide highly accurate timekeeping'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确性**：RTCs使用晶振振荡器，提供高度准确的时间计时'
- en: '**Low power consumption**: RTCs are designed to operate on very low power,
    often running for years on a small battery'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低功耗**：RTCs设计为在非常低的功耗下运行，通常可以在小型电池上运行数年'
- en: '**Battery backup**: RTCs continue to keep time even when the main power is
    off, thanks to their battery backup'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池备份**：由于电池备份，RTCs即使在主电源关闭时也能继续计时'
- en: '**Independence from the main system**: RTCs operate independently of the main
    microcontroller, ensuring continuous timekeeping'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立于主系统**：RTCs独立于主微控制器运行，确保连续计时'
- en: By understanding how RTCs work and their common use cases, we can appreciate
    their importance and effectively incorporate them into our embedded projects.
    Whether you’re building a simple alarm clock or a complex data logging system,
    the RTC is an important component that ensures your system always knows the right
    time. In the next section, we will explore the RTC peripheral in our STM32F411
    microcontroller.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解RTC的工作原理及其常见用例，我们可以欣赏它们的重要性，并有效地将它们纳入我们的嵌入式项目中。无论您是在构建一个简单的闹钟还是一个复杂的数据记录系统，RTC都是一个重要的组件，确保您的系统始终知道正确的时间。在下一节中，我们将探讨STM32F4微控制器中的RTC外设。
- en: The STM32 RTC module
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32 RTC模块
- en: In this section, we will explore the RTC module in the STM32F4 microcontroller
    family. Let’s start by looking at its features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨STM32F4微控制器系列中的RTC模块。让我们首先看看它的功能。
- en: The main features of the STM32F4 RTC module
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块的主要功能
- en: 'The STM32F4 RTC module is like the Swiss Army knife of timekeeping, offering
    a rich set of features designed to meet the needs of numerous applications. Here
    are some of the standout features:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块就像计时领域的瑞士军刀，提供了一组丰富的功能，旨在满足众多应用的需求。以下是一些突出的功能：
- en: '**Calendar with sub-seconds**: The RTC module doesn’t just keep track of hours,
    minutes, and seconds; it also maintains sub-second accuracy. This is particularly
    useful for applications that require precise time measurements.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有秒级的日历**：RTC模块不仅跟踪小时、分钟和秒，还保持秒级精度。这对于需要精确时间测量的应用特别有用。'
- en: '**Alarm functionality**: Imagine that you have two alarm clocks within your
    microcontroller. The STM32F4 RTC module provides two programmable alarms, **Alarm
    A** and **Alarm B**, which can trigger events at specific times. This is perfect
    for tasks that need to be performed at regular intervals or at a specific time
    of day.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闹钟功能**：想象一下，您在微控制器内部有两个闹钟。STM32F4 RTC模块提供了两个可编程的闹钟，**闹钟A**和**闹钟B**，可以在特定时间触发事件。这对于需要定期执行或在一天中的特定时间执行的任务来说非常完美。'
- en: '**Low power consumption**: One of the biggest advantages of the RTC module
    is its low power usage. This makes it ideal for battery-operated devices, where
    conserving power is paramount.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低功耗**：RTC模块最大的优点之一是其低功耗。这使得它非常适合电池供电的设备，在这些设备中，节省电力至关重要。'
- en: '**Backup domain**: The RTC can operate independently of the main power supply
    thanks to a backup battery. This means that even if your device loses power, the
    RTC keeps running, maintaining accurate time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份域**：RTC可以通过备用电池独立于主电源运行。这意味着即使您的设备断电，RTC也会继续运行，保持准确的时间。'
- en: '**Daylight saving time**: With the RTC module, you can program adjustments
    for daylight saving time automatically. No more manual resets twice a year!'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**夏令时**：使用RTC模块，您可以自动编程夏令时的调整。不再需要每年手动重置两次！'
- en: '**Automatic wakeup**: The RTC can generate periodic wakeup signals, bringing
    your system out of low-power modes at preset intervals. This feature is invaluable
    for applications that need to perform regular checks or updates.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动唤醒**：RTC可以生成周期性唤醒信号，在预设间隔将您的系统从低功耗模式唤醒。对于需要定期检查或更新的应用，这个特性非常有价值。'
- en: '**Tamper detection**: Security is a critical aspect of many applications, and
    the RTC module has you covered with tamper detection. It can log tamper events,
    providing an added layer of security for your system.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**篡改检测**：对于许多应用来说，安全性是一个关键方面，RTC模块通过篡改检测为您提供了保障。它可以记录篡改事件，为您的系统提供额外的安全层。'
- en: '**Digital calibration**: Accuracy is king when it comes to timekeeping. The
    RTC module includes a digital calibration feature to compensate for deviations
    in the crystal oscillator frequency, ensuring your timekeeping remains spot-on.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字校准**：在计时方面，精度是王道。RTC模块包括数字校准功能，以补偿晶振频率的偏差，确保您的计时保持精确无误。'
- en: '**Synchronization with external clocks**: To enhance precision, the RTC can
    synchronize with an external clock source. This is great for applications that
    need to maintain very high accuracy over long periods.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与外部时钟同步**：为了提高精度，RTC可以与外部时钟源同步。这对于需要长时间内保持非常高精度的应用来说非常棒。'
- en: Now, let’s analyze some of the key components of the STM32F4 RTC module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析STM32F4 RTC模块的一些关键组件。
- en: The key components of the STM32F4 RTC module
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 RTC模块的关键组件
- en: Let’s take a closer look at the key components of the RTC module in the STM32F4
    microcontroller family. We’ll break down each part to understand how they work
    together to provide accurate timekeeping and versatile functionality, starting
    with the clock sources.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看STM32F4微控制器系列中RTC模块的关键组件。我们将逐个分析每个部分，了解它们如何协同工作以提供准确的时间保持和多功能性，从时钟源开始。
- en: Clock sources
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时钟源
- en: 'The driver of the RTC module is its clock sources. *Figure 15**.1* presents
    a detailed block diagram of the RTC module, highlighting the RTC clock sources.
    This diagram, sourced from the reference manual, provides a clear visual representation
    of the various components and their interactions within the RTC module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: RTC模块的驱动器是其时钟源。*图15*.*1*展示了RTC模块的详细框图，突出了RTC时钟源。此图来自参考手册，提供了RTC模块中各种组件及其相互作用的清晰视觉表示：
- en: '![Figure 15.1: RTC block diagram with clock sources highlighted](img/B21914_15_1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：RTC模块框图，突出显示时钟源](img/B21914_15_1.jpg)'
- en: 'Figure 15.1: RTC block diagram with clock sources highlighted'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：RTC模块框图，突出显示时钟源
- en: 'The STM32F4 RTC can use multiple clock sources:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4 RTC可以使用多个时钟源：
- en: '**Low-speed external (LSE)**: A 32.768 kHz crystal oscillator known for its
    stability and low power consumption. This is typically the preferred clock source
    for accurate timekeeping.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低速外部（LSE）**：一个32.768 kHz的晶体振荡器，以其稳定性和低功耗而闻名。这通常是用于精确时间保持的首选时钟源。'
- en: '**Low-speed internal (LSI)**: An internal RC oscillator that provides a less
    accurate but convenient option when an external crystal is not available.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低速内部（LSI）**：一个内部RC振荡器，当外部晶体不可用时提供一种不太精确但方便的选项。'
- en: '**High-speed external (HSI)**: A high-speed clock source that can be used but
    is less common for RTC applications due to its higher power consumption.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高速外部（HSI）**：一个高速时钟源，虽然可以使用，但由于其较高的功耗，在RTC应用中不太常见。'
- en: 'The selected clock source feeds into the RTC’s prescalers, which are responsible
    for dividing the clock frequency into suitable levels for timekeeping:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的时钟源输入到RTC的预分频器，预分频器负责将时钟频率分频到适合时间保持的合适水平：
- en: '![Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers](img/B21914_15_2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：RTC模块框图 – 异步和同步预分频器](img/B21914_15_2.jpg)'
- en: 'Figure 15.2: RTC block diagram – asynchronous and synchronous prescalers'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：RTC模块框图 – 异步和同步预分频器
- en: Prescalers
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预分频器
- en: 'The RTC module employs two types of prescalers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: RTC模块采用两种类型的预分频器：
- en: '**Asynchronous prescaler**: This prescaler, typically set to divide by **128**,
    reduces the clock frequency to a lower rate that can be managed by the synchronous
    prescaler. It helps balance power consumption and accuracy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步预分频器**：此预分频器通常设置为除以**128**，降低时钟频率到一个较低的水平，可以被同步预分频器管理。它有助于平衡功耗和精度。'
- en: '**Synchronous prescaler**: Often configured to divide by **256**, this prescaler
    further reduces the clock frequency to generate a precise **1 Hz clock**, which
    is essential for updating the time and date registers accurately.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步预分频器**：通常配置为除以**256**，此预分频器进一步降低时钟频率以生成精确的**1 Hz时钟**，这对于准确更新时间和日期寄存器至关重要。'
- en: These prescalers ensure the RTC can operate efficiently, providing the necessary
    timekeeping precision while conserving power. Next, we have the time and date
    registers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预分频器确保RTC可以高效运行，提供必要的时间保持精度同时节省功耗。接下来，我们有时间和日期寄存器。
- en: Time and date registers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间和日期寄存器
- en: '*Figure 15**.3* highlights the time and date registers of the RTC block:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15*.*3*突出了RTC模块的时间和日期寄存器：'
- en: '![Figure 15.3: RTC block diagram – time and date registers](img/B21914_15_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：RTC模块框图 – 时间和日期寄存器](img/B21914_15_3.jpg)'
- en: 'Figure 15.3: RTC block diagram – time and date registers'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：RTC模块框图 – 时间和日期寄存器
- en: 'At the core of the RTC’s functionality are the time and date registers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: RTC的核心功能在于时间和日期寄存器：
- en: '**Time register (RTC_TR)**: This register holds the current time in hours,
    minutes, and seconds, stored in **Binary-Coded Decimal** (**BCD**) format. It
    is updated every second by the 1 Hz clock from the prescalers.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间寄存器（RTC_TR）**：此寄存器以二进制编码十进制（BCD）格式存储当前的小时、分钟和秒。它由预分频器的1 Hz时钟每秒更新。'
- en: '**Date register (RTC_DR)**: This register maintains the current date, including
    the year, month, and day, also in BCD format.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期寄存器（RTC_DR）**：此寄存器维护当前的日期，包括年、月和日，也以BCD格式存储。'
- en: These registers are crucial for maintaining accurate time and date information,
    which can be read and adjusted as needed. The next key component is the RTC alarm.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器对于维护准确的时间和日期信息至关重要，可以根据需要读取和调整。下一个关键组件是RTC报警。
- en: Alarms
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 报警
- en: 'The RTC module features two programmable alarms, Alarm A and Alarm B. These
    alarms can be set to trigger at specific times, providing a powerful tool for
    scheduling tasks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: RTC模块具有两个可编程报警，报警A和报警B。这些报警可以设置为在特定时间触发，为任务调度提供强大的工具：
- en: '`RTC_ALRMAR` and `RTC_ALRMBR`) to store the alarm time and date.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_ALRMAR`和`RTC_ALRMBR`用于存储报警时间和日期。'
- en: '**Interrupts**: When an alarm is triggered, it can generate an interrupt, waking
    up the microcontroller from a low-power state or initiating a specific function.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断**：当报警被触发时，它可以生成中断，从低功耗状态唤醒微控制器或启动特定功能。'
- en: 'The alarm modules are indicated in the following figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 报警模块在以下图中表示：
- en: '![Figure 15.4: RTC block diagram – alarms](img/B21914_15_4.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：RTC模块框图 – 报警](img/B21914_15_4.jpg)'
- en: 'Figure 15.4: RTC block diagram – alarms'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：RTC模块框图 – 报警
- en: Next, we have the wakeup timer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论唤醒定时器。
- en: Wakeup timer
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 唤醒定时器
- en: 'Another key feature of the RTC module is the wakeup timer, which is managed
    by the `RTC_WUTR` register:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: RTC模块的另一个关键特性是唤醒定时器，它由`RTC_WUTR`寄存器管理：
- en: '![Figure 15.5: RTC block diagram – wakeup timer](img/B21914_15_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5：RTC模块框图 – 唤醒定时器](img/B21914_15_5.jpg)'
- en: 'Figure 15.5: RTC block diagram – wakeup timer'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：RTC模块框图 – 唤醒定时器
- en: This **16-bit** auto-reload timer can generate periodic wakeup events, bringing
    the system out of low-power modes at regular intervals. It’s ideal for tasks such
    as sensor readings or system checks, ensuring efficient power usage.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**16位**自动重载定时器可以生成周期性唤醒事件，定期将系统从低功耗模式唤醒。它非常适合传感器读取或系统检查等任务，确保高效节能。
- en: There’s also the tamper detection module. Let’s take a look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还有篡改检测模块。让我们看看。
- en: Tamper detection
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 篡改检测
- en: Security is a vital aspect of many applications, and the RTC module includes
    tamper detection features. The tamper detection circuitry can log events when
    a tamper attempt is detected, using the timestamp registers to record the exact
    time and date. This adds an extra layer of security, especially in applications
    requiring reliable timekeeping and event logging. Next, we have the calibration
    register features.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是许多应用的一个关键方面，RTC模块包括篡改检测功能。当检测到篡改尝试时，篡改检测电路可以使用时间戳寄存器记录确切的时间和日期，从而增加一个额外的安全层，特别是在需要可靠的时间记录和事件记录的应用中。接下来，我们讨论校准寄存器功能。
- en: Calibration and synchronization
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 校准和同步
- en: 'To maintain high accuracy, the RTC module includes calibration features:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持高精度，RTC模块包括校准功能：
- en: '`RTC_CALR` register allows for fine adjustments to the clock frequency, compensating
    for any deviations in the crystal oscillator'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_CALR`寄存器允许对时钟频率进行精细调整，以补偿晶振的任何偏差'
- en: '**External clock synchronization**: The RTC can synchronize with an external
    clock source, enhancing accuracy by periodically adjusting the internal clock
    so that it matches the external reference'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部时钟同步**：RTC可以与外部时钟源同步，通过定期调整内部时钟以匹配外部参考来提高精度'
- en: These features ensure the RTC maintains precise timekeeping, even in varying
    environmental conditions. We also have the backup and control registers module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能确保RTC即使在不同的环境条件下也能保持精确的时间记录。我们还有备份和控制寄存器模块。
- en: Backup and control registers
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份和控制寄存器
- en: 'The RTC module includes several backup and control registers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: RTC模块包括几个备份和控制寄存器：
- en: '**Backup registers**: These registers store critical data that must be retained
    even when the main power supply is off'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份寄存器**：这些寄存器存储必须保留的关键数据，即使在主电源关闭时也是如此'
- en: '`RTC_CR`) manage the configuration and operation of the RTC, including enabling
    the clock, setting alarms, and configuring wakeup events'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_CR`寄存器用于管理RTC的配置和操作，包括启用时钟、设置报警和配置唤醒事件'
- en: 'The backup and control registers module is indicated in the following figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 备份和控制寄存器模块在以下图中表示：
- en: '![Figure 15.6: RTC block diagram – backup and control registers](img/B21914_15_6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6：RTC模块框图 – 备份和控制寄存器](img/B21914_15_6.jpg)'
- en: 'Figure 15.6: RTC block diagram – backup and control registers'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：RTC模块框图 – 备份和控制寄存器
- en: Finally, there is the output control block.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是输出控制块。
- en: Output control
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出控制
- en: The RTC module can output specific signals, such as a calibration clock or alarm
    outputs, through the `RTC_AF1` pin. This allows the RTC module to interact with
    other components or systems, providing synchronized signals or triggering external
    events.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: RTC 模块可以通过 `RTC_AF1` 引脚输出特定信号，例如校准时钟或闹钟输出。这使得 RTC 模块能够与其他组件或系统交互，提供同步信号或触发外部事件。
- en: In the next section, we will analyze some of the key registers for configuring
    the RTC peripheral.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析一些配置 RTC 外设的关键寄存器。
- en: Some key RTC registers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些关键的 RTC 寄存器
- en: In this section, we will explore the characteristics and functions of some of
    the important registers within the RTC module. These registers are the building
    blocks that allow us to configure, control, and utilize the RTC’s features effectively.
    Let’s start with the `RTC_TR`).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 RTC 模块中一些重要寄存器的特性和功能。这些寄存器是构建块，使我们能够有效地配置、控制和利用 RTC 的功能。让我们从 `RTC_TR`）开始。
- en: RTC Time Register (RTC_TR)
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC 时间寄存器 (RTC_TR)
- en: 'The `RTC_TR` register is responsible for keeping track of the current time.
    It maintains the hours, minutes, and seconds in BCD format, ensuring that time
    is easily readable and manipulable. Here are some of the key fields in this register:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_TR` 寄存器负责跟踪当前时间。它以 BCD 格式维护小时、分钟和秒，确保时间易于阅读和操作。以下是该寄存器中的一些关键字段：'
- en: '**Hour tens (HT) and hour units (HU)**: These bits represent the tens and units
    of the hour, respectively. They can handle both **24-hour** and **12-hour** formats.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小时十位 (HT) 和小时个位 (HU)**：这些位分别代表小时的十位和个位。它们可以处理 **24 小时** 和 **12 小时** 格式。'
- en: '**Minute tens (MNT) and minute units (MNU)**: These bits represent the tens
    and units of the minutes.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分钟十位 (MNT) 和分钟个位 (MNU)**：这些位代表分钟的十位和个位。'
- en: '**Second tens (ST) and second units (SU)**: These bits represent the tens and
    units of the seconds.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秒十位 (ST) 和秒个位 (SU)**：这些位代表秒的十位和个位。'
- en: '**PM**: This bit indicates the **AM/PM** notation when in **12-hour** format.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PM**：此位在 **12 小时** 格式下指示 **AM/PM** 标记。'
- en: Further information about this register can be found on *page 450* of the *reference
    manual*. Let’s move on to the `RTC_DR`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此寄存器的更多信息可以在 *参考手册* 的 *第 450 页* 找到。让我们继续到 `RTC_DR`）。
- en: RTC Date Register (RTC_DR)
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC 日期寄存器 (RTC_DR)
- en: The `RTC_DR` register is responsible for maintaining the current date. It keeps
    track of the year, month, day of the month, and day of the week, all in BCD format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_DR` 寄存器负责维护当前日期。它跟踪年份、月份、月份中的日期和星期几，所有这些都在 BCD 格式下。'
- en: 'The following are the key fields in this register:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该寄存器中的关键字段：
- en: '**Year tens (YT) and year units YU)**: These bits represent the tens and units
    of the year'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**年份十位 (YT) 和年份个位 YU)**：这些位代表年份的十位和个位'
- en: '**Month tens (MT) and month units (MU)**: These bits represent the tens and
    units of the month'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**月份十位 (MT) 和月份个位 (MU)**：这些位代表月份的十位和个位'
- en: '**Date tens (DT) and date units (DU)**: These bits represent the tens and units
    of the day of the month'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期十位 (DT) 和日期个位 (DU)**：这些位代表月份中的日期的十位和个位'
- en: '**Week day units (WDU)**: This bit represents the day of the week (1 to 7)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**星期几个位 (WDU)**：此位代表星期几（1 到 7）'
- en: You can read more about this register on *page 451* of the *reference manual*.
    The next crucial register is the `RTC_CR`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *参考手册* 的 *第 451 页* 上了解更多关于此寄存器的信息。下一个关键寄存器是 `RTC_CR`）。
- en: RTC Control Register (RTC_CR)
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC 控制寄存器 (RTC_CR)
- en: The `RTC_CR` register is where we control the various operational modes and
    features of the RTC. This register allows us to enable the RTC, configure alarms,
    and set up the wakeup timer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_CR` 寄存器是我们控制 RTC 的各种操作模式和功能的地方。此寄存器允许我们启用 RTC、配置闹钟和设置唤醒定时器。'
- en: 'Let’s consider the key bits in this register:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个寄存器中的关键位：
- en: '**WUTE**: Enable the wakeup timer. This bit enables the RTC wakeup timer.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WUTE**：启用唤醒定时器。此位启用 RTC 唤醒定时器。'
- en: '**TSE**: Enable a timestamp event. This bit enables the timestamping of events.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TSE**：启用时间戳事件。此位启用事件的标记。'
- en: '**ALRAE and ALRBE**: Enable Alarm A and Alarm B. These bits enable the respective
    alarms.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALRAE 和 ALRBE**：启用闹钟 A 和闹钟 B。这些位启用相应的闹钟。'
- en: '**DCE**: Enable digital calibration. This bit enables digital calibration of
    the RTC clock.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DCE**：启用数字校准。此位启用 RTC 时钟的数字校准。'
- en: '**FMT**: Hour format. This bit sets the hour format to either 24-hour or 12-hour
    (AM/PM).'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMT**：小时格式。此位将小时格式设置为 24 小时或 12 小时（AM/PM）。'
- en: Further details about this register can be found on *page 453* of the *reference
    manual*. Next, we have the `RTC_ISR`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于此寄存器的详细信息可以在 *参考手册的第 453 页* 上找到。接下来，我们有 `RTC_ISR`)。
- en: RTC Initialization and Status Register (RTC_ISR)
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时时钟初始化和状态寄存器 (RTC_ISR)
- en: 'The `RTC_ISR` register plays a dual role in both initializing the RTC and monitoring
    its status. This register is crucial during the setup process and for checking
    the RTC’s current state. Here are the key bits in this register:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_ISR` 寄存器在初始化实时时钟和监控其状态方面发挥着双重作用。在设置过程中以及检查实时时钟当前状态时，此寄存器至关重要。以下是此寄存器中的关键位：'
- en: '**INIT**: Initialization mode. Setting this bit puts RTC into initialization
    mode.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INIT**：初始化模式。设置此位将实时时钟置于初始化模式。'
- en: '**RSF**: Registers synchronization flag. This bit indicates that the calendar
    registers are synchronized.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSF**：寄存器同步标志。此位指示日历寄存器已同步。'
- en: '**INITS**: Initialization status flag. This bit indicates whether the RTC calendar
    has been initialized.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INITS**：初始化状态标志。此位指示实时时钟日历是否已初始化。'
- en: '**ALRAF and ALRBF**: Alarm A and Alarm B flags. These bits indicate whether
    an alarm has been triggered.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALRAF 和 ALRBF**：报警 A 和报警 B 标志。这些位指示是否已触发报警。'
- en: Next, we have the `RTC_PRER`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `RTC_PRER`)。
- en: RTC Prescaler Register (RTC_PRER)
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时时钟预分频器寄存器 (RTC_PRER)
- en: 'The `RTC_PRER` register manages the prescalers that divide the RTC clock source
    to produce the 1 Hz clock necessary for accurate timekeeping. There are two key
    fields in this register:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_PRER` 寄存器管理预分频器，这些预分频器将实时时钟时钟源分频以产生用于精确时间保持的 1 Hz 时钟。此寄存器中有两个关键字段：'
- en: '**PREDIV_A**: Asynchronous prescaler. This field sets the value for the asynchronous
    prescaler.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PREDIV_A**：异步预分频器。此字段设置异步预分频器的值。'
- en: '**PREDIV_S**: Synchronous prescaler. This field sets the value for the synchronous
    prescaler.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PREDIV_S**：同步预分频器。此字段设置同步预分频器的值。'
- en: Configuring the `RTC_PRER` register properly is vital for maintaining the accuracy
    of the RTC.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正确配置 `RTC_PRER` 寄存器对于保持实时时钟的准确性至关重要。
- en: Next, we’ll look at the RTC Alarm Registers, `RTC_ALRMAR` and `RTC_ALRMBR`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看实时时钟报警寄存器，`RTC_ALRMAR` 和 `RTC_ALRMBR`。
- en: RTC Alarm Registers (RTC_ALRMAR and RTC_ALRMBR)
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时时钟报警寄存器 (RTC_ALRMAR 和 RTC_ALRMBR)
- en: 'These registers handle the configuration of Alarms A and B. They allow us to
    set specific times when the alarms should trigger. Here are the key fields in
    these registers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器处理报警 A 和 B 的配置。它们允许我们设置报警应触发的特定时间。以下是这些寄存器中的关键字段：
- en: '**ALRMASK**: Alarm mask bits. These bits allow you to mask certain parts of
    the alarm time, providing flexibility in how and when the alarms trigger.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALRMASK**：报警掩码位。这些位允许您掩码报警时间的某些部分，从而在如何以及何时触发报警方面提供灵活性。'
- en: '**ALRH, ALRMN, and ALRS**: Hour, minute, and second fields. These fields set
    the specific time for the alarm.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ALRH, ALRMN, 和 ALRS**：小时、分钟和秒字段。这些字段设置报警的具体时间。'
- en: The `RTC_ALRMAR` and `RTC_ALRMBR` registers are vital for applications requiring
    reliable, time-based event triggering. Lastly, let’s explore the `RTC_WUTR`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_ALRMAR` 和 `RTC_ALRMBR` 寄存器对于需要可靠基于时间的触发事件的应用至关重要。最后，让我们来探讨 `RTC_WUTR`)。'
- en: RTC Wakeup Timer Register (RTC_WUTR)
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时时钟唤醒定时器寄存器 (RTC_WUTR)
- en: The `RTC_WUTR` register configures the wakeup timer, enabling the RTC to periodically
    wake the system from low-power modes. The key field in this register is the **wakeup
    auto-reload value** (**WUT**). This field sets the interval for the wakeup timer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`RTC_WUTR` 寄存器配置唤醒定时器，使实时时钟能够定期从低功耗模式唤醒系统。此寄存器中的关键字段是 **唤醒自动重载值**（**WUT**）。此字段设置唤醒定时器的间隔。'
- en: In the next section, we will apply everything we’ve learned in this section
    to develop a driver for the RTC peripheral.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将应用本节学到的所有知识来开发实时时钟外设的驱动程序。
- en: Developing the RTC driver
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发实时时钟驱动程序
- en: In this section, we will develop the RTC calendar driver so that we can configure
    and keep track of the time and date.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发实时时钟日历驱动程序，以便我们可以配置和跟踪时间和日期。
- en: As always, we will create a copy of our previous project while following the
    steps outlined in earlier chapters. We rename this copied project to `RTC_Calendar`.
    Next, create a new file named `rtc.c` in the `Src` folder and another file named
    `rtc.h` in the `Inc` folder. The RTC configuration can be quite elaborate, so
    we will create several helper functions to modularize the initialization process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们将遵循前面章节中概述的步骤创建我们之前项目的副本。我们将此复制的项目重命名为`RTC_Calendar`。接下来，在`Src`文件夹中创建一个名为`rtc.c`的新文件，并在`Inc`文件夹中创建一个名为`rtc.h`的新文件。RTC配置可能相当复杂，因此我们将创建几个辅助函数来模块化初始化过程。
- en: The RTC implementation file
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTC实现文件
- en: 'Let’s begin by populating the `rtc.c` file, starting with the helper functions
    necessary for the initialization function. Here are the macro definitions that
    we will use in the RTC configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从填充`rtc.c`文件开始，首先是初始化函数所需的辅助函数。以下是我们在RTC配置中将要使用的宏定义：
- en: '[PRE0]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break them down:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析：
- en: '`PWREN` (`1U << 28`): This macro enables the clock for the PWR module by setting
    bit 28 in the APB1 peripheral clock enable register.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWREN` (`1U << 28`): 此宏通过在APB1外设时钟使能寄存器中设置位28来启用PWR模块的时钟。'
- en: '`CR_DBP` (`1U << 8`): This enables access to the backup domain by setting bit
    8 in the PWR register.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR_DBP` (`1U << 8`): 此函数通过在PWR寄存器中设置位8来启用对备份域的访问。'
- en: '`CSR_LSION` (`1U << 0`): This macro enables the LSI oscillator by setting bit
    0 in the Clock Control & Status Register.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSR_LSION` (`1U << 0`): 此宏通过在时钟控制与状态寄存器中设置位0来启用LSI振荡器。'
- en: '`CSR_LSIRDY` (`1U << 1`): This macro is used to read the state of the `LSI`
    register. The LSIRDY bit is set to 1 when the LSI is stable and ready to be used.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CSR_LSIRDY` (`1U << 1`): 此宏用于读取`LSI`寄存器的状态。当`LSI`稳定且准备好使用时，LSIRDY位被设置为1。'
- en: '`BDCR_BDRST` (`1U << 16`): This macro forces a reset of the backup domain by
    setting bit 16 in the Backup Domain Control Register.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BDCR_BDRST` (`1U << 16`): 此宏通过在备份域控制寄存器中设置位16来强制重置备份域。'
- en: '`BDCR_RTCEN` (`1U << 15`): This enables RTC by setting bit 15 in the Backup
    Domain Control Register.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BDCR_RTCEN` (`1U << 15`): 通过在备份域控制寄存器中设置位15来启用RTC。'
- en: '`RTC_WRITE_PROTECTION_KEY_1` (`(uint8_t)0xCAU`): This key is used to disable
    write protection on the RTC registers.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_WRITE_PROTECTION_KEY_1` (`(uint8_t)0xCAU`): 此密钥用于禁用RTC寄存器的写保护。'
- en: '`RTC_WRITE_PROTECTION_KEY_2` (`(uint8_t)0x53U`): This is the second key needed
    to disable write protection on the RTC registers.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_WRITE_PROTECTION_KEY_2` (`(uint8_t)0x53U`): 这是禁用RTC寄存器写保护所需的第二个密钥。'
- en: '`RTC_INIT_MASK` (`0xFFFFFFFFU`): This mask is used to enter initialization
    mode in the RTC peripheral.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_INIT_MASK` (`0xFFFFFFFFU`): 此掩码用于将RTC外设进入初始化模式。'
- en: '`ISR_INITF` (`1U << 6`): This bit in the `ISR` register indicates that the
    RTC peripheral is in initialization mode.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISR_INITF` (`1U << 6`): `ISR`寄存器中的此位指示RTC外设处于初始化模式。'
- en: '`WEEKDAY_FRIDAY` (`(uint8_t)0x05U`): This macro is used to configure the weekday
    of the calendar to Friday.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WEEKDAY_FRIDAY` (`(uint8_t)0x05U`): 此宏用于配置日历的星期为星期五。'
- en: '`MONTH_DECEMBER` (`(uint8_t)0x12U`): This macro is used to configure the month
    of the calendar to December.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MONTH_DECEMBER` (`(uint8_t)0x12U`): 此宏用于配置日历的月份为十二月。'
- en: '`TIME_FORMAT_PM` (`1U << 22`): This macro sets the time format to PM in the
    12-hour format.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME_FORMAT_PM` (`1U << 22`): 此宏将12小时制中的时间格式设置为下午。'
- en: '`CR_FMT` (`1U << 6`): This macro sets the hour format to 24-hour format in
    the RTC control register (`RTC->CR`).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CR_FMT` (`1U << 6`): 此宏在RTC控制寄存器（`RTC->CR`）中将小时格式设置为24小时格式。'
- en: '`ISR_RSF` (`1U << 5`): This bit in the `ISR` register indicates that the RTC
    registers are synchronized.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISR_RSF` (`1U << 5`): `ISR`寄存器中的此位指示RTC寄存器已同步。'
- en: '`RTC_ASYNCH_PREDIV` (`(uint32_t)0x7F`): This value sets the asynchronous prescaler
    for the RTC peripheral and is used to divide the clock frequency.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_ASYNCH_PREDIV` (`(uint32_t)0x7F`): 此值设置RTC外设的异步预分频，并用于分频时钟频率。'
- en: '`RTC_SYNCH_PREDIV` (`(uint32_t)0x00F9`): This value sets the synchronous prescaler
    for the RTC peripheral and is used to further divide the clock frequency for timekeeping
    accuracy.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_SYNCH_PREDIV` (`(uint32_t)0x00F9`): 此值设置RTC外设的同步预分频，并用于进一步分频时钟频率以提高时间保持精度。'
- en: Let’s examine the two functions responsible for setting the prescaler values
    for the RTC peripheral.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查负责设置RTC外设预分频值的两个函数。
- en: 'First, we have `rtc_set_asynch_prescaler`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`rtc_set_asynch_prescaler`：
- en: '[PRE1]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This function sets the asynchronous prescaler value for the RTC peripheral.
    Let’s break it down:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数设置RTC外设的异步预分频值。让我们逐一分析：
- en: '`MODIFY_REG`: This macro modifies specific bits in a register. It is defined
    in the `stm32f4xx.h` header file.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODIFY_REG`：此宏修改寄存器中的特定位。它在`stm32f4xx.h`头文件中定义。'
- en: '`RTC->PRER`: The `PRER` register of the RTC.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC->PRER`：RTC的`PRER`寄存器。'
- en: '`RTC_PRER_PREDIV_A`: The mask for the asynchronous prescaler bits in the `PRER`
    register.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_PRER_PREDIV_A`：`PRER`寄存器中异步预分频器位的掩码。'
- en: '`AsynchPrescaler << RTC_PRER_PREDIV_A_Pos`: This snippet shifts the `AsynchPrescaler`
    value to the correct position within the `PRER` register.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchPrescaler << RTC_PRER_PREDIV_A_Pos`：此片段将`AsynchPrescaler`值移位到`PRER`寄存器中的正确位置。'
- en: 'In short, this function configures the asynchronous prescaler by updating the
    appropriate bits in the `PRER` register. Next, we have the function for setting
    the synchronous prescaler – that is, `rtc_set_synch_prescaler`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，此函数通过更新`PRER`寄存器中的适当位来配置异步预分频器。接下来，我们有设置同步预分频器的函数——即`rtc_set_synch_prescaler`：
- en: '[PRE2]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function configures the synchronous prescaler by updating the appropriate
    bits in the `PRER` register:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过更新`PRER`寄存器中的适当位来配置同步预分频器：
- en: '`RTC->PRER`: The `PRER` register of the RTC'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC->PRER`：RTC的`PRER`寄存器'
- en: '`RTC_PRER_PREDIV_S`: This is the mask for the synchronous prescaler bits in
    the `PRER` register'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_PRER_PREDIV_S`：这是`PRER`寄存器中同步预分频器位的掩码'
- en: '`SynchPrescaler`: This directly sets the synchronous prescaler value in the
    `PRER` register'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchPrescaler`：此直接在`PRER`寄存器中设置同步预分频器值'
- en: Next, we must analyze the other RTC initialization helper functions to understand
    how they work together to configure and synchronize the RTC peripheral.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须分析其他RTC初始化辅助函数，以了解它们如何协同工作来配置和同步RTC外设。
- en: 'First, we have the `_rtc_enable_init_mode` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`_rtc_enable_init_mode`函数：
- en: '[PRE3]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Simply put, this function sets the RTC peripheral to initialization mode by
    writing the initialization mask to the `ISR` register:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，此函数通过将初始化掩码写入`ISR`寄存器来将RTC外设设置为初始化模式：
- en: '`RTC->ISR`: This is the `RTC_ISR` register of the RTC'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC->ISR`：这是RTC的`RTC_ISR`寄存器'
- en: '`RTC_INIT_MASK`: This mask is used to enter initialization mode'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_INIT_MASK`：此掩码用于进入初始化模式'
- en: 'Next, we have `_rtc_disable_init_mode`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`_rtc_disable_init_mode`：
- en: '[PRE4]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function disables initialization mode by clearing the initialization mask
    in the ISR register. Here, `~RTC_INIT_MASK` clears the initialization mask, exiting
    initialization mode.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过清除ISR寄存器中的初始化掩码来禁用初始化模式。在这里，`~RTC_INIT_MASK`清除初始化掩码，退出初始化模式。
- en: 'The next helper function is `_rtc_isActiveflag_init`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个辅助函数是`_rtc_isActiveflag_init`：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function returns 1 if the RTC peripheral is in initialization mode by checking
    the `ISR_INITF` bit, which indicates that the RTC peripheral is in initialization
    mode.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过检查`ISR_INITF`位来返回1，该位指示RTC外设处于初始化模式。
- en: 'Next, we have `_rtc_isActiveflag_rs`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`_rtc_isActiveflag_rs`：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function returns 1 if the RTC registers are synchronized by checking the
    `ISR_RSF` bit, which indicates that the RTC registers are synchronized.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过检查`ISR_RSF`位来返回1，该位指示RTC寄存器已同步。
- en: 'There’s also the `rtc_init_seq` function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`rtc_init_seq`函数：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function starts the RTC initialization by enabling initialization mode
    and waiting until the RTC peripheral enters initialization mode:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过启用初始化模式并等待RTC外设进入初始化模式来启动RTC初始化：
- en: '`_rtc_enable_init_mode`: This line puts the RTC peripheral into initialization
    mode'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rtc_enable_init_mode`：此行将RTC外设置于初始化模式'
- en: '`_rtc_isActiveflag_init`: This line waits until the RTC peripheral is in initialization
    mode'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_rtc_isActiveflag_init`：此行等待直到RTC外设处于初始化模式'
- en: 'Next, we have the `wait_for_synchro` function:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`wait_for_synchro`函数：
- en: '[PRE8]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function clears the synchronization flag and waits until the RTC registers
    are synchronized.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数清除同步标志并等待直到RTC寄存器同步。
- en: 'We also have the `exit_init_seq` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`exit_init_seq`函数：
- en: '[PRE9]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function exits the RTC initialization mode and waits for the registers
    to synchronize to ensure everything is set up correctly. Now, let’s see the functions
    for configuring the date and time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数退出RTC初始化模式，并等待寄存器同步，以确保一切设置正确。现在，让我们看看配置日期和时间的函数。
- en: 'First, we have `rtc_date_config`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`rtc_date_config`：
- en: '[PRE10]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function sets the date in the RTC peripheral.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数设置RTC外设的日期。
- en: 'We begin by creating a temporary variable called `temp` to hold the date value.
    This variable is carefully constructed by shifting and combining the weekday,
    day, month, and year into the appropriate positions for the RTC’s date register.
    The `MODIFY_REG` macro is then used to update the RTC’s date register with this
    new value. Here, we can have the following values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为 `temp` 的临时变量来保存日期值。这个变量通过将星期几、日、月和年移位并组合到 RTC 日期寄存器的适当位置来仔细构建。然后使用
    `MODIFY_REG` 宏更新 RTC 的日期寄存器，使用这个新值。在这里，我们可以有以下值：
- en: '`WeekDay`: Represents the day of the week'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeekDay`：表示星期几'
- en: '`Day`: Represents the day of the month'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Day`：表示月份中的日'
- en: '`Month`: Represents the month of the year'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Month`：表示年份中的月'
- en: '`Year`: Represents the year'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Year`：表示年份'
- en: In essence, `rtc_date_config` takes the date components, assembles them into
    a single value, and writes it to the RTC’s date register, ensuring the RTC peripheral
    accurately tracks the current date.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`rtc_date_config` 将日期组件组合成一个单一值，并将其写入 RTC 的日期寄存器，确保 RTC 外设准确跟踪当前日期。
- en: 'We have the `rtc_time_config` function for configuring the time:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `rtc_time_config` 函数用于配置时间：
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function sets the time in the RTC peripheral. Much like the date configuration,
    `rtc_time_config` begins by initializing a temporary variable, `temp`, to hold
    the time value. The time components – format, hours, minutes, and seconds – are
    then combined into this variable. The `MODIFY_REG` macro updates the RTC’s time
    register with the newly constructed time value. Here, we have the following additional
    values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设置 RTC 外设中的时间。与日期配置类似，`rtc_time_config` 首先初始化一个临时变量 `temp` 来保存时间值。然后将时间组件——格式、小时、分钟和秒——组合到这个变量中。`MODIFY_REG`
    宏更新 RTC 的时间寄存器，使用新构造的时间值。在这里，我们还有以下额外的值：
- en: '`Format12_24`: This determines whether the time is in 12-hour or 24-hour format'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Format12_24`：这决定了时间是在 12 小时还是 24 小时格式'
- en: '`Hours`: Represents the hour value'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hours`：表示小时值'
- en: '`Minutes`: Represents the minute value'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minutes`：表示分钟值'
- en: '`Seconds`: Represents the second value'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seconds`：表示秒值'
- en: 'Now that we’ve implemented all the helper functions required for initialization,
    let’s go ahead and implement the `rtc_init()` function:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了初始化所需的全部辅助函数，让我们继续实现 `rtc_init()` 函数：
- en: '[PRE12]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s break it down:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '[PRE13]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start by enabling the clock for the PWR module. This is crucial as it allows
    us to access and configure the RTC peripheral:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先启用 PWR 模块的时钟。这一点至关重要，因为它允许我们访问和配置 RTC 外设：
- en: '[PRE14]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we must enable access to the backup domain. This step is necessary to
    make changes to the RTC configuration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须启用对备份域的访问。这一步是必要的，以便更改 RTC 配置：
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we enable the LSI oscillator, which serves as the clock source for the
    RTC peripheral:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启用 LSI 振荡器，它作为 RTC 外设的时钟源：
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We must wait until the LSI oscillator is stable and ready to use:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须等待直到 LSI 振荡器稳定并准备好使用：
- en: '[PRE17]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To ensure a clean configuration, we must force a reset of the backup domain:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保配置干净，我们必须强制备份域复位：
- en: '[PRE18]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we must release the reset, allowing the backup domain to function normally:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须释放复位，允许备份域正常工作：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After, we must configure the RTC peripheral so that it uses the LSI oscillator
    as its clock source:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须配置 RTC 外设，使其使用 LSI 振荡器作为其时钟源：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we must enable the RTC peripheral by setting the appropriate bit in the
    backup domain control register:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须通过设置备份域控制寄存器中的适当位来启用 RTC 外设：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To allow changes to the RTC registers, we must disable write protection:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许更改 RTC 寄存器，我们必须禁用写保护：
- en: '[PRE22]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can enter initialization mode using our `rtc_init_seq()` helper function.
    If it fails, we must handle the error appropriately:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的 `rtc_init_seq()` 辅助函数进入初始化模式。如果它失败，我们必须适当地处理错误：
- en: '[PRE23]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, we must configure the RTC peripheral to the desired date using
    another one of our helper functions. In this example, we will set the date to
    *Friday, December* *29, 2016*:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们必须使用我们的另一个辅助函数将 RTC 外设配置为所需的日期。在这个例子中，我们将日期设置为 *2016 年 12 月 29 日星期五*：
- en: '[PRE24]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we must set the RTC peripheral to the desired time. In this case, we
    will set the time to *11:59:55 P.M.*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将 RTC 外设设置为所需的日期。在这种情况下，我们将时间设置为 *晚上 11:59:55*：
- en: '[PRE25]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we must configure the RTC peripheral so that it uses a 24-hour format:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置 RTC 外设，使其使用 24 小时格式：
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we must set the asynchronous and synchronous prescaler values:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须设置异步和同步预分频器的值：
- en: '[PRE27]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, we can exit initialization mode using the `exit_init_seq()`
    helper function we created earlier:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用我们之前创建的 `exit_init_seq()` 辅助函数退出初始化模式：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finally, we must re-enable write protection on the RTC registers to prevent
    accidental changes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须重新启用 RTC 寄存器的写保护，以防止意外更改。
- en: This `rtc_init` function meticulously sets up the RTC peripheral by enabling
    the necessary clock, configuring the backup domain, setting the RTC clock source,
    and initializing the date and time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `rtc_init` 函数仔细地通过启用必要的时钟、配置备份域、设置 RTC 时钟源和初始化日期和时间来设置 RTC 外设。
- en: Before moving on to the `main.c` file, let’s implement a few helper functions
    that are essential for handling various RTC tasks, such as converting values and
    getting the current date and time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到 `main.c` 文件之前，让我们实现一些辅助函数，这些函数对于处理各种 RTC 任务至关重要，例如转换值和获取当前日期和时间。
- en: 'Let’s start with the `rtc_convert_dec2bcd` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `rtc_convert_dec2bcd` 函数开始：
- en: '[PRE29]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function takes a decimal value and returns its equivalent in BCD format,
    which is useful for setting RTC values.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个十进制值并返回其等效的 BCD 格式，这对于设置 RTC 值很有用。
- en: 'Let’s take a closer look at decimal to BCD conversion:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看十进制到 BCD 的转换：
- en: First, `((value) / 10U) << 4U` shifts the tens digit to the left by 4 bits
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`((value) / 10U) << 4U` 将十位数字左移 4 位
- en: Then, `((value) % 10U)` gets the units digit
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`((value) % 10U)` 获取个位数字
- en: The `OR` operation combines these two to form the BCD value
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OR` 操作将这两个值组合起来形成 BCD 值'
- en: Before going any further, let’s take a closer look at the BCD format and the
    conversion process.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们更仔细地看看 BCD 格式和转换过程。
- en: Understanding BCD format
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 BCD 格式
- en: 'BCD is a way of representing decimal numbers in binary form. But here’s the
    twist: instead of converting the whole number into a single binary value, each
    decimal digit is represented by its own binary sequence.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: BCD 是一种以二进制形式表示十进制数字的方法。但这里有一个转折：不是将整个数字转换成一个单一的二进制值，而是每个十进制数字都由其自己的二进制序列表示。
- en: How does BCD work?
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BCD 是如何工作的？
- en: In BCD, each digit of a decimal number is encoded separately as a 4-bit binary
    number. Let’s break it down with an example to make it clearer.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BCD 中，十进制数字的每一位都是单独编码为 4 位二进制数的。让我们用一个例子来详细说明。
- en: 'Say you have the decimal number *42*. In BCD, this would be represented as
    follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个十进制数字 *42*。在 BCD 中，这将如下表示：
- en: '*4* in decimal is *0100* in binary'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制中的 *4* 是二进制中的 *0100*
- en: '*2* in decimal is *0010* in binary'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制中的 *2* 是二进制中的 *0010*
- en: So, 42 in BCD is *0100 0010*. Notice how each decimal digit is converted into
    a 4-bit binary form and then combined to represent the entire number.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，42 在 BCD 中是 *0100 0010*。注意每个十进制数字是如何转换为 4 位二进制形式，然后组合起来表示整个数字的。
- en: Why use BCD?
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用 BCD？
- en: 'You might be wondering, why not just use regular binary? Well, BCD has its
    perks, especially in digital systems that need to display numbers or interface
    with human-readable formats:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么不直接使用常规的二进制？嗯，BCD 有其优点，尤其是在需要显示数字或与人类可读格式接口的数字系统中：
- en: '**Ease of conversion**: Converting between BCD and decimal is straightforward.
    Each 4-bit group corresponds directly to a decimal digit, making it easy to read
    and convert.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换简单**：在 BCD 和十进制之间进行转换很简单。每个 4 位组直接对应一个十进制数字，这使得读取和转换变得容易。'
- en: '**Display compatibility**: Devices such as digital clocks, calculators, and
    other numeric displays often use BCD because it simplifies the process of converting
    binary values into a form that can be easily shown on a screen.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示兼容性**：像数字时钟、计算器和其他数字显示设备这样的设备通常使用 BCD，因为它简化了将二进制值转换为屏幕上易于显示的格式的过程。'
- en: Now, let’s see how this relates to RTCs.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这与 RTC 有什么关系。
- en: BCD in RTC configurations
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RTC 配置中的 BCD
- en: 'When working with RTCs, BCD is particularly handy. The RTC hardware often uses
    BCD to store time and date values because it simplifies how these values can be
    displayed and manipulated. For instance, setting the time to *12:34:56* in BCD
    means we have the following representations:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 RTC 一起工作时，BCD 特别有用。RTC 硬件通常使用 BCD 来存储时间和日期值，因为它简化了这些值的显示和操作方式。例如，将时间设置为 BCD
    的 *12:34:56* 意味着我们有以下表示：
- en: '*12* is *0001 0010*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*12* 是 *0001 0010*'
- en: '*34* is *0011 0100*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*34* 是 *0011 0100*'
- en: '*56* is *0101 0110*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*56* 是 *0101 0110*'
- en: Each of these pairs is easy to interpret and convert back into decimal for display
    or further processing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些每一对都很容易解释，并可以轻松转换回十进制以进行显示或进一步处理。
- en: 'BCD format is a clever way of encoding decimal numbers in a binary system.
    By handling each decimal digit separately, BCD simplifies many operations, especially
    when interfacing with human-readable displays or systems that require precise
    decimal representation. *Figure 15**.6* illustrates how BCD values can easily
    be mapped onto digital displays:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: BCD格式是一种在二进制系统中编码十进制数字的巧妙方法。通过单独处理每个十进制数字，BCD简化了许多操作，尤其是在与可读性强的显示或需要精确十进制表示的系统接口时。*图15**.6*展示了BCD值如何轻松映射到数字显示上：
- en: '![Figure 15.7: Display with BCD format](img/B21914_15_7.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7：BCD格式的显示](img/B21914_15_7.jpg)'
- en: 'Figure 15.7: Display with BCD format'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：BCD格式的显示
- en: 'Now, let’s analyze the `rtc_convert_bcd2dec` function:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析`rtc_convert_bcd2dec`函数：
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function takes a BCD value and returns its decimal equivalent, making it
    easier to work with RTC data in a decimal format.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收一个BCD值并返回其十进制等效值，使得在十进制格式下处理RTC数据更加容易。
- en: 'Here’s the BCD to decimal conversion for this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是BCD到十进制的转换：
- en: First, `((value) & (uint8_t)0xF0U) >> (uint8_t)0x4U` extracts the tens digit
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`((value) & (uint8_t)0xF0U) >> (uint8_t)0x4U` 提取十位数字
- en: Then, `((value) & (uint8_t)0x0FU)` extracts the units digit
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`((value) & (uint8_t)0x0FU)` 提取个位数字
- en: Multiplication and addition combine these to form the binary value
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法和加法将这些值组合成二进制值
- en: 'Next, we have a helper function for getting the day – that is, `rtc_date_get_day`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个用于获取日期的辅助函数——即`rtc_date_get_day`：
- en: '[PRE31]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function reads the RTC date register and returns the current day of the
    month.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数读取RTC日期寄存器并返回当前月份。
- en: We can read the day by using `READ_BIT(RTC->DR, (RTC_DR_DT | RTC_DR_DU))`, which
    reads the day tens and units bits.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`READ_BIT(RTC->DR, (RTC_DR_DT | RTC_DR_DU))`来读取日期，它读取日期的十位和个位比特。
- en: Shifting the result to the right positions the value correctly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果右移将值放置在正确的位置。
- en: 'We also have a function for the year – that is, `rtc_date_get_year`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个用于年份的函数——即`rtc_date_get_year`：
- en: '[PRE32]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function reads the RTC date register and returns the current year.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数读取RTC日期寄存器并返回当前年份。
- en: Here, `READ_BIT(RTC->DR, (RTC_DR_YT | RTC_DR_YU))` reads the year tens and units
    bits.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`READ_BIT(RTC->DR, (RTC_DR_YT | RTC_DR_YU))`读取年份的十位和个位比特。
- en: 'We also have functions for retrieving the month, second, minute, and hour,
    all of which are implemented using the same approach as the other getter functions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有用于获取月份、秒、分钟和小时的函数，所有这些函数都是使用与其他获取函数相同的方法实现的：
- en: 'First, we have `rtc_date_get_month`:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有`rtc_date_get_month`：
- en: '[PRE33]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we have `rtc_time_get_second`:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有`rtc_time_get_second`：
- en: '[PRE34]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, there’s `rtc_time_get_minute`:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，是`rtc_time_get_minute`：
- en: '[PRE35]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, there’s `rtc_time_get_hour`:'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，是`rtc_time_get_hour`：
- en: '[PRE36]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With all of these functions implemented, our `rtc.c` file is complete. Our next
    task is to populate the `rtc.h` file.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了所有这些函数之后，我们的`rtc.c`文件就完成了。我们的下一个任务是填充`rtc.h`文件。
- en: The header file
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'Here’s the code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we’re simply exposing the functions implemented in `rtc.c`, making them
    callable from other files. Let’s go ahead and test our driver’s `main.c` file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是公开了在`rtc.c`中实现的函数，使它们可以从其他文件中调用。让我们继续测试我们的驱动程序的`main.c`文件。
- en: The main file
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主文件
- en: 'Let’s update the `main.c` file so that it looks like this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`main.c`文件，使其看起来像这样：
- en: '[PRE38]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let’s break down the unique aspects of the code, starting with the `display_rtc_calendar`
    function. This function retrieves the current time and date from the RTC peripheral,
    formats these values, prints them out, and stores them in a buffer for further
    processing.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析代码的独特之处，从`display_rtc_calendar`函数开始。这个函数从RTC外设获取当前时间和日期，格式化这些值，打印它们，并将它们存储在缓冲区以供进一步处理。
- en: 'The following are our buffer definitions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的缓冲区定义：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we can see the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到以下内容：
- en: '`BUFF_LEN`: This defines the length of the buffer for storing the time and
    date string'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUFF_LEN`：这定义了存储时间和日期字符串的缓冲区长度'
- en: '`time_buff`: This is an array that holds the formatted time string'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_buff`：这是一个数组，用于存储格式化的时间字符串'
- en: '`date_buff`: This is an array that holds the formatted date string'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date_buff`：这是一个数组，用于存储格式化的日期字符串'
- en: 'Let’s take a closer look at the time formatting and display block:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看时间格式化和显示块：
- en: '[PRE40]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we can see the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到以下内容：
- en: '`sprintf`: This is used to format the time string into `time_buff`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sprintf`：用于将时间字符串格式化到`time_buff`'
- en: '`rtc_convert_bcd2dec`: This converts the BCD values from RTC into decimal'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rtc_convert_bcd2dec`：这个函数将RTC中的BCD值转换为十进制'
- en: '`rtc_time_get_hour`, `rtc_time_get_minute`, and `rtc_time_get_second`: These
    retrieve the current hour, minute, and second from the RTC peripheral, respectively'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rtc_time_get_hour`、`rtc_time_get_minute` 和 `rtc_time_get_second`：这些函数分别从 RTC
    外设检索当前小时、分钟和秒'
- en: '`printf`: This function is used to print formatted output to the serial port'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printf`：此函数用于将格式化输出打印到串行端口'
- en: '`%.2d`: This format specifier means that the integer will be printed with at
    least 2 digits, padding with leading zeros if necessary'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%.2d`：此格式说明符表示整数将以至少 2 位打印，如果需要则用前导零填充'
- en: 'We’re now ready to test our RTC calendar driver on the microcontroller. We
    can test the project by following these steps:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在微控制器上测试我们的 RTC 日历驱动程序。我们可以通过以下步骤测试项目：
- en: Compile and upload the project to your microcontroller.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并将项目上传到您的微控制器。
- en: Launch RealTerm or your preferred serial terminal program.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 RealTerm 或您首选的串行终端程序。
- en: Configure the appropriate port and baud rate.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置适当的端口和波特率。
- en: 'You should see the time and date values printed and updating in real time,
    as shown in *Figure 15**.7*:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到时间和日期值实时打印并更新，如图 *图15**.7* 所示：
- en: '![Figure 15.8: Expected results](img/B21914_15_8.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8：预期结果](img/B21914_15_8.jpg)'
- en: 'Figure 15.8: Expected results'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：预期结果
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the RTC peripheral, a component for timekeeping
    in embedded systems. This peripheral is essential for applications requiring precise
    time and date maintenance, making it fundamental for a wide range of embedded
    applications.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 RTC 外设，这是嵌入式系统中用于计时的组件。该外设对于需要精确时间和日期维护的应用至关重要，因此对于广泛的嵌入式应用来说是基本的。
- en: We began by introducing RTCs and understanding their functionality. This included
    a deep dive into how RTCs operate, which involved focusing on the crystal oscillator,
    counters, time and date registers, and the importance of battery backup. We illustrated
    these concepts with case studies, showcasing the practical use of RTCs in data
    logging, alarm clocks, time-stamping transactions, and calendar functions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了 RTC 并理解其功能。这包括深入了解 RTC 的工作原理，涉及关注晶振振荡器、计数器、时间和日期寄存器以及电池备份的重要性。我们通过案例研究说明了这些概念，展示了
    RTC 在数据记录、闹钟、时间戳交易和日历功能中的实际应用。
- en: Following this, we examined the STM32 RTC module, highlighting its key features
    and capabilities. We discussed the calendar in terms of sub-seconds accuracy,
    dual programmable alarms, low power consumption, backup domain, daylight saving
    time adjustments, automatic wakeup, tamper detection, digital calibration, and
    synchronization with external clocks. Each feature was detailed to show its application
    and importance in maintaining accurate timekeeping.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，我们检查了 STM32 RTC 模块，强调了其关键特性和功能。我们讨论了以亚秒精度为标准的日历，双可编程闹钟，低功耗，备份域，夏令时调整，自动唤醒，篡改检测，数字校准以及与外部时钟的同步。每个特性都进行了详细说明，以展示其在保持精确计时中的应用和重要性。
- en: Next, we analyzed the relevant registers from the STM32 reference manual, providing
    a detailed understanding of the configuration and operation of the RTC. We covered
    the `RTC_TR`, `RTC_DR`, `RTC_CR`, `RTC_ISR`, `RTC_PRER`, `RTC_ALRMAR`, `RTC_ALRMBR`,
    and `RTC_WUTR` registers. Each register’s role and key fields were explained to
    ensure you have a comprehensive grasp of how they contribute to the RTC’s functionality.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分析了 STM32 参考手册中的相关寄存器，提供了对 RTC 配置和操作的详细理解。我们涵盖了 `RTC_TR`、`RTC_DR`、`RTC_CR`、`RTC_ISR`、`RTC_PRER`、`RTC_ALRMAR`、`RTC_ALRMBR`
    和 `RTC_WUTR` 寄存器。每个寄存器的角色和关键字段都得到了解释，以确保您全面了解它们如何有助于 RTC 的功能。
- en: Finally, we applied this knowledge to develop an RTC driver. We walked through
    the steps to create and configure the RTC driver, starting with the initialization
    sequence and covering functions to set the date and time. We also implemented
    helper functions for converting values between decimal and BCD formats, as well
    as retrieving current time and date values from the RTC peripheral.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些知识应用于开发 RTC 驱动程序。我们介绍了创建和配置 RTC 驱动程序的步骤，从初始化序列开始，涵盖了设置日期和时间的函数。我们还实现了在十进制和
    BCD 格式之间转换值的辅助函数，以及从 RTC 外设检索当前时间和日期值。
- en: In the next chapter, we will delve into another useful peripheral, expanding
    our knowledge and toolkit for embedded systems development.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解另一个有用的外设，扩展我们的嵌入式系统开发知识和工具集。
