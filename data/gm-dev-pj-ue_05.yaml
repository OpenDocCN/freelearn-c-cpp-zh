- en: 5\. Line Traces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 线性跟踪
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will be the start of a new game project called Dodgeball, where
    we will be creating a game from scratch that features mechanics based on collision
    concepts. In this chapter, you will modify the Third Person Template project to
    give it a top-down perspective. Then, you will be introduced to line traces, a
    key concept in game development, and learn about their potential and use cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章将是一个名为躲避球的新游戏项目的开始，我们将从头开始创建一个基于碰撞概念的游戏。在本章中，您将修改第三人称模板项目，使其具有俯视视角。然后，您将介绍线性跟踪，这是游戏开发中的一个关键概念，并了解它们的潜力和用例。
- en: By the end of this chapter, you will be able to use UE4's built-in Line Trace
    feature (also known as Raycasts or Raytraces in other game development tools)
    by executing different types of line traces; creating your own trace channels;
    and modifying an object's response to each trace channel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使用UE4内置的线性跟踪功能（在其他游戏开发工具中也称为射线投射或光线跟踪），通过执行不同类型的线性跟踪；创建自己的跟踪通道；并修改物体对每个跟踪通道的响应。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we learned how we can reproduce the Third Person Template
    project offered to us by the Unreal Engine team in order to understand some of
    the basic concepts of UE4's workflow and framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何重现虚幻引擎团队提供给我们的第三人称模板项目，以了解UE4工作流程和框架的一些基本概念。
- en: In this chapter, you will start creating another game from scratch. In this
    game, the player will control a character from a top-down point of view (*similar
    to games such as Metal Gear Solid 1, 2, and 3*). A top-down perspective implies
    that the player controls a character that is seen as if it was being looked down
    upon, usually with the camera rotation being fixed (the camera doesn't rotate).
    In our game, the player character must go from point A to point B without being
    hit by dodgeballs that are being thrown at the player by the enemies that are
    spread throughout the level. The levels in this game will be maze-like in nature,
    and the player will have multiple paths to choose from, all of which will have
    enemies trying to throw dodgeballs at the player.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将开始从头开始创建另一个游戏。在这个游戏中，玩家将以俯视的角度控制一个角色（*类似于《合金装备》1、2和3等游戏*）。俯视视角意味着玩家控制一个角色，就好像从上方看下去一样，通常摄像机旋转是固定的（摄像机不会旋转）。在我们的游戏中，玩家角色必须从A点到B点，而不被敌人在整个关卡中投掷的躲避球击中。这个游戏的关卡将是迷宫般的，玩家将有多条路径可供选择，所有这些路径都将有敌人试图向玩家投掷躲避球。
- en: The specific topics we'll be approaching in this chapter will be Line Traces
    (Single and Multi), Sweep Traces, Trace Channels, and Trace Responses. In the
    first section, we begin by getting to know what *collision* is in the world of
    video games.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要涉及的具体主题包括线性跟踪（单一和多重）、扫描跟踪、跟踪通道和跟踪响应。在第一节中，我们将开始了解在视频游戏世界中*碰撞*是什么。
- en: Collision
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞
- en: A collision is basically a point at which two objects come into contact with
    each other (for example, two objects colliding, an object hitting a character,
    a character walking into a wall, and so on). Most game development tools have
    their own set of features that allow for collision and physics to exist inside
    the game. This set of features is called a **Physics Engine**, which is responsible
    for everything related to collisions. It is responsible for executing Line Traces,
    checking whether two objects are overlapping each other, blocking each other's
    movement, bouncing off of a wall, and much more. When we ask the game to execute
    or notify us of these collision events, the game is essentially asking the Physics
    Engine to execute it and then show us the results of these collision events.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞基本上是两个物体相互接触的点（例如，两个物体碰撞，物体撞击角色，角色走进墙壁等）。大多数游戏开发工具都有自己的一套功能，允许碰撞和物理存在于游戏中。这一套功能被称为**物理引擎**，它负责与碰撞相关的一切。它负责执行线性跟踪，检查两个物体是否重叠，阻止彼此的移动，从墙壁上弹开等等。当我们要求游戏执行或通知我们这些碰撞事件时，游戏实际上是在要求物理引擎执行它，然后向我们展示这些碰撞事件的结果。
- en: In the `Dodgeball` game you will be building, examples of where collision needs
    to be taken into account include checking whether enemies are able to see the
    player (which will be achieved using a Line Trace, covered in this chapter), simulating
    physics on an object that will behave just like a dodgeball, checking whether
    anything is blocking the player character's movement, and much more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将要构建的`躲避球`游戏中，需要考虑碰撞的例子包括检查敌人是否能看到玩家（这将通过线性跟踪来实现，在本章中介绍），模拟物理学上的一个对象，它将表现得就像一个躲避球一样，检查是否有任何东西阻挡玩家角色的移动，等等。
- en: Collision is one of the most important aspects of most games, so understanding
    it is crucial in order to get started with game development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞是大多数游戏中最重要的方面之一，因此了解它对于开始游戏开发至关重要。
- en: 'Before we start building our collision-based features, we will first need to
    set up our new `Dodgeball` project in order to support the game mechanics we will
    be implementing. This process starts with the steps described in the next section:
    *Project Setup*.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建基于碰撞的功能之前，我们首先需要设置我们的新`躲避球`项目，以支持我们将要实现的游戏机制。这个过程从下一节描述的步骤开始：*项目设置*。
- en: Project Setup
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'Let''s begin this chapter by creating our Unreal Engine project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建我们的虚幻引擎项目开始这一章节：
- en: '`Launch` UE4\. Select the `Games` project category, then press `Next`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`启动`UE4。选择`游戏`项目类别，然后按`下一步`。'
- en: Select the `Third Person template`, then press `Next`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`第三人称模板`，然后按`下一步`。
- en: Make sure the first option is set to `C++` and not `Blueprint`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将第一个选项设置为`C++`而不是`Blueprint`。
- en: Select the location of the project according to your preference and name your
    project `Dodgeball`, then press `Create Project`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的喜好选择项目的位置，并将项目命名为`躲避球`，然后按`创建项目`。
- en: 'When the project is done being generated, you should see the following on your screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 项目生成完成后，您应该在屏幕上看到以下内容：
- en: '![Figure 5.1: Dodgeball project loaded up'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：加载的躲避球项目'
- en: '](img/B16183_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_01.jpg)'
- en: 'Figure 5.1: Dodgeball project loaded up'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：加载的躲避球项目
- en: 'After the code has been generated and the project opens up, close the UE4 editor
    and open the files of the generated third-person Character class, `DodgeballCharacter`,
    in Visual Studio, as shown in the following figure:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码生成并打开项目后，关闭UE4编辑器，并在Visual Studio中打开生成的第三人角色类`DodgeballCharacter`的文件，如下图所示：
- en: '![Figure 5.2: Files generated in Visual studio'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：在Visual Studio中生成的文件'
- en: '](img/B16183_05_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_02.jpg)'
- en: 'Figure 5.2: Files generated in Visual studio'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：在Visual Studio中生成的文件
- en: As mentioned before, your project is going to have a top-down perspective. Given
    that we're starting this project from the Third Person Template, we'll have to
    change a few things before we turn this into a top-down game. This will mainly
    involve changing some lines of code in the existing Character class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您的项目将具有俯视角。鉴于我们从第三人模板开始此项目，我们需要在将其转换为俯视游戏之前进行一些更改。这将主要涉及更改现有角色类中的一些代码行。
- en: 'Exercise 5.01: Converting DodgeballCharacter to a Top-Down Perspective'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：将躲避球角色转换为俯视角
- en: In this exercise, you'll be performing the necessary changes to your generated
    `DodgeballCharacter` class. Remember, it currently features a third-person perspective,
    where the rotation of the character is dictated by the player's input (*namely
    the mouse or right analog stick*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将对生成的`DodgeballCharacter`类进行必要的更改。请记住，它目前具有第三人称视角，其中角色的旋转由玩家的输入（即鼠标或右摇杆）决定。
- en: In this exercise, you will change this to a top-down perspective, which remains
    the same regardless of the player's input, where the camera always follows the
    character from above.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将把它改为俯视角，不管玩家的输入如何，相机始终从上方跟随角色。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Head to the `DodgeballCharacter` class's constructor and update the `CameraBoom`
    properties, as mentioned in the following steps.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`DodgeballCharacter`类的构造函数，并根据以下步骤更新`CameraBoom`的属性。
- en: 'Change `TargetArmLength`, which is a property of `CameraBoom`, to `900.0f`,
    in order to add some distance between the camera and the player:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CameraBoom`的属性`TargetArmLength`更改为`900.0f`，以在相机和玩家之间增加一些距离：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add a line that sets the relative pitch to `-70`º, using the `SetRelativeRotation`
    function, so that the camera looks down at the player. The `FRotator` constructor''s
    parameters are the *pitch*, *yaw*, and *roll*, respectively:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一行代码，使用`SetRelativeRotation`函数将相对俯仰设置为`-70`º，以便相机向下看玩家。`FRotator`构造函数的参数分别是*俯仰*、*偏航*和*翻滚*：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change `bUsePawnControlRotation` to `false`, so that the camera''s rotation
    isn''t changed by the player''s movement input:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bUsePawnControlRotation`更改为`false`，以便相机的旋转不受玩家的移动输入影响：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a line that sets `bInheritPitch`, `bInheritYaw`, and `bInheritRoll` to
    `false`, so that the camera''s rotation isn''t changed by the character''s orientation:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码，将`bInheritPitch`、`bInheritYaw`和`bInheritRoll`设置为`false`，以便相机的旋转不受角色方向的影响：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After we've made these modifications, we're going to remove the character's
    ability to jump (we don't want the player to escape from the dodgeballs that easily)
    and to rotate the camera from the player's rotation input.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行了这些修改之后，我们将删除角色跳跃的能力（我们不希望玩家那么容易就躲开躲避球），以及根据玩家的旋转输入旋转相机的能力。
- en: 'Go to the `SetupPlayerInputComponent` function in the `DodgeballCharacter''s`
    source file and remove the following lines of code in order to remove the ability
    to jump:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`DodgeballCharacter`源文件中的`SetupPlayerInputComponent`函数，并删除以下代码行以删除跳跃的能力：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add the following lines in order to remove the player''s rotation input:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下行以删除玩家的旋转输入：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This step is optional, but in order to keep your code clean, you should remove
    the declarations and implementations of the `TurnAtRate` and `LookUpAtRate` functions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步是可选的，但为了保持代码整洁，您应该删除`TurnAtRate`和`LookUpAtRate`函数的声明和实现。
- en: Finally, after you've made these changes, run your project from Visual Studio.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您进行了这些更改之后，从Visual Studio运行您的项目。
- en: 'When the editor has loaded, play the level. The camera''s perspective should
    look like this and should not rotate based on the player''s input or the character''s rotation:![Figure
    5.3: Locked camera rotation to a top-down perspective'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑器加载完成后，播放关卡。相机的视角应该是这样的，并且不应根据玩家的输入或角色的旋转而旋转：![图5.3：将相机旋转锁定到俯视角
- en: '](img/B16183_05_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_03.jpg)'
- en: 'Figure 5.3: Locked camera rotation to a top-down perspective'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：将相机旋转锁定到俯视角
- en: And that concludes the first exercise of this chapter, and the first step to
    your new project, `Dodgeball`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的第一个练习，也是您新项目`Dodgeball`的第一步。
- en: 'Next, you will be creating the `EnemyCharacter` class. This character will
    be the enemy that throws dodgeballs at the player while the player is in view.
    But the question that arises here is this: how will the enemy know whether it
    can see the player character or not?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将创建`EnemyCharacter`类。这个角色将是敌人，在玩家在视野中时向玩家投掷躲避球。但在这里出现的问题是：敌人如何知道它是否能看到玩家角色呢？
- en: That will be achieved with the power of **Line Traces** (also known as **Raycasts**
    or **Raytraces**), which you will be looking at in the next section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过**线追踪**（也称为**射线投射**或**光线追踪**）的能力来实现，您将在下一节中了解到。
- en: Line Traces
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线追踪
- en: One of the most important features of any game development tool is its ability
    to execute Line Traces. These are available through the Physics Engine that the
    tool is using.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏开发工具的最重要功能之一是执行线追踪的能力。这些功能是通过工具使用的物理引擎提供的。
- en: Line Traces are a way of asking the game to tell you whether anything stands
    between two points in the game world. The game will *shoot a ray* between those
    two points, specified by you, and return the objects that were hit (if any), where
    they were hit, at what angle, and much more.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 线性跟踪是一种询问游戏是否有任何东西站在游戏世界中两点之间的方式。游戏将在你指定的两点之间*发射一条射线*，并返回被击中的对象（如果有的话），它们被击中的位置，以及角度等等。
- en: 'In the following figure, you can see a representation of a Line Trace where
    we assume object `1` is ignored and object `2` is detected, due to their Trace
    Channel properties (further explained in the following paragraphs):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到线性跟踪的表示，我们假设对象`1`被忽略，而对象`2`被检测到，这是由于它们的跟踪通道属性（在接下来的段落中进一步解释）：
- en: '![Figure 5.4: A Line Trace being executed from point A to point B'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：从点A到点B执行的线性跟踪'
- en: '](img/B16183_05_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_04.jpg)'
- en: 'Figure 5.4: A Line Trace being executed from point A to point B'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：从点A到点B执行的线性跟踪
- en: 'In *Figure 5.4*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.4*中：
- en: The dashed line represents the Line Trace before it hits an object.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线代表线性跟踪撞击物体前的情况。
- en: The arrows represent the direction of the Line Trace.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头代表线性跟踪的方向。
- en: The dotted line represents the Line Trace after it hits an object.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线代表线性跟踪撞击物体后的情况。
- en: The striped circle represents the Line Trace's impact point.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条纹圆圈代表线性跟踪的撞击点。
- en: The big squares represent two objects that are in the path of the Line Trace
    (objects `1` and `2`).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大方块代表线性跟踪路径上的两个对象（对象`1`和`2`）。
- en: We notice that only object `2` was hit by the Line Trace and not object `1`,
    although it is also in the path of the Line Trace. This is due to assumptions
    made about object `1`'s Trace Channel properties, which are talked about later
    in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到只有对象`2`被线性跟踪击中，而对象`1`没有，尽管它也在线性跟踪的路径上。这是由于对对象`1`的跟踪通道属性所做的假设，这些将在本章后面讨论。
- en: 'Line Traces are used for many game features, such as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 线性跟踪用于许多游戏功能，例如：
- en: Checking whether a weapon hits an object when it fires
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查武器开火时是否击中物体
- en: Highlighting an item that the player can interact with when the character looks
    at it
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色看着可以与之交互的物品时进行突出显示
- en: Rotating the camera around the player character automatically as it goes around corners
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相机自动围绕玩家角色旋转时
- en: 'A common and important feature of Line Traces is **Trace Channels**. When you
    execute a Line Trace, you may want to check only specific types of objects, which
    is what Trace Channels are for. They allow you to specify filters to be used when
    executing a Line Trace so that it doesn''t get blocked by unwanted objects. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线性跟踪的一个常见且重要的特性是**跟踪通道**。当执行线性跟踪时，您可能只想检查特定类型的对象，这就是跟踪通道的作用。它们允许您指定在执行线性跟踪时使用的过滤器，以便它不会被不需要的对象阻挡。例如：
- en: You may want to execute a Line Trace only to check for objects that are visible.
    These objects would block the `Visibility` Trace Channel. For instance, invisible
    walls, which are invisible pieces of geometry used in games to block the player's
    movement, would not be visible and therefore would not block the `Visibility`
    Trace Channel.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能只想执行线性跟踪以检查可见的对象。这些对象将阻挡`Visibility`跟踪通道。例如，不可见的墙壁，这些是游戏中用来阻挡玩家移动的不可见几何体，不可见，因此不会阻挡`Visibility`跟踪通道。
- en: You may want to execute a Line Trace only to check for objects that can be interacted
    with. These objects would block the `Interaction` Trace Channel.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能只想执行线性跟踪以检查可以与之交互的对象。这些对象将阻挡`Interaction`跟踪通道。
- en: You may want to execute a Line Trace only to check for pawns that can move around
    the game world. These objects would block the `Pawn` Trace Channel.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能只想执行线性跟踪以检查可以在游戏世界中移动的pawn。这些对象将阻挡`Pawn`跟踪通道。
- en: You can specify how different objects react to different Trace Channels so that
    only some objects block specific Trace Channels and others ignore them. In our
    case, we want to know whether anything stands between the enemy and the player
    character, so that we know whether the enemy can see the player. We will be using
    Line Traces for this purpose, by checking for anything that blocks the enemy's
    line of sight to the player character, using a `Tick` event.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定不同对象如何对不同的跟踪通道做出反应，以便只有一些对象阻挡特定的跟踪通道，而其他对象忽略它们。在我们的情况下，我们想知道敌人和玩家角色之间是否有任何东西，这样我们就知道敌人是否能看到玩家。我们将使用线性跟踪来实现这一目的，通过检查任何阻挡敌人对玩家角色的视线的东西，使用`Tick`事件。
- en: In the next section, we will be creating the `EnemyCharacter` class using C++.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用C++创建`EnemyCharacter`类。
- en: Creating the EnemyCharacter C++ class
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建EnemyCharacter C++类
- en: In our `Dodgeball` game, the `EnemyCharacter` class will constantly be looking
    at the player character, if they're within view. This is the same class that will
    later throw dodgeballs at the player; however, we'll leave that to the next chapter.
    In this chapter, we will be focusing on the logic that allows our enemy character
    to look at the player.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Dodgeball`游戏中，`EnemyCharacter`类将不断地观察玩家角色，如果他们在视野内的话。这是同一个类，稍后将向玩家投掷躲避球；但是，这将留到下一章。在本章中，我们将专注于允许我们的敌人角色观察玩家的逻辑。
- en: 'So, let''s get started:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧：
- en: Right-click the `Content Browser` inside the editor and select `New C++ Class`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器内右键单击`Content Browser`，然后选择`New C++ Class`。
- en: Choose the `Character` class as the parent class.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Character`类作为父类。
- en: Name the new class `EnemyCharacter`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`EnemyCharacter`。
- en: 'After you''ve created the class and opened its files in Visual Studio, let''s
    add the `LookAtActor` function declaration in its `header` file. This function
    should be `public`, not return anything and only receive the `AActor* TargetActor`
    parameter, which will be the actor it should be facing. Have a look at the following
    code snippet, which shows this function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了类并在Visual Studio中打开了它的文件之后，让我们在其`header`文件中添加`LookAtActor`函数声明。这个函数应该是`public`，不返回任何东西，只接收`AActor*
    TargetActor`参数，这将是它应该面对的Actor。看一下下面的代码片段，它展示了这个函数：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we only want the enemy to look at the player's character, in order
    to execute good software development practices, we're going to abstract this function
    a bit more and allow `EnemyCharacter` to look at any Actor, because the logic
    that allows an Actor to look at another Actor or at the player character will
    be exactly the same.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只希望敌人看着玩家的角色，但为了执行良好的软件开发实践，我们将稍微抽象化这个函数，并允许`EnemyCharacter`看任何Actor，因为允许一个Actor看另一个Actor或玩家角色的逻辑将是完全相同的。
- en: Remember, you should not create unnecessary restrictions when writing code.
    If you can write similar code while at the same time allowing more possibilities,
    you should do so, if that doesn't overcomplicate the logic of your program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在编写代码时不应该创建不必要的限制。如果你可以编写类似的代码，同时又允许更多的可能性，那么你应该这样做，只要不过于复杂化程序的逻辑。
- en: Moving on ahead, if `EnemyCharacter` can't see the `Target` `Actor`, it shouldn't
    be looking at it. In order to check whether the enemy can see the Actor, it should
    be looking at the `LookAtActor` function which will call another function, the
    `CanSeeActor` function. This is what you'll be doing in the next exercise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，如果`EnemyCharacter`看不到`Target` `Actor`，它就不应该看着它。为了检查敌人是否能看到Actor，它应该看着`LookAtActor`函数，该函数将调用另一个函数，即`CanSeeActor`函数。这就是你将在下一个练习中要做的事情。
- en: 'Exercise 5.02: Creating the CanSeeActor Function, Which Executes Line Traces'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：创建CanSeeActor函数，执行线性跟踪
- en: In this exercise, we will create the `CanSeeActor` function, which will return
    whether the enemy character can see the given Actor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建`CanSeeActor`函数，该函数将返回敌人角色是否能看到给定的Actor。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Create the declaration for the `CanSeeActor` function in the header file of
    the `EnemyCharacter` class, which will return a `bool` and receive a `const Actor*
    TargetActor` parameter, which is the Actor we want to look at. This function will
    be a `const` function, because it doesn''t change any of the class''s attributes,
    and the parameter will also be `const` because we won''t need to modify any of
    its properties; we''ll only need to access them:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`类的头文件中创建`CanSeeActor`函数的声明，该函数将返回一个`bool`，并接收一个`const Actor*
    TargetActor`参数，这是我们想要看的Actor。这个函数将是一个`const`函数，因为它不会改变类的任何属性，参数也将是`const`，因为我们不需要修改它的任何属性；我们只需要访问它们：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's get to the fun part, which is executing the Line Trace.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来到有趣的部分，即执行线性跟踪。
- en: 'In order to call functions related to line tracing, we''ll have to fetch the
    enemy''s current world with the `GetWorld` function. However, we haven''t included
    the `World` class in this file, so let''s do so in the following step:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用与线性跟踪相关的函数，我们将需要使用`GetWorld`函数获取敌人当前的世界。然而，我们还没有在这个文件中包含`World`类，所以让我们在接下来的步骤中这样做：
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetWorld` function is accessible to any Actor and will return the `World`
    object that the Actor belongs to. Remember, the world is necessary in order to
    execute the Line Trace.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld`函数对任何Actor都是可访问的，并将返回Actor所属的`World`对象。请记住，为了执行线性跟踪，世界是必要的。'
- en: 'Open the `EnemyCharacter` source file and find the following code line:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnemyCharacter`源文件，并找到以下代码行：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following line right after the preceding line of code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码的后面添加以下行：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create the implementation of the `CanSeeActor` function in the `EnemyCharacter`
    source file, where you''ll start by checking whether our `TargetActor` is a `nullptr`.
    If it is, we return `false`, given that we have no valid Actor to check our sight
    to:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`EnemyCharacter`源文件中创建`CanSeeActor`函数的实现，你将首先检查我们的`TargetActor`是否为`nullptr`。如果是，我们将返回`false`，因为我们没有有效的Actor来检查我们的视线：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, before we add our Line Trace function call, we need to set up some necessary
    parameters; we will be implementing these in the following steps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在添加线性跟踪函数调用之前，我们需要设置一些必要的参数；我们将在接下来的步骤中实现这些参数。
- en: 'After the previous `if` statement, create a variable to store all the necessary
    data relative to the results of the Line Trace. Unreal already has a built-in
    type for this called the `FHitResult` type:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`if`语句之后，创建一个变量来存储与线性跟踪结果相关的所有必要数据。Unreal已经为此提供了一个内置类型，称为`FHitResult`类型：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the variable we will send to our Line Trace function, which will populate
    it with the relevant info of the executed Line Trace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将发送到线性跟踪函数的变量，该函数将用执行的线性跟踪的相关信息填充它。
- en: 'Create two `FVector` variables, for the `Start` and `End` locations of our
    Line Trace, and set them to our enemy''s current location and our target''s current
    location, respectively:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`FVector`变量，用于我们线性跟踪的`Start`和`End`位置，并将它们分别设置为我们敌人当前的位置和我们目标当前的位置：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, set the Trace Channel we wish to compare against. In our case, we want
    to have a `Visibility` Trace Channel specifically designated to indicate whether
    an object blocks another object''s view. Luckily for us, such a Trace Channel
    already exists in UE4, as shown in the following code snippet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置我们希望进行比较的跟踪通道。在我们的情况下，我们希望有一个`Visibility`跟踪通道，专门用于指示一个物体是否阻挡另一个物体的视图。幸运的是，对于我们来说，UE4中已经存在这样一个跟踪通道，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ECollisionChannel` `enum` represents all the possible Trace Channels available
    to compare against. We will be using the `ECC_Visibility` value, which represents
    the `Visibility` Trace Channel.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: “ECollisionChannel”枚举代表了所有可能的跟踪通道，我们将使用“ECC_Visibility”值，该值代表“Visibility”跟踪通道。
- en: 'Now that we''ve set up all our necessary parameters, we can finally call the
    `LineTrace` function, `LineTraceSingleByChannel`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好所有必要的参数，我们最终可以调用“LineTrace”函数，“LineTraceSingleByChannel”：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function will consider the parameters we send it, execute the Line Trace,
    and return its results by modifying our `Hit` variable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将考虑我们发送的参数，执行线性跟踪，并通过修改我们的“Hit”变量返回其结果。
- en: Before we continue, there are still a couple more things we need to consider.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一些事情需要考虑。
- en: If the Line Trace starts from within our enemy character, which is what will
    happen in our case, that means it's very likely that the Line Trace will simply
    hit our enemy character immediately and just stop there, because our character
    might block the `Visibility` Trace Channel. In order to fix that, we need to tell
    the Line Trace to ignore it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线性跟踪从我们的敌人角色内部开始，这在我们的情况下会发生，这意味着线性跟踪很可能会立即击中我们的敌人角色并停在那里，因为我们的角色可能会阻塞“Visibility”跟踪通道。为了解决这个问题，我们需要告诉线性跟踪忽略它。
- en: 'Use the built-in `FCollisionQueryParams` type, which allows us to give even
    more options to our Line Trace:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的“FCollisionQueryParams”类型，可以为我们的线性跟踪提供更多选项：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, update the `Line Trace` to ignore our enemy, by adding itself to the list
    of Actors to ignore:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新线性跟踪以忽略我们的敌人，通过将自身添加到要忽略的Actor列表中：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We should also add our target to our list of Actors to ignore because we don't
    want to know whether it blocks the `EnemySight` channel; we just simply want to
    know whether something between the enemy and the player character blocks that
    channel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应将我们的目标添加到要忽略的Actor列表中，因为我们不想知道它是否阻塞了“EnemySight”通道；我们只是想知道敌人和玩家角色之间是否有东西阻塞了该通道。
- en: 'Add the Target Actor to the list of Actors to be ignored as shown in the following
    code snippet:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标Actor添加到要忽略的Actor列表中，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, send our `FCollisionQueryParams` to the Line Trace by adding it as the
    last parameter of the `LineTraceSingleByChannel` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将其作为“LineTraceSingleByChannel”函数的最后一个参数发送我们的“FCollisionQueryParams”：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finalize our `CanSeeActor` function, by returning whether the Line Trace hits
    anything or not. We can do that by accessing our `Hit` variable and checking whether
    there was a blocking hit, using the `bBlockingHit` property. If there was, that
    means we can''t see our `TargetActor`. This can be achieved with the following
    code snippet:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回线性跟踪是否击中任何东西来完成我们的“CanSeeActor”函数。我们可以通过访问我们的“Hit”变量并检查是否有阻塞命中来实现这一点，使用“bBlockingHit”属性。如果有，这意味着我们看不到我们的“TargetActor”。可以通过以下代码片段实现：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although we won''t need any more information from the `Hit` result, other than
    whether there was a blocking hit, the `Hit` variable can give us much more information
    on the Line Trace, such as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不需要从“Hit”结果中获取更多信息，除了是否有阻塞命中，但“Hit”变量可以为我们提供关于线性跟踪的更多信息，例如：
- en: Information on the Actor that was hit by the Line Trace (`nullptr` if no Actor
    was hit), by accessing the `Hit.GetActor()` function
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问“Hit.GetActor（）”函数，可以获取被线性跟踪击中的Actor的信息（如果没有击中Actor，则为“nullptr”）
- en: Information on the Actor component that was hit by the Line Trace (`nullptr`
    if no Actor component was hit), by accessing the `Hit.GetComponent()` function
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问“Hit.GetComponent（）”函数，找到被线性跟踪击中的Actor组件的信息（如果没有击中Actor组件，则为“nullptr”）
- en: Information on the location of the hit by accessing the `Hit.Location` variable
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问“Hit.Location”变量获取击中位置的信息
- en: The distance of the hit can be found by accessing the `Hit.Distance` variable
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问“Hit.Distance”变量找到击中的距离
- en: The angle at which the Line Trace hit the object, which can be found by accessing
    the `Hit.ImpactNormal` variable
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问“Hit.ImpactNormal”变量找到线性跟踪击中对象的角度
- en: Finally, our `CanSeeActor` function is complete. We now know how to execute
    a Line Trace and we can use it for our enemy's logic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的“CanSeeActor”函数已经完成。我们现在知道如何执行线性跟踪，并且可以将其用于我们敌人的逻辑。
- en: 'By completing this exercise, we have finished the `CanSeeActor` function; we
    can now get back to the `LookAtActor` function. However, there is something we
    should look at first: visualizing our Line Trace.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们已经完成了“CanSeeActor”函数；现在我们可以回到“LookAtActor”函数。但是，首先有件事情我们应该看一下：可视化我们的线性跟踪。
- en: Visualizing the Line Trace
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化线性跟踪
- en: When creating new logic that makes use of Line Traces, it is very useful to
    actually visualize the Line Trace while it's being executed, which is something
    that the Line Trace function doesn't allow you to do. In order to do that, we
    must use a set of helper debug functions that can draw objects dynamically at
    runtime, such as lines, cubes, spheres, and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建使用线性跟踪的新逻辑时，实际上在执行线性跟踪时可视化线性跟踪非常有用，而线性跟踪函数不允许您这样做。为了做到这一点，我们必须使用一组辅助调试函数，在运行时可以动态绘制对象，如线条、立方体、球体等。
- en: 'Let''s then add a visualization of our Line Trace. The first thing we must
    do in order to use the debug functions is to add the following `include` below
    our last `include` line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们添加线性跟踪的可视化。为了使用调试函数，我们必须在最后一个“include”行下添加以下“include”：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will want to call the `DrawDebugLine` function in order to visualize the
    Line Trace, which needs the following inputs, very similar to the ones received
    by the Line Trace function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用“DrawDebugLine”函数以可视化线性跟踪，该函数需要以下输入，与线性跟踪函数接收到的非常相似：
- en: The current `World`, which we will supply with the `GetWorld` function
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前的“World”，我们将使用“GetWorld”函数提供
- en: The `Start` and `End` points of the line, which will be the same as the `LineTraceSingleByChannel`
    function
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线的“Start”和“End”点，将与“LineTraceSingleByChannel”函数相同
- en: The desired color of the line in the game, which can be set to `Red`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏中线的期望颜色，可以设置为“红色”
- en: 'Then, we can add the `DrawDebugLine` function call below our Line Trace function
    call as shown in the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的线段跟踪函数调用下面添加`DrawDebugLine`函数调用，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will allow you to visualize the Line Trace as it is being executed, which
    is very useful.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您在执行时可视化线段跟踪，这非常有用。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel the need for it, you can also specify more of the visual Line Trace's
    properties, such as its lifetime and thickness.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要，您还可以指定更多的可视化线段跟踪属性，比如它的生命周期和厚度。
- en: There are many `DrawDebug` functions available that will draw cubes, spheres,
    cones, donuts, and even custom meshes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的`DrawDebug`函数，可以绘制立方体、球体、圆锥体、甜甜圈，甚至自定义网格。
- en: Now that we can both execute and visualize our Line Trace, let's use the `CanSeeActor`
    function, which we created in the last exercise, inside the `LookAtActor` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们既可以执行又可以可视化我们的线段跟踪，让我们在`LookAtActor`函数内使用我们在上一个练习中创建的`CanSeeActor`函数。
- en: 'Exercise 5.03: Creating the LookAtActor Function'
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：创建LookAtActor函数
- en: In this exercise, we will be creating the definition of our `LookAtActor` function,
    which will change the enemy's rotation so that it faces the given Actor.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建`LookAtActor`函数的定义，该函数将改变敌人的旋转，使其面向给定的角色。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个练习：
- en: Create the `LookAtActor` function definition in the `EnemyCharacter` source file.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`源文件中创建`LookAtActor`函数定义。
- en: 'Start by checking whether our `TargetActor` is a `nullptr` and returns nothing
    immediately if it is (because it''s not valid), as shown in the following code snippet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先检查我们的`TargetActor`是否为`nullptr`，如果是，则立即返回空（因为它无效），如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we want to check whether we can see our Target Actor, using our `CanSeeActor`
    function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要检查是否能看到我们的目标角色，使用我们的`CanSeeActor`函数：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this `if` statement is true, that means we can see the Actor, and we will
    set our rotation in such a way that we are facing that Actor. Luckily for us,
    there''s already a function within UE4 that allows us to do that: the `FindLookAtRotation`
    function. This function will receive as input two points in the level, point A
    (the `Start` point) and point B (the `End` point), and return the rotation that
    the object at the start point must have in order to face the object at the end
    point.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`if`语句为真，那意味着我们能看到这个角色，并且我们将设置我们的旋转，以便面向该角色。幸运的是，UE4中已经有一个允许我们这样做的函数：`FindLookAtRotation`函数。这个函数将接收级别中的两个点作为输入，点A（`Start`点）和点B（`End`点），并返回起始点的对象必须具有的旋转，以便面向结束点的对象。
- en: 'In order to use this function, include `KismetMathLibrary` as shown in the
    following code snippet:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用这个函数，包括`KismetMathLibrary`，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `FindLookAtRotation` function must receive a `Start` and `End` point, which
    will be our enemy''s location and our Target Actor''s location, respectively:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FindLookAtRotation`函数必须接收一个`Start`和`End`点，这将是我们的敌人位置和我们的目标角色位置，分别：'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, set your enemy character''s rotation to the same value as our `LookAtRotation`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将敌人角色的旋转设置为与我们的`LookAtRotation`相同的值：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And that's it for the `LookAtActor` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`LookAtActor`函数的全部内容。
- en: Now the last step is to call the `LookAtActor` function inside the Tick event
    and to send the player character as the `TargetActor`, the Actor that we want
    to look at.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后一步是在Tick事件中调用`LookAtActor`函数，并将玩家角色作为`TargetActor`发送。
- en: 'For us to fetch the character that is currently being controlled by the player,
    we can do so using the `GameplayStatics` object. As with other UE4 objects, we
    must first include them:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取当前由玩家控制的角色，我们可以使用`GameplayStatics`对象。与其他UE4对象一样，我们必须首先包含它们：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, head to your Tick function''s body and call the `GetPlayerCharacter`
    function from `GameplayStatics`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到您的Tick函数的主体，并从`GameplayStatics`中调用`GetPlayerCharacter`函数：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function receives as input:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收以下输入：
- en: A World context object, which is, essentially, an object that belongs to our
    current World, used to let the function know which World object to access. This
    World context object can simply be the `this` pointer.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个世界上下文对象，本质上是属于我们当前世界的对象，用于让函数知道要访问哪个世界对象。这个世界上下文对象可以简单地是`this`指针。
- en: A player index, which, given that our game is supposed to be a single-player
    game, we can safely assume to be `0` (the first player).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家索引，鉴于我们的游戏应该是单人游戏，我们可以安全地假设为`0`（第一个玩家）。
- en: 'Next, call the `LookAtActor` function, sending the player character that we
    just fetched:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`LookAtActor`函数，发送我们刚刚获取的玩家角色：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last step of this exercise is to compile your changes in Visual Studio.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个练习的最后一步是在Visual Studio中编译您的更改。
- en: Now that you've completed this exercise, your `EnemyCharacter` class has all
    the necessary logic to face the player character, if it's within view, and we
    can start creating the `EnemyCharacter` Blueprint class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这个练习，您的`EnemyCharacter`类已经具备了面向玩家角色的必要逻辑，如果它在视野内，我们可以开始创建`EnemyCharacter`蓝图类。
- en: Creating the EnemyCharacter Blueprint Class
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建EnemyCharacter蓝图类
- en: 'Now that we have finished the logic for our `EnemyCharacter` C++ class, we
    must create our blueprint class that derives from it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`EnemyCharacter` C++类的逻辑，我们必须创建从中派生的蓝图类：
- en: Open our project in the Editor.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开我们的项目。
- en: Go to the `Blueprints` folder inside the `ThirdPersonCPP` folder, in the `Content
    Browser`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`ThirdPersonCPP`文件夹中的`Content Browser`中的`Blueprints`文件夹。
- en: '*Right-click* and select the option to create a new blueprint class.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*并选择创建新的蓝图类。'
- en: Expand the `All Classes` tab near the bottom of the `Pick Parent Class` window,
    search for our `EnemyCharacter` C++ class, and select it as the parent class.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pick Parent Class`窗口底部附近展开`All Classes`选项卡，搜索我们的`EnemyCharacter` C++类，并将其选择为父类。
- en: Name the Blueprint class `BP_EnemyCharacter`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蓝图类命名为`BP_EnemyCharacter`。
- en: Open the Blueprint class, select the `SkeletalMeshComponent` (called `Mesh`)
    from the `Components` tab, and set its `Skeletal Mesh` property to `SK_Mannequin`
    and its `Anim Class` property to `ThirdPerson_AnimBP`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图类，从“组件”选项卡中选择`SkeletalMeshComponent`（称为`Mesh`），并将其“骨骼网格”属性设置为`SK_Mannequin`，将其“动画类”属性设置为`ThirdPerson_AnimBP`。
- en: Change the *Yaw* of `SkeletalMeshComponent` to `-90º` (on the *z-axis*) and
    its position on the *z-axis* to `-83` units.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SkeletalMeshComponent`的*Yaw*更改为`-90º`（在*z轴*上），将其在*z轴*上的位置更改为`-83`个单位。
- en: After you've set up the Blueprint class, its mesh setup should look very similar
    to that of our `DodgeballCharacter` Blueprint class.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好蓝图类之后，其网格设置应该与我们的`DodgeballCharacter`蓝图类非常相似。
- en: 'Drag an instance of the `BP_EnemyCharacter` class to your level, in a location
    near an object that can block its line of sight, such as this location (the selected
    character is `EnemyCharacter`):![Figure 5.5: Dragging the BP_EnemyCharacter class
    into the level'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BP_EnemyCharacter`类的一个实例拖到你的关卡中，放在一个可能阻挡其视线的物体附近，比如这个位置（所选角色是`EnemyCharacter`）：![图5.5：将BP_EnemyCharacter类拖入关卡
- en: '](img/B16183_05_05.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_05.jpg)'
- en: 'Figure 5.5: Dragging the BP_EnemyCharacter class into the level'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：将BP_EnemyCharacter类拖入关卡
- en: 'Now we can finally play the game and verify that our enemy does look at our
    player character whenever it''s within view:![Figure 5.6: Enemy character with
    a clear view of the player using a Line Trace'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于可以玩游戏，验证我们的敌人在视线范围内时确实看向我们的玩家角色：![图5.6：敌人角色使用线扫描清晰看到玩家
- en: '](img/B16183_05_06.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_06.jpg)'
- en: 'Figure 5.6: Enemy character with a clear view of the player using a Line Trace'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：敌人角色使用线扫描清晰看到玩家
- en: 'We can also see that the enemy stops seeing the player whenever it''s not within
    view, as shown in *Figure 5.7*:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以看到，敌人在视线范围之外时停止看到玩家，如*图5.7*所示：
- en: '![Figure 5.7: Enemy losing sight of the player'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：敌人失去对玩家的视线'
- en: '](img/B16183_05_07.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_07.jpg)'
- en: 'Figure 5.7: Enemy losing sight of the player'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：敌人失去对玩家的视线
- en: And that concludes our `EnemyCharacter`'s logic. In the next section, we will
    be looking at Sweep Traces.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的`EnemyCharacter`的逻辑。在下一节中，我们将看一下扫描轨迹。
- en: Sweep Traces
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描轨迹
- en: Before we continue with our project, it is important to know about a variant
    of the Line Trace, which is the **Sweep Trace**. Although we won't be using these
    in our project, it is important to know about them and how to use them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续我们的项目之前，了解一种线扫描的变体——**扫描轨迹**是很重要的。虽然我们不会在项目中使用它们，但了解它们以及如何使用它们是很重要的。
- en: While the Line Trace basically *shoots a ray* between two points, the Sweep
    Trace will simulate *throwing an object* between two points in a straight line.
    The object that is being *thrown* is simulated (doesn't actually exist in the
    game) and can have various shapes. In the Sweep Trace, the `Hit` location will
    be the first point at which the virtual object (which we will call **Shape**)
    hits another object, if it were thrown from the start point to the end point.
    The shapes of the Sweep Trace can be either a box, a sphere, or a capsule.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然线扫描基本上是在两点之间“发射一条射线”，但扫描轨迹将模拟在直线上两点之间“抛出一个物体”。被“抛出”的物体是模拟的（实际上并不存在于游戏中），可以有各种形状。在扫描轨迹中，“击中”位置将是虚拟物体（我们将其称为**形状**）从起点到终点抛出时首次击中另一个物体的位置。扫描轨迹的形状可以是盒形、球形或胶囊形。
- en: 'Here is a representation of a Sweep Trace from point `A` to point `B`, where
    we assume that object `1` is ignored due to its Trace Channel properties, using
    a box shape:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从点`A`到点`B`的扫描轨迹的表示，我们假设由于其跟踪通道属性，物体`1`被忽略，使用盒形：
- en: '![Figure 5.8: Representation of a Sweep Trace'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：扫描轨迹的表示'
- en: '](img/B16183_05_08.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_08.jpg)'
- en: 'Figure 5.8: Representation of a Sweep Trace'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：扫描轨迹的表示
- en: 'From *Figure 5.8*, we notice the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图5.8*中，我们注意到以下内容：
- en: A Sweep Trace, using a box shape, being executed from point A to point B.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用盒形的扫描轨迹，从点A到点B执行。
- en: The dashed boxes represent the Sweep Trace before it hits an object.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线框表示扫描轨迹在击中物体之前。
- en: The dotted boxes represent the Sweep Trace after it hits an object.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线框表示扫描轨迹击中物体后的情况。
- en: The striped circle represents the Sweep Trace's impact point with object `2`,
    which is the point at which the Sweep Trace Box shape's surface and object `2`'s
    surface collide with each other.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条纹圆圈表示扫描轨迹与物体`2`的碰撞点，即扫描轨迹盒形的表面与物体`2`的表面相互碰撞的点。
- en: The big squares represent two objects that are in the path of the Line Sweep
    Trace (objects `1` and `2`).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大方块代表了两个物体在线扫描轨迹（物体`1`和`2`）的路径上。
- en: Object `1` is ignored in the Sweep Trace due to assumptions based on its Trace
    Channel properties.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其跟踪通道属性的假设，物体`1`在扫描轨迹中被忽略。
- en: 'Sweep Traces are more useful than regular Line Traces in a few situations.
    Let''s take the example of our enemy character, which can throw dodgeballs. If
    we wanted to add a way for the player to constantly visualize where the next dodgeball
    that the enemy throws will land, that could be better achieved with a Sweep Trace:
    we would do a Sweep Trace with the shape of our dodgeball (a sphere) toward our
    player, check the impact point, and show a sphere on that impact point, which
    would be visible to the player. If the Sweep Trace hits a wall or a corner somewhere,
    the player would know that, if the enemy were to throw a dodgeball at that moment,
    that''s where it would hit first. You could use a simple Line Trace for the same
    purpose, but the setup would have to be rather complex in order to achieve the
    same quality of results, which is why Sweep Traces are a better solution in this
    case.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，扫描跟踪比普通的线性跟踪更有用。让我们以我们的敌人角色为例，它可以投掷躲避球。如果我们想要为玩家添加一种方式，让玩家不断地可视化敌人投掷的下一个躲避球将会着陆的位置，那么最好的方法是使用扫描跟踪：我们可以用我们躲避球的形状（一个球体）对玩家进行扫描跟踪，检查碰撞点，并在碰撞点显示一个球体，这样玩家就可以看到。如果扫描跟踪击中了墙壁或某个角落，玩家就会知道，如果敌人此时投掷躲避球，它会首先击中那里。你可以使用简单的线性跟踪来达到同样的目的，但是为了达到相同的结果质量，设置会变得相当复杂，这就是为什么在这种情况下扫描跟踪是更好的解决方案。
- en: Let's now take a quick look at how we can do a Sweep Trace in code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下如何在代码中进行扫描跟踪。
- en: 'Exercise 5.04: Executing a Sweep Trace'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.04：执行扫描跟踪
- en: In this exercise, we will implement a Sweep Trace in code. Although we won't
    be using it for our project, by performing this exercise, you will become familiar
    with such an operation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在代码中实现扫描跟踪。虽然我们不会在项目中使用它，但通过进行这个练习，你将熟悉这样的操作。
- en: 'Go to the end of the `CanSeeActor` function created in the previous sections
    and follow these steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 进入前几节创建的`CanSeeActor`函数的末尾，然后按照以下步骤进行：
- en: 'The function responsible for the Sweep Trace is `SweepSingleByChannel`, which
    is available within UE4 and requires the following parameters as inputs:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负责扫描跟踪的函数是`SweepSingleByChannel`，它在UE4中可用，并需要以下参数作为输入：
- en: 'An `FHitResult` type, to store the results of the sweep (we already have one
    of these, so there''s no need to create another variable of this type):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`FHitResult`类型，用于存储扫描的结果（我们已经有了一个，所以不需要再创建另一个这种类型的变量）：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Start` and `End` points of the sweep (we already have both of these, so there''s
    no need to create another variable of this type):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描的“起点”和“终点”（我们已经有了这两个，所以不需要再创建另一个这种类型的变量）：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the intended rotation of the shape, which is in the form of an `FQuat`
    type (representing a quaternion). In this case, it''s set to a rotation of `0`
    on all axes, by accessing the `FQuat`''s `Identity` property:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用形状的预期旋转，它是一个`FQuat`类型（表示四元数）。在这种情况下，它被设置为在所有轴上的旋转为`0`，通过访问`FQuat`的`Identity`属性来实现： '
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, use the intended Trace Channel to compare it against (we already have
    one of these, so there''s no need to create another variable of this type):'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用预期的跟踪通道进行比较（我们已经有了一个这样的变量，所以不需要再创建另一个这种类型的变量）：
- en: '[PRE33]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, use the shape of a box for the Sweep Trace by calling the `FcollisionShape`
    `MakeBox` function and supplying it with the radius (on all three axes) of the
    box shape we want. This is shown in the following code snippet:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`FcollisionShape`的`MakeBox`函数并提供盒形形状在三个轴上的半径来使用盒形的形状进行扫描跟踪。这在下面的代码片段中显示：
- en: '[PRE34]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, call the `SweepSingleByChannel` function:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用`SweepSingleByChannel`函数：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With these steps completed, we finish our exercise on Sweep Traces. Given that
    we won't be using Sweep Traces in our project, you should comment out the `SweepSingleByChannel`
    function, so that our `Hit` variable doesn't get modified and lose the results
    from our Line Trace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这些步骤后，我们完成了有关扫描跟踪的练习。鉴于我们不会在项目中使用扫描跟踪，你应该注释掉`SweepSingleByChannel`函数，这样我们的`Hit`变量就不会被修改，也不会丢失我们线性跟踪的结果。
- en: Now that we've concluded the segment on Sweep Traces, let's get back to our
    `Dodgeball` project and learn how to change an object's response to a Trace Channel.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了有关扫描跟踪的部分，让我们回到我们的“躲避球”项目，并学习如何更改对象对跟踪通道的响应。
- en: Changing the Visibility Trace Response
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改可见性跟踪响应
- en: 'In our current setup, every object that is visible blocks the `Visibility`
    Trace Channel; however, what if we wanted to change whether an object blocks that
    channel completely? In order to do this, we must change a component''s response
    to that channel. Have a look at the following example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设置中，每个可见的对象都会阻挡“可见性”跟踪通道；但是，如果我们想要改变一个对象是否完全阻挡该通道，该怎么办呢？为了做到这一点，我们必须改变一个组件对该通道的响应。看下面的例子：
- en: 'We select the cube that we''ve been using to block the enemy''s sight in our
    level as shown in *Figure 5.9*:![Figure 5.9: Default spawn of the character'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择我们在关卡中用来阻挡敌人视线的立方体，如*图5.9*所示：![图5.9：角色的默认生成点
- en: '](img/B16183_05_09.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_09.jpg)'
- en: 'Figure 5.9: Default spawn of the character'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：角色的默认生成点
- en: 'Then, you go to the `Collision` section of this object''s `Details Panel` (its
    default place in the `Editor`''s interface):![Figure 5.10: Collision tab in the
    Details Panel in Unreal'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到对象“详细面板”中的“碰撞”部分（它在“编辑器”界面中的默认位置）：![图5.10：虚幻引擎中详细面板中的碰撞选项卡
- en: '](img/B16183_05_10.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_10.jpg)'
- en: 'Figure 5.10: Collision tab in the Details Panel in Unreal'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：虚幻引擎中详细面板中的碰撞选项卡
- en: Here, you'll find several collision-related options. The one we want to pay
    attention to right now is the `CollisionPresets` option. Its current value is
    `Default`; however, we want to change it according to our own preferences, so
    we will click on the drop-down box and change its value to `Custom`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你会发现几个与碰撞相关的选项。我们现在要注意的是“碰撞预设”选项。它当前的值是“默认”，但是，我们想根据自己的喜好进行更改，所以我们将点击下拉框并将其值更改为“自定义”。
- en: 'Once you do this, you''ll notice a whole group of new options pops up:![Figure
    5.11: Collision Preset set to Custom'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这样做，您会注意到一整组新选项弹出：![图5.11：碰撞预设设置为自定义
- en: '](img/B16183_05_11.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_11.jpg)'
- en: 'Figure 5.11: Collision Preset set to Custom'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：碰撞预设设置为自定义
- en: This group of options allows you to specify how this object responds to Line
    Traces and object collision, and the type of collision object it is.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这组选项允许您指定此对象对线追踪和对象碰撞的响应方式，以及它是何种类型的碰撞对象。
- en: The option you should be paying attention to is `Visibility`. You'll notice
    it's set to `Block`, but that you can also set it to `Overlap` and `Ignore`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意的选项是“可见性”。您会注意到它设置为“阻挡”，但您也可以将其设置为“重叠”和“忽略”。
- en: Right now, the cube is blocking the `Visibility` trace channel, which is why
    our enemy can't see the character when it's behind this cube. However, if we change
    the object's response to the `Visibility` Trace Channel to either `Overlap` or
    `Ignore`, the object will no longer block Line Traces that check for visibility
    (which is the case for the Line Trace you've just written in C++).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，立方体正在阻挡“可见性”追踪通道，这就是为什么我们的敌人在立方体后面时看不到角色。但是，如果我们将对象对“可见性”追踪通道的响应更改为“重叠”或“忽略”，则该对象将不再阻止检查可见性的线追踪（这是您刚刚在C++中编写的线追踪的情况）。
- en: 'Let''s change the cube''s response to the `Visibility` channel to `Ignore`,
    and then play the game. You''ll notice that the enemy is still looking toward
    the player character, even when it''s behind the cube:![Figure 5.12: Enemy character
    looking through an object at the player'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将立方体对“可见性”通道的响应更改为“忽略”，然后玩游戏。您会注意到即使敌人在立方体后面时，它仍然朝向玩家角色：![图5.12：敌人角色透过物体看玩家
- en: '](img/B16183_05_12.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_12.jpg)'
- en: 'Figure 5.12: Enemy character looking through an object at the player'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：敌人角色透过物体看玩家
- en: This is because the cube no longer blocks the `Visibility` Trace Channel, and
    so the Line Trace the enemy is executing no longer hits anything when trying to
    reach the player character.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为立方体不再阻挡“可见性”追踪通道，因此敌人执行的线追踪在试图接触玩家角色时不再击中任何东西。
- en: Now that we've seen how we can change an object's response to a specific Trace
    Channel, let's change the cube's response to the `Visibility` channel back to `Block`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何更改对象对特定追踪通道的响应方式，让我们将立方体对“可见性”通道的响应更改回“阻挡”。
- en: 'However, there''s one thing that''s worth mentioning: if we were to set the
    cube''s response to the `Visibility` channel to `Overlap`, instead of `Ignore`,
    the result would be the same. But why is that, and what is the purpose of having
    these two responses? In order to explain that, we''ll look at Multi Line Traces.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，值得一提的是：如果我们将立方体对“可见性”通道的响应设置为“重叠”，而不是“忽略”，结果将是相同的。但是为什么呢，这两种响应的目的是什么？为了解释这一点，我们将看看多线追踪。
- en: Multi Line Traces
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线追踪
- en: While using the `CanSeeActor` function in *Exercise 5.02*, *Creating the CanSeeActor
    Function, Which Executes Line Traces*, you might have wondered to yourself about
    the name of the Line Trace function we used, `LineTraceSingleByChannel`, specifically
    about why it used the word *Single*. The reason for that is because you can also
    execute `LineTraceMultiByChannel`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习5.02*中使用`CanSeeActor`函数时，您可能会对我们使用的线追踪函数`LineTraceSingleByChannel`的名称，特别是为什么使用了“单”这个词，感到困惑。原因是因为您也可以执行`LineTraceMultiByChannel`。
- en: But how do these two Line Traces differ?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这两种线追踪有何不同？
- en: While the Single Line Trace will stop checking for objects that block it after
    it hits an object, and tell us that was the object that it hit, the Multi Line
    Trace can check for any objects that are hit by the same Line Trace.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 单线追踪在击中物体后将停止检查阻挡物体，并告诉我们击中的物体是什么，而多线追踪可以检查同一线追踪击中的任何物体。
- en: 'The Single Line Trace will:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 单线追踪将：
- en: Ignore the objects that have their response set to either `Ignore` or `Overlap`
    on the Trace Channel being used by the Line Trace
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略那些在线追踪中使用的追踪通道上设置为“忽略”或“重叠”的对象
- en: Stop when it finds an object that has its response set to `Block`
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到其响应设置为“阻挡”的对象时停止
- en: 'However, instead of ignoring objects that have their response set to `Overlap`,
    the Multi Line Trace will add them as objects that were found during the Line
    Trace, and only stop when it finds an object that blocks the desired Trace Channel
    (*or when it reaches the end point*). In the next figure, you''ll find an illustration
    of a Multi Line Trace being executed:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多线追踪不会忽略那些在追踪通道上设置为“重叠”的对象，而是将它们添加为在线追踪期间找到的对象，并且只有在找到阻挡所需追踪通道的对象时（*或者到达终点时*）才会停止。在下一个图中，您将找到执行多线追踪的示例：
- en: '![Figure 5.13: A Multi Line Trace being executed from point A to point B'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：从点A到点B执行的多线追踪'
- en: '](img/B16183_05_13.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_13.jpg)'
- en: 'Figure 5.13: A Multi Line Trace being executed from point A to point B'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：从点A到点B执行的多线追踪
- en: 'In *Figure 5.13*, we notice the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.13*中，我们注意到以下内容：
- en: The dashed line represents the Line Trace before it hits an object that blocks
    it.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线代表线追踪在击中阻挡物体之前。
- en: The dotted line represents the Line Trace after it hits an object that blocks
    it.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点线代表线追踪击中阻挡物体后。
- en: The striped circles represent the Line Trace's impact points, only the last
    one of which is a blocking hit in this case.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条纹圆圈代表线追踪的影响点，其中只有最后一个在这种情况下是阻挡击中。
- en: The only difference between the `LineTraceSingleByChannel` and the `LineTraceMultiByChannel`
    functions, when it comes to their inputs, is that the latter must receive a `TArray<FHitResult>`
    input, instead of a single `FHitResult`. All other inputs are the same.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineTraceSingleByChannel`和`LineTraceMultiByChannel`函数之间唯一的区别在于它们的输入，后者必须接收`TArray<FHitResult>`输入，而不是单个`FHitResult`。所有其他输入都是相同的。'
- en: Multi Line Traces are very useful when simulating the behavior of bullets with
    strong penetration that can go through several objects before stopping completely.
    Keep in mind that you can also do Multi Sweep Traces by calling the `SweepMultiByChannel`
    function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 多线跟踪在模拟具有强穿透力的子弹行为时非常有用，可以穿过多个对象后完全停止。请记住，您还可以通过调用`SweepMultiByChannel`函数进行多扫描跟踪。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another thing about the `LineTraceSingleByChannel` function that you might be
    wondering about is the `ByChannel` portion. This distinction has to do with using
    a Trace Channel, as opposed to the alternative, which is an Object Type. You can
    do a Line Trace that uses Object Types instead of Trace Channels by calling the
    `LineTraceSingleByObjectType` function, also available from the World object.
    Object Types are related to topics we will be covering in the next chapter, so
    we won't be going into detail on this function just yet.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`LineTraceSingleByChannel`函数的另一件事，你可能会想知道的是`ByChannel`部分。这个区别与使用跟踪通道有关，而不是另一种选择，即对象类型。您可以通过调用`LineTraceSingleByObjectType`函数来执行使用对象类型而不是跟踪通道的线跟踪，该函数也可以从World对象中获得。对象类型与我们将在下一章中涵盖的主题相关，因此我们暂时不会详细介绍这个函数。
- en: The Camera Trace Channel
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机跟踪通道
- en: 'When changing our cube''s response to the `Visibility` Trace Channel, you may
    have noticed the other out-of-the-box Trace Channel: `Camera`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当将我们的立方体的响应更改为`Visibility`跟踪通道时，您可能已经注意到了另一个内置的跟踪通道：`Camera`。
- en: This channel is used to specify whether an object blocks the line of sight between
    the camera's spring arm and the character it's associated with. In order to see
    this in action, we can drag an object to our level and place it in such a way
    that it will stay between the camera and our player character.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该通道用于指定对象是否阻挡了摄像机弹簧臂和其关联的角色之间的视线。为了看到这一点，我们可以将一个对象拖到我们的级别中，并将其放置在这样一种方式，即它将保持在摄像机和我们的玩家角色之间。
- en: Have a look at the following example; we begin by duplicating the `floor` object.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例；我们首先复制“floor”对象。
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can easily duplicate an object in the level by holding the *Alt* key and
    dragging one of the *Move Tool*'s arrows in any direction.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按住*Alt*键并沿任何方向拖动*移动工具*的箭头来轻松复制级别中的对象。
- en: '![Figure 5.14: Floor object being selected'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：选择地板对象'
- en: '](img/B16183_05_14.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_14.jpg)'
- en: 'Figure 5.14: Floor object being selected'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：选择地板对象
- en: 'Next, we change its `Transform` values as shown in the following figure:![Figure
    5.15: Updating the Transform values'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更改其`Transform`值，如下图所示：![图5.15：更新变换值
- en: '](img/B16183_05_15.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_15.jpg)'
- en: 'Figure 5.15: Updating the Transform values'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：更新变换值
- en: 'Now when you play your game, you''ll notice that when the character goes under
    our duplicated floor object, you won''t lose sight of the player''s character,
    but rather the spring arm will cause the camera to move down until you can see
    the character:![Figure 5.16: Changes in the camera angle'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当您玩游戏时，您会注意到当角色走到我们复制的地板下方时，您不会失去对玩家角色的视线，而是弹簧臂会使摄像机向下移动，直到您能看到角色：![图5.16：摄像机角度的变化
- en: '](img/B16183_05_16.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_16.jpg)'
- en: 'Figure 5.16: Changes in the camera angle'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16：摄像机角度的变化
- en: In order to see how the spring arm's behavior differs when an object isn't blocking
    the `Camera` Trace Channel, change our duplicated floor's response to the `Camera`
    channel to `Ignore` and play the level again. What will happen is that, when our
    character goes under the duplicated floor, we will lose sight of the character.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到当对象不阻挡`Camera`跟踪通道时弹簧臂的行为如何不同，将我们复制的地板对`Camera`通道的响应更改为`Ignore`，然后再次播放级别。结果将是，当我们的角色走到复制的地板下方时，我们将失去对角色的视线。
- en: After you've done these steps, you can see that the `Camera` channel is used
    to specify whether an object will cause the spring arm to move the camera closer
    to the player when it intersects that object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您会发现“摄像机”通道用于指定对象是否会导致弹簧臂将摄像机靠近玩家当它与该对象相交时。
- en: Now that we know how to use the existing Trace Channels, what if we wanted to
    create our own Trace Channels?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用现有的跟踪通道，那么如果我们想创建自己的跟踪通道呢？
- en: 'Exercise 5.05: Creating a Custom EnemySight Trace Channel'
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：创建自定义EnemySight跟踪通道
- en: 'As we''ve discussed before, UE4 comes with two out-of-the-box Trace Channels:
    `Visibility` and `Camera`. The first one is a general-use channel that we can
    use to specify which objects block the line of sight of an object, while the second
    one allows us to specify whether an object blocks the line of sight between the
    camera''s spring arm and the character it''s associated with.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论过的，UE4自带两个跟踪通道：`Visibility`和`Camera`。第一个是一个通用通道，我们可以用它来指定哪些对象阻挡了对象的视线，而第二个允许我们指定对象是否阻挡了摄像机弹簧臂和其关联的角色之间的视线。
- en: 'But how can we create our own Trace Channels? That''s what we''ll be looking
    into in this exercise. We will create a new `EnemySight` Trace Channel and use
    it to check whether the enemy can see the player character, instead of the built-in
    `Visibility` channel:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何创建自己的跟踪通道呢？这就是我们将在本练习中探讨的内容。我们将创建一个新的`EnemySight`跟踪通道，并使用它来检查敌人是否能看到玩家角色，而不是使用内置的`Visibility`通道：
- en: Open `Project Settings` by pressing the `Edit` button at the top-left corner
    of the editor, and go to the `Collision` section. There you'll find the `Trace
    Channels` section. It's currently empty because we haven't yet created any of
    our own Trace Channels.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按编辑器左上角的“编辑”按钮打开“项目设置”，然后转到“碰撞”部分。在那里，您会找到“跟踪通道”部分。它目前为空，因为我们还没有创建自己的跟踪通道。
- en: Select the `New Trace Channel` option. A window should pop up, giving you the
    option to name your new channel and set its default response by the objects in
    your project. Name our new Trace Channel `EnemySight` and set its default response
    to `Block`, because we want most objects to do exactly that.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`New Trace Channel`选项。一个窗口应该弹出，让您可以命名您的新通道，并根据您项目中的对象设置其默认响应。将我们的新Trace通道命名为`EnemySight`，并将其默认响应设置为`Block`，因为我们希望大多数对象都这样做。
- en: 'After you''ve created the new Trace Channel, we must go back to our `EnemyCharacter`
    C++ class and change the trace we''re comparing against in our Line Trace:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的Trace通道后，我们必须回到我们的`EnemyCharacter` C++类中，并更改我们在Line Trace中比较的Trace：
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Given that we are no longer using the `Visibility` channel, we must reference
    our new channel, but how do we do that?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们不再使用`Visibility`通道，我们必须引用我们的新通道，但我们该如何做呢？
- en: In your project's directory, you'll find the `Config` folder. This folder contains
    several `ini` files related to your project, such as `DefaultGame.ini`, `DefaultEditor.ini`,
    `DefaultEngine.ini`, and so on. Each of these contains several properties that
    will be initialized when the project is loaded. The properties are set by name-value
    pairs (`property=value`), and you can change their values as desired.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录中，您会找到`Config`文件夹。该文件夹包含与您的项目相关的几个`ini`文件，如`DefaultGame.ini`，`DefaultEditor.ini`，`DefaultEngine.ini`等。每个文件都包含在加载项目时将被初始化的几个属性。这些属性以名称-值对(`property=value`)的形式设置，您可以根据需要更改它们的值。
- en: 'When we created our `EnemySight` channel, the project''s `DefaultEngine.ini`
    file was updated with our new Trace Channel. Somewhere in that file, you''ll find
    this line:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建了我们的`EnemySight`通道时，项目的`DefaultEngine.ini`文件将被更新为我们的新Trace通道。在那个文件的某个地方，您会找到这一行：
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Verify that our enemy's behavior remains the same after all the changes we've
    made. This means that the enemy must still face the player's character, as long
    as it's within view of said enemy.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的敌人在我们所做的所有更改之后行为是否保持不变。这意味着只要玩家角色在敌人的视野范围内，敌人就必须面对玩家角色。
- en: By completing this exercise, we now know how to make our own Trace Channels
    for any desired purpose.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们现在知道如何为任何所需的目的创建我们自己的Trace通道。
- en: Going back to our enemy character, there are still ways that we can improve
    its logic. Right now, when we fetch our enemy's location as the start point of
    the Line Trace, that point is somewhere around the enemy's hip, because that's
    where the origin of the Actor is. However, that's not usually where people's eyes
    are, and it wouldn't make much sense to have a humanoid character looking from
    its hip instead of its head.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的敌人角色，还有一些方法可以改进它的逻辑。现在，当我们获取我们敌人的位置作为Line Trace的起点时，那个点大约在敌人的臀部附近，因为那是Actor的原点。然而，那通常不是人们的眼睛所在的地方，让一个类人角色从它的臀部而不是头部看会没有多大意义。
- en: So, let's change that, and have our enemy character check whether it sees the
    player character starting from its eyes, instead of its hip.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们改变一下，让我们的敌人角色从它的眼睛开始检查是否看到玩家角色，而不是从它的臀部开始。
- en: 'Activity 5.01: Creating the SightSource Property'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：创建SightSource属性
- en: In this activity, we will be improving our enemy's logic to determine whether
    it should look at the player. Currently, the Line Trace that's being done to determine
    that is being *shot* from around our character's hips, (`0,0,0`) in our `BP_EnemyCharacter`
    blueprint, and we want this to make a bit more sense, so we'll make it so that
    the Line Trace starts somewhere close to our enemy's eyes. Let's get started then.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将改进我们敌人的逻辑，以确定它是否应该看着玩家。目前，用于确定这一点的Line Trace是从我们角色的臀部附近(`0,0,0`)在我们的`BP_EnemyCharacter`蓝图中进行的，我们希望这更有意义一些，所以我们将使Line
    Trace的起点接近我们敌人的眼睛。那么，让我们开始吧。
- en: 'The following steps will help you complete the activity:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个活动：
- en: Declare a new `SceneComponent` in our `EnemyCharacter` C++ class called `SightSource`.
    Make sure to declare this as a `UPROPERTY` with the `VisibleAnywhere`, `BlueprintReadOnly`,
    `Category = LookAt` and `meta = (AllowPrivateAccess = "true")` tags.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`EnemyCharacter` C++类中声明一个名为`SightSource`的新`SceneComponent`。确保将其声明为`UPROPERTY`，并使用`VisibleAnywhere`，`BlueprintReadOnly`，`Category
    = LookAt`和`meta = (AllowPrivateAccess = "true")`标签。
- en: Create this component in the `EnemyCharacter` constructor by using the `CreateDefaultSubobject`
    function, and attach it to the `RootComponent`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`CreateDefaultSubobject`函数在`EnemyCharacter`构造函数中创建这个组件，并将其附加到`RootComponent`。
- en: Change the start location of the Line Trace in the `CanSeeActor` function to
    the `SightSource` component's location, instead of the Actor's location.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Line Trace的起始位置更改为`CanSeeActor`函数中的`SightSource`组件的位置，而不是Actor的位置。
- en: Open the `BP_EnemyCharacter` Blueprint class and change the `SightSource` component's
    location to the location of the enemy's head, `(10, 0, 80)`, as was done in the
    *Creating the EnemyCharacter Blueprint Class* section to the `SkeletalMeshComponent`
    property of `BP_EnemyCharacter`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_EnemyCharacter`蓝图类，并将`SightSource`组件的位置更改为敌人头部的位置`(10, 0, 80)`，就像在*创建EnemyCharacter蓝图类*部分中对`BP_EnemyCharacter`的`SkeletalMeshComponent`属性所做的那样。
- en: '`Transform` tab in the `Editor Panel` as shown in *Figure 5.17*.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor Panel`中的`Transform`选项卡，如*图5.17*所示。'
- en: '![Figure 5.17: Updating the SightSource component’s values'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.17：更新SightSource组件的值'
- en: '](img/B16183_05_17.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_17.jpg)'
- en: 'Figure 5.17: Updating the SightSource component''s values'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17：更新SightSource组件的值
- en: 'Expected output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 5.18: Expected output showing the updated Line Trace from the hip
    to the eye'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18：预期输出显示从臀部到眼睛的更新的Line Trace'
- en: '](img/B16183_05_18.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_05_18.jpg)'
- en: 'Figure 5.18: Expected output showing the updated Line Trace from the hip to
    the eye'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18：预期输出显示从臀部到眼睛的更新的Line Trace
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在这里找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: By completing this activity, we have updated our `SightSource` property for
    our `EnemyCharacter`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，我们已经更新了我们的`EnemyCharacter`的`SightSource`属性。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'By completing this chapter, you have added a new tool to your belt: Line Traces.
    You now know how to execute Line Traces and Sweep Traces, both Single and Multi;
    how to change an object''s response to a specific Trace Channel; and how to create
    your own Trace Channels.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这一章，你已经为自己的工具箱增添了一个新工具：线性跟踪。你现在知道如何执行线性跟踪和扫描跟踪，包括单一和多重；如何改变对象对特定跟踪通道的响应；以及如何创建自己的跟踪通道。
- en: You will quickly realize in the chapters ahead that these are essential skills
    when it comes to game development, and you will make good use of them on your
    future projects.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将很快意识到这些是游戏开发中必不可少的技能，并且你将在未来的项目中充分利用它们。
- en: Now that we know how to use Line Traces, we're ready for the next step, which
    is Object Collision. In the next chapter, you will learn how to set up collisions
    between objects and how to use collision events to create your own game logic.
    You will create the Dodgeball Actor, which will be affected by real-time physics
    simulation; the Wall Actors, which will block both the characters' movements and
    the dodgeball; and the Actor responsible for ending the game when the player comes
    into contact with it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用线性跟踪，我们已经准备好迈出下一步，即对象碰撞。在下一章中，你将学习如何设置对象之间的碰撞，以及如何使用碰撞事件来创建自己的游戏逻辑。你将创建躲避球角色，它将受到实时物理模拟的影响；墙角色，它将阻挡角色的移动和躲避球的移动；以及负责在玩家接触到它时结束游戏的角色。
