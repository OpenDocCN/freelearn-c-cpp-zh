- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Things to Be Careful With
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要小心的事情
- en: So, you decided to read a book about memory management in C++ and are as ready
    to look at the high-level approaches and techniques as you are willing to “get
    your hands dirty”, so to speak, in order to get fine-grained control over the
    memory management process. What an excellent plan!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你决定阅读一本关于C++内存管理的书，你愿意查看高级方法和技巧，就像你愿意“动手”一样，以便对内存管理过程有精细的控制。多么出色的计划！
- en: Since you know that you are going to be writing very high-level code, but also
    very low-level code, there are a few things we need to make sure you are aware
    of such that you do not get in trouble or write code that seems to work but does
    not, at least not portably.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你知道你将编写非常高级的代码，但也会编写非常底层的代码，有一些事情我们需要确保你意识到，这样你就不会陷入麻烦或编写看似工作但实际上并不工作（至少不是可移植的）的代码。
- en: In this chapter, we will point out some aspects of C++ programming that will
    come into play throughout this book, but that you should be careful with. This
    might look like a (very) small compendium of bad practices or an encouragement
    to get in trouble, but please consider what follows as ways to use somewhat dangerous
    or tricky features well. You’re using C++, you have significant freedom of expression,
    and you get access to features that are useful if you know and understand them
    well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将指出一些在本书中将发挥作用但你应该小心处理的C++编程方面。这看起来可能像（非常）小的不良实践汇编或鼓励你陷入麻烦，但请将以下内容视为使用某些危险或棘手特性的好方法。你使用C++，你有很大的表达自由，并且如果你了解并理解它们，你可以访问一些有用的特性。
- en: We want code that’s clean and efficient, and we want responsible programmers.
    Let’s try to get there together.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望代码干净高效，我们希望有责任感的程序员。让我们共同努力实现这个目标。
- en: 'In this chapter, we will learn about the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: We will cover some of the ways in which one can get into trouble with C++ code.
    Indeed, there are things a compiler cannot reliably diagnose, just as there are
    things for which the C++ standard does not say what will happen, and writing code
    that does such things is a recipe for disaster – or at the very least surprising
    or non-portable behavior.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将涵盖一些可能导致麻烦的C++代码的方式。确实，有些事情编译器无法可靠地诊断，就像有些事情C++标准没有说明会发生什么一样，编写执行这些事情的代码是灾难的配方——至少是令人惊讶或不可移植的行为。
- en: In particular, we will explore how one can get in trouble with pointers. Since
    this book discusses memory management, we will use pointers and pointer arithmetic
    quite often, and being able to distinguish appropriate uses thereof from inappropriate
    ones will be valuable.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尤其是我们将探讨一个人如何因为指针而陷入麻烦。由于这本书讨论了内存管理，我们将经常使用指针和指针运算，能够区分适当的用法和不适当的用法将非常有价值。
- en: Finally, we will discuss what kinds of type conversions we can do without resorting
    to type casts (the main subject of [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047)),
    and how rarely that’s a good idea, contrary to popular belief.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将讨论我们可以不使用类型转换（第3章的主要主题[*](B21071_03.xhtml#_idTextAnchor047)）进行哪些类型转换，以及这与普遍看法相反，这种情况很少是好的主意。
- en: Our overall goal will be to learn things we should not do (even though we will
    do some maneuvers that resemble them, on occasion), and avoid them thereafter,
    hopefully understanding why we do so. With that out of the way, we’ll have many
    chapters to look at things we *should* do, and how to do them well!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整体目标将是学习我们不应该做的事情（尽管有时我们也会做一些类似的操作），并在之后避免它们，希望理解我们这样做的原因。解决了这个问题之后，我们将有大量的章节来探讨我们应该做的事情，以及如何做好它们！
- en: Different kinds of evil
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的邪恶类型
- en: Before delving into some actual practices that require care, it’s interesting
    to look at the main categories of risks we could run into if our code does not
    respect the rules of the language. With each such category comes a form of unpleasantness
    we should strive to avoid.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究需要谨慎处理的一些实际实践之前，看看如果我们的代码不遵守语言规则，我们可能会遇到的主要风险类别是很有趣的。每个这样的类别都伴随着一种我们应该努力避免的不愉快。
- en: Ill-formed, no diagnostic required
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 形式不当，无需诊断
- en: Some constructs in C++ are said to be **Ill-Formed, No Diagnostic Required**
    (**IFNDR**). Indeed, you will find quite a few occurrences in the standard of
    *“if […], the program is ill-formed, with no diagnostic required.”* When something
    is IFNDR, it means your program is broken. Bad things could happen, but the compiler
    is not required to tell you about them (indeed, sometimes, the compiler does not
    have sufficient information to diagnose the problematic situation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的一些结构被称为**不合法，无需诊断**（**IFNDR**）。确实，你会在标准中找到许多类似“如果[...], 程序是不合法的，无需诊断。”的表述。当某物是IFNDR时，意味着你的程序是有问题的。可能会发生一些不好的事情，但编译器不需要告诉你（实际上，有时编译器没有足够的信息来诊断问题情况）。
- en: '`alignas`) in different translation units (different source files, essentially),
    or having a constructor that delegates to itself either directly or indirectly.
    Here is an example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`alignas`)在不同的翻译单元（基本上是不同的源文件）中，或者有一个构造函数直接或间接地委托给自己。以下是一个示例：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that your compiler might give a diagnostic; it’s just not required to do
    so. It’s not that compilers are lazy – they might even be unable to provide a
    diagnostic in some cases! So, be careful not to write code that leads to IFNDR
    situations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的编译器可能会给出诊断信息；但这不是强制要求的。并不是编译器懒惰——在某些情况下，它们甚至可能无法提供诊断信息！因此，要小心不要编写导致IFNDR（无需诊断）情况的代码。
- en: Undefined behavior
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不确定行为
- en: 'We mentioned **Undefined Behavior** (**UB**) in [*Chapter 1*](B21071_01.xhtml#_idTextAnchor016).
    UB is often seen as a source of headaches and pain for C++ programmers but it
    refers to any behavior for which the C++ standard imposes no requirement. In practice,
    this means that if you write code that contains UB, you have no idea what’s going
    to happen at runtime (at least if you’re aiming for somewhat portable code). Canonical
    examples of UB include dereferencing a null pointer or an uninitialized pointer:
    do that and you’ll be in serious trouble.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第一章*](B21071_01.xhtml#_idTextAnchor016)中提到了**不确定行为**（**UB**）。UB通常被视为C++程序员头痛和痛苦的原因，但它指的是C++标准没有要求的任何行为。在实践中，这意味着如果你编写的代码包含UB，你不知道运行时会发生什么（至少如果你希望代码具有一定的可移植性）。UB的典型例子包括解引用空指针或未初始化的指针：这样做会让你陷入严重的麻烦。
- en: 'To compilers, UB is not supposed to happen (code that respects the rules of
    the language does not contain UB, after all). For that reason, compilers “optimize
    around” code that contains UB, to sometimes surprising effect: they might begin
    removing tests and branches, optimizing loops away, and so on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器来说，UB不应该发生（毕竟，尊重语言规则的代码不包含UB）。因此，编译器会“围绕”包含UB的代码进行优化，有时会产生令人惊讶的效果：它们可能会开始移除测试和分支、优化循环等。
- en: The effects of UB tend to be local. For instance, in the following example,
    there is a test that ensures that `p` is not null before using `*p` in one case,
    but there is at least one access to `*p` that is unchecked. This code is broken
    (the unchecked access to `*p` is UB), so the compiler is allowed to rewrite it
    in such a way that all tests to verify that `p` is not null are effectively removed.
    After all, the damage would be done if `p` were `nullptr`, so the compiler is
    entitled to assume that the programmer passed a non-null pointer to the function!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: UB的影响往往局限于局部。例如，在以下示例中，有一个测试确保在使用`*p`之前`p`不是空指针，但至少有一个对`*p`的访问是没有检查的。这段代码是有问题的（未检查的`*p`访问是UB），因此编译器允许以这种方式重写它，从而有效地移除所有验证`p`不是空指针的测试。毕竟，如果`p`是`nullptr`，那么损害已经造成，因此编译器有权利假设程序员传递了一个非空指针给函数！
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The whole body of `f()` could legitimately be rewritten by your compiler as
    `return g(*p)` in this case, with the `return *p` statement being turned into
    unreachable code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器可以合法地将整个`f()`函数体重写为`return g(*p)`，将`return *p`语句转换为不可达代码。
- en: The potential for UB hides in various places in the language, including signed
    integer overflow, accessing an array out of bounds, data races, and so on. There
    are ongoing efforts to reduce the number of potential UB cases (there’s even a
    study group, **SG12**, dedicated to this effort), but UB will likely remain part
    of the language for the foreseeable future, and we need to be aware of it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中存在潜在的不确定行为（UB）的多个地方，包括有符号整数溢出、访问数组越界、数据竞争等。目前有持续的努力在减少潜在UB案例的数量（甚至有一个专门致力于此的**SG12**研究小组），但UB可能在未来一段时间内仍然是语言的一部分，我们需要对此有所警觉。
- en: Implementation-defined behavior
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现定义的行为
- en: Some parts of the standard fall under the umbrella of **implementation-defined
    behavior**, or behavior that you can count on with a specific platform. This is
    behavior that your platform of choice is supposed to document, but that is not
    guaranteed to be portable to other platforms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中的一些部分属于**实现定义的行为**范畴，或者说是你可以依赖特定平台的行为。这种行为是你选择的平台应该记录的，但并不保证可以移植到其他平台。
- en: 'Implementation-defined behavior occurs in many situations and includes such
    things as implementation-defined limits: the maximum number of nested parentheses;
    the maximum number of case labels in a switch statement; the actual size of an
    object; the maximum number of recursive calls in a `constexpr` function; the number
    of bits in a byte; and so on. Other well-known cases of implementation-defined
    behavior include the number of bytes in an `int` object or whether the `char`
    type is a signed or an unsigned integral type.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实现定义的行为出现在许多情况下，包括如下事物：实现定义的限制，例如最大嵌套括号数；switch语句中的最大case标签数；对象的实际大小；`constexpr`函数中的最大递归调用数；字节中的位数；等等。其他已知的实现定义行为案例包括`int`对象中的字节数或`char`类型是有符号还是无符号整型。
- en: Implementation-defined behavior is not really a source of evil, but it can be
    problematic if one strives for portable code but depends on some non-portable
    assumptions. It is sometimes useful to spell one’s assumptions in code through
    `static_assert` when the assumption can be validated at compile-time or some similar,
    potentially runtime mechanisms in order to realize—before it’s too late—that these
    assumptions are broken for a given target platform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实现定义的行为本身并不是邪恶的源头，但如果追求可移植代码但依赖于一些不可移植的假设，则可能会出现问题。有时，当假设可以在编译时或类似的潜在运行时机制中验证时，通过`static_assert`在代码中表达这些假设是有用的，以便在为时已晚之前意识到这些假设对于特定目标平台是错误的。
- en: 'For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unless you are convinced that your code will never need to be ported to another
    platform, strive to rely as little as possible on implementation-defined behavior,
    and if you do, make sure that you validate (through `static_assert` if possible,
    at runtime if there’s no other choice) and document this situation. It might help
    you avoid some nasty surprises in the future.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你确信你的代码永远不会需要移植到另一个平台，否则应尽可能少地依赖实现定义的行为，并且如果确实需要，确保通过`static_assert`（如果可能的话）或运行时（如果没有其他选择）验证并记录这种情况。这可能会帮助你避免未来的一些令人不快的惊喜。
- en: Unspecified behavior (not documented)
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未指定行为（未记录）
- en: Where implementation-defined behavior is non-portable but documented for a given
    platform, unspecified behavior is a behavior that, even for a well-formed program
    given correct data, behaves in a way that depends on the implementation but does
    not need to be documented.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现定义的行为在特定平台上不可移植但有文档记录时，未指定行为是指即使对于给定正确数据的良好格式程序，其行为也依赖于实现但不需要记录的行为。
- en: Some cases of unspecified behavior include the state of a moved-from object
    (said to be `f(g(),h())` will evaluate `g()` or `h()` first, the values in a newly
    allocated chunk of memory, and so on. This latter example is interesting to our
    study; a debug build might fill newly allocated chunks of memory with a recognizable
    bit pattern to help in the debugging process, and an optimized build with the
    same toolset could leave the initial bits of a newly allocated chunk of memory
    “uninitialized”, with the bits it held at the time when the allocation was performed,
    to get speed improvements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些未指定行为的案例包括已移动对象的状体（例如，`f(g(),h())`将首先评估`g()`或`h()`，新分配内存块中的值等）。这个后者的例子对我们研究很有趣；调试构建可能会用可识别的位模式填充新分配的内存块以帮助调试过程，而使用相同工具集的优化构建可能会留下新分配内存块初始位的“未初始化”，保留分配时的位，以获得速度提升。
- en: The ODR
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ODR
- en: 'The ODR, simply summarized, states that there shall be only one definition
    of each “thing” (function, object in a scope, enumeration, template, and so on)
    in a translation unit, although there can be multiple declarations of that thing.
    Consider the following example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ODR（One Definition Rule，单一定义规则）简单来说，就是在一个翻译单元中，每个“事物”（函数、作用域中的对象、枚举、模板等）只能有一个定义，尽管可以有多个声明。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In C++, avoiding ODR violations is important, as these “evils” can escape the
    compiler’s scrutiny and fall into the realm of IFNDR situations. For example,
    due to the separate compilation of source files, a header file containing the
    definition of a non-`inline` function will lead to that definition being replicated
    in each source file that includes that same header. Then, each compilation might
    succeed, and the fact that there are multiple definitions of that function in
    the same build might be detected later (at link time) or just left undetected
    and cause havoc.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，避免 ODR 违反很重要，因为这些“邪恶”可以逃过编译器的审查，落入 IFNDR 情境。例如，由于源文件的独立编译，包含非 `inline`
    函数定义的头文件会导致该定义在每个包含该头文件的源文件中重复。然后，每次编译可能都会成功，而同一构建中该函数存在多个定义的事实可能在稍后（在链接时）被发现，或者根本未被检测到，从而造成混乱。
- en: Erroneous behavior
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误行为
- en: Ongoing security-related efforts in C++ have led to discussions on a new kind
    of “evil” tentatively named *erroneous behavior*. This new category is meant to
    cover situations that could have been UB in the past, but for which we could issue
    diagnostics and provide well-defined behavior. The behavior would still be incorrect,
    but erroneous behavior would, in a way, provide boundaries to the consequences.
    Note that work on erroneous behavior is ongoing as of this writing, and this new
    wording feature might target C++26.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中持续进行的与安全相关的工作导致了对一种新类型的“邪恶”的讨论，这种类型暂时被命名为 *错误行为*。这个新类别旨在涵盖过去可能被视为未定义行为（UB）的情况，但对于这些情况，我们可以提供诊断并定义良好的行为。这种行为仍然是不正确的，但错误行为在某种程度上为后果提供了边界。请注意，截至本文撰写时，错误行为的这项工作仍在进行中，这个新的措辞功能可能针对
    C++26。
- en: One use case envisioned for erroneous behavior is reading from an uninitialized
    variable, where the implementation could (for safety reasons) provide a fixed
    value for the bits read, and the conceptual error that stems from reading that
    variable would be something that implementations are encouraged to diagnose. Another
    use case would be forgetting to return a value from a non-void assignment operator.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 错误行为的预期用例之一是从未初始化的变量中读取，实现（出于安全原因）可以为读取的位提供固定值，从读取该变量产生的概念性错误是实施者鼓励诊断的东西。另一个用例是忘记从非
    void 赋值运算符返回值。
- en: Now that we’ve looked at the large “families” of unpleasantness that might hit
    our programs if we don’t behave, let’s delve into some of the main facilities
    that could get us in trouble and see what we should avoid doing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如果不行为可能会影响我们程序的许多“不愉快”的“家族”，让我们深入研究一些可能会让我们陷入麻烦的主要设施，并看看我们应该避免做什么。
- en: Pointers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: '[*Chapter 1*](B21071_01.xhtml#_idTextAnchor016) looked at pointers in C++ in
    the sense of what they represent and what they mean. It described what pointer
    arithmetic is, and what it allows us to do. We will now examine practical uses
    of pointer arithmetic, with both proper and improper uses of this low-level (but
    sometimes precious) tool.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第一章*](B21071_01.xhtml#_idTextAnchor016) 讨论了 C++ 中指针的概念及其所代表的意义。它描述了指针算术是什么，以及它允许我们做什么。现在，我们将探讨指针算术的实际应用，包括这个低级（但有时宝贵）工具的恰当和不恰当使用。'
- en: Uses of pointer arithmetic within an array
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中使用指针算术
- en: 'Pointer arithmetic is a nice and useful tool, but it’s a sharp one that tends
    to be misused. With raw arrays, the following two loops, labeled `A` and `B`,
    behave in exactly the same way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 指针算术是一个既好又实用的工具，但它是一把锋利的工具，往往被误用。对于原始数组，以下两个标记为 `A` 和 `B` 的循环的行为完全相同：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You might wonder about the `vals + N` part in loop `B`, but it’s valid (and
    idiomatic) C++ code. You can observe the pointer just past the end of an array,
    even though you’re not allowed to observe what it points to; the standard guarantees
    that this specific one-past-the-end address is accessible to your program. However,
    no such guarantee is provided for the following address, so be careful!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对循环 `B` 中的 `vals + N` 部分感到好奇，但它是有效的（并且是惯用的）C++ 代码。你可以观察到数组末尾之后的指针，尽管你不允许观察它指向的内容；标准保证这个特定的一个超出末尾的地址对你的程序是可访问的。然而，对于下一个地址，没有这样的保证，所以请小心！
- en: 'As long as you respect the rules, you can use pointers to jump back and forth
    within an array. If you overreach and use a pointer to go further than one past-the-end,
    you will end up in UB territory; that is, you might be trying to access an address
    that’s not in your process’ address space:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你遵守规则，你就可以使用指针在数组内部跳来跳去。如果你超出了范围，并使用指针超出数组末尾一个位置，你将进入UB区域；也就是说，你可能会尝试访问不在你的进程地址空间中的地址：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pointer interconvertibility
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针可转换性
- en: 'The C++ standard defines what it means for an object to be `reinterpret_cast`
    (we will expand on this in [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047)), as
    they have the same address. Broadly speaking, the following points hold true:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准定义了对象如何进行`reinterpret_cast`（我们将在[*第3章*](B21071_03.xhtml#_idTextAnchor047)中详细说明），因为它们具有相同的地址。广义上，以下几点是正确的：
- en: An object is pointer-interconvertible with itself
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象与其自身是可指针转换的
- en: A `union` is pointer-interconvertible with its data members, as well as their
    first data member if they are compound types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`union`与其数据成员是可指针转换的，如果它们是复合类型，则还包括其第一个数据成员
- en: With some restrictions, `x` and `y` are pointer-interconvertible with one another
    if one is an object and the other one is of the same type as the first non-static
    data member of that object
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些限制下，如果`x`是一个对象而`y`是那个对象的第一个非静态数据成员的类型，那么`x`和`y`是可指针转换的
- en: 'Some examples are included here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含了一些示例：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you try to apply `reinterpret_cast` in a way that does not respect pointer-interconvertibility
    rules, your code is technically incorrect and is not guaranteed to work in practice.
    Don’t do that.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试以不尊重指针可转换性规则的方式应用`reinterpret_cast`，你的代码在技术上是不正确的，并且在实践中不一定能保证工作。不要这样做。
- en: We will occasionally use the pointer-interconvertibility property in our code
    examples, including in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码示例中偶尔使用指针可转换性属性，包括在下一节中。
- en: Uses of pointer arithmetic within an object
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在对象内使用指针算术的应用
- en: Pointer arithmetic within an object is also allowed in C++, although one should
    be careful about how this is handled (using the appropriate casts, which we will
    explore in [*Chapter 3*](B21071_03.xhtml#_idTextAnchor047), and ensuring that
    one performs pointer arithmetic appropriately).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，对象内的指针算术也是允许的，尽管人们应该小心处理这一点（使用适当的类型转换，我们将在[*第3章*](B21071_03.xhtml#_idTextAnchor047)中探讨，并确保适当地执行指针算术）。
- en: 'For example, the following code is correct, albeit not something one should
    seek to do (it makes no sense, and it does things in unnecessarily complicated
    ways, but it’s legal and does no harm):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是正确的，尽管这不是人们应该追求的事情（这没有意义，它以不必要的复杂方式做事，但它是合法的，并且不会造成伤害）：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will not abuse this aspect of the C++ language in this book, but we do need
    to be aware of it in order to write correct, low-level code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中滥用C++语言的这一方面，但我们需要意识到它，以便编写正确、低级别的代码。
- en: About the difference between pointer and address
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于指针和地址的区别
- en: 'In order to strengthen hardware and software security, there has been work
    on hardware architectures that can provide a form of “pointer tagging”, which
    allows the hardware tracking of pointer provenance, among other things. Two well-known
    examples are the CHERI architecture ([https://packt.link/cJeLo](https://packt.link/cJeLo))
    and **Memory Tagging Extensions** (**MTEs**) (Linux: [https://packt.link/KXeRn](https://packt.link/KXeRn)
    | Android: [https://packt.link/JDfEo](https://packt.link/JDfEo), and [https://packt.link/fQM2T](https://packt.link/fQM2T)|
    Windows: [https://packt.link/DgSaH](https://packt.link/DgSaH)).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '为了加强硬件和软件安全，人们已经在可以提供“指针标记”形式的硬件架构上进行了工作，这允许硬件跟踪指针来源，以及其他方面。两个著名的例子是CHERI架构([https://packt.link/cJeLo](https://packt.link/cJeLo))和**内存标记扩展**(**MTEs**)（Linux:
    [https://packt.link/KXeRn](https://packt.link/KXeRn) | Android: [https://packt.link/JDfEo](https://packt.link/JDfEo),
    和 [https://packt.link/fQM2T](https://packt.link/fQM2T)| Windows: [https://packt.link/DgSaH](https://packt.link/DgSaH))）。'
- en: To benefit from such hardware, the language needs to distinguish between the
    low-level idea of addresses and the high-level idea of pointers, as the latter
    could take into account the fact that a pointer is more than just a memory location.
    If your code absolutely needs to compare unrelated pointers for ordering, one
    thing you can do is cast the pointers to `std::intprt_t` or to `std::uintptr_t`
    and compare the (numeric) results instead of comparing the actual pointers. Note
    that compiler support for those two types is optional, although all major compiler
    vendors offer it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这样的硬件，语言需要区分地址的低级概念和指针的高级概念，因为后者需要考虑到指针不仅仅是内存位置。如果你的代码绝对需要比较无关的指针以确定顺序，你可以做的一件事是将指针转换为`std::intptr_t`或`std::uintptr_t`，然后比较（数值）结果而不是比较实际的指针。请注意，编译器对这两种类型的支持是可选的，尽管所有主要的编译器供应商都提供了它。
- en: The null pointer
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空指针
- en: The idea of a null pointer as a recognizable value for pointers that lead to
    nowhere valid can be traced back to C.A.R. Hoare ([https://packt.link/ByfeX](https://packt.link/ByfeX)).
    In the C language, through the `NULL` macro, it has been represented first as
    a `char*` of value `0`, then as a `void*` of value `0`, then in C++ as value `0`
    simply since such things as `int *p = NULL;` with a typed `NULL` were legal C
    but not legal C++. This is because the type system is stricter in C++. Note that
    a pointer with value `0` does not mean “point to address zero” as this address
    is in itself perfectly valid and is used as such on many platforms.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针作为指向无效位置的指针的可识别值的想法可以追溯到C.A.R. Hoare ([https://packt.link/ByfeX](https://packt.link/ByfeX))。在C语言中，通过`NULL`宏，它最初被表示为一个值为`0`的`char*`，然后是一个值为`0`的`void*`，然后在C++中，由于像`int
    *p = NULL;`这样的带有类型`NULL`的语句在C中是合法的，但在C++中不是，所以它简单地表示值为`0`。这是因为C++的类型系统更加严格。请注意，值为`0`的指针并不意味着“指向地址零”，因为这个地址本身是完全有效的，并且在许多平台上被这样使用。
- en: 'In C++, the preferred way of expressing a null pointer is `nullptr`, an object
    of the `std::nullptr_t` type that converts to pointers of any type and behaves
    as expected. This solves some longstanding issues with literal `0` in C++, such
    as the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，表达空指针的首选方式是`nullptr`，这是一个`std::nullptr_t`类型的对象，它可以转换为任何类型的指针，并按预期行为。这解决了C++中一些长期存在的问题，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `nullptr` is not a pointer; it’s an object that implicitly converts
    to a pointer. For that reason, the `std::is_pointer_v<nullptr>` trait is false,
    and C++ offers a distinct trait named `std::is_null_pointer<T>` to statically
    test whether `T` is a `std::nullptr_t` or not (taking `const` and `volatile` into
    account).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nullptr`不是一个指针；它是一个可以隐式转换为指针的对象。因此，`std::is_pointer_v<nullptr>`特性是假的，C++提供了一个名为`std::is_null_pointer<T>`的独立特性，用于静态测试`T`是否是`std::nullptr_t`（考虑`const`和`volatile`）。
- en: 'Dereferencing a null pointer is UB, just as dereferencing an uninitialized
    pointer is. The point of using `nullptr` in your code is to make that state recognizable:
    `nullptr` is a distinguishable value, whereas an uninitialized pointer could be
    anything.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用空指针是未定义的行为，就像解引用未初始化的指针一样。在代码中使用`nullptr`的目的就是为了使这种状态可识别：`nullptr`是一个可区分的值，而未初始化的指针可能什么都是。
- en: 'In C++ (contrary to C), arithmetic on a null pointer is well-defined… as long
    as you add zero to the null pointer. Or, to put it differently: if you add zero
    to a null pointer, the code remains well-defined, but if you add anything else,
    you’re on your own. There’s an explicit provision to that effect in wg21.link/c++draft/expr.add#4.1\.
    This means that the following is correct as in the case of an empty `Array`, `begin()`
    yields `nullptr` and `size()` yields zero, so `end()` effectively computes `nullptr+0`,
    which respects the rules:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中（与C不同），对空指针进行算术运算是有明确定义的……只要你在空指针上加上零。或者，换一种说法：如果你在空指针上加上零，代码仍然是有定义的，但如果你加上任何其他东西，那就得你自己负责了。在wg21.link/c++draft/expr.add#4.1中有一个明确的规定。这意味着以下情况是正确的，就像空`数组`的情况一样，`begin()`返回`nullptr`，`size()`返回零，所以`end()`实际上计算的是`nullptr+0`，这符合规则：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will return to this `Array` example in more detail in *Chapters 12*, *13*,
    and *14*; it will help us discuss several important aspects of efficient memory
    management techniques. For now, let’s look at another source of risky programming
    maneuvers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第12章、第13章和第14章中更详细地回到这个`数组`示例；这将帮助我们讨论高效内存管理技术的一些重要方面。现在，让我们看看另一个危险的编程操作来源。
- en: Type punning
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: Another area where a C++ programmer can get into trouble is **type punning**.
    By type punning, we mean techniques that subvert the language’s type system somewhat.
    The consecrated tool to perform type conversions is casts, as they are explicit
    in source code text and (apart from C-style casts) express the intent for the
    conversion, but that topic deserves its own chapter ([*Chapter 3*](B21071_03.xhtml#_idTextAnchor047),
    if you’re wondering).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员可能陷入麻烦的另一个领域是**类型欺骗**。通过类型欺骗，我们指的是在一定程度上颠覆语言类型系统的技术。执行类型转换的圣洁工具是类型转换，因为它们在源代码文本中是显式的，并且（除C风格类型转换外）表达了转换的意图，但这个主题值得单独成章（[*第3章*](B21071_03.xhtml#_idTextAnchor047)，如果你想知道的话）。
- en: In this section, we will examine other ways to achieve type punning, including
    both recommendable ones and others that you should seek to avoid.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨其他实现类型欺骗的方法，包括可推荐的方法和应避免的方法。
- en: Type punning through members of a union
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过联合成员进行类型欺骗
- en: A union is a type for which the members are all at the same address. The size
    of a union is the size of its largest member, and the alignment of a union is
    the strictest alignment of its members.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 联合是一种成员都位于同一地址的类型。联合的大小是其最大成员的大小，联合的对齐是其成员的最严格对齐。
- en: 'Consider the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s tempting to think that one can use a union to implicitly convert such things
    as a four-byte floating point number into a four-byte integral number, and in
    the C language (not C++), that is indeed possible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想到，可以使用`union`隐式地将诸如四字节的浮点数转换为四字节的整数，在C语言（而不是C++）中，这确实是可能的。
- en: 'Even though there is a widespread belief that this practice is legal in C++,
    the reality is that it is not (with one special caveat, which we will explore
    shortly). Indeed, in C++, the last member of a union one has written to is called
    the union’s `constexpr` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管广泛认为这种做法在C++中是合法的，但实际情况并非如此（有一个特殊的注意事项，我们将在稍后探讨）。实际上，在C++中，已写入的联合的最后一个成员被称为联合的`constexpr`函数：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you might know, a `constexpr` function such as `f()` in the preceding example
    cannot contain code that is UB if it is called in a `constexpr` context. This
    sometimes makes it an interesting tool to make a point.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在先前的示例中，像`f()`这样的`constexpr`函数不能包含在`constexpr`上下文中调用时会导致未定义行为的代码。这有时使其成为一个有趣的表达观点的工具。
- en: There is a caveat with respect to conversions between `union` members, and that
    caveat is associated with the common initial sequence.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`union`成员之间的转换方面存在一个注意事项，这个注意事项与公共初始序列有关。
- en: Common initial sequence
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共初始序列
- en: 'As explained at wg21.link/class.mem.general#23, the `A` and `B` is made of
    their first two members (`int` is layout-compatible with `const int` and `float`
    is layout-compatible with `volatile float`):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如在wg21.link/class.mem.general#23中解释的那样，`A`和`B`由它们的前两个成员组成（`int`与`const int`布局兼容，`float`与`volatile
    float`布局兼容）：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With a union, it is possible to read from a non-active member if the value
    read is part of both the common initial sequence of that member and of the active
    member. Here’s an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取的值是成员的公共初始序列和活动成员的一部分，则可以使用`union`从非活动成员中读取。以下是一个示例：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that such type punning should be kept to a minimum, as it can make it harder
    to reason about source code, but it can be quite useful. For example, it can be
    used to implement some interesting underlying representations for classes that
    can have two distinct representations (classes such as `optional` or `string`),
    making it easier to switch from one to the other. Some useful optimizations can
    be built on this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种类型欺骗应尽量减少，因为它可能会使推理源代码变得更加困难，但它非常有用。例如，它可以用来实现一些有趣的底层表示，这些表示对于可以有两个不同表示的类（例如`optional`或`string`）来说是有用的，这使得从一个切换到另一个变得更加容易。可以基于此构建一些有用的优化。
- en: The intptr_t and uintptr_t types
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: intptr_t和uintptr_t类型
- en: 'As mentioned earlier in this chapter, one cannot directly compare pointers
    to arbitrary locations in memory in a well-defined manner in C++. One can, however,
    compare the integral values associated with pointers in a well-defined manner,
    such as here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，在C++中，无法以定义良好的方式直接比较指向内存中任意位置的指针。然而，可以以定义良好的方式比较与指针相关联的整数值，如下所示：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `std::intptr_t` and `std::uintptr_t` types are aliases for integral types
    that are large enough to hold an address. Use the signed type, `intptr_t`, for
    operations that could lead to negative values (for example, subtraction).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::intptr_t` 和 `std::uintptr_t` 类型是足够大的整数类型的别名，可以容纳地址。对于可能导致负值操作（例如，减法）的情况，请使用有符号类型
    `intptr_t`。'
- en: The std::memcpy() function
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::memcpy()` 函数'
- en: 'For historical (and C compatibility) reasons, `std::memcpy()` is *special*
    as it can start the lifetime of an object if used appropriately. An incorrect
    use of `std::memcpy()` for type punning would be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史（和与 C 的兼容性）原因，`std::memcpy()` 是特殊的，因为它如果使用得当可以启动对象的生命周期。对 `std::memcpy()`
    的错误使用进行类型转换可能如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The reason why this is illegal is that the call to `std::memcpy()` copies a
    `float` object into the storage pointed to by `p`, effectively starting the lifetime
    of a `float` object in that storage. Since `q` is an `int*`, dereferencing it
    is UB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以非法，是因为对 `std::memcpy()` 的调用将一个 `float` 对象复制到由 `p` 指向的存储中，实际上是在那个存储中启动了一个
    `float` 对象的生命周期。由于 `q` 是一个 `int*`，解引用它是未定义行为（UB）。
- en: 'On the other hand, the following is legal and shows how `std::memcpy()` can
    be used for type punning:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下操作是合法的，展示了如何使用 `std::memcpy()` 进行类型转换：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Indeed, in this second example, using `std::memcpy()` to copy the bits from
    `f` to `value` starts the lifetime of `value`. That object can be used as any
    other `int` from that point on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在这个第二个例子中，使用 `std::memcpy()` 从 `f` 复制位到 `value` 启动了 `value` 的生命周期。从那时起，该对象可以像任何其他
    `int` 一样使用。
- en: The special cases of char*, unsigned char*, and std::byte*
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`char*`、`unsigned char*` 和 `std::byte*` 的特殊情况'
- en: The `char*`, `unsigned char*` (not `signed char*`), and `std::byte*` types have
    special status in C++ as they can literally point anywhere and alias anything
    ([wg21.link/basic.lval#11](http://wg21.link/basic.lval#11)). For that reason,
    if you need to access the underlying bytes of the value representation of an object,
    these types are an important tool in your toolbox.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`char*`、`unsigned char*`（不是 `signed char*`）和 `std::byte*` 类型在 C++ 中具有特殊地位，因为它们可以指向任何地方并代表任何类型（[wg21.link/basic.lval#11](http://wg21.link/basic.lval#11)）。因此，如果您需要访问对象的值表示形式下的底层字节，这些类型是您工具箱中的重要工具。'
- en: We will, later in this book, occasionally resort to these types to perform low-level
    byte manipulation. Note that such maneuvers are inherently fragile and non-portable,
    as such details as the order of bytes in an integer can vary from platform to
    platform. Use such low-level facilities with care.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续内容中，我们偶尔会使用这些类型来执行低级字节操作。请注意，此类操作本质上是脆弱且不可移植的，因为整数中字节的顺序可能会因平台而异。请谨慎使用此类低级设施。
- en: The std::start_lifetime_as<T>() function
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`std::start_lifetime_as<T>()` 函数'
- en: 'One last set of facilities for this chapter is `std::start_lifetime_as<T>()`
    and `std::start_lifetime_as_array<T>()`. These functions have been discussed for
    years but came into their own with C++23\. Their role is to take as arguments
    something such as a buffer of raw memory bytes and return a pointer to some `T`
    (pointing to that buffer) whose lifetime has started, such that the pointee can
    be used as such from that point on:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后介绍的一组设施是 `std::start_lifetime_as<T>()` 和 `std::start_lifetime_as_array<T>()`。这些函数讨论了多年，但直到
    C++23 才真正发挥其作用。它们的作用是将原始内存字节数组作为参数，并返回一个指向 `T` 的指针（指向该缓冲区），其生命周期已开始，从而可以从该点开始将指针所指的内容用作
    `T` 类型：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is, again, a low-level feature to be used with care. The intent here is
    to be able to implement such things as low-level file I/O and networking code
    (for example, receiving a UDP packet and treating its value representation as
    if it were an existing object) in pure C++ without falling into a UB trap. We
    will discuss these functions in more detail in [*Chapter 15*](B21071_15.xhtml#_idTextAnchor213).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样是一个需要谨慎使用的低级特性。这里的意图是能够用纯 C++ 实现诸如低级文件 I/O 和网络代码（例如，接收 UDP 数据包并将其值表示形式视为现有对象）等，而不会陷入未定义行为的陷阱。我们将在[*第
    15 章*](B21071_15.xhtml#_idTextAnchor213)中更详细地讨论这些函数。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explored some low-level and sometimes unpleasant facilities that
    we will sometimes use, in order to put up the proper “warning signs” and remind
    us that we have to be responsible and write sensible and correct code even though
    our language of choice gives significant freedom.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了我们将有时使用的一些低级和有时令人不快的设施，目的是设置适当的“警告标志”，并提醒我们必须负责任地编写合理且正确的代码，尽管我们选择的语言提供了很大的自由度。
- en: When writing advanced memory management facilities in the later chapters of
    this book, these dangerous facilities will sometimes be useful to us. Inspired
    by the contents of this chapter on things to be careful with, we will resort to
    these facilities sparingly, carefully, and in ways that make them hard to misuse.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当在本书的后续章节中编写高级内存管理功能时，这些危险的设施有时对我们是有用的。受到本章关于需要注意的事项的内容的启发，我们将谨慎、小心地使用这些设施，并使其难以被误用。
- en: In our next chapter, we will examine the key C++ casts put at our disposal;
    the intent is to make us aware of what each cast does, as well as when (and to
    what end) it should be used, such that we can thereafter build the powerful memory
    management abstractions we want to use.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们接下来的章节中，我们将探讨置于我们手中的关键C++类型转换；目的是让我们了解每种转换的作用，以及何时（以及为了什么目的）应该使用它，这样我们就可以构建我们想要使用的强大内存管理抽象。
