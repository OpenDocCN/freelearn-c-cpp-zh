["```cpp\nnamespace Db {\n  class ConnectionManager \n  {\n  public:\n    static std::shared_ptr<ConnectionManager> get_instance()\n {\n if (instance_ == nullptr) {\n instance_.reset(new ConnectionManager());\n }\n return instance_;\n }\n\n    // Database connection related code omitted\n  private:\n    static std::shared_ptr<ConnectionManager> instance_{nullptr};\n  };\n}\n```", "```cpp\nget_instance()\n  if (_instance == nullptr)\n    instance_.reset(new)\n  return instance_;\n```", "```cpp\nget_instance()\n  if (_instance == nullptr)   <--- Thread A\n    instance_.reset(new)\n  return instance_;\n```", "```cpp\nget_instance()\n  if (_instance == nullptr)   <--- Thread B (checking)\n    instance_.reset(new)      <--- Thread A (already checked)\n  return instance_;\n```", "```cpp\nget_instance()\n  if (_instance == nullptr)   \n    instance_.reset(new)      <--- Thread B (already checked)\n  return instance_;           <--- Thread A (returns)\n```", "```cpp\nstatic std::shared_ptr<ConnectionManager> get_instance()\n{\n  if (instance_ == nullptr) {\n    // mutex_ is declared in the private section\n std::lock_guard lg{mutex_};\n if (instance_ == nullptr) { // double-checking\n instance_.reset(new ConnectionManager());\n }\n  }\n  return instance_;\n}\n```", "```cpp\nget_instance()\n  if (instance_ == nullptr)     <--- Thread B\n    lock mutex                  <--- Thread A (locks the mutex)\n    if (instance_ == nullptr)\n      instance_.reset(new)\n    unlock mutex\n  return instance_\n```", "```cpp\nget_instance()\n  if (instance_ == nullptr)\n    lock mutex                  <--- Thread B (tries to lock, waits)\n    if (instance_ == nullptr)   <--- Thread A (double check)\n      instance_.reset(new)      \n    unlock mutex\n  return instance_\n```", "```cpp\nget_instance()\n  if (instance_ == nullptr)\n    lock mutex                  <--- Thread B (finally locks the mutex)\n    if (instance_ == nullptr)   <--- Thread B (check is not passed)\n      instance_.reset(new)      \n    unlock mutex                <--- Thread A (unlocked the mutex)\n  return instance_              <--- Thread A (returns)  \n```", "```cpp\n#include <thread>\n\nint counter = 0;\n\nvoid foo()\n{\n counter++;\n}\n\nint main()\n{\n  std::jthread A{foo};\n  std::jthread B{foo};\n  std::jthread C{[]{foo();}};\n  std::jthread D{\n    []{\n      for (int ix = 0; ix < 10; ++ix) { foo(); }\n    }\n  };\n}\n```", "```cpp\nauto res = counter;\ncounter = counter + 1;\nreturn res;\n```", "```cpp\nauto res = counter;     <--- thread A\ncounter = counter + 1;  <--- thread B\nreturn res;             <--- thread C\n```", "```cpp\n#include <thread>\n#include <mutex>\n\nint counter = 0;\nstd::mutex m;\n\nvoid foo()\n{\n std::lock_guard g{m};\n  counter++;\n}\n\nint main()\n{\n  // code omitted for brevity\n}\n```", "```cpp\nlock mutex;             <--- thread A, B, D wait for the locked mutex \nauto res = counter;     <--- thread C has locked the mutex\ncounter = counter + 1;\nunlock mutex;           *<--- A, B, D are blocked until C reaches here*\nreturn res;             \n```", "```cpp\ntemplate <typename T>\nclass safe_stack\n{\npublic:\n  safe_stack();\n  safe_stack(const safe_stack& other);\n  void push(T value); // we will std::move it instead of copy-referencing\n  void pop();\n  T& top();\n  bool empty() const;\n\nprivate:\n  std::stack<T> wrappee_;\n  mutable std::mutex mutex_;\n};\n```", "```cpp\nsafe_stack::safe_stack(const safe_stack& other)\n{\n  std::lock_guard<std::mutex> lock(other.mutex_);\n  wrappee_ = other.wrappee_;\n}\n```", "```cpp\nvoid safe_stack::push(T value)\n{\n  std::lock_guard<std::mutex> lock(mutex_);\n  // note how we std::move the value\n  wrappee_.push(std::move(value));\n}\n```", "```cpp\nstd::shared_ptr<T> pop()\n{\n  std::lock_guard<std::mutex> lock(mutex_);\n  if (wrappee_.empty()) {\n    throw std::exception(\"The stack is empty\");\n  }\n  std::shared_ptr<T> top_element{std::make_shared<T>(std::move(wrappee_.top()))};\n  wrappee_.pop();\n  return top_element;\n}\n```", "```cpp\nnum = 37;\n```", "```cpp\nvoid foo()\n{\n  mutex.lock();\n  int a{41};\n  int b{a + 1};\n  mutex.unlock();\n}\n```", "```cpp\ndouble d{4.2}; // \"store\" 4.2 into \"d\"\nstd::cout << d; // \"read\" the contents of \"d\"\n```", "```cpp\natomic_int m;\nm.store(42);             // atomically \"store\" the value\nstd::cout << m.load();   // atomically \"read\" the contents \n```", "```cpp\nT load(std::memory_order order = std::memory_order_seq_cst) const noexcept;\nvoid store(T value, std::memory_order order = \n            std::memory_order_seq_cst) noexcept;\nT exchange(T value, std::memory_order order = \n            std::memory_order_seq_cst) noexcept;\n```", "```cpp\nbool compare_exchange_weak(T& expected_value, T target_value, \n                           std::memory_order order = \n                            std::memory_order_seq_cst) noexcept;\nbool compare_exchange_strong(T& expected_value, T target_value,\n                            std::memory_order order =\n                             std::memory_order_seq_cst) noexcept;\n```", "```cpp\ntemplate <typename T>\nclass lock_free_stack\n{\nprivate:\n struct node {\n T data;\n node* next;\n node(const T& d) : data(d) {}\n }  node* head_;\n// the rest of the body is omitted for brevity\n};\n```", "```cpp\ntemplate <typename T>\nclass lock_free_stack\n{\nprivate:\n  // code omitted for brevity\n std::atomic<node*> head_;  // code omitted for brevity\n};\n```", "```cpp\nvoid push(const T& data)\n{\n  node* new_elem = new node(data);\n  new_elem->next = head_.load();\n  while (!head_.compare_exchange_weak(new_elem->next, new_elem));\n}\n```", "```cpp\nstruct some_struct {};\nany arr[10];\nstd::atomic<some_struct*> ap(arr);\nsome_struct* old = ap.fetch_add(2);\n// now old is equal to arr\n// ap.load() is equal to &arr[2]\n```", "```cpp\nvoid pop(T& popped_element)\n{\n  node* old_head = head_;\n  popped_element = old_head->data;\n  head_ = head_->next;\n  delete old_head;\n}\n```", "```cpp\nvoid pop(T& popped_element)\n{\n  node* old_head = head_.load();\n  while (!head_.compare_exchange_weak(old_head, old_head->next));\n  popped_element = old_head->data;\n}\n```", "```cpp\n// the node struct is internal to \n// the lock_free_stack class defined above\nstruct node\n{\n  T data;\n  node* next;\n};\n```"]