- en: Code Smells and Clean Code Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味和干净代码实践
- en: 'This chapter will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to code smells
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码异味简介
- en: The concept of clean code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 干净代码的概念
- en: How agile and clean code practices are related
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敏捷和干净代码实践的关系
- en: SOLID design principle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: Code refactoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构
- en: Refactoring code smells into clean code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码异味重构为干净代码
- en: Refactoring code smells into design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码异味重构为设计模式
- en: Clean code is the source code that works in an accurate way functionally and
    is structurally well written. Through thorough testing, we can ensure the code
    is functionally correct. We can improve code quality via code self-review, peer code review,
    code analysis, and most importantly, by code refactoring.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的代码是在功能上准确运行并且结构良好编写的源代码。通过彻底的测试，我们可以确保代码在功能上是正确的。我们可以通过代码自审、同行代码审查、代码分析，最重要的是通过代码重构来提高代码质量。
- en: 'The following are some of the qualities of clean code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些干净代码的特质：
- en: Easy to understand
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解
- en: Easy to enhance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于增强
- en: Adding new functionality doesn't require many code changes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新功能不需要进行太多的代码更改
- en: Easy to reuse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于重用
- en: Self-explanatory
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自解释
- en: Has comments when necessary
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时有注释
- en: Lastly, the best part about writing clean code is that both the development
    team involved in the project or product and the customer will be happy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编写干净代码的最好之处是项目或产品中涉及的开发团队和客户都会很高兴。
- en: Code refactoring
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: Refactoring helps improve the structural quality of the source code. It doesn't
    modify the functionality of the code; it just improves the structural aspect of
    the code quality. Refactoring makes the code cleaner, but at times it may help
    you improve the overall code performance. However, you need to understand that
    performance tuning is different from code refactoring.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重构有助于改善源代码的结构质量。它不会修改代码的功能；它只是改善了代码的结构方面的质量。重构使代码更清晰，但有时它可能帮助您改善整体代码性能。但是，您需要明白性能调优与代码重构是不同的。
- en: 'The following diagram demonstrates the development process overview:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了开发过程的概述：
- en: '![](img/ce236672-0fd5-44af-a596-c08005e76b8c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce236672-0fd5-44af-a596-c08005e76b8c.png)'
- en: 'How is code refactoring done safely? The answer to this question is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安全地进行代码重构？这个问题的答案如下：
- en: Embrace DevOps
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥抱DevOps
- en: Adapt to test-driven development
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应测试驱动开发
- en: Adapt to behavior-driven development
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适应行为驱动开发
- en: Use acceptance test-driven development
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用验收测试驱动开发
- en: Code smell
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味
- en: Source code has two aspects of quality, namely **functional** and **structural**.
    The functional quality of a piece of source code can be achieved by testing the
    code against the customer specifications. The biggest mistake most developers
    make is that they tend to commit the code to version control software without
    refactoring it; that is, they commit the code the moment they believe it is functionally
    complete.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码有两个方面的质量，即**功能**和**结构**。源代码的功能质量可以通过根据客户规格对代码进行测试来实现。大多数开发人员犯的最大错误是他们倾向于在不进行重构的情况下将代码提交到版本控制软件；也就是说，他们一旦认为代码在功能上完成了，就提交了代码。
- en: As a matter of fact, committing code to version control often is a good habit,
    as this is what makes continuous integration and DevOps possible. After committing
    the code to version control, what the vast majority of developers ignore is refactoring
    it. It is highly critical that you refactor the code to ensure it is clean, without
    which being agile is impossible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，将代码提交到版本控制通常是一个好习惯，因为这是持续集成和DevOps可能的基础。将代码提交到版本控制后，绝大多数开发人员忽视的是对其进行重构。重构代码非常重要，以确保代码是干净的，没有这一点，敏捷是不可能的。
- en: Code that looks like noodles (spaghetti) requires more efforts to enhance or
    maintain. Hence, responding to a customer's request quickly is not practically
    possible. This is why maintaining clean code is critical to being agile. This
    is applicable irrespective of the agile framework that is followed in your organization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像面条（意大利面）的代码需要更多的努力来增强或维护。因此，快速响应客户的请求在实际上是不可能的。这就是为什么保持干净的代码对于敏捷至关重要。这适用于您组织中遵循的任何敏捷框架。
- en: What is agile?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是敏捷？
- en: 'Agile is all about **fail fast**. An agile team will be able to respond to
    a customer''s requirement quickly without involving any circus from the development
    team. It doesn''t really matter much which agile framework the team is using:
    Scrum, Kanban, XP, or something else. What really matters is, are you following
    them seriously?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷就是**快速失败**。一个敏捷团队将能够快速响应客户的需求，而不需要开发团队的任何花哨。团队使用的敏捷框架并不是很重要：Scrum、Kanban、XP或其他什么。真正重要的是，你是否认真地遵循它们？
- en: As an independent software consultant, I have personally observed and learned
    who generally complains, and why they complain about agile.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为独立的软件顾问，我个人观察并学习了谁通常抱怨，以及他们为什么抱怨敏捷。
- en: As Scrum is one of the most popular agile frameworks, let's assume a product company,
    say, ABC Tech Private Ltd., has decided to follow Scrum for the new product that
    they are planning to develop. The good news is that ABC Tech, just like most organizations,
    also hosts a Sprint planning meeting, a daily stand-up meeting, Sprint review,
    Sprint retrospective, and all other Scrum ceremonies efficiently. Assume that
    ABC Tech has ensured their Scrum master is Scrum-certified and the product manager
    is a Scrum-certified product owner. Great! Everything sounds good so far.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Scrum是最流行的敏捷框架之一，让我们假设一个产品公司，比如ABC科技私人有限公司，已决定为他们计划开发的新产品采用Scrum。好消息是，ABC科技，就像大多数组织一样，也有效地举行了冲刺计划会议、每日站立会议、冲刺回顾、冲刺回顾等所有其他Scrum仪式。假设ABC科技已确保他们的Scrum主管是Scrum认证的，产品经理是Scrum认证的产品负责人。太好了！到目前为止一切听起来都很好。
- en: Let's say the ABC Tech product team doesn't use TDD, BDD, ATDD, and DevOps.
    Do you think the ABC Tech product team is agile? Certainly not. As a matter of
    fact, the development team will be highly stressed with a hectic and impractical
    schedule. At the end of the day, there will be very high attrition, as the team
    will not be happy. Hence, customers will not be happy, as the quality of the product
    will suffer terribly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设ABC科技产品团队不使用TDD、BDD、ATDD和DevOps。你认为ABC科技产品团队是敏捷的吗？当然不是。事实上，开发团队将面临繁忙和不切实际的日程安排。最终，将会有非常高的离职率，因为团队不会开心。因此，客户也不会开心，产品的质量将遭受严重损害。
- en: What do you think has gone wrong with the ABC Tech product team?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为ABC科技产品团队出了什么问题？
- en: Scrum has two sets of processes, namely the project management process, which
    is covered by Scrum ceremonies. Then, there is the engineering side of the process,
    which most organizations don't pay much attention to. This is evident from the
    interest or awareness of **Certified SCRUM Developer** (**CSD**) certification
    in the IT industry. The amount of interest the IT industry shows to CSM, CSPO,
    or CSP is hardly shown to CSD, which is required for developers. However, I don't
    believe certification alone could make someone a subject-matter expert; it only
    shows the seriousness the person or the organization shows in embracing an agile
    framework and delivering quality products to their customers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum有两套流程，即项目管理流程，由Scrum仪式涵盖。然后，还有流程的工程方面，大多数组织并不太关注。这可以从IT行业对**Certified SCRUM
    Developer**（CSD）认证的兴趣或认识程度中看出。IT行业对CSM、CSPO或CSP所表现的兴趣几乎不会表现在CSD上，而开发人员是需要的。然而，我不认为单凭认证就能使某人成为专家；它只能显示个人或组织在接受敏捷框架并向客户交付优质产品方面的严肃性。
- en: Unless the code is kept clean, how is it possible for the development team to
    respond to customers' requirements quickly? In other words, unless the engineers
    in the development team embrace TDD, BDD, ATDD, continuous integration, and DevOps
    in the product development, no team will be able to succeed in Scrum or, for that
    matter, with any other agile framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除非代码保持清晰，否则开发团队如何能够快速响应客户的需求？换句话说，除非开发团队的工程师在产品开发中采用TDD、BDD、ATDD、持续集成和DevOps，否则任何团队都无法在Scrum或其他敏捷框架中取得成功。
- en: The bottom line is that unless your organization takes the engineering Scrum
    process and project management Scrum process equally serious, no development team
    can claim to succeed in agile.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，除非你的组织同等重视工程Scrum流程和项目管理Scrum流程，否则没有开发团队能够声称在敏捷中取得成功。
- en: SOLID design principle
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: SOLID is an acronym for a set of important design principles that, if followed,
    can avoid code smells and improve the code quality, both structurally and functionally.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一组重要的设计原则的首字母缩写，如果遵循，可以避免代码异味并改善代码质量，无论是在结构上还是在功能上。
- en: 'Code smells can be prevented or refactored into clean code if your software
    architecture meets the SOLID design principle compliance. The following principles
    are collectively called SOLID design principles:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的软件架构符合SOLID设计原则的要求，代码异味可以被预防或重构为清晰的代码。以下原则统称为SOLID设计原则：
- en: Single responsibility principle
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open closed principle
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution principle
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: Interface segregation
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Dependency inversion
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转
- en: The best part is that most design patterns also follow and are compliant with
    SOLID design principles.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，大多数设计模式也遵循并符合SOLID设计原则。
- en: Let's go through each of the preceding design principles one by one in the following
    sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个在以下部分讨论上述设计原则。
- en: Single responsibility principle
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: '**Single responsibility principle** is also referred to as **SRP** in short.
    SRP says that every class must have only one responsibility. In other words, every
    class must represent exactly one object. When a class represents multiple objects,
    it tends to violate SRP and opens up chances for multiple code smells.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则**简称为**SRP**。SRP表示每个类必须只有一个责任。换句话说，每个类必须恰好代表一个对象。当一个类代表多个对象时，它往往违反SRP并为多个代码异味打开机会。'
- en: 'For example, let''s take a simple `Employee` class, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以一个简单的“Employee”类为例：
- en: '![](img/3c50e462-2489-4330-92ed-af564049d677.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c50e462-2489-4330-92ed-af564049d677.png)'
- en: 'In the preceding class diagram, the `Employee` class seems to represent three
    different objects: `Employee`, `Address`, and `Contact`. Hence, it violates the
    SRP. As per this principle, from the preceding `Employee` class, two other classes
    can be extracted, namely `Address` and `Contact`, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述类图中，“Employee”类似乎代表了三个不同的对象：“Employee”、“Address”和“Contact”。因此，它违反了SRP。根据这个原则，可以从上述的“Employee”类中提取出另外两个类，即“Address”和“Contact”，如下所示：
- en: '![](img/c49529f1-d721-4b7a-b85e-aa15f9effa08.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c49529f1-d721-4b7a-b85e-aa15f9effa08.png)'
- en: For simplicity, the class diagrams used in this section don't show any methods
    that are supported by the respective classes, as our focus is understanding the
    SRP with a simple example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，本节中使用的类图不显示各个类支持的方法，因为我们的重点是通过一个简单的例子理解SRP。
- en: In the preceding refactored design, Employee has one or more addresses (personal
    and official) and one or more contacts (personal and official). The best part
    is that after refactoring the design, every class abstracts one and only thing;
    that is, it has only one responsibility.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述重构后的设计中，Employee有一个或多个地址（个人和官方）和一个或多个联系人（个人和官方）。最好的部分是，在重构设计后，每个类都抽象出一个且仅有一个责任。
- en: Open closed principle
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: An architecture or design is in compliance with the **open closed principle** (**OCP**)
    when the design supports the addition of new features with no code changes or
    without modifying the existing source code. As you know, based on your professional
    industry experience, every single project you have come across was extensible
    in one way or another. This is how you were able to add new features to your product.
    However, the design will be in compliance with the OCP when such a feature extension
    is done without you modifying the existing code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计支持添加新功能而无需更改代码或不修改现有源代码时，架构或设计符合**开闭原则**（**OCP**）。正如您所知，根据您的专业行业经验，您遇到的每个项目都以某种方式是可扩展的。这就是您能够向产品添加新功能的方式。但是，当这种功能扩展是在不修改现有代码的情况下完成时，设计将符合OCP。
- en: 'Let''s take a simple `Item` class, as shown in the following code. For simplicity,
    only the essential details are captured in the `Item` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个简单的`Item`类为例，如下所示。为简单起见，`Item`类中只捕获了基本细节：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assume the preceding `Item` class is part of a simple billing application for
    a small shop. As the `Item` class will be able to represent a pen, calculator,
    chocolate, notebook, and so on, it is generic enough to support any billable item
    that is dealt by the shop. However, if the shop owner is supposed to collect **Goods
    and Services Tax** (**GST**) or **Value Added Tax** (**VAT**), the existing `Item`
    class doesn't seem to support the tax component. One common approach is to modify
    the `Item` class to support the tax component. However, if we were to modify existing
    code, our design would be non-compliant to OCP.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的`Item`类是一个小商店的简单结算应用程序的一部分。由于`Item`类将能够代表钢笔、计算器、巧克力、笔记本等，它足够通用，可以支持商店处理的任何可计费项目。但是，如果商店老板应该收取**商品和服务税**（**GST**）或**增值税**（**VAT**），现有的`Item`类似乎不支持税收组件。一种常见的方法是修改`Item`类以支持税收组件。但是，如果我们修改现有代码，我们的设计将不符合OCP。
- en: 'Hence, let''s refactor our design to make it OCP-compliant using Visitor design
    pattern. Let''s explore the refactoring possibility, as shown in the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们重构我们的设计，使其符合OCP，使用访问者设计模式。让我们探索重构的可能性，如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Visitable` class is an abstract class with three pure virtual functions.
    The `Item` class will be inheriting the `Visitable` abstract class, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visitable`类是一个具有三个纯虚函数的抽象类。`Item`类将继承`Visitable`抽象类，如下所示：'
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let''s take a look at the `Visitor` class, shown in the following code.
    It says there can be any number of `Visitor` subclasses that can be implemented
    in future to add new functionalities, all without modifying the `Item` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`Visitor`类，如下所示。它说未来可以实现任意数量的`Visitor`子类以添加新功能，而无需修改`Item`类：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `GSTVisitor` class is the one that lets us add the GST functionality without
    modifying the `Item` class. The `GSTVisitor` implementation looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`GSTVisitor`类是让我们在不修改`Item`类的情况下添加GST功能的类。`GSTVisitor`的实现如下所示：'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Makefile` looks as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`如下所示：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The refactored design is OCP-compliant, as we would be able to add new functionalities
    without modifying the `Item` class. Just imagine: if the GST calculation varies
    from time to time, without modifying the `Item` class, we would be able to add
    new subclasses of `Visitor` and address the upcoming changes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的设计符合OCP，因为我们将能够在不修改`Item`类的情况下添加新功能。想象一下：如果GST计算随时间变化，我们将能够添加`Visitor`的新子类并应对即将到来的变化，而无需修改`Item`类。
- en: Liskov substitution principle
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则
- en: '**Liskov substitution principle** (**LSP**) stresses the importance of subclasses
    adhering to the contract established by the base class. In an ideal inheritance
    hierarchy, as the design focus moves up the class hierarchy, we should notice
    generalization; as the design focus moves down the class hierarchy, we should
    notice specialization.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**里斯科夫替换原则**（**LSP**）强调子类遵守基类建立的契约的重要性。在理想的继承层次结构中，随着设计重点向上移动类层次结构，我们应该注意泛化；随着设计重点向下移动类层次结构，我们应该注意专门化。'
- en: The inheritance contract is between two classes, hence it is the responsibility
    of the base class to impose rules that all subclasses can follow, and the subclasses
    are equally responsible for obeying the contract once agreed. A design that compromises
    these design philosophies will be non-compliant to the LSP.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 继承契约是两个类之间的，因此基类有责任强加所有子类都能遵守的规则，一旦达成协议，子类同样有责任遵守契约。违反这些设计原则的设计将不符合LSP。
- en: LSP says if a method takes the base class or interface as an argument, one should
    be able to substitute the instance of any one of the subclasses unconditionally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: LSP说，如果一个方法以基类或接口作为参数，应该能够无条件地用任何一个子类的实例替换它。
- en: 'As a matter of fact, inheritance violates the most fundamental design principles:
    inheritance is weakly cohesive and strongly coupled. Hence, the real benefit of
    inheritance is polymorphism, and code reuse is a tiny benefit compared to the
    price paid for inheritance. When LSP is violated, we can''t substitute the base
    class instance with one of its subclass instances, and the worst part is we can''t
    invoke methods polymorphically. In spite of paying the design penalties of using
    inheritance, if we can''t reap the benefit of polymorphism, there is no real motivation
    to use it.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，继承违反了最基本的设计原则：继承是弱内聚和强耦合的。因此，继承的真正好处是多态性，而代码重用与继承相比是微不足道的好处。当LSP被违反时，我们无法用其子类实例替换基类实例，最糟糕的是我们无法多态地调用方法。尽管付出了使用继承的设计代价，如果我们无法获得多态性的好处，就没有真正使用它的动机。
- en: 'The technique to identify LSP violation is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 识别LSP违规的技术如下：
- en: Subclasses will have one or more overridden methods with empty implementations
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类将具有一个或多个带有空实现的重写方法
- en: The base class will have a specialized behavior, which will force certain subclasses,
    irrespective of whether those specialized behaviors are of the subclasses' interest
    or not
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类将具有专门的行为，这将强制某些子类，无论这些专门的行为是否符合子类的兴趣
- en: Not all generalized methods can be invoked polymorphically
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有的泛化方法都可以被多态调用
- en: 'The following are the ways to refactor LSP violations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是重构LSP违规的方法：
- en: Move the specialized methods from the base class to the subclass that requires
    those specialized behaviors.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基类中的专门方法移动到需要这些专门行为的子类中。
- en: Avoid forcing vaguely related classes to participate in an inheritance relationship.
    Unless the subclass is a base type, do not use inheritance for the mere sake of
    code reuse.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免强制让关联不大的类参与继承关系。除非子类是基本类型，否则不要仅仅为了代码重用而使用继承。
- en: Do not look for small benefits, such as code reuse, but look for ways to use
    polymorphism or aggregation or composition when possible.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要寻求小的好处，比如代码重用，而是寻求在可能的情况下使用多态性、聚合或组合的方法。
- en: Interface segregation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离
- en: '**Interface segregation** design principle recommends modeling many small interfaces
    for a specific purpose, as opposed to modeling one bigger interface that represents
    many things. In the case of C++, an abstract class with pure virtual functions
    can be thought of as an interface.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离**设计原则建议为特定目的建模许多小接口，而不是建模代表许多东西的一个更大的接口。在C++中，具有纯虚函数的抽象类可以被视为接口。'
- en: 'Let''s take a simple example to understand interface segregation:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子来理解接口隔离：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, the abstract class demonstrates a chaotic design.
    The design is chaotic as it seems to represent many things, such as employee,
    address, and contact. One of the ways in which the preceding abstract class can
    be refactored is by breaking the single interface into three separate interfaces:
    `IEmployee`, `IAddress`, and `IContact`. In C++, interfaces are nothing but abstract
    classes with pure virtual functions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，抽象类展示了一个混乱的设计。这个设计混乱是因为它似乎代表了许多东西，比如员工、地址和联系方式。前面的抽象类可以重构的一种方式是将单一接口分解为三个独立的接口：`IEmployee`、`IAddress`和`IContact`。在C++中，接口只不过是具有纯虚函数的抽象类：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the refactored code snippet, every interface represents exactly one object,
    hence it is in compliance with the interface segregation design principle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构后的代码片段中，每个接口都代表一个对象，因此符合接口隔离设计原则。
- en: Dependency inversion
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转
- en: A good design will be strongly cohesive and loosely coupled. Hence, our design
    must have less dependency. A design that makes a code dependent on many other
    objects or modules is considered a poor design. If **Dependency Inversion** (**DI**)
    is violated, any change that happens in the dependent modules will have a bad
    impact on our module, leading to a ripple effect.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的设计将是高内聚且低耦合的。因此，我们的设计必须具有较少的依赖性。一个使代码依赖于许多其他对象或模块的设计被认为是一个糟糕的设计。如果**依赖反转**（**DI**）被违反，发生在依赖模块中的任何变化都会对我们的模块产生不良影响，导致连锁反应。
- en: 'Let''s take a simple example to understand the power of DI. A `Mobile` class
    "has a" `Camera` object and notice that has a form is composition. Composition
    is an exclusive ownership where the lifetime of the `Camera` object is directly
    controlled by the `Mobile` object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个简单的例子来理解DI的威力。一个`Mobile`类"拥有"一个`Camera`对象，注意这里的拥有是组合。组合是一种独占所有权，`Camera`对象的生命周期由`Mobile`对象直接控制：
- en: '![](img/154320b2-e8db-4897-b38f-786bbcf6a6d8.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/154320b2-e8db-4897-b38f-786bbcf6a6d8.png)'
- en: As you can see in the preceding image, the `Mobile` class has an instance of
    `Camera` and the *has a* form used is composition, which is an exclusive ownership
    relationship.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上图中所看到的，`Mobile`类有一个`Camera`的实例，使用的是组合的*拥有*形式，这是一种独占所有权的关系。
- en: 'Let''s take a look at the `Mobile` class implementation, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Mobile`类的实现，如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, `Mobile` has implementation-level knowledge about `Camera`,
    which is a poor design. Ideally, `Mobile` should be interacting with `Camera`
    via an interface or an abstract class with pure virtual functions, as this separates
    the `Camera` implementation from its contract. This approach helps replace `Camera`
    without affecting `Mobile` and also gives an opportunity to support a bunch of
    `Camera` subclasses in place of one single camera.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Mobile`对`Camera`有实现级别的了解，这是一个糟糕的设计。理想情况下，`Mobile`应该通过一个接口或具有纯虚函数的抽象类与`Camera`进行交互，因为这样可以将`Camera`的实现与其契约分离。这种方法有助于替换`Camera`而不影响`Mobile`，也为支持一系列`Camera`子类提供了机会，而不是单一的摄像头。
- en: Wondering why it is called **Dependency Injection** (**DI**) or **Inversion
    of Control** (**IOC**)? The reason it is termed dependency injection is that currently,
    the lifetime of `Camera` is controlled by the `Mobile` object; that is, `Camera`
    is instantiated and destroyed by the `Mobile` object. In such a case, it is almost
    impossible to unit test `Mobile` in the absence of `Camera`, as `Mobile` has a
    hard dependency on `Camera`. Unless `Camera` is implemented, we can't test the
    functionality of `Mobile`, which is a bad design approach. When we invert the
    dependency, it lets the `Mobile` object use the `Camera` object while it gives
    up the responsibility of controlling the lifetime of the `Camera` object. This
    process is rightly referred to as IOC. The advantage is that you will be able
    to unit test the `Mobile` and `Camera` objects independently and they will be
    strongly cohesive and loosely coupled due to IOC.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道为什么它被称为**依赖注入**（**DI**）或**控制反转**（**IOC**）吗？之所以称之为依赖注入，是因为目前`Camera`的生命周期由`Mobile`对象控制；也就是说，`Camera`由`Mobile`对象实例化和销毁。在这种情况下，如果没有`Camera`，几乎不可能对`Mobile`进行单元测试，因为`Mobile`对`Camera`有硬依赖。除非实现了`Camera`，否则无法测试`Mobile`的功能，这是一种糟糕的设计方法。当我们反转依赖时，它让`Mobile`对象使用`Camera`对象，同时放弃了控制`Camera`对象的生命周期的责任。这个过程被称为IOC。优点是你将能够独立单元测试`Mobile`和`Camera`对象，它们将由于IOC而具有强大的内聚性和松散的耦合性。
- en: 'Let''s refactor the preceding code with the DI design principle:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用DI设计原则重构前面的代码：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The changes are highlighted in bold in the preceding code snippet. IOC is such
    a powerful technique that it lets us decouple the dependency as just demonstrated;
    however, its implementation is quite simple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码片段中，对更改进行了加粗标记。IOC是一种非常强大的技术，它让我们解耦依赖，正如刚才所示；然而，它的实现非常简单。
- en: Code smell
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码异味
- en: Code smell is a term used to refer to a piece of code that lacks structural
    quality; however, the code may be functionally correct. Code smells violate SOLID
    design principles, hence they must be taken seriously, as the code that is not
    well written leads to heavy maintenance cost in the long run. However, code smells
    can be refactored into clean code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味是指指缺乏结构质量的代码；然而，代码可能在功能上是正确的。代码异味违反了SOLID设计原则，因此必须认真对待，因为编写不好的代码会导致长期的高昂维护成本。然而，代码异味可以重构为干净的代码。
- en: Comment smell
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释异味
- en: 'As an independent software consultant, I have had a lot of opportunities to
    interact and learn from great developers, architects, QA folks, system administrators,
    CTOs and CEOs, entrepreneurs, and so on. Whenever our discussions crossed the
    billion dollar question, "What is clean code or good code?", I more or less got
    one common response globally, "Good code will be well commented." While this is
    partially correct, certainly that''s where the problem starts. Ideally, clean
    code should be self-explanatory, without any need for comments. However, there
    are some occasions where comments improve the overall readability and maintainability.
    Not all comments are code smells, hence it becomes necessary to differentiate
    a good comment from a bad one. Have a look at the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为独立的软件顾问，我有很多机会与优秀的开发人员、架构师、质量保证人员、系统管理员、首席技术官和首席执行官、企业家等进行互动和学习。每当我们的讨论涉及到“什么是干净的代码或好的代码？”这个十亿美元的问题时，我基本上在全球范围内得到了一个共同的回答，“好的代码将会有良好的注释。”虽然这部分是正确的，但问题也正是从这里开始。理想情况下，干净的代码应该是不言自明的，不需要任何注释。然而，有些情况下注释可以提高整体的可读性和可维护性。并非所有的注释都是代码异味，因此有必要区分好的注释和坏的注释。看看下面的代码片段：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I'm sure you have come across these kinds of comments. Needless to explain that
    the preceding scenario is a code smell. Ideally, the developer should have refactored
    the code to fix the bug instead of writing such a comment. I was once debugging
    a critical issue in the middle of the night and I noticed the control reached
    the mysterious empty code block with just a comment in it. I'm sure you have come
    across funnier code and can imagine the frustration it brings; at times, you too
    would have written such a type of code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定遇到过这些评论。毋庸置疑，前述情况是代码异味。理想情况下，开发人员应该重构代码来修复错误，而不是写这样的评论。有一次我在半夜调试一个关键问题，我注意到控制流达到了一个神秘的空代码块，里面只有一个注释。我相信你也遇到过更有趣的代码，可以想象它带来的挫败感；有时候，你也会写这种类型的代码。
- en: A good comment will express *why* the code is written in a specific way rather
    than express *how* the code does something. A comment that conveys how the code
    does something is a code smell, whereas a comment that conveys the why part of
    the code is a good comment, as the why part is not expressed by the code; therefore,
    a good comment provides value addition.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的注释会表达代码为什么以特定方式编写，而不是表达代码如何做某事。传达代码如何做某事的注释是代码异味，而传达代码为什么部分的注释是一个好的注释，因为代码没有表达为什么部分；因此，一个好的注释提供了附加值。
- en: Long method
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长方法
- en: 'A method is long when it is identified to have multiple responsibilities. Naturally,
    a method that has more than 20-25 lines of code tends to have more than one responsibility.
    Having said that, a method with more lines of code is longer. This doesn''t mean
    a method with less than 25 lines of code isn''t longer. Take a look at the following
    code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法被确定具有多个责任时，它就被认为是长的。通常，一个方法如果有超过20-25行的代码，往往会有多个责任。话虽如此，代码行数更多的方法就更长。这并不意味着代码行数少于25行的方法就不长。看看下面的代码片段：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Clearly, the preceding method has multiple responsibilities; that is, it seems
    to validate and save the details. While validating before saving isn''t wrong,
    the same method shouldn''t do both. So the preceding method can be refactored
    into two smaller methods that have one single responsibility:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前述方法有多个责任；也就是说，它似乎在验证和保存细节。在保存之前进行验证并没有错，但同一个方法不应该同时做这两件事。因此，前述方法可以重构为两个具有单一责任的较小方法：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of the refactored methods shown in the preceding code has exactly one responsibility.
    It would be tempting to make the `validateAddress()` method a predicate method;
    that is, a method that returns a bool. However, if `validateAddress()` is written
    as a predicate method, then the client code will be forced to do `if` check, which
    is a code smell. Handling errors by returning error code isn't considered object-oriented
    code, hence error handling must be done using C++ exceptions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中显示的每个重构方法都只负责一项任务。将`validateAddress()`方法变成一个谓词方法可能很诱人；也就是说，一个返回布尔值的方法。然而，如果`validateAddress()`被写成一个谓词方法，那么客户端代码将被迫进行`if`检查，这是一种代码异味。通过返回错误代码来处理错误不被认为是面向对象的代码，因此错误处理必须使用C++异常来完成。
- en: Long parameter list
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长参数列表
- en: An object-oriented method takes fewer arguments, as a well-designed object will
    be strongly cohesive and loosely coupled. A method that takes too many arguments
    is a symptom that informs that the knowledge required to make a decision is received
    externally, which means the current object doesn't have all of the knowledge to
    make a decision by itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的方法接收较少的参数，因为一个设计良好的对象将具有较强的内聚性和较松散的耦合性。接收太多参数的方法是一种症状，表明做出决定所需的知识是从外部获得的，这意味着当前对象本身没有所有的知识来做出决定。
- en: This means the current object is weakly cohesive and strongly coupled, as it
    depends on too much external data to make a decision. Member functions generally
    tend to receive fewer arguments, as the data members they require are generally
    member variables. Hence, the need to pass member variables to member functions
    sounds artificial.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当前对象的内聚性较弱，耦合性较强，因为它依赖于太多外部数据来做出决定。成员函数通常倾向于接收较少的参数，因为它们通常需要的数据成员是成员变量。因此，将成员变量传递给成员函数的需求听起来是不自然的。
- en: 'Let''s see some of the common reasons why a method tends to receive too many
    arguments. The most common symptoms and reasons are listed here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看方法倾向于接收过多参数的一些常见原因。最常见的症状和原因列在这里：
- en: The object is weakly cohesive and strongly coupled; that is, it depends too
    much on other objects
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的内聚性较弱，耦合性较强；也就是说，它过于依赖其他对象
- en: It is a static method
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个静态方法
- en: It is a misplaced method; that is, it doesn't belong to that object
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个放错位置的方法；也就是说，它不属于该对象
- en: It is not object-oriented code
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是面向对象的代码
- en: SRP is violated
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SRP被违反
- en: 'The ways to refactor a method that takes **long parameter list** (**LPL**)
    are listed here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重构接收**长参数列表**（LPL）的方法的方式如下：
- en: Avoid extracting and passing data in bits and pieces; consider passing an entire
    object and let the method extract the details it requires
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免逐个提取和传递数据；考虑传递整个对象，让方法提取所需的细节
- en: Identify the object that supplies the arguments to the method that receives
    LPL and consider moving the method there
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别提供给接收LPL方法的参数的对象，并考虑将方法移至该对象
- en: Group the list of arguments and create a parameter object and move the method
    that receives LPL inside the new object
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数列表分组并创建参数对象，并将接收LPL的方法移至新对象内部
- en: Duplicate code
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复代码
- en: Duplicate code is a commonly recurring code smell that doesn't require much
    explanation. The copying and pasting code culture alone can't be blamed for duplicate
    code. Duplicate code makes code maintenance more cumbersome, as the same issues
    may have to be fixed in multiple places, and integrating new features requires
    too many code changes, which tends to break the unexpected functionalities. Duplicate
    code also increases the application binary footprint, hence it must be refactored
    to clean code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码是一个常见的反复出现的代码异味，不需要太多解释。仅仅复制和粘贴代码文化本身不能完全归咎于重复代码。重复代码使得代码维护更加繁琐，因为相同的问题可能需要在多个地方修复，并且集成新功能需要太多的代码更改，这往往会破坏意外的功能。重复代码还会增加应用程序的二进制占用空间，因此必须对其进行重构以获得清晰的代码。
- en: Conditional complexity
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件复杂性
- en: 'Conditional complexity code smell is about complex large conditions that tend
    to grow larger and more complex with time. This code smell can be refactored with
    the strategy design pattern. As the strategy design pattern deals with many related
    objects, there is scope for using the `Factory` method, and the **null object
    design pattern** can be used to deal with unsupported subclasses in the `Factory`
    method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 条件复杂性代码异味是指复杂的大条件随着时间的推移趋于变得更大更复杂。这种代码异味可以通过策略设计模式进行重构。由于策略设计模式涉及许多相关对象，因此可以使用`工厂`方法，并且**空对象设计模式**可以用于处理`工厂`方法中不支持的子类：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Large class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大类
- en: A large class code smell makes the code difficult to understand and tougher
    to maintain. A large class can do too many things for one class. Large classes
    can be refactored by breaking them into smaller classes with a single responsibility.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 大类代码异味使得代码难以理解，更难以维护。一个大类可能为一个类做太多的事情。大类可以通过将其拆分为具有单一职责的较小类来进行重构。
- en: Dead code
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死代码
- en: Dead code is commented code or code that is never used or integrated. It can
    be detected with code coverage tools. Generally, developers retain these instances
    of code due to lack of confidence, and this happens more often in legacy code.
    As every code is tracked in version control software tools, dead code can be deleted,
    and if required, can always be retrieved back from version control software.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 死代码是被注释掉或者从未被使用或集成的代码。它可以通过代码覆盖工具来检测。通常，开发人员由于缺乏信心而保留这些代码实例，这在传统代码中更常见。由于每个代码都在版本控制软件工具中进行跟踪，死代码可以被删除，如果需要的话，总是可以从版本控制软件中检索回来。
- en: Primitive obsession
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始执念
- en: '**Primitive Obsession** (**PO**) is a wrong design choice: use of a primitive
    data type to represent a complex domain entity. For example, if the string data
    type is used to represent date, though it sounds like a smart idea initially,
    it invites a lot of maintenance trouble in the long run.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始执念**（PO）是一种错误的设计选择：使用原始数据类型来表示复杂的领域实体。例如，如果使用字符串数据类型来表示日期，虽然起初听起来像一个聪明的想法，但从长远来看，这会带来很多维护麻烦。'
- en: 'Assuming you have used a string data type to represent date, the following
    issues will be a challenge:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您使用字符串数据类型来表示日期，将会面临以下问题：
- en: You would need to sort things based on date
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要根据日期对事物进行排序
- en: Date arithmetic will become very complex with the introduction of string
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入字符串后，日期算术将变得非常复杂
- en: Supporting various date formats as per regional settings will become complex
    with string
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据区域设置支持各种日期格式将会变得复杂，如果使用字符串
- en: Ideally, date must be represented by a class as opposed to a primitive data
    type.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，日期必须由一个类来表示，而不是一个原始数据类型。
- en: Data class
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Data classes provide only getter and setter functions. Though they are very
    good for transferring data from one layer to another, they tend to burden the
    classes that depend on the data class. As data classes won't provide any useful
    functionalities, the classes that interact or depend on data classes end up adding
    functionalities with the data from the data class. In this fashion, the classes
    around the data class violate the SRP and tend to be a large class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类只提供获取器和设置器函数。虽然它们非常适用于在不同层之间传输数据，但它们往往会给依赖于数据类的类增加负担。由于数据类不提供任何有用的功能，与数据类交互或依赖的类最终会使用数据类的数据添加功能。这样，围绕数据类的类违反了单一职责原则，并且往往会成为一个大类。
- en: Feature envy
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性嫉妒
- en: Certain classes are termed feature envy if they have too much knowledge about
    other internal details of other classes. Generally, this happens when the other
    classes are data classes. Code smells are interrelated; breaking one code smell
    tends to attract other code smells.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类被称为“特性嫉妒”，如果它们对其他类的内部细节了解过多。一般来说，当其他类是数据类时，就会发生这种情况。代码异味是相互关联的；消除一个代码异味往往会吸引其他代码异味。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about the following topics:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了以下主题：
- en: Code smells and the importance of refactoring code
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码异味和重构代码的重要性
- en: 'SOLID design principles:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID设计原则：
- en: Single responsibility principle
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open closed principle
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换
- en: Interface segregation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离
- en: Dependency injection
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Various code smells:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种代码异味：
- en: Comments smell
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释异味
- en: Long method
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长方法
- en: Long parameter list
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长参数列表
- en: Duplicate code
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复代码
- en: Conditional complexity
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件复杂性
- en: Large class
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大类
- en: Dead code
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死代码
- en: Object-oriented code smells' primitive obsession
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的代码异味的原始执念
- en: Data class
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类
- en: Feature envy
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性嫉妒
- en: You also learned about many refactoring techniques that will help you maintain
    your code cleaner. Happy coding!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了许多重构技术，这将帮助您保持代码更清晰。愉快的编码！
