- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Setting Up the Development Environment for a C++ Embedded Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置C++嵌入式项目的开发环境
- en: In the previous chapter, we explored the embedded tools ecosystem and reviewed
    the most widely used tools in the industry. Now, we’ll set requirements for a
    modern embedded development environment and each of its components. Then, we’ll
    set up our development environment for running the examples that will be provided
    in the remainder of this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了嵌入式工具生态系统，并回顾了行业中最广泛使用的工具。现在，我们将为现代嵌入式开发环境和其各个组件设定要求。然后，我们将设置我们的开发环境，以便运行本书剩余部分提供的示例。
- en: One of the major selling points of integrated environments is their ease of
    use. They provide you with everything you need through simple installation steps.
    Customized environments, on the other hand, require all components to be installed
    individually, including all the dependencies for each component. It’s important
    to ensure reproducible builds and a reliable debugging environment, so containerizing
    customized environments is of great importance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 集成环境的主要卖点之一是它们易于使用。它们通过简单的安装步骤为您提供所需的一切。另一方面，定制环境需要单独安装所有组件，包括每个组件的所有依赖项。确保可重复构建和可靠的调试环境非常重要，因此容器化定制环境具有重要意义。
- en: You’ll be provided with a Docker container for the development environment that
    we’ll be using in this book, but we’ll analyze all of its components individually.
    Understanding the tools that we use in our daily work is necessary to comprehend
    and control the processes behind them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得一个用于本书中使用的开发环境的Docker容器，但我们将单独分析其所有组件。了解我们日常工作中使用的工具对于理解和控制其背后的流程是必要的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Requirements for a modern software development environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代软件开发环境的要求
- en: Containerized development environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化开发环境
- en: Containerized development environment and Visual Studio Code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化开发环境和Visual Studio Code
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have Docker installed ([https://www.docker.com/).](https://www.docker.com/).)
    Please follow the installation instructions provided for your specific operating
    system. This chapter will guide you through the basic steps for downloading and
    running a container with a preconfigured development environment. For more advanced
    Docker usage, please refer to the official Docker documentation available on their
    website.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要安装Docker（[https://www.docker.com/）。](https://www.docker.com/) 请遵循为您的特定操作系统提供的安装说明。本章将指导您完成下载和运行具有预配置开发环境的容器的基本步骤。对于更高级的Docker使用，请参阅他们网站上可用的官方Docker文档。
- en: The code from this chapter is available on GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04).)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到（[https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04）。](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter04)。)
- en: Requirements for a modern software development environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代软件开发环境的要求
- en: '**Firmware development** is no different than any other form of software development
    and the tools we use are crucial for effective work. To make this book and the
    examples accessible as much as possible, the first requirement we’ll set is to
    use free tools. The **compiler** is the basis and the most important part of every
    development requirement, so let’s define the requirements and choose a compiler
    for our needs.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**固件开发**与其他任何形式的软件开发没有区别，我们使用的工具对于有效工作至关重要。为了尽可能使本书和示例易于访问，我们设定的第一个要求是使用免费工具。**编译器**是每个开发要求的基础和最重要的部分，因此让我们定义要求并选择适合我们需求的编译器。'
- en: Compiler
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器
- en: Since we’re exploring modern C++, we’ll require compiler support for the C++23
    standard. The latest version of **ARM GNU Toolchain** (based on GCC) is 13.2;
    it supports C++23 and is free. It’s also the most commonly used free compiler
    toolchain for ARM development, making it a perfect fit for our compiler.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在探索现代C++，因此我们需要支持C++23标准的编译器。**ARM GNU Toolchain**（基于GCC）的最新版本是13.2；它支持C++23且免费。它也是ARM开发中最常用的免费编译器工具链，使其成为我们的编译器的完美选择。
- en: ARM GNU Toolchain comes with C and C++ compilers, **GNU Debugger** (**GDB**),
    which we’ll use for debugging, and other useful tools, such as `objcopy`, `objdump`,
    `size`, and more, and can be downloaded from [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.)
    The architecture that we need for Arm Cortex-M is `arm-none-eabi`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ARM GNU 工具链包含 C 和 C++ 编译器，**GNU 调试器**（**GDB**），我们将用它进行调试，以及其他有用的工具，如 `objcopy`、`objdump`、`size`
    等，可以从 [https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads.)
    下载。我们需要的 Arm Cortex-M 架构是 `arm-none-eabi`。
- en: 'ARM GNU Toolchain for `arm-none-eabi` is available for all common host architectures:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ARM GNU 工具链 `arm-none-eabi` 可用于所有常见的主机架构：
- en: GNU/Linux x86_64 and AArch64 host architectures
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU/Linux x86_64 和 AArch64 主机架构
- en: Windows x86 host architecture only (compatible with `x86_64`)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于 Windows x86 主机架构（兼容 `x86_64`）
- en: macOS x86_64 and Apple silicon
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS x86_64 和 Apple Silicon
- en: 'Compiling a single file or few files is as simple as running a few commands
    in the terminal, but building even the simplest embedded projects involves the
    following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 编译单个文件或少数几个文件就像在终端运行几个命令一样简单，但构建即使是简单的嵌入式项目也涉及以下步骤：
- en: Compile all C and C++ source files, the file that contains the main function,
    and at least several files from **Hardware Abstraction Layer** (**HAL**). You’ll
    learn more about HAL in [*Chapter 12*](Chapter_12.xhtml).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译所有 C 和 C++ 源文件、包含主函数的文件，以及至少来自 **硬件抽象层**（**HAL**）的几个文件。你将在 [*第 12 章*](Chapter_12.xhtml)
    中了解更多关于 HAL 的内容。
- en: Set up compiler include paths.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置编译器包含路径。
- en: Set up compiler C and C++ flags.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置编译器 C 和 C++ 标志。
- en: Set up compiler define macros.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置编译器定义宏。
- en: Compile the startup assembly script.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译启动汇编脚本。
- en: Set up linker options, including the linker script, static libraries, CPU architecture
    and instruction set, and standard library options.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置链接器选项，包括链接器脚本、静态库、CPU 架构和指令集以及标准库选项。
- en: Upon doing this, we must convert the ELF file into other formats that are commonly
    used by flashing programs, such as `bin` and `hex`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之后，我们必须将 ELF 文件转换为闪存程序常用的其他格式，例如 `bin` 和 `hex`。
- en: Running all of these tasks manually in the terminal would be a tedious process,
    so the next requirement for our development environment is *build automation*.
    The first candidate for build automation is the **make** utility. It’s a common
    tool that’s used for automating huge amounts of software projects across different
    industries. It would be a good fit for the task, but it’s an old tool with odd
    syntax. However, we can use **CMake**, a more flexible tool with more modern syntax
    that can generate Makefiles for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端手动运行所有这些任务将是一个繁琐的过程，因此我们开发环境的下一个要求是 *构建自动化*。构建自动化的第一个候选者是 **make** 工具。它是一个常用的工具，用于自动化不同行业中大量软件项目。它非常适合这项任务，但它是一个语法古怪的老工具。然而，我们可以使用
    **CMake**，这是一个更灵活的工具，具有更现代的语法，可以为我们生成 Makefiles。
- en: Build automation
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自动化
- en: '**CMake** isn’t an actual build automation tool, but it generates files for
    other automation tools, such as the make utility. It’s cross-platform, free, and
    open source software for the build automation process, which involves testing,
    packaging, and installing software. It does so by using a compiler-independent
    method.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMake** 不是一个实际的构建自动化工具，但它为其他自动化工具生成文件，例如 make 工具。它是跨平台的、免费的、开源的构建自动化过程软件，涉及测试、打包和安装软件。它通过使用编译器无关的方法来实现。'
- en: 'We’ll use **CMake** to help us generate targets for the make utility that will
    do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **CMake** 来帮助我们为 make 工具生成目标，该工具将执行以下操作：
- en: Configure source files, including paths and linker settings to build ELF files
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置源文件，包括路径和链接器设置以构建 ELF 文件
- en: Convert ELF files into hex and binary formats
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ELF 文件转换为十六进制和二进制格式
- en: Start the simulator and load it with the generated ELF file
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动模拟器并加载生成的 ELF 文件
- en: We’ll use build automation not only to build the firmware but also to start
    the simulator that will run the firmware.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用构建自动化工具不仅来构建固件，还要启动将运行固件的模拟器。
- en: Simulator
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟器
- en: To make this book accessible to a wide audience, we’ll be using a **simulator**
    to run the examples that have been compiled for the ARM Cortex M target. **Renode**
    ([https://github.com/renode/renode)](https://github.com/renode/renode)) is an
    open source simulating framework with good support for ARM targets.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本书对更广泛的读者群体可访问，我们将使用 **模拟器** 来运行为 ARM Cortex M 目标编译的示例。**Renode** ([https://github.com/renode/renode](https://github.com/renode/renode))
    是一个开源的模拟框架，对 ARM 目标有良好的支持。
- en: Renode allows you to run simulations with multiple targets and simulate wireless
    and wired connections between them. We’ll use it in a simple scenario that involves
    running simulations on a single target. Renode can also start a GDB server, allowing
    you to connect to it and debug the target.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Renode 允许您运行具有多个目标的模拟，并在它们之间模拟无线和有线连接。我们将使用一个简单场景，其中涉及在单个目标上运行模拟。Renode 还可以启动
    GDB 服务器，允许您连接到它并调试目标。
- en: We’ll integrate simulation execution and debugging, as well as compiler and
    build automation, using the highly configurable **Visual Studio Code**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用高度可配置的 **Visual Studio Code** 集成模拟执行和调试，以及编译器和构建自动化。
- en: Code editor
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码编辑器
- en: '**Visual Studio Code** is a modern and flexible code editor. It provides us
    with all the extensions we need to integrate all our tools into a single environment.
    We’ll install the following extensions in Visual Studio Code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** 是一个现代且灵活的代码编辑器。它为我们提供了将所有工具集成到单个环境中的所有扩展。我们将在 Visual
    Studio Code 中安装以下扩展：'
- en: '**C/C++**: This extension provides syntax highlighting, code autocompletion,
    and code navigation'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C/C++**：此扩展提供语法高亮、代码自动完成和代码导航'
- en: '**Cortex-Debug**: This extension allows debugging to be performed via GDB'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cortex-Debug**：此扩展允许通过 GDB 进行调试'
- en: '**CS 128 Clang-Tidy**: This extension integrates clang-tidy into Visual Studio
    Code'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CS 128 Clang-Tidy**：此扩展将 clang-tidy 集成到 Visual Studio Code 中'
- en: '**Dev Containers**: This extension attaches to running a container and uses
    it for development purposes'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dev Containers**：此扩展将连接到正在运行的容器，并用于开发目的'
- en: We’ll base our development environment on a Docker container. Visual Studio
    Code will attach to that container and use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于 Docker 容器构建我们的开发环境。Visual Studio Code 将连接到该容器并使用它。
- en: Containerized development environment
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化开发环境
- en: The Visual Studio Code Dev Containers extension allows Visual Studio Code to
    attach to a running Docker container and use all the tools inside it that have
    been installed. To use this feature, we need to build a container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code Dev Containers 扩展允许 Visual Studio Code 连接到一个正在运行的 Docker
    容器，并使用其中安装的所有工具。要使用此功能，我们需要构建一个容器。
- en: 'We’ll use Docker to build a container with the following tools:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker 构建以下工具的容器：
- en: ARM GNU Toolchain version 13.2
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARM GNU Toolchain 版本 13.2
- en: CMake and the make utility
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 和 make 工具
- en: Renode version 1.14
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Renode 版本 1.14
- en: Make sure you’ve installed Docker on your host machine by following the instructions
    provided on the official website ([https://docs.docker.com)](https://docs.docker.com)).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已按照官方网站上提供的说明在主机机器上安装了 Docker ([https://docs.docker.com](https://docs.docker.com))。
- en: You can find the **Dockerfile** that will be used to build the container in
    this book’s GitHub repository ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems)),
    in the `Chapter04` folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的 GitHub 仓库中找到用于构建容器的 **Dockerfile** ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems))，位于
    `Chapter04` 文件夹中。
- en: 'There’s also an image that you can download from Docker Hub ([https://hub.docker.com/).](https://hub.docker.com/).)
    You can pull it using the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) 下载一个镜像。您可以使用以下命令拉取它：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Make sure that the Docker daemon has been started by following the instructions
    for your platform; they’re available on the official website. After downloading
    the image, start Docker using the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保按照您平台上的说明启动了 Docker 守护进程；它们可在官方网站上找到。在下载镜像后，使用以下命令启动 Docker：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will start the Docker container in detached and interactive mode. If you’ve
    already created A Docker container using the `docker run` command, you need to
    start it by running the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在分离和交互模式下启动 Docker 容器。如果您已经使用 `docker run` 命令创建了一个 Docker 容器，您需要通过运行以下命令来启动它：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To access the bash of the started container, we can use the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问已启动容器的 bash，我们可以使用以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As shown in the following screenshot, we can run various commands to ensure
    the compiler, debugger, simulator, and other tools have been installed in the
    container:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，我们可以运行各种命令以确保容器中已安装编译器、调试器、模拟器和其它工具：
- en: '![Figure 4.1 – Development environment container bash](img/B22402_04_01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 开发环境容器bash](img/B22402_04_01.png)'
- en: Figure 4.1 – Development environment container bash
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 开发环境容器bash
- en: '*Figure 4.1* shows the expected outputs from the commands we used to check
    the versions of the tools that we’ve installed.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.1*显示了使用我们用来检查已安装工具版本的命令所期望的输出。'
- en: We can use the running container as a self-contained environment. Let’s start
    by cloning the project GitHub repository ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用运行中的容器作为一个自包含的环境。让我们首先通过克隆项目GitHub仓库([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems):)开始
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once you’ve done this, go to the `Chapter04/bare` folder. This folder contains
    the *Hello, World!* example firmware for STM32F072 that we’ll run in Renode. The
    project is organized into the following folders:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，转到`Chapter04/bare`文件夹。这个文件夹包含我们将要在Renode中运行的STM32F072的*Hello, World!*示例固件。项目组织成以下文件夹：
- en: '`app`: Contains the business layer code, including `main.cpp`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`: 包含业务层代码，包括`main.cpp`'
- en: '`hal`: Contains the HAL C++ code'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hal`: 包含HAL C++代码'
- en: '`platform`: Contains platform-specific code, including the ST-provided HAL
    layer in C and the CMSIS, startup, and linker scripts'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`平台`: 包含特定平台的代码，包括C语言中的ST提供的HAL层、CMSIS、启动脚本和链接脚本'
- en: '`renode_scripts`: Contains Renode simulator scripts'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renode_scripts`: 包含Renode模拟器脚本'
- en: In the project folder, you’ll also see `CMakeLists.txt`, a CMake file that we’ll
    use to specify how the firmware is built. Let’s learn how to use CMake with the
    help of an example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件夹中，你也会看到`CMakeLists.txt`，这是一个我们将用来指定如何构建固件的CMake文件。让我们通过一个例子来学习如何使用CMake。
- en: Building the Hello, World! program using CMake
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CMake构建Hello, World!程序
- en: 'We can use CMake to specify a toolchain, source files, compiler include paths,
    and compiler flags. The first thing we must do in a CMake file is specify the
    CMake version that’s in use, as shown in the following line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CMake指定工具链、源文件、编译器包含路径和编译器标志。在CMake文件中，我们必须做的第一件事是指定正在使用的CMake版本，如下所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'CMake is a powerful tool that allows us to write highly flexible build files.
    We can write toolchain details in separate files and include them in the main
    project file, which would allow us to reuse them for different architectures.
    However, in our example, we have the toolchain details in the main CMake file.
    The following lines specify various toolchain components:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是一个强大的工具，它允许我们编写高度灵活的构建文件。我们可以在单独的文件中编写工具链细节并将它们包含在主项目文件中，这样我们就可以为不同的架构重用它们。然而，在我们的例子中，我们在主CMake文件中包含工具链细节。以下行指定了各种工具链组件：
- en: set(CMAKE_C_COMPILER “arm-none-eabi-gcc”)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: set(CMAKE_C_COMPILER “arm-none-eabi-gcc”)
- en: set(CMAKE_CXX_COMPILER “arm-none-eabi-g++”)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: set(CMAKE_CXX_COMPILER “arm-none-eabi-g++”)
- en: set(CMAKE_ASM_COMPILER “arm-none-eabi-gcc”)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: set(CMAKE_ASM_COMPILER “arm-none-eabi-gcc”)
- en: Using the `CMAKE_C_COMPILER`, `CMAKE_CXX_COMPILER`, and `CMAKE_ASM_COMPILER`
    CMake variables, we specify paths for the C, C++, and assembler compilers, respectively.
    We need to use all three since our project contains ST-provided HAL written in
    C, our C++ code, and an assembly startup script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CMAKE_C_COMPILER`、`CMAKE_CXX_COMPILER`和`CMAKE_ASM_COMPILER` CMake变量，我们分别指定C、C++和汇编编译器的路径。我们需要使用所有三个，因为我们的项目包含用C编写的ST提供的HAL、我们的C++代码和一个汇编启动脚本。
- en: 'Now, we must specify various compiler options and preprocessor macros by running
    the following lines in our `CMakeLists.txt` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须通过在`CMakeLists.txt`文件中运行以下行来指定各种编译器选项和预处理器宏：
- en: set(CDEFS “-DUSE_HAL_DRIVER -DSTM32F072xB”)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: set(CDEFS “-DUSE_HAL_DRIVER -DSTM32F072xB”）
- en: set(MCU “-mcpu=cortex-m0 -mthumb”)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: set(MCU “-mcpu=cortex-m0 -mthumb”)
- en: set(COMMON_FLAGS “${MCU} ${CDEFS} -fdata-sections -ffunction-sections -Wno-address-of-packed-member
    -Wall -Wextra -Wno-unused-parameter”)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: set(COMMON_FLAGS “${MCU} ${CDEFS} -fdata-sections -ffunction-sections -Wno-address-of-packed-member
    -Wall -Wextra -Wno-unused-parameter”)
- en: set(CMAKE_C_FLAGS “${COMMON_FLAGS}”)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: set(CMAKE_C_FLAGS “${COMMON_FLAGS}”)
- en: set(CMAKE_CXX_FLAGS “${COMMON_FLAGS} -Wno-register -fno-exceptions -fno-rtti
    -fno-threadsafe-statics”)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: set(CMAKE_CXX_FLAGS “${COMMON_FLAGS} -Wno-register -fno-exceptions -fno-rtti
    -fno-threadsafe-statics”)
- en: 'Here, we set the `USE_HAL_DRIVER` and `STM32F072xB` compile-time macros, which
    are used by ST’s HAL. Then, we set some compiler flags that are used for both
    C and C++ files:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 `USE_HAL_DRIVER` 和 `STM32F072xB` 编译时宏，这些宏由 ST 的 HAL 使用。然后，我们设置了用于
    C 和 C++ 文件的编译器标志：
- en: '`-mcpu=cortex-m0` and -`mthumb`: Architecture-specific flags.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mcpu=cortex-m0` 和 `-mthumb`：架构特定的标志。'
- en: '`-fdata-sections`: This option tells the compiler to place data items in their
    own sections in the resulting objectfile. This can be useful for optimization
    purposes (removing unused sections).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fdata-sections`: 此选项告诉编译器将数据项放置在结果对象文件中的自己的部分。这可以用于优化目的（删除未使用的部分）。'
- en: '`-ffunction-sections`: Similar to `-fdata-sections`, but for functions. Each
    function gets its own section, allowing the linker to potentially discard unused
    functions.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ffunction-sections`: 与 `-fdata-sections` 类似，但用于函数。每个函数都获得自己的部分，允许链接器可能丢弃未使用的函数。'
- en: '`-Wno-address-of-packed-member`: Suppresses warnings related to taking the
    address of a packed member of a structure.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wno-address-of-packed-member`: 抑制与结构体打包成员的地址相关的警告。'
- en: '`-Wall`: Enables all the common warning messages recommended for normal operation.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall`: 启用所有推荐的正常操作中的常见警告消息。'
- en: '`-Wextra`: Enables extra warning flags that aren’t enabled by `-Wall`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wextra`: 启用 `-Wall` 未启用的额外警告标志。'
- en: '`-Wno-unused-parameter`: Disables warnings about unused parameters in functions.'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wno-unused-parameter`: 禁用关于函数中未使用参数的警告。'
- en: 'Then, we set the C++-specific compiler flags:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置 C++ 特定的编译器标志：
- en: '`-Wno-register`: Disables warnings about the use of the `register` keyword,
    which is deprecated in modern C++ but might be used in legacy code'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wno-register`: 禁用关于使用 `register` 关键字的警告，该关键字在现代 C++ 中已弃用，但可能在旧代码中使用'
- en: '`-fno-exceptions`: Disables support for exceptions in C++'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-exceptions`: 禁用 C++ 中的异常支持'
- en: '`-fno-rtti`: Disables **Run-Time Type Information** (**RTTI**)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-rtti`: 禁用 **运行时类型信息**（**RTTI**）'
- en: '`-fno-threadsafe-statics`: Prevents the compiler from using extra code to ensure
    that static local variables are initialized in a thread-safe way'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-threadsafe-statics`: 防止编译器使用额外的代码来确保静态局部变量以线程安全的方式初始化'
- en: 'The next part of our CMake file is project-specific: we must declare a new
    project, give it a name, enable the languages we want to use, and specify a CMake
    target, source files, and linker options.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 CMake 文件的下一部分是项目特定的：我们必须声明一个新的项目，给它一个名称，启用我们想要使用的语言，并指定 CMake 目标、源文件和链接器选项。
- en: 'This is our basic setup compiler setup for a C++ (mixed with C) project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 C++（混合 C）项目的基本设置编译器设置：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding CMake code, we have `TARGET`. This represents an entity that’s
    being built by a CMake, be it the entire firmware (an executable file) or a static
    library. In our case, the target is the entire firmware, and the target name is
    created using the project name and `.elf` suffix, meaning CMake will create a
    `bare.elf` target for us.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 CMake 代码中，我们有 `TARGET`。这代表一个由 CMake 构建的对象实体，无论是整个固件（可执行文件）还是静态库。在我们的例子中，目标是整个固件，目标名称是通过项目名称和
    `.elf` 后缀创建的，这意味着 CMake 将为我们创建一个 `bare.elf` 目标。
- en: 'The remaining step is to specify linker options using the following lines:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的步骤是使用以下行指定链接器选项：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we specify the linker script to be used – that is, `STM32F072C8Tx_FLASH.ld`
    – set a target CPU and instruction set, and specify the new-lib nano system library
    and map file to be created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们指定了要使用的链接脚本——即 `STM32F072C8Tx_FLASH.ld`——设置目标 CPU 和指令集，并指定要创建的新-lib nano
    系统库和映射文件。
- en: Now, let’s build the firmware using CMake.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 CMake 构建固件。
- en: Building a firmware using CMake
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 构建固件
- en: 'Here, we’ll create a build folder and configure the build in `Debug` mode using
    the following commands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将创建一个构建文件夹，并使用以下命令在 `Debug` 模式下配置构建：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you list the files in the build folder using `ls –l`, you’ll see that CMake
    generated `Makefile`, which is used to build the firmware. Let’s run it to build
    the firmware:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `ls –l` 列出构建文件夹中的文件，你会看到 CMake 生成的 `Makefile`，它用于构建固件。让我们运行它来构建固件：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Figure 4.2 – Building the firmware](img/B22402_04_02.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 构建固件](img/B22402_04_02.png)'
- en: Figure 4.2 – Building the firmware
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 构建固件
- en: '*Figure 4**.2* shows the output of building the firmware. We can run the resulting
    ELF file, `bare.elf`, in Renode using the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 显示了构建固件的结果。我们可以使用以下命令在 Renode 中运行生成的 ELF 文件，`bare.elf`：'
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will start the simulator using the `stm32f072.resc` Renode script from
    the `renode_scripts` folder. The script will create a new Renode machine using
    the STM32F072 target architecture and load it with the `bare.elf` file. We’ll
    see the following as part of the terminal output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 `renode_scripts` 文件夹中的 `stm32f072.resc` Renode 脚本启动模拟器。脚本将使用 STM32F072
    目标架构创建一个新的 Renode 机器，并用 `bare.elf` 文件加载它。我们将看到以下内容作为终端输出的部分：
- en: '![Figure 4.3 – Running firmware in Renode](img/B22402_04_03.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 在 Renode 中运行固件](img/B22402_04_03.png)'
- en: Figure 4.3 – Running firmware in Renode
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 在 Renode 中运行固件
- en: '*Figure 4**.3* shows the output of the simulation running in Renode in console
    mode with GUI disabled. To stop the simulation, type *q* and press *Enter*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.3* 显示了在 Renode 控制台模式下（禁用 GUI）运行的模拟器输出。要停止模拟，请输入 *q* 并按 *Enter*。'
- en: Keep in mind that if you stop or reset the Docker container, all the changes,
    including the cloned GitHub repository, will be lost. To prevent this from happening,
    you need to save them using the `docker commit` command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你停止或重置 Docker 容器，包括克隆的 GitHub 仓库在内的所有更改都将丢失。为了防止这种情况发生，你需要使用 `docker commit`
    命令保存它们。
- en: At this point, we have a pretty development environment contained in a Docker
    container. However, to fully utilize it, we must connect it to Visual Studio Code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个包含在 Docker 容器中的相当的开发环境。然而，为了充分利用它，我们必须将其连接到 Visual Studio Code。
- en: Containerized development environment and Visual Studio Code
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化开发环境和 Visual Studio Code
- en: 'To start, install Visual Studio Code ([https://code.visualstudio.com/)](https://code.visualstudio.com/)).
    Once you’ve done this, go to **Extensions** and search for and install the following
    extensions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请安装 Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))。完成此操作后，转到
    **Extensions** 并搜索并安装以下扩展：
- en: C/C++
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C/C++
- en: Cortex-Debug
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cortex-Debug
- en: CS 128 Clang-Tidy
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CS 128 Clang-Tidy
- en: Dev Containers
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dev Containers
- en: 'Once you’ve done this, open **View**| **Command Palette** (*Ctrl* + *Shift*
    + *P*), find **Dev Containers: Attach to Running Container**, and select `dev_env`.
    This should open a new Visual Studio Code window where the container’s name is
    in the bottom left bar:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '完成这些操作后，打开 **View**| **Command Palette** (*Ctrl* + *Shift* + *P*)，找到 **Dev
    Containers: Attach to Running Container** 并选择 `dev_env`。这应该会打开一个新的 Visual Studio
    Code 窗口，其中容器的名称位于左下角的状态栏中：'
- en: '![Figure 4.4 – Visual Studio Code attached to a running container](img/B22402_04_04.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – Visual Studio Code 连接到正在运行的容器](img/B22402_04_04.png)'
- en: Figure 4.4 – Visual Studio Code attached to a running container
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – Visual Studio Code 连接到正在运行的容器
- en: '*Figure 4.4* shows that Visual Studio Code was successfully attached to the
    running container. Now, let’s open the project folder at `/workspace/Cpp-in-Embedded-Systems/Chapter04/bare`.
    Open `main.cpp` in the **EXPLORER** view and set a breakpoint on line 23, as shown
    in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.4* 显示 Visual Studio Code 已成功连接到正在运行的容器。现在，让我们打开位于 `/workspace/Cpp-in-Embedded-Systems/Chapter04/bare`
    的项目文件夹。在 **EXPLORER** 视图中打开 `main.cpp` 文件，并在第 23 行设置断点，如下面的截图所示：'
- en: '![Figure 4.5 – Setting a breakpoint in Visual Studio Code](img/B22402_04_05.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 在 Visual Studio Code 中设置断点](img/B22402_04_05.png)'
- en: Figure 4.5 – Setting a breakpoint in Visual Studio Code
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 在 Visual Studio Code 中设置断点
- en: 'After setting a breakpoint, as shown in *Figure 4**.5*, select **Run**| **Start
    Debugging** (*F5*). This will do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置断点，如图 *图 4.5* 所示后，选择 **Run**| **Start Debugging** (*F5*)。这将执行以下操作：
- en: Configure the project in debug mode
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以调试模式配置项目
- en: Start the simulator and load ELF
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动模拟器和加载 ELF
- en: Connect the GDB client to the GDB server running in the simulator
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 GDB 客户端连接到模拟器中运行的 GDB 服务器
- en: Allow you to debug the target running in the simulator
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你在模拟器中调试目标运行程序
- en: 'If everything has been set up correctly, the program flow will stop on line
    23, and you’ll see the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，程序流程将在第 23 行停止，你将看到以下输出：
- en: '![Figure 4.6 – Visual Studio Code program flow](img/B22402_04_06.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – Visual Studio Code 程序流程](img/B22402_04_06.png)'
- en: Figure 4.6 – Visual Studio Code program flow
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – Visual Studio Code 程序流程
- en: '*Figure 4.6* shows that the program flow stopped on line 23\. We can switch
    to the **TERMINAL** view to see the output from Renode. Renode is in console mode,
    and it will also display **UART**. Let’s switch to the **TERMINAL** view and hit
    **Continue** (*F5*). You should see the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.6* 显示程序流程在第 23 行停止。我们可以切换到 **TERMINAL** 视图来查看 Renode 的输出。Renode 处于控制台模式，它也会显示
    **UART**。让我们切换到 **TERMINAL** 视图并按 **Continue** (*F5*)。你应该会看到以下输出：'
- en: '![Figure 4.7 – Visual Studio Code Renode output](img/B22402_04_07.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – Visual Studio Code Renode 输出](img/B22402_04_07.png)'
- en: Figure 4.7 – Visual Studio Code Renode output
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – Visual Studio Code Renode 输出
- en: 'In *Figure 4.7*, we can see the Renode output in Visual Studio Code’s **TERMINAL**
    view. To be able to debug assembly files, we need to do the following in Visual
    Studio Code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.7* 中，我们可以看到 Visual Studio Code 的 **终端** 视图中的 Renode 输出。为了能够调试汇编文件，我们需要在
    Visual Studio Code 中执行以下操作：
- en: Go to **File**|**Preferences**|**Settings**.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **文件**|**首选项**|**设置**。
- en: Search for `Allow Breakpoints Everywhere` and select the relevant checkbox.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“允许在任何地方设置断点”并选择相关复选框。
- en: 'Now, we can set a breakpoint in **platform/startup_stm32f072xb.s** on line
    87, stop the debugging session, and run it again. The program flow should stop,
    as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 **platform/startup_stm32f072xb.s** 的第 87 行设置断点，停止调试会话，然后再次运行。程序流程应该停止，如下所示：
- en: '![Figure 4.8 – Visual Studio Code assembly debugging](img/B22402_04_08.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – Visual Studio Code 汇编调试](img/B22402_04_08.png)'
- en: Figure 4.8 – Visual Studio Code assembly debugging
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – Visual Studio Code 汇编调试
- en: In *Figure 4.8*, we can see that the program flow executes the `SystemInit`
    function on line 87 of the assembly startup script, before the `main` function.
    If we use **Step Into** (*F11*), the program flow will enter the `SystemInit`
    function and Visual Studio Code will open `platform/src/system_stm32f0xx.c` file.
    If you keep moving using **Step Over** (*F10*), you’ll eventually enter the main
    function. This shows us that `main` isn’t the first function to be called.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.8* 中，我们可以看到程序流程在汇编启动脚本的第 87 行执行了 `SystemInit` 函数，在 `main` 函数之前。如果我们使用
    **进入** (*F11*)，程序流程将进入 `SystemInit` 函数，Visual Studio Code 将打开 `platform/src/system_stm32f0xx.c`
    文件。如果我们继续使用 **单步执行** (*F10*)，最终会进入 `main` 函数。这表明 `main` 不是第一个被调用的函数。
- en: 'Note that `Reset_Handler` from `startup_stm32f072xb.s` is the entry point of
    the firmware. This is defined in the linker script (`platform/STM32F072C8Tx_FLASH.ld`).
    It does the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`startup_stm32f072xb.s` 中的 `Reset_Handler` 是固件的入口点。这在链接脚本（`platform/STM32F072C8Tx_FLASH.ld`）中定义。它执行以下操作：
- en: '**Initializes the stack pointer**: It sets the initial stack pointer from the
    end of the stack (`_estack`).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始化堆栈指针**：它从堆栈的末尾（`_estack`）设置初始堆栈指针。'
- en: '**Copies data**: It copies the initialization values from flash memory to SRAM
    for the data section, which ensures that initialized global/static variables are
    set up correctly.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制数据**：它将初始化值从闪存复制到 SRAM 的数据部分，以确保初始化的全局/静态变量被正确设置。'
- en: '**Zeroes BSS**: It clears the BSS section by setting it to zero, which is required
    for uninitialized global/static variables.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零 BSS**：通过将其设置为零来清除 BSS 部分，这对于未初始化的全局/静态变量是必需的。'
- en: '**Calls SystemInit**: The `SystemInit` function is used to set the default
    system clock (system clock source, PLL multiplier and divider factors, AHB/APBx
    prescalers, and flash settings).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用 SystemInit**：`SystemInit` 函数用于设置默认系统时钟（系统时钟源、PLL 乘数和除数因子、AHB/APBx 预分频器以及闪存设置）。'
- en: '**Calls __libc_init_array**: The `__libc_init_array` function is used to initialize
    the static constructors in a C++ program or to run initialization functions in
    C programs.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用 __libc_init_array**：`__libc_init_array` 函数用于初始化 C++ 程序中的静态构造函数或在 C 程序中运行初始化函数。'
- en: '**Calls main**: This operation concludes the activities of the startup script
    and transfers program flow to the `main` function.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用 main**：此操作结束启动脚本的活动，并将程序流程转移到 `main` 函数。'
- en: With our modern development environment now fully set up, we’re ready to dive
    into learning C++ for embedded systems. The Renode simulator allows us to run,
    test, and debug our firmware efficiently, eliminating the need for physical hardware
    in the initial stages of development. This provides a flexible and efficient solution
    for embedded system learning and testing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全设置了现代开发环境，我们准备好深入学习嵌入式系统的 C++ 了。Renode 模拟器使我们能够高效地运行、测试和调试我们的固件，消除了在开发初期阶段需要物理硬件的需求。这为嵌入式系统学习和测试提供了一个灵活且高效的解决方案。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we defined the components of our development environment for
    C++ in embedded systems. We went through all of its components using a Docker
    container, which we connected to Visual Studio Code to enable a seamless development
    experience and debugging.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们定义了嵌入式系统 C++ 开发环境的组件。我们使用 Docker 容器遍历了所有组件，并将其连接到 Visual Studio Code，以实现无缝的开发体验和调试。
- en: We also set up compiler flags using CMake, ran the firmware using the Renode
    simulator, and learned how to set up our C and C++ runtime environment by going
    through the relevant assembly startup script using a debugger.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用CMake设置了编译器标志，通过Renode模拟器运行了固件，并通过调试器逐步执行相关的汇编启动脚本，学习了如何设置我们的C和C++运行时环境。
- en: In the next chapter, we’ll use the development environment we created in this
    chapter to learn more about classes in C++.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用本章创建的开发环境来学习更多关于C++中的类。
