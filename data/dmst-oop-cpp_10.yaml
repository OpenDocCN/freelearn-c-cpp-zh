- en: '*Chapter 8*: Mastering Abstract Classes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：掌握抽象类'
- en: This chapter will continue expanding our knowledge of object-oriented programming
    in C++. We will begin by exploring a powerful OO concept, **abstract classes**,
    and then progress to understanding how this idea is implemented in C++ through
    *direct language support*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续扩展我们对C++面向对象编程的知识。我们将首先探讨一个强大的面向对象概念，**抽象类**，然后逐步理解这一概念如何通过*直接语言支持*在C++中实现。
- en: We will implement abstract classes using pure virtual functions to ultimately
    support refinements in a hierarchy of related classes. We will understand how
    abstract classes augment and pair with our understanding of polymorphism. We will
    also recognize how the OO concept of abstract classes presented in this chapter
    will support powerful and adaptable designs, allowing us to create easily extensible
    C++ code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用纯虚函数实现抽象类，最终支持相关类层次结构中的细化。我们将了解抽象类如何增强和配合我们对多态性的理解。我们还将认识到本章介绍的抽象类的面向对象概念将支持强大且灵活的设计，使我们能够轻松创建可扩展的C++代码。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the OO concept of an abstract class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解抽象类的面向对象概念
- en: Implementing abstract classes with pure virtual functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纯虚函数实现抽象类
- en: Creating interfaces using abstract classes and pure virtual functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类和纯虚函数创建接口
- en: Generalizing derived class objects using abstract classes; upcasting and downcasting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类泛化派生类对象；向上转型和向下转型
- en: By the end of this chapter, you will understand the OO concept of an abstract
    class, and how to implement this idea in C++ through pure virtual functions. You
    will learn how abstract classes containing only pure virtual functions can define
    an OOP concept of an interface. You will understand why abstract classes and interfaces
    contribute to powerful OO designs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将理解抽象类的面向对象概念，以及如何通过纯虚函数在C++中实现这一概念。您将学会仅包含纯虚函数的抽象类如何定义面向对象概念的接口。您将了解为什么抽象类和接口有助于强大的面向对象设计。
- en: You will see how we can very easily generalize groups of related, specialized
    objects using sets of abstract types. We will further explore upcasting and downcasting
    within the hierarchy to understand what is allowed and when such typecasting is
    reasonable to employ.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到我们如何非常容易地使用一组抽象类型来泛化相关的专门对象。我们还将进一步探讨层次结构中的向上转型和向下转型，以了解何时允许以及何时合理使用此类类型转换。
- en: By understanding the direct language support of abstract classes in C++ using
    pure virtual functions, as well as why creating interfaces is useful, you will
    have more tools available to create an extensible hierarchy of related classes.
    Let's expand our understanding of C++ as an OOP language by understanding how
    these concepts are implemented in C++.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解C++中抽象类的直接语言支持，使用纯虚函数，以及创建接口的有用性，您将拥有更多工具来创建相关类的可扩展层次结构。让我们通过了解这些概念在C++中的实现来扩展我们对C++作为面向对象编程语言的理解。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the `Chapter08`
    subdirectory in a file named `Chp8-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可在以下GitHub网址找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08)。每个完整程序示例都可以在GitHub存储库中的适当章节标题（子目录）下找到，文件名与所在章节编号相对应，后跟破折号，再跟所在章节中的示例编号。例如，本章的第一个完整程序可以在`Chapter08`子目录中的名为`Chp8-Ex1.cpp`的文件中找到。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2Pa6XBT](https://bit.ly/2Pa6XBT).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下网址观看：[https://bit.ly/2Pa6XBT](https://bit.ly/2Pa6XBT)。
- en: Understanding the OO concept of an abstract class
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象类的面向对象概念
- en: In this section, we will introduce an essential object-oriented concept, that
    of an abstract class. Considering your growing knowledge base of key OO ideas,
    including encapsulation, information hiding, generalization, specialization, and
    polymorphism, you know how to encapsulate a class. You also know how to build
    inheritance hierarchies using single inheritance (and various reasons to build
    hierarchies, such as supporting **Is-A** relationships or for the lesser-used
    reason of supporting implementation inheritance). Furthermore, you know how to
    employ runtime binding of methods to operations using the concept of polymorphism,
    implemented by virtual functions. Let's extend our growing OO terminology by exploring
    **abstract classes**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一个重要的面向对象概念，即抽象类。考虑到您对关键面向对象思想的知识基础不断增长，包括封装、信息隐藏、泛化、特化和多态性，您知道如何封装一个类。您还知道如何使用单继承构建继承层次结构（以及构建层次结构的各种原因，例如支持**是一个**关系或支持实现继承的较少使用的原因）。此外，您知道如何使用虚函数实现方法到操作的运行时绑定，从而实现多态性的概念。让我们通过探索**抽象类**来扩展我们不断增长的面向对象术语。
- en: An **abstract class** is a base class that is intended to collect commonalities
    that may exist in derived classes for the purpose of asserting a common interface
    (that is, a set of operations) on the derived class. An abstract class does not
    represent a class that is intended for instantiation. Only objects of the derived
    class types may be instantiated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类**是一个旨在收集派生类中可能存在的共同点，以便在派生类上断言一个公共接口（即一组操作）的基类。抽象类不代表一个用于实例化的类。只有派生类类型的对象可以被实例化。'
- en: Let's start by looking at the C++ language feature that allows us to implement
    abstract classes, that is, pure virtual functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下C++语言特性，允许我们实现抽象类，即纯虚拟函数。
- en: Implementing abstract classes with pure virtual functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯虚拟函数实现抽象类
- en: An abstract class is specified by introducing at least one abstract method (that
    is, a pure virtual function prototype) in the class definition. The OO concept
    of an **abstract method** is the specification of an operation with only its protocol
    for usage (that is, with only the *name* and *signature* of the member function),
    but with no definition for the function. An abstract method will be polymorphic,
    in that, having no definition, it is expected to be redefined by derived classes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在类定义中引入至少一个抽象方法（即纯虚拟函数原型）来指定抽象类。**抽象方法**的面向对象概念是指定一个仅具有其使用协议（即成员函数的*名称*和*签名*）的操作，但没有函数定义。抽象方法将是多态的，因为没有定义，它预计会被派生类重新定义。
- en: 'A `=0` after the arguments to the function. Additionally, it is important to
    understand the following nuances regarding pure virtual functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数后面的`=0`。此外，重要的是要理解关于纯虚拟函数的以下微妙之处：
- en: Usually, definitions for pure virtual functions are not provided. This equates
    to the operation (prototype only) being specified at the base class level and
    all methods (member function definitions) being supplied at the derived class
    level.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不提供纯虚拟函数的定义。这相当于在基类级别指定操作（仅原型），并在派生类级别提供所有方法（成员函数定义）。
- en: Derived classes that do not provide methods for all pure virtual functions introduced
    by their base classes are also considered abstract and are hence not instantiable.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未为其基类引入的所有纯虚拟函数提供方法的派生类也被视为抽象类，因此不能被实例化。
- en: The `=0` in the prototype is merely an indication to the linker that a definition
    for this function need not be linked in (or resolved) when creating an executable
    program.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型中的`=0`只是向链接器指示，在创建可执行程序时，不需要链接（或解析）此函数的定义。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An abstract class is designated by including one or more pure virtual function
    prototypes in the class definition. The optional definitions for these methods
    are not typically provided.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在类定义中包含一个或多个纯虚拟函数原型来指定抽象类。通常不提供这些方法的可选定义。
- en: The reason that pure virtual functions will most often not have a definition
    is they are meant to provide a protocol of usage for polymorphic operations to
    be implemented in descendent classes. A pure virtual function designates a class
    to be abstract; an abstract class cannot be instantiated. Therefore, a definition
    provided in a pure virtual function will never be selected as the appropriate
    method for a polymorphic operation because instances of the abstract type will
    never exist. That being said, a pure virtual function can still provide a definition
    that could be explicitly called using the scope resolution operator (`::`) and
    base class name. Perhaps, this default behavior might be meaningful as a helper
    function used by derived class implementations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 纯虚拟函数通常不提供定义的原因是它们旨在为多态操作提供使用协议，以在派生类中实现。纯虚拟函数指定一个类为抽象；抽象类不能被实例化。因此，纯虚拟函数中提供的定义永远不会被选择为多态操作的适当方法，因为抽象类型的实例永远不会存在。也就是说，纯虚拟函数仍然可以提供一个定义，可以通过作用域解析运算符（`::`）和基类名称显式调用。也许，这种默认行为可能作为派生类实现中使用的辅助函数具有意义。
- en: 'Let''s begin with a brief overview of the syntax required to specify an abstract
    class. Remember, a potential keyword of *abstract* is not used to specify an abstract
    class. Rather, by merely introducing one or more pure virtual functions, we have
    indicated the class to be an abstract class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先简要概述指定抽象类所需的语法。请记住，*abstract*可能是一个用于指定抽象类的关键字。相反，仅仅通过引入一个或多个纯虚拟函数，我们已经指示该类是一个抽象类：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice, in the abstract class definition, we have introduced four virtual functions,
    three of which are pure virtual functions. The virtual destructor has no memory
    to release but is indicated as `virtual` so that it will be polymorphic, and so
    that the correct destruction sequence can be applied to derived class instances
    stored as pointers to base class types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在抽象类定义中，我们引入了四个虚拟函数，其中三个是纯虚拟函数。虚拟析构函数没有要释放的内存，但被指定为`virtual`，以便它是多态的，并且可以应用正确的销毁顺序到存储为基类类型指针的派生类实例。
- en: The three pure virtual functions, `Print()`, `IsA()`, and `Speak()`, are indicated
    with `=0` in their prototype. There are no definitions for these operations (though
    there optionally can be). A pure virtual function can have a default implementation,
    but not as an inline function. It will be the derived class's responsibility to
    provide methods for these operations using the interface (that is, signature)
    specified by this base class definition. Here, the pure virtual functions provide
    the *interface* for the polymorphic operations, which will be defined in derived
    class definitions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 三个纯虚拟函数`Print()`、`IsA()`和`Speak()`在它们的原型中被指定为`=0`。这些操作没有定义（尽管可以选择性地提供）。纯虚拟函数可以有默认实现，但不能作为内联函数。派生类的责任是使用基类定义指定的接口（即签名）为这些操作提供方法。在这里，纯虚拟函数为多态操作提供了*接口*，这些操作将在派生类定义中定义。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Abstract classes will certainly have derived classes (since we cannot instantiate
    an abstract class itself). In order to allow the virtual destructor mechanism
    to work appropriately in the eventual hierarchy, be sure to include a *virtual
    destructor* in the abstract class definition. This will ensure that all derived
    class destructors are `virtual`, and can be overridden to provide the correct
    entry point in an object's destruction sequence.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类肯定会有派生类（因为我们不能实例化抽象类本身）。为了确保虚析构函数机制在最终层次结构中能够正常工作，请确保在抽象类定义中包含虚析构函数。这将确保所有派生类的析构函数都是`virtual`，并且可以被重写以提供对象销毁序列中的正确入口点。
- en: Now, let's take a deeper look at what it means to have an interface, from an
    OO perspective.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解从面向对象的角度来拥有接口意味着什么。
- en: Creating interfaces
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建接口。
- en: An **interface class** is an OO concept of a class that is a further refinement
    of an abstract class. Whereas an abstract class can contain generalized attributes
    and default behaviors (through including data members and default definitions
    for pure virtual functions or through providing non-virtual member functions),
    an interface class will only contain abstract methods. An abstract class in C++
    containing only abstract methods (that is, pure virtual functions with no optional
    definitions) can be thought of as an **interface** class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接口类是面向对象概念中的一个类，它是抽象类的进一步细化。抽象类可以包含通用属性和默认行为（通过包含数据成员和纯虚函数的默认定义，或者通过提供非虚拟成员函数），而接口类只包含抽象方法。在C++中，一个只包含抽象方法的抽象类（即没有可选定义的纯虚函数）可以被视为接口类。
- en: 'When considering interface classes as implemented in C++, it is useful to remember
    that:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑C++中实现的接口类时，有几点需要记住：
- en: Abstract classes are not instantiable; they provide (via inheritance) the interfaces
    (that is, operations) that a derived class must offer.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类不可实例化；它们通过继承提供了派生类必须提供的接口（即操作）。
- en: Although a pure virtual function may contain an optional implementation (that
    is, method body) in the abstract class, this implementation should not be provided
    if the class wishes to be considered an interface class in pure OO terms.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然在抽象类中纯虚函数可能包含可选实现（即方法体），但如果类希望在纯面向对象的术语中被视为接口类，则不应提供此实现。
- en: Although an abstract class may have data members, it should not if the class
    wishes to be considered an interface class.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然抽象类可能有数据成员，但如果类希望被视为接口类，则不应该有数据成员。
- en: An abstract method, in OO terms, is an operation without a method; it is the
    interface only and is implemented in C++ as a pure virtual function.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面向对象的术语中，抽象方法是没有方法的操作；它只是接口，并且在C++中实现为纯虚函数。
- en: As a reminder, be sure to include a virtual destructor prototype in the interface
    class definition; this will ensure that derived class destructors will be virtual.
    The destructor definition should be empty.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为提醒，请确保在接口类定义中包含虚析构函数原型；这将确保派生类的析构函数是虚拟的。析构函数定义应为空。
- en: Let's consider various motivations for having interface classes within our OOP
    arsenal of implementation techniques. Some OOP languages follow very strict OO
    concepts and only allow for the implementation of very pure OO designs. Other
    OOP languages, such as C++, offer more flexibility, by allowing more radical OOP
    ideas to be implemented by the language directly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在面向对象编程实现技术中拥有接口类的各种动机。一些面向对象编程语言遵循非常严格的面向对象概念，只允许实现非常纯粹的面向对象设计。其他面向对象编程语言，如C++，通过直接允许实现更激进的面向对象思想，提供了更多的灵活性。
- en: For example, in pure object-oriented terms, inheritance should be reserved for
    Is-A relationships. We've seen implementation inheritance, which C++ supports
    through private and protected base classes. We've seen some acceptable uses of
    implementation inheritance, that is, to implement a new class in terms of another
    (with the ability to hide the underlying implementation with the use of protected
    and public base classes).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在纯面向对象的术语中，继承应该保留给Is-A关系。我们已经看到了C++支持的实现继承，通过私有和受保护的基类。我们已经看到了一些可接受的实现继承的用法，即以另一个类的术语实现一个新类（通过使用受保护和公共基类来隐藏底层实现）。
- en: Another example of a fringe OOP feature is that of multiple inheritance. We'll
    see in an upcoming chapter, [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*, that C++ allows a class to be derived from more
    than one base class. In some cases, we are truly saying that the derived class
    has an Is-A relationship with potentially many base classes, but not always.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个面向对象编程特性的例子是多重继承。我们将在接下来的章节中看到，C++允许一个类从多个基类派生。在某些情况下，我们确实在说派生类与许多基类可能存在Is-A关系，但并非总是如此。
- en: Some OOP languages do not allow multiple inheritance, and those that do not
    rely more on interface classes to mix in the functionality of (otherwise) multiple
    base classes. In these situations, the OOP language can allow a derived class
    to implement the functionality as specified in multiple interface classes without
    actually using multiple-inheritance. Ideally, interfaces are used to mix in functionality
    from multiple classes. These classes, not surprisingly, are sometimes referred
    to as **mix-in** classes. In these situations, we are not saying that the Is-A
    relationship necessarily applies between derived and base classes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向对象编程语言不允许多重继承，而那些不允许的语言更多地依赖于接口类来混合（否则）多个基类的功能。在这些情况下，面向对象编程语言可以允许派生类实现多个接口类中指定的功能，而不实际使用多重继承。理想情况下，接口用于混合多个类的功能。这些类，不出所料，有时被称为**混入**类。在这些情况下，我们并不一定说派生类和基类之间存在Is-A关系。
- en: In C++, when we introduce an abstract class with only pure virtual functions,
    we can think of creating an interface class. When a new class mixes in functionality
    from multiple interfaces, we can think of this in OO terms as using the interface
    classes each as a way to mix in the desired interfaces for behaviors. Note that
    the derived classes must override each of the pure virtual functions with their
    own implementation; we're mixing in only the required API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，当我们引入一个只有纯虚函数的抽象类时，我们可以认为创建了一个接口类。当一个新类混合了来自多个接口的功能时，我们可以在面向对象的术语中将其视为使用接口类来混合所需的行为接口。请注意，派生类必须用自己的实现重写每个纯虚函数；我们只混合所需的API。
- en: C++'s implementation of the OO concept of an interface is merely that of an
    abstract class containing only pure virtual functions. Here, we're using public
    inheritance from an abstract class, paired with polymorphism to simulate the OO
    concept of an interface class. Note that other languages (such as Java) implement
    this idea directly in the language (but then those languages do not support multiple
    inheritance). In C++, we can do almost anything, yet it remains important to understand
    how to implement OO ideals (even those not offered with direct language support)
    in reasonable and meaningful ways.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C++对面向对象概念中的接口的实现仅仅是一个只包含纯虚函数的抽象类。在这里，我们使用公共继承自抽象类，配合多态性来模拟面向对象概念中的接口类。请注意，其他语言（如Java）直接在语言中实现了这个想法（但是这些语言不支持多重继承）。在C++中，我们几乎可以做任何事情，但重要的是要理解如何以合理和有意义的方式实现面向对象理想（即使这些理想在直接语言支持中没有提供）。
- en: 'Let''s see an example to illustrate an abstract class used to implement an
    interface class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来说明使用抽象类实现接口类：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the aforementioned class definitions, we first notice a simple interface
    class, `Charitable`, implemented using a restricted abstract class. We include
    no data members, a pure virtual function to define the `virtual void Give(float)
    = 0;` interface, and a virtual destructor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的类定义中，我们首先注意到一个简单的接口类`Charitable`，使用受限的抽象类实现。我们不包括数据成员，一个纯虚函数来定义`virtual
    void Give(float) = 0;`接口，以及一个虚析构函数。
- en: Next, `Person` is derived from `Charitable` using public inheritance to implement
    the `Charitable` interface. We simply override `virtual void Give(float);` to
    provide a default definition for *giving*. We then derive `Student` from `Person`;
    note that a *Student Is-A Person that mixes-in (or implements) the Charitable
    interface*. In our `Student` class, we choose to redefine `virtual void Give(float);`
    to provide a more suitable `Give()` definition for `Student` instances. Perhaps
    `Student` instances have limited finances and opt to donate an amount of their
    time that is equivalent to a predetermined monetary amount.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`Person`从`Charitable`派生，使用公共继承来实现`Charitable`接口。我们简单地重写`virtual void Give(float);`来为*给予*提供一个默认定义。然后我们从`Person`派生`Student`；请注意*学生是一个实现了Charitable接口的人*。在我们的`Student`类中，我们选择重新定义`virtual
    void Give(float);`来为`Student`实例提供更合适的`Give()`定义。也许`Student`实例财务有限，选择捐赠一个等同于预定货币金额的时间量。
- en: Here, we have used an abstract class in C++ to model the OO concept of an interface
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在C++中使用抽象类来模拟面向对象概念中的接口类。
- en: Let's continue with our discussion relating to abstract classes overall by examining
    how derived class objects may be collected by abstract class types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论关于抽象类的整体问题，通过检查派生类对象如何被抽象类类型收集。
- en: Generalizing derived class objects as abstract types
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将派生类对象泛化为抽象类型
- en: We've seen in [*Chapter 7*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298),
    *Utilizing Dynamic Binding through Polymorphism*, that it is reasonable at times
    to group related derived class instances in a collection that is stored using
    base class pointers. Doing so allows uniform processing of related derived class
    types using polymorphic operations as specified by the base class. We also know
    that when a polymorphic base class operation is invoked, the correct derived class
    method will be invoked at runtime by virtue of the virtual functions and internal
    v-table that implement polymorphism in C++.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](B15702_07_Final_NM_ePub.xhtml#_idTextAnchor298)中已经看到，*通过多态性利用动态绑定*，有时将相关的派生类实例分组存储在使用基类指针的集合中是合理的。这样做允许使用基类指定的多态操作对相关的派生类类型进行统一处理。我们也知道，当调用多态基类操作时，由于C++中实现多态性的虚函数和内部虚表，将在运行时调用正确的派生类方法。
- en: You may contemplate, however, whether it is possible to collect a group of related
    derived class types by a base class type that is an abstract class? Remember,
    an abstract class is not instantiable, so how might we store a derived class object
    as an object that cannot be instantiated? The solution is to use *pointers*. Whereas
    we cannot collect derived class instances in a set of abstract base class instances
    (those types cannot be instantiated), we can collect derived class instances in
    a set of pointers of the abstract class type. We've been doing this type of grouping
    (with base class pointers) since we learned about polymorphism.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会思考，是否可能通过抽象类类型来收集一组相关的派生类类型？请记住，抽象类是不可实例化的，那么我们如何将一个派生类对象存储为一个不能被实例化的对象呢？解决方案是使用*指针*。虽然我们不能将派生类实例收集在一组抽象基类实例中（这些类型不能被实例化），但我们可以将派生类实例收集在抽象类类型的指针集合中。自从我们学习了多态性以来，我们一直在做这种类型的分组（使用基类指针）。
- en: Generalized groups of specialized objects employ implicit upcasting. Undoing
    such an upcast must be done using an explicit downcast, and the programmer will
    need to be correct as to the derived type that was previously generalized. An
    incorrect downcast to the wrong type will cause a runtime error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 广义的专门对象组使用隐式向上转型。撤消这样的向上转型必须使用显式向下转型，并且程序员需要正确地确定先前泛化的派生类型。对错误的向下转型将导致运行时错误。
- en: When is it necessary to collect derived class objects by base class types, including
    abstract base class types? The answer is when it makes sense in your application
    to process related derived class types in a more generic way, that is, when the
    operations specified in the base class type account for all of the operations
    you'd like to utilize. Undeniably, you may find just as many situations where
    keeping derived class instances in their own type (to utilize specialized operations
    introduced at the derived class level) is reasonable. Now you understand what
    is possible.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 何时需要按基类类型收集派生类对象，包括抽象基类类型？答案是，当在应用程序中以更通用的方式处理相关的派生类类型时，即当基类类型中指定的操作涵盖了您想要利用的所有操作时。毫无疑问，您可能会发现同样多的情况，即保留派生类实例在其自己的类型中（以利用在派生类级别引入的专门操作）是合理的。现在您明白了可能发生的情况。
- en: Let's continue by examining a comprehensive example showing abstract classes
    in action.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过检查一个全面的示例来展示抽象类的实际应用。
- en: Putting all the pieces together
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有部分放在一起
- en: So far, in this chapter, we have understood the subtleties of abstract classes,
    including pure virtual functions, and how to create interface classes using abstract
    classes and pure virtual functions. It is always important to see our code in
    action, with all its various components and their various nuances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经了解了抽象类的微妙之处，包括纯虚函数，以及如何使用抽象类和纯虚函数创建接口类。始终重要的是看到我们的代码在各种组件及其各种细微差别中的运行情况。
- en: 'Let''s take a look at a more complex, full program example to fully illustrate
    abstract classes, implemented using pure virtual functions in C++. In this example,
    we will not further designate an abstract class as an interface class, but we
    will take the opportunity to collect related derived class types using a set of
    pointers of their abstract base class type. This example will be broken down into
    many segments; the full program can be found at the following GitHub location:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的、完整的程序示例，以充分说明在C++中使用纯虚函数实现抽象类。在这个例子中，我们不会进一步将抽象类指定为接口类，但我们将利用机会使用一组指向其抽象基类类型的指针来收集相关的派生类类型。这个例子将被分解成许多段落；完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter08/Chp8-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the aforementioned class definition, we notice that `LifeForm` is an abstract
    class. It is an abstract class because it contains at least one pure virtual function
    definition. In fact, it contains three pure virtual function definitions, namely,
    `Print()`, `IsA()`, and `Speak()`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的类定义中，我们注意到`LifeForm`是一个抽象类。它是一个抽象类，因为它包含至少一个纯虚函数定义。事实上，它包含了三个纯虚函数定义，即`Print()`、`IsA()`和`Speak()`。
- en: 'Now, let''s extend `LifeForm` with a concrete derived class, `Cat`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一个具体的派生类`Cat`来扩展`LifeForm`：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous segment of code, we see the class definition for `Cat`. Notice
    that `Cat` has redefined the `LifeForm` pure virtual functions, `Print()`, `IsA()`,
    and `Speak()`, by providing definitions for each of these methods in the `Cat`
    class. With the existing methods in place for these functions, any derived class
    of `Cat` may optionally choose to redefine these methods with more suitable versions
    (but they are no longer obligated to do so).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们看到了`Cat`的类定义。请注意，`Cat`已经重新定义了`LifeForm`的纯虚函数`Print()`、`IsA()`和`Speak()`，并为`Cat`类中的每个方法提供了定义。有了这些函数的现有方法，`Cat`的任何派生类都可以选择重新定义这些方法，使用更合适的版本（但它们不再有义务这样做）。
- en: Note that if `Cat` had failed to redefine even one of the pure virtual functions
    of `LifeForm`, then `Cat` would also be considered an abstract class and hence
    not instantiable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果`Cat`未能重新定义`LifeForm`的任何一个纯虚函数，那么`Cat`也将被视为抽象类，因此无法实例化。
- en: As a reminder, even though the virtual functions `IsA()` and `Speak()` are written
    inline to abbreviate the code, virtual functions will never be inlined by the
    compiler, as their correct method must be determined at runtime.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，虚函数`IsA()`和`Speak()`虽然是内联写的以缩短代码，但编译器永远不会将虚函数内联，因为它们的正确方法必须在运行时确定。
- en: Notice that in the `Cat` constructors, the member initialization list is used
    to select the `LifeForm` constructor, which takes an integer argument (that is,
    `:LifeForm(15)`). A value of `15` is passed up to the `LifeForm` constructor to
    initialize `lifeExpectancy`, defined in `LifeForm`, to the value of `15`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`Cat`构造函数中，成员初始化列表用于选择接受整数参数的`LifeForm`构造函数（即`:LifeForm(15)`）。将值`15`传递给`LifeForm`构造函数，以初始化`LifeForm`中定义的`lifeExpectancy`为`15`。
- en: 'Now, let''s move forward to the class definition for `Person`, along with its
    inline functions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进到`Person`的类定义，以及它的内联函数：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that `Person` now extends `LifeForm` using public inheritance. In previous
    chapters, `Person` was a base class at the top of the inheritance hierarchy. `Person`
    redefines the pure virtual functions from `LifeForm`, namely, `Print()`, `IsA()`,
    and `Speak()`. As such, `Person` is now a concrete class and can be instantiated.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Person`现在使用公共继承扩展了`LifeForm`。在之前的章节中，`Person`是继承层次结构顶部的基类。`Person`重新定义了来自`LifeForm`的纯虚函数，即`Print()`、`IsA()`和`Speak()`。因此，`Person`现在是一个具体类，可以被实例化。
- en: 'Now, let''s review the member function definition for `Person`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下`Person`的成员函数定义：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `Person` member functions, notice that we have implementations for `Print()`,
    `IsA()`, and `Speak()`. Additionally, notice that in two of the `Person` constructors,
    we select `:LifeForm(80)` in their member initialization lists to call the `LifeForm(int)`
    constructor. This call will set the private inherited data member `LifeExpectancy`
    to `80` in the `LifeForm` sub-object of a given `Person` instance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`成员函数中，请注意我们为`Print()`、`IsA()`和`Speak()`实现了功能。另外，请注意在两个`Person`构造函数中，我们在它们的成员初始化列表中选择了`:LifeForm(80)`来调用`LifeForm(int)`构造函数。这个调用将在给定`Person`实例的`LifeForm`子对象中将私有继承的数据成员`LifeExpectancy`设置为`80`。
- en: 'Next, let''s review the `Student` class definition, along with its inline function
    definitions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾`Student`类的定义，以及它的内联函数定义：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The aforementioned class definition for `Student` looks much as we've seen in
    the past. `Student` extends `Person` using public inheritance because a `Student`
    *Is-A* `Person`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的`Student`类定义看起来很像我们以前见过的。`Student`使用公共继承扩展了`Person`，因为`Student` *是一个* `Person`。
- en: 'Moving forward, we''ll recall the non-inline `Student` class member functions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾非内联的`Student`类成员函数：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previously listed section of code, we see the non-inline member function
    definitions for `Student`. The complete class definition is, at this point, largely
    familiar to us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列出的代码部分中，我们看到了`Student`的非内联成员函数定义。到目前为止，完整的类定义对我们来说已经非常熟悉了。
- en: 'Accordingly, let''s examine the `main()` function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们来审查一下`main()`函数：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in `main()`, we declare an array of pointers to `LifeForm`. Recall, `LifeForm`
    is an abstract class. We could not create an array of `LifeForm` objects, because
    that would require us to be able to instantiate a `LifeForm`; we can't – `LifeForm`
    is an abstract class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们声明了一个指向`LifeForm`的指针数组。回想一下，`LifeForm`是一个抽象类。我们无法创建`LifeForm`对象的数组，因为那将要求我们能够实例化一个`LifeForm`；我们不能这样做——`LifeForm`是一个抽象类。
- en: However, we can create a set of pointers to an abstract type and this allows
    us to collect related types – the `Person`, `Student`, and `Cat` instances in
    this set. Of course, the only operations we may apply to instances stored in this
    generalized fashion are those found in the abstract base class, `LifeForm`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以创建一个指向抽象类型的指针集合，这使我们能够收集相关类型——在这个集合中的`Person`、`Student`和`Cat`实例。当然，我们可以对以这种泛化方式存储的实例应用的唯一操作是在抽象基类`LifeForm`中找到的那些操作。
- en: Next, we allocate a variety of `Person`, `Student`, and `Cat` instances, storing
    each instance via an element in the generalized set of pointers of type `LifeForm`.
    When any of these derived class instances is stored in this fashion, an implicit
    upcast to the abstract base class type is performed (but the instance is not altered
    in any fashion – we're just pointing to the most base class sub-object comprising
    the entire memory layout).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分配了各种`Person`、`Student`和`Cat`实例，将每个实例存储在类型为`LifeForm`的泛化指针集合的元素中。当以这种方式存储任何这些派生类实例时，将执行隐式向上转型到抽象基类类型（但实例不会以任何方式被改变——我们只是指向整个内存布局组成部分的最基类子对象）。
- en: Now, we proceed through a loop to apply operations as found in the abstract
    class `LifeForm` to all instances in this generalized collection, such as `Speak()`,
    `Print()`, and `IsA()`. These operations happen to be polymorphic, allowing each
    instance's most appropriate implementation to be utilized via dynamic binding.
    We additionally invoke `GetLifeExpectancy()` on each of these instances, which
    is a non-virtual function found at the `LifeForm` level. This function merely
    returns the life expectancy of the `LifeForm` in question.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过循环来对这个泛化集合中的所有实例应用在抽象类`LifeForm`中找到的操作，比如`Speak()`、`Print()`和`IsA()`。这些操作恰好是多态的，允许通过动态绑定使用每个实例的最适当实现。我们还在每个实例上调用`GetLifeExpectancy()`，这是在`LifeForm`级别找到的非虚拟函数。这个函数只是返回了相关`LifeForm`的寿命预期。
- en: Lastly, we loop through deleting the dynamically allocated instances of `Person`,
    `Student`, and `Cat` again using the generalized `LifeForm` pointers. We know
    that `delete()` will patch in a call to the destructor, and because the destructor
    is virtual, the appropriate starting level of the destructor and proper destruction
    sequence will commence.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过循环使用泛化的`LifeForm`指针再次删除动态分配的`Person`、`Student`和`Cat`实例。我们知道`delete()`将会调用析构函数，并且因为析构函数是虚拟的，适当的析构顺序将会开始。
- en: The utility of the `LifeForm` abstract class in this example is that its use
    allows us to generalize common aspects and behaviors of all `LifeForm` objects
    together in one base class (such as `lifeExpectancy` and `GetLifeExpectancy()`).
    The common behaviors also extend to a set of pure virtual functions with the desired
    interfaces that all `LifeForm` objects should have, namely, `Print()`, `IsA()`,
    and `Speak()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`LifeForm`抽象类的实用性在于它的使用允许我们将所有`LifeForm`对象的共同特征和行为概括在一个基类中（比如`lifeExpectancy`和`GetLifeExpectancy()`）。这些共同行为还扩展到一组具有所需接口的纯虚函数，所有`LifeForm`对象都应该有，即`Print()`、`IsA()`和`Speak()`。
- en: Important reminder
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提醒
- en: An abstract class is one that collects common traits of derived classes, yet
    does not itself represent a tangible entity or object that should be instantiated.
    In order to specify a class as abstract, it must contain at least one pure virtual
    function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是收集派生类的共同特征，但本身并不代表应该被实例化的有形实体或对象。为了将一个类指定为抽象类，它必须包含至少一个纯虚函数。
- en: Looking at the output for the aforementioned program, we can see that objects
    of various related derived class types are instantiated and processed uniformly.
    Here, we've collected these objects by their abstract base class type and have
    overridden the pure virtual functions in the base class with meaningful definitions
    in various derived classes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上述程序的输出，我们可以看到各种相关的派生类类型的对象被实例化并统一处理。在这里，我们通过它们的抽象基类类型收集了这些对象，并且在各种派生类中用有意义的定义覆盖了基类中的纯虚函数。
- en: 'Here is the output for the full program example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整程序示例的输出：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have now thoroughly examined the OO idea of an abstract class and how it
    is implemented in C++ using pure virtual functions, as well as how these ideas
    can extend to creating OO interfaces. Let's briefly recap the language features
    and OO concepts we've covered in this chapter before moving onward to our next
    chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经彻底研究了抽象类的面向对象概念以及在C++中如何使用纯虚函数实现，以及这些概念如何扩展到创建面向对象接口。在继续前进到下一章之前，让我们简要回顾一下本章涵盖的语言特性和面向对象概念。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have continued our progression with object-oriented programming,
    foremost by understanding how pure virtual functions in C++ provide direct language
    support for the OO concept of an abstract class. We have explored how abstract
    classes without data members, and that do not contain non-virtual functions, can
    support the OO ideal of an interface class. We've talked about how other OOP languages
    utilize interface classes and how C++ may choose to support this paradigm as well,
    by using such restricted abstract classes. We've up cast related derived class
    types to be stored as pointers of the abstract base class type, as it is a typical
    and overall very useful programming technique.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续了解面向对象编程，首先是通过理解C++中纯虚函数如何直接支持抽象类的面向对象概念。我们探讨了没有数据成员且不包含非虚函数的抽象类如何支持接口类的面向对象理想。我们谈到了其他面向对象编程语言如何利用接口类，以及C++如何选择支持这种范式，通过使用这种受限制的抽象类。我们将相关的派生类类型向上转换为抽象基类类型的指针存储，这是一种典型且非常有用的编程技术。
- en: We have seen how abstract classes complement polymorphism not only by providing
    a class to specify common attributes and behaviors that derived classes share,
    but most notably to provide the interfaces of polymorphic behaviors for the related
    classes since abstract classes themselves are not instantiable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到抽象类如何通过提供一个类来指定派生类共享的共同属性和行为，以及最重要的是为相关类提供多态行为的接口，因为抽象类本身是不可实例化的。
- en: By adding abstract classes and potentially the OO concept of interface classes
    to our programming repertoire in C++, we are able to implement designs that promote
    easily extensible code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在C++中添加抽象类和可能的面向对象接口类的概念，我们能够实现促进易于扩展的代码设计。
- en: We are now ready to continue to [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*, to enhance our OOP skills by next learning how
    and when to appropriately utilize the concept of multiple inheritance, while understanding
    trade-offs and potential design alternatives. Let's move forward!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续[*第9章*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361)，*探索多重继承*，通过学习如何以及何时适当地利用多重继承的概念，同时理解权衡和潜在的设计替代方案，来增强我们的面向对象编程技能。让我们继续前进吧！
- en: Questions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Create a hierarchy of shapes using the following guidelines:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下指南创建形状的层次结构：
- en: 'a. Create an abstract base class called `Shape`, which defines an operation
    to compute the area of a `Shape`. Do not include a method for the `Area()` operation.
    Hint: use a pure virtual function.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: a. 创建一个名为`Shape`的抽象基类，它定义了计算`Shape`面积的操作。不要包括`Area()`操作的方法。提示：使用纯虚函数。
- en: b. Derive `Rectangle`, `Circle`, and `Triangle` classes from `Shape` using public
    inheritance. Optionally, derive the `Square` class from `Rectangle`. Redefine
    the `Area()` `operation`, which `Shape` has introduced, in each derived class.
    Be sure to provide the method to support the operation in each derived class so
    that you can later instantiate each type of `Shape`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: b. 使用公共继承从`Shape`派生`Rectangle`、`Circle`和`Triangle`类。可选择从`Rectangle`派生`Square`类。在每个派生类中重新定义`Shape`引入的`Area()`操作。确保在每个派生类中提供支持该操作的方法，以便稍后实例化每种`Shape`类型。
- en: c. Add data members and other member functions as necessary to complete the
    newly introduced class definitions. Remember, only common attributes and operations
    should be specified in `Shape` – all others belong in their respective derived
    classes. Don't forget to implement the copy constructor and access functions within
    each class definition.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: c. 根据需要添加数据成员和其他成员函数来完成新引入的类定义。记住，只有共同的属性和操作应该在`Shape`中指定 - 所有其他属性和操作都属于它们各自的派生类。不要忘记在每个类定义中实现复制构造函数和访问函数。
- en: d. Create an array of pointers of the abstract class type, `Shape`. Assign elements
    in this array point to instances of the `Rectangle`, `Square`, `Circle`, and `Triangle`
    `type`. Since you are now treating derived class objects as generalized `Shape`
    objects, loop through the array of pointers and invoke the `Area()` function for
    each. Be sure to `delete()` any dynamically allocated memory you have allocated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: d. 创建一个抽象类类型`Shape`的指针数组。将该数组中的元素指向`Rectangle`、`Square`、`Circle`和`Triangle`类型的实例。由于现在你正在将派生类对象视为通用的`Shape`对象，所以循环遍历指针数组，并为每个调用`Area()`函数。确保`delete()`任何动态分配的内存。
- en: e. Is your abstract `Shape` class also an interface class in conceptual OO terms?
    Why or why not?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: e. 在概念上，你的抽象`Shape`类也是一个接口类吗？为什么或为什么不是？
