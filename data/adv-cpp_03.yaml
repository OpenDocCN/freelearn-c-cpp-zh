- en: 2B. No Ducks Allowed – Templates and Deduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2B.不允许鸭子-模板和推导
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够：
- en: Develop your own classes to an even greater effect using inheritance and polymorphism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承和多态将自己的类发挥到更大的效果
- en: Implement an alias to make your code easier to read
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现别名以使您的代码更易于阅读
- en: Develop templates using SFINAE and constexpr to simplify your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SFINAE和constexpr开发模板以简化您的代码
- en: Implement your own solutions using the STL to leverage generic programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STL实现自己的解决方案，以利用通用编程
- en: Describe the context and basic rules for type deduction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述类型推导的上下文和基本规则
- en: This chapter will show you how to define and extend your types through inheritance,
    polymorphism, and templates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何通过继承，多态和模板来定义和扩展您的类型。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to develop our own types (classes) with
    the help of unit tests and made them behave like built-in types. We were introduced
    to function overloading, Rule of Three/Five, and Rule of Zero.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过单元测试开发自己的类型（类），并使它们表现得像内置类型。我们介绍了函数重载，三/五法则和零法则。
- en: In this chapter, we will learn how to extend the type system even further. We'll
    learn how to create functions and classes using templates and revisit function
    overloading since it's impacted by the use of templates. We'll be introduced to
    a new technology, **SFINAE**, and use it to control the parts of our templates
    that are included in the generated code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何进一步扩展类型系统。我们将学习如何使用模板创建函数和类，并重新讨论函数重载，因为它受到模板的影响。我们将介绍一种新技术**SFINAE**，并使用它来控制我们模板中包含在生成代码中的部分。
- en: Inheritance, Polymorphism, and Interfaces
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承，多态和接口
- en: 'So far in our journey of object-oriented design and C++, we have focused on
    abstraction and data encapsulation. We will now turn our attention to **inheritance**
    and **polymorphism**. What is inheritance? What is polymorphism? Why do we need
    it? Consider the following three objects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的面向对象设计和C++的旅程中，我们已经专注于抽象和数据封装。现在我们将把注意力转向**继承**和**多态**。什么是继承？什么是多态？我们为什么需要它？考虑以下三个对象：
- en: '![Figure 2B.1: Vehicle objects'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.1：车辆对象'
- en: '](img/C14583_02B_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_01.jpg)'
- en: 'Figure 2B.1: Vehicle objects'
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.1：车辆对象
- en: In the preceding diagram, we can see that there are three very different objects.
    They have some things in common. They all have wheels (a different number), an
    engine (different size, power, or configuration), start engine, drive, apply brakes,
    stop engine, and so on, using which we can do something.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到有三个非常不同的对象。它们有一些共同之处。它们都有轮子（不同数量），发动机（不同大小，功率或配置），启动发动机，驾驶，刹车，停止发动机等，我们可以使用这些来做一些事情。
- en: 'So, we can abstract them into something called a vehicle that demonstrates
    these attributes and general behaviors. If we express this as a C++ class, it
    might look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将它们抽象成一个称为车辆的东西，展示这些属性和一般行为。如果我们将其表达为C++类，可能会看起来像下面这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Vehicle` class is a more generalized (or abstract) expression of `Motorcycle`,
    `Car`, and `Truck`. We can now create more specialized types by reusing what is
    already available in the Vehicle class. We are going to reuse Vehicle''s properties
    and methods by using inheritance. The syntax for inheritance is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`类是`Motorcycle`，`Car`和`Truck`的更一般（或抽象）表达。我们现在可以通过重用Vehicle类中已有的内容来创建更专业化的类型。我们将通过继承来重用Vehicle的属性和方法。继承的语法如下：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have come across access modifiers such as `public`, `protected` and `private`
    before. They control how we have access to the base classes'' members. The Motorcycle
    class will be derived as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前遇到过`public`，`protected`和`private`等访问修饰符。它们控制我们如何访问基类的成员。Motorcycle类将派生如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, the Vehicle class is referred to as the **base class** or the
    **super class**, while the Motorcycle class is referred to as the **derived class**
    or **subclass**. Graphically, we can represent this as follows, where the arrows
    point from the derived class to the base class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Vehicle类被称为**基类**或**超类**，而Motorcycle类被称为**派生类**或**子类**。从图形上看，我们可以表示为下面的样子，箭头从派生类指向基类：
- en: '![Figure 2B.2: Vehicle class hierarchy'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.2：车辆类层次结构'
- en: '](img/C14583_02B_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_02.jpg)'
- en: 'Figure 2B.2: Vehicle class hierarchy'
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.2：车辆类层次结构
- en: 'But a motorcycle drives differently from a generic vehicle. So, we need to
    modify the `Motorcycle` class so that it behaves differently. The updated code
    will be as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但摩托车的驾驶方式与通用车辆不同。因此，我们需要修改`Motorcycle`类，使其行为不同。更新后的代码将如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we think about object-oriented design, this is about modeling a problem space
    in terms of objects that collaborate. These objects communicate with each other
    through messages. Now, we have two classes that respond to the same message (the
    `Drive()` method) in different ways. The sender of the message has no knowledge
    of what will happen and doesn't really care, and this is the essence of polymorphism.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑面向对象设计，这是关于以对象协作的方式对问题空间进行建模。这些对象通过消息相互通信。现在，我们有两个类以不同的方式响应相同的消息（`Drive()`方法）。发送消息的人不知道会发生什么，也不真的在乎，这就是多态的本质。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Polymorphism comes from the Greek words poly and morph, where `poly` means many
    and `morph` means form. So, polymorphism means `having many forms`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多态来自希腊词poly和morph，其中`poly`表示许多，`morph`表示形式。因此，多态意味着`具有多种形式`。
- en: 'We can now use these classes to try out polymorphism:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些类来尝试多态：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we compile and run this program, we get the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行此程序，我们会得到以下输出：
- en: '![Figure 2B.3: Vehicle program output'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.3：车辆程序输出'
- en: '](img/C14583_02B_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_03.jpg)'
- en: 'Figure 2B.3: Vehicle program output'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.3：车辆程序输出
- en: 'In the preceding screenshot, the lines after the line `Vehicle::StartEngine
    1500 cc` are all related to the `Motorcycle`. But the Drive line still shows `Vehicle::Drive`
    and not the expected `Motorcycle::Drive`. What''s going on? The problem is that
    we have not told the compiler that the `Drive` method in the `Vehicle` class can
    be modified (or overridden) by a derived class. We need to make one change in
    our code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，在`Vehicle::StartEngine 1500 cc`之后的行都与`Motorcycle`有关。但是`Drive`行仍然显示`Vehicle::Drive`，而不是预期的`Motorcycle::Drive`。出了什么问题？问题在于我们没有告诉编译器`Vehicle`类中的`Drive`方法可以被派生类修改（或覆盖）。我们需要在代码中做出一些改变：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By adding the `virtual` keyword before the member function declaration, we
    are telling the compiler that a derived class can (but doesn''t have to) override
    or replace the function. If we make this change and then compile and run the program,
    we get the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在成员函数声明之前添加`virtual`关键字，我们告诉编译器派生类可以（但不一定）覆盖或替换该函数。如果我们进行此更改，然后编译并运行程序，将得到以下输出：
- en: '![Figure 2B.4: Vehicle program output with virtual methods'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.4：带有虚方法的车辆程序输出'
- en: '](img/C14583_02B_04.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_04.jpg)'
- en: 'Figure 2B.4: Vehicle program output with virtual methods'
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.4：带有虚方法的车辆程序输出
- en: 'Now, we have learned about inheritance and polymorphism. We used a pointer
    to a `Vehicle` class to control the `Motorcycle` class. Another change to the
    code should be made as a matter of best practice. We should also change the declaration
    of the `Drive` function in the `Motorcyle` as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了继承和多态性。我们使用`Vehicle`类的指针来控制`Motorcycle`类。作为最佳实践的一部分，应该对代码进行另一个更改。我们还应该更改`Motorcyle`中`Drive`函数的声明如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'C++11 introduced the `override` keyword as a hint to the compiler, stating
    that a particular method should have the same function prototype as a method somewhere
    in its parent tree. If it cannot find one, then the compiler will report an error.
    This is a very useful feature and can save you from hours of debugging. If there
    is some way for the compiler to report an error, use it. The earlier a defect
    is detected, the easier it is to fix. One final change is that whenever we add
    a virtual function to a class, we must declare its destructor `virtual`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了`override`关键字，作为向编译器的提示，说明特定方法应具有与其父树中某个方法相同的函数原型。如果找不到，则编译器将报告错误。这是一个非常有用的功能，可以帮助您节省数小时的调试时间。如果编译器有办法报告错误，请使用它。缺陷检测得越早，修复就越容易。最后一个变化是，每当我们向类添加虚函数时，必须声明其析构函数为`virtual`：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We saw this with the `Drive()` function before it was made virtual. When the
    destructor is called through the pointer to a Vehicle, it needs to know which
    destructor to call. Thus, making it virtual enables this. If you fail to do so,
    then you can end up with resource leaks or spliced objects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Drive()`函数设为虚函数之前，我们已经看到了这一点。当通过指向Vehicle的指针调用析构函数时，需要知道调用哪个析构函数。因此，将其设为虚函数可以实现这一点。如果未能这样做，可能会导致资源泄漏或对象被切割。
- en: Inheritance and Access Specifiers
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承和访问说明符
- en: 'As we mentioned previously, the general form of inheriting one subclass from
    a super class is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，从超类继承一个子类的一般形式如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we derived Motorcycle class from Vehicle class, we use the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Vehicle类派生Motorcycle类时，我们使用以下代码：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The access modifier is optional and is one of the ones that we have met before:
    `public`, `protected`, and `private`. In the following table, you can see the
    accessibility of the base classes'' members. If access_modifier is omitted, then
    the compiler assumes private was specified.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是可选的，是我们之前遇到的`public`、`protected`和`private`之一。在下表中，您可以看到基类成员的可访问性。如果省略access_modifier，则编译器会假定指定了private。
- en: '![Figure 2B.5: Accessibility of base class members in derived classes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.5：派生类中基类成员的可访问性'
- en: '](img/C14583_02B_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_05.jpg)'
- en: 'Figure 2B.5: Accessibility of base class members in derived classes'
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.5：派生类中基类成员的可访问性
- en: Abstract Classes and Interfaces
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类和接口
- en: All the classes that we have talked about up until now are **concrete class**
    – they can be instantiated as a type for a variable. There is another type of
    class – an **abstract class**– that contains at least one **pure virtual member
    function**. A pure virtual function is a virtual function that has no definition
    (or implementation) in the class. And because it has no implementation, the class
    is malformed (or abstract) and cannot be instantiated. If you attempt to create
    a variable of an abstract type, then the compiler will generate an error.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们谈论过的所有类都是**具体类** - 它们可以实例化为变量的类型。还有另一种类型的类 - **抽象类** - 它包含至少一个**纯虚成员函数**。纯虚函数是一个在类中没有定义（或实现）的虚函数。由于它没有实现，该类是畸形的（或抽象的），无法实例化。如果尝试创建抽象类型的变量，则编译器将生成错误。
- en: 'To declare a pure virtual member function, end the function prototype declaration
    with `= 0`. To make Drive() a pure virtual function in the Vehicle class, we would
    declare it as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明纯虚成员函数，将函数原型声明结束为`= 0`。要将`Drive()`作为Vehicle类中的纯虚函数声明，我们将其声明如下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, to be able to use a derived class as a variable type (for example, the
    `Motorcycle` class), it must define an implementation of the `Drive()` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了能够将派生类用作变量类型（例如`Motorcycle`类），它必须定义`Drive()`函数的实现。
- en: You can, however, declare a variable to be either a pointer to the abstract
    class or a reference to the abstract class. In either case, it must point to,
    or reference, some non-abstract class derived from the abstract class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以声明变量为抽象类的指针或引用。在任何一种情况下，它必须指向或引用从抽象类派生的某个非抽象类。
- en: In Java, there is a keyword interface that allows you to define a class that
    is all pure virtual functions. The same is achieved in C++ by declaring a class
    that only declares public pure virtual functions (and a virtual destructor). In
    this way, we define an interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，有一个关键字接口，允许你定义一个全是纯虚函数的类。在C++中，通过声明一个只声明公共纯虚函数（和虚析构函数）的类来实现相同的效果。通过这种方式，我们定义了一个接口。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Before solving any practical in this chapter, download this book's GitHub repository
    ([https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus))
    and import the folder for Lesson 2B in Eclipse so that you can view the code for
    each exercise and activity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中解决任何实际问题之前，请下载本书的GitHub存储库（[https://github.com/TrainingByPackt/Advanced-CPlusPlus](https://github.com/TrainingByPackt/Advanced-CPlusPlus)）并在Eclipse中导入Lesson
    2B文件夹，以便查看每个练习和活动的代码。
- en: 'Exercise 1: Implementing Game Characters with Polymorphism'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：使用多态实现游戏角色
- en: 'In this exercise, we will demonstrate inheritance, interfaces, and polymorphism.
    We will start with an ad hoc implementation of a role-playing game and evolve
    it to be more generic and expandable. Let''s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将演示继承、接口和多态。我们将从一个临时实现的角色扮演游戏开始，然后将其演变为更通用和可扩展的形式。让我们开始吧：
- en: Open Eclipse and create a new project named **Lesson2B** using the files found
    in the **Lesson2B** examples folder.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Eclipse，并使用**Lesson2B**示例文件夹中的文件创建一个名为**Lesson2B**的新项目。
- en: As this is a **CMake-based project**, change the current builder to **Cmake
    Build (portable)**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个**基于CMake的项目**，将当前构建器更改为**Cmake Build (portable)**。
- en: Go to the **Project** | **Build All** menu to build all exercises. By default,
    the console at the bottom of the screen will display the **CMake console [Lesson2B]**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**项目** | **构建所有**菜单以构建所有练习。默认情况下，屏幕底部的控制台将显示**CMake控制台[Lesson2B]**。
- en: 'Configure a **New Launch Configuration** named **L2BExercise1** that runs the
    **Exercise1** binary and click on **Run** to build and run **Exercise 1**. You
    will receive the following output:![Figure 2B.6: Exercise 1 default output'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个名为**L2BExercise1**的**新启动配置**，运行**Exercise1**二进制文件，然后点击**运行**以构建和运行**Exercise
    1**。你将收到以下输出：![图2B.6：练习1默认输出
- en: '](img/C14583_02B_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_06.jpg)'
- en: 'Figure 2B.6: Exercise 1 default output'
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.6：练习1默认输出
- en: 'Open `speak()` and `act()` directly. This is fine for a small program. But
    as the game grew to tens or hundreds of characters, it would become unmanageable.
    So, we need to abstract all the characters. Add the following Interface declaration
    to the top of the file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接打开`speak()`和`act()`。对于一个小程序来说这是可以的。但是当游戏扩大到几十甚至上百个角色时，就会变得难以管理。因此，我们需要将所有角色抽象出来。在文件顶部添加以下接口声明：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Normally, the destructor would be empty, but here, it has logging to show the
    behavior.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，析构函数将是空的，但在这里，它有日志来显示行为。
- en: 'Derive the `Wizard`, `Healer`, and `Warrior` classes from this interface class
    and add the `override` keyword to the end of the declarations of the `speak()`
    and `act()` functions for each class:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个接口类派生`Wizard`、`Healer`和`Warrior`类，并在每个类的`speak()`和`act()`函数声明末尾添加`override`关键字：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Click the **Run** button to rebuild and run the exercise. We will now see that
    the base class destructor is also called after the destructor of the derived class:![Figure
    2B.7: Output of the modified program'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新构建和运行练习。现在我们将看到在派生类的析构函数之后也调用了基类的析构函数：![图2B.7：修改后程序的输出
- en: '](img/C14583_02B_07.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_07.jpg)'
- en: 'Figure 2B.7: Output of the modified program'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.7：修改后程序的输出
- en: 'Create the characters and manage them in a container such as a `vector`. Create
    the following two methods in the file, before the `main()` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建角色并在容器中管理它们，比如`vector`。在`main()`函数之前在文件中创建以下两个方法：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Replace the content of `main()` with the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`main()`的内容：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Click the **Run** button to rebuild and run the exercise. Here is the output
    that is generated:![Figure 2B.8: Output of the polymorphic version'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新构建和运行练习。以下是生成的输出：![图2B.8：多态版本的输出
- en: '](img/C14583_02B_08.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_08.jpg)'
- en: 'Figure 2B.8: Output of the polymorphic version'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.8：多态版本的输出
- en: As you can see from the preceding screenshot, the logging for **Destroying Wizard**
    and so on has disappeared. The problem is that the container holds the pointers
    to the base class and that it doesn't know how to call the full destructor in
    each case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中可以看出，“销毁巫师”等日志已经消失了。问题在于容器保存了指向基类的指针，并且不知道如何在每种情况下调用完整的析构函数。
- en: 'To fix this, simply declare the destructor for `ICharacter` as virtual:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，只需将`ICharacter`的析构函数声明为虚函数：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Click the **Run** button to rebuild and run the exercise. The output now reads
    as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**按钮重新构建和运行练习。输出现在如下所示：
- en: '![Figure 2B.9: Output from the full polymorphic version'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.9：完整多态版本的输出'
- en: '](img/C14583_02B_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_09.jpg)'
- en: 'Figure 2B.9: Output from the full polymorphic version'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.9：完整多态版本的输出
- en: We have now implemented an interface to our `ICharacter` characters and used
    them polymorphically by simply calling the `speak()` and `act()` methods through
    a base class pointer stored in a container.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为我们的`ICharacter`角色实现了一个接口，并通过在容器中存储基类指针简单地调用`speak()`和`act()`方法进行了多态使用。
- en: Classes, Structs, and Unions Revisited
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类、结构体和联合体再讨论
- en: 'Previously, we discussed that the difference between a class and a struct was
    the default access modifier – private for class and public for struct. This difference
    goes one step further – it applies to the base class if it does not specify anything:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论过类和结构体的区别是默认访问修饰符 - 类的为私有，结构体的为公共。这个区别更进一步 - 如果基类没有指定任何内容，它将应用于基类：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It should be noted that a union can neither be a base class nor be derived
    from a base class. If there is essentially no difference between a struct and
    a class, then which type should we use? Essentially, it is one of convention.
    A **struct** is used to bundle together several related elements, while a **class**
    can do things and has responsibilities. An example of a struct is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，联合既不能是基类，也不能从基类派生。如果结构和类之间本质上没有区别，那么我们应该使用哪种类型？本质上，这是一种惯例。**结构**用于捆绑几个相关的元素，而**类**可以执行操作并具有责任。结构的一个例子如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we can see that it groups together three coordinates
    so that we can reason about a point in a 3D space. This structure can be passed
    as a coherent dataset to methods that need points, rather than three separate
    arguments per point. A class, on the other hand, models an object that can perform
    actions. Take a look at the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到它将三个坐标组合在一起，这样我们就可以推断出三维空间中的一个点。这个结构可以作为一个连贯的数据集传递给需要点的方法，而不是每个点的三个单独的参数。另一方面，类模拟了一个可以执行操作的对象。看看下面的例子：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A rule of thumb is to use a class if there is at least one private member as
    this implies that the details of the implementation will be behind the public
    member functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则是，如果至少有一个私有成员，则应使用类，因为这意味着实现的细节将在公共成员函数的后面。
- en: Visibility, Lifetime, and Access
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性、生命周期和访问
- en: We have talked about creating our own types and declaring variables and functions
    while mainly focusing on simple functions and a single file. We will now look
    at what happens when there are multiple source files (translation units) that
    contain classes and function definitions. Also, we'll check which variables and
    functions can be visible from the other parts of the source files, how long the
    variables live, and look at the difference between internal and external linkage.
    In *Chapter 1*, *Anatomy of Portable C++ Software*, we saw how the toolchain works
    to compile the source files and produce the object files and that the the linker
    puts it all together to form an executable program.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了创建自己的类型和声明变量和函数，主要关注简单函数和单个文件。现在我们将看看当有多个包含类和函数定义的源文件（翻译单元）时会发生什么。此外，我们将检查哪些变量和函数可以从源文件的其他部分可见，变量的生存周期有多长，并查看内部链接和外部链接之间的区别。在*第1章*，*可移植C++软件的解剖学*中，我们看到了工具链是如何工作的，编译源文件并生成目标文件，链接器将其全部组合在一起形成可执行程序。
- en: 'When a compiler processes a source file, it generates an object file that contains
    the translated C++ code and enough information for the linker to resolve any references
    from the compiled source file to another source file. In *Chapter 1*, *Anatomy
    of Portable C++ Software*, `sum()`, which is defined in the **SumFunc.cpp** file.
    When the compiler constructs an object file, it creates the following segments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器处理源文件时，它会生成一个包含转换后的C++代码和足够信息的目标文件，以便链接器解析已编译源文件到另一个源文件的任何引用。在*第1章*，*可移植C++软件的解剖学*中，`sum()`在**SumFunc.cpp**文件中定义。当编译器构建目标文件时，它创建以下段：
- en: '**Code segment** (also known as text): This is the translation of the C++ functions
    into the target machine instructions.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码段**（也称为文本）：这是C++函数翻译成目标机器指令的结果。'
- en: '**Data segment**: This contains all the variables and data structures that
    are declared in the program, not local or allocated off the heap or stack, and
    are initialized.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据段**：这包含程序中声明的所有变量和数据结构，不是本地的或从堆栈分配的，并且已初始化。'
- en: '**BSS segment**: This contains all the variables and data structures that are
    declared in the program, not local or allocated off the heap or stack, and are
    not initialized (but will be initialized to zero).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSS段**：这包含程序中声明的所有变量和数据结构，不是本地的或从堆栈分配的，并且未初始化（但将初始化为零）。'
- en: '**Database of exported symbols**: A list of variables and functions that are
    in this object file and their location.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导出符号数据库**：此对象文件中的变量和函数列表及其位置。'
- en: '**Database of referenced symbols**: A list of variables and functions this
    object file needs from outside itself and where they are used.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用符号数据库**：此对象文件需要从外部获取的变量和函数列表以及它们的使用位置。'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: BSS is used to name the uninitialized data segment and its name is historically
    derived from Block Started by Symbol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: BSS用于命名未初始化的数据段，其名称历史上源自Block Started by Symbol。
- en: 'The linker then collects all the code segments, data segments, and **BSS**
    segments together to form the program. It uses the information in the two databases
    (DB) to resolve all the referenced symbols to the exported symbols list and patch
    the code segments with this information so that they can operate correctly. Graphically,
    this is depicted as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，链接器将所有代码段、数据段和**BSS**段收集在一起形成程序。它使用两个数据库（DB）中的信息将所有引用的符号解析为导出的符号列表，并修补代码段，使其能够正确运行。从图形上看，这可以表示如下：
- en: '![Figure 2B.10: Parts of the object files and the executable file'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.10：目标文件和可执行文件的部分'
- en: '](img/C14583_02B_10.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_10.jpg)'
- en: 'Figure 2B.10: Parts of the object files and the executable file'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.10：目标文件和可执行文件的部分
- en: 'For the purposes of the discussion that follows, BSS and data segments will
    be referred to simply as data segment (the only difference being that BSS is not
    initialized). When a program is executed, it is loaded into memory and its memory
    looks a bit like the executable file layout – it contains the text segment, data
    segment, BSS segment, and free memory allocated by the host system, which contains
    what is known as the **stack** and the **heap**. The stack typically starts at
    the top of the memory and grows down, while the heap starts where BSS finishes
    and grows up, toward the stack:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了后续讨论的目的，BSS和数据段将简称为数据段（唯一的区别是BSS未初始化）。当程序执行时，它被加载到内存中，其内存看起来有点像可执行文件布局 - 它包含文本段、数据段、BSS段以及主机系统分配的空闲内存，其中包含所谓的**堆栈**和**堆**。堆栈通常从内存顶部开始并向下增长，而堆从BSS结束的地方开始并向上增长，朝向堆栈：
- en: '![Figure 2B.11: CxxTemplate runtime memory map'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.11：CxxTemplate运行时内存映射'
- en: '](img/C14583_02B_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_11.jpg)'
- en: 'Figure 2B.11: CxxTemplate runtime memory map'
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.11：CxxTemplate运行时内存映射
- en: 'The section of the program in which a variable or identifier is accessible
    is known as the **scope**. There are two broad categories of scope:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变量或标识符可访问的程序部分称为**作用域**。作用域有两个广泛的类别：
- en: '`{}`). The variable can be accessed inside the curly braces. Just like blocks
    can be nested, so can the scope of the variable. This typically includes local
    variables and function parameters, and these are generally stored in the stack.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`). 变量可以在大括号内部访问。就像块可以嵌套一样，变量的作用域也可以嵌套。这通常包括局部变量和函数参数，这些通常存储在堆栈中。'
- en: '**Global / file scope**: This applies to variables declared outside a normal
    function or class, as well as to the normal functions. The variable can be accessed
    anywhere in the file and possibly from other files (global) if the linkage is
    correct. These variables are allocated memory by the linker in the data segment.
    The identifiers are placed into the global namespace, which is the default namespace.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局/文件作用域**：这适用于在普通函数或类之外声明的变量，以及普通函数。可以在文件中的任何地方访问变量，并且如果链接正确，可能还可以从其他文件（全局）访问。这些变量由链接器在数据段中分配内存。标识符被放入全局命名空间，这是默认命名空间。'
- en: Namespaces
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'We can think of a namespace as a dictionary of names of variables, functions,
    and user-defined types. For small programs, it is ok to use the global namespace
    as there is very little chance of you creating multiple variables with the same
    name and getting name clashes. As programs get larger, and more third-party libraries
    are included, the chance of name clashes increases. Therefore, library writers
    will put their code into a namespace (that is hopefully unique). This allows the
    programmer to control access to the identifiers in the namespace. By using the
    standard library, we have already been using the std namespace. A namespace is
    declared like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将命名空间看作是变量、函数和用户定义类型的名称字典。对于小型程序，使用全局命名空间是可以的，因为很少有可能创建多个具有相同名称并发生名称冲突的变量。随着程序变得更大，并且包含了更多的第三方库，名称冲突的机会增加。因此，库编写者将他们的代码放入一个命名空间（希望是唯一的）。这允许程序员控制对命名空间中标识符的访问。通过使用标准库，我们已经在使用std命名空间。命名空间的声明如下：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is usual for name_of_namespace to be short, and namespaces can be nested.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，name_of_namespace很短，命名空间可以嵌套。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'A good use of namespaces can be seen in the boost libraries here: [https://www.boost.org/](https://www.boost.org/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在boost库中可以看到命名空间的良好使用：[https://www.boost.org/](https://www.boost.org/)。
- en: 'A variable has another attribute, that of **lifetime**. There are three fundamental
    lifetimes; two that are managed by the compiler and one that the programmer chooses:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 变量还有另一个属性，即**寿命**。有三种基本寿命；两种由编译器管理，一种由程序员选择：
- en: '**Automatic lifetime**: Local variables are created when they are declared
    and are destroyed upon exiting the scope that they are in. These are managed by
    the stack.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动寿命**：局部变量在声明时创建，并在退出其所在的作用域时被销毁。这些由堆栈管理。'
- en: '**Permanent lifetime**: Global variables and static local variables. The compiler
    causes global variables to be created when the program begins (before entering
    the main() function) and causes static local variables to be created when they
    are first accessed. In both cases, the variable is destroyed when the program
    exits. These variables are placed in the data segments by the linker.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久寿命**：全局变量和静态局部变量。编译器在程序开始时（进入main()函数之前）创建全局变量，并在首次访问静态局部变量时创建它们。在这两种情况下，变量在程序退出时被销毁。这些变量由链接器放置在数据段中。'
- en: '`new` and `delete`). These variables have their memory allocated from the heap.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new`和`delete`）。这些变量的内存是从堆中分配的。'
- en: 'The final attribute of a variable we will consider is **linkage**. Linkage
    indicates what the compiler and linker will do if they encounter variables and
    functions that have the same name (or identifier). For a function, its actually
    what is known as the mangled name – the compiler uses the name of the function,
    its return type, and its argument types to produce a mangled name. There are three
    types of linkage:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的变量的最终属性是**链接**。链接指示编译器和链接器在遇到具有相同名称（或标识符）的变量和函数时会执行什么操作。对于函数，实际上是所谓的重载名称
    - 编译器使用函数的名称、返回类型和参数类型来生成重载名称。有三种类型的链接：
- en: '**No linkage**: This means that the identifier only refers to itself and applies
    to local variables and locally defined user types (that is, inside a block).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无链接**：这意味着标识符只引用自身，并适用于局部变量和本地定义的用户类型（即在块内部）。'
- en: '**Internal linkage**: This means that the identifier can be accessed anywhere
    in the file in which it is declared. This applies to static global variables,
    const global variables, static functions, and any variables or functions declared
    in an anonymous namespace within the file. An anonymous namespace is a namespace
    with no stated name.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部链接**：这意味着可以在声明它的文件中的任何地方访问该标识符。这适用于静态全局变量、const全局变量、静态函数以及文件中匿名命名空间中声明的任何变量或函数。匿名命名空间是一个没有指定名称的命名空间。'
- en: '**External linkage**: This means that, with the right forward declarations,
    it can be accessed from within all files. This includes normal functions, non-static
    global variables, extern const global variables, and user-defined types.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部链接**：这意味着在正确的前向声明的情况下，可以从所有文件中访问它。这包括普通函数、非静态全局变量、extern const全局变量和用户定义类型。'
- en: While these are termed linkages, only the last one actually involves the linker.
    The other two are achieved by the compiler excluding information from the DB of
    exported identifiers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些被称为链接，但只有最后一个实际上涉及链接器。其他两个是通过编译器排除导出标识符数据库中的信息来实现的。
- en: Templates – Generic Programming
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板-泛型编程
- en: 'As a computer scientist, or as a programming enthusiast, at some point in time,
    you probably had to write one (or more) sort algorithms. When discussing the algorithm,
    you were not particularly concerned about the type of data being sorted, just
    that the two objects of that type could be compared and that the domain is a totally
    ordered set (that is, if one object is compared with any other, you can determine
    which comes first). Different programming languages provide different solutions
    to this problem:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算机科学家或编程爱好者，您可能在某个时候不得不编写一个（或多个）排序算法。在讨论算法时，您可能并不特别关心正在排序的数据类型，只是该类型的两个对象可以进行比较，并且该域是一个完全有序的集合（也就是说，如果一个对象与任何其他对象进行比较，您可以确定哪个排在前面）。不同的编程语言为这个问题提供了不同的解决方案：
- en: '`swap` function.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap`函数。'
- en: '`void pointer`. `size_t` size defines how big each object is, while the `compare()`
    function defines how to compare the two objects.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void指针`。`size_t`大小定义了每个对象的大小，而`compare()`函数定义了如何比较这两个对象。'
- en: '`std::sort()` is a function provided in its standard library, where one of
    its signatures is as follows:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`是标准库中提供的一个函数，其中一个签名如下：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, the details of the type are captured in the iterator type called
    `RandomIt` and passed to the method when compiled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类型的细节被捕获在名为`RandomIt`的迭代器类型中，并在编译时传递给方法。
- en: In the next section, we will briefly define generic programming, show how C++
    implements them through templates, highlight what the language already provides,
    and discuss how the compiler deducts the types so that they can be used for the
    template.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要定义泛型编程，展示C++如何通过模板实现它们，突出语言已经提供的内容，并讨论编译器如何推断类型，以便它们可以用于模板。
- en: What is Generic Programming?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是泛型编程？
- en: When you developed a sort algorithm, you may have originally focused on just
    sorting plain numbers. But once that is established, you could then abstract that
    to any type, provided that the type exhibits certain attributes such as total
    ordered set (that is, the comparison operator, <, has meaning between all the
    elements in the domain we are sorting over). So, to express an algorithm in terms
    of generic programming, we define a placeholder in the algorithm for the type
    that needs to be manipulated by that algorithm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开发排序算法时，您可能最初只关注对普通数字的排序。但一旦建立了这一点，您就可以将其抽象为任何类型，只要该类型具有某些属性，例如完全有序集（即比较运算符<在我们正在排序的域中的所有元素之间都有意义）。因此，为了以泛型编程的方式表达算法，我们在算法中为需要由该算法操作的类型定义了一个占位符。
- en: '**Generic programming** is the development of a type-agnostic general algorithm.
    The algorithm can be reused by passing types as arguments. In this way, algorithms
    are abstracted and allow the compiler to optimize based on types.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型编程**是开发一种类型不可知的通用算法。通过传递类型作为参数，可以重用该算法。这样，算法被抽象化，并允许编译器根据类型进行优化。'
- en: In other words, generic programming is an approach to programming where an algorithm
    is defined with types as parameters that are specified when the algorithm is instantiated.
    Many languages provide support for generic programming with different names. In
    C++, generic programming is supported through the language feature known as templates.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，泛型编程是一种编程方法，其中算法是以参数化的类型定义的，当实例化算法时指定了参数。许多语言提供了不同名称的泛型编程支持。在C++中，泛型编程是通过模板这种语言特性来支持的。
- en: Introducing C++ Templates
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍C++模板
- en: 'Templates are C++''s support for generic programming. Think of a template as
    a cookie cutter, and the type that we give it as a parameter as cookie dough (which
    can be chocolate brownie, ginger snap, or some other delicious flavor). When we
    apply the cookie cutter, we end up with instances of cookies that are in the same
    form but have different flavors. So, a template captures the definition of a generic
    function or class and when specified with types as arguments, the compiler goes
    to work to write the class or function for us as if the type was hand-coded by
    us. It has several advantages, such as the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++对泛型编程的支持。把模板想象成一个饼干模具，我们给它的类型参数就像饼干面团（可以是巧克力布朗尼、姜饼或其他美味口味）。当我们使用饼干模具时，我们得到的饼干实例形式相同，但口味不同。因此，模板捕获了泛型函数或类的定义，当指定类型参数时，编译器会根据我们手动编码的类型来为我们编写类或函数。它有几个优点，例如：
- en: You only need to develop the class or algorithm once and evolve it.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您只需要开发一次类或算法，然后进行演化。
- en: You can apply it to many types.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将其应用于许多类型。
- en: You can hide complex details behind a simple interface and the compiler can
    apply optimizations to the generated code, based on the type.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将复杂细节隐藏在简单的接口后，编译器可以根据类型对生成的代码进行优化。
- en: 'So, how do we write a template? Let''s start with a template that will allow
    us to clamp a value within a range from `lo` to `hi` and be able to use it on
    `int`, `float`, `double`, or any other built-in type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何编写一个模板呢？让我们从一个模板开始，它允许我们将值夹在从`lo`到`hi`的范围内，并且能够在`int`、`float`、`double`或任何其他内置类型上使用它：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s break this down:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: '`template <class T>` declares what follows to be a template and uses one type,
    which has a placeholder of `T` in the template.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template <class T>`声明接下来是一个模板，并使用一个类型，模板中有一个`T`的占位符。'
- en: '`T` is substituted. It declares that the function clamp takes three arguments
    of type `T` and returns a value of type `T`.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`被替换。它声明函数clamp接受三个类型为`T`的参数，并返回类型为`T`的值。'
- en: '`<` operator, then we can perform a clamp on the three values so that `lo <=
    val <= hi`. This algorithm is valid for all the types that can be ordered.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`运算符，然后我们可以对三个值执行clamp，使得`lo <= val <= hi`。这个算法对所有可以排序的类型都有效。'
- en: 'Let''s say we use it in the following program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在以下程序中使用它：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will get the following expected output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下预期输出：
- en: '![Figure 2B.12: Clamp program output'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.12：Clamp程序输出'
- en: '](img/C14583_02B_12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_12.jpg)'
- en: 'Figure 2B.12: Clamp program output'
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.12：Clamp程序输出
- en: In the last call to clamp, we have passed the template the double type between
    `<` and `>`. But we haven't followed the same for the other four calls. Why? It
    turns out that the compiler is getting smarter as it gets older. With every release
    of the standard, they improve what is known as **type deduction**. Because the
    compiler is able to deduce the type, we do not need to tell it what type to use.
    The reason for this is that the three arguments to the class without the template
    parameter have the same type – the first three are all int while the fourth one
    is double. But we had to tell the compiler which type to use for the final one
    because it has two doubles and an int as arguments, which resulted in a compilation
    error saying no function found. But then, it gave us information about why the
    template could not be used. This form, where you force the types, is known as
    **explicit template argument specification**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次调用clamp时，我们在`<`和`>`之间传递了double类型的模板。但是我们没有对其他四个调用遵循相同的方式。为什么？原来编译器随着年龄的增长变得越来越聪明。随着每个标准的发布，它们改进了所谓的**类型推导**。因为编译器能够推断类型，我们不需要告诉它使用什么类型。这是因为类的三个参数没有模板参数，它们具有相同的类型
    - 前三个都是int，而第四个是double。但是我们必须告诉编译器使用最后一个的类型，因为它有两个double和一个int作为参数，这导致编译错误说找不到函数。但是然后，它给了我们关于为什么不能使用模板的信息。这种形式，你强制类型，被称为**显式模板参数规定**。
- en: C++ Pre-Packaged Templates
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++预打包模板
- en: 'The C++ Standard is comprised of two major parts:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准由两个主要部分组成：
- en: The language definition, that is, the keywords, syntax, lexical definitions,
    structures, and so on.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言定义，即关键字、语法、词法定义、结构等。
- en: The Standard Library, that is, all the pre-written general-purpose functions
    and classes to be provided by the compiler vendor. A subset of this library is
    implemented using templates and is known as the **Standard Template Library**
    (**STL**).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库，即编译器供应商提供的所有预先编写的通用函数和类。这个库的一个子集是使用模板实现的，被称为**标准模板库**（**STL**）。
- en: The STL has origins in the generics provided in the Ada language that was developed
    by David Musser and Alexander Stepanov. Stepanov was a strong advocate for the
    use of generic programming as the basis for software development. In the 90s,
    he saw the opportunity to do this with the new language C++ to influence mainstream
    development, and proposed to the ISO C++ committee that the STL should be included
    as part of the language. The rest is history.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: STL起源于Ada语言中提供的泛型，该语言由David Musser和Alexander Stepanov开发。Stepanov是泛型编程作为软件开发基础的坚定支持者。在90年代，他看到了用新语言C++来影响主流开发的机会，并建议ISO
    C++委员会应该将STL作为语言的一部分包含进去。其余的就是历史了。
- en: 'The STL is comprised of four categories of predefined generic algorithms and
    classes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: STL由四类预定义的通用算法和类组成：
- en: '**Containers**: General sequence (vector, list, deque) and associative containers
    (set, multiset, map)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：通用序列（vector，list，deque）和关联容器（set，multiset，map）'
- en: '`begin()` and `end()`). Note that one fundamental design choice in the STL
    is that `end()` points to a position one after the last item – mathematically,
    that is [`begin()`, `end()`).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin()`和`end()`）。请注意，STL中的一个基本设计选择是`end()`指向最后一项之后的位置 - 在数学上，即[`begin()`，`end()`)。'
- en: '**Algorithms**: Over 100 different algorithms covering sorting, searching,
    set operations, and others.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：涵盖排序、搜索、集合操作等100多种不同算法。'
- en: '`find_if()`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_if()`.'
- en: 'The clamp function template that we implemented previously is simplistic and
    while it would work for any type that supports the less than operator, it would
    not be very efficient – it could result in very large copies if the type has a
    large size. Since C++17, the STL includes a `std::clamp()` function that is declared
    more like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前实现的clamp函数模板是简单的，虽然它适用于支持小于运算符的任何类型，但它可能不太高效 - 如果类型具有较大的大小，可能会导致非常大的副本。自C++17以来，STL包括一个`std::clamp()`函数，声明更像这样：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, it uses references for the arguments and the return value. Changing
    the arguments to use references reduces what has to be passed on and returned
    on the stack. Also, note that the designers have worked to produce a more general
    version of the template so that we are not reliant on the < operator that exists
    for the type. However, we can define the ordering by passing comp.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它使用引用作为参数和返回值。将参数更改为使用引用减少了需要传递和返回的堆栈上的内容。还要注意，设计者们努力制作了模板的更通用版本，这样我们就不会依赖于类型存在的<运算符。然而，我们可以通过传递comp来定义排序。
- en: From the preceding examples, we have seen that, like functions, templates can
    take multiple comma-separated parameters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们已经看到，像函数一样，模板可以接受多个逗号分隔的参数。
- en: Type Aliases – typedef and using
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名 - typedef和using
- en: If you have used the `std::string` class, then you have been using an alias.
    There are a few template classes related to strings that need to implement the
    same functionality. But the type representing a character is different. For example,
    for `std::string`, the representation is `char`, while `std::wstring` uses `wchar_t`.
    There are several others for `char16_t` and `char32_t`. Any variation in the functionality
    will be managed through traits or template specialization.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了`std::string`类，那么您一直在使用别名。有一些与字符串相关的模板类需要实现相同的功能。但是表示字符的类型是不同的。例如，对于`std::string`，表示是`char`，而`std::wstring`使用`wchar_t`。还有一些其他的用于`char16_t`和`char32_t`。任何功能上的变化都将通过特性或模板特化来管理。
- en: 'Prior to C++11, this would have been aliased from the `std::basic_string` base
    class, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，这将从`std::basic_string`基类中进行别名处理，如下所示：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This does two main things:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了两件主要的事情：
- en: 'Reduces the amount of typing required to declare the variable. This is a simple
    case, but when you declare a unique pointer to a map of strings to object, it
    can get very long and you will make errors:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少声明变量所需的输入量。这是一个简单的情况，但是当你声明一个指向字符串到对象的映射的唯一指针时，可能会变得非常长，你会犯错误：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Improves the readability as you now conceptually think of it as a string and
    do not need to worry about the details.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高了可读性，因为现在你在概念上将其视为一个字符串，不需要担心细节。
- en: 'But C++11 introduced a better way – `alias declarations` – which utilizes the
    `using` keyword. The preceding code can be implemented like so:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是C++11引入了一种更好的方式 - `别名声明` - 它利用了`using`关键字。前面的代码可以这样实现：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding example is simple and the alias, either typedef or using, is
    not too hard to grok. But when the alias involves more complicated expressions,
    they too can be a little unreadable – particularly function pointers. Consider
    the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很简单，别名，无论是typedef还是using，都不太难理解。但是当别名涉及更复杂的表达式时，它们也可能有点难以理解 - 特别是函数指针。考虑以下代码：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, consider the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is a reason for the new feature in C++11 where alias declaration may be
    incorporated easily into templates – they can be templatized. A `typedef` cannot
    be templatized and while it is possible to achieve the same outcome with `typedef`,
    the alias declaration (`using`) is the preferred method as it results in simpler
    and easier to understand template code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: C++11中有一个新功能，即别名声明可以轻松地并入模板中 - 它们可以被模板化。`typedef`不能被模板化，虽然可以通过`typedef`实现相同的结果，但别名声明（`using`）是首选方法，因为它会导致更简单、更易于理解的模板代码。
- en: 'Exercise 2: Implementing Aliases'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：实现别名
- en: 'In this exercise, we will implement aliases using a typedef and see how the
    code becomes easier to read and efficient by using a reference. Follow these steps
    to implement this exercise:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用typedef实现别名，并看看通过使用引用使代码变得更容易阅读和高效。按照以下步骤实现这个练习：
- en: Open the **Lesson2B** project in Eclipse, and then in the Project Explorer,
    expand **Lesson2B**, then **Exercise02** and double-click on **Exercise2.cpp**
    to open the file for this exercise in the editor.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2B**项目，然后在项目资源管理器中展开**Lesson2B**，然后展开**Exercise02**，双击**Exercise2.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise2** to run with the name **Exercise2**.
    When that is complete, it will be the currently selected Launch Configuration.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，然后选择**新启动配置...**。配置**L2BExercise2**以使用名称**Exercise2**运行。完成后，它将成为当前选择的启动配置。
- en: 'Click on the **Run** button. **Exercise 2** will run and produce something
    similar to the following output:![Figure 2B.13: Exercise 2 output'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。**Exercise 2**将运行并产生类似以下输出：![图2B.13：练习2输出
- en: '](img/C14583_02B_13.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_13.jpg)'
- en: 'Figure 2B.13: Exercise 2 output'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.13：练习2输出
- en: 'In the editor, before the declaration of the `printVector()` function, add
    the following line:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在`printVector()`函数的声明之前，添加以下行：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, change all occurrences of `std::vector<int>` in the file with `IntVector`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将文件中所有的`std::vector<int>`更改为`IntVector`。
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: 'In the editor, change the line that you previously added to the following:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改之前添加的行为以下内容：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: 'In the editor, add the following line:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，添加以下行：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, change the one occurrence of `IntVector::iterator` to `IntVectorIter.`
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`IntVector::iterator`的一个出现更改为`IntVectorIter`。
- en: Click on the **Run** button. The output should be the same as before.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出应与以前相同。
- en: In this exercise, there appears to be little difference between typedef and
    using alias. In either case, the use of a well-named alias makes code easier to
    read and understand. When more complicated aliases are involved, `using` produces
    an easier way to write an alias. Introduced in C++11, `using` is now the preferred
    method for defining an alias. It has other advantages over `typedef`, such as
    being able to use it inside templates.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，typedef和使用别名似乎没有太大区别。在任何一种情况下，使用一个命名良好的别名使得代码更容易阅读和理解。当涉及更复杂的别名时，`using`提供了一种更容易编写别名的方法。在C++11中引入，`using`现在是定义别名的首选方法。它还比`typedef`有其他优点，例如能够在模板内部使用它。
- en: Templates – More than Generic Programming
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板 - 不仅仅是泛型编程
- en: Templates can also deliver much more than just generic programming (a cookie
    cutter with types). In the case of generic programming, the template operates
    as a blueprint that cannot be changed and delivers the compiled version of the
    template for the specified type or types.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 模板还可以提供比泛型编程更多的功能（一种带有类型的模板）。在泛型编程的情况下，模板作为一个不能更改的蓝图运行，并为指定的类型或类型提供模板的编译版本。
- en: Templates can be written to provide specialization of a function or algorithm
    based on the types involved. This is known as **template specialization** and
    is not generic programming in the sense we previously used it. It can only be
    called generic programming when it makes certain types behave as we would expect
    them to do in a given context. It cannot be called generic programming when the
    algorithm that's used for all types is modified.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以被编写以根据涉及的类型提供函数或算法的特化。这被称为**模板特化**，并不是我们先前使用的意义上的通用编程。只有当它使某些类型在给定上下文中表现得像我们期望它们在某个上下文中表现得一样时，它才能被称为通用编程。当用于所有类型的算法被修改时，它不能被称为通用编程。
- en: 'Examine the following sample of specialization code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下专业化代码的示例：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It defines a template that calls `printf()` with a different format string,
    based on the specialization of the template using `std::enable_if_t<>` and `sizeof()`.
    When we run it, the following output is generated:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了一个模板，根据使用`std::enable_if_t<>`和`sizeof()`的模板的特化，调用`printf()`并使用不同的格式字符串。当我们运行它时，会生成以下输出：
- en: '![Figure 2B.14: Erroneous print template program output'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.14：错误的打印模板程序输出'
- en: '](img/C14583_02B_14.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_14.jpg)'
- en: 'Figure 2B.14: Erroneous print template program output'
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.14：错误的打印模板程序输出
- en: Substitution Failure Is Not An Error – SFINAE
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换失败不是错误 - SFINAE
- en: 'The value printed for `32.1F` (`-1073741824`) does not bear any resemblance
    to the number. If we examine the code that was generated by the compiler for the
    following program, we will find that it has generated the code as if we wrote
    the following (and more):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`32.1F`打印的值（`-1073741824`）与数字毫不相干。如果我们检查编译器为以下程序生成的代码，我们会发现它生成的代码就好像我们写了以下内容（以及更多）：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Why does it generate this code? The preceding templates use a feature of the
    C++ compiler called `std::enable_if_t<>` and access what are known as **type traits**
    to help us. Firstly, we will replace the last template with the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会生成这段代码？前面的模板使用了C++编译器的一个特性，叫做`std::enable_if_t<>`，并访问了所谓的**类型特征**来帮助我们。首先，我们将用以下代码替换最后一个模板：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This takes some explaining. Firstly, we consider the definition of `std::enable_if_t`,
    which is actually a type alias:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些解释。首先，我们考虑`std::enable_if_t`的定义，实际上是一个类型别名：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The first template for `enable_if` will result in the definition of an empty
    struct (or class). The second template for `enable_if` is a specialization for
    true as a first template argument that will result in the class with a typedef
    definition. The definition of `enable_if_t` is a helper template that removes
    the need for us to enter `::type` on the end of the template when we use it. So,
    how does this work? Consider the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_if`的第一个模板将导致定义一个空的结构体（或类）。`enable_if`的第二个模板是对true的第一个模板参数的特化，将导致具有typedef定义的类。`enable_if_t`的定义是一个帮助模板，它消除了我们在使用它时需要在模板末尾输入`::type`的需要。那么，这是如何工作的呢？考虑以下代码：'
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the condition that is evaluated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在编译时评估的条件导致`enable_if_t`模板将导致一个看起来像这样的模板：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is valid syntax and the function is added to the symbol table as a candidate
    function. If the condition that is calculated at compile time results in `enable_if_t`
    template will result in a template that looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有效的语法，函数被添加到符号表作为候选函数。如果在编译时计算的条件导致`enable_if_t`模板将导致一个看起来像这样的模板：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is **malformed code** which is now discarded – SFINAE at work.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**格式错误的代码**，现在被丢弃了 - SFINAE在起作用。
- en: '`std::is_floating_point_v<T>` is another helper class that accesses the `::value`
    member of the `std::is_floating_point<T>` template. Its name says it all – it
    will be true if T is a floating-point type (float, double, long double); otherwise,
    it will be false. If we make this change, then the compiler (GCC) generates the
    following error:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::is_floating_point_v<T>`是另一个访问`std::is_floating_point<T>`模板的`::value`成员的帮助类。它的名字说明了一切
    - 如果T是浮点类型（float、double、long double），它将为true；否则，它将为false。如果我们进行这个改变，那么编译器（GCC）会生成以下错误：'
- en: '![Figure 2B.15: Compiler error for the modified print template program'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.15：修改后的打印模板程序的编译器错误'
- en: '](img/C14583_02B_15.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_15.jpg)'
- en: 'Figure 2B.15: Compiler error for the modified print template program'
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.15：修改后的打印模板程序的编译器错误
- en: 'The problem now is that we have two templates that can satisfy when the type
    is a float:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，当类型是浮点数时，我们有两个可以满足的模板：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It turns out that (usually) `sizeof(float) == sizeof(int)`, so we need to make
    another change. We'll replace the first condition with another type trait – `std::is_integral_v<>:`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，通常情况下`sizeof(float) == sizeof(int)`，所以我们需要做另一个改变。我们将用另一个类型特征`std::is_integral_v<>`替换第一个条件：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we make this change, then the compiler (GCC) generates the following error:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进行这个改变，那么编译器（GCC）会生成以下错误：
- en: '![Figure 2B.16: Second compiler error for the modified print template program'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.16：修改后的打印模板程序的第二个编译器错误'
- en: '](img/C14583_02B_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_16.jpg)'
- en: 'Figure 2B.16: Second compiler error for the modified print template program'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.16：修改后的打印模板程序的第二个编译器错误
- en: 'We fixed the floating-point ambiguity, but the problem here is that `std::is_integral_v(char)`
    returns true and again there are two functions that are generated by the templates
    for a type of char with the same prototype. It turns out that the conditions that''s
    passed to `std::enable_if_t<>` obeys standard C++ logic expressions. So, to fix
    this problem, we will add an extra condition that will exclude chars:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决了浮点数的歧义，但这里的问题是`std::is_integral_v(char)`返回true，再次生成了具有相同原型的模板函数。原来传递给`std::enable_if_t<>`的条件遵循标准C++逻辑表达式。因此，为了解决这个问题，我们将添加一个额外的条件来排除字符：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we compile the program now, it completes the compilation and links the program.
    If we run it, it now produces the following (expected) output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译程序，它完成编译并链接程序。如果我们运行它，它现在会产生以下（预期的）输出：
- en: '![Figure 2B.17: Corrected print template program output'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.17：修正的打印模板程序输出'
- en: '](img/C14583_02B_17.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_17.jpg)'
- en: 'Figure 2B.17: Corrected print template program output'
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.17：修正的打印模板程序输出
- en: Floating-Point Representations
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点表示
- en: Shouldn't that `32.099998` be `32.1`? That is what was passed to the function.
    The problem with performing floating-point operations on a computer is that the
    representation automatically introduces an error. Real numbers form a continuous
    (infinite) domain. If you consider the numbers 1 and 2 in the real domain, then
    there is an infinite amount of real numbers between them. Unfortunately, a computer's
    representation of floating-point numbers quantizes the values and cannot represent
    all of the infinite number of numbers. The bigger the number of bits used to store
    the number, the better the representation of the value is on the real domain.
    So, long double is better than double is better than float. It really depends
    on your problem domain as to what is appropriate for storing the data. Back to
    `32.099998`. The computer stores the single precision numbers as the sum of powers
    of 2 and then shifts them by a power factor. Integral numbers are usually easy
    as they can be easily represented by the sum of `2^n` powers (n>=0). The fractional
    part, which in this case is 0.1, has to be expressed as the sum of `2^(-n) (n>0)`.
    We add more power-2 fractions to attempt to get the number closer to the target
    until we have used up the 24 bits that we have for precision in a single precision
    floating-point number.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`32.099998`不应该是`32.1`吗？这是传递给函数的值。在计算机上执行浮点运算的问题在于，表示自动引入了误差。实数形成一个连续（无限）的域。如果你考虑实域中的数字1和2，那么它们之间有无限多个实数。不幸的是，计算机对浮点数的表示量化了这些值，并且无法表示所有无限数量的数字。用于存储数字的位数越多，值在实域上的表示就越好。因此，long
    double比double好，double比float好。对于存储数据来说，真正取决于您的问题域。回到`32.099998`。计算机将单精度数存储为2的幂的和，然后将它们移位一个幂因子。整数通常很容易，因为它们可以很容易地表示为`2^n`的和（n>=0）。在这种情况下的小数部分，即0.1，必须表示为`2^(-n)
    (n>0)`的和。我们添加更多的2的幂分数，以尝试使数字更接近目标，直到我们用完了单精度浮点数中的24位精度。'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to know more about how computers store floating-point numbers, research
    the IEEE 754 standard that defines it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解计算机如何存储浮点数，请研究定义它的IEEE 754标准。
- en: Constexpr if Expressions
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Constexpr if表达式
- en: 'C++17 introduced the `constexpr if` expression to the language, which simplifies
    template writing greatly. We can rewrite the preceding three templates that use
    SFINAE as one simpler template:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C++17引入了`constexpr if`表达式到语言中，大大简化了模板编写。我们可以将使用SFINAE的前面三个模板重写为一个更简单的模板：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For the call to `print(55)`, the compiler generates the function to call as
    follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对`print(55)`的调用，编译器生成的函数调用如下：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What happened to the if/else if statements? What happens with a `constexpr if`
    expression is that the compiler contextually determines the value of the condition
    and converts it into a bool value (true/false). If the evaluated value is true,
    then the if condition and the else clause are discarded, leaving only the true
    clause to generate code. Likewise, if it is false, then the false clause is left
    to generate code. In other words, only the first constexpr if condition that evaluates
    to true will have the code for its clause generated, while the rest are discarded.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: if/else if语句发生了什么？`constexpr if`表达式的作用是，编译器在上下文中确定条件的值，并将其转换为布尔值（true/false）。如果评估的值为true，则if条件和else子句被丢弃，只留下true子句生成代码。同样，如果为false，则留下false子句生成代码。换句话说，只有第一个constexpr
    if条件评估为true时，才会生成其子句的代码，其余的都会被丢弃。
- en: Non-Type Template Arguments
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非类型模板参数
- en: 'So far, we have only seen template arguments that are types. It is also possible
    to pass an integral value as a template argument. This allows us to prevent array
    decay for a function. For example, consider a template function that calculates
    the `sum`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了作为模板参数的类型。还可以将整数值作为模板参数传递。这允许我们防止函数的数组衰减。例如，考虑一个计算`sum`的模板函数：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this case, we need to pass the length of the array in the call:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要在调用中传递数组的长度：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But wouldn't it be better if we could just call the following?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们只能调用以下内容会不会更好呢？
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can do it by making changes to the template, like in the following code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对模板进行更改来实现，就像下面的代码一样：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we changed the data to be a reference to an array of a certain size –
    a size that is passed to the template – and so the compiler figures it out. We
    no longer need the second argument to the function call. This simple example showed
    how to pass and use a non-type argument directly. We will explore this more in
    the *Template Type Deduction* section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数据更改为对模板传递的特定大小的数组的引用，因此编译器会自行解决。我们不再需要函数调用的第二个参数。这个简单的例子展示了如何直接传递和使用非类型参数。我们将在*模板类型推导*部分进一步探讨这个问题。
- en: 'Exercise 3: Implementing Stringify – specialization Versus constexpr'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：实现Stringify - 专用与constexpr
- en: 'In this exercise, we will implement a stringify template by utilizing constexpr
    to produce an easier to read and simpler version of the code. Follow these steps
    to implement this exercise:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用constexpr实现一个stringify模板，以生成一个更易读和更简单的代码版本。按照以下步骤实现这个练习：
- en: Note
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The stringify specialization templates can be found at [https://isocpp.org/wiki/faq/templates#template-specialization-example](https://isocpp.org/wiki/faq/templates#template-specialization-example).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://isocpp.org/wiki/faq/templates#template-specialization-example](https://isocpp.org/wiki/faq/templates#template-specialization-example)找到stringify专用模板。
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise03**, and double-click on **Exercise3.cpp**
    to open the file for this exercise in the editor.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2B**项目，然后在**项目资源管理器**中展开**Lesson2B**，然后展开**Exercise03**，双击**Exercise3.cpp**以在编辑器中打开此练习的文件。
- en: Click on the **Launch Configuration** dropdown menu and select **New Launch
    Configuration…**. Configure **L2BExercise3** to run with the name **Exercise3**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**启动配置**下拉菜单，选择**新启动配置...**。配置**L2BExercise3**以使用名称**Exercise3**运行。
- en: 'Click on the **Run** button. **Exercise 3** will run and produce the following
    output:![Figure 2B.18: Exercise 3 specialized template output'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。**练习3**将运行并产生以下输出：![图2B.18：练习3特化模板输出
- en: '](img/C14583_02B_18.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_18.jpg)'
- en: 'Figure 2B.18: Exercise 3 specialized template output'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.18：练习3特化模板输出
- en: In **Exercise3.cpp**, comment out all of the template specializations for the
    stringify template while leaving the original general template.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Exercise3.cpp**中，将stringify模板的所有特化模板注释掉，同时保留原始的通用模板。
- en: 'Click on the **Run** button. The output will change to have the boolean printed
    as a number and the double printed to only two decimal places:![Figure 2B.19:
    Exercise 3 general template only output'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出将更改为将布尔型打印为数字，将双精度浮点数打印为仅有两位小数：![图2B.19：练习3仅通用模板输出
- en: '](img/C14583_02B_19.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_19.jpg)'
- en: 'Figure 2B.19: Exercise 3 general template only output'
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.19：练习3仅通用模板输出
- en: 'We will now "specialize" the template for the boolean type again. Add the `#include
    <type_traits>` directive with the other `#includes` and modify the template so
    that it reads as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将再次为布尔类型“特化”模板。在其他`#includes`中添加`#include <type_traits>`指令，并修改模板，使其如下所示：
- en: '[PRE48]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Click on the **Run** button. The output boolean stringify works as before:![Figure
    2B.20: stringify tailored for boolean'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。布尔型的stringify输出与以前一样：![图2B.20：针对布尔型定制的stringify
- en: '](img/C14583_02B_20.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_20.jpg)'
- en: 'Figure 2B.20: stringify tailored for boolean'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.20：针对布尔型定制的stringify
- en: 'We will now "specialize" the template for the floating-point types (`float`,
    `double`, `long double`) again. Modify the template so that it reads as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将再次为浮点类型（`float`、`double`、`long double`）“特化”模板。修改模板，使其如下所示：
- en: '[PRE49]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Click on the **Run** button. The output is restored to the original:![Figure
    2B.21: constexpr if version template output'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮。输出恢复为原始状态：![图2B.21：constexpr if版本模板输出
- en: '](img/C14583_02B_21.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_21.jpg)'
- en: 'Figure 2B.21: constexpr if version template output'
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.21：constexpr if版本模板输出
- en: If you compare the original version with multiple templates to the final version,
    you will find that the final version is more like a normal function and is easier
    to read and maintain.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将多个模板的原始版本与最终版本进行比较，您会发现最终版本更像是一个普通函数，更易于阅读和维护。
- en: In the exercise, we learned how much simpler and compact our templates can be
    when using the new constexpr if construct in C++17.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了在C++17中使用新的constexpr if结构时，模板可以变得更简单和紧凑。
- en: Function Overloading Revisited
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数重载再探讨
- en: 'When we first discussed function overloading, we only considered the scenarios
    where the name of the function came from the list of functions that we wrote by
    hand. Now, we need to update this. We can also write templated functions that
    can have the same name. Like we did previously, when the compiler meets the line
    `print(55)`, it needs to work out which of the previously defined functions to
    call. So, it performs the following process (grossly simplified):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次讨论函数重载时，我们只考虑了函数名称来自我们手动编写的函数列表的情况。现在，我们需要更新这一点。我们还可以编写可以具有相同名称的模板函数。就像以前一样，当编译器遇到`print(55)`这一行时，它需要确定调用先前定义的函数中的哪一个。因此，它执行以下过程（大大简化）：
- en: '![Figure 2B.22: Function overload resolution with templates (simplified)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.22：模板的函数重载解析（简化版）'
- en: '](img/C14583_02B_22.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_22.jpg)'
- en: 'Figure 2B.22: Function overload resolution with templates (simplified)'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.22：模板的函数重载解析（简化版）
- en: Template Type Deduction
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板类型推断
- en: 'When we first introduced templates, we touched on Template type deduction.
    Now, we are going to explore this further. We will start by considering the general
    declaration for a function template:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次介绍模板时，我们涉及了模板类型推断。现在，我们将进一步探讨这一点。我们将从考虑函数模板的一般声明开始：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The call for this might look like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用可能如下所示：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When the compiler reaches this line, it must now deduce two types related to
    the template – `T` and `ParamType`. These are often different due to qualifiers
    and other attributes attached to the T in the ParamType (for example pointer,
    reference, const, and so on). The types are related but the deduction progresses
    differently, depending on the form of `expression` used.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器到达这一行时，它现在必须推断与模板相关的两种类型—`T`和`ParamType`。由于T在ParamType中附加了限定符和其他属性（例如指针、引用、const等），它们通常是不同的。这些类型是相关的，但推断的过程取决于所使用的`expression`的形式。
- en: Displaying the Deduced Types
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示推断类型
- en: Before we look into the different forms, it might be useful if we could get
    the compiler to tell us the types that it has deduced. We have a few options here,
    including the IDE editors showing types, the compiler generating errors, and runtime
    support (which, due to the C++ standard, is not necessarily effective). We will
    use the compiler errors to help us explore some of the type deductions.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究不同形式之前，如果我们能让编译器告诉我们它推断出的类型，那将非常有用。我们有几种选择，包括IDE编辑器显示类型、编译器生成错误和运行时支持（由于C++标准的原因，这不一定有效）。我们将使用编译器错误来帮助我们探索一些类型推断。
- en: 'We can achieve a type displayer by declaring a template without a definition.
    Any attempt to instantiate the template will cause the compiler to generate an
    error message as there is no definition, along with the type information that
    it is trying to instantiate:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过声明一个没有定义的模板来实现类型显示器。任何尝试实例化模板都将导致编译器生成错误消息，因为没有定义，以及它正在尝试实例化的类型信息：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s attempt to compile the following program:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译以下程序：
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The compiler spits out the following errors:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器输出以下错误：
- en: '![Figure 2B.23: Compiler errors showing deduced types'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.23：显示推断类型的编译器错误'
- en: '](img/C14583_02B_23.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_23.jpg)'
- en: 'Figure 2B.23: Compiler errors showing deduced types'
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.23：显示推断类型的编译器错误
- en: Note that, in each case, the aggregate being named includes the type being deduced
    – for x, it is an int, for y, an unsigned int, and for x+y, an unsigned int. Also,
    note that the TypeDisplay template requires a type for its arguments and so the
    `decltype()` function is used to get the compiler to provide the type for the
    expression in brackets.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每种情况下，被命名的聚合包括被推断的类型 - 对于x，它是一个int，对于y，是一个unsigned int，对于x+y，是一个unsigned
    int。还要注意，TypeDisplay模板需要其参数的类型，因此使用`decltype()`函数来获取编译器提供括号中表达式的类型。
- en: It is also possible to display the deduced type at runtime either using the
    built-in `typeid(T).name()` operator, which returns a std::string, or by using
    the boost library called type_index.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用内置的`typeid(T).name()`运算符在运行时显示推断的类型，它返回一个std::string，或者使用名为type_index的boost库。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on this, visit the following link: [https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html).'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问以下链接：[https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html](https://www.boost.org/doc/libs/1_70_0/doc/html/boost_typeindex.html)。
- en: Because of the type deduction rules, the built-in operator will give you an
    indication of the type, but it will lose reference (`&`, and `&&`) and any constness
    information (const or volatile). If required at runtime, then consider `boost::type_index`,
    which will produce the same output for all the compilers.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断规则，内置运算符将为您提供类型的指示，但会丢失引用（`&`和`&&`）和任何constness信息（const或volatile）。如果需要在运行时，考虑使用`boost::type_index`，它将为所有编译器产生相同的输出。
- en: Template Type Deduction – the Details
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板类型推断 - 详细信息
- en: 'Let''s return to the generic template:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到通用模板：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s say that the call looks like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 假设调用看起来像这样：
- en: '[PRE55]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Type deduction proceeds differently depending on the form of ParamType used:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断取决于ParamType的形式：
- en: '**ParamType is a value (T)**: Pass-by-value function call'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ParamType是值（T）**：按值传递函数调用'
- en: '**ParamType is a reference or pointer (T& or T*)**: Pass-by-reference function
    call'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ParamType是引用或指针（T&或T*）**：按引用传递函数调用'
- en: '**ParamType is a rvalue reference (T&&)**: Pass-by-reference function call
    or something else'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ParamType是右值引用（T&&）**：按引用传递函数调用或其他内容'
- en: '**Case 1: ParamType is pass-by-value (T)**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况1：ParamType是按值传递（T）**'
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As a pass-by-value call, this means that the parameter will be a copy of whatever
    is passed in. Because this is a new instance of the object, the following rules
    are applied to the expression:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 作为按值传递的调用，这意味着参数将是传入内容的副本。因为这是对象的新实例，所以以下规则适用于表达式：
- en: If the expression's type is a reference, then ignore the reference part.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式的类型是引用，则忽略引用部分。
- en: If, after step 1, the remaining type is const and/or volatile, then ignore those
    as well.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在步骤1之后，剩下的类型是const和/或volatile，则也忽略它们。
- en: 'What''s left is T. Let''s attempt to compile the following file code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的是T。让我们尝试编译以下文件代码：
- en: '[PRE57]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The compiler produces the following error:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器产生以下错误：
- en: '![Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.24：显示按类型推断类型的编译器错误'
- en: '](img/C14583_02B_24.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_24.jpg)'
- en: 'Figure 2B.24: Compiler error showing a deduced type for the pass by type'
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.24：显示按类型推断类型的编译器错误
- en: 'So, the type is deduced to be `int`. Likewise, we get exactly the same error
    if we declare the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类型被推断为`int`。同样，如果我们声明以下内容，我们将得到完全相同的错误：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The same will happen if we declare this version:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们声明这个版本，同样的情况会发生：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In all three cases, the deduced type is `int`, as per the rules stated previously.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有三种情况下，根据先前规定的规则，推断的类型都是`int`。
- en: '**Case 2: ParamType is pass-by-reference (T&)**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况2：ParamType是按引用传递（T&）**'
- en: 'As a pass-by-reference call, this means that the parameter will be able to
    access the original storage location of the object. Because of this, the generated
    function has to honor the constness and volatileness we ignored before. The following
    rules are applied to type deduction:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 作为按引用传递的调用，这意味着参数将能够访问对象的原始存储位置。因此，生成的函数必须遵守我们之前忽略的constness和volatileness。类型推断适用以下规则：
- en: If the expression's type is a reference, then ignore the reference part.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式的类型是引用，则忽略引用部分。
- en: Pattern match what's left of the type of expression with ParamType to determine
    T.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配表达式类型的剩余部分与ParamType以确定T。
- en: 'Let''s attempt to compile the following file:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试编译以下文件：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The compiler will generate the following error:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将生成以下错误：
- en: '![Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.25：显示按引用传递推断类型的编译器错误'
- en: '](img/C14583_02B_25.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_25.jpg)'
- en: 'Figure 2B.25: Compiler error showing the deduced type for pass by reference'
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.25：显示按引用传递推断类型的编译器错误
- en: 'From this, we can see that the compiler has T as an `int` from ParamType as
    `int&`. Changing x to be a const int provides no surprises as T is deduced to
    be `const int` from ParamType as `const int&`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以看到编译器将T作为`int`，从ParamType作为`int&`。将x更改为const int不会有任何意外，因为T被推断为`const
    int`，从ParamType作为`const int&`：
- en: '![Figure 2B.26:  Compiler error showing the deduced type for pass by const
    reference'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.26：显示按const引用传递推断类型的编译器错误'
- en: '](img/C14583_02B_26.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_26.jpg)'
- en: 'Figure 2B.26: Compiler error showing the deduced type for pass by const reference'
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.26：传递const引用时显示推断类型的编译器错误
- en: 'Likewise, introducing rx as a reference to a const int, as before, gives no
    surprises, as T is deduced to be `const int` from ParamType as `const int&`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，像之前一样引入rx作为对const int的引用，不会有令人惊讶的地方，因为T从ParamType作为`const int&`推断为`const
    int`：
- en: '[PRE61]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.27：传递const引用时显示推断类型的编译器错误'
- en: '](img/C14583_02B_27.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_27.jpg)'
- en: 'Figure 2B.27: Compiler error showing the deduced type when passing a const
    reference'
  id: totrans-376
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.27：传递const引用时显示推断类型的编译器错误
- en: 'If we change the declaration to include a const, then the compiler will honor
    the constness when it generates the function from the template:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变声明以包括一个const，那么编译器在从模板生成函数时将遵守constness：
- en: '[PRE62]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This time, the compiler reports the following
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，编译器报告如下
- en: '`int x`: T is int (as the constness will be honored), while the parameter''s
    type is `const int&`.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int x`：T是int（因为constness将被尊重），而参数的类型是`const int&`。'
- en: '`const int x`: T is int (const is in the pattern, leaving int), while the parameter''s
    type is `const int&`.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int x`：T是int（const在模式中，留下int），而参数的类型是`const int&`。'
- en: '`const int& rx`: T is int (reference is ignored, const is in the pattern, leaving
    int), while the parameter''s type is `const int&`.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int& rx`：T是int（引用被忽略，const在模式中，留下int），而参数的类型是`const int&`。'
- en: 'If we attempt to compile the following, what do we expect? Normally, an array
    decays to be a pointer:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译以下内容，我们期望会发生什么？通常，数组会衰减为指针：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The compiler error is as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误如下：
- en: '![Figure 2B.28:  Compiler error showing the deduced type for the array argument'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.28：传递数组参数时显示推断类型的编译器错误'
- en: when passed by reference
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 传递引用时
- en: '](img/C14583_02B_28.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_28.jpg)'
- en: 'Figure 2B.28: Compiler error showing the deduced type for the array argument
    when passed by reference'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.28：传递引用时显示数组参数的推断类型的编译器错误
- en: 'This time, the array is captured as a reference and the size is also included.
    So, if ary was declared as `ary[10]`, then a completely different function would
    result. Let''s revert the template to the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，数组被捕获为引用，并且大小也被包括在内。因此，如果ary声明为`ary[10]`，那么将得到一个完全不同的函数。让我们将模板恢复到以下内容：
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we attempt to compile the array call, then the error reports the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译数组调用，那么错误报告如下：
- en: '![Figure 2B.29: Compiler error showing the deduced type for the array argument'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.29：传递数组参数时显示推断类型的编译器错误'
- en: when passed by value
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 传递值时
- en: '](img/C14583_02B_29.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_29.jpg)'
- en: 'Figure 2B.29: Compiler error showing the deduced type for the array argument
    when passed by value'
  id: totrans-396
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.29：传递值时显示数组参数的推断类型的编译器错误
- en: We can see that, in this case, the array has decayed as the usual behavior when
    passing an array to a function. We saw this behavior when talking about *Non-Type
    Template Arguments*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在这种情况下，数组已经衰减为传递数组给函数时的通常行为。当我们谈论*非类型模板参数*时，我们看到了这种行为。
- en: '**Case 3: ParamType is a rvalue reference (T&&)**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况3：ParamType是右值引用（T&&）**'
- en: 'T&& is called a rvalue reference while T& is called a lvalue reference. C++
    not only characterizes an expression by type but also by a property called the
    **value category**. These categories control expression evaluation in the compiler,
    including the rules for creating, copying, and moving temporary objects. There
    are five expression value categories defined in the C++17 standard that have the
    following relationships:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: T&&被称为右值引用，而T&被称为左值引用。C++不仅通过类型来表征表达式，还通过一种称为**值类别**的属性来表征。这些类别控制编译器中表达式的评估，包括创建、复制和移动临时对象的规则。C++17标准中定义了五种表达式值类别，它们具有以下关系：
- en: '![Figure 2B.30: C++ value categories'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.30：C++值类别'
- en: '](img/C14583_02B_30.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_30.jpg)'
- en: 'Figure 2B.30: C++ value categories'
  id: totrans-402
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.30：C++值类别
- en: 'The definitions of each are as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 每个的定义如下：
- en: An expression that determines the identity of an object is a `glvalue`.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定对象身份的表达式是“glvalue”。
- en: An expression whose evaluation initializes an object or the operand of an operator
    is a `prvalue`. Examples include a literal (except string literal) such as 3.1415,
    true or nullptr, the this pointer, post increment, and post decrement expressions.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估初始化对象或操作数的表达式是“prvalue”。例如，文字（除了字符串文字）如3.1415，true或nullptr，this指针，后增量和后减量表达式。
- en: A glvalue object that has resources and can be reused (because its life is ending)
    is an `xvalue`. Examples include a function call whose return type is an rvalue
    reference to an object, such as `std::move()`.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有资源并且可以被重用（因为它的生命周期即将结束）的glvalue对象是“xvalue”。例如，返回类型为对象的右值引用的函数调用，如`std::move()`。
- en: A glvalue that is not an xvalue is an `lvalue`. Examples include the name of
    a variable, a function or a data member, or a string literal.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是xvalue的glvalue是“lvalue”。例如，变量的名称，函数或数据成员的名称，或字符串文字。
- en: A prvalue or xvalue is an `rvalue`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: prvalue或xvalue是一个“rvalue”。
- en: 'It does not matter if you do not fully understand these for the explanation
    that follows – just know that an expression that is considered to be an lvalue
    can have its address taken (using the address of operator, that is, "&"). The
    type deduction rules for the following require that you know what an lvalue is,
    as well as what it isn''t:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 不要紧，如果你不完全理解这些，因为接下来的解释需要你知道什么是左值，以及什么不是左值：
- en: '[PRE65]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The type deduction rules for this ParamType form are as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这种ParamType形式的类型推断规则如下：
- en: If the expression is an lvalue reference, then both T and ParamType are deduced
    to be an lvalue reference. This is the only scenario where the type is deduced
    to be a reference.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式是左值引用，那么T和ParamType都被推断为左值引用。这是唯一一种类型被推断为引用的情况。
- en: If the expression is an rvalue reference, then the rules for Case 2 apply.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式是一个右值引用，那么适用于情况2的规则。
- en: SFINAE Expression and Trailing Return Types
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SFINAE表达式和尾返回类型
- en: 'C++11 introduced a feature called `trailing return types` to provide a mechanism
    for templates so that they can generalize the return type. A simple example is
    as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一个名为`尾返回类型`的功能，为模板提供了一种通用返回类型的机制。一个简单的例子如下：
- en: '[PRE66]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, `auto` is used to indicate that a trailing return type is defined. The
    trailing return type starts with the `->` pointer and in this case, the return
    type is the type that's returned by multiplying `a` and `b`. The compiler will
    process the content of the decltype and, if it is malformed, it will remove the
    definition from the function name's lookup, as per usual. This capability opens
    up many possibilities as the comma operator, "`,`", can be used inside `decltype`
    to check for certain attributes.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`auto`用于指示定义尾返回类型。尾返回类型以`->`指针开始，在这种情况下，返回类型是通过将`a`和`b`相乘返回的类型。编译器将处理decltype的内容，如果它格式不正确，它将从函数名的查找中删除定义，与往常一样。这种能力打开了许多可能性，因为逗号运算符“`,`”可以在`decltype`内部使用来检查某些属性。
- en: 'If we want to test that a class implements a method or contains a type then
    we can place this inside the decltype by converting it into a void (in case the
    comma operator has been overloaded) and then define an object of the real return
    type at the end of the comma operator. An example of this is shown in the following
    program:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想测试一个类是否实现了一个方法或包含一个类型，那么我们可以将其放在decltype内部，将其转换为void（以防逗号运算符已被重载），然后在逗号运算符的末尾定义一个真实返回类型的对象。下面的程序示例中展示了这种方法：
- en: '[PRE67]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When this program is compiled and executed, we obtain the following output:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译并执行此程序时，我们将获得以下输出：
- en: '![Figure 2B.31: Output from the SFINAE expression'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.31：SFINAE表达式的输出'
- en: '](img/C14583_02B_31.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_31.jpg)'
- en: 'Figure 2B.31: Output from the SFINAE expression'
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.31：SFINAE表达式的输出
- en: 'The return type is given by the following code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型由以下代码给出：
- en: '[PRE68]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s break this down:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：
- en: The operand of `decltype` is a comma-separated list of expressions. This means
    that the compiler will construct but not evaluate the expressions and use the
    type of the right-most value to determine the return type for the function.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decltype`的操作数是一个逗号分隔的表达式列表。这意味着编译器将构造但不评估表达式，并使用最右边的值的类型来确定函数的返回类型。'
- en: '`std::declval<T>()` allows us to convert the T type into a reference type that
    we can then use to access member functions without having to actually construct
    an object.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::declval<T>()`允许我们将T类型转换为引用类型，然后可以使用它来访问成员函数，而无需实际构造对象。'
- en: As with all SFINAE-based operations, if any expression in the comma-separated
    list is invalid, then the function is discarded. If they are all valid, then it
    is added to the list of functions for lookup.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与所有基于SFINAE的操作一样，如果逗号分隔列表中的任何表达式无效，则函数将被丢弃。如果它们都有效，则将其添加到查找函数列表中。
- en: The cast to void is to prevent any problems that may arise if the user overloads
    the comma operator.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将void转换是为了防止用户重载逗号运算符可能引发的任何问题。
- en: Basically, this is testing whether the `C` class has a member function called
    `find()` that takes `class T`, `class T&`, or `const class T&` as an argument.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上，这是在测试`C`类是否有一个名为`find()`的成员函数，该函数以`class T`、`class T&`或`const class T&`作为参数。
- en: This method will work for `std::set`, which has a `find()` method that takes
    one argument but will fail for other containers because they do not have a `find()`
    member method.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于`std::set`，它具有一个接受一个参数的`find()`方法，但对于其他容器来说会失败，因为它们没有`find()`成员方法。
- en: 'This approach works well if we are only dealing with one type. But if we have
    a function that needs to produce different implementations based on type, as we
    have seen before, the `if constexpr` approach is much cleaner and generally easier
    to understand. To use the `if constexpr` approach, we need to produce templates
    that will evaluate to `true` or `false` at compile time. The standard library
    provides helper classes for this: `std::true_type` and `std::false_type`. These
    two structures have a static constant member named value set to `true` and `false`,
    respectively. Using SFINAE and template overloads, we can create new detection
    classes that derive from either of these classes to give us the desired outcome:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只处理一种类型，这种方法效果很好。但是，如果我们有一个需要根据类型生成不同实现的函数，就像我们以前看到的那样，`if constexpr`方法更清晰，通常更容易理解。要使用`if
    constexpr`方法，我们需要生成在编译时评估为`true`或`false`的模板。标准库提供了这方面的辅助类：`std::true_type`和`std::false_type`。这两个结构都有一个名为value的静态常量成员，分别设置为`true`和`false`。使用SFINAE和模板重载，我们可以创建新的检测类，这些类从这些类中派生，以给出我们想要的结果：
- en: '[PRE69]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first template for `test_find` creates the default behavior that will set
    the return type to `std::false_type`. Note that this has an argument type of `long`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_find`的第一个模板创建了将返回类型设置为`std::false_type`的默认行为。注意它的参数类型是`long`。'
- en: The second template for `test_find` creates a specialization that tests for
    a class that has a member function called `find()` and has a return type of `std::true_type`.
    Note that this has an argument type of `int`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_find`的第二个模板创建了一个专门测试具有名为`find()`的成员函数并具有`std::true_type`返回类型的类的特化。注意它的参数类型是`int`。'
- en: The `has_find<T,A0>` template works by deriving itself from the return types
    of the `test_find()` functions. If the T class does not have the `find()` method,
    then only the `std::false_type` version of `test_find()` is generated and so the
    `has_find<T,A0>::value` value will be false and can be used in `if constexpr()`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_find<T,A0>`模板通过从`test_find()`函数的返回类型派生自身来工作。如果T类没有`find()`方法，则只会生成`std::false_type`版本的`test_find()`，因此`has_find<T,A0>::value`值将为false，并且可以在`if
    constexpr()`中使用。'
- en: The interesting part occurs if the T class has the `find()` method as both of
    the `test_find()` methods are generated. But the specialized version takes an
    argument of the `int` type while the default takes an argument of the `long` type.
    As we "call" the function with zero (0), it will match the specialized version
    and use it. The argument difference is important because you cannot have two functions
    with the same argument types and only differ by return type. If you want to check
    this behavior, then change the argument from 0 to 0L to force the long version.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是，如果T类具有`find()`方法，则两个`test_find()`方法都会生成。但是专门的版本使用`int`类型的参数，而默认版本使用`long`类型的参数。当我们使用零（0）“调用”函数时，它将匹配专门的版本并使用它。参数的差异很重要，因为您不能有两个具有相同参数类型但仅返回类型不同的函数。如果要检查此行为，请将参数从0更改为0L以强制使用长版本。
- en: Class Templates
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类模板
- en: 'We have only dealt with function templates so far. But templates can also be
    used to provide blueprints for classes. The general structure of a templated class
    declaration is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了函数模板。但是模板也可以用于为类提供蓝图。模板类声明的一般结构如下：
- en: '[PRE70]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Whereas template functions allow us to produce generic algorithms, template
    classes allow us to produce generic data types and their associated behaviors.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 而模板函数允许我们生成通用算法，模板类允许我们生成通用数据类型及其相关行为。
- en: When we introduced the Standard Template Library, we highlighted that it includes
    templates for containers – `vector`, `deque`, `stack`, and so on. These templates
    allow us to store and manage any data type that we want, but still behave as we
    would expect.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍标准模板库时，我们强调它包括容器的模板-`vector`，`deque`，`stack`等。这些模板允许我们存储和管理任何我们想要的数据类型，但仍然表现得像我们期望的那样。
- en: 'Exercise 4: Writing a Class Template'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：编写类模板
- en: 'Two of the most commonly used data structures in computing science are stack
    and queue. Both currently have implementations in the STL. But to get our feet
    wet with a templated class, we are going to write a stack template class that
    can be used for any type. Let''s get started:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算科学中，最常用的两种数据结构是堆栈和队列。目前，STL中已经有了它们的实现。但是为了尝试使用模板类，我们将编写一个可以用于任何类型的堆栈模板类。让我们开始吧：
- en: Open the **Lesson2B** project in Eclipse, and then in the **Project Explorer**,
    expand **Lesson2B**, then **Exercise04**, and double-click on **Exercise4.cpp**
    to open the file for this exercise in the editor.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中打开**Lesson2B**项目，然后在**Project Explorer**中展开**Lesson2B**，然后展开**Exercise04**，双击**Exercise4.cpp**以在编辑器中打开此练习的文件。
- en: Configure a new **Launch Configuration**, **L2BExercise4**, to run with the
    name **Exercise4**.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置一个新的**Launch Configuration**，**L2BExercise4**，以运行名称为**Exercise4**的配置。
- en: Also, configure a new C/C++ Unit Run Configuration, **L2BEx4Tests**, to run
    **L2BEx4tests**. Set the **Google Tests Runner**.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要配置一个新的C/C++单元运行配置，**L2BEx4Tests**，以运行**L2BEx4tests**。设置**Google Tests Runner**。
- en: 'Click on the **Run** option for the test, which we have to run for the first
    time:![Figure 2B.32: Initial unit test for stacks'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**选项以运行测试，这是我们第一次运行：![图2B.32：堆栈的初始单元测试
- en: '](img/C14583_02B_32.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_32.jpg)'
- en: 'Figure 2B.32: Initial unit test for stacks'
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.32：堆栈的初始单元测试
- en: 'Open `#pragma once`) which tells the compiler that if it encounters this file
    again to be #included, it does not need to be. While not strictly part of the
    standard, nearly all modern C++ compilers support it. Finally, note that, for
    the purpose of this exercise, we have chosen to store the items in the STL vector.'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`#pragma once`），告诉编译器如果再次遇到此文件要被#include，它就不需要了。虽然不严格属于标准的一部分，但几乎所有现代C++编译器都支持它。最后，请注意，为了本练习的目的，我们选择将项目存储在STL向量中。
- en: 'In the editor, add the following declaration in the `public` section of the
    `Stack` class:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，在`Stack`类的`public`部分中添加以下声明：
- en: '[PRE71]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'At the top of the file, change **EXERCISE4_STEP** to a value of **10**. Click
    on the **Run** button. The Exercise 4 tests should run and fail:![Figure 2B.33:
    Jumping to a Failing test'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，将**EXERCISE4_STEP**更改为值**10**。单击**运行**按钮。练习4的测试应该运行并失败：![图2B.33：跳转到失败的测试
- en: '](img/C14583_02B_33.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_33.jpg)'
- en: 'Figure 2B.33: Jumping to a Failing test'
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.33：跳转到失败的测试
- en: Click on the name of the failing test, that is, `empty()` reports false.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击失败测试的名称，即`empty()`报告为false。
- en: Change `ASSERT_FALSE` to `ASSERT_TRUE` and rerun the test. This time, it passes
    because it is testing the right thing.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ASSERT_FALSE`更改为`ASSERT_TRUE`并重新运行测试。这一次，它通过了，因为它正在测试正确的事情。
- en: 'The next thing we will do is add some type aliases ready for use with the next
    few methods. In the editor, add the following lines just above the `empty()` method:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要做的是添加一些类型别名，以便在接下来的几个方法中使用。在编辑器中，在`empty()`方法的上面添加以下行：
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Click on the **Run** button to rerun the tests. They should pass. When doing
    test-driven development, the mantra is to write a small test and see it fail,
    and then write just enough code to make it pass. In this case, we actually tested
    that we got the definition of the aliases correct because failing to compile is
    one form of test failure. We are now ready to add the push function.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮重新运行测试。它们应该通过。在进行测试驱动开发时，口头禅是编写一个小测试并看到它失败，然后编写足够的代码使其通过。在这种情况下，我们实际上测试了我们是否正确获取了别名的定义，因为编译失败是一种测试失败的形式。我们现在准备添加push函数。
- en: 'In the editor, change **Stack.hpp** by adding the following code just below
    the **empty()** method:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，通过在**empty()**方法的下面添加以下代码来更改**Stack.hpp**：
- en: '[PRE73]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At the top of the file, change `EXERCISE4_STEP` to a value of `15`. Click on
    the `PushOntoStackNotEmpty`, in **StackTests.cpp** proves that the push does something
    to make the stack no longer empty. We need to add more methods to make sure that
    it has done the expected.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部，将`EXERCISE4_STEP`更改为值`15`。单击**PushOntoStackNotEmpty**，在**StackTests.cpp**中证明了push对使堆栈不再为空做了一些事情。我们需要添加更多方法来确保它已经完成了预期的工作。
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `16`:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改`push()`方法并将`EXERCISE4_STEP`更改为值`16`：
- en: '[PRE74]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Click on the **Run** button to run the tests. There should now have three passing
    tests.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮运行测试。现在应该有三个通过的测试。
- en: 'In the editor, change `push()` method and change `EXERCISE4_STEP` to a value
    of `18`:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改`push()`方法并将`EXERCISE4_STEP`更改为`18`的值：
- en: '[PRE75]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Click on the **Run** button to run the tests. There should now be four passing
    tests.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮运行测试。现在应该有四个通过的测试。
- en: 'In the editor, change `pop()` method and change `EXERCISE4_STEP` to a value
    of `20`:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，更改`pop()`方法并将`EXERCISE4_STEP`更改为`20`的值：
- en: '[PRE76]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Click on the **Run** button to run the tests. There are now five passing tests
    and we have implemented a stack.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**运行**按钮运行测试。现在有五个通过的测试，我们已经实现了一个堆栈。
- en: 'From the Launch Configuration dropdown, select **L2BExercise4** and click on
    the **Run** button. Exercise 4 will run and produce something similar to the following
    output:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动配置下拉菜单中，选择**L2BExercise4**，然后单击**运行**按钮。练习4将运行并产生类似以下输出：
- en: '![Figure 2B.34: Exercise 4 output'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.34：练习4输出'
- en: '](img/C14583_02B_34.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_34.jpg)'
- en: 'Figure 2B.34: Exercise 4 output'
  id: totrans-478
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.34：练习4输出
- en: Examine the code that is now in the `std::stack` template takes two arguments,
    with the second one defining the container to be used – vector could be the first.
    Examine the tests in **StackTests.cpp**. The tests should be named to indicate
    what they aim to test, and they should focus on doing that.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 检查现在在`std::stack`模板中的代码，它带有两个参数，第二个参数定义要使用的容器 - vector可以是第一个。检查**StackTests.cpp**中的测试。测试应该被命名以指示它们的测试目标，并且它们应该专注于做到这一点。
- en: 'Activity 1: Developing a Generic "contains" Template Function'
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：开发一个通用的“contains”模板函数
- en: The programming language Python has a membership operator called "in" that can
    be used on any sequence, that is, list, sequence, set, string, and so on. Even
    though C++ has over 100 algorithms, it does not have an equivalent method to achieve
    the same. C++ 20 introduced the `contains()` method on `std::set`, but that is
    not enough for us. We need to create a `contains()` template function that works
    with `std::set`, `std::string`, `std::vector`, and any other container that provides
    iterators. This is determined by the ability to call end() on it. We are aiming
    for best performance, so we will call the `find()` member method on any container
    that has one (it will be the most efficient) and otherwise fall back to using
    `std::end()` on the container. We also need to treat `std::string()` differently
    as its `find()` method returns a special value.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言Python有一个称为“in”的成员运算符，可以用于任何序列，即列表、序列、集合、字符串等。尽管C++有100多种算法，但它没有相应的方法来实现相同的功能。C++
    20在`std::set`上引入了`contains()`方法，但这对我们来说还不够。我们需要创建一个`contains()`模板函数，它可以与`std::set`、`std::string`、`std::vector`和任何提供迭代器的其他容器一起使用。这是通过能够在其上调用end()来确定的。我们的目标是获得最佳性能，因此我们将在任何具有`find()`成员方法的容器上调用它（这将是最有效的），否则将退回到在容器上使用`std::end()`。我们还需要将`std::string()`区别对待，因为它的`find()`方法返回一个特殊值。
- en: 'We could implement this using a general template and two specializations, but
    this activity is being used to get it working using the techniques of SFINAE and
    if constexpr. In addition, this template must only work on a class that supports
    `end(C)`. Follow these steps to implement this activity:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用通用模板和两个特化来实现这一点，但是这个活动正在使用SFINAE和if constexpr的技术来使其工作。此外，这个模板必须只能在支持`end(C)`的类上工作。按照以下步骤实现这个活动：
- en: Load the prepared project from the **Lesson2B/Activity01** folder.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Lesson2B/Activity01**文件夹加载准备好的项目。
- en: Define the helper template functions and class to detect the std:string case
    using the `npos` member.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义辅助模板函数和类来检测std:string情况，使用`npos`成员。
- en: Define the helper template functions and class to detect whether the class has
    a `find()` method.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义辅助模板函数和类，以检测类是否具有`find()`方法。
- en: Define the contains template function that uses constexpr to select between
    one of three implementations – string case, the has find method, or general case.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义包含模板函数，使用constexpr来在三种实现中选择一种 - 字符串情况、具有find方法的情况或一般情况。
- en: 'After implementing the preceding steps, the expected output should look as
    follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了上述步骤之后，预期输出应如下所示：
- en: '![Figure 2B.35: Output from the successful implementation of contains'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2B.35：包含成功实现的输出'
- en: '](img/C14583_02B_35.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14583_02B_35.jpg)'
- en: 'Figure 2B.35: Output from the successful implementation of contains'
  id: totrans-490
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2B.35：包含成功实现的输出
- en: Note
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 653.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第653页找到。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about interfaces, inheritance, and polymorphism,
    which extended our skills of what we can do with our types. We had our first adventure
    into generic programming with C++ templates and touched on what the language gives
    us for free from the C++ Standard Library, which includes the STL. We explored
    a feature of C++ that just works, that is, template type deduction, which makes
    our life easier when using templates. We then went further with templates and
    learned how to control the parts of the template that are included by the compiler
    using SFINAE and if constexpr. These form the building blocks for our journey
    into C++. In the next chapter, we will revisit the stack and the heap, and understand
    what an exception is, what happens, and when it occurs. We'll also learn how to
    protect our programs from resource losses when exceptions occur.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了接口、继承和多态，这扩展了我们对类型的操作技能。我们首次尝试了C++模板的泛型编程，并接触了语言从C++标准库（包括STL）中免费提供给我们的内容。我们探索了C++的一个功能，即模板类型推断，它在使用模板时使我们的生活更加轻松。然后我们进一步学习了如何使用SFINAE和if
    constexpr控制编译器包含的模板部分。这些构成了我们进入C++之旅的基石。在下一章中，我们将重新讨论堆栈和堆，并了解异常是什么，发生了什么，以及何时发生。我们还将学习如何在异常发生时保护我们的程序免受资源损失。
