- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: The General-Purpose Input/Output (GPIO) Peripheral
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用输入/输出（GPIO）外设
- en: In this chapter, we will explore the **General-Purpose Input/Output** (**GPIO**)
    peripheral, an essential component in microcontrollers. This peripheral is crucial
    for interfacing with microcontrollers, making it fundamental to embedded systems
    development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**通用输入/输出**（**GPIO**）外设，这是微控制器中一个基本组件。这个外设对于与微控制器接口至关重要，对于嵌入式系统开发来说是基本的。
- en: We will start by exploring the organization of GPIO ports and pins, covering
    both the general-purpose and alternate functions of these pins. Next, we will
    examine the key registers associated with the GPIO peripheral in STM32 microcontrollers.
    Finally, we will apply this knowledge to develop input and output drivers using
    the detailed register information we learn in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索GPIO端口和引脚的组织结构，涵盖这些引脚的通用和替代功能。接下来，我们将检查与STM32微控制器中的GPIO外设相关的关键寄存器。最后，我们将应用这些知识，利用本章学到的详细寄存器信息开发输入和输出驱动程序。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the GPIO peripheral
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GPIO外设
- en: The STM32 GPIO registers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 GPIO寄存器
- en: Developing input and output drivers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发输入和输出驱动程序
- en: By the end of this chapter, you will be able to use the GPIO peripheral to interface
    effectively with microcontrollers, which will enable you to handle various input
    and output tasks with confidence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用GPIO外设有效地与微控制器接口，这将使你能够自信地处理各种输入和输出任务。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding the GPIO peripheral
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GPIO外设
- en: Since we introduced the GPIO peripheral in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039),
    this section will reiterate the key points to remember regarding GPIOs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在[*第2章*](B21914_02.xhtml#_idTextAnchor039)中介绍了GPIO外设，本节将重申关于GPIO的关键要点。
- en: 'Microcontroller pins are grouped into ports. For instance, a microcontroller
    might have ports named **GPIOA**, **GPIOB**, and **GPIOC**. See *Figure 2**.10*
    in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039). Each port is composed of individual
    pins, which are referred to by their port name, followed by their pin number.
    The following are examples of this naming convention:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器的引脚被分组到端口中。例如，一个微控制器可能有名为**GPIOA**、**GPIOB**和**GPIOC**的端口。参见[*第2章*](B21914_02.xhtml#_idTextAnchor039)中的*图2**.10*。每个端口由单个引脚组成，这些引脚通过其端口名称，后跟其引脚编号来引用。以下是一些命名约定的示例：
- en: PA1 refers to port A, pin 1
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PA1指的是端口A，引脚1
- en: PD7 refers to port D, pin 7
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PD7指的是端口D，引脚7
- en: This naming convention helps in identifying and configuring specific pins for
    various functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定有助于识别和配置特定引脚以执行各种功能。
- en: 'The STM32F411xC/E microcontroller series features six ports: **PORTA**, **PORTB**,
    **PORTC**, **PORTD**, **PORTE**, and **PORTH**. Each port is equipped with a comprehensive
    set of registers to manage configuration, data handling, and functionality.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F411xC/E微控制器系列具有六个端口：**PORTA**、**PORTB**、**PORTC**、**PORTD**、**PORTE**和**PORTH**。每个端口都配备了一套全面的寄存器，用于管理配置、数据处理和功能。
- en: 'These ports offer a variety of features designed for versatility and performance.
    The features offered include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端口提供了一系列旨在提高通用性和性能的功能。提供的功能包括以下内容：
- en: '**I/O control**: They allow us to manage up to 16 input/output pins per port.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/O控制**：它们允许我们管理每个端口的最多16个输入/输出引脚。'
- en: '**Output states**: Pins can be configured for push-pull or open-drain modes,
    with optional pull-up or pull-down resistors.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出状态**：引脚可以配置为推挽或开漏模式，并可选择上拉或下拉电阻。'
- en: '`GPIOx_ODR` register when the pin is configured as a general-purpose output.
    For alternate function configurations, the associated peripheral drives the output
    data.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引脚配置为通用输出时，`GPIOx_ODR`寄存器。对于替代功能配置，相关外设驱动输出数据。
- en: '**Speed selection**: The operating speed for each I/O pin can be set.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度选择**：可以设置每个I/O引脚的运行速度。'
- en: '**Input states**: Pins can be configured as floating, pull-up, pull-down, or
    analog inputs.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入状态**：引脚可以配置为浮空、上拉、下拉或模拟输入。'
- en: '`GPIOx_IDR` register or an associated peripheral when configured for alternate
    function input.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当配置为复用功能输入时，`GPIOx_IDR`寄存器或相关的外设。
- en: '`GPIOx_LCKR` register can be used to lock the I/O configuration, preventing
    accidental changes.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_LCKR`寄存器可用于锁定I/O配置，防止意外更改。'
- en: '**Alternate function selection**: Up to 16 alternate functions per I/O pin
    can be configured, providing flexibility in pin usage.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复用功能选择**：每个I/O引脚可以配置多达16个复用功能，提供引脚使用的灵活性。'
- en: In the next section, we shall explore some of the GPIO registers of the STM32F411
    microcontroller.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨STM32F411微控制器的一些GPIO寄存器。
- en: The STM32 GPIO registers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32 GPIO寄存器
- en: In this section, we will explore the characteristics and functions of some of
    the common registers within the GPIO peripheral.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨GPIO外设中一些常见寄存器的特性和功能。
- en: 'Each GPIO port includes a set of 32-bit registers essential for configuration
    and control. The configuration registers comprise the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO端口都包含一组32位寄存器，这些寄存器对于配置和控制至关重要。配置寄存器包括以下内容：
- en: '`GPIOx_MODER` (mode register)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_MODER`（模式寄存器）'
- en: '`GPIOx_OTYPER` (output type register)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_OTYPER`（输出类型寄存器）'
- en: '`GPIOx_OSPEEDR` (output speed register)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_OSPEEDR`（输出速度寄存器）'
- en: '`GPIOx_PUPDR` (pull-up/pull-down register)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_PUPDR`（上拉/下拉寄存器）'
- en: 'The data registers include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据寄存器包括以下内容：
- en: '`GPIOx_IDR` (input data register)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_IDR`（输入数据寄存器）'
- en: '`GPIOx_ODR` (output data register)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOx_ODR`（输出数据寄存器）'
- en: '`GPIOx_BSRR` (the bit-set/reset register) and `GPIOx_LCKR` (the locking register)
    are used to control pin states and access. Additionally, the alternate function
    selection registers, `GPIOx_AFRH` and `GPIOx_AFRL`, manage the alternate function
    assignments for the pins within the GPIO port.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOx_BSRR`（位设置/重置寄存器）和`GPIOx_LCKR`（锁定寄存器）用于控制引脚状态和访问。此外，复用功能选择寄存器`GPIOx_AFRH`和`GPIOx_AFRL`管理GPIO端口内引脚的复用功能分配。'
- en: Let’s start with the GPIO mode register.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从GPIO模式寄存器开始。
- en: The GPIO mode register (GPIOx_MODER)
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO模式寄存器（GPIOx_MODER）
- en: The GPIO port mode register (`GPIOx_MODER`) is an important register for configuring
    the mode of each pin in the GPIO port. This register allows us to set each pin
    in different modes, such as **input**, **output**, **alternate function**, or
    **analog**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO端口模式寄存器（`GPIOx_MODER`）是配置GPIO端口中每个引脚模式的 重要寄存器。此寄存器允许我们设置每个引脚在不同的模式，例如**输入**、**输出**、**复用功能**或**模拟**。
- en: It is a 32-bit register divided into 16 pairs of bits. Each pair of bits corresponds
    to a specific pin in the GPIO port, allowing the individual configuration of each
    pin. See *Figure 2**.17* in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个32位寄存器，分为16对位。每对位对应GPIO端口中的一个特定引脚，允许对每个引脚进行单独配置。参见[*第2章*](B21914_02.xhtml#_idTextAnchor039)中的*图2**.17*。
- en: 'The possible configurations for these bits are the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些位的可能配置如下：
- en: '**00**: Input mode (reset state)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**00**：输入模式（复位状态）'
- en: In this mode, the pin is configured as an input, which can be used to read signals
    from external devices such as a push button.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此模式下，引脚被配置为输入，可用于从外部设备（如按钮）读取信号。
- en: '**01**: General-purpose output mode'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**01**：通用输出模式'
- en: This mode configures the pin as an output, which can be used to drive external
    signals or components such as an LED.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模式将引脚配置为输出，可用于驱动外部信号或组件，如LED。
- en: '**10**: Alternate function mode'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10**：复用功能模式'
- en: This mode sets the pin to an alternate function, allowing it to interface with
    various peripherals such as UART, SPI, or I2C.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模式将引脚设置为复用功能，允许它与各种外设接口，如UART、SPI或I2C。
- en: '**11**: Analog mode'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**11**：模拟模式'
- en: This mode configures the pin for analog input, which is useful for **analog-to-digital
    converter** (**ADC**) operations.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此模式将引脚配置为模拟输入，这对于**模数转换器**（**ADC**）操作很有用。
- en: Let’s see a practical example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个实际例子。
- en: 'Consider configuring a pin (e.g., **PA5**) on port A:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑配置端口A上的一个引脚（例如，**PA5**）：
- en: 'To set **PA5** as a general-purpose output (**01**), we can follow these steps:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将**PA5**设置为通用输出（**01**），我们可以按照以下步骤操作：
- en: Locate the bit pair corresponding to **PA5 (MODER5[1:0])**; these are **bit11**
    and **bit10**
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位到对应**PA5 (MODER5[1:0])**的位对；这些是**bit11**和**bit10**
- en: Write **0** to **bit11** and **1** to **bit10**
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**bit11**设置为**0**，将**bit10**设置为**1**
- en: To set **PA5** as an alternate function (**10**), we should write **1** to **bit11**
    and **0** to **bit10**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将**PA5**设置为复用功能（**10**），我们应该将**bit11**设置为**1**，将**bit10**设置为**0**。
- en: To set **PA5** as an analog input (**11**), we should write **1** to **bit11**
    and **1** to **bit10**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将**PA5**设置为模拟输入（**11**），我们应该将**bit11**和**bit10**都写入**1**。
- en: This is all there is to know about the `GPIOx_MODER` register.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于`GPIOx_MODER`寄存器需要了解的全部内容。
- en: 'Let’s move on to examine two other important registers: the output data register
    (`GPIOx_ODR`) and the input data register (`GPIOx_IDR`).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续考察另外两个重要的寄存器：输出数据寄存器（`GPIOx_ODR`）和输入数据寄存器（`GPIOx_IDR`）。
- en: The GPIO output data register (GPIOx_ODR) and the GPIO input data register (GPIOx_IDR)
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO输出数据寄存器（GPIOx_ODR）和GPIO输入数据寄存器（GPIOx_IDR）
- en: The GPIO output data register (`GPIOx_ODR`) and GPIO input data register (`GPIOx_IDR`)
    are essential for managing the data flow through the GPIO pins. These registers
    allow for reading the state of pins and setting the state of pins, enabling our
    microcontroller to interact with external devices effectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO输出数据寄存器（`GPIOx_ODR`）和GPIO输入数据寄存器（`GPIOx_IDR`）对于通过GPIO引脚管理数据流至关重要。这些寄存器允许读取引脚的状态并设置引脚的状态，使我们的微控制器能够有效地与外部设备交互。
- en: '`GPIOx_ODR` is a 32-bit register, but only the lower 16 bits are used to control
    the output state of the pins. Each bit in the register corresponds to a pin in
    the GPIO port.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOx_ODR`是一个32位寄存器，但仅使用低16位来控制引脚的输出状态。寄存器中的每个位都对应GPIO端口中的一个引脚。'
- en: By writing to this register, we can set the logic level (high or low) of each
    pin configured as an output. *Figure 7**.1* shows the structure of the GPIO **output
    data register** (**ODR**) extracted from the reference manual.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写入此寄存器，我们可以设置配置为输出的每个引脚的逻辑电平（高或低）。*图7.1*显示了从参考手册中提取的GPIO **输出数据寄存器**（**ODR**）的结构。
- en: '![Figure 7.1: GPIO ODR](img/B21914_07_1.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：GPIO ODR](img/B21914_07_1.jpg)'
- en: 'Figure 7.1: GPIO ODR'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：GPIO ODR
- en: 'Take the following examples:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: Writing `bit5(ODR5)` sets **PA5** to a high state
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入`bit5(ODR5)`将**PA5**设置为高电平状态
- en: Writing `bit5(ODR5)` sets **PA5** to a low state
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入`bit5(ODR5)`将**PA5**设置为低电平状态
- en: '*How about the GPIO input* *data register?*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么GPIO输入数据寄存器呢？*'
- en: The GPIO input data register (`GPIOx_IDR`) is used to read the current state
    of the GPIO pins configured as inputs. By reading from this register, we can determine
    whether each input is at a high or low logic level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO输入数据寄存器（`GPIOx_IDR`）用于读取配置为输入的GPIO引脚的当前状态。通过从这个寄存器读取，我们可以确定每个输入是处于高逻辑电平还是低逻辑电平。
- en: It is a 32-bit register, but similar to the ODR, only the lower 16 bits are
    used to read the state of the pins. Each bit in the register corresponds to a
    pin in the GPIO port.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个32位寄存器，但与ODR类似，仅使用低16位来读取引脚的状态。寄存器中的每个位都对应GPIO端口中的一个引脚。
- en: A bit value of **1** indicates that the corresponding pin is at a high logic
    level, while a bit value of **0** indicates that it is at a low logic level.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**的位值表示相应的引脚处于高逻辑电平，而**0**的位值表示它处于低逻辑电平。'
- en: '*Figure 7**.2* shows the structure of the GPIO input data register:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2*显示了GPIO输入数据寄存器的结构：'
- en: '![Figure 7.2: GPIO input data register](img/B21914_07_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：GPIO输入数据寄存器](img/B21914_07_2.jpg)'
- en: 'Figure 7.2: GPIO input data register'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：GPIO输入数据寄存器
- en: 'Take the following examples:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: If `bit5(IDR5)` reads **1**, **PA5** is at a high state
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`bit5(IDR5)`读取为**1**，则**PA5**处于高电平状态
- en: If `bit5(IDR5)` reads **0**, **PA5** is at a low state
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`bit5(IDR5)`读取为**0**，则**PA5**处于低电平状态
- en: Another commonly used register is the GPIO bit set/reset register (`GPIOx_BSRR`).
    Let’s examine this register in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的寄存器是GPIO位设置/重置寄存器（`GPIOx_BSRR`）。让我们在下一节中考察这个寄存器。
- en: The GPIO bit-set/reset register (GPIOx_BSRR)
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO位设置/重置寄存器（GPIOx_BSRR）
- en: The GPIO bit-set/reset register (`GPIOx_BSRR`) is a crucial register for controlling
    the state of GPIO pins. It provides atomic bitwise operations to set or reset
    individual bits, which ensures that no interrupts can disrupt the operation, maintaining
    data integrity during modifications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO位设置/重置寄存器（`GPIOx_BSRR`）是控制GPIO引脚状态的关键寄存器。它提供原子位操作来设置或重置单个位，这确保了没有中断可以干扰操作，在修改过程中保持数据完整性。
- en: '`GPIOx_BSRR` is a 32-bit register divided into two 16-bit sections:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOx_BSRR`是一个32位寄存器，分为两个16位部分：'
- en: '**Bits 15:0 (BSy)**: These bits are used to set the corresponding GPIO pin'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位15:0 (BSy)**：这些位用于设置相应的GPIO引脚'
- en: '**Bits 31:16 (BRy)**: These bits are used to reset the corresponding GPIO pin'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位31:16 (BRy)**：这些位用于重置相应的GPIO引脚'
- en: '*Figure 7**.3* shows the structure of the GPIO **bit-set/reset** **register**
    (**BSRR**).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3*显示了GPIO **位设置/重置** **寄存器**（**BSRR**）的结构。'
- en: '![Figure 7.3: BSRR](img/B21914_07_3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：BSRR](img/B21914_07_3.jpg)'
- en: 'Figure 7.3: BSRR'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：BSRR
- en: 'Let’s analyze the bits in the register:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析寄存器中的位：
- en: '**Bits 31:16 (BRy)**: Writing **1** to any of the upper 16 bits resets the
    corresponding pin to a low state'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位31:16（BRy）**：将任何高16位写入**1**将相应的引脚重置为低电平'
- en: '**Bits 15:0 (BSy)**: Writing **1** to any of the lower 16 bits sets the corresponding
    pin to a high state'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位15:0（BSy）**：将任何低16位写入**1**将相应的引脚设置为高电平'
- en: 'For example, let’s see how to set PA5 as high and low using the BSRR:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何使用BSRR将PA5设置为高电平和低电平：
- en: To set PA5 as `GPIOA_BSRR` register
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PA5设置为`GPIOA_BSRR`寄存器
- en: To set PA5 as `GPIOA_BSRR` register
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将PA5设置为`GPIOA_BSRR`寄存器
- en: The GPIO BSRR (`GPIOx_BSRR`) provides a robust mechanism for controlling the
    state of GPIO pins. By understanding its structure and functionality, we can perform
    efficient and atomic operations to set or reset individual pins.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO BSRR（`GPIOx_BSRR`）提供了一个强大的机制来控制GPIO引脚的状态。通过理解其结构和功能，我们可以执行高效且原子的操作来设置或重置单个引脚。
- en: Another pair of commonly used GPIO registers are the GPIO alternate function
    high and alternate function low registers. Let’s explore them in the next section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一对常用的GPIO寄存器是GPIO复用功能高和复用功能低寄存器。让我们在下一节中探讨它们。
- en: The GPIO alternate function registers (GPIOx_AFRL and GPIOx_AFRH)
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO复用功能寄存器（GPIOx_AFRL和GPIOx_AFRH）
- en: The GPIO **alternate function registers** (**AFRs**) are important for configuring
    the alternate functions of the GPIO pins in STM32 microcontrollers. These registers
    allow each pin to be assigned a specific peripheral function, enhancing the versatility
    and functionality of the microcontroller.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO **复用功能寄存器**（**AFRs**）对于配置STM32微控制器中GPIO引脚的复用功能非常重要。这些寄存器允许每个引脚被分配一个特定的外围功能，增强了微控制器的多功能性和功能性。
- en: 'Each GPIO port has two AFRs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO端口有两个AFR：
- en: '**GPIOx_AFRL**: **Alternate function low register** (**AFRL**), for pins 0
    to 7'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOx_AFRL**：**复用功能低寄存器**（**AFRL**），用于0到7引脚'
- en: '**GPIOx_AFRH**: **Alternate function high register** (**AFRH**), for pins 8
    to 15'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOx_AFRH**：**复用功能高寄存器**（**AFRH**），用于8到15引脚'
- en: These registers enable the selection of alternate functions for each pin, facilitating
    the use of the pins for various peripheral interfaces such as UART, I2C, and SPI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器允许为每个引脚选择复用功能，便于使用引脚进行各种外围接口，如UART、I2C和SPI。
- en: '`GPIOx_AFRL` is a 32-bit register, divided into eight 4-bit fields. Each 4-bit
    field corresponds to one pin in the range of pins 0 to 7 in the GPIO port.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOx_AFRL`是一个32位寄存器，分为八个4位字段。每个4位字段对应GPIO端口中0到7范围内的一个引脚。'
- en: '`GPIOx_AFRH` is also a 32-bit register, divided into eight 4-bit fields. Here,
    each 4-bit field corresponds to one pin in the range of pins 8 to 15 in the GPIO
    port.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOx_AFRH`也是一个32位寄存器，分为八个4位字段。在这里，每个4位字段对应GPIO端口中8到15范围内的一个引脚。'
- en: '![Figure 7.4: Alternate function low register](img/B21914_07_4.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：复用功能低寄存器](img/B21914_07_4.jpg)'
- en: 'Figure 7.4: Alternate function low register'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：复用功能低寄存器
- en: '*Figure 7**.4* illustrates the AFRL. To understand the various alternate functions
    each pin can assume based on the values of the corresponding 4-bit fields, we
    will refer to *Figure 7**.5* as our guide:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.4*说明了AFRL。为了了解每个引脚可以基于相应的4位字段值假设的各种复用功能，我们将参考*图7.5*作为我们的指南：'
- en: '![Figure 7.5: Alternate function selection](img/B21914_07_5.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：复用功能选择](img/B21914_07_5.jpg)'
- en: 'Figure 7.5: Alternate function selection'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：复用功能选择
- en: '*Figure 7**.5* shows a diagram with two multiplexers. The first multiplexer
    represents the selector for the AFRL, while the second represents the selector
    for the AFRH. This diagram is sourced from page 150 of the reference manual. It
    effectively demonstrates how to configure GPIO pins for alternate functions on
    STM32F411 microcontrollers using these registers.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.5*显示了包含两个多路复用器的图。第一个多路复用器代表AFRL的选择器，而第二个代表AFRH的选择器。此图来源于参考手册的第150页。它有效地展示了如何使用这些寄存器在STM32F411微控制器上配置GPIO引脚的复用功能。'
- en: Let’s break down what we see.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们看到的内容。
- en: 'For both `GPIOx_AFRL` and `GPIOx_AFRH`, the diagram provides a list of the
    possible alternate functions that can be selected for each pin. The alternate
    functions are designated by **AF0** through **AF15**, each associated with specific
    peripheral functions, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GPIOx_AFRL`和`GPIOx_AFRH`，图提供了每个引脚可以选定的可能复用功能的列表。复用功能由**AF0**到**AF15**指定，每个都与特定的外围功能相关，如下所示：
- en: '| **Alternate** **function description** | **Binary value** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **备用功能描述** | **二进制值** |'
- en: '| AF0: System functions | 0000 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| AF0: 系统功能 | 0000 |'
- en: '| AF1: TIM1/TIM2 | 0001 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| AF1: TIM1/TIM2 | 0001 |'
- en: '| AF2: TIM3/TIM4/TIM5 | 0010 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| AF2: TIM3/TIM4/TIM5 | 0010 |'
- en: '| AF3: TIM9/TIM10/TIM11 | 0011 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| AF3: TIM9/TIM10/TIM11 | 0011 |'
- en: '| AF4: I2C1/I2C2/I2C3 | 0100 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| AF4: I2C1/I2C2/I2C3 | 0100 |'
- en: '| AF5: SPI1/SPI2/SPI3/SPI4 | 0101 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| AF5: SPI1/SPI2/SPI3/SPI4 | 0101 |'
- en: '| AF6: SPI3/SPI4/SPI5 | 0110 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| AF6: SPI3/SPI4/SPI5 | 0110 |'
- en: '| AF7: USART1/USART2 | 0111 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| AF7: USART1/USART2 | 0111 |'
- en: '| AF8: USART6 | 1000 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| AF8: USART6 | 1000 |'
- en: '| AF9: I2C2/I2C3 | 1001 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| AF9: I2C2/I2C3 | 1001 |'
- en: '| AF10: OTG_FS | 1010 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| AF10: OTG_FS | 1010 |'
- en: '| AF11: Reserved | 1011 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| AF11: 保留 | 1011 |'
- en: '| AF12: SDIO | 1100 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| AF12: SDIO | 1100 |'
- en: '| AF13: Reserved | 1101 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| AF13: 保留 | 1101 |'
- en: '| AF14: Reserved | 1110 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| AF14: 保留 | 1110 |'
- en: '| AF15: EVENTOUT | 1111 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| AF15: EVENTOUT | 1111 |'
- en: 'Table 7.1: Alternate function selection'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：备用功能选择
- en: For example, to configure pin 5 (`GPIOA_AFRL` register. We use `GPIOA_AFRL`
    because PA5 falls within the range of pins 0 to 7, which are managed by this register.
    To configure pin 10 (`GPIOA_AFRH` register. This is because `GPIOA_AFRH` register.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要配置引脚5（`GPIOA_AFRL`寄存器。我们使用`GPIOA_AFRL`，因为PA5位于0到7引脚的范围内，这些引脚由该寄存器管理。要配置引脚10（`GPIOA_AFRH`寄存器。这是因为`GPIOA_AFRH`寄存器。
- en: In this section, we explored the characteristics and functions of several essential
    registers within the STM32 GPIO peripheral. We began with the GPIO mode register
    (`GPIOx_MODER`), which configures the mode of each GPIO pin, allowing settings
    for the input, output, alternate function, or analog mode. We then examined the
    GPIO output data register (`GPIOx_ODR`) and input data register (`GPIOx_IDR`),
    which manage the data flow through the GPIO pins by setting and reading pin states.
    Next, we looked at the GPIO BSRR (`GPIOx_BSRR`), which provides atomic operations
    for setting and resetting individual pin states. Finally, we covered the GPIO
    alternate function registers (`GPIOx_AFRL` and `GPIOx_AFRH`), which assign specific
    peripheral functions to each pin, enhancing the microcontroller’s versatility.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了STM32 GPIO外设中几个基本寄存器的特性和功能。我们从配置每个GPIO引脚模式的GPIO模式寄存器（`GPIOx_MODER`）开始，允许设置输入、输出、备用功能或模拟模式。然后我们检查了GPIO输出数据寄存器（`GPIOx_ODR`）和输入数据寄存器（`GPIOx_IDR`），它们通过设置和读取引脚状态来管理通过GPIO引脚的数据流。接下来，我们看了GPIO
    BSRR（`GPIOx_BSRR`），它提供了设置和重置单个引脚状态的原子操作。最后，我们涵盖了GPIO备用功能寄存器（`GPIOx_AFRL`和`GPIOx_AFRH`），它们将特定的外设功能分配给每个引脚，增强了微控制器的多功能性。
- en: In the next section, we will develop GPIO drivers using the knowledge gained
    in this section. Specifically, we will focus on creating input and output drivers.
    We will explore the practical usage of the alternate function registers in the
    chapters dedicated to communication peripherals.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将利用本节获得的知识开发GPIO驱动程序。具体来说，我们将专注于创建输入和输出驱动程序。我们将探讨在通信外设章节中关于备用功能寄存器的实际用法。
- en: Developing input and output drivers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发输入和输出驱动
- en: In this section, we will apply the knowledge gained about the GPIO peripheral
    to develop practical input and output drivers for STM32 microcontrollers. Since
    we are already familiar with developing the output driver to toggle an LED using
    the ODR, this section will focus on developing the output driver using the BSRR.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用关于GPIO外设的知识来开发STM32微控制器的实际输入和输出驱动程序。由于我们已经熟悉使用ODR来切换LED的输出驱动程序开发，本节将重点开发使用BSRR的输出驱动程序。
- en: The GPIO output driver using the BSRR
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BSRR的GPIO输出驱动程序
- en: 'Let’s start by making a copy of our last project in our IDE:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的IDE中复制我们上一个项目开始：
- en: Right-click on the last project and select **Copy**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个项目上右键单击并选择**复制**。
- en: Right-click in the **Project Explorer** pane and select **Paste**.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目资源管理器**窗格中右键单击并选择**粘贴**。
- en: Rename the copied project to `GpioInput-Output`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的项目重命名为 `GpioInput-Output`。
- en: 'Next, we will modularize our code by creating dedicated files for the GPIO
    driver code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过创建专门的文件来模块化我们的代码，用于GPIO驱动代码：
- en: Right-click on the `Src` folder in the project and select **New** | **File**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`Src`文件夹上右键单击并选择**新建** | **文件**。
- en: In the `gpio.c`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gpio.c`。
- en: 'Then, we will create the corresponding header file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建相应的头文件：
- en: Right-click on the `Inc` folder in the project and select **New** | **File**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`Inc`文件夹上右键单击并选择**新建** | **文件**。
- en: In the `gpio.h`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gpio.h`。
- en: Our next task is to implement the driver code in the `gpio.c` file and declare
    the public functions in the `gpio.h` file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是实现`gpio.c`文件中的驱动程序代码并在`gpio.h`文件中声明公共函数。
- en: 'Populate your `gpio.c` with the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `gpio.c` 文件中填充以下代码：
- en: '[PRE0]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down the unique elements of the `gpio.c` file, focusing on the
    usage of the BSRR. We start with the header file inclusion:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解 `gpio.c` 文件中的独特元素，重点关注 BSRR 的使用。我们从头文件包含开始：
- en: '[PRE1]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line includes the `gpio.h` header file, which in turn includes `stm32fxx.h`
    to provide access to the register definitions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行包含 `gpio.h` 头文件，该文件反过来包含 `stm32fxx.h` 以提供对寄存器定义的访问。
- en: 'Next, we define all the macros we need:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们需要的所有宏：
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break these macros down:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这些宏：
- en: '`GPIOAEN`: This macro is used to enable the clock for GPIOA by writing to the
    `AHB1ENR` register.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOAEN`：此宏用于通过写入 `AHB1ENR` 寄存器来启用 GPIOA 的时钟。'
- en: '`LED_BS5`: This macro represents the bit-set operation for pin PA5\. Writing
    this value to the BSRR sets PA5 to high, turning the LED on.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LED_BS5`：此宏代表对引脚 PA5 的位设置操作。将此值写入 BSRR 将 PA5 设置为高电平，打开 LED。'
- en: '`LED_BR5`: This macro represents the bit-reset operation for pin PA5\. Writing
    this value to the BSRR resets PA5 to low, turning the LED off.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LED_BR5`：此宏代表对引脚 PA5 的位重置操作。将此值写入 BSRR 将 PA5 重置为低电平，关闭 LED。'
- en: 'Next, we implement the function for turning on the LED:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现打开 LED 的函数：
- en: '[PRE3]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GPIOA->BSRR |= LED_BS5` line uses the BSRR to set PA5 to high. Writing
    **1** to bit 5 of the BSRR sets the corresponding pin (PA5) to high, turning the
    LED on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPIOA->BSRR |= LED_BS5` 这一行使用 BSRR 将 PA5 设置为高电平。将 **1** 写入 BSRR 的第 5 位将相应的引脚（PA5）设置为高电平，打开
    LED。'
- en: 'And then we implement the function to turn the LED off:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现关闭 LED 的函数：
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly, `GPIOA->BSRR |= LED_BR5` uses the BSRR to reset PA5 to low. Writing
    **1** to bit 21 of the BSRR resets the corresponding pin (PA5) to low, turning
    the LED off.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`GPIOA->BSRR |= LED_BR5` 使用 BSRR 将 PA5 重置为低电平。将 **1** 写入 BSRR 的第 21 位将相应的引脚（PA5）重置为低电平，关闭
    LED。
- en: 'Here is the content for the `gpio.h` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `gpio.h` 文件的内容：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s break it down, starting with the header guard:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头文件守卫开始分解：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The header guards prevent multiple inclusions of the same header file, which
    can lead to errors and redundant declarations. The `#ifndef GPIO_H_` directive
    checks whether `GPIO_H_` has been defined yet. If it hasn’t, it proceeds to define
    `GPIO_H_` and includes the rest of the file. The `#endif` directive at the end
    closes the conditional directive that began with `#ifndef`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件守卫防止重复包含相同的头文件，这可能导致错误和冗余声明。`#ifndef GPIO_H_` 指令检查 `GPIO_H_` 是否已被定义。如果没有，它将定义
    `GPIO_H_` 并包含文件的其余部分。`#endif` 指令在末尾关闭了从 `#ifndef` 开始的条件指令。
- en: 'Next, we have the `include` directive:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `include` 指令：
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This directive includes the `stm32f4xx.h` header file, which in turn includes
    the `stm32f411xe.h` header file, which provides definitions and declarations for
    all the registers in our microcontroller.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令包含 `stm32f4xx.h` 头文件，该文件反过来包含 `stm32f411xe.h` 头文件，它为我们微控制器中的所有寄存器提供定义和声明。
- en: 'And then we have the function declarations:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有函数声明：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These declarations allow us to access the functions defined in the `gpio.c`
    file from other files, such as `main.c`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些声明允许我们从其他文件（如 `main.c`）访问在 `gpio.c` 文件中定义的函数。
- en: 'Now that our GPIO output driver for PA5 is complete, let’s test it by updating
    the `main.c` file to call the functions defined in the `gpio.c` file. Here is
    the updated `main.c` code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 PA5 的 GPIO 输出驱动程序，让我们通过更新 `main.c` 文件来调用 `gpio.c` 文件中定义的函数来测试它。以下是更新的
    `main.c` 代码：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code begins by including the `gpio.h` header file to access the GPIO functions
    defined in `gpio.c`. Within the `main` function, it first calls `led_init()` to
    initialize PA5 as an output pin. Then, it enters an infinite loop where it alternately
    turns the LED on and off by calling `led_on()` and `led_off()`, respectively.
    We use simple delay loops between these calls to keep the LED on and off for visible
    durations, effectively making the LED blink continuously.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过包含 `gpio.h` 头文件来访问在 `gpio.c` 中定义的 GPIO 函数。在 `main` 函数中，它首先调用 `led_init()`
    来初始化 PA5 为输出引脚。然后，它进入一个无限循环，通过分别调用 `led_on()` 和 `led_off()` 来交替打开和关闭 LED。我们在这些调用之间使用简单的延时循环，以使
    LED 在可见的时间内打开和关闭，从而有效地使 LED 连续闪烁。
- en: Proceed to build the project and run it on the development board. You should
    see the green LED blinking.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 继续构建项目并在开发板上运行它。你应该看到绿色 LED 在闪烁。
- en: In the next section, we shall develop the GPIO input driver using **PC13**.
    We are using **PC13** because the blue push button of the development board is
    connected to this pin.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开发使用**PC13**的GPIO输入驱动程序。我们使用**PC13**是因为开发板的蓝色按钮连接到这个引脚。
- en: The GPIO input driver
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO输入驱动程序
- en: 'Let’s start by analyzing the initialization function. Add this function to
    the `gpio.c` file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析初始化函数开始。将此函数添加到`gpio.c`文件中：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function enables clock access to GPIO port C and configures pin PC13 as
    an input pin:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数启用对GPIO端口C的时钟访问，并将引脚PC13配置为输入引脚：
- en: '**GPIOC->MODER**: This is the GPIO port mode register for port C. Each pair
    of bits in this register corresponds to the mode configuration of a specific pin.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOC->MODER**: 这是端口C的GPIO端口模式寄存器。此寄存器中的每一对位对应于特定引脚的模式配置。'
- en: '**Clearing bits 26 and 27**: The bits corresponding to pin 13 in the **GPIOC->MODER**
    register are bits **26** and **27**.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除位26和27**：对应于**GPIOC->MODER**寄存器中引脚13的位是位**26**和**27**。'
- en: The bitwise AND operator combined with the bitwise NOT operator (**&=~**) clears
    these bits, setting them to **00**. As we learned earlier, configuring these bits
    to **00** sets PC13 as an input pin.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按位与操作符与按位非操作符（**&=~**）结合使用，清除这些位，将它们设置为**00**。正如我们之前所学的，将这些位设置为**00**将PC13配置为输入引脚。
- en: 'Next, add the function for reading the state of the pin:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加读取引脚状态的函数：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function reads the state of the button. The button is internally connected
    as an active-low input. This means the pin reads at a low logic level (0) when
    the button is pressed and a high logic level (1) when it is not pressed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数读取按钮的状态。按钮内部连接为低电平有效输入。这意味着当按钮按下时，引脚读取低逻辑电平（0），而当按钮未按下时，引脚读取高逻辑电平（1）。
- en: '**GPIOC->IDR**: This is the input data register for GPIO port C. It holds the
    current state of all the pins in the port.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIOC->IDR**: 这是GPIO端口C的输入数据寄存器。它保存端口中所有引脚的当前状态。'
- en: '**Bitwise AND Operator (&)**: This checks whether the bit corresponding to
    **BTN_PIN** in the IDR register is set to high.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位与操作符（&）**: 这检查IDR寄存器中对应于**BTN_PIN**的位是否设置为高。'
- en: '`false`: If the bit is set, the button is not pressed'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`: 如果位被设置，则按钮未按下'
- en: '`true`: If the bit is not set, the button is pressed'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`true`: 如果位未设置，则按钮被按下'
- en: To be able to access these new functions from other files, such as `main.c`,
    we need to add their prototypes to the `gpio.h` file.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从其他文件，如`main.c`，访问这些新函数，我们需要将它们的原型添加到`gpio.h`文件中。
- en: 'Add the following lines to `gpio.h`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`gpio.h`中：
- en: '[PRE12]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let’s test the new functions by updating the `main.c` file to call them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过更新`main.c`文件以调用它们来测试新函数。
- en: 'The following is the updated `main.c` code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更新后的`main.c`代码：
- en: '[PRE13]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s break it down:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`bool btn_state`: This variable holds the state of the push button'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool btn_state`: 此变量保存按钮的状态'
- en: '`led_init()`: Configures PA5 as an output pin'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`led_init()`: 将PA5配置为输出引脚'
- en: '`button_init()`: Configures PC13 as an input pin'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`button_init()`: 将PC13配置为输入引脚'
- en: '`while(1){…}`:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while(1){…}`:'
- en: Continuously reads the state of the push button using `get_btn_state()`
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`get_btn_state()`持续读取按钮的状态
- en: Turns the LED on if the button is pressed (`btn_state` is true)
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按钮被按下（`btn_state`为true），则打开LED
- en: Turns the LED off if the button is not pressed (`btn_state` is false)
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果按钮未按下（`btn_state`为false），则关闭LED
- en: Build the project and run it on the development board. You should see the green
    LED light up only when you press the push button.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目并在开发板上运行它。你应该只在你按下按钮时看到绿色LED亮起。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the GPIO peripheral, a critical peripheral in microcontrollers
    that is essential for interfacing with various external components. We began by
    understanding the organization of GPIO ports and pins, covering both general-purpose
    and alternate functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了GPIO外设，这是微控制器中一个关键的外设，对于与各种外部组件进行接口至关重要。我们首先了解了GPIO端口和引脚的组织结构，涵盖了通用功能和备用功能。
- en: The STM32F411 microcontroller series features several ports, each equipped with
    registers to manage configuration, data handling, and functionality.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F411微控制器系列具有多个端口，每个端口都配备了用于管理配置、数据处理和功能的寄存器。
- en: We introduced the registers associated with the GPIO peripheral, including configuration
    registers such as `GPIOx_MODER`, `GPIOx_OTYPER`, `GPIOx_OSPEEDR`, and `GPIOx_PUPDR`,
    as well as data registers such as `GPIOx_IDR` and `GPIOx_ODR`. We also covered
    `GPIOx_BSRR` (bit-set/reset register) for atomic pin state control and `GPIOx_LCKR`
    (locking register) for preventing accidental configuration changes. Additionally,
    we explored the GPIO alternate function registers (`GPIOx_AFRL` and `GPIOx_AFRH`),
    which enable versatile pin usage by assigning specific peripheral functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了与GPIO外设相关的寄存器，包括配置寄存器，如`GPIOx_MODER`、`GPIOx_OTYPER`、`GPIOx_OSPEEDR`和`GPIOx_PUPDR`，以及数据寄存器，如`GPIOx_IDR`和`GPIOx_ODR`。我们还涵盖了`GPIOx_BSRR`（位设置/重置寄存器）用于原子引脚状态控制和`GPIOx_LCKR`（锁定寄存器）用于防止意外配置更改。此外，我们还探讨了GPIO复用功能寄存器（`GPIOx_AFRL`和`GPIOx_AFRH`），通过分配特定的外设功能，这些寄存器能够实现引脚的灵活使用。
- en: In practical terms, we developed both output and input drivers. We first created
    an output driver using the `GPIOx_BSRR` register to control the LED connected
    to pin PA5\. This involved setting up the necessary macros, implementing initialization
    and control functions, and testing the driver by making the LED blink. We then
    developed an input driver for reading the state of the push button connected to
    pin PC13\. This included configuring PC13 as an input pin, implementing a function
    to read the button state, and testing the driver by making the LED respond to
    button presses.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，我们开发了输出和输入驱动程序。我们首先使用`GPIOx_BSRR`寄存器创建了一个输出驱动程序来控制连接到PA5引脚的LED。这包括设置必要的宏、实现初始化和控制函数，并通过使LED闪烁来测试驱动程序。然后，我们为连接到PC13引脚的按钮开发了一个输入驱动程序来读取其状态。这包括将PC13配置为输入引脚、实现读取按钮状态的函数，并通过使LED对按钮按下做出响应来测试驱动程序。
- en: 'In the next chapter, we shall explore another important peripheral: the **system
    tick** (**SysTick**) timer.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个重要的外设：**系统滴答**（**SysTick**）定时器。
