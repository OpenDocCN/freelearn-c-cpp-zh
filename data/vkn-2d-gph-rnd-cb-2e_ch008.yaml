- en: 7 Advanced PBR extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 高级 PBR 扩展
- en: Join our book community on Discord
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 书籍社区
- en: '![](img/file40.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/file40.png)'
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: In this chapter, we will delve into advanced glTF PBR extensions that build
    upon the base metallic-roughness model. While the base metallic-roughness model
    provides a starting point, it falls short of capturing the full spectrum of real-life
    materials. To address this, glTF incorporates additional material layers, each
    with specific parameters that define their unique behaviors. Our goal here is
    to guide you through implementing these layers from the ground up. We will introduce
    the concept of layers, break down some mathematical principles behind them, and
    then show you how to integrate each layer into the GLSL shader code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨基于基础金属-粗糙度模型的 glTF 高级 PBR 扩展。虽然基础金属-粗糙度模型提供了一个起点，但它无法完全捕捉现实生活材料的全谱。为了解决这个问题，glTF
    引入了额外的材质层，每个层都有特定的参数来定义其独特的表现。我们的目标是引导你从零开始实现这些层。我们将介绍层的概念，分解它们背后的某些数学原理，然后展示如何将每一层集成到
    GLSL 着色器代码中。
- en: Most of the C++ code provided in this chapter is applicable across all the recipes
    we will cover here and throughout the rest of our book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供的 C++ 代码大多适用于我们在这里和本书其余部分将要涵盖的所有食谱。
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下食谱：
- en: Introduction to glTF PBR extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: glTF PBR 扩展简介
- en: Implementing the `KHR_materials_clearcoat` extension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_clearcoat` 扩展
- en: Implementing the `KHR_materials_sheen` extension
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_sheen` 扩展
- en: Implementing the `KHR_materials_transmission` extension
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_transmission` 扩展
- en: Implementing the `KHR_materials_volume` extension
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_volume` 扩展
- en: Implementing the `KHR_materials_ior` extension
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_ior` 扩展
- en: Implementing the `KHR_materials_specular` extension
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_specular` 扩展
- en: Implementing the `KHR_materials_emissive_strength` extension
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `KHR_materials_emissive_strength` 扩展
- en: Extending analytical lights support with `KHR_lights_punctual`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `KHR_lights_punctual` 扩展增强分析光支持
- en: Our GLSL shaders code is based on the official Khronos Sample Viewer and serves
    as an example implementation of these extensions.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们的 GLSL 着色器代码基于官方的 Khronos 示例查看器，并作为这些扩展的示例实现。
- en: Introduction to glTF PBR extensions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: glTF PBR 扩展简介
- en: In this recipe, we will explore the design approach for PBR Material extensions,
    offering plenty of context to help you implement various glTF PBR extensions.
    The actual code will be shared in subsequent recipes, with the chapter structure
    following the sequence in which Khronos developed these PBR extensions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨 PBR 材料扩展的设计方法，提供丰富的上下文来帮助你实现各种 glTF PBR 扩展。实际代码将在后续食谱中分享，章节结构将遵循
    Khronos 开发这些 PBR 扩展的顺序。
- en: PBR specifications evolve rapidly, and the reader should be aware that some
    extensions may become deprecated or obsolete by the time of reading.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PBR 规范迅速发展，读者应意识到，到阅读时，一些扩展可能会被弃用或过时。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: We assume our readers have some basic understanding of linear algebra and calculus.
    It is recommended to have the glTF 2.0 list of ratified extensions specification
    at hand which can be found at [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者对线性代数和微积分有一些基本了解。建议手头备有 glTF 2.0 认可的扩展规范列表，可以在 [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)
    找到。
- en: How is the glTF 2.0 PBR model designed?
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: glTF 2.0 PBR 模型是如何设计的？
- en: In the previous chapter, we explored the core Metallic-Roughness PBR model.
    This model is great for depicting many types of metallic and non-metallic materials,
    but the real world is much more complex.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了核心的金属-粗糙度 PBR 模型。这个模型非常适合描绘多种金属和非金属材质，但现实世界要复杂得多。
- en: To better capture that complexity, Khronos decided not to simply extend the
    Metallic-Roughness model. Instead, they introduced a layered approach, much like
    the layers of an onion. This method lets you gradually add complexity to the PBR
    material, similar to how layers are built up in Adobe Standard Surface [https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface](https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地捕捉这种复杂性，Khronos决定不仅仅扩展金属-粗糙度模型。相反，他们引入了一种分层方法，就像洋葱的层一样。这种方法允许你逐渐向PBR材料添加复杂性，类似于如何在Adobe标准表面[https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface](https://github.com/Autodesk/standard-surfacehttps://github.com/Autodesk/standard-surface)中构建层。
- en: '**Layering** mimics real-world material structures by stacking multiple layers,
    each with its own light-interacting properties. To maintain physical accuracy,
    the first layer, called the base layer, should be either fully opaque (like metallic
    surfaces) or completely transparent (like glass or skin). After that, additional
    layers, known as dielectric slabs, can be added on top of that one by one.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**分层**通过堆叠多个层来模拟现实世界的材料结构，每个层都有其自己的光交互属性。为了保持物理准确性，第一层，称为基层，应该是完全不透明（如金属表面）或完全透明（如玻璃或皮肤）。之后，可以逐个添加额外的层，称为电介质板。'
- en: When light hits the boundary between two layers, it can reflect and bounce back
    in the opposite direction. However, our main concern here is the light that continues
    to move through the material stack. As this light passes through the lower layers,
    it may be absorbed by the material.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当光线击中两层之间的边界时，它可以反射并反弹到相反的方向。然而，我们在这里的主要关注点是继续通过材料堆栈的光线。当这束光穿过底层时，它可能被材料吸收。
- en: The mixing operation provides a unique method for material modeling. You can
    think of it as a statistically weighted blend of two different materials, where
    you combine a certain percentage of material `A` with a certain percentage of
    material `B`. While this technique is great for creating new materials, it is
    important to remember that not all combinations are physically realistic. For
    example, mixing oil and water wouldn’t produce a believable material.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 混合操作为材料建模提供了一种独特的方法。你可以将其视为两种不同材料的统计加权混合，其中你将一定比例的材料`A`与一定比例的材料`B`相结合。虽然这种技术在创造新材料方面非常出色，但重要的是要记住，并非所有组合都是物理上现实的。例如，混合油和水不会产生可信的材料。
- en: When the mixing operation is done as a linear interpolation, it naturally follows
    the principle of energy conservation. This means that the total energy within
    the resulting material stays the same, consistent with the basic laws of physics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合操作以线性插值的方式进行时，它自然遵循能量守恒的原则。这意味着结果材料中的总能量保持不变，与物理学的基本定律一致。
- en: '![Figure 7.1: glTF PBR layering and mixing](img/file51.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：glTF PBR分层和混合](img/file51.png)'
- en: 'Figure 7.1: glTF PBR layering and mixing'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：glTF PBR分层和混合
- en: 'In the following recipes, we will dive into several advanced material layers:
    specular retro-reflection (sheen), coating specular reflection, and diffuse transmission.
    We will also explore how these layers can be combined to create a broader range
    of material appearances.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下配方中，我们将深入了解几个高级材料层：镜面反光（光泽）、涂层镜面反射和漫反射透射。我们还将探讨如何将这些层组合起来以创建更广泛的外观材料。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This chapter uses a single glTF viewer sample code for all the recipes. The
    `main.cpp` file varies across recipes in only two ways: they use different model
    files to demonstrate the specific glTF PBR extensions covered and the initial
    camera positions are adjusted to showcase the models attractively.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用单个glTF查看器示例代码来展示所有配方。`main.cpp`文件在配方之间只有两种变化：它们使用不同的模型文件来演示所涵盖的特定glTF PBR扩展，并且初始相机位置被调整以展示模型的美观。
- en: The source code for the glTF Viewer itself resides in the file `shared/UtilsGLTF.cpp`.
    The corresponding GLSL vertex and fragment shaders are located in the `data/shaders/gltf/`
    folder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: glTF查看器的源代码本身位于文件`shared/UtilsGLTF.cpp`中。相应的GLSL顶点和片段着色器位于`data/shaders/gltf/`文件夹中。
- en: The structure of these GLSL shaders differs from those covered in the previous
    chapter. We will explore the specific implementation differences in each of the
    individual recipes.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些GLSL着色器的结构不同于上一章中介绍的那些。我们将探索每个单独配方中的具体实现差异。
- en: How to do it…
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Let’s go over the main differences between our glTF Viewer implementation from
    the previous chapter and the newly proposed unified version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前一章中我们的 glTF 观察器实现和最新提出的统一版本之间的主要区别。
- en: We refactored the code and introduced a very basic structure in `shared/UtilsGLTF.h`
    to store all the necessary application data. This chapter will explain all the
    struct member fields.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重构了代码，并在 `shared/UtilsGLTF.h` 中引入了一个非常基本的结构来存储所有必要的应用程序数据。本章将解释所有结构成员字段。
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s introduce a very basic loading and rendering API for it. The `rebuildRenderList`
    argument signals that model-to-world transformations of glTF nodes should be rebuilt:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为它引入一个非常基本的加载和渲染 API。`rebuildRenderList` 参数表示应该重建 glTF 节点的模型到世界变换：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We expanded the GPU data structures to include the required material properties
    and added a new `enum` called `MaterialType`, which allows us to provide the material
    ID as needed. The previous *Chapter 6, Physically Based Rendering Using the glTF
    2.0 Shading Model* covered the old materials: unlit, metallic-roughness, and specular-glossiness.
    New materials will be covered here in this chapter in the subsequent recipes.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们扩展了 GPU 数据结构以包括所需的材质属性，并添加了一个名为 `MaterialType` 的新 `enum`，允许我们根据需要提供材质 ID。上一章
    *第 6 章，使用 glTF 2.0 着色模型的基于物理的渲染* 覆盖了旧材质：未光照、金属-粗糙度和镜面-光泽度。新材质将在本章后续的食谱中介绍。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ve added `3` different vector containers to keep lists of the glTF nodes:
    opaque, transparent and transmission. Here is the function `buildTransformsList()`
    to build node transformations and collect other nodes data:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了 `3` 个不同的向量容器来保存 glTF 节点的列表：不透明、透明和透射。以下是 `buildTransformsList()` 函数，用于构建节点变换并收集其他节点数据：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The body of our recursive traversal function is declared as a local C++ lambda.
    It collects all the transforms into `gltf.transforms` and adds opaque, transparent,
    and transmissive nodes to their corresponding containers:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的递归遍历函数的主体被声明为一个局部 C++ lambda。它将所有变换收集到 `gltf.transforms` 中，并将不透明、透明和透射节点添加到它们相应的容器中：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Push the index of the transform that was just added to `gltf.transforms` in
    the code block above.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚添加到 `gltf.transforms` 中的变换索引推送到上述代码块中。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Invoke the lambda to traverse the entire tree of glTF nodes starting from the
    root and store all the resulting transformations in a buffer:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 lambda 函数遍历从根节点开始的整个 glTF 节点树，并将所有结果变换存储在缓冲区中：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s add a node-sorting function to correctly render glTF nodes in the right
    order to support transparency. We’re using a very simple algorithm that sorts
    nodes based on the distance from the camera to the node’s center. To properly
    render transparent nodes, they should be rendered last, from back to front.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个节点排序函数，以正确渲染 glTF 节点并支持透明度。我们使用一个非常简单的算法，根据相机到节点中心的距离对节点进行排序。为了正确渲染透明节点，它们应该从后向前依次渲染。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have to change the actual rendering function `renderGLTF()` to accommodate
    all the changes mentioned above.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须更改实际的渲染函数 `renderGLTF()` 以适应上述所有更改。
- en: First, we have to update the transforms list and sort glTF nodes based on the
    distance to the current camera.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须更新变换列表并根据当前相机到 glTF 节点的距离对 glTF 节点进行排序。
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Store per-frame camera parameters and prepare push constants with all necessary
    buffers and textures:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储每帧的相机参数并准备所有必要的缓冲区和纹理的推送常量：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s render all opaque nodes. For this pass, no transmission framebuffer is
    required:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们渲染所有不透明节点。对于这个传递，不需要透射帧缓冲区：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We use the built-in GLSL variable `gl_BaseInstance` to pass the value of `transformId`
    into shaders. This way, we do not have to update push constants per each draw
    call. This is the most efficient way to do it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用内置的 GLSL 变量 `gl_BaseInstance` 将 `transformId` 的值传递到着色器中。这样，我们就不必为每个绘制调用更新推送常量。这是最有效的方法。
- en: The `firstInstance` parameter of `vkCmdDrawIndexed()` is assigned to the built-in
    GLSL variable `gl_BaseInstance`. This allows you to pass an arbitrary per-draw-call
    `uint32_t` value into vertex shaders without involving any buffers or push constants.
    This is a very fast technique and should be used whenever possible.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`vkCmdDrawIndexed()` 的 `firstInstance` 参数被分配给内置的 GLSL 变量 `gl_BaseInstance`。这允许你在不涉及任何缓冲区或推送常量的情况下，将任意每绘制调用的
    `uint32_t` 值传递到顶点着色器中。这是一个非常快速的技术，应该尽可能使用。'
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we should render transparent nodes on top of opaque ones. Some transparent
    nodes may require a screen copy to render various effects, such as volume or index-of-refraction.
    Here’s a very simple way to obtain it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在非透明节点之上渲染透明节点。一些透明节点可能需要屏幕拷贝来渲染各种效果，例如体积或折射率。这是一个非常简单的方法来获得它：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we start the next render pass and use the offscreen texture, we have to
    synchronize it properly:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们开始下一个渲染通道并使用离屏纹理时，我们必须正确同步它：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we render transmission nodes:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们渲染透射节点：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Transparent nodes come last. The same `gl_BaseInstance` trick is used to pass
    the value of `transformId` for each glTF mesh:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 透明节点最后处理。使用相同的 `gl_BaseInstance` 技巧传递每个 glTF 网格的 `transformId` 值：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once the command buffer is filled, we can submit it and use another offscreen
    texture in a round-robin manner.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦命令缓冲区被填满，我们就可以提交它，并以轮询方式使用另一个离屏纹理。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This was a complete overview of our generic glTF rendering code. The real magic
    happens inside the GLSL shaders. In the next recipes, we will go through the shaders
    step by step to learn how to implement different glTF material extensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们通用 glTF 渲染代码的完整概述。真正的魔法发生在 GLSL 着色器内部。在下一系列的菜谱中，我们将逐步学习如何实现不同的 glTF 材料扩展。
- en: There’s more...
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Khronos *3D Formats Working Group* is constantly working to improve PBR
    material capabilities by introducing new extension specifications. To stay up
    to date with the status of approved extensions, you can visit the Khronos GitHub
    page: [https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos *3D Formats Working Group* 正在通过引入新的扩展规范来不断改进 PBR 材料的功能。要了解已批准扩展的状态，您可以访问
    Khronos GitHub 页面：[https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/README.md)
- en: Implementing the KHR_materials_clearcoat extension
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 KHR_materials_clearcoat 扩展
- en: The **KHR_materials_clearcoat** extension improves glTF’s core **physically
    based rendering** (**PBR**) model by adding a clear, reflective layer on top of
    another material or surface. This layer reflects light both from itself and the
    layers underneath. Examples of this effect include the glossy finish on car paint
    or the shine of a well-polished shoe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**KHR_materials_clearcoat** 扩展通过在另一种材料或表面之上添加一个清晰、反射的层来改进 glTF 的核心 **基于物理的渲染**（**PBR**）模型。此层既反射来自自身的光线，也反射来自下层的光线。此效果包括汽车漆面的光泽效果或抛光鞋的光泽。'
- en: 'Here is a link to the Khronos glTF PBR extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接到 Khronos glTF PBR 扩展：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)
- en: Clearcoat parameters
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清漆参数
- en: 'The following parameters are provided by the `KHR_materials_clearcoat` extension:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参数由 `KHR_materials_clearcoat` 扩展提供：
- en: '*clearcoatFactor / clearcoatTexure*: This parameter indicates the intensity
    of the coating. It can be set using a scalar factor or a texture. A value of `0`
    means no coating, while a value of `1` indicates the presence of the coating.
    In-between values should be used only along the boundary between coated and uncoated
    areas.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*clearcoatFactor / clearcoatTexture*: 此参数表示涂层的强度。可以使用标量因子或纹理进行设置。`0` 的值表示没有涂层，而
    `1` 的值表示存在涂层。介于两者之间的值应仅用于涂层和非涂层区域之间的边界。'
- en: '*clearcoatNormalTexture:* This parameter allows a normal map to be applied
    to the coating layer, introducing variations and details to the coating surface.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*clearcoatNormalTexture:* 此参数允许将法线图应用于涂层层，为涂层表面引入变化和细节。'
- en: '*clearcoatRoughnessFactor / clearcoatRoughnessTexture:* This parameter indicates
    the coating roughness. It can be set as a roughness scalar factor or a roughness
    texture. It works similarly to the roughness parameter of a base material but
    is applied to the coating layer.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*clearcoatRoughnessFactor / clearcoatRoughnessTexture:* 此参数表示涂层的粗糙度。它可以设置为粗糙度标量因子或粗糙度纹理。它的工作方式与基材料的粗糙度参数类似，但应用于涂层层。'
- en: Specular BRDF for the clearcoat layer
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清漆层的镜面 BRDF
- en: The specular BRDF for the clearcoat layer uses the specular term from the glTF
    2.0 Metallic-Roughness material. However, to maintain energy conservation within
    the material when using a simple layering function, a slight adjustment is applied.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 清漆层的镜面BRDF使用了glTF 2.0金属-粗糙度材质中的镜面项。然而，为了在使用简单的分层函数时在材料内部保持能量守恒，进行了一些微调。
- en: The microfacet Fresnel term is calculated using the `NdotV` term instead of
    the `VdotH` term, effectively ignoring the microscopic surface orientation within
    the clearcoat layer. This simplification is justified because clearcoat layers
    usually have very low roughness, meaning the microfacets are mostly aligned with
    the normal direction. As a result, `NdotV` becomes approximately equivalent to
    `NdotL`. This approach ensures energy conservation within the material through
    a simple layering function and keeps computations efficient by omitting the `VdotH`
    term.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微面Fresnel项使用`NdotV`项而不是`VdotH`项来计算，实际上忽略了清漆层内部的微观表面方向。这种简化是合理的，因为清漆层通常具有非常低的粗糙度，这意味着微面主要与法线方向对齐。因此，`NdotV`变得大约等同于`NdotL`。这种方法通过简单的分层函数确保材料内部的能量守恒，并通过省略`VdotH`项来保持计算效率。
- en: As explained in the previous chapter *Physically Based Rendering Using the glTF
    2.0 Shading Model*, `N` represents the normal vector at the surface point, `V`
    is the vector pointing from the surface to the viewer, `L` is the vector pointing
    from the surface point to the light source, and `H` is the half-vector that lies
    exactly between the directions of the light source `L` and the viewer `V`.
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如前一章*使用glTF 2.0着色模型的物理渲染*中所述，`N`代表表面点的法向量，`V`是从表面指向观察者的向量，`L`是从表面点指向光源的向量，而`H`是位于光源`L`和观察者`V`方向之间的半向量。
- en: 'The provided implementation of the `clearcoat` layer within the BRDF framework
    makes certain assumptions that neglect some real-world material properties. Here’s
    a breakdown of these limitations:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在BRDF框架内提供的`clearcoat`层实现中，做出了一些假设，这些假设忽略了某些现实世界的材料属性。以下是这些限制的分解：
- en: '**Infinitely Thin Layer**: The clearcoat layer is treated as infinitely thin,
    disregarding its actual thickness.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无限薄的层**：清漆层被视为无限薄，忽略了其实际厚度。'
- en: '**Neglecting Refraction**: Refraction, bending of light as it passes through
    the clearcoat layer, is not taken into account.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略折射**：折射，即光通过清漆层时的弯曲，没有被考虑在内。'
- en: '**Independent Fresnel Terms**: The refractive indices of the clearcoat and
    base layers are treated as independent, with their Fresnel terms calculated separately,
    without accounting for any interaction between them.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立的Fresnel项**：清漆层和底层的折射率被视为独立，它们的Fresnel项分别计算，不考虑它们之间的任何相互作用。'
- en: '**Omitted Scattering**: The current model does not account for light scattering
    between the clearcoat layer and the base layer.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**省略的散射**：当前模型没有考虑清漆层和底层之间的光散射。'
- en: '**Diffraction Ignored:** Diffraction effects, the slight bending of light around
    the edges of microscopic facets, are not taken into account.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略衍射**：衍射效应，即光在微观面边缘的轻微弯曲，没有被考虑在内。'
- en: Despite these limitations, the clearcoat BRDF is a valuable tool for simulating
    clear coat effects in material modeling. It strikes a good balance between computational
    efficiency and producing visually plausible results, especially for clearcoat
    layers with low roughness.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些限制，但清漆层BRDF在材料建模中模拟清漆效果是一个有价值的工具。它在计算效率和产生视觉上可信的结果之间取得了良好的平衡，特别是对于低粗糙度的清漆层。
- en: Important notice
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要通知
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The clearcoat extension is designed to work with glTF’s core PBR shading model
    and is not compatible with other shading models like Unlit or Specular-glossiness.
    However, it can still be used alongside other PBR parameters, such as emissive
    materials, where the emitted light is influenced by the clearcoat layer.
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清漆扩展旨在与glTF的核心PBR着色模型一起工作，并且与Unlit或Specular-glossiness等其他着色模型不兼容。然而，它仍然可以与其他PBR参数一起使用，例如发射材料，其中发射的光受到清漆层的影响。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/01_Clearcoat/`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码可以在`Chapter07/01_Clearcoat/`中找到。
- en: How to do it…
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let’s take a look at the C++ code in `Chapter07/01_Clearcoat/src/main.cpp`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Chapter07/01_Clearcoat/src/main.cpp`中的C++代码。
- en: 'First, let’s load a `.gltf` file using our new glTF API:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用我们新的glTF API加载一个`.gltf`文件：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we render it using the `renderGLTF()` function described in the previous
    recipe *Introduction to glTF PBR extensions*:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用之前菜谱 *glTF PBR 扩展简介* 中描述的 `renderGLTF()` 函数进行渲染：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To load clearcoat parameters from a `.gltf` file, we have to introduce some
    changes to our GLTF material loader. Let’s take a look at the steps required to
    do it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `.gltf` 文件中加载 clearcoat 参数，我们必须对我们的 GLTF 材料加载器进行一些更改。让我们看看完成此操作所需的步骤。
- en: 'First, we should add some new member fields to the `GLTFMaterialDataGPU` structure
    in the file `shared/UtilsGLTF.h` to store scalar values and corresponding textures:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该在文件 `shared/UtilsGLTF.h` 中的 `GLTFMaterialDataGPU` 结构体中添加一些新的成员字段来存储标量值和相应的纹理：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s load textures and properties using the Assimp library in `shared/UtilsGLTF.cpp`.
    Here we emphasize only the properties related to the clearcoat extension:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 Assimp 库在 `shared/UtilsGLTF.cpp` 中加载纹理和属性。在这里，我们只强调与 clearcoat 扩展相关的属性：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Please note that we only set the `MaterialType_ClearCoat` flag if the checks
    pass and the extension is present in the `.gltf` file. While it’s technically
    possible to enable the clearcoat layer all the time — since the default settings
    effectively disable it — doing so is highly inefficient. The clearcoat layer adds
    secondary BRDF sampling, which is computationally expensive. It is better to use
    only the expensive features that are actually needed!
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，我们只有在检查通过并且扩展存在于 `.gltf` 文件中时才设置 `MaterialType_ClearCoat` 标志。虽然从技术上讲，始终启用
    clearcoat 层是可能的——因为默认设置实际上禁用了它——但这样做效率非常低。clearcoat 层增加了二级 BRDF 样本，这计算成本很高。最好只使用实际需要的昂贵功能！
- en: 'That’s it for the C++ changes. Now, let’s look at the GLSL shader changes,
    where the actual rendering work takes place:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 的更改到此为止。现在，让我们看看 GLSL 着色器更改，实际的渲染工作就在这里进行：
- en: 'Similar to the C++ changes for new parameters, we added GLSL utility functions
    to read clearcoat data from textures and input buffers in `data/shaders/gltf/inputs.frag`.
    The clearcoat factor and roughness are packed into a texture as `r` and `g` channels
    respectively:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与为新参数进行的 C++ 更改类似，我们在 `data/shaders/gltf/inputs.frag` 中添加了 GLSL 工具函数，用于从纹理和输入缓冲区中读取
    clearcoat 数据。clearcoat 因子和粗糙度分别打包到纹理的 `r` 和 `g` 通道中：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We calculate the clearcoat contribution as described in the beginning of this
    recipe. We use the GGX BRDF to perform an additional lookup and provide clearcoat
    roughness, reflectance `clearcoatF0`, and normal as inputs in `data/shaders/gltf/main.frag`.
    Please note that we use the IOR parameter, which will be covered later in the
    recipe *Implementing the IOR extension*:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照本菜谱开头描述的方法计算 clearcoat 贡献。我们使用 GGX BRDF 进行额外的查找，并在 `data/shaders/gltf/main.frag`
    中提供 clearcoat 粗糙度、反射率 `clearcoatF0` 和法线作为输入。请注意，我们使用了 IOR 参数，它将在菜谱 *实现 IOR 扩展*
    中稍后介绍：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We calculate the Fresnel term for the clearcoat layer using a similar approach.
    We apply the Schlick approximation, but with input data specific to the clearcoat:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用类似的方法计算 clearcoat 层的 Fresnel 项。我们应用 Schlick 近似，但使用针对 clearcoat 的特定输入数据：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, at the very end of the fragment shader `data/shaders/gltf/main.frag`,
    we apply the clearcoat contribution on top of all layers, including emissive ones!
    Note the `sheenColor` value here, which will be covered in the next recipe *Implementing
    the sheen material extension*.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在片段着色器 `data/shaders/gltf/main.frag` 的最后，我们在所有层（包括发射层）之上应用 clearcoat 贡献！注意这里的
    `sheenColor` 值，它将在下一道菜谱 *实现 sheen 材料扩展* 中介绍。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This concludes all the necessary GLSL changes to implement the clearcoat extension.
    The demo app should look like the screenshot below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了实现 clearcoat 扩展所需的所有必要的 GLSL 更改。演示应用应该看起来像下面的截图：
- en: '![Figure 7.2: glTF PBR KHR_materials_clearcoat example](img/file52.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：glTF PBR KHR_materials_clearcoat 示例](img/file52.png)'
- en: 'Figure 7.2: glTF PBR KHR_materials_clearcoat example'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：glTF PBR KHR_materials_clearcoat 示例
- en: Notice the glossy layer on top of the ball—this is the clearcoat! Congratulations,
    we’ve completed our first advanced PBR extension.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意球体顶部的光泽层——这就是 clearcoat！恭喜你，我们已经完成了我们的第一个高级 PBR 扩展。
- en: There’s more...
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Khronos glTF extensions repository includes a comprehensive list of references
    for clearcoat materials: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos glTF 扩展存储库包括清晰涂层材料的综合参考列表：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)
- en: Implementing the KHR_materials_sheen extension
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 KHR_materials_sheen 扩展
- en: The `KHR_materials_sheen` extension improves the glTF 2.0 Metallic-Roughness
    material by adding a layer that simulates the sheen effect found on fabrics like
    satin or brushed metals. This enhancement creates more realistic and visually
    appealing sheen highlights.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_sheen` 扩展通过添加模拟丝绸或刷金属等织物上光泽效果的层来改进 glTF 2.0 金属-粗糙度材质。这种增强创造了更真实和视觉上吸引人的光泽高光。'
- en: '**Sheen BRDF** sits on top of the glTF 2.0 Metallic-Roughness material. If
    the previous extension `KHR_materials_clearcoat` is also active, it is layered
    on top of the sheen effect.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sheen BRDF** 位于 glTF 2.0 金属-粗糙度材质之上。如果之前的扩展 `KHR_materials_clearcoat` 也处于活动状态，它将叠加在光泽效果之上。'
- en: The `sheenColorFactor` property controls the base intensity of the sheen effect,
    independent of the viewing angle. A value of `0` disables **sheen** entirely.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`sheenColorFactor` 属性控制光泽效果的基本强度，独立于观察角度。值为 `0` 将完全禁用 **光泽**。'
- en: Sheen parameters
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光泽参数
- en: '*sheenColorTexture / sheenColorFactor*: If the texture is defined, the sheen
    color is calculated by multiplying `sheenColorFactor` and the texture’s RGB value.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*sheenColorTexture / sheenColorFactor*: 如果定义了纹理，光泽颜色通过将 `sheenColorFactor`
    与纹理的 RGB 值相乘来计算。'
- en: '*sheenRoughnessTexture / sheenRoughnessFactor:* If defined, the sheen roughness
    is calculated by multiplying with the texture’s alpha channel value.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*sheenRoughnessTexture / sheenRoughnessFactor:* 如果定义了，光泽粗糙度通过乘以纹理的 alpha 通道值来计算。'
- en: If no textures are specified, `sheenColorFactor` directly controls the sheen
    color, and `sheenRoughnessFactor` directly controls sheen roughness.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定纹理，`sheenColorFactor` 直接控制光泽颜色，而 `sheenRoughnessFactor` 直接控制光泽粗糙度。
- en: Simulating the sheen effect
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟光泽效果
- en: 'The **sheen BRDF** simulates how light scatters off velvet-like materials.
    It models how light bounces off tiny fibers that are oriented perpendicular to
    the surface. Sheen roughness controls how much these fibers deviate from that
    direction:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**sheen BRDF** 模拟了光线从绒面材料上散射的方式。它模拟了光线如何从垂直于表面的微小纤维上反射。光泽粗糙度控制这些纤维偏离该方向的程度：'
- en: 'Lower sheen roughness: the fibers are more aligned, creating a sharper sheen
    highlight when light grazes the surface.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低的光泽粗糙度：纤维更整齐，当光线掠过表面时，会创建更锐利的光泽高光。
- en: 'Higher sheen roughness: the fibers are more scattered, leading to a softer
    sheen highlight.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较高的光泽粗糙度：纤维更分散，导致更柔和的光泽高光。
- en: The sheen BRDF is mathematically based on an exponentiated sinusoidal distribution,
    derived from the microfacet theory (Conty & Kulla, 2017 [https://blog.selfshadow.com/publications/s2017-shading-course/#course_content](https://blog.selfshadow.com/publications/s2017-shading-course/#course_content)).
    The roughness is mapped using `r=sheenRoughness^2` for a more intuitive understanding
    of roughness changes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 光泽 BRDF 在数学上基于指数正弦分布，该分布源自微面理论（Conty & Kulla，2017 [https://blog.selfshadow.com/publications/s2017-shading-course/#course_content](https://blog.selfshadow.com/publications/s2017-shading-course/#course_content)）。粗糙度通过
    `r=sheenRoughness^2` 映射，以便更直观地理解粗糙度变化。
- en: Sheen roughness operates independently of the material’s base roughness. This
    makes it possible for a material to have a rough surface texture (high base roughness)
    while still displaying a sharp sheen effect (low sheen roughness).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 光泽粗糙度独立于材质的基本粗糙度。这使得材质可以具有粗糙的表面纹理（高基本粗糙度），同时仍然显示出锐利的光泽效果（低光泽粗糙度）。
- en: Not all incoming light interacts with the microfibers. Some light may directly
    reach the base layer or bounce between the fibers before doing so. The behavior
    of this light is governed by the underlying glTF 2.0 PBR Metallic-Roughness material
    properties.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有入射光都与微纤维相互作用。一些光可能直接到达底层，或者在与纤维碰撞之前在其之间反射。这种光的行为受底层 glTF 2.0 PBR 金属-粗糙度材质属性的控制。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/02_Sheen/`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可在 `Chapter07/02_Sheen/` 中找到。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: Similar to the previous recipe *Implementing the clear coat material extension*,
    we introduce a bunch of new material parameters . Let’s take a look at the C++
    code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的小节 *实现清漆材质扩展* 类似，我们引入了一组新的材质参数。让我们看看 C++ 代码。
- en: 'Let’s load a `.gltf` file to demonstrate the effect `Chapter07/02_Sheen/src/main.cpp`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们加载一个 `.gltf` 文件来演示效果 `Chapter07/02_Sheen/src/main.cpp`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the file `shared/UtilsGLTF.h`, we added new member fields to the `GLTFMaterialDataGPU`
    structure in:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件 `shared/UtilsGLTF.h` 中，我们在 `GLTFMaterialDataGPU` 结构体中添加了新的成员字段：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s load new parameters via Assimp in `shared/UtilsGLTF.cpp` and store them
    into the sheen material. The sheen color texture is `sRGB` and has the index `0`
    and the roughness texture has the index of `1`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过 Assimp 在 `shared/UtilsGLTF.cpp` 中加载新的参数并将它们存储到光泽度材质中。光泽度颜色纹理是 `sRGB`，索引为
    `0`，粗糙度纹理的索引为 `1`：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we follow the same pattern as with the clearcoat extension and
    set the flag `MaterialType_Sheen` only when we use this extension. This is it
    for the main C++ code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们遵循与清漆扩展相同的模式，并且仅在使用此扩展时设置标志 `MaterialType_Sheen`。这就是主要的 C++ 代码。
- en: The Sheen extension needs a different BRDF function, which was discussed in
    the recipe *Precomputing BRDF look-up tables* of the previous *Chapter 6, Physically
    Based Rendering Using the glTF 2.0 Shading Model*. We recommend reviewing that
    recipe to refresh your understanding of how precomputed BRDF LUTs work and revisiting
    the implementation details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 光泽度扩展需要一个不同的 BRDF 函数，这在之前的 *第 6 章，使用 glTF 2.0 着色模型进行基于物理的渲染* 中的 *预计算 BRDF 查找表*
    小节中讨论过。我们建议回顾那个小节以刷新您对预计算 BRDF LUT 工作原理的理解，并重新审视实现细节。
- en: 'Now let’s take a look at the GLSL shader code changes which follow a similar
    pattern:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看遵循类似模式的 GLSL 着色器代码更改：
- en: 'Let’s introduce some utility functions in `data/shaders/gltf/inputs.frag`.
    We can simplify these functions by pre-multiplying textures values by sheen factors.
    In the C++ code, we set `sheenColorTexture` and `sheenRoughnessTexture` to use
    a white 1x1 texture in case when no texture data is provided in the `.gltf` asset.
    In this case, it is always correct to multiply these values by identity factors.
    We still perform a texture lookup for this small texture, but the overhead is
    minimal. These small textures should always fit into the GPU’s fastest cache:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `data/shaders/gltf/inputs.frag` 中引入一些实用函数。我们可以通过预先乘以光泽度因子来简化这些函数。在 C++
    代码中，我们将 `sheenColorTexture` 和 `sheenRoughnessTexture` 设置为使用白色 1x1 纹理，以防在 `.gltf`
    资产中没有提供纹理数据。在这种情况下，总是正确地将这些值乘以单位因子。我们仍然会对这个小型纹理进行纹理查找，但开销最小。这些小型纹理应该始终适合 GPU 的最快缓存：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The GLSL code of the sheen extension is scattered between the main fragment
    shader `data/shaders/gltf/main.frag` and the PBR module `data/shaders/gltf/PBR.sp`.
    In `main.frag`, we apply sheen parameters:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光泽度扩展的 GLSL 代码分散在主片段着色器 `data/shaders/gltf/main.frag` 和 PBR 模块 `data/shaders/gltf/PBR.sp`
    之间。在 `main.frag` 中，我们应用光泽度参数：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the next step during IBL calculations, we accumulate the sheen contribution
    calculated using the Charlie distribution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IBL 计算的下一步中，我们累积使用 Charlie 分布计算的光泽度贡献：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s take a look at the implementation of `getIBLRadianceCharlie()` in the
    file `data/shaders/gltf/PBR.sp`. This function is similar to `getIBLRadianceGGX()`
    used for metallic-roughness, but is much simpler. The Sheen extension provides
    its own roughness value, so no perceptual adjustments are needed. All we have
    to do here is to multiply `sheenRoughnessFactor` by the total number of mip-levels
    `mipCount` to determine the correct mip-level, sample the precalculated environment
    map, and then multiply it by the `BRDF` and `sheenColor`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看文件 `data/shaders/gltf/PBR.sp` 中 `getIBLRadianceCharlie()` 的实现。这个函数与用于金属-粗糙度的
    `getIBLRadianceGGX()` 类似，但更简单。光泽度扩展提供了自己的粗糙度值，因此不需要感知调整。我们在这里要做的只是将 `sheenRoughnessFactor`
    乘以总的米普级数 `mipCount` 以确定正确的米普级，采样预计算的环境图，然后将其乘以 `BRDF` 和 `sheenColor`。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s go back to `data/shaders/gltf/main.frag`. We modify the sheen contribution
    based on the value of `occlusionStrength`. Light’s The l sheen calculation `lights_sheen`
    will be covered in the last recipe *Extend analytical lights support* in this
    chapter. For now, assume it is just zero.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到 `data/shaders/gltf/main.frag`。我们根据 `occlusionStrength` 的值修改光泽度贡献。光的 l
    光泽度计算 `lights_sheen` 将在本章的最后一个小节 *扩展分析光支持* 中介绍。现在，假设它只是零。
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is all the additional code required to implement the Sheen extension.
    The running demo app should look as in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现 Sheen 扩展所需的所有额外代码。运行中的演示应用应该看起来如下截图所示：
- en: '![Figure 7.3: glTF PBR KHR_materials_sheen example](img/file53.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：glTF PBR KHR_materials_sheen 示例](img/file53.png)'
- en: 'Figure 7.3: glTF PBR KHR_materials_sheen example'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：glTF PBR KHR_materials_sheen 示例
- en: There’s more...
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Khronos glTF extensions repository has a comprehensive list of references
    to sheen materials: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos glTF 扩展存储库有一个关于 Sheen 材料的综合参考列表：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)。
- en: Implementing the KHR_materials_transmission extension
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 KHR_materials_transmission 扩展
- en: The glTF 2.0 core specification uses a basic method for handling transparency
    called **alpha-as-coverage**. While this approach works well for simple materials
    like gauze or burlap, it doesn’t do a good job of representing more complex transparent
    materials like glass or plastic. These materials involve complicated light interactions—such
    as reflection, refraction, absorption, and scattering—that alpha-as-coverage can’t
    accurately simulate on its own.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: glTF 2.0 核心规范使用了一种处理透明度的基本方法，称为 **alpha-as-coverage**。虽然这种方法对于像纱或麻布这样的简单材料效果很好，但它并不能很好地表示像玻璃或塑料这样的更复杂透明材料。这些材料涉及复杂的光学相互作用——如反射、折射、吸收和散射——而
    alpha-as-coverage 无法独立准确地模拟这些相互作用。
- en: Alpha-as-coverage basically decides if a surface is there or not. A value of
    `0` means nothing is visible, while a value of `1` means the surface is solid.
    This method works well for materials with holes or gaps that let light pass through
    without actually entering the material. However, for materials like glass, light
    interacts with the surface in more complex ways—like reflecting, refracting, or
    even being absorbed. Alpha-as-coverage can’t handle these kinds of interactions.
    Additionally, it affects how intense reflections are, making more transparent
    materials have weaker reflections. This is the opposite of what happens with real-world
    transparent materials, which often have strong reflections even when they’re see-through.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha-as-coverage 基本上决定了表面是否存在。值为 `0` 表示没有任何东西可见，而值为 `1` 表示表面是实心的。这种方法对于有孔或缝隙的材料效果很好，这些缝隙可以让光线通过而不实际进入材料。然而，对于像玻璃这样的材料，光线与表面的相互作用更为复杂——如反射、折射，甚至吸收。Alpha-as-coverage
    无法处理这些类型的相互作用。此外，它还会影响反射的强度，使得更透明的材料反射更弱。这与现实世界中的透明材料相反，后者即使在透明时也常常有强烈的反射。
- en: To overcome the limitations of alpha-as-coverage, the `KHR_materials_transmission`
    extension offers a more realistic way to render transparent materials in glTF.
    It allows for the simulation of materials that absorb, reflect, and transmit light
    depending on the angle of incidence and the light’s wavelength. This extension
    is especially useful for accurately representing thin-surface materials like plastic
    and glass.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服 alpha-as-coverage 的限制，`KHR_materials_transmission` 扩展提供了一种在 glTF 中更真实地渲染透明材料的方法。它允许根据入射角和光的波长来模拟吸收、反射和透射光线的材料。这个扩展对于准确表示像塑料和玻璃这样的薄表面材料特别有用。
- en: 'The `KHR_materials_transmission` extension targets the simplest cases of optical
    transparency: infinitely thin materials without refraction, scattering, or dispersion.
    This simplification enables efficient calculations of refraction and absorption.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_transmission` 扩展针对的是光学透明度最简单的情况：无限薄的、无折射、散射或色散的材料。这种简化使得折射和吸收的计算变得高效。'
- en: Transmission parameters
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透射参数
- en: 'The `KHR_materials_transmission` extension adds new properties to define material’s
    transmission characteristics:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_transmission` 扩展为定义材料的透射特性添加了新的属性：'
- en: '*transmissionFactor*: A scalar value between `0` and `1` that represents the
    material’s overall opacity. A value of `0` means the material is fully opaque,
    while a value of `1` means it is completely transparent.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*transmissionFactor*：一个介于 `0` 和 `1` 之间的标量值，表示材料的整体不透明度。值为 `0` 表示材料完全不透明，而值为
    `1` 表示材料完全透明。'
- en: '*transmissionFilter*: A color value that alters the color of the light passing
    through the material.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*transmissionFilter*：一个颜色值，会改变通过材料的灯光颜色。'
- en: Transmission BTDF
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透射 BTDF
- en: The `KHR_materials_transmission` extension introduces a specular **BTDF** (Bidirectional
    Transmission Distribution Function) based on the microfacet model. It uses the
    same **Trowbridge-Reitz** distribution as the specular **BRDF** (Bidirectional
    Reflectance Distribution Function) but samples along the view vector instead of
    the reflection direction. This method simulates how microfacets act like tiny
    prisms, blurring the transmitted light.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_transmission` 扩展引入了一个基于微facet 模型的镜面 **BTDF**（双向透射分布函数）。它使用与镜面
    **BRDF**（双向反射分布函数）相同的 **Trowbridge-Reitz** 分布，但沿着视向量而不是反射方向进行采样。这种方法模拟了微facet
    如何像微小的棱镜一样作用，使透射光变得模糊。'
- en: The transmission process is modeled as two back-to-back surfaces, representing
    a thin material. This approach simplifies the process by avoiding the complexities
    of average refraction and instead focusing on refraction at the microfacet level.
    The roughness parameter affects both reflection and transmission since the microfacet
    distribution impacts both sides of the surface. Let’s take a look at how to implement
    this glTF extension.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 透射过程被建模为两个背对背的表面，代表一种薄材料。这种方法通过避免平均折射的复杂性，而是专注于微facet 层的折射，简化了过程。粗糙度参数影响反射和透射，因为微facet
    分布影响表面的两侧。让我们看看如何实现这个 glTF 扩展。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/03_Transmission/`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码位于 `Chapter07/03_Transmission/`。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: This is the most complex extension discussed in this chapter, requiring changes
    to the C++ code to handle the complexities of transparency rendering. In addition
    to updating the C++ rendering code, we need to implement a specular BTDF in the
    GLSL shader code and incorporate the blending of two layers to accurately represent
    a thin material.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章讨论的最复杂的扩展，需要更改 C++ 代码以处理透明度渲染的复杂性。除了更新 C++ 渲染代码外，我们还需要在 GLSL 着色器代码中实现镜面
    BTDF，并将两层混合结合起来，以准确地表示薄材料。
- en: Let’s start with C++ changes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 C++ 代码更改开始。
- en: 'First, we should load a corresponding `.gltf` sample model in `Chapter07/03_Transmission/src/main.cpp`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该在 `Chapter07/03_Transmission/src/main.cpp` 中加载相应的 `.gltf` 样本模型：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The parameters parsing is in `shared/UtilsGLTF.cpp` and quite simple:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数解析在 `shared/UtilsGLTF.cpp` 中，相当简单：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Significant changes have been made to the rendering function `renderGLTF()`.
    We touched on some of these in the first recipe *Introduction to glTF PBR extensions*.
    Now, let’s take a closer look at these changes. To effectively render transparent
    and transmission surfaces, we need to follow these steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对渲染函数 `renderGLTF()` 已进行了重大更改。我们在第一个食谱 *glTF PBR 扩展简介* 中提到了一些这些更改。现在，让我们更详细地看看这些更改。为了有效地渲染透明和透射表面，我们需要遵循以下步骤：
- en: 'Prepare lists of completely opaque, transmission, and transparent nodes, because
    these should be rendered in a particular order: opaque nodes first, then transmission,
    and then transparent.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备完全不透明、透射和透明节点的列表，因为这些节点应该按照特定顺序渲染：首先是不透明节点，然后是透射，最后是透明节点。
- en: Keep in mind that rendering transmission nodes doesn’t automatically make them
    transparent! Instead, we need to use the result from rendering opaque nodes. To
    do this, we must create a copy of the rendered surface and use it as input for
    the transmission nodes.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请记住，渲染透射节点并不会自动使它们变得透明！相反，我们需要使用渲染不透明节点的结果。为此，我们必须创建渲染表面的副本，并将其用作透射节点的输入。
- en: 'Pre-allocate an offscreen texture to store the rendered opaque nodes:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预分配一个离屏纹理来存储渲染的不透明节点：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Create a screen copy when necessary and pass its handle as `transmissionFramebuffer:`
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在必要时创建屏幕副本，并将其句柄作为 `transmissionFramebuffer:` 传递。
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can render transmission nodes using the screen copy as input. It’s important
    to note that we’re not using alpha blending for this pass. The nodes are still
    rendered as opaque, and we simulate transparency by sampling the screen copy.
    We also specify a texture dependency for LightweightVK here to ensure the correct
    Vulkan barriers are applied:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用屏幕副本作为输入来渲染透射节点。重要的是要注意，我们在这个过程中不使用 alpha 混合。节点仍然以不透明的方式渲染，我们通过采样屏幕副本来模拟透明度。我们还在这里为
    LightweightVK 指定了一个纹理依赖项，以确保应用正确的 Vulkan 障碍：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to render all transparent nodes in back-to-front order. We
    did not change push constants and these transparent nodes use the same offscreen
    texture as input:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是按照前后顺序渲染所有透明节点。我们没有更改推送常量，这些透明节点使用与输入相同的离屏纹理：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is it for the C++ changes. Let’s take a look at the GLSL shader changes
    now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C++的更改就到这里。现在让我们看看GLSL着色器的更改。
- en: 'First, we introduce a utility function in `data/shaders/gltf/inputs.frag` to
    read material inputs. The transmission factor is stored in the `r` channel of
    the texture:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`data/shaders/gltf/inputs.frag`中引入一个实用函数来读取材料输入。传输因子存储在纹理的`r`通道中：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we populate inputs in `data/shaders/gltf/main.frag` if the transmission
    extension is enabled for this material:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果此材料的传输扩展被启用，我们在`data/shaders/gltf/main.frag`中填充输入：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We calculate the transmission contribution. The volumetric part will be covered
    in detail in our next recipe for the `KHR_materials_volume` extension *Implementing
    the volume extension*. In a pure transmission implementation without the volume
    extension, the transmission part would be similar to GGX/Lambertian, but instead
    of using the reflection vector, we use the dot product `NdotV`. Implementing just
    the transmission extension without volume support is not practical, as the volume
    extension offers greater flexibility to represent effects like refraction, absorption,
    or scattering without adding excessive complexity on top of transmission:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算传输贡献。体积部分将在我们关于`KHR_materials_volume`扩展的下一个配方中详细说明：*实现体积扩展*。在没有体积扩展的纯传输实现中，传输部分将与GGX/Lambertian类似，但不是使用反射向量，而是使用点积`NdotV`。仅实现传输扩展而不支持体积是不切实际的，因为体积扩展提供了更大的灵活性来表示折射、吸收或散射等效果，而不会在传输之上增加过多的复杂性：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we add the calculated transmission value to the diffuse contribution
    scaled by `transmissionFactor`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将计算出的传输值添加到由`transmissionFactor`缩放的漫反射贡献中：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The resulting rendered 3D model should look as in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的渲染3D模型应如下截图所示：
- en: '![Figure 7.4: glTF PBR KHR_materials_transmission example](img/file54.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：glTF PBR KHR_materials_transmission示例](img/file54.png)'
- en: 'Figure 7.4: glTF PBR KHR_materials_transmission example'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：glTF PBR KHR_materials_transmission示例
- en: There is more…
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Rendering transparent objects efficiently and accurately in real-time is challenging,
    particularly when dealing with overlapping transparent polygons. Issues such as
    order-dependent transparency and the need for separate blending operations for
    absorption and reflections add to the complexity. We will address some of these
    issues in *Chapter 11, Advanced Rendering Techniques and Optimizations*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时中高效且准确地渲染透明物体具有挑战性，尤其是在处理重叠的透明多边形时。依赖于顺序的透明度和需要为吸收和反射执行单独的混合操作等问题增加了复杂性。我们将在*第11章，高级渲染技术和优化*中解决一些这些问题。
- en: 'The Khronos extensions repository provides comprehensive reference materials
    for the transmission extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos扩展存储库为传输扩展提供了全面的参考材料：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)。
- en: Implementing the KHR_materials_volume extension
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现KHR_materials_volume扩展
- en: The `KHR_materials_volume` extension adds volumetric effects to the glTF 2.0
    ecosystem, enabling the creation of materials with depth and internal structure.
    It’s crucial for accurately rendering materials such as smoke, fog, clouds, and
    translucent objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_volume`扩展为glTF 2.0生态系统添加了体积效果，使得可以创建具有深度和内部结构的材料。这对于准确渲染烟雾、雾、云和半透明物体至关重要。'
- en: Volumetric effects are different from surface-based materials. While surface-based
    materials focus on how light interacts with a surface, volumetric materials describe
    how light moves through a medium. This includes simulating how light scatters
    and gets absorbed as it passes through the volume.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 体积效果与基于表面的材料不同。基于表面的材料关注光线与表面的相互作用，而体积材料描述光线通过介质的方式。这包括模拟光线在通过体积时的散射和吸收。
- en: To create realistic volumetric effects, the `KHR_materials_volume` extension
    needs to work alongside other extensions that define light interactions with the
    material’s surface. The `KHR_materials_transmission` extension is key here, as
    it lets light rays pass through the surface and enter the volume. Once inside,
    the light’s interaction with the material is no longer affected by the surface
    properties. Instead, the light travels through the volume, undergoing refraction
    and attenuation. When it exits the volume, its direction is determined by the
    angle at which it leaves the volume boundary.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建逼真的体积效果，`KHR_materials_volume` 扩展需要与其他定义材料表面与光线交互的扩展协同工作。`KHR_materials_transmission`
    扩展在这里是关键，因为它允许光线穿过表面并进入体积。一旦进入，光线与材料的交互不再受表面属性的影响。相反，光线穿过体积，经历折射和衰减。当它离开体积时，其方向由它离开体积边界的角度决定。
- en: Let’s explore how to add this extension to our glTF renderer.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何将此扩展添加到我们的 glTF 渲染器中。
- en: Volumetric parameters
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 体积参数
- en: 'The `KHR_materials_volume` extension defines the following parameters to describe
    a volumetric material:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_volume` 扩展定义以下参数来描述体积材料：'
- en: '**thicknessFactor**: A scalar floating-point value that represents the base
    thickness of the volume. This value is multiplied by the thickness texture value
    (if available) to determine the final thickness at any point on the surface.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thicknessFactor**：一个表示体积基础厚度的标量浮点值。此值乘以厚度纹理值（如果可用）以确定表面任何点的最终厚度。'
- en: '**attenuationDistance**: A floating-point value that indicates the distance
    over which the volume’s density decreases. This parameter controls how quickly
    the volume’s opacity fades as light passes through it.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**attenuationDistance**：一个表示体积密度随距离降低的距离的浮点值。此参数控制体积不透明度随光线通过而迅速减淡的速度。'
- en: '**attenuationColo***r*: A color value representing the base color of the volume’s
    attenuation. This color influences how light is absorbed as it travels through
    the volume.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**attenuationColor**：一个表示体积衰减的基础颜色的颜色值。此颜色影响光线在穿过体积时的吸收情况。'
- en: '**thicknessTexture**: An optional texture that adds extra detail about the
    volume’s thickness. The values in the texture are multiplied by the `thicknessFactor`
    to determine the final thickness at each point on the surface.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**thicknessTexture**：一个可选的纹理，它提供了关于体积厚度额外的细节。纹理中的值会乘以 `thicknessFactor` 以确定表面每个点的最终厚度。'
- en: 'Here’s how these parameters work together:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是如何一起工作的：
- en: '**Thickness**: The `thicknessFactor` and `thicknessTexture` are multiplied
    to define the volume’s depth. A higher thickness value results in a thicker volume.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thickness**：`thicknessFactor` 和 `thicknessTexture` 相乘以定义体积的深度。较高的厚度值会导致体积更厚。'
- en: '**Attenuation**: The `attenuationDistance` and `attenuationColor` control how
    light is absorbed as it travels through the volume. A smaller value of `attenuationDistance`
    leads to quicker attenuation. The value of `attenuationColor` determines the color
    change due to absorption.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Attenuation**：`attenuationDistance` 和 `attenuationColor` 控制光线在穿过体积时的吸收情况。`attenuationDistance`
    的较小值会导致更快的衰减。`attenuationColor` 的值决定了由于吸收而产生的颜色变化。'
- en: The `KHR_materials_volume` extension currently assumes a homogeneous volume,
    where the material properties are uniform throughout. Future extensions may add
    support for heterogeneous volumes with varying properties.
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目前，`KHR_materials_volume` 扩展假设体积是均匀的，其中材料属性在整个体积中是均匀的。未来的扩展可能会添加对具有不同属性的非均匀体积的支持。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/04_Volume/`. Please
    review the previous recipe *Implementing the transmission extension*, where we
    covered the transmission and volumetric C++ rendering flow.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的源代码可以在 `Chapter07/04_Volume/` 中找到。请查阅之前的菜谱 *实现传输扩展*，其中我们介绍了传输和体积 C++ 渲染流程。
- en: How to do it…
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: This extension requires only a handful of changes across our existing C++ and
    GLSL shader code. This extension requires `KHR_materials_transmission` support
    and works only in conjunction with it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展只需要在我们的现有 C++ 和 GLSL 着色器代码中进行少量更改。此扩展需要 `KHR_materials_transmission` 支持，并且仅与其一起工作。
- en: Let’s explore how to create advanced volumetric effects such as refraction,
    absorption, or scattering, starting with the C++.++. code
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用 C++.++ 代码创建高级体积效果，如折射、吸收或散射。
- en: 'First, we load a corresponding `.gltf` model in `Chapter07/04_Volume/main.cpp`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在 `Chapter07/04_Volume/main.cpp` 中加载相应的 `.gltf` 模型：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Parsing the volume parameters using Assimp in `shared/UtilsGLTF.cpp`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Assimp在`shared/UtilsGLTF.cpp`中解析体积参数：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Most of the magic is hidden in GLSL shaders. Let’s step inside `data/shaders/gltf/PBR.sp`
    and check important helper functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的魔法都隐藏在GLSL着色器中。让我们进入`data/shaders/gltf/PBR.sp`并检查重要的辅助函数。
- en: The function `getVolumeTransmissionRay()` calculates the direction of refracted
    light `refractionVector` and uses the `modelScale` factor to get an actual lookup
    vector inside a volume. Note that the `thickness` factor is designed to be normalized
    to the actual scale of the mesh.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`getVolumeTransmissionRay()`计算折射光线的方向`refractionVector`，并使用`modelScale`因子在体积内获取实际的查找向量。请注意，`thickness`因子被设计为归一化到网格的实际比例。
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Compute rotation-independent scaling of the model matrix. The `thickness` factor
    is specified in local space:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算模型矩阵的旋转无关缩放。`thickness`因子在局部空间中指定：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Another helper function is `getIBLVolumeRefraction()`. This function has several
    important steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个辅助函数是`getIBLVolumeRefraction()`。此函数有几个重要步骤：
- en: 'The first step is to get a transmission ray `transmissionRay` and calculate
    the final refraction position:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是获取一个透射光线`transmissionRay`并计算最终的折射位置：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We project the refracted vector onto the framebuffer and map it to normalized
    device coordinates to sample the color of the pixel where the refracted ray hits
    the framebuffer. The refracted framebuffer coordinates should be transformed from
    the `-1...+1` range into `0...1` and then flipped vertically:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将折射向量投影到帧缓冲区，并将其映射到归一化设备坐标以采样折射光线击中帧缓冲区的像素的颜色。折射的帧缓冲区坐标应从`-1...+1`范围转换为`0...1`，然后垂直翻转：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, we apply volume attenuation and sample GGX BRDF to get the specular
    component and modulate it by `baseColor` and `attenuatedColor`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们应用体积衰减并采样GGX BRDF以获取镜面分量，并通过`baseColor`和`attenuatedColor`对其进行调制：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here’s the function `getTransmissionSample()`. We use a copy of the framebuffer
    as we explained in the previous recipe *Implementing the transmission extension*:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是函数`getTransmissionSample()`。我们使用先前的配方*实现透射扩展*中解释的帧缓冲区副本：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The helper function `applyVolumeAttenuation()` looks as follows. The attenuation
    distance of `0` means the transmitted color is not attenuated at all. Light attenuation
    is computed using Beer-Lambert law [https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law](https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助函数`applyVolumeAttenuation()`看起来如下。`0`的衰减距离意味着透射颜色完全没有衰减。光衰减是使用Beer-Lambert定律计算的[https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law](https://en.wikipedia.org/wiki/Beer%E2%80%93Lambert_law)：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can go back to `data/shaders/gltf/main.frag` and use `getIBLVolumeRefraction()`,
    together with other helper functions as described in the previous recipe *Implementing
    the transmission extension*:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以回到`data/shaders/gltf/main.frag`并使用`getIBLVolumeRefraction()`，以及其他在先前的配方*实现透射扩展*中描述的辅助函数：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The resulting demo application should render a translucent dragon, similar to
    the screenshot below. You can move the camera around the dragon to observe how
    light interacts with the volume from different angles. This will allow you to
    see how the light passes through the medium and interacts with the volumetric
    material.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的演示应用程序应该渲染一个半透明的龙，类似于下面的截图。你可以围绕龙移动相机来观察光线从不同角度与体积的交互。这将允许你看到光线如何穿过介质并与体积材料交互。
- en: '![](img/file55.png)Figure 7.5: glTF PBR KHR_materials_volume example'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5: glTF PBR KHR_materials_volume示例](img/file55.png)'
- en: 'After we explored a range of complex PBR glTF extensions, it is time to switch
    gears. Let’s take a look at something a bit more straightforward: implementing
    the **Index-of-Refraction** extension. This simpler extension is a great way to
    continue building your understanding while giving you a break from the more complex
    topics we have covered.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索了一系列复杂的PBR glTF扩展之后，是时候转换方向了。让我们看看一些更直接的东西：实现**折射率**扩展。这个更简单的扩展是继续构建你的理解的好方法，同时让你从我们之前覆盖的更复杂主题中休息一下。
- en: There is more…
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An alternative way to implement this extension could involve volume ray-casting
    or ray-tracing. We leave that as an exercise for our readers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此扩展的另一种方法可能涉及体积光线投射或光线追踪。我们将此留作读者练习。
- en: 'The Khronos extensions repository provides comprehensive reference materials
    for this extension: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos 扩展存储库为此扩展提供了全面的参考材料：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#overview)。
- en: Implementing the KHR_materials_ior extension
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 KHR_materials_ior 扩展
- en: The `KHR_materials_ior` extension for glTF 2.0 adds the concept of **Index-of-Refraction**
    (**IOR**) to materials, allowing for more accurate and realistic simulations of
    transparent objects. IOR is a key material property that dictates how light bends
    when it passes through a substance [https://en.wikipedia.org/wiki/Refractive_index](https://en.wikipedia.org/wiki/Refractive_index).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: glTF 2.0 的 `KHR_materials_ior` 扩展为材质添加了**折射率**（**IOR**）的概念，允许更精确和逼真的透明物体模拟。折射率是关键材质属性，决定了光线通过物质时的弯曲程度
    [https://en.wikipedia.org/wiki/Refractive_index](https://en.wikipedia.org/wiki/Refractive_index)。
- en: The **IOR** is a dimensionless number that shows the ratio of the speed of light
    in a vacuum to its speed in a particular medium. Different materials have different
    IOR values, which influence how light bends when it enters or exits the material.
    A higher IOR means more refraction. For instance, the IOR of air is nearly `1`,
    water has an IOR of about `1.33`, and glass has an IOR of around `1.5`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**IOR** 是一个无量纲数，表示光在真空中速度与在特定介质中速度的比值。不同材料有不同的 IOR 值，这影响了光线进入或离开材料时的弯曲程度。较高的
    IOR 意味着更多的折射。例如，空气的 IOR 接近 `1`，水的 IOR 大约是 `1.33`，而玻璃的 IOR 大约是 `1.5`。'
- en: IOR parameters
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IOR 参数
- en: 'The `KHR_materials_ior` extension adds a single property to the glTF material
    definition:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_ior` 扩展向 glTF 材质定义添加了一个属性：'
- en: '*ior*: A floating-point value representing the index-of-refraction of the material.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*ior*：表示材料折射率的浮点值。'
- en: This value is used in conjunction with the `KHR_materials_transmission` extension
    to calculate the refraction direction of light rays when passing through the material.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此值与 `KHR_materials_transmission` 扩展结合使用，以计算光线通过材料时的折射方向。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/05_IOR/`. Check out
    the recipe *Implementing the transmission extension* to recap how `KHR_materials_transmission`
    is implemented.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的源代码可在 `Chapter07/05_IOR/` 中找到。查看菜谱 *实现传输扩展* 以回顾 `KHR_materials_transmission`
    的实现方式。
- en: How to do it…
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: This extension requires only a handful of changes across C++ and GLSL shader
    code. Let’s start with C++.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展只需对 C++ 和 GLSL 着色器代码进行少量更改。让我们从 C++ 开始。
- en: 'In `Chapter07/05_IOR/main.cpp`, load a corresponding `.gltf` model:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter07/05_IOR/main.cpp` 中，加载相应的 `.gltf` 模型：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here is the code in `shared/UtilsGLTF.cpp` for parsing the IOR material parameter
    with Assimp. You will notice that we don’t set any material flag, it’s not needed.
    IOR is just a value and does not alter the functionality of shaders.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 `shared/UtilsGLTF.cpp` 中用于使用 Assimp 解析 IOR 材质参数的代码。你会注意到我们没有设置任何材质标志，这不是必需的。IOR
    只是一个值，不会改变着色器的功能。
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here goes the GLSL shader code. We need to modify a couple lines:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 GLSL 着色器代码。我们需要修改几行：
- en: 'The first line is in the PBR module `data/shaders/gltf/PBR.sp` in the function
    `calculatePBRInputsMetallicRoughness()`. The default index of refraction value,
    `ior = 1.5`, results in the `f0` term being calculated as `0.04`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行在 PBR 模块 `data/shaders/gltf/PBR.sp` 中的函数 `calculatePBRInputsMetallicRoughness()`
    中。默认折射率值 `ior = 1.5` 导致 `f0` 项计算为 `0.04`：
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The second line is in `data/shaders/gltf/main.frag` and modifies the clearcoat
    reflectance value:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行在 `data/shaders/gltf/main.frag` 中，并修改了清漆反射率值：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That’s it! The application should now render a mosquito encased in a piece
    of amber, as shown in the following screenshot:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！应用程序现在应该可以渲染出被琥珀包裹的蚊子，如下面的截图所示：
- en: '![Figure 7.6: glTF PBR KHR_materials_ior example](img/file56.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6：glTF PBR KHR_materials_ior 示例](img/file56.png)'
- en: 'Figure 7.6: glTF PBR KHR_materials_ior example'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6：glTF PBR KHR_materials_ior 示例
- en: There is more…
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The official extension specification includes a normative section that explains
    how this glTF extension `KHR_material_ior` interacts with other extensions: [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 官方扩展规范包括一个规范性部分，解释了此glTF扩展`KHR_material_ior`如何与其他扩展交互：[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)。
- en: Implementing the KHR_materials_specular extension
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现KHR_materials_specular扩展
- en: In the previous chapter, we discussed the **Specular-Glossiness** PBR model.
    One of its main issues is the lack of compatibility with most other extensions.
    This is because it introduces non-physically based material properties, including
    an unclear distinction between dielectrics and metals in specular-glossiness mode,
    which makes it impossible to combine with the metallic-roughness model or other
    extension properties.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**镜面-光泽度**PBR模型。其主要问题之一是与大多数其他扩展不兼容。这是因为它引入了非物理基础的材料属性，包括在镜面-光泽度模式下对介电质和金属的模糊区分，这使得它无法与金属-粗糙度模型或其他扩展属性结合。
- en: As an alternative, Khronos proposed the `KHR_materials_specular` extension,
    which addresses these issues and offers the functionality of `KHR_materials_pbrSpecularGlossiness`
    without compromising the physical accuracy of the **Metallic-Roughness** PBR model.
    This makes it compatible with most glTF PBR extensions. At the time of writing,
    the `KHR_materials_specular` extension is only incompatible with the `KHR_materials_pbrSpecularGlossiness`
    and `KHR_materials_unlit` extensions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，Khronos提出了`KHR_materials_specular`扩展，它解决了这些问题，并提供了`KHR_materials_pbrSpecularGlossiness`的功能，同时不牺牲**金属-粗糙度**PBR模型的物理精度。这使得它与大多数glTF
    PBR扩展兼容。在撰写本文时，`KHR_materials_specular`扩展仅与`KHR_materials_pbrSpecularGlossiness`和`KHR_materials_unlit`扩展不兼容。
- en: The `KHR_materials_specular` extension allows for more precise control over
    specular reflections in glTF materials. While the core glTF specification includes
    a basic specular BRDF, this extension introduces additional parameters to better
    fine-tune the appearance of specular highlights.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_specular`扩展允许对glTF材质中的镜面反射进行更精确的控制。虽然核心的glTF规范包括基本的镜面BRDF，但此扩展引入了额外的参数，以更好地微调镜面高光的外观。'
- en: Specular parameters
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜面参数
- en: 'The `KHR_materials_specular` extension introduces several parameters to enhance
    specular reflections:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_specular`扩展引入了几个参数以增强镜面反射：'
- en: '**specularFactor/specularTexture**: A scalar value that scales the overall
    intensity of the specular reflection.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**specularFactor/specularTexture**: 一个标量值，用于缩放整体镜面反射的强度。'
- en: '**specularColorFactor/specularColorTexture**: A color value that modifies the
    color of the specular reflection.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**specularColorFactor/specularColorTexture**: 一个颜色值，用于修改镜面反射的颜色。'
- en: Specular-Glossiness conversion
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜面-光泽度转换
- en: You can convert **Specular-Glossiness** materials to the **Metallic-Roughness**
    workflow using the `KHR_materials_ior` extension described in the previous recipe
    *Implementing the index-of-refraction extension*. By setting the `IOR` parameter
    to `0`, the material is treated as a dielectric with the maximum specular reflection.
    The `IOR` parameter controls the upper limit of the specular reflection’s strength,
    and setting it to `0` maximizes this strength, allowing full control over specular
    reflection through the `specularColorFactor`. This method eliminates the need
    to classify materials as either dielectric or metallic. It’s important to note
    that materials using the `KHR_materials_volume` extension are incompatible with
    this conversion due to their non-zero `IOR` value. For new materials, it’s often
    better to use the **Metallic-Roughness** model directly.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一节中描述的`KHR_materials_ior`扩展将**镜面-光泽度**材质转换为**金属-粗糙度**工作流程。通过将`IOR`参数设置为`0`，材质被视为具有最大镜面反射的介电质。`IOR`参数控制镜面反射强度的上限，将其设置为`0`将最大化这种强度，允许通过`specularColorFactor`完全控制镜面反射。这种方法消除了将材料分类为介电质或金属的需求。需要注意的是，使用`KHR_materials_volume`扩展的材料与此转换不兼容，因为它们的`IOR`值不为零。对于新材料，通常直接使用**金属-粗糙度**模型会更好。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/06_Specular/`. Reread
    two previous recipes *Implementing the index-of-refraction extension* and *Implementing
    the volume extension* as this extension interacts with them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的源代码可以在`Chapter07/06_Specular/`中找到。重新阅读两个之前的菜谱*实现折射率扩展*和*实现体积扩展*，因为这个扩展与它们交互。
- en: How to do it…
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This extension doesn’t require any major changes to the C++ code, aside from
    reading the additional material properties via Assimp:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过Assimp读取额外的材质属性之外，这个扩展不需要对C++代码进行任何重大更改：
- en: 'Let’s load a new `.gltf` model in `Chapter07/06_Specular/src/main.cpp`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Chapter07/06_Specular/src/main.cpp`中加载一个新的`.gltf`模型：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To make this example more interesting, we added rotation to our 3D model:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个例子更有趣，我们在我们的3D模型中添加了旋转：
- en: '[PRE59]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let’s load material properties in `shared/UtilsGLTF.cpp`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`shared/UtilsGLTF.cpp`中加载材质属性：
- en: '[PRE60]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: GLSL shader changes are a bit more complex. The `specularColor` parameter introduces
    color variations into the specular reflection. It is integrated into the Fresnel
    term, influencing the specular reflectance at different viewing angles. At normal
    incidence, the specular color directly scales the base reflectance (`F0`), while
    at grazing angles, the reflectance approaches `1.0` regardless of the specular
    color. To maintain energy conservation, the maximum component of the specular
    color is used to calculate the scaling factor for the Fresnel term, preventing
    excessive energy in the specular reflection.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL着色器更改稍微复杂一些。`specularColor`参数将颜色变化引入到镜面反射中。它集成到菲涅耳项中，影响不同观察角度的镜面反射率。在正常入射时，镜面颜色直接缩放基础反射率（`F0`），而在掠射角时，反射率接近`1.0`，无论镜面颜色如何。为了保持能量守恒，使用镜面颜色的最大分量来计算菲涅耳项的缩放因子，防止镜面反射中能量过多。
- en: 'First, we introduce some utility functions in `data/shaders/gltf/inputs.frag`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在`data/shaders/gltf/inputs.frag`中引入一些实用函数：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We add a new field `specularWeight` to the `PBRInfo` structure in `data/shaders/gltf/PBR.sp`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`data/shaders/gltf/PBR.sp`中的`PBRInfo`结构中添加了一个新的字段`specularWeight`。
- en: '[PRE62]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We modify the method for obtaining the `F0` reflectance and populate the `specularWeigthspecularWeigthh`
    field in the `calculatePBRInputsMetallicRoughness()` function:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改了获取`F0`反射率的方法，并在`calculatePBRInputsMetallicRoughness()`函数中填充`specularWeigthspecularWeigthh`字段：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we can use these parameters in `data/shaders/gltf/main.frag` to calculate
    the specular and diffuse components of the IBL contribution:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`data/shaders/gltf/main.frag`中使用这些参数来计算IBL贡献的镜面和漫反射分量：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here is how the specular contribution is calculated. Please note that we multiply
    by `specularWeight` at the end of the function `getIBLRadianceContributionGGX()`:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是如何计算镜面贡献的。请注意，我们在`getIBLRadianceContributionGGX()`函数的末尾乘以`specularWeight`：
- en: '[PRE65]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The diffuse contribution looks like this. Note that we scale the Fresnel term
    and replace it with a `vec3` RGB value to incorporate the `specularColor` contribution
    into `F0`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 漫反射贡献看起来是这样的。注意，我们缩放菲涅耳项，并用`vec3` RGB值替换它，以将`specularColor`贡献纳入`F0`：
- en: '[PRE66]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Those are all the changes required to implement the `KHR_materials_specular`
    extension in our glTF renderer. The demo application should render a rotating
    torus as in the following screenshot:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是实现我们glTF渲染器中的`KHR_materials_specular`扩展所需的所有更改。演示应用程序应该渲染一个如以下截图所示的旋转环：
- en: '![Figure 7.7: glTF PBR KHR_materials_specular example](img/file57.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7：glTF PBR KHR_materials_specular示例](img/file57.png)'
- en: 'Figure 7.7: glTF PBR KHR_materials_specular example'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：glTF PBR KHR_materials_specular示例
- en: For further details on the motivation behind this approach, please refer to
    the Khronos specification [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种方法的动机的更多细节，请参阅Khronos规范[https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md#implementation)。
- en: There is more…
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Khronos extension page [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)
    provides comprehensive information on various aspects of the extension. It includes
    detailed explanations of the BRDF and additional insights into converting between
    different PBR models.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Khronos 扩展页面 [https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)
    提供了关于扩展各个方面的全面信息。它包括对 BRDF 的详细解释以及不同 PBR 模型之间转换的额外见解。
- en: Implementing the KHR_materials_emissive_strength extension
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 KHR_materials_emissive_strength 扩展
- en: The metallic-roughness core model supports light emission, but before the introduction
    of the `KHR_materials_emissive_strength` extension, it was difficult to control
    the intensity of a material’s light emission. This made it challenging to create
    realistic glowing objects or materials that function as light sources in a scene.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 金属-粗糙度核心模型支持光发射，但在 `KHR_materials_emissive_strength` 扩展引入之前，控制材质光发射的强度很困难。这使得创建逼真的发光物体或场景中作为光源的材质变得具有挑战性。
- en: The `KHR_materials_emissive_strength` extension overcomes this limitation by
    introducing a new property called *emissiveStrength*. This property allows for
    precise control over the intensity of a material’s emitted light. With values
    ranging from `0.0` for no emission to higher values for increased intensity, artists
    and designers gain more control over the lighting in their scenes.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`KHR_materials_emissive_strength` 扩展通过引入一个名为 *emissiveStrength* 的新属性来克服这一限制。这个属性允许对材质发出的光强度进行精确控制。从
    `0.0`（无发射）到更高的值（增加强度），艺术家和设计师可以更好地控制场景中的照明。'
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/07_EmissiveStrength/`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的源代码可在 `Chapter07/07_EmissiveStrength/` 中找到。
- en: How to do it…
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: This extension is one of the simplest to implement. All it requires is loading
    an intensity value and applying it to the existing emissive value. Essentially,
    you only need to take the `emissiveStrength` property from Assimp, which determines
    how intense the material’s emitted light should be, and multiply it by the emissive
    color.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展是最容易实现的之一。它只需要加载一个强度值并将其应用于现有的发射值。本质上，你只需要从 Assimp 中获取 `emissiveStrength`
    属性，该属性决定了材质发出的光应该有多强烈，并将其乘以发射颜色。
- en: Let’s load a new 3D model in `Chapter07/07_EmissiveStrength/src/main.cpp` to
    demonstrate this extension.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `Chapter07/07_EmissiveStrength/src/main.cpp` 中加载一个新的 3D 模型来演示这个扩展。
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here’s the C++ code in `shared/UtilsGLTF.cpp` to retrieve the material properties
    from Assimp:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是存储在 `shared/UtilsGLTF.cpp` 中的 C++ 代码，用于从 Assimp 中检索材质属性：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The resulting demo app should render a set of five glowing cubes, as shown
    in the following screenshot:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的演示应用程序应该渲染一组五个发光的立方体，如下面的截图所示：
- en: '![Figure 7.8: glTF PBR KHR_materials_emissive_strength example](img/file58.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8：glTF PBR KHR_materials_emissive_strength 示例](img/file58.png)'
- en: 'Figure 7.8: glTF PBR KHR_materials_emissive_strength example'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：glTF PBR KHR_materials_emissive_strength 示例
- en: Now, let’s jump to the final recipe of this chapter, where we will dive into
    implementing support for glTF analytical lights.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳到本章的最后一道菜谱，我们将深入实现对 glTF 分析光的支持。
- en: Extend analytical lights support with KHR_lights_punctual
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 KHR_lights_punctual 扩展扩展分析光支持
- en: This is the final recipe in this chapter, and we will add support for analytical
    light sources to our glTF viewer. In the next chapter, we will cover the `KHR_lights_punctual`
    extension, which will allow us to load lighting information directly from glTF
    assets. In this recipe, we will only be dealing with shader changes.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一道菜谱，我们将为我们的 glTF 查看器添加对分析光源的支持。在下一章中，我们将介绍 `KHR_lights_punctual` 扩展，它将允许我们直接从
    glTF 资产中加载照明信息。在这个菜谱中，我们只处理着色器更改。
- en: 'In the context of glTF PBR, the terms “analytical” and “punctual” lights are
    often used interchangeably to describe the same type of light source:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在 glTF PBR 的背景下，术语“分析”和“点光源”经常互换使用，以描述同一种类型的光源：
- en: '**Analytical light**: This refers to light sources defined by mathematical
    equations, enabling precise calculations of its effect on lighting.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析光**: 这指的是由数学方程定义的光源，能够精确计算其对照明效果的影响。'
- en: '**Punctual light**: This describes light sources that are infinitely small
    points that emit light in specific directions and intensities.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这描述了无限小的点光源，在特定方向和强度上发射光线。'
- en: We will explore these concepts in more detail in the next chapter. In this recipe,
    fFor simplicity, we’ll use both terms interchangeably.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更详细地探讨这些概念。在本食谱中，为了简单起见，我们将这两个术语交替使用。
- en: Image-Based Lighting vs Punctual lights
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于图像的光照与点光源
- en: Let’s refresh the difference between Image-Based (IBL) and punctual lights.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下基于图像（IBL）和点光源之间的区别。
- en: IBL simulates indirect lighting from the environment using a pre-computed environment
    map. In glTF PBR, this environment map is filtered based on roughness and normal
    direction to approximate incoming radiance. The reflected light is calculated
    using **BRDF** (**Bidirectional Reflectance Distribution Function**) based on
    the surface material properties, with integration performed over the hemisphere
    to account for light coming from all directions. Punctual lights, on the other
    hand, represent specific light sources like point, spot, and directional lights.
    For each surface point, the direction and distance to the light are calculated,
    with attenuation applied based on how far the light source is. Shadows are also
    considered to check if the light reaches the surface. The BRDF is then used to
    calculate the reflected light based on the light direction, surface normal, and
    material properties. This method is more computationally expensive than IBL since
    it requires calculating lighting for each individual light source.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: IBL 使用预计算的环境图模拟环境中的间接光照。在 glTF PBR 中，该环境图根据粗糙度和法线方向进行过滤，以近似入射辐射。反射光使用基于表面材料属性的
    **BRDF**（**双向反射分布函数**）进行计算，通过半球进行积分，以考虑来自所有方向的光。另一方面，点光源表示特定的光源，如点光源、聚光灯和方向性光源。对于每个表面点，计算光的方向和距离，并根据光源的远近应用衰减。还考虑了阴影，以检查光线是否到达表面。然后，使用
    BRDF 根据光方向、表面法线和材料属性计算反射光。由于需要为每个单独的光源计算光照，因此这种方法比 IBL 计算成本更高。
- en: Let’s take a look at how to add glTF punctual lights to our viewer.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 glTF 点光源添加到我们的查看器中。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code for this recipe can be found in `Chapter07/08_AnalyticalLight`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的源代码可以在 `Chapter07/08_AnalyticalLight` 中找到。
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: C++ code changes are pretty small and straightforward. We introduce additional
    structures to provide light information data.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 代码更改很小且直接。我们引入了额外的结构来提供光照信息数据。
- en: First, let’s load a corresponding `.gltf` model in `Chapter07/08_AnalyticalLight/src/main.cpp`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在 `Chapter07/08_AnalyticalLight/src/main.cpp` 中加载相应的 `.gltf` 模型。
- en: '[PRE69]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Declare an enumeration for different light types in `shared/UtilsGLTF.h`:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `shared/UtilsGLTF.h` 中声明一个用于不同光照类型的枚举：
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here’s a structure called `LightDataGPU` to store light information in GPU
    buffers. It has default values defining a dummy directional light:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个名为 `LightDataGPU` 的结构，用于在 GPU 缓冲区中存储光照信息。它具有定义一个虚拟方向光源的默认值：
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We set the light sources in `shared/UtilsGLTF.cpp` as a part of our per-frame
    constants:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `shared/UtilsGLTF.cpp` 中将光源设置为每帧常量的一部分：
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The changes to the GLSL shader code are substantial. We need to reimplement
    the specular and diffuse contributions for Metallic-Roughness and other extensions,
    applying these calculations for each light source individually. In this recipe,
    we will not go too deep into the implementation details, but we strongly recommend
    reviewing the actual shaders and the reference materials provided in the comments
    to fully understand this topic. Here’s a brief glimpse of the changes.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 着色器代码的更改很大。我们需要重新实现金属-粗糙度和其他扩展的镜面和漫反射贡献，并对每个光源单独应用这些计算。在本食谱中，我们不会深入探讨实现细节，但强烈建议您查看注释中提供的实际着色器和参考材料，以全面理解这个主题。以下是更改的简要概述。
- en: 'Let’s introduce a couple of utility functions in `data/shaders/gltf/inputs.frag`
    to conveniently access the light data:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `data/shaders/gltf/inputs.frag` 中引入一些实用函数，以便方便地访问光照数据：
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `data/shaders/gltf/main.frag`, we introduce accumulation variables for each
    individual contribution component:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `data/shaders/gltf/main.frag` 中，我们为每个单独的贡献组件引入累积变量：
- en: '[PRE74]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We iterate over all light sources, calculating the necessary terms for each
    one and checking if the light source is visible from the rendering point. Then
    we calculate the light intensity:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历所有光源，计算每个光源所需的项，并检查光源是否可以从渲染点看到。然后我们计算光强度：
- en: '[PRE75]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Evaluating all lights for every object can be quite costly. Alternatives like
    clustered or deferred shading can help improve performance in this situation.
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为每个对象评估所有光源可能会相当昂贵。在这种情况下，集群或延迟着色等替代方案可以帮助提高性能。
- en: 'Then we calculate diffuse and specular contributions for this light:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们计算这个光源的漫反射和镜面反射贡献：
- en: '[PRE76]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The sheen contribution is now calculated as follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 光泽贡献现在是按照以下方式计算的：
- en: '[PRE77]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The new clearcoat contribution is calculated in a similar way. Transmission
    and volume contributions are skipped here for the sake of brevity:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的清漆贡献以类似的方式计算。为了简洁，这里省略了传输和体积贡献：
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We used a helper function `getLightIntensity()` which is declared in `data/shaders/gltf/PBR.sp`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了一个辅助函数 `getLightIntensity()`，该函数在 `data/shaders/gltf/PBR.sp` 文件中声明：
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Other helper functions, such as `getBRDFLambertian()`, `getBRDFSpecularGGX()`,
    `getBRDFSpecularSheen()`, `getPunctualRadianceSheen()`, and many others mentioned
    in the GLSL code earlier, are defined in `data/shaders/gltf/PBR.sp`. These functions
    contain the math for calculating the specific terms. For brevity, we do not include
    them here.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 其他辅助函数，例如 `getBRDFLambertian()`、`getBRDFSpecularGGX()`、`getBRDFSpecularSheen()`、`getPunctualRadianceSheen()`
    以及在前面提到的 GLSL 代码中提到的许多其他函数，都在 `data/shaders/gltf/PBR.sp` 文件中定义。这些函数包含了计算特定项的数学公式。为了简洁，我们在此不包括它们。
- en: 'The running application should render a mesh illuminated by an analytical directional
    light, as shown in the screenshot below:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的应用程序应该渲染一个由分析方向光源照亮的网格，如下面的截图所示：
- en: '![Figure 7.9: Analytical lights example](img/file59.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：分析光源示例](img/file59.png)'
- en: 'Figure 7.9: Analytical lights example'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：分析光源示例
- en: With this example, we wrap up our chapter on advanced glTF PBR extensions. We
    have delved into complex topics and extended our understanding of how to work
    with various lighting models and extensions. In the next chapter, *Graphics Rendering
    Pipeline*, we will shift our focus to the broader organization of 3D scenes. We
    will explore various data structures and strategies needed to efficiently manage
    and render multiple 3D models. This will involve a detailed look at how to structure
    and optimize data for rendering, ensuring smooth and effective visualization of
    complex scenes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们结束了关于高级 glTF PBR 扩展的章节。我们深入探讨了复杂主题，并扩展了我们如何使用各种光照模型和扩展的理解。在下一章，*图形渲染管线*中，我们将关注
    3D 场景的更广泛组织。我们将探讨需要高效管理和渲染多个 3D 模型的各种数据结构和策略。这将涉及对如何结构和优化数据以进行渲染的详细分析，以确保复杂场景的平滑和有效可视化。
