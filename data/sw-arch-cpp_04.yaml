- en: Functional and Nonfunctional Requirements
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 功能和非功能需求
- en: As an architect, it is important for you to recognize which requirements are
    significant for the architecture and why. This chapter will teach you about the
    various requirements of a solution—functional and nonfunctional. Functional requirements
    are those that tell you what your solution should do. On the other hand, nonfunctional
    ones are those that tell you how your solution should be*.*
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为架构师，重要的是要认识到哪些需求对架构有重要意义，以及为什么。本章将教你关于解决方案的各种需求——功能和非功能。功能需求告诉您您的解决方案应该做什么。另一方面，非功能需求告诉您您的解决方案应该如何*。*
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the types of requirements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解需求的类型
- en: Recognizing architecturally significant requirements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别具有架构重要性的需求
- en: Gathering requirements from various sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从各种来源收集需求
- en: Documenting requirements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录需求
- en: Documenting architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录架构
- en: Choosing the right views to document
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的视图来记录
- en: Generating documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文档
- en: By the end of this chapter, you will have learned how to recognize and categorize
    both types of requirements and how to create documentation that describes them
    in a clear manner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将学会如何识别和分类这两种类型的需求，并如何创建清晰描述它们的文档。
- en: Technical requirements documentation from sources, you must have
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自源的技术需求文档，您必须安装
- en: To replicate our steps to generate documentation from sources, you must have
    CMake, Doxygen, Sphinx, m2r2 and Breathe installed. We're using the ReadTheDocs
    Sphinx theme, so please install it as well. Feel free to use the latest versions
    of the tools mentioned.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源生成文档，必须安装CMake、Doxygen、Sphinx、m2r2和Breathe。我们正在使用ReadTheDocs Sphinx主题，所以也请安装它。请随意使用提到的工具的最新版本。
- en: You can find the related code at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03)找到相关代码。
- en: Understanding the types of requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解需求的类型
- en: 'While creating a software system, you should constantly ask yourself whether
    what you''re making is what your customers need. Many times, they won''t even
    know what requirement fulfills their needs best. It''s the role of a successful
    architect to discover the requirements of the product and to make sure they are
    being met. There are three distinct types of requirements that you need to consider:
    functional requirements, quality attributes, and constraints. Let''s have a look
    at each of these.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建软件系统时，您应该不断地问自己您正在做的是否是您的客户需要的。很多时候，他们甚至不知道哪个需求最能满足他们的需求。成功的架构师的角色是发现产品的需求，并确保它们得到满足。有三种不同类型的需求需要考虑：功能需求、质量属性和约束。让我们来看看每一种。
- en: Functional requirements
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能需求
- en: The first group is the functional requirements. These are the ones that define
    what your system should do, or what functionality it should offer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组是功能需求。这些是定义您的系统应该做什么或应该提供什么功能的需求。
- en: Remember that functionality does not always influence architecture, so you'll
    have to keep an eye on which of those requirements will actually dictate what
    your solution will look like.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，功能并不总是影响架构，因此您必须密切关注这些需求中哪些实际上会决定您的解决方案的外观。
- en: 'Often, if a functional requirement has some qualities that must be met, it
    can become architecturally significant. Consider an app for merchants and visitors
    of the Dominican Fair, an annual event with music, various arts, and shops, happening
    in the city of Gdańsk. A few examples of functional requirements for it could
    be the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果功能需求具有必须满足的某些特性，它可能会变得具有架构重要性。考虑一个为多米尼加展会的商家和游客设计的应用程序，这是一年一度的活动，包括音乐、各种艺术和商店，发生在格但斯克市。对它的一些功能需求的几个例子可能是以下内容：
- en: '*As a shopkeeper, I want to filter orders that contain a specific product.*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为店主，我想要筛选包含特定产品的订单。*'
- en: '*Clicking the Subscribe button adds the customer to a list of notified watchers
    of a selected merchant.*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单击订阅按钮会将客户添加到所选商家的通知观察者列表中。*'
- en: The first of those requirements tells us we'll have to have a component for
    tracking orders and products with search capabilities. Depending on how exactly
    the UI should appear and what scale our app should be, we could just add a simple
    page to our app, or it could require features such as Lucene or Elasticsearch.
    This means that we could be looking at an **Architecturally Significant Requirement**
    (**ASR**), one that can influence our architecture.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求中的第一个告诉我们，我们将需要一个用于跟踪订单和产品并具有搜索功能的组件。根据UI的具体外观和我们的应用程序的规模，我们可以只向我们的应用程序添加一个简单的页面，或者它可能需要诸如Lucene或Elasticsearch之类的功能。这意味着我们可能正在考虑一个对架构有影响的**架构上重要的需求**（**ASR**）。
- en: The second example is even more straightforward; now we know we need to have
    a service for subscribing and sending notifications. This is definitely an architecturally
    significant functional requirement. Let's now look at some **Non-Functional Requirements**
    (**NFRs**) that can also be ASRs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子更加直接；现在我们知道我们需要一个用于订阅和发送通知的服务。这绝对是一个具有架构重要性的功能需求。现在让我们看一些**非功能需求**（**NFRs**），它们也可以是ASRs。
- en: 'By the way, the first requirement is actually given as a user story. User stories
    are requirements given in the following format: "*As a <role>, I can/want to <capability>,
    so that <benefit>*." This is a common way to phrase requirements and can help
    stakeholders and developers find common ground and communicate better.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，第一个要求实际上是以用户故事的形式给出的。用户故事是以以下格式给出的需求：“*作为<角色>，我可以/想要<能力>，以便<好处>*。”这是表达需求的常见方式，可以帮助利益相关者和开发人员找到共同点并更好地沟通。
- en: Nonfunctional requirements
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能需求
- en: 'Instead of focusing on what functionality your system should have, nonfunctional
    requirements focus on how well and under which conditions the system should perform
    said functionality. This group consists of two main subgroups: **Quality Attributes**
    (**QAs**) and **constraints**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求不是关注你的系统应该具有什么功能，而是关注系统应该在多好的条件下执行这些功能。这一组主要包括两个子组：**质量属性**（**QAs**）和**约束**。
- en: Quality attributes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 质量属性
- en: '**Quality** **attributes** (**QAs**) are the traits of your solution, such
    as performance, maintainability, and user-friendliness. There are dozens, if not
    hundreds, of different qualities your software can have. Try to focus just on
    the important ones instead of listing all that come to your mind when choosing
    which ones your software should have. Examples of quality attribute requirements
    include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**质量** **属性**（**QAs**）是你的解决方案的特征，如性能、可维护性和用户友好性。你的软件可能有数十个，甚至数百个不同的质量。在选择你的软件应该具有哪些质量时，试着只关注重要的质量，而不是列出你脑海中出现的所有质量。质量属性需求的例子包括以下内容：'
- en: The system will respond in under 500 ms for 99.9% of all requests under usual
    load (don't forget to specify what the usual load is or will be).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统在通常负载下对99.9%的请求在500毫秒内做出响应（不要忘记指定通常负载是什么或将是什么）。
- en: The website will not store customer credit card data used in the payment process
    (an example of confidentiality).
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站不会存储在支付过程中使用的客户信用卡数据（保密性的一个例子）。
- en: When updating the system, if updating any component fails, the system will be
    rolled back to a state prior to the update (survivability).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更新系统时，如果更新任何组件失败，系统将被回滚到更新之前的状态（生存能力）。
- en: As a user of Windows, macOS, and Android, I want to be able to use the system
    from all of them (portability; try to understand whether it's needed to support
    platforms such as desktop, mobile, and/or web).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Windows、macOS和Android的用户，我希望能够从所有这些系统中使用系统（可移植性；尝试了解是否需要支持桌面、移动和/或网络等平台）。
- en: 'While catching functional requirements in a backlog is pretty straightforward,
    we cannot say the same regarding quality attribute requirements. Fortunately,
    there are a few ways you could approach this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在积压中捕捉功能性需求非常简单，但我们不能说同样的话适用于质量属性需求。幸运的是，有几种方法可以解决这个问题：
- en: Some of them can be expressed in the **Definition of done** or **Acceptance
    criteria** for your tasks, stories, and releases.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些可以在你的任务、故事和发布的**完成定义**或**验收标准**中表达。
- en: Others can be expressed directly as user stories, as shown in the last example
    previously.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他可以直接表达为用户故事，如前面的最后一个例子所示。
- en: You can also check them as part of design and code reviews and create automated
    tests for some of them.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在设计和代码审查中检查它们，并为其中一些创建自动化测试。
- en: Constraints
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约束
- en: 'Constraints are the non-negotiable decisions that you must follow while delivering
    the project. Those can be design decisions, technological ones, or even political
    (regarding people or organizational matters). Two other common constraints are
    **time** and **budget**. Examples of constraints could be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是在交付项目时必须遵循的不可协商的决定。这些可以是设计决策、技术决策，甚至是政治（涉及人员或组织事务）的决定。另外两个常见的约束是**时间**和**预算**。约束的例子可能如下：
- en: '*The team will never grow beyond four developers, one QA engineer, and one
    sysadmin.*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*团队的人数永远不会超过四名开发人员、一名质量保证工程师和一名系统管理员。*'
- en: '*Since our company leverages Oracle DB in all its current products, the new
    product must use it too so we can make the most of our expertise.*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由于我们公司在所有当前产品中都使用Oracle DB，新产品也必须使用它，这样我们就可以充分利用我们的专业知识。*'
- en: nonfunctional requirements are always going to influence your architecture.
    It's essential not to over-specify them, as having *false positives* will be a
    constant burden during product development. It's equally important to not under-specify
    them as this can later come out in missed sales opportunities or failing to comply
    with regulatory bodies' requirements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求总是会影响你的架构。不要过度规定它们，因为出现*假阳性*将会是产品开发过程中的一个不断的负担。同样重要的是不要过度规定它们，因为这可能会在错过销售机会或未能遵守监管机构的要求时出现。
- en: In the next section, you will learn how to strike a balance between those two
    extremes and to focus on just those requirements that really matter in your specific
    case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学会如何在这两个极端之间取得平衡，只关注那些在你的具体情况下真正重要的需求。
- en: Recognizing architecturally significant requirements
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别具有架构重要性的需求
- en: When designing a software system, it's common to deal with dozens or hundreds
    of various requirements. In order to make sense of them and come up with a good
    design, you need to know which of them are important and which could be implemented
    regardless of your design decisions, or even dismissed. You should learn how to
    recognize the most important ones so you can focus on them first and deliver the
    most value in the shortest possible time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计软件系统时，通常要处理数十个甚至数百个不同的需求。为了理解它们并提出一个好的设计，你需要知道哪些是重要的，哪些可以不考虑你的设计决策而实现，甚至可以被忽略。你应该学会如何识别最重要的需求，这样你就可以首先专注于它们，并在最短的时间内提供最大的价值。
- en: 'You should prioritize requirements using two metrics: the business value and
    the impact on architecture. Those that will be high on both scales are most important
    and should be dealt with as a matter of priority. If you come up with too many
    such requirements, you should revisit your prioritization scheme. If it doesn''t
    help, it might be that the system just isn''t achievable.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用两个指标来优先考虑需求：业务价值和对架构的影响。那些在两个方面都很重要的需求是最重要的，应该优先处理。如果你提出了太多这样的需求，你应该重新审视你的优先考虑方案。如果这没有帮助，可能是系统根本无法实现。
- en: ASRs are those that have a measurable impact on your system's architecture.
    They can be both functional and nonfunctional. How can you identify which ones
    are actually significant? If the absence of a specific requirement were to allow
    you to create a different architecture, you are looking at an ASR. Late discovery
    of such requirements will often cost you both time and money, as you'll need to
    redesign some part of your system, if not the whole solution. You can only hope
    it won't cost you other resources and your reputation, too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ASR是对系统架构产生可衡量影响的要求。它们可以是功能性的，也可以是非功能性的。你如何确定哪些才是真正重要的？如果某个特定要求的缺失会允许你创建不同的架构，那么你就在考虑一个ASR。对这类要求的迟发现通常会花费你大量的时间和金钱，因为你需要重新设计系统的某些部分，甚至整个解决方案。你只能希望这不会给你的声誉和其他资源带来损失。
- en: It's a common mistake to start by applying concrete technologies to your architecture
    from the very beginning of your architectural work. We strongly suggest that you
    first gather all the requirements, focus on the ones significant for the architecture,
    and only then decide what technologies and technology stacks to build your project
    on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构工作的一开始就将具体技术应用于你的架构是一个常见的错误。我们强烈建议你首先收集所有的要求，专注于对架构重要的要求，然后再决定使用什么技术和技术栈来构建你的项目。
- en: Since it's that important to recognize ASRs, let's talk about a few patterns
    that can help you with this.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于识别ASR如此重要，让我们谈谈一些可以帮助你的模式。
- en: Indicators of architectural significance
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构重要性的指标
- en: 'If you have a requirement to integrate with any external system, this is most
    likely going to influence your architecture. Let''s go through some common indicators
    that a requirement is an ASR:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有要求与任何外部系统集成，这很可能会影响你的架构。让我们来看看一些常见的指标，表明一个要求是ASR：
- en: '**Needing to create a software component to handle it**: Examples include sending
    emails, pushing notifications, exchanging data with the company''s SAP server,
    or using a specific data storage.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要创建一个软件组件来处理它**：例如发送电子邮件、推送通知、与公司的SAP服务器交换数据，或者使用特定的数据存储。'
- en: '**Having a significant impact on the system**: Core functionality often defines
    what your system should look like. Cross-cutting concerns, such as authorization,
    auditability, or having transactional behavior, are other good examples.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对系统产生重大影响**：核心功能通常定义了你的系统应该是什么样子。诸如授权、可审计性或事务行为等横切关注点都是其他很好的例子。'
- en: '**Being hard to achieve**: Having low latency is a great example: unless you
    think of it early in development, it can be a long battle to achieve it, especially
    if you suddenly realize you can''t really afford to have garbage collections when
    you''re on your hot path.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以实现**：低延迟就是一个很好的例子：除非你在开发初期就考虑到它，否则要实现它可能是一场漫长的战斗，特别是当你突然意识到在热路径上不能承受垃圾回收时。'
- en: '**Forcing trade-offs when satisfying certain architectures**: Perhaps your
    design decision will even need to compromise some requirements in favor of other,
    more important ones if the cost is too high. It''s a good practice to log such
    decisions somewhere and to notice that you''re dealing with ASRs here. If any
    requirement constrains you or limits the product in any way, it''s very likely
    significant for the architecture. If you want to come up with the best architecture
    given many trade-offs, then be sure to read about the **Architecture Trade-off
    Analysis Method** (**ATAM**), which you can read about under one of the links
    in the *Further reading* section.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在满足某些架构时强制进行权衡**：也许你的设计决策甚至需要在成本过高的情况下牺牲一些要求，以支持其他更重要的要求。将这类决策记录在某个地方，并注意到你正在处理ASR是一个很好的做法。如果任何要求限制了你或以任何方式限制了产品，那很可能对架构来说是重要的。如果你想在许多权衡中提出最佳架构，那么一定要阅读一下**架构权衡分析方法**（**ATAM**），你可以在*进一步阅读*部分的链接中找到相关内容。'
- en: Constraints and the environment your application will run in can also impact
    your architecture. Embedded apps need to be designed in a different way to those
    running in the cloud, and apps being developed by less-experienced developers
    should probably use a simple and safe framework instead of using one with a steep
    learning curve or developing their own.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 约束和应用程序将运行的环境也可能会影响你的架构。嵌入式应用程序需要以不同的方式设计，以适应在云中运行的应用程序，而由经验不足的开发人员开发的应用程序可能应该使用简单且安全的框架，而不是使用学习曲线陡峭的框架或开发他们自己的框架。
- en: Hindrances in recognizing ASRs and how to deal with them
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别ASR的障碍以及如何处理它们
- en: 'Contrary to intuition, many architecturally significant requirements are difficult
    to spot at first glance. This is caused by two factors: they can be hard to define
    and even if they''re described, this can be done vaguely. Your customers might
    not yet be clear about what they need, but you should still be proactive in asking
    questions to steer clear of any assumptions. If your system is to send notifications,
    you must know whether those are real time or whether a daily email will suffice,
    as the former could require you to create a publisher-subscriber architecture.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与直觉相反，许多架构上重要的要求一开始很难发现。这是由两个因素造成的：它们很难定义，即使描述了，也可能模糊不清。你的客户可能还不清楚他们需要什么，但你仍然应该积极提出问题，以避免任何假设。如果你的系统要发送通知，你必须知道这些是实时的还是每天的电子邮件就足够了，因为前者可能需要你创建一个发布-订阅的架构。
- en: In most cases, you'll need to make some assumptions since not everything is
    known upfront. If you discover a requirement that challenges your assumptions,
    it might be an ASR. If you assume you can maintain your service between 3 a.m.
    and 4 a.m. and you realize your customers from a different time zone will still
    need to use it, it will challenge your assumption and likely change the product's
    architecture.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你需要做一些假设，因为并非所有事情都能事先知道。如果你发现一个要求挑战了你的假设，那可能就是一个ASR。如果你假设你可以在凌晨3点到4点之间维护你的服务，然后你意识到来自不同时区的客户仍然需要使用它，那就会挑战你的假设，很可能改变产品的架构。
- en: What's more, people often tend to treat quality attributes vaguely during the
    earlier phases of projects, especially less-experienced or less-technical individuals.
    On the other hand, that's the best moment to address such ASRs, as the cost of
    implementing them in the system is the lowest.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，人们在项目的早期阶段，特别是经验较少或技术水平较低的人，往往倾向于模糊地对待质量属性。另一方面，这是解决这些ASR的最佳时机，因为在系统中实施它们的成本最低。
- en: 'It''s worth noting, however, that many people, when specifying requirements,
    like to use vague phrases without actually thinking it through. If you were designing
    a service similar to Uber, some examples could be: *when receiving a DriverSearchRequest,
    the system must reply with an AvailableDrivers message fast*, or *the system must
    be available 24/7*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而值得注意的是，许多人在指定需求时喜欢使用模糊的短语，而实际上并没有仔细考虑。如果您正在设计类似Uber的服务，一些例子可能是：*当接收到DriverSearchRequest时，系统必须快速回复AvailableDrivers消息*，或者*系统必须全天候可用*。
- en: Upon asking questions, it often turns out that 99.9% monthly availability is
    perfectly fine, and *fast* is actually a few seconds. Such phrases always require
    clarification, and it's often valuable to know the rationale behind them. Perhaps
    it is just someone's subjective opinion, not backed by any data or business needs.
    Also, note that in the request and response case, the quality attribute is hidden
    inside another requirement, making it even harder to catch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 询问问题后，通常会发现99.9%的月可用性是完全可以接受的，而*快速*实际上是几秒钟。这些短语总是需要澄清，了解背后的原因通常也是有价值的。也许这只是某人的主观看法，没有任何数据或业务需求支持。此外，请注意，在请求和响应的情况下，质量属性隐藏在另一个需求中，这使得更难以捕捉。
- en: Finally, requirements being architecturally significant for one system aren't
    necessarily of the same importance to another, even if those systems serve similar
    purposes. Some will become more important over time, once the system grows and
    starts to communicate with more and more other systems. Others may become important
    once the needs for the product change. This is why there's no silver bullet in
    telling which of your requirements will be ASRs, and which won't.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于一个系统而言，具有架构重要性的需求并不一定对另一个系统具有相同的重要性，即使这些系统提供类似的目的。一些需求会随着时间的推移变得更加重要，一旦系统增长并开始与越来越多的其他系统进行通信。其他需求可能在产品需求发生变化时变得重要。这就是为什么没有一种确定哪些需求将成为ASR，哪些不会的银弹。
- en: Equipped with all this knowledge on how to distinguish the important requirements
    from the rest, you know *what* to look for. Let's now say a few words about *where*
    to look.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了如何区分重要需求和其他需求的所有知识，您知道要寻找*什么*。现在让我们谈谈*在哪里*寻找。
- en: Gathering requirements from various sources
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从各种来源收集需求
- en: Now that you know what requirements to focus on, let's discuss a few techniques
    for gathering these requirements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道要关注哪些需求，让我们讨论一下收集这些需求的一些技术。
- en: Knowing the context
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解背景
- en: 'When mining requirements, you should take into account the broader context.
    You must identify what potential problems may have a negative impact on your product
    in the future. Those risks often come from the outside. Let''s revisit our Uber-like
    service scenario. An example risk for your service could be a potential change
    in legislation: you should be aware that some countries may try to change the
    law to remove you from their market. Uber''s way to mitigate those risks is to
    have local partners cope with regional limitations.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖掘需求时，您应该考虑更广泛的背景。您必须确定未来可能对产品产生负面影响的潜在问题。这些风险通常来自外部。让我们重新审视我们类似Uber的服务场景。您的服务的一个例子风险可能是法律的潜在变化：您应该意识到一些国家可能会试图改变法律以将您从市场中移除。Uber减轻这些风险的方式是与当地合作伙伴应对地区限制。
- en: 'Future risks aside, you must also be aware of current issues, such as the lack
    of subject matter experts in the company, or heavy competition on the market.
    Here''s what you can do:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未来的风险之外，您还必须了解当前的问题，比如公司中缺乏主题专家，或市场上的激烈竞争。您可以做以下事情：
- en: Be aware of and note any assumptions being made. It's best to have a dedicated
    document for tracking those.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要注意并记录任何假设。最好有一个专门的文档来跟踪这些假设。
- en: Ask questions to clarify or eliminate your assumptions, if possible.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能提出问题以澄清或排除您的假设。
- en: You need to consider the dependencies inside your project, as they can influence
    the development schedule. Other useful areas are the business rules that shape
    the day-to-day behavior of the company, as your product will likely need to adhere
    to and possibly enhance those.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要考虑项目内部的依赖关系，因为它们可能会影响开发进度。其他有用的领域是塑造公司日常行为的业务规则，因为您的产品可能需要遵守并可能增强这些规则。
- en: Moreover, if there's enough data relating to the users or the business, you
    should try to mine it to get insights and find useful patterns that can help with
    making decisions regarding the future product and its architecture. If you already
    have some users but are unable to mine data, it's often useful to just observe
    how they behave.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果有足够的与用户或业务相关的数据，您应该尝试挖掘它以获取见解，并找到有用的模式，可以帮助做出关于未来产品及其架构的决策。如果您已经有一些用户，但无法挖掘数据，观察他们的行为通常也是有用的。
- en: Ideally, you could record them when they perform their daily tasks using the
    currently deployed systems. This way, you could not only automate parts of their
    work but also change their workflow to a more efficient one entirely. However,
    remember that users don't like changing their habits, so it's better to introduce
    changes gradually where possible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您可以在他们使用当前部署的系统执行日常任务时记录下来。这样，您不仅可以自动化他们工作的部分，还可以完全改变他们的工作流程为更高效的工作流程。然而，请记住，用户不喜欢改变他们的习惯，因此在可能的情况下逐渐引入变化更好。
- en: Knowing existing documentation
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解现有文档
- en: Existing documents can be a great source of information, even though they can
    also have their issues. You should reserve some time to at least get familiar
    with all the existing documents related to your work. Chances are that there are
    some requirements hidden in them. On the other hand, keep in mind that the documentation
    is never perfect; highly likely it will lack some significant information. You
    should also be prepared for it to be outdated. There is never one source of truth
    when it comes to architecture, so aside from reading documents, you should have
    lots of discussions with the people involved. Nonetheless, reading documents can
    be a great way of preparing yourself for such discussions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现有文件可以是信息的重要来源，尽管它们也可能存在问题。您应该至少留出一些时间来熟悉与您的工作相关的所有现有文件。很可能其中隐藏着一些需求。另一方面，要记住，文档永远不会完美；很可能会缺少一些重要信息。您还应该做好文档可能已过时的准备。在架构方面，从来没有一个真正的信息来源，因此除了阅读文档，您还应该与相关人员进行大量讨论。尽管如此，阅读文件可以是为此类讨论做好准备的好方法。
- en: Knowing your stakeholders
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的利益相关者
- en: 'To be a successful architect, you must learn to communicate with business people
    as requirements come, directly or indirectly, from them. Whether they''re from
    your company or a customer, you should get to know the context of their business.
    For instance, you must know the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为成功的架构师，你必须学会与商业人士沟通，因为需求直接或间接来自他们。无论是来自你的公司还是客户，你都应该了解他们业务的背景。例如，你必须了解以下内容：
- en: What drives the business?
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是什么推动业务？
- en: What goals does the company have?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司有什么目标？
- en: What specific objectives will your product help to achieve?
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的产品将帮助实现什么具体目标？
- en: Once you are aware of this, it will be much easier to establish a common ground
    with many people coming from management or executives, as well as gathering more
    specific requirements regarding your software. If the company cares about the
    privacy of its users, for instance, it can have a requirement to store as little
    data about its users as possible and to encrypt it using a key stored only on
    a user's device. Often, if such requirements come from the company culture, it
    will be too obvious for some employees to even articulate them. Knowing the context
    of the business can help you to ask proper questions and help the company in return.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你意识到这一点，与许多来自管理或高管的人建立共同基础，以及收集有关软件的更具体要求，将会更容易。例如，如果公司关心用户的隐私，它可以要求尽可能少地存储有关用户的数据，并使用仅存储在用户设备上的密钥进行加密。通常，如果这些要求来自公司文化，对一些员工来说，甚至表达这些要求都太明显了。了解业务背景可以帮助你提出适当的问题，并帮助公司回报。
- en: Having said that, remember that your stakeholders can, and will, have needs
    that aren't necessarily directly reflected in the company's objectives. They can
    have their own ideas for functionality to provide or metrics that the software
    should achieve. Perhaps a manager promised his employees a chance to learn a new
    technology or work with a specific one. If this project is important for their
    career, they can be a strong ally and even convince others as to your decisions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，请记住，您的利益相关者可能会有需求，这些需求不一定直接反映在公司的目标中。他们可能会有自己的功能提供或软件应该实现的指标的想法。也许一个经理承诺让他的员工有机会学习一种新技术或与特定技术一起工作。如果这个项目对他们的职业发展很重要，他们可能会成为强有力的盟友，甚至说服其他人支持你的决定。
- en: Another important group of stakeholders is the people responsible for deploying
    your software. They can come with their own subgroup of needs, called transition
    requirements. Examples of those include user and database migration, infrastructure
    transition, or data conversion, so don't forget to reach out to them to gather
    these as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的利益相关者群体是负责部署您的软件的人。他们可能会提出自己的需求子组，称为过渡需求。这些需求的例子包括用户和数据库迁移、基础设施过渡或数据转换，因此不要忘记与他们联系以收集这些需求。
- en: Gathering requirements from stakeholders
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从利益相关者那里收集需求
- en: 'At this point, you should have a list of stakeholders with their roles and
    contact information. Now it''s time to make use of it: be sure to make time to
    talk with each stakeholder about what they need from the system and how they envision
    it. You can hold interviews such as 1:1 meetings or group ones. When talking with
    your stakeholders, help them to make informed decisions – show the potential outcomes
    of their answers on the end product.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该有一个利益相关者列表，包括他们的角色和联系信息。现在是时候利用它了：一定要抽出时间与每个利益相关者谈论他们对系统的需求以及他们对系统的设想。你可以进行面谈，如一对一会议或小组会议。与利益相关者交谈时，帮助他们做出明智的决定——展示他们的答案对最终产品的潜在影响。
- en: It's common for stakeholders to say that all of their requirements are equally
    important. Try to persuade them to prioritize their requirements according to
    the value they bring to their business. Certainly, there will be some mission-critical
    requirements, but most probably, the project won't fail if a bunch of others won't
    be delivered, not to mention any nice-to-haves that will land on your requirements
    wish list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 利益相关者常常说他们所有的需求都同等重要。试着说服他们根据需求对他们的业务价值进行优先排序。当然，会有一些使命关键的需求，但很可能，如果一堆其他需求没有被交付，项目也不会失败，更不用说任何愿望清单上的附加需求了。
- en: 'Aside from interviews, you can also organize workshops for them, which could
    work like brainstorming sessions. In such workshops, once the common ground is
    established and everybody knows why they''re taking part in such a venture, you
    can start asking everyone for as many usage scenarios as they can think of. Once
    these have been established, you can proceed with consolidating similar ones,
    after which you should prioritize and, finally, refine all the stories. Workshops
    are not just about functional requirements; each usage scenario can have a quality
    attribute assigned as well. After refining, all the quality attributes should
    be measurable. The final thing to note is this: you don''t need to bring all stakeholders
    into such events, as they can sometimes take more than a day, depending on the
    size of the system.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了采访外，您还可以为他们组织研讨会，这可以像头脑风暴会议一样起作用。在这样的研讨会上，一旦建立了共同基础，每个人都知道他们为什么参与这样的冒险，您可以开始要求每个人尽可能多地提出使用场景。一旦这些场景确定下来，您可以开始整合相似的场景，然后应该对其进行优先排序，最后完善所有的故事。研讨会不仅仅是关于功能需求；每个使用场景也可以分配一个质量属性。在完善之后，所有的质量属性都应该是可衡量的。最后需要注意的是：您不需要将所有利益相关者都带到这样的活动中，因为它们有时可能需要超过一天的时间，这取决于系统的规模。
- en: Now that you know how to mine for requirements using various techniques and
    sources, let's discuss how to pour your findings into well-crafted documents.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用各种技术和来源挖掘需求，让我们讨论如何将您的发现倾注到精心制作的文档中。
- en: Documenting requirements
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录需求
- en: Once you're done with the steps described previously, it's time to put all the
    requirements you've gathered and refine them together in a single document. It
    doesn't matter what form the document will take and how you will manage it. What
    matters is that you have a document that puts all the stakeholders on the same
    page with regard to what is required from the product and what value each requirement
    brings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了前面描述的步骤，就该将您收集到的所有需求整理并精炼到一个文档中了。文档的形式和管理方式并不重要。重要的是您有一个文档，让所有利益相关者对产品的要求和每个需求带来的价值有一个共同的认识。
- en: Requirements are produced and consumed by all stakeholders, and a broad set
    of them will need to read your document. This means that you should write it so
    that it brings value for people of various technical skills from customers, salespeople,
    and marketers, through designers and project managers, to software architects,
    developers, and testers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 需求由所有利益相关者产生和消耗，他们中的广泛一部分将需要阅读您的文档。这意味着您应该以一种能够为各种技术技能的人带来价值的方式来撰写它，从客户、销售人员和营销人员，到设计师和项目经理，再到软件架构师、开发人员和测试人员。
- en: Sometimes it makes sense to prepare two versions of the document, one for the
    people closest to the business side of the project, and another, a more technical
    one, for the development team. However, usually, it's enough to just have one
    document written to be understandable by everyone, with sections (sometimes single
    paragraphs) or whole chapters meant to cover the more technical details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，准备文档的两个版本是有意义的，一个是针对项目业务方面的人员，另一个是更技术性的，针对开发团队。然而，通常，只需撰写一个文档，使每个人都能理解，其中包括用于涵盖更多技术细节的部分（有时是单独的段落）或整章。
- en: Let's now take a tour of what sections could go into your requirements document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看您的需求文档可能包含哪些部分。
- en: Documenting the context
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录上下文
- en: 'A requirements document should act as one of the entry points for people getting
    on board with your project: it should outline the purpose of your product, who
    will use it, and how it can be used. Before design and development, the product
    team members should read it to have a clear idea of what they''ll actually work
    on.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 需求文档应该作为项目的一个入口点之一：它应该概述产品的目的，谁将使用它，以及如何使用它。在设计和开发之前，产品团队成员应该阅读它，以清楚地了解他们将实际工作的内容。
- en: The context section should provide an overview of the system – why it's being
    built, what business goals is it trying to accomplish, and what key functionality
    it will deliver.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文部分应该提供系统的概述-为什么要构建它，它试图实现什么业务目标，以及它将提供什么关键功能。
- en: You can describe a few typical user personas, such as *John the CTO*, or *Ann
    the driver*, to give the readers a better chance to think about the users of the
    system as actual human beings and know what to expect from them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以描述一些典型的用户角色，比如*CTO约翰*，或者*司机安*，以便读者更有机会考虑系统的用户是实际的人类，并知道可以从他们那里期望什么。
- en: All those things described in the *Knowing the context* section should also
    be summarized as parts of this context section, or sometimes even given separate
    sections in the document. The context and scope sections should provide all the
    information required by most non-project stakeholders. They should be concise
    and precise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解上下文*部分中描述的所有事情也应该作为上下文部分的一部分进行总结，有时甚至在文档中单独给出部分。上下文和范围部分应该提供大多数非项目利益相关者所需的所有信息。它们应该简洁而准确。'
- en: 'The same goes for any open questions you may want to research and decide on
    later. For each decision you make, it''s best to note the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您可能想要研究并稍后决定的任何悬而未决的问题也是如此。对于您做出的每个决定，最好记录以下内容：
- en: What the decision itself was
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策本身是什么
- en: Who made it and when
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是谁做的，什么时候做的
- en: What rationale stands behind it
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背后的理由是什么
- en: Now that you know how to document the context of your project, let's learn how
    to properly describe its scope too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何记录项目的上下文，让我们学习如何正确描述其范围。
- en: Documenting the scope
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录范围
- en: This section should define what's in the scope of the project, as well as what
    is beyond the scope. You should provide a rationale for why the scope is defined
    in a particular way, especially when writing about things that won't make the
    cut.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分应该定义项目的范围，以及超出范围的内容。您应该解释为什么以特定方式定义范围的理由，特别是在写关于不会被采纳的事情时。
- en: This section should also cover the high-level functional and nonfunctional requirements,
    but details should go into the subsequent sections of the document. If you're
    familiar with Agile practices, just describe epics and bigger user stories here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分还应该涵盖高级功能和非功能性要求，但详细信息应该放在文档的后续部分。如果您熟悉敏捷实践，只需在这里描述史诗和更大的用户故事。
- en: If you or your stakeholders have any assumptions regarding the scope, you should
    mention those here. If the scope is subject to change due to any issues or risks,
    you should also write some words about it, and similarly for any trade-offs you
    had to make.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您或您的利益相关者对范围有任何假设，您应该在这里提到。如果范围由于任何问题或风险而可能发生变化，您也应该写一些相关内容，同样适用于您不得不做出的任何权衡。
- en: Documenting functional requirements
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录功能性要求
- en: 'Each requirement should be precise and testable. Consider this example: "The
    system will have a ranking system for the drivers." How would you create tests
    against it? It''s better to create a section for the ranking system and specify
    the precise requirements for it there.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个要求都应该是精确和可测试的。考虑这个例子："系统将为司机建立一个排名系统。"您会如何对其进行测试？最好为排名系统创建一个部分，并在那里指定精确的要求。
- en: 'Consider this other example: If there''s a free driver close to the rider,
    they should be notified of the incoming ride request. What if there''s more than
    one driver available? What maximum distance can we still describe as being *close*?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个例子：如果有一名空闲司机靠近乘客，他们应该被通知即将到来的乘车请求。如果有多名可用司机呢？我们仍然可以描述为“靠近”的最大距离是多少呢？
- en: This requirement is both imprecise and lacking parts of the business logic.
    We can only hope that the case where there are no free drivers is covered by another
    requirement.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个要求既不精确，也缺乏业务逻辑的部分。我们只能希望没有空闲司机的情况已经被另一个要求覆盖了。
- en: 'In 2009, Rolls Royce developed its **Easy Approach to Requirements Syntax**
    (**EARS**), to help cope with this. In EARS, there are five basic types of requirements,
    which should be written in a different way and serve different purposes. They
    can be later combined to create more complex requirements. Those basic ones are
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，劳斯莱斯开发了其**Easy Approach to Requirements Syntax**（**EARS**），以帮助应对这一问题。在EARS中，有五种基本类型的要求，它们应该以不同的方式编写并服务于不同的目的。它们可以后来组合成更复杂的要求。这些基本要求如下：
- en: '**Ubiquitous requirement**: "The `$SYSTEM` shall `$REQUIREMENT`," for example,
    the application will be developed in C++.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普遍要求**："`$SYSTEM`应该`$REQUIREMENT`"，例如，应用程序将使用C++开发。'
- en: '**Event-driven**: "When `$TRIGGER $OPTIONAL\_PRECONDITION` the `$SYSTEM` shall
    `$REQUIREMENT`," for example, "When an order arrives, the gateway will produce
    a NewOrderEvent.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动**："当`$TRIGGER $OPTIONAL\_PRECONDITION`时，`$SYSTEM`应该`$REQUIREMENT`"，例如，"当订单到达时，网关将产生一个NewOrderEvent。'
- en: '**Unwanted behavior**: "If `$CONDITION`, then the `$SYSTEM` shall `$REQUIREMENT`,"
    for example if the processing of the request takes longer than 1 second, the tool
    will display a progress bar.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不需要的行为**："如果`$CONDITION`，那么`$SYSTEM`应该`$REQUIREMENT`"，例如，如果请求的处理时间超过1秒，工具将显示一个进度条。'
- en: '**State-driven**: "While `$STATE`, the `$SYSTEM` shall `$REQUIREMENT`," for
    example, while a ride is taking place, the app will display a map to help the
    driver navigate to the destination.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态驱动**："当`$STATE`时，`$SYSTEM`应该`$REQUIREMENT`"，例如，当乘车进行时，应用程序将显示地图以帮助司机导航到目的地。'
- en: '**Optional feature**: "Where `$FEATURE`, the `$SYSTEM` shall `$REQUIREMENT`,"
    for example, where A/C is present, the app will let the user set the temperature
    through the mobile application.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选功能**："在`$FEATURE`的情况下，`$SYSTEM`应该`$REQUIREMENT`"，例如，如果有空调，应用程序将允许用户通过移动应用程序设置温度。'
- en: 'An example of a more complex requirement would be: When using a dual-server
    setup, if the backup server doesn''t hear from the primary one for 5 seconds,
    it should try to register itself as a new primary server.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的要求的例子是：在使用双服务器设置时，如果备份服务器在5秒内没有收到主服务器的消息，它应该尝试注册自己为新的主服务器。
- en: You don't need to use EARS, but it can help if you struggle with ambiguous,
    vague, overly complex, untestable, omissive, or otherwise badly worded requirements.
    Whatever way or wording you choose, be sure to use a concise model, which is based
    on common syntax and uses predefined keywords. It's also good practice to assign
    an identificator for each requirement you list, so you'll have an easy way to
    refer to them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用EARS，但如果您在处理模糊、含糊、过于复杂、不可测试、遗漏或者用词不当的要求时遇到困难，它可能会有所帮助。无论您选择哪种方式或措辞，都要确保使用基于常用语法并使用预定义关键字的简洁模型。为您列出的每个要求分配一个标识符也是一个好的做法，这样您就可以轻松地引用它们。
- en: 'When it comes to more detailed requirements formats, it should have the following
    fields:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更详细的要求格式时，它应该具有以下字段：
- en: '**ID or Index**: To easily identify a specific requirement.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID或索引**：方便识别特定要求。'
- en: '**Title**: You can use the EARS template here.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：您可以在这里使用EARS模板。'
- en: '**Detailed Description**: You can put whatever information you find relevant
    here, for example, user stories.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细描述**：您可以在这里放置您认为相关的任何信息，例如用户故事。'
- en: '**Owner**: Who this requirement serves. This can be the product owner, the
    sales team, legal, IT, and so on.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者**：这个要求是为谁服务的。可以是产品所有者、销售团队、法律部门、IT等等。'
- en: '**Priority**: Pretty self-explanatory.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：相当不言自明。'
- en: '**Deliver By**: If this requirement is needed for any key date, you can note
    it here.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付日期**：如果这个要求需要在任何关键日期之前完成，您可以在这里记录。'
- en: Now that we know how to document functional requirements, let's discuss how
    you should approach documenting the nonfunctional ones.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何记录功能性要求，让我们讨论一下您应该如何记录非功能性要求。
- en: Documenting nonfunctional requirements
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录非功能性要求
- en: Each quality attribute, such as performance or scalability, should have its
    own section in your document, with specific, testable requirements listed. Most
    of the QAs are measurable, so having specific metrics can do a world of good to
    resolve future questions. You can also have a separate section about the constraints
    that your project has.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个质量属性，比如性能或可扩展性，都应该在你的文档中有自己的部分，列出具体的、可测试的要求。大多数质量属性都是可衡量的，所以具体的度量标准可以在解决未来问题时起到很大作用。你也可以有一个关于项目约束的单独部分。
- en: With regard to wording, you can use the same EARS template to document your
    NFRs. Alternatively, you can also specify them as user stories using the personas
    that you defined in the context of this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 关于措辞，你可以使用相同的EARS模板来记录你的NFRs。或者，你也可以使用在本章节中定义的角色来将它们指定为用户故事。
- en: Managing the version history of your documentation
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理文档的版本历史
- en: 'You can take one of the two following approaches: either create a version log
    inside the document or use an external versioning tool. Both have their pros and
    cons, but we recommend going with the latter approach. Just like you use a version
    control system for your code, you can use it for your documentation. We''re not
    saying you must use a Markdown document stored in a Git repo, but that''s a perfectly
    valid approach as long as you''re also generating a **business people-readable**
    version of it, be it a web page or a PDF file. Alternatively, you can just use
    online tools, such as RedmineWikis, or Confluence pages, which allow you to put
    a meaningful comment describing what''s been changed on each edit you publish
    and to view the differences between versions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取以下两种方法之一：要么在文档内部创建一个版本日志，要么使用外部版本控制工具。两者都有各自的优缺点，但我们建议选择后者的方法。就像你为代码使用版本控制系统一样，你也可以用它来管理你的文档。我们并不是说你必须使用存储在Git仓库中的Markdown文档，但只要你也生成了一个**业务人员可读**的版本，比如网页或PDF文件，这也是一个完全有效的方法。或者，你也可以使用在线工具，比如RedmineWikis，或Confluence页面，它们允许你在每次发布编辑时放置一个有意义的评论来描述所做的更改，并查看版本之间的差异。
- en: 'If you decided to take a revision log approach, it''s usually a table that
    includes the following fields:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定采用修订日志的方法，通常是一个包括以下字段的表格：
- en: '**Revision**: A number identifying which iteration of the document the changes
    were introduced at. You can also add tags for special revisions, such as *the
    first draft*, if you so wish.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订**：标识引入变化的文档迭代的编号。如果你愿意，你也可以为特殊的修订添加标签，比如*第一稿*。'
- en: '**Updated by**: Who made the change.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新者**：谁做出了更改。'
- en: '**Reviewed by**: Who reviewed the change.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审查人**：谁审查了这个变化。'
- en: '**Change description**: A *commit message* for this revision. It states what
    changes have taken place.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改描述**：这个修订的*提交消息*。它说明了发生了什么变化。'
- en: Documenting requirements in Agile projects
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在敏捷项目中记录需求
- en: 'Many proponents of Agile would claim that documenting all the requirements
    is simply a waste of time as they will probably change anyway. However, a good
    approach is to treat them similarly to items in your backlog: the ones that will
    be developed in the upcoming sprints should be defined in more detail than the
    ones that you wish to implement later. Just like you won''t split your epics into
    stories and stories into tasks before it''s necessary, you can get away with having
    just roughly described, less granular requirements until you''re certain that
    you need them implemented.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 许多敏捷的支持者会声称记录所有需求只是浪费时间，因为它们可能会发生变化。然而，一个好的方法是将它们类似地对待你的待办事项中的项目：在即将到来的冲刺中将会开发的项目应该比你希望以后实施的项目更详细地定义。就像在必要之前你不会将史诗故事拆分成故事和任务一样，你可以只粗略地描述、不那么细粒度地定义需求，直到你确定需要它们被实施。
- en: Note who or what was the source of a given requirement so that you'll know how
    who can provide you with necessary input for refining it in the future.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意是谁或什么是给定需求的来源，这样你就会知道谁可以为你提供未来完善它所需的输入。
- en: 'Let''s take our Dominican Fair, for example. Say in the next sprint, we''ll
    be building the shop page for a visitor to view, and in the sprint after that
    one, we''ll be adding a subscription mechanism. Our requirements could look like
    the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的多米尼加集市为例。比如说在下一个冲刺中，我们将为访客构建商店页面，然后在下一个冲刺中，我们将添加一个订阅机制。我们的需求可能看起来像下面这样：
- en: '| **ID** | **Priority** | **Description** | **Stakeholders** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | **优先级** | **描述** | **利益相关者** |'
- en: '| DF-42 | P1 | The shop''s page must show the shop''s inventory, with a photo
    and price for each item. | Josh, Rick |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| DF-42 | P1 | 商店页面必须显示商店的库存，每件物品都有照片和价格。 | 乔什，瑞克 |'
- en: '| DF-43 | P2 | The shop''s page must feature a map with the shop''s location.
    | Josh, Candice |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| DF-43 | P2 | 商店页面必须包含商店位置的地图。 | 乔什，坎迪斯 |'
- en: '| DF-44 | P2 | Customers must be able to subscribe to shops. | Steven |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| DF-44 | P2 | 客户必须能够订阅商店。 | 史蒂文 |'
- en: As you can see, the first two items relate to the feature we'll be doing next.
    so they are described in more detail. Who knows, maybe before the next sprint,
    the requirement about subscriptions will be dropped, so it doesn't make sense
    to think about every detail of it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前两项与我们接下来要做的功能有关，所以它们被描述得更详细。谁知道，也许在下一个冲刺之前，关于订阅的需求就会被取消，所以考虑每个细节就没有意义了。
- en: 'There are cases, on the other hand, that would still require you to have a
    complete list of requirements. If you need to deal with external regulators or
    internal teams such as auditing, legal, or compliance, chances are they''ll still
    require a well-written physical document from you. Sometimes just handing them
    a document containing work items extracted from your backlog is OK. It''s best
    to communicate with such stakeholders just like with any other ones: gather their
    expectations to know the minimum viable documentation that satisfies their needs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有些情况可能仍需要你列出完整的需求清单。如果你需要与外部监管机构或内部团队（如审计、法律或合规性）打交道，他们可能仍然需要你提供一份完整的书面文件。有时，只需向他们提供一份包含从你的待办事项中提取的工作项的文件就可以了。最好像对待其他利益相关者一样与这些利益相关者沟通：了解他们的期望，以了解满足他们需求的最低可行文档。
- en: What's important about documenting requirements is to have an understanding
    between you and the parties proposing specific requirements. How can this be achieved?
    Once you have a draft ready to go, you should show your documentation to them
    and gather feedback. This way, you'll know what was ambiguous, unclear, or missing.
    Even if it takes a few iterations, it will help you have a common ground with
    your stakeholders, so you'll gain more confidence that you're building the right
    thing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记录需求的重要之处在于你和提出具体需求的各方之间有一个共识。如何实现这一点？一旦你准备好了草稿，你应该向他们展示你的文档并收集反馈。这样，你就会知道哪些地方含糊不清、不清楚或遗漏了。即使需要几次迭代，这也将帮助你与利益相关者达成共识，从而更有信心地确保你正在构建正确的东西。
- en: Other sections
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他部分
- en: It's a good idea to have a links and resources section in which you point to
    stuff such as the issue tracker boards, artifacts, CI, the source repo, and whatever
    else you'll find handy. Architectural, marketing, and other kinds of documents
    can also be listed here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站中设置一个链接和资源部分是个好主意，你可以在这里指向问题跟踪板、工件、持续集成、源代码库以及其他你觉得有用的东西。架构、营销和其他类型的文档也可以在这里列出。
- en: If needed, you can also include a glossary.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你也可以包括一个术语表。
- en: You now know how to document your requirements and related information. Let's
    now say a few words about documenting the designed system.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何记录你的需求和相关信息了。现在让我们简要谈谈如何记录设计的系统。
- en: Documenting architecture
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录架构
- en: 'Just as you should document your requirements, you should also document the
    emerging architecture. It''s certainly not just for the sake of having documentation:
    it should help each person involved in the project to be more productive by making
    them better understand what''s required from them and from the final product.
    Not all diagrams you''ll make will be useful for everyone, but you should create
    them from the perspective of their future readers.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你应该记录你的需求一样，你也应该记录新兴的架构。这当然不仅仅是为了有文档：它应该帮助项目中的每个人更加高效，让他们更好地理解他们需要做什么以及最终产品需要什么。你制作的并不是所有图表都对每个人都有用，但你应该从未来读者的角度来创建它们。
- en: 'There''s a multitude of frameworks to document your vision and many of them
    serve specific fields, project types, or architectural scopes. If you''re interested
    in documenting enterprise architecture, for instance, you could be interested
    in TOGAF. This is an acronym for *The Open Group Architecture Framework*. It relies
    on four domains, namely the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多框架可以用来记录你的愿景，其中许多框架专门服务于特定领域、项目类型或架构范围。如果你有兴趣记录企业架构，比如说，你可能会对TOGAF感兴趣。这是“开放组织架构框架”的缩写。它依赖于四个领域，即以下内容：
- en: Business architecture (strategy, organization, key processes, and governance)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务架构（战略、组织、关键流程和治理）
- en: Data architecture (logical and physical data management)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据架构（逻辑和物理数据管理）
- en: Application architecture (blueprints for individual systems)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用架构（单个系统的蓝图）
- en: Technical architecture (hardware, software, and network infrastructure)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术架构（硬件、软件和网络基础设施）
- en: Such grouping is useful if you document your software in the scope of the whole
    company or even broader ones. Other similar-scale frameworks include those developed
    by the **British Ministry of Defence** (**MODAF**) and the **American equivalent**
    (**DoDAF**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在整个公司范围内或者更广泛的范围内记录你的软件，这种分组是有用的。其他类似规模的框架包括英国国防部（MODAF）和美国国防部（DoDAF）开发的框架。
- en: If you're not documenting enterprise architectures, and especially if you're
    just starting on your architectural self-development path, you'll probably be
    more interested in other frameworks, such as the 4+1 and C4 models.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在记录企业架构，尤其是如果你刚开始自己的架构自我发展之路，你可能会对其他框架更感兴趣，比如4+1和C4模型。
- en: Understanding the 4+1 model
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解4+1模型
- en: The 4+1 view model was created by Philippe Kruchten in 1995\. The author then
    claimed it is intended for "describing the architecture of software-intensive
    systems, based on the use of multiple, concurrent views." Its name comes from
    the views it consists of.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 4+1视图模型是由Philippe Kruchten于1995年创建的。作者当时声称它旨在“描述基于多个并发视图使用的软件密集型系统的架构”。它的名称来源于它包含的视图。
- en: This model is widely known since it has been on the market for so long and does
    its job. It's well suited for bigger projects and while it can be used for small-
    and medium-sized ones as well, it can also turn out too complex for their needs
    (especially if they're written in an Agile way). If that's your case, you should
    try out the C4 model described in the next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型因为在市场上存在已久并且发挥了作用而广为人知。它非常适合大型项目，虽然也可以用于中小型项目，但对于它们的需求来说可能过于复杂（特别是如果它们是以敏捷方式编写的）。如果你的情况是这样，你应该尝试下一节中描述的C4模型。
- en: A downside to the 4+1 model is that it uses a fixed set of views, while a pragmatic
    approach to document architecture would be to choose views based on the specifics
    of your project (more on that later).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 4+1模型的一个缺点是它使用了一组固定的视图，而实际上，对架构进行文档化的务实方法应该是根据项目的具体情况选择视图（稍后详述）。
- en: 'A nice upside, on the other hand, is how the views link together, especially
    when it comes to scenarios. At the same time, each stakeholder can easily get
    the parts of the model relevant to them. This brings us to how the model appears:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个很好的优势是视图之间的链接，特别是在场景方面。同时，每个利益相关者都可以轻松地获得与他们相关的模型部分。这将引出模型的外观：
- en: '![](img/c00a75c2-c3b7-4b1e-a6dc-f0ed40f39339.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c00a75c2-c3b7-4b1e-a6dc-f0ed40f39339.png)'
- en: Figure 3.1 – An overview of the 4+1 model
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 4+1模型概述
- en: 'Actors in the preceding diagram are the ones most interested in their corresponding
    views. All the views can be represented using different kinds of **Unified Modeling
    Language** (**UML**) diagrams. Let''s now discuss each view:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的参与者是最感兴趣的各自视图。所有视图都可以用不同类型的**统一建模语言**（**UML**）图表来表示。现在让我们讨论每个视图：
- en: '**The logical view** shows how functionality is provided to users. It shows
    the system''s components (objects) and how they interact with each other. Most
    commonly, it consists of class and state diagrams. If you have thousands of classes
    or just want to better show the interactions between them, you should also have
    communication or sequence diagrams, both being parts of our next view:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑视图**显示如何向用户提供功能。它显示系统的组件（对象）以及它们之间的交互。通常，它由类和状态图组成。如果你有成千上万的类，或者只是想更好地展示它们之间的交互，你还应该有通信或序列图，它们都是我们下一个视图的一部分：'
- en: '![](img/f5752842-53db-436d-9519-f63a178633c4.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5752842-53db-436d-9519-f63a178633c4.png)'
- en: Figure 3.2 – Class diagrams can be used to show what types we plan to have,
    along with their relations
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 类图可用于显示我们计划拥有的类型及其关系
- en: '**The process view** revolves around the system''s runtime behavior. It shows
    processes, the communication between them, and interactions with external systems.
    It''s represented by activity and interaction diagrams. This view addresses many
    NFRs, including concurrency, performance, availability, and scalability:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程视图**围绕系统的运行时行为展开。它显示进程、它们之间的通信以及与外部系统的交互。它由活动和交互图表示。该视图涉及许多NFR，包括并发性、性能、可用性和可扩展性。'
- en: '![](img/3104e8d9-3c79-43e3-9c54-fc0f9afbdead.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3104e8d9-3c79-43e3-9c54-fc0f9afbdead.png)'
- en: Figure 3.3 – Activity diagrams are graphical representations of workflows and
    processes
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 活动图是工作流程和流程的图形表示
- en: '**The development view** is for decomposing into subsystems and revolves around
    software organization. Reuse, tooling constraints, layering, modularization, packaging,
    execution environments – this view can represent them by showing a building-block
    decomposition of the system. It does so by using components and package diagrams:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发视图**用于将系统分解为子系统，并围绕软件组织展开。重用、工具约束、分层、模块化、打包、执行环境 - 该视图可以通过显示系统的构建块分解来表示它们。它通过使用组件和包图来实现：'
- en: '![](img/431900b8-0b52-46b0-9021-4e0e28341238.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/431900b8-0b52-46b0-9021-4e0e28341238.png)'
- en: Figure 3.4 – Package diagrams can show the parts of a system from a higher perspective,
    as well as dependencies or relations between specific components
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 包图可以从更高的角度显示系统的部分，以及特定组件之间的依赖或关系
- en: '**The physical view** is used to map software to hardware using deployment
    diagrams. Aimed at system engineers, it can cover a subset of NFRs concerned with
    the hardware, for example, communication:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理视图**用于使用部署图将软件映射到硬件。针对系统工程师，它可以涵盖与硬件相关的一部分NFR，例如通信：'
- en: '![](img/693cdedc-e843-429f-b544-d6d783b884c7.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/693cdedc-e843-429f-b544-d6d783b884c7.png)'
- en: Figure 3.5 – Deployment diagrams demonstrate the hardware on which each software
    component will run. It can also be used to pass on information regarding the network
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 部署图展示每个软件组件将在哪些硬件上运行。它还可以用于传递有关网络的信息
- en: '**The scenarios** are gluing all the other views together. Represented by use
    case diagrams, these can be useful for all stakeholders. This view shows whether
    the system does what it should and that it is consistent. When all other views
    are finished, the scenario view can be redundant. However, all the other views
    wouldn''t be possible without usage scenarios. This view shows the system from
    a high level, while the other views go into the details:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**将所有其他视图粘合在一起。通过用例图表示，这对所有利益相关者都有用。该视图显示系统是否按照应有的方式运行，并且是一致的。当所有其他视图完成时，场景视图可能会变得多余。然而，没有使用场景，其他视图就不可能存在。该视图从高层次显示系统，而其他视图则进入细节：'
- en: '![](img/0b88b24d-e5b2-4655-a29c-c04eae0d2447.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b88b24d-e5b2-4655-a29c-c04eae0d2447.png)'
- en: Figure 3.6 – Use case diagrams show how specific actors interact with the system
    and how the interactions relate to each other
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 用例图显示特定参与者如何与系统交互以及这些交互之间的关系
- en: 'Each of those views is interconnected with the others and often they must coexist
    to show the full picture. Let''s think about expressing concurrency. It can''t
    be done using only the logical view, as it''s more expressive to map them to tasks
    and processes; we need the process view. On the other hand, the processes will
    be mapped to physical, often distributed, nodes. This means we''ll need to effectively
    document it in three views, each of which will be relevant for a specific group
    of stakeholders. Other connections between the views include the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图中的每一个都与其他视图相互关联，通常它们必须共存以展示完整的画面。让我们考虑表达并发性。仅使用逻辑视图无法完成，因为将其映射到任务和流程更具表现力；我们需要过程视图。另一方面，流程将被映射到物理的、通常是分布式的节点。这意味着我们需要有效地在三个视图中记录它，每个视图对特定的利益相关者都是相关的。视图之间的其他连接包括以下内容：
- en: Both logical and process views are used in analysis and design to conceptualize
    the product.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑视图和过程视图在分析和设计中用于概念化产品。
- en: Development and deployment in conjunction describe how the software is packaged
    and when each package will get deployed.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发和部署结合描述了软件的打包以及每个软件包的部署时间。
- en: The logical and development views show how the functionality is reflected in
    the source code.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑和开发视图显示功能如何在源代码中反映出来。
- en: The process and deployment views are meant to collectively describe NFRs.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程和部署视图旨在共同描述非功能需求。
- en: 'Now that you''re familiar with the 4+1 model, let''s discuss another one, which
    is simple, yet extremely effective: the C4 model. We hope using it will be a blast
    (pun intended).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了4+1模型，让我们讨论另一个简单但极其有效的模型：C4模型。我们希望使用它会很有趣（双关语）。
- en: Understanding the C4 model
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解C4模型
- en: The C4 model is a great fit for small- to medium-sized projects. It's easy to
    apply, as it's quite simple and it doesn't rely on any predefined notation. If
    you want to start diagramming using it, you can try out Tobias Shochguertel's
    c4-draw.io plugin ([https://github.com/tobiashochguertel/c4-draw.io](https://github.com/tobiashochguertel/c4-draw.io))
    for the free online drawing tool – draw.io ([https://www.draw.io/](https://www.draw.io/)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C4模型非常适合中小型项目。它易于应用，因为它非常简单，不依赖于任何预定义的符号。如果您想要开始使用它进行图表绘制，可以尝试Tobias Shochguertel的c4-draw.io插件（[https://github.com/tobiashochguertel/c4-draw.io](https://github.com/tobiashochguertel/c4-draw.io)）用于免费在线绘图工具draw.io（[https://www.draw.io/](https://www.draw.io/)）。
- en: 'In the C4 model, there are four main types of diagram, namely the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在C4模型中，有四种主要类型的图表，即以下：
- en: Context
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文
- en: Container
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Component
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Code
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: Just like zooming in and out using a map, you can use those four types to show
    more details of a particular code region or "zoom out" to show more about the
    interactions and surroundings of either a specific module or even the whole system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用地图放大和缩小一样，您可以使用这四种类型来显示特定代码区域的更多细节，或者“缩小”以显示有关特定模块甚至整个系统的更多交互和周围环境的信息。
- en: 'The system context is a great starting point for looking at the architecture,
    as it shows the system as a whole, surrounded by its users and other systems that
    it interacts with. You can take a look at an example C4 context diagram here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上下文是查看架构的绝佳起点，因为它显示了系统作为一个整体，周围是其用户和与之交互的其他系统。您可以在这里查看一个C4上下文图的示例：
- en: '![](img/a823121c-a913-44b9-a2fd-360ea2e9d2f0.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a823121c-a913-44b9-a2fd-360ea2e9d2f0.png)'
- en: Figure 3.7 – A C4 context diagram
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - C4上下文图
- en: As you can see, it shows the "big picture," so it shouldn't focus on specific
    technologies or protocols. Instead, think of it as a diagram that could also be
    shown to non-technical stakeholders. Just by looking at the diagram, it should
    be clear that there's one actor involved (the human-shaped depiction of the customer),
    who interacts with one of the components of our solution, namely, the customer
    service system. This system, on the other hand, interacts with two more, with
    each of the interactions described along with the arrows.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它显示了“大局”，因此不应该专注于特定的技术或协议。相反，将其视为一张图表，也可以展示给非技术利益相关者。仅仅通过看图，应该清楚地看到有一个参与者（客户的人形描述），他与我们解决方案的一个组件进行交互，即客户服务系统。另一方面，这个系统与另外两个系统进行交互，每个交互都有箭头描述。
- en: 'The context diagram we described is used to provide an overview of the system
    with few details. Let''s now look at the other diagrams one by one:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述的上下文图用于提供系统的概览，但没有太多细节。现在让我们逐个查看其他图表：
- en: '**Container diagram**: This one is for showing the overview of the system internals.
    If your system uses a database, offers services, or just consists of certain applications,
    this diagram will show it. It can also show the major technology choices for the
    containers. Note that containers don''t mean Docker containers; although each
    is a separately runnable and deployable unit, this diagram type is not about deployment
    scenarios. The container view is meant for technical people but isn''t limited
    to the development team only. Architects, as well as operations and support, are
    the intended audience, too.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器图：这个图表用于显示系统内部的概览。如果您的系统使用数据库、提供服务，或者只是由某些应用程序组成，这个图表会显示出来。它还可以显示容器的主要技术选择。请注意，容器并不意味着Docker容器；尽管每个容器都是一个可以单独运行和部署的单元，但这种图表类型并不涉及部署场景。容器视图是为技术人员准备的，但并不仅限于开发团队。架构师、运维和支持人员也是预期的受众。
- en: '**Component diagram**: If you want more details about a specific container,
    this is where the component diagram comes into play. It shows how the components
    inside a selected container interact with each other, as well as with elements
    and actors outside the container. By looking at this diagram, you can learn about
    the responsibilities of each component and what technology it''s being built with.
    The intended audience for component diagrams is mostly focused around a specific
    container and consists of the development team and the architect.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件图表：如果您想要了解特定容器的更多细节，那么组件图表就派上用场了。它显示了所选容器内部组件之间的交互，以及与容器外部的元素和参与者的交互。通过查看这个图表，您可以了解每个组件的责任以及它所使用的技术。组件图表的目标受众主要集中在特定容器周围，包括开发团队和架构师。
- en: '**Code diagrams**: We finally come to code diagrams, which emerge when you
    zoom in to a specific component. This view consists mostly of UML diagrams, including
    class, entity-relationship, and others, and ideally should be created automatically
    from source code by standalone tools and IDEs. You should definitely not make
    such diagrams for each component in your system; instead, focus on making them
    for the most important ones in a way that allows them to actually tell the reader
    what you wanted to tell. This means that less can be more in such diagrams, so
    you should omit unnecessary elements from code diagrams. In many systems, especially
    smaller ones, this class of diagram is omitted. The target audience is the same
    as in the case of component diagrams.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码图表：最后我们来到了代码图表，当您放大到特定组件时，这些图表就会出现。这个视图主要由UML图表组成，包括类、实体关系等，理想情况下应该由独立工具和集成开发环境自动创建。您绝对不应该为系统中的每个组件制作这样的图表；相反，应该专注于为最重要的组件制作图表，以便它们真正告诉读者您想要传达的信息。这意味着在这样的图表中，少即是多，因此您应该省略代码图表中的不必要元素。在许多系统中，特别是较小的系统中，这类图表是被省略的。目标受众与组件图表的情况相同。
- en: 'You may find the C4 model lacking some specific views. If you''re wondering
    how to demonstrate how your system should be deployed, for instance, you might
    be interested to learn that aside from the main diagrams, there are also a few
    supplementary ones. One of them is the deployment diagram, which you can see next.
    It shows how containers in your system are mapped to nodes in your infrastructure.
    In general, it''s a simpler version of UML''s deployment diagram:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现C4模型缺少一些特定的视图。例如，如果您想知道如何展示系统的部署，那么您可能会对除了主要图表之外的一些补充图表感兴趣。其中之一是部署图，您可以在下面看到。它展示了系统中的容器如何映射到基础设施中的节点。总的来说，这是UML部署图的一个简化版本：
- en: '![](img/9f6c6238-84f2-4e82-b39c-d8852099b930.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f6c6238-84f2-4e82-b39c-d8852099b930.png)'
- en: Figure 3.8 – A C4 deployment diagram
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - C4部署图
- en: Speaking of UML diagrams with regard to the C4 model, you might also wonder
    why it puts such little effort into presenting the system's use cases. If that's
    your case, then you should think about supplementing the preceding models with
    either the use case diagram from UML or perhaps think about introducing some sequence
    diagrams.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到C4模型的UML图，您可能会想知道为什么它对呈现系统的用例付出如此少的努力。如果是这种情况，那么您应该考虑用UML的用例图或者考虑引入一些序列图来补充前面的模型。
- en: When documenting architecture, it's more important what you document and what
    knowledge you share than to follow a specific hard set of rules. Choose whatever
    tools suit your needs the best.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录架构时，更重要的是您记录了什么知识和分享了什么，而不是遵循特定的硬性规则。选择最适合您需求的工具。
- en: Documenting architecture in Agile projects
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在敏捷项目中记录架构
- en: In Agile environments, your approach to documenting architecture should be similar
    to the one about documenting requirements. First and foremost, consider who will
    be reading the materials you prepare to be sure you're describing the right things
    in the right way. Your documentation doesn't need to be a lengthy Word document.
    You can use presentations, wiki pages, single diagrams, or even recordings from
    meetings when someone describes the architecture.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷环境中，您记录架构的方法应该与记录需求的方法类似。首先，考虑谁将阅读您准备的材料，以确保您以正确的方式描述了正确的事物。您的文档不需要是冗长的Word文档。您可以使用演示文稿、维基页面、单个图表，甚至是会议记录，当有人描述架构时。
- en: What is important is to gather feedback on the documented architecture. Again,
    in the same way, as with the documented requirements, it's important to reiterate
    the documents with your stakeholders to know where to improve them. Even though
    this may seem like you're wasting time, if done properly, it should save you some
    time in terms of delivering the product. Good enough documentation should help
    newcomers to start being productive faster and guide more familiar stakeholders
    down the road. If you just discuss the architecture at some meetings, chances
    are, a quarter later, no one will remember why you made the decisions you made
    and whether they will remain valid in the ever-changing, Agile landscape.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是收集有关记录架构的反馈。同样，与记录需求一样，与利益相关者重复文档是重要的，以了解在哪里改进它们。即使这看起来可能会浪费时间，但如果做得当，它应该能节省您一些交付产品的时间。足够好的文档应该帮助新手更快地开始工作，并引导更熟悉的利益相关者走下去。如果您只是在一些会议上讨论架构，很可能在一个季度后，没有人会记得您为什么做出这些决定，以及它们是否在不断变化的敏捷环境中仍然有效。
- en: Reiteration is important when creating documentation because most probably there
    will be some misunderstanding of an important detail or two. Other times, you
    or your stakeholders will gain more knowledge and decide to change things. Be
    prepared to go through the document at least a few times before it will be considered
    mature and done. Often, a few conversations over IM, phone, or in-person will
    help you finish it quicker and address any follow-ups that could arise, so prefer
    those to emails or other asynchronous ways of communication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文档时，重复是重要的，因为很可能会有一些重要细节的误解。其他时候，您或您的利益相关者会获得更多知识并决定改变事物。在文档被认为成熟和完成之前，准备至少多次审查文档。通常，通过即时通讯、电话或面对面的几次对话将帮助您更快地完成，并解决可能出现的任何后续问题，因此更倾向于这些方式而不是电子邮件或其他异步的沟通方式。
- en: Choosing the right views to document
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的视图来记录
- en: 'Architecture is way too complex a topic to be described by a single big diagram.
    Imagine you''re the architect of a building. To design the whole thing, you''d
    need separate diagrams for different aspects: one for plumbing, another one for
    electricity and other cables, and so on. Each of those diagrams would show a different
    view of the project. The same goes for software architecture: you need to present
    the software from different perspectives, aimed at different stakeholders.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是一个太复杂的主题，无法用一个大图来描述。想象一下您是一栋建筑的建筑师。为了设计整个建筑，您需要为不同方面制作单独的图表：一个用于管道，另一个用于电力和其他电缆，依此类推。这些图表中的每一个都会展示项目的不同视图。软件架构也是如此：您需要从不同的角度呈现软件，以满足不同的利益相关者。
- en: 'Moreover, if you were building a smart house, chances are you would draw some
    plan of the devices you want to place around. Although not all projects will require
    such views, since it plays a role in your project, it may be worth adding it.
    The same approach is also valid for architecture: if you find a different view
    valuable to the document, you should do it. So, how do you know which views could
    be valuable? You can try to perform the following steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您正在建造一个智能房屋，很可能会绘制一些设备放置的计划。尽管并非所有项目都需要这样的视图，但由于它在您的项目中起着作用，可能值得添加。对于架构也是同样的方法：如果您发现不同的视图对文档有价值，那么您应该这样做。那么，您如何知道哪些视图可能有价值呢？您可以尝试执行以下步骤：
- en: Start with the views from either the 4+1 model or the C4 model.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从4+1模型或C4模型开始选择视图。
- en: Ask your stakeholders what is essential for them to have documented and think
    about modifying your set of views.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 询问您的利益相关者对他们来说什么是必要的，并考虑修改您的视图集。
- en: Choose views that will help you to evaluate whether the architecture meets its
    objectives and that all the ASRs are satisfied. Read the first paragraph of each
    of the views from the next sections to check whether they suit your needs.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择能帮助您评估架构是否达到其目标并且所有ASR是否满足的视图。阅读下一节中每个视图的第一段，以检查它们是否符合您的需求。
- en: 'If you''re still not sure which views to document, here''s a set of tips:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然不确定要记录哪些视图，以下是一些提示：
- en: Try to just pick the most important views, because when there are too many of
    them, the architecture will become too hard to follow. A good set of views should
    not only showcase the architecture but also expose the technical risks to the
    project.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量只选择最重要的视图，因为如果太多，架构将变得难以跟踪。一个好的视图集不仅应该展示架构，还应该暴露项目的技术风险。
- en: There are a few things you should think about when choosing what views you should
    describe in your documentation. We'll describe them shortly here, but if you're
    interested, you should grab *Rozanski and Woods*' book mentioned in the *Further
    reading* section.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要在文档中描述的视图时，有一些事情您应该考虑。我们将在这里简要描述它们，但如果您感兴趣，可以查看*罗赞斯基和伍兹*在*进一步阅读*部分提到的书籍。
- en: Functional view
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能视图
- en: If your software is being developed as part of a bigger system, especially with
    teams that don't communicate on a daily basis, you should include a functional
    view (as in the 4+1 model).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的软件是作为更大系统的一部分开发的，特别是与不经常交流的团队，您应该包括一个功能视图（如4+1模型）。
- en: One important and often overlooked aspect of documenting your architecture is
    the definition of the interfaces you provide, despite it being one of the most
    important things to describe. Whether it's an interface between two of your components
    or an entry point for the outside world, you should take the time to document
    it clearly, describing the semantics of objects and calls, as well as usage examples
    (which you can sometimes reuse as tests).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 文档化架构的一个重要且经常被忽视的方面是定义您提供的接口，尽管这是描述的最重要的事情之一。无论是两个组件之间的接口还是外部世界的入口点，您都应该花时间清楚地记录它，描述对象和调用的语义，以及使用示例（有时可以重复使用为测试）。
- en: Another great benefit of including a functional view in your documentation is
    that it clarifies the responsibilities between components of your system. Each
    team developing the system should understand where the boundaries are and who's
    responsible for developing which functionality. All requirements should be explicitly
    mapped to components to eliminate gaps and duplicated work.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档中包括功能视图的另一个重要好处是澄清系统各组件之间的责任。开发系统的每个团队都应该了解边界在哪里，以及谁负责开发哪些功能。所有需求都应明确映射到组件，以消除差距和重复工作。
- en: An important thing to note here is to avoid overloading your functional view.
    If it gets messy, no one will want to read it. If you're starting to describe
    infrastructure on it, consider adding a deployment view. If you end up having
    a *God object* in your models, try to rethink the design and split it into smaller,
    more cohesive pieces.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是避免过度加载功能视图。如果变得混乱，没有人会想要阅读它。如果您开始在其中描述基础设施，请考虑添加部署视图。如果您的模型中出现了“上帝对象”，请尝试重新思考设计并将其拆分为更小、更具凝聚力的部分。
- en: 'One last important note about the functional view: try to keep each diagram
    you include on one level of abstraction. On the other hand, don''t make it too
    vague by choosing an overly abstract level; ensure that every element is properly
    defined and understood by the interested parties.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关于功能视图的最后一个重要说明是，尽量保持每个包含的图表在一个抽象级别上。另一方面，不要选择过于抽象的级别使其变得太模糊；确保每个元素都得到了相关方的明确定义和理解。
- en: Information view
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息视图
- en: If your system has non-straightforward needs with regard to information, its
    processing flow, management process, or storage, perhaps it's a good idea to include
    this kind of view.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统在信息、处理流程、管理流程或存储方面有非直接的需求，也许包括这种视图是个好主意。
- en: Take the most important, data-rich entities and demonstrate how they flow through
    the system, who owns them, and who the producers and consumers are. It may be
    useful to mark how long certain data remains "fresh" and when it can be safely
    discarded, what the expected latency for it to arrive at certain points of the
    system is, or how to deal with identifiers if your system works in a distributed
    environment. If your system manages transactions, this process, along with any
    rollbacks, should also be clear to your stakeholders. Techniques for transforming,
    sending, and persisting data can also be important for some of them. If you are
    operating in the financial domain or have to deal with personal data, you most
    probably must obey some regulations, so describe how your system plans to tackle
    this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最重要的、数据丰富的实体，并展示它们如何在系统中流动，谁拥有它们，生产者和消费者是谁。标记某些数据保持“新鲜”的时间以及何时可以安全丢弃，预期到达系统某些点的延迟是多少，或者在分布式环境中如何处理标识符可能会有用。如果您的系统管理交易，这个过程以及任何回滚也应该清晰地展示给利益相关者。转换、发送和持久化数据的技术对其中一些人也可能很重要。如果您在金融领域工作或者必须处理个人数据，您很可能必须遵守一些法规，因此描述您的系统计划如何应对这些是很重要的。
- en: The structure of your data can be diagrammed using UML class models. Remember
    to be clear about the format of your data, especially if it flows between two
    different systems. NASA lost the $125 million-worth Mars Climate Orbiter, which
    it co-developed with Lockheed Martin, because they used different units unknowingly,
    so keep an eye out for data inconsistencies between systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据结构可以使用UML类模型进行图表化。请记住要清楚地描述您的数据格式，特别是如果它在两个不同的系统之间流动。美国宇航局与洛克希德·马丁合作开发的火星气候轨道飞行器价值1.25亿美元的失误，就是因为他们无意中使用了不同的单位，因此要注意系统之间的数据不一致性。
- en: The processing flow of your data can use UML's activity model, and to show the
    life cycle of information, a state diagram can be used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据处理流程可以使用UML的活动模型，并且可以使用状态图来展示信息的生命周期。
- en: Concurrency view
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发视图
- en: If running many concurrent units of execution is an important aspect of your
    product, consider adding a concurrency view. It can show what issues and bottlenecks
    you may have (unless that sounds too detailed). Other good reasons to include
    it are the reliance on interprocess communication, having a non-straightforward
    task structure, concurrent state management, synchronization, or task failure
    handling logic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行许多并发执行单元是产品的一个重要方面，请考虑添加并发视图。它可以显示您可能遇到的问题和瓶颈（除非听起来太详细）。包括它的其他好理由是依赖进程间通信，具有非直观的任务结构，并发状态管理，同步或任务失败处理逻辑。
- en: Use whatever notation you want for this view, as long as it captures the units
    of execution and their communication. Assign priorities to your processes and
    threads, if necessary, and then analyze any potential issues, such as deadlocks
    or contention. You can use state diagrams to show the possible states and their
    transitions for important units of execution (waiting for queries, executing a
    query, distributing results, and so on).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个视图，您可以使用任何您想要的符号，只要它能捕捉到执行单元及其通信。如果需要，为您的进程和线程分配优先级，然后分析任何潜在的问题，比如死锁或争用。您可以使用状态图来显示重要执行单元的可能状态及其转换（等待查询、执行查询、分发结果等）。
- en: If you're not sure about the need to introduce concurrency to your system, a
    good rule of thumb is *don't*. And if you must, strive for a simple design. Debugging
    concurrency issues is never easy and always long, so if possible, try to optimize
    what you have first instead of just throwing more threads at the problem at hand.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否需要向系统引入并发，一个好的经验法则是*不要*。如果必须引入，并且力求简单的设计。调试并发问题从来都不容易，而且总是很耗时，所以如果可能的话，尝试优化您现有的东西，而不是仅仅向问题投入更多的线程。
- en: If, by looking at your diagram, you're worried about resource contention, try
    to replace locks on big objects with more locks, but finer-grained, use lightweight
    synchronization (sometimes atomics are enough), introduce optimistic locking,
    or reduce what's shared (creating an additional copy of some data in a thread
    and processing it can be faster than sharing access to the only copy).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过查看您的图表，您担心资源争用，请尝试用更多、但更细粒度的锁替换大对象上的锁，使用轻量级同步（有时原子操作就足够了），引入乐观锁定，或减少共享的内容（在线程中创建一份数据的额外副本并处理它可能比共享对唯一副本的访问更快）。
- en: Development view
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发视图
- en: If you're building a big system with lots of modules, and you need to structure
    your code, have system-wide design constraints, or if you want to share some common
    aspects between parts of your system, presenting the solution from a development
    viewpoint should benefit you, along with software developers and testers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个具有许多模块的大型系统，并且需要结构化您的代码，具有系统范围的设计约束，或者如果您希望在系统的各个部分之间共享一些共同的方面，那么从开发的角度呈现解决方案应该对您有益，以及软件开发人员和测试人员。
- en: A package diagram of the development view can be handy to show where different
    modules in your system are located, what their dependencies are, and other related
    modules (for example, residing in the same software layer). It doesn't need to
    be a UML diagram – even boxes and lines would do. If you plan for a module to
    be replaceable, this kind of diagram can show you what other software packages
    can be affected.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 开发视图的包图可以很方便地显示系统中不同模块的位置，它们的依赖关系以及其他相关模块（例如，位于相同的软件层）。它不需要是UML图表 - 即使是方框和线条也可以。如果您计划将一个模块替换掉，这种类型的图表可以显示哪些其他软件包可能会受到影响。
- en: Tactics to increase reuse in your system, such as creating your own runtime
    framework for components, or tactics for increasing the coherence of your systems,
    such as a common approach to authentication, logging, internationalization, or
    other kinds of processing, are all part of the development view. If you see any
    common parts of the system, document it to be sure that all developers see them
    too.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 增加系统中重用的策略，例如为组件创建自己的运行时框架，或者增加系统的一致性的策略，例如对认证、日志记录、国际化或其他类型的处理采用共同的方法，都属于开发视图的一部分。如果您发现系统中有共同的部分，请确保所有开发人员也能看到它们。
- en: A common approach to code organization, building, and configuration management
    should also go into this section of your documentation. If all this sounds like
    a lot to document, then focus on the most important parts and cover the rest just
    briefly, if at all.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 代码组织、构建和配置管理的常见方法也应该包括在文档的这一部分。如果所有这些听起来都需要大量文档记录，那么重点关注最重要的部分，如果可能的话，简要涵盖其余部分。
- en: Deployment and operational views
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和运行视图
- en: If you have a non-standard or complex deployment environment, such as specific
    needs with regard to hardware, third-party software or networking requirements,
    consider documenting it in a separate deployment section, aimed at system administrators,
    developers, and testers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个非标准或复杂的部署环境，例如硬件、第三方软件或网络需求方面的特定需求，请考虑在一个单独的部署部分中记录它，针对系统管理员、开发人员和测试人员。
- en: 'If necessary, cover the following things:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要，涵盖以下内容：
- en: The amount of memory required
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的内存量
- en: The CPU thread count (with or without hyperthreading)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU线程数（是否启用超线程）
- en: Pinning and affinity with regard to NUMA nodes
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于NUMA节点的固定和亲和性
- en: Specialist networking equipment requirements, such as switches that mark packages
    to measure latency and throughput in a black-box manner
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业的网络设备要求，例如标记数据包以以黑盒方式测量延迟和吞吐量的交换机
- en: The networking topology
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络拓扑
- en: The estimated bandwidth required
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的估计带宽
- en: Storage requirements for your app
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的存储需求
- en: Any third-party software that you plan to use
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您计划使用的任何第三方软件
- en: Once you have the requirements, you can map them to specific hardware and put
    them into a runtime platform model. You can use a UML deployment diagram with
    stereotypes if you desire formal modeling. This should show your processing nodes
    and client nodes, online and offline storage, network links, specialized hardware,
    such as firewalls or FPGA or ASIC devices, and a mapping between functional elements
    and the nodes they'll run on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了需求，您可以将它们映射到特定的硬件，并将其放入运行时平台模型中。如果您需要正式建模，可以使用UML部署图与构造型。这应该显示您的处理节点和客户节点、在线和离线存储、网络链接、专用硬件（如防火墙或FPGA或ASIC设备）以及功能元素与它们将在其上运行的节点之间的映射。
- en: If you have non-straightforward networking needs, you can add another diagram
    showing the networking nodes and the connections between them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有非直接的网络需求，可以添加另一个图表，显示网络节点和它们之间的连接。
- en: If you depend on specific technologies (including specific versions of software),
    it's a good idea to list them to see whether there are any compatibility issues
    between the software you use. Sometimes, two third-party components will require
    the same dependency, but in different versions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您依赖于特定的技术（包括特定版本的软件），列出它们是个好主意，以查看您使用的软件之间是否存在兼容性问题。有时，两个第三方组件将需要相同的依赖项，但是版本不同。
- en: If you have a specific installation and upgrade plan in your head, it might
    be a good idea to write a few words about it. Things such as A/B testing, blue-green
    deployments, or any particular container magic that your solution will rely on
    should be clear to everyone involved. Data migration plans should also be covered,
    if needed, including how long the migration can take and when it could be scheduled.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在脑海中有一个特定的安装和升级计划，写几句话可能是个好主意。诸如A/B测试、蓝绿部署或者您的解决方案将依赖的任何特定容器技术都应该对所有相关人员清晰可见。如果需要，还应该包括数据迁移计划，包括迁移可能需要多长时间以及何时可以安排迁移。
- en: Any plans for configuration management, performance monitoring, operational
    monitoring, and control, as well as backup strategies, can all be things worth
    describing. You'll probably want to create a few groups, identify the dependencies
    of each, and define the approach for each such group. If you can think about any
    probable errors that may occur, have a plan to detect and recover from them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 任何配置管理、性能监控、运行监控和控制以及备份策略的计划都值得描述。您可能希望创建几个组，识别每个组的依赖关系，并为每个组定义方法。如果您能想到可能发生的任何错误，应该有一个检测和恢复计划。
- en: 'A few notes to the support team can also go into this section: what support
    is required by which stakeholder group, what classes of incidents you plan to
    have, how to escalate, and what each level of support will be responsible for.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一些支持团队的注意事项也可以放在这一部分：哪些利益相关者组需要支持，您计划拥有哪些类别的事件，如何升级，以及每个支持级别将负责什么。
- en: It's best to engage early with the operational staff and create diagrams specifically
    for them in order to keep them engaged.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽早与运营人员进行沟通，并为他们专门创建图表，以保持他们的参与。
- en: Now that we've discussed how to create documentation about your system and its
    requirements manually, let's switch to documenting your APIs in an automated manner.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何手动创建关于您的系统及其需求的文档，让我们转而以自动化的方式记录您的API。
- en: Generating documentation
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成文档
- en: As engineers, we don't like manual labor. This is why, if something can be automated
    and save us work, it most likely will be. With all this effort to create good
    enough documentation, having the possibility to automate at least parts of the
    work can actually be bliss.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 作为工程师，我们不喜欢手工劳动。这就是为什么，如果某些事情可以自动化并节省我们的工作，它很可能会被实现。在努力创建足够好的文档的过程中，至少部分工作可以自动化，这实际上可能是一种幸福。
- en: Generating requirements documentation
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成需求文档
- en: If you're creating a project from scratch, it can be hard to generate documentation
    out of thin air. However, sometimes it's possible to generate documentation if
    you have nothing but the requirements in an appropriate tool. If you're using
    JIRA, for instance, a starting point would be to just export all items from an
    issue navigator view. You can use whatever filter you like and get printouts just
    for those items. If you don't like the default set of fields or just feel this
    is not what you're looking for, you can try out one of JIRA's plugins for requirements
    management. They allow a whole lot more than to just export requirements; for
    example, **R4J** (**Requirements for Jira**) allows you to create whole hierarchies
    of requirements, trace them, manage changes and propagate them through your whole
    project, perform impact analyses of any requirements changes, and, of course,
    export using user-defined templates. Many such tools will also aid you in creating
    test suites for your requirements, but none that we saw were free.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从零开始创建一个项目，很难凭空生成文档。然而，有时候，如果您只有适当的工具和需求，生成文档是可能的。例如，如果您使用JIRA，一个起点就是从问题导航器视图中导出所有项目。您可以使用任何您喜欢的过滤器，并为这些项目获取打印输出。如果您不喜欢默认的字段集，或者觉得这不是您要找的东西，您可以尝试使用JIRA的需求管理插件之一。它们不仅允许您导出需求，例如**R4J**（**Jira的需求**）还允许您创建整个需求层次结构，跟踪它们，管理变更并将其传播到整个项目中，执行任何需求变更的影响分析，当然，还可以使用用户定义的模板进行导出。许多这样的工具还可以帮助您创建与您的需求相关的测试套件，但我们看到的没有一个是免费的。
- en: Generating diagrams from code
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从代码生成图表
- en: If you want to get to know your code structure without taking an initial deep
    dive into the sources, you might be interested in tools that generate diagrams
    from code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解代码结构，但又不想深入研究源代码，您可能会对从代码生成图表的工具感兴趣。
- en: One such tool is CppDepend. It enables you to create various dependency diagrams
    between different parts of your sources. What's more, it allows you to query and
    filter the code based on various parameters. Whether you want to just grasp how
    the code is structured, discover what the dependencies are between different software
    components and how tightly they're coupled, or want to quickly locate parts with
    the most technical debt, you might be interested in this tool. It's proprietary,
    but offers a fully functional trial.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个工具是CppDepend。它使你能够在源代码的不同部分之间创建各种依赖关系图。更重要的是，它允许你根据各种参数查询和过滤代码。无论你是想了解代码的结构，发现不同软件组件之间的依赖关系以及它们之间的紧密程度，还是想快速定位具有最多技术债务的部分，你可能会对这个工具感兴趣。它是专有的，但提供了一个完全功能的试用版。
- en: Some diagramming tools allow you to create code from class diagrams and class
    diagrams from code. Enterprise Architect enables you to take your class and interface
    diagrams and generate code in multiple languages. C++ is one of these, and allows
    UML class diagrams to be generated directly from source code. Another tool that
    can do that is Visual Paradigm.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一些绘图工具允许你从类图中创建代码，并从代码中创建类图。Enterprise Architect可以让你从类和接口图生成多种语言的代码。C++就是其中之一，并允许直接从源代码生成UML类图。另一个可以做到这一点的工具是Visual
    Paradigm。
- en: Generating (API) documentation from code
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从代码生成（API）文档
- en: To help others navigate your existing code and use the APIs you provide, a good
    idea is to provide documentation generated from the comments in your code. There's
    no better place for such documentation than just right next to the functions and
    data types it describes, and this helps a lot in keeping them in sync.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助其他人浏览你现有的代码并使用你提供的API，一个好主意是提供从代码注释中生成的文档。没有比将这样的文档放在描述函数和数据类型的旁边更好的地方了，这在保持它们同步方面有很大帮助。
- en: A de facto standard tool for writing such documentation is Doxygen. Its positives
    are that it's fast (especially for big projects and HTML document generation),
    the generator has some built-in correctness checks (for example, for partially
    documented parameters in a function – a good marker to check whether the documentation
    is still up to date), and it allows the navigation of class and file hierarchies.
    Its disadvantages include not being able to do a full-text search, less than ideal
    PDF generation, and an interface some may find cumbersome.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编写这种文档的事实上的标准工具是Doxygen。它的优点是它很快（特别是对于大型项目和HTML文档生成），生成器具有一些内置的正确性检查（例如对函数中部分记录的参数的检查
    - 这是检查文档是否仍然是最新的一个好标记），并允许导航类和文件层次结构。它的缺点包括不能进行全文搜索，PDF生成不够理想，以及一些人可能觉得繁琐的界面。
- en: Fortunately, the usability flaws can be remediated by using another popular
    tool for documentation. If you've ever read any Python documentation, you have
    probably stumbled upon Sphinx. It has a fresh-looking and usable interface and
    uses reStructuredText as a markup language. The good news is that there's a bridge
    between those two, so you can take XML generated from Doxygen and use it in Sphinx.
    This bridging software is called Breathe.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些可用性缺陷可以通过使用另一个流行的文档工具来补救。如果你曾经阅读过任何Python文档，你可能会遇到Sphinx。它具有清新的界面和可用性，并使用reStructuredText作为标记语言。好消息是这两者之间有一个桥梁，所以你可以使用Doxygen生成的XML在Sphinx中使用。这个桥接软件叫做Breathe。
- en: 'Let''s now see how to set it up in your project. Let''s assume we keep our
    sources in `src`, public headers in `include,` and documentation in `doc`. First,
    let''s create a `CMakeLists.txt` file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在你的项目中设置它。假设我们将源代码保存在`src`中，公共头文件保存在`include`中，文档保存在`doc`中。首先，让我们创建一个`CMakeLists.txt`文件：
- en: '[PRE0]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've set requirements on the CMake version supported by our project, specified
    its name, version, and the languages used (in our case, it's just C++), and added
    the `cmake` directory to the path under which CMake looks for its include files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对我们的项目支持的CMake版本设置了要求，指定了它的名称、版本和使用的语言（在我们的情况下，只是C++），并将`cmake`目录添加到CMake查找其包含文件的路径下。
- en: 'In the `cmake` subdirectory, we''ll create one file, `FindSphinx.cmake`, which
    we''ll use just as the name suggests, since Sphinx doesn''t offer one already:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmake`子目录中，我们将创建一个名为`FindSphinx.cmake`的文件，我们将按照名称使用它，因为Sphinx并没有提供这样的文件：
- en: '[PRE1]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, CMake will look for our Sphinx build tool and, if found, will set appropriate
    CMake variables to mark the Sphinx package as found. Next, let''s create our sources
    to generate the documentation. Let''s have an `include/breathe_demo/demo.h` file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CMake将寻找我们的Sphinx构建工具，如果找到，将设置适当的CMake变量来标记Sphinx包已找到。接下来，让我们创建我们的源代码来生成文档。让我们有一个`include/breathe_demo/demo.h`文件：
- en: '[PRE2]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the comment syntax. Doxygen recognizes it while parsing our header file
    so that it knows what to put in the generated documentation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意注释语法。Doxygen在解析我们的头文件时会识别它，以便知道在生成的文档中放入什么。
- en: 'Now, let''s add a corresponding `src/demo.cpp` implementation for our header:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的头文件添加一个相应的`src/demo.cpp`实现：
- en: '[PRE3]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No Doxygen comments here. We prefer to document our types and functions in the
    header files since they're the interface to our library. The source files are
    just implementation and they don't add anything new to the interface.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有Doxygen注释。我们更喜欢在头文件中记录我们的类型和函数，因为它们是我们库的接口。源文件只是实现，它们对接口没有任何新的东西。
- en: 'Aside from the preceding files, we also need a simple `CMakeLists.txt` file
    in `src`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的文件，我们还需要在`src`中添加一个简单的`CMakeLists.txt`文件：
- en: '[PRE4]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we specify the source files for our target, the directory with the header
    files for it, and the required C++ standard to compile against.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为我们的目标指定了源文件，为它指定了头文件目录，并指定了编译所需的C++标准。
- en: 'Now, let''s move to the `doc` folder, where the magic happens; first, its `CMakeLists.txt`
    file, beginning with a check to establish whether Doxygen is available and omitting
    generation if so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`doc`文件夹，这里是魔法发生的地方；首先是它的`CMakeLists.txt`文件，从检查是否有Doxygen可用并在这种情况下省略生成开始：
- en: '[PRE5]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If Doxygen is not installed, we'll just skip documentation generation. Note
    also the `return()` call, which will exit the current CMake list file, a not-that-widely-known,
    but nevertheless useful, trick.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Doxygen没有安装，我们将跳过文档生成。还要注意`return()`调用，它将退出当前的CMake列表文件，这是一个不太广为人知，但仍然有用的技巧。
- en: 'Next, assuming Doxygen was found, we need to set some variables to steer the
    generation. We want just the XML output for Breathe, so let''s set the following
    variables:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设找到了Doxygen，我们需要设置一些变量来引导生成。我们只想要Breathe的XML输出，所以让我们设置以下变量：
- en: '[PRE6]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To force relative paths, use `set(DOXYGEN_STRIP_FROM_PATH ${PROJECT_SOURCE_DIR}/include)`.
    If you have any implementation details to hide, you can do this using `set(DOXYGEN_EXCLUDE_PATTERNS
    "*/detail/*")`. OK, since we have all the variables set, let''s now generate:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制使用相对路径，使用`set(DOXYGEN_STRIP_FROM_PATH ${PROJECT_SOURCE_DIR}/include)`。如果你有任何要隐藏的实现细节，你可以使用`set(DOXYGEN_EXCLUDE_PATTERNS
    "*/detail/*")`。好了，既然所有变量都设置好了，现在让我们生成：
- en: '[PRE7]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we call a CMake function specifically written for using Doxygen. We define
    a target, `doxygen-doc`, which we'll need to explicitly invoke to generate our
    docs on demand, just like the comment says.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了一个专门用于使用Doxygen的CMake函数。我们定义了一个目标，`doxygen-doc`，我们需要明确调用它以根据需要生成我们的文档，就像注释中所说的那样。
- en: 'Now we need to create a Breathe target to consume what we got from Doxygen.
    We can use our `FindSphinx` module to this end:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个Breathe目标来消耗我们从Doxygen得到的东西。我们可以使用我们的`FindSphinx`模块来实现这一点：
- en: '[PRE8]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we invoke our module. Then, we fill in a Python configuration file with
    variables from our project for Sphinx to use. We create a `sphinx-doc` target
    that will generate HTML files as its output and will print a line in the build's
    output when doing so.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用我们的模块。然后，我们用我们项目的变量填写一个Python配置文件，供Sphinx使用。我们创建一个`sphinx-doc`目标，它将生成HTML文件作为其输出，并在构建输出时打印一行。
- en: 'Finally, let''s force CMake to call Doxygen each time we generate Sphinx docs:
    `add_dependencies(sphinx-doc doxygen-doc)`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们强制CMake在每次生成Sphinx文档时调用Doxygen：`add_dependencies(sphinx-doc doxygen-doc)`。
- en: If you wish to have more targets for documentation, it may be useful to introduce
    some CMake functions that will handle documentation-related targets for you.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望有更多的文档目标，引入一些CMake函数来处理与文档相关的目标可能会很有用。
- en: 'Let''s now see what lies inside our `conf.py.in` file, used to steer our feline
    tool. Let''s create it and let it point Sphinx to Breathe:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的`conf.py.in`文件中有什么，用于引导我们的猫工具。让我们创建它，并让它指向Sphinx到Breathe：
- en: '[PRE9]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see from the preceding listing, we set the extensions for Sphinx
    to use, the name of the documented project, and a few other related variables.
    Note `@NOTATION@`, used by CMake to fill in the output file with the value of
    appropriate CMake variables. Finally, we tell Sphinx to use our ReadTheDocs theme
    (`sphinx_rtd_theme`).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的列表所示，我们设置了Sphinx要使用的扩展名，文档化项目的名称以及其他一些相关变量。注意`@NOTATION@`，它被CMake用来用适当的CMake变量的值填充输出文件。最后，我们告诉Sphinx使用我们的ReadTheDocs主题（`sphinx_rtd_theme`）。
- en: 'The final pieces of the puzzle are reStructuredText files, which define what
    to include where in the docs. First, let''s create an `index.rst` file, containing
    a table of contents and a few links:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块是reStructuredText文件，它们定义了文档中包含什么。首先，让我们创建一个`index.rst`文件，其中包含目录和一些链接：
- en: '[PRE10]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first link points to this page, so we can get back to it from other ones.
    We''ll display `Introduction` as the label. Other names point to other files with
    the `.rst` extension. Since we''re including the M2R2 Sphinx extension, we can
    include our `README.md` file in the docs, which can save you some duplication.
    The contents of the `readme.rst` file are simply `.. mdinclude:: ../README.md`.
    Now for the last part: merging Doxygen''s output. This is done in the `api_reference.rst`
    file using just the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个链接指向这个页面，所以我们可以从其他页面返回到它。我们将显示`Introduction`作为标签。其他名称指向具有`.rst`扩展名的其他文件。由于我们包含了M2R2
    Sphinx扩展，我们可以在文档中包含我们的`README.md`文件，这可以节省一些重复。`readme.rst`文件的内容只是`.. mdinclude::
    ../README.md`。现在是最后一部分：合并Doxygen的输出。这是在`api_reference.rst`文件中使用以下命令完成的：'
- en: '[PRE11]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So we just named the reference page as we liked and specified that the Doxygen-generated
    docs should be listed here, and that''s all! Just build the `sphinx-doc` target
    and you''ll get a page looking like so:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只是按照自己的喜好命名了参考页面，并指定了Doxygen生成的文档应该在这里列出，就是这样！只需构建`sphinx-doc`目标，你就会得到一个看起来像这样的页面：
- en: '![](img/b4d742ab-7431-49b9-9c2f-cae386dde9cd.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4d742ab-7431-49b9-9c2f-cae386dde9cd.jpg)'
- en: Figure 3.9 – The main page of our documentation, consolidating both the generated
    and manually written parts
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 我们文档的主页，整合了生成的部分和手动编写的部分
- en: 'And when we look at the API docs page, it should look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看API文档页面时，它应该是这样的：
- en: '![](img/cb4eb5a0-f0a3-4ff6-95f9-039a846faf30.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb4eb5a0-f0a3-4ff6-95f9-039a846faf30.jpg)'
- en: Figure 3.10 – The automatically generated API documentation
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 自动生成的API文档
- en: As you can see, the documentation was automatically generated for our `Payload`
    type with each of its members, as well as for the free `perform_work` function,
    including each of its parameters, and was grouped based on the file that defines
    them. Neat!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，文档已经自动生成了我们的`Payload`类型及其每个成员，以及自由的`perform_work`函数，包括每个参数，并根据定义它们的文件进行了分组。整洁！
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you got to know all the essentials regarding requirements and
    documentation. You learned how to gather requirements successfully and how to
    identify the most important ones. You can now prepare lean and useful documentation
    that shows only what's important in a view-oriented manner. You are able to distinguish
    between different types and styles of diagrams and use the one that suits your
    needs the best. Last, but not least, you are now able to automatically generate
    aesthetic documentation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您了解了有关需求和文档的所有基本知识。您学会了如何成功收集需求以及如何识别最重要的需求。您现在可以准备精简而有用的文档，以一种面向视图的方式只展示重要内容。您能够区分不同类型和风格的图表，并使用最适合您需求的那种。最后，但同样重要的是，您现在能够自动生成美观的文档。
- en: In the next chapter, you'll learn about useful architectural design patterns
    that will help you fulfill your system's requirements. We'll discuss various patterns
    and how to apply them to provide many important quality attributes, both on a
    single-component scale in distributed systems.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解有用的架构设计模式，这将帮助您满足系统的需求。我们将讨论各种模式以及如何应用它们来提供许多重要的质量属性，无论是在分布式系统中的单个组件规模上。
- en: Questions
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are quality attributes?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是质量属性？
- en: What sources should be used when gathering requirements?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收集需求时应使用哪些来源？
- en: How can you tell whether a requirement is architecturally significant?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何判断一个需求是否具有架构上的重要性？
- en: When is development view documentation useful?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发视图文档在什么时候有用？
- en: How can you automatically check whether your code's API documentation is out
    of date?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何自动检查您的代码的API文档是否过时？
- en: How can you indicate on a diagram that a given process is handled by different
    components of the system?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在图表上指示给定的过程是由系统的不同组件处理的？
- en: Further reading
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Evaluate the Software Architecture using ATAM,* JC Olamendy, blog post: [https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/](https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/)'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*使用ATAM评估软件架构*，JC Olamendy，博客文章：[https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/](https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/)'
- en: '**EARS**: *The Easy Approach to Requirements Syntax*, John Terzakis, Intel
    Corporation, conference talk from the ICCGI conference: [https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf](https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf)'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**EARS**：*需求语法的简易方法*，John Terzakis，英特尔公司，来自ICCGI会议的会议演讲：[https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf](https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf)'
- en: 'Eoin Woods and Nick Rozanski, *Software Systems Architecture: Working With
    Stakeholders Using Viewpoints and Perspectives*'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eoin Woods和Nick Rozanski，*软件系统架构：使用观点和透视与利益相关者合作*
