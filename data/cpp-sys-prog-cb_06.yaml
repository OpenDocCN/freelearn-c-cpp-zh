- en: Pipes, First-In First-Out (FIFO), Message Queues, and Shared Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道、先进先出（FIFO）、消息队列和共享内存
- en: Communication between processes is an important part of software systems, and
    choosing the appropriate communication technique is not a simple task. One important
    distinction that developers should keep in mind when making a choice is whether
    processes are going to run on the same machine or not. This chapter focuses on
    the first category, where you'll learn how to develop **interprocess communication** (**IPC**)
    solutions based on pipes, **First-In First-Out** (**FIFO**), message queues, and
    shared memory. It'll start with an overview of the four types of IPC in the first
    recipe, their characteristics, and the differences between the types. Then, a
    recipe for each type will provide hands-on information needed to apply them to
    your daily work. This chapter does not contain any C++-specific solutions, in
    order to let you familiarize yourself with the Linux native mechanisms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程之间的通信是软件系统的重要部分，选择适当的通信技术并不是一项简单的任务。开发人员在做出选择时应牢记的一个重要区别是进程是否将在同一台机器上运行。本章重点介绍了第一类，您将学习如何基于管道、**先进先出**（**FIFO**）、消息队列和共享内存开发**进程间通信**（**IPC**）解决方案。它将从第一个配方中概述四种IPC的特性和类型之间的区别。然后，每种类型的配方将提供实用信息，以便将它们应用到您的日常工作中。本章不包含任何特定于C++的解决方案，以便让您熟悉Linux本地机制。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning the different types of IPC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习不同类型的IPC
- en: Learning how to use the oldest form of IPC—pipes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用最古老的IPC形式——管道
- en: Learning how to use FIFO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用FIFO
- en: Learning how to use message queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用消息队列
- en: Learning how to use shared memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用共享内存
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to let you try the programs immediately, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您立即尝试这些程序，我们设置了一个Docker镜像，其中包含了本书中将需要的所有工具和库。这是基于Ubuntu 19.04的。
- en: 'In order to set it up, follow these steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，请按照以下步骤进行：
- en: Download and install Docker Engine from [www.docker.com](http://www.docker.com).
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](http://www.docker.com)下载并安装Docker Engine。
- en: 'Pull the image from Docker Hub by running the following command: `docker pull
    kasperondocker/system_programming_cookbook:latest`.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像现在应该可用。键入以下命令以查看镜像：`docker images`。
- en: 'You should have at least this image now: `kasperondocker/system_programming_cookbook`.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该至少有这个镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker镜像，获取交互式shell的帮助：`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`。
- en: The shell on the running container is now available. Type in `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。键入 `root@39a5a8934370/# cd /BOOK/` 以获取所有按章节开发的程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow the **GNU Project Debugger**
    (**GDB**) in the Docker container to set breakpoints, which, by default, Docker
    does not allow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--cap-add sys_ptrace`参数以允许Docker容器中的**GNU项目调试器**（**GDB**）设置断点，默认情况下Docker不允许这样做。
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：C++20标准已经在二月底的布拉格会议上由WG21批准（即技术上最终确定）。这意味着本书使用的GCC编译器版本8.3.0不包括（或者对C++20的新功能支持非常有限）。因此，Docker镜像不包括C++20配方代码。GCC将最新功能的开发保留在分支中（您必须使用适当的标志，例如`-std=c++2a`）；因此，鼓励您自行尝试。因此，请克隆并探索GCC合同和模块分支，并尽情玩耍。'
- en: Learning the different types of IPC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习不同类型的IPC
- en: This recipe's goal is to provide guidance among the different IPC solutions
    typically used with processes running on the same machine. It'll provide an overview
    of the main characteristics seen from the developer's point of view (your point
    of view!), explaining how they are different from each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的目标是在同一台机器上运行的进程中提供不同IPC解决方案之间的指导。它将从开发人员的角度（您的角度！）提供主要特征的概述，解释它们之间的不同之处。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'The following table shows the four types of IPC always available on a Linux
    machine, where the columns represent what we believe are the distinctive factors
    that a developer should consider when making design choices:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Linux机器上始终可用的四种IPC类型，其中列代表我们认为开发人员在进行设计选择时应考虑的独特因素：
- en: '|  | ****Processes'' r******elation required?** | **Synchronization required?**
    | **Communication type** | **Scope** | **Kernel involved?** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | **进程关系需要？** | **需要同步？** | **通信类型** | **范围** | **涉及内核？** |'
- en: '| **Pipe** | Yes | Generally no | Half-duplex | Same machine | Yes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **管道** | 是 | 通常不 | 半双工 | 同一台机器 | 是 |'
- en: '| **FIFO** | No | Generally no | Half-duplex | Typically same machine | Yes
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **FIFO** | 否 | 通常不 | 半双工 | 通常是同一台机器 | 是 |'
- en: '| **Message queue** | No | Generally no | Half-duplex | Same machine | Yes
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **消息队列** | 否 | 通常不 | 半双工 | 同一台机器 | 是 |'
- en: '| **Shared memory** | No | Yes | Half-duplex | Same machine | Yes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **共享内存** | 否 | 是 | 半双工 | 同一台机器 | 是 |'
- en: 'The columns of the table have the following descriptions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表的列具有以下描述：
- en: '**Processes'' relation required?**: This indicates whether a relation between
    processes (for example, parent-child) is required or not to implement the specific
    IPC.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程之间的关系是否需要？**：这表明实现特定IPC是否需要进程之间的关系（例如父子关系）。'
- en: '**Synchronization required?**: This indicates whether you have to take into
    consideration any form of synchronization between processes (for example, mutex,
    semaphores, and so on; see [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml),
    *Using Mutexes, Semaphores, and Condition Variables*) or not.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要同步？**：这表明您是否需要考虑进程之间的任何形式的同步（例如互斥锁，信号量等；参见[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)，*使用互斥锁、信号量和条件变量*）或不需要。'
- en: '**Communication type**: A communication between two or more entities can be
    half-duplex (the closest analogy is the walkie-talkie, where just one individual
    can talk at any given time) or full-duplex (the telephone, for example, whereby
    two people can talk simultaneously). This can have a profound impact on the solution
    designed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信类型**：两个或多个实体之间的通信可以是半双工（最接近的类比是对讲机，只有一个人可以同时说话）或全双工（例如电话，两个人可以同时交谈）。这可能对设计的解决方案产生深远影响。'
- en: '**Scope**: This indicates if the solution can be applied to a broader scope,
    in terms of IPC among processes on different machines.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范围**：这表明解决方案是否可以应用于更广泛的范围，即在不同机器上的进程之间的IPC。'
- en: '**Kernel involved?**: This warns you about the kernel involvement in the communication
    process. The *How it works...* section will explain why this is important.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**涉及的内核？**：这警告您有关通信过程中内核的参与。*它是如何工作...*部分将解释为什么这很重要。'
- en: In the next section, we'll analyze row by row the single characteristics highlighted
    in the table.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐行分析表中突出显示的单个特征。
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作...
- en: The first IPC mechanism in the list is a **pipe**. A pipe requires a relation
    between two processes (parent-child, for example) for it to work. This relation
    is needed in order to make the pipe **visible** by both the processes (as opposed
    to FIFO). It is like a variable that must be visible by a method in order to be
    usable. In the pipe recipe, we'll see how this works technically.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一个IPC机制是**管道**。管道需要两个进程之间的关系（例如父子关系）才能工作。为了使管道对两个进程都**可见**（与FIFO相反），需要这种关系。这就像一个变量必须对一个方法可见才能使用一样。在管道的示例中，我们将看到这是如何在技术上工作的。
- en: 'The communication type is half-duplex: the data flows from process *A* to process
    *B,* and for this reason, there is no need for synchronization. In order to achieve
    a full-duplex communication type between two processes, two pipes must be used.
    For the same reason that two processes must have a relationship in order to be
    able to use a pipe, a pipe cannot be used as a communication mechanism between
    processes on two different machines. The Linux kernel is involved in the communication
    as the data is copied to the kernel, which is then further copied to the receiver
    process.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通信类型是半双工：数据从进程*A*流向进程*B*，因此不需要同步。为了在两个进程之间实现全双工通信类型，必须使用两个管道。由于两个进程必须有关系才能使用管道，管道不能用作两台不同机器上的进程之间的通信机制。Linux内核参与通信，因为数据被复制到内核，然后进一步复制到接收进程。
- en: The second IPC mechanism in the table is the **FIFO** (or **named pipe**). It
    is a named pipe as it requires a pathname to be created, and indeed, it is a special
    kind of a file. This makes the FIFO usable by any processes even without a relationship
    between them. All they need is the path of the FIFO (likewise, a filename) that
    all the process will use. Synchronization is not required in this case either.
    We have to be careful, though, as there are cases where synchronization is required,
    as the `man page` specifies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的第二个IPC机制是**FIFO**（或**命名管道**）。它是命名管道，因为它需要一个路径名来创建，实际上，它是一种特殊类型的文件。这使得FIFO可供任何进程使用，即使它们之间没有关系。他们所需要的只是FIFO的路径（同样，一个文件名）所有进程都会使用。在这种情况下也不需要同步。但是，我们必须小心，因为有些情况下需要同步，正如`man
    page`所指定的。
- en: POSIX.1 says that writes ([http://man7.org/linux/man-pages/man2/write.2.html](http://man7.org/linux/man-pages/man2/write.2.html))
    of less than `pipe_BUF` bytes must be atomic (that is, the output data is written
    to the pipe as a contiguous sequence). Writes of more than `pipe_BUF` bytes may
    be nonatomic (that is, the kernel may interleave the data with data written by
    other processes). POSIX.1 requires `pipe_BUF` to be at least 512 bytes. (On Linux,
    `pipe_BUF` is 4,096 bytes.) The precise semantics depends on whether the file
    descriptor is nonblocking (`O_NONBLOCK`); whether there are multiple writers to
    the pipe; and on *n*, the number of bytes to be written.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.1规定，少于`pipe_BUF`字节的写操作必须是原子的（即，输出数据被作为连续序列写入管道）。超过`pipe_BUF`字节的写操作可能是非原子的（即，内核可能会将数据与其他进程写入的数据交错）。POSIX.1要求`pipe_BUF`至少为512字节（在Linux上，`pipe_BUF`为4,096字节）。精确的语义取决于文件描述符是否为非阻塞（`O_NONBLOCK`）；管道是否有多个写入者；以及要写入的字节数*n*。
- en: The general rule is that, if you have any doubts about how much data exchange
    should happen between the processes, always provide a synchronization mechanism
    (for example, mutex, semaphores, and many others). A FIFO (likewise, a pipe) provides
    a half-duplex communication mechanism unless two FIFOs are provided for each process
    (one reader and one writer for each process); in that case, it would make it a
    full-duplex communication. FIFOs are typically used for IPC between processes
    on the same machine but, as it is based on files, if the file is visible by other
    machines, a FIFO could potentially be used for IPC between processes on different
    machines. Even in this case, the kernel is involved in the IPC, with data copied
    from kernel space to the user space of the processes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，如果你对进程之间应该发生多少数据交换有任何疑问，总是提供一个同步机制（例如互斥锁、信号量和其他许多机制）。FIFO（同样，管道）提供了半双工通信机制，除非为每个进程提供两个FIFO（每个进程一个读取器和一个写入器）；在这种情况下，它将成为全双工通信。FIFO通常用于同一台机器上的进程之间的IPC，但是，由于它基于文件，如果文件对其他机器可见，FIFO可能潜在地用于不同机器上的进程之间的IPC。即使在这种情况下，内核也参与了IPC，数据从内核空间复制到进程的用户空间。
- en: A **message queue** is a linked list of messages stored in the kernel. This
    definition already contains a piece of information; this is a communication mechanism
    provided by the kernel, and again, it means that the data is copied back and forth
    from/to the kernel. Message queues do not require any relation between processes;
    they have to share a key to be able to access the same queue. The Linux kernel
    guarantees the atomicity of the operations on the queue if the message is smaller
    than or equal to `pipe_BUF`. In that case, a synchronization mechanism is required.
    A message queue cannot be used outside the scope of a machine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息队列**是存储在内核中的消息的链表。这个定义已经包含了一部分信息；这是内核提供的一种通信机制，同样，这意味着数据来回从/到内核进行复制。消息队列不需要进程之间的任何关系；它们必须共享一个键才能访问相同的队列。如果消息小于或等于`pipe_BUF`，Linux内核保证队列上的操作的原子性。在这种情况下，需要一种同步机制。消息队列不能在机器范围之外使用。'
- en: The last IPC mechanism in the table is **shared memory**. This is the fastest
    form of IPC. This comes with a cost, in the sense that the processes using shared
    memory should use a form of synchronization (for example, mutexes or semaphores),
    as the `man page` suggests (`man shm_overview`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的最后一个IPC机制是**共享内存**。这是最快的IPC形式。这是有代价的，因为使用共享内存的进程应该使用一种同步形式（例如互斥锁或信号量），正如`man
    page`所建议的那样（`man shm_overview`）。
- en: Any time there is a critical section to protect, processes must synchronize
    the access using a mechanism we've seen in [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using
    Mutexes, Semaphores, and Condition Variables.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有一个需要保护的临界区时，进程必须使用我们在[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)中看到的机制来同步访问，*使用互斥锁、信号量和条件变量*。
- en: Processes must be running on the same machine to use the same shared memory,
    and it is identified with a key, likewise for message queues. As the shared memory
    resides in the kernel space, data is copied from the kernel space to the processes
    that read and delete it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进程必须在同一台机器上运行才能使用相同的共享内存，并且使用一个键进行标识，消息队列也是如此。由于共享内存位于内核空间，数据会从内核空间复制到读取和删除数据的进程中。
- en: There's more...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: These four forms of IPC are the ones originally developed on the Unix System
    V and then reimplemented in the more modern POSIX standard, which Linux supports.
    There are cases where the processes are not on the same machine, and in those
    cases, we need to use other mechanisms such as sockets, which we'll see in the
    next chapter. Of course, a socket has wider applicability as it puts in communication
    processes, regardless of the position on the network.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种IPC形式最初是在Unix System V上开发的，然后在更现代的POSIX标准中重新实现，Linux支持这些标准。有些情况下，进程不在同一台机器上，在这种情况下，我们需要使用其他机制，比如套接字，我们将在下一章中看到。当然，套接字具有更广泛的适用性，因为它可以在网络上的任何位置将进程进行通信。
- en: 'This generality, so to speak, comes at a cost: they are slower than the mechanisms
    described in this recipe. So, as developers, this is a factor that must be taken
    into consideration when making a design choice.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种泛化，可以这么说，是有代价的：它们比本食谱中描述的机制慢。因此，作为开发人员，在做设计选择时必须考虑这一因素。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)*, Using Mutexes, Semaphores,
    and Condition Variables*: About the synchronization mechanisms you can use.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)*，使用互斥锁、信号量和条件变量*：关于你可以使用的同步机制。'
- en: '[Chapter 7](edc01b79-661b-4ecd-88f2-a6501eeaa085.xhtml)*, Network Programming*:
    To complement this chapter with the notion of sockets (connection-oriented and
    connectionless).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](edc01b79-661b-4ecd-88f2-a6501eeaa085.xhtml)*，网络编程*：为了补充本章关于套接字（面向连接和无连接）的概念。'
- en: Learning how to use the oldest form of IPC – pipes
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用最古老的IPC形式-管道
- en: In the previous recipe, you learned how to choose an IPC based on some key factors.
    It's now time to get hands-on with the four communication types, and this recipe
    focuses on pipes. In this recipe, you'll learn how to use pipes to make two processes
    communicating full-duplex by using two pipes. We'll not use any form of synchronization
    as generally, it is not required. In the *How it works...* section, we'll see
    why and when is it not required.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇食谱中，你学会了如何根据一些关键因素选择IPC。现在是时候动手使用四种通信类型了，这篇食谱专注于管道。在这篇食谱中，你将学习如何使用管道通过使用两个管道使两个进程进行全双工通信。我们将不使用任何形式的同步，因为通常情况下是不需要的。在*它是如何工作的...*部分，我们将看到为什么不需要以及何时不需要。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll develop a program that will create two processes, with
    the unique goal of sending a message to each other. With a pipe, as we''ve seen,
    the data flows in one direction. To make a bidirectional communication, and to
    simulate the general case, we will make use of two pipes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个程序，该程序将创建两个进程，其唯一目标是相互发送消息。正如我们所见，使用管道，数据只能单向流动。为了进行双向通信，并模拟一般情况，我们将使用两个管道：
- en: 'We instantiate the two messages to send, and their size, which we''ll need
    later:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实例化了要发送的两条消息及其大小，稍后我们将需要它们：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we move on to the initialization section. We need to instantiate the
    space for the message received, both the `childToParent` and `parentToChild` pipes,
    and the **process identifier** (**PID**) that we use to track the child:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们进入初始化部分。我们需要为接收到的消息、`childToParent`和`parentToChild`管道以及我们用于跟踪子进程的**进程标识符**（PID）实例化空间：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s see the child section. This section has two parts: the first, where
    the child sends the `msg1` message to the parent; and the second, where the child
    receives the  `msg2` message from the parent:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看子部分。这部分有两个部分：第一个部分是子进程向父进程发送`msg1`消息；第二个部分是子进程从父进程接收`msg2`消息：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, let''s see the parent code. It has two sections: one to receive
    the message from the child, and the second to reply to it:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们看看父代码。它有两个部分：一个用于从子进程接收消息，另一个用于回复消息：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've implemented programmatically what we learned in [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting
    Started with System Programming*, for the shell (see the *Learning the Linux fundamentals
    – shell* recipe). These steps are detailed in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以编程方式实现了我们在[第1章](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml)中学到的内容，即*开始系统编程*，用于shell（参见*学习Linux基础知识-
    shell*配方）。这些步骤在下一节中详细介绍。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the first step, we just defined `msg1` and `msg2` to be used by the two processes
    and defined `MSGSIZE` for the message length needed to read them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们只是定义了`msg1`和`msg2`，供两个进程使用，并定义了`MSGSIZE`，用于读取它们所需的消息长度。
- en: The second step essentially defines the two pipes, `childToParent` and `parentToChild`,
    as an array of two integers each. They are used by the `pipe` system call to create
    two communication buffers, which the processes can access through the `childToParent[0]`
    and `childToParent[1]` file descriptors. The message is written to `childToParent[1]`
    and read from `childToParent[0]` with the FIFO policy. In order to avoid a situation
    where buffers are not initialized, this step sets the pointer of `inbuf1` and `inbuf2`
    to `0`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步基本上定义了两个管道`childToParent`和`parentToChild`，每个都是两个整数的数组。它们由`pipe`系统调用用于创建两个通信缓冲区，进程可以通过`childToParent[0]`和`childToParent[1]`文件描述符访问。消息被写入`childToParent[1]`，并且按照FIFO策略从`childToParent[0]`读取。为了避免缓冲区未初始化的情况，此步骤将`inbuf1`和`inbuf2`的指针设置为`0`。
- en: The third step deals with the child's code. It writes to `childToParent[1]`,
    then reads from `parentToChild[0]`. Writes to `childToParentp[1]` by the child
    process can be read on `childToParent[0]` by the parent process. The `read` and
    `write` system call causes the process to step in kernel mode and save the input
    data temporarily in kernel space until the second process reads it. One rule to
    follow is that the unused end of the pipes has to be closed. In our case, we write
    to `childToParent[1]`; so, we close the `read` end of the pipe, `childToParent[0]`,
    and once read, we close the `write` end as this is not used.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步处理子代码。它向`childToParent[1]`写入，然后从`parentToChild[0]`读取。子进程写入`childToParent[1]`的内容可以由父进程在`childToParent[0]`上读取。`read`和`write`系统调用会导致进程进入内核模式，并临时将输入数据保存在内核空间，直到第二个进程读取它。要遵循的一个规则是未使用的管道端点必须关闭。在我们的情况下，我们写入`childToParent[1]`；因此，我们关闭了管道的`read`端`childToParent[0]`，一旦读取完毕，我们关闭了`write`端，因为它不再使用。
- en: The fourth step, pretty similar to the third, has the symmetric code to the
    child code. It reads on the `childToParent[0]` pipe and writes on `parentToChild[1]`,
    following the same rule of closing the end of the pipe not used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步，与第三步非常相似，具有与子代码对称的代码。它在`childToParent[0]`管道上读取，并在`parentToChild[1]`上写入，遵循相同的关闭未使用管道端点的规则。
- en: From the code analyzed, the reason why pipes are not usable by processes that
    are not ancestors should now be clear: `childToParent` and `parentToChild` file
    descriptors must be visible to parents and children at runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从分析的代码来看，现在应该清楚为什么管道不能被非祖先进程使用了：`childToParent`和`parentToChild`文件描述符必须在运行时对父进程和子进程可见。
- en: 'If we compile the code with `gcc pipe.c` in the Docker container''s `/BOOK/Chapter06/`
    folder and run it, the output would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Docker容器的`/BOOK/Chapter06/`文件夹中用`gcc pipe.c`编译代码并运行它，输出将如下所示：
- en: '![](img/91aaa497-4f77-4015-8784-f09f8d31dffd.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91aaa497-4f77-4015-8784-f09f8d31dffd.png)'
- en: This shows that the parent and the child send and receive the two messages correctly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明父进程和子进程正确地发送和接收了这两条消息。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For the vast majority of use cases, pipes are intended to be used with small
    amounts of data, but there might be scenarios where a larger amount is needed.
    The standard POSIX, to which we adhere in this chapter, says that a `write` of
    less than `pipe_BUF` bytes must be atomic. It furthermore dictates that `pipe_BUF`
    must be at least 512 bytes (on Linux, it is 4 KB); otherwise, you have to take
    care of the synchronization at the user level by using mechanisms such as semaphores
    and mutexes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绝大多数用例，管道旨在与少量数据一起使用，但可能存在需要大量数据的情况。我们在本章中遵循的标准POSIX规定，`write`少于`pipe_BUF`字节必须是原子的。它进一步规定，`pipe_BUF`必须至少为512字节（在Linux上为4KB）；否则，您必须通过使用信号量和互斥锁等机制在用户级别处理同步。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting Started with
    System Programming*, shows the pipe concept from the shell point of view.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml)，*开始系统编程*，从shell的角度展示了管道的概念。'
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables* has the tools necessary to add the synchronization, in
    case the data to send and receive is larger than `pipe_BUF`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)，*使用互斥锁、信号量和条件变量*具有添加同步所需的工具，以防要发送和接收的数据大于`pipe_BUF`。'
- en: Learning how to use FIFO
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用FIFO
- en: The pipes we've seen in the previous recipe are temporary, in the sense that
    when no process has them open, they cease to exist. **FIFOs** (also called **named
    pipes**) are different; they are special pipes that exist as a special file on
    the filesystem. In principle, any process, assuming it has the right permissions,
    can access a FIFO. This last one is the FIFO-distinctive characteristic. Using
    files allows us to program a more general communication mechanism to put processes
    in communication, even without an ancestor relationship; or, in other words, we
    can use FIFO to get any two files to communicate. In this recipe, you'll learn
    how to program FIFO.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中看到的管道是临时的，也就是说当没有进程打开它们时，它们就会消失。**FIFO**（也称为**命名管道**）是不同的；它们是特殊的管道，作为文件系统上的特殊文件存在。原则上，任何进程，只要有合适的权限，都可以访问FIFO。这是FIFO的独特特性。使用文件允许我们编程一个更通用的通信机制，以便让进程进行通信，即使它们没有祖先关系；换句话说，我们可以使用FIFO让任意两个文件进行通信。在这个配方中，你将学习如何编程FIFO。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll develop a very primitive chat program based on FIFOs,
    resulting in two different programs that at runtime will allow two users to chat:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个非常原始的基于FIFO的聊天程序，从而产生两个不同的程序，在运行时将允许两个用户进行聊天：
- en: 'Let''s create a file called  `fifo_chat_user1.c` and add the includes that
    we need later, and the `MAX_LENGTH` define to determine the max length of messages
    the two users can exchange:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`fifo_chat_user1.c`的文件，并添加我们稍后需要的包含和`MAX_LENGTH`定义，以确定两个用户可以交换的消息的最大长度：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, start with `main`. Here, we need to define the `fd` file descriptor to
    open the file; the path in which we intend to store the file; the two strings
    we''ll use to store the `msgReceived` and `msgToSend` messages; and, finally, 
    the  `mkfifo` system call to create the FIFO in the defined path:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从`main`开始。在这里，我们需要定义`fd`文件描述符以打开文件；我们打算存储文件的路径；我们将用来存储`msgReceived`和`msgToSend`消息的两个字符串；最后，使用`mkfifo`系统调用在定义的路径中创建FIFO：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now need an infinite loop to `write` and `read` continuously. We do this
    by creating two sections: in the `write` section, we open the `fifoChat` file
    in write mode, get the message from the user with `fgets`, and write `msgToSend`
    to the file, represented by the `fd` file descriptor. In the reader''s section,
    we open the file in reading mode and read the content of the file with the `read` method,
    print the output, and close `fd`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个无限循环来连续`write`和`read`。我们通过创建两个部分来实现：在`write`部分，我们以写模式打开`fifoChat`文件，使用`fgets`从用户获取消息，并将`msgToSend`写入由`fd`文件描述符表示的文件。在读者部分，我们以读模式打开文件，并使用`read`方法读取文件的内容，打印输出，并关闭`fd`：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second program is very similar. The only difference is the `while` loop,
    which is the other way around. Here, we have the `read` section, and then, the
    `write` section. You can copy the `fifo_chat_user1.c` file into `fifo_chat_user2.c`
    and modify it, like the following:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个程序非常相似。唯一的区别是`while`循环，它是相反的。在这里，我们有`read`部分，然后是`write`部分。你可以将`fifo_chat_user1.c`文件复制到`fifo_chat_user2.c`并进行修改，如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although this is not the most interactive chat you'll find around, it's definitely
    useful to experiment with FIFO. In the next section, we'll analyze the steps seen
    in this section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是您会在周围找到的最互动的聊天，但它绝对有助于实验FIFO。在下一节中，我们将分析本节中所见的步骤。
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s first compile and run the two programs. In this case, we want to give
    a different name to the executables, so as to distinguish them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先编译并运行这两个程序。在这种情况下，我们希望为可执行文件提供不同的名称，以便加以区分：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This creates two executables: `chatUser1` and `chatUser2`. Let''s run them
    in two separate Terminals, and let''s chat:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个可执行文件：`chatUser1`和`chatUser2`。让我们在两个单独的终端中运行它们，并进行聊天：
- en: '![](img/7359f0c3-5c8e-4a74-95fa-74763e739dbf.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7359f0c3-5c8e-4a74-95fa-74763e739dbf.png)'
- en: In *step 1*, we essentially defined `MAX_LENGTH` to the `128` bytes and added
    the defines we need.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们基本上将`MAX_LENGTH`定义为`128`字节，并添加了我们需要的定义。
- en: 'In *step 2*, we created the `mkfifo` FIFO at the path specified by `fifoChat`,
    which points to the `/tmp/chat` file, with permissions `6` (read and write for
    the user), `0` (no read, no write, no execution for the group the user belongs
    to), and `0` (no read, no write, no execution for others). These settings can
    be checked once `mkfifo` is called:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们创建了`mkfifo`指定路径的FIFO，该路径指向`/tmp/chat`文件，权限为`6`（用户读写），`0`（用户所属组无读、无写、无执行权限），`0`（其他用户无读、无写、无执行权限）。这些设置可以在调用`mkfifo`后进行检查：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In *step 3*, we opened the FIFO with the `open` method. It's worth mentioning
    that `open` is the same method used to open regular files, and on the descriptor
    returned, we can call `read` and `write`, as we would do on normal files. In this
    step, we made an infinite loop to allow the user to chat as long as they want.
    The `read` and `write` sections, as you can see, are swapped in *step 4* to allow
    the second user to read if the first is writing, and vice versa.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们使用`open`方法打开了FIFO。值得一提的是，`open`是用于打开常规文件的相同方法，并且在返回的描述符上，我们可以调用`read`和`write`，就像在普通文件上一样。在这一步中，我们创建了一个无限循环，允许用户进行聊天。如您所见，在*步骤4*中，`read`和`write`部分被交换，以便第二个用户在第一个用户写入时读取，反之亦然。
- en: A FIFO is managed internally by the kernel with the FIFO policy. Every time
    we `write` or `read` data from/to the FIFO, the data is passed from/to the kernel.
    You should keep this aspect in mind. The message passes from the `chat1` executable,
    then, in the kernel space, and back in the user space again when the `chat2` program
    calls the `read` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO由内核使用FIFO策略进行内部管理。每次我们从FIFO中`write`或`read`数据时，数据都会从内核传递到内核。您应该记住这一点。消息从`chat1`可执行文件传递，然后在内核空间中，当`chat2`程序调用`read`方法时，再次回到用户空间。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It should be clear so far that a FIFO is a special pipe. This means the same
    limitation we have for pipes applies to FIFO too. For example, there is no need
    for synchronization unless the amount of data sent exceeds the `pipe_BUF` limit,
    which the standard POSIX defines as 512 bytes, and Linux sets to 4 KB.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应该很清楚FIFO是一个特殊的管道。这意味着我们对管道的限制也适用于FIFO。例如，除非发送的数据量超过了`pipe_BUF`限制，否则不需要同步，标准POSIX将其定义为512字节，Linux将其设置为4
    KB。
- en: Another aspect to highlight is that a named pipe (FIFO) can be used in *N* to
    *M* communication types (that is, multiple readers and multiple writers). The
    kernel guarantees the atomicity of the operations (`read` and `write` calls) if
    the preceding conditions are met.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要强调的另一个方面是，命名管道（FIFO）可以在*N*到*M*通信类型（即多个读取者和多个写入者）中使用。如果满足前述条件，内核将保证操作（`read`和`write`调用）的原子性。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)，*处理进程和线程*'
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables*'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)，*使用互斥锁、信号量和条件变量*'
- en: Learning how to use message queues
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用消息队列
- en: Another mechanism directly supported by POSIX-compliant operating systems (and
    then, the Linux kernel) is a message queue. A message queue, in its essence, is
    a linked list of messages stored in the kernel, where each queue is identified
    by an ID. In this recipe, we'll rewrite the chat program using a message queue,
    highlighting the key pros and cons.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX兼容操作系统（然后是Linux内核）直接支持的另一种机制是消息队列。消息队列本质上是存储在内核中的消息的链表，每个队列由一个ID标识。在这个配方中，我们将使用消息队列重写聊天程序，突出显示其主要优缺点。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll rewrite the chat program from the *Learning how to
    use FIFO* recipe. This will allow you to see, hands-on, similarities and differences
    between FIFO and a message queue:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从*学习如何使用FIFO*的配方中重写聊天程序。这将使您能够亲身体验FIFO和消息队列之间的相似之处和不同之处：
- en: 'Create a new file called `mq_chat_user_1.c`, and add the following includes
    and defines:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mq_chat_user_1.c`的新文件，并添加以下包含和定义：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `main` method, let''s now define the two message queue descriptors (`user1Desc`
    and `user2Desc`) needed to store the result from the `mq_open` method later. We
    have to define and initialize the `mq_attr` struct to store the configuration
    of the message queues we''ll create:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，现在让我们定义两个消息队列描述符（`user1Desc`和`user2Desc`），以便稍后存储`mq_open`方法的结果。我们必须定义和初始化`mq_attr`结构以存储我们将创建的消息队列的配置：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can open the two `/user1` and `/user2` message queues:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以打开两个`/user1`和`/user2`消息队列：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The central part of the program is the loop to send and receive the messages
    from the two users. To do this, we have to:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序的核心部分是循环，用于从两个用户那里发送和接收消息。为此，我们必须：
- en: Send a message to the user 2 with the `mq_send` method, using the `user1Desc` message
    queue descriptor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mq_send`方法向用户2发送消息，使用`user1Desc`消息队列描述符。
- en: 'Receive an eventual message that the user 2 sent us with `mq_receive`, using
    the `user2Desc` message queue descriptor:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mq_receive`从`user2Desc`消息队列描述符接收用户2发送给我们的消息：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need another program that would reply to user 1\. This program is very similar;
    the only difference is that it sends messages on `user2Desc` (which is open in
    write mode this time) and reads from `user1Desc` (which is open in read mode).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要另一个程序来回复给用户1。这个程序非常相似；唯一的区别是它在`user2Desc`上发送消息（这次以写模式打开），并从`user1Desc`（以读模式打开）读取消息。
- en: 'Let''s run the program now. We need to compile the `mq_chat_user_1.c` and `mq_chat_user_2.c` programs
    by typing the following two commands in the shell:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行程序。我们需要通过在shell中输入以下两个命令来编译`mq_chat_user_1.c`和`mq_chat_user_2.c`程序：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We're compiling and linking the programs, and generating `user1` and `user2` executables.
    We've added `-lrt` (which is the POSIX.1b Realtime Extensions library) as we need
    to include the POSIX message queue implementation. Remember that with `-l`, you're
    asking the compiler to consider a specific library for the linker phase. In the
    next section, we'll see the output, and analyze all the steps seen previously.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编译和链接程序，并生成`user1`和`user2`可执行文件。我们已经添加了`-lrt`（这是POSIX.1b实时扩展库），因为我们需要包含POSIX消息队列实现。请记住，使用`-l`时，您正在要求编译器在链接阶段考虑特定的库。在下一节中，我们将看到输出，并分析之前看到的所有步骤。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By running the `./user1` and `./user2` executables, we''d have the following
    output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`./user1`和`./user2`可执行文件，我们将得到以下输出：
- en: '![](img/5838d556-e1d8-4538-a817-e7b1fcbe6004.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5838d556-e1d8-4538-a817-e7b1fcbe6004.png)'
- en: 'Let''s have a look at the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: '**Step 1**: We need `#include <stdio.h>` for the user input/output, `#include
    <string.h>` to get the length of string through `strlen`, and `#include <mqueue.h>`
    to have access to the message queue interfaces. In this step, we''ve defined the
    max number of messages in the queue (`10`) and the max size of a message in the
    queue (`256` bytes).'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤1**：我们需要`#include <stdio.h>`进行用户输入/输出，`#include <string.h>`通过`strlen`获取字符串的长度，以及`#include
    <mqueue.h>`以访问消息队列接口。在这一步中，我们已经定义了队列中的最大消息数（`10`）和队列中消息的最大大小（`256`字节）。'
- en: '**Step 2**: In the `main` method of the program, we''ve defined the two message
    queue descriptors (`user1Desc` and `user2Desc`) to keep a reference to message
    queues; the two message arrays (`message` and `message2`) to store the messages
    to send and receive between the two users; and finally, we''ve defined and initialized
    the `struct mq_attr` structure, used to initialize the message queues we''ll use
    in the next step.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤2**：在程序的`main`方法中，我们定义了两个消息队列描述符（`user1Desc`和`user2Desc`）来保持对消息队列的引用；两个消息数组（`message`和`message2`）用于在两个用户之间存储要发送和接收的消息；最后，我们定义并初始化了`struct
    mq_attr`结构，用于初始化我们将在下一步中使用的消息队列。'
- en: '**Step 3**: In this step, we''ve opened the two message queues. These are `/user1`
    and `/user2`, and they are located in `/dev/mqueue`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤3**：在这一步中，我们已经打开了两个消息队列。它们分别是`/user1`和`/user2`，位于`/dev/mqueue`中：'
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`mq_chat_user_1.c` opens the `/user1` message queue in write-only mode and
    creates it if it''s not present. It also opens `/user2` in read-only mode and
    creates it if it''s not present. It should be clear that if the current process
    doesn''t have access rights to the message queue (which we open with `660`), `mq_open`
    will fail.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`mq_chat_user_1.c`以只写模式打开`/user1`消息队列，并在不存在时创建它。它还以只读模式打开`/user2`，并在不存在时创建它。应该清楚的是，如果当前进程没有消息队列的访问权限（我们以`660`打开），`mq_open`将失败。'
- en: '**Step 4**: This step contains the main logic of our program. It has an infinite
    loop, which sends a message from user 1 to user 2 and receives from user 2 to
    user 1\. The method used to send messages is `mq_send`. It needs the message queue
    descriptor, the message to send, its length (`+1`, as we need to include the terminator),
    and the message priority (which we didn''t use in this case). `mq_send` (see `man mq_send` for
    more info) blocks if there is no space in the queue until enough becomes available.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤4**：这一步包含了程序的主要逻辑。它有一个无限循环，从用户1发送消息到用户2，然后从用户2接收到用户1。发送消息所使用的方法是`mq_send`。它需要消息队列描述符、要发送的消息、消息的长度（`+1`，因为我们需要包括终止符）以及消息的优先级（在这种情况下我们没有使用）。`mq_send`（参见`man
    mq_send`了解更多信息）如果队列中没有足够的空间，会阻塞直到有足够的空间为止。'
- en: After the send, we call the `mq_receive` method (see `man mq_receive` for more
    info) to get an eventual message from the user 2\. It needs the message queue
    descriptor, an array that will contain the message, the max size we can receive,
    and the priority. Keep in mind that `mq_receive` blocks if there are no messages
    in the queue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 发送完毕后，我们调用`mq_receive`方法（参见`man mq_receive`了解更多信息）来从用户2获取可能的消息。它需要消息队列描述符、将包含消息的数组、我们可以接收的最大大小以及优先级。请记住，如果队列中没有消息，`mq_receive`会阻塞。
- en: For more info, see the `man mq_receive` page.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅`man mq_receive`页面。
- en: 'As send and receive are core concepts, let''s analyze them a little deeper
    with a schema:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于发送和接收是核心概念，让我们通过一个示意图来更深入地分析它们：
- en: '![](img/6f49dbd8-e83c-495b-b7b7-fb2546928205.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f49dbd8-e83c-495b-b7b7-fb2546928205.png)'
- en: '**(1)** In this case, the user 1 process calls `mq_send`. The Linux kernel
    makes a copy of the message to send from the user space to the kernel space. The
    same happens in case **(3)**.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在这种情况下，用户1进程调用`mq_send`。Linux内核会将要发送的消息从用户空间复制到内核空间。在**(3)**中也是同样的情况。'
- en: '**(2)** When the user 2 process calls `mq_receive` on the same message queue
    (`user1Desc`), the Linux kernel makes a copy of the message from the kernel space
    to the user space, copying the data in the `message2` buffer. The same happens
    in case **(4)**.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 当用户2进程在相同的消息队列（`user1Desc`）上调用`mq_receive`时，Linux内核会将消息从内核空间复制到用户空间，将数据复制到`message2`缓冲区中。在**(4)**中也是同样的情况。'
- en: There's more...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There might be cases where you may need to get the messages from the queue based
    on priority, which we didn't use in this case. Can you modify this recipe's program
    to include the priority? What do you have to modify?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有情况需要根据优先级从队列中获取消息，这在这种情况下我们没有使用。您能修改这个示例程序以包括优先级吗？您需要修改什么？
- en: You may have noticed that we used the `perror` method in this recipe. The `perror`
    method prints in the standard output the last error (`errno`), which occurs in
    a descriptive format. The advantage for the developer is that you don't have to
    explicitly get the `errno` value and translate it to a string; it is done automatically
    for you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们在这个示例中使用了`perror`方法。`perror`方法会在标准输出中打印出最后一个错误（`errno`），以描述性格式出现。开发者的优势在于不必显式地获取`errno`值并将其转换为字符串；这一切都会自动完成。
- en: The same concept of atomicity that we described for pipes and FIFOs is valid
    for message queues. The delivery of a message is guaranteed to be atomic if the
    message is smaller than `pipe_BUF`. Otherwise, a synchronization mechanism must
    be provided by the developer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息队列，我们描述管道和FIFO的原子性概念也是适用的。如果消息小于`pipe_BUF`，则消息的传递是保证原子性的。否则，开发者必须提供同步机制。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Recipes in [Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing
    with Processes and Threads* (about threading) and [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using
    Mutexes, Semaphores, and Condition Variables* (about synchronization). As usual,
    `man pages` offer a great source of information, and a suggested starting point
    is `man  mq_overview`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第3章](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml)的示例中，*处理进程和线程*（关于线程）和[第5章](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)的示例中，*使用互斥锁、信号量和条件变量*（关于同步）。通常情况下，`man`页面提供了丰富的信息源，建议的起点是`man
    mq_overview`。 '
- en: Learning how to use shared memory
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何使用共享内存
- en: In all the IPC mechanisms we've seen so far, the kernel plays an active part
    in the communication between processes, as we've learned. The information indeed
    flows through from the Linux kernel to the processes, and vice versa. In this
    recipe, we'll learn the fastest form of interprocess communication that does not
    require the kernel as the mediator between processes. As usual, although the System
    V APIs are widely available, we'll be using the newest, simpler, and better-designed
    POSIX APIs. We'll rewrite our chat application using the shared memory, digging
    into it in greater detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止看到的所有IPC机制中，内核在进程之间的通信中起着积极的作用，正如我们所学到的那样。信息确实是从Linux内核流向进程，反之亦然。在本示例中，我们将学习最快的进程间通信形式，它不需要内核作为进程之间的中介。尽管System
    V API是广泛可用的，但我们将使用最新的、更简单、设计更好的POSIX API。我们将使用共享内存重写我们的聊天应用程序，并深入研究它。
- en: How to do it...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll focus on developing a simple chat application by using
    the POSIX shared memory APIs. As the kernel does not take part in the communication
    process (directly), we need to provide a synchronization mechanism to protect
    the critical section—the shared memory—from the reads and the writes of the two
    processes:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点介绍使用POSIX共享内存API开发简单的聊天应用程序。由于内核不直接参与通信过程，我们需要提供同步机制来保护关键部分（共享内存）免受两个进程的读写：
- en: 'Let''s start by adding the include and defines we need. We''ll have two shared
    memory spaces (`STORAGE_ID1` and `STORAGE_ID2`) to have bidirectional communication
    between the processes:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先添加我们需要的包含和定义。我们将有两个共享内存空间（`STORAGE_ID1`和`STORAGE_ID2`）来实现进程之间的双向通信：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `main` method, we need two arrays to store the sent and received messages.
    Furthermore, we need to open two shared memory spaces with the following flags:
    read and write mode, create if not existing, and flags indicating read and write
    permission for the owner of the file `(S_IRUSR` and `S_IWUSR`, respectively):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，我们需要两个数组来存储发送和接收的消息。此外，我们需要以读写模式打开两个共享内存空间，并且如果不存在则创建，并且标志指示文件所有者的读写权限（分别为`S_IRUSR`和`S_IWUSR`）：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shared memory is based on `mmap` (we essentially map a file to a portion
    of memory), we need to expand the file pointed by the file descriptor 1 (`fd1`)
    to the size `STORAGE_SIZE` that we need. Then, we need to map the two file descriptors
    to a portion of memory in shared mode (`MAP_SHARED`) and, of course, check for
    errors:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于共享内存基于`mmap`（我们实质上将文件映射到内存的一部分），我们需要扩展文件描述符1（`fd1`）指向的文件到我们需要的大小`STORAGE_SIZE`。然后，我们需要将两个文件描述符映射到共享模式（`MAP_SHARED`）的一部分内存，并且当然，要检查错误：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `main` loop, as with the previous two recipes, we `read` and `write`
    in the two shared memory instances:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`循环中，与前两个示例一样，我们在两个共享内存实例中进行`read`和`write`操作：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The second program mirrors this one. You can find both of them in the `/BOOK/Chapter06`
    folder: `shm_chat_user1.c` (the one we described) and `shm_chat_user2.c`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个程序与此程序相似。您可以在`/BOOK/Chapter06`文件夹中找到它们：`shm_chat_user1.c`（我们描述的那个）和`shm_chat_user2.c`。
- en: 'Let''s compile and link the two `shm_chat_user1.c` and `shm_chat_user2.c` programs
    by typing the following two commands on the shell:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在shell上输入以下两个命令来编译和链接两个`shm_chat_user1.c`和`shm_chat_user2.c`程序：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The outputs will be two binary files: `user1` and `user2`. We've added `-lrt` in
    this case too as we need to include the POSIX shared memory implementation (without
    it, the linking phase will throw an `undefined reference to 'shm_open'` error).
    In the next section, we'll analyze all the steps seen in this section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是两个二进制文件：`user1`和`user2`。在这种情况下，我们也添加了`-lrt`，因为我们需要包含POSIX共享内存实现（如果没有它，链接阶段将抛出`undefined
    reference to 'shm_open'`错误）。在下一节中，我们将分析本节中所见的所有步骤。
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Running the `./user1` and `./user2` programs would give the following interactions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`./user1`和`./user2`程序将产生以下交互：
- en: '![](img/4d2095df-4516-4651-bdfa-36f932343e57.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d2095df-4516-4651-bdfa-36f932343e57.png)'
- en: 'Let''s perform the steps, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行：
- en: '**Step 1**: The first step just includes a few headers we need: `stdio.h` for
    the standard input/output (for example, `perror` , `printf`, and so on); `mman.h`
    for the shared memory APIs; `mmap` and `fcntl.h` for the `shm_open` flags (for
    example, `O_CREAT`, `O_RDWR`, and many others); `unistd.h` for the `ftruncate`
    method; and `string.h` for `strlen` and `memcpy` methods.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤1**：第一步只包括我们需要的一些头文件：`stdio.h`用于标准输入/输出（例如`perror`，`printf`等）；`mman.h`用于共享内存API；`mmap`和`fcntl.h`用于`shm_open`标志（例如`O_CREAT`，`O_RDWR`等）；`unistd.h`用于`ftruncate`方法；`string.h`用于`strlen`和`memcpy`方法。'
- en: 'We defined `STORAGE_ID1` and `STORAGE_ID2` to identify the two shared memory
    objects, which will be available in the `/dev/shm` folder:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`STORAGE_ID1`和`STORAGE_ID2`来标识两个共享内存对象，它们将在`/dev/shm`文件夹中可用：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Step 2**: In this step, we allocated the space on the stack for the two messages
    (`message1` and `message2`) that we''ll use to send and receive messages between
    processes. We then created and opened two new shared memory objects and checked
    for any errors.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤2**：在这一步中，我们在堆栈上为两条消息（`message1`和`message2`）分配了空间，我们将使用它们在进程之间发送和接收消息。然后，我们创建并打开了两个新的共享内存对象，并检查是否有任何错误。'
- en: '**Step 3**: Once the two shared memory objects are available, we need to extend
    the two files (through the two file descriptors `fd1` and `fd2`, one for each
    program) and—very important—mapping `fd1` and `fd2` to a virtual address space
    of the current process.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤3**：一旦两个共享内存对象可用，我们需要扩展两个文件（通过两个文件描述符`fd1`和`fd2`，每个程序一个）并且非常重要的是将`fd1`和`fd2`映射到当前进程的虚拟地址空间。'
- en: '**Step 4**: This step is the central part of the program. Here, there are a
    couple of interesting things to note. First, we can see that there is none of
    the movement of data between user space and kernel space that there was with FIFOs,
    pipes, and message queues. We just do memory copies between local buffers (allocated
    on the stack) and the memory we mapped, and vice versa. The second factor is that
    as we just deal with memory copy, the performance will be better than other IPC
    mechanisms.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4步：这一步是程序的核心部分。在这里，有一些有趣的事情需要注意。首先，我们可以看到，与FIFO、管道和消息队列不同，这里没有数据在用户空间和内核空间之间的移动。我们只是在本地缓冲区（在堆栈上分配）和我们映射的内存之间进行内存复制，反之亦然。第二个因素是，由于我们只处理内存复制，性能将优于其他IPC机制。
- en: 'The mechanic of this step is pretty simple: we ask the user to type a message
    and store it in the `message1` buffer, and then copy the buffer to the memory-mapped
    address with `addr1`. The read section (where we read the message from the second
    user) is simple too: we copy the message from the memory to the local buffer,
    `message2`.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步的机制非常简单：我们要求用户输入一条消息并将其存储在`message1`缓冲区中，然后将缓冲区复制到内存映射地址`addr1`。读取部分（我们从第二个用户那里读取消息的地方）也很简单：我们将消息从内存复制到本地缓冲区`message2`。
- en: There's more...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, there was no synchronization between the two processes in this
    recipe. That was to let you focus on one aspect only: communication with shared
    memory. The reader is again invited to improve this code to make it more interactive
    by using threads, and more secure by using a synchronization mechanism.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个配方中两个进程之间没有同步。这是为了让您只关注一个方面：与共享内存的通信。读者再次被邀请改进此代码，通过使用线程使其更加交互，并通过使用同步机制使其更加安全。
- en: Since kernel 2.6.19, Linux supports the use of **access control lists** (**ACLs**)
    to control the permissions of objects in the virtual filesystem. For more info,
    see `man acl`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.6.19内核以来，Linux支持使用访问控制列表（ACL）来控制虚拟文件系统中对象的权限。有关更多信息，请参阅`man acl`。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Recipes about threading and synchronization:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程和同步的配方：
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3章，处理进程和线程
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5章，使用互斥锁、信号量和条件变量
