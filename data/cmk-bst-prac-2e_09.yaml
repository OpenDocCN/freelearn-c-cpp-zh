- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Seamlessly Integrating Code Quality Tools with CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与CMake无缝集成代码质量工具
- en: So far, we have focused on building and installing projects, as well as generating
    documentation and handling external dependencies. Another major task when writing
    quality software is testing and ensuring that code quality is at the desired level
    by various other means. To achieve high code quality, writing unit tests and executing
    them occasionally is no longer enough. If you want to produce high-quality software,
    having proper test tools that integrate easily with your build system is not a
    luxury but a necessity. Only when building and testing work effortlessly together
    can programmers focus on writing good tests, instead of focusing on getting those
    tests to run. Methods such as test-driven development bring huge value to software
    quality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们集中于构建和安装项目，生成文档以及处理外部依赖项。编写高质量软件的另一个重要任务是测试，并通过其他手段确保代码质量达到预期水平。为了实现高代码质量，仅仅编写单元测试并偶尔执行是不够的。如果你想开发高质量的软件，拥有与构建系统轻松集成的合适测试工具不仅不是奢侈，而是必须的。只有构建和测试能够无缝配合，程序员才能专注于编写良好的测试，而不是花时间确保这些测试能够运行。像测试驱动开发这样的方式为软件质量带来了巨大价值。
- en: However, it is not just writing plain tests that increase the quality. Writing
    good tests is one thing; checking the effectiveness of the tests with coverage
    reports and ensuring general code quality with static code analysis is another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提高质量的不仅仅是编写普通的测试。编写良好的测试是一回事；通过覆盖率报告检查测试的有效性，并通过静态代码分析确保整体代码质量是另一回事。
- en: While tests, coverage, and static code analysis help determine whether code
    functions as intended, one problem is often that some of the tools only work with
    a specific compiler or require special compiler settings. In order to benefit
    from the tools, it might be necessary to compile the same source in different
    ways with different compilers. Luckily, this is exactly what CMake is extremely
    good at, which is why CMake can help to boost the quality of code by making these
    quality tools accessible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试、覆盖率和静态代码分析有助于确定代码是否按预期运行，但一个常见的问题是，一些工具仅与特定编译器兼容，或需要特殊的编译器设置。为了利用这些工具，可能需要使用不同的编译器以不同的方式编译相同的源代码。幸运的是，CMake正是擅长这一点，这也是为什么CMake能够帮助提升代码质量，使得这些质量工具易于访问的原因。
- en: The good thing about a lot of the tools for ensuring high code quality is that
    they can often be automated. With today’s easy availability of CI/CD systems,
    creating a high degree of automated checks for good quality software is quite
    easy, especially since, with CMake, these things can often be configured and executed
    right where you define how the software is built. In this chapter, you will learn
    how to define and orchestrate tests using CMake, as well as how to create code
    coverage reports to see which parts of the software are tested at all. We will
    examine how to integrate various code sanitizers and static code analyzers to
    check code quality already while compiling. We will show you various ways to include
    all the tools and how to create a dedicated build type to run static code quality
    tools. Finally, we will have a peek at how to set up micro-benchmarks to check
    the runtime performance of your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 很多确保高代码质量的工具有一个好处，那就是它们通常可以自动化。随着如今CI/CD系统的普及，创建高程度的自动化检查以确保软件质量变得相当容易，尤其是使用CMake时，这些工具通常可以在定义软件构建方式的地方进行配置和执行。本章将教你如何使用CMake定义和协调测试，并创建代码覆盖率报告，以查看哪些部分的代码已被测试。我们还将探讨如何集成各种代码清理工具和静态代码分析器，在编译时就检查代码质量。我们会展示如何将所有这些工具集成在一起，以及如何创建一个专门的构建类型来运行静态代码质量工具。最后，我们还会看看如何设置微基准测试，检查代码的运行时性能。
- en: 'This chapter covers the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主要内容：
- en: Defining, discovering, and running tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义、发现和运行测试
- en: Generating code coverage reports
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: Sanitizing your code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理代码
- en: Static code analysis using CMake
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake进行静态代码分析
- en: Creating custom build types for quality tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为质量工具创建自定义构建类型
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, the examples are tested with CMake 3.24 and
    run on any of the following compilers:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，示例在CMake 3.24下进行测试，并可以在以下任意编译器上运行：
- en: GCC 9 or newer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更高版本
- en: Clang 12 or newer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更高版本
- en: MSVC 19 or newer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更高版本
- en: Some of the examples for code coverage, sanitizers, and static code analysis
    require GCC or Clang to run and will not work with MSVC. To run Clang on Windows,
    take a look at [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible
    Build* *Environments*, where toolchain files are introduced. Some examples need
    the Catch2 unit testing suite installed to compile. Some examples pull dependencies
    from various online locations, so an internet connection is required as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关于代码覆盖率、清理工具和静态代码分析的示例需要 GCC 或 Clang 才能运行，无法在 MSVC 上运行。要在 Windows 上运行 Clang，请查看
    [*第9章*](B30947_09.xhtml#_idTextAnchor146)，*创建可重现的构建* *环境*，该章节介绍了工具链文件的使用。一些示例需要安装
    Catch2 单元测试套件才能编译。某些示例会从不同的在线位置拉取依赖项，因此也需要连接互联网。
- en: 'In addition to a working compiler, the following software is used for the examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个有效的编译器外，以下软件也用于示例中：
- en: '`Gcov`, `Gcovr`, and `lcov` for the Linux examples on code coverage'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gcov`、`Gcovr` 和 `lcov` 用于 Linux 示例中的代码覆盖率'
- en: '`Opencppcoverage` for the Windows examples on code coverage'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Opencppcoverage` 用于 Windows 示例中的代码覆盖率'
- en: '`Clang-tidy`, `Cppcheck`, `Cpplint`, and `include-what-you-use` for the examples
    on static code analyzers'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clang-tidy`、`Cppcheck`、`Cpplint` 和 `include-what-you-use` 用于静态代码分析器的示例'
- en: All examples and source code are available on the GitHub repository of this
    book at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有示例和源代码都可以在 [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)
    的 GitHub 仓库中找到。
- en: If any software is missing, the related examples will be excluded from the build.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少某些软件，相关示例将从构建中排除。
- en: Defining, discovering, and running tests
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义、发现和运行测试
- en: Testing is the staple diet for any software engineer who takes pride in quality
    software. The number of frameworks to write unit tests in the various languages
    is huge, and, especially for C++, CMake includes modules to work with most of
    the more popular ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何注重软件质量的工程师的主食。各种语言中用于编写单元测试的框架数量庞大，尤其是在 C++ 中，CMake 包含了与大多数流行框架一起使用的模块。
- en: 'At very abstract levels, all unit testing frameworks do the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常抽象的层面上，所有单元测试框架都执行以下操作：
- en: Allow the formulation and grouping of test cases
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对测试用例进行定义和分组
- en: Contain some form of assertion to check for various test conditions
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含某种形式的断言来检查不同的测试条件
- en: Discover and run test cases, either altogether or a selection of them
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现并运行测试用例，可以是全部或其中的某些测试
- en: Produce a test result in a variety of formats, such as plain text, JSON, and
    XML
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以多种格式（如纯文本、JSON 和 XML）生成测试结果
- en: With the CTest utility, CMake includes a built-in way to execute almost any
    test. Any CMake project that has set `enable_testing()` and added at least one
    test with `add_test()` has testing support enabled. Any call to `enable_testing()`
    will enable test discovery in the current directory and any directory below it,
    so it is often a good idea to set it in the top-level `CMakeLists.txt` before
    any calls to `add_subdirectory`. The CTest module of CMake automatically sets
    `enable_testing` if used with `include(CTest)`, unless the `BUILD_TESTING` option
    was set to `OFF`. /
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CTest 工具，CMake 提供了一种内置的执行几乎任何测试的方法。任何已设置 `enable_testing()` 并通过 `add_test()`
    添加了至少一个测试的 CMake 项目，都启用了测试支持。任何对 `enable_testing()` 的调用都会启用当前目录及其子目录中的测试发现，因此通常建议在顶层
    `CMakeLists.txt` 文件中设置它，且在任何调用 `add_subdirectory` 之前进行设置。CMake 的 CTest 模块会自动设置
    `enable_testing`，如果与 `include(CTest)` 一起使用，除非将 `BUILD_TESTING` 选项设置为 `OFF`。
- en: It is good practice to not build and run tests that depend on the `BUILD_TESTING`
    option. A common pattern here is to put all parts of a project that concern testing
    into their own subfolder and only include the subfolder if `BUILD_TESTING` is
    set to `ON`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议构建和运行依赖于 `BUILD_TESTING` 选项的测试。一个常见的做法是将所有与测试相关的部分放入自己的子文件夹中，并且只有在 `BUILD_TESTING`
    设置为 `ON` 时才包含该子文件夹。
- en: 'The CTest module should generally be included only in the top-level `CMakeLists.txt`
    file of a project. Since CMake version 3.21, the `PROJECT_IS_TOP_LEVEL` variable
    can be used to test whether the current `CMakeLists.txt` file is the top level.
    This variable will be `true` for the top-level directory of a project and top-level
    directories of projects added with `ExternalProject`. For directories added with
    `add_subdirectory` or `FetchContent`, the value is `false`. As such, CTest should
    be included like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 模块通常应该仅在项目的顶级 `CMakeLists.txt` 文件中包含。自 CMake 版本 3.21 起，可以使用 `PROJECT_IS_TOP_LEVEL`
    变量来测试当前的 `CMakeLists.txt` 文件是否为顶级文件。对于项目的顶级目录及通过 `ExternalProject` 添加的项目的顶级目录，该变量的值为
    `true`。对于通过 `add_subdirectory` 或 `FetchContent` 添加的目录，值为 `false`。因此，CTest 应该像这样被包含：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Generally, projects should rely on the `BUILD_TESTING` flag to determine whether
    tests should be built and included. However, especially for open source projects
    or projects with complicated requirements regarding testing, providing an additional
    `option()` to disable testing for only one specific project can be convenient
    for developers using the project. The resulting CMake code could look something
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，项目应该依赖 `BUILD_TESTING` 标志来确定是否应该构建和包含测试。然而，特别是对于开源项目或具有复杂测试需求的项目，提供一个额外的
    `option()` 来禁用仅特定项目的测试对于开发者来说是非常方便的。生成的 CMake 代码可能如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unit tests are, in essence, small programs that run a list of assertions inside,
    and if any of the assertions fail, they return a non-zero return value. There
    are many frameworks and libraries that help to organize tests and write assertions,
    but from the outside, checking assertions and returning a corresponding value
    is the core functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本质上是小型程序，它们在内部运行一系列断言，如果任何断言失败，它们将返回一个非零的返回值。有许多框架和库可以帮助组织测试和编写断言，但从外部来看，检查断言并返回相应的值是核心功能。
- en: 'Tests can be added to any `CMakeLists.txt` file with the `add_test` function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以通过 `add_test` 函数添加到任何 `CMakeLists.txt` 文件中：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`COMMAND` can be the name of an executable target defined in the project or
    a full path to an arbitrary executable. Any arguments needed for the test are
    also included. Using target names is the preferred way, as CMake will then substitute
    the path to the executable automatically. The `CONFIGURATION` option is used to
    tell CMake for which build configurations the test is valid. For most test cases,
    this is irrelevant, but for micro-benchmarking, for instance, this can be quite
    useful. `WORKING_DIRECTORY` should be an absolute path. By default, tests are
    executed in `CMAKE_CURRENT_BINARY_DIR`. The `COMMAND_EXPAND_LISTS` option ensures
    that any lists passed as part of the `COMMAND` option are expanded.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMAND` 可以是项目中定义的可执行目标的名称，也可以是任意可执行文件的完整路径。任何测试所需的参数也包括在内。使用目标名称是首选的方式，因为这样
    CMake 会自动替换可执行文件的路径。`CONFIGURATION` 选项用于告诉 CMake 测试适用于哪些构建配置。对于大多数测试用例，这一点无关紧要，但对于微基准测试等，这可能非常有用。`WORKING_DIRECTORY`
    应该是绝对路径。默认情况下，测试在 `CMAKE_CURRENT_BINARY_DIR` 中执行。`COMMAND_EXPAND_LISTS` 选项确保作为
    `COMMAND` 选项一部分传递的任何列表都会被展开。'
- en: 'A simple project including a test might look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个测试的简单项目可能如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, an executable target called `simple_test` is used as a test
    called `example_test`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用一个名为 `simple_test` 的可执行目标作为一个名为 `example_test` 的测试。
- en: 'CTest will consume the information about the tests and execute them. The tests
    are executed by running the `ctest` command standalone or as a special target
    as part of the build step of CMake. Both ways of executing require that the project
    has been built beforehand. Either of the two following commands will execute the
    tests:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 将消耗有关测试的信息并执行它们。测试通过单独运行 `ctest` 命令或作为 CMake 构建步骤的一部分执行的特殊目标来执行。无论哪种执行方式，都要求项目在执行之前已经构建。以下两条命令都将执行测试：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Invoking CTest as a target of the build has the advantage that CMake will check
    first whether all the needed targets are built and on the newest version, but
    running `ctest` directly offers more control over the tests to be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CTest 作为构建的目标来调用的优点是，CMake 会首先检查所有需要的目标是否已构建并且是最新版本，但直接运行 `ctest` 则提供了更多对执行测试的控制。
- en: 'The output of `ctest` might look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctest` 的输出可能类似于以下内容：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Generally, the test suppresses all output to `stdout`. By passing the `-V` or
    `--verbose` command-line argument, the output is always printed. However, usually,
    you’re only interested in the output of the failed tests. So, the `--output-on-failure`
    argument is often the better alternative. This way, only failed tests produce
    output. For very verbose tests, the output can be limited in size with the `--test-output-size-passed
    <size>` and `--test-output-size-failed <size>` options, where size is the number
    of bytes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试会抑制所有输出到 `stdout`。通过传递 `-V` 或 `--verbose` 命令行参数，输出将始终打印出来。然而，通常情况下，你只对失败的测试的输出感兴趣。因此，`--output-on-failure`
    参数通常是更好的选择。这样，只有失败的测试会产生输出。对于非常详细的测试，可以使用 `--test-output-size-passed <size>` 和
    `--test-output-size-failed <size>` 选项来限制输出的大小，其中 size 为字节数。
- en: Having one or more calls to `add_test` in the build tree will cause CMake to
    write out an input file for CTest in `CMAKE_CURRENT_BINARY_DIR`. The input files
    for CTest are not necessarily located at the top level of the project but where
    they are defined instead. To list all tests but not execute them, the `-N` option
    for CTest is used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建树中有一个或多个对 `add_test` 的调用，会导致 CMake 在 `CMAKE_CURRENT_BINARY_DIR` 中为 CTest
    写出一个输入文件。CTest 的输入文件不一定位于项目的顶层，而是位于定义它们的位置。要列出所有测试但不执行它们，可以使用 CTest 的 `-N` 选项。
- en: A very useful feature of CTest is that it caches the states of tests between
    runs. This allows you to only run tests that failed in the last run. To do this,
    run `ctest --rerun-failed`. If no tests failed or no tests were run before, all
    tests will be run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CTest 的一个非常有用的功能是，它在每次运行之间缓存测试的状态。这使得你只需运行上次运行中失败的测试。要做到这一点，可以运行 `ctest --rerun-failed`。如果没有测试失败或之前没有运行过任何测试，所有测试都会被执行。
- en: 'Sometimes, you do not want to execute the full test set – for instance, if
    a single failing test needs to be fixed. The `-E` and `-R` command-line options
    take `-E` option excludes tests matching the pattern, and the `-R` option selects
    tests to be included. The options can be combined. The following command would
    run all tests that begin with `FeatureX` but exclude the test called `FeatureX_Test_1`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不想执行完整的测试集——例如，如果需要修复某个单一失败的测试。`-E` 和 `-R` 命令行选项分别表示 `-E` 选项排除匹配模式的测试，而
    `-R` 选项选择需要包含的测试。这些选项可以组合使用。以下命令将执行所有以 `FeatureX` 开头的测试，但排除名为 `FeatureX_Test_1`
    的测试：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another way to selectively execute tests is to label them using the `LABELS`
    properties for tests, and then select the labels to run with the `-L` option of
    CTest. A test can have multiple labels assigned, separated by a semicolon, as
    shown in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有选择性地执行测试的方法是使用 `LABELS` 属性为测试标记标签，然后使用 CTest 的 `-L` 选项选择要执行的标签。一个测试可以分配多个标签，标签之间用分号分隔，如以下示例所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-L` command line option takes a regex to filter the labels:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L` 命令行选项接受一个正则表达式，用于过滤标签：'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will only execute `labeled_test_1` and `labeled_test_3`, as they both have
    the `example` label assigned, but not `labeled_test_2` or any other tests that
    have no label assigned.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只执行 `labeled_test_1` 和 `labeled_test_3`，因为它们都被分配了 `example` 标签，但不会执行 `labeled_test_2`
    或任何其他没有分配标签的测试。
- en: 'By formulating the regex accordingly, multiple labels can be combined:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过相应地制定正则表达式，可以将多个标签组合在一起：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will execute all the tests from the example but no other tests that have
    no label assigned.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行所有来自示例的测试，但不会执行其他没有分配标签的测试。
- en: Using labels would be particularly useful to mark tests that are designed to
    fail or similar, or tests that are only relevant in certain execution contexts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签特别有助于标记设计上会失败的测试或类似的测试，或者仅在某些执行上下文中相关的测试。
- en: 'The last alternative to the regex or label-based test selection is to use the
    `-I` option, which takes the assigned test numbers. The argument for the `-I`
    option is somewhat complicated:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式或标签基础的测试选择的最后一个替代方法是使用 `-I` 选项，它接受分配的测试编号。`-I` 选项的参数有些复杂：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With `Start`, `End`, and `Stride`, a range for the tests to be executed in can
    be specified. The three numbers are for the range combined with explicit test
    numbers, `test#`. Alternatively, a file containing the argument can be passed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Start`、`End` 和 `Stride`，可以指定要执行的测试范围。三个数字表示与显式测试编号 `test#` 结合的范围。或者，也可以传递包含参数的文件。
- en: 'The following call will execute all odd tests from `1` to `10`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调用将执行从 `1` 到 `10` 的所有奇数测试：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, tests `1`, `3`, `5`, `7`, and `9` will be executed. The following command
    will execute only the tests and `8`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试 `1`、`3`、`5`、`7` 和 `9` 将被执行。以下命令将只执行测试 `8`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that, in this call, `End` is set to `0`, so no test range is executed.
    To combine the range and explicit test numbers, the following command will execute
    all odd tests from `1` to `10`, and additionally test `6` and `8`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此调用中，`End`被设置为`0`，因此没有执行测试范围。要结合范围和显式的测试编号，以下命令将执行从`1`到`10`的所有奇数测试，并另外测试`6`和`8`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The cumbersome handling of the `-I` option and the fact that adding new tests
    might reassign the numbers are two reasons why this method is rarely used in practice.
    Usually, filtering either by labels or test names is preferred.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`-I`选项的繁琐以及添加新测试可能会重新分配编号，是这种方法在实践中很少使用的两个原因。通常，更倾向于通过标签或测试名称进行过滤。
- en: Another common pitfall when writing tests is that they are not independent enough.
    So, test `2` might accidentally depend on a previous execution of test `1`. To
    harden against this accidental dependency, CTest has the ability to randomize
    test execution order with the `--schedule-random` command-line argument. This
    will ensure that tests are executed in an arbitrary order.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试时的另一个常见陷阱是测试不够独立。因此，测试`2`可能意外地依赖于测试`1`的先前执行。为了防止这种意外依赖，CTest可以通过`--schedule-random`命令行参数随机化测试执行顺序。这将确保测试以任意顺序执行。
- en: Automatically discovering tests
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动发现测试
- en: Defining tests with `add_test` is one way to expose them to CTest. One drawback
    is that this will register the whole executable as a single test. In most cases,
    however, a single executable will contain many unit tests and not just one, so
    when one of the tests inside the executable fails, it might be hard to figure
    out which test exactly failed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_test`定义测试是将测试暴露给CTest的一种方式。一个缺点是，这将把整个可执行文件注册为一个单独的测试。然而，在大多数情况下，一个可执行文件将包含许多单元测试，而不仅仅是一个，因此当其中一个测试失败时，可能很难确定究竟是哪个测试失败了。
- en: 'Consider a C++ file containing the following test code, and let’s assume that
    the Fibonacci function contains a bug, so `Fibonacci(0)` will not return `1` as
    it should but something else instead:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含以下测试代码的C++文件，假设Fibonacci函数包含一个bug，因此`Fibonacci(0)`不会返回`1`，而是返回其他值：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If all these tests are compiled into the same executable, called `Fibonacci`,
    then adding them with `add_test` will only indicate that the executable failed,
    not telling us in which of the scenarios seen in the previous code block it did
    so.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将所有这些测试编译到同一个可执行文件中，名为`Fibonacci`，那么通过`add_test`将它们添加进去时，只会显示可执行文件失败，但不会告诉我们它在前面代码块中的哪个场景下失败了。
- en: 'The result of the test will look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果将类似于以下内容：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That is hardly helpful to figure out which of the test cases failed. Luckily,
    with Catch2 and GoogleTest, there is a way to expose the internal tests to CTest
    so that they are executed as regular tests. For GoogleTest, the module to do so
    is provided by CMake itself; Catch2 provides this functionality in its own CMake
    integration. Discovering the tests with Catch2 is done with `catch_discover_tests`,
    while for GoogleTest, `gtest_discover_tests` is used. The following example will
    expose tests written in the Catch2 framework to CTest:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做对确定哪个测试用例失败并没有太大帮助。幸运的是，使用Catch2和GoogleTest时，可以通过将内部测试暴露给CTest来使它们作为常规测试执行。对于GoogleTest，CMake本身提供了执行此操作的模块；Catch2则在其自己的CMake集成中提供了这一功能。使用Catch2发现测试是通过`catch_discover_tests`，而对于GoogleTest，则使用`gtest_discover_tests`。以下示例将把在Catch2框架中编写的测试暴露给CTest：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that, in order to have the function available, the `Catch` module has
    to be included. For GoogleTest, it works very similarly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使该函数可用，必须包含`Catch`模块。对于GoogleTest，它的工作方式非常相似：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When using the discovery functions, each test case defined in a test executable
    will be treated as its own test by CTest. If tests are exposed like this, the
    result of a call to CTest might look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用发现功能时，在测试可执行文件中定义的每个测试用例将被CTest视为其自己的测试。如果像这样暴露测试，则调用CTest的结果可能如下所示：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can see exactly which of the defined test cases failed. In this case,
    the `Fibonacci(0) returns 1` test case did not behave as expected. This comes
    in especially handy when using an editor or IDE with integrated testing functionality.
    The discovery functions both work by running the specified executable, with an
    option to only print the test names to register them internally with CTest, so
    there is a slight overhead added to each build step. Discovering tests more granularly
    also has the advantage that their execution can be better parallelized by CMake,
    as described in the *Running tests in parallel and managing test resources* section
    of this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到哪些已定义的测试用例失败了。在这种情况下，`Fibonacci(0) returns 1` 测试用例没有按预期行为工作。当使用具有集成测试功能的编辑器或IDE时，这尤其有用。发现功能通过运行指定的可执行文件来工作，可以选择仅打印测试名称并将其内部注册到
    CTest，因此每个构建步骤会有一些额外的开销。更细粒度地发现测试也有一个优点，即其执行可以更好地由 CMake 并行化，如本章的*并行运行测试和管理测试资源*部分所述。
- en: 'Both `gtest_discover_tests` and `catch_discover_tests` have various options,
    such as adding a prefix or suffix to the test names or a list of properties to
    add to the generated tests. The full documentation for the functions can be found
    here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtest_discover_tests` 和 `catch_discover_tests` 都有多种选项，例如为测试名称添加前缀或后缀，或将属性列表添加到生成的测试中。有关这些函数的完整文档可以在这里找到：'
- en: '**Catch2**: [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Catch2**: [https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md)'
- en: '**GoogleTest**: [https://cmake.org/cmake/help/v3.21/module/GoogleTest.html](https://cmake.org/cmake/help/v3.21/module/GoogleTest.html)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GoogleTest**: [https://cmake.org/cmake/help/v3.21/module/GoogleTest.html](https://cmake.org/cmake/help/v3.21/module/GoogleTest.html)'
- en: Catch2 and GoogleTest are just two of the many testing frameworks out there;
    there might be more test suites that carry this functionality that aren’t as well
    known.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Catch2 和 GoogleTest 只是众多测试框架中的两个；可能还有其他未广为人知的测试套件也具备相同功能。
- en: Now, let’s move on from finding tests and have a closer look at how to control
    test behavior.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从寻找测试转向更深入地了解如何控制测试行为。
- en: Advanced ways to determine test success or failure
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定测试成功或失败的高级方法
- en: By default, CTest determines whether a test failed or passed based on the return
    value of the command. `0` means all tests were successful; anything other than
    `0` is interpreted as a failure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CTest 会根据命令的返回值来判断测试是否失败或通过。`0` 表示所有测试成功；任何非 `0` 的返回值都被视为失败。
- en: 'Sometimes, the return value is not enough to determine whether a test passes
    or fails. If you need to check program output for a certain string, the `FAIL_REGULAR_EXPRESSION`
    and `PASS_REGULAR_EXPRESSION` test properties can be used, as shown in the following
    example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅凭返回值不足以判断测试是否通过。如果需要检查程序输出中是否包含某个字符串，可以使用 `FAIL_REGULAR_EXPRESSION` 和 `PASS_REGULAR_EXPRESSION`
    测试属性，如下例所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These properties would cause the `some_test` test to fail if the output contains
    either `"Warning"` or `"Error"`. If the `"Success"` string is found, the test
    is considered to have passed. If `PASS_REGULAR_EXPRESSION` is set, the test is
    considered to have passed only if the string is present. In both cases, the return
    value will be ignored. If a certain return value of a test needs to be ignored,
    it can be passed with the `SKIP_RETURN_CODE` option.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性会导致 `some_test` 测试失败，如果输出中包含 `"Warning"` 或 `"Error"`。如果发现 `"Success"` 字符串，则认为测试通过。如果设置了
    `PASS_REGULAR_EXPRESSION`，则仅当字符串存在时，测试才会被认为通过。在这两种情况下，返回值将被忽略。如果需要忽略某个测试的特定返回值，可以使用
    `SKIP_RETURN_CODE` 选项。
- en: 'Sometimes, a test is expected to fail. In those cases, setting `WILL_FAIL`
    to `true` will cause the test result to be inverted:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，测试预期会失败。在这种情况下，将 `WILL_FAIL` 设置为 `true` 会导致测试结果反转：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is often better than disabling the test because it will still be executed
    on each test run, and if the test unexpectedly starts to pass again, the developer
    is made aware of it. A special test failure case is when tests fail to return
    or take too much time to complete. For this case, CTest provides the means of
    adding timeouts of tests and even retrying tests if there is a failure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常比禁用测试更好，因为它仍然会在每次测试运行时执行，如果测试意外开始通过，开发人员会立即知道。一个特殊的测试失败情况是测试未返回或完成需要太长时间。对于这种情况，CTest
    提供了添加测试超时的功能，甚至可以在失败时重试测试。
- en: Handling timeouts and repeating tests
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理超时和重试测试
- en: 'Sometimes, we’re not just interested in the success or failure of a test but
    also in how long it takes to complete. The `TIMEOUT` test property takes a number
    of seconds to determine the maximum runtime for a test. If the test exceeds the
    set time, it is terminated and considered a failure. The following command would
    limit the test execution of a test to 10 seconds:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅仅关注测试的成功或失败，还关注测试完成所需的时间。`TIMEOUT`测试属性使用一个秒数来确定测试的最大运行时间。如果测试超出了设定的时间，它将被终止并视为失败。以下命令将测试的执行时间限制为10秒：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `TIMEOUT` property often comes in handy for tests that run the risk of falling
    into infinite loops or hanging forever for whatever reason.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMEOUT`属性通常对于那些有可能因某些原因进入无限循环或永远挂起的测试非常有用。'
- en: Alternatively, CTest accepts the `--timeout` argument, setting a global timeout
    that is applied to all tests that have no `TIMEOUT` property specified. For those
    tests that have `TIMEOUT` defined, the timeout defined in `CmakeLists.txt` takes
    precedence over the timeout passed over the command line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，CTest还接受`--timeout`参数，设置一个全局超时，这个超时适用于所有没有指定`TIMEOUT`属性的测试。对于那些已定义`TIMEOUT`的测试，`CmakeLists.txt`中定义的超时会优先于命令行传递的超时设置。
- en: 'To avoid long test execution, the CTest command line accepts the `--stop-time`
    argument, which takes the real-time of the day as a time limit for the complete
    set of tests. The following command would set a default timeout of 30 seconds
    for each test, and the tests would have to be completed before 23:59:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免长时间的测试执行，CTest命令行接受`--stop-time`参数，该参数以当天的实时时间作为完整测试集的时间限制。以下命令会为每个测试设置一个默认的超时为30秒，且所有测试必须在23:59之前完成：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes, we can expect a test to experience occasional timeouts due to factors
    outside of our control. Very common cases are tests that need some form of network
    communication or a resource that has some kind of bandwidth limitation. Sometimes,
    the only way to get a test to run is to try it again. For this, the `--repeat
    after-timeout:n` command-line argument can be passed to CTest, where *n* is a
    number.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会遇到由于一些不可控因素而导致的测试超时。常见的情况是需要进行某种网络通信或依赖某种带宽有限资源的测试。有时，唯一能让测试继续运行的方法是重新尝试。为此，可以将`--repeat
    after-timeout:n`命令行参数传递给CTest，其中*n*是一个数字。
- en: 'The `--repeat` argument actually has three options:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`--repeat`参数实际上有三个选项：'
- en: '`after-timeout`: This retries the test several times if a timeout occurred.
    Generally, the `--timeout` option should be passed to CTest whenever there are
    repeated timeouts.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after-timeout`：如果发生超时，这会重新尝试测试若干次。通常，若发生重复超时，应将`--timeout`选项传递给CTest。'
- en: '`until-pass`: This reruns a test until it passes or the number of retries is
    reached. Setting this as a general rule in a CI environment is a bad idea, as
    tests should generally always pass.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-pass`：这个选项会一直重新运行测试，直到通过或者达到重试次数为止。在CI环境中，作为一般规则设置此选项是不推荐的，因为测试通常应该总是通过的。'
- en: '`until-fail`: Tests are rerun a number of times or until they fail. This is
    often used if a test fails occasionally to find out how frequently this happens.
    The `--repeat-until-fail` argument works exactly like `--repeat:until-fail:n`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`until-fail`：测试会重新运行若干次，直到失败为止。这通常用于测试偶尔失败的情况，目的是找出这种失败发生的频率。`--repeat-until-fail`参数与`--repeat:until-fail:n`的作用完全相同。'
- en: As mentioned, the reason for failing tests might be the unavailability of resources
    that the test depends on. One common case for external resources being unavailable
    is that they are flooded with requests from tests. The *Running tests in parallel
    and managing test resources* section explores a few options to avoid such complications.
    Another common cause for timeouts when accessing external resources is that the
    resource is not yet available when the tests run.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试失败的原因可能是测试依赖的资源不可用。外部资源不可用的常见情况是它们被测试请求淹没。*并行运行测试和管理测试资源*部分探讨了避免此类问题的一些方法。另一种常见的超时原因是，当测试运行时，外部资源尚未可用。
- en: In the next section, we will see how to write test fixtures that can be used
    to ensure that resources are started before a test run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将看到如何编写测试夹具，确保在测试运行之前资源已经启动。
- en: Writing test fixtures
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试夹具
- en: 'Tests should, in general, be independent of each other. There are cases where
    tests might depend on a precondition that is not controlled by the test itself.
    For instance, a test might require a server to be running in order to test a client.
    These dependencies can be expressed in CMake by defining them as test fixtures,
    using the `FIXTURE_SETUP`, `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED` test properties.
    All three properties take a list of strings to identify a fixture. A test might
    indicate that it needs a particular fixture by defining the `FIXTURE_REQUIRED`
    property. This will ensure that the test named `fixture` completes successfully
    before it is executed. Similarly, a test might declare it in `FIXTURE_CLEANUP`
    to indicate that it must be run after the completion of the test requiring the
    fixture. The fixtures defined in the cleanup part are always run, regardless of
    whether a test succeeded or failed. Consider the following example, which can
    be found in the `chapter07/fixture_example` directory in the repository:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常应该彼此独立。也有一些情况，测试可能依赖于一个前提条件，而这个前提条件并不由测试本身控制。例如，某个测试可能要求一个服务器正在运行，才能测试客户端。这些依赖关系可以通过在
    CMake 中定义测试固定装置（test fixtures）来表达，使用`FIXTURE_SETUP`、`FIXTURE_CLEANUP`和`FIXTURE_REQUIRED`测试属性。所有三个属性都接受一个字符串列表来标识一个固定装置。一个测试可以通过定义`FIXTURE_REQUIRED`属性来表明它需要某个特定的固定装置。这将确保在执行该测试之前，名为`fixture`的测试已经成功完成。同样，一个测试可以在`FIXTURE_CLEANUP`中声明，表示它必须在依赖该固定装置的测试完成后执行。清理部分中定义的固定装置无论测试成功与否，都会被执行。考虑以下示例，它可以在代码库的`chapter07/fixture_example`目录中找到：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, a program called `echo_server` is used as a fixture so that
    another program called `echo_client` can use it. The execution of `echo_server`
    with the `--start` and `--stop` arguments are formulated as tests, with the names
    `start_server` and `stop_server`, respectively. The `start_server` test is marked
    as the setup of the fixture, with the name `server`. The `stop_server` test is
    set up likewise but is marked as the cleanup routine of the fixture. Finally,
    the actual test called `client_test` is set up, and it gets passed to the `server`
    fixture as a required precondition.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，名为`echo_server`的程序作为固定装置使用，以便另一个名为`echo_client`的程序可以使用它。`echo_server`的执行通过`--start`和`--stop`参数被制定为两个测试，分别命名为`start_server`和`stop_server`。`start_server`测试被标记为固定装置的设置部分，命名为`server`。`stop_server`测试同样被设置，但标记为固定装置的清理部分。最后，实际的测试`client_test`被设置，并作为必要的前提条件传递给`server`固定装置。
- en: 'If the `client_test` test is now run using CTest, the fixtures are automatically
    invoked with it. The fixture tests show up as regular tests in the output for
    CTest, as shown in the following example output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在使用 CTest 运行`client_test`，固定装置会自动与测试一起调用。固定装置测试会作为常规测试出现在 CTest 的输出中，如下所示的示例输出所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that CTest was invoked with a regex filter that only matches the client
    test, but CTest started the fixture anyway. To not overwhelm test fixtures when
    tests are executed in parallel, they can be defined as resources, as shown in
    the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，CTest是通过正则表达式过滤器调用的，仅匹配客户端测试，但CTest仍然启动了固定装置。为了避免在并行执行测试时过度加载测试固定装置，可以将它们定义为资源，如下一节所示。
- en: Running tests in parallel and managing test resources
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行运行测试并管理测试资源
- en: 'If a project has many tests, executing them in parallel will speed them up.
    By default, CTest runs tests serially; by passing the `-j` option to the call
    to CTest, tests can be run in parallel. Alternatively, the number of parallel
    threads can be defined in the `CTEST_PARALLEL_LEVEL` environment variable. By
    default, CTest assumes that each test will run on a single CPU. If a test requires
    multiple processors to run successfully, the `PROCESSORS` property for the test
    can be set to define the number of processors required:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目有很多测试，并行执行它们会加速测试过程。默认情况下，CTest 按序列运行测试；通过向 CTest 调用传递`-j`选项，可以并行运行测试。或者，也可以在`CTEST_PARALLEL_LEVEL`环境变量中定义并行线程的数量。默认情况下，CTest假设每个测试只会在单个
    CPU 上运行。如果一个测试需要多个处理器才能成功运行，则可以为该测试设置`PROCESSORS`属性，以定义所需的处理器数量：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will tell CTest that the `concurrency_test` test requires two CPUs to
    run. When running tests parallel with `-j 8`, `concurrency_test` will occupy two
    of the eight available “slots” for parallel execution. If, in this case, the `PROCESSORS`
    property is be set to `8`, this would mean that no other test can run parallel
    to `concurrency_test`. When setting a value for `PROCESSORS` that is higher than
    the available number of parallel slots or CPUs on the system, the test will run
    as soon as the full pool is available. Sometimes, some tests do not just require
    a specific number of processors but also need to run exclusively, without any
    other test running. To achieve this, the `RUN_SERIAL` property can be set to `true`
    for a test. This might have a serious impact on the overall test performance,
    so use this with caution. A more granular way to control this is by using the
    `RESOURCE_LOCK` property, which contains a list of strings. The strings have no
    particular meaning, except that CTest prevents two tests from running in parallel
    if they list the same strings. This way, partial serialization can be achieved
    without halting the whole test execution. It also is a nice way to specify whether
    tests need a particular unique resource, such as a certain file, a database, or
    similar. Consider the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉CTest，`concurrency_test` 测试需要两个CPU才能运行。当使用 `-j 8` 并行运行测试时，`concurrency_test`
    将占用八个并行执行“插槽”中的两个。如果此时，`PROCESSORS` 属性被设置为 `8`，则意味着没有其他测试可以与 `concurrency_test`
    并行运行。当为 `PROCESSORS` 设置一个大于系统上可用的并行插槽或CPU数量的值时，测试将在整个池可用时运行。有时候，一些测试不仅需要特定数量的处理器，还需要独占运行，而不与任何其他测试一起运行。为了实现这一点，可以为测试设置
    `RUN_SERIAL` 属性为 `true`。这可能会严重影响整体测试性能，因此使用时需要谨慎。一个更细粒度的控制方式是使用 `RESOURCE_LOCK`
    属性，它包含一个字符串列表。这些字符串没有特别的含义，除了 CTest 会阻止两个测试并行运行，如果它们列出了相同的字符串。通过这种方式，可以实现部分序列化，而不会中止整个测试执行。这也是指定测试是否需要某个特定唯一资源（如某个文件、数据库等）的好方法。考虑以下示例：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `database_test_1`, `database_test_2`, and `database_test_3`
    tests are prevented from running in parallel. The `some_other_test` test is not
    affected by the database tests, but `yet_another_test` will not run together with
    any of the database tests and `some_other_test`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`database_test_1`、`database_test_2` 和 `database_test_3` 测试被阻止并行运行。`some_other_test`
    测试不受数据库测试的影响，但 `yet_another_test` 将不会与任何数据库测试和 `some_other_test` 一起运行。
- en: Fixtures as resources
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为资源的夹具
- en: While not technically required, if `RESOURCE_LOCK` is used together with `FIXTURE_SETUP`,
    `FIXTURE_CLEANUP`, and `FIXTURE_REQUIRED`, it is good practice to use the same
    identifiers for the same resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上不是必需的，但如果 `RESOURCE_LOCK` 与 `FIXTURE_SETUP`、`FIXTURE_CLEANUP` 和 `FIXTURE_REQUIRED`
    一起使用，最好为相同的资源使用相同的标识符。
- en: Managing the parallelism of tests with `RESOURCE_LOCK` is very handy when tests
    need exclusive access to some resource. In most cases, it is entirely sufficient
    to manage the parallelism. Since CMake 3.16, this can be controlled on an even
    more granular level with the `RESOURCE_GROUPS` property. Resource groups allow
    you to not just specify *which* resources are used but also *how much* of a resource
    is used. Common scenarios are defining the amount of memory a particular greedy
    operation might need or avoiding overrunning the connection limit of a certain
    service. Resource groups often come into play when working on projects that use
    the GPU for general-purpose computing, defining how many slots of a GPU each test
    needs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RESOURCE_LOCK` 管理测试的并行性在测试需要独占访问某些资源时非常方便。在大多数情况下，这完全足够管理并行性。从 CMake 3.16
    开始，这可以通过 `RESOURCE_GROUPS` 属性在更细粒度的级别上进行控制。资源组不仅允许你指定*哪些*资源被使用，还允许你指定*使用多少*资源。常见的场景是定义特定贪婪操作可能需要的内存量，或者避免超过某个服务的连接限制。资源组通常在使用GPU进行通用计算的项目中出现，定义每个测试需要多少GPU插槽。
- en: 'Resource groups are quite a step up in complexity compared to simple resource
    locks. To use them, CTest has to do the following things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单的资源锁相比，资源组在复杂性上迈出了很大一步。要使用它们，CTest必须执行以下操作：
- en: '**Know which resources a test needs to run**: This is defined by setting the
    test properties in a project'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解一个测试需要哪些资源才能运行**：这通过在项目中设置测试属性来定义'
- en: '**Know which resources a system has available**: This is done from outside
    a project when running tests'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解系统中可用的资源**：这是在运行测试时在项目之外完成的'
- en: '**Pass on information about which resources to use for a test**: This is done
    by using environment variables'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递关于测试使用哪些资源的信息**：这是通过使用环境变量来完成的。'
- en: 'Like resource locks, resource groups are arbitrary strings used to identify
    resources. The definition of the actual resource tied to the label is left to
    the user. The resource groups are defined as `name:value` pairs, which are separated
    by commas if there are multiple groups. A test can define which resources to use
    with the `RESOURCE_GROUPS` property, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于资源锁，资源组是用来标识资源的任意字符串。实际与标签绑定的资源定义由用户来指定。资源组定义为 `name:value` 对，如果有多个组，则通过逗号分隔。测试可以通过
    `RESOURCE_GROUPS` 属性定义要使用的资源，如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, `SomeTest` states that it uses two CPUs and 500 MB
    of memory. It uses a total of six instances of a client-server pair, each pair
    having several servers and clients assigned. The first pair consists of one server
    instance and one client instance; the second pair requires one server but two
    client instances.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`SomeTest` 表示它使用了两个 CPU 和 500 MB 的内存。它总共使用了六个客户端-服务器对实例，每对包含多个服务器和客户端实例。第一对由一个服务器实例和一个客户端实例组成；第二对需要一个服务器，但有两个客户端实例。
- en: The last line, `4, servers:1,clients:1`, is shorthand to tell CTest to use four
    instances of the same pair, consisting of one `servers` resource and one `clients`
    resource. This means this test will not run unless a total of six servers and
    seven clients are available, in addition to the required CPUs and memory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行，`4, servers:1,clients:1`，是用来告诉 CTest 使用四个相同的实例对，由一个 `servers` 资源和一个 `clients`
    资源组成。这意味着这个测试不会运行，除非总共可以提供六个服务器和七个客户端，以及所需的 CPU 和内存。
- en: The available system resources are specified in a JSON file that is passed to
    CTest, either by the `ctest --resource-spec-file` command-line parameter or by
    setting the `CTEST_RESOURCE_SPEC_FILE` variable when calling CMake. Setting the
    variable should be done by using `cmake -D` and not done in `CMakeLists.txt`,
    as specifying the system resources should be done from outside a project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的系统资源在一个 JSON 文件中指定，该文件传递给 CTest，方法是通过 `ctest --resource-spec-file` 命令行参数，或在调用
    CMake 时设置 `CTEST_RESOURCE_SPEC_FILE` 变量。设置变量应该通过使用 `cmake -D` 来完成，而不是在 `CMakeLists.txt`
    中进行，因为指定系统资源应该在项目外部完成。
- en: 'A sample resource specification file for the preceding example could look like
    this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的一个资源规格文件可能如下所示：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This file specifies a system with 4,096 MB of memory, 8 CPUs, 2x4 server instances,
    and 2x8 client instances for a total of 8 servers and 16 clients. If a resource
    request for a test cannot be satisfied with the available system resources, it
    fails to run, throwing an error like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件指定了一个具有 4096 MB 内存、8 个 CPU、2x4 服务器实例和 2x8 客户端实例的系统，总共 8 个服务器和 16 个客户端。如果无法用可用的系统资源满足测试的资源请求，则测试无法运行，并抛出类似如下的错误：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The current example would be able to run with this specification, as it needs
    a total of six servers and seven clients. CTest has no way of ensuring that the
    specified resources are actually available or not; this is the task of the user
    or the CI system. For instance, a resource file might specify that there are eight
    CPUs available, while the hardware actually only contains four cores.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的示例可以在这个规格下运行，因为它需要总共六个服务器和七个客户端。CTest 无法确保指定的资源是否真正可用；这项任务由用户或 CI 系统负责。例如，一个资源文件可能指定有八个
    CPU 可用，但硬件实际上只有四个核心。
- en: 'The information about the assigned resource groups is passed to the test over
    environment variables. The `CTEST_RESOURCE_GROUP_COUNT` environment variable specifies
    the total number of resource groups assigned to a test. If it is not set, this
    means that CTest was invoked without an environment file. Tests should check this
    and act accordingly. If a test cannot run without the resources, it should either
    fail or indicate that it did not run by returning the respective return code or
    string defined in the `SKIP_RETURN_CODE` or `SKIP_REGULAR_EXPRESSION` property.
    The resource groups assigned to the test are passed with pairs of environment
    variables:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分配的资源组的信息通过环境变量传递给测试。`CTEST_RESOURCE_GROUP_COUNT` 环境变量指定分配给测试的资源组的总数。如果未设置该变量，则表示
    CTest 是在没有环境文件的情况下调用的。测试应该检查这一点并相应地采取行动。如果一个测试在没有资源的情况下无法运行，它应该失败，或者通过返回在 `SKIP_RETURN_CODE`
    或 `SKIP_REGULAR_EXPRESSION` 属性中定义的相应返回代码或字符串来表明它未运行。分配给测试的资源组通过一对环境变量传递：
- en: '`CTEST_RESOURCE_GROUP_<ID>`, which will contain the type of resource group.
    In the example from earlier, this will be either `"mem_mb"`, `"cpus"`, `"clients"`,
    or `"servers"`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CTEST_RESOURCE_GROUP_<ID>`，它将包含资源组的类型。在之前的示例中，这将是 `"mem_mb"`、`"cpus"`、`"clients"`
    或 `"servers"`。'
- en: '`CTEST_RESOURCE_GROUP_<ID>_<TYPE>`, which will contain a pair of `id:slots`
    for the types.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CTEST_RESOURCE_GROUP_<ID>_<TYPE>`，它将包含一个 `id:slots` 的类型对。'
- en: It is up to the implementation of the test on how the resource groups are used
    and internally distributed. So far, we have seen how tests are executed with CTest,
    but defining and discovering the tests is equally important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用资源组以及如何在内部分配资源，取决于测试的实现。到目前为止，我们已经看到了如何使用 CTest 执行测试，但定义和发现测试同样重要。
- en: Writing and running tests is obviously one of the major boosters of code quality.
    However, another interesting metric is often how much of your code is actually
    covered by tests. Surveying and reporting code coverage can give interesting hints,
    not just about how widely a software is tested but also about where gaps lie.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和运行测试显然是提升代码质量的主要推动力之一。然而，另一个有趣的指标往往是你的代码实际被多少测试覆盖。调查和报告代码覆盖率可以提供有趣的线索，不仅可以了解软件的测试广度，还能发现代码中的空白区域。
- en: Generating code coverage reports
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成代码覆盖率报告
- en: Being aware of how much of your code is covered by tests is a great benefit
    and often gives a very good impression of how well-tested a given software is.
    It can also give hints to developers about the execution paths and edge cases
    that are not covered by tests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 了解你的代码被测试覆盖的程度是一个很大的好处，通常可以给人留下软件测试充分的良好印象。它还可以为开发者提供有关未被测试覆盖的执行路径和边缘情况的提示。
- en: To get code coverage in C++
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 C++ 代码覆盖率
- en: There are a few tools that help you get code coverage in C++. Arguably, the
    most popular is *Gcov* from GNU. It’s been around for years and works well with
    GCC and Clang. Although it does not work with Microsoft’s Visual Studio, using
    Clang to build and run software provides a viable alternative for Windows. Alternatively,
    the `OpenCppCoverage` tool can be used to get coverage data on Windows to build
    with MSVC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助你获取 C++ 代码覆盖率。可以说，最流行的工具是来自 GNU 的*Gcov*。它已经存在多年，并且与 GCC 和 Clang 配合得很好。尽管它与微软的
    Visual Studio 不兼容，但使用 Clang 来构建和运行软件为 Windows 提供了可行的替代方案。或者，`OpenCppCoverage`
    工具可以在 Windows 上获取 MSVC 构建的覆盖率数据。
- en: The coverage information generated by Gcov can be collected in summarized reports
    with the Gcovr or LCOV tools.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Gcov 生成的覆盖率信息可以通过 Gcovr 或 LCOV 工具汇总为报告。
- en: Generating coverage reports using Clang or GCC
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Clang 或 GCC 生成覆盖率报告
- en: 'In this section, we will look at how to create code coverage reports with Gcovr.
    Generating these reports roughly works in the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看看如何使用 Gcovr 创建代码覆盖率报告。生成这些报告的大致过程如下：
- en: The program and libraries to be tested are compiled with special flags so that
    they expose the coverage information.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被测试的程序和库需要使用特殊的标志进行编译，以便它们暴露出覆盖率信息。
- en: The program is run, and the coverage information is stored in a file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序运行后，覆盖率信息会存储在一个文件中。
- en: The coverage analyzers, such as Gcovr or LCOV, analyze the coverage files and
    generate reports.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖率分析工具，如 Gcovr 或 LCOV，会分析覆盖率文件并生成报告。
- en: Optionally, the reports are stored or further analyzed to display trends in
    coverage.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，报告可以存储或进一步分析，以显示覆盖率的趋势。
- en: A common setting for code coverage is that you want to have information about
    how much of a project’s code is covered by the unit tests. In order to do this,
    the code has to be compiled with the necessary flags so that the information is
    exposed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率的常见设置是，你想要了解项目代码中有多少部分被单元测试覆盖。为了做到这一点，代码必须使用必要的标志进行编译，以便信息能够被暴露出来。
- en: 'The `<LANG>_COMPILER_FLAGS` cache variable should be passed to CMake over the
    command line. When using GCC or Clang, this might look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`<LANG>_COMPILER_FLAGS` 缓存变量应通过命令行传递给 CMake。使用 GCC 或 Clang 时，这可能看起来像这样：'
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: An alternative method is to define the respective preset, as explained in [*Chapter
    9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build* *Environments*.
    When building for coverage, it is often a good idea to compile with the debug
    information enabled and disable any optimization with the `-Og` flag. Additionally,
    specifying the `-fkeep-inline-functions` and `-fkeep-static-consts` compiler flags
    will prevent you from optimizing out static and inlined functions if they are
    never used. This will make sure that all possible execution branches are compiled
    into code; otherwise, the coverage report might be misleading, especially for
    inlined functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是定义各自的预设，如在[*第9章*](B30947_09.xhtml#_idTextAnchor146)中所述，*创建可复现的构建* *环境*。在构建代码覆盖率时，通常一个好的做法是启用调试信息并使用`-Og`标志禁用任何优化。此外，指定`-fkeep-inline-functions`和`-fkeep-static-consts`编译器标志将防止在函数未被使用的情况下优化掉静态和内联函数。这将确保所有可能的执行分支都被编译到代码中；否则，覆盖率报告可能会产生误导，特别是对于内联函数。
- en: Coverage reports work not just for single executables but also for libraries.
    However, the libraries must be compiled with coverage flags on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告不仅适用于单个可执行文件，还适用于库。但是，库必须在启用覆盖率标志的情况下编译。
- en: As the compiler flags for coverage are set globally, the options will be passed
    on to projects added with `FetchContent` or `ExternalProject`, which might increase
    compilation time considerably.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于覆盖率的编译器标志是全局设置的，这些选项将传递给通过`FetchContent`或`ExternalProject`添加的项目，这可能会显著增加编译时间。
- en: Compiling sources using GCC or Clang with the coverage flags enabled will create
    `.gcno` files in the build directories for each object file and executable. These
    files contain meta information for Gcov about which calls and execution paths
    are available in the respective compilation units. In order to find out which
    of these paths are used, the programs have to be run.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启用覆盖率标志的GCC或Clang编译源代码将会在每个目标文件和可执行文件的构建目录中创建`.gcno`文件。这些文件包含关于各自编译单元中可用的调用和执行路径的Gcov元信息。为了找出哪些路径被使用，必须运行程序。
- en: Check out the versions of Gcov and GCC
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Gcov和GCC的版本
- en: A common cause for failure and frustration when trying to extract code coverage
    information is that the versions of GCC and Gcov do not match. Always check with
    `g++ --version` and `gcov --version` that they are the same.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提取代码覆盖率信息时常见的失败和挫折原因是GCC和Gcov的版本不匹配。请始终通过`g++ --version`和`gcov --version`检查它们是否相同。
- en: In a scenario where we want to find out the code coverage of tests, running
    CTest will generate the coverage results. Alternatively, running the executables
    directly will produce the same results. Running executables with coverage enabled
    will generate `.gcda` files in the build directories that contain information
    about the calls in the respective object files.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要了解测试代码覆盖率的场景中，运行CTest将生成覆盖率结果。或者，直接运行可执行文件也会产生相同的结果。启用覆盖率的可执行文件将会在构建目录中生成`.gcda`文件，其中包含关于各自目标文件中调用的信息。
- en: Once these files are generated, running Gcovr on them will create information
    about the coverage. By default, Gcovr outputs the information to `stdout`, but
    it can also generate HTML pages, JSON files, or SonarQube reports.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些文件生成，运行Gcovr将会生成有关覆盖率的信息。默认情况下，Gcovr将信息输出到`stdout`，但它也可以生成HTML页面、JSON文件或SonarQube报告。
- en: 'One of the pitfalls is that Gcovr expects all source and object files to be
    in the same directory, which is not the case with CMake. So, we have to pass the
    respective directories to Gcov with the `-r` option, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的陷阱是，Gcovr期望所有源代码和目标文件都位于同一目录中，但这在CMake中并非如此。因此，我们必须通过`-r`选项将相应的目录传递给Gcov，如下所示：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Such a call might produce an HTML file that looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的调用可能会生成一个看起来像这样的HTML文件：
- en: '![Figure 7.1 – Example output for a coverage run](img/B30947_07_01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 覆盖率运行示例输出](img/B30947_07_01.jpg)'
- en: Figure 7.1 – Example output for a coverage run
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 覆盖率运行示例输出
- en: 'Another alternative to Gcovr is LCOV, which works in a very similar way. In
    contrast to Gcovr, LCOV cannot directly produce HTML or XML output but will assemble
    any coverage information in an intermediate format, which can then be consumed
    by various converters. To produce HTML output, the `genhtml` tool is often used.
    To generate a report using LCOV, the commands might look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Gcovr的另一个替代方案是LCOV，它的工作方式非常相似。与Gcovr不同，LCOV不能直接生成HTML或XML输出，而是将任何覆盖率信息组装成一个中间格式，然后可以通过各种转换器进行处理。为了生成HTML输出，通常使用`genhtml`工具。使用LCOV生成报告的命令可能如下所示：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A coverage report generated with LCOV might look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LCOV生成的覆盖率报告可能如下所示：
- en: '![Figure 7.2 – An example coverage report generated with LCOV](img/B30947_07_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 使用LCOV生成的示例覆盖率报告](img/B30947_07_02.jpg)'
- en: Figure 7.2 – An example coverage report generated with LCOV
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 使用LCOV生成的示例覆盖率报告
- en: Note that these calls will only create coverage reports for the last run. If
    you want to assemble them into a time series to see whether code coverage increases
    or decreases, there are various CI tools available, such as Codecov and Cobertura,
    to do this. Such tools can generally parse output from Gcovr or LCOV and assemble
    it into fancy graphics, showing the coverage trends. The detailed documentation
    for Gcovr can be found at [https://gcovr.com/en/stable/](https://gcovr.com/en/stable/).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些调用只会为最后一次运行创建覆盖率报告。如果你想将它们汇总成一个时间序列，以查看代码覆盖率是增加还是减少，有许多CI工具可供使用，如Codecov和Cobertura，来完成这项工作。这些工具通常可以解析Gcovr或LCOV的输出，并将其汇总为精美的图形，展示覆盖率的趋势。有关Gcovr的详细文档可以在[https://gcovr.com/en/stable/](https://gcovr.com/en/stable/)找到。
- en: Creating coverage reports for MSVC
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为MSVC创建覆盖率报告
- en: 'When building software using MSVC, the `OpenCppCoverage` tool is an alternative
    to Gcov. It works by analyzing the program databases (`.pdb`) produced by the
    MSVC compiler, rather than by compiling the source with different flags. The command
    to generate an HTML coverage report for a single executable might look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MSVC构建软件时，`OpenCppCoverage`工具是Gcov的替代方案。它通过分析MSVC编译器生成的程序数据库（`.pdb`），而不是通过使用不同的标志重新编译源代码来工作。生成单个可执行文件的HTML覆盖率报告的命令可能如下所示：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since this will only generate the coverage report for a single executable,
    `OpenCppCoverage` enables you to read the input from previous rounds and combine
    it into a report like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将仅生成单个可执行文件的覆盖率报告，`OpenCppCoverage`允许你读取先前回合的输入，并将其合并成如下报告：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will combine the input of the first two runs into a common report. To consume
    the coverage information, the `export_type` option has to be `binary`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把前两次运行的输入合并成一个公共报告。为了处理覆盖率信息，`export_type`选项必须设置为`binary`。
- en: 'A common use for coverage reports is to find out how much code is covered by
    the tests defined in a project. In this case, using CTest as the test driver is
    convenient. As CTest will run the actual tests as subprocesses, the `--cover_children`
    option has to be passed to `OpenCppCoverage`. To avoid generating coverage reports
    for the system libraries used, adding a module and a source filter might be required.
    The command might look something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告的一个常见用途是找出项目中由测试定义所覆盖的代码量。在这种情况下，使用CTest作为测试驱动程序是很方便的。由于CTest将实际测试作为子进程运行，因此必须将`--cover_children`选项传递给`OpenCppCoverage`。为了避免生成系统库的覆盖率报告，可能需要添加模块和源过滤器。命令可能如下所示：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A slight downside to this approach is that the coverage report will include
    a coverage report for CTest itself. The generated HTML report might look like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个小缺点是，覆盖率报告会包括CTest本身的覆盖率报告。生成的HTML报告可能如下所示：
- en: '![Figure 7.3 – A coverage report generated with OpenCppCoverage](img/B30947_07_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 使用OpenCppCoverage生成的覆盖率报告](img/B30947_07_03.jpg)'
- en: Figure 7.3 – A coverage report generated with OpenCppCoverage
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 使用OpenCppCoverage生成的覆盖率报告
- en: 'If you use Visual Studio, an alternative to the command line is to use a plugin.
    The plugin can be found on the Visual Studio marketplace: [https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin](https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio，命令行的替代方案是使用插件。插件可以在Visual Studio市场中找到：[https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin](https://marketplace.visualstudio.com/items?itemName=OpenCppCoverage.OpenCppCoveragePlugin)
- en: 'For the full documentation, consult the GitHub page of `OpenCppCoverage`: [https://github.com/OpenCppCoverage/OpenCppCoverage](https://github.com/OpenCppCoverage/OpenCppCoverage)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的文档，请参考 `OpenCppCoverage` 的 GitHub 页面：[https://github.com/OpenCppCoverage/OpenCppCoverage](https://github.com/OpenCppCoverage/OpenCppCoverage)
- en: Knowing how much of your code is covered by the supplied tests is a piece of
    very valuable information regarding code quality. In fact, in a lot of regulated
    industries, such as healthcare, aviation, and the car industry, providing code
    coverage reports might be required by the regulatory bodies. However, only knowing
    how much code is executed is obviously not enough; the quality of the underlying
    code is of even more importance. Some compilers provide useful tools to detect
    common errors in your code with the help of so-called sanitizers. In the next
    section, you will learn how to use and apply the sanitizers using CMake.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 知道代码测试覆盖了多少内容是了解代码质量的非常有价值的信息。事实上，在许多受监管的行业中，比如医疗、航空和汽车行业，监管机构可能要求提供代码覆盖率报告。然而，仅仅知道代码执行了多少是不够的；底层代码的质量更为重要。一些编译器提供了有用的工具，通过所谓的
    sanitizer 来检测代码中的常见错误。在下一节中，您将学习如何使用 CMake 来应用这些 sanitizer。
- en: Sanitizing your code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理代码
- en: Today’s compilers are often more than just programs to convert text to binary
    code. They are complex software suites that have built-in functionality to ensure
    code quality. The focus on how much compilers are aware of code quality issues
    has drastically increased, especially with the advent of LLVM and Clang. These
    quality tools are commonly called **sanitizers** and are enabled by passing certain
    flags to the compiler and linker.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的编译器不仅仅是将文本转换为二进制代码的程序。它们是复杂的软件套件，内置了确保代码质量的功能。编译器对代码质量问题的关注程度急剧增加，尤其是随着 LLVM
    和 Clang 的出现。这些质量工具通常被称为 **sanitizers**，并通过向编译器和链接器传递特定标志来启用。
- en: Code sanitizers are a way to bring additional quality checks into code by using
    the compiler to decorate the binary code with annotations and hooks, detecting
    various runtime issues. When the code is executed, the annotations are checked
    and confirmed if any violations are reported. Sanitizers are relatively fast,
    but they obviously have an impact on the runtime behavior of any program. If the
    sanitizers catch anything, programs are terminated with `abort()` and return with
    non-zero. This is particularly useful with testing because this means any test
    violating a sanitizer will be marked as a failure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 sanitizer 是通过使用编译器为二进制代码添加注释和钩子，从而带来额外的质量检查，能够检测各种运行时问题。代码执行时，系统会检查这些注释，若发现任何违规行为，会进行报告。Sanitizer
    相对较快，但显然会对程序的运行时行为产生影响。如果 sanitizer 检测到任何问题，程序会调用 `abort()` 终止，并返回非零值。这在测试中尤为有用，因为这意味着任何违反
    sanitizer 的测试都会被标记为失败。
- en: 'The following are the most common types of sanitizers:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常见的几种 sanitizer 类型：
- en: The **address sanitizer** (**ASan**) detects memory access errors such as out-of-bounds
    and use-after-free bugs. On some platforms, the ASan can even be run with hardware
    assistance.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址 sanitizer**（**ASan**）用于检测内存访问错误，如越界访问和使用后释放错误。在某些平台上，ASan 甚至可以使用硬件辅助来运行。'
- en: The **leak sanitizer** (**LSan**), which is part of the ASan, can be used to
    detect memory leaks.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泄漏 sanitizer**（**LSan**）是 ASan 的一部分，可用于检测内存泄漏。'
- en: In GCC and Clang, there are a few specialized versions of the general ASan,
    such as the **kernel address sanitizer** (**KASAN**) to detect memory errors in
    the Linux kernel.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GCC 和 Clang 中，存在一些 ASan 的专用版本，比如 **内核地址 sanitizer**（**KASAN**），用于检测 Linux
    内核中的内存错误。
- en: The **memory sanitizer** (**MSan**) detects uninitialized memory reads.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存 sanitizer**（**MSan**）用于检测未初始化的内存读取。'
- en: The **thread sanitizer** (**TSan**) will report data races. Because of the way
    the TSan works, it cannot be run together with the ASan and LSan.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程 sanitizer**（**TSan**）会报告数据竞争问题。由于 TSan 的工作方式，它不能与 ASan 和 LSan 一起运行。'
- en: The **undefined behavior sanitizer** (**UBSan**) detects and reports cases where
    code results in undefined behavior. Using variables before initialization or ambiguity
    regarding operator precedence are common examples.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未定义行为 sanitizer**（**UBSan**）用于检测并报告代码导致未定义行为的情况。使用未初始化的变量或操作符优先级的歧义是常见的例子。'
- en: The Clang suite leads the field with the availability of sanitizers, with GCC
    coming a close second. Microsoft has been a bit slower in adopting the features,
    but from MSVC version 16.9, which comes with Visual Studio 19, the Microsoft compilers
    support at least the ASan. For details on what the respective sanitizers do and
    how to configure them in detail, refer to the helpful documentation of the various
    compilers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 套件在 sanitizers 的可用性方面处于领先地位，其次是 GCC。微软在采用这些特性上稍慢，但从 MSVC 版本 16.9（随 Visual
    Studio 19 一起发布）开始，微软的编译器至少支持 ASan。有关各个 sanitizer 的详细功能以及如何详细配置它们，请参考各编译器的有用文档。
- en: The sanitizers are enabled by passing various compiler flags that cause a compiler
    to add extra debugging information to the binaries. When the binaries are executed,
    the sanitizer code will perform its check and print out any errors to `stderr`.
    As the code needs to be executed for the sanitizers to find any potential bugs,
    having high code coverage is essential to improve the reliability of the sanitizers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递各种编译器标志启用 sanitizers，这些标志会使编译器将额外的调试信息添加到二进制文件中。当执行二进制文件时，sanitizer 代码会执行检查，并将任何错误打印到`stderr`。由于代码需要执行才能让
    sanitizers 找到潜在的 bug，因此，高代码覆盖率对于提高 sanitizers 的可靠性至关重要。
- en: To enable the ASan in GCC or Clang, the `-fsanitize=<sanitizer>` compiler flag
    has to be passed. For MSVC, the corresponding option is `/fsanitize=<sanitizer>`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 GCC 或 Clang 中启用 ASan，必须传递`-fsanitize=<sanitizer>`编译器标志。对于 MSVC，相应的选项是`/fsanitize=<sanitizer>`。
- en: 'The compiler flags are passed into CMake with the `CMAKE_CXX_FLAGS` cache variable.
    So, calling CMake from the command line with a sanitizer enabled would look like
    this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器标志通过`CMAKE_CXX_FLAGS`缓存变量传递给CMake。因此，从命令行调用启用 sanitizers 的 CMake 命令应该如下所示：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When using CMake presets, the cache variables to contain the compiler flags
    can also be defined there. Presets are covered in depth in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146),
    *Creating Reproducible Build* *Environments*. Setting the `sanitizer` option globally
    will also affect any projects included that use `FetchContent` or `ExternalProject`
    after the flags are set, so act with caution there. For the ASan, use `-fsanitizer=address`
    on GCC and Clang, and `/fsanitizer=address` on MSVC. The MSan is enabled with
    `-fsanitize=memory`, the LSan is enabled with `-fsanitize=leak`, the TSan is enabled
    with `-fsanitize=thread`, and the UBSan is enabled with `-fsanitize=undefined`
    for GCC and Clang only at the time of writing. To get a more concise output for
    the ASan, LSan, and MSan, tell the compiler to explicitly keep the frame pointer.
    This is done by setting `-fno-omit-framepointer` in GCC and Clang. MSVC only supports
    this for x86 builds with the `/``Oy-` option.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 CMake 预设时，也可以在其中定义包含编译器标志的缓存变量。预设在[*第 9 章*](B30947_09.xhtml#_idTextAnchor146)《创建可重现的构建环境》中有详细介绍。全局设置`sanitizer`选项也会影响在标志设置后使用`FetchContent`或`ExternalProject`的任何包含项目，因此在这里请小心操作。对于
    ASan，使用在 GCC 和 Clang 中的`-fsanitizer=address`，在 MSVC 中使用`/fsanitizer=address`。MSan
    通过`-fsanitize=memory`启用，LSan 通过`-fsanitize=leak`启用，TSan 通过`-fsanitize=thread`启用，UBSan
    在撰写本文时仅在 GCC 和 Clang 中通过`-fsanitize=undefined`启用。为了获得 ASan、LSan 和 MSan 更简洁的输出，可以告诉编译器显式保留帧指针。通过在
    GCC 和 Clang 中设置`-fno-omit-framepointer`来实现。MSVC 仅在 x86 构建中通过`/Oy-`选项支持此功能。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the `CMAKE_CXX_FLAGS` variable to enable sanitizers in `CMakeLists.txt`
    itself is discouraged, as the sanitizers are neither built nor have any usage
    requirements to use any of the targets defined by a project. Additionally, setting
    the `CMAKE_CXX_FLAGS` variable in `CMakeLists.txt` might conflict with what the
    user might pass from the command line.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐在`CMakeLists.txt`中设置`CMAKE_CXX_FLAGS`变量来启用 sanitizers，因为 sanitizers 既不构建也没有任何使用要求来使用项目定义的目标。此外，在`CMakeLists.txt`中设置`CMAKE_CXX_FLAGS`变量可能与用户从命令行传递的标志发生冲突。
- en: Sanitizers are a very powerful tool to increase code quality. Together with
    unit tests and the coverage report, they provide three of the four major concepts
    to ensure code quality. The fourth option to automatically ensure code quality
    is using static code analyzers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Sanitizers 是提高代码质量的非常强大的工具。结合单元测试和覆盖率报告，它们提供了确保代码质量的四个主要概念中的三个。第四种自动确保代码质量的方式是使用静态代码分析器。
- en: Static code analysis using CMake
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CMake 进行静态代码分析
- en: Unit tests, sanitizers, and coverage reports all depend on code being actually
    run to detect possible errors. Static code analysis analyzes code without running
    it. The good thing about that is that all code that is compiled can be analyzed,
    not just the parts that are covered by tests. This, of course, also means that
    different kinds of glitches can be found. A downside of static code analysis is
    that it can take a very long time to run tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试、清理器和覆盖率报告都依赖于实际运行代码来检测可能的错误。静态代码分析则是在不运行代码的情况下进行分析。其优点是所有编译的代码都可以进行分析，而不仅仅是测试覆盖的部分。当然，这也意味着可以发现不同类型的故障。静态代码分析的一个缺点是，它可能需要很长时间才能运行完所有测试。
- en: 'CMake supports several tools for static code analysis that are enabled either
    by setting a property or a global variable. All of the tools, except *link what
    you use*, are external programs that need to be installed and found in the path
    of the system. *Link what you use* uses the linker of a system, so no further
    installation is necessary. The tools supported by CMake are the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持多种静态代码分析工具，这些工具通过设置属性或全局变量来启用。除*link what you use*外，所有工具都是外部程序，需要安装并在系统路径中找到。*Link
    what you use* 使用系统的链接器，因此不需要进一步安装。CMake 支持的工具如下：
- en: '`LANG>_CLANG_TIDY` property or the `CMAKE_<LANG>_CLANG_TIDY` variable.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANG>_CLANG_TIDY` 属性或 `CMAKE_<LANG>_CLANG_TIDY` 变量。'
- en: '`<LANG>_CPPCHECK` property or the `CMAKE_<LANG>_CPPCHECK` variable.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPCHECK` 属性或 `CMAKE_<LANG>_CPPCHECK` 变量。'
- en: '`<LANG>_CPPLINT` property or the `CMAKE_<LANG>_CPPLINT` variable. Cpplint was
    originally developed at Google, and because of this, it has the Google C++ style
    hardcoded within.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPLINT` 属性或 `CMAKE_<LANG>_CPPLINT` 变量。Cpplint 最初由 Google 开发，因此它内置了
    Google C++ 风格。'
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE` property or the `CMAKE_<LANG>_INCLUDE_WHAT_YOU_USE`
    variable.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_INCLUDE_WHAT_YOU_USE` 属性或 `CMAKE_<LANG>_INCLUDE_WHAT_YOU_USE` 变量。'
- en: '`LINK_WHAT_YOU_USE` property or the `CMAKE_LINK_WHAT_YOU_USE` variable. Note
    that this is not dependent on the language chosen.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_WHAT_YOU_USE` 属性或 `CMAKE_LINK_WHAT_YOU_USE` 变量。请注意，这与所选择的语言无关。'
- en: For all tools, `<LANG>` is either `C` or `CXX`. The properties contain a semicolon-separated
    list containing the respective executable and command-line arguments. As of CMake
    3.21, automatic execution of the static code analyzers is only supported for the
    Ninja and Makefile generators. Visual Studio handles the static code analyzers
    over settings of the IDE, which CMake cannot control. lwyu is a special case because
    it uses special flags for the `ldd` or `ld` linker and is not a special tool.
    So, the `LINK_WHAT_YOU_USE` property is just a Boolean value and not a command
    line. It also means that lwyu is only supported on ELF platforms.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有工具，`<LANG>` 是 `C` 或 `CXX`。这些属性包含一个以分号分隔的列表，其中包含各自的可执行文件和命令行参数。从 CMake 3.21
    开始，静态代码分析器的自动执行仅支持 Ninja 和 Makefile 生成器。Visual Studio 通过 IDE 设置处理静态代码分析器，而 CMake
    无法控制这些设置。lwyu 是一个特殊的情况，因为它使用特定的标志来处理 `ldd` 或 `ld` 链接器，并且不是一个特殊工具。因此，`LINK_WHAT_YOU_USE`
    属性仅是一个布尔值，而不是一个命令行。这也意味着 lwyu 仅在 ELF 平台上受支持。
- en: 'Like the coverage reports and the sanitizers earlier in this chapter, the static
    code analysis tools are enabled by passing the command in the respective variable
    to CMake over the command line, or by using a preset. If the variable is set,
    then the static code analyzers will be executed automatically when compiling the
    source files. Enabling `clang-tidy` for a build might look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章前面的覆盖率报告和清理器类似，静态代码分析工具通过将命令传递到相应变量中来启用 CMake，可以通过命令行或使用预设来实现。如果设置了该变量，静态代码分析器将在编译源文件时自动执行。启用
    `clang-tidy` 构建可能如下所示：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The command and the arguments are formatted as a semicolon-separated list. In
    the preceding example, all checks for `clang-tidy` are enabled with `-checks=*`,
    and a filter is added to only apply `clang-tidy` to the `include` files of the
    current project with `-header-filter=<sourceDir/*>`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和参数以分号分隔的列表形式格式化。在上述示例中，通过 `-checks=*` 启用所有 `clang-tidy` 检查，并添加了一个过滤器，仅将 `clang-tidy`
    应用于当前项目的 `include` 文件，使用 `-header-filter=<sourceDir/*>`。
- en: 'The same patterns work when using Cppcheck, Cpplint, and iwyu, as the following
    examples show:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cppcheck、Cpplint 和 iwyu 时，相同的模式也适用，以下示例展示了这一点：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The static code analyzers will run when compiling the files in a project. The
    output of any finding will be printed out with any usual compiler warnings or
    errors. By default, all non-critical findings of the analyzers will not cause
    the build to fail. For high-quality software where zero-tolerance against warnings
    exists, the appropriate flags can be passed to Cppcheck and Clang-Tidy:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析器将在编译项目中的文件时运行。任何发现的输出将与通常的编译器警告或错误一起打印出来。默认情况下，分析器的所有非关键问题不会导致构建失败。对于零容忍警告的高质量软件，可以传递适当的标志给
    Cppcheck 和 Clang-Tidy：
- en: For Clang-Tidy, passing `--warnings-as-errors=*` will cause a compilation to
    fail on any issue found
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Clang-Tidy，传递 `--warnings-as-errors=*` 将导致在发现任何问题时编译失败
- en: For Cppcheck, passing the `--error-exitcode=1` parameter will cause Cppcheck
    to exit with `1` instead of `0` if an issue is found, and the build will fail
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Cppcheck，传递 `--error-exitcode=1` 参数将在发现问题时使 Cppcheck 以 `1` 而非 `0` 退出，导致构建失败
- en: '**iwyu** and **cpplint**, unfortunately, lack similar flags.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**iwyu** 和 **cpplint** 不幸的是，缺少类似的标志。'
- en: A very nice feature of Clang-Tidy is that it can automatically apply fixes to
    source files. This can be done by additionally passing the `--fix` and `--fix-error`
    flags to Clang-Tidy.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Clang-Tidy 的一个非常棒的功能是它可以自动对源文件应用修复。这可以通过向 Clang-Tidy 额外传递 `--fix` 和 `--fix-error`
    标志来实现。
- en: Attention when building incrementally
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 构建增量时的注意事项
- en: All the static code analyzers work only if a file is actually compiled. To ensure
    that the static code analyzers catch all errors, they have to be run on a clean
    build.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有静态代码分析器仅在文件实际编译时工作。为了确保静态代码分析器捕捉到所有错误，必须在干净的构建上运行它们。
- en: With the exception of lwyu, all the static code analyzers look at the source
    files to find any issues; conversely, **lwyu** will look at the binary files to
    find unused dependencies.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除 lwyu 外，所有静态代码分析器都会查看源文件以发现任何问题；相反，**lwyu** 会查看二进制文件以查找未使用的依赖项。
- en: 'The lwyu analyzer is intended to help speed up builds and reduce the complexity
    of the dependencies tree. The command for lwyu is defined in `CMAKE_LINK_WHAT_YOU_USE_CHECK`.
    This variable is just a Boolean option, not a command for an external like the
    other tools. If set, it will pass the respective flags to the linker to output
    any unused direct dependencies. As of CMake version 3.21, this is defined as the
    `ldd –u -r` command. The usage of `ldd` means that this analyzer is only available
    for ELF platforms. lwyu can be enabled by passing a simple option, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: lwyu 分析器旨在帮助加速构建并减少依赖树的复杂性。lwyu 的命令在 `CMAKE_LINK_WHAT_YOU_USE_CHECK` 中定义。这个变量只是一个布尔选项，而不是像其他工具那样的外部命令。如果设置，它会将相应的标志传递给链接器，以输出任何未使用的直接依赖项。从
    CMake 版本 3.21 开始，这被定义为 `ldd –u -r` 命令。使用 `ldd` 意味着此分析器仅适用于 ELF 平台。可以通过传递一个简单的选项来启用
    lwyu，像这样：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of lwyu might look something like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: lwyu 的输出可能如下所示：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example shows that `libssl.so` was linked but not used, even the ones indirectly
    linked by any dependencies.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子显示了 `libssl.so` 已经链接但没有被使用，甚至是那些通过任何依赖项间接链接的。
- en: The combination of the various static code analyzers and iwyu and lwyu helps
    to keep codebases small and free from common code smells. So far in this chapter,
    we have looked at how tests are defined, sanitizers, and static code analysis,
    which deal with checking whether code functions correctly. One of the problems
    we’ve seen is that if the combinations must be enabled for all the single targets,
    `CMakeLists.txt` can become cluttered, especially for large projects. A clean
    alternative is to provide a custom build type that enables compile-time code analysis
    globally.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 各种静态代码分析器与 iwyu 和 lwyu 的组合有助于保持代码库简洁并避免常见的代码异味。到目前为止，本章我们已经讨论了如何定义测试、使用清理工具和静态代码分析，它们主要用于检查代码是否正确工作。我们看到的一个问题是，如果必须为所有单独的目标启用这些组合，`CMakeLists.txt`
    可能会变得杂乱无章，尤其是对于大型项目。一个干净的替代方案是提供一个自定义构建类型，全球启用编译时代码分析。
- en: Creating custom build types for quality tools
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为质量工具创建自定义构建类型
- en: So far, we have discussed build types such as `Debug`, `Release`, `RelWithDebInfo`,
    and `MinSizeRel`, which are provided by CMake by default. These build types can
    be extended with custom build types that pass global flags to all targets. For
    the code quality tools that rely on certain compiler flags, providing a custom
    build type can simplify `CMakeLists.txt` considerably, especially for large projects.
    Creating a custom build type is also much preferred to directly interfering with
    the global `CMAKE_<LANG>_FLAGS`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了CMake默认提供的构建类型，例如`Debug`、`Release`、`RelWithDebInfo`和`MinSizeRel`。这些构建类型可以通过自定义构建类型进行扩展，从而将全局标志传递给所有目标。对于依赖特定编译器标志的代码质量工具，提供自定义构建类型可以显著简化`CMakeLists.txt`，特别是对于大型项目。创建自定义构建类型通常比直接修改全局的`CMAKE_<LANG>_FLAGS`更为推荐。
- en: Do not override CMAKE_<LANG>_FLAGS
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 不要覆盖`CMAKE_<LANG>_FLAGS`
- en: Setting the global compiler option is over the generic `CMAKE_<LANG>_FLAGS`
    in your `CMakeLists.txt`. These flags are intended to be set outside a project,
    either by passing them over the command line or by supplying them with a toolchain
    file. Modifying them inside a project creates a high chance of interfering with
    the cases where they are set from the outside.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 设置全局编译器选项时，应使用通用的`CMAKE_<LANG>_FLAGS`，并将其写入`CMakeLists.txt`文件中。这些标志应该在项目外部设置，可以通过命令行传递或通过工具链文件提供。如果在项目内部修改这些标志，容易与外部传递的设置发生冲突。
- en: For multi-configuration generators such as MSVC or Ninja Multi-Config, the available
    build types are stored in the `CMAKE_CONFIGURATION_TYPES` cache variable. For
    single configuration generators such as Make or Ninja, the current build type
    is stored in the `CMAKE_BUILD_TYPE` variable. Custom build types should be defined
    on the top-level project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像MSVC或Ninja Multi-Config这样的多配置生成器，可用的构建类型会存储在`CMAKE_CONFIGURATION_TYPES`缓存变量中。对于像Make或Ninja这样的单配置生成器，当前的构建类型会存储在`CMAKE_BUILD_TYPE`变量中。自定义构建类型应在顶级项目中定义。
- en: 'A custom build type called `Coverage` could be added to `CMakeLists.txt`, like
    this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`CMakeLists.txt`中添加一个名为`Coverage`的自定义构建类型，示例如下：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s break down what happens in the preceding example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下前面示例中的操作：
- en: First, it is determined whether the current `Generator` is a multi or single-configuration
    generator. This is stored in the `GENERATOR_IS_MULTI_CONFIG` global property.
    Since the property cannot be used directly in an `if` statement, the property
    is retrieved and stored in the `IS_MULTI_CONFIG` variable.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，需要确定当前的`Generator`是多配置生成器还是单配置生成器。这一信息会存储在`GENERATOR_IS_MULTI_CONFIG`全局属性中。由于该属性不能直接用于`if`语句，因此需要检索该属性并将其存储在`IS_MULTI_CONFIG`变量中。
- en: If the current generator is indeed a multi-configuration generator, the custom
    build configuration called `Coverage` is added to `CMAKE_CONFIGURATION_TYPES`
    and made available to the generator, but only if it does not yet exist.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前的生成器确实是一个多配置生成器，那么名为`Coverage`的自定义构建配置将被添加到`CMAKE_CONFIGURATION_TYPES`中，并在生成器中可用，但前提是它尚不存在。
- en: If the generator is a single configuration generator, a hint that the `Coverage`
    build exists is added by setting the `STRINGS` property of the `CMAKE_BUILD_TYPE`
    cache variable. This will create a drop-down menu with the valid options in the
    CMake GUI. For convenience, the supported build types are stored in the `KNOWN_BUILD_TYPES`
    variable.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果生成器是单配置生成器，则通过设置`CMAKE_BUILD_TYPE`缓存变量的`STRINGS`属性来添加`Coverage`构建类型的提示。这将在CMake
    GUI中创建一个下拉菜单，显示有效选项。为了方便起见，支持的构建类型存储在`KNOWN_BUILD_TYPES`变量中。
- en: As the current build type is usually supplied from the outside for single configuration
    generators, it is prudent to check for unknown build types and abort the configuration
    if an unknown build type is specified. Printing a message as `FATAL_ERROR` will
    cause CMake to stop the build.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于当前构建类型通常是由外部为单配置生成器提供的，因此最好检查未知的构建类型，并在指定了未知的构建类型时中止配置。将消息打印为`FATAL_ERROR`将导致CMake停止构建。
- en: 'With this, the `Coverage` build type is added to CMake, but the build type
    is not yet configured to add a custom compiler and linker flags to the build.
    To define the flags, two sets of cache variables are used:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，`Coverage`构建类型被添加到CMake中，但此时构建类型尚未配置为向构建中添加自定义编译器和链接器标志。要定义这些标志，使用了两组缓存变量：
- en: '`CMAKE_<LANG>_FLAGS_<CONFIGURATION>`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<LANG>_FLAGS_<CONFIGURATION>`'
- en: '`CMAKE_<TARGET_TYPE>_LINKER_FLAGS_<CONFIGURATION>`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_<TARGET_TYPE>_LINKER_FLAGS_<CONFIGURATION>`'
- en: '`<CONFIGURATION>` is the name of the custom build type, `<LANG>` is the programming
    language, and `<TARGET_TYPE>` for the linker flags are either executable or the
    various types of libraries. It can be useful to base the configuration for a custom
    build on existing build types to reuse any of the configuration options. The following
    example sets up the `Coverage` build type for a Clang- or GCC-compatible compiler,
    based on the flags of the `Debug` build type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`<CONFIGURATION>` 是自定义构建类型的名称，`<LANG>` 是编程语言，`<TARGET_TYPE>` 的链接器标志可以是可执行文件或各种类型的库。基于现有构建类型来创建自定义构建配置非常有用，这样可以重用任何配置选项。以下示例设置了一个基于
    `Debug` 构建类型标志的 `Coverage` 构建类型，适用于 Clang 或 GCC 兼容的编译器：'
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The flags can also contain generator expressions to account for different compilers
    when setting the flags. Marking the flags as `advanced` will help prevent accidental
    change of the variables by the user:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 标志也可以包含生成器表达式，以便在设置标志时考虑不同的编译器。将标志标记为 `advanced` 将有助于防止用户意外更改这些变量：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sometimes, the filename for libraries should reflect that they are created
    with a special build type. Setting `CMAKE_<CONFIGURATION>_POSTFIX` for the custom
    build type will achieve that. This is already common practice for debug builds,
    so the files can be distinguished from the release build when packaged together.
    Related to this is the `DEBUG_CONFIGURATIONS` global property, which contains
    the configurations that are considered non-optimized and are used for debugging.
    If the custom build is considered a non-release build, adding to the property,
    as follows, should be considered:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，库的文件名应当反映它们是通过特殊构建类型创建的。为自定义构建类型设置 `CMAKE_<CONFIGURATION>_POSTFIX` 可以实现这一点。这在调试构建中已经是常见做法，这样文件在打包时可以与发布构建区分开来。与此相关的是
    `DEBUG_CONFIGURATIONS` 全局属性，它包含被认为是非优化的配置，用于调试。如果自定义构建被认为是非发布构建，应该考虑如以下方式将其添加到该属性中：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `DEBUG_CONFIGURATION` property should be set on the top-level project before
    any calls to `target_link_libraries`. The `DEBUG_CONFIGURATIONS` property is currently
    only used by `target_link_libraries`, where, for historical reasons, the libraries
    can be prefixed with `debug` or optimized to indicate that they should only be
    linked for the respective build configuration. Nowadays, this is rarely used,
    as generator expressions allow for more granular control of this.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG_CONFIGURATION` 属性应该在顶层项目中设置，在任何 `target_link_libraries` 调用之前。`DEBUG_CONFIGURATIONS`
    属性目前仅由 `target_link_libraries` 使用，出于历史原因，库可能会以 `debug` 前缀标记或优化，表明它们只应在相应的构建配置下链接。如今，这种做法很少使用，因为生成器表达式提供了更细粒度的控制。'
- en: That concludes this chapter. We have covered the most common aspects of testing
    and quality tools and hope that we have contributde to your journey toward excellent
    software quality.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本章到此结束。我们已经涵盖了测试和质量工具的最常见方面，并希望我们能为你在追求卓越软件质量的道路上做出贡献。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Maintaining high-quality software is a huge and complex task, and today, there
    is such a multitude of tools and techniques to test software that it can be hard
    to up. With the techniques and tools described in this chapter, we hope to have
    given a brief overview of the most common tasks and tools used in modern C++ development.
    CTest and CMake can help orchestrate the various kinds of tests to get the most
    out of the tools. In this chapter, you’ve seen how tests can be defined and run,
    how to execute them in parallel, and how to manage test resources. We’ve explored
    how to define test fixtures and how to define advanced ways to determine whether
    a test succeeded or failed, based on its output.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 维护高质量的软件是一个庞大而复杂的任务，今天，有如此多的工具和技术可供测试软件，以至于可能难以掌握。通过本章描述的技术和工具，我们希望简要概述了现代 C++
    开发中最常见的任务和工具。CTest 和 CMake 可以帮助协调各种测试类型，从而最大化工具的效能。在本章中，你已经看到如何定义和运行测试，如何并行执行测试，以及如何管理测试资源。我们还探讨了如何定义测试夹具，以及如何定义更高级的方法来根据测试输出确定测试是否成功或失败。
- en: We illustrated how to set up code coverage reports using Gcov and how to define
    custom build types to pass the necessary compiler flags. We looked at how various
    tools for static code analysis can be included in CMake projects and how the sanitizers
    of various compilers can be used.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何使用 Gcov 设置代码覆盖率报告，以及如何定义自定义构建类型来传递必要的编译器标志。我们还介绍了如何将各种静态代码分析工具包含到 CMake
    项目中，以及如何使用各种编译器的 sanitizer。
- en: In the next chapter, we will see how to use external programs from within CMake
    and how to perform platform-independent tasks.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在CMake中使用外部程序，以及如何执行平台无关的任务。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are tests defined in CMake?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CMake中，测试是如何定义的？
- en: How can CTest be told to execute a specific test?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何告诉CTest执行特定的测试？
- en: How can an unstable test be repeated until it either succeeds or fails?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将一个不稳定的测试重复执行，直到它成功或失败？
- en: How are tests run in parallel and random order?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何以并行和随机顺序运行测试？
- en: How can you prevent multiple tests from using a unique test resource at the
    same time?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何防止多个测试同时使用唯一的测试资源？
- en: How are static code analyzers enabled for targets?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为目标启用静态代码分析工具？
- en: How are custom build types defined?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何定义自定义构建类型？
- en: Answers
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Tests are defined by using the `add_test` function.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试是通过使用`add_test`函数定义的。
- en: Either by using a regex on the test’s name with `ctest -R` or by using the test
    number, using `ctest -I`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`ctest -R`对测试名称应用正则表达式，或者通过使用测试编号，使用`ctest -I`。
- en: By calling `ctest --repeat:until-pass:n` or `ctest --repeat:until-fail:n`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ctest --repeat:until-pass:n`或`ctest --repeat:until-fail:n`。
- en: By running `ctest -j <``num_of_jobs> --schedule-random`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`ctest -j <num_of_jobs> --schedule-random`。
- en: By setting the `RESOURCE_LOCK` or `RESOURCE_GROUP` property for the respective
    tests.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过为相应的测试设置`RESOURCE_LOCK`或`RESOURCE_GROUP`属性。
- en: Static code analyzers are enabled by passing the command line, including any
    arguments, to the respective target properties.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 静态代码分析工具是通过将命令行（包括任何参数）传递给相应的目标属性来启用的。
- en: By either adding them to the `CMAKE_CONFIGURATION_TYPES` property for multi-configuration-type
    generators or by adding them to the `CMAKE_BUILD_TYPE` property.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其添加到多配置类型生成器的`CMAKE_CONFIGURATION_TYPES`属性中，或通过将其添加到`CMAKE_BUILD_TYPE`属性中。
