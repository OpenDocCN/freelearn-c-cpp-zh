- en: 17\. Remote Procedure Calls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.远程过程调用
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to Remote Procedure Calls, which is
    another important multiplayer concept of Unreal Engine 4's Network Framework.
    You'll also learn how to use enumerations in Unreal Engine 4 and how to use bi-directional
    circular array indexing, which is a way to help you iterate arrays in both directions
    and be able to loop around when you go beyond its index limits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解远程过程调用，这是虚幻引擎4网络框架的另一个重要多人游戏概念。您还将学习如何在虚幻引擎4中使用枚举，以及如何使用双向循环数组索引，这是一种帮助您在两个方向上迭代数组并在超出其索引限制时循环的方法。
- en: By the end of this chapter, you'll understand how Remote Procedure Calls work
    to make the server and the clients execute logic on one another. You'll also be
    able to expose enumerations to the Unreal Engine 4 editor and use bi-directional
    circular array indexing to cycle through arrays.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解远程过程调用是如何使服务器和客户端在彼此上执行逻辑的。您还将能够在虚幻引擎4编辑器中公开枚举，并使用双向循环数组索引来循环遍历数组。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered some critical multiplayer concepts, including
    the server-client architecture, connections and ownership, roles, and variable
    replication. We also saw how the listen server is quicker to set up compared to
    the dedicated server but is not as lightweight. We used that knowledge to create
    a basic first-person shooter character that walks, jumps, and looks around.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了一些关键的多人游戏概念，包括服务器-客户端架构，连接和所有权，角色和变量复制。我们还看到监听服务器比专用服务器更快设置，但不够轻量级。我们利用这些知识创建了一个基本的第一人称射击角色，可以行走，跳跃和四处张望。
- en: In this chapter, we're going to cover **Remote Procedure Calls** (**RPC**s),
    which is another important multiplayer concept that allows the server to execute
    functions on the clients and vice versa. So far, we've learned variable replication
    as a form of communication between the server and the clients, but that won't
    be enough, because the server might need to execute specific logic on the clients
    that doesn't involve updating the value of a variable. The client also needs a
    way to tell its intentions to the server, so that the server can validate the
    action and let the other clients know about it. This will ensure that the multiplayer
    world is synchronized, and we'll explore this in more detail within this chapter.
    We'll also cover how to use enumerations in Unreal Engine 4, as well as bi-directional
    circular array indexing, which helps you iterate an array in both directions and
    loops around when you go beyond its index limits.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**远程过程调用**（**RPC**），这是另一个重要的多人游戏概念，允许服务器在客户端上执行函数，反之亦然。到目前为止，我们已经学习了变量复制作为服务器和客户端之间通信的一种形式，但这还不够，因为服务器可能需要在客户端上执行特定的逻辑，而不涉及更新变量的值。客户端还需要一种方式告诉服务器其意图，以便服务器可以验证操作并让其他客户端知道。这将确保多人游戏世界同步，我们将在本章中更详细地探讨这一点。我们还将介绍如何在虚幻引擎4中使用枚举，以及双向循环数组索引的使用，这有助于您在两个方向上迭代数组，并在超出其索引限制时循环。
- en: In the first topic, we will be looking at RPCs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个主题中，我们将研究RPC。
- en: Remote Procedure Calls
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程过程调用
- en: 'We''ve covered variable replication in *Chapter 16*, *Multiplayer Basics*,
    and, while a very useful feature, it is a bit limited in terms of allowing the
    execution of custom code in remote machines (client-to-server or server-to-client)
    for two main reasons:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第16章*，*多人游戏基础*中涵盖了变量复制，虽然这是一个非常有用的功能，但在允许在远程机器上执行自定义代码（客户端到服务器或服务器到客户端）方面有一些限制，主要有两个原因：
- en: The first one is that variable replication is strictly a form of server-to-client
    communication, so there isn't a way for a client to use variable replication to
    tell the server to execute some custom logic by changing the value of a variable.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是变量复制严格来说是一种服务器到客户端的通信形式，因此客户端无法使用变量复制来告诉服务器通过改变变量的值来执行一些自定义逻辑。
- en: The second reason is that variable replication, as the name suggests, is driven
    by the values of variables, so even if variable replication allowed the client-to-server
    communication, it would require you to change the value of a variable on the client
    to trigger a `RepNotify` functionality on the server to run the custom logic,
    which is not very practical.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是变量复制，顾名思义，是由变量的值驱动的，因此即使变量复制允许客户端到服务器的通信，也需要您在客户端更改变量的值来触发服务器上的`RepNotify`功能来运行自定义逻辑，这并不是很实际。
- en: To solve this problem, Unreal Engine 4 supports RPCs. An RPC works just like
    a normal function that can be defined and called, but instead of executing it
    locally, it will execute it on a remote machine. The main goal of using RPCs is
    to have the possibility to execute specific logic, which is not directly tied
    to a variable, on a remote machine. To be able to use RPCs, make sure you are
    defining them in an actor that has replication turned on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，虚幻引擎4支持RPC。RPC的工作原理就像一个普通的函数，可以定义和调用，但是它不会在本地执行，而是在远程机器上执行。使用RPC的主要目标是有可能在远程机器上执行特定的逻辑，这与变量没有直接关联。要能够使用RPC，请确保在打开复制的角色中定义它们。
- en: 'There are three types of RPCs, and each one serves a different purpose:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的RPC，每种都有不同的目的：
- en: Server RPC
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器RPC
- en: Multicast RPC
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多播RPC
- en: Client RPC
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端RPC
- en: 'Let''s go into detail about these three types and explain when you should use
    them:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解这三种类型，并解释何时应该使用它们：
- en: Server RPC
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器RPC
- en: 'You use a Server RPC every time you want the server to run a function on the
    actor that has defined the RPC. There are two main reasons why you would want
    to do this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您希望服务器在定义了RPC的角色上运行函数时，您就会使用服务器RPC。您希望这样做的两个主要原因是：
- en: The first one is for security reasons because when making multiplayer games,
    especially competitive ones, you always have to assume that the client will try
    to cheat. The way to make sure there is no cheating is by forcing the client to
    execute the functions that are critical to gameplay on the server.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个原因是出于安全考虑，因为在制作多人游戏时，特别是竞争性游戏，您总是要假设客户端会尝试作弊。确保没有作弊的方法是强制客户端在服务器上执行对游戏玩法至关重要的函数。
- en: The second reason is for synchronicity because since the critical gameplay logic
    is only executed on the server, which means that the important variables are only
    going to be changed there, which will trigger the variable replication logic to
    update the clients whenever they are changed.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个原因是为了同步性，因为关键的游戏逻辑只在服务器上执行，这意味着重要的变量只会在那里被改变，这将触发变量复制逻辑，在变量被改变时更新客户端。
- en: An example of this would be when a client's character tries to fire a weapon.
    Since there's always the possibility that the client might try to cheat, you can't
    just execute the fire weapon logic locally. The correct way of doing this is by
    having the client call a Server RPC that tells the server to validate the `Fire`
    action by making sure the character has enough ammo and has the weapon equipped,
    and so on. If everything checks out, then it will deduct the ammo variable, and
    finally, it will execute a Multicast RPC (*covered in the next RPC type*) that
    will tell all of the clients to play the fire animation on that character.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是当客户端的角色尝试开火时。由于客户端可能会尝试作弊，您不能只在本地执行开火逻辑。正确的做法是让客户端调用一个告诉服务器验证“Fire”动作的服务器RPC，确保角色有足够的弹药并且装备了武器等等。如果一切都符合要求，那么它将扣除弹药变量，并最终执行一个多播RPC（*在下一个RPC类型中介绍*），告诉所有客户端在该角色上播放开火动画。
- en: Declaration
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'To declare a Server RPC, you use the `Server` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明服务器RPC，您需要在“UFUNCTION”宏上使用“Server”修饰符。请看以下例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the `Server` specifier is used on the `UFUNCTION` macro
    to state that the function is a Server RPC. You can have parameters on a Server
    RPC just like a normal function, but with some caveats that will be explained
    later in this topic, as well as the purpose of the `Reliable` and `WithValidation`
    specifiers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，“Server”修饰符在“UFUNCTION”宏上被用来声明该函数是一个服务器RPC。您可以像普通函数一样在服务器RPC上有参数，但是有一些注意事项将在本主题后面解释，以及“Reliable”和“WithValidation”修饰符的目的。
- en: Execution
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Server RPC, you call it from a client on the actor instance that
    defined it. Take a look at the following examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器RPC，您需要在定义它的角色实例上从客户端调用它。请看以下例子：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first code snippet implements the `CallMyOwnServerRPC` function, which calls
    the `ServerMyOwnRPC` RPC function, defined in its own `ARPCTest` class, with an
    integer parameter. This will execute the implementation of the `ServerMyOwnRPC`
    function on the server version of that actor's instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码片段实现了“CallMyOwnServerRPC”函数，该函数调用了其自己“ARPCTest”类中定义的“ServerMyOwnRPC” RPC函数，带有一个整数参数。这将在该角色实例的服务器版本上执行“ServerMyOwnRPC”函数的实现。
- en: The second code snippet implements the `CallServerRPCOfAnotherActor` function,
    which calls the `ServerAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `ServerAnotherActorRPC` function on the server version of the `OtherActor`
    instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段实现了“CallServerRPCOfAnotherActor”函数，该函数调用了“ServerAnotherActorRPC” RPC函数，在“AAnotherActor”中定义，在“OtherActor”实例上只要它是有效的。这将在“OtherActor”实例的服务器版本上执行“ServerAnotherActorRPC”函数的实现。
- en: Valid Connection
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效连接
- en: One important thing to take into consideration when calling a Server RPC from
    a client is that the actor that defines it needs to have a valid connection. If
    you try to call a Server RPC on an actor that doesn't have a valid connection,
    then nothing will happen. You have to make sure that the actor is either a player
    controller, is being possessed by one (*if applicable*), or that its owning actor
    has a valid connection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端调用服务器RPC时需要考虑的一个重要事项是定义它的角色需要有一个有效的连接。如果尝试在没有有效连接的角色上调用服务器RPC，则什么也不会发生。您必须确保该角色要么是玩家控制器，要么被一个（*如果适用*）控制，或者其拥有的角色有一个有效的连接。
- en: Multicast RPC
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播RPC
- en: You use a Multicast RPC when you want the server to tell all clients to run
    a function on the actor that has defined the RPC.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望服务器告诉所有客户端在定义了RPC的角色上运行函数时，您可以使用多播RPC。
- en: An example of this would be when a client's character tries to fire a weapon.
    After the client calls the Server RPC to ask permission to fire the weapon and
    the server has handled the request (all validations checked out, the ammo has
    been deducted, and the line trace/projectile was processed), then we need to do
    a Multicast RPC so that all of the instances of that specific character play the
    fire animation. This will ensure that the character will always be playing the
    fire animation independent of which client is looking at the character.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是当客户端的角色尝试开火时。在客户端调用服务器RPC请求允许开火，并且服务器处理了请求（所有验证都通过，弹药已经扣除，线性跟踪/抛射物已经处理），然后我们需要进行多播RPC，以便该特定角色的所有实例都播放开火动画。这将确保无论哪个客户端正在观察角色，角色都会一直播放开火动画。
- en: Declaration
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'To declare a Multicast RPC, you need to use the `NetMulticast` specifier on
    the `UFUNCTION` macro. Have a look at the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明多播RPC，您需要在“UFUNCTION”宏上使用“NetMulticast”修饰符。请看以下例子：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `NetMulticast` specifier is used on the `UFUNCTION`
    macro to say that the following function is a Multicast RPC. You can have parameters
    on a Multicast RPC just like a normal function, but with the same caveats as the
    Server RPC.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`NetMulticast`修饰符用于`UFUNCTION`宏，表示接下来的函数是一个多播RPC。你可以像普通函数一样在多播RPC中使用参数，但与服务器RPC一样有相同的注意事项。
- en: Execution
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Multicast RPC, you call it from the server on the actor instance
    that defined it. Take a look at the following examples:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行多播RPC，你需要在定义它的角色实例上从服务器调用它。看一下下面的例子：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first code snippet implements the `CallMyOwnMulticastRPC` function, which
    calls the `MulticastMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `MulticastMyOwnRPC`
    function on all of the clients' versions of that actor's instance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码片段实现了`CallMyOwnMulticastRPC`函数，它调用了其自己`ARPCTest`类中定义的`MulticastMyOwnRPC`
    RPC函数，带有一个整数参数。这将在该角色实例的所有客户端版本上执行`MulticastMyOwnRPC`函数的实现。
- en: The second code snippet implements the `CallMulticastRPCOfAnotherActor` function,
    which calls the `MulticastAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `MulticastAnotherActorRPC` function on all of the clients' versions of
    the `OtherActor` instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段实现了`CallMulticastRPCOfAnotherActor`函数，它调用了`AAnotherActor`中定义的`MulticastAnotherActorRPC`
    RPC函数，只要`OtherActor`实例有效。这将在`OtherActor`实例的所有客户端版本上执行`MulticastAnotherActorRPC`函数的实现。
- en: Client RPC
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端RPC
- en: You use a Client RPC when you want to run a function only on the owning client
    of the actor that has defined the RPC. To set the owning client, you need to call
    Set Owner on the server and set it with the client's player controller.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在定义RPC的角色的拥有客户端上运行函数时，你可以使用客户端RPC。要设置拥有客户端，你需要在服务器上调用SetOwner，并使用客户端的玩家控制器进行设置。
- en: An example of this would be when a character is hit by a projectile and plays
    a pain sound that only that client will hear. By calling a Client RPC from the
    server, the sound will only be played on the owning client, so the other clients
    won't hear it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当角色被抛射物击中并播放只有该客户端会听到的疼痛声音时。通过从服务器调用客户端RPC，声音只会在拥有客户端上播放，因此其他客户端不会听到。
- en: Declaration
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明
- en: 'To declare a Client RPC, you need to use the `Client` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明客户端RPC，你需要在`UFUNCTION`宏上使用`Client`修饰符。看一下下面的例子：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the `Client` specifier is used on the `UFUNCTION` macro
    to say that the following function is a Client RPC. You can have parameters on
    a Client RPCs just like a normal function, but with the same caveats as the Server
    RPC and Multicast RPC.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Client`修饰符用于`UFUNCTION`宏，表示接下来的函数是一个客户端RPC。你可以像普通函数一样在客户端RPC中使用参数，但与服务器RPC和多播RPC一样有相同的注意事项。
- en: Execution
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行
- en: 'To execute a Client RPC, you call it from the server on the actor instance
    that defined it. Take a look at the following examples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端RPC，你需要在定义它的角色实例上从服务器调用它。看一下下面的例子：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first code snippet implements the `CallMyOwnClientRPC` function, which calls
    the `ClientMyOwnRPC` RPC function, defined in its own `ARPCTest` class, with an
    integer parameter. This will execute the implementation of the `ClientMyOwnRPC`
    function on the owning client's version of that actor's instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码片段实现了`CallMyOwnClientRPC`函数，它调用了其自己`ARPCTest`类中定义的`ClientMyOwnRPC` RPC函数，带有一个整数参数。这将在该角色实例的拥有客户端版本上执行`ClientMyOwnRPC`函数的实现。
- en: The second code snippet implements the `CallClientRPCOfAnotherActor` function,
    which calls the `ClientAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `ClientAnotherActorRPC` function on the owning client's version of the
    `OtherActor` instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个代码片段实现了`CallClientRPCOfAnotherActor`函数，它调用了`AAnotherActor`中定义的`ClientAnotherActorRPC`
    RPC函数，只要`OtherActor`实例有效。这将在`OtherActor`实例的拥有客户端版本上执行`ClientAnotherActorRPC`函数的实现。
- en: Important Considerations When Using RPCs
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在使用RPC时需要考虑的重要事项
- en: 'RPCs are very useful, but there are a couple of things that you need to take
    into consideration when using them, such as:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: RPC非常有用，但在使用它们时有一些需要考虑的事项，比如：
- en: '**Implementation**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**'
- en: 'The implementation of an RPC differs slightly to that of a typical function.
    Instead of implementing the function as you normally do, you should only implement
    the `_Implementation` version of it, even though you didn''t declare it in the
    header file. Have a look at the following examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RPC的实现与典型函数略有不同。你不应该像通常那样实现函数，而是只实现它的`_Implementation`版本，即使你没有在头文件中声明它。看一下下面的例子：
- en: '**Server RPC:**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器RPC：**'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `ServerRPCTest` function, which uses three parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`ServerRPCTest`函数的`_Implementation`版本，它使用了三个参数。
- en: '**Multicast RPC:**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**多播RPC：**'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `MulticastRPCTest` function, which uses three parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`MulticastRPCTest`函数的`_Implementation`版本，它使用了三个参数。
- en: '**Client RPC:**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端RPC：**'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `ClientRPCTest` function, which uses three parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实现了`ClientRPCTest`函数的`_Implementation`版本，它使用了三个参数。
- en: 'As you can see from the previous examples, independent of the type of the RPC
    you are implementing, you should only implement the `_Implementation` version
    of the function and not the normal one, as demonstrated in the following code
    snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，无论你正在实现的RPC的类型是什么，你都应该只实现函数的`_Implementation`版本，而不是普通版本，就像下面的代码片段中所演示的那样：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we're defining the normal implementation of `ServerRPCFunction`.
    If you implement the RPC like this, you'll get an error saying that it was already
    implemented. The reason for this is that when you declare the RPC function in
    the header file, Unreal Engine 4 will automatically create the normal implementation
    internally, which will later call the `_Implementation` version. If you create
    your version of the normal implementation, the build will fail because it will
    find two implementations of the same function. To fix this, just make sure to
    only implement the `_Implementation` version of the RPC.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们正在定义`ServerRPCFunction`的正常实现。如果您像这样实现RPC，将会收到一个错误，说它已经被实现了。原因是当您在头文件中声明RPC函数时，虚幻引擎4将自动在内部创建正常的实现，然后调用`_Implementation`版本。如果您创建自己版本的正常实现，构建将失败，因为它会找到相同函数的两个实现。要解决此问题，只需确保只实现RPC的`_Implementation`版本。
- en: Next, we move to name prefixes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转到名称前缀。
- en: '**Name Prefix**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称前缀**'
- en: 'In Unreal Engine 4, it''s good practice to prefix RPCs with their corresponding
    types. Have a look at the following examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，最好使用相应类型的前缀来命名RPC。看看以下示例：
- en: A `ServerRPCFunction`.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ServerRPCFunction`。
- en: A `MulticastRPCFunction`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`MulticastRPCFunction`。
- en: A `ClientRPCFunction`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ClientRPCFunction`。
- en: '**Return Value**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值**'
- en: Since the call and execution of RPCs are typically done on different machines,
    you can't have a return value, so it always needs to be void.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RPC的调用和执行通常在不同的机器上进行，因此您不能有返回值，因此它总是需要是void。
- en: '**Overriding**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**重写**'
- en: 'You can override the implementation of an RPC to expand or bypass the parent''s
    functionality by declaring and implementing the `_Implementation` function in
    the child class without the `UFUNCTION` macro. Here is an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重写RPC的实现，通过在子类中声明和实现`_Implementation`函数而不使用`UFUNCTION`宏来扩展或绕过父功能。以下是一个示例：
- en: 'The declaration on the parent class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 父类上的声明：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we have the declaration of the parent class of
    the `ServerRPCTest` function, which uses one integer parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们有`ServerRPCTest`函数的父类声明，它使用一个整数参数。
- en: 'The overridden declaration on the child class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 子类上的重写声明：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, we override the declaration of the `ServerRPCTest_Implementation`
    function in the child class header file. The implementation of the function is
    just like any other override, with the possibility of calling `Super::ServerRPCTest_Implementation`
    if you still want to execute the parent functionality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在子类头文件中重写了`ServerRPCTest_Implementation`函数的声明。函数的实现就像任何其他重写一样，如果您仍然想执行父功能，可以调用`Super::ServerRPCTest_Implementation`。
- en: '**Supported Parameter Types**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的参数类型**'
- en: When using RPCs, you can add parameters just like any other function. Currently,
    most common types are supported, including `bool`, `int32`, `float`, `FString`,
    `FName`, `TArray`, `TSet`, and `TMap`. The types that you have to pay more attention
    to are pointers to any `UObject` class or sub-class, especially actors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RPC时，您可以像任何其他函数一样添加参数。目前，支持最常见的类型，包括`bool`、`int32`、`float`、`FString`、`FName`、`TArray`、`TSet`和`TMap`。您需要更加注意的类型是指向任何`UObject`类或子类的指针，特别是actors。
- en: 'If you create an RPC with an actor parameter, then that actor also needs to
    exist on the remote machine, or else it will be `nullptr`. Another important thing
    to take into account is that the instance names of each version of the actor can
    be different. That means that if you call an RPC with an actor parameter, then
    the instance name of the actor when calling the RPC might be different than the
    one when executing the RPC on the remote machine. Here is an example to help you
    understand this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用actor参数创建RPC，则该actor也需要存在于远程机器上，否则它将为`nullptr`。另一件重要的事情是要注意每个版本的actor的实例名称可能是不同的。这意味着如果您使用actor参数调用RPC，那么在调用RPC时actor的实例名称可能与在远程机器上执行RPC时的实例名称不同。以下是一个示例，以帮助您理解这一点：
- en: '![Figure 17.1: The listen server and two clients running'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.1：监听服务器和两个运行的客户端'
- en: '](img/B16183_17_01.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_01.jpg)'
- en: 'Figure 17.1: The listen server and two clients running'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：监听服务器和两个运行的客户端
- en: In the preceding example, you can see three clients running (one of them is
    a listen server) and each window is displaying the name of all of the character
    instances. If you look at the Client 1 window, its controlled character instance
    is called `ThirdPersonCharacter_C_0`, but on the Server window, that equivalent
    character is called `ThirdPersonCharacter_C_1`. That means that if Client 1 calls
    a Server RPC and passes its `ThirdPersonCharacter_C_0` as an argument, then when
    the RPC is executed on the server, the parameter will be `ThirdPersonCharacter_C_1`,
    which is the instance name of the equivalent character in that machine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您可以看到三个运行的客户端（其中一个是监听服务器），每个窗口都显示所有角色实例的名称。如果您查看客户端1窗口，其控制的角色实例称为`ThirdPersonCharacter_C_0`，但在服务器窗口上，相应的角色称为`ThirdPersonCharacter_C_1`。这意味着如果客户端1调用服务器RPC并将其`ThirdPersonCharacter_C_0`作为参数传递，那么在服务器上执行RPC时，参数将是`ThirdPersonCharacter_C_1`，这是该机器上等效角色的实例名称。
- en: '**Executing RPCs on the Target Machine**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**在目标机器上执行RPC**'
- en: You can call RPCs directly on its target machine and it will still execute.
    In other words, you can call a Server RPC on the server and it will execute, as
    well as a Multicast/Client RPC on the client, but in this case, it will only execute
    the logic on the client that called the RPC. Either way, in these cases, you should
    always call the `_Implementation` version directly instead so as to execute the
    logic faster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接在目标机器上调用RPC，并且它仍然会执行。换句话说，您可以在服务器上调用服务器RPC并执行，以及在客户端上调用Multicast/Client
    RPC，但在这种情况下，它只会在调用RPC的客户端上执行逻辑。无论如何，在这些情况下，您应该始终直接调用`_Implementation`版本，以便更快地执行逻辑。
- en: The reason for this is that the `_Implementation` version just holds the logic
    to execute and doesn't have the overhead of creating and sending the RPC request
    through the network that the regular call has.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`_Implementation`版本只包含执行逻辑，没有创建和通过网络发送RPC请求的开销，而常规调用有。
- en: 'Have a look at the following example of an actor that has authority on the
    server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下具有服务器权限的演员的以下示例：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, you have the `CallServerRPC` function that calls `ServerRPCFunction`
    in two different ways. If the actor is already on the server, then it calls `ServerRPCFunction_Implementation`,
    which will skip the overhead as mentioned previously.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，您有`CallServerRPC`函数以两种不同的方式调用`ServerRPCFunction`。如果演员已经在服务器上，则调用`ServerRPCFunction_Implementation`，这将跳过前面提到的开销。
- en: If the actor is not on the server, then it executes the regular call by using
    `ServerRPCFunction`, which adds the required overhead of creating and sending the
    RPC request through the network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果演员不在服务器上，则通过使用`ServerRPCFunction`执行常规调用，这将增加创建和通过网络发送RPC请求所需的开销。
- en: '**Validation**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 验证
- en: When you define an RPC, you have the option of using an additional function
    to check whether there are any invalid inputs before the RPC is called. This is
    used to avoid processing the RPC if the inputs are invalid, due to cheating or
    for some other reason.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义RPC时，您可以选择使用附加函数来检查RPC调用之前是否存在任何无效输入。这用于避免处理RPC，如果输入无效，由于作弊或其他原因。
- en: To use validation, you need to add the `WithValidation` specifier in the `UFUNCTION`
    macro. When you use that specifier, you will be forced to implement the `_Validate`
    version of the function, which will return a Boolean stating whether the RPC can
    be executed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用验证，您需要在`UFUNCTION`宏中添加`WithValidation`修饰符。当您使用该修饰符时，您将被强制实现函数的`_Validate`版本，该版本将返回一个布尔值，指示RPC是否可以执行。
- en: 'Have a look at the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we''ve declared a validated Server RPC called `ServerSetHealth`,
    which takes a float parameter for the new value of `Health`. As for the implementation,
    this is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们声明了一个经过验证的服务器RPC称为`ServerSetHealth`，它接受一个浮点参数作为`Health`的新值。至于实现，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, we implement the `_Validate` function, which will check
    whether the new health is less than or equal to the maximum value of the health.
    If a client tries to hack and call `ServerSetHealth` with `200` and `MaxHealth`
    is `100`, then the RPC won't be called, which prevents the client from changing
    the health with values outside a certain range. If the `_Validate` function returns
    `true`, the `_Implementation` function is called as usual, which sets `Health`
    with the value of `NewHealth`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们实现了`_Validate`函数，该函数将检查新的健康值是否小于或等于健康的最大值。如果客户端尝试通过`200`和`MaxHealth`为`100`调用`ServerSetHealth`，则不会调用RPC，这可以防止客户端使用超出一定范围的值更改健康。如果`_Validate`函数返回`true`，则会像往常一样调用`_Implementation`函数，该函数将使用`NewHealth`的值设置`Health`。
- en: '**Reliability**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠性**'
- en: 'When you declare an RPC, you are required to either use the `Reliable` or `Unreliable`
    specifiers in the `UFUNCTION` macro. Here''s a quick overview of what they do:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您声明RPC时，您需要在`UFUNCTION`宏中使用`Reliable`或`Unreliable`修饰符之一。以下是它们的快速概述：
- en: '`Reliable`: Used when you want to make sure the RPC is executed, by repeating
    the request until the remote machine confirms its reception. This should only
    be used for RPCs that are very important, such as executing critical gameplay
    logic. Here is an example of how to use it:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可靠`：用于确保执行RPC，通过重复请求直到远程机器确认其接收。这应仅用于非常重要的RPC，例如执行关键的游戏逻辑。以下是如何使用它的示例：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Unreliable`: Used when you don''t care whether the RPC is executed due to
    bad network conditions, such as playing a sound or spawning a particle effect.
    This should only be used for RPCs that aren''t very important or are called very
    frequently to update values, since it wouldn''t matter if one call missed because
    it''s updating very often. Here is an example of how to use it:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`不可靠`：用于不关心RPC是否由于糟糕的网络条件而执行，例如播放声音或生成粒子效果。这应仅用于不太重要或非常频繁调用以更新值的RPC，因为如果一个调用错过了，因为它经常更新，所以不重要。以下是如何使用它的示例：'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on RPCs, please visit [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RPC的更多信息，请访问[https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html)。
- en: In the next exercise, you will see how to implement different types of RPCs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将看到如何实现不同类型的RPC。
- en: 'Exercise 17.01: Using Remote Procedure Calls'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习17.01：使用远程过程调用
- en: 'In this exercise, we''re going to create a C++ project that uses the `Third
    Person` template and we''re going to expand it in the following way:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用“Third Person”模板的C++项目，并按以下方式扩展它：
- en: Add a fire timer variable that will prevent the client from spamming the fire
    button during the fire animation.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个火灾计时器变量，它将防止客户端在火灾动画期间不断按下火灾按钮。
- en: Add a new Ammo integer variable that defaults to `5` and replicates to all of
    the clients.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个新的弹药整数变量，默认值为`5`，并复制给所有客户端。
- en: Add a `Fire Anim montage` that is played when the server tells the client that
    the shot was valid.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个“火灾动画剪辑”，当服务器告诉客户端射击有效时播放。
- en: Add a `No Ammo Sound` that will play when the server tells the client that they
    didn't have sufficient ammo.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个“无弹药声音”，当服务器告诉客户端他们没有足够的弹药时会播放。
- en: Every time the player presses the *Left Mouse Button*, the client will perform
    a reliable and validated Server RPC that will check whether the character has
    sufficient ammo. If it does, it will subtract 1 from the Ammo variable and call
    an unreliable Multicast RPC that plays the fire animation in every client. If
    it doesn't have ammo, then it will execute an unreliable Client RPC that will
    play the `No Ammo Sound` that will only be heard by the owning client.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当玩家按下*左鼠标按钮*时，客户端将执行可靠且经过验证的服务器RPC，检查角色是否有足够的弹药。如果有，它将从Ammo变量中减去1，并调用一个不可靠的多播RPC，在每个客户端播放开火动画。如果没有弹药，那么它将执行一个不可靠的客户端RPC，只有拥有客户端才能听到`No
    Ammo Sound`。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `RPC` and save
    it to a location of your choosing.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`C++`创建一个名为`RPC`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，应该打开编辑器以及Visual Studio解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，返回Visual Studio。
- en: 'Open the `RPCCharacter.h` file and include the `UnrealNetwork.h` header file,
    which has the definition of the `DOREPLIFETIME_CONDITION` macro that we''re going
    to use:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`RPCCharacter.h`文件，并包括`UnrealNetwork.h`头文件，其中包含我们将要使用的`DOREPLIFETIME_CONDITION`宏的定义：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare the protected timer variable to prevent the client from spamming the
    `Fire` action:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的计时器变量，以防止客户端滥用`Fire`动作：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare the protected replicated ammo variable, which starts with `5` shots:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的可复制的弹药变量，初始为`5`发子弹：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, declare the protected animation montage variable that will be played
    when the character fires:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个受保护的动画蒙太奇变量，当角色开火时将会播放：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Declare the protected sound variable that will be played when the character
    has no ammo:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个受保护的声音变量，当角色没有弹药时将会播放：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Override the `Tick` function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Tick`函数：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Declare the input function that will process the pressing of the *Left Mouse
    Button*:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个输入函数，用于处理*左鼠标按钮*的按压：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Declare the reliable and validated Server RPC for firing:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明可靠且经过验证的服务器RPC以进行射击：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the unreliable Multicast RPC that will play the fire animation on all
    of the clients:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个不可靠的多播RPC，将在所有客户端上播放开火动画：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare the unreliable Client RPC that will play a sound only in the owning
    client:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个不可靠的客户端RPC，仅在拥有客户端中播放声音：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, open the `RPCCharacter.cpp` file and include `DrawDebugHelpers.h`, `GameplayStatics.h`,
    `TimerManager.h` and `World.h`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`RPCCharacter.cpp`文件，并包括`DrawDebugHelpers.h`，`GameplayStatics.h`，`TimerManager.h`和`World.h`：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At the end of the constructor, enable the `Tick` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的末尾，启用`Tick`函数：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the `GetLifetimeReplicatedProps` function so that the `Ammo` variable
    will replicate to all of the clients:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetLifetimeReplicatedProps`函数，以便`Ammo`变量能够复制到所有客户端：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, implement the `Tick` function, which displays the value of the `Ammo` variable:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`Tick`函数，显示`Ammo`变量的值：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the end of the `SetupPlayerInputController` function, bind the `Fire` action
    to the `OnPressedFire` function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputController`函数的末尾，将`Fire`动作绑定到`OnPressedFire`函数：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the function that will process the press of the *Left Mouse Button*,
    which will call the fire Server RPC:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现处理*左鼠标按钮*按压的函数，该函数将调用fire Server RPC：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Implement the fire Server RPC validation function:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现fire服务器RPC验证函数：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Implement the fire Server RPC implementation function:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现fire服务器RPC实现函数：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, add the logic to abort the function if the fire timer is still active
    since we fired the last shot:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加逻辑以在上一次射击后仍处于活动状态时中止函数：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Check whether the character has ammo. If it doesn''t, then play `NoAmmoSound`
    only in the client that controls the character and abort the function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查角色是否有弹药。如果没有，那么只在控制角色的客户端中播放`NoAmmoSound`并中止函数：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Deduct the ammo and schedule the `FireTimer` variable to prevent this function
    from being spammed while playing the fire animation:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扣除弹药并安排`FireTimer`变量，以防止在播放开火动画时过度使用此函数：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the fire Multicast RPC to make all the clients play the fire animation:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用fire多播RPC，使所有客户端播放开火动画：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Implement the fire Multicast RPC, which will play the fire animation montage:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现fire多播RPC，将播放开火动画蒙太奇：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the Client RPC that plays a 2D sound:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现在客户端播放2D声音的客户端RPC：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, you can launch the project in the editor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在编辑器中启动项目。
- en: Compile the code and wait for the editor to fully load.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并等待编辑器完全加载。
- en: 'Go to `Project Settings`, go to `Engine`, then `Input`, and add the `Fire`
    action binding:![Figure 17.2: Adding the new Fire action binding'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Project Settings`，转到`Engine`，然后`Input`，并添加`Fire`动作绑定：![图17.2：添加新的Fire动作绑定
- en: '](img/B16183_17_02.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_02.jpg)'
- en: 'Figure 17.2: Adding the new Fire action binding'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：添加新的Fire动作绑定
- en: Close `Project Settings`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Project Settings`。
- en: In `Content Browser`, go to the `Content\Mannequin\Animations` folder.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`中，转到`Content\Mannequin\Animations`文件夹。
- en: Click the `Import` button, go to the `Exercise17.01\Assets` folder and import
    the `ThirdPersonFire.fbx` file, and then make sure it's using the `UE4_Mannequin_Skeleton`
    skeleton.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`导入`按钮，转到`Exercise17.01\Assets`文件夹，并导入`ThirdPersonFire.fbx`文件，然后确保它使用`UE4_Mannequin_Skeleton`骨架。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Assets` folder mentioned earlier is available on our GitHub repository
    at [https://packt.live/36pEvAT](https://packt.live/36pEvAT).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的`Assets`文件夹可以在我们的GitHub存储库中找到[https://packt.live/36pEvAT](https://packt.live/36pEvAT)。
- en: Open the new animation and, on the details, the panel finds the `Enable Root
    Motion` option and sets it to true. This will prevent the character from moving
    when playing the animation.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的动画，在详细信息面板中找到`启用根动作`选项，并将其设置为true。这将在播放动画时防止角色移动。
- en: Save and close `ThirdPersonFire`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonFire`。
- en: '*Right-click* `ThirdPersonFire` on `Content Browser` and pick `Create -> AnimMontage`.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*“内容浏览器”上的“ThirdPersonFire”，然后选择“创建->AnimMontage”。'
- en: Rename `AnimMontage` to `ThirdPersonFire_Montage`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“AnimMontage”重命名为“ThirdPersonFire_Montage”。
- en: 'The `Animations` folder should look like this:![Figure 17.3: The animations
    folder for the Mannequin'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Animations”文件夹应该是这样的：![图17.3：模特的动画文件夹
- en: '](img/B16183_17_03.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_03.jpg)'
- en: 'Figure 17.3: The animations folder for the Mannequin'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：模特的动画文件夹
- en: Open `ThirdPerson_AnimBP` and then open `AnimGraph`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“ThirdPerson_AnimBP”，然后打开“AnimGraph”。
- en: '*Right-click* on an empty part of the graph, add a `DefaultSlot` node (to be
    able to play the animation montage), and connect it between `State Machine` and
    `Output Pose`. You should get the following output:![Figure 17.4: The AnimGraph
    of the character'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*图表的空白部分，添加一个“DefaultSlot”节点（以便播放动画镜头），并将其连接在“状态机”和“输出姿势”之间。您应该会得到以下输出：![图17.4：角色的AnimGraph'
- en: '](img/B16183_17_04.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_04.jpg)'
- en: 'Figure 17.4: The AnimGraph of the character'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：角色的AnimGraph
- en: Save and close `ThirdPerson_AnimBP`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭“ThirdPerson_AnimBP”。
- en: In `Content Browser`, go to the `Content` folder, create a new folder called
    `Audio`, and open it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容浏览器”中，转到“内容”文件夹，创建一个名为“音频”的新文件夹，并打开它。
- en: Click the `Import` button and go to the `Exercise17.01\Assets` folder, import
    `noammo.wav`, and save it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“导入”按钮，转到“Exercise17.01\Assets”文件夹，导入“noammo.wav”，然后保存。
- en: Go to `Content\ThirdPersonCPP\Blueprints` and open the `ThirdPersonCharacter`
    blueprint.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“Content\ThirdPersonCPP\Blueprints”，并打开“ThirdPersonCharacter”蓝图。
- en: In the class defaults, set `No Ammo Sound` to use `noammo`, and set `Fire Anim
    Montage` to use `ThirdPersonFire_Montage`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类默认值中，将“无弹药声音”设置为使用“noammo”，并将“Fire Anim Montage”设置为使用“ThirdPersonFire_Montage”。
- en: Save and close `ThirdPersonCharacter`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭“ThirdPersonCharacter”。
- en: Go to the Multiplayer options and set the number of clients to `2`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到多人游戏选项，并将客户端数量设置为“2”。
- en: Set the window size to 800x600 and play using PIE.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为800x600，并使用PIE播放。
- en: 'You should get the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '![Figure 17.5: The end result of the exercise'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.5：练习的最终结果'
- en: '](img/B16183_17_05.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_05.jpg)'
- en: 'Figure 17.5: The end result of the exercise'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：练习的最终结果
- en: By completing this exercise, you will be able to play on each client, and every
    time you press the *Left Mouse Button*, the character of the client will play
    the `Fire Anim` montage, which all clients will be able to see, and its ammo will
    reduce by `1`. If you try to fire when the ammo is `0`, that client will hear
    `No Ammo Sound` and won't do the fire animation, because the server didn't call
    the Multicast RPC. If you try to spam the fire button, you'll notice that it will
    only trigger a new fire once the animation is finished.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您将能够在每个客户端上进行游戏，每次按下*左鼠标按钮*时，客户端的角色将播放“Fire Anim”镜头，所有客户端都将能够看到，并且其弹药将减少1。如果您在弹药为`0`时尝试开火，该客户端将听到“无弹药声音”，并且不会执行开火动画，因为服务器没有调用多播RPC。如果您尝试连续按下开火按钮，您会注意到只有在动画完成后才会触发新的开火。
- en: In the next section, we will be looking at enumerations, which are used in game
    development for many different things, such as managing the state of a character (whether
    it's idle, walking, attacking, or dead, and so on) or to assign a human-friendly
    name for each index in the gear slot array (head, primary weapon, secondary weapon,
    torso, hands, belt, pants, and so on).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论枚举，它在游戏开发中用于许多不同的事情，比如管理角色的状态（是否空闲、行走、攻击或死亡等），或者为装备槽数组中的每个索引分配一个人类友好的名称（头部、主要武器、次要武器、躯干、手部、腰带、裤子等）。
- en: Enumerations
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: An enumeration is a user-defined data type that holds a list of integer constants,
    where each item has a human-friendly name assigned by you, which makes the code
    easier to read. As an example, we could use an integer variable to represent the
    different states that a character can be in – `0` means it's idle, `1` means it's
    walking, and so on. The problem with this approach is that when you start writing
    code such as `if(State == 0)`, it will become hard to remember what `0` means,
    especially if you have a lot of states, without using some documentation or comments
    to help you remember. To fix this problem, you should use enumerations, where
    you can write code such as `if(State == EState::Idle)`, which is much more explicit
    and easier to understand.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种用户定义的数据类型，它包含一系列整数常量，其中每个项目都由您分配了一个人类友好的名称，这使得代码更容易阅读。例如，我们可以使用整数变量来表示角色可能处于的不同状态
    - `0`表示空闲，`1`表示行走，依此类推。这种方法的问题在于，当您开始编写诸如`if(State == 0)`之类的代码时，很难记住`0`的含义，特别是如果您有很多状态，没有使用一些文档或注释来帮助您记住。为了解决这个问题，您应该使用枚举，其中您可以编写诸如`if(State
    == EState::Idle)`之类的代码，这样更加明确和易于理解。
- en: In C++, you have two types of enums, the older raw enums and the new enum classes,
    introduced in C++11\. If you want to use C++ enumerations in the editor, your
    first instinct might be to do it in the typical way, which is by declaring a variable
    or a function that uses the enumeration as a parameter, with `UPROPERTY` or `UFUNCTION`,
    respectively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您有两种类型的枚举，旧的原始枚举和引入于C++11的新枚举类。如果您想在编辑器中使用C++枚举，您的第一反应可能是以典型的方式来声明一个使用枚举作为参数的变量或函数，分别使用`UPROPERTY`或`UFUNCTION`。
- en: 'The problem is, if you try to do that, you''ll get a compilation error. Take
    a look at the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，如果您尝试这样做，将会出现编译错误。看一下以下示例：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, we declare an enum class called `ETestEnum` that
    has three possible values – `EnumValue1`, `EnumValue2`, and `EnumValue3`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了一个名为“ETestEnum”的枚举类，它有三个可能的值 - `EnumValue1`，`EnumValue2`和`EnumValue3`。
- en: 'After that, try either one of the following examples:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，尝试以下示例之一：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code snippet, we declare a `UPROPERTY` variable and `UFUNCTION`
    function that uses the `ETestEnum` enumeration in a class. If you try to compile,
    you''ll get the following compilation error:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个在类中使用`ETestEnum`枚举的`UPROPERTY`变量和`UFUNCTION`函数。如果您尝试编译，您将收到以下编译错误：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Unreal Engine 4, it's good practice to prefix the name of an enumeration
    with the letter `E`. Examples include `EWeaponType` and `EAmmoType`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，最好的做法是使用字母`E`作为枚举名称的前缀。例如`EWeaponType`和`EAmmoType`。
- en: This error happens because when you try to expose a class, struct, or enumeration
    to the editor with the `UPROPERTY` or `UFUNCTION` macro, you need to add it to
    the Unreal Engine 4 Reflection System by using the `UCLASS`, `USTRUCT`, and `UENUM`
    macros, respectively.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误发生的原因是，当您尝试使用`UPROPERTY`或`UFUNCTION`宏将类、结构或枚举暴露给编辑器时，您需要分别使用`UCLASS`、`USTRUCT`和`UENUM`宏将其添加到虚幻引擎4反射系统中。
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the Unreal Engine 4 Reflection System by visiting
    the following link: [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下链接了解更多关于虚幻引擎4反射系统的信息：[https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)。
- en: 'With that knowledge in mind, it is simple to fix the previous error, so just
    do the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，修复先前的错误就很简单了，只需执行以下操作：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we will look at the `TEnumAsByte` type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看`TEnumAsByte`类型。
- en: TEnumAsByte
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TEnumAsByte
- en: If you want to expose a variable to the engine that uses a raw enum, then you
    need to use the `TEnumAsByte` type. If you declare a `UPROPERTY` variable using
    a raw enum (not enum classes), you'll get a compilation error.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想向使用原始枚举的引擎公开变量，那么您需要使用`TEnumAsByte`类型。如果您使用原始枚举（而不是枚举类）声明`UPROPERTY`变量，您将收到编译错误。
- en: 'Have a look at the following example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you declare a `UPROPERTY` variable using `ETestRawEnum`, such as the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`ETestRawEnum`声明`UPROPERTY`变量，如下所示：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You''ll get this compilation error:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下编译错误：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To fix this error, you need to surround the enum type of the variable, which
    in this case is `ETestRawEnum`, with `TEnumAsByte<>`, like so:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决此错误，您需要将变量的枚举类型（在本例中为`ETestRawEnum`）用`TEnumAsByte<>`括起来，如下所示：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: UMETA
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UMETA
- en: 'When you use the `UENUM` macro to add an enumeration to the Unreal Engine Reflection
    System, this will allow you to use the `UMETA` macro on each value of the enum.
    The `UMETA` macro, just like with other macros such as `UPROPERTY` or `UFUNCTION`,
    can use specifiers that will inform Unreal Engine 4 on how to handle that value.
    Here is a list of the most commonly used `UMETA` specifiers:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`UENUM`宏将枚举添加到虚幻引擎反射系统时，这将允许您在枚举的每个值上使用`UMETA`宏。`UMETA`宏，就像其他宏（如`UPROPERTY`或`UFUNCTION`）一样，可以使用说明符，这些说明符将告知虚幻引擎4如何处理该值。以下是最常用的`UMETA`说明符列表：
- en: DisplayName
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DisplayName
- en: This specifier allows you to define a new name that is easier to read for the
    enum value when it's displayed in the editor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此说明符允许您在编辑器中显示枚举值时定义一个更易读的新名称。
- en: 'Take a look at the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s declare the following variable:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明以下变量：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, when you open the editor and look at the `TestEnum` variable, you will
    see a dropdown where `EnumValue1`, `EnumValue2,` and `EnumValue3` have been replaced
    by `My First Option`, `My Second Option,` and `My Third Option`, respectively.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您打开编辑器并查看`TestEnum`变量时，您将看到一个下拉菜单，其中`EnumValue1`，`EnumValue2`和`EnumValue3`已分别替换为`My
    First Option`，`My Second Option`和`My Third Option`。
- en: Hidden
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hidden
- en: This specifier allows you to hide a specific enum value from the dropdown. This
    is typically used when there is an enum value that you only want to be able to
    use in C++ and not in the editor.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此说明符允许您从下拉菜单中隐藏特定的枚举值。当只想在C++中使用枚举值而不想在编辑器中使用时，通常会使用此功能。
- en: 'Take a look at the following example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s declare the following variable:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明以下变量：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then, when you open the editor and look at the `TestEnum` variable, you will
    see a dropdown. You should notice that `My Second Option` doesn't appear in the
    dropdown and therefore can't be selected.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当您打开编辑器并查看`TestEnum`变量时，您将看到一个下拉菜单。您应该注意到`My Second Option`不会出现在下拉菜单中，因此无法选择。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on all of the UMETA specifiers, visit [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有UMETA说明符的更多信息，请访问[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers)。
- en: In the next section, we will look at the `BlueprintType` specifier for the `UENUM` macro.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看`UENUM`宏的`BlueprintType`说明符。
- en: BlueprintType
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BlueprintType
- en: 'This `UENUM` specifier will expose the enumeration to blueprints. This means
    that there will be an entry for that enumeration on the dropdown that is used
    when making new variables or inputs/outputs for a function, as in the following
    example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此`UENUM`说明符将枚举暴露给蓝图。这意味着在创建新变量或函数的输入/输出时，下拉菜单中将有该枚举的条目，就像以下示例中一样：
- en: '![Figure 17.6: Setting a variable to use the ETestEnum variable type.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.6：设置变量以使用ETestEnum变量类型。'
- en: '](img/B16183_17_06.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_06.jpg)'
- en: 'Figure 17.6: Setting a variable to use the ETestEnum variable type.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6：设置变量以使用ETestEnum变量类型。
- en: 'It will also show additional functions that you can call on the enumeration
    in the editor, as in this example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将显示您可以在编辑器中对枚举调用的其他函数，就像这个例子一样：
- en: '![Figure 17.7: List of additional functions available when using BlueprintType'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图17.7：使用BlueprintType时可用的其他函数列表'
- en: '](img/B16183_17_07.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_07.jpg)'
- en: 'Figure 17.7: List of additional functions available when using BlueprintType'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7：使用BlueprintType时可用的其他函数列表
- en: MAX
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MAX
- en: When using enumerations, it's common to want to know how many values it has.
    In Unreal Engine 4, the standard way of doing this is by adding `MAX` as the last
    value, which will be automatically hidden in the editor.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用枚举时，通常希望知道它有多少个值。在虚幻引擎4中，标准做法是将`MAX`添加为最后一个值，这将自动隐藏在编辑器中。
- en: 'Take a look at the following example:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you want to know how many values `ETestEnum` has in C++, you just need to
    do the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要知道C++中`ETestEnum`有多少个值，只需执行以下操作：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This works because enumerations in C++ are internally stored as numbers, where
    the first value is `0`, the second is `1`, and so on. This means that as long
    as `MAX` is the last value, it will always have the total number of values in
    the enumeration. An important thing to take into consideration is that in order
    for `MAX` to give you the correct value, you cannot change the internal numbering
    order of the enumeration, like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为C++中的枚举内部存储为数字，第一个值为`0`，第二个值为`1`，依此类推。这意味着只要`MAX`是最后一个值，它将始终具有枚举中的总值。需要考虑的一个重要事项是，为了使`MAX`给出正确的值，不能更改枚举的内部编号顺序，如下所示：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this case, `MAX` will be `101` because it will use the number immediately
    next to the previous value, which is `EnumValue3 = 100`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`MAX`将是`101`，因为它将使用紧接前一个值的数字，即`EnumValue3 = 100`。
- en: Using `MAX` is only meant to be used in C++ and not in the editor, because the
    `MAX` value is hidden in blueprints, as previously mentioned. To get the number
    of entries of an enumeration in blueprints, you should use the `BlueprintType`
    specifier in the `UENUM` macro in order to expose some useful functions on the
    context menu. After that, you just need to type the name of your enumeration in
    the context menu. If you select the `Get number of entries in ETestEnum` option,
    you will have a function that returns the number of entries of an enumeration.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MAX`只能在C++中使用，而不能在编辑器中使用，因为`MAX`值在蓝图中是隐藏的，如前所述。要在蓝图中获取枚举的条目数，应在`UENUM`宏中使用`BlueprintType`修饰符，以便在上下文菜单中公开一些有用的函数。之后，您只需要在上下文菜单中输入枚举的名称。如果选择`Get
    number of entries in ETestEnum`选项，将获得一个返回枚举条目数的函数。
- en: In the next exercise, you will be using C++ enumerations in the Unreal Engine
    4 editor.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将在虚幻引擎4编辑器中使用C++枚举。
- en: 'Exercise 17.02: Using C++ Enumerations in the Unreal Engine 4 Editor'
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习17.02：在虚幻引擎4编辑器中使用C++枚举
- en: 'In this exercise, we''re going to create a new C++ project that uses the `Third
    Person` template, and we''re going to add the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用`Third Person`模板的新C++项目，并添加以下内容：
- en: An enumeration called `EWeaponType` containing `3` weapons – a pistol, shotgun,
    and rocket launcher.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`EWeaponType`的枚举，包含`3`种武器-手枪、霰弹枪和火箭发射器。
- en: An enumeration called `EAmmoType` containing `3` ammo types – bullets, shells,
    and rockets.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`EAmmoType`的枚举，包含`3`种弹药类型-子弹、弹壳和火箭。
- en: A variable called `Weapon` that uses `EWeaponType` to tell the type of the current weapon.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Weapon`的变量，使用`EWeaponType`来告诉当前武器的类型。
- en: An integer array variable called `Ammo` that holds the amount of ammo for each
    type, which is initialized with the value `10`.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Ammo`的整数数组变量，保存每种类型的弹药数量，初始化值为`10`。
- en: When the player presses the *1*, *2*, and *3* keys, it will set `Weapon` to
    `Pistol`, `Shotgun`, and `Rocket Launcher`, respectively.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家按下*1*、*2*和*3*键时，它将分别将`Weapon`设置为`Pistol`、`Shotgun`和`Rocket Launcher`。
- en: When the player presses the *Left Mouse Button*, this will consume ammo from
    the current weapon.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家按下*左鼠标按钮*时，这将消耗当前武器的弹药。
- en: With every `Tick`function call, the character will display the current weapon
    type and the equivalent ammo type and amount.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次`Tick`函数调用时，角色将显示当前武器类型和相应的弹药类型和数量。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `Enumerations`
    and save it to a location of your choosing.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C++创建一个名为`Enumerations`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，它应该同时打开编辑器和Visual Studio解决方案。
- en: Close the editor and go back to Visual Studio.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，返回Visual Studio。
- en: Open the `Enumerations.h` file.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Enumerations.h`文件。
- en: 'Create a macro called `ENUM_TO_INT32` that will convert an enumeration to an
    `int32` datatype:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ENUM_TO_INT32`的宏，它将枚举转换为`int32`数据类型：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create a macro called `ENUM_TO_FSTRING` that will get the display name for
    a value of an `enum` datatype and convert it to an `FString` datatype:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ENUM_TO_FSTRING`的宏，它将获取`enum`数据类型的值的显示名称，并将其转换为`FString`数据类型：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare the enumerations `EWeaponType` and `EAmmoType`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明枚举`EWeaponType`和`EAmmoType`：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open the `EnumerationsCharacter.h` file, include the `Enumerations.h` header:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnumerationsCharacter.h`文件，包括`Enumerations.h`头文件：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Declare the protected `Weapon` variable that holds the weapon type of the selected
    weapon:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`Weapon`变量，保存所选武器的武器类型：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Declare the protected `Ammo` array that holds the amount of ammo for each type:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`Ammo`数组，保存每种类型的弹药数量：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Declare the protected overrides for the `Begin Play` and `Tick` functions:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Begin Play`和`Tick`函数的受保护覆盖：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare the protected input functions:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的输入函数：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Open the `EnumerationsCharacter.cpp` file, include the `DrawDebugHelpers.h`
    header:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnumerationsCharacter.cpp`文件，包括`DrawDebugHelpers.h`头文件：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Bind the new action bindings at the end of the `SetupPlayerInputController`
    function, as shown in the following code snippet:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputController`函数的末尾绑定新的动作绑定，如下面的代码片段所示：
- en: '[PRE65]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, implement the override for `BeginPlay` that executes the parent logic,
    but also initializes the size of the `Ammo` array with the number of entries in
    the `EAmmoType` enumeration. Each position in the array will also be initialized
    with a value of `10`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`BeginPlay`的重写，执行父逻辑，但也初始化`Ammo`数组的大小，大小为`EAmmoType`枚举中的条目数。数组中的每个位置也将初始化为值`10`：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Implement the override for `Tick`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Tick`的重写：
- en: '[PRE67]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Convert the `Weapon` variable to `int32` and the `Weapon` variable to an `FString`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Weapon`变量转换为`int32`，将`Weapon`变量转换为`FString`：
- en: '[PRE68]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Convert the ammo type to an `FString` and get the ammo count for the current weapon:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹药类型转换为`FString`并获取当前武器的弹药数量：
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We use `Weapon` to get the ammo type string because the entries in `EAmmoType`
    match the type of ammo of the equivalent `EWeaponType`. In other words, `Pistol
    = 0` uses `Bullets = 0`, `Shotgun = 1` uses `Shells = 1`, and `RocketLauncher
    = 2` uses `Rockets = 2`, so it's a 1-to-1 mapping that we can use in our favor.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Weapon`来获取弹药类型字符串，因为`EAmmoType`中的条目与等效的`EWeaponType`的弹药类型匹配。换句话说，`Pistol
    = 0`使用`Bullets = 0`，`Shotgun = 1`使用`Shells = 1`，`RocketLauncher = 2`使用`Rockets
    = 2`，因此这是我们可以利用的一对一映射。
- en: 'Display in the character''s location the name of the current weapon and its
    corresponding ammo type and ammo count, as shown in the following code snippet:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色位置显示当前武器的名称及其对应的弹药类型和弹药数量，如下面的代码片段所示：
- en: '[PRE70]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the equip input functions that sets the `Weapon` variable with the
    corresponding value:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现装备输入函数，将`Weapon`变量设置为相应的值：
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the fire input function that will use the weapon index to get the
    corresponding ammo type count and subtract `1`, as long as the resulting value
    is greater or equal to 0:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现火力输入函数，该函数将使用武器索引获取相应的弹药类型计数，并减去`1`，只要结果值大于或等于0：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Compile the code and run the editor.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并运行编辑器。
- en: 'Go to `Project Settings` and then `Engine`, then `Input`, and add the new action
    `bindings`:![Figure 17.8: Adding the Pistol, Shotgun, Rocket Launcher, and Fire
    bindings'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`项目设置`，然后转到`引擎`，然后转到`输入`，并添加新的动作`绑定`：![图17.8：添加手枪、霰弹枪、火箭发射器和火绑定
- en: '](img/B16183_17_08.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_08.jpg)'
- en: 'Figure 17.8: Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8：添加手枪、霰弹枪、火箭发射器和火焰绑定
- en: Close the `Project Settings`.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`项目设置`。
- en: 'Play in `New Editor Window (PIE)` in single-player mode (one client and dedicated
    server disabled):![Figure 17.9: The end result of the exercise'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单人模式下（一个客户端和禁用的专用服务器）中进行`New Editor Window (PIE)`游戏：![图17.9：练习的最终结果
- en: '](img/B16183_17_09.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_09.jpg)'
- en: 'Figure 17.9: The end result of the exercise'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9：练习的最终结果
- en: By completing this exercise, you will be able to use the *1*, *2*, and *3* keys
    to select the current weapon. You'll notice that every tick will display the type
    of the current weapon and its corresponding ammo type and ammo count. If you press
    the fire key, this will deduct the ammo count for the current weapon, but it will
    never go below `0`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您将能够使用*1*、*2*和*3*键选择当前武器。您会注意到每次都会显示当前武器的类型及其对应的弹药类型和弹药数量。如果按下火键，这将减少当前武器的弹药数量，但不会低于`0`。
- en: In the next section, you will be looking at bi-directional circular array indexing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习双向循环数组索引。
- en: Bi-Directional Circular Array Indexing
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向循环数组索引
- en: 'Sometimes, when you use arrays to store information, you might want to iterate
    it in a bi-direction circular fashion. An example of this is the previous/next
    weapon logic in shooter games, where you have an array with weapons and you want
    to be able to cycle through them in a particular direction, and when you reach
    the first or the last index, you want to loop back around to the last and first
    index, respectively. The typical way of doing this example would be the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当您使用数组存储信息时，您可能希望以双向循环的方式迭代它。一个例子是射击游戏中的上一个/下一个武器逻辑，您在其中有一个包含武器的数组，并且希望能够以特定方向循环遍历它们，当您到达第一个或最后一个索引时，您希望循环回到最后一个和第一个索引。执行此示例的典型方法将是以下内容：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we adjust the weapon index to loop back if the new weapon
    index is outside the limits of the weapons array, which can happen in two cases.
    The first case is when the player has the last weapon of the inventory equipped
    and asks for the next weapon. In this case, it should go back to the first weapon.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们调整武器索引以在新武器索引超出武器数组限制时循环回来，这可能发生在两种情况下。第一种情况是玩家装备了库存中的最后一把武器并要求下一把武器。在这种情况下，它应该返回到第一把武器。
- en: The second case is when the player has the first weapon of the inventory equipped
    and asks for the previous weapon. In this case, it should go to the last weapon.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是玩家装备了库存中的第一把武器并要求上一把武器。在这种情况下，它应该转到最后一把武器。
- en: While the example code works, it's still quite a lot of code to solve such a
    trivial problem. To improve this code, there is a mathematical formula that will
    help you contemplate these two cases automatically in just one function. It's
    called the modulo (represented in C++ by the `%` operator), which gives you the
    remainder of a division between two numbers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然示例代码有效，但仍然需要大量代码来解决这样一个微不足道的问题。为了改进这段代码，有一个数学公式将帮助您在一个函数中自动考虑这两种情况。它被称为模数（在C++中表示为`%`运算符），它给出两个数字之间的余数。
- en: 'So how do we use the modulo to do a bi-directional circular array indexing?
    Let''s rewrite the previous example using the modulo:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何使用模数来进行双向循环数组索引？让我们使用模数重写上一个例子：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is the new version, and you can tell right away that it's a bit harder
    to understand, but it's more functional and compact. If you don't use the variables
    to store the intermediate values of each operation, you can probably make the
    entire function in one or two lines of code.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新版本，您可以立即看出它有点难以理解，但它更加功能齐全和紧凑。如果您不使用变量来存储每个操作的中间值，您可能可以将整个函数编写为一两行代码。
- en: 'Let''s break down the preceding code snippet:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码片段：
- en: '`const int WeaponCount = Weapons.Num()`: We need to know the size of the array
    to determine the index where it should circle back to `0`. In other words, if
    `WeaponCount = 4`, then the array has the indexes `0`, `1`, `2`, and `3`, so that
    tells us that index 4 is the cutoff index where it should go back to `0`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`const int WeaponCount = Weapons.Num()`：我们需要知道数组的大小，以确定它应该循环回`0`的索引。换句话说，如果`WeaponCount
    = 4`，那么数组具有索引`0`、`1`、`2`和`3`，这告诉我们索引4是应该回到`0`的截止索引。'
- en: '`const int32 NewIndex = WeaponIndex + Direction`: This is the new raw index
    without clamping it to the limits of the array. The `Direction` variable is used
    to indicate the offset we want to navigate the array, and this is either `-1`
    if we want the previous index or `1` if we want the next index.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`const int32 NewIndex = WeaponIndex + Direction`：这是未经夹紧到数组限制的新原始索引。`Direction`变量用于指示我们要导航数组的偏移量，如果我们想要上一个索引，则为`-1`，如果我们想要下一个索引，则为`1`。'
- en: '`const int32 ClampedNewIndex = NewIndex % WeaponCount`: This will make sure
    that `NewIndex` is within the `0` to `WeaponCount - 1` interval due to the modulo
    properties.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`const int32 ClampedNewIndex = NewIndex % WeaponCount`：这将确保由于模数属性，`NewIndex`在`0`到`WeaponCount
    - 1`的区间内。'
- en: If `Direction` was always `1`, then `ClampedNewIndex` would be enough for what
    we need. The problem is, the modulo operation doesn't work very well with negative
    values, which can happen when `WeaponIndex` is `0` and `Direction` is `-1`, which
    would cause `NewIndex` to be `-1`. To fix this limitation, we need to do some
    additional calculations.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Direction`总是`1`，那么`ClampedNewIndex`就足够了。问题是，当`WeaponIndex`为`0`且`Direction`为`-1`时，模运算不太适用于负值，这会导致`NewIndex`为`-1`。为了解决这个限制，我们需要进行一些额外的计算。
- en: '`WeaponIndex = (ClampedNewIndex + WeaponCount) % WeaponCount`: This will add
    `WeaponCount` to `ClampedNewIndex` to make it positive and apply the modulo again
    to get the correct clamped index, which fixes the problem.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponIndex = (ClampedNewIndex + WeaponCount) % WeaponCount`：这将向`ClampedNewIndex`添加`WeaponCount`以使其为正，并再次应用模数以获得正确的夹紧索引，从而解决了问题。'
- en: '`return Weapons[WeaponIndex]`: This returns the weapon in the calculated `WeaponIndex`
    index position.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`return Weapons[WeaponIndex]`：这将返回计算出的`WeaponIndex`索引位置的武器。'
- en: 'Let''s take a look at a practical example to help you visualize how all this
    works:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子来帮助你理解所有这些是如何工作的：
- en: '**Weapons** ='
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**武器** ='
- en: '[0] Knife'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[0] 刀'
- en: '[1] Pistol'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[1] 手枪'
- en: '[2] Shotgun'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2] 霰弹枪'
- en: '[3] Rocket Launcher'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3] 火箭发射器'
- en: '`Weapons.Num() = 4`.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weapons.Num() = 4`。'
- en: Let's assume that `WeaponIndex = 3` and `Direction = 1`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`WeaponIndex = 3`，`Direction = 1`。
- en: 'Then:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '`NewIndex` = *WeaponIndex + Direction* = 3 + 1 = 4'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewIndex` = *WeaponIndex + Direction* = 3 + 1 = 4'
- en: '`ClampedIndex` = *NewIndex % WeaponCount* = 4 % 4 = 0'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClampedIndex` = *NewIndex % WeaponCount* = 4 % 4 = 0'
- en: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (0 + 4) % 4
    = 0'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (0 + 4) % 4
    = 0'
- en: In this example, the starting value for the weapon index is `3` (which is the
    Rocket Launcher), and we want the next weapon (since `Direction` is `1`). Performing
    the calculations, `WeaponIndex` will now be `0` (which is the Knife). This is
    the desired behavior because we have 4 weapons, so we circled back to In this
    case, since `Direction` is `1`, we could've just used `ClampedIndex` without doing
    the extra calculations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，武器索引的起始值是`3`（火箭发射器），我们想要下一个武器（因为`Direction`是`1`）。进行计算，`WeaponIndex`现在将是`0`（刀）。这是期望的行为，因为我们有4个武器，所以我们回到了这种情况下，由于`Direction`是`1`，我们可以只使用`ClampedIndex`而不进行额外的计算。
- en: Let's debug it again using different values.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用不同的值进行调试。
- en: 'Let''s assume that `WeaponIndex = 0` and `Direction = -1`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`WeaponIndex = 0`，`Direction = -1`：
- en: '`NewIndex` = *WeaponIndex + Direction* = 0 + -1 = -1'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewIndex` = *WeaponIndex + Direction* = 0 + -1 = -1'
- en: '`ClampedIndex` = *NewIndex % WeaponCount *= -1 % 4 = -1'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClampedIndex` = *NewIndex % WeaponCount *= -1 % 4 = -1'
- en: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (-1 + 4) % 4
    = 3'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (-1 + 4) % 4
    = 3'
- en: In this example, the starting value for the weapon index is 0 (which is the
    Knife), and we want the previous weapon (since `Direction` is -`1`). Doing the
    calculations, `WeaponIndex` will now be 3 (which is the Rocket Launcher). This
    is the desired behavior because we have 4 weapons, so we circled back to 3\. In
    this specific case, `NewIndex` is negative, so we can't just use `ClampedIndex`;
    we need to do the extra calculation to get the correct value.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，武器索引的起始值为0（刀），我们想要上一个武器（因为`Direction`是-`1`）。进行计算，`WeaponIndex`现在将是3（火箭发射器）。这是期望的行为，因为我们有4个武器，所以我们回到了3。在这种特定情况下，`NewIndex`是负数，所以我们不能只使用`ClampedIndex`；我们需要进行额外的计算来获得正确的值。
- en: 'Exercise 17.03: Using Bi-Directional Circular Array Indexing to Cycle between
    an Enumeration'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Exercise 17.03: 使用双向循环数组索引在枚举之间循环'
- en: In this exercise, we're going to use the project from *Exercise17.02*, *Using
    C++ Enumerations in the Unreal Engine 4 Editor*, and add two new action mappings
    for cycling the weapons. The mouse wheel up will go to the previous weapon type,
    and the mouse wheel down will go to the next weapon type.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用*Exercise17.02*，*在虚幻引擎4编辑器中使用C++枚举*中的项目，并为武器循环添加两个新的动作映射。鼠标滚轮向上将转到上一个武器类型，鼠标滚轮向下将转到下一个武器类型。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: First, open the Visual Studio project from *Exercise 17.02*, *Using C++ Enumerations
    in the Unreal Engine 4 Editor*.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从*Exercise 17.02*，*在虚幻引擎4编辑器中使用C++枚举*中打开Visual Studio项目。
- en: Next, you will be updating `Enumerations.h` and add a macro that will handle
    the bi-directional array cycling in a very convenient way, as shown in the following
    steps.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将更新`Enumerations.h`并添加一个宏，该宏将以非常方便的方式处理双向数组循环，如下所示。
- en: 'Open `Enumerations.h` and add the `GET_CIRCULAR_ARRAY_INDEX` macro that will
    apply the modulo formula that we''ve already covered previously:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Enumerations.h`并添加`GET_CIRCULAR_ARRAY_INDEX`宏，该宏将应用我们已经讨论过的模数公式：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Open `EnumerationsCharacter.h` and declare the new input functions for the
    weapon cycling:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnumerationsCharacter.h`并声明武器循环的新输入函数：
- en: '[PRE76]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Declare the `CycleWeapons` function, as shown in the following code snippet:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`CycleWeapons`函数，如下面的代码片段所示：
- en: '[PRE77]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Open `EnumerationsCharacter.cpp` and bind the new action bindings in the `SetupPlayerInputController`
    function:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnumerationsCharacter.cpp`并在`SetupPlayerInputController`函数中绑定新的动作绑定：
- en: '[PRE78]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, implement the new input functions, as shown in the following code snippet:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现新的输入函数，如下面的代码片段所示：
- en: '[PRE79]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the preceding code snippet, we define the functions that handle the action
    mappings for `Previous Weapon` and `Next Weapon`. Each function uses the `CycleWeapons`
    function, with a direction of `-1` for the previous weapon and `1` for the next
    weapon.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们定义了处理“上一个武器”和“下一个武器”动作映射的函数。每个函数都使用`CycleWeapons`函数，对于上一个武器使用方向为`-1`，对于下一个武器使用方向为`1`。
- en: 'Implement the `CycleWeapons` functions, which does the bi-directional cycling
    using the `Direction` parameter based on the current weapon index:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`CycleWeapons`函数，根据当前武器索引和`Direction`参数进行双向循环。
- en: '[PRE80]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In the preceding code snippet, we implement the `CycleWeapons` function that
    uses the modulo operator to calculate the next valid weapon index based on the
    direction supplied.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们实现了`CycleWeapons`函数，该函数使用模运算符根据提供的方向计算下一个有效武器索引。
- en: Compile the code and run the editor.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码并运行编辑器。
- en: 'Go to `Project Settings` and then to `Engine`, then `Input`, and add the new
    action `bindings`:![Figure 17.10: Adding the Previous Weapon and Next Weapon bindings'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Project Settings`，然后转到`Engine`，然后转到`Input`，并添加新的动作`绑定`：![图17.10：添加上一个武器和下一个武器绑定
- en: '](img/B16183_17_10.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_10.jpg)'
- en: 'Figure 17.10: Adding the Previous Weapon and Next Weapon bindings'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10：添加上一个武器和下一个武器绑定
- en: Close the `Project Settings`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Project Settings`。
- en: 'Now, play in `New Editor Window (PIE)` in single-player mode (one client and
    dedicated server disabled):![Figure 17.11: The end result of the exercise'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在单人模式下（一个客户端和禁用专用服务器）中播放`New Editor Window (PIE)`：![图17.11：练习的最终结果
- en: '](img/B16183_17_11.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_11.jpg)'
- en: 'Figure 17.11: The end result of the exercise'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11：练习的最终结果
- en: By completing this exercise, you will be able to use the mouse wheel to cycle
    between the weapons. If you select the rocket launcher and use the mouse wheel
    down to go to the next weapon, it will go back to the pistol. If you use the mouse
    wheel down to go to the previous weapon with the pistol selected, it will go back
    to the rocket launcher.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您将能够使用鼠标滚轮在武器之间进行循环。如果选择火箭发射器并使用鼠标滚轮向下滚动到下一个武器，它将返回到手枪。如果使用鼠标滚轮向下滚动到上一个武器并选择手枪，它将返回到火箭发射器。
- en: In the next activity, you will be adding the concept of weapons and ammo to
    the multiplayer FPS project we started in *Chapter 16*, *Multiplayer Basics*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，您将向我们在*第16章*“多人游戏基础”中开始的多人FPS项目中添加武器和弹药的概念。
- en: 'Activity 17.01: Adding Weapons and Ammo to the Multiplayer FPS Game'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动17.01：向多人FPS游戏添加武器和弹药
- en: In this activity, you'll add the concept of weapons and ammo to the Multiplayer
    FPS project we embarked on in the previous chapter activity. You will need to
    use the different types of RPCs covered in this chapter to complete this activity.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将向我们在上一章活动中开始的多人FPS项目中添加武器和弹药的概念。您需要使用本章中介绍的不同类型的RPC来完成这个活动。
- en: 'The following steps will help you complete this activity:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成这个活动：
- en: Open the `MultiplayerFPS` project from *Activity 16.01*, *Creating a Character
    for the Multiplayer FPS Project*.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*Activity 16.01*“为多人FPS项目创建角色”中打开`MultiplayerFPS`项目。
- en: Create a new `AnimMontage` slot called `Upper Body`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Upper Body`的新`AnimMontage`插槽。
- en: Import the animations (`Pistol_Fire.fbx`, `MachineGun_Fire.fbx`, and `Railgun_Fire.fbx`)
    from the `Activity17.01\Assets` folder to `Content\Player\Animations`.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`文件夹导入动画（`Pistol_Fire.fbx`，`MachineGun_Fire.fbx`和`Railgun_Fire.fbx`）到`Content\Player\Animations`。
- en: Note
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Assets folder, `Activity17.01\Assets`, can be found on our GitHub repository
    at [https://packt.live/2It4Plb](https://packt.live/2It4Plb).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Assets文件夹`Activity17.01\Assets`可以在我们的GitHub存储库中找到，网址为[https://packt.live/2It4Plb](https://packt.live/2It4Plb)。
- en: 'Create an anim montage for `Pistol_Fire`, `MachineGun_Fire`, and `Railgun_Fire`
    and make sure they have the following configurations:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Pistol_Fire`，`MachineGun_Fire`和`Railgun_Fire`创建一个动画蒙太奇，并确保它们具有以下配置：
- en: '`Blend In` time of `0.01`, the `Blend Out` time of `0.1`, and make sure it
    uses the `Upper Body` slot.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blend In`时间为`0.01`，`Blend Out`时间为`0.1`，并确保它使用`Upper Body`插槽。'
- en: '`Blend In` time of `0.01`, the `Blend Out` time of `0.1`, and make sure it
    uses the Upper Body slot.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blend In`时间为`0.01`，`Blend Out`时间为`0.1`，并确保它使用`Upper Body`插槽。'
- en: '`Upper Body` slot.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`Upper Body`插槽。'
- en: Import `SK_Weapon.fbx`, `NoAmmo.wav`, `WeaponChange.wav`, and `Hit.wav` from
    the `Activity17.01\Assets` folder to `Content\Weapons`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`文件夹导入`SK_Weapon.fbx`，`NoAmmo.wav`，`WeaponChange.wav`和`Hit.wav`到`Content\Weapons`。
- en: Import `Pistol_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\Pistol`
    and use it on an `AnimNotify` Play Sound in the `Pistol_Fire` animation.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`Pistol_Fire_Sound.wav`到`Content\Weapons\Pistol`，并在`Pistol_Fire`动画的`AnimNotify`
    Play Sound中使用它。
- en: Create a simple green-colored material called `M_Pistol` and place it on `Content\Weapons\Pistol`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`M_Pistol`的简单绿色材质，并将其放置在`Content\Weapons\Pistol`上。
- en: Import `MachineGun_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\MachineGun`
    and use it on an `AnimNotify` Play Sound in the `MachineGun_Fire` animation.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`MachineGun_Fire_Sound.wav`到`Content\Weapons\MachineGun`，并在`MachineGun_Fire`动画中的`AnimNotify`
    Play Sound中使用它。
- en: Create a simple red-colored material called `M_MachineGun` and place it on `Content\Weapons\MachineGun`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`M_MachineGun`的简单红色材质，并将其放置在`Content\Weapons\MachineGun`上。
- en: Import `Railgun_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\Railgun`
    and use it on an `AnimNotify` Play Sound in the `Railgun_Fire` animation.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity17.01\Assets`导入`Railgun_Fire_Sound.wav`到`Content\Weapons\Railgun`，并在`Railgun_Fire`动画中使用`AnimNotify`播放声音。
- en: Create a simple white-colored material called `M_Railgun` and place it on `Content\Weapons\Railgun`.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`M_Railgun`的简单白色材质，并将其放置在`Content\Weapons\Railgun`上。
- en: Edit the `SK_Mannequin` skeletal mesh and create a socket called `GripPoint`
    from `hand_r` with Relative Location (*X=-10.403845,Y=6.0,Z=-3.124871*) and Relative
    Rotation (*X=0.0,Y=0.0,Z=90.0*).
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`SK_Mannequin`骨骼网格，并从`hand_r`创建一个名为`GripPoint`的插槽，相对位置为（*X=-10.403845，Y=6.0，Z=-3.124871*），相对旋转为（*X=0.0，Y=0.0，Z=90.0*）。
- en: 'Add the following input mappings in `Project Settings`, using the knowledge
    acquired in *Chapter 4*, *Player Input*:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project Settings`中添加以下输入映射，使用*第4章*，*玩家输入*中获得的知识：
- en: 'Fire (Action mapping): Left Mouse Button'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击（动作映射）：鼠标左键
- en: 'Previous Weapon (Action mapping): Mouse Wheel Up'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个武器（动作映射）：鼠标滚轮向上
- en: 'Next Weapon (Action mapping): Mouse Wheel Down'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个武器（动作映射）：鼠标滚轮向下
- en: 'Pistol (Action mapping): 1'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手枪（动作映射）：1
- en: 'Machine Gun (Action mapping): 2'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机枪（动作映射）：2
- en: 'Railgun (Action mapping): 3'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Railgun（动作映射）：3
- en: In `MultiplayerFPS.h`, create the `ENUM_TO_INT32(Enum)` macro, which casts an
    enumeration to `int32` and `GET_CIRCULAR_ARRAY_INDEX(Index, Count)` that uses
    bi-directional circular array indexing to convert the index into an index that
    is within the interval of `0` and a count of `-1`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MultiplayerFPS.h`中，创建`ENUM_TO_INT32(Enum)`宏，将枚举转换为`int32`，并创建`GET_CIRCULAR_ARRAY_INDEX(Index,
    Count)`，该宏使用双向循环数组索引将索引转换为在`0`和`-1`计数之间的索引。
- en: 'Create a header file called `EnumTypes.h`, which holds the following enumerations:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`EnumTypes.h`的头文件，其中包含以下枚举：
- en: '**EWeaponType**: Pistol, MachineGun, Railgun, MAX'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**EWeaponType**：手枪，机枪，电磁炮，最大'
- en: '**EWeaponFireMode**: Single, Automatic'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**EWeaponFireMode**：单发，自动'
- en: '**EAmmoType**: Bullets, Slugs, MAX'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAmmoType**：子弹，弹丸，最大'
- en: Create a C++ class `Weapon` that derives from the `Actor` class that has a skeletal
    mesh component called `Mesh` as the root component. In terms of variables, it
    stores the name, the weapon type, the ammo type, the fire mode, how far the hitscan
    goes, how much damage the hitscan does when it hits, the fire rate, the animation
    montage to use when firing, and the sound to play when it has no ammo. In terms
    of functionality, it needs to be able to start the fire (and also stop the fire,
    because of the automatic fire mode), which checks whether the player can fire.
    If it can, then it plays the fire animation in all of the clients and shoots a
    line trace in the camera position and direction with the supplied length to damage
    the actor it hits. If it doesn't have ammo, it will play a sound only on the owning
    client.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个C++类`Weapon`，它继承自`Actor`类，具有名为`Mesh`的骨骼网格组件作为根组件。在变量方面，它存储名称、武器类型、弹药类型、射击模式、命中扫描范围、命中扫描伤害、射速、开火时使用的动画蒙太奇以及无弹药时播放的声音。在功能方面，它需要能够开始射击（也需要停止射击，因为是自动射击模式），检查玩家是否能够开火。如果可以，它会在所有客户端上播放射击动画，并使用提供的长度在摄像机位置和方向进行一条线的射线检测，以对其命中的角色造成伤害。如果没有弹药，它将仅在拥有客户端上播放声音。
- en: Edit `FPSCharacter` to support the new mappings for `Fire`, `Previous/Next Weapon`,
    `Pistol`, `Machine Gun`, and `Railgun`. In terms of variables, it needs to store
    the amount of ammo for each type, the currently equipped weapon, all of the weapons
    classes and spawned instances, the sound to play when it hits another player,
    and the sound when it changes weapons. In terms of functions, it needs to be able
    to equip/cycle/add weapons, manage ammo (add, remove, and get), handle when the
    character is damaged, play an anim montage on all of the clients, and play a sound
    on the owning client.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`FPSCharacter`以支持`Fire`、`Previous/Next Weapon`、`Pistol`、`Machine Gun`和`Railgun`的新映射。在变量方面，它需要存储每种类型的弹药数量，当前装备的武器，所有武器类和生成的实例，命中其他玩家时播放的声音，以及更换武器时的声音。在功能方面，它需要能够装备/循环/添加武器，管理弹药（添加、移除和获取），处理角色受伤时，在所有客户端上播放动画蒙太奇，并在拥有客户端上播放声音。
- en: 'Create `BP_Pistol` from `AWeapon`, place it on `Content\Weapons\Pistol`, and
    configure it with the following values:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeapon`创建`BP_Pistol`，将其放置在`Content\Weapons\Pistol`上，并使用以下值进行配置：
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼网格：`Content\Weapons\SK_Weapon`
- en: 'Material: `Content\Weapons\Pistol\M_Pistol`'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapons\Pistol\M_Pistol`
- en: 'Name: `Pistol Mk I`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`手枪 Mk I`
- en: 'Weapon Type: `Pistol`, Ammo Type: `Bullets`, Fire Mode: `Automatic`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类型：`手枪`，弹药类型：`子弹`，射击模式：`自动`
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `5.0`, Fire Rate: `0.5`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中扫描范围：`9999.9`，命中扫描伤害：`5.0`，射速：`0.5`
- en: 'Fire Anim Montage: `Content\Player\Animations\Pistol_Fire_Montage`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击动画蒙太奇：`Content\Player\Animations\Pistol_Fire_Montage`
- en: 'NoAmmoSound: `Content\Weapons\NoAmmo`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无弹药声音：`Content\Weapons\NoAmmo`
- en: 'Create `BP_MachineGun` from `AWeapon` and place it on `Content\Weapons\MachineGun`
    and configure it with the following values:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeapon`创建`BP_MachineGun`，并将其放置在`Content\Weapons\MachineGun`上，并使用以下值进行配置：
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼网格：`Content\Weapons\SK_Weapon`
- en: 'Material: `Content\Weapons\MachineGun\M_MachineGun`'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapons\MachineGun\M_MachineGun`
- en: 'Name: `Machine Gun Mk I`'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：`机枪 Mk I`
- en: 'Weapon Type: `Machine Gun`, Ammo Type: `Bullets`, Fire Mode: `Automatic`'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类型：`机枪`，弹药类型：`子弹`，射击模式：`自动`
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `5.0`, Fire Rate: `0.1`'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中扫描范围：`9999.9`，命中扫描伤害：`5.0`，射速：`0.1`
- en: 'Fire Anim Montage: `Content\Player\Animations\MachineGun_Fire_Montage`'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击动画蒙太奇：`Content\Player\Animations\MachineGun_Fire_Montage`
- en: 'NoAmmoSound: `Content\Weapons\NoAmmo`'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无弹药声音：`Content\Weapons\NoAmmo`
- en: 'Create `BP_Railgun` from `AWeapon` and place it on `Content\Weapons\Railgun`
    and configure it with the following values:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeapon`创建`BP_Railgun`，并将其放置在`Content\Weapons\Railgun`上，并使用以下值进行配置：
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼网格：`Content\Weapons\SK_Weapon`
- en: 'Material: `Content\Weapons\Railgun\M_Railgun`'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapons\Railgun\M_Railgun`
- en: 'Name: Railgun `Mk I`, Weapon Type: `Railgun`, AmmoType: `Slugs`, Fire Mode:
    `Single`'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：电磁炮`Mk I`，武器类型：`电磁炮`，弹药类型：`弹丸`，射击模式：`单发`
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `100.0`, Fire Rate: `1.5`'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中扫描范围：`9999.9`，命中扫描伤害：`100.0`，射速：`1.5`
- en: 'Fire Anim Montage: `Content\Player\Animations\Railgun_Fire_Montage`'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开火动画蒙太奇：`Content\Player\Animations\Railgun_Fire_Montage`
- en: 'No Ammo Sound: `Content\Weapons\NoAmmo`'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无弹药声音：`Content\Weapons\NoAmmo`
- en: 'Configure `BP_Player` with the following values:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下数值配置`BP_Player`：
- en: 'Weapon Classes (Index 0: `BP_Pistol`, Index 1: `BP_MachineGun`, Index 2: `BP_Railgun`).'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类（索引0：`BP_Pistol`，索引1：`BP_MachineGun`，索引2：`BP_Railgun`）。
- en: 'Hit Sound: `Content\Weapons\Hit`.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命中声音：`Content\Weapons\Hit`。
- en: 'Weapon Change Sound: `Content\Weapons\WeaponChange`.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器切换声音：`Content\Weapons\WeaponChange`。
- en: Make the mesh component block the visibility channel so it can be hit by the
    hitscans of the weapons.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使网格组件阻止可见性通道，以便可以被武器的hitscan命中。
- en: Edit `ABP_Player` to use a `Layered Blend Per Bone` node, with `Mesh Space Rotation
    Blend` enabled, on the `spine_01` bone so that the upper body animations use the
    Upper Body slot.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`ABP_Player`，使用`Layered Blend Per Bone`节点，在`spine_01`骨骼上启用`Mesh Space Rotation
    Blend`，以便上半身动画使用上半身插槽。
- en: 'Edit `UI_HUD` so that it displays a white dot crosshair in the middle of the
    screen and the current weapon and ammo count under the Health and Armor indicators:![Figure
    17.12: The expected result of the activity'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`UI_HUD`，使其在屏幕中央显示一个白色点十字准星，以及当前武器和弹药数量在健康和护甲指示器下方：![图17.12：活动的预期结果
- en: '](img/B16183_17_12.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_17_12.jpg)'
- en: 'Figure 17.12: The expected result of the activity'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.12：活动的预期结果
- en: The result should be a project where each client will have weapons with ammo
    and will be able to use them to fire at and damage other players. You will also
    be able to select weapons by using the *1*, *2*, and *3* keys and by using the
    mouse wheel up and down to select the previous and next weapon.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，其中每个客户端都将拥有带弹药的武器，并且能够使用它们来射击和伤害其他玩家。您还可以使用*1*、*2*和*3*键以及鼠标滚轮向上和向下来选择武器。
- en: Note
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: 'The solution to this activity can be found at: https://packt.live/338jEBx.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：https://packt.live/338jEBx。
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use RPCs to allow the server and the clients
    to execute logic on one another. We also learned how enumerations work in Unreal
    Engine 4 by using the `UENUM` macro and how to use bi-directional circular array
    indexing, which helps you iterate an array in both directions and loops around
    when you go beyond its index limits.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用RPC允许服务器和客户端在彼此上执行逻辑。我们还学习了在虚幻引擎4中如何使用`UENUM`宏以及如何使用双向循环数组索引，这有助于您在两个方向上迭代数组，并在超出其索引限制时循环。
- en: With the activity of this chapter complete, you'll have a basic playable game
    where players can shoot each other and switch weapons, but there is still more
    we can add to make it even more interesting.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章的活动后，您将拥有一个基本的可玩游戏，玩家可以互相射击和切换武器，但我们仍然可以添加更多内容，使游戏变得更加有趣。
- en: In the next chapter, we'll learn where the instances of the most common gameplay
    framework classes exist in multiplayer, as well as learn about the Player State
    and Game State classes, which we haven't covered yet. We'll also cover some new
    concepts in the game mode that are used in multiplayer matches, as well as some
    useful general-purpose, built-in functionality.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解最常见的游戏框架类的实例在多人游戏中存在的位置，以及了解我们尚未涵盖的Player State和Game State类。我们还将介绍一些在多人游戏中使用的游戏模式中的新概念，以及一些有用的通用内置功能。
