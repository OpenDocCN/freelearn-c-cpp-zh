- en: '*Chaper 1*: New C++20 Features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*: 新的C++20特性'
- en: This chapter concentrates on some of the more compelling features that C++20
    adds to the STL. You can use some of these right away. Others may need to wait
    for implementation in your favorite compiler. But in the long run, I expect you'll
    want to know about most of these features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要集中介绍C++20为STL添加的一些更具吸引力的特性。其中一些特性您可以立即使用。其他特性可能需要等待您喜欢的编译器实现。但从长远来看，我预计您会想了解这些特性中的大多数。
- en: There are a lot of new additions to the C++20 standard, far more than we could
    cover here. These are a few that I think will have long-term impact.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准新增了很多内容，远远超出了我们在这里所能涵盖的范围。以下是一些我认为将产生长期影响的特性。
- en: 'In this chapter we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Format text with the new `format` library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的`format`库格式化文本
- en: Use compile-time vectors and strings with `constexpr`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`constexpr`编译时向量和字符串
- en: Safely compare integers of different types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全比较不同类型的整数
- en: Use the "spaceship" operator `<=>` for three-way comparisons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“飞船”运算符`<=>`进行三路比较
- en: Easily find feature test macros with the `<version>` header
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`<version>`头文件轻松找到特性测试宏
- en: Create safer templates with concepts and constraints
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用概念和约束创建更安全的模板
- en: Avoid re-compiling template libraries with modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块避免重新编译模板库
- en: Create views into containers with ranges
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用范围创建容器视图
- en: This chapter aims to familiarize you with these new features in C++20, so you
    may use them in your own projects and understand them when you encounter them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在使您熟悉C++20中的这些新特性，以便您可以在自己的项目中使用它们，并在遇到它们时理解它们。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01](https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap01)。
- en: Format text with the new format library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的格式化库格式化文本
- en: Until now, if you wanted to format text, you could use either the legacy `printf`
    functions or the STL `iostream` library. Both have their strengths and flaws.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果您想格式化文本，可以使用传统的`printf`函数或STL的`iostream`库。两者都有其优点和缺点。
- en: The `printf`-based functions are inherited from C and have proven efficient,
    flexible, and convenient for over 50 years. The formatting syntax can look a bit
    cryptic, but it's simple enough once you get used to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`printf`的函数是从C继承而来的，并且经过50多年的证明，它们既高效、灵活又方便。格式化语法看起来可能有点晦涩，但一旦习惯了，就足够简单。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main weakness in `printf` is its lack of type safety. The common `printf()`
    function (and its relatives) use C's *variadic arguments* model to pass parameters
    to a formatter. This works great when it works, but it can cause serious problems
    when a parameter type doesn't match its corresponding format specifier. Modern
    compilers do as much type-checking as they can, but the model is inherently flawed
    and the protection can only go so far.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`的主要弱点是其缺乏类型安全。常见的`printf()`函数（及其相关函数）使用C的*可变参数*模型将参数传递给格式化器。当它起作用时，效果很好，但当参数类型与其对应的格式说明符不匹配时，可能会引起严重问题。现代编译器尽可能多地执行类型检查，但该模型本身有缺陷，保护作用有限。'
- en: The STL `iostream` library brings type safety at the expense of readability
    and run-time performance. The `iostream` syntax is unusual, yet familiar. It overloads
    the *bitwise left-shift operator* (`<<`) to allow a chain of objects, operands,
    and *formatting manipulators*, which produce the formatted output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: STL的`iostream`库以牺牲可读性和运行时性能为代价，带来了类型安全。`iostream`的语法不寻常，但熟悉。它重载了*位左移运算符*（`<<`），允许一系列对象、操作数和*格式化操作符*，从而生成格式化输出。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The weakness of `iostream` is its complexity, in both syntax and implementation.
    Building a formatted string can be verbose and obscure. Many of the formatting
    manipulators must be reset after use, or they create cascading formatting errors
    that can be difficult to debug. The library itself is vast and complex, resulting
    in code significantly larger and slower than its `printf` equivalent.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostream`的弱点在于其复杂度，无论是语法还是实现。构建格式化字符串可能既冗长又晦涩。许多格式化操作符在使用后必须重置，否则会创建级联的格式化错误，这可能导致难以调试。该库本身庞大而复杂，导致代码比其`printf`等效版本大得多且运行速度慢。'
- en: This dismal situation has left C++ programmers with little option but to choose
    between two flawed systems, until now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种令人沮丧的情况让C++程序员别无选择，只能在这两个有缺陷的系统之间做出选择，直到现在。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The new `format` library is in the `<format>` header. As of this writing, `format`
    is implemented only in the *MSVC* (Microsoft) compiler. By the time you read this,
    it should be available on more systems. Otherwise, you may use its reference implementation
    as a third-party library from `fmt.dev` ([j.bw.org/fmt](http://j.bw.org/fmt)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `format` 库位于 `<format>` 头文件中。截至本文写作时，`format` 仅在 *MSVC*（微软）编译器中实现。到你阅读本文时，它应该可以在更多系统上使用。否则，你可以从
    `fmt.dev`（[j.bw.org/fmt](http://j.bw.org/fmt)）作为第三方库使用其参考实现。
- en: 'The `format` library is modeled on the `str.format()` method from Python 3\.
    *Format strings* are substantially the same as those in Python and, for most purposes,
    they should be interchangeable. Let''s examine some simple examples:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 库是基于 Python 3 中的 `str.format()` 方法构建的。*格式化字符串*与 Python 中的格式化字符串基本相同，并且在大多数情况下可以互换。让我们看看一些简单的例子：'
- en: 'In its simplest form, the `format()` function takes a `string_view` format
    string and a *variadic parameter pack* of arguments. It returns a `string`. Its
    function signature looks like this:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其最简单形式中，`format()` 函数接受一个 `string_view` 格式字符串和一个 *可变参数包* 的参数。它返回一个 `string`。其函数签名看起来像这样：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `format()` function returns a `string` representation of virtually any
    type or value. For example:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format()` 函数返回几乎任何类型或值的 `string` 表示形式。例如：'
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *format string* uses braces `{}` as a placeholder. With no *format specifiers*,
    the braces are effectively a type-safe *placeholder* which will convert a value
    of any compatible type to a reasonable string representation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式化字符串* 使用花括号 `{}` 作为占位符。如果没有 *格式说明符*，花括号实际上是一个类型安全的 *占位符*，它将任何兼容类型的值转换为合理的字符串表示形式。'
- en: 'You can include multiple placeholders in your format string, like this:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在格式化字符串中包含多个占位符，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can specify the order of the replacement values. This could be useful for
    internationalization:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以指定替换值的顺序。这可能对国际化很有用：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can align values, left (`<`), right (`>`), or center (`^`), with or without
    a fill character:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以左对齐（`<`）、右对齐（`>`）或居中对齐（`^`）值，可以带或不带填充字符：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can set the decimal precision of values:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以设置值的十进制精度：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And much, much more.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多更多。
- en: It's a rich and complete formatting specification that provides the type-safety
    of `iostream` with the performance and simplicity of `printf`, for the best of
    both worlds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个丰富且完整的格式化规范，它提供了 `iostream` 的类型安全，以及 `printf` 的性能和简单性，实现了两者的最佳结合。
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `format` library does not yet include a `print()` function, which is planned
    for *C++23*. The `format()` function itself returns a `string` object. So, if
    you want to print the string, you'll need to use either `iostream` or `cstdio`.
    (Sad face.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`format` 库尚未包含 `print()` 函数，该函数计划在 *C++23* 中实现。`format()` 函数本身返回一个 `string`
    对象。因此，如果你想打印字符串，你需要使用 `iostream` 或 `cstdio`。 (悲伤的表情。)'
- en: 'You can print the string using `iostream`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `iostream` 打印字符串：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or you may use `cstdio`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你也可以使用 `cstdio`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Neither is ideal, but it's not very hard to write a simple `print()` function.
    And we can use this process to understand a bit of the `format` library's inner
    workings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不理想，但编写一个简单的 `print()` 函数并不困难。我们可以通过这个过程了解 `format` 库的一些内部工作原理。
- en: 'Here''s a simple implementation of a `print()` function using the `format`
    library:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `format` 库实现的 `print()` 函数的一个简单示例：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This uses the same arguments as the `format()` function. The first argument
    is a `string_view` object for the format string. This is followed by a variadic
    parameter pack for the arguments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用与 `format()` 函数相同的参数。第一个参数是格式字符串的 `string_view` 对象。随后是一个参数的可变参数包。
- en: The `make_format_args()` function takes the parameter pack and returns an object
    that contains *type-erased values* suitable for formatting. This object is then
    passed to `vformat()`, which returns a `string` suitable for printing. We use
    `fputs()` to print the value to the console because it's far more efficient than
    `cout`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_format_args()` 函数接受参数包并返回一个包含 *类型擦除值* 的对象，这些值适合格式化。然后，该对象被传递给 `vformat()`，它返回一个适合打印的
    `string`。我们使用 `fputs()` 将值打印到控制台，因为它比 `cout` 效率要高得多。'
- en: 'We can now use this `print()` function in place of the `cout << format()` combination:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个 `print()` 函数代替 `cout << format()` 组合：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you eventually get a C++23 complier with `print()` support, you should
    be able to simply replace the above `print()` template function definition with
    `using std::print;` and all the `print()` calls should continue to work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您最终获得一个支持`print()`的C++23编译器时，您应该能够简单地用`using std::print;`替换上面的`print()`模板函数定义，并且所有的`print()`调用都应该继续工作。
- en: There's more…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: It's nice to have the ability to format strings and primitives, but for the
    `format` library to be fully functional, it needs customization to work with your
    own classes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 能够格式化字符串和原始数据很有用，但为了让`format`库完全功能，它需要自定义以与您自己的类一起工作。
- en: 'For example, here''s a simple `struct` with two members: a *numerator* and
    *denominator*. We would like this to print as a fraction:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个简单的`struct`结构，包含两个成员：一个**分子**和一个**分母**。我们希望它以分数的形式打印出来：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When I compile this, it leads to a cascade of errors to the effect of, "No user-defined
    conversion operator…". Cool. So, let's fix it!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编译这段代码时，会出现一系列错误，效果类似于“没有用户定义的转换操作符……”。不错。那么，让我们来修复它！
- en: When the `format` system encounters an object for *conversion*, it looks for
    a *specialization* of a `formatter` object with the corresponding type. Standard
    specializations are included for common objects such as strings and numbers and
    such.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`format`系统遇到一个需要进行**转换**的对象时，它会寻找与相应类型对应的`formatter`对象的**特化**。标准特化包括字符串和数字等常见对象。
- en: 'It''s quite simple to create a specialization for our `Frac` type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的`Frac`类型创建一个特化相当简单：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This `formatter` specialization is a class with two short template functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`formatter`特化是一个包含两个短模板函数的类：
- en: The `parse()` function parses the *format string* from after the colon (or,
    if there is no colon, after the opening brace) up to but not including the closing
    brace. (In other words, the part that specifies the type of the object.) It takes
    a `ParseContext` object and returns an iterator. For our purposes, we can just
    return the `begin()` iterator because we don't need any new syntax for our *type*.
    You will rarely need to put anything else here.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse()`函数解析冒号（或如果没有冒号，则在开括号之后）之后的**格式字符串**，直到但不包括闭括号。（换句话说，指定对象类型的部分。）它接受一个`ParseContext`对象并返回一个迭代器。对于我们的目的，我们只需返回`begin()`迭代器，因为我们不需要为我们的**类型**添加任何新语法。您很少需要在这里放置其他内容。'
- en: The `format()` function takes a `Frac` object and a `FormatContext` object.
    It returns an *end iterator*. The `format_to()` function makes this easy. It takes
    an iterator, a format string, and a parameter pack. In this case, the parameter
    pack is the two properties of our `Frac` class, the numerator and denominator.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format()`函数接受一个`Frac`对象和一个`FormatContext`对象。它返回一个**结束迭代器**。`format_to()`函数使这变得简单。它接受一个迭代器、一个格式字符串和一个参数包。在这种情况下，参数包是我们`Frac`类的两个属性，即分子和分母。'
- en: All we need to do here is provide a simple format string `"{0}/{1}"` and the
    numerator and denominator values. (The `0` and `1` indicate the position of the
    parameters. They're not strictly necessary but they could come in handy later.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要提供一个简单的格式字符串`"{0}/{1}"`以及分子和分母的值。（`0`和`1`表示参数的位置。它们不是必需的，但将来可能会有用。）
- en: 'Now that we have a specialization for `Frac`, we can pass our object to `print()`
    to get a readable result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`Frac`创建了一个特化，我们可以将我们的对象传递给`print()`以获得可读的结果：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The C++20 `format` library solves a long-standing problem by providing a type-safe
    text formatting library that is both efficient and convenient.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的`format`库通过提供一个既高效又方便的类型安全文本格式化库来解决了一个长期存在的问题。
- en: Use compile-time vectors and strings with constexpr
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`constexpr`编译时向量和字符串
- en: C++20 allows the use of `constexpr` in several new contexts. This provides improved
    efficiency, in that these things may be evaluated at compile time, instead of
    run time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C++20允许在多个新的上下文中使用`constexpr`。这提供了改进的效率，因为这些事情可以在编译时而不是运行时进行评估。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'The specification includes the ability to use `string` and `vector` objects
    in `constexpr` context. It''s important to note that these objects may not themselves
    be declared `constexpr`, but they may be used in a compile-time context:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范包括在`constexpr`上下文中使用`string`和`vector`对象的能力。重要的是要注意，这些对象本身可能不是`constexpr`声明的，但它们可以在编译时上下文中使用：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also use algorithms in `constexpr` context:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`constexpr`上下文中使用算法：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result of the `accumulate` algorithm is available at compile time and in
    `constexpr` context.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`算法的结果在编译时和`constexpr`上下文中都是可用的。'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The `constexpr` specifier declares a variable or function that may be *evaluated
    at compile time.* Before C++20, this was limited to objects initialized with a
    literal value, or a function within limited constraints. C++17 allowed a somewhat
    expanded use and C++20 expands it further.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr` 修饰符声明了一个可能在编译时评估的变量或函数。在 C++20 之前，这仅限于使用字面值初始化的对象，或者是在有限约束内的函数。C++17
    允许有某种程度的扩展使用，而 C++20 进一步扩展了它。'
- en: As of C++20, the STL `string` and `vector` classes now have `constexpr`-qualified
    constructors and destructors, which allow them to be invoked at compile time.
    This also means that the memory allocated for the `string` or `vector` object
    *must be freed at compile time.*
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C++20，STL 的 `string` 和 `vector` 类现在有了 `constexpr` 修饰的构造函数和析构函数，这使得它们可以在编译时调用。这也意味着为
    `string` 或 `vector` 对象分配的内存 *必须在编译时释放*。
- en: 'For example, this `constexpr` function, which returns a `vector`, will compile
    without error:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个返回`vector`的`constexpr`函数将无错误编译：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But if you try to use the result in a run-time context, you will get an error
    about memory that was allocated during constant evaluation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果在运行时环境中尝试使用该结果，你将得到一个关于在常量评估期间分配的内存的错误：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because the `vector` object was allocated *and freed* during compilation.
    So, the object is no longer available at run time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`vector`对象是在编译期间分配和释放的。因此，该对象在运行时不再可用。
- en: 'On the other hand, you can use some `constexpr`-qualified methods from the
    `vector` object, such as `size()`, at run time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以在运行时使用`vector`对象的某些`constexpr`修饰的方法，例如`size()`：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the `size()` method is `constexpr`-qualified, the expression can be
    evaluated at compile time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`size()`方法是`constexpr`修饰的，表达式可以在编译时评估。
- en: Safely compare integers of different types
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地比较不同类型的整数
- en: 'Comparing different types of integers may not always produce the expected results.
    For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 比较不同类型的整数可能不会总是产生预期的结果。例如：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You may expect this code to print `true`, and that's understandable. -3 is usually
    less than 7\. But it will print `false`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望这段代码打印 `true`，这是可以理解的。-3 通常小于 7。但它会打印 `false`。
- en: The problem is that `x` is signed and `y` is unsigned. The standardized behavior
    is to convert the signed type to unsigned for the comparison. That seems counterintuitive,
    doesn't it? Indeed, you cannot reliably convert an unsigned value to a signed
    value of the same size, because a signed integer uses *two's complement* representation
    (which uses the most significant bit as a sign). Given the same sized integer,
    the maximum signed value is half that of an unsigned value. Using this example,
    if your integers are 32-bits, -3 (signed) becomes `FFFF FFFD` (hexadecimal), or
    4,294,967,293 (unsigned decimal), which is *not less than 7*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`x`是有符号的，而`y`是无符号的。标准化的行为是将有符号类型转换为无符号类型进行比较。这似乎有些反直觉，不是吗？确实，你不能可靠地将无符号值转换为相同大小的有符号值，因为有符号整数使用二进制补码表示（它使用最高位作为符号）。对于相同大小的整数，最大有符号值是无符号值的一半。使用这个例子，如果你的整数是32位，-3（有符号）变为`FFFF
    FFFD`（十六进制），或4,294,967,293（无符号十进制），这并不是小于7。
- en: Some compilers may issue a warning when you try to compare signed with unsigned
    integer values, but most do not.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器在尝试比较有符号和无符号整数值时可能会发出警告，但大多数不会。
- en: The C++20 standard includes a set of integer-safe comparison functions in the
    `<utility>` header.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准在 `<utility>` 头文件中包含了一组整数安全的比较函数。
- en: How to do it…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The new integer comparison functions are found in the `<utility>` header. They
    each take two arguments, which correspond with the left- and right-hand sides
    of the operator.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新的整数比较函数可以在 `<utility>` 头文件中找到。它们各自接受两个参数，对应于运算符的左右两侧。
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `cmp_less()` function gives us the result we expect. -3 is less than 7 and
    the program now prints `true`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp_less()` 函数给出了我们期望的结果。-3 小于 7，程序现在打印 `true`。'
- en: 'The `<utility>` header provides a full complement of integer comparison functions.
    Assuming our values for `x` and `y`, we get these comparisons:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`<utility>` 头文件提供了完整的整数比较函数。假设我们的 `x` 和 `y` 的值，我们得到以下比较：'
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here''s the sample implementation of the `cmp_less()` function from the C++20
    standard, to give you a more complete picture of how it works:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是C++20标准中`cmp_less()`函数的示例实现，以给你一个更完整的关于其工作方式的了解：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `UT` and `UU` aliases are declared as `make_unsigned_t`, a useful helper
    type introduced with C++17\. This allows safe conversions of signed to unsigned
    types.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`UT` 和 `UU` 别名被声明为 `make_unsigned_t`，这是一个在 C++17 中引入的有用的辅助类型。这允许安全地将有符号类型转换为无符号类型。'
- en: The function first tests if both arguments are either signed or unsigned. If
    so, it returns a simple comparison.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先测试两个参数是否都是有符号或无符号。如果是这样，它返回一个简单的比较。
- en: It then tests if either side is signed. If that signed value is less than zero,
    it can return `true` or `false` without performing a comparison. Otherwise, it
    converts the signed value to unsigned and returns the comparison.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它测试任一边是否为有符号。如果该有符号值小于零，它可以不执行比较就返回 `true` 或 `false`。否则，它将有符号值转换为无符号并返回比较结果。
- en: Similar logic is applied to each of the other comparison functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的逻辑应用于每个其他比较函数。
- en: Use the "spaceship" operator <=> for three-way comparisons
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“飞船”运算符 `<=>` 进行三向比较
- en: The *three-way comparison* operator (`<=>`), commonly called the *spaceship*
    operator because it looks like a flying saucer in profile, is new in C++20\. You
    may wonder, what's wrong with the existing six comparison operators? Nothing at
    all, and you will continue using them. The purpose of the spaceship is to provide
    a unified comparison operator for objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**三向比较**运算符 (`<=>`)，通常称为**飞船**运算符，因为从侧面看它像一只飞碟，是 C++20 中的新特性。你可能想知道，现有的六个比较运算符有什么问题？根本没问题，你将继续使用它们。飞船的目的在于为对象提供一个统一的比较运算符。'
- en: 'The common two-way comparison operators return one of two states, `true` or
    `false`, according to the result of the comparison. For example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的双向比较运算符根据比较结果返回两种状态之一，`true` 或 `false`。例如：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `a < b` expression uses the *less-than comparison* operator (`<`) to test
    if `a` is less than `b`. The comparison operator returns `true` if the condition
    is satisfied, or `false` if not. In this case it returns `true` because 7 is less
    than 42.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`a < b` 表达式使用**小于比较**运算符 (`<`) 来测试 `a` 是否小于 `b`。如果条件满足，比较运算符返回 `true`，如果不满足，则返回
    `false`。在这种情况下，它返回 `true`，因为 7 小于 42。'
- en: The three-way comparison works differently. It returns one of three states.
    The spaceship operator will return a value equal to `0` if the operands are equal,
    *negative* if the left-hand operand is less than the right-hand operand, or *positive*
    if the left-hand operand is greater than the right-hand operator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 三向比较的工作方式不同。它返回三种状态之一。如果操作数相等，飞船运算符将返回等于 `0` 的值；如果左操作数小于右操作数，则返回**负值**；如果左操作数大于右操作数，则返回**正值**。
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The returned value is *not an integer*. It's an object from the `<compare>`
    header that compares with `0`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值**不是一个整数**。它是一个来自 `<compare>` 头文件的比较对象，与 `0` 进行比较。
- en: If the operands have an integral type, the operator returns a `strong_ordering`
    object from the `<compare>` library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数具有整型，运算符返回 `<compare>` 库中的 `strong_ordering` 对象。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the operands have a floating-point type, the operator returns a `partial_ordering`
    object:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数具有浮点类型，运算符返回一个 `partial_ordering` 对象：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These objects are designed to compare against a literal zero (`0`) with conventional
    comparison operators (for example, `(a <=> b) < 0`). This allows the results of
    the three-way comparison to be more precise than conventional comparisons.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象被设计成使用传统的比较运算符（例如，`(a <=> b) < 0`）与字面量零 (`0`) 进行比较。这使得三向比较的结果比传统比较更精确。
- en: If all of that seems a bit complicated, that's okay. For most applications you
    will never use the spaceship operator directly. Its real power is in its application
    as a unified comparison operator for objects. Let's dig a bit deeper.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些都显得有些复杂，那没关系。对于大多数应用，你永远不会直接使用飞船运算符。它的真正力量在于它作为对象统一比较运算符的应用。让我们深入探讨一下。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s look at a simple class that encapsulates an integer and provides comparison
    operators:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的类，它封装了一个整数并提供比较运算符：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's not uncommon to see a list of comparison operator overloads like this.
    In fact, it should be even more complicated with *non-member friends* that work
    with objects on either side of the operator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这样的比较运算符重载列表并不罕见。实际上，它应该与**非成员友元**更复杂，这些友元与运算符两边的对象一起工作。
- en: 'With the new spaceship operator, all of this can be accomplished with one overload:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的飞船运算符，所有这些都可以通过一个重载来完成：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that we need to include the `<compare>` header for the three-way operator
    return types. Now we can declare some variables and test them with comparisons:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要包含 `<compare>` 头文件以支持三路运算符的返回类型。现在我们可以声明一些变量并通过比较来测试它们：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The compiler will automatically favor the `<=>` operator for each of the comparisons.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将自动优先选择 `<=>` 运算符进行每个比较。
- en: Because the default `<=>` operator is already `constexpr` safe, we don't need
    to declare it as such in our member function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因为默认的 `<=>` 运算符已经是 `constexpr` 安全的，所以我们不需要在我们的成员函数中声明它为 `constexpr`。
- en: How it works…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `operator<=>` overload takes advantage of a new C++20 concept, *rewritten
    expressions*. During overload resolution, the compiler rewrites the expression
    according to a set of rules. For example, if we write `a < b`, the compiler will
    rewrite it to `(a <=> b < 0)` so that it works with our member operator. The compiler
    will rewrite every relevant comparison expression for the `<=>` operator, where
    we haven't included a more specific operator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator<=>` 重载利用了 C++20 的新概念，*重写表达式*。在重载解析过程中，编译器根据一组规则重写表达式。例如，如果我们写 `a
    < b`，编译器将重写它为 `(a <=> b < 0)`，以便与我们的成员运算符一起工作。编译器将重写 `<=>` 运算符的每个相关比较表达式，其中我们没有包含更具体的运算符。'
- en: In fact, we no longer need a non-member function to handle comparisons with
    a compatible type on the left-hand side. The compiler will *synthesize* an expression
    that works with the member operator. For example, if we write `42 > a`, the compiler
    will synthesize an expression with the operators reversed `(a <=> 42 < 0)` so
    that it works with our member operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们不再需要一个非成员函数来处理与左侧兼容类型的比较。编译器将 *合成* 一个与成员运算符一起工作的表达式。例如，如果我们写 `42 > a`，编译器将合成一个反转运算符的表达式
    `(a <=> 42 < 0)`，以便与我们的成员运算符一起工作。
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `<=>` operator has *higher precedence* than the other comparison operators
    so it will always evaluate first. All comparison operators evaluate left-to-right.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`<=>` 运算符的优先级高于其他比较运算符，因此它总是首先评估。所有比较运算符都是从左到右评估的。'
- en: There's more…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'The default operator will work just fine with a wide variety of classes, including
    classes with multiple numeric members of different types:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认运算符可以与各种类一起正常工作，包括具有多个不同类型数值成员的类：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But what if you have a more complex type? Here''s an example of a simple fraction
    class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有一个更复杂的数据类型呢？这里有一个简单的分数类的例子：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case we need to define the `operator<=>` overload because our data members
    are not stand-alone scalar values. It's still quite simple and it works just as
    well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要定义 `operator<=>` 重载，因为我们的数据成员不是独立的标量值。这仍然相当简单，并且效果很好。
- en: Notice that we also needed an `operator==` overload. This is because the expression
    rewrite rules will not rewrite `==` and `!=` with a custom `operator<=>` overload.
    You only need to define `operator==`. The compiler will rewrite the `!=` expression
    as needed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还需要一个 `operator==` 重载。这是因为表达式重写规则不会重写带有自定义 `operator<=>` 重载的 `==` 和 `!=`。你只需要定义
    `operator==`。编译器将根据需要重写 `!=` 表达式。
- en: 'Now we can define some objects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一些对象：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And we can test them with normal comparison operators, as expected:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用正常的比较运算符来测试它们，正如预期的那样：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The power of the spaceship operator is in its ability to streamline comparison
    overloads in your classes. It improves both simplicity and efficiency when compared
    to overloading each operator independently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 空间船运算符的力量在于其简化类中比较重载的能力。与独立重载每个运算符相比，它提高了简单性和效率。
- en: Easily find feature test macros with the <version> header
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `<version>` 头文件轻松找到特性测试宏
- en: C++ has provided some form of feature test macros for as long as new features
    have been added. Beginning with C++20, the process is standardized, and all *library
    feature* test macros have been added to the `<version>` header. This will make
    it much easier to test for a new feature in your code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 在添加新功能的同时，一直提供了一些形式的特性测试宏。从 C++20 开始，这个过程被标准化，所有 *库特性* 测试宏都已添加到 `<version>`
    头文件中。这将使测试代码中的新功能变得更加容易。
- en: This is a useful feature and it's very simple to use.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的特性，并且使用起来非常简单。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'All feature test macros begin with the prefix `__cpp_`. Library features begin
    with `__cpp_lib_`. Language feature test macros are typically defined by the compiler.
    Library feature test macros are defined in the new `<version>` header. Use them
    as you would any other preprocessor macro:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有功能测试宏都以前缀 `__cpp_` 开头。库功能以 `__cpp_lib_` 开头。语言功能测试宏通常由编译器定义。库功能测试宏在新 `<version>`
    头文件中定义。你可以像使用任何其他预处理器宏一样使用它们：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In some cases, you can use the `__has_include` preprocessor operator (introduced
    in C++17) to test for the existence of an include file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以使用 `__has_include` 预处理器运算符（自 C++17 引入）来测试包含文件的存在。
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can use `__has_include` to test for the existence of any header file. Because
    it's a preprocessor directive, it doesn't require a header of its own to work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `__has_include` 来测试任何头文件的存在。因为它是一个预处理器指令，所以它不需要自己的头文件来工作。
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Generally, you can use the feature test macros by testing for a non-zero value
    using `#ifdef` or `#if defined`. Each of the feature test macros has a non-zero
    value that corresponds to the year and month it was accepted by the standards
    committee. For example, the `__cpp_lib_three_way_comparison` macro has a value
    of `201907`. This means that it was accepted in July 2019.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过使用 `#ifdef` 或 `#if defined` 测试非零值来使用功能测试宏。每个功能测试宏都有一个非零值，对应于它被标准委员会接受的那一年和一个月。例如，`__cpp_lib_three_way_comparison`
    宏的值为 `201907`。这意味着它在 2019 年 7 月被接受。
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The value of the macro may be useful in some obscure cases where a feature has
    changed and you're dependent upon the changes. For most purposes, you can safely
    ignore the value and just test for non-zero with `#ifdef`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的值在某些不常见的情况下可能很有用，在这些情况下，功能已更改，而你依赖于这些更改。对于大多数目的，你可以安全地忽略值，只需使用 `#ifdef` 测试非零值即可。
- en: Several websites maintain a complete list of feature test macros. I tend to
    use *cppreference* ([https://j.bw.org/cppfeature](https://j.bw.org/cppfeature))
    but there are others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 几个网站维护了一个功能测试宏的完整列表。我倾向于使用 *cppreference* ([https://j.bw.org/cppfeature](https://j.bw.org/cppfeature))，但还有其他网站。
- en: Create safer templates with concepts and constraints
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用概念和约束创建更安全的模板
- en: 'Templates are great for writing code that works with different types. For example,
    this function will work with any numeric type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模板非常适合编写与不同类型一起工作的代码。例如，这个函数将适用于任何数值类型：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But what happens when you try to call it with a non-numeric type?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你尝试用非数值类型调用它时会发生什么呢？
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This compiles and runs without error, but the result is unpredictable. In fact,
    the call is dangerous and it could easily crash or become a vulnerability. I would
    much prefer the compiler generate an error message so I can fix the code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序编译和运行没有错误，但结果不可预测。实际上，这个调用是危险的，它很容易崩溃或成为漏洞。我更希望编译器生成错误信息，这样我就可以修复代码。
- en: 'Now, with concepts, I can write it like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了概念，我可以这样写：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `requires` keyword is new for C++20\. It applies constraints to a template.
    `Numeric` is the name of a *concept* that only accepts integer and floating-point
    types. Now, when I compile this code with a non-numeric parameter, I get a reasonable
    compiler error:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires` 关键字是 C++20 中的新特性。它将约束应用于模板。`Numeric` 是一个只接受整数和浮点类型的 *概念* 的名称。现在，当我用非数值参数编译这段代码时，我得到了一个合理的编译器错误：'
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Error messages like this are far more useful than most compiler errors.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的错误信息比大多数编译器错误更有用。
- en: Let's take a closer look at how to use concepts and constraints in your code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看如何在代码中使用概念和约束。
- en: How to do it…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'A concept is simply a named constraint. The `Numeric` concept from above looks
    like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 概念只是一个命名的约束。上面的 `Numeric` 概念看起来像这样：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This *concept* requires a type `T`, which satisfies either the `std::integral`
    or `std::floating_point` predefined concepts. These concepts are included in the
    `<concepts>` header.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *概念* 需要一个满足 `std::integral` 或 `std::floating_point` 预定义概念的类型 `T`。这些概念包含在
    `<concepts>` 头文件中。
- en: 'Concepts and constraints may be used in class templates, function templates,
    or variable templates. We''ve seen a constrained function template, now here''s
    a simple constrained class template example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和约束可用于类模板、函数模板或变量模板。我们已经看到了一个约束函数模板的例子，现在这里有一个简单的约束类模板示例：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And here''s a simple variable template example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个简单的变量模板示例：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can use concepts and constraints on any template. Let's consider some further
    examples. We'll be using function templates in these examples for simplicity.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何模板上使用概念和约束。让我们考虑一些进一步的例子。为了简单起见，我们将使用函数模板。
- en: A constraint may use concepts or *type traits* to evaluate the characteristics
    of a type. You may use any of the type traits found in the `<type_traits>` header,
    so long as it returns a `bool`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束可以使用概念或 *类型特性* 来评估类型的特征。你可以使用 `<type_traits>` 头文件中找到的任何类型特性，只要它返回一个 `bool`。
- en: 'For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `requires` keyword is new in C++20\. It introduces a constraint for the
    template arguments. In this example, the constraint expression tests the template
    argument against the type trait `is_integral`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires` 关键字是 C++20 中新增的。它为模板参数引入了一个约束。在这个例子中，约束表达式测试模板参数是否满足类型特性 `is_integral`。'
- en: 'You can use one of the pre-defined traits found in the `<type_traits>` header,
    or you can define your own, just as you would a template variable. For use in
    constraints, the variable must return `constexpr bool`. For example:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `<type_traits>` 头文件中找到的预定义特性，或者你可以定义自己的，就像定义一个模板变量一样。用于约束的变量必须返回 `constexpr
    bool`。例如：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This defines a type trait called `is_gt_byte`. This trait uses the `sizeof`
    operator to test if the type `T` is larger than 1 byte.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `is_gt_byte` 的类型特性。这个特性使用 `sizeof` 运算符来测试类型 `T` 是否大于 1 字节。
- en: 'A *concept* is simply a named set of constraints. For example:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *概念* 简单地是一个命名的约束集合。例如：
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This defines a concept named `Numeric`. It uses our `is_gt_byte` constraint,
    along with the `floating_point` and `integral` concepts from the `<concepts>`
    header. We can use it to constrain a template to only accept numeric types that
    are greater than 1 byte in size.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `Numeric` 的概念。它使用我们的 `is_gt_byte` 约束，以及 `<concepts>` 头文件中的 `floating_point`
    和 `integral` 概念。我们可以用它来约束模板，使其只接受大于 1 字节大小的数值类型。
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You'll notice that I've applied the constraint in the template declaration,
    rather than on a separate line in a `requires` expression. There are a few ways
    to apply a concept. Let's look at how this works.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我在模板声明中应用了约束，而不是在 `requires` 表达式的单独一行上。有几种方法可以应用一个概念。让我们看看这是如何工作的。
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are several different ways you can apply a concept or constraint:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种不同的方式应用一个概念或约束：
- en: 'You can apply a concept or constraint with the `requires` keyword:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `requires` 关键字应用一个概念或约束：
- en: '[PRE53]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can apply a concept in the template declaration:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在模板声明中应用一个概念：
- en: '[PRE54]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can use the `requires` keyword in a function signature:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在函数签名中使用 `requires` 关键字：
- en: '[PRE55]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or you can use a concept in a parameter list for an abbreviated function template:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以在函数模板的参数列表中使用一个概念以缩写形式：
- en: '[PRE56]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For many purposes, choosing one of these strategies may be a matter of style.
    And there are circumstances where one may be a better option than another.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多目的，选择这些策略之一可能只是风格问题。而且，在某些情况下，一个可能比另一个更好。
- en: There's more…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The standard uses the terms *conjunction*, *disjunction*, and *atomic*, to describe
    types of expressions that can be used to construct a constraint. Let's define
    these terms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 标准使用术语 *合取*、*析取* 和 *原子* 来描述可以用来构造约束的表达式类型。让我们定义这些术语。
- en: You can combine concepts and constraints using the `&&` and `||` operators.
    These combinations are called *conjunctions* and *disjunctions*, respectively.
    You can think of them as logical *AND* and *OR*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `&&` 和 `||` 运算符组合概念和约束。这些组合分别称为 *合取* 和 *析取*。你可以把它们看作逻辑的 *AND* 和 *OR*。
- en: 'A *constraint conjunction* is formed by using the `&&` operator with two constraints:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `&&` 运算符和两个约束形成了一个 *约束合取*。
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A conjunction is satisfied only if both sides of the `&&` operator are satisfied.
    It is evaluated left-to-right. The operands of a conjunction are short-circuited,
    that is, if the left side constraint is not satisfied the right side will not
    be evaluated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与（`&&`）运算符仅在两侧都满足时才成立。它的计算顺序是从左到右。逻辑与的运算数是短路操作，也就是说，如果左侧的约束不满足，则不会评估右侧。
- en: 'A *constraint disjunction* is formed by using the `||` operator with two constraints:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `||` 运算符和两个约束形成了一个 *约束析取*。
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A disjunction is satisfied if either side of the `||` operator is satisfied.
    It is evaluated left-to-right. The operands of a conjunction are short-circuited,
    that is, if the left side constraint is satisfied the right side will not be evaluated.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`||`运算符的任一侧被满足，则析取成立。它是从左到右评估的。合取的运算符是短路，也就是说，如果左侧约束成立，则不会评估右侧。
- en: An *atomic constraint* is an expression that returns a `bool` type, which cannot
    be further decomposed. In other words, it is not a conjunction or a disjunction.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子约束*是一个返回`bool`类型、不能进一步分解的表达式。换句话说，它不是合取或析取。'
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can also use the logical`!` (*NOT*) operator in an atomic constraint:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在原子约束中使用逻辑`!`（*非*）运算符。
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As expected, the `!` operator inverts the value of the `bool` expression to
    the right of the `!`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`!`运算符将右侧的`bool`表达式的值取反。
- en: 'Of course, we can combine all these expression types into a larger expression.
    We see examples of each of these constraint expressions in the following example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将这些表达式类型组合成更大的表达式。在以下示例中，我们可以看到每种约束表达式都有示例。
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's break this down. The sub-expression, `(integral<T>` `floating_point<T>)`
    is a *disjunction*. The sub-expression, `is_gt_byte<T>` `(`…`)` is a *conjunction*.
    And each of the sub-expressions `integral<T>`, `floating_point<T>`, and `is_gt_byte<T>`,
    are *atomic*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。子表达式`(integral<T>` `floating_point<T>)`是一个*析取*。子表达式`is_gt_byte<T>` `(`…`)`是一个*合取*。而每个子表达式`integral<T>`、`floating_point<T>`和`is_gt_byte<T>`都是*原子*的。
- en: These distinctions are mostly for descriptive purposes. While it's good to understand
    the details, as you write your code, it's safe to think of them as simple logical
    `||`, `&&`, and `!` operators.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区别主要是为了描述目的。虽然了解细节是好的，但在编写代码时，可以安全地将它们视为简单的逻辑`||`、`&&`和`!`运算符。
- en: Concepts and constraints are a welcome addition to the C++ standard and I'm
    looking forward to using them in my future projects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 概念和约束是C++标准的受欢迎的补充，我期待在未来的项目中使用它们。
- en: Avoid re-compiling template libraries with modules
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用模块重新编译模板库
- en: Header files have been around since the very beginning of the C language. Originally,
    they were mainly used for *text substitution macros* and linking *external symbols*
    between translation units. With the introduction of templates, C++ leveraged header
    files to carry actual code. Because templates need to be recompiled for changes
    in specializations, we've been carrying them around in header files for many years.
    As the STL continues to grow over the years, these header files have grown as
    well. The situation has become unwieldy and is no longer scalable for the future.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件自从C语言一开始就存在了。最初，它们主要用于*文本替换宏*和在不同翻译单元之间链接*外部符号*。随着模板的引入，C++利用头文件来携带实际代码。因为模板需要为特化的变化重新编译，所以我们已经很多年都在头文件中携带它们。随着STL在多年来的持续增长，这些头文件也相应地增长。这种状况已经变得难以管理，并且不再适合未来的扩展。
- en: Header files typically contain a lot more than templates. They often contain
    configuration macros and other symbols that are required for system purposes,
    but not useful for the application. As the number of headers grows, the number
    of opportunities for symbol collisions grows as well. This is even more problematic
    when you consider the abundance of macros, which are not subject to namespace
    restrictions nor any form of type safety.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件通常包含比模板多得多的内容。它们通常包含配置宏和其他用于系统目的但不对应用户的符号。随着头文件数量的增加，符号冲突的机会也增加了。考虑到宏的丰富性，这是一个更大的问题，因为宏不受命名空间限制，也不受任何形式的安全类型的影响。
- en: C++20 addresses this problem with *modules*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: C++20通过*模块*解决了这个问题。
- en: How to do it…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You may be used to creating header files like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能习惯于创建如下所示的头文件：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This minimalist example illustrates several of the problems that modules address.
    The `BW_MATH` symbol is used as an *include guard*. Its only purpose is to prevent
    the header file from being included more than once, yet its symbol is carried
    throughout the translation unit. When you include this header in your source file,
    it may look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小化示例说明了模块解决的一些问题。`BW_MATH`符号被用作*包含保护器*。它的唯一目的是防止头文件被多次包含，但它的符号在整个翻译单元中都被携带。当你将这个头文件包含到源文件中时，它可能看起来像这样：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that `BW_MATH` symbol is available to every other header you've included,
    and every header included by the other headers, and on and on. That's a lot of
    opportunities for collision. And keep in mind, the compiler cannot check for these
    collisions. They're macros. That means they're translated by the preprocessor
    before the compiler ever has a chance to see them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `BW_MATH` 符号对包含的每个其他头文件以及由其他头文件包含的每个头文件都可用。这有很多机会发生冲突。而且记住，编译器无法检查这些冲突。它们是宏。这意味着在编译器有机会看到它们之前，它们就被预处理器翻译了。
- en: 'Now we get to the actual point of the header, the template function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了头文件的实际重点，即模板函数：
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Because it's a template, every time you use the `add()` function the compiler
    must create a separate specialization. This means that the template function must
    be parsed and specialized each time it's invoked. That's why templates go in header
    files; the source must be available at compile time. As the STL grows and evolves,
    with its many large template classes and functions, this becomes a significant
    scalability problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个模板，每次使用 `add()` 函数时，编译器都必须创建一个单独的特化。这意味着模板函数必须在每次调用时都进行解析和特化。这就是为什么模板放在头文件中的原因；源代码必须在编译时可用。随着
    STL 的增长和演变，以及其许多大型模板类和函数，这成为一个显著的扩展性问题。
- en: '*Modules* solve these problems and more.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 解决了这些问题以及更多。'
- en: 'As a module, `bw-math.h` becomes `bw-math.ixx` (in the MSVC naming convention)
    and it looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为模块，`bw-math.h` 变为 `bw-math.ixx`（在 MSVC 命名约定中）并且看起来是这样的：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that the only symbols exported are the name of the module, `bw_math`,
    and the name of the function, `add()`. This keeps the namespace clean.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一导出的符号是模块的名称 `bw_math` 和函数的名称 `add()`。这保持了命名空间整洁。
- en: 'The usage is cleaner as well. When we use it in `module-test.cpp`, it looks
    like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它时更干净。当我们将其用于 `module-test.cpp` 时，它看起来像这样：
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `import` declarations are used where we might otherwise use `#include` preprocessor
    directives. These import the symbol tables from the modules for linkage.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 声明用于我们可能使用 `#include` 预处理器指令的地方。这些导入模块的符号表以进行链接。'
- en: 'The output of our example looks like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的输出看起来像这样：
- en: '[PRE67]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The module version works exactly as it did in a header file, only cleaner and
    more efficiently.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 模块版本的工作方式与在头文件中完全一样，只是更干净、更高效。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The compiled module includes a separate *metadata file* (*module-name*`.ifc`
    in the MSVC naming convention), which describes the module interface. This allows
    the module to support templates. The metadata includes sufficient information
    for the compiler to create template specializations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的模块包括一个单独的 *元数据文件*（在 MSVC 命名约定中为 `*module-name*`.ifc`），它描述了模块接口。这允许模块支持模板。元数据包括足够的信息，使编译器能够创建模板特化。
- en: How it works…
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `import` and `export` declarations are at the core of the *Modules* implementation.
    Let''s take another look at the `bw-math.ixx` module:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 和 `export` 声明是 *模块* 实现的核心。让我们再次看看 `bw-math.ixx` 模块：'
- en: '[PRE68]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notice the two `export` declarations. The first exports the module itself with
    `export module bw_math`. This declares the translation unit as a module. There
    must be a module declaration at the top of every module file, and before any other
    statements. The second `export` makes the function name `add()` available to the
    *module consumer*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个 `export` 声明。第一个使用 `export module bw_math` 导出模块本身，这声明了翻译单元为模块。每个模块文件顶部必须有一个模块声明，并且在任何其他语句之前。第二个
    `export` 使函数名称 `add()` 可用于 *模块消费者*。
- en: 'If your module requires `#include` directives, or other global fragments, you
    will need to first declare your module with a simple module declaration like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块需要 `#include` 指令或其他全局片段，你将需要首先使用如下简单的模块声明来声明你的模块：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `module;` declaration, on a line by itself at the top of the file, introduces
    a *global module fragment*. Only preprocessor directives may appear in the global
    module fragment. This must be immediately followed by a standard module declaration
    (`export module bw_math;`) and the rest of the module content. Let''s look closer
    at how this works:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部单独一行上的 `module;` 声明引入了一个 *全局模块片段*。全局模块片段中只能出现预处理器指令。这必须立即后接一个标准模块声明（`export
    module bw_math;`）以及模块内容的其余部分。让我们更仔细地看看它是如何工作的：
- en: An `export` declaration makes a symbol visible to the *module consumer*, that
    is, the code that imports the module. Symbols default to private.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export` 声明使符号对 *模块消费者* 可见，即导入模块的代码。符号默认为私有。'
- en: '[PRE70]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can export a block, like this:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以导出一个块，如下所示：
- en: '[PRE71]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You can export a namespace:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以导出一个命名空间：
- en: '[PRE72]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or, you can export individual symbols from a namespace:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以从命名空间中导出单个符号：
- en: '[PRE73]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'An `import` declaration imports a module in the *consumer*:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `import` 声明将模块导入到 *消费者* 中：
- en: '[PRE74]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can even import a module and export it to the consumer to pass it along:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你甚至可以导入一个模块并将其导出给消费者以传递：
- en: '[PRE75]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `export` keyword must precede the `import` keyword.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 关键字必须位于 `import` 关键字之前。'
- en: 'The `std.core` module is now available for the consumer:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`std.core` 模块现在可供消费者使用：'
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As you can see, modules are a simple, straightforward alternative to header
    files. I know a lot of us are looking forward to the broad availability of modules.
    I can see this greatly reducing our dependency on header files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，模块是相对于头文件的一个简单、直接的选择。我知道我们中的许多人都在期待模块的广泛可用性。我认为这将大大减少我们对头文件的依赖。
- en: Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the only complete implementation of modules is in a
    *preview release* of MSVC. The module filename extension (`.ixx`) may be different
    for other compilers. Also, the amalgamated `std.core` module is part of how MSVC
    implements the STL as modules in this release. Other compilers may not use this
    convention. Some details may change when fully compliant implementations are released.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，模块的唯一完整实现是在 MSVC 的 *预览发布* 中。模块文件扩展名（`.ixx`）可能因其他编译器而异。此外，合并的 `std.core`
    模块是 MSVC 在此版本中实现 STL 作为模块的一部分。其他编译器可能不会使用此约定。当完全符合的实现发布时，一些细节可能会发生变化。
- en: In the example files, I've included a module version of my `format`-based `print()`
    function. This works on the current preview release of MSVC. It may require some
    small modifications to make it work on other systems, once they support enough
    of the modules specification.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例文件中，我包含了基于 `format` 的 `print()` 函数的模块版本。这适用于当前 MSVC 的预览发布版。一旦其他系统支持足够的模块规范，可能需要一些小的修改才能在其他系统上运行。
- en: Create views into containers with ranges
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用范围创建容器中的视图
- en: The new `ranges` library is one of the more significant additions to C++20\.
    It provides a new paradigm for filtering and processing containers. Ranges provide
    clean and intuitive building blocks for more effective and readable code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `ranges` 库是 C++20 中更重要的添加之一。它为过滤和处理容器提供了一种新的范式。范围提供了干净、直观的构建块，以实现更有效和可读的代码。
- en: 'Let''s start by defining a few terms:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一些术语：
- en: A `begin()` and `end()` iterators is a range. This includes most STL containers.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `begin()` 和 `end()` 迭代器是一个范围。这包括大多数 STL 容器。
- en: A **View** is a range that transforms another underlying range. Views are lazy,
    meaning they only operate as the range iterates. A view returns data from the
    underlying range and does not own any data itself. Views operate in *O(1)* constant
    time.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **视图** 是一个转换另一个底层范围的范围。视图是惰性的，意味着它们只在迭代时操作。视图从底层范围返回数据，并不拥有任何数据。视图以 *O(1)*
    常数时间操作。
- en: A `|` operator.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `|` 操作符。
- en: Note
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `<ranges>` library uses the `std::ranges` and the `std::ranges::view` namespaces.
    Recognizing that this is cumbersome, the standard includes an alias for `std::ranges::view`
    as the simply, `std::view`. I still find that cumbersome. For this recipe I will
    use the following aliases, to save space and because I find it more elegant:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<ranges>` 库使用 `std::ranges` 和 `std::ranges::view` 命名空间。认识到这很繁琐，标准包括了一个对 `std::ranges::view`
    的别名，简单地称为 `std::view`。我仍然觉得这很繁琐。对于这个配方，我将使用以下别名，以节省空间，因为我认为它更优雅：'
- en: '`namespace ranges = std::ranges;  // save the fingers!`'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`namespace ranges = std::ranges;  // 省去手指的麻烦！`'
- en: '`namespace views = std::ranges::views;  `'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`namespace views = std::ranges::views;  `'
- en: This applies to all the code in this recipe.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这适用于本配方中的所有代码。
- en: How to do it…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `ranges` and `views` classes are in the `<ranges>` header. Let''s look
    at how you can use them:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges` 和 `views` 类位于 `<ranges>` 头文件中。让我们看看如何使用它们：'
- en: 'A *View* is applied to a *Range*, like this:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *视图* 应用到一个 *范围* 上，如下所示：
- en: '[PRE77]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Output:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`ranges::take_view(range, n)` is a view that returns the first *n* elements.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges::take_view(range, n)` 是一个返回前 *n* 个元素的视图。'
- en: 'You may also use the *view adapter* version of `take_view()`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `take_view()` 的 *视图适配器* 版本：
- en: '[PRE79]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Output:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '*View adapters* are in the `std::ranges::views` namespace. A *view adapter*
    takes the *range operand* from the left-hand side of the `|` operator, much like
    the `iostreams` usage of the `<<` operator. The `|` operands are evaluated left-to-right.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图适配器* 位于 `std::ranges::views` 命名空间中。一个 *视图适配器* 从 `|` 操作符的左侧获取 *范围操作数*，就像
    `iostreams` 使用 `<<` 操作符的 `iostreams` 一样。`|` 操作数从左到右评估。'
- en: 'Because a view adapter is *iterable*, it also qualifies as a range. This allows
    them to be applied serially, like this:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为视图适配器是 *可迭代的*，它也符合 *范围* 的资格。这使得它们可以串联使用，如下所示：
- en: '[PRE81]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `filter()` view uses a predicate function:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()` 视图使用谓词函数：'
- en: '[PRE83]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Output:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE84]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `transform()` view uses a transformation function:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform()` 视图使用转换函数：'
- en: '[PRE85]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE86]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Of course, these views and adapters work on ranges of any type:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，这些视图和适配器适用于任何类型的范围：
- en: '[PRE87]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Output:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `ranges` library also includes a few *range factories*. The `iota` factory
    will generate an incrementing series of values:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ranges` 库还包括一些 *范围生成器*。`iota` 生成器将生成一个递增的值序列：'
- en: '[PRE89]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Output:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `iota(value, bound)` function generates a sequence starting with `value`
    and ending *before* `bound`. If `bound` is omitted, the sequence is infinite:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`iota(value, bound)` 函数生成一个从 `value` 开始，在 *bound* 之前结束的序列。如果省略 `bound`，则序列是无限的：'
- en: '[PRE91]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE92]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*Ranges*, *Views*, and *View Adapters* are incredibly flexible and useful.
    Let''s take a deeper look for a better understanding.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*范围*、*视图* 和 *视图适配器* 非常灵活且有用。让我们更深入地了解它们，以便更好地理解。'
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To satisfy the basic requirements for a *Range*, an object must have at least
    two iterators, `begin()` and `end()`, where the `end()` iterator is a sentinel,
    used to determine the end point of a range. Most STL containers qualify as ranges,
    including `string`, `vector`, `array`, `map`, and others, with the notable exception
    of container-adapters, like `stack` and `queue`, which don't have `begin` and
    `end` iterators.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足 *范围* 的基本要求，一个对象必须至少有两个迭代器，`begin()` 和 `end()`，其中 `end()` 迭代器是一个哨兵，用于确定范围的终点。大多数
    STL 容器都符合 *范围* 的资格，包括 `string`、`vector`、`array`、`map` 等，但容器适配器（如 `stack` 和 `queue`）除外，它们没有
    `begin` 和 `end` 迭代器。
- en: 'A *View* is an object which operates on a range and returns a modified range.
    A view operates lazily, and contains no data of its own. Instead of keeping a
    copy of the underlying data, it simply returns iterators to underlying elements
    as needed. Let''s examine this code snippet:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*视图* 是一个操作范围并返回修改后范围的对象。视图是惰性操作的，不包含自己的数据。它不是保留底层数据的副本，而是根据需要简单地返回指向底层元素的迭代器。让我们看看这个代码片段：'
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, the `take_view` object takes two parameters, a *range* (in
    this case, a `vector<int>` object), and a *count*. The result is a *view* with
    the first *count* objects from the `vector`. At evaluation time, during the iteration
    of the `for` loop, the `take_view` object simply returns iterators that point
    to elements of the `vector` object, as needed. The `vector` object is not modified
    in this process.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`take_view` 对象接受两个参数，一个 *范围*（在这种情况下，一个 `vector<int>` 对象），和一个 *计数*。结果是包含
    `vector` 中前 *count* 个对象的 *视图*。在评估时间，在 `for` 循环迭代期间，`take_view` 对象只需返回指向 `vector`
    对象元素的迭代器，按需返回。在这个过程中，`vector` 对象不会被修改。
- en: 'Many of the views in the `ranges` namespace have corresponding *range adapters*
    in the `views` namespace. These adapters may be used with the *bitwise or* (`|`)
    operator, as a pipe, like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`ranges` 命名空间中的许多视图都有 `views` 命名空间中的相应的 *范围适配器*。这些适配器可以用作 *按位或* (`|`) 操作符，就像管道一样，如下所示：'
- en: '[PRE95]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'As expected, the `|` operator evaluates left to right. And because the result
    of the range adapter is another range, these adapter expressions may be chained:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`|` 操作符从左到右评估。因为范围适配器的结果是另一个范围，所以这些适配器表达式可以链式使用：
- en: '[PRE97]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Output:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE98]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The library includes a `filter` view that is used with a *predicate*, for defining
    simple filters:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 该库包括一个用于与 *谓词* 一起使用的 `filter` 视图，用于定义简单的过滤器：
- en: '[PRE99]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Output:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE100]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Also included, is a `transform` view that is used with a *transform function*
    for transforming results:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 还包括一个用于与 *转换函数* 一起使用的 `transform` 视图：
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE102]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: There are quite a few useful views and view adapters in the library. Please
    check your favorite reference site, or ([https://j.bw.org/ranges](https://j.bw.org/ranges))
    for a complete list.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 该库中有许多有用的视图和视图适配器。请查看您喜欢的参考网站，或 ([https://j.bw.org/ranges](https://j.bw.org/ranges))
    以获取完整列表。
- en: There's more…
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Beginning with C++20, most of the algorithms in the `<algorithm>` header include
    versions for use with `ranges`. These versions are still in the `<algorithm>`
    header, but in the `std::ranges` namespace. This distinguishes them from the legacy
    algorithms.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从 C++20 开始，`<algorithm>` 头文件中的大多数算法都包括用于与 `ranges` 一起使用的版本。这些版本仍然在 `<algorithm>`
    头文件中，但在 `std::ranges` 命名空间中。这使它们与旧算法区分开来。
- en: 'This means that, instead of calling an algorithm with two iterators:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，你不需要调用一个算法并传递两个迭代器：
- en: '[PRE103]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can now call it with just a range, like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以用一个范围来调用它，就像这样：
- en: '[PRE104]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That's certainly more convenient, but how does it really help?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实更方便，但它实际上是如何帮助我们的呢？
- en: 'Consider the case where you want to sort part of a vector, you could do that
    the old way, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个情况，你想要对一个向量的部分进行排序，你可以像这样使用旧的方法：
- en: '[PRE105]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This would sort the elements of the vector after the first 5\. With the `ranges`
    version, you can use a view to skip the first 5 elements:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按顺序对向量中第一个5个元素之后的元素进行排序。使用 `ranges` 版本，你可以使用一个视图来跳过前5个元素：
- en: '[PRE106]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You can even combine views:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将视图组合起来：
- en: '[PRE107]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In fact, you can even use range adapters as the argument to `ranges::sort`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你甚至可以使用范围适配器作为 `ranges::sort` 的参数：
- en: '[PRE108]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In contrast, if you wanted to do this with the traditional `sort` algorithm
    and vector iterators, it would look something like this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，如果你想要使用传统的 `sort` 算法和向量迭代器来完成这个任务，它看起来可能像这样：
- en: '[PRE109]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: While that's certainly shorter, and not impossible to understand, I find the
    range adapters version far more intuitive.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这确实更短，并且并不难理解，但我发现范围适配器版本更加直观。
- en: You can find a complete list of algorithms that have been constrained to work
    with ranges on the *cppreference* site (https://j.bw.org/algoranges).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *cppreference* 网站上找到一个完整的算法列表，这些算法被限制只能与范围一起工作（https://j.bw.org/algoranges）。
- en: In this recipe, we've only scratched the surface of *Ranges* and *Views*. This
    feature is the culmination of over a decade of work by many different teams, and
    I expect it to fundamentally change the way we use containers in the STL.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们仅仅只是触及了 *Ranges* 和 *Views* 的表面。这个特性是许多不同团队超过十年工作的结晶，我预计它将从根本上改变我们在
    STL 中使用容器的方式。
