- en: Understanding Language Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解语言特性
- en: In the previous chapter, you installed a C++ compiler and developed a simple
    application. You also explored the basic structure of C++ projects and how to
    manage them. In this chapter, you will dive deeper into language, and learn the
    various language features to control flow in your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您安装了C++编译器并开发了一个简单的应用程序。您还探索了C++项目的基本结构以及如何管理它们。在本章中，您将深入了解语言，并学习控制代码流的各种语言特性。
- en: Writing C++
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写C++
- en: C++ is a very flexible language when it comes to formatting and writing code.
    It is also a strongly typed language, meaning there are rules about declaring
    the types of variables, which you can use to your advantage by making the compiler
    help you write better code. In this section, we will cover how to format C++ code
    and rules on declaring and scoping variables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式和编写代码方面，C++是一种非常灵活的语言。它也是一种强类型语言，这意味着有关声明变量类型的规则，您可以利用这些规则使编译器帮助您编写更好的代码。在本节中，我们将介绍如何格式化C++代码以及声明和作用域变量的规则。
- en: Using white space
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用空格
- en: 'Other than string literals, you have free usage of white space (spaces, tabs,
    newlines), and are able to use as much or as little as you like. C++ statements
    are delimited by semicolons, so in the following code there are three statements,
    which will compile and run:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串文字之外，您可以自由使用空格（空格，制表符，换行符），并且可以根据需要使用多少。C++语句由分号分隔，因此在以下代码中有三个语句，这些语句将被编译和运行：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The entire code could be written as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 整个代码可以写成如下形式：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are some cases where white space is needed (for example, when declaring
    a variable you must have white space between the type and the variable name),
    but the convention is to be as judicious as possible to make the code readable.
    And while it is perfectly correct, language-wise, to put all the statements on
    one line (like JavaScript), it makes the code almost completely unreadable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下需要空格（例如，在声明变量时，类型和变量名之间必须有空格），但惯例是尽可能谨慎，以使代码可读。虽然在语言上完全正确，将所有语句放在一行上（如JavaScript）会使代码几乎完全无法阅读。
- en: If you are interested in some of the more creative ways of making code unreadable,
    have a look at the entries for the annual International Obfuscated C Code Contest
    ([http://www.ioccc.org/](http://www.ioccc.org/)). As the progenitor of C++, many
    of the lessons in C shown at IOCCC apply to C++ code too.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对一些更有创意的使代码难以阅读的方法感兴趣，请查看年度国际混淆C代码大赛的条目（[http://www.ioccc.org/](http://www.ioccc.org/)）。作为C++的鼻祖，IOCCC中展示的许多C的教训也适用于C++代码。
- en: Bear in mind that, if the code you write is viable, it may be in use for decades,
    which means you may have to come back to the code years after you have written
    it, and it means that other people will support your code, too. Making your code
    readable is not only a courtesy to other developers, but unreadable code is always
    a likely target for replacement.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您编写的代码是可行的，它可能会被使用数十年，这意味着您可能需要在编写代码数年后回到代码，并且其他人也将支持您的代码。使您的代码可读不仅是对其他开发人员的礼貌，而且不可读的代码总是可能被替换的目标。
- en: Formatting code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化代码
- en: Inevitably, whoever you are writing code for will dictate how you format code.
    Sometimes it makes sense, for example, if you use some form of preprocessing to
    extract code and definitions to create documentation for the code. In many cases,
    the style that is imposed on you is the personal preference of someone else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您为谁编写代码，最终都会决定您如何格式化代码。有时是有道理的，例如，如果您使用某种形式的预处理来提取代码和定义以创建代码的文档。在许多情况下，强加给您的风格是他人的个人偏好。
- en: Visual C++ allows you to place XML comments in your code. To do this you use
    a three--slash comment (`///`) and then compile the source file with the `/doc`
    switch. This creates an intermediate XML file called an `xdc` file with a `<doc>`
    root element and containing all the three--slash comments. The Visual C++ documentation
    defines standard XML tags (for example, `<param>`, `<returns>` to document the
    parameters and return value of a function). The intermediate file is compiled
    to the final document XML file with the `xdcmake` utility.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++允许您在代码中放置XML注释。要做到这一点，您可以使用三斜杠注释（`///`），然后使用`/doc`开关编译源文件。这将创建一个名为`xdc`的中间XML文件，其中包含所有三斜杠注释的`<doc>`根元素。Visual
    C++文档定义了标准的XML标记（例如，`<param>`，`<returns>`用于记录函数的参数和返回值）。中间文件使用`xdcmake`实用程序编译为最终文档XML文件。
- en: 'There are two broad styles in C++: **K&R** and **Allman**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++有两种广泛的风格：**K&R**和**Allman**。
- en: 'Kernighan and Ritchie (K&R) wrote the first, and most influential, book about
    C (Dennis Ritchie was the author of the C language). The K&R style is used to
    describe the formatting style used in that book. In general, K&R places the opening
    brace of a code block on the same line of the last statement. If your code has
    nested statements (and typically, it will) then this style can get a bit confusing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kernighan和Ritchie（K&R）写了关于C的第一本，也是最有影响力的书（Dennis Ritchie是C语言的作者）。 K&R风格用于描述该书中使用的格式样式。一般来说，K&R将代码块的左大括号放在最后一条语句的同一行。如果您的代码有嵌套语句（通常会有），那么这种风格可能会有点令人困惑：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This style is typically used in Unix (and Unix-like) code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格通常用于Unix（和类Unix）代码。
- en: 'The Allman style (named after the developer Eric Allman) places the opening
    brace on a new line, so the nested example looks as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Allman风格（以开发人员Eric Allman命名）将左大括号放在新行上，因此嵌套示例如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Allman style is typically used by Microsoft.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Allman风格通常由微软使用。
- en: Remember that your code is unlikely to be presented on paper, so the fact that
    K&R is more compact will save no trees. If you have the choice, you should choose
    the style that is the most readable; the decision of this author, for this book,
    is that Allman is the more readable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的代码不太可能以纸质形式呈现，因此K&R更紧凑将不会节省任何树木。如果可以选择，您应该选择最可读的风格；对于本书的作者来说，Allman更可读。
- en: 'If you have multiple nested blocks, the indents can give you an idea of which
    block the code resides in. However, comments can help. In particular, if a code
    block has a large amount of code, it is often helpful to comment the reason for
    the code block. For example, in an `if` statement, it is helpful to put the result
    of the test in the code block so you know what the variable values are in that
    block. It is also useful to put a comment on the closing brace of the test:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个嵌套的块，缩进可以让你知道代码位于哪个块中。然而，注释也可以帮助。特别是，如果一个代码块有大量的代码，通常有助于注释代码块的原因。例如，在`if`语句中，将测试的结果放在代码块中是有帮助的，这样你就知道该块中的变量值是什么。在测试的右括号上放一个注释也是有用的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you put the test as a comment on a closing brace, it means that you have
    a search term that you can use to find the test that resulted in the code block.
    The preceding lines make this commenting redundant, but when you have code blocks
    with many tens of lines of code, and with many levels of nesting, comments like
    this can be very helpful.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在右括号上放一个测试的注释，这意味着你有一个搜索项，可以用来找到导致代码块的测试。前面的行使这种注释变得多余，但是当你有许多行代码的代码块，并且有许多层嵌套时，这样的注释是非常有帮助的。
- en: Writing statements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写语句
- en: A statement can be a declaration of a variable, an expression that evaluates
    to a value, or it can be a definition of a type. A statement may also be a control
    structure to affect the flow of the execution through your code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 语句可以是变量的声明，求值为值的表达式，或者可以是类型的定义。语句也可以是控制结构，以影响代码的执行流程。
- en: A statement ends with a semicolon. Other than that, there are few rules about
    how to format statements. You can even use a semicolon on its own, and this is
    called a null statement. A null statement does nothing, so having too many semicolons
    is usually benign.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 语句以分号结束。除此之外，关于语句的格式几乎没有规则。你甚至可以单独使用分号，这被称为空语句。空语句什么也不做，所以有太多分号通常是无害的。
- en: Working with expressions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用表达式
- en: 'An expression is a sequence of operators and operands (variables or literals)
    that results in some value. Consider the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是一系列操作符和操作数（变量或字面值），其结果为某个值。考虑以下内容：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On the right side `6 * 7` is an expression, and the assignment (from `i` on
    the left-hand side to the semicolon on the right) is a statement.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧`6 * 7`是一个表达式，而赋值（从左侧的`i`到右侧的分号）是一个语句。
- en: 'Every expression is either an **lvalue** or an **rvalue**. You are most likely
    to see these keywords used in error descriptions. In effect, an lvalue is an expression
    that refers to some memory location. Items on the left-hand side of an assignment
    must be lvalues. However, an lvalue can appear on the left- or right-hand side
    of an assignment. All variables are lvalues. An rvalue is a temporary item that
    does not exist longer than the expression that uses it; it will have a value,
    but cannot have a value assigned to it, so it can only exist on the right-hand
    side of an assignment. Literals are rvalues. The following shows a simple example
    of lvalues and rvalues:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表达式都是**lvalue**或**rvalue**。你最有可能在错误描述中看到这些关键字。实际上，lvalue是一个引用某个内存位置的表达式。赋值语句的左侧必须是lvalue。然而，lvalue可以出现在赋值语句的左侧或右侧。所有变量都是lvalues。rvalue是一个临时项，它的存在不会超过使用它的表达式；它将有一个值，但不能对它进行赋值，因此它只能存在于赋值语句的右侧。字面值是rvalues。以下是lvalues和rvalues的一个简单示例：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the second line, `i` is an lvalue, and the expression `6 * 7` results in
    an rvalue (`42`). The following will not compile because there is an rvalue on
    the left:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，`i`是一个lvalue，表达式`6 * 7`的结果是一个rvalue（`42`）。以下代码将无法编译，因为左侧有一个rvalue：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Broadly speaking, an expression becomes a statement by when you append a semicolon.
    For example, the following are both statements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上讲，通过在表达式后附加分号，表达式变成了语句。例如，以下两者都是语句：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line is an rvalue of `42`, but since it is temporary it has no effect.
    A C++ compiler will optimize it away. The second line calls the standard library
    function to calculate the square root of `2`. Again, the result is an rvalue and
    the value is not used, so the compiler will optimize this away. However, it illustrates
    that a function can be called without using its return value. Although it is not
    the case with `std::sqrt`, many functions have a lasting effect other than their
    return value. Indeed, the whole point of a function is usually to do something,
    and the return value is often used merely to indicate if the function was successful;
    often developers assume that a function will succeed and ignore the return value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是`42`的rvalue，但由于它是临时的，所以没有影响。C++编译器会对其进行优化。第二行调用标准库函数来计算`2`的平方根。同样，结果是一个rvalue，值没有被使用，所以编译器会对其进行优化。然而，它说明了一个函数可以被调用而不使用其返回值。虽然对于`std::sqrt`来说并非如此，但许多函数除了返回值之外还有持久的影响。实际上，函数的整个目的通常是做某事，返回值通常仅用于指示函数是否成功；通常开发人员假设函数会成功，并忽略返回值。
- en: Using the comma operator
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用逗号运算符
- en: 'Operators will be covered later in this chapter; however, it is useful to introduce
    the comma operator here. You can have a sequence of expressions separated by a
    comma as a single statement. For example, the following code is legal in C++:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符将在本章后面介绍；然而，在这里介绍逗号运算符是有用的。你可以有一系列由逗号分隔的表达式作为单个语句。例如，以下代码在C++中是合法的：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The writer intended to type `c = a + 8 / b + 1;` and `:` they pressed comma
    instead of a `/`. The intention was for `c` to be assigned to 9 + 2 + 1, or 12\.
    This code will compile and run, and the variable `c` will be assigned with a value
    of 17 (`a + 8`). The reason is that the comma separates the right-hand side of
    the assignment into two expressions, `a + 8` and `b + 1`, and it uses the value
    of the first expression to assign `c`. Later in this chapter, we will look at
    operator precedence. However, it is worth saying here that the comma has the lowest
    precedence and `+` has a higher precedence than `=`, so the statement is executed
    in the order of the addition: the assignment and then the comma operator (with
    the result of `b + 1` thrown away).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作者本打算输入`c = a + 8 / b + 1;`，但是他们按错了按键，按了逗号而不是斜杠。本意是让`c`被赋值为9 + 2 + 1，即12。这段代码将编译并运行，变量`c`将被赋值为17（`a
    + 8`）。原因是逗号将赋值语句的右侧分为两个表达式，`a + 8`和`b + 1`，并且它使用第一个表达式的值来赋值`c`。在本章的后面，我们将看到运算符的优先级。然而，值得在这里说的是，逗号的优先级最低，`+`的优先级高于`=`，因此语句按照加法的顺序执行：赋值，然后逗号运算符（`b
    + 1`的结果被丢弃）。
- en: 'You can change the precedence using parentheses to group expressions. For example,
    the mistyped code could have been as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用括号来改变优先级以分组表达式。例如，错误输入的代码可能如下所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result of this statement is: variable `c` is assigned to 5 (or `b + 1`).
    The reason is that with the comma operator expressions are executed from left
    to right so the value of the group of expressions is the tight-most one. There
    are some cases, for example, in the initialization or loop expression of a `for`
    loop, where you will find the comma operator useful, but as you can see here,
    even used intentionally, the comma operator produces hard-to-read code.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句的结果是：变量`c`被赋值为5（或`b + 1`）。原因是，使用逗号运算符时，表达式从左到右执行，因此表达式组的值是最右边的值。有一些情况，例如`for`循环的初始化或循环表达式中，您会发现逗号运算符很有用，但正如您在这里看到的，即使有意使用，逗号运算符也会产生难以阅读的代码。
- en: Using types and variables
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型和变量
- en: Types will be covered in more detail in the next chapter, but it is useful to
    give basic information here. C++ is a strongly typed language, which means that
    you have to declare the type of the variables that you use. The reason for this
    is that the compiler needs to know how much memory to allocate for the variable,
    and it can determine this by the type of the variable. In addition, the compiler
    needs to know how to initialize a variable, if it has not been explicitly initialized,
    and to perform this initialization the compiler needs to know the type of the
    variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类型将在下一章中更详细地介绍，但在这里提供基本信息是有用的。C++是一种强类型语言，这意味着您必须声明您使用的变量的类型。原因是编译器需要知道为变量分配多少内存，并且它可以通过变量的类型来确定这一点。此外，编译器需要知道如何初始化变量，如果没有明确初始化，它需要执行此初始化，而编译器需要知道变量的类型。
- en: C++11 provides the `auto` keyword, which relaxes this concept of strong typing,
    and it will be covered in the next chapter. However, the type checking of the
    compiler is so important that you should use type checking as much as possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了`auto`关键字，它放宽了强类型的概念，将在下一章中介绍。然而，编译器的类型检查非常重要，因此应尽可能多地使用类型检查。
- en: C++ variables can be declared anywhere in your code as long as they are declared
    before they are used. *Where* you declare a variable determines *how* you use
    it (this is called the **scope** of the variable). In general, it is best to declare
    the variable as close as possible to where you will use it, and within the most
    restrictive scope. This prevents *name clashes*, where you will have to add additional
    information to disambiguate two or more variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C++变量可以在代码的任何位置声明，只要它们在使用之前声明即可。您声明变量的位置决定了您如何使用它（这称为变量的**作用域**）。一般来说，最好在尽可能接近使用变量的地方声明变量，并在最严格的范围内声明。这可以防止*名称冲突*，在这种情况下，您将不得不添加额外的信息来消除两个或更多个变量的歧义。
- en: 'You may, *and should*, give your variables descriptive names. This makes your
    code much more readable and easier to understand. C++ names must start with an
    alphabetic character, or an underscore. They can contain alphanumeric characters
    except spaces, but can contain underscores. So, the following are valid names:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以*并且应该*给变量起一个描述性的名称。这样可以使您的代码更易读，更容易理解。C++名称必须以字母字符或下划线开头。它们可以包含除空格之外的字母数字字符，但可以包含下划线。因此，以下名称是有效的：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: C++ names are case-sensitive, and the first `2,048` characters are significant.
    You can start a variable name with an underscore, but you cannot use two underscores,
    nor can you use an underscore followed by a capital letter (these are reserved
    by C++). C++ also reserves keywords (for example, `while` and `if`), and clearly
    you cannot use type names as variable names, neither built in type names (`int`,
    `long`, and so on) nor your own custom types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C++名称区分大小写，前2048个字符是有效的。您可以用下划线开头的变量名，但不能使用两个下划线，也不能使用下划线后面跟大写字母（这些被C++保留）。C++还保留了关键字（例如`while`和`if`），显然您不能使用类型名称作为变量名称，无论是内置类型名称（`int`、`long`等）还是您自己的自定义类型。
- en: You declare a variable in a statement, ending with a semicolon. The basic syntax
    of declaring a variable is that you specify the type, then the name, and, optionally,
    any initialization of the variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您在语句中声明变量，并以分号结束。声明变量的基本语法是指定类型，然后是名称，以及可选的变量初始化。
- en: 'Built-in types must be initialized before you use them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型必须在使用之前初始化：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are essentially three ways to initialize variables. You can assign a
    value, you can call the type constructor (constructors for classes will be defined
    in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*) or you
    can initialize a variable using function syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化变量基本上有三种方法。您可以赋值，可以调用类型构造函数（类的构造函数将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中定义，*类*），或者可以使用函数语法初始化变量：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These three are all legal C++, but stylistically the first is the better because
    it is more obvious: the variable is an integer, it is called `i`, and it is assigned
    a value of 1\. The third looks confusing; it looks like the declaration of a function
    when it is actually declaring a variable. The next chapter will show a variation
    of assigning a value using the initialization list syntax. The reasons why you
    will want to do this will be left to that chapter.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个在C++中都是合法的，但从风格上讲，第一个更好，因为它更明显：变量是一个整数，叫做`i`，并且被赋值为1。第三个看起来令人困惑；它看起来像是一个函数的声明，实际上是在声明一个变量。下一章将展示使用初始化列表语法进行赋值的变化。为什么你会想要这样做的原因将留到那一章。
- en: '[Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes* will cover
    classes, your own custom types. A custom type may be defined to have a default
    value, which means that you may decide not to initialize a variable of a custom
    type before using it. However, this will result in poorer performance, because
    the compiler will initialize the variable with the default value and subsequently
    your code will assign a value, resulting in an assignment being performed twice.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)，*类*将涵盖类，你自己的自定义类型。自定义类型可以被定义为具有默认值，这意味着你可以决定在使用自定义类型的变量之前不初始化它。然而，这会导致性能较差，因为编译器将使用默认值初始化变量，随后你的代码将赋值一个值，导致赋值操作执行两次。'
- en: Using constants and literals
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量和文字
- en: 'Each type will have a literal representation. An integer will be a numeric
    represented without a decimal point and, if it is a signed integer, the literal
    can also use the plus or minus symbol to indicate the sign. Similarly, a real
    number can have a literal value that contains a decimal point, and you may even
    use the scientific (or engineering) format including an exponent. C++ has various
    rules to use when specifying literals in code, and these will be covered in the
    next chapter. Some examples of literals are shown here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都有一个文字表示。整数将是一个没有小数点的数字表示，如果是有符号整数，文字也可以使用加号或减号符号来表示符号。同样，实数可以有包含小数点的文字值，甚至可以使用科学（或工程）格式，包括指数。C++在代码中指定文字时有各种规则，这些将在下一章中介绍。这里展示了一些文字的例子：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that for the `unit` variable, the compiler knows that the literal is a
    real number because the value has a decimal point. For integers, you can provide
    a hexadecimal literal in your code by prefixing the number with `0x`, so `0x100`
    is `256` in decimal. By default, the output stream will print numeric values in
    base 10; however, you can insert a **manipulator** into an output stream to tell
    it to use a different number base. The default behavior is `std::dec`, which means
    the numbers should be displayed as base 10, `std::oct` means display as octal
    (base 8), and `std::hex` means display as hexadecimal (base `16`). If you prefer
    to see the prefix printed, then you use the stream manipulator `std::showbase` (more
    details will be given in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`unit`变量，编译器知道文字是一个实数，因为这个值有一个小数点。对于整数，你可以在你的代码中提供一个十六进制文字，通过在数字前加上`0x`，所以`0x100`在十进制中是`256`。默认情况下，输出流将以十进制打印数字值；然而，你可以在输出流中插入一个**操作器**来告诉它使用不同的数字基数。默认行为是`std::dec`，这意味着数字应该以十进制显示，`std::oct`表示八进制（基数8）显示，`std::hex`表示十六进制（基数`16`）显示。如果你希望看到前缀被打印出来，那么你可以使用流操作器`std::showbase`（更多细节将在[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)，*使用标准库容器*中给出）。
- en: C++ defines some literals. For `bool`, the logic type, there are `true` and
    `false` constants, where `false` is zero and `true` is 1\. There is also the `nullptr`
    constant, again, zero, which is used as an invalid value for any pointer type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++定义了一些文字。对于`bool`，逻辑类型，有`true`和`false`常量，其中`false`是零，`true`是1。还有`nullptr`常量，同样是零，它被用作任何指针类型的无效值。
- en: Defining constants
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义常量
- en: 'In some cases, you will want to provide constant values that can be used throughout
    your code. For example, you may decide to declare a constant for `π`. You should
    not allow this value to be changed because it will change the underlying logic
    in your code. This means that you should mark the variable as being constant.
    When you do this, the compiler will check the use of the variable and if it is
    used in code that changes the value of the variable the compiler will issue an
    error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你会想要提供可以在整个代码中使用的常量值。例如，你可能决定为`π`声明一个常量。你不应该允许这个值被改变，因为它会改变你代码中的基本逻辑。这意味着你应该将变量标记为常量。当你这样做时，编译器将检查变量的使用，如果它在改变变量值的代码中使用，编译器将发出一个错误：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case the symbol `pi` is declared as being constant, so it cannot change.
    If you subsequently decide to change the constant, the compiler will issue an
    error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，符号`pi`被声明为常量，所以它不能改变。如果你随后决定改变这个常量，编译器会发出一个错误：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you have declared a constant, you can be assured that the compiler will
    make sure it remains so. You can assign a constant with an expression as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你声明了一个常量，你可以确保编译器会确保它保持不变。你可以按照以下方式用表达式赋值一个常量：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, a global constant called `sqrtOf2` is declared and assigned with
    a value using the `std::sqrt` function. Since this constant is declared outside
    a function, it is global to the file and can be used throughout the file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，声明了一个名为`sqrtOf2`的全局常量，并使用`std::sqrt`函数赋值。由于这个常量是在函数外声明的，它是文件中的全局变量，并且可以在整个文件中使用。
- en: In the last chapter, you learned that one way to declare a constant is to use
    `#define` symbols. The problem with this approach is that the preprocessor does
    a simple replacement. With constants declared with `const`, the C++ compiler will
    perform type checking to ensure that the constant is being used appropriately.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学到了声明常量的一种方法是使用`#define`符号。这种方法的问题在于预处理器进行简单的替换。使用`const`声明的常量，C++编译器将执行类型检查，以确保常量被适当使用。
- en: 'You can also use `const` to declare a constant that will be used as a **constant
    expression**. For example, you can declare an array using the square bracket syntax
    (more details will be given in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers*):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`const`来声明一个将被用作**常量表达式**的常量。例如，你可以使用方括号语法声明一个数组（更多细节将在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*使用内存、数组和指针*中给出）。
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This declares an array of five integers on the stack and these items are accessed
    through the `values` array variable. The `5` here is a constant expression. When
    you declare an array on the stack, you have to provide the compiler with a constant
    expression so it knows how much memory to allocate and this means the size of
    the array must be known at compile time. (You can allocate an array with a size
    known only at runtime, but this requires dynamic memory allocation, explained
    in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml), *Working with Memory,
    Arrays, and Pointers.*) In C++, you can declare a constant to do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这在堆栈上声明了一个包含五个整数的数组，这些项目通过`values`数组变量访问。这里的`5`是一个常量表达式。当你在堆栈上声明一个数组时，你必须提供编译器一个常量表达式，以便它知道要分配多少内存，这意味着数组的大小必须在编译时知道。（你可以分配一个只在运行时知道大小的数组，但这需要动态内存分配，在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)中有解释，*使用内存、数组和指针*。）在C++中，你可以声明一个常量来执行以下操作：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Elsewhere in your code, when you access the `values` array, you can use the
    `size` constant to make sure that you do not access items past the end of the
    array. Since the `size` variable is declared in just one place, if you need to
    change the size of the array at a later stage, you have just one place to make
    this change.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的其他地方，当你访问`values`数组时，你可以使用`size`常量来确保你不会访问数组末尾之后的项目。由于`size`变量只在一个地方声明，如果你需要在以后的阶段更改数组的大小，你只需要在一个地方进行更改。
- en: The `const` keyword can also be used on pointers and references (see [Chapter
    4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml), *Working with Memory, Arrays,
    and Pointers*) and on objects (see [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml),
    *Classes*); often, you'll see it used on parameters to functions (see [Chapter
    5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml), *Using Functions*). This is used
    to get the compiler to help ensure that pointers, references, and objects are
    used appropriately, as you intended.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`关键字也可以用于指针和引用（见[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*使用内存、数组和指针*）和对象（见[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)，*类*）；通常，你会看到它用于函数的参数（见[第5章](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml)，*使用函数*）。这用于让编译器帮助确保指针、引用和对象被按照你的意图使用。'
- en: Using constant expressions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用常量表达式
- en: 'C++11 introduces a keyword called `constexpr`. This is applied to an expression,
    and indicates that the expression should be evaluated at compile type rather than
    at runtime:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了一个名为`constexpr`的关键字。这个关键字应用于一个表达式，表示该表达式应该在编译时而不是在运行时求值：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is similar to initializing a constant declared with the `const` keyword.
    However, the `constexpr` keyword can also be applied to functions that return
    a value that can be evaluated at compile time, and so this allows the compiler
    to optimize the code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于初始化使用`const`关键字声明的常量。然而，`constexpr`关键字也可以应用于返回可以在编译时求值的值的函数，因此这允许编译器优化代码：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, the function `triang` calculates triangular numbers recursively.
    The code uses the conditional operator. In the parentheses, the function parameter
    is tested to see if it is zero, and if so the function returns zero, in effect
    ending the recursion and returning the function to the original caller. If the
    parameter is not zero, then the return value is the sum of the parameter and the
    return value of `triang` called with the parameter is decremented.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，函数`triang`递归地计算三角数。代码使用了条件运算符。在括号中，测试函数参数是否为零，如果是，则函数返回零，实际上结束了递归，并将函数返回给原始调用者。如果参数不为零，则返回值是参数和减小参数的`triang`调用的返回值的和。
- en: This function, when called with a literal in your code, can be evaluated at
    compile time. The `constexpr` is an indication to the compiler to check the usage
    of the function to see if it can determine the parameter at compile time. If this
    is the case, the compiler can evaluate the return value and produce code more
    efficiently than by calling the function at runtime. If the compiler cannot determine
    the parameter at compile-time, the function will be called as **normal**. A function
    marked with the `constexpr` keyword must only have one expression (hence the use
    of the conditional operator `?:` in the `triang` function).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中使用文字调用这个函数时，它可以在编译时求值。`constexpr`是对编译器的指示，检查函数的使用情况，看它是否可以在编译时确定参数。如果是这样，编译器可以求值返回值，并比在运行时调用函数更有效地生成代码。如果编译器无法在编译时确定参数，函数将被正常调用。用`constexpr`关键字标记的函数只能有一个表达式（因此在`triang`函数中使用条件运算符`?:`）。
- en: Using enumerations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用枚举
- en: 'A final way to provide constants is to use an `enum` variable. In effect, an
    `enum` is a group of named constants, which means that you can use an `enum` as
    a parameter to a function. For example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提供常量的最后一种方法是使用`enum`变量。实际上，`enum`是一组命名常量，这意味着你可以将`enum`用作函数的参数。例如：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This defines an enumeration called `suits`, with named values for the suits
    in a deck of cards. An enumeration is an integer type and by default the compiler
    will assume an `int`, but you can change this by specifying the integer type in
    the declaration. Since there are just four possible values for card suits, it
    is a waste of memory to use `int` (usually `4` bytes) and instead we can use `char`
    (a single byte):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`suits`的枚举，其中包含了一副牌中的花色的命名值。枚举是一个整数类型，默认情况下编译器会假定为`int`，但你可以在声明中指定整数类型来改变这一点。由于卡牌花色只有四种可能的值，使用`int`（通常为`4`字节）是一种浪费内存，我们可以使用`char`（一个字节）来代替。
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you use an enumerated value, you can use just the name; however, it is
    usual to scope it with the name of the enumeration, making the code more readable:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用枚举值时，您可以只使用名称；但是，通常会使用枚举的名称对其进行范围限定，使代码更易读：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Both forms are allowed, but the latter makes it more explicit that the value
    is taken from an enumeration. To force developers to specify the scope, you can
    apply the keyword `class`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种形式都是允许的，但后一种形式更明确地表示值是从枚举中获取的。为了强制开发人员指定作用域，可以应用关键字`class`：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this definition and the preceding code, the line declaring `card2` will
    compile, but the line declaring `card1` will not. With a scoped `enum`, the compiler
    treats the enumeration as a new type and has no inbuilt conversion from your new
    type to an integer variable. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义和前面的代码，声明`card2`的行将编译，但声明`card1`的行将不会。使用作用域的`enum`，编译器将枚举视为新类型，并且没有从新类型到整数变量的内置转换。例如：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `enum` type is based on `char` but when you define the `suits` variable
    as being scoped (with `class`) the second line will not compile. If the enumeration
    is defined as not being scoped (without `class`) then there is an inbuilt conversion
    between the enumerated value and `char`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型是基于`char`的，但当您将`suits`变量定义为带有`class`的作用域时，第二行将无法编译。如果枚举被定义为不带有`class`的作用域，则枚举值和`char`之间存在内置转换。'
- en: 'By default, the compiler will give the first enumerator a value of 0 and then
    increment the value for the subsequent enumerators. Thus `suits::diamonds` will
    have a value of 1 because it is the second value in `suits`. You can assign values
    yourself:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器将为第一个枚举器赋值为0，然后递增后续枚举器的值。因此，`suits::diamonds`的值将为1，因为它是`suits`中的第二个值。您也可以自己分配值：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, `ports::ftp` has a value of 21, `ports::ssh` has a value of 22
    (21 incremented), `ports::telnet` is 22, `ports::smtp` is 25, and `ports::http`
    is 80.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ports::ftp`的值为21，`ports::ssh`的值为22（21递增），`ports::telnet`为22，`ports::smtp`为25，`ports::http`为80。
- en: Often the point of enumerations is to provide named symbols within your code
    and their values are unimportant. Does it matter what value is assigned to `suits::hearts`?
    The intention is usually to ensure that it is different from the other values.
    In other cases, the values are important because they are a way to provide values
    to other functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，枚举的目的是在您的代码中提供命名的符号，它们的值并不重要。`suits::hearts`分配什么值有关系吗？通常的意图是确保它与其他值不同。在其他情况下，这些值很重要，因为它们是向其他函数提供值的一种方式。
- en: 'Enumerations are useful in a `switch` statement (see later) because the named
    value makes it clearer than using just an integer. You can also use an enumeration
    as a parameter to a function and hence restrict the values passed via that parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在`switch`语句中很有用（稍后会看到），因为命名值使其比仅使用整数更清晰。您还可以将枚举用作函数的参数，从而限制通过该参数传递的值：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Declaring pointers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明指针
- en: Since we are covering the use of variables, it is worth explaining the syntax
    used to define pointers and arrays because there are some potential pitfalls.
    [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml), *Working with Memory,
    Arrays, and Pointers*, covers this in more detail, so we will just introduce the
    syntax so that you are familiar with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论变量的使用，因此值得解释用于定义指针和数组的语法，因为存在一些潜在的陷阱。[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*使用内存、数组和指针*，将更详细地介绍这一点，因此我们只是介绍语法，以便您熟悉它。
- en: In C++, you will access memory using a typed pointer. The type indicates the
    type of the data that is held in the memory that is pointed to. So, if the pointer
    is an (`4` byte) integer pointer, it will point to four bytes that can be used
    as an integer. If the integer pointer is incremented, then it will point to the
    next four bytes, which can be used as an integer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您将使用类型化指针访问内存。类型指示指向的内存中保存的数据类型。因此，如果指针是（4字节）整数指针，它将指向可以用作整数的四个字节。如果整数指针被递增，那么它将指向下一个四个字节，这些字节可以用作整数。
- en: Don't worry if you find pointers confusing at this point. [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers*, will explain this in more detail.
    The purpose of introducing pointers at this time is to make you aware of the syntax.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现指针令人困惑，不要担心。[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*使用内存、数组和指针*，将更详细地解释这一点。此时介绍指针的目的是让您了解语法。
- en: 'In C++, pointers are declared using the `*` symbol and you access a memory
    address with the `&` operator:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，指针使用`*`符号声明，并使用`&`运算符访问内存地址：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first line declares a variable, `p`, which will be used to hold the memory
    address of an integer. The second line declares an integer and assigns it a value.
    The third line assigns a value to the pointer `p` to be the address of the integer
    variable just declared. It is important to stress that the value of `p` *is not*
    `42`; it will be a memory address where the value of `42` is stored.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明一个变量`p`，用于保存整数的内存地址。第二行声明一个整数并为其分配一个值。第三行将一个值分配给指针`p`，使其成为刚刚声明的整数变量的地址。需要强调的是，`p`的值*不是*`42`；它将是存储`42`值的内存地址。
- en: 'Note how the declaration has the `*` on the variable name. This is common convention.
    The reason is that if you declare several variables in one statement, the `*`
    applies only to the immediate variable. So, for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意声明中变量名称上的`*`。这是常见的约定。原因是，如果您在一个语句中声明多个变量，则`*`仅适用于直接变量。例如：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Initially this looks like you are declaring two integer pointers. However,
    this line does not do this; it declares just one pointer to integer called `p1`.
    The second variable is an integer called `p2`. The preceding line is equivalent
    to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最初看起来好像您在声明两个整数指针。但是，这行并不是这样做的；它只声明了一个名为`p1`的整数指针。第二个变量是一个名为`p2`的整数。前一行等同于以下内容：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you wish to declare two integers in one statement, then you should do it
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在一条语句中声明两个整数，那么应该这样做：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using namespaces
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间
- en: Namespaces give you one mechanism to modularize code. A namespace allows you
    to label your types, functions, and variables with a unique name so that, using
    the scope resolution operator, you can give a *fully qualified name*. The advantage
    is that you know exactly which item will be called. The disadvantage is that using
    a fully qualified name you are in effect switching off C++'s *argument-dependent
    lookup* mechanism for overloaded functions where the compiler will choose the
    function that has the best fit according to the arguments passed to the function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间为您提供了一种模块化代码的机制。命名空间允许您使用作用域解析运算符为您的类型、函数和变量打上唯一的标签，以便您可以给出*完全限定的名称*。优点是您确切地知道将调用哪个项目。缺点是，使用完全限定的名称实际上关闭了C++的*参数相关查找*机制，对于重载函数，编译器将根据传递给函数的参数选择最佳匹配的函数。
- en: 'Defining a namespace is simple: you decorate the types, functions, and global
    variables with the `namespace` keyword and the name you give to it. In the following
    example, two functions are defined in the `utilities` namespace:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 定义命名空间很简单：您使用`namespace`关键字和您给它的名称来装饰类型、函数和全局变量。在以下示例中，两个函数在`utilities`命名空间中定义：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Do not use semicolon after the closing bracket.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在右括号后不要使用分号。
- en: 'Now when you use these symbols, you need to qualify the name with the namespace:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您使用这些符号时，您需要用命名空间限定名称：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The namespace declaration may just declare the functions, in which case the
    actual functions would have to be defined elsewhere, and you will need to use
    a qualified name:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间声明可能只声明函数，此时实际函数必须在其他地方定义，并且您需要使用限定名称：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One use of namespaces is to version your code. The first version of your code
    may have a side-effect that is not in your functional specification and is technically
    a bug, but some callers will use it and depend on it. When you update your code
    to fix the bug, you may decide to allow your callers the option to use the old
    version so that their code does not break. You can do this with a namespace:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的一个用途是对代码进行版本控制。代码的第一个版本可能具有一个不在功能规范中的副作用，从技术上讲是一个错误，但一些调用者会使用它并依赖它。当您更新代码以修复错误时，您可能决定允许调用者选择使用旧版本，以便他们的代码不会出错。您可以使用命名空间来实现这一点：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now callers who want a specific version can call the fully qualified names,
    for example, callers could use `utilities::V2::poll_data` to use the newer version
    and `utilities::poll_data` to use the older version. When an item in a specific
    namespace calls an item in the same namespace, it does not have to use a qualified
    name. So, if the `new_feature` function calls `get_data`, it will be `utilities::V2::get_data`
    that is called. It is important to note that, to declare a nested namespace, you
    have to do the nesting manually (as shown here); you cannot simply declare a namespace
    called `utilities::V2`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想要特定版本的调用者可以调用完全限定的名称，例如，调用者可以使用`utilities::V2::poll_data`来使用更新版本，使用`utilities::poll_data`来使用旧版本。当特定命名空间中的项目调用同一命名空间中的项目时，它不必使用限定名称。因此，如果`new_feature`函数调用`get_data`，将调用`utilities::V2::get_data`。重要的是要注意，要声明嵌套命名空间，您必须手动进行嵌套（如此处所示）；您不能简单地声明一个名为`utilities::V2`的命名空间。
- en: 'The preceding example has been written so that the first version of the code
    will call it using the namespace `utilities`. C++11 provides a facility called
    an **inline** namespace that allows you to define a nested namespace, but allows
    the compiler to treat the items as being in the parent namespace when it performs
    an argument-dependent lookup:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是这样编写的，以便代码的第一个版本将使用`utilities`命名空间进行调用。C++11提供了一个名为**内联**命名空间的设施，允许您定义嵌套命名空间，但允许编译器在执行参数相关查找时将项目视为在父命名空间中：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now to call the first version of `get_data`, you can use `utilities::get_data`
    or `utilities::V1::get_data`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要调用`get_data`的第一个版本，您可以使用`utilities::get_data`或`utilities::V1::get_data`。
- en: 'Fully qualified names can make the code difficult to read, especially if your
    code will only use one namespace. To help here you have several options. You can
    place a `using` statement to indicate that symbols declared in the specified namespace
    can be used without a fully qualified name:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完全限定的名称可能会使代码难以阅读，特别是如果您的代码只使用一个命名空间。在这里，您有几个选项可以帮助。您可以放置一个`using`语句来指示可以在指定的命名空间中声明的符号可以在不使用完全限定名称的情况下使用：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can still use fully qualified names, but this statement allows you to ease
    the requirement. Note that a nested namespace is a member of a namespace, so the
    preceding `using` statement means that you can call the second version of `get_data`
    with either `utilities::V2::get_data` or `V2::get_data`. If you use the unqualified
    name, then it means that you will call `utilities::get_data`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以使用完全限定的名称，但此语句允许您放宽要求。请注意，嵌套命名空间是命名空间的成员，因此前面的`using`语句意味着您可以使用`utilities::V2::get_data`或`V2::get_data`调用`get_data`的第二个版本。如果使用未限定名称，则意味着您将调用`utilities::get_data`。
- en: 'A namespace can contain many items, and you may decide that you only want to
    relax the use of fully qualified names with just a few of them. To do this, use
    `using` and give the name of the item:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以包含许多项目，您可能决定只想放宽对其中一些项目的完全限定名称的使用。要做到这一点，使用`using`并给出项目的名称：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code says that, whenever `cout` is used, it refers to `std::cout`. You
    can use `using` within a function, or you can put it as file scope and make the
    intention global to the file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码表示，每当使用`cout`时，它都指的是`std::cout`。您可以在函数内部使用`using`，也可以将其放在文件范围，并使意图全局化到文件。
- en: 'You do not have to declare a namespace in one place, you can declare it over
    several files. The following could be in a different file to the previous declaration
    of `utilities`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在一个地方声明命名空间，可以在几个文件中声明它。以下内容可以与先前对`utilities`的声明不同的文件中：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `print_data` function is still part of the `utilities::V2` namespace.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_data`函数仍然是`utilities::V2`命名空间的一部分。'
- en: You can also put an `#include` in a namespace, in which case the items declared
    in the header file will now be part of the namespace. The standard library header
    files that have a prefix of `c` (for example, `cmath`, `cstdlib`, and `ctime`)
    give access to the C runtime functions by including the appropriate C header in
    the `std` namespace.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在命名空间中放置一个`#include`，在这种情况下，头文件中声明的项目现在将成为命名空间的一部分。具有`c`前缀的标准库头文件（例如`cmath`、`cstdlib`和`ctime`）通过在`std`命名空间中包含适当的C头文件来访问C运行时函数。
- en: 'The great advantage of a namespace is to be able to define your items with
    names that may be common, but are hidden from other code that does not know the
    namespace name of. The namespace means that the items are still available to your
    code via the fully qualified name. However, this only works if you use a unique
    namespace name, and the likelihood is that, the longer the namespace name, the
    more unique it is likely to be. Java developers often name their classes using
    a URI, and you could decide to do the same thing:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的一个巨大优势是能够使用可能是常见的名称来定义你的项目，但对于不知道命名空间名称的其他代码是隐藏的。命名空间意味着这些项目仍然可以通过完全限定的名称在你的代码中使用。然而，这仅在你使用唯一的命名空间名称时才有效，而很可能的情况是，命名空间名称越长，它就越有可能是唯一的。Java开发人员通常使用URI来命名他们的类，你也可以决定做同样的事情：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The problem is that the fully qualified name becomes quite long:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于完全限定的名称变得相当长：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can get around this issue using an alias:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用别名来解决这个问题：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: C++ allows you to define a namespace without a name, an **anonymous** namespace.
    As mentioned previously, namespaces allow you to prevent name clashes between
    code defined in several files. If you intend to use such a name in only one file
    you could define a unique namespace name. However, this could get tedious if you
    had to do it for several files. A namespace without a name has the special meaning
    that it has **internal linkage**, that is, the items can only be used in the current
    translation unit, the current file, and not in any other file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许你定义一个没有名称的命名空间，一个**匿名**命名空间。如前所述，命名空间允许你防止在多个文件中定义的代码之间发生名称冲突。如果你打算在只有一个文件中使用这样的名称，你可以定义一个唯一的命名空间名称。然而，如果你必须为多个文件做同样的事情，这可能会变得乏味。没有名称的命名空间具有特殊含义，即它具有**内部链接**，也就是说，这些项目只能在当前翻译单元，当前文件中使用，而不能在任何其他文件中使用。
- en: 'Code that is not declared in a namespace will be a member of the `global` namespace.
    You can call the code without a namespace name, but you may want to explicitly
    indicate that the item is in the `global` namespace using the scope resolution
    operator without a namespace name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有在命名空间中声明的代码将成为`global`命名空间的成员。你可以在没有命名空间名称的情况下调用代码，但你可能希望明确指出该项目在`global`命名空间中使用作用域解析运算符：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: C++ scoping of variables
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++变量的作用域
- en: 'As you saw in the previous chapter the compiler will compile your source files
    as individual items called **translation units**. The compiler will determine
    the objects and variables you declare and the types and functions you define,
    and once declared you can use any of these in the subsequent code within the scope
    of the declaration. At its very broadest, you can declare an item at the global
    scope by declaring it in a header file that will be used by all of the source
    files in your project. If you do not use a namespace it is often wise when you
    use such global variables to name them as being part of the global namespace:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到编译器会将你的源文件编译为称为**翻译单元**的单独项目。编译器将确定你声明的对象和变量以及你定义的类型和函数，一旦声明，你就可以在声明的范围内在随后的代码中使用任何这些。在最广泛的意义上，你可以通过在一个头文件中声明一个项目来在全局范围内声明它，该头文件将被项目中的所有源文件使用。如果你不使用命名空间，当你使用这样的全局变量时，将它们命名为全局命名空间的一部分通常是明智的：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code has the C++ for two source files (`version.cpp` and `print.cpp`) and
    a header file (`version.h`) included by both source files. The header file declares
    the global variable `version`, which can be used by both source files; it declares
    the variable, but does not define it. The actual variable is defined and initialized
    in `version.cpp`; it is here that the compiler will allocate memory for the variable.
    The `extern` keyword used on the declaration in the header indicates to the compiler
    that `version` has **external linkage**, that is, the name is visible in files
    other than where the variable is defined. The `version` variable is used in the `print.cpp`
    source file. In this file, the scope resolution operator (`::`) is used without
    a namespace name and hence indicates that the variable `version` is in the global
    namespace.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个C++源文件（`version.cpp`和`print.cpp`）和一个头文件（`version.h`），两个源文件都包含了这个头文件。头文件声明了全局变量`version`，可以被两个源文件使用；它声明了这个变量，但没有定义它。实际的变量在`version.cpp`中定义和初始化；编译器将在这里为变量分配内存。在头文件中声明的`extern`关键字指示编译器`version`具有**外部链接**，即该名称在变量定义所在的文件之外的文件中可见。`version`变量在`print.cpp`源文件中使用。在这个文件中，作用域解析运算符（`::`）在没有命名空间名称的情况下使用，因此表明变量`version`在全局命名空间中。
- en: 'You can also declare items that will only be used within the current translation
    unit, by declaring them within the source file before they are used (usually at
    the top of the file). This produces a level of modularity and allows you to hide
    implementation details from code in other source files. For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明只在当前翻译单元中使用的项目，方法是在使用之前在源文件中声明它们（通常在文件的顶部）。这产生了一定程度的模块化，并允许你隐藏来自其他源文件的实现细节。例如：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `print.h` header contains the interface for the code in the file `print.cpp`.
    Only those functions declared in the header will be callable by other source files.
    The caller does not need to know about the implementation of the `usage` function,
    and as you can see here it is implemented using a call to a function called `print_version`
    that is only available to code in `print.cpp`. The variable `app_name` is declared
    at file scope, so it will only be accessible to code in `print.cpp`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`print.h`头文件包含了`print.cpp`文件中代码的接口。只有在头文件中声明的函数才能被其他源文件调用。调用者不需要知道`usage`函数的实现，正如你在这里看到的，它是使用一个名为`print_version`的函数调用来实现的，该函数只能在`print.cpp`中的代码中使用。变量`app_name`在文件范围内声明，因此只能被`print.cpp`中的代码访问。'
- en: If another source file declares a variable at file scope, that is called `app_name`,
    and is also a `std::string` the file will compile, but the linker will complain
    when it tries to link the object files. The reason is that the linker will see
    the same variable defined in two places and it will not know which one to use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个源文件在文件范围内声明了一个名为`app_name`的`std::string`类型的变量，那么该文件将编译通过，但在链接目标文件时链接器会抱怨。原因是链接器会看到同一个变量在两个地方被定义，它不知道该使用哪一个。
- en: A function also defines a scope; variables defined within the function can only
    be accessed through that name. The parameters of the function are also included
    as variables within the function, so when you declare other variables, you have
    to use different names. If a parameter is not marked as `const` then you can alter
    the value of the parameter in your function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也定义了一个作用域；在函数内定义的变量只能通过该名称访问。函数的参数也被包括在函数内部作为变量，因此当你声明其他变量时，你必须使用不同的名称。如果一个参数没有标记为`const`，那么你可以在函数中改变参数的值。
- en: You can declare variables anywhere within a function as long as you declare
    them before you use them. Curly braces (`{}`) are used to define code blocks,
    and they also define local scope; if you declare a variable within a code block
    then you can only use it there. This means that you can declare variables with
    the same name outside the code block and the compiler will use the variable closest
    to the scope it is accessed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，只要在使用变量之前声明它们，就可以在任何地方声明变量。花括号（`{}`）用于定义代码块，它们还定义了局部作用域；如果在代码块内声明变量，那么只能在那里使用它。这意味着你可以在代码块外声明同名变量，编译器会使用最接近访问范围的变量。
- en: Before finishing this section, it is important to mention one aspect of the
    C++ **storage class**. A variable declared in a function means that the compiler
    will allocate memory for the variable on the stack frame created for the function.
    When the function finishes, the stack frame is torn down and the memory recycled.
    This means that, after a function returns, the values in any local variables are
    lost; when the function is called again, the variable is created anew and initialized
    again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本节之前，重要的是要提到C++ **存储类**的一个方面。在函数中声明的变量意味着编译器会在为函数创建的堆栈帧上为变量分配内存。当函数结束时，堆栈帧被销毁，内存被回收。这意味着在函数返回后，任何局部变量中的值都会丢失；当再次调用函数时，变量会被重新创建并再次初始化。
- en: 'C++ provides the `static` keyword to change this behavior. The `static` keyword
    means that the variable is allocated when the program starts just like variables
    declared at global scope. Applying `static` to a variable declared in a function
    means that the variable has internal linkage, that is, the compiler restricts
    access to that variable to that function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了`static`关键字来改变这种行为。`static`关键字意味着变量在程序启动时就像在全局范围声明的变量一样被分配。将`static`应用于在函数中声明的变量意味着该变量具有内部链接，也就是说，编译器限制对该函数的访问：
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By default, the compiler will initialize a static variable to `0`, but you can
    provide an initialization value, and this will be used when the variable is first
    allocated. When this program starts, the `value` variable will be initialized
    to `0` before the `main` function is called. The first time the `inc` function
    is called, the `value` variable is incremented to 10, which is returned by the
    function and printed to the console. When the `inc` function returns the `value`
    variable is retained, so that when the `inc` function is called again, the `value`
    variable is incremented by `5` to a value of `15`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器会将静态变量初始化为`0`，但你可以提供一个初始化值，在变量首次分配时将使用该值。当程序启动时，`value`变量将在调用`main`函数之前初始化为`0`。第一次调用`inc`函数时，`value`变量增加到10，这个值被函数返回并打印到控制台。当`inc`函数返回时，`value`变量被保留，所以当再次调用`inc`函数时，`value`变量增加了`5`，变为`15`。
- en: Using operators
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运算符
- en: Operators are used to compute a value from one or more operands. The following
    table groups all of the operators with equal *precedence* and lists their *associativity*.
    The higher in the table, the higher precedence of execution the operator has in
    an expression. If you have several operators in an expression, the compiler will
    perform the higher--precedence operators before the lower--precedence operators.
    If an expression contains operators of equal precedence, then the compiler will
    use the associativity to decide whether an operand is grouped with the operator
    to its left or right.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符用于从一个或多个操作数计算值。下表将所有具有相同*优先级*的运算符分组，并列出它们的*结合性*。表中越高的位置，表示在表达式中运算符的执行优先级越高。如果表达式中有多个运算符，编译器会先执行优先级更高的运算符，然后再执行优先级较低的运算符。如果一个表达式包含相同优先级的运算符，那么编译器将使用结合性来决定操作数是与其左边还是右边的运算符分组。
- en: There are some ambiguities in this table. A pair of parentheses can mean a function
    call or a cast and in the table these are listed as `function()` and `cast()`;
    in your code you will simply use `()`. The `+` and `-` symbols are either used
    to indicate sign (unary plus and unary minus, given in the table as `+x` and `-x`),
    or addition and subtraction (given in the table as `+` and `-`). The `&` symbol
    means either "take the address of" (listed in the table as `&x`) or bitwise `AND`
    (listed in the table as `&`). Finally, the postfix increment and decrement operators
    (listed in the table as `x++` and `x--`) have a higher precedence than the prefix
    equivalents (listed as `++x` and `--x`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格中存在一些歧义。一对括号可以表示函数调用或转换，在表格中列出为 `function()` 和 `cast()`；在您的代码中，您将简单地使用 `()`。`+`
    和 `-` 符号既用于表示符号（一元加和一元减，在表格中表示为 `+x` 和 `-x`），也用于加法和减法（在表格中表示为 `+` 和 `-`）。`&` 符号表示取地址（在表格中列为
    `&x`）或按位 `AND`（在表格中列为 `&`）。最后，后缀递增和递减运算符（在表格中列为 `x++` 和 `x--`）的优先级高于前缀等价物（列为 `++x`
    和 `--x`）。
- en: '| **Precedence and Associativity** | **Operators** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: 优先级和结合性 | 运算符
- en: '| **1**: No associativity | `::` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '1: 无结合性 | `::` '
- en: '| **2**: Left to right associativity | `.` or `-> [] function() {} x++ x--
    typeid const_cast dynamic_cast reinterpret_cast static_cast` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '2: 从左到右的结合性 | `.` 或 `-> [] function() {} x++ x-- typeid const_cast dynamic_cast
    reinterpret_cast static_cast` '
- en: '| **3**: Right to left associativity | `sizeof ++x --x ~ ! -x +x &x * new delete
    cast()` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '3: 从右到左的结合性 | `sizeof ++x --x ~ ! -x +x &x * new delete cast()` '
- en: '| **4**: Left to right associativity | `.*` or `->*` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '4: 从左到右的结合性 | `.*` 或 `->*` '
- en: '| **5**: Left to right associativity | `* / %` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '5: 从左到右的结合性 | `* / %` '
- en: '| **6**: Left to right associativity | `+ -` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '6: 从左到右的结合性 | `+ -` '
- en: '| **7**: Left to right associativity | `<< >>` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '7: 从左到右的结合性 | `<< >>` '
- en: '| **8**: Left to right associativity | `< > <= >=` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '8: 从左到右的结合性 | `< > <= >=` '
- en: '| **9**: Left to right associativity | `== !=` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '9: 从左到右的结合性 | `== !=` '
- en: '| **10**: Left to right associativity | `&` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '10: 从左到右的结合性 | `&` '
- en: '| **11**: Left to right associativity | `^` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '11: 从左到右的结合性 | `^` '
- en: '| **12**: Left to right associativity | `&#124;` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '12: 从左到右的结合性 | `&#124;` '
- en: '| **13**: Left to right associativity | `&&` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '13: 从左到右的结合性 | `&&` '
- en: '| **14**: Left to right associativity | `&#124;&#124;` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '14: 从左到右的结合性 | `&#124;&#124;` '
- en: '| **15**: Right to left associativity | `? :` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '15: 从右到左的结合性 | `? :` '
- en: '| **16**: Right to left associativity | `= *= /= %= += -= <<= >>= &= &#124;=
    ^=` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '16: 从右到左的结合性 | `= *= /= %= += -= <<= >>= &= &#124;= ^=` '
- en: '| **17**: Right to left associativity | `throw` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '17: 从右到左的结合性 | `throw` '
- en: '| **18**: Left to right associativity | `,` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '18: 从左到右的结合性 | `,` '
- en: 'For example, take a look at the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看下面的代码：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is interpreted as the multiplication being performed first, and then the
    addition. A clearer way to write the same code is:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这被解释为首先执行乘法，然后执行加法。写相同代码的更清晰的方法是：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The reason is that `*` has a higher precedence than `+` so that the multiplication
    is carried out first, and then the addition is performed:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 `*` 的优先级高于 `+`，因此首先执行乘法，然后执行加法：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, the `+` operators have the same precedence, which is higher than
    the precedence of assignment. Since `+` has left to right associativity the statement
    is interpreted as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`+` 运算符具有相同的优先级，高于赋值的优先级。由于 `+` 具有从左到右的结合性，该语句的解释如下：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That is, the first action is the addition of `b` and `c`, and the result is
    added to `d` and it is this result that is used to assign `a`. This may not seem
    important, but bear in mind that the addition could be between function calls
    (a function call has a higher precedence than `+`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，首先执行 `b` 和 `c` 的加法，然后将结果加到 `d` 上，然后将这个结果用于赋值给 `a`。这可能看起来不重要，但请记住，加法可能是在函数调用之间进行的（函数调用的优先级高于
    `+`）：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This means that the three functions are called in the order `b`, `c`, `d`, and
    then their return values are summed according to the left-to-right associativity.
    This may be important because `d` may depend on global data altered by the other
    two functions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这三个函数按照从左到右的结合性的顺序被调用，即 `b`，`c`，`d`，然后它们的返回值被相加。这可能很重要，因为 `d` 可能依赖于其他两个函数改变的全局数据。
- en: It makes your code more readable and easier to understand if you explicitly
    specify the precedence by grouping expressions with parentheses. Writing `b +
    (c * d)` makes it immediately clear which expression is executed first, whereas
    `b + c * d` means you have to know the precedence of each operator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用括号将表达式分组，可以使您的代码更易读和理解。编写 `b + (c * d)` 可以立即清楚地知道哪个表达式首先执行，而 `b + c * d`
    意味着您必须知道每个运算符的优先级。
- en: The built-in operators are overloaded, that is, the same syntax is used regardless
    of which built-in type is used for the operands. The operands must be the same
    type; if different types are used, the compiler will perform some default conversions,
    but in other cases (in particular, when operating on types of different sizes),
    you will have to perform a cast to indicate explicitly what you mean. The next
    chapter will explain this in more detail.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 内置运算符是重载的，也就是说，无论使用哪种内置类型的操作数，都使用相同的语法。操作数必须是相同的类型；如果使用不同的类型，编译器将执行一些默认转换，但在其他情况下（特别是在操作不同大小的类型时），您将不得不执行一个转换来明确表示您的意思。下一章将更详细地解释这一点。
- en: Exploring the built-in operators
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索内置运算符
- en: C++ comes with a wide range of built-in operators; most are arithmetic or logic
    operators, which will be covered in this section. The casting operators will be
    covered in the next chapter; memory operators will be covered in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working with Memory, Arrays, and Pointers,* and the object-related operators
    in [Chapter 6](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml), *Classes*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了广泛的内置运算符；大多数是算术或逻辑运算符，将在本节中介绍。强制转换运算符将在下一章中介绍；内存运算符将在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)中介绍，*处理内存、数组和指针*，对象相关的运算符将在[第6章](35dc7051-5301-4fd1-bc4c-de09a50de0ee.xhtml)中介绍，*类*。
- en: Arithmetic operators
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The arithmetic operators `+`, `-`, `/`, `*`, and `%` need little explanation
    other than perhaps the division and modulus operators. All of these operators
    act upon integer and real numeric types except for `%`, which can only be used
    with integer types. If you mix the types (say, add an integer to a floating-point
    number) then the compiler will perform an automatic conversion, as explained in
    the next chapter. The division operator `/` behaves as you expect for floating
    point variables: it produces the result of the division of the two operands. When
    you perform the division between two integers `a / b`, the result is the whole
    number of the divisor (`b`) in the dividend (`a`). The remainder of the division
    is obtained by the modulus `%`. So, for any integer, `b` (other than zero), one
    could say that, an integer `a` can be expressed as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符`+`、`-`、`/`、`*`和`%`需要很少的解释，除了除法和取模运算符。所有这些运算符都作用于整数和实数类型，除了`%`，它只能与整数类型一起使用。如果混合类型（比如，将整数加到浮点数），那么编译器将执行自动转换，如下一章所述。除法运算符`/`对浮点变量的行为与预期相符：它产生两个操作数的除法结果。当你对两个整数`a
    / b`进行除法运算时，结果是被除数（`a`）中除数（`b`）的整数部分。取模运算符`%`得到除法的余数。因此，对于任何整数`b`（非零），可以说，整数`a`可以表示如下：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that the modulus operator can only be used with integers. If you want to
    get the remainder of a floating-point division, use the standard function, `std:;remainder`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，取模运算符只能用于整数。如果要获得浮点数除法的余数，可以使用标准函数`std:;remainder`。
- en: 'Be careful when using division with integers, since fractional parts are discarded.
    If you need the fractional parts, then you may need to explicitly convert the
    numbers into real numbers. For example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用整数进行除法时要小心，因为小数部分会被舍弃。如果需要小数部分，则可能需要将数字显式转换为实数。例如：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This gives an aspect ratio of `1` when it should be `1.3333` (or `4 : 3`).
    To ensure that floating-point division is performed, rather than integer division,
    you can cast either (or both) the dividend or divisor to a floating-point number
    as explained in the next chapter.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个纵横比为`1`，而实际应为`1.3333`（或`4：3`）。为确保执行浮点数除法，而不是整数除法，可以将被除数或除数（或两者）转换为浮点数，如下一章所述。
- en: Increment and decrement operators
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递增和递减运算符
- en: 'There are two versions of these operators, prefix and postfix. As the name
    suggests, prefix means that the operator is placed on the left of the operand
    (for example, `++i`), and a postfix operator is placed to the right (`i++`). The
    `++` operator will increment the operand and the `--` operator will decrement
    it. The prefix operator means "return the value *after* the operation," and the
    postfix operator means "return the value *before* the operation." So the following
    code will increment one variable and use it to assign another:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符有两个版本，前缀和后缀。顾名思义，前缀意味着运算符放在操作数的左边（例如，`++i`），后缀运算符放在右边（`i++`）。`++`运算符将递增操作数，`--`运算符将递减操作数。前缀运算符意味着“返回操作之后的值”，后缀运算符意味着“返回操作之前的值”。因此，以下代码将递增一个变量并将其用于赋值另一个变量：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, the prefix operator is used so the variable `b` is incremented and the
    variable `a` is assigned to the value after `b` has been incremented. Another
    way of expressing this is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了前缀运算符，所以变量`b`被递增，变量`a`被赋值为`b`递增后的值。另一种表达方式是：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following code assigns a value using the postfix operator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用后缀运算符赋值：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This means that the variable `b` is incremented, but the variable `a` is assigned
    to the value before `b` has been incremented. Another way of expressing this is:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着变量`b`被递增，但变量`a`被赋值为`b`递增前的值。另一种表达方式是：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that this statement uses the comma operator, so `a` is assigned to the
    temporary variable `t` in the right-most expression.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此语句使用逗号运算符，因此`a`被赋值为右侧表达式中临时变量`t`的值。
- en: The increment and decrement operators can be applied to both integer and floating
    point numbers. The operators can also be applied to pointers, where they have
    a special meaning. When you increment a pointer variable it means *increment the
    pointer by the size of the type pointed to by the operator*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 递增和递减运算符可以应用于整数和浮点数。这些运算符也可以应用于指针，其中它们具有特殊含义。当你递增一个指针变量时，它的意思是*递增指针的大小*。
- en: Bitwise operators
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: Integers can be regarded as a series of bits, `0` or `1`. Bitwise operators
    act upon these bits compared to the bit in the same position in the other operand.
    Signed integers use a bit to indicate the sign, but bitwise operators act on every
    bit in an integer, so it is usually only sensible to use them on unsigned integers.
    In the following, all the types are marked as `unsigned`, so they are treated
    as not having a sign bit.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以被视为一系列位，`0`或`1`。位运算符作用于这些位，与另一个操作数中相同位置的位进行比较。有符号整数使用一位来表示符号，但位运算符作用于整数的每一位，因此通常只有在无符号整数上使用它们才有意义。在以下内容中，所有类型都标记为`unsigned`，因此它们被视为没有符号位。
- en: 'The `&` operator is bitwise AND, which means that each bit in the left-hand
    operand is compared with the bit in the right-hand operand in the same position.
    If both are 1, the resultant bit in the same position will be 1; otherwise, the
    resultant bit is zero:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`运算符是按位AND，这意味着将左操作数中的每个位与右操作数中相同位置的位进行比较。如果两者都为1，则相同位置的结果位将为1；否则，结果位为零：'
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, using bitwise `&` with `0x00ff` has the same effect as providing
    a mask that masks out all but the lowest byte.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用位`&`与`0x00ff`具有与提供掩码相同的效果，该掩码掩盖了除最低字节之外的所有内容。
- en: 'The bitwise OR operator `|` will return a value of 1 if either or both bits
    in the same position are 1, and a value of 0 only if both are 0:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按位OR运算符`|`将在相同位置的两个位中的任一个或两个位为1时返回值1，并且仅当两者都为0时返回值0：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'One use of the `&` operator is to find if a particular bit (or a specific collection
    of bits) is set:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`运算符的一个用途是查找特定位（或特定位的集合）是否设置：'
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `flags` variable has the bits we require, and the `test` variable is a value
    that we are examining. The value `(flags & test)` will have only those bits in
    the `test` variables that are also set in `flags`. Thus, if the result is non-zero,
    it means that at least one bit in `test` is also set in `flags`; if the result
    is exactly the same as the `flags` variable then all the bits in `flags` are set
    in `test`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags`变量具有我们需要的位，`test`变量是我们正在检查的值。值`（flags＆test）`将仅具有`flags`变量中也在`flags`中设置的`test`变量中的那些位。因此，如果结果非零，则意味着`test`中至少有一个位也在`flags`中设置；如果结果与`flags`变量完全相同，则`flags`中的所有位都在`test`中设置。'
- en: 'The exclusive OR operator `^` is used to test when the bits are different;
    the resultant bit is `1` if the bits in the operands are different, and `0` if
    they are the same. Exclusive OR can be used to flip specific bits:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 异或运算符`^`用于测试位不同的情况；如果操作数中的位不同，则结果位为`1`，如果它们相同，则为`0`。异或运算可以用于翻转特定位：
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The final bitwise operator is the bitwise complement `~`. This operator is applied
    to a single integer operand and returns a value where every bit is the complement
    of the corresponding bit in the operand; so if the operand bit is 1, the bit in
    the result is 0, and if the bit in the operand is 0, the bit in the result is
    1\. Note that all bits are examined, so you need to be aware of the size of the
    integer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个位运算符是位取反`〜`。该运算符应用于单个整数操作数，并返回一个值，其中每个位都是操作数中相应位的补码；因此，如果操作数位为1，则结果中的位为0，如果操作数中的位为0，则结果中的位为1。请注意，所有位都会被检查，因此您需要了解整数的大小。
- en: Boolean operators
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: 'The `==` operator tests whether two values are exactly the same. If you test
    two integers then the test is obvious; for example, if `x` is 2 and `y` is 3,
    then `x == y` is obviously `false`. However, two real numbers may not be the same
    even when you think so:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符测试两个值是否完全相同。如果测试两个整数，则测试是显而易见的；例如，如果`x`为2，`y`为3，则`x == y`显然为`false`。但是，即使您认为两个实数可能不相同：'
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `double` type is a floating-point type held in 8 bytes, but this is not
    enough for the precision being used here; the value stored in the `x` variable
    is `1000000999999.9999` (to four decimal places).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`类型是一个浮点类型，占用8个字节，但这对于此处使用的精度来说是不够的；存储在`x`变量中的值为`1000000999999.9999`（保留四位小数）。'
- en: 'The `!=` operator tests if two values are not true. The operators `>` and `<`,
    test two values to see if the left-hand operand is greater than, or less than,
    the right-hand operand, the `>=` operator tests if the left-hand operand is greater
    than or equal to the right-hand operand, and the `<=` operator tests if the left-hand
    operand is less than or equal to the right-hand operand. These operators can be
    used in the `if` statement similarly to how `==` is used in the preceding example.
    The expressions using the operators return a value of type `bool` and so you can
    use them to assign values to Boolean variables:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`！=`运算符测试两个值是否不为真。运算符`>`和`<`测试两个值，以查看左操作数是否大于或小于右操作数，`>=`运算符测试左操作数是否大于或等于右操作数，`<=`运算符测试左操作数是否小于或等于右操作数。这些运算符可以在`if`语句中使用，类似于在前面的示例中使用`==`。使用运算符的表达式返回`bool`类型的值，因此您可以使用它们来为布尔变量分配值：'
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The assignment operator (`=`) has a higher precedence than the greater than
    (`>=`) operator, but we have used the parentheses to make it explicit that the
    value is tested before being used to assign the variable. You can use the `!`
    operator to negate a logical value. So, using the value of `b` obtained previously,
    you can write the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符（`=`）的优先级高于大于（`>=`）运算符，但我们已经使用括号明确表示在使用变量之前对其进行测试。您可以使用`！`运算符来否定逻辑值。因此，使用先前获得的`b`的值，您可以编写以下内容：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can combine two logical expressions using the `&&` (AND) and `||` (OR)
    operators. An expression with the `&&` operator is true only if both operands
    are `true`, whereas an expression with the `||` operator is `true` if either,
    or both, operands are `true`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`&&`（AND）和`||`（OR）运算符组合两个逻辑表达式。具有`&&`运算符的表达式仅在两个操作数都为`true`时才为`true`，而具有`||`运算符的表达式仅在两个操作数中的任一个或两个操作数都为`true`时才为`true`：
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code involves three tests; the first tests if the `x` and `y` variables
    have the same value, the second tests if the variable `y` is less than `z`, and
    then there is a test to see if either or both of the first two tests are `true`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码涉及三个测试；第一个测试`x`和`y`变量是否具有相同的值，第二个测试变量`y`是否小于`z`，然后有一个测试，看看第一个两个测试中的任一个或两个是否为`true`。
- en: 'In a `||` expression such as this, where the first operand (`x==y`) is `true`,
    the total logical expression will be `true` regardless of the value of the right
    operand (here, `y < z`). So there is no point in testing the second expression.
    Correspondingly, in an `&&` expression, if the first operand is `false` then the
    entire expression must be `false`, and so the right-hand part of the expression
    need not be tested. The compiler will provide code to perform this *short-circuiting*
    for you:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`||`表达式中，第一个操作数（`x==y`）为`true`，则无论右操作数的值如何，总逻辑表达式都将为`true`。因此，没有必要测试第二个表达式。同样，在`&&`表达式中，如果第一个操作数为`false`，则整个表达式必须为`false`，因此无需测试表达式的右侧部分。编译器将为您提供执行此*短路*的代码：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This code tests to see if the reciprocal of `x` is less than 0.5 (or, conversely,
    that `x` is greater than 2). If the `x` variable has value 0 then the test `1/x`
    is an error but, in this case, the expression will never be executed because the
    left operand to `&&` is `false`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码测试`x`的倒数是否小于0.5（或者`x`大于2）。如果`x`变量的值为0，则测试`1/x`是一个错误，但在这种情况下，表达式永远不会被执行，因为`&&`的左操作数为`false`。
- en: Bitwise shift operators
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位移操作符
- en: 'Bitwise shift operators shift the bits in the left-hand operand integer the
    specified number of bits given in the right-hand operand, in the specified direction.
    A shift by one bit left multiplies the number by two, a shift one bit to the right
    divides by 2\. In the following a 2-byte integer is bit-shifted:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 位移操作符将左操作数整数中的位向指定方向中的右操作数指定的位数移动。向左移动一位将数字乘以2，向右移动一位将数字除以2。在以下示例中，一个2字节整数进行了位移：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this example, the `s1` variable has the fifth bit set (`0x0010` or 16). The `s2` variable
    has this value, shifted left by 8 bits, so the single bit is shifted to the 13th
    bit, and the bottom 8 bits are all set to 0 (`0x10000` or 4,096). This means that
    `0x0010` has been multiplied by 2⁸, or 256, to give `0x1000`. Next, the value
    is shifted left by another 3 bits, and the result is `0x8000`; the top bit is
    set.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，变量`s1`的第五位被设置为`0x0010`或16。变量`s2`具有此值，向左移动8位，因此单个位移动到第13位，并且底部8位全部设置为0（`0x10000`或4,096）。这意味着`0x0010`已乘以2⁸，或256，得到`0x1000`。接下来，该值再向左移动3位，结果为`0x8000`；最高位被设置。
- en: 'The operator discards any bits that overflow, so if you have the top bit set
    and shift the integer one bit left, that top bit will be discarded:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符丢弃任何溢出的位，因此如果设置了最高位并将整数向左移动一位，那么最高位将被丢弃：
- en: '[PRE69]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A final shift left by one bit results in a value 0.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后再向左移动一位将得到一个值为0。
- en: It is important to remember that, when used with a stream, the operator `<<`
    means *insert into the stream*, and when used with integers, it means *bitwise
    shift*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当与流一起使用时，操作符`<<`表示*插入到流中*，当与整数一起使用时，它表示*位移*。
- en: Assignment operators
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'The assignment operator `=` assigns an lvalue (a variable) on the left with
    the result of the rvalue (a variable or expression) on the right:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符`=`将左边的lvalue（变量）赋予右边rvalue（变量或表达式）的结果：
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first line declares an integer and initializes it to 10\. The second line
    alters the variable by adding another 10 to it, so now the variable `x` has a
    value of 20\. This is assignment. C++ allows you to change the value of a variable
    based on the variable''s value using an abbreviated syntax. The previous lines
    can be written as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明一个整数并将其初始化为10。第二行通过添加另外10来更改变量，所以现在变量`x`的值为20。这是赋值。C++允许您根据变量的值使用简化的语法更改变量的值。前面的行可以写成如下形式：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: An increment operator such as this (and the decrement operator) can be applied
    to integers and floating-point types. If the operator is applied to a pointer,
    then the operand indicates how many whole item addresses the pointer is changed
    by. For example, if an `int` is 4 bytes and you add `10` to an `int` pointer,
    the actual pointer value is incremented by 40 (10 times 4 bytes).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的增量运算符（以及减量运算符）可以应用于整数和浮点类型。如果该运算符应用于指针，则操作数指示指针更改了多少个整体项目地址。例如，如果`int`为4字节，并且您将`10`添加到`int`指针，则实际指针值将增加40（10乘以4字节）。
- en: In addition to the increment (`+=`) and decrement (`-=`) assignments, you can
    have assignments for multiply (`*=`), divide (`/=`), and remainder (`%=`). All
    of these except for the last one (`%=`) can be used for both floating-point types
    and integers. The remainder assignment can only be used on integers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除了增量（`+=`）和减量（`-=`）赋值之外，还可以进行乘法（`*=`），除法（`/=`）和取余（`%=`）的赋值。除了最后一个（`%=`）之外，所有这些都可以用于浮点类型和整数。取余赋值只能用于整数。
- en: 'You can also perform bitwise assignment operations on integers: left shift
    (`<<=`), right shift (`>>=`), bitwise AND (`&=`), bitwise OR (`|=`), and bitwise
    exclusive OR (`^=`). It usually only makes sense to apply these to unsigned integers.
    So, multiplying by eight can be carried out by both of these two lines:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以对整数执行位赋值操作：左移（`<<=`），右移（`>>=`），按位与（`&=`），按位或（`|=`），按位异或（`^=`）。通常只有对无符号整数应用这些操作才有意义。因此，通过以下两行可以进行乘以八的操作：
- en: '[PRE72]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Controlling execution flow
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制执行流程
- en: C++ provides many ways to test values and loop through code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了许多测试值和循环执行代码的方法。
- en: Using conditional statements
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: 'The most frequently used conditional statement is `if`. In its simplest form,
    the `if` statement takes a logical expression in a pair of parentheses and is
    immediately followed by the statement that is executed if the condition is `true`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的条件语句是`if`。在其最简单的形式中，`if`语句在一对括号中接受一个逻辑表达式，并紧接着执行该条件为`true`的语句：
- en: '[PRE73]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also use the `else` statement to catch occasions when the condition
    is `false`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`else`语句来捕获条件为`false`的情况：
- en: '[PRE74]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If you want to execute several statements, you can use braces (`{}`) to define
    a code block.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要执行多个语句，可以使用大括号（`{}`）来定义一个代码块。
- en: 'The condition is a logical expression and C++ will convert from numeric types
    to a `bool`, where 0 is `false` and anything not 0 is `true`. If you are not careful,
    this can be a source of an error that is not only difficult to notice, but also
    can have an unexpected side-effect. Consider the following code, which asks for
    input from the console and then tests to see if the user enters -1:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 条件是一个逻辑表达式，C++会将数值类型转换为`bool`，其中0是`false`，而非0是`true`。如果你不小心，这可能是一个难以注意到的错误源，而且可能会产生意想不到的副作用。考虑以下代码，它要求从控制台输入，然后测试用户是否输入了-1：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is contrived, but you may be asking for values in a loop and then performing
    actions on those values, except when the user enters -1, at which point the loop
    finishes. If you mistype, you may end up with the following code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是刻意的，但你可能会在循环中要求值，然后对这些值执行操作，除非用户输入-1，此时循环结束。如果你误输入，你可能会得到以下代码：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this case, the assignment operator (`=`) is used instead of the *equality*
    operator (`==`). There is just one character difference, but this code is still
    correct C++ and the compiler is happy to compile it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，赋值运算符（`=`）被用来代替*相等*运算符（`==`）。只有一个字符的差别，但这段代码仍然是正确的C++，编译器也乐意编译它。
- en: 'The result is that, regardless of what you type at the console, the variable
    `i` is assigned to -1, and since -1 is not zero, the condition in the `if` statement
    is `true`, hence the true clause of the statement is executed. Since the variable
    has been assigned to -1, this may alter logic further on in your code. The way
    to avoid this bug is to take advantage of the requirement that in an assignment
    the left-hand side must be an lvalue. Perform your test as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，无论你在控制台输入什么，变量`i`都被赋值为-1，而且由于-1不是零，`if`语句中的条件是`true`，因此执行了语句的真分支。由于变量已经被赋值为-1，这可能会改变你代码中的逻辑。避免这个bug的方法是利用赋值的要求，左侧必须是一个左值。按照以下方式进行测试：
- en: '[PRE77]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here, the logical expression is `(-1 == i)`, and since the `==` operator is
    commutative (the order of the operands does not matter; you get the same result),
    this is exactly the same as you intended in the preceding test. However, if you
    mistype the operator, you get the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，逻辑表达式是`(-1 == i)`，由于`==`运算符是可交换的（操作数的顺序不重要；你会得到相同的结果），这与你在前面的测试中打算的完全相同。然而，如果你误输入了运算符，你会得到以下结果：
- en: '[PRE78]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this case, the assignment has an rvalue on the left-hand side, and this
    will cause the compiler to issue an error (in Visual C++ this is `C2106 ''=''
    : left operand must be l-value`).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，赋值在左侧有一个rvalue，这将导致编译器发出错误（在Visual C++中是`C2106 ''='' : left operand
    must be l-value`）。'
- en: 'You are allowed to declare a variable in an `if` statement, and the scope of
    the variable is in the statement blocks. For example, a function that returns
    an integer can be called as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`if`语句中声明一个变量，变量的作用域在语句块中。例如，一个返回整数的函数可以这样调用：
- en: '[PRE79]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: While this is perfectly legal C++, there are few reasons why you would want
    to do this.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在C++中是完全合法的，但你可能会想这样做的原因很少。
- en: In some cases, the conditional operator `?:` can be used instead of an `if`
    statement. The operator executes the expression to the left of the `?` operator
    and, if the conditional expression is `true`, it executes the expression to the
    right of the `?`. If the conditional expression is `false`, it executes the expression
    to the right of the `:`. The expression that the operator executes provides the
    return value of the conditional operator.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，条件运算符`?:`可以代替`if`语句。该运算符执行`?`运算符左侧的表达式，如果条件表达式为`true`，则执行`:`右侧的表达式。如果条件表达式为`false`，则执行`:`右侧的表达式。运算符执行的表达式提供了条件运算符的返回值。
- en: 'For example, the following code determines the maximum of two variables, `a`
    and `b`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码确定了两个变量`a`和`b`的最大值：
- en: '[PRE80]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This can be expressed with the following single statement:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下单一语句来表达：
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The main choice is which ever is most readable in the code. Clearly, if the
    assignment expressions are large it may well be best to split them over lines
    in an `if` statement. However, it is useful to use the conditional statement in
    other statements. For example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 主要选择是在代码中哪个更可读。显然，如果赋值表达式很大，最好将它们分成几行放在`if`语句中。然而，在其他语句中使用条件语句也是有用的。例如：
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This code determines if the variable `number` is 1 and if so it prints on the
    console `there is 1 item`. This is because in both conditionals, if the value
    of the `number` variable is 1, the test is `true` and the first expression is
    used. Note that there is a pair of parentheses around the entire operator. The
    reason is that the stream `<<` operator is overloaded, and you want the compiler
    to choose the version that takes a string, which is the type returned by the operator
    rather than `bool`, which is the type of the expression `(number == 1)`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确定变量`number`是否为1，如果是，则在控制台上打印`there is 1 item`。这是因为在两个条件中，如果`number`变量的值为1，测试是`true`，并且使用第一个表达式。请注意，整个运算符周围有一对括号。原因是流`<<`运算符被重载了，你希望编译器选择接受字符串的版本，这是运算符返回的类型，而不是`bool`，这是表达式`(number
    == 1)`的类型。
- en: 'If the value returned by the conditional operator is an lvalue then you can
    use it on the left-hand side of an assignment. This means that you can write the
    following, rather odd, code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件运算符返回的值是一个左值，那么你可以将其用在赋值的左侧。这意味着你可以写出以下相当奇怪的代码：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The conditional operator checks to see if `i` is less than `j` and if so it
    assigns a value to `i`; otherwise, it assigns `j` with that value. This code is
    terse, but it lacks readability. It is far better in this case to use an `if`
    statement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符检查`i`是否小于`j`，如果是，则将一个值赋给`i`；否则，将`j`赋值为该值。这段代码很简洁，但缺乏可读性。在这种情况下，最好使用`if`语句。
- en: Selecting
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择
- en: 'If you want to test to see if a variable is one of several values, using multiple
    `if` statements becomes cumbersome. The C++ `switch` statement fulfills this purpose
    much better. The basic syntax is shown here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想测试变量是否是多个值中的一个，使用多个`if`语句会变得很麻烦。C++的`switch`语句更好地实现了这一目的。基本语法如下所示：
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Each `case` is essentially a label as to the specific code to be run if the
    selected variable is the specified value. The `default` clause is for values where
    there exists no `case`. You do not have to have a `default` clause, which means
    that you are testing only for specified cases. The `default` clause could be for
    the most common case (in which case, the cases filter out the less likely values)
    or it could be for exceptional values (in which case, the cases handle the most
    likely values).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`case`本质上是一个标签，用于指定如果所选变量是指定值，则要运行的特定代码。`default`子句用于不存在`case`的值。您不必有`default`子句，这意味着您只测试指定的情况。`default`子句可以是最常见的情况（在这种情况下，`case`过滤掉不太可能的值），也可以是异常值（在这种情况下，`case`处理最可能的值）。
- en: 'A `switch` statement can only test integer types (which includes `enum`), and
    you can only test for constants. The `char` type is an integer, and this means
    that you can use characters in the `case` items, but only individual characters;
    you cannot use strings:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句只能测试整数类型（包括`enum`），并且只能测试常量。`char`类型是一个整数，这意味着您可以在`case`项中使用字符，但只能使用单个字符；您不能使用字符串：'
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `break` statement indicates the end of the statements executed for a `case`.
    If you do not specify it, execution will *fall through* and the following `case`
    statements will be executed even though they have been specified for a different
    case:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句表示执行`case`的语句结束。如果您不指定它，执行将*穿透*并且将执行以下`case`语句，即使它们已被指定为不同的`case`：'
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This code shows the importance of the `break` statement. A value of 1 will print
    both `one` and `less than three` to the console, because execution *falls through*
    to the preceding `case`, even though that `case` is for another value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码显示了`break`语句的重要性。值为1将同时打印`one`和`less than three`到控制台，因为执行*穿透*到前面的`case`，即使该`case`是另一个值。
- en: It is usual to have different code for different cases, so you will most often
    finish a `case` with `break`. It is easy to miss out a `break` by mistake, and
    this will lead to unusual behavior. It is good practice to document your code
    when deliberately missing out the `break` statement so that you know that if a
    `break` is missing, it is likely to be a mistake.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通常每个`case`都有不同的代码，因此您最常会在`case`结束时使用`break`。如果不小心忽略了`break`，这将导致异常行为。在有意省略`break`语句时，最好记录您的代码，以便知道如果缺少`break`，那很可能是一个错误。
- en: You can provide zero or more statements for each `case`. If there is more than
    one statement, they are all executed for that specific case. If you provide no
    statements (as for `case 4` in this example) then it means that no statements
    will be executed, not even those in the `default` clause.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为每个`case`提供零个或多个语句。如果有多个语句，则它们都将执行该特定`case`。如果您不提供语句（例如在此示例中的`case 4`），那么这意味着不会执行任何语句，甚至不会执行`default`子句中的语句。
- en: The `break` statement means *break out of this code block*, and it behaves like
    this in the loop statements `while` and `for` as well. There are other ways that
    you can break out of a `switch`. A `case` could call `return` to finish the function
    where the `switch` is declared; it can call `goto` to jump to a label, or it can
    call `throw` to throw an exception that will be caught by an exception handler
    outside the `switch`, or even outside the function.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`语句表示*跳出此代码块*，并且在`while`和`for`循环语句中也是如此。还有其他方法可以跳出`switch`。`case`可以调用`return`来结束声明`switch`的函数；它可以调用`goto`跳转到一个标签，或者它可以调用`throw`抛出一个异常，该异常将被`switch`之外的异常处理程序捕获，甚至是函数之外。'
- en: So far, the cases are in numeric order. This is not a requirement, but it does
    make the code more readable, and clearly, if you want to *fall through* the `case`
    statements (as in `case 1` here), you should pay attention to the order the `case`
    items.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`case`是按数字顺序排列的。这不是必需的，但这样做会使代码更易读，显然，如果您想*穿透*`case`语句（就像这里的`case 1`一样），您应该注意`case`项的顺序。
- en: If you need to declare a temporary variable in a `case` handler then you must
    define a code block using braces, and this will make the scope of the variable
    localized to just that code block. You can, of course, use any variable declared
    outside of the `switch` statement in any of the `case` handlers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在`case`处理程序中声明临时变量，则必须使用大括号定义代码块，这将使变量的作用域局限于该代码块。当然，您可以在任何`case`处理程序中使用在`switch`语句之外声明的任何变量。
- en: 'Since enumerated constants are integers, you can test an `enum` in a `switch`
    statement:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于枚举常量是整数，您可以在`switch`语句中测试`enum`：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Although the `enum` here is not scoped (it is neither `enum class` nor `enum
    struct`), it is not required to specify the scope of the value in the `case`,
    but it makes the code more obvious what the constant refers to.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此处的`enum`未被作用域化（既不是`enum class`也不是`enum struct`），但不需要在`case`中指定值的作用域，但这样做会使常量所指的内容更加明显。
- en: Looping
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Most programs will need to loop through some code. C++ provides several ways
    to do this, either by iterating with an indexed value or testing a logical condition.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序都需要循环执行一些代码。C++提供了几种方法来实现这一点，可以通过使用索引值进行迭代，也可以通过测试逻辑条件来实现。
- en: Looping with iteration
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代循环
- en: 'There are two versions of the `for` statement, iteration and range-based. The
    latter was introduced in C++11\. The iteration version has the following format:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句有两个版本，迭代和基于范围的。后者是在C++11中引入的。迭代版本的格式如下：'
- en: '[PRE88]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can provide one or more loop statements, and for more than one statement,
    you should provide a code block using braces. The purpose of the loop may be served
    by the loop expression, in which case you may not want a loop statement to be
    executed; here, you use the null statement, `;` which means *do nothing*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供一个或多个循环语句，对于多个语句，应使用大括号提供代码块。循环的目的可能由循环表达式完成，在这种情况下，您可能不希望执行循环语句；在这种情况下，您可以使用空语句`；`，表示*什么也不做*。
- en: Within the parentheses are three expressions separated by semicolons. The first
    expression allows you to declare and initialize a loop variable. This variable
    is scoped to the `for` statement, so you can only use it in the `for` expressions
    or in the loop statements that follow. If you want more than one loop variable,
    you can declare them in this expression using the comma operator.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内是由分号分隔的三个表达式。第一个表达式允许您声明和初始化循环变量。此变量的作用域限定为`for`语句，因此您只能在`for`表达式或随后的循环语句中使用它。如果您想要多个循环变量，可以使用逗号运算符在此表达式中声明它们。
- en: 'The `for` statement will loop while the condition expression is `true`; so
    if you are using a loop variable, you can use this expression to check the value
    of the loop variable. The third expression is called at the end of the loop, after
    the loop statement has been called; following this, the condition expression is
    called to see if the loop should continue. This final expression is often used
    to update the value of the loop variable. For example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句将在条件表达式为`true`时循环; 因此，如果您使用循环变量，可以使用此表达式来检查循环变量的值。第三个表达式在循环结束后调用; 随后调用循环语句，然后调用条件表达式以查看循环是否应继续。通常使用此最终表达式来更新循环变量的值。例如：'
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this code, the loop variable is `i` and it is initialized to zero. Next,
    the condition is checked, and since `i` will be less than 10, the statement will
    be executed (printing the value to the console). The next action is the loop expression; `++i`,
    is called, which increments the loop variable, `i`, and then the condition is
    checked, and so on. Since the condition is `i < 10`, this means that this loop
    will run ten times with a value of `i` between 0 and 9 (so you will see 0123456789
    on the console).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，循环变量是`i`，并且初始化为零。接下来，检查条件，由于`i`小于10，将执行该语句（将值打印到控制台）。接下来是循环表达式; 调用`++i`，它会递增循环变量`i`，然后检查条件，依此类推。由于条件是`i
    < 10`，这意味着此循环将以`i`在0和9之间的值运行十次（因此您将在控制台上看到0123456789）。
- en: The loop expression can be any expression you like, but often it increments
    or decrements a value. You do not have to change the loop variable value by 1;
    for example, you can use `i -= 5` as the loop expression to decrease the variable
    by 5 on each loop. The loop variable can be any type you like; it does not have
    to be integer, it does not even have to be numeric (for example, it could be a
    pointer, or an **iterator object** described in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*), and the condition and loop expression
    do not have to use the loop variable. In fact, you do not have to declare a loop
    variable at all!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 循环表达式可以是您喜欢的任何表达式，但通常会递增或递减值。您不必将循环变量值更改为1；例如，您可以使用`i -= 5`作为循环表达式，以在每次循环时减少变量5。循环变量可以是您喜欢的任何类型；它不必是整数，甚至不必是数字（例如，它可以是指针，或者是[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)中描述的**迭代器对象**，*使用标准库容器*），条件和循环表达式也不必使用循环变量。实际上，您根本不必声明循环变量！
- en: 'If you do not provide a loop condition then the loop will be infinite, unless
    you provide a check in the loop:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不提供循环条件，那么循环将是无限的，除非您在循环中提供检查：
- en: '[PRE90]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This uses the `break` statement introduced earlier with the `switch` statement.
    It indicates that execution exits the `for` loop, and you can also use `return`,
    `goto`, or `throw`. You will rarely see a statement that finishes using `goto`;
    however, you may see the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了早期引入的`switch`语句的`break`语句。它表示执行退出`for`循环，并且还可以使用`return`，`goto`或`throw`。您很少会看到使用`goto`结束的语句；但是，您可能会看到以下内容：
- en: '[PRE91]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In this case, there is no loop variable, no loop expression, and no conditional.
    This is an everlasting loop, and the code within the loop determines when the
    loop finishes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有循环变量，没有循环表达式，也没有条件。这是一个永恒的循环，循环内的代码决定了循环何时结束。
- en: 'The third expression in the `for` statement, the loop expression, can be anything
    you like; the only property is that it is executed at the end of a loop. You may
    choose to change another variable in this expression, or you can even provide
    several expressions separated by the comma operator. For example, if you have
    two functions, one called `poll_data` that returns `true` if there is more data
    available and `false` when there is no more data, and a function called `get_data`
    that returns the next available data item, you could use `for` as follows (bear
    in mind; this is a contrived example, to make a point):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句中的第三个表达式，循环表达式，可以是您喜欢的任何内容；唯一的属性是它在循环结束时执行。您可以选择在此表达式中更改另一个变量，或者甚至可以使用逗号运算符提供几个表达式。例如，如果您有两个函数，一个名为`poll_data`，如果有更多数据可用则返回`true`，当没有更多数据时返回`false`，以及一个名为`get_data`的函数，返回下一个可用的数据项，您可以使用`for`如下（请记住；这是一个虚构的例子，用于阐明观点）：'
- en: '[PRE92]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'When `poll_data` returns a `false` value, the loop will end. The `if` statement
    is needed because the first time the loop is called, `get_data` has not yet been
    called. A better version is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当`poll_data`返回`false`值时，循环将结束。需要`if`语句，因为第一次调用循环时，尚未调用`get_data`。更好的版本如下：
- en: '[PRE93]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Keep this example in mind for the following section.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个例子，以备后续部分使用。
- en: 'There is one other keyword that you can use in a `for` loop. In many cases,
    your `for` loop will have many lines of code and at some point, you may decide
    that the current loop has completed and you want to start the next loop (or, more
    specifically, execute the loop expression and then test the condition). To do
    this, you can call `continue`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中还有另一个关键字可以使用。在许多情况下，你的`for`循环会有很多行代码，而在某个时候，你可能会决定当前循环已经完成，你想开始下一个循环（或者更具体地说，执行循环表达式，然后测试条件）。为了做到这一点，你可以调用`continue`：
- en: '[PRE94]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this code, we print the reciprocal of the numbers 0 to 9 (`0.f` is a 4-byte
    floating-point literal). The first line in the `for` loop prints the loop variable,
    and the next line checks to see if the variable is zero. If it is, it prints a
    new line and continues, that is, the last line in the `for` loop is not executed.
    The reason is that the last line prints the reciprocal and it would be an error
    to divide any number by zero.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们打印了0到9的数的倒数（`0.f`是一个4字节的浮点文字）。`for`循环中的第一行打印循环变量，下一行检查变量是否为零。如果是，它会打印一个新行并继续，也就是说，`for`循环中的最后一行不会被执行。原因是最后一行打印了倒数，将任何数字除以零都会出错。
- en: C++11 introduces another way to use the `for` loop, which is intended to be
    used with containers. The C++ standard library contains **templates** for container
    classes. These classes contain collections of objects, and provide access to those
    items in a standard way. The standard way is to iterate through collections using
    an **iterator** object. More details about how to do this will be given in [Chapter
    8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml), *Using the Standard Library Containers*;
    the syntax requires an understanding of pointers and iterators, so we will not
    cover them here. The range-based `for` loop gives a simple mechanism to access
    items in a container without explicitly using iterators.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: C++11引入了另一种使用`for`循环的方法，这种方法旨在与容器一起使用。C++标准库包含容器类的**模板**。这些类包含对象的集合，并以标准方式提供对这些项目的访问。标准方式是使用**迭代器**对象遍历集合。如何做到这一点的更多细节将在[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)中给出，*使用标准库容器*；这种语法需要理解指针和迭代器，所以我们在这里不会涉及它们。基于范围的`for`循环提供了一种简单的机制来访问容器中的项目，而不需要显式使用迭代器。
- en: 'The syntax is simple:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 语法很简单：
- en: '[PRE95]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The first thing to point out is that there are only two expressions and they
    are separated by a colon (`:`). The first expression is used to declare the loop
    variable, which is of the type of the items in the collection being iterated through.
    The second expression gives access to the collection.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要指出的是只有两个表达式，它们之间用冒号（`:`）分隔。第一个表达式用于声明循环变量，它是正在迭代的集合中项目的类型。第二个表达式提供对集合的访问。
- en: In C++ terms, the collections that can be used are those that define a `begin`
    and `end` function that gives access to iterators, and also to stack-based arrays
    (that the compiler knows the size of).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++术语中，可以使用的集合是那些定义了`begin`和`end`函数以访问迭代器的集合，以及基于堆栈的数组（编译器知道大小）。
- en: 'The Standard Library defines a container object called a `vector`. The `vector`
    template is a class that contains items of the type specified in the angle brackets
    (`<>`); in the following code, the `vector` is initialized in a special way that
    is new to C++11, called **list initialization**. This syntax allows you to specify
    the initial values of the vector in a list between curly braces. The following
    code creates and initializes a `vector`, and then uses an iteration `for` loop
    to print out all the values:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义了一个叫做`vector`的容器对象。`vector`模板是一个包含在尖括号（`<>`）中指定类型的项目的类；在下面的代码中，`vector`以一种新的方式初始化，这是C++11中的新方法，称为**列表初始化**。这种语法允许你在花括号之间的列表中指定向量的初始值。以下代码创建和初始化了一个`vector`，然后使用迭代`for`循环打印出所有的值：
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here a `using` statement is used so that the classes `vector` and `string` do
    not have to be used with fully qualified names.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了`using`语句，这样`vector`和`string`类就不必使用完全限定的名称。
- en: 'The `vector` class has a member function called `size` (called through the
    `.` operator, which means "call this function on this object") that returns the
    number of items in the `vector`. Each item is accessed using the `at` function
    passing the item''s index. The one big problem with this code is that it uses
    random access, that is, it accesses each item using its index. This is a property
    of `vector`, but other Standard Library container types do not have random access.
    The following uses the range-based `for`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类有一个成员函数叫做`size`（通过`.`操作符调用，意思是“在这个对象上调用这个函数”），它返回`vector`中项目的数量。每个项目都可以使用`at`函数通过传递项目的索引来访问。这段代码的一个大问题是它使用了随机访问，也就是说，它使用索引访问每个项目。这是`vector`的一个特性，但其他标准库容器类型没有随机访问。以下使用基于范围的`for`：'
- en: '[PRE97]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This syntax works with any of the standard container types and for arrays allocated
    on the stack:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法适用于任何标准容器类型和在堆栈上分配的数组：
- en: '[PRE98]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, the compiler knows the size of the array (because the compiler
    has allocated the array) and so it can determine the range. The range-based `for`
    loop will iterate through all the items in the container, but as with the previous
    version you can leave the `for` loop using `break`, `return`, `throw`, or `goto`,
    and you can indicate that the next loop should be executed using the `continue`
    statement.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器知道数组的大小（因为编译器已经分配了数组），所以它可以确定范围。基于范围的`for`循环将遍历容器中的所有项目，但与之前的版本一样，你可以使用`break`、`return`、`throw`或`goto`离开`for`循环，并且你可以使用`continue`语句指示下一个循环应该执行。
- en: Conditional loops
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件循环
- en: 'In the previous section we gave a contrived example, where the condition in
    the `for` loop polled for data:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们给出了一个牵强的例子，`for`循环中的条件轮询数据：
- en: '[PRE99]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In this example, there is no loop variable used in the condition. This is a
    candidate for the `while` conditional loop:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在条件中没有使用循环变量。这是`while`条件循环的一个候选：
- en: '[PRE100]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The statement will continue to loop until the expression (`poll_data` in this
    case) has a value of `false`. As with `for`, you can exit the `while` loop with
    `break`, `return`, `throw`, or `goto`, and you can indicate that the next loop
    should be executed using the `continue` statement.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句将继续循环，直到表达式（在本例中为`poll_data`）的值为`false`。与`for`一样，您可以使用`break`、`return`、`throw`或`goto`退出`while`循环，并且可以使用`continue`语句指示应执行下一个循环。
- en: 'The first time the `while` statement is called, the condition is tested before
    the loop is executed; in some cases you may want the loop executed at least once,
    and then test the condition (most likely dependent upon the action in the loop)
    to see if the loop should be repeated. The way to do this is to use the `do-while`
    loop:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`while`语句时，在执行循环之前会测试条件；在某些情况下，您可能希望至少执行一次循环，然后测试条件（很可能取决于循环中的操作），以查看是否应重复循环。这样做的方法是使用`do-while`循环：
- en: '[PRE101]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note the semicolon after the `while` clause. This is required.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`while`子句后面的分号。这是必需的。
- en: This loop will print 5 to 1 in reverse order. The reason is that the loop starts
    with `i` initialized to 5\. The statement in the loop decrements the variable
    through a postfix operator, which means the value before the decrement is passed
    to the stream. At the end of the loop, the `while` clause tests to see if the
    variable is greater than zero. If this test is `true`, the loop is repeated. When
    the loop is called with `i` assigned to 1, the value of 1 is printed to the console
    and the variable decremented to zero, and the `while` clause will test an expression
    that is `false` and the looping will finish.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将以逆序打印1到5。原因是循环从`i`初始化为5开始。循环中的语句通过后缀运算符递减变量，这意味着在递减之前的值传递给流。循环结束时，`while`子句测试变量是否大于零。如果这个测试是`true`，则重复循环。当循环调用时，`i`赋值为1，值1被打印到控制台并将变量递减为零，`while`子句将测试一个为`false`的表达式，循环将结束。
- en: The difference between the two types of loop is that the condition is tested
    before the loop is executed in the `while` loop, and so the loop may not be executed.
    In a `do-while` loop, the condition is called after the loop, which means that,
    with a `do-while` loop, the loop statements are always called at least once.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的循环之间的区别在于，在`while`循环中，在执行循环之前测试条件，因此可能不会执行循环。在`do-while`循环中，条件在循环之后调用，这意味着使用`do-while`循环时，循环语句始终至少被调用一次。
- en: Jumping
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳转
- en: 'C++ supports jumps, and in most cases, there are better ways to branch code;
    however, for completeness, we will cover the mechanism here. There are two parts
    to a jump: a labeled statement to jump to and the `goto` statement. A label has
    the same naming rules as a variable; it is declared suffixed with a colon, and
    it must be before a statement. The `goto` statement is called using the label''s
    name:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持跳转，在大多数情况下，有更好的分支代码的方法；但是，为了完整起见，我们将在这里介绍机制。跳转有两个部分：要跳转到的标记语句和`goto`语句。标签具有与变量相同的命名规则；它以冒号结尾声明，并且必须在语句之前。使用标签的`goto`语句如下所示：
- en: '[PRE102]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The label must be in the same function as the calling `goto`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 标签必须与调用`goto`的同一函数中。
- en: Jumps are rarely used, because they encourage you to write non-structured code.
    However, if you have a routine with highly nested loops or `if` statements, it
    may make more sense and be more readable to use a `goto` to jump to clean up code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转很少使用，因为它鼓励您编写非结构化的代码。但是，如果您有高度嵌套的循环或`if`语句的例程，使用`goto`跳转到清理代码可能更有意义且更易读。
- en: Using C++ language features
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++语言特性
- en: Let's now use the features you have learned in this chapter to write an application.
    This example is a simple command-line calculator; you type an expression such
    as *6 * 7*, and the application parses the input and performs the calculation.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用本章学到的特性来编写一个应用程序。这个例子是一个简单的命令行计算器；您可以输入一个表达式，比如*6 * 7*，应用程序会解析输入并进行计算。
- en: Start Visual C++ and click the File menu, and then New, and finally, click on
    the File... option to get the New File dialog. In the left-hand pane, click on
    Visual C++, and in the middle pane, click on C++ File (.cpp), and then click on
    the Open button. Before you do anything else, save this file. Using a Visual C++
    console (a command line, which has the Visual C++ environment), navigate to the
    `Beginning_C++` folder you created in the previous chapter and create a new folder
    called `Chapter_02`. Now, in Visual C++, on the File menu, click Save Source1.cpp
    As... and in the Save File As dialog locate the `Chapter_02` folder you just created.
    In the File name box, type calc.cpp and click on the Save button.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Visual C++，单击“文件”菜单，然后单击“新建”，最后单击“文件...”选项以获取新文件对话框。在左侧窗格中，单击Visual C++，在中间窗格中，单击C++文件（.cpp），然后单击“打开”按钮。在做任何其他操作之前，请保存此文件。使用Visual
    C++控制台（Visual C++环境中的命令行），导航到您在上一章中创建的`Beginning_C++`文件夹，并创建一个名为`Chapter_02`的新文件夹。现在，在Visual
    C++中，单击“文件”菜单，单击“另存为...”，在“另存为”对话框中找到刚刚创建的`Chapter_02`文件夹。在“文件名”框中，键入calc.cpp，然后单击“保存”按钮。
- en: 'The application will use `std::cout` and `std::string`; so at the top of the
    file, add the headers that define these and, so that you do not have to use fully
    qualified names, add a `using` statement:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用`std::cout`和`std::string`；因此，在文件顶部添加定义这些的头文件，并且为了不必使用完全限定的名称，添加一个`using`语句：
- en: '[PRE103]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You will pass the expression via the command-line, so add a `main` function
    that takes command line parameters at the bottom of the file:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您将通过命令行传递表达式，因此在文件底部添加一个接受命令行参数的`main`函数：
- en: '[PRE104]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The application handles expressions in the form `arg1 op arg2` where `op` is
    an operator and `arg1` and `arg2` are the arguments. This means that, when the
    application is called, it must have four parameters; the first is the command
    used to start the application and the last three are the expression. The first
    code in the `main` function should ensure that the right number of parameters
    is provided, so at the top of this function add a condition, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序处理形式为`arg1 op arg2`的表达式，其中`op`是运算符，`arg1`和`arg2`是参数。这意味着，当调用应用程序时，必须有四个参数；第一个是用于启动应用程序的命令，最后三个是表达式。`main`函数中的第一行代码应该确保提供了正确数量的参数，因此在这个函数的顶部添加一个条件，如下所示：
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If the command is called with more or less than four parameters, a function
    `usage` is called, and then the `main` function returns, stopping the application.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令被调用时参数多于或少于四个，会调用`usage`函数，然后`main`函数返回，停止应用程序。
- en: 'Add the `usage` function before the `main` function, as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数之前添加`usage`函数，如下所示：
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This simply explains how to use the command and explains the parameters. At
    this point, you can compile the application. Since you are using the C++ Standard
    Library, you will need to compile with support for C++ exceptions, so type the
    following at the command-line:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地解释了如何使用命令并解释了参数。在这一点上，您可以编译应用程序。由于您使用了C++标准库，您需要编译支持C++异常，因此在命令行中输入以下内容：
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If you typed in the code without any mistakes, the file should compile. If
    you get any errors from the compiler, check the source file to see if the code
    is exactly as given in the preceding code. You may get the following error:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入的代码没有任何错误，文件应该可以编译。如果您从编译器那里得到任何错误，请检查源文件，看看代码是否与前面的代码完全一样。您可能会得到以下错误：
- en: '[PRE108]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This means that the console is not set up with the Visual C++ environment, so
    either close it down and start the console via the Windows Start menu, or run
    the vcvarsall.bat batch file. The steps to do both of these were given in the
    previous chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着控制台没有设置为Visual C++环境，因此要么关闭它并通过Windows开始菜单启动控制台，要么运行vcvarsall.bat批处理文件。如何执行这两个步骤在前一章中已经给出。
- en: 'Once the code has compiled you may run it. Start by running it with the correct
    number of parameters (for example, `calc 6 * 7`), and then try it with an incorrect
    number of parameters (for example, `calc 6 * 7 / 3`). Note that the space between
    the parameters is important:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码编译完成，您可以运行它。首先用正确数量的参数运行它（例如`calc 6 * 7`），然后尝试用不正确数量的参数运行它（例如`calc 6 * 7
    / 3`）。请注意参数之间的空格很重要：
- en: '[PRE109]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In the first case, the application does nothing, so all you see is a blank line.
    In the second example, the code has determined that there are not enough parameters,
    and so it prints the usage information to the console.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，应用程序什么也不做，所以您只会看到一个空行。在第二个例子中，代码已经确定参数不足，因此它会将用法信息打印到控制台。
- en: 'Next, you need to do some simple parsing of the parameters to check that the
    user has passed valid values. At the bottom of the `main` function, add the following:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要对参数进行一些简单的解析，以检查用户是否传递了有效值。在`main`函数的底部，添加以下内容：
- en: '[PRE110]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first line initializes a C++ `std::string` object with the third command-line
    parameter, which should be the operator in the expression. This simple example
    only allows a single character for the operator, so the subsequent lines check
    to make sure that the operator is a single character. The C++ `std::string` class
    has a member function called `length` that returns the number of characters in
    the string.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用第三个命令行参数初始化了一个C++ `std::string`对象，这应该是表达式中的运算符。这个简单的例子只允许运算符是单个字符，所以下面的行检查以确保运算符是单个字符。C++
    `std::string`类有一个名为`length`的成员函数，返回字符串中的字符数。
- en: The `argv[2]` parameter will have a length of at least one character (a parameter
    with no length will not be treated as a command-line parameter!), so we have to
    check if the user typed an operator longer than one character.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`argv[2]`参数的长度至少为一个字符（长度为零的参数将不被视为命令行参数！），因此我们必须检查用户是否输入了一个超过一个字符的运算符。'
- en: 'Next you need to test to ensure that the parameter is one of the restricted
    set allowed and, if the user types another operator, print an error and stop the
    processing. At the bottom of the `main` function, add the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要测试以确保参数是允许的受限集之一，如果用户输入了另一个运算符，则打印错误并停止处理。在`main`函数的底部，添加以下内容：
- en: '[PRE111]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The tests are going to be made on a character, so you need to extract this
    character from the `string` object. This code uses the `at` function, which is
    passed the index of the character you need. ([Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*, will give more details about the members
    of the `std::string` class.) The next line checks to see if the character is not
    supported. The code relies on the following values for the characters that we
    support:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将在一个字符上进行，因此您需要从`string`对象中提取这个字符。这段代码使用`at`函数，传递了您需要的字符的索引。（[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)，*使用标准库容器*，将更详细地介绍`std::string`类的成员。）下一行检查字符是否不受支持。代码依赖于我们支持的字符的以下值：
- en: '| **Character** | **Value** |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **值** |'
- en: '| `+` | `42` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `42` |'
- en: '| `*` | `43` |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `43` |'
- en: '| `-` | `45` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `-` | `45` |'
- en: '| `/` | `47` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `47` |'
- en: 'As you can see, if the character is less than `42` or greater than `47` it
    will be incorrect, but between `42` and `47` there are two characters that we
    also want to reject: `,` (`44`) and `.` (`46`). This is why we have the preceding
    conditional: "if the character is less than 42 or greater than `47`, or it is
    `44` or `46`, then reject it."'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果字符小于`42`或大于`47`，它将是不正确的，但在`42`和`47`之间还有两个我们想要拒绝的字符：`,`（`44`）和`.`（`46`）。这就是为什么我们有前面的条件：“如果字符小于42或大于`47`，或者是`44`或`46`，那么拒绝它。”
- en: 'The `char` data type is an integer, which is why the test uses integer literals.
    You could have used character literals, so the following change is just as valid:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`数据类型是一个整数，这就是为什么测试使用整数文字的原因。您可以使用字符文字，所以下面的更改同样有效：'
- en: '[PRE112]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You should use whichever you find the most readable. Since it makes less sense
    to check whether one character is *greater than* another, this book will use the
    former.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用您认为最可读的那个。因为检查一个字符是否*大于*另一个字符更没有意义，本书将使用前者。
- en: At this point, you can compile the code and test it. First try with an operator
    that is more than one character (for example, `**`) and confirm that you get the
    message that the operator should be a single character. Secondly, test with a
    character that is not a recognized operator; try any character other than `+`,
    `*`, `-`, or `/`, but it is also worth trying `.` and `,`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以编译代码并进行测试。首先尝试使用一个多于一个字符的运算符（例如`**`），并确认您收到了运算符应该是单个字符的消息。其次，尝试使用一个不被识别的运算符；尝试任何不是`+`，`*`，`-`或`/`的字符，但也值得尝试`.`和`,`。
- en: Bear in mind that the command prompt has special actions for some symbols, such
    as "`&`" and "`|`", and the command prompt may give you an error from it by parsing
    the command-line before even calling your code.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，命令提示符对一些符号有特殊操作，比如“`&`”和“`|`”，命令提示符可能会在调用代码之前解析命令行而给您带来错误。
- en: The next thing to do is to convert the arguments into a form that the code can
    use. The command-line parameters are passed to the program in an array of strings;
    however, we are interpreting some of those parameters as floating-point numbers
    (in fact, double-precision floating-point numbers). The C runtime provides a function
    called `atof`, which is available through the C++ Standard Library (in this case,
    `<iostream>` includes files that include `<cmath>`, where `atof` is declared).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是将参数转换为代码可以使用的形式。命令行参数以字符串数组的形式传递给程序；然而，我们将一些参数解释为浮点数（实际上是双精度浮点数）。C运行时提供了一个名为`atof`的函数，它可以通过C++标准库（在本例中，`<iostream>`包含了包含`<cmath>`的文件，其中声明了`atof`）。
- en: It is a bit counter-intuitive to get access to a math function such as `atof`
    through including a file associated with stream input and output. If this makes
    you uneasy, you can add a line after the `include` lines to include the `<cmath>`
    file. As mentioned in the previous chapter, the C++ Standard Library headers have
    been written to ensure that a header file is only included once, so including
    `<cmath>` twice has no ill effect. This was not done in the preceding code, because
    it was argued that `atof` is a string function and the code includes the `<string>`
    header and, indeed, `<cmath>` is included via the files the `<string>` header
    includes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含与流输入和输出相关的文件来访问`atof`这样的数学函数有点反直觉。如果这让你感到不安，你可以在`include`行后添加一行来包含`<cmath>`文件。正如前一章所述，C++标准库头文件已经被编写，以确保头文件只被包含一次，因此两次包含`<cmath>`没有任何不良影响。这在前面的代码中没有做，因为有人认为`atof`是一个字符串函数，代码包含了`<string>`头文件，而且确实，`<cmath>`是通过`<string>`头文件包含的。
- en: 'Add the following lines to the bottom of the `main` function. The first two
    lines convert the second and fourth parameters (remember, C++ arrays are zero-based
    indexed) to `double` values. The final line declares a variable to hold the result:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的底部添加以下行。前两行将第二个和第四个参数（记住，C++数组是从零开始索引的）转换为`double`值。最后一行声明一个变量来保存结果：
- en: '[PRE113]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now we need to determine which operator was passed and perform the requested
    action. We will do this with a `switch` statement. We know that the `op` variable
    will be valid, and so we do not have to provide a `default` clause to catch the
    values we have not tested for. Add a `switch` statement to the bottom of the function:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要确定传递了哪个运算符并执行请求的操作。我们将使用`switch`语句来做这个。我们知道`op`变量将是有效的，因此我们不必提供一个`default`子句来捕获我们没有测试的值。在函数的底部添加一个`switch`语句：
- en: '[PRE114]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The first three cases, `+`, `-`, and `*`, are straightforward:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个案例，`+`，`-`和`*`，都很简单：
- en: '[PRE115]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Again, since `char` is an integer, you can use it in a `switch` statement, but
    C++ allows you to check for the character values. In this case, using characters
    rather than numbers makes the code much more readable.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于`char`是一个整数，您可以在`switch`语句中使用它，但C++允许您检查字符值。在这种情况下，使用字符而不是数字使得代码更易读。
- en: 'After the `switch`, add the final code to print out the result:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`之后，添加最终代码以打印结果：
- en: '[PRE116]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: You can now compile the code and test it with calculations that involve `+`,
    `-`, and `*`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以编译代码并测试涉及`+`，`-`和`*`的计算。
- en: 'Division is a problem, because it is invalid to divide by zero. To test this
    out, add the following lines to the bottom of the `switch`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是一个问题，因为被零除是无效的。要测试这个，添加以下行到`switch`的底部：
- en: '[PRE117]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Compile and run the code, passing zero as the final parameter:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码，将零作为最后一个参数传递：
- en: '[PRE118]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The code ran successfully, and printed out the expression, but it says that
    the result is an odd value of `inf`. What is happening here?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 代码成功运行，并打印出表达式，但它说结果是一个奇怪的`inf`值。这里发生了什么？
- en: 'The division by zero assigned `result` to a value of `NAN`, which is a constant
    defined in `<math.h>` (included via `<cmath>`), and means "not a number." The
    `double` overload of the insertion operator for the `cout` object tests to see
    if the number has a valid value, and if the number has a value of `NAN`, it prints
    the string inf. In our application, we can test for a zero divisor, and we treat
    the user action of passing a zero as being an error. Thus, change the code so
    that it reads as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 被零除将`result`赋值为`NAN`，这是在`<math.h>`（通过`<cmath>`包含）中定义的一个常量，意思是“不是一个数字”。`cout`对象的`double`重载插入运算符测试看数字是否有有效值，如果数字的值是`NAN`，它打印字符串inf。在我们的应用程序中，我们可以测试零除数，并将用户传递零的操作视为错误。因此，更改代码如下：
- en: '[PRE119]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Now when the user passes zero as a divisor, you will get a `divide by zero!`
    message.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当用户将零作为除数传递时，您将得到一个`divide by zero!`的消息。
- en: You can now compile the full example and test it out. The application supports
    floating-point arithmetic using the `+`, `-`, `*`, and `/` operators, and will
    handle the case of dividing by zero.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以编译完整的示例并进行测试。该应用程序支持使用`+`、`-`、`*`和`/`运算符进行浮点运算，并将处理除以零的情况。
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to format your code, and how to identify
    expressions and statements. You have learned how to identify the scope of variables,
    and how to group collections of functions and variables into namespaces so that
    you can prevent name clashes. You have also learned the basic plumbing in C++
    of looping and branching code, and how the built-in operators work. Finally, you
    put all of this together in a simple application that allows you to perform simple
    calculations at the command line.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何格式化您的代码，以及如何识别表达式和语句。您已经学会了如何识别变量的作用域，以及如何将函数和变量的集合分组到命名空间中，以防止名称冲突。您还学会了C++中循环和分支代码的基本原理，以及内置运算符的工作原理。最后，您将所有这些内容整合到一个简单的应用程序中，该应用程序允许您在命令行上执行简单的计算。
- en: In the following chapter, you will learn about C++ types and how to convert
    values from one type to another.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习关于C++类型以及如何将一个类型的值转换为另一个类型。
