- en: Porting a Game with Emscripten
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Emscripten移植游戏
- en: As demonstrated in [Chapter 7](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml), *Creating
    an Application from Scratch*, WebAssembly is still relatively limited in its current
    form. Emscripten provides powerful APIs for extending WebAssembly's capabilities
    to add functionality to your application. Compiling to a WebAssembly module and
    JavaScript glue code (instead of an executable) can, in some cases, only require
    minor changes to the existing C or C++ source.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第7章](79019325-2d3e-452c-b680-ac90522aa4bf.xhtml) 所示，*从头开始创建应用程序*，WebAssembly在当前形式下仍然相对有限。Emscripten提供了强大的API，用于扩展WebAssembly的功能，以添加功能到您的应用程序。在某些情况下，编译为WebAssembly模块和JavaScript粘合代码（而不是可执行文件）可能只需要对现有的C或C++源代码进行轻微更改。
- en: In this chapter, we're going to take a code base written in C++ that gets compiled
    to a traditional executable, and update the code so that it can be compiled to
    Wasm/JavaScript. We'll also add some additional features for tighter integration
    with the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将接受一个用C++编写的代码库，将其编译为传统可执行文件，然后更新代码，以便将其编译为Wasm/JavaScript。我们还将添加一些额外功能，以更紧密地集成到浏览器中。
- en: 'By the end of this chapter, you''ll know how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将知道如何执行以下操作：
- en: Update a C++ code base to compile to a Wasm module/JavaScript glue code (instead
    of a native executable)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新C++代码库以编译为Wasm模块/JavaScript粘合代码（而不是本机可执行文件）是很重要的
- en: Use Emscripten's APIs to add browser integration to a C++ application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Emscripten的API将浏览器集成到C++应用程序中
- en: Build a multi-file C++ project with the proper `emcc` flags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的`emcc`标志构建一个多文件的C++项目
- en: Run and test a C++ application in the browser using `emrun`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emrun`在浏览器中运行和测试C++应用程序
- en: Overview of the game
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏概述
- en: In this chapter, we're taking a Tetris clone written in C++ and updating the
    code to integrate Emscripten and compile to Wasm/JS. The code base in its original
    form compiled to an executable utilizes SDL2 and can be loaded from the command
    line. In this section, we're going to briefly review what Tetris is, how to get
    the code (without having to write it from scratch), and how to get it running.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将接受一个用C++编写的俄罗斯方块克隆，并更新代码以集成Emscripten并编译为Wasm/JS。原始形式的代码库利用SDL2编译为可执行文件，并可以从命令行加载。在本节中，我们将简要回顾一下俄罗斯方块是什么，如何获取代码（而无需从头开始编写），以及如何运行它。
- en: What is Tetris?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是俄罗斯方块？
- en: In Tetris, the main objective of the game is to rotate and move pieces (*Tetriminos*)
    of various shapes within a playing field (*well* or *matrix*) to create a row
    of blocks without gaps. When a full row is created, it is deleted from the playing
    field and your score is increased by one. In our version of the game, there won't
    be a win condition (although it would be simple to add it).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯方块的主要目标是在游戏区域内旋转和移动各种形状的方块（*Tetriminos*），以创建没有间隙的一行方块。当创建了一整行时，它将从游戏区域中删除，并且您的得分将增加一分。在我们的游戏版本中，不会有获胜条件（尽管很容易添加）。
- en: 'It''s important to understand the rules and mechanics of the game because the
    code uses algorithms for concepts such as collision detection and scoring. Understanding
    the goal of a function helps you understand the code within. I recommend you give
    it a try online if you need to brush up on your Tetris skills. You can play it
    at [https://emulatoronline.com/nes-games/classic-tetris/](https://emulatoronline.com/nes-games/classic-tetris/)
    without having to install Adobe Flash. It looks just like the original Nintendo
    Version:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要了解游戏的规则和机制，因为代码使用算法来实现诸如碰撞检测和记分等概念。了解函数的目标有助于理解其中的代码。如果需要提高俄罗斯方块技能，我建议您在线尝试一下。您可以在[https://emulatoronline.com/nes-games/classic-tetris/](https://emulatoronline.com/nes-games/classic-tetris/)上玩，无需安装Adobe
    Flash。它看起来就像原始的任天堂版本：
- en: '![](img/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60566c17-a951-44f8-a3f4-a1e2bf8c6115.png)'
- en: Classic Tetris at EmulatorOnline.com
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在EmulatorOnline.com上玩经典的俄罗斯方块
- en: The version we'll be working with won't contain the piece counters, levels,
    or points (we're sticking to line counts), but it will operate in the same way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的版本不包含方块计数器、级别或分数（我们只关注行数），但其操作方式将相同。
- en: The source of the source
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源的源
- en: It turns out that a search for Tetris C++ provides a multitude of tutorials
    and example repositories to choose from. In the interest of sticking to the formatting
    and naming conventions that I've been using up to this point, I combined these
    resources to create my own version of the game. The *Further reading* section
    at the end of this chapter has links to these resources if you're interested in
    learning more. The concepts and process for porting a code base are applicable,
    regardless of the source. On that note, let's take a brief step-aside to discuss
    porting in general.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，搜索Tetris C++会提供大量的教程和示例存储库供选择。为了保持到目前为止使用的格式和命名约定，我将这些资源结合起来创建了自己的游戏版本。本章结束时的*进一步阅读*部分中有这些资源的链接，如果您有兴趣了解更多。无论来源如何，移植代码库的概念和过程都是适用的。在这一点上，让我们简要讨论一下移植的一般情况。
- en: A note about porting
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于移植的说明
- en: 'Porting an existing code base to Emscripten is not always a simple task. There
    are several variables to take into account when evaluating whether a C, C++, or
    Rust application is amenable to conversion. For example, games that make use of
    several third-party libraries or even a few third-party libraries that are of
    considerable complexity may require a significant amount of effort. Emscripten
    provides the following commonly used libraries out of the box:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有代码库移植到Emscripten并不总是一项简单的任务。在评估C、C++或Rust应用程序是否适合转换时，需要考虑几个变量。例如，使用多个第三方库的游戏，甚至使用几个复杂的第三方库可能需要大量的工作。Emscripten提供了以下常用库：
- en: '`asio`: A network and low-level I/O programming library'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asio`：一个网络和低级I/O编程库'
- en: '`Bullet`: A real-time collision detection and multi-physics simulation library'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bullet`：一个实时碰撞检测和多物理模拟库'
- en: '`Cocos2d`: A suite of open source, cross-platform, game development tools'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cocos2d`：一套开源的跨平台游戏开发工具'
- en: '`FreeType`: A library used to render fonts'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeType`：用于呈现字体的库'
- en: '`HarfBuzz`: An OpenType text shaping engine'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HarfBuzz`：一个OpenType文本整形引擎'
- en: '`libpng`: The official PNG reference library'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libpng`：官方PNG参考库'
- en: '`Ogg`: A multimedia container format'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ogg`：一个多媒体容器格式'
- en: '`SDL2`: A library designed to provide low-level access to audio, a keyboard,
    a mouse, a joystick, and graphics hardware'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2`：设计用于提供对音频、键盘、鼠标、操纵杆和图形硬件的低级访问的库'
- en: '`SDL2_image`: An image file loading library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_image`：一个图像文件加载库'
- en: '`SDL2_mixer`: A sample multi-channel audio mixer library'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_mixer`：一个示例多通道音频混音库'
- en: '`SDL2_net`: A small sample cross-platform networking library'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_net`：一个小型的跨平台网络库'
- en: '`SDL2_ttf`: A sample library that allows you to use TrueType fonts in your
    SDL applications'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDL2_ttf`：一个示例库，允许您在SDL应用程序中使用TrueType字体'
- en: '`Vorbis`: A general purpose audio and music encoding format'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vorbis`：通用音频和音乐编码格式'
- en: '`zlib`: A lossless data compression library'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zlib`：无损数据压缩库'
- en: If the library isn't already ported, you will need to do it yourself. This would
    benefit the community, but requires a significant investment of time and resources.
    Our Tetris example only uses SDL2, which makes the porting process relatively
    simple.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库尚未移植，您将需要自行移植。这将有利于社区，但需要大量的时间和资源投入。我们的俄罗斯方块示例只使用了SDL2，这使得移植过程相对简单。
- en: Getting the code
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: 'The code for this chapter is located in the `/chapter-08-tetris` folder of
    the `learn-webassembly` repository. There are two directories within `/chapter-08-tetris`:
    the `/output-native` folder, which contains the original (pre-ported) code and
    the `/output-wasm` folder, which contains the ported code.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于`learn-webassembly`存储库的`/chapter-08-tetris`文件夹中。`/chapter-08-tetris`中有两个目录：`/output-native`文件夹，其中包含原始（未移植）代码，以及`/output-wasm`文件夹，其中包含移植后的代码。
- en: If you want to use VS Code's Task feature for the native build step, you'll
    need to open the `/chapter-08-tetris/output-native` folder in VS Code, not the
    top-level `/learn-webassembly` folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用VS Code的任务功能进行本地构建步骤，您需要在VS Code中打开`/chapter-08-tetris/output-native`文件夹，而不是顶层的`/learn-webassembly`文件夹。
- en: Building the native project
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建本地项目
- en: The `/cmake` folder and `CMakeLists.txt` file within the `/output-native` folder
    are required to build the project. The `README.md` file contains instructions
    to get the code up and running on each platform. Building the project isn't necessary
    to work through the porting process. The process for installing the required dependencies
    and getting the project to build successfully on your platform can be time-consuming
    and complex. If you still wish to proceed, you can build the executable through
    VS Code's Task feature by selecting Tasks | Run Task... from the menu and selecting
    Build Executable from the list after following the instructions in the `README.md`
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`/output-native`文件夹中的`/cmake`文件夹和`CMakeLists.txt`文件是构建项目所必需的。`README.md`文件包含了在每个平台上启动代码的说明。构建项目并不是必须要通过移植过程。在您的平台上安装所需的依赖项并成功构建项目的过程可能会耗费大量时间和精力。如果您仍然希望继续，您可以按照`README.md`文件中的说明，在选择任务
    | 运行任务... 后从列表中选择构建可执行文件来通过VS Code的任务功能构建可执行文件。'
- en: The game in action
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏的运行情况
- en: 'If you were successful in building the project, you should be able to run it
    by selecting **Tasks** | **Run Task...** from the VS Code menu and selecting the
    Start Executable task from the list. If everything was successful, you should
    see something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您成功构建了项目，您应该能够通过从VS Code菜单中选择**任务** | **运行任务...**并从列表中选择启动可执行任务来运行它。如果一切顺利，您应该会看到类似以下的内容：
- en: '![](img/34e1026f-bd47-4209-a611-671d81f98ede.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34e1026f-bd47-4209-a611-671d81f98ede.png)'
- en: Compiled game running natively
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的游戏可以本地运行
- en: Our version of the game doesn't have a losing condition; it just increments
    the ROWS count by one for each row you clear. If one of the Tetriminos touches
    the top of the board, the game is over and the board resets. It's a rudimentary
    implementation of the game, but additional features increase the complexity and
    amount of code required. Let's review the code base in more detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏版本没有失败条件；它只是每清除一行就将行数增加一。如果俄罗斯方块中的一个方块触及到了板的顶部，游戏就结束了，板重新开始。这是游戏的一个基本实现，但是额外的功能会增加复杂性和所需的代码量。让我们更详细地审查代码库。
- en: The code base in depth
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解代码库
- en: Now that you have the code available, you'll need to familiarize yourself with
    the code base. Without having a good understanding of the code you want to port,
    you'll have a much harder time porting it successfully. In this chapter, we're
    going to walk through each of the C++ class and header files and describe their
    roles in the application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以使用代码了，您需要熟悉代码库。如果您不了解要移植的代码，那么您将更难成功地进行移植。在本章中，我们将逐个讨论每个C++类和头文件，并描述它们在应用程序中的作用。
- en: Breaking the code into objects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码分解为对象
- en: C++ was designed around an object-oriented paradigm, which is what the Tetris
    code base uses to simplify management of the application. The code base consists
    of C++ class files
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++是围绕面向对象的范式设计的，这正是俄罗斯方块代码库用来简化应用程序管理的方式。代码库由C++类文件组成
- en: (`.cpp`) and header files (`.h`) that represent objects within the context of
    the game. I used the gameplay summary from the *What is Tetris?* section to extrapolate
    which objects I needed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （`.cpp`）和头文件（`.h`）代表游戏上下文中的对象。我使用了*什么是俄罗斯方块？*部分的游戏概述来推断我需要哪些对象。
- en: 'The game pieces (Tetriminos) and playing field (referred to as a well or matrix)
    are good candidates for classes. Maybe less intuitively, but still just as valid,
    is the *game* itself. Classes don''t necessarily need to be as concrete as actual
    objects — they''re excellent for storing shared code. I''m a big fan of less typing,
    so I opted to use `Piece` to represent a Tetrimino and `Board` for the playing
    field (although the word *well *is shorter, it just doesn''t quite fit). I created
    a header file to store global variables (`constants.h`), a `Game` class to manage
    gameplay, and a `main.cpp` file, which acts as the entry point for the game. Here''s
    the contents of the `/src` folder:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏方块（Tetriminos）和游戏区（称为井或矩阵）是类的良好候选对象。也许不那么直观，但同样有效的是*游戏*本身。类不一定需要像实际对象那样具体
    —— 它们非常适合存储共享代码。我很喜欢少打字，所以我选择使用`Piece`来表示一个Tetrimino，`Board`来表示游戏区（尽管*井*这个词更短，但并不太合适）。我创建了一个头文件来存储全局变量（`constants.h`），一个`Game`类来管理游戏过程，以及一个`main.cpp`文件，它作为游戏的入口点。以下是`/src`文件夹的内容：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each file (with the exception of `main.cpp` and `constants.h`) has a class (`.cpp`)
    and header (`.h`) file. Header files allow you to reuse code across multiple files
    and prevent code duplication. The *Further reading* section contains resources
    for you to learn more about header files if you're interested. The `constants.h`
    file is used in almost all of the other files within the application, so let's
    review that first.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件（除了`main.cpp`和`constants.h`）都有一个类（`.cpp`）和头文件（`.h`）。头文件允许您在多个文件中重用代码并防止代码重复。*进一步阅读*部分包含了一些资源，供您了解更多关于头文件的知识。`constants.h`文件几乎在应用程序的所有其他文件中都被使用，所以让我们首先来回顾一下它。
- en: The constants file
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量文件
- en: 'Rather than have confusing *magic numbers* sprinkled throughout the code base,
    I opted for a header file containing the constants we''ll be using (`constants.h`).
    The contents of this file are shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用一个包含我们将要使用的常量的头文件，而不是在代码库中到处使用令人困惑的*魔术数字*。这个文件的内容如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `#ifndef` statement in the first line of the file is an `#include` guard,
    which prevents the header file from being included multiple times during compilation.
    These guards are used in all of the application's header files. The purpose of
    each of these constants will become clear when we step through each of the classes.
    I included it first to provide context around the various element sizes and how
    they relate to each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件第一行的`#ifndef`语句是一个`#include`保护，它可以防止在编译过程中多次包含头文件。这些保护在应用程序的所有头文件中都被使用。每个常量的目的将在我们逐个讨论每个类时变得清晰。我首先包含它是为了提供各种元素大小及其相互关系的上下文。
- en: Let's move on to the various classes that represent aspects of the game. The
    `Piece` class represents an object at the lowest level, so we'll start there and
    work our way up to the `Board` and `Game` classes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下代表游戏各个方面的各种类。`Piece`类代表最低级别的对象，所以我们从这里开始，逐步向上到`Board`和`Game`类。
- en: The piece class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方块类
- en: 'The piece, or *Tetrimino*, is the element that can be moved and rotated on
    the board. There are seven kinds of Tetriminos — each is represented by a letter
    and has a corresponding color:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 方块，或*Tetrimino*，是可以在棋盘上移动和旋转的元素。有七种不同的Tetriminos — 每种都用一个字母表示，并有对应的颜色：
- en: '![](img/bc6eabd2-b522-4990-9973-6d5432055b3d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc6eabd2-b522-4990-9973-6d5432055b3d.png)'
- en: Tetrimino colors, taken from Wikipedia
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Tetrimino颜色，取自维基百科
- en: 'We need a way to define each piece in terms of shape, color, and current orientation.
    Each piece has four different orientations (at 90 degree increments), which results
    in 28 total variations for all pieces. The color doesn''t change, so that only
    needs to be assigned once. With that in mind, let''s first take a look at the
    header file (`piece.h`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方式来定义每个方块的形状、颜色和当前方向。每个方块有四种不同的方向（每次旋转90度），这导致了所有方块的28种总变化。颜色不会改变，所以只需要分配一次。有了这个想法，让我们首先看一下头文件（`piece.h`）：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The game uses SDL2 to render the various graphical elements and handle keyboard
    input, which is why we're passing a `SDL_Renderer` into the `draw()` function.
    You'll see how SDL2 is used in the `Game` class, but for now just be aware of
    its inclusion. The header file defines the interface for the `Piece` class; let's
    review the implementation in `piece.cpp`. We'll walk through each section of code
    and describe the functionality.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏使用SDL2来渲染各种图形元素并处理键盘输入，这就是为什么我们将`SDL_Renderer`传递给`draw()`函数。您将看到SDL2是如何在`Game`类中使用的，但现在只需知道它被包含在内即可。头文件定义了`Piece`类的接口；让我们来看一下`piece.cpp`中的实现。我们将逐段代码进行讨论并描述功能。
- en: The constructor and draw() function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和draw()函数
- en: 'The first section of code defines the constructor of the `Piece` class and
    the `draw()` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了`Piece`类的构造函数和`draw()`函数：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor initializes the class with default values. The `BoardColumns`
    and `PieceSize` values are constants from the `constants.h` file. `BoardColumns`
    represents the amount of columns that can fit on a board, which is `10` in this
    case. The `PieceSize` constant represents the area or block that a piece takes
    up in columns, which is `4`. The initial value assigned to the private `columns_`
    variable represents the center of the board.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数用默认值初始化类。`BoardColumns`和`PieceSize`的值是来自`constants.h`文件的常量。`BoardColumns`表示棋盘上可以放置的列数，在这种情况下是`10`。`PieceSize`常量表示方块在列中占据的区域或块，为`4`。分配给私有`columns_`变量的初始值表示棋盘的中心。
- en: The `draw()` function loops through all of the possible rows and columns on
    the board and fills in any cells that are populated by a piece with the color
    that corresponds to its kind. The determination for whether a cell is populated
    by a piece is performed in the `isBlock()` function, which we'll discuss next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数循环遍历棋盘上所有可能的行和列，并填充任何由棋子占据的单元格与其对应的颜色。判断单元格是否被棋子占据是在`isBlock()`函数中执行的，接下来我们将讨论这个函数。'
- en: The move(), rotate(), and isBlock() functions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: move()、rotate()和isBlock()函数
- en: 'The second section contains the logic to move or rotate the piece and determine
    its current location:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含移动或旋转方块并确定其当前位置的逻辑：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `move()` function updates the values of the private `column_` and `row_`
    variables, which dictates the piece's location on the board. The `rotate()` function
    sets the value of the private `angle_` variable to either `0`, `1`, `2`, or `3`
    (which is why `%= 4` is used).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`move()`函数更新了私有`column_`和`row_`变量的值，从而决定了方块在棋盘上的位置。`rotate()`函数将私有`angle_`变量的值设置为`0`、`1`、`2`或`3`（这就是为什么使用`%=
    4`）。'
- en: Determination for which kind of piece is shown, its location, and rotation is
    performed in the `isBlock()` function. I omitted all but the first two elements
    of the `Shapes` multi-dimensional array to avoid cluttering up the file, but the
    remaining five piece kinds are present in the actual code. I will admit that this
    isn't the most elegant implementation, but it suits our purposes just fine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 确定显示哪种类型的方块，它的位置和旋转是在`isBlock()`函数中执行的。我省略了`Shapes`多维数组的除了前两个元素之外的所有内容，以避免文件混乱，但是剩下的五种方块类型在实际代码中是存在的。我承认这不是最优雅的实现，但它完全适合我们的目的。
- en: The private `kind_` and `angle_` values are specified as dimensions in the `Shapes`
    array to pick the four corresponding `char*` elements. These four elements represent
    the four possible orientations of the piece. If the index of `column + row * PieceSize`
    in the string is an asterisk, the piece is present in the specified row and column.
    If you decide to work through one of the Tetris tutorials available on the web
    (or look at one of the many Tetris repositories on GitHub), you'll find that there
    are several different ways to calculate whether a cell is populated by a piece.
    I chose this method because it's easier to visualize the pieces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 私有的`kind_`和`angle_`值被指定为`Shapes`数组中的维度，以选择四个相应的`char*`元素。这四个元素代表方块的四种可能的方向。如果字符串中的`column
    + row * PieceSize`索引是一个星号，那么方块就存在于指定的行和列。如果你决定通过网络上的一个俄罗斯方块教程（或者查看GitHub上的许多俄罗斯方块存储库之一）来学习，你会发现有几种不同的方法来计算一个单元格是否被方块占据。我选择了这种方法，因为它更容易可视化方块。
- en: The getColumn() and getRow() functions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getColumn()`和`getRow()`函数'
- en: 'The final section of code contains functions to get the row and column of the
    piece:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一部分包含了获取方块的行和列的函数：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These functions simply return the value of the private `column_` or `row_` variable.
    Now that you have a better understanding of the `Piece` class, let's move on to
    the `Board`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只是简单地返回私有`column_`或`row_`变量的值。现在你对`Piece`类有了更好的理解，让我们继续学习`Board`。
- en: The Board class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Board类
- en: 'The `Board` contains instances of the `Piece` class and needs to detect collisions
    among the pieces, when rows are filled, and when the game is over. Let''s start
    with the contents of the header file (`board.h`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`包含`Piece`类的实例，并且需要检测方块之间的碰撞，行是否已满，以及游戏是否结束。让我们从头文件（`board.h`）的内容开始：'
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Board` has a `draw()` function like the `Piece` class as well as several
    other functions for managing rows and keeping track of which cells are populated
    on the board. The `SDL2_ttf` library is used to render the ROWS: text at the bottom
    of the window with the current score (count of rows cleared). Now, let''s take
    a look at each section of the implementation file (`board.cpp`).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`有一个`draw()`函数，类似于`Piece`类，还有一些其他函数用于管理行和跟踪棋盘上哪些单元格被占据。`SDL2_ttf`库用于在窗口底部渲染带有当前分数（清除的行数）的“ROWS:”文本。现在，让我们来看看实现文件（`board.cpp`）的每个部分。'
- en: The constructor and draw() function
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和draw()函数
- en: 'The first section of code defines the constructor of the `Board` class and
    the `draw()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了`Board`类的构造函数和`draw()`函数：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Board` constructor initializes the values of the private `cells_` and `currentScore_`
    variables to default values. The `cells_` variable is a two-dimensional array
    of Booleans, with the first dimension representing columns and the second rows.
    If a piece occupies a specific column and row, the corresponding value in the
    array is `true`. The `draw()` function behaves similarly to the `draw()` function
    of `Piece` in that it fills cells that contain pieces with color. However, this
    function only fills in cells that are occupied by pieces that have reached the
    bottom of the board with a light gray color, regardless of what kind of piece
    it is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Board`构造函数将私有`cells_`和`currentScore_`变量的值初始化为默认值。`cells_`变量是一个布尔值的二维数组，第一维表示列，第二维表示行。如果一个方块占据特定的列和行，数组中相应的值为`true`。`draw()`函数的行为类似于`Piece`中的`draw()`函数，它用颜色填充包含方块的单元格。然而，这个函数只填充被已经到达底部的方块占据的单元格，颜色为浅灰色，不管是什么类型的方块。'
- en: The isCollision() function
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: isCollision()函数
- en: 'The second section of code contains logic to detect collisions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第二部分包含了检测碰撞的逻辑：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `isCollision()` function loops through each cell on the board until it reaches
    one populated by the `&piece` passed as an argument. If the piece is about to
    collide with either side of the board or it has reached the bottom, the function
    returns `true`, otherwise it returns `false`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`isCollision()`函数循环遍历棋盘上的每个单元格，直到找到由作为参数传递的`&piece`占据的单元格。如果方块即将与棋盘的任一侧碰撞，或者已经到达底部，函数返回`true`，否则返回`false`。'
- en: The unite() function
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unite()函数
- en: 'The third section of code contains logic to unite a piece with the top row
    when it comes to rest:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第三部分包含了将方块与顶行合并的逻辑，当方块停止时。
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `unite()` function and the corresponding `isRowFull()`, `areFullRowsPresent()`,
    and `updateOffsetRow()` functions perform several operations. It updates the private
    `cells_` variable with the rows and columns that the specified `&piece` argument
    occupies by setting the appropriate array location to `true`. It also clears any
    full rows (all columns filled) from the board by setting the corresponding `cells_`
    array locations to `false` and increments the `currentScore_`. After the row is
    cleared, the `cells_` array is updated to shift the row above the cleared row
    down by `1`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`unite()`函数和相应的`isRowFull()`、`areFullRowsPresent()`和`updateOffsetRow()`函数执行多个操作。它通过将适当的数组位置设置为`true`，使用指定的`&piece`参数更新了私有的`cells_`变量，该参数占据了行和列。它还通过将相应的`cells_`数组位置设置为`false`来清除棋盘上的任何完整行（所有列都填满），并增加了`currentScore_`。清除行后，`cells_`数组被更新，将清除的行上面的行向下移动`1`。'
- en: The displayScore() function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: displayScore()函数
- en: 'The final section of code displays the score at the bottom of the game window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分在游戏窗口底部显示分数：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `displayScore()` function uses the `SDL2_ttf` library to display the current
    score at the bottom of the window (underneath the board). The `TTF_Font *font`
    argument is passed in from the `Game` class to avoid initializing the font every
    time the score is updated. The `stringstream message` variable is used to create
    the text value and set it to a C `char*` within the `TTF_RenderText_Blended()`
    function. The rest of the code draws the text on a `SDL_Rect` to ensure that it's
    properly displayed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayScore()`函数使用`SDL2_ttf`库在窗口底部（在棋盘下方）显示当前分数。`TTF_Font *font`参数从`Game`类传递进来，以避免在更新分数时每次初始化字体。`stringstream
    message`变量用于创建文本值，并将其设置为`TTF_RenderText_Blended()`函数内的C `char*`。其余代码绘制文本在`SDL_Rect`上，以确保正确显示。'
- en: That's it for the `Board` class; let's move on to the `Game` to see how it all
    fits together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Board`类的全部内容；让我们继续看看`Game`类是如何组合在一起的。
- en: The Game class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏类
- en: 'The `Game` class contains the looping function that enables you to move pieces
    around the board with key presses. Here''s the contents of the header file (`game.h`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game`类包含循环函数，使您可以通过按键在棋盘上移动方块。以下是头文件（`game.h`）的内容：'
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `loop()` function contains the game logic and manages state based on events.
    The first two lines under the `private:` header prevent more than one instance
    of the game from being created, which could cause a memory leak. The private methods
    reduce the amount of code lines in the `loop()` function, which simplifies maintenance
    and debugging. Let's move on to the implementation in `game.cpp`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数包含游戏逻辑，并根据事件管理状态。在`private:`标头下的前两行防止创建多个游戏实例，这可能会导致内存泄漏。私有方法减少了`loop()`函数中的代码行数，简化了维护和调试。让我们继续看`game.cpp`中的实现。'
- en: The constructor and destructor
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数和析构函数
- en: 'The first section of code defines the actions to perform when the class instance
    is loaded (constructor) and unloaded (destructor):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一部分定义了在加载类实例（构造函数）和卸载类实例（析构函数）时执行的操作：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constructor represents the entry point for the application, so all of the
    required resources are allocated and initialized within it. The `TTF_OpenFont()`
    function is referencing a TrueType font file downloaded from Google Fonts named
    Press Start 2P. You can view the font at [https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P).
    It's present in the `/resources` folder of the repository and gets copied into
    the same folder as the executable when the project is built. If at any point an
    error occurs when initializing the SDL2 resources, a `runtime_error` is thrown
    with details of the error. The destructor (`~Game()`) frees up the resources we
    allocated for SDL2 and `SDL2_ttf` before the application exits. This is done to
    avoid a memory leak.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数代表应用程序的入口点，因此所有必需的资源都在其中分配和初始化。`TTF_OpenFont()`函数引用了从Google Fonts下载的TrueType字体文件，名为Press
    Start 2P。您可以在[https://fonts.google.com/specimen/Press+Start+2P](https://fonts.google.com/specimen/Press+Start+2P)上查看该字体。它存在于存储库的`/resources`文件夹中，并在构建项目时复制到可执行文件所在的相同文件夹中。如果在初始化SDL2资源时发生错误，将抛出`runtime_error`并提供错误的详细信息。析构函数（`~Game()`）在应用程序退出之前释放我们为SDL2和`SDL2_ttf`分配的资源，以避免内存泄漏。
- en: The loop() function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: loop()函数
- en: 'The final section of code represents the `Game::loop`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分代表了`Game::loop`：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `loop()` function returns a Boolean as long as the `SDL_QUIT` event hasn't
    fired. Every `1` second, the `draw()` functions for the `Piece` and `Board` instances
    are executed, and the piece locations on the board are updated accordingly. The
    left, right, and down arrow keys control the piece's movement while the up arrow
    key rotates the piece by 90 degrees. Appropriate responses to key presses are
    handled in the `handleKeyEvents()` function. The `checkForCollision()` function
    determines if a new instance of the active piece collided with either side of
    the board or came to rest on top of the other pieces. If it did, a new piece is
    created. The logic for clearing the rows (via the `unite()` function of `Board`)
    is also handled in this function. We're almost done! Let's move on to the `main.cpp`
    file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数返回一个布尔值，只要`SDL_QUIT`事件尚未触发。每隔`1`秒，执行`Piece`和`Board`实例的`draw()`函数，并相应地更新棋盘上的方块位置。左、右和下箭头键控制方块的移动，而上箭头键将方块旋转90度。对按键的适当响应在`handleKeyEvents()`函数中处理。`checkForCollision()`函数确定活动方块的新实例是否与棋盘的任一侧发生碰撞，或者停在其他方块的顶部。如果是，就创建一个新方块。清除行的逻辑（通过`Board`的`unite()`函数）也在这个函数中处理。我们快要完成了！让我们继续看`main.cpp`文件。'
- en: The main file
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主文件
- en: 'There''s no header file associated with `main.cpp` because its only purpose
    is to act as an entry point to the application. In fact, the file is only seven
    lines long:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`没有关联的头文件，因为它的唯一目的是作为应用程序的入口点。实际上，该文件只有七行：'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `while` statement is exited when the `loop()` function returns `false`,
    which occurs when the `SDL_QUIT` event fires. All this file is doing is creating
    a new instance of `Game` and starting the loop. That's it for the codebase; let's
    start porting!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句在`loop()`函数返回`false`时退出，这发生在`SDL_QUIT`事件触发时。这个文件所做的就是创建一个新的`Game`实例并启动循环。这就是代码库的全部内容；让我们开始移植！'
- en: Porting to Emscripten
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植到Emscripten
- en: You have a good understanding of the code base, so now it's time to start porting
    it over with Emscripten. Fortunately, we're able to leverage some of the browser's
    features to simplify the code and completely remove a third-party library. In
    this section, we're going to update the code to compile to a Wasm module and JavaScript
    *glue* file and update some of the functionality to utilize the browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你对代码库有很好的理解，现在是时候开始用Emscripten移植了。幸运的是，我们能够利用一些浏览器的特性来简化代码，并完全移除第三方库。在这一部分，我们将更新代码以编译为Wasm模块和JavaScript
    *glue*文件，并更新一些功能以利用浏览器。
- en: Preparing for porting
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为移植做准备
- en: The `/output-wasm` folder contains the end result, but I recommend that you
    create a copy of the `/output-native` folder so that you can follow along with
    the porting process. There are VS Code Tasks set up for both native compilation
    and Emscripten compilation. If you get stuck, you can always reference the `/output-wasm`
    contents. Make sure you open your copied folder in VS Code (File | Open and select
    your copied folder), otherwise you won't be able to use the Tasks feature.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`/output-wasm`文件夹包含最终结果，但我建议你创建一个`/output-native`文件夹的副本，这样你就可以跟随移植过程。为本地编译和Emscripten编译设置了VS
    Code任务。如果你遇到困难，你可以随时参考`/output-wasm`的内容。确保你在VS Code中打开你复制的文件夹（文件 | 打开并选择你复制的文件夹），否则你将无法使用任务功能。'
- en: What's changing?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有什么改变？
- en: 'This game is an ideal candidate for porting because it uses SDL2, a widely
    used library with an existing Emscripten port. Including SDL2 in the compilation
    step requires only one additional argument passed to the `emcc` command. An Emscripten
    port of the `SDL2_ttf` library also exists, but keeping it in the code base doesn''t
    make much sense. Its sole purpose is to render the score (amount of rows cleared)
    as text. We would need to include the TTF file with the application and complicate
    the build process. Emscripten provides the means for using JavaScript code within
    our C++, so we''re going to take a much simpler route: show the score in the DOM.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏是移植的理想候选，因为它使用了SDL2，这是一个广泛使用的库，已经有了Emscripten移植。在编译步骤中包含SDL2只需要传递一个额外的参数给`emcc`命令。`SDL2_ttf`库的Emscripten移植也存在，但保留它在代码库中并没有太多意义。它的唯一目的是以文本形式呈现得分（清除的行数）。我们需要将TTF文件与应用程序一起包含，并复杂化构建过程。Emscripten提供了在我们的C++中使用JavaScript代码的方法，所以我们将采取一个更简单的方法：在DOM中显示得分。
- en: In addition to changing the existing code, we'll need to create an HTML and
    CSS file for displaying and styling the game in the browser. The JavaScript code
    we write will be minimal — we just need to load the Emscripten module and all
    our functionality is handled in the C++ code base. We'll also need to add a few
    `<div>` elements and lay them out accordingly to display the score. Let's start
    porting!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了改变现有的代码，我们还需要创建一个HTML和CSS文件来在浏览器中显示和样式化游戏。我们编写的JavaScript代码将是最小的——我们只需要加载Emscripten模块，所有功能都在C++代码库中处理。我们还需要添加一些`<div>`元素，并相应地布局以显示得分。让我们开始移植！
- en: Adding the web assets
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加web资源
- en: 'Create a folder in your project folder named `/public`. Add a new file named
    `index.html` to the `/public` folder and populate it with the following contents:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目文件夹中创建一个名为`/public`的文件夹。在`/public`文件夹中添加一个名为`index.html`的新文件，并填充以下内容：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `index.js` file being loaded in the first `<script>` tag doesn''t exist
    yet; that''ll be generated in the compilation step. Let''s add some styles to
    the elements. Create a `styles.css` file in the `/public` folder and populate
    it with the following contents:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`<script>`标签中加载的`index.js`文件尚不存在；它将在编译步骤中生成。让我们为元素添加一些样式。在`/public`文件夹中创建一个`styles.css`文件，并填充以下内容：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the Press Start 2P font we're using is hosted on Google Fonts, we can
    import it for use on the site. The CSS rules in this file handle simple layout
    and styling. That's it for the web-related files we needed to create. Now, it's
    time to update the C++ code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的Press Start 2P字体托管在Google Fonts上，我们可以导入它以在网站上使用。这个文件中的CSS规则处理简单的布局和样式。这就是我们需要创建的与web相关的文件。现在，是时候更新C++代码了。
- en: Porting the existing code
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移植现有代码
- en: We only need to edit a few files to get Emscripten working correctly. For the
    sake of simplicity and compactness, only the affected sections of code will be
    included (rather than the entire file). Let's work through the files in the same
    order as the previous section and start with `constants.h`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编辑一些文件才能正确使用Emscripten。为了简单和紧凑起见，只包含受影响的代码部分（而不是整个文件）。让我们按照上一节的顺序逐个文件进行，并从`constants.h`开始。
- en: Updating the constants file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新常量文件
- en: 'We''ll display the rows cleared count on the DOM instead of in the game window
    itself, so you can delete the `ScreenHeight` constant from the file. We no longer
    need additional space to accommodate for the score text:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在DOM上显示清除的行数，而不是在游戏窗口本身上显示，所以你可以从文件中删除`ScreenHeight`常量。我们不再需要额外的空间来容纳得分文本：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: No changes need to be made to the `Piece` class files (`piece.cpp`/`piece.h`).
    However, we will need to update the `Board` class. Let's start with the header
    file (`board.h`). Starting with the bottom and working our way up, let's update
    the `displayScore()` function. In the `<body>` section of the `index.html` file,
    there's a `<span>` element with `id="score"`. We're going to update this element
    using the `emscripten_run_script` command to display the current score. As a result,
    the `displayScore()` function becomes much shorter. The before and after is shown
    as follows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要对`Piece`类文件（`piece.cpp`/`piece.h`）进行任何更改。但是，我们需要更新`Board`类。让我们从头文件（`board.h`）开始。从底部开始，逐步更新`displayScore()`函数。在`index.html`文件的`<body>`部分，有一个`id="score"`的`<span>`元素。我们将使用`emscripten_run_script`命令来更新此元素以显示当前分数。因此，`displayScore()`函数变得更短了。变化前后如下所示。
- en: 'Here is the original version of the Board class''s `displayScore()` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Board类的`displayScore()`函数的原始版本：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the ported version of the `displayScore()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`displayScore()`函数的移植版本：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `emscripten_run_script` action simply finds the `<span>` element on the
    DOM and sets the `innerHTML` to the current score. We can''t use the `EM_ASM()`
    function here because Emscripten doesn''t recognize the `document` object. Since
    we have access to the private `currentScore_` variable in the class, we''re going
    to move the `displayScore()` call in the `draw()` function into the `unite()`
    function. This limits the amount of calls to `displayScore()` to ensure that the
    function is called only when the score has actually changed. We only need to add
    one line of code to accomplish this. Here''s what the `unite()` function looks
    like now:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`emscripten_run_script`操作只是在DOM上找到`<span>`元素，并将`innerHTML`设置为当前分数。我们无法在这里使用`EM_ASM()`函数，因为Emscripten不识别`document`对象。由于我们可以访问类中的私有`currentScore_`变量，我们将把`draw()`函数中的`displayScore()`调用移动到`unite()`函数中。这限制了对`displayScore()`的调用次数，以确保只有在分数实际改变时才调用该函数。我们只需要添加一行代码来实现这一点。现在`unite()`函数的样子如下：'
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since we''re no longer using the `SDL2_ttf` library, we can update the `draw()`
    function signature and remove the `displayScore()` function call. Here''s the
    updated `draw()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用`SDL2_ttf`库，我们可以更新`draw()`函数的签名并删除`displayScore()`函数调用。更新后的`draw()`函数如下：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `displayScore()` function call was removed from the first line of the function
    and the `TTF_Font *font` argument was removed as well. Let''s add a call to `displayScore()`
    in the constructor to ensure that the initial value is set to `0` when the game
    ends and a new one begins:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`displayScore()`函数调用已从函数的第一行中删除，并且`TTF_Font *font`参数也被删除了。让我们在构造函数中添加一个对`displayScore()`的调用，以确保当游戏结束并开始新游戏时，初始值设置为`0`。'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That''s it for the class file. Since we changed the signatures for the `displayScore()`
    and `draw()` functions, and removed the dependency for `SDL2_ttf`, we''ll need
    to update the header file. Remove the following lines from `board.h`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 课堂文件就到这里。由于我们更改了`displayScore()`和`draw()`函数的签名，并移除了对`SDL2_ttf`的依赖，我们需要更新头文件。从`board.h`中删除以下行：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We're moving right along! The final change we need to make is the also the biggest
    one. The existing code base has a `Game` class that manages the application logic
    and a `main.cpp` file that calls the `Game.loop()` function in the `main()` function.
    The looping mechanism is a while loop that continues to run as long as the `SDL_QUIT`
    event hasn't fired. We need to change our approach to accommodate for Emscripten.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在顺利进行！我们需要做的最后一个更改也是最大的一个。现有的代码库有一个`Game`类来管理应用程序逻辑，以及一个`main.cpp`文件来在`main()`函数中调用`Game.loop()`函数。循环机制是一个while循环，只要`SDL_QUIT`事件没有触发就会继续运行。我们需要改变我们的方法以适应Emscripten。
- en: 'Emscripten provides an `emscripten_set_main_loop` function that accepts an
    `em_callback_func` looping function, `fps`, and a `simulate_infinite_loop` flag.
    We can''t include the `Game` class and pass `Game.loop()` as the `em_callback_func`
    argument, because the build will fail. Instead, we''re going to eliminate the
    `Game` class completely and move the logic into the `main.cpp` file. Copy the
    contents of `game.cpp` into `main.cpp` (overwriting the existing contents) and
    delete the `Game` class files (`game.cpp`/`game.h`). Since we''re not declaring
    a class for `Game`, remove the `Game::` prefixes from the functions. The constructor
    and destructor are no longer valid (they''re no longer part of a class), so we
    need to move that logic to a different location. We also need to reorder the file
    to ensure that our called functions come before the calling functions. The final
    result looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten提供了一个`emscripten_set_main_loop`函数，接受一个`em_callback_func`循环函数、`fps`和一个`simulate_infinite_loop`标志。我们不能包含`Game`类并将`Game.loop()`作为`em_callback_func`参数，因为构建会失败。相反，我们将完全消除`Game`类，并将逻辑移到`main.cpp`文件中。将`game.cpp`的内容复制到`main.cpp`（覆盖现有内容）并删除`Game`类文件（`game.cpp`/`game.h`）。由于我们不再声明`Game`类，因此从函数中删除`Game::`前缀。构造函数和析构函数不再有效（它们不再是类的一部分），因此我们需要将该逻辑移动到不同的位置。我们还需要重新排列文件以确保我们调用的函数出现在调用函数之前。最终结果如下：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `handleKeyEvents()` and `checkForCollision()` functions haven't changed;
    we simply moved them to the top of the file. The `loop()` function return type
    was changed from `bool` to `void` as required by `emscripten_set_main_loop`. Finally,
    the code from the constructor and destructor was moved into the `main()` function
    and any references to `SDL2_ttf` were removed. Instead of the while statement
    that called the `loop()` function of `Game`, we have the `emscripten_set_main_loop(loop,
    0, 1)` call. We changed the `#include` statements at the top of the file to accommodate
    for Emscripten, SDL2, and our `Board` and `Piece` classes. That's it for changes
    — now it's time to configure the build and test out the game.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleKeyEvents()`和`checkForCollision()`函数没有改变；我们只是将它们移到了文件的顶部。`loop()`函数的返回类型从`bool`改为`void`，这是`emscripten_set_main_loop`所需的。最后，构造函数和析构函数中的代码被移动到了`main()`函数中，并且移除了对`SDL2_ttf`的任何引用。我们不再使用调用`Game`的`loop()`函数的while语句，而是使用`emscripten_set_main_loop(loop,
    0, 1)`。我们修改了文件顶部的`#include`语句以适应Emscripten、SDL2和我们的`Board`和`Piece`类。这就是所有的更改——现在是时候配置构建并测试游戏了。'
- en: Building and running the game
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行游戏
- en: With the code updated and the required web assets present, it's time to build
    and test out the game. The compilation step is similar to the previous examples
    in this book, but we're going to use a different technique to run the game. In
    this section, we're going to configure the build task to accommodate for the C++
    files and run the application using a feature provided by Emscripten.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码的更新和所需的Web资产的准备，现在是构建和测试游戏的时候了。编译步骤与本书中之前的示例类似，但我们将使用不同的技术来运行游戏。在本节中，我们将配置构建任务以适应C++文件，并使用Emscripten提供的功能来运行应用程序。
- en: Building with VS Code tasks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VS Code任务进行构建
- en: 'We''re going to configure the build in two ways: with VS Code tasks and a Makefile.
    Makefiles are nice if you prefer to use a different editor than VS Code. The `/.vscode/tasks.json`
    file already contains the tasks you''ll need to build the project. The Emscripten
    build step is the default (a set of native build tasks is also present). Let''s
    walk through each task in the `tasks` array and review what''s taking place. The
    first task deletes any existing compiled output files prior to building:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种方式配置构建：使用VS Code任务和Makefile。如果您喜欢使用VS Code以外的编辑器，Makefile是一个不错的选择。`/.vscode/tasks.json`文件已经包含了构建项目所需的任务。Emscripten构建步骤是默认的（还有一组本地构建任务）。让我们逐个检查`tasks`数组中的每个任务，看看发生了什么。第一个任务在构建之前删除任何现有的编译输出文件：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second task performs the build with the `emcc` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务使用`emcc`命令进行构建：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The related arguments are placed on the same line. The only new and unfamiliar
    addition to the `args` array is the `--bind` argument with the corresponding `.cpp`
    files. This tells Emscripten that all the files after `--bind` are required to
    build the project. Test out the build by selecting Tasks | Run Build Task... from
    the menu or using the keyboard shortcut *Cmd*/*Ctrl + Shift + B*. It takes a few
    seconds to build, but the terminal will let you know when the compilation process
    is complete. If successful, you should see an `index.js` and `index.wasm` file
    in the `/public` folder.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的参数都放在同一行上。`args`数组中唯一的新的和陌生的添加是`--bind`参数和相应的`.cpp`文件。这告诉Emscripten所有在`--bind`之后的文件都是构建项目所需的。通过从菜单中选择任务|运行构建任务...或使用键盘快捷键*Cmd*/*Ctrl
    + Shift + B*来测试构建。构建需要几秒钟，但终端会在编译过程完成时通知您。如果成功，您应该在`/public`文件夹中看到一个`index.js`和一个`index.wasm`文件。
- en: Building with a Makefile
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Makefile进行构建
- en: 'If you prefer not to use VS Code, you can use a Makefile to accomplish the
    same goal as the VS Code tasks. Create a file named `Makefile` in your project
    folder and populate it with the following contents (make sure that the file is
    using tabs, not spaces):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用VS Code，您可以使用Makefile来实现与VS Code任务相同的目标。在项目文件夹中创建一个名为`Makefile`的文件，并填充以下内容（确保文件使用制表符而不是空格）：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The operations being performed are identical to the VS Code tasks, just in
    a different format using more universal tooling. The default build step is set
    in the file, so you can run the following command within your project folder to
    compile the project:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所执行的操作与VS Code任务中执行的操作相同，只是使用更通用的工具格式。默认的构建步骤已在文件中设置，因此您可以在项目文件夹中运行以下命令来编译项目：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that you have a compiled Wasm file and JavaScript glue code, let's try running
    the game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了一个编译好的Wasm文件和JavaScript粘合代码，让我们尝试运行游戏。
- en: Running the game
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行游戏
- en: 'Instead of using serve or `browser-sync`, we''re going to use a built-in feature
    of Emscripten''s toolchain, `emrun`. It provides the added benefit of capturing
    `stdout` and `stderr` (if you pass the `--emrun` linker flag to the `emcc` command)
    and printing them to the terminal if desired. We''re not going to use the `--emrun`
    flag, but having a local web server available without having to install any additional
    dependencies is a nice added feature to be aware of. Open up a terminal instance
    within your project folder and run the following command to start the game:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Emscripten工具链的内置功能`emrun`，而不是使用`serve`或`browser-sync`。它提供了一个额外的好处，即捕获`stdout`和`stderr`（如果您将`--emrun`链接标志传递给`emcc`命令），并在需要时将它们打印到终端。我们不会使用`--emrun`标志，但是在不必安装任何额外的依赖项的情况下拥有一个本地Web服务器是一个很好的附加功能。在项目文件夹中打开一个终端实例，并运行以下命令来启动游戏：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can specify `firefox` for the browser if that''s what you''re using for
    development. The `--no_emrun_detect` flag hides a message in the terminal stating
    that the HTML page is not `emrun` capable. If you navigate to `http://localhost:6931/index.html`,
    you should see the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发中使用`firefox`，可以为浏览器指定`firefox`。`--no_emrun_detect`标志会隐藏终端中的一条消息，指出HTML页面不支持`emrun`。如果您导航到`http://localhost:6931/index.html`，您应该会看到以下内容：
- en: '![](img/700df992-90f3-4452-84da-49e770e1a1c7.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/700df992-90f3-4452-84da-49e770e1a1c7.png)'
- en: Tetris running in the browser
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的俄罗斯方块
- en: Try rotating and moving the pieces to ensure that everything is working correctly.
    The ROWS count should increment by one when you've successfully cleared a row.
    You may also notice that if you're too close to the edge of the board, you won't
    be able to rotate some of the pieces. Congratulations, you've successfully ported
    a C++ game over to Emscripten!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试旋转和移动方块，以确保一切都正常工作。当成功清除一行时，行数应该增加一。您还可能注意到，如果您离棋盘边缘太近，您将无法旋转一些方块。恭喜，您已成功将一个C++游戏移植到Emscripten！
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we ported a Tetris clone written in C++ that used SDL2 to Emscripten
    so it could be run in the browser with WebAssembly. We covered the rules of Tetris
    and how they map to the logic within the existing codebase. We also reviewed each
    file in the existing code base individually and which changes had to be made to
    successfully compile to a Wasm file and JavaScript glue code. After updating the
    existing code, we created the required HTML and CSS files, then configured a build
    step with the appropriate `emcc` flags. Once built, the game was run using Emscripten's
    `emrun` command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一个使用SDL2编写的C++ Tetris克隆移植到Emscripten，以便可以在浏览器中使用WebAssembly运行。我们介绍了Tetris的规则以及它们如何映射到现有代码库中的逻辑。我们还逐个审查了现有代码库中的每个文件以及必须进行的更改，以成功编译为Wasm文件和JavaScript粘合代码。更新现有代码后，我们创建了所需的HTML和CSS文件，然后使用适当的`emcc`标志配置了构建步骤。构建完成后，使用Emscripten的`emrun`命令运行游戏。
- en: In [Chapter 9](52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml), *Integrating with
    Node.js*, we're going to discuss how to integrate WebAssembly into Node.js and
    the benefits this integration provides.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](52c9bfe6-6178-4795-8316-09aee11e8e28.xhtml)中，*与Node.js集成*，我们将讨论如何将WebAssembly集成到Node.js中，以及这种集成提供的好处。
- en: Questions
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the pieces called in Tetris?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tetris中的方块叫什么？
- en: What is one reason for choosing not to port an existing C++ code base to Emscripten?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不将现有的C++代码库移植到Emscripten的一个原因是什么？
- en: What tool did we use to compile the game natively (for example, to an executable)?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用什么工具来将游戏编译成本机代码（例如，可执行文件）？
- en: What is the purpose of the `constants.h` file?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`constants.h`文件的目的是什么？'
- en: Why were we able to eliminate the SDL2_ttf library?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们能够消除SDL2_ttf库？
- en: Which Emscripten function did we use to start running the game?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了哪个Emscripten函数来开始运行游戏？
- en: Which argument did we add to the `emcc` command to build the game and what purpose
    does it serve?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`emcc`命令中添加了哪个参数来构建游戏，它有什么作用？
- en: What advantage does `emrun` offer over a tool like `serve` and Browsersync?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emrun`相对于`serve`和Browsersync这样的工具有什么优势？'
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Header Files in C++: [https://www.sitesbay.com/cpp/cpp-header-files](https://www.sitesbay.com/cpp/cpp-header-files)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的头文件：[https://www.sitesbay.com/cpp/cpp-header-files](https://www.sitesbay.com/cpp/cpp-header-files)
- en: SDL2 Tetris on GitHub: [https://github.com/andwn/sdl2-tetris](https://github.com/andwn/sdl2-tetris)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的SDL2 Tetris：[https://github.com/andwn/sdl2-tetris](https://github.com/andwn/sdl2-tetris)
- en: Tetris on GitHub: [https://github.com/abesary/tetris](https://github.com/abesary/tetris)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的Tetris：[https://github.com/abesary/tetris](https://github.com/abesary/tetris)
- en: Tetris - Linux on GitHub: [https://github.com/abesary/tetris-linux](https://github.com/abesary/tetris-linux)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Tetris - Linux on GitHub: [https://github.com/abesary/tetris-linux](https://github.com/abesary/tetris-linux)'
