- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding the Build Process and Exploring the GNU Toolchain
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解构建过程和探索 GNU 工具链
- en: Bare-metal programming is a journey of deep understanding and precision, and
    in this chapter, we will navigate the complex realm of the embedded firmware build
    process. Our focus is the GNU Arm Toolchain, an important element in firmware
    development. Through a blend of theory and hands-on programming exercises, you
    will gain insights into how **integrated development environments** (**IDEs**)
    streamline the build process and how these processes can be manually replicated
    using the GNU Arm Toolchain.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 原地编程是一项深入理解和精确的旅程，在本章中，我们将探索嵌入式固件构建过程的复杂领域。我们的重点是 GNU Arm 工具链，它是固件开发中的一个重要元素。通过理论与实践相结合的编程练习，你将深入了解集成开发环境（**IDEs**）如何简化构建过程，以及如何使用
    GNU Arm 工具链手动复制这些过程。
- en: As the chapter progresses, we delve into the nuances of the compiler and its
    various options, tailored for Arm Cortex microcontrollers. The programming exercise
    in this chapter is designed to help you understand and effectively utilize the
    GNU tools, from compiling and linking to analyzing the depths of the output object
    files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着章节的深入，我们将探讨编译器的细微差别及其针对 Arm Cortex 微控制器的各种选项。本章的编程练习旨在帮助你理解和有效利用 GNU 工具，从编译和链接到分析输出目标文件的深度。
- en: 'In this chapter, we shall cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: The foundations – understanding the embedded build process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础——理解嵌入式构建过程
- en: A tour of GNU binary tools for embedded systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式系统的 GNU 二进制工具之旅
- en: From IDE to command-line – watching the build process unfold
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 IDE 到命令行——观察构建过程展开
- en: By the end of the chapter, you will have an understanding of the embedded firmware
    build process and have developed the skills to fluidly switch between IDEs and
    command-line interfaces, enhancing your versatility as a firmware developer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将理解嵌入式固件构建过程，并掌握在 IDE 和命令行界面之间流畅切换的技能，这将增强你作为固件开发者的多面性。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: The foundations – understanding the embedded build process
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础——理解嵌入式构建过程
- en: The journey from high-level source code in embedded firmware development to
    an executable binary image is intricate and multilayered. This process is commonly
    referred to as the firmware build process and involves several critical stages
    – pre-processing, compilation, assembly, linking, and locating. Each of these
    stages plays an important role in transforming human-readable code into machine-executable
    instructions. *Figure 3**.1* shows the entire build process and the tools involved
    at each stage of the process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从嵌入式固件开发中的高级源代码到可执行二进制映像的旅程复杂且层次繁多。这个过程通常被称为固件构建过程，涉及几个关键阶段——预处理、编译、汇编、链接和定位。这些阶段中的每一个都在将人类可读代码转换为机器可执行指令中扮演着重要角色。*图
    3.1* 展示了整个构建过程以及每个阶段涉及的工具。
- en: '![Figure 3.1: The build process, detailing the input and output files for each
    stage and the specific tools used](img/B21914_03_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：构建过程，详细说明了每个阶段的输入和输出文件以及使用的特定工具](img/B21914_03_01.jpg)'
- en: 'Figure 3.1: The build process, detailing the input and output files for each
    stage and the specific tools used'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：构建过程，详细说明了每个阶段的输入和输出文件以及使用的特定工具
- en: Let’s examine the stages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查各个阶段。
- en: The pre-processing stage
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理阶段
- en: Pre-processing is the initial stage in the firmware build process. In this stage,
    the source code undergoes a series of transformations to prepare it for compilation.
    Typically, source files in embedded systems are written in C (`.c` files) and
    accompanied by header files (`.h` files). The preprocessor is the specialized
    tool in the build process whose task is to handle these input files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理是固件构建过程的初始阶段。在这个阶段，源代码经过一系列转换，以便为编译做准备。通常，嵌入式系统中的源文件是用 C 语言编写的（`.c` 文件），并伴随头文件（`.h`
    文件）。预处理程序是构建过程中的专用工具，其任务是处理这些输入文件。
- en: 'During pre-processing, the preprocessor executes several key operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理阶段，预处理程序执行几个关键操作：
- en: '**Stripping comments**: Comments, which are crucial for human readability but
    irrelevant for machines, are removed from code.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去除注释**：注释对于人类可读性至关重要，但对于机器来说无关紧要，因此从代码中移除。'
- en: '`#` symbol, known as preprocessor directives, are processed. These directives
    often include macro definitions (`#define`), conditional compilation instructions
    (`#ifdef`, `#ifndef`, `#endif`), and file inclusion commands (`#include`). The
    preprocessor replaces these directives with their defined values or corresponding
    code segments.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#` 符号，称为预处理器指令，被处理。这些指令通常包括宏定义（`#define`）、条件编译指令（`#ifdef`、`#ifndef`、`#endif`）和文件包含命令（`#include`）。预处理器将这些指令替换为其定义的值或相应的代码段。'
- en: '`.i` extension. These files represent the transformed source code, devoid of
    comments and with all directives evaluated.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.i` 扩展名。这些文件代表经过转换的源代码，去除了注释，并且所有指令都已评估。'
- en: The next stage is the compilation stage.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是编译阶段。
- en: The compilation stage
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译阶段
- en: Compilation starts immediately after pre-processing. The compiler’s role is
    to take `.i` files and convert them into architecture-specific assembly code.
    This phase is where the high-level constructs of `C` are translated into the lower-level,
    more granular assembly instructions understood by the target processor architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程在预处理之后立即开始。编译器的角色是将 `.i` 文件转换为特定架构的汇编代码。在这个阶段，`C` 语言的高级结构被翻译成目标处理器架构所能理解的更低级、更细粒度的汇编指令。
- en: 'This stage involves the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段包括以下内容：
- en: '`.``i` files'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.i` 文件'
- en: '**Process**: The compiler analyzes the code structure, optimizes it for performance
    and space, and translates it into assembly language'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：编译器分析代码结构，优化性能和空间，并将其翻译成汇编语言。'
- en: '`.``s` extension'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.s` 扩展名'
- en: The next stage makes use of the `.``s` files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段使用 `.s` 文件。
- en: The assembly stage
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编阶段
- en: Assembly is the stage where the `.s` files containing assembly code are converted
    into machine code, in the form of **object files**. This stage translates the
    human-readable assembly instructions into a binary format.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编是将包含汇编代码的 `.s` 文件转换为机器代码的阶段，以**目标文件**的形式。这个阶段将可读的汇编指令转换为二进制格式。
- en: 'This stage involves the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段包括以下内容：
- en: '`.s`).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （`.s` 文件）。
- en: '**Process**: The assembler interprets each assembly instruction and converts
    it into corresponding machine code.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：汇编器解释每条汇编指令并将其转换为相应的机器代码。'
- en: '`.o` extension. These files contain binary code and are ready for the next
    stage of linking.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.o` 扩展名。这些文件包含二进制代码，并准备好进入链接的下一阶段。'
- en: The linking stage
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接阶段
- en: Linking is the stage where all individual object files are combined to form
    a cohesive program. This stage also integrates any necessary standard library
    files and resolves references between different code modules.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是将所有单个目标文件组合成一个完整程序的阶段。这个阶段还整合了任何必要的标准库文件，并解决不同代码模块之间的引用。
- en: 'This stage involves the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段包括以下内容：
- en: '`.o`) and C standard library files.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （`.o` 文件）和 C 标准库文件。
- en: '**Process**: The linker stitches together all object files, resolving symbolic
    references and addresses. It handles tasks such as memory allocation for variables
    and functions.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：链接器将所有目标文件缝合在一起，解决符号引用和地址。它处理诸如变量和函数的内存分配等任务。'
- en: '**Output**: The linker generates a **relocatable file**, which is comprehensive
    but not yet final executable code.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：链接器生成一个**可重定位文件**，内容全面但还不是最终的可执行代码。'
- en: A relocatable file is intermediate output in the firmware build process, which
    is created during the linking stage. It’s a comprehensive file that combines all
    individual object files `(.o)` and the necessary library. However, it is not yet
    a final executable. The concept of **relocation** plays an important role here.
    Relocation involves adjusting the symbolic addresses in the relocatable file to
    actual, specific memory locations. This process ensures that when the firmware
    runs on a target device, each part of the code and data is correctly placed in
    memory. The relocatable file contains all the necessary components of the firmware,
    but with addresses that are still “relative” – they need further adjustment during
    the locating stage to fit the unique memory map of the target microcontroller,
    leading to the creation of the final executable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 可重定位文件是固件构建过程中的中间输出，在链接阶段创建。它是一个综合文件，结合了所有单个目标文件（`.o`）和必要的库。然而，它还不是最终的执行文件。**重定位**的概念在这里起着重要作用。重定位涉及调整可重定位文件中的符号地址到实际的、特定的内存位置。这个过程确保当固件在目标设备上运行时，代码和数据部分的每个部分都正确地放置在内存中。可重定位文件包含固件的所有必要组件，但地址仍然是“相对的”——它们需要在定位阶段进一步调整以适应目标微控制器的独特内存映射，从而创建最终的执行文件。
- en: The next stage is where we finally get our executable code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个阶段是我们最终获得可执行代码的阶段。
- en: The locating stage
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位阶段
- en: This is the last stage; it involves converting the relocatable file into the
    final executable binary. This stage is guided by a linker script, which provides
    essential information about the memory layout of the target device.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一个阶段；它涉及将可重定位文件转换为最终的执行二进制文件。这个阶段由链接脚本指导，它提供了有关目标设备内存布局的必要信息。
- en: 'This stage involves the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段包括以下内容：
- en: '**Input**: A relocatable file and a linker script.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**：一个可重定位文件和一个链接脚本。'
- en: '**Process**: The locator uses the linker script to place code and data sections
    into their designated memory locations. It adjusts addresses and offsets to fit
    the target’s memory map.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程**：定位器使用链接脚本将代码和数据部分放置到指定的内存位置。它调整地址和偏移量以适应目标内存映射。'
- en: '**Output**: An executable binary file, typically in formats such as **Executable
    and Linkable Format** (**ELF**) or a plain binary format.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：一个可执行的二进制文件，通常以**可执行和链接格式**（**ELF**）或纯二进制格式。'
- en: With this knowledge in hand, we are well-equipped to delve into the GNU Toolchain
    for Arm. Our goal is to effectively utilize specific tools within the toolchain
    to execute the various stages of the build process. This will be the focus of
    the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，我们已准备好深入探讨GNU Toolchain for Arm。我们的目标是有效地利用工具链中的特定工具来执行构建过程的各个阶段。这将是下一节的重点。
- en: A tour of GNU binary tools for embedded systems
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU嵌入式系统二进制工具之旅
- en: In this section, we’ll delve into the GNU Bin tools, a suite of tools that come
    with the installation of the GNU Toolchain for Arm. These tools (commands) are
    essential for the various stages of the firmware build process, as well as additional
    tasks such as debugging.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解GNU Bin工具，这是一套随GNU Toolchain for Arm安装而来的工具。这些工具（命令）对于固件构建过程的各个阶段以及如调试等额外任务都是必不可少的。
- en: The first command we’ll explore is `arm-none-eabi-gcc`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一个命令是`arm-none-eabi-gcc`。
- en: arm-none-eabi-gcc
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: arm-none-eabi-gcc
- en: 'Let’s break down the components of the command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解命令的各个部分：
- en: '`arm`: This specifies the target architecture.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm`：这指定了目标架构。'
- en: '`none`: This component indicates the operating system for which the code is
    being compiled. Here, `none` signifies that the code is meant for a bare-metal
    environment, meaning it will run directly on the hardware without an underlying
    operating system.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：这个组件表示代码正在编译的操作系统。在这里，`none`表示代码是为裸机环境设计的，这意味着它将直接在硬件上运行，而不需要底层操作系统。'
- en: '`eabi`: This stands for **Embedded Application Binary Interface**. EABI defines
    a standard for the binary layout of system and user programs, libraries, and so
    on. It ensures that the compiled code will work correctly on any Arm processor
    that adheres to the EABI standard.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eabi`：这代表**嵌入式应用程序二进制接口**。EABI定义了系统和用户程序、库等的二进制布局标准。它确保编译的代码将在遵循EABI标准的任何Arm处理器上正确运行。'
- en: '`gcc`: This is short for **GNU** **Compiler Collection**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc`：这是**GNU** **编译器集合**的缩写。'
- en: This single command compiles, assembles, and links our input code in one go.
    To use it, type `arm-none-eabi-gcc` in the command prompt or terminal, followed
    by the source file, then `-o`, and the desired output filename.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此单个命令一次编译、汇编和链接我们的输入代码。要使用它，请在命令提示符或终端中输入 `arm-none-eabi-gcc`，然后是源文件，然后是 `-o`，以及所需的输出文件名。
- en: 'See *Figure 3**.2* for an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 见 *图 3**.2* 的示例：
- en: '![Figure 3.2: Usage of the arm-none-eabi-gcc command](img/B21914_03_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：arm-none-eabi-gcc 命令的用法](img/B21914_03_02.jpg)'
- en: 'Figure 3.2: Usage of the arm-none-eabi-gcc command'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：arm-none-eabi-gcc 命令的用法
- en: In this example, we specify the source file as `main.c` and the output file
    as `main.o.`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们指定源文件为 `main.c`，输出文件为 `main.o`。
- en: Some common compiler flags
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些常见的编译器标志
- en: 'Since we have just introduced the `-o` compiler flag, let’s take this opportunity
    to introduce some of the other commonly used compiler flags. These compiler flags
    are used to modify command behavior as well as add options to commands:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚介绍了 `-o` 编译器标志，让我们借此机会介绍一些其他常用的编译器标志。这些编译器标志用于修改命令行为以及向命令添加选项：
- en: '`-c`: This flag is used to compile and assemble but not link. When added to
    the command, it processes the code up to the assembly stage but stops before linking.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`: 此标志用于编译和汇编但不进行链接。当添加到命令中时，它将代码处理到汇编阶段，但在链接之前停止。'
- en: '`-o file`: As mentioned earlier, this specifies the name of the output file.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o file`: 如前所述，此选项指定输出文件的名称。'
- en: '`-g`: Generates debugging information in the executable.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g`: 在可执行文件中生成调试信息。'
- en: '`-Wall`: Enables all warning messages, helping us identify potential issues
    in the code.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall`: 启用所有警告消息，帮助我们识别代码中的潜在问题。'
- en: '`-Werror`: Treats all warnings as errors, ensuring code quality and stability.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Werror`: 将所有警告视为错误，确保代码质量和稳定性。'
- en: '`-I [DIR]`: Includes a specified directory to search for header files; it’s
    useful for organizing large projects.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I [DIR]`: 包含一个指定的目录以搜索头文件；这对于组织大型项目很有用。'
- en: '`-ansi` and `-std=STANDARD`: These flags specify which standard version of
    the c language should be used.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ansi` 和 `-std=STANDARD`: 这些标志指定应使用 C 语言的哪个标准版本。'
- en: '`-v`: Provides verbose output from GCC, giving us detailed information about
    the compilation process.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`: 从 GCC 提供详细输出，给我们关于编译过程的详细信息。'
- en: '*Table 3.1* provides a summary of the flags and example usage for each flag.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.1* 提供了标志的总结以及每个标志的示例用法。'
- en: '| **Flag** | **Purpose** | **Example usage** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **用途** | **示例用法** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `-c` | Compile and assemble but don’t link | `arm-none-eabi-gcc -``c source_file`
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `-c` | 编译和汇编但不链接 | `arm-none-eabi-gcc -``c source_file` |'
- en: '| `-``o file` | Link to the output file, named file | `arm-none-eabi-gcc source_file
    -``o output_file` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `-``o file` | 链接到输出文件，文件名为 file | `arm-none-eabi-gcc source_file -``o output_file`
    |'
- en: '| `-g` | Generate debugging info in the executable | `arm-none-eabi-gcc -``g
    source_file` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `-g` | 在可执行文件中生成调试信息 | `arm-none-eabi-gcc -``g source_file` |'
- en: '| `-``Wall` | Enable all warning messages | `arm-none-eabi-gcc -``Wall source_file`
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `-``Wall` | 启用所有警告消息 | `arm-none-eabi-gcc -``Wall source_file` |'
- en: '| `-``Werror` | Treat warnings as errors | `arm-none-eabi-gcc -``Werror source_file`
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `-``Werror` | 将警告视为错误 | `arm-none-eabi-gcc -``Werror source_file` |'
- en: '| `-``I [DIR]` | Include a directory for header files | `arm-none-eabi-gcc
    -I` `directory_path source_file` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `-``I [DIR]` | 包含用于头文件的目录 | `arm-none-eabi-gcc -I` `directory_path source_file`
    |'
- en: '| `-``ansi` | Use the **American National Standards Institute** (**ANSI**)
    standard | `arm-none-eabi-gcc -``ansi source_file` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `-``ansi` | 使用美国国家标准协会（**ANSI**）标准 | `arm-none-eabi-gcc -``ansi source_file`
    |'
- en: '| `-``std` | Specify a standard version (e.g., C11) | `arm-none-eabi-gcc -``std=c11
    source_file` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `-``std` | 指定标准版本（例如，C11） | `arm-none-eabi-gcc -``std=c11 source_file` |'
- en: '| `-v` | Verbose output from GCC | `arm-none-eabi-gcc -``v source_file` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | GCC 的详细输出 | `arm-none-eabi-gcc -``v source_file` |'
- en: 'Table 3.1: Some compiler flags and their example usage'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：一些编译器标志及其示例用法
- en: Some architecture-specific flags
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些特定架构的标志
- en: 'In addition to the general compiler flags, there are several architecture-specific
    flags that enable precise configuration for various processor architectures. These
    flags are integral for tailoring the build process to specific ARM processors
    and their respective architectures. Let’s delve into some of the most frequently
    used architecture-specific flags:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用编译器标志之外，还有一些针对特定架构的标志，这些标志可以精确配置各种处理器架构。这些标志对于针对特定 ARM 处理器和它们各自的架构定制构建过程至关重要。让我们深入了解一些最常用的特定架构标志：
- en: '`-mcpu=[NAME]`: Specifies the target ARM processor. Using this option configures
    the compiler to optimize the code for a specific processor.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mcpu=[NAME]`: 指定目标 ARM 处理器。使用此选项将配置编译器以针对特定处理器优化代码。'
- en: '`march=[NAME]`: Specifies the target ARM architecture. It configures the compiler
    for a particular ARM architecture version.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`march=[NAME]`: 指定目标 ARM 架构。它配置编译器以针对特定的 ARM 架构版本。'
- en: '`-mtune=[NAME]`: Similar to `-mcpu`, this specifies the target ARM processor
    for optimization purposes.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mtune=[NAME]`: 与 `-mcpu` 类似，此选项指定了优化目的的目标 ARM 处理器。'
- en: '`-thumb`: Configures the compiler to generate code for the Thumb instruction
    set, which is a compressed version of the standard ARM instruction set, providing
    more code density and efficiency.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-thumb`: 配置编译器以生成适用于 Thumb 指令集的代码，这是标准 ARM 指令集的压缩版本，提供了更高的代码密度和效率。'
- en: '`-marm`: Instructs the compiler to generate code for the ARM instruction set.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-marm`: 指示编译器生成适用于 ARM 指令集的代码。'
- en: '`-mlittle-endian`/`-mbig-endian`: These options specify the endianness for
    the generated code. Little-endian is the most common format in ARM processors.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mlittle-endian`/`-mbig-endian`: 这些选项指定了生成的代码的端序。小端序是 ARM 处理器中最常见的格式。'
- en: 'Let’s see an example involving some of these flags:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看涉及一些这些标志的示例：
- en: '![Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific
    flags](img/B21914_03_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：使用一些架构特定标志的 arm-none-eabi-gcc 命令](img/B21914_03_03.jpg)'
- en: 'Figure 3.3: Usage of the arm-none-eabi-gcc command with some architecture-specific
    flags'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：使用一些架构特定标志的 arm-none-eabi-gcc 命令
- en: 'In this example, we say the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们说以下内容：
- en: '`-c`: Compile and assemble but do not link'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`: 编译和汇编但不链接'
- en: '`-mcpu=cortex-m4`: Build for the Cortex-M4 processor'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mcpu=cortex-m4`: 为 Cortex-M4 处理器构建'
- en: '`-mthumb`: Use the Thumb instruction set'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mthumb`: 使用 Thumb 指令集'
- en: '`-o main.o`: Output the compiled file as `main.o`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o main.o`: 将编译文件输出为 `main.o`'
- en: '*Table 3.2* provides a summary of the architecture-specific flags and example
    usage for each flag.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.2* 提供了架构特定标志及其每个标志的示例用法总结。'
- en: '| **Flag** | **Purpose** | **Example usage** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **用途** | **示例用法** |'
- en: '| `-``mcpu=[NAME]` | Specify the target ARM processor | `-``mcpu=cortex-m4`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `-mcpu=[NAME]` | 指定目标 ARM 处理器 | `-mcpu=cortex-m4` |'
- en: '| `-``march=[NAME]` | Specify the target ARM architecture | `-``march=armv7-m`
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `-march=[NAME]` | 指定目标 ARM 架构 | `-march=armv7-m` |'
- en: '| `-``mtune=[NAME]` | Optimize for a specific ARM processor | `-``mtune=cortex-m4`
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `-mtune=[NAME]` | 为特定 ARM 处理器优化 | `-mtune=cortex-m4` |'
- en: '| `-``thumb` | Generate code for the Thumb instruction set | `-``mthumb` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `-mthumb` | 生成适用于 Thumb 指令集的代码 | `-mthumb` |'
- en: '| `-``marm` | Generate code for the ARM instruction set | `-``marm` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `-marm` | 生成适用于 ARM 指令集的代码 | `-marm` |'
- en: '| `-``mlittle-endian` | Generate code for little-endian mode | `-``mlittle-endian`
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `-mlittle-endian` | 生成适用于小端序模式的代码 | `-mlittle-endian` |'
- en: '| `-``mbig-endian` | Generate code for big-endian mode | `-``mbig-endian` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `-mbig-endian` | 生成适用于大端序模式的代码 | `-mbig-endian` |'
- en: 'Table 3.2: Some architecture-specific compiler flags and their example usage'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：一些架构特定编译器标志及其示例用法
- en: Other commands in the GNU Toolchain for Arm
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arm GNU 工具链中的其他命令
- en: 'Apart from the `arm-none-eabi-gcc` command, there are other important commands
    that we will frequently use when building with the GNU toolchain for Arm. Let’s
    examine some of these commands:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `arm-none-eabi-gcc` 命令之外，还有一些我们在使用 GNU 工具链构建 Arm 时会经常使用的其他重要命令。让我们来检查一些这些命令：
- en: '`arm-none-eabi-nm`: The `arm-none-eabi-nm` command is a handy tool for listing
    the symbols from an object file. Symbols in this context refer to various identifiers
    in a program, such as function names, variable names, and constants. This tool
    is invaluable for examining the contents of compiled files, offering us insights
    into the structure and components of our program. This can be particularly useful
    for debugging purposes.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-nm`: `arm-none-eabi-nm` 命令是一个方便的工具，用于列出对象文件中的符号。在此上下文中，符号指的是程序中的各种标识符，例如函数名、变量名和常量。这个工具对于检查编译文件的内容非常有价值，它为我们提供了关于程序结构和组件的见解。这对于调试目的尤其有用。'
- en: '`arm-none-eabi-size`: In embedded firmware development, where memory resources
    are often limited, understanding the memory footprint of different sections of
    our code is crucial. This tool provides valuable insights into how much memory
    the various parts of our code consume, allowing us to make informed decisions
    about optimization and memory management.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-size`：在嵌入式固件开发中，由于内存资源通常有限，了解代码不同部分占用的内存大小至关重要。此工具提供了关于代码各个部分消耗多少内存的宝贵见解，使我们能够就优化和内存管理做出明智的决定。'
- en: '`arm-none-eabi-objdump`: This tool is used to extract and display detailed
    information from object files. It offers an in-depth view of the machine instructions,
    making it an invaluable resource for thorough analysis of object files. This includes
    capabilities such as disassembling code, presenting section headers, and revealing
    symbol tables. Its utility becomes crucial when we need to delve into the intricate
    details of compiled code, providing clarity on a file’s structure, content, and
    operational mechanics. This helps us to both debug and optimize our code.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-objdump`：此工具用于从对象文件中提取和显示详细信息。它提供了对机器指令的深入了解，使其成为彻底分析对象文件的无价资源。这包括代码反汇编、展示部分标题和揭示符号表等功能。当我们需要深入了解编译代码的复杂细节时，其效用变得至关重要，它提供了关于文件结构、内容和操作机制的解释。这有助于我们调试和优化代码。'
- en: Disassembling code refers to the process of converting machine code, which is
    a set of binary instructions that a computer’s processor can execute directly,
    back into assembly language. Assembly language is a more human-readable form of
    instructions, although it’s still quite low-level compared to the C language.
    *Figure 3**.4* presents a comparison of C-language code, its corresponding assembly
    language translation, and the resulting machine code.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反汇编代码是指将机器代码（一组计算机处理器可以直接执行的二进制指令）转换回汇编语言的过程。汇编语言是一种更易于人类阅读的指令形式，尽管与C语言相比，它仍然相当低级。*图3**.4*展示了C语言代码、其对应的汇编语言翻译以及生成的机器代码的比较。
- en: '![Figure 3.4: C-language code, its corresponding assembly language code, and
    the resulting machine code](img/B21914_03_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：C语言代码、其对应的汇编语言代码以及生成的机器代码](img/B21914_03_04.jpg)'
- en: 'Figure 3.4: C-language code, its corresponding assembly language code, and
    the resulting machine code'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：C语言代码、其对应的汇编语言代码以及生成的机器代码
- en: '`arm-none-eabi-readelf`: This tool provides detailed information about the
    output ELF file, including section headers, program headers, and symbol tables.
    It is useful when we work with ELF files, as it offers insights into how an executable
    is structured and prepared to run on a system.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-readelf`：此工具提供了关于输出ELF文件的详细信息，包括部分标题、程序标题和符号表。当我们处理ELF文件时，它非常有用，因为它提供了关于可执行文件结构以及如何在系统上运行的见解。'
- en: '`: arm-none-eabi-objcopy`: We use this tool to convert object files from one
    format to another or to make a copy of an object file.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`: arm-none-eabi-objcopy`：我们使用此工具将对象文件从一种格式转换为另一种格式，或者制作对象文件的副本。'
- en: '*Table 3.3* provides a summary of these additional tools and example usage
    for each tool.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*表3.3*提供了这些附加工具的总结以及每个工具的示例用法。'
- en: '| **Tool** | **Function** | **Example Usage** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **工具** | **功能** | **示例用法** |'
- en: '| `arm-none-eabi-nm` | Lists symbols from object files | `arm-none-eabi-nm
    [``object file]` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `arm-none-eabi-nm` | 列出对象文件中的符号 | `arm-none-eabi-nm [对象文件]` |'
- en: '| `arm-none-eabi-size` | Lists section sizes of object/executable files | `arm-none-eabi-size
    [file]` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `arm-none-eabi-size` | 列出对象/可执行文件的部分大小 | `arm-none-eabi-size [文件]` |'
- en: '| `arm-none-eabi-objdump` | Dumps information about object files | `arm-none-eabi-objdump
    [options] [``object file]` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `arm-none-eabi-objdump` | 输出对象文件的信息 | `arm-none-eabi-objdump [选项] [对象文件]`
    |'
- en: '| `arm-none-eabi-readelf` | Displays information about ELF files | `arm-none-eabi-readelf
    [options] [``ELF file]` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `arm-none-eabi-readelf` | 显示ELF文件的信息 | `arm-none-eabi-readelf [选项] [ELF文件]`
    |'
- en: '| `arm-none-eabi-objcopy` | Converts/copies object files between formats |
    `arm-none-eabi-objcopy [options] [input file] [``output file]` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `arm-none-eabi-objcopy` | 在格式之间转换/复制对象文件 | `arm-none-eabi-objcopy [选项] [输入文件]
    [输出文件]` |'
- en: 'Table 3.3: Some common commands in the GNU toolchain for Arm and their example
    usage'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.3：GNU工具链中一些常见的Arm命令及其示例用法
- en: In this section, we explored the GNU Binary Tools that are essential for embedded
    firmware development. These tools, including commands such as `arm-none-eabi-gcc`,
    play important roles in various stages of the firmware build process and are invaluable
    for tasks such as compiling, linking, and debugging. The next section will further
    expand our understanding of these tools; we’ll dive into their practical applications,
    demonstrating their utility in the embedded firmware build process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了嵌入式固件开发中必不可少的 GNU 二进制工具。这些工具，包括 `arm-none-eabi-gcc` 等命令，在固件构建过程的各个阶段发挥着重要作用，对于编译、链接和调试等任务来说是无价的。下一节将进一步扩展我们对这些工具的理解；我们将深入研究它们的应用，展示它们在嵌入式固件构建过程中的实用性。
- en: From IDE to the command line – watching the build process unfold
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 IDE 到命令行 - 观察构建过程展开
- en: In this section, our aim is to understand how the compiler within the IDE handles
    our code when we initiate a build. Additionally, we will delve into the practical
    applications of some of the GNU Binary Tools we discussed in the previous section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的目标是了解 IDE 内部的编译器在启动构建时如何处理我们的代码。此外，我们还将深入研究上一节中讨论的一些 GNU 二进制工具的实际应用。
- en: Observing the build process from the IDE’s perspective
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 IDE 视角观察构建过程
- en: Let’s start by revisiting the bare-metal GPIO driver we developed in the previous
    chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾上一章中开发的裸机 GPIO 驱动程序开始。
- en: Begin by launching your STM32CubeIDE. To conduct a proper analysis of the build
    commands that the IDE executes, it’s necessary to first clean the project and
    then build again. The reason for this is straightforward – we’ve already built
    the project, in a previous chapter. Without any modifications to the source code
    since then, a new build attempt would skip the detailed command execution we aim
    to scrutinize, since the source code hasn’t changed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动您的 STM32CubeIDE。为了正确分析 IDE 执行的构建命令，有必要首先清理项目然后再次构建。原因很简单 - 我们已经在上一章中构建了项目。从那时起，源代码没有进行任何修改，新的构建尝试将跳过我们旨在仔细审查的详细命令执行，因为源代码没有变化。
- en: 'Let’s clean the project:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理项目：
- en: Locate the project in the **Projects** pane.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中定位项目。
- en: Right-click on the name of the project.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目名称。
- en: A menu will appear. From this menu, select the **Clean** **Project** option.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会弹出一个菜单。从该菜单中选择**清理项目**选项。
- en: The IDE will now clear any already compiled data from the project. This action
    resets the build state of the project to its initial condition, erasing any previous
    build results.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDE 现在将清除项目中的任何已编译数据。此操作将项目的构建状态重置为其初始状态，删除任何以前的构建结果。
- en: 'Now, let’s build it again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次构建它：
- en: Right-click once more on the same project’s name in the **Projects** pane.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在**项目**面板中同一项目的名称上单击鼠标右键。
- en: Again, a menu will appear. This time, select the **Build** **Project** option.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次弹出一个菜单。这次，选择**构建项目**选项。
- en: By selecting this option, the IDE will start the process of building the project
    from scratch.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择此选项后，IDE 将开始从头开始构建项目的进程。
- en: To observe the build commands in the STM32CubeIDE, we must find the **Console**
    pane, which is usually positioned at the bottom area of the IDE’s interface. The
    **Console** pane is an important component that displays real-time outputs and
    logs for various actions, including the build process. This makes it an invaluable
    tool to monitor the commands and actions undertaken during the compilation of
    our projects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 STM32CubeIDE 中观察构建命令，我们必须找到**控制台**面板，它通常位于 IDE 界面的底部区域。**控制台**面板是一个重要的组件，它显示各种操作的实时输出和日志，包括构建过程。这使得它成为监控编译过程中进行的命令和动作的宝贵工具。
- en: If the **Console** pane is not readily visible in your current IDE layout, you
    can access it through the menu bar located at the top of the IDE. Simply click
    on the **Window** menu to reveal a drop-down list of options. From there, navigate
    to **Show View**, which will expand to show more choices. Among these, select
    **Console** to bring the pane into view within your workspace.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在当前 IDE 布局中**控制台**面板不可见，您可以通过位于 IDE 顶部的菜单栏访问它。只需点击**窗口**菜单，即可显示一个选项的下拉列表。从那里，导航到**显示视图**，这将展开以显示更多选项。在这些选项中，选择**控制台**，以便在您的工区内查看该面板。
- en: 'Once you have the `2_RegisterManipulation` bare-metal GPIO driver project.
    *Figure 3**.5* shows some of the content of the `2_RegisterManipulation` bare-metal
    GPIO driver project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `2_RegisterManipulation` 硬件裸机 GPIO 驱动项目。*图 3*.5 显示了 `2_RegisterManipulation`
    硬件裸机 GPIO 驱动项目的一些内容：
- en: '![Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal
    GPIO driver project.](img/B21914_03_05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：构建 2_RegisterManipulation 硬件裸机 GPIO 驱动项目后的控制台面板](img/B21914_03_05.jpg)'
- en: 'Figure 3.5: The Console pane after building the 2_RegisterManipulation bare-metal
    GPIO driver project.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：构建 2_RegisterManipulation 硬件裸机 GPIO 驱动项目后的控制台面板。
- en: '*Figure 3**.5* provides a snapshot of the build process steps, although it
    only displays a segment of each step. For a comprehensive view of all the steps,
    including the full lines of commands and responses, you should refer to the **Console**
    pane in your STM32CubeIDE.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3*.5 提供了构建过程步骤的快照，尽管它只显示了每个步骤的一个片段。要全面了解所有步骤，包括完整的命令行和响应，你应该参考你的 STM32CubeIDE
    中的 **控制台** 面板。'
- en: Let's analyze the console pane in *Figure 3**.5*, according to the line numbering..
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据行号分析 *图 3*.5 中的控制台面板。
- en: Compilation of assembly and C files
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编和 C 文件的编译
- en: '**Line (1)**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**行 (1)**'
- en: '`make -j8 all`: This is a command to the `make` build automation tool, requesting
    it to execute the build. We shall learn about `make` in the upcoming chapters.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`make -j8 all`：这是一个对 `make` 构建自动化工具的命令，请求它执行构建。我们将在接下来的章节中学习 `make`。'
- en: '**Lines (2)(3)(4)(5)**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**行 (2)(3)(4)(5)**'
- en: The following lines are specific `arm-none-eabi-gcc` commands to compile individual
    source files such as `main.c`, `syscalls.c`, and `sysmem.c`. These commands specify
    the target CPU (`-mcpu=cortex-m4`) and other compiler flags. Each source file
    is compiled into an object file (`.o`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是针对 `arm-none-eabi-gcc` 的特定命令，用于编译单个源文件，如 `main.c`、`syscalls.c` 和 `sysmem.c`。这些命令指定了目标
    CPU (`-mcpu=cortex-m4`) 和其他编译器标志。每个源文件都被编译成一个目标文件 (`.o`)。
- en: Linking process
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接过程
- en: '**Line (6)**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**行 (6)**'
- en: The `arm-none-eabi-gcc` command with a list of object files (`@"objects.list")`
    and a linker script (`STM32F411RETX_FLASH.ld`) links these object files into an
    executable file (`2_RegisterManipulation.elf`). The linker script guides how different
    sections of the code and data are placed in the final executable. We shall discuss
    linker scripts in the next chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 带有对象文件列表 (`@"objects.list")` 和链接脚本 (`STM32F411RETX_FLASH.ld`) 的 `arm-none-eabi-gcc`
    命令将这些对象文件链接成一个可执行文件 (`2_RegisterManipulation.elf`)。链接脚本指导代码和数据的不同部分如何在最终的可执行文件中放置。我们将在下一章讨论链接脚本。
- en: 'Size calculation:'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尺寸计算：
- en: '**Line (8)**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**行 (8)**'
- en: '`arm-none-eabi-size 2_RegisterManipulation.elf:` This command calculates the
    size of the compiled program, breaking it down into text (code), data (initialized
    data), and bss (uninitialized data) sections. The output shows the size of these
    sections in bytes and their total in both decimal (**dec**) and hexadecimal (**hex**)
    formats.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-size 2_RegisterManipulation.elf:` 这个命令计算编译程序的尺寸，将其分解为文本（代码）、数据（初始化数据）和
    bss（未初始化数据）部分。输出显示了这些部分的字节数以及它们的十进制（**dec**）和十六进制（**hex**）格式的总大小。'
- en: 'Creation of a list file:'
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表文件的创建：
- en: '**Line (9)**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**行 (9)**'
- en: '`arm-none-eabi-objdump -h -S 2_RegisterManipulation.elf > "2_RegisterManipulation.list"`:
    This command disassembles the executable and outputs a detailed list file. The
    `-h` flag shows the header information, and `-S` intersperses source code with
    disassembly. A list file is a detailed textual representation of compiled code,
    containing both the assembly language instructions and their corresponding machine
    code, often with annotations of the original high-level source code.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`arm-none-eabi-objdump -h -S 2_RegisterManipulation.elf > "2_RegisterManipulation.list"`：这个命令将可执行文件反汇编并输出一个详细的列表文件。`-h`
    标志显示头部信息，`-S` 将源代码与反汇编代码交织在一起。列表文件是编译代码的详细文本表示，包含汇编语言指令及其对应的机器代码，通常还包含原始高级源代码的注释。'
- en: As we can observe from these logs, it is clear that our STM32CubeIDE employs
    the same GNU Binary Tools previously discussed. In our forthcoming section, we
    will manually execute these commands via the command line. This approach will
    teach us how to build our firmware without using an IDE, simply using the source
    text files, the command-line interface, and our suite of GNU Bin Tools.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些日志中我们可以观察到，很明显，我们的 STM32CubeIDE 采用了之前讨论过的相同的 GNU 二进制工具。在我们接下来的章节中，我们将通过命令行手动执行这些命令。这种方法将教会我们如何不使用
    IDE，仅使用源代码文件、命令行界面和我们的 GNU Bin 工具套件来构建我们的固件。
- en: Working with the GNU bin tools
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GNU 二进制工具
- en: In this section, our focus is to execute some of the GNU Bin Tools directly,
    using our command line. To start I want to show you why I use the words *commands*
    and *tools* interchangeably to describe the GNU Bin Tools.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们的重点是直接执行一些 GNU Bin Tools，使用我们的命令行。首先，我想向您展示为什么我会交替使用 *命令* 和 *工具* 来描述
    GNU Bin Tools。
- en: Locate the installation folder for the GNU Arm Embedded Toolchain on your computer.
    On my computer, this is `C:/Program Files(x86)/GNU Arm` `Embedded Toolchain.`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的计算机上找到 GNU Arm Embedded Toolchain 的安装文件夹。在我的计算机上，这是 `C:/Program Files(x86)/GNU
    Arm` `Embedded Toolchain`。
- en: Once you’ve located the GNU Arm Embedded Toolchain folder, the next step involves
    accessing the `bin` folder within it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您找到了 GNU Arm Embedded Toolchain 文件夹，下一步是访问其中的 `bin` 文件夹。
- en: Upon opening the `bin` folder, you’ll be greeted with a plethora of tools, each
    represented by an executable file (`.exe`). Looking closely, you will find `arm-none-eabi-gcc.exe`,
    our compiler, along with other tools we previously discussed. When we input a
    command corresponding to these tools in the command line, the associated `.exe`
    file is executed. For instance, entering `arm-none-eabi-gcc` in the command line
    will run the `arm-none-eabi-gcc.exe` executable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `bin` 文件夹后，您将看到许多工具，每个工具都由一个可执行文件（`.exe`）表示。仔细观察，您将找到我们的编译器 `arm-none-eabi-gcc.exe`
    以及我们之前讨论过的其他工具。当我们在命令行中输入对应这些工具的命令时，相关的 `.exe` 文件将被执行。例如，在命令行中输入 `arm-none-eabi-gcc`
    将运行 `arm-none-eabi-gcc.exe` 可执行文件。
- en: 'Now that we have clarified that, it’s time to shift our focus toward practical
    testing. However, before diving into this testing phase, a few essential preparatory
    steps are required. Let’s create a backup of our current project, `2_RegisterManipulation`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经澄清了这一点，是时候将我们的注意力转向实际测试了。然而，在进入测试阶段之前，需要一些基本的准备工作。让我们创建当前项目 `2_RegisterManipulation`
    的备份：
- en: '`2_RegisterManipulation` project is stored.'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2_RegisterManipulation` 项目已存储。'
- en: '`2_RegisterManipulation` project folder, select **Copy**, and then **Paste**
    within the same directory.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `2_RegisterManipulation` 项目文件夹中，选择 **复制**，然后在同一目录下 **粘贴**。
- en: '`2_RegisterManipulation-old`.'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2_RegisterManipulation-old`。'
- en: 'With the backup in place, our next move is to modify the `main.c` file in the
    `2_Register` **Manipulation** project, changing the LED’s behavior from a constant
    *on* state to a blinking one:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 备份完成后，我们的下一步是修改 `2_Register` **Manipulation** 项目中的 `main.c` 文件，将 LED 的行为从恒定
    *开启* 状态改为闪烁状态：
- en: '`2_RegisterManipulation/Src` directory.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`2_RegisterManipulation/Src` 目录。'
- en: '`main.c` file and choose to open it in a simple text editor, such as Notepad.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.c` 文件，并选择在简单的文本编辑器中打开它，例如记事本。
- en: '`PA5 (LED_PIN)` high. It should look like this:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PA5 (LED_PIN)` 高电平。它应该看起来像这样：'
- en: '[PRE0]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace this code with the following to toggle the state of `PA5` and create
    a blinking effect:'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此代码替换为以下代码以切换 `PA5` 的状态并创建闪烁效果：
- en: '[PRE1]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`main.c` file.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.c` 文件。'
- en: Let’s go back to our project folder and access the `2_RegisterManipulation/Debug`
    directory through the command prompt. This specific folder is important because
    it’s where STM32CubeIDE automatically places the project’s `makefile`. Understanding
    the role and structure of **makefiles** is crucial in embedded firmware development,
    and we will delve into this topic in more detail in upcoming chapters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的项目文件夹，并通过命令提示符访问 `2_RegisterManipulation/Debug` 目录。这个特定的文件夹很重要，因为 STM32CubeIDE
    会自动将项目的 `makefile` 放置在这里。理解 **makefile** 的角色和结构对于嵌入式固件开发至关重要，我们将在接下来的章节中更详细地探讨这个主题。
- en: 'We can access the folder through the command prompt in multiple ways:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式通过命令提示符访问文件夹：
- en: 'Windows users can choose between these methods:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可以选择这些方法之一：
- en: '`2_RegisterManipulation/Debug` folder in Windows Explorer. Once there, hold
    down the *Shift* key, right-click in an empty space within the folder, and select
    `Debug` folder.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 资源管理器中找到 `2_RegisterManipulation/Debug` 文件夹。一旦到达那里，按住 *Shift* 键，在文件夹内的空白区域右键单击，然后选择
    `Debug` 文件夹。
- en: '`2_RegisterManipulation/Debug` folder and then copy the folder path. Then,
    open Command Prompt from the `cmd` in the `cd` (note the space after ‘cd’), paste
    the copied path, and press *Enter*. This will change the directory to the `Debug`
    folder.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `2_RegisterManipulation/Debug` 文件夹中找到文件夹路径，然后复制该路径。然后，从 `cd` 的 `cmd` 中打开命令提示符（注意
    'cd' 后面的空格），粘贴复制的路径，并按 *Enter*。这将更改目录到 `Debug` 文件夹。
- en: 'Users of other operating systems can choose between these methods:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其他操作系统的用户可以选择这些方法之一：
- en: Navigate to the folder, and open the terminal specific to your operating system.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到该文件夹，并打开您操作系统的特定终端。
- en: Use the `cd` (change directory) command, followed by the absolute path to the
    `2_RegisterManipulation/Debug` folder to navigate to it. The exact path may vary,
    based on where the project is located on your system.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cd`（更改目录）命令，后跟 `2_RegisterManipulation/Debug` 文件的绝对路径来导航到它。确切路径可能因项目在系统中的位置而异。
- en: '![Figure 3.6: Accessing the Debug folder through the Windows Command Prompt](img/B21914_03_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：通过 Windows 命令提示符访问调试文件夹](img/B21914_03_06.jpg)'
- en: 'Figure 3.6: Accessing the Debug folder through the Windows Command Prompt'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：通过 Windows 命令提示符访问调试文件夹
- en: In this practical exercise, we’ll replicate the commands used by STM32CubeIDE,
    extracting them directly from its console pane. We’ll execute them one by one,
    as depicted in *Figure 3**.5*, starting with line number 2 (since our current
    focus isn’t on makefiles).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际练习中，我们将复制 STM32CubeIDE 中使用的命令，直接从其控制台面板中提取它们。我们将逐行执行，如图 3**.5** 所示，从第 2
    行开始（因为我们的当前重点不在于 makefile）。
- en: 'To do this, follow these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤操作：
- en: 'Copy line number 2 from the STM32CubeIDE console pane and paste it into the
    command prompt. This line compiles the startup file using `arm-none-eabi-gcc`,
    referencing paths specific to my system setup:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 STM32CubeIDE 控制台面板复制第 2 行，并将其粘贴到命令提示符中。这一行使用 `arm-none-eabi-gcc` 编译启动文件，并引用了我系统设置特定的路径：
- en: '[PRE2]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: syscalls.c and system.c files, respectively.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`syscalls.c` 和 `system.c` 文件，分别。'
- en: '[PRE3]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will proceed to link these files. To do this, copy the linking command,
    which is on line number 6 in the STM32CubeIDE console pane, and paste it into
    the command prompt, like this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续链接这些文件。为此，复制 STM32CubeIDE 控制台面板中的链接命令，该命令位于第 6 行，并将其粘贴到命令提示符中，如下所示：
- en: '[PRE4]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To execute this, copy line number 8 from the STM32CubeIDE console pane and
    paste it into the command prompt. Running the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请从 STM32CubeIDE 控制台面板复制第 8 行，并将其粘贴到命令提示符中。运行以下命令：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will display the size details of the `.``elf` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示 `.elf` 文件的大小细节：
- en: '![Figure 3.7: Output produced by executing the arm-none-eabi-size command](img/B21914_03_07.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：执行 arm-none-eabi-size 命令产生的输出](img/B21914_03_07.jpg)'
- en: 'Figure 3.7: Output produced by executing the arm-none-eabi-size command'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：执行 arm-none-eabi-size 命令产生的输出
- en: Observing the results, we can confirm that the output matches exactly what is
    displayed in the STM32CubeIDE console pane.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 观察结果，我们可以确认输出与 STM32CubeIDE 控制台面板中显示的完全匹配。
- en: At this stage, we can choose to convert our `.elf` file into the `.bin` format
    using the `arm-none-eabi-objcopy` tool, with the appropriate flags.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以选择使用 `arm-none-eabi-objcopy` 工具将我们的 `.elf` 文件转换为 `.bin` 格式，并使用适当的标志。
- en: 'Type the following in the command prompt and press *Enter*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中键入以下内容并按 *Enter*：
- en: '[PRE6]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break down this snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个片段：
- en: '`-O binary` specifies the output format, which in this case is a binary file'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O binary` 指定输出格式，在这种情况下是一个二进制文件'
- en: '`2_RegisterManipulation.elf` is the source ELF file you are converting'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2_RegisterManipulation.elf` 是你正在转换的源 ELF 文件'
- en: '`2_RegisterManipulation.bin` is the name of the output binary file that will
    be created'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2_RegisterManipulation.bin` 是将要创建的输出二进制文件的名称'
- en: This final step marks the completion of our first build process. We have successfully
    compiled and linked all necessary files, resulting in the creation of our final
    executable in two formats. The next process involves uploading the firmware to
    our microcontroller using *OpenOCD*. This will be covered in the next section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一步标志着我们第一次构建过程的完成。我们已经成功编译和链接了所有必要的文件，从而创建了我们的最终可执行文件，有两种格式。下一个过程涉及使用 *OpenOCD*
    将固件上传到我们的微控制器。这将在下一节中介绍。
- en: Uploading firmware to the microcontroller using OpenOCD
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OpenOCD 将固件上传到微控制器
- en: '`2_RegisterManipulation` executable file into our microcontroller.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `2_RegisterManipulation` 可执行文件放入我们的微控制器中。
- en: 'We will start by locating the correct OpenOCD script for our development board.
    OpenOCD comes with a variety of scripts, each tailored to different microcontrollers
    and development boards. In our case, the focus is on the **st_nucleo_f4 series**.
    To find the right script, follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定位我们开发板的正确 OpenOCD 脚本。OpenOCD 附带各种脚本，每个脚本都针对不同的微控制器和开发板量身定制。在我们的情况下，重点是
    **st_nucleo_f4 系列**。要找到正确的脚本，请按照以下步骤操作：
- en: Navigate to the OpenOCD installation directory, typically found in the `Program
    Files` folder for Windows users. The OpenOCD folder is usually named `xpack-openocd`.
    Once there, enter the `openocd` subfolder, then the `scripts` subfolder, and finally,
    the `board` subfolder. You will find a file named `st_nucleo_f4.cfg`; this is
    the OpenOCD file we have to execute for our NUCLEO-F4 development board.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 OpenOCD 安装目录，通常位于 Windows 用户 `Program Files` 文件夹中。OpenOCD 文件夹通常命名为 `xpack-openocd`。一旦到达那里，进入
    `openocd` 子文件夹，然后是 `scripts` 子文件夹，最后是 `board` 子文件夹。您将找到一个名为 `st_nucleo_f4.cfg`
    的文件；这是我们为 NUCLEO-F4 开发板必须执行的 OpenOCD 文件。
- en: 'To launch OpenOCD, connect your development board, open the command prompt
    window, and enter the following command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动 OpenOCD，连接您的开发板，打开命令提示符窗口，并输入以下命令：
- en: '[PRE7]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a snippet of the output from the command prompt after executing the
    command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行命令后命令提示符窗口的输出片段：
- en: '![Figure 3.8: OpenOCD’s first output](img/B21914_03_08.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：OpenOCD 的首次输出](img/B21914_03_08.jpg)'
- en: 'Figure 3.8: OpenOCD’s first output'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：OpenOCD 的首次输出
- en: 'The information presented here includes the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的信息包括以下内容：
- en: '`6666` for Tcl connections and port `4444` for Telnet connections. These ports
    are used to send commands to OpenOCD and interact with it during debugging sessions.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`6666` 用于 Tcl 连接，端口 `4444` 用于 Telnet 连接。这些端口用于在调试会话期间向 OpenOCD 发送命令并与之交互。'
- en: '**Processor and debug capabilities**: The debugger has identified the Cortex-M4
    r0p1 processor in the STM32F4 series microcontroller. Additionally, it notes that
    the target has six breakpoints and four watchpoints, which are crucial for setting
    breakpoints and watchpoints during debugging.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器和调试能力**：调试器已识别出 STM32F4 系列微控制器中的 Cortex-M4 r0p1 处理器。此外，它还指出目标设备有六个断点和四个观察点，这在调试过程中设置断点和观察点时至关重要。'
- en: '`3333`. This server allows a **GDB** (**GNU Debugger**) client to connect for
    debugging purposes.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3333`。此服务器允许 **GDB** （**GNU 调试器**）客户端连接以进行调试。'
- en: 'With OpenOCD running, the next step involves using the GDB to upload the firmware
    to the microcontroller. Let’s access another command prompt window, still from
    the Debug folder (as OpenOCD should keep running in the first one), and enter
    the following command to start the GDB:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当 OpenOCD 运行时，下一步涉及使用 GDB 将固件上传到微控制器。让我们打开另一个命令提示符窗口，仍然在调试文件夹中（因为 OpenOCD 应该在第一个窗口中继续运行），并输入以下命令以启动
    GDB：
- en: '[PRE8]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the GDB is open, we establish a connection to the microcontroller by running
    the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GDB 打开，我们通过运行以下命令与微控制器建立连接：
- en: '[PRE9]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command connects GDB to the OpenOCD server running on the local machine
    (`localhost`) on port `3333`, which is the default port for OpenOCD.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 GDB 连接到本地机器（`localhost`）上运行的 OpenOCD 服务器，端口号为 `3333`，这是 OpenOCD 的默认端口。
- en: 'Upon executing this command, both command prompt windows return outputs telling
    us that debugging has started:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，两个命令提示符窗口都会返回输出，告诉我们调试已经开始：
- en: '![Figure 3.9: Output from the command prompt window running the GDB](img/B21914_03_09.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：运行 GDB 的命令提示符窗口的输出](img/B21914_03_09.jpg)'
- en: 'Figure 3.9: Output from the command prompt window running the GDB'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：运行 GDB 的命令提示符窗口的输出
- en: 'This is the output from the command prompt window running `st_nucleo_f4.cfg`
    :'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行 `st_nucleo_f4.cfg` 的命令提示符窗口的输出：
- en: '![Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg](img/B21914_03_10.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：运行 st_nucleo_f4.cfg 的命令提示符窗口的输出](img/B21914_03_10.jpg)'
- en: 'Figure 3.10: Output from the command prompt window running st_nucleo_f4.cfg'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：运行 st_nucleo_f4.cfg 的命令提示符窗口的输出
- en: 'Before loading the firmware, we have to reset and initialize the board using
    the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载固件之前，我们必须使用以下命令来重置和初始化板：
- en: '[PRE10]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s break down the command into its components:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将命令分解为其组成部分：
- en: '`monitor`: This prefix is used in the GDB to indicate that the following command
    is not a GDB command but is meant for the debugging server (in this case, OpenOCD)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor`：此前缀在 GDB 中用于指示以下命令不是 GDB 命令，而是针对调试服务器（在这种情况下，OpenOCD）的'
- en: '`reset`: This part of the command instructs OpenOCD to reset the target device'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`：此命令部分指示 OpenOCD 重置目标设备'
- en: '`init`: This tells OpenOCD to execute its initialization sequence for the target
    device'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这告诉 OpenOCD 为目标设备执行其初始化序列'
- en: 'Then, we load the firmware onto the microcontroller using the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令将固件加载到微控制器上：
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command erases the existing firmware on the microcontroller and writes
    the new firmware (in this case, `2_RegisterManipulation.elf`) onto it. This command
    erases the existing firmware on the microcontroller and writes the new firmware
    (in this case, `2_RegisterManipulation.elf`) onto it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将擦除微控制器上的现有固件，并将新的固件（在本例中为`2_RegisterManipulation.elf`）写入其中。此命令将擦除微控制器上的现有固件，并将新的固件（在本例中为`2_RegisterManipulation.elf`）写入其中：
- en: '`flash write_image`: This is an OpenOCD command that tells it to write an image
    to the flash memory of the target microcontroller – in effect, programming the
    microcontroller with a new firmware image.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flash write_image`：这是一个OpenOCD命令，告诉它将映像写入目标微控制器的闪存中——实际上，用新的固件映像编程微控制器。'
- en: '`erase`: This option tells OpenOCD to erase the flash memory before writing
    the new image. Erasing the flash is a common requirement in microcontroller programming,
    as it clears any previous program and ensures that the new firmware is written
    to a clean memory space.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`erase`：此选项告诉OpenOCD在写入新映像之前擦除闪存。在微控制器编程中，擦除闪存是一个常见的要求，因为它清除任何以前的程序，并确保新的固件被写入干净的内存空间。'
- en: After successfully loading the firmware, we reset the board again with the same
    `reset` command.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功加载固件后，我们再次使用相同的`reset`命令重置了板子。
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we resume the execution of the code on the microcontroller with the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令在微控制器上继续执行代码：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Voila! The firmware should now be running on the microcontroller. You should
    see the LED on the board blinking, indicating the successful upload and execution
    of the new firmware.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！固件现在应该在微控制器上运行了。你应该看到板上的LED闪烁，表明新固件的上传和执行成功。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the intricacies of the embedded firmware build
    process, with a specific focus on the GNU Toolchain.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了嵌入式固件构建过程的复杂性，特别关注GNU工具链。
- en: We began by getting to know the embedded build process, exploring its multiple
    stages – pre-processing, compilation, assembly, linking, and locating. Each stage
    was analyzed, clarifying its significance in transforming human-readable source
    code into executable machine instructions. We delved into the roles of pre-processing
    in preparing code, the nuances of compilation and assembly in translating and
    converting code, and the intricate tasks of linking and locating in forming a
    cohesive, executable binary.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了嵌入式构建过程，探索了它的多个阶段——预处理、编译、汇编、链接和定位。每个阶段都被分析，阐明了它在将人类可读的源代码转换为可执行机器指令中的重要性。我们深入研究了预处理在准备代码中的作用，编译和汇编在转换和转换代码中的细微差别，以及链接和定位在形成连贯、可执行二进制中的复杂任务。
- en: Transitioning to practical application, the chapter introduced the GNU Binary
    Tools for Embedded Systems. By revisiting our previously developed bare-metal
    GPIO driver, we observed the build commands executed by the STM32CubeIDE, replicating
    these steps manually using our command-line interface. This approach gave us a
    deeper appreciation of the underlying processes and commands that IDEs automate.
    In the latter part of the chapter, we went through the step-by-step process of
    uploading our firmware to the microcontroller using OpenOCD, from locating the
    correct OpenOCD script for the development board to executing commands to reset,
    initialize, and run the firmware on the microcontroller. This practical exercise
    demonstrated the successful application of the theoretical knowledge we gained
    earlier, marking a significant milestone in our journey.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 转向实际应用，本章介绍了嵌入式系统的GNU二进制工具。通过回顾我们之前开发的裸机GPIO驱动程序，我们观察了STM32CubeIDE执行的构建命令，通过我们的命令行界面手动复制这些步骤。这种方法让我们更深入地理解了IDE自动化的底层过程和命令。在章节的后半部分，我们逐步介绍了使用OpenOCD将我们的固件上传到微控制器的过程，从找到适合开发板的正确OpenOCD脚本到执行重置、初始化和运行微控制器上固件的命令。这个实际练习展示了我们之前获得的理论知识的成功应用，标志着我们旅程中的一个重要里程碑。
- en: In the next chapter, we shall learn how to write our own linker scripts and
    startup files. This important step will represent another significant milestone
    in our journey toward mastering the art of developing entirely bare-metal firmware
    from the ground up.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写我们自己的链接脚本和启动文件。这一重要步骤将代表我们掌握从头开始开发完全裸机固件的旅程中的另一个重要里程碑。
