- en: Manipulating Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作字符串
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Changing cases and case-insensitive comparison
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改大小写和不区分大小写比较
- en: Matching strings using regular expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配字符串
- en: Searching and replacing strings using regular expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索和替换字符串
- en: Formatting strings using safe printf-like functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的printf样式函数格式化字符串
- en: Replacing and erasing strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换和删除字符串
- en: Representing a string with two iterators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用两个迭代器表示一个字符串
- en: Using a reference to string type
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对字符串类型的引用
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This whole chapter is devoted to different aspects of changing, searching, and
    representing strings. We'll see how some common string-related tasks can be easily
    done using Boost libraries. This chapter is easy enough; it addresses very common
    string manipulation tasks. So, let's begin!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节都致力于不同方面的更改、搜索和表示字符串。我们将看到如何使用Boost库轻松完成一些常见的与字符串相关的任务。这一章很容易；它涉及非常常见的字符串操作任务。所以，让我们开始吧！
- en: Changing cases and case-insensitive comparison
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改大小写和不区分大小写比较
- en: 'This is a pretty common task. We have two non-Unicode or ANSI character strings:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的任务。我们有两个非Unicode或ANSI字符字符串：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to compare them in a case-insensitive manner. There are a lot of methods
    to do that, let's take a look at Boost's.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以不区分大小写的方式进行比较。有很多方法可以做到这一点，让我们看看Boost的方法。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of `std::string` is all we need here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只需要基本的`std::string`知识。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are different ways to do case-insensitive comparisons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进行不区分大小写比较的不同方法：
- en: 'The most simple one is:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的方法是：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the Boost predicate and standard library method:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Boost谓词和标准库方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Making a lowercase copy of both the strings:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作两个字符串的小写副本：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Making an uppercase copy of the original strings:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作原始字符串的大写副本：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Converting the original strings to lowercase:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始字符串转换为小写：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The second method is not an obvious one. In the second method, we compare the
    length of strings. If they have the same length, we compare the strings character
    by character using an instance of the `boost::is_iequal` predicate. The `boost::is_iequal`
    predicate compares two characters in a case insensitive way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法并不明显。在第二种方法中，我们比较字符串的长度。如果它们长度相同，我们使用`boost::is_iequal`谓词的实例逐个字符比较字符串，该谓词以不区分大小写的方式比较两个字符。
- en: The `Boost.StringAlgorithm` library uses `i` in the name of a method or class,
    if this method is case-insensitive. For example, `boost::is_iequal`, `boost::iequals`,
    `boost::is_iless`, and others.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm`库在方法或类的名称中使用`i`，如果该方法是不区分大小写的。例如，`boost::is_iequal`，`boost::iequals`，`boost::is_iless`等。'
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Each function and the functional object of the `Boost.StringAlgorithm` library
    that works with cases accept `std::locale`. By default (and in our examples),
    methods and classes use default constructed `std::locale`. If we work a lot with
    strings, it may be a good optimization to construct an `std::locale` variable
    once and pass it to all the methods. Another good optimization would be to use
    the *C* locale (if your application logic permits that) via `std::locale::classic()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm`库的每个函数和函数对象都接受`std::locale`。默认情况下（在我们的示例中），方法和类使用默认构造的`std::locale`。如果我们大量使用字符串，一次构造`std::locale`变量并将其传递给所有方法可能是一个很好的优化。另一个很好的优化是通过`std::locale::classic()`使用*C*语言环境（如果您的应用逻辑允许）：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Nobody forbids you to use both optimizations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人禁止您同时使用这两种优化。
- en: Unfortunately, C++17 has no string functions from `Boost.StringAlgorithm`. All
    the algorithms are fast and reliable, so do not be afraid to use them in your
    code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，C++17没有来自`Boost.StringAlgorithm`的字符串函数。所有的算法都快速可靠，所以不要害怕在代码中使用它们。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation of the Boost String Algorithms Library can be found at
    [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost String Algorithms库的官方文档可以在[http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)找到
- en: See the *C++ Coding Standards* book by Andrei Alexandrescu and Herb Sutter for
    an example on how to make a case-insensitive string with a few lines of code
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Andrei Alexandrescu和Herb Sutter的*C++编程标准*一书，了解如何使用几行代码制作不区分大小写的字符串的示例
- en: Matching strings using regular expressions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配字符串
- en: Let's do something useful! It is a common case when the user's input must be
    checked using some **regular expression**. The problem is that there are a lot
    of regular expression syntaxes, expressions written using one syntax are not treated
    well by the other syntaxes. Another problem is that long regexes are not so easy
    to write.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些有用的事情！当用户的输入必须使用一些**正则表达式**进行检查时，这是一个常见情况。问题在于有很多正则表达式语法，使用一种语法编写的表达式在其他语法中处理得不好。另一个问题是，长的正则表达式不那么容易编写。
- en: So in this recipe, we are going to write a program that supports different regular
    expression syntaxes and checks that the input strings match the specified regexes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个示例中，我们将编写一个支持不同正则表达式语法并检查输入字符串是否匹配指定正则表达式的程序。
- en: Getting started
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe requires basic knowledge of standard library. Knowledge of regular
    expression syntaxes can be helpful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要基本的标准库知识。了解正则表达式语法可能会有所帮助。
- en: Linking examples against the `boost_regex` library is required.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将示例链接到`boost_regex`库。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This regex-matcher example consists of a few lines of code in the `main()`
    function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式匹配器示例由`main()`函数中的几行代码组成：
- en: 'To implement it, we need the following headers:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现它，我们需要以下标头：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the start of the program, we need to output the available regex syntaxes:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始时，我们需要输出可用的正则表达式语法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, correctly set up flags, according to the chosen syntax:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据所选择的语法正确设置标志：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now requesting regex patterns in a loop:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在循环中请求正则表达式模式：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Getting a `String to match:` in a loop:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中获取`要匹配的字符串`：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Applying regex to it and outputting the result:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其应用正则表达式并输出结果：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will finish our example by restoring `std::cin` and requesting new regex
    patterns:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过恢复`std::cin`并请求新的正则表达式模式来完成我们的示例：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now if we run the preceding example, we''ll get the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行前面的示例，我们将得到以下输出：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All the matching is done by the `boost::regex` class. It constructs an object
    that is capable of regex parsing and compilation. Additional configuration options
    are passed to the class using a `flag` input variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的匹配都是由`boost::regex`类完成的。它构造了一个能够进行正则表达式解析和编译的对象。通过`flag`输入变量将额外的配置选项传递给类。
- en: 'If the regular expression is incorrect, `boost::regex` throws an exception.
    If the `boost::regex::no_except` flag was passed, it reports an error returning
    a non-zero in the `status()` call (just like in our example):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正则表达式不正确，`boost::regex`会抛出异常。如果传递了`boost::regex::no_except`标志，它会在`status()`调用中返回非零以报告错误（就像我们的示例中一样）：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Regular expressions matching is done by a call to the `boost::regex_match` function.
    It returns `true` in case of a successful match. Additional flags may be passed
    to `regex_match`, but we avoided their usage for brevity of the example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`boost::regex_match`函数来进行正则表达式匹配。如果匹配成功，它将返回`true`。可以向`regex_match`传递其他标志，但为了简洁起见，我们避免了它们的使用。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 contains almost all the `Boost.Regex` classes and flags. They can be found
    in the `<regex>` header of the `std::` namespace (instead of `boost::`). Official
    documentation provides information about differences of C++11 and `Boost.Regex`.
    It also contains some performance measures that tell that `Boost.Regex` is fast.
    Some standard libraries have performance issues, so choose wisely between Boost
    and Standard library versions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++11几乎包含了所有`Boost.Regex`类和标志。它们可以在`std::`命名空间的`<regex>`头文件中找到（而不是`boost::`）。官方文档提供了关于C++11和`Boost.Regex`的差异的信息。它还包含一些性能测量，表明`Boost.Regex`很快。一些标准库存在性能问题，因此在Boost和标准库版本之间明智地进行选择。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Searching and replacing strings by regular expressions* recipe will give
    you more information about the `Boost.Regex` usage
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式搜索和替换字符串*示例将为您提供有关`Boost.Regex`用法的更多信息'
- en: You may also consider official documentation to get more information about flags,
    performance measures, regular expression syntaxes, and C++11 conformance at [http://boost.org/libs/regex](http://boost.org/libs/regex)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以考虑官方文档，以获取有关标志、性能测量、正则表达式语法和C++11兼容性的更多信息，网址为[http://boost.org/libs/regex](http://boost.org/libs/regex)
- en: Searching and replacing strings using regular expressions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索和替换字符串
- en: My wife enjoyed the *Matching strings by regular expressions* recipe very much.
    But, she wanted more and told me that I'll get no food until I promote the recipe
    to be able to replace parts of the input string according to a regex match.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我的妻子非常喜欢*通过正则表达式匹配字符串*示例。但是，她想要更多，并告诉我，除非我提升这个配方以便能够根据正则表达式匹配替换输入字符串的部分，否则我将得不到食物。
- en: Ok, here it comes. Each matched sub-expression (part of the regex in parenthesis)
    must get a unique number starting from 1; this number would be used to create
    a new string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它来了。每个匹配的子表达式（括号中的正则表达式部分）必须从1开始获得一个唯一的编号；这个编号将用于创建一个新的字符串。
- en: 'This is how an updated program should work like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是更新后的程序应该工作的方式：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be reusing the code from the *Matching strings by regular expressions*
    recipe. It is recommended to read it before getting your hands on this one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用*通过正则表达式匹配字符串*示例中的代码。建议在阅读本示例之前先阅读它。
- en: Linking an example against the `boost_regex` library is required.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要链接一个示例到`boost_regex`库。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe is based on the code from the previous one. Let''s see what must
    be changed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是基于前一个配方的代码。让我们看看必须改变什么：
- en: 'No additional headers should be included. However, we need an additional string
    to store the replace pattern:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要包含额外的头文件。但是，我们需要一个额外的字符串来存储替换模式：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We replace `boost::regex_match` with `boost::regex_find` and output matched
    results:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用`boost::regex_match`替换为`boost::regex_find`并输出匹配的结果：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we need to get the replace pattern and apply it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要获取替换模式并应用它：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That's it! Everyone's happy and I'm fed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！每个人都很开心，我也吃饱了。
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `boost::regex_search` function doesn''t only return a `true` or a `false`
    value (unlike the `boost::regex_match` function does), but also stores matched
    parts. We output matched parts using the following construction:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::regex_search`函数不仅返回`true`或`false`值（不像`boost::regex_match`函数那样），而且还存储匹配的部分。我们使用以下结构输出匹配的部分：'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we outputted the results by skipping the first result (`results.begin()
    + 1`), that is because `results.begin()` contains the whole regex match.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过跳过第一个结果（`results.begin() + 1`）输出了结果，这是因为`results.begin()`包含整个正则表达式匹配。
- en: The `boost::regex_replace` function does all the replacing and returns the modified
    string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::regex_replace`函数执行所有替换并返回修改后的字符串。'
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are different variants of the `regex_*` functions, some of them receive
    bidirectional iterators instead of strings and some provide output to the iterator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_*`函数有不同的变体，其中一些接收双向迭代器而不是字符串，有些则向迭代器提供输出。'
- en: '`boost::smatch` is a `typedef` for `boost::match_results<std::string::const_iterator>`.
    If you are using some other bidirectional iterators instead of `std::string::const_iterator`,
    you shall use the type of your bidirectional iterators as a template parameter
    for `boost::match_results`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::smatch`是`boost::match_results<std::string::const_iterator>`的`typedef`。如果您使用的是`std::string::const_iterator`之外的其他双向迭代器，您应该将您的双向迭代器的类型作为`boost::match_results`的模板参数。'
- en: '`match_results` has a format function, so we may tune our example with it,
    instead of:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results`有一个格式函数，因此我们可以使用它来调整我们的示例，而不是：'
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We may use the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下内容：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By the way, `replace_string` supports multiple formats:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`replace_string`支持多种格式：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All the classes and functions from this recipe exist in C++11 in the `std::`
    namespace of the `<regex>` header.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的所有类和函数都存在于C++11的`<regex>`头文件的`std::`命名空间中。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation of `Boost.Regex` will give you more examples and information
    about performance, C++11 standard compatibility, and regular expression syntax
    at [http://boost.org/libs/regex](http://boost.org/libs/regex). The *Matching strings
    by regular expressions* recipe will tell you the basics of `Boost.Regex`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Regex`的官方文档将为您提供更多关于性能、C++11标准兼容性和正则表达式语法的示例和信息，网址为[http://boost.org/libs/regex](http://boost.org/libs/regex)。*通过正则表达式匹配字符串*示例将告诉您`Boost.Regex`的基础知识。'
- en: Formatting strings using safe printf-like functions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全的printf样式函数格式化字符串
- en: The `printf` family of functions is a threat to security. It is a very bad design
    to allow users to put their own strings as a type and format the specifiers. So
    what do we do when user-defined format is required? How shall we implement the
    `std::string to_string(const std::string& format_specifier) const;` member function
    of the following class?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`系列函数对安全性构成威胁。允许用户将自己的字符串作为类型并格式化说明符是非常糟糕的设计。那么当需要用户定义的格式时，我们该怎么办？我们应该如何实现以下类的成员函数`std::string
    to_string(const std::string& format_specifier) const;`？'
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of standard library is more than enough for this recipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对标准库的基本知识就足够了。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We wish to allow users to specify their own output format for a string:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许用户为字符串指定自己的输出格式：
- en: 'To do that in a safe manner, we need the following header:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了以安全的方式进行操作，我们需要以下头文件：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we add some comments for the user:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们为用户添加一些注释：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is time to make all the parts work:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候让所有部分都运行起来了：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That is all. Take a look at this code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。看一下这段代码：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Imagine that `class_instance` has a member `i` equal to `100`, `s` member equal
    to `"Reader"`, and a member `c` equal to `''!''`. Then, the program will output
    the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`class_instance`有一个成员`i`等于`100`，一个成员`s`等于`"Reader"`，一个成员`c`等于`'!'`。然后，程序将输出如下内容：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::format` class accepts the string that specifies the resulting string
    format. Arguments are passed to `boost::format` using `operator%`. Values `%1%`,
    `%2%`, `%3%`, `%4%`, and so on, in the format specifying string are replaced by
    arguments passed to `boost::format`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::format`类接受指定结果字符串格式的字符串。参数通过`operator%`传递给`boost::format`。在指定字符串格式中，`%1%`、`%2%`、`%3%`、`%4%`等值会被传递给`boost::format`的参数替换。'
- en: 'We also disable the exceptions for cases when a format string contains fewer
    arguments than passed to `boost::format`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还禁用了异常，以防格式字符串包含的参数少于传递给`boost::format`的参数：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is done to allow some formats like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了允许一些这样的格式：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What happens in case of an incorrect format?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式不正确的情况下会发生什么？
- en: 'Nothing awful, an exception is thrown:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么可怕的，会抛出一个异常：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following lines are outputted to the console by the previous code snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段通过控制台输出了以下行：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: C++17 has no `std::format`. The `Boost.Format` library is not a very fast library.
    Try not to use it in performance critical sections a lot.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有`std::format`。`Boost.Format`库不是一个非常快的库。尽量不要在性能关键的部分大量使用它。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation contains more information about performance of the `Boost.Format`
    library. More examples and documentation on extended printf-like format is available
    at [http://boost.org/libs/format.](http://boost.org/libs/format)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档包含了有关`Boost.Format`库性能的更多信息。在[http://boost.org/libs/format](http://boost.org/libs/format)上还有更多关于扩展printf格式的示例和文档。
- en: "[\uFEFF](http://boost.org/libs/format)"
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: "[\uFEFF](http://boost.org/libs/format)"
- en: Replacing and erasing strings
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换和擦除字符串
- en: Situations where we need to erase something in a string, replace a part of the
    string, or erase the first or last occurrence of some sub-string are very common.
    Standard library allows us to do more parts of this, but it usually involves too
    much code writing.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在字符串中擦除某些内容，替换字符串的一部分，或者擦除某些子字符串的第一个或最后一个出现的情况非常常见。标准库允许我们做更多的部分，但通常需要编写太多的代码。
- en: 'We saw the `Boost.StringAlgorithm` library in action in the *Changing cases
    and case-insensitive comparison* recipe. Let''s see how it can be used to simplify
    our lives when we need to modify some strings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*更改大小写和不区分大小写比较*示例中看到了`Boost.StringAlgorithm`库的实际应用。让我们看看当我们需要修改一些字符串时，它如何简化我们的生活：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要对C++有基本的了解。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe shows how different string-erasing and replacing methods from the
    `Boost.StringAlgorithm` library work:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了`Boost.StringAlgorithm`库中不同的字符串擦除和替换方法的工作原理：
- en: 'Erasing requires the `#include <boost/algorithm/string/erase.hpp>` header:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 擦除需要`#include <boost/algorithm/string/erase.hpp>`头文件：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code outputs the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出如下内容：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replacing requires the `<boost/algorithm/string/replace.hpp>` header:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换需要`<boost/algorithm/string/replace.hpp>`头文件：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This code outputs the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码输出如下内容：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the examples are self-documenting. The only one that is not obvious is the
    `replace_head_copy` function. It accepts count of bytes to replace as a second
    parameter and a replace string as the third parameter. So, in the preceding example,
    `Hello` gets replaced with `Whaaaaaaa!`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都是自解释的。唯一不明显的是`replace_head_copy`函数。它接受要替换的字节数作为第二个参数，替换字符串作为第三个参数。因此，在前面的示例中，`Hello`被替换为`Whaaaaaaa!`。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are also methods that modify strings in-place. They just do not end on
    `_copy` and return `void`. All the case-insensitive methods (the ones that start
    with `i`) accept `std::locale` as the last parameter and use a default constructed
    locale as a default parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些可以就地修改字符串的方法。它们不以`_copy`结尾，返回`void`。所有不区分大小写的方法（以`i`开头的方法）都接受`std::locale`作为最后一个参数，并使用默认构造的locale作为默认参数。
- en: 'Do you use case insensitive methods a lot and need a better performance? Just
    create a `std::locale` variable holding `std::locale::classic()` and pass it to
    all the algorithms. On small strings most of the time is eaten by `std::locale`
    constructions, not by the algorithms:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常使用不区分大小写的方法并且需要更好的性能吗？只需创建一个持有`std::locale::classic()`的`std::locale`变量，并将其传递给所有算法。在小字符串上，大部分时间都被`std::locale`构造所消耗，而不是算法：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: C++17 does not have `Boost.StringAlgorithm` methods and classes. However, it
    has a `std::string_view` class that can use substrings without memory allocations.
    You can find out more about `std::string_view` like classes in the next two recipes
    of this chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有`Boost.StringAlgorithm`方法和类。然而，它有一个`std::string_view`类，可以在没有内存分配的情况下使用子字符串。您可以在本章的下两个配方中找到更多关于类似`std::string_view`的类的信息。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Official documentation contains a lot of examples and a full reference of all
    the methods at [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含大量示例和所有方法的完整参考[http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
- en: See the *Changing cases and case-insensitive comparison* recipe from this chapter
    for more information about the `Boost.StringAlgorithm` library
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.StringAlgorithm`库的更多信息，请参见本章的*更改大小写和不区分大小写比较*配方
- en: Representing a string with two iterators
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用两个迭代器表示一个字符串
- en: There are situations when we need to split some strings into substrings and
    do something with those substrings. In this recipe, we want to split string into
    sentences, count characters, and white-spaces and, of course, we want to use Boost
    and be as efficient as possible.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将一些字符串拆分成子字符串并对这些子字符串进行操作。在这个配方中，我们想将字符串拆分成句子，计算字符和空格，当然，我们想使用Boost并尽可能高效。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need some basic knowledge of standard library's algorithms for this recipe.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要一些标准库算法的基本知识。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'That''s very easy to do with Boost:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost非常容易：
- en: 'First of all, include the right headers:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包括正确的头文件：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s define our test string:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的测试字符串：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We make a `typedef` for our splitting iterator:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的分割迭代器制作了一个`typedef`：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Construct that iterator:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造该迭代器：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we can iterate between matches:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在匹配之间进行迭代：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Count the number of characters:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字符的数量：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And count the white-spaces:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并计算空格：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'That''s it. Now if we run an example, it will output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在，如果我们运行一个示例，它将输出：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main idea of this recipe is that we do not need to construct `std::string`
    from substrings. We even do not need to tokenize the whole string at once. All
    we need to do is find the first substring and return it as a pair of iterators
    to the beginning and to the end of the substring. If we need more substrings,
    find the next substring and return a pair of iterators for that substring.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的主要思想是我们不需要从子字符串构造`std::string`。我们甚至不需要一次性对整个字符串进行标记。我们所需要做的就是找到第一个子字符串，并将其作为一对迭代器返回到子字符串的开头和结尾。如果我们需要更多的子字符串，找到下一个子字符串并返回该子字符串的一对迭代器。
- en: '![](img/00015.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Now, let's take a closer look at `boost::split_iterator`. We constructed one
    using the `boost::make_split_iterator` function that takes `range` as the first
    argument and a binary finder predicate (or binary predicate) as the second. When
    `split_iterator` is dereferenced, it returns the first substring as `boost::iterator_range<const
    char*>`, which just holds a pair of pointers and has a few methods to work with
    them. When we increment `split_iterator`, it tries to find the next substring,
    and if there is no substring found, `split_iterator::eof()` returns `true`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看`boost::split_iterator`。我们使用`boost::make_split_iterator`函数构造了一个，它将`range`作为第一个参数，二进制查找谓词（或二进制谓词）作为第二个参数。当解引用`split_iterator`时，它将第一个子字符串作为`boost::iterator_range<const
    char*>`返回，它只是保存一对指针并有一些方法来处理它们。当我们递增`split_iterator`时，它会尝试找到下一个子字符串，如果没有找到子字符串，`split_iterator::eof()`将返回`true`。
- en: 'Default constructed split iterator represents an `eof()`. So we could rewrite
    the loop condition from `!sentences.eof()` to `sentences != split_iter_t()`. You
    could also use the split iterators with algorithms, for example: `std::for_each(sentences,
    split_iter_t(), [](auto range){ /**/ });`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的分割迭代器表示`eof()`。因此，我们可以将循环条件从`!sentences.eof()`重写为`sentences != split_iter_t()`。您还可以使用分割迭代器与算法，例如：`std::for_each(sentences,
    split_iter_t(), [](auto range){ /**/ });`。
- en: There's more...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::iterator_range` class is widely used across all the Boost libraries.
    You may find it useful even for your own code in situations when a pair of iterators
    must be returned or when a function shall accept/work with a pair of iterators.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::iterator_range`类广泛用于所有Boost库。即使在您自己的代码中，当需要返回一对迭代器或者函数需要接受/处理一对迭代器时，您可能会发现它很有用。'
- en: The `boost::split_iterator<>` and `boost::iterator_range<>` classes accept a
    forward iterator type as a template parameter. Because we were working with the
    character array in the preceding example, we provided `const char*` as iterators.
    If we were working with `std::wstring`, we would need to use the `boost::split_iterator<std::wstring::const_iterator>`
    and `boost::iterator_range<std::wstring::const_iterator>` types.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::split_iterator<>`和`boost::iterator_range<>`类接受前向迭代器类型作为模板参数。因为在前面的示例中我们使用字符数组，所以我们提供了`const
    char*`作为迭代器。如果我们使用`std::wstring`，我们需要使用`boost::split_iterator<std::wstring::const_iterator>`和`boost::iterator_range<std::wstring::const_iterator>`类型。'
- en: C++17 has neither `iterator_range` nor `split_iterator`. However, there are
    discussions going on for accepting `iterator_range` like class that would probably
    have the name `std::span`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中既没有`iterator_range`也没有`split_iterator`。然而，正在讨论接受类似`iterator_range`的类，可能会有名为`std::span`的名称。
- en: The `boost::iterator_range` class has no virtual functions and no dynamic memory
    allocations, it is fast and efficient. However, its output stream operator `<<`
    has no specific optimizations for character arrays, so streaming could be slow.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::iterator_range`类没有虚函数和动态内存分配，它非常快速和高效。然而，它的输出流操作符`<<`对字符数组没有特定的优化，因此流操作可能会很慢。'
- en: The `boost::split_iterator` class has a `boost::function` class in it, so constructing
    it for big functors could be slow. Iterating adds only tiny overheads that you
    won't feel even in performance critical sections.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::split_iterator`类中有一个`boost::function`类，因此为大型函数构造它可能会很慢。迭代只会增加微小的开销，即使在性能关键的部分，你也不会感觉到。'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next recipe will tell you about a nice replacement for `boost::iterator_range<const
    char*>`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个示例将告诉您`boost::iterator_range<const char*>`的一个很好的替代品
- en: Official documentation for `Boost.StringAlgorithm` may provide you with more
    detailed information about classes and a whole bunch of examples at [http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm`的官方文档可能会为您提供有关类的更详细信息以及大量示例的信息，网址为[http://boost.org/libs/algorithm/string](http://boost.org/libs/algorithm/string)'
- en: 'More information about `boost::iterator_range` can be found here: [http://boost.org/libs/range](http://boost.org/libs/range);
    it is a part of the `Boost.Range` library that is not described in this book,
    but you may wish to study it by yourself'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`boost::iterator_range`的更多信息可以在这里找到：[http://boost.org/libs/range](http://boost.org/libs/range)；它是`Boost.Range`库的一部分，本书中没有描述，但您可能希望自行研究它
- en: Using a reference to string type
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对字符串类型的引用
- en: 'This recipe is the most important recipe in this chapter! Let''s take a look
    at a very common case, where we write some function that accepts a string and
    returns a part of the string between character values passed in the `starts` and
    `ends` arguments:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是本章中最重要的示例！让我们看一个非常常见的情况，我们编写一些接受字符串并返回在`starts`和`ends`参数中传递的字符值之间的字符串部分的函数：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Do you like this implementation? In my opinion, it is awful. Consider the following
    call to it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢这个实现吗？在我看来，这个实现很糟糕。考虑对它的以下调用：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, a temporary `std::string` variable is constructed from `"Getting
    expression (between brackets)"`. The character array is long enough, so there
    is a big chance that dynamic memory allocation is called inside the `std::string`
    constructor and the character array is copied into it. Then, somewhere inside
    the `between_str` function, new `std::string` is being constructed, which may
    also lead to another dynamic memory allocation and copying.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，从`"Getting expression (between brackets)"`构造了一个临时的`std::string`变量。字符数组足够长，因此在`std::string`构造函数内可能会调用动态内存分配，并将字符数组复制到其中。然后，在`between_str`函数的某个地方，将构造新的`std::string`，这可能还会导致另一个动态内存分配和复制。
- en: 'So, this simple function may, and in most cases will:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个简单的函数可能会，并且在大多数情况下会：
- en: Call dynamic memory allocation (two times)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用动态内存分配（两次）
- en: Copy string (two times)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制字符串（两次）
- en: Deallocate memory (two times)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存（两次）
- en: Can we do better?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires basic knowledge of standard library and C++.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例需要对标准库和C++有基本的了解。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We do not really need a `std::string` class here, we only need some lightweight
    class that does not manage resources and only has a pointer to the character array
    and array's size. Boost has the `boost::string_view` class for that.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们实际上并不需要`std::string`类，我们只需要一些轻量级的类，它不管理资源，只有一个指向字符数组和数组大小的指针。Boost有`boost::string_view`类可以满足这个需求。
- en: 'To use the `boost::string_view` class, include the following header:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`boost::string_view`类，请包含以下头文件：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Change the method''s signature:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改方法的签名：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Change `std::string` to `boost::string_view:` everywhere inside the function
    body:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体内的任何地方将`std::string`更改为`boost::string_view`：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `boost::string_view` constructor accepts size as a second parameter, so
    we need to slightly change the code:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::string_view`构造函数接受大小作为第二个参数，因此我们需要稍微更改代码：'
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That''s it! Now we may call `between("Getting expression (between brackets)",
    ''('', '')'')` and it will work without any dynamic memory allocation and characters
    copying. And we can still use it for `std::string`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在我们可以调用`between("Getting expression (between brackets)", '(', ')')`，而且它将在没有任何动态内存分配和字符复制的情况下工作。而且我们仍然可以将其用于`std::string`：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As already mentioned, `boost::string_view` contains only a pointer to the character
    array and size of data. It has a lot of constructors and may be initialized in
    different ways:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`boost::string_view`只包含一个指向字符数组的指针和数据大小。它有很多构造函数，可以以不同的方式初始化：
- en: '[PRE60]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `boost::string_view` class has all the methods required by the `container`
    class, so it is usable with standard library algorithms and Boost algorithms:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_view`类具有`container`类所需的所有方法，因此可以与标准库算法和Boost算法一起使用：'
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `boost::string_view` class does not really own string, so all its methods
    return constant iterators. Because of that, we cannot use it in methods that modify
    data, such as `boost::to_lower(r)`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_view`类实际上并不拥有字符串，因此它的所有方法都返回常量迭代器。因此，我们不能在修改数据的方法中使用它，比如`boost::to_lower(r)`。'
- en: While working with `boost::string_view`, we must take additional care about
    data that it refers to; it must exist and be valid for the whole lifetime of the
    `boost::string_view` variable that references it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`boost::string_view`时，我们必须额外注意它所引用的数据；它必须存在并且在整个`boost::string_view`变量的生命周期内都有效。
- en: Before Boost 1.61 there was no `boost::string_view` class, but the `boost::string_ref`
    class was used instead. Those classes are really close. `boost::string_view` closer
    follows the C++17 design and has better constexpr support. Since Boost 1.61, `boost::string_ref`
    is deprecated.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boost 1.61之前，没有`boost::string_view`类，而是使用`boost::string_ref`类。这些类非常接近。`boost::string_view`更接近C++17的设计，并且具有更好的constexpr支持。自Boost
    1.61以来，`boost::string_ref`已被弃用。
- en: 'The `string_view` classes are fast and efficient, because they never allocate
    memory and have no virtual functions! Use them wherever it is possible. They are
    designed to be a drop-in replacement for `const std::string&` and `const char*`
    parameters. It means that you can replace the following three functions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view`类是快速和高效的，因为它们从不分配内存，也没有虚函数！在任何可能的地方使用它们。它们被设计为`const std::string&`和`const
    char*`参数的即插即用替代品。这意味着你可以替换以下三个函数：'
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'With a single one:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个单一的：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::string_view` class is a C++17 class. You can find it in the `<string_view>`
    header in the `std::` namespace if your compiler is C++17 compatible.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_view`类是一个C++17类。如果您的编译器兼容C++17，可以在`std::`命名空间的`<string_view>`头文件中找到它。'
- en: Boost's and standard library's version support constexpr usage of `string_view`s;
    however, `std::string_view` currently has more functions marked with constexpr.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Boost和标准库的版本支持对`string_view`的constexpr使用；然而，`std::string_view`目前具有更多的标记为constexpr的函数。
- en: 'Note that we have accepted the `string_view` variable by value instead of a
    constant reference. That''s the recommended way for passing `boost::string_view`s
    and `std::string_view`s because:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经通过值接受了`string_view`变量，而不是常量引用。这是传递`boost::string_view`和`std::string_view`的推荐方式，因为：
- en: '`string_view` is a small class with trivial types inside. Passing it by value
    usually results in better performance because of less indirections and it allows
    the compiler to do more optimizations.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string_view`是一个具有平凡类型的小类。通过值传递它通常会导致更好的性能，因为减少了间接引用，并且允许编译器进行更多的优化。'
- en: In other cases, when there's no performance difference writing `string_view
    val` is shorter than writing `const string_view& val`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他情况下，当没有性能差异时，编写`string_view val`比编写`const string_view& val`更短。
- en: 'Just like the C++17''s `std::string_view`, the `boost::string_view` class is
    actually a `typedef`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 就像C++17的`std::string_view`一样，`boost::string_view`类实际上是一个`typedef`：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You may also find useful the following typedefs for wide characters in the
    `boost::` and `std::` namespaces:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`boost::`和`std::`命名空间中找到宽字符的以下typedef：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Boost documentation for `string_ref` and `string_view` can be found at [http://boost.org/libs/utility](http://boost.org/libs/utility).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_ref`和`string_view`的Boost文档可以在[http://boost.org/libs/utility](http://boost.org/libs/utility)找到。'
