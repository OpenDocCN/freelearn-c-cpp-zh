- en: Chapter 3. Cooking an RSS Reader with Qt Quick
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。使用 Qt Quick 制作 RSS 阅读器
- en: 'In this chapter, we will focus on developing applications with Qt Quick. For
    touchscreen-enabled devices, Qt Quick applications are much more responsive and
    easy to write. An RSS reader is used as a demonstration in this chapter. The following
    topics will enable you to build elegant Qt Quick applications:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于开发使用 Qt Quick 的应用程序。对于支持触控屏的设备，Qt Quick 应用程序响应更快，编写起来也更简单。本章使用 RSS
    阅读器作为演示。以下主题将帮助您构建优雅的 Qt Quick 应用程序：
- en: Understanding model and view
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模型和视图
- en: Parsing RSS Feeds by `XmlListModel`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `XmlListModel` 解析 RSS 源
- en: Tweaking the categories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整分类
- en: Utilizing `ScrollView`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `ScrollView`
- en: Adding `BusyIndicator`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `BusyIndicator`
- en: Making a frameless window
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作无边框窗口
- en: Debugging QML
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QML 调试
- en: Understanding model and view
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模型和视图
- en: As mentioned before, Qt Quick applications are different from traditional Qt
    Widgets applications. You are going to write QML instead of C++ code. So, let's
    create a new project, a Qt Quick application named `RSS_Reader`. This time, we
    will use Qt Quick 2.3 as the component set. Since we won't use the widgets provided
    by Qt Quick Controls, we'll write our own widgets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Qt Quick 应用程序与传统 Qt Widgets 应用程序不同。您将编写 QML 而不是 C++ 代码。因此，让我们创建一个新的项目，一个名为
    `RSS_Reader` 的 Qt Quick 应用程序。这次，我们将使用 Qt Quick 2.3 作为组件集。由于我们不会使用 Qt Quick Controls
    提供的小部件，我们将编写自己的小部件。
- en: Before getting our hands dirty, let's sketch out what this application looks
    like. According to the following diagram, there will be two sections. The left-hand
    panel provides some categories so that users can choose interesting categories.
    The right-hand panel is the main area, which displays news under the current category.
    This is a typical RSS news reader's user interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手之前，让我们勾勒出这个应用程序的外观。根据以下图表，将有两个部分。左侧面板提供一些分类，以便用户可以选择有趣的分类。右侧面板是主要区域，显示当前分类下的新闻。这是一个典型的
    RSS 新闻阅读器的用户界面。
- en: '![Understanding model and view](img/4615OS_03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![理解模型和视图](img/4615OS_03_01.jpg)'
- en: 'We can implement the **Categories** panel by using `ListView`. This type (we
    say "type" instead of "class" in QML) is used to display data from all sorts of
    list models. So let''s edit our `main.qml` to something similar to this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `ListView` 来实现 **分类** 面板。这种类型（我们在 QML 中说 "类型" 而不是 "类"）用于显示来自各种列表模型的数据。所以让我们编辑我们的
    `main.qml`，使其类似于以下内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ListView` needs a model to get data from. In this case, we can utilize `ListModel`
    for its simplicity. To achieve this, let''s create a new `Feeds.qml` file, which
    will contain a custom `ListModel` example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 需要一个模型来获取数据。在这种情况下，我们可以利用 `ListModel` 的简单性。为了实现这一点，让我们创建一个新的 `Feeds.qml`
    文件，它将包含一个自定义的 `ListModel` 示例：'
- en: Right-click on the project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目。
- en: Select **Add New…**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **添加新…**。
- en: Navigate to **Qt** | **QML File (Qt Quick 2)**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **Qt** | **QML 文件（Qt Quick 2）**。
- en: Enter the `Feeds.qml` filename.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `Feeds.qml` 文件名。
- en: 'Here is the content of `Feeds.qml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Feeds.qml` 的内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use BBC News RSS as feeds, but you may wish to change it to another.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 BBC News RSS 作为源，但您可能希望将其更改为另一个。
- en: As you can see, the preceding `ListModel` example has two roles, `name` and
    `url`. A "role" is basically a fancy way of saying the child item. These can be
    bound to by the `ListView` delegate that we are about to create. In this way,
    roles usually represent the properties of an entity or columns of a table.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的 `ListModel` 示例有两个角色，`name` 和 `url`。一个 "角色"基本上是孩子项的另一种说法。这些可以通过我们即将创建的
    `ListView` 代理来绑定。以这种方式，角色通常代表实体的属性或表格的列。
- en: 'Let me explain the relation between view, model, and delegate, which is another
    important yet difficult concept in the world of Qt. This is officially called
    **model-view** architecture. In addition to the traditional view, Qt decouples
    the view and controller so that the data can be rendered and edited in many customized
    ways. The latter is much more elegant and efficient. The following diagram helps
    you understand this concept:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下视图、模型和代理之间的关系，这是 Qt 世界中另一个重要但难以理解的概念。这官方上被称为 **模型-视图** 架构。除了传统的视图之外，Qt
    将视图和控制器解耦，以便数据可以以许多定制的方式进行渲染和编辑。后者更加优雅和高效。以下图表有助于您理解这个概念：
- en: '![Understanding model and view](img/4615OS_03_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![理解模型和视图](img/4615OS_03_02.jpg)'
- en: Take `ListModel`, which is a model used to arrange data, as an example to elaborate
    the relationship. `CategoriesDelegate`, shown in the following code, is a delegate
    and is used to control how to display the roles from the model. Lastly, we use
    a view, which is `ListView` in this case, to render the delegate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以用于排列数据的模型`ListModel`为例来阐述它们之间的关系。以下代码中显示的`CategoriesDelegate`是一个代理，用于控制如何从模型中显示角色。最后，我们使用一个视图，在这个例子中是`ListView`，来渲染代理。
- en: 'The communication between the models, views, and delegates are based on the
    signals and slots mechanism. It''ll take you some time to fully understand this
    concept. Hopefully, we can shorten this time by practicing this example. At this
    stage, we already have a view and a model. We have to define a delegate, which
    is `CategoriesDelegate` as mentioned before, to control the data from the model
    and render it on the view. Add a new `CategoriesDelegate.qml` file, whose content
    is pasted in this way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、视图和代理之间的通信基于信号和槽机制。这需要您花费一些时间才能完全理解这个概念。希望我们可以通过练习这个例子来缩短这个时间。在这个阶段，我们已经有了一个视图和一个模型。我们必须定义一个代理，正如之前提到的`CategoriesDelegate`，来控制模型中的数据并将其渲染在视图上。添加一个新的`CategoriesDelegate.qml`文件，其内容如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should have some idea about the relation between the model, delegate, and
    view. Here, we use `Rectangle` as the delegate type. Inside the `Rectangle` type
    is a `Text` object that displays the `name` from our `ListModel` example. As for
    the `font` property, here we use `pointSize` to specify the size of text, while
    you can use `pixelSize` as an alternative.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对模型、代理和视图之间的关系有所了解。在这里，我们使用`Rectangle`作为代理类型。在`Rectangle`类型内部是一个`Text`对象，用于显示来自我们的`ListModel`示例中的`name`。至于`font`属性，在这里我们使用`pointSize`来指定文本的大小，而您也可以使用`pixelSize`作为替代。
- en: 'To finish the model-view architecture, go back to the `main.qml` edit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成模型-视图架构，请回到`main.qml`编辑：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Take note of the third line; it's crucial to import this directory into `qrc`.
    We use `"qrc:/"` because we need to put the QML files in the root directory. Modify
    it if you use a subdirectory to keep `Feeds.qml` and `CategoriesDelegate.qml`.
    In this example, these files are left unorganized. But it's highly recommended
    to keep them categorized as a different module. If you didn't import the directory,
    you won't be able to use these QML files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第三行；将其导入`qrc`是至关重要的。我们使用`"qrc:/"`是因为我们需要将QML文件放在根目录下。如果您使用子目录来保持`Feeds.qml`和`CategoriesDelegate.qml`，请修改它。在这个例子中，这些文件是未组织的。但强烈建议将它们分类为不同的模块。如果您没有导入目录，您将无法使用这些QML文件。
- en: Inside the `Window` item, we create `Feeds`, which is exactly an element of
    `ListModel` from `Feeds.qml`. Then, we give this `Feeds` item a `categoriesModel`
    ID and use it as the model of `ListView`. Specifying the delegate is quite similar
    to specifying the model for views. Instead of declaring it outside `ListView`,
    we have to define it inside the `delegate` scope, otherwise the `delegate` item,
    `CategoriesDelegate`, won't be able to get data from the model. As you can see,
    we can manipulate the `width` of `categoriesDelegate`. This is to ensure that
    the text won't lie outside the boundary of `ListView`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Window`项中，我们创建`Feeds`，它是来自`Feeds.qml`的`ListModel`的一个元素。然后，我们给这个`Feeds`项一个`categoriesModel`
    ID，并使用它作为`ListView`的模型。指定代理的方式与指定视图的模型类似。我们不是在`ListView`外部声明它，而必须在`delegate`作用域内定义它，否则代理项`CategoriesDelegate`将无法从模型中获取数据。如您所见，我们可以操作`categoriesDelegate`的`width`。这是为了确保文本不会超出`ListView`的边界。
- en: 'If everything is done correctly, click on **Run** and you''ll see it run like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切设置正确，点击**运行**，您将看到它这样运行：
- en: '![Understanding model and view](img/4615OS_03_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![理解模型和视图](img/4615OS_03_03.jpg)'
- en: Parsing RSS Feeds by XmlListModel
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XmlListModel解析RSS源
- en: It's true that we now have categories, but they don't seem to be involved with
    RSS at all. Also, if you dig deeper, you'll find that the RSS feeds are in fact
    the XML documents. Qt already provides a useful type to help us parse them. We
    don't need to reinvent the wheel. This powerful type is the so-called `XmlListModel`
    element and it uses `XmlRole` to query.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，我们现在有了分类，但它们似乎与RSS没有任何关系。此外，如果您进一步挖掘，您会发现RSS源实际上是XML文档。Qt已经提供了一个有用的类型来帮助我们解析它们。我们不需要重新发明轮子。这个强大的类型就是所谓的`XmlListModel`元素，它使用`XmlRole`进行查询。
- en: 'Firstly, we need to expose the `url` role of `categoriesModel` to the main
    scope. This is done by declaring the property storing the model''s current element,
    `url`, inside `ListView`. Then, we can add an `XmlListModel` element and use that
    `url` element as its `source`. Accordingly, the modified `main.qml` file is pasted
    here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`categoriesModel`的`url`角色暴露给主作用域。这是通过在`ListView`内部声明存储模型当前元素`url`的属性来完成的，即`url`。然后，我们可以添加一个`XmlListModel`元素，并使用该`url`元素作为其`source`。相应地，修改后的`main.qml`文件如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Objects' values are changed dynamically and updated implicitly in Qt Quick.
    You don't need to give new values explicitly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt Quick中，对象的值会动态改变并隐式更新。你不需要显式地给出新值。
- en: 'In order to use this element, you will need to import the module by adding
    an `import QtQuick.XmlListModel 2.0` line. Additionally, `XmlListModel` is a read-only
    model which means that you can''t modify the data source through this model. This
    is completely acceptable since what we need is to retrieve the news data from
    the RSS feeds. Take `Top Stories` as an example; the following code is a part
    of this XML document content:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用此元素，你需要通过添加`import QtQuick.XmlListModel 2.0`行来导入模块。此外，`XmlListModel`是一个只读模型，这意味着你不能通过此模型修改数据源。这是完全可以接受的，因为我们需要从RSS源检索新闻数据。以“头条新闻”为例；以下代码是该XML文档内容的一部分：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `namespaceDeclarations` property needs to be set because the XML document
    has the XML namespaces.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要设置`namespaceDeclarations`属性，因为XML文档有XML命名空间。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `xmlns` stands for the XML namespace, so we declare the namespace accordingly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`xmlns`代表XML命名空间，因此我们相应地声明了命名空间。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In fact, you can just declare a `media` namespace and safely ignore an `atom`
    namespace. However, if you didn't declare the `media` namespace, the application
    would end up failing to parse the XML document. Hence, go back to see the XML
    document and you'll find it has a hierarchy to order data. What we want here are
    these items. Take the top-level as root, `/`, so the path of `item` can be written
    as `/rss/channel/item`. This is exactly what we put in `query`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你只需声明一个`media`命名空间并安全地忽略一个`atom`命名空间。然而，如果你没有声明`media`命名空间，应用程序最终会失败解析XML文档。因此，回到XML文档，你会发现它有一个数据排序的层次结构。我们这里需要的是这些项。以顶级作为根`/`，因此`item`的路径可以写成`/rss/channel/item`。这正是我们放入`query`中的内容。
- en: All the `XmlRole` elements are created using `query` as the base. For `XmlRole`,
    `name` defines its name, which doesn't need to be the same as in the XML document.
    It's similar to `id` for the regular Qt Quick items. However, the query of `XmlRole`
    must use a relative path to the query of `XmlListModel`. Although it's a `string()`
    type in most cases, it still must be declared explicitly. If there are elements
    sharing the same keys, it'd be an array where the element listed first has the
    first index.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`XmlRole`元素都是使用`query`作为基础创建的。对于`XmlRole`，`name`定义了它的名称，它不需要与XML文档中的名称相同。它类似于常规Qt
    Quick项的`id`。然而，`XmlRole`的查询必须使用相对于`XmlListModel`查询的相对路径。尽管在大多数情况下它是`string()`类型，但它仍然必须显式声明。如果有共享相同键的元素，它将是一个数组，其中列出的第一个元素具有第一个索引。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first index in XPath is `1` instead of `0`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: XPath的第一个索引是`1`而不是`0`。
- en: Sometimes, we need to get an attribute `thumbnail`. This is the `url` attribute
    of the `media:thumbnail` tag. In this case, it's the `@` symbol that will do all
    the magic we need.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要获取一个属性`thumbnail`。这是`media:thumbnail`标签的`url`属性。在这种情况下，是`@`符号将完成我们需要的所有魔法。
- en: 'Similar to these categories, we have to write a delegate for the `XmlListModel`
    element to render the view. The new QML `NewsDelegate.qml` file is shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些类别类似，我们必须为`XmlListModel`元素编写一个委托以渲染视图。新的QML `NewsDelegate.qml`文件如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The difference is that this time we use `Column` to organize the news data
    and represent it in an intuitive way. The relevant diagram is sketched as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于这次我们使用`Column`来组织新闻数据并以直观的方式表示。相关的图示如下：
- en: '![Parsing RSS Feeds by XmlListModel](img/4615OS_03_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![通过XmlListModel解析RSS源](img/4615OS_03_04.jpg)'
- en: So, this is why we use `Row` inside `Column` to box **Thumbnail** and **Title**
    together. Thus, we need to put an empty `item` element in front to separate each
    news delegate. Apart from these self-explanatory lines, there is a tip for dealing
    with links. You need to specify the slot for the `onLinkActivated` signal, which
    is `Qt.openUrlExternally(link)` in this case. Otherwise, nothing will happen when
    you click on the link.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是我们为什么在 `Column` 中使用 `Row` 来将 **缩略图** 和 **标题** 一起装箱的原因。因此，我们需要在前面放置一个空的
    `item` 元素来分隔每个新闻代理。除了这些不言自明的行之外，还有一个处理链接的技巧。您需要指定 `onLinkActivated` 信号的槽，在这种情况下是
    `Qt.openUrlExternally(link)`。否则，点击链接时将不会发生任何操作。
- en: 'After all this, it''s time to write a view in `main.qml` to display our news:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，是时候在 `main.qml` 中编写一个视图来显示我们的新闻了：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remember to define the `width` of `NewsDelegate` in case it displays abnormally.
    Click on **Run**; the application will look like the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记得定义 `NewsDelegate` 的 `width`，以防它显示异常。点击 **运行**；应用程序将看起来像以下截图：
- en: '![Parsing RSS Feeds by XmlListModel](img/4615OS_03_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![通过 XmlListModel 解析 RSS 源](img/4615OS_03_05.jpg)'
- en: Tweaking the categories
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整类别
- en: This application is still incomplete. For example, the news view won't change
    at all after you click on the other categories. In this stage, we're going to
    work this out and make it more beautiful.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序仍然不完整。例如，点击其他类别后，新闻视图将完全不会改变。在这个阶段，我们将解决这个问题并使其更加美观。
- en: 'What we need to do is add `MouseArea` to `CategoriesDelegate`. This element
    is used to deal with a variety of mouse interactions, including clicking. The
    new `CategoriesDelegate.qml` file''s code is pasted here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是向 `CategoriesDelegate` 添加 `MouseArea`。此元素用于处理各种鼠标交互，包括点击。新的 `CategoriesDelegate.qml`
    文件的代码如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, once a delegate gets clicked on, it'll change `categories.currentIndex`
    and `currentUrl` if necessary, or simply let `newsModel` reload. As mentioned
    before, QML is a dynamic language, which changes `categories.currentUrl`, the
    `source` property of `newsModel`, and would automatically cause `newsModel` to
    reload.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦点击了代理，如果需要，它将更改 `categories.currentIndex` 和 `currentUrl`，或者简单地让 `newsModel`
    重新加载。如前所述，QML 是一种动态语言，它更改 `categories.currentUrl`，`newsModel` 的 `source` 属性，这会自动导致
    `newsModel` 重新加载。
- en: 'To help users distinguish a currently-selected category from others, we may
    wish to change its size and scale. There are some attached properties, which are
    attached to each instance of a delegate or are simply shared among them. The `.isCurrentItem`
    property is the one that would so us a favor. It''s a Boolean value that holds
    whether this delegate is the current item or not. However, only the root item
    of a delegate can access these attached properties directly. In order to code
    in a clean way, we add a line to `Rectangle` of `CategoriesDelegate` to hold this
    property:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户区分当前选中的类别和其他类别，我们可能希望改变其大小和缩放。有一些附加属性，它们附加到每个代理实例上，或者简单地被它们共享。`.isCurrentItem`
    属性是会帮我们大忙的一个属性。它是一个布尔值，表示此代理是否是当前项。然而，只有代理的根项可以直接访问这些附加属性。为了以干净的方式编写代码，我们在 `CategoriesDelegate`
    的 `Rectangle` 中添加了一行来持有这个属性：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can utilize `selected` in `Text` by adding the following lines to the
    `Text` item:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在 `Text` 项中添加以下行来利用 `selected`：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Text` will be scaled to `0.8` if it''s not selected and will behave as usual
    when it''s active. A similar condition is in place for its color. The `#AAA` color
    code is an extremely light gray color, which makes the active black text stand
    out more. However, there is no animation for these changes. While we want these
    transitions to be more natural, Qt Quick provides **Behavior with State** to make
    these transitions happen. By adding these lines to the `Text` item, we get the
    following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 将在未选中时缩放至 `0.8`，并在激活时保持正常行为。对于其颜色也有类似条件。`#AAA` 颜色代码是一种非常浅的灰色，这使得激活时的黑色文本更加突出。然而，这些变化没有动画效果。虽然我们希望这些过渡更加自然，Qt
    Quick 提供了 **带有状态的 Behavior** 来实现这些过渡。通过将这些行添加到 `Text` 项目中，我们得到以下代码：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Animations are expected to present when you change the current delegate, which
    results in changes in the color and scale. If you''re not sure whether you''ve
    performed the correct modification, the following code shows you the newly modified
    `CategoriesDelegate.qml` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 预期在更改当前代理时会出现动画，这会导致颜色和缩放的变化。如果您不确定是否已执行正确的修改，以下代码显示了新修改的 `CategoriesDelegate.qml`
    文件：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is room to improve the categories, including the background image which
    is simply an `Image` element, and could form part of your exercises. However,
    it won't be covered in this chapter. Here, what we do next is to change the displaying
    fonts on the Windows platform. We're going to change the font to `Times New Roman`
    by adding a few lines in `main.cpp` (not `main.qml`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有改进分类的空间，包括背景图像，它只是一个简单的`Image`元素，可以成为你的练习的一部分。然而，这部分内容不会在本章中涉及。接下来，我们将更改Windows平台上的显示字体。我们将在`main.cpp`（而不是`main.qml`）中添加几行代码来将字体更改为`Times
    New Roman`。
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we use a predefined macro to limit this change for the Windows platforms.
    By setting the font of `app` whose type is `QGuiApplication`, all the children
    widgets, including `engine`, are subjected to this change. Now run the application
    again; you should expect a new RSS reader with this newspaper-like font:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个预定义的宏来限制这种更改仅适用于Windows平台。通过设置类型为`QGuiApplication`的`app`的字体，所有子小部件，包括`engine`，都将受到这种更改的影响。现在再次运行应用程序；你应该期望看到一个带有这种报纸式字体的新的RSS阅读器：
- en: '![Tweaking the categories](img/4615OS_03_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![调整分类](img/4615OS_03_06.jpg)'
- en: Utilizing ScrollView
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用ScrollView
- en: Our RSS news reader is shaping up now. From now on, let's focus on the unpleasant
    details. The first thing we're going to add is a scroll bar. To be more specific,
    `ScrollView` is about to be added.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在构建RSS新闻阅读器。从现在开始，让我们关注那些不愉快的细节。我们首先要添加的是滚动条。更具体地说，`ScrollView`即将被添加。
- en: Back in the Qt 4 era, you had to write your own `ScrollView` component to gain
    this small yet very nice feature. Although you can utilize KDE Plasma Components'
    `ScrollArea` on X11 Platforms, there are no Qt bundled modules for this purpose,
    which means you can't use these on Windows and Mac OS X. Thanks to the open governance
    of the Qt project, a lot of community code gets merged, especially from the KDE
    community. From Qt 5.1 onwards, we have the `QtQuick.Controls` module, which has
    many built-in desktop components, including `ScrollView`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Qt 4时代，你必须编写自己的`ScrollView`组件来获得这个虽小但非常不错的功能。尽管你可以在X11平台上使用KDE Plasma Components的`ScrollArea`，但Qt没有捆绑的模块用于此目的，这意味着你无法在Windows和Mac
    OS X上使用这些模块。感谢Qt项目的开放治理，许多社区代码被合并，特别是来自KDE社区。从Qt 5.1开始，我们有了`QtQuick.Controls`模块，它包含许多内置的桌面组件，包括`ScrollView`。
- en: It's a very easy to use element that provides scroll bars and content frames
    for its child item. There can be only one direct `Item` child, and this child
    is implicitly anchored to fill the `ScrollView` component. This means that we
    only need to anchor the `ScrollView` component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常易于使用的元素，它为子项提供了滚动条和内容框架。只能有一个直接的`Item`子项，并且这个子项会隐式地锚定以填充`ScrollView`组件。这意味着我们只需要锚定`ScrollView`组件。
- en: 'There are two ways to specify the child item. The first one is to declare the
    child item inside the `ScrollView` component''s scope, and the item which is inside
    will implicitly become the child of the `ScrollView` component. Another way is
    to set the `contentItem` property, which is an explicit method. In this chapter''s
    example, both ways are demonstrated for you. The content of `main.qml` is shown
    here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 指定子项有两种方式。第一种是在`ScrollView`组件的作用域内声明子项，那么内部的项将隐式地成为`ScrollView`组件的子项。另一种方式是设置`contentItem`属性，这是一个显式的方法。在本章的示例中，这两种方式都为你演示了。以下是`main.qml`的内容：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the child item is automatically filled with `anchors`, some lines inside
    `ListView` are deleted. Most of them are just moved to `ScrollView` though. You
    can see that we use the explicit way for `categories` and the implicit way for
    `newsList`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子项会自动填充`anchors`，`ListView`内部的一些行被删除了。尽管如此，大多数行只是被移动到了`ScrollView`中。你可以看到我们为`categories`使用了显式方式，而为`newsList`使用了隐式方式。
- en: 'Looking into `ScrollView`, we defined a custom `style` element by forcing `transientScrollBars`
    to `true`. It''s noted that the default value of `transientScrollBars` is platform
    dependent. The transient scroll bars only appear when the content is scrolled
    and then disappear when they are no longer needed. Anyway, it''s `false` by default
    on Windows, so we turn it on explicitly, resulting in a better visual style shown
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`ScrollView`，我们通过将`transientScrollBars`设置为`true`来定义了一个自定义的`style`元素。需要注意的是，`transientScrollBars`的默认值是平台相关的。瞬态滚动条仅在内容被滚动时出现，并在不再需要时消失。无论如何，默认情况下在Windows上是`false`，所以我们显式地将其打开，从而得到以下更好的视觉样式：
- en: '![Utilizing ScrollView](img/4615OS_03_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![利用ScrollView](img/4615OS_03_07.jpg)'
- en: Adding BusyIndicator
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加BusyIndicator
- en: The absence of a busy indicator makes people uncomfortable as well. No matter
    how short or long indicator it is, it takes time to download data and parse XML.
    I'm pretty sure you'd like to add such an indicator, which tells users to calm
    down and wait. Luckily, `BusyIndicator`, which is simply a running circle, is
    an element of `QtQuick.Controls`. This does exactly what we want.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少忙碌指示器也会让人感到不舒服。无论指示器有多短或多长，下载数据和解析XML都需要时间。我非常确信您会想添加这样的指示器，告诉用户保持冷静并等待。幸运的是，`BusyIndicator`，它只是一个运行中的圆圈，是`QtQuick.Controls`的一个元素。这正好是我们想要的。
- en: 'What you need to do is to add these lines to `main.qml` inside the `Window`
    item:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的是将这些行添加到`main.qml`文件中的`Window`元素内部：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we don't need to change the `visible` property of `BusyIndicator`,
    because `BusyIndicator` is only visible when the `running` property is set to
    `true`. In this case, we set `running` to `true` when the `newsModel` status is
    `Loading`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要更改`BusyIndicator`的`visible`属性，因为`BusyIndicator`仅在`running`属性设置为`true`时可见。在这种情况下，当`newsModel`状态为`Loading`时，我们将`running`设置为`true`。
- en: Making a frameless window
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作无边框窗口
- en: 'Similar to what we did in the previous chapter, here we don''t want the borders
    of the system window to decorate our Qt Quick application. This is partly because
    it looks like a web application, which makes it seems odd with native window decorations.
    This job is even easier in QML than in C++. We can add the following line to `Window`
    in `main.qml`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中所做的一样，我们在这里不希望系统窗口的边框装饰我们的Qt Quick应用程序。这主要是因为它看起来像是一个Web应用程序，这使得它带有原生的窗口装饰看起来很奇怪。在QML中完成这项工作比在C++中更容易。我们可以在`main.qml`中的`Window`元素中添加以下行：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although our RSS reader runs in a frameless style, there is no way to move it
    and it's difficult to close it, just like the situation in the previous chapter.
    Since our mouse has many duties for the categories and news `ListView` along with
    `ScrollView`, we can't simply use a new `MouseArea` element to fill the `Window`
    root. Therefore, what we're going to do is to draw our own title bar and, of course,
    the exit button.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的RSS阅读器以无边框风格运行，但无法移动它，关闭它也很困难，就像上一章中的情况一样。由于我们的鼠标在类别和新闻`ListView`以及`ScrollView`上有很多任务，我们无法简单地使用一个新的`MouseArea`元素来填充`Window`根。因此，我们将绘制自己的标题栏，当然还有退出按钮。
- en: To add the exit button image to the `qrc` file, right-click on `qml.qrc`, select
    **Open in Editor**, navigate to **Add** | **Add Files**, and then select `close.png`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要将退出按钮图片添加到`qrc`文件中，右键点击`qml.qrc`，选择**在编辑器中打开**，导航到**添加** | **添加文件**，然后选择`close.png`。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It'd be better to use different resource files (`qrc`) for different types of
    files, which make it more organized. We'll talk more about resource files in [Chapter
    8](ch08.xhtml "Chapter 8. Enabling Your Qt Application to Support Other Languages"),
    *Enabling Your Qt Application to Support Other Languages*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的资源文件（`qrc`）为不同类型的文件会更好，这会使它更有组织。我们将在第8章中更多关于资源文件的内容，*启用您的Qt应用程序支持其他语言*。
- en: 'Now, add a new QML `TitleBar.qml` file whose content is pasted here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个新的QML `TitleBar.qml`文件，其内容如下：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we use a `QPoint` object, `mPos`, to store the position when the mouse
    button is clicked.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个`QPoint`对象，`mPos`，来存储鼠标按钮被点击时的位置。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we may have declared it as `var` or `variant` in the past, for maximum
    performance you should avoid the use of `var`. Also note that `variant` is deprecated
    now, so it shouldn't be used under any circumstances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们过去可能将其声明为`var`或`variant`，但为了获得最佳性能，您应避免使用`var`。此外，请注意，`variant`现在已弃用，因此在任何情况下都不应使用。
- en: The `MouseArea` element, which is used for moving, is located inside the `Rectangle`
    element. There are lots of predefined signals and slots for `MouseArea`. Note
    that we use the `onPressed` slot instead of `onClicked` here to get the mouse
    position. This is because the `clicked` signal is only emitted when the mouse
    button is pressed and then released, which makes it unsuitable for moving the
    window.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 用于移动的`MouseArea`元素位于`Rectangle`元素内部。`MouseArea`有很多预定义的信号和槽。请注意，我们在这里使用`onPressed`槽而不是`onClicked`来获取鼠标位置。这是因为`clicked`信号仅在鼠标按钮按下然后释放时发出，这使得它不适合移动窗口。
- en: The `positionChanged` signal is emitted when the mouse button is pressed and
    then moved. In addition to this, there is a property called `hoverEnabled`, which
    is `false` by default. If you set it to `true`, all the mouse events will be handled
    even when no mouse button is clicked. In other words, the `positionChanged` signal
    will be emitted when the mouse is moving, regardless of whether it's clicked or
    not. Therefore, we don't set `hoverEnabled` to `true` in this example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标按钮被按下然后移动时，会发出 `positionChanged` 信号。除此之外，还有一个名为 `hoverEnabled` 的属性，默认值为 `false`。如果您将其设置为
    `true`，则即使没有鼠标按钮被点击，也会处理所有鼠标事件。换句话说，当鼠标移动时，无论是否点击，都会发出 `positionChanged` 信号。因此，在这个例子中，我们不将
    `hoverEnabled` 设置为 `true`。
- en: Now let's go back and check the `Image` item. The `fillMode` element determines
    how an image should be adjusted. By default, it'll be stretched despite the ratio.
    Here, we set it to preserve the ratio while we fit the `Image`. The `source` property
    holds the image file path. In this case, it's the `close.png` file that is in
    the `Resources` file, `qml.qrc`. Here we go; this is another `MouseArea`, which
    simply makes `Image` into a closed button.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 `Image` 元素并检查它。`fillMode` 元素决定了图像应该如何调整。默认情况下，它会被拉伸，尽管有比例。在这里，我们将其设置为在调整
    `Image` 时保持比例。`source` 属性持有图像文件路径。在这种情况下，它是位于 `Resources` 文件中的 `qml.qrc` 的 `close.png`
    文件。这里我们走；这是一个简单的 `MouseArea`，它将 `Image` 变成关闭按钮。
- en: 'At last, it''s time to add `TitleBar` to `main.qml` as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候将 `TitleBar` 添加到 `main.qml` 中了，如下所示：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We also use a `Text` element, `windowTitle`, to display the window title in
    `titleBar`. Since we retrieve data from BBC News, it's not a bad idea to call
    it `BBC News Reader` or just name it whatever you like.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个 `Text` 元素，`windowTitle`，在 `titleBar` 中显示窗口标题。由于我们从 BBC News 获取数据，将其称为
    `BBC News Reader` 或随意命名都是不错的选择。
- en: Apart from the addition of the title bar, some code needs to be modified to
    spare room for it. Both the `ScrollView` component's anchored `top` should be
    changed to `titleBar.bottom` instead of `parent.top`, otherwise the title bar
    will be placed partially on top of these two scroll views.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加标题栏外，还需要修改一些代码以留出空间。`ScrollView` 组件的锚定 `top` 应该改为 `titleBar.bottom` 而不是
    `parent.top`，否则标题栏将部分位于这两个滚动视图的顶部。
- en: Give the application a run; it should deliver a new visual style. Although it
    looks more like a web application, the whole interface is clean and integrated.
    Another benefit of this change is a unified UI across all platforms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序；它应该提供一种新的视觉风格。尽管它看起来更像是一个网络应用程序，但整个界面整洁且集成。这种改变的另一个好处是在所有平台上实现统一的 UI。
- en: '![Making a frameless window](img/4615OS_03_08.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![创建无框窗口](img/4615OS_03_08.jpg)'
- en: Debugging QML
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 QML
- en: 'The most common practice to debug QML is the use of the API console. JavaScript
    developers should be familiar with this because of the console support in QML.
    The relationships between the `console` functions and the Qt/C++ `QDebug` functions
    are given as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 QML 最常见的做法是使用 API 控制台。JavaScript 开发者应该熟悉这一点，因为 QML 中有控制台支持。`console` 函数与
    Qt/C++ `QDebug` 函数之间的关系如下：
- en: '| QML | Qt/C++ |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| QML | Qt/C++ |'
- en: '| --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `console.log()` | `qDebug()` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `console.log()` | `qDebug()` |'
- en: '| `console.debug()` | `qDebug()` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `console.debug()` | `qDebug()` |'
- en: '| `console.info()` | `qDebug()` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `console.info()` | `qDebug()` |'
- en: '| `console.warn()` | `qWarning()` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `console.warn()` | `qWarning()` |'
- en: '| `console.error()` | `qCritical()` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `console.error()` | `qCritical()` |'
- en: 'With the preceding supports present, QML is just like JavaScript programming.
    At the same time, the following functions are also introduced in QML:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的支持基础上，QML 就像 JavaScript 编程一样。同时，以下函数也被引入到 QML 中：
- en: '| Functions | Description |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `console.assert()` | This function tests whether the expression is true.
    If not, it will write an optional message to the console and print the stack trace.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `console.assert()` | 此函数测试表达式是否为真。如果不是，它将可选地将消息写入控制台并打印堆栈跟踪。|'
- en: '| `console.exception()` | This function prints an error message together with
    the stack trace of the JavaScript execution at the point it is called. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `console.exception()` | 此函数在调用点打印错误消息以及 JavaScript 执行的堆栈跟踪。|'
- en: '| `console.trace()` | This function prints the stack trace of the JavaScript
    execution at the point it is called. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `console.trace()` | 此函数在调用点打印 JavaScript 执行的堆栈跟踪。|'
- en: '| `console.count()` | This function prints the current number of times a particular
    piece of code has been executed, along with a message. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `console.count()` | 此函数打印特定代码块当前执行的次数，并附带一条消息。|'
- en: '| `console.time()``console.timeEnd()` | This pair of functions will print the
    time that a particular piece of code between them takes in milliseconds. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `console.time()``console.timeEnd()` | 这对函数将打印它们之间特定代码块所花费的时间（以毫秒为单位）。|'
- en: '| `console.profile()``console.profileEnd()` | This pair of functions profiles
    both the state of `QDeclarativeEngine` as well as the V8 call methods. However,
    you need to attach the QML Profiler tool to the application before `console.profileEnd()`
    is called. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `console.profile()``console.profileEnd()` | 这对函数可以分析`QDeclarativeEngine`的状态以及V8调用方法。然而，在调用`console.profileEnd()`之前，您需要将QML分析器工具附加到应用程序上。|'
- en: 'In addition to the preceding useful functions, the common **Debug** mode in
    Qt Creator is available for QML as well. The operations are almost identical to
    C++ debugging. You can set the breakpoints, observe values, and so on. However,
    there is one more thing provided for QML. It''s the **QML/JS Console**! Qt Creator
    doesn''t show the **QML/JS Console** by default, you have to turn it on manually.
    Just click on the small button (the red circle in the following screenshot), and
    then tick **QML/JS Console**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的有用功能外，Qt Creator中的常见**调试**模式也适用于QML。操作几乎与C++调试相同。您可以设置断点、观察值等。然而，QML还提供了一项额外功能。那就是**QML/JS控制台**！Qt
    Creator默认不显示**QML/JS控制台**，您需要手动开启。只需点击以下截图中的小按钮（红色圆圈），然后勾选**QML/JS控制台**：
- en: '![Debugging QML](img/4615OS_03_09.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![调试QML](img/4615OS_03_09.jpg)'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When the application is interrupted by a breakpoint, you can use the **QML/JS
    Console** to execute the JavaScript expressions in the current context. You can
    change the property values temporarily, without editing the source, and view the
    results in the running application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序被断点中断时，您可以使用**QML/JS控制台**执行当前上下文中的JavaScript表达式。您可以在不编辑源代码的情况下临时更改属性值，并在运行的应用程序中查看结果。
- en: The **QML/JS Console** tab shows the debug output, both the Qt debug messages
    and JavaScript console messages, in an appealing way. It provides a button group
    to help you filter information, warnings, and errors. Therefore, just use this
    **QML/JS Console** tab to replace **Application Output** when you debug Qt Quick
    applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**QML/JS控制台**标签以吸引人的方式显示调试输出，包括Qt调试信息和JavaScript控制台消息。它提供了一个按钮组，帮助您过滤信息、警告和错误。因此，当您调试Qt
    Quick应用程序时，只需使用这个**QML/JS控制台**标签来替换**应用程序输出**。'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through a thorough introduction to Qt Quick. We also
    covered model-view programming, which is a vital concept in both Qt/C++ and Qt
    Quick/QML. You may also find that QML is in some way an extensible version of
    JavaScript. This is an additional bonus for JavaScript developers. However, it's
    not difficult to start if you've never written a script before. Once you start,
    you'll get to explore the fascinating qualities of Qt Quick. We're going to show
    you how to access camera devices using Qt in the next chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了Qt Quick。我们还涵盖了模型-视图编程，这是Qt/C++和Qt Quick/QML中的关键概念。您可能还会发现，QML在某种程度上是JavaScript的可扩展版本。这对于JavaScript开发者来说是一个额外的优势。然而，如果您之前从未编写过脚本，开始并不困难。一旦开始，您将能够探索Qt
    Quick的迷人特性。我们将在下一章向您展示如何使用Qt访问相机设备。
