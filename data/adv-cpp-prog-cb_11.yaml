- en: Common Patterns in C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的常见模式
- en: In this chapter, you will learn various design patterns in C++. Design patterns
    provide a common approach to solving different types of problems properly, and
    oftentimes, design patterns are discussed throughout the internet, at conferences,
    and in front of the water cooler at work regarding their advantages and disadvantages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习C++中的各种设计模式。设计模式提供了解决不同类型问题的常见方法，通常在互联网上、会议上以及在工作中的水机前讨论设计模式的优缺点。
- en: The goal of this chapter is to introduce you to some of the more popular, less
    popular, and even controversial patterns, giving you an idea of the different
    types of problems that design patterns attempt to solve. This is an important
    chapter as it will give you the skills to tackle hard problems by teaching you
    already existing approaches to common problems others have experienced in the
    past. Learning even a subset of these design patterns will lay the foundation
    for discovering other design patterns on your own as you run into problems in
    your own applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您介绍一些更受欢迎、不太受欢迎甚至有争议的模式，让您了解设计模式试图解决的不同类型问题。这是一个重要的章节，因为它将教会您如何通过教授已经存在的解决方案来解决自己应用程序中遇到的常见问题。学习这些设计模式中的任何一种都将为您打下基础，使您能够在自己的应用程序中遇到问题时自行发现其他设计模式。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例如下：
- en: Learning the factory pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习工厂模式
- en: Using the singleton pattern properly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用单例模式
- en: Extending your objects with the decorator pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器模式扩展您的对象
- en: Adding communication with the observer pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者模式添加通信
- en: Improving performance with static polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过静态多态性提高性能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有管理访问权限，可以访问具有功能互联网连接的运行Ubuntu 18.04的计算机。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是在Ubuntu 18.04之外的任何操作系统上安装的，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter11)找到。
- en: Learning the factory pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习工厂模式
- en: In this recipe, we will learn what the factory pattern is, how to implement
    it, and when to use it. This recipe is important, especially when unit testing
    as the factory pattern provides the ability to add seams (that is, intentional
    places in your code that provide opportunities for making changes) capable of
    changing what type of object another object allocates, including the ability to
    allocate fake objects for testing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习工厂模式是什么，如何实现它以及何时使用它。这个示例很重要，特别是在单元测试时，因为工厂模式提供了添加接缝（即，代码中提供机会进行更改的有意义的地方）的能力，能够改变另一个对象分配的对象类型，包括分配虚假对象进行测试的能力。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the code for the factory pattern:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试工厂模式的代码：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端中，运行以下命令来下载源代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本章中的每个示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will go through each of these examples and explain what
    each example program does and how it relates to the lessons being taught in this
    recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The factory pattern provides an object that allocates resources with a means
    to change the types that the object allocates. To better understand how this pattern
    works and why it is so useful, let''s look at the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式提供了一个分配资源的对象，可以更改对象分配的类型。为了更好地理解这种模式的工作原理以及它为什么如此有用，让我们看下面的例子：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We start, as shown in the preceding code, with a class called `know_it_all`
    that provides an answer when asked a question. In this particular case, no matter
    what question is asked, it always returns the same answer. The answer is defined
    as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的代码所示，我们从一个名为`know_it_all`的类开始，当被问及问题时，它会提供一个答案。在这种情况下，无论问什么问题，它总是返回相同的答案。答案定义如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown in the preceding, the answer is a simple class that is constructed
    given a string and stores the string internally. It is important to note in this
    case that the user of this API cannot actually extract the string that the answer
    class stores, meaning the use of these APIs is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，答案是一个简单的类，它根据一个字符串构造并在内部存储字符串。在这种情况下，重要的是要注意，这个API的用户实际上无法提取答案类存储的字符串，这意味着使用这些API的方式如下：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the preceding, we can ask a question, and a result is provided,
    but we are not sure of what result was actually provided. This type of problem
    exists all of the time in object-oriented programming, and testing this sort of
    logic is one of the many reasons why entire books have been written on the subject
    of object mocking. A mock is a fake version of an object designed specifically
    to validate the output of a test (unlike a fake, which is nothing more than an
    object that provides test input). In the preceding example, however, a mock still
    needs a way to be created so that the output of a function can be verified. Enter
    the factory pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们可以提问，得到一个结果，但我们不确定实际提供了什么结果。这种问题在面向对象编程中经常存在，测试这种逻辑是为什么整本书都写了。模拟是一个专门设计用来验证测试输出的假对象（不像假对象，它只是提供测试输入的对象）。然而，在上面的例子中，模拟仍然需要一种方式来创建，以便验证函数的输出。这就是工厂模式的作用。
- en: 'Let''s modify the answer class as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`answer`类，如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As shown in the preceding code, we have added a static function that allows
    the `answer` class to create instances of itself. We have not changed the fact
    that the `answer` class doesn''t provide the ability to extract the content it
    holds within, just how the `answer` class is created. We can then modify the `know_it_all`
    class as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的代码中，我们添加了一个静态函数，允许`answer`类创建自己的实例。我们没有改变`answer`类不提供提取其内部内容的能力，只是改变了`answer`类的创建方式。然后我们可以修改`know_it_all`类，如下所示：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As shown in the preceding code, the only difference here is that the `know_it_all`
    class takes a template parameter for `factory_t` and uses it to create the answer
    class instead of creating the `answer` class directly. `factory_t` is defined
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示的代码中，唯一的区别是`know_it_all`类接受`factory_t`的模板参数，并使用它来创建`answer`类，而不是直接创建`answer`类。`factory_t`的定义如下：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This defaults to the static `make_answer()` function that we added to the `answer`
    class. In its most simple form, the preceding example demonstrates the factory
    pattern. Instead of creating an object directly, we delegate the creation of an
    object to another object. The preceding implementation doesn''t change anything
    about how the two classes are used, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这默认使用了我们添加到`answer`类中的静态`make_answer()`函数。在最简单的形式下，上面的例子演示了工厂模式。我们不直接创建对象，而是将对象的创建委托给另一个对象。上述实现并不改变这两个类的使用方式，如下所示：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown in the preceding, the `main()` logic remains unchanged, but this new
    approach ensures that the `know_it_all` class focuses on answering questions without
    worrying about how to create the `answer` class itself, leaving that task to a
    different object. The real power behind this subtle change is we can now provide
    the `know_it_all` class with a different factory, resulting in a different `answer`
    class being returned. To demonstrate this, let''s create a new `answer` class
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，`main()`逻辑保持不变，但这种新方法确保`know_it_all`类专注于回答问题，而不必担心如何创建`answer`类本身，将这个任务留给另一个对象。这个微妙变化背后的真正力量是，我们现在可以为`know_it_all`类提供一个不同的工厂，从而返回一个不同的`answer`类。为了演示这一点，让我们创建一个新的`answer`类，如下所示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As shown in the preceding, we have created a new `answer` class that sub-classes
    the original `answer` class. This new class checks the value it is given during
    construction and outputs success or failure based on the string it is provided.
    We can then use this new `answer` class as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们创建了一个新的`answer`类，它是原始`answer`类的子类。这个新类在构造时检查给定的值，并根据提供的字符串输出成功或失败。然后我们可以使用这个新的`answer`类，如下所示：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is the resulting output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果输出：
- en: '![](img/41a225db-9424-4bd1-aa9f-8be824d88b8d.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41a225db-9424-4bd1-aa9f-8be824d88b8d.png)'
- en: 'Using the preceding approach, we are not able to ask different questions to
    see whether the `know_it_all` class provides the right answers without having
    to modify the original `answer` class. For example, suppose the `know_it_all`
    class was implemented this way:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，我们可以询问不同的问题，以查看`know_it_all`类是否提供了正确的答案，而无需修改原始的`answer`类。例如，假设`know_it_all`类是这样实现的：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We tested this version of the `know_it_all` class, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了这个`know_it_all`类的版本，如下所示：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result would be the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/3626806f-b78e-4c07-81cf-329507c18135.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3626806f-b78e-4c07-81cf-329507c18135.png)'
- en: 'It should be noted that there are several ways to implement the factory pattern.
    The preceding approach uses a template argument to change how the `know_it_all`
    class creates answers, but we could also use a runtime approach as well, as in
    this example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，有几种实现工厂模式的方法。上述方法使用模板参数来改变`know_it_all`类创建答案的方式，但我们也可以使用运行时方法，就像这个例子中一样：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding, we start with a custom `know_it_all` constructor
    that stores a pointer to a factory function, which again, defaults to our `answer`
    class, but provides the ability to change the factory if we choose, which is shown
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，我们首先使用自定义的`know_it_all`构造函数，它存储了一个指向工厂函数的指针，该函数默认为我们的`answer`类，但提供了更改工厂的能力，如下所示：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we wanted, we could also add a setter to this class to change this function
    pointer at runtime.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们还可以为这个类添加一个setter来在运行时更改这个函数指针。
- en: Using the singleton pattern properly
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用单例模式
- en: In this recipe, we will learn how to properly implement the singleton pattern
    in C++11 and above and when it is appropriate to use the singleton pattern. This
    recipe is important as it will teach you when to use the singleton pattern, which
    provides a clear definition of a single global resource, ensuring the resource
    is kept global without the possibility of multiple copies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何在C++11及以上正确实现单例模式，以及何时适合使用单例模式。这个教程很重要，因为它将教会你何时使用单例模式，它提供了对单个全局资源的清晰定义，确保资源保持全局，而不会出现多个副本的可能性。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你的操作系统具有编译和执行本书中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the singleton pattern:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试单例模式：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To compile the source code, run the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，你可以通过运行以下命令来执行本书中的每个示例：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本书所教授的课程的关系。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The singleton pattern has been around in C++ for several years, and it is arguably
    one of the most controversial patterns in all of C++ as its global nature introduces
    coupling in your application (similar to how global variables introduce coupling).
    The singleton pattern implements a single, global resource. Specifically, it creates
    an object that maintains global scope, while ensuring no copies of itself can
    exist. The debate as to whether or not the singleton pattern should be used in
    your code will not be answered in this book as it depends on your use case, but
    let's at least cover some advantages and disadvantages of this pattern.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式在C++中已经存在了好几年，可以说是C++中最具争议的模式之一，因为其全局性质会在应用程序中引入耦合（类似于全局变量引入的耦合）。单例模式实现了一个单一的全局资源。具体来说，它创建了一个维持全局范围的对象，同时确保自身没有副本存在。关于是否应该在代码中使用单例模式的争论将不会在本书中得到解答，因为这取决于你的用例，但至少让我们来讨论一下这种模式的一些优缺点。
- en: '**Advantages: **The singleton pattern provides a clearly defined interface
    for global resources that can only contain a single instance. Whether we like
    it or not, global resources exist in all of our applications (for example, heap
    memory). If such a global resource is needed, and you have a mechanism to handle
    coupling (for example, a mocking engine such as Hippomocks), the singleton pattern
    is a great way to ensure the global resource is managed properly.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**单例模式为只能包含一个实例的全局资源提供了一个明确定义的接口。不管我们喜欢与否，全局资源存在于我们所有的应用程序中（例如，堆内存）。如果需要这样一个全局资源，并且你有一种处理耦合的机制（例如，Hippomocks这样的模拟引擎），单例模式是确保全局资源得到正确管理的好方法。'
- en: '**Disadvantages:** The following are the disadvantages:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**以下是缺点：'
- en: The singleton pattern defines a global resource, and like any global resource
    (for example, a global variable), any code that uses a singleton object becomes
    tightly coupled with the singleton. Coupling, in objected-oriented design, should
    always be avoided as it prevents the ability to fake a resource your code might
    depend on, which limits flexibility when testing.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式定义了一个全局资源，就像任何全局资源（例如，全局变量）一样，使用单例对象的任何代码都会与单例对象紧密耦合。在面向对象设计中，耦合应该始终被避免，因为它会阻止你能够伪造代码可能依赖的资源，这会限制测试时的灵活性。
- en: The singleton pattern hides dependencies. When inspecting an object's interface,
    there is no way to determine that the object's implementation depends on a global
    resource. Most argue that this can be handled with good documentation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式隐藏了依赖关系。当检查一个对象的接口时，无法确定对象的实现是否依赖于全局资源。大多数人认为这可以通过良好的文档来处理。
- en: The singleton pattern maintains its state throughout the lifetime of the application.
    This is especially true (that is, the disadvantage is obvious) when unit testing
    as the singleton's state carries from one unit test to the next, which most consider
    a violation of what a unit test is.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式在应用程序的整个生命周期中保持其状态。这在单元测试时尤其明显（也就是说，缺点是显而易见的），因为单例的状态会从一个单元测试传递到下一个单元测试，这被大多数人认为是对单元测试的违反。
- en: In general, global resources should always be avoided. Period. To ensure that
    your code is properly written to enforce the singleton design pattern, if and
    when you need a single global resource. Let's discuss the following example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，全局资源应该始终被避免。为了确保你的代码被正确编写以实施单例设计模式，如果你需要一个单一的全局资源。让我们讨论以下的例子。
- en: 'Suppose you are writing an application for an embedded device, and your embedded
    device has an additional memory pool that you can map into your application (for
    example, device memory for a video or network device). Now, suppose you can only
    ever have one of these additional memory pools and you need to implement a set
    of APIs to allocate memory from this pool. In our example, we will implement this
    memory pool using the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为一个嵌入式设备编写应用程序，你的嵌入式设备有一个额外的内存池，你可以将其映射到你的应用程序中（例如，用于视频或网络设备的设备内存）。现在，假设你只能有一个这样的额外内存池，并且你需要实现一组API来从这个池中分配内存。在我们的例子中，我们将使用以下方式来实现这个内存池：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will implement a memory manager class to allocate memory from this
    pool, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个内存管理器类，以从这个池中分配内存，如下所示：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As shown in the preceding code, we have created a memory manager class that
    stores a pointer to the memory buffer that contains our single, global resource.
    We then create a simple allocation function that handles this memory out as needed
    (with no ability to free, which keeps the algorithm really simple).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的代码，我们创建了一个内存管理器类，它存储指向包含我们单一全局资源的内存缓冲区的指针。然后我们创建一个简单的分配函数，根据需要处理这个内存（没有释放的能力，这使得算法非常简单）。
- en: 'Since this is a global resource, we create the class globally as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个全局资源，我们可以全局创建这个类，如下所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can use our new memory manager as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按照以下方式使用我们的新内存管理器：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding example, we allocate four integer pointers and then output
    the address of our memory block and the addresses of the integer pointers to ensure
    the algorithm is working as intended, resulting in the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们分配了四个整数指针，然后输出我们内存块的地址和整数指针的地址，以确保算法按预期工作，结果如下：
- en: '![](img/4538b81d-108f-4a76-98a9-f759ccfadcff.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4538b81d-108f-4a76-98a9-f759ccfadcff.png)'
- en: As shown in the preceding, the memory manager properly allocates memory as needed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，内存管理器根据需要正确分配内存。
- en: 'The problem with the preceding implementation is that the memory manager is
    just a class like any other, meaning it can be created as many times as we want
    as well as copied. To better demonstrate why this is a problem, let''s look at
    the following example. Instead of creating one memory manager, let''s create two:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面实现的问题在于内存管理器只是一个像其他类一样的类，这意味着它可以被创建多次以及被复制。为了更好地说明这是一个问题，让我们看下面的例子。我们不是创建一个内存管理器，而是创建两个：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, let''s use both of these memory managers as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式使用这两个内存管理器：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As shown in the preceding, the only difference is we are now using two memory
    managers instead of one. This results in the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，唯一的区别是现在我们使用两个内存管理器而不是一个。这导致以下输出：
- en: '![](img/8a5fd1a4-19c6-44c5-8250-18a3e61714ec.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a5fd1a4-19c6-44c5-8250-18a3e61714ec.png)'
- en: As shown in the preceding, memory has been double allocated, which will likely
    result in corruption and undefined behavior. The reason this occurs is the memory
    buffer itself is a global resource—something we cannot change. The memory manager
    itself does nothing to ensure this scenario cannot happen and, as a result, the
    user of this API might accidentally create a second memory manager. Note that,
    in our example, we explicitly created a second copy, but a second copy could occur
    by simply passing the memory manager around, inadvertently creating copies along
    the way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，内存已经被双重分配，这可能导致损坏和未定义的行为。发生这种情况的原因是内存缓冲区本身是一个全局资源，这是我们无法改变的。内存管理器本身并没有做任何事情来确保这种情况不会发生，因此，这个API的用户可能会意外地创建第二个内存管理器。请注意，在我们的例子中，我们明确地创建了第二个副本，但通过简单地传递内存管理器，可能会意外地创建副本。
- en: 'To address this issue, we must handle two specific scenarios:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须处理两种特定的情况：
- en: Creating more than one instance of the memory manager
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个内存管理器实例
- en: Copying the memory manager
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制内存管理器
- en: 'To address both of these issues, let''s now show the singleton pattern:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这两个问题，让我们现在展示单例模式：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As shown in the preceding, we start with the constructor being marked as `private`.
    Marking the constructor as `private` prevents the use of the memory manager from
    creating their own instances of the memory manager. Instead, to get an instance
    of the memory manager, we will use the following `public` function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们从将构造函数标记为`private`开始。将构造函数标记为`private`可以防止内存管理器的使用者创建自己的内存管理器实例。相反，要获得内存管理器的实例，我们将使用以下`public`函数：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This preceding function creates a static (that is, global) instance of the memory
    manager and then returns a reference to this instance. Using this function, the
    user of the API can only get an instance of the memory manager from this function,
    which always returns only a reference to the globally defined resource. In other
    words, there is no ability to create additional instances of the class without
    the compiler complaining.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前面的函数创建了内存管理器的静态（即全局）实例，然后返回对这个实例的引用。使用这个函数，API的用户只能从这个函数中获得内存管理器的实例，这个函数总是只返回对全局定义资源的引用。换句话说，没有能力创建额外的类实例，否则编译器会报错。
- en: 'The last step to creating the singleton class is the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单例类的最后一步是以下：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As shown in the preceding, the copy and move constructors/operators are explicitly
    deleted. This addresses the second issue. By removing the copy constructor and
    operator, there is no ability to create a copy of the global resource, ensuring
    that the class only exists as a single global object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，复制和移动构造函数/操作符被明确删除。这解决了第二个问题。通过删除复制构造函数和操作符，就没有能力创建全局资源的副本，确保类只存在为单一全局对象。
- en: 'To use this singleton class, we would do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个单例类，我们需要做以下操作：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '![](img/cde66b36-11d4-4296-b84d-0a76d9e7da36.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cde66b36-11d4-4296-b84d-0a76d9e7da36.png)'
- en: 'If we attempt to create another instance of the memory manager ourselves, we
    would get an error similar to the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试自己创建另一个内存管理器实例，我们会得到类似以下的错误：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, since the singleton class is a single, global resource, we can create
    wrappers to remove the verbosity, as in the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于单例类是一个单一的全局资源，我们可以创建包装器来消除冗长，如下所示：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This change can be used as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变可以按照以下方式使用：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding, the `constexpr` wrapper provides a simple means to
    remove the verbosity of our singleton class, something that would be difficult
    to do if the memory manager wasn't a singleton.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`constexpr`包装器提供了一种简单的方法来消除我们单例类的冗长，如果内存管理器不是单例的话，这将是很难做到的。
- en: Extending your objects with the decorator pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰器模式扩展您的对象
- en: In this recipe, we will learn how to implement the decorator pattern, which
    provides the ability to extend the functionality of a class without the need for
    inheritance, which by design is static in nature. This recipe is important because
    inheritance doesn't support the ability to extend a class at runtime, a problem
    the decorator pattern addresses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何实现装饰器模式，该模式提供了在不需要继承的情况下扩展类功能的能力，这是静态性质的设计。这个示例很重要，因为继承不支持在运行时扩展类的能力，这是装饰器模式解决的问题。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To compile the source code, run the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will learn how to implement the decorator pattern. To start,
    let''s look at a simple example: suppose we are writing a C++ application that
    will host a website. In our website, we need to define a button that users can
    click on, but we need to calculate the width of the button given an extra margin
    that adds to the total size of the button:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何实现装饰器模式。首先，让我们看一个简单的例子：假设我们正在编写一个C++应用程序，将托管一个网站。在我们的网站中，我们需要定义一个用户可以点击的按钮，但我们需要计算给定额外边距的按钮的宽度：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in the preceding, we have created a class called `margin` that returns
    the width of the margin in question (we will only focus on the width to simplify
    our example). We can then define our button as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们创建了一个名为`margin`的类，返回所讨论边距的宽度（我们只关注宽度以简化我们的示例）。然后我们可以按照以下方式定义我们的按钮：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As shown in the preceding, the total width of our button is the width of the
    button itself plus the width of the margin. We can then get the width of our button
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们按钮的总宽度是按钮本身的宽度加上边距的宽度。然后我们可以按照以下方式获取按钮的宽度：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This results in the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/697bea8a-1cdb-45ac-8431-53344285e825.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/697bea8a-1cdb-45ac-8431-53344285e825.png)'
- en: 'The problem with the preceding example is the button must always have a margin
    as the button directly inherits the margin class. There are ways to prevent this
    (for example, our button could have a configuration option that determines whether
    the button returns the width with the margin or not), but in this recipe, we will
    use the decorator pattern to solve this issue, allowing us to create two buttons:
    one button with a margin, and one button without a margin. Let''s try this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的问题是按钮必须始终具有边距，因为按钮直接继承了边距类。有方法可以防止这种情况发生（例如，我们的按钮可以有一个配置选项，确定按钮是否返回带有边距的宽度），但在这个示例中，我们将使用装饰器模式来解决这个问题，允许我们创建两个按钮：一个带有边距的按钮，一个没有边距的按钮。让我们试试看：
- en: 'To start, let''s define the following pure virtual base class as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义以下纯虚基类如下：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown in the preceding, the pure virtual base class defines the `width` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，纯虚基类定义了`width`函数。
- en: 'We can then implement our button as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以按照以下方式实现我们的按钮：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in the preceding, the button inherits the base class and returns a
    width of `10`. Using the preceding, we can start that `button` is always a width
    of `10`, and the button has no concept of a margin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，按钮继承了基类并返回`10`的宽度。使用上述，我们可以开始`button`始终是`10`的宽度，按钮没有边距的概念。
- en: 'To add a margin to the button, we first must create a decorator class as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向按钮添加边距，我们首先必须创建一个装饰器类，如下所示：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The decorator pattern starts with a private member to a `base` pointer, which
    is set in the decorator's constructor. The decorator also defines the `width`
    function but forwards the call to the base class.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式从一个私有成员开始，指向一个`base`指针，该指针在装饰器的构造函数中设置。装饰器还定义了`width`函数，但将调用转发给基类。
- en: 'Now, we can create a margin class, which is a decorator, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个边距类，它是一个装饰器，如下所示：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As shown in the preceding, the margin class returns the width of the object
    it is decorating with an additional `32` added to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，边距类返回所装饰对象的宽度，并额外添加`32`。
- en: 'We can then create our two buttons as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以按照以下方式创建我们的两个按钮：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This results in the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/c40ae265-8e79-4f31-8cea-5a48a0d65d00.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c40ae265-8e79-4f31-8cea-5a48a0d65d00.png)'
- en: 'The biggest advantage to the decorator pattern is it allows us to extend a
    class at runtime. For example, we can create a button with two margins if we want:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式的最大优势是它允许我们在运行时扩展一个类。例如，我们可以创建一个带有两个边距的按钮：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We could otherwise create another decorator. To demonstrate this, let''s extend
    our base class as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们可以创建另一个装饰器。为了演示这一点，让我们扩展我们的基类如下：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding base class now defines a width, and a content width (the amount
    of space inside our button that we can actually use). Now, we can create our button
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的基类现在定义了一个宽度和一个内容宽度（我们按钮内部可以实际使用的空间）。现在，我们可以按照以下方式创建我们的按钮：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As shown in the preceding, our button has a static width, and the content width
    is the same as the width itself minus 1 (to leave space for the button''s border).
    We then define our decorator as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们的按钮具有静态宽度，内容宽度与宽度本身相同减去1（为按钮的边框留出空间）。然后我们定义我们的装饰器如下：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As shown in the preceding, the only difference is the decorator now has to
    forward the width and the content width functions. Our margin decorator looks
    like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，唯一的区别是装饰器现在必须转发宽度和内容宽度函数。我们的边距装饰器如下所示：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As is the case with web programming, a margin increases the size of an object.
    It doesn''t change the space within an object for its internal contents, and hence,
    the margin returns the content width with no modifications. With the preceding
    changes, we can now add a padding decorator as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web编程一样，边距增加了对象的大小。它不会改变对象内部内容的空间，因此边距返回的是内容宽度，没有进行修改。通过前面的更改，我们现在可以按照以下方式添加填充装饰器：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The padding decorator is the opposite of the margin decorator. It doesn't change
    the size of an object, it reduces the total amount of space given to the internal
    contents of an object. As a result, it doesn't change the width, but it does decrease
    the size of the content.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 填充装饰器与边距装饰器相反。它不会改变对象的大小，而是减少了给对象内部内容的总空间。因此，它不会改变宽度，但会减小内容的大小。
- en: 'To create a button using our new decorators, we can use the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的新装饰器创建一个按钮，我们可以使用以下命令：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown in the preceding, we create a button that has an added margin and
    added padding, which results in the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们创建了一个具有额外边距和填充的按钮，结果如下输出：
- en: '![](img/2d871265-d736-4585-83b8-30b74a6b04e9.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d871265-d736-4585-83b8-30b74a6b04e9.png)'
- en: The decorator pattern provides the ability to create different buttons without
    the need for compile-time inheritance, which would require us to have a different
    button definition for every possible type of button we could think of. It should
    be noted, however, that the decorator pattern comes at a cost of added allocations
    and redirections of function calls, so this runtime flexibility does come at a
    cost.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式提供了创建不同按钮的能力，而无需编译时继承，这将要求我们为每种可能的按钮类型都有一个不同的按钮定义。然而，需要注意的是，装饰器模式会增加分配和函数调用的重定向成本，因此这种运行时灵活性是有代价的。
- en: Adding communication with the observer pattern
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加与观察者模式的通信
- en: In this recipe, we will learn how to implement the observer pattern. The observer
    pattern provides the ability for a class to register with another class to receive
    notifications when an event occurs. The Qt language provides this feature through
    the use of its singles and slots mechanism while requiring a MOC compiler to make
    it work. This recipe is important as we will learn how to implement the observer
    pattern without the need for Qt, using standard C++.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何实现观察者模式。观察者模式提供了一个类注册到另一个类以接收事件发生时的通知的能力。Qt语言通过使用其信号和槽机制提供了这一功能，同时需要使用MOC编译器使其工作。这个食谱很重要，因为我们将学习如何在不需要Qt的情况下实现观察者模式，而是使用标准的C++。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本食谱中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来尝试这个食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的终端，运行以下命令来下载源代码：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To compile the source code, run the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本食谱中的每个示例：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The observer pattern provides the ability for an observer to be notified when
    an event occurs. To explain how this works, let''s start with the following pure
    virtual base class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式提供了观察者在事件发生时被通知的能力。为了解释这是如何工作的，让我们从以下纯虚基类开始：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As shown in the preceding, we have defined `observer`, which must implement
    a `trigger()` function. We can then create two different versions of this pure
    virtual base class as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们定义了`observer`，它必须实现`trigger()`函数。然后我们可以创建两个不同版本的这个纯虚基类，如下所示：
- en: '[PRE59]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As shown in the preceding code, we have created two different classes, both
    of which subclass the observer pure virtual class, overriding the trigger function.
    We can then implement a class that produces an event the observer might be interested
    in, shown as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示的代码，我们创建了两个不同的类，它们都是观察者纯虚类的子类，重写了触发函数。然后我们可以实现一个产生观察者可能感兴趣的事件的类，如下所示：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As shown in the preceding code, we start with `std::vector`, which stores any
    number of observers. We then provide a trigger function, which represents our
    event. When this function is executed, we loop through all of the observers and
    notify them of the event by calling their `trigger()` functions. Finally, we provide
    a function that allows an observer to subscribe to the event in question.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们首先使用`std::vector`来存储任意数量的观察者。然后我们提供一个触发函数，代表我们的事件。当执行此函数时，我们循环遍历所有观察者，并通过调用它们的`trigger()`函数来通知它们事件。最后，我们提供一个函数，允许观察者订阅相关事件。
- en: 'The following demonstrates how these classes could be used:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了如何使用这些类：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output for this is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/381ac2b5-23b3-46d9-9c09-6eda2174b3b4.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/381ac2b5-23b3-46d9-9c09-6eda2174b3b4.png)'
- en: As shown in the preceding, when the alarm class is triggered, the observers
    are notified of the event and process the notification as needed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，当触发警报类时，观察者将收到事件通知并根据需要处理通知。
- en: Improving performance with static polymorphism
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态多态性来提高性能
- en: In this recipe, we will learn how to create polymorphism without the need for
    virtual inheritance. Instead, we will use compile-time inheritance (called static
    polymorphism). This recipe is important because static polymorphism does not incur
    the same performance and memory usage penalties as runtime, virtual inheritance
    (as no vTable is required), at the expense of readability and the inability to
    leverage the runtime benefits of virtual subclassing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何创建多态性，而无需虚拟继承。相反，我们将使用编译时继承（称为静态多态性）。这个教程很重要，因为静态多态性不会像运行时虚拟继承那样产生性能和内存使用的惩罚（因为不需要vTable），但会牺牲可读性和无法利用虚拟子类化的运行时优势。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本教程中示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the recipe:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To compile the source code, run the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the main goals of polymorphism is that it provides the ability to override
    how an object executes a particular function while, at the same time, providing
    the ability to provide common logic across a set of objects. The problem with
    virtual inheritance is that the ability to override requires the use of a vTable
    (that is, a virtual table, which is an extra block of memory needed to handle
    virtual inheritance) if you wish to use the base class as your interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性的主要目标之一是它提供了覆盖对象执行特定函数的能力，同时也提供了在一组对象中提供通用逻辑的能力。虚拟继承的问题在于，如果希望使用基类作为接口，覆盖的能力就需要使用vTable（即虚拟表，这是处理虚拟继承所需的额外内存块）。
- en: 'For example, consider the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s start with the previously defined base class. It provides a `foo()`
    function as pure (that is, a subclass must implement this function) while also
    providing its own common logic. We can then create two subclasses as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前定义的基类开始。它提供了一个`foo()`函数作为纯虚函数（即，子类必须实现此函数），同时还提供了自己的通用逻辑。然后我们可以创建两个子类，如下所示：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As shown in the preceding, we subclass the base class and override the `foo()`
    function with subclass-specific functionality. We can then call the subclass-specific
    `foo()` functions from our base class as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们对基类进行子类化，并使用子类特定功能重写`foo()`函数。然后我们可以从基类调用子类特定的`foo()`函数，如下所示：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This results in the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/523debdb-a99c-47b7-9ea3-d8aa453ca274.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/523debdb-a99c-47b7-9ea3-d8aa453ca274.png)'
- en: This type of runtime polymorphism requires the use of a vTable, which not only
    increases the memory footprint of each object but also incurs a performance penalty
    as each function call requires a vTable lookup. If the runtime properties of virtual
    inheritance are not needed, static polymorphism can provide the same functionality
    without the penalties.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的运行时多态性需要使用vTable，这不仅增加了每个对象的内存占用，还会导致性能损失，因为每个函数调用都需要进行vTable查找。如果不需要虚拟继承的运行时特性，静态多态性可以提供相同的功能而不会产生这些惩罚。
- en: 'To start, let''s define the base class as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义基类如下：
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Like our previous example, the base class doesn't implement the `foo()` function
    but instead requires a subclass to implement this function (which is what allows
    a static cast to cast this to type `T`).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的示例一样，基类不实现`foo()`函数，而是要求子类实现此函数（这就允许静态转换将其转换为类型`T`）。
- en: 'We can then implement our subclasses as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以按以下方式实现我们的子类：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As with the previous example, the subclasses simply implement the `foo()` function.
    The difference, in this case, is the inheritance requires the use of the template
    parameter, which removes the need for the `foo()` function to override as the
    base class never uses a virtual function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，子类只是实现了`foo()`函数。不同之处在于，这种情况下继承需要使用模板参数，这消除了`foo()`函数需要覆盖的需要，因为基类从未使用虚函数。
- en: 'The preceding static polymorphism allows us to execute the `foo()` function
    from our base class as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的静态多态性允许我们执行来自基类的`foo()`函数如下：
- en: '[PRE71]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As shown in the preceding, the `test()` function does not have any information
    about each subclass. It only has information about the base (or interface) class.
    This `test()` function can be executed as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`test()`函数对每个子类都没有任何信息。它只有关于基类（或接口）的信息。这个`test()`函数可以这样执行：
- en: '[PRE72]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This again results in the same output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次导致相同的输出：
- en: '![](img/18a35eb7-3016-43dc-9871-77f0e57eb78f.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18a35eb7-3016-43dc-9871-77f0e57eb78f.png)'
- en: As shown in the preceding, if the polymorphic types are known at compile time,
    static polymorphism can be used to remove the need for `virtual`, removing the
    need of a vTable. This type of logic is especially helpful when working with template
    classes where the base type is known but the subclass type is not (and is provided),
    allowing the template function to only need the base interface.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，如果在编译时知道多态类型，可以使用静态多态性来消除对`virtual`的需要，从而消除对vTable的需要。这种逻辑在使用模板类时特别有帮助，其中基本类型已知但子类类型不知道（并且已提供），允许模板函数只需要基本接口。
