- en: '*Chapter 12*: Blending between Animations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：动画之间的混合'
- en: The transition from one animation to another can be jarring. Imagine if a character
    is in the middle of a punch and the player decides that they want to start running.
    If the animation just switches from the jump clip to the run clip, the transitions
    will be hard and unnatural.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个动画过渡到另一个动画可能会很突兀。想象一下，如果一个角色正在进行一次拳击，玩家决定开始奔跑。如果动画直接从跳跃片段切换到奔跑片段，过渡将会很生硬和不自然。
- en: Animation blending can fix this by generating intermediate frames that are an
    average of both animations. This fade is usually short—a quarter of a second or
    less. The smooth animated transition generated by this short blend provides a
    much better looking experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动画混合可以通过生成两个动画的平均中间帧来修复这个问题。这种淡入通常很短——不到一秒钟。这种短混合产生的平滑动画过渡提供了更好的观感体验。
- en: 'This chapter explores how to implement animation blending and additive animation
    blending and how to set up a crossfade controller to manage a blend queue. The
    following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何实现动画混合和附加动画混合，以及如何设置交叉淡入淡出控制器来管理混合队列。将涵盖以下主题：
- en: Pose blending
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姿势混合
- en: Crossfading animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉淡入淡出动画
- en: Additive blending
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加混合
- en: Pose blending
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 姿势混合
- en: Animation blending is a linear blend between two poses in the local space of
    each joint. Think of it as a `lerp` or `mix` function but applied to an entire
    pose. This technique does not blend animation clips; rather, it blends the poses
    that these clips have been sampled into.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 动画混合是在每个关节的本地空间中两个姿势之间的线性混合。可以将其视为`lerp`或`mix`函数，但应用于整个姿势。这种技术不是混合动画片段；而是混合这些片段被采样到的姿势。
- en: When blending two poses, the entire pose does not need to be blended. Assume
    there are two animations—a run cycle and an attack. If the player presses the
    attack button, the top half of the attack pose is blended in over a short period
    of time, maintains a weight of `1` throughout the animation, and is then blended
    out near the end of the animation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在混合两个姿势时，不需要整个姿势都进行混合。假设有两个动画——奔跑循环和攻击。如果玩家按下攻击按钮，攻击姿势的上半部分在短时间内混合进来，保持在整个动画中的权重为`1`，然后在动画结束时淡出。
- en: This is an example of using pose blending to create a running attack animation
    without having to animate the legs of the attack animation. The attack animation
    could be blended on top of a walk cycle for a walking animation. Animation blending
    can be used to transition smoothly between animations or to combine multiple animations
    into a new one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用姿势混合来创建奔跑攻击动画的示例，而无需对攻击动画的腿部进行动画处理。攻击动画可以在行走动画的基础上混合。动画混合可用于平滑地过渡动画或将多个动画组合成一个新动画。
- en: In the following section, you will declare a `Blend` function for the `Pose`
    class. This `Blend` function will linearly interpolate between two poses, similar
    to how a vector `lerp` works. The function needs two poses and an interpolation
    value, commonly represented as `t`, which has a range of `0` to `1`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将为`Pose`类声明一个`Blend`函数。这个`Blend`函数将在两个姿势之间进行线性插值，类似于向量`lerp`的工作方式。该函数需要两个姿势和一个插值值，通常表示为`t`，其范围为`0`到`1`。
- en: Declaring the Blend function
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明混合函数
- en: The `Blend` function takes two poses—a mix value and a root node—as arguments.
    When the mix value is `0`, the `Blend` function returns the first pose, and when
    it is `1`, it returns the second pose. For any values between `0` and `1`, the
    poses are blended. The root node decides which node (and its children) of the
    second animation should be blended into the first animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blend`函数接受两个姿势——混合值和根节点作为参数。当混合值为`0`时，`Blend`函数返回第一个姿势，当为`1`时，返回第二个姿势。对于介于`0`和`1`之间的任何值，姿势都会被混合。根节点决定了第二个动画的哪个节点（及其子节点）应该混合到第一个动画中。'
- en: 'To accommodate specifying a root bone to start blending from, there needs to
    be a way to check whether one node is in the hierarchy of another node. The `IsInHierarchy`
    function takes a `Pose` class, a node that is the root node, and a node that is
    the search node. If the search node is a descendant of the root node, the function
    returns `true`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应指定从哪个骨骼节点开始混合，需要一种方法来检查一个节点是否在另一个节点的层次结构中。`IsInHierarchy`函数接受一个`Pose`类，一个作为根节点的节点和一个作为搜索节点的节点。如果搜索节点是根节点的后代，则函数返回`true`：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When blending two poses, it is assumed that the poses are similar. Similar poses
    have the same number of joints, and each joint has the same parent index between
    the poses. In the following section, you will implement the `Blend` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合两个姿势时，假设这些姿势是相似的。相似的姿势具有相同数量的关节，并且每个关节在姿势之间具有相同的父级索引。在接下来的部分，您将实现`Blend`函数。
- en: Implementing the Blend function
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现混合功能
- en: For blending to work, it must happen in local space, which is convenient for
    blending between two poses. Loop through all the joints in the input poses and
    interpolate between the local transforms of the joint in both poses that are being
    blended. For the position and scale, use the vector `lerp` function, and for the
    rotation, use the quaternion `nlerp` function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使混合有效，它必须在本地空间中进行，这对于在两个姿势之间进行混合非常方便。循环遍历输入姿势中的所有关节，并在正在混合的两个姿势中插值关节的本地变换。对于位置和比例，使用向量`lerp`函数，对于旋转，使用四元数`nlerp`函数。
- en: 'To support an animation root, check whether the current transform is a descendant
    of the blend root. If it is, carry out the blend. If it is not, skip the blend
    and keep the transform values of the first input pose. Follow these steps to implement
    the hierarchy check and `Blend` functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持动画根节点，检查当前变换是否是混合根的后代。如果是，进行混合。如果不是，则跳过混合，并保持第一个输入姿势的变换值。按照以下步骤实现层次结构检查和`Blend`函数：
- en: 'To check whether one joint is the descendant of another, follow the descendant
    joint all the way up the hierarchy until the root node. If any of the nodes encountered
    in this hierarchy are the node that you are checking against, return `true`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查一个关节是否是另一个关节的后代，沿着后代关节一直向上遍历层次结构，直到根节点。如果在这个层次结构中遇到的任何节点都是您要检查的节点，则返回`true`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To blend two poses together, loop through the joints of each pose. If the current
    joint is not in the blend root''s hierarchy, don''t blend it. Otherwise, blend
    the `Transform` objects using the `mix` function you wrote in [*Chapter 5*](B16191_05_Final_JC_ePub.xhtml#_idTextAnchor094),
    *Implementing Transforms*. The `mix` function takes quaternion neighborhooding
    into account:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将两个姿势混合在一起，循环遍历每个姿势的关节。如果当前关节不在混合根的层次结构中，则不进行混合。否则，使用您在[*第5章*](B16191_05_Final_JC_ePub.xhtml#_idTextAnchor094)中编写的`mix`函数来混合`Transform`对象。`mix`函数考虑四元数邻域：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If two animations are blended using the whole hierarchy, the root argument to
    `Blend` will be negative. With a negative joint for the blend root, the `Blend`
    function skips the `IsInHierarchy` check. In the following section, you will explore
    how to fade between two animations for a smooth transition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用整个层次结构混合两个动画，则`Blend`的根参数将为负数。对于混合根的负关节，`Blend`函数会跳过`IsInHierarchy`检查。在接下来的部分，您将探索如何在两个动画之间进行淡入淡出以实现平滑过渡。
- en: Crossfading animations
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 淡入淡出动画
- en: The most common use case for blending animations is crossfading between two
    animations. A **crossfade** is a fast blend from one animation to another. The
    goal of the crossfade is to hide the transition between two animations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 混合动画的最常见用例是在两个动画之间进行淡入淡出。**淡入淡出**是从一个动画快速混合到另一个动画。淡入淡出的目标是隐藏两个动画之间的过渡。
- en: Once a crossfade is done, the active animation needs to be replaced by the animation
    that you are fading to. If you are fading to multiple animations, they are all
    evaluated. The ones that end the soonest are removed first. Animations that are
    requested are added to a list, and animations that have faded out are removed
    from the list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦淡入淡出完成，活动动画需要被正在淡入的动画替换。如果您正在淡入多个动画，则它们都会被评估。最先结束的动画首先被移除。请求的动画被添加到列表中，已经淡出的动画被从列表中移除。
- en: In the following section, you will build a `CrossFadeController` class that
    takes care of the crossfade logic. This class provides a simple intuitive API
    that makes fading between animations simple with just one function call.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将构建一个`CrossFadeController`类来处理淡入淡出逻辑。这个类提供了一个简单直观的API，只需一个函数调用就可以简单地在动画之间进行淡入淡出。
- en: Creating helper classes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建辅助类
- en: When fading an animation into an already-sampled pose, you need to know what
    the animation being faded is, it's current playtime, the length of the fade durations,
    and the current time of the fade. These values are used to perform the actual
    blend and contain data about the state of the blend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当将动画淡入到已经采样的姿势中时，您需要知道正在淡入的动画是什么，它的当前播放时间，淡入持续时间的长度以及淡入的当前时间。这些值用于执行实际的混合，并包含有关混合状态的数据。
- en: 'Create a new file and name it `CrossFadeTarget.h` to implement the `CrossFadeTarget`
    helper class in. This helper class contains the variables described previously.
    The default constructor should set the value of everything to `0`. A convenience
    constructor that takes a clip pointer, pose reference, and duration is also provided:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件并命名为`CrossFadeTarget.h`，以实现`CrossFadeTarget`辅助类。这个辅助类包含了之前描述的变量。默认构造函数应将所有值设置为`0`。还提供了一个方便的构造函数，它接受剪辑指针、姿势引用和持续时间：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `mPose`, `mClip`, and `mTime` variables of the `CrossFadeTarget` helper
    class are used in every frame to sample the animation that is being faded to.
    The `mDuration` and `mElapsed` variables are used to control how much the animation
    should be faded in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrossFadeTarget`辅助类的`mPose`、`mClip`和`mTime`变量在每一帧都用于采样正在淡入的动画。`mDuration`和`mElapsed`变量用于控制动画应该淡入多少。'
- en: In the next section, you will implement a class that controls animation playback
    and fading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将实现一个控制动画播放和淡入淡出的类。
- en: Declaring the cross-fade controller
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明淡入淡出控制器
- en: Keeping track of the currently playing clip and managing the fading is the job
    of a new `CrossFadeController` class. Create a new file, `CrossFadeController.h`,
    to declare the new class in. This class needs to contain a skeleton, a pose, the
    current playback time, and an animation clip. It also needs a vector of the `CrossFadeTarget`
    objects that control the animation blending.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪当前播放的剪辑并管理淡入淡出是新的`CrossFadeController`类的工作。创建一个新文件`CrossFadeController.h`，声明新的类。这个类需要包含一个骨架、一个姿势、当前播放时间和一个动画剪辑。它还需要一个控制动画混合的`CrossFadeTarget`对象的向量。
- en: Both the `CrossFadeController` and `CrossFadeTarget` classes contain pointers
    to animation clips, but they don't own these pointers. Because neither class owns
    the memory for the pointers, the generated constructor, copy constructor, assignment
    operator, and destructor should be fine to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrossFadeController`和`CrossFadeTarget`类都包含指向动画剪辑的指针，但它们不拥有这些指针。因为这两个类都不拥有指针的内存，所以生成的构造函数、复制构造函数、赋值运算符和析构函数应该可以正常使用。'
- en: 'The `CrossFadecontroller` class needs functions to set the current skeleton,
    retrieve the current pose, and retrieve the current clip. The current animation
    can be set with the `Play` function. New animations can be blended in using the
    `FadeTo` function. Since the `CrossFadeController` class manages animation playback,
    it needs an `Update` function to sample the animation clips:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`CrossFadecontroller`类需要函数来设置当前骨架、检索当前姿势和检索当前剪辑。当前动画可以使用`Play`函数设置。可以使用`FadeTo`函数淡入新动画。由于`CrossFadeController`类管理动画播放，它需要一个`Update`函数来采样动画剪辑：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entire `mTargets` list is evaluated with every frame. Each animation is
    evaluated and blended into the currently playing animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`mTargets`列表在每一帧都会被评估。每个动画都会被评估并混合到当前播放的动画中。
- en: In the following section, you will implement the `CrossFadeController` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将实现`CrossFadeController`类。
- en: Implementing the cross-fade controller
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现淡出控制器
- en: 'Create a new file, `CrossFadeController.cpp`. `CrossFadeController` is implemented
    in this new file. Follow these steps to implement `CrossFadeController`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`CrossFadeController.cpp`。在这个新文件中实现`CrossFadeController`。按照以下步骤实现`CrossFadeController`：
- en: 'In the default constructor, set a default value of `0` for the current clip
    and time and mark the skeleton as not set. There is a convenience constructor
    that takes a skeleton reference. The convenience constructor should call the `SetSkeleton`
    function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认构造函数中，为当前剪辑和时间设置默认值`0`，并将骨骼标记为未设置。还有一个方便的构造函数，它接受一个骨骼引用。方便的构造函数应调用`SetSkeleton`函数：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the `SetSkeleton` function, which copies the provided skeleton into
    `CrossFadeController`. It marks the class as having its skeleton set and copies
    the rest pose into the internal pose of the crossfade controller:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`SetSkeleton`函数，将提供的骨骼复制到`CrossFadeController`中。它标记该类的骨骼已设置，并将静止姿势复制到交叉淡出控制器的内部姿势中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `Play` function. This function should clear any active crossfades.
    It should set the clip and playback time, but it also needs to reset the current
    pose to the rest pose of the skeleton:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Play`函数。此函数应清除任何活动的交叉淡出。它应设置剪辑和播放时间，但还需要将当前姿势重置为骨骼的静止姿势：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `FadeTo` function, which should check whether the requested fade
    target is valid. A fade target is only valid if it is not the first or last item
    in the fade list. Assuming these conditions are met, the `FadeTo` function adds
    the provided animation clip and duration to the fade list:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FadeTo`函数，该函数应检查请求的淡出目标是否有效。淡出目标仅在不是淡出列表中的第一个或最后一个项目时才有效。假设满足这些条件，`FadeTo`函数将提供的动画剪辑和持续时间添加到淡出列表中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the `Update` function to play the active animation and blend in any
    other animations that are in the fade list:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Update`函数以播放活动动画并混合任何在淡出列表中的其他动画：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set the current animation as the target animation and remove the fade object
    if an animation has finished fading. Only one target is removed per frame. If
    you want to remove all the faded-out targets, change the loop to go backward:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前动画设置为目标动画，并在动画淡出完成时移除淡出对象。每帧只移除一个目标。如果要移除所有已淡出的目标，请将循环改为反向：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Blend the fade list with the current animation. The current animation and all
    the animations in the fade list will need to be sampled:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将淡出列表与当前动画混合。需要对当前动画和淡出列表中的所有动画进行采样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finish the `CrossFadeController` class implementation with the `GetCurrentPose`
    and `GetCurrentclip` helper functions. These are simple getter functions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetCurrentPose`和`GetCurrentclip`辅助函数完成`CrossFadeController`类的实现。这些都是简单的getter函数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of manually controlling what animation is playing, you can now create
    an instance of `CrossFadeController` to control animation playback. The `CrossFadeController`
    class automatically fades to new animations when you start playing them. In the
    next section, you will explore additive animation blending.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建`CrossFadeController`的实例来控制动画播放，而不是手动控制正在播放的动画。`CrossFadeController`类在开始播放新动画时会自动淡出到新动画。在下一部分中，您将探索加法动画混合。
- en: Additive blending
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法混合
- en: Additive animations are used to modify an animation by adding in extra joint
    movements. A common example is leaning left. If there is a leaning-left animation
    that simply bends the character's spine, it can be added to a walking animation
    to create a leaning-left-while-walking animation, a running animation, or any
    other kind of animation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加法动画用于通过添加额外的关节运动来修改动画。一个常见的例子是向左倾斜。如果有一个向左倾斜的动画，它只是简单地弯曲了角色的脊柱，它可以添加到行走动画中，以创建一个边走边倾斜的动画，奔跑动画，或者任何其他类型的动画。
- en: Not all animations are a good fit for additive animations. Additive animations
    are usually specifically made. I have added a `Lean_Left` animation to the `Woman.gltf`
    file provided with the sample code for this chapter. This animation is made to
    be additive. It only bends one of the spine joints.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有动画都适合作为加法动画。加法动画通常是专门制作的。我已经在本章的示例代码中提供的`Woman.gltf`文件中添加了一个`Lean_Left`动画。这个动画是为了加法而制作的。它只弯曲了脊柱关节中的一个。
- en: Additive animations typically don't play according to time, but rather, according
    to some other input. Think of leaning left as an example—it should be controlled
    by the user's joystick. The closer the joystick is to the left, the further in
    the animation the lean should go. It's common to sync the playback of additive
    animations to something other than time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 加法动画通常不是根据时间播放，而是根据其他输入播放。以向左倾斜为例——它应该由用户的操纵杆控制。操纵杆越靠近左侧，倾斜的动画就应该越进。将加法动画的播放与时间以外的其他内容同步是很常见的。
- en: Declaring additive animations
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明加法动画
- en: The functions for additive blending are declared in `Blending.h`. The first
    function, `MakeAditivePose`, samples the additive clip at time `0` into an output
    pose. This output pose is the reference that is used to add two poses together.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合的函数声明在`Blending.h`中。第一个函数`MakeAditivePose`在时间`0`处对加法剪辑进行采样，生成一个输出姿势。这个输出姿势是用来将两个姿势相加的参考。
- en: 'The `Add` function performs the additive blending process between two poses.
    The additive blending formula is *result pose* = *input pose* + (*additive pose
    – additive base pose*). The first two arguments, which are the output pose and
    the input pose, can point to the same pose. To apply an additive pose, both the
    additive pose and a reference for the additive pose are needed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`函数执行两个姿势之间的加法混合过程。加法混合公式为*result pose* = *input pose* + (*additive pose
    – additive base pose*)。前两个参数，即输出姿势和输入姿势，可以指向同一个姿势。要应用加法姿势，需要加法姿势和加法姿势的引用：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MadeAdditivePose` helper function generates the additive base pose that
    the `Add` function takes for its fourth argument. The function is intended to
    be called during initialization time. In the next section, you will implement
    these functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`MadeAdditivePose`辅助函数生成`Add`函数用于其第四个参数的附加基础姿势。该函数旨在在初始化时调用。在下一节中，您将实现这些函数。'
- en: Implementing additive animations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现附加动画
- en: 'Implement the `MakeAdditivePose` function in `Blending.cpp`. This function
    is only intended to be called during load time. It should sample the provided
    clip at the start time of the clip. The result of that sample is the additive
    base pose:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Blending.cpp`中实现`MakeAdditivePose`函数。该函数仅在加载时调用。它应在剪辑的开始时间对提供的剪辑进行采样。该采样的结果是附加基础姿势：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The formula for additive blending is *result pose* = *input pose* + (*additive
    pose – additive base pose*). The subtraction of the additive base pose only applies
    the delta of the additive animation between the first and current frames of the
    animation. Because of this, you can only animate one bone, say, one of the spine
    bones, and achieve an effect that makes the character lean left.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 附加混合的公式为*结果姿势* = *输入姿势* + (*附加姿势 - 附加基础姿势*)。减去附加基础姿势只应用于动画的第一帧和当前帧之间的附加动画增量。因此，您只能对一个骨骼进行动画，比如脊柱骨骼之一，并实现使角色向左倾斜的效果。
- en: 'To implement additive blending, loop through every joint of the pose. As with
    regular animation blending, there is a `blendroot` parameter that needs to be
    considered. Follow the provided formula using the local transform of each joint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现附加混合，需要循环遍历每个姿势的关节。与常规动画混合一样，需要考虑`blendroot`参数。使用每个关节的本地变换，按照提供的公式进行操作：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important information
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Quaternions don't have a subtraction operator. To remove the rotation of quaternion
    *A* from quaternion *B*, multiply *B* by the inverse of *A*. The inverse of a
    quaternion applies the opposite of a rotation, which is why a quaternion multiplied
    by its inverse results in the identity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数没有减法运算符。要从四元数*A*中移除四元数*B*的旋转，需要将*B*乘以*A*的逆。四元数的逆应用相反的旋转，这就是为什么四元数乘以其逆的结果是单位。
- en: Additive animations are most often used to create new animation variants—for
    example, mixing a walking animation with a crouching pose to create a crouched
    walk. All animations can be additively blended with the crouched pose to create
    crouching versions of the animations programmatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 附加动画通常用于创建新的动画变体，例如，将行走动画与蹲姿混合以创建蹲行动画。所有动画都可以与蹲姿进行附加混合，以在程序中创建动画的蹲姿版本。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to blend multiple animations. Blended animations
    can blend the whole hierarchy or just a subset. You also built a system to manage
    the fading between animations when a new animation plays. We also covered additive
    animations, which can be used to create a new motion when given the joint angles
    to interpolate between.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何混合多个动画。混合动画可以混合整个层次结构或只是一个子集。您还构建了一个系统，用于管理在播放新动画时动画之间的淡入淡出。我们还介绍了附加动画，可以在给定关节角度的情况下用于创建新的运动。
- en: There are four samples included in the downloadable materials for this chapter.
    `Sample00` is all the code up to this point in the book. `Sample01` demonstrates
    how to use the `Blend` function by blending between a walk and a run animation
    on a timer. `Sample02` demonstrates the use of the cross-fade controller by crossfading
    to random animations and `Sample03` demonstrates how to use additive animation
    blending.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的可下载材料中包括四个示例。`Sample00`是本书到目前为止的所有代码。`Sample01`演示了如何使用`Blend`函数，通过定时器在行走和奔跑动画之间进行混合。`Sample02`演示了交叉淡入淡出控制器的使用，通过交叉淡入淡出到随机动画。`Sample03`演示了如何使用附加动画混合。
- en: In the next chapter, you will learn about inverse kinematics. Inverse kinematics
    allows you to figure out how the limb of a character should be bent according
    to where its ends are. Think about pinning the foot of a character onto uneven
    terrain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习逆向运动学。逆向运动学允许您根据角色的末端位置来确定角色的肢体应该弯曲的方式。想象一下将角色的脚固定在不平整的地形上。
