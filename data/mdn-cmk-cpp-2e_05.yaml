- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Targets
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用目标
- en: 'The entire application in CMake can be built from a single source code file
    (such as the classic `helloworld.cpp`). But it’s equally possible to create a
    project where the executable is built from many source files: dozens or even thousands.
    Many beginners follow this path: they build their binaries with only a few files
    and let their projects grow organically without strict planning. They keep adding
    files as required and before they know it, everything is linked directly to a
    single binary without any structure whatsoever.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，整个应用程序可以从一个源代码文件（例如经典的 `helloworld.cpp`）构建。但同样，也可以创建一个项目，其中可执行文件由多个源文件构建：几十个甚至成千上万个。许多初学者遵循这种路径：他们只用几个文件来构建二进制文件，并让他们的项目自然发展，缺乏严格的规划。他们会根据需要不断添加文件，直到所有内容都直接链接到一个二进制文件，没有任何结构。
- en: As software developers, we deliberately draw boundaries and designate components
    to group one or more units of translation (`.cpp` files). We do it to increase
    code readability, manage coupling and connascence, speed up the build process,
    and finally, discover and extract reusable components into autonomic units.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件开发者，我们有意地划定边界并指定组件，以将一个或多个翻译单元（`.cpp` 文件）分组。我们这样做是为了提高代码可读性、管理耦合性和内聚性、加速构建过程，并最终发现和提取可重用的组件，使其成为自治单元。
- en: Every big project will push you to introduce some form of partitioning. This
    is where CMake targets find their use. A CMake target represents a logical unit
    that focuses on a specific objective. Targets can have dependencies on other targets,
    and their construction follows a declarative approach. CMake takes care of determining
    the proper order for building targets, optimizing with parallel builds where possible,
    and executing the necessary steps accordingly. As a general principle, when a
    target is built, it generates an artifact that can be utilized by other targets
    or serve as the final output of the build process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个大型项目都会促使你引入某种形式的分区。这就是 CMake 目标派上用场的地方。CMake 目标代表一个专注于特定目标的逻辑单元。目标之间可以有依赖关系，它们的构建遵循声明式方法。CMake
    会负责确定构建目标的正确顺序，尽可能进行并行构建，并按需执行必要的步骤。作为一般原则，当一个目标被构建时，它会生成一个可以被其他目标使用的 artifact，或者作为构建过程的最终输出。
- en: 'Notice the usage of the word *artifact*. I intentionally refrain from using
    specific terms because CMake offers flexibility beyond just generating executables
    or libraries. In practice, we can utilize generated buildsystems to produce various
    types of outputs: additional source files, headers, object files, archives, configuration
    files, and more. The only requirements are a command-line tool (like a compiler),
    optional input files, and a designated output path.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 *artifact* 这个词的使用。我故意避免使用特定术语，因为 CMake 提供了灵活性，不仅限于生成可执行文件或库。实际上，我们可以利用生成的构建系统来生成各种类型的输出：额外的源文件、头文件、目标文件、档案、配置文件等等。唯一的要求是一个命令行工具（如编译器）、可选的输入文件和一个指定的输出路径。
- en: Targets are an incredibly powerful concept that greatly streamlines the process
    of building a project. Understanding how they function and mastering the art of
    configuring them in an elegant and organized manner is crucial. This knowledge
    ensures a smooth and efficient development experience.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是一个非常强大的概念，大大简化了构建项目的过程。理解它们的功能，并掌握如何以优雅和有组织的方式配置它们至关重要。这些知识确保了一个顺畅和高效的开发体验。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the concept of a target
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解目标的概念
- en: Setting properties of targets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置目标的属性
- en: Writing custom commands
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义命令
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch05](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中提到的代码文件，链接为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch05](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch05)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory, while **source tree** is the path at which your source code is located.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必用适当的路径替换 `<build tree>` 和 `<source tree>` 占位符。提醒一下：**build tree** 是目标/输出目录的路径，而
    **source tree** 是你的源代码所在的路径。
- en: Understanding the concept of a target
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解目标的概念
- en: If you have ever used GNU Make, you have already seen the concept of a target.
    Essentially, it’s a recipe that a buildsystem follows to compile a set of files
    into another file. It can be a `.cpp` implementation file compiled into a `.o`
    **object file** or a group of `.o` files packaged into a `.a` static library.
    There are numerous combinations and possibilities when it comes to targets and
    their transformations within a buildsystem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾使用过 GNU Make，你已经见过目标的概念。实际上，它是一个构建系统遵循的配方，用来将一组文件编译成另一个文件。它可以是一个 `.cpp`
    实现文件编译成的 `.o` **目标文件**，也可以是多个 `.o` 文件打包成的 `.a` 静态库。在构建系统中，目标及其转换有很多种组合和可能性。
- en: 'CMake, however, allows you to save time and skip defining the intermediate
    steps of those recipes; it works on a higher level of abstraction. It understands
    how most languages build an executable directly from their source files. So, you
    don’t need to write explicit commands to compile your C++ **object files** (as
    you would using GNU Make). All that’s required is an `add_executable()` command
    with the name of the executable target followed by a list of the source files:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，CMake 允许你节省时间，并跳过定义这些步骤的中间过程；它在更高的抽象层次上工作。它理解大多数语言如何直接从源文件生成可执行文件。因此，你不需要像使用
    GNU Make 那样编写明确的命令来编译你的 C++ **目标文件**。只需使用 `add_executable()` 命令，后跟可执行目标的名称和源文件列表即可：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have used this command in the previous chapters, and we already know how
    executable targets are used in practice – during the generation step, CMake will
    create a buildsystem and fill it with appropriate recipes to compile each of the
    source files and link them together into a single binary executable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中已经使用过这个命令，我们也知道可执行目标在实际应用中的使用方式——在生成步骤中，CMake 会创建一个构建系统，并填充适当的配方，将每个源文件编译并链接成一个单一的二进制可执行文件。
- en: 'In CMake, we can create a target using these three commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，我们可以使用这三个命令来创建一个目标：
- en: '`add_executable()`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_executable()`'
- en: '`add_library()`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_library()`'
- en: '`add_custom_target()`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_custom_target()`'
- en: Before building executables or libraries, CMake performs a check to determine
    whether the generated output is older than the source files. This mechanism helps
    CMake avoid recreating artifacts that are already up to date. By comparing timestamps,
    CMake efficiently identifies which targets need to be rebuilt, reducing unnecessary
    recompilation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可执行文件或库之前，CMake 会检查生成的输出是否比源文件更新。这个机制帮助 CMake 避免重新创建已经是最新的产物。通过比较时间戳，CMake
    可以有效地识别哪些目标需要重新构建，从而减少不必要的重新编译。
- en: All commands defining targets require the name of the target to be provided
    as a first argument, so it can be later referenced in other commands that do things
    with targets, like `target_link_libraries()`, `target_sources()`, or `target_include_directories()`.
    We’ll learn about those commands later, but for now, let’s take a closer look
    at what kind of targets we can define.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有定义目标的命令都要求将目标的名称作为第一个参数提供，以便在后续的命令中引用这些目标，诸如`target_link_libraries()`、`target_sources()`或`target_include_directories()`等命令都可以用到目标。我们稍后会学习这些命令，但现在，让我们仔细看看我们可以定义什么样的目标。
- en: Defining executable targets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可执行目标
- en: 'The command to define an executable target, `add_executable()`, is self-explanatory
    (we leaned on this fact and used it already in previous chapters). The formal
    structure looks like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 定义可执行目标的命令 `add_executable()` 不言自明（我们在前面的章节中已经依赖并使用了这个命令）。它的正式结构如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we’re compiling for Windows, by adding the optional argument, the `WIN32`
    keyword, we’ll produce an executable that won’t show the default console window
    (where we usually see the output streamed to `std::cout`). Instead, the application
    will be expected to generate its own GUI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 Windows 编译，通过添加可选参数 `WIN32` 关键字，我们将生成一个不会显示默认控制台窗口的可执行文件（通常我们可以在控制台窗口中看到输出流
    `std::cout`）。相反，应用程序将期望生成自己的图形用户界面（GUI）。
- en: The next optional argument, `MACOSX_BUNDLE`, is quite similar in a way; it makes
    the applications produced for macOS/iOS launchable from the Finder as GUI apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个可选参数`MACOSX_BUNDLE`在某种程度上类似；它使得为macOS/iOS生成的应用程序可以从Finder中启动，作为GUI应用程序。
- en: 'The `EXCLUDE_FROM_ALL` keyword, when used, will prevent the executable target
    from being built in a regular, default build. Such a target will have to be explicitly
    mentioned in the *build command*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXCLUDE_FROM_ALL`关键字在使用时，会阻止可执行目标在常规默认构建中被构建。这样的目标必须在*构建命令*中明确提到：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we’re expected to provide the list of sources that will be compiled
    into the target. The following extensions are supported:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提供将被编译成目标的源代码列表。支持以下扩展：
- en: 'For C: `c`, `m`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于C语言：`c`，`m`
- en: 'For C++: `C`, `M`, `c++`, `cc`, `cpp`, `cxx`, `m`, `mm`, `mpp`, `CPP`, `ixx`,
    `cppm`, `ccm`, `cxxm`, `c++m`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于C++语言：`C`，`M`，`c++`，`cc`，`cpp`，`cxx`，`m`，`mm`，`mpp`，`CPP`，`ixx`，`cppm`，`ccm`，`cxxm`，`c++m`
- en: Note that we’re not adding any **header files** to the sources list. That can
    be done either implicitly, by providing a path to the directory where those files
    are with the `target_include_directories()` command, or by using a `FILE_SET`
    feature of the `target_sources()` command (added in CMake 3.23). This is an important
    topic for executables, but since it’s complex and orthogonally related to targets,
    we’ll dive into its details in *Chapter 7*, *Compiling C++ Sources with CMake*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有将任何**头文件**添加到源代码列表中。这可以通过提供包含这些文件的目录路径给`target_include_directories()`命令来隐式完成，或者通过使用`target_sources()`命令的`FILE_SET`功能（在CMake
    3.23中新增）。这是可执行文件的重要话题，但由于其复杂且与目标相互独立，我们将在*第7章*，*使用CMake编译C++源代码*中深入探讨其细节。
- en: Defining library targets
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义库目标
- en: 'Defining the libraries is very similar to defining executables, but, of course,
    it doesn’t require keywords that define how GUI aspects will be handled. Here’s
    the signature of the command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 定义库与定义可执行文件非常相似，但当然，它不需要定义如何处理GUI方面的关键字。以下是该命令的签名：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Rules regarding the name, *exclusion from all*, and sources match the executable
    targets exactly. The only difference is in the `STATIC`, `SHARED`, and `MODULE`
    keywords. If you have any experience with libraries, you’ll know that these define
    what sort of artifact CMake will generate: statically linked libraries, shared
    (dynamic libraries), or modules. Again, it is quite a vast subject, which will
    be covered in depth in *Chapter 8*, *Linking Executables and Libraries*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于名称、*排除所有* 和源代码匹配可执行目标的规则完全一致。唯一的区别在于`STATIC`、`SHARED`和`MODULE`关键字。如果你有使用库的经验，你会知道这些关键字定义了CMake将生成哪种类型的构件：静态链接库、共享（动态）库或模块。再一次，这确实是一个庞大的话题，将在*第8章*，*链接可执行文件和库*中深入讲解。
- en: Custom targets
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义目标
- en: 'Custom targets are a bit different than executables or libraries. They extend
    the build functionality beyond what CMake provides out of the box by executing
    explicitly given command lines; for example, they can be used to:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标与可执行文件或库有所不同。它们通过执行明确给定的命令行，扩展了CMake默认提供的构建功能；例如，它们可以用于：
- en: Calculate the checksums of other binaries.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算其他二进制文件的校验和。
- en: Run the code sanitizer and collect the results.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行代码清理工具并收集结果。
- en: Send a compilation report to the metrics pipeline.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将编译报告发送到指标管道。
- en: As you can guess from this list, custom targets are only useful in quite advanced
    projects, so we’ll just cover the basics to move on to more important topics.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这个列表中可以猜到的，自定义目标仅在相当复杂的项目中有用，因此我们将仅介绍基本内容，继续深入更重要的主题。
- en: 'To define a custom target, use the following syntax (some options have been
    removed for brevity):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义目标时，使用以下语法（为了简洁，某些选项已被省略）：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Custom targets have certain drawbacks to consider. Since they involve shell
    commands, they can be system specific, potentially limiting portability. Additionally,
    custom targets may not provide a straightforward means for CMake to determine
    the specific artifacts or byproducts being generated, if any.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标有一些需要考虑的缺点。由于它们涉及Shell命令，可能是系统特定的，从而限制了可移植性。此外，自定义目标可能不会为CMake提供一种直接的方法来确定生成的具体构件或副产品（如果有的话）。
- en: Custom targets also don’t apply the staleness check like executables and libraries
    (they don’t verify whether the sources are newer than the binaries), because by
    default they’re not added to the **dependency graph** (so the `ALL` keyword works
    in opposite to `EXCLUDE_FROM_ALL`). Let’s find out what that dependency graph
    is about.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标与可执行文件和库不同，不会进行陈旧性检查（它们不会验证源文件是否比二进制文件更新），因为默认情况下，它们没有被添加到**依赖关系图**中（因此`ALL`关键字与`EXCLUDE_FROM_ALL`正好相反）。让我们来了解一下这个依赖关系图的内容。
- en: Dependency graph
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖关系图
- en: 'Mature applications are often built from many components, specifically, internal
    libraries. Partitioning the project is useful from a structural perspective. When
    related things are packaged together in a single logical entity, they can be linked
    with other targets: another library or an executable. This is especially convenient
    when multiple targets are using the same library. Take a look at *Figure 5.1*,
    which describes an exemplary dependency graph:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的应用程序通常由多个组件构建而成，特别是内部库。从结构角度来看，将项目进行划分是有用的。当相关的内容被打包成一个单一的逻辑实体时，它们可以与其他目标进行链接：另一个库或一个可执行文件。当多个目标使用相同的库时，这尤其方便。请看一下*图
    5.1*，它描述了一个示例性的依赖关系图：
- en: '![](img/B19844_05_01.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_05_01.png)'
- en: 'Figure 5.1: Order of building dependencies in the BankApp project'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：BankApp项目中依赖关系构建的顺序
- en: 'In this project, we have two libraries, two executables, and a custom target.
    Our use case here is to provide a banking application with a nice GUI for users
    (**GuiApp**) and a command-line version to be used as part of an automated script
    (**TerminalApp**). Both executables depend on the same **Calculations** library,
    but only one of them needs the **Drawing** library. To guarantee that our app’s
    binaries were downloaded from a genuine source, we’ll also calculate a checksum,
    and distribute it through separate secure channels. CMake is pretty flexible when
    it comes to writing listfiles for such a solution:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们有两个库、两个可执行文件和一个自定义目标。我们的用例是为用户提供一个带有良好图形界面的银行应用程序（**GuiApp**），以及一个命令行版本，作为自动化脚本的一部分（**TerminalApp**）。这两个可执行文件都依赖于相同的**Calculations**库，但只有其中一个需要**Drawing**库。为了确保我们的应用程序二进制文件是从可靠来源下载的，我们还会计算一个校验和，并通过单独的安全渠道分发它。CMake在为这样的解决方案编写list文件时非常灵活：
- en: '**ch05/01-targets/CMakeLists.txt**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch05/01-targets/CMakeLists.txt**'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We link our libraries with executables by using the `target_link_libraries()`
    command. Without it, the building of executables would fail because of undefined
    symbols. Have you noticed that we invoked this command before declaring any of
    the libraries? When CMake configures the project, it collects information about
    targets and their properties – their names, dependencies, source files, and other
    details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`target_link_libraries()`命令将我们的库与可执行文件链接。如果没有这个命令，生成可执行文件时将因为未定义的符号而失败。你有没有注意到我们在声明任何库之前就调用了这个命令？当CMake配置项目时，它会收集有关目标及其属性的信息——它们的名称、依赖关系、源文件以及其他细节。
- en: After parsing all the files, CMake will attempt to build a dependency graph.
    Like with all valid dependency graphs, they’re **Directed Acyclic Graph** (**DAGs**).
    This means that there is a clear direction of which target depends on which, and
    such dependencies cannot form cycles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析所有文件之后，CMake将尝试构建一个依赖关系图。像所有有效的依赖关系图一样，它们是**有向无环图**（**DAGs**）。这意味着有明确的方向，指示哪个目标依赖于哪个，且这些依赖关系不能形成循环。
- en: 'When we execute `cmake` in build mode, the generated buildsystem will check
    what top-level targets we have defined and recursively build their dependencies.
    Let’s consider our example from *Figure 5.1*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在构建模式下执行`cmake`时，生成的构建系统将检查我们定义了哪些顶级目标，并递归地构建它们的依赖关系。让我们考虑一下*图 5.1*中的示例：
- en: Start from the top and build both libraries in group 1.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部开始，构建第1组中的两个库。
- en: When the **Calculations** and **Drawing** libraries are complete, build group
    2 – **GuiApp** and **TerminalApp**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当**Calculations**和**Drawing**库构建完成后，构建第2组——**GuiApp**和**TerminalApp**。
- en: Build a checksum target; run specified command lines to generate checksums (`cksum`
    is a Unix checksum tool, which means that this example won’t build on other platforms).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个校验和目标；运行指定的命令行以生成校验和（`cksum`是一个Unix的校验和工具，这意味着该示例在其他平台上无法构建）。
- en: 'There’s a slight issue, though – the preceding solution doesn’t guarantee that
    a checksum target will be built after the executables. CMake doesn’t know that
    a checksum depends on the executable binaries being present, so it’s free to start
    building it first. To resolve this problem, we can put the `add_dependencies()`
    command at the end of the file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个小问题——上述解决方案并不能保证校验和目标在可执行文件之后构建。CMake不知道校验和依赖于可执行二进制文件的存在，因此它可以自由地先开始构建校验和。为了解决这个问题，我们可以将`add_dependencies()`命令放在文件的最后：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will ensure that CMake understands the relationship between the checksum
    target and the executables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保CMake理解校验和目标与可执行文件之间的关系。
- en: That’s great, but what’s the difference between `target_link_libraries()` and
    `add_dependencies()`? `target_link_libraries()` is intended to be used with actual
    libraries and allows you to control property propagation. The second is meant
    to be used only with top-level targets to set their build order.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但`target_link_libraries()`和`add_dependencies()`之间有什么区别？`target_link_libraries()`是用来与实际库配合使用的，并允许你控制属性传播。第二个则仅用于顶级目标，用来设置它们的构建顺序。
- en: As projects grow in complexity, the dependency tree gets harder to understand.
    How can we simplify this process?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目复杂度的增加，依赖树变得越来越难以理解。我们如何简化这个过程？
- en: Visualizing dependencies
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化依赖关系
- en: Even small projects can be difficult to reason about and share with other developers.
    A neat diagram will go a long way here. After all, a picture is worth a thousand
    words. We can do the work and draw a diagram ourselves, just like I did in *Figure
    5.1*. But this is tedious and requires updates whenever the project changes. Luckily,
    CMake has a great module to generate dependency graphs in the `dot/graphviz` format,
    and it supports both internal and external dependencies!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是小型项目也可能很难理解并与其他开发人员共享。一个简洁的图表在这里会大有帮助。毕竟，一图胜千言。我们可以像我在*图 5.1*中做的那样，自己动手绘制图表。但这既繁琐又需要在项目变动时更新。幸运的是，CMake有一个很棒的模块，可以生成`dot/graphviz`格式的依赖图，并且它支持内部和外部依赖！
- en: 'To use it, we can simply execute this command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们可以简单地执行以下命令：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The module will produce a text file that we can import to the Graphviz visualization
    software, which can render an image or produce a PDF or SVG file that can be stored
    as part of the software documentation. Everybody loves great documentation, but
    hardly anyone likes to create it – now, you don’t need to!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将生成一个文本文件，我们可以将其导入到Graphviz可视化软件中，Graphviz可以渲染图像或生成PDF或SVG文件，这些文件可以作为软件文档的一部分存储。每个人都喜欢出色的文档，但几乎没有人喜欢创建它——现在，你不需要做这件事了！
- en: 'Custom targets are not visible by default and we need to create a special configuration
    file, `CMakeGraphVizOptions.cmake`, that will allow us to customize the graph.
    Use the `set(GRAPHVIZ_CUSTOM_TARGETS TRUE)` command to enable custom targets in
    your graph:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标默认不可见，我们需要创建一个特殊的配置文件`CMakeGraphVizOptions.cmake`，它将允许我们自定义图形。使用`set(GRAPHVIZ_CUSTOM_TARGETS
    TRUE)`命令可以在图形中启用自定义目标：
- en: '**ch05/01-targets/CMakeGraphVizOptions.cmake**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch05/01-targets/CMakeGraphVizOptions.cmake**'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other options allow the addition of a graph name, a header, and node prefixes
    and configure which targets should be included or excluded from the output (by
    name or type). Visit the official CMake documentation for the `CMakeGraphVizOptions`
    full description of this module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项允许添加图表名称、标题和节点前缀，并配置哪些目标应包含或排除在输出中（按名称或类型）。有关`CMakeGraphVizOptions`模块的完整描述，请访问官方的CMake文档。
- en: 'If you’re in a rush, you can even run Graphviz straight from your browser at
    this address: [https://dreampuf.github.io/GraphvizOnline/](https://dreampuf.github.io/GraphvizOnline/).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很着急，你甚至可以直接通过浏览器在这个地址运行Graphviz：[https://dreampuf.github.io/GraphvizOnline/](https://dreampuf.github.io/GraphvizOnline/)。
- en: All you need to do is copy and paste the contents of the `test.dot` file into
    the window on the left and your project will be visualized (*Figure 5.2*). Quite
    convenient, isn’t it?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你所需要做的就是将`test.dot`文件的内容复制并粘贴到左侧窗口，你的项目就会被可视化（*图 5.2*）。很方便，不是吗？
- en: '![](img/B19844_05_02.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_05_02.png)'
- en: 'Figure 5.2: A visualization of the BankApp example in Graphviz'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：BankApp示例在Graphviz中的可视化
- en: Using this method, we can quickly see all the explicitly defined targets.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以快速查看所有显式定义的目标。
- en: Now that we understand the concept of a target, we know how to define different
    types of targets, including executables, libraries, and custom targets, as well
    as how to create a dependency graph and print it. Let’s use this information to
    do a deeper dive and see how to configure them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了目标的概念，知道如何定义不同类型的目标，包括可执行文件、库和自定义目标，以及如何创建依赖图并将其打印出来。让我们利用这些信息深入探讨，看看如何配置这些目标。
- en: Setting properties of targets
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置目标属性
- en: 'Targets have properties that work in a similar way to fields of C++ objects.
    Some of these properties are meant to be modified, and some are read only. CMake
    defines a large list of “known properties” (see the *Further reading* section)
    that are available depending on the type of the target (executable, library, or
    custom). You can also add your own properties if you like. Use the following commands
    to manipulate the properties of a target:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目标具有类似于 C++ 对象字段的属性。这些属性中有些是可以修改的，有些则是只读的。CMake 定义了一个庞大的“已知属性”列表（见 *进一步阅读* 部分），根据目标的类型（可执行文件、库或自定义目标），可以使用不同的属性。你也可以根据需要添加自己的属性。使用以下命令来操作目标的属性：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To print a target property on the screen, we first need to store it in the `<var>`
    variable and then message itto the user. Reading of the properties has to be done
    one by one; setting properties on a target allows us to specify multiple properties
    at the same time, on multiple targets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上打印目标属性，我们首先需要将其存储在 `<var>` 变量中，然后通过消息将其传递给用户。属性的读取必须逐一进行；而在目标上设置属性时，可以同时为多个目标指定多个属性。
- en: 'The concept of properties isn’t unique to targets; CMake supports setting properties
    of other scopes as well: `GLOBAL`, `DIRECTORY`, `SOURCE`, `INSTALL`, `TEST`, and
    `CACHE`. To manipulate all kinds of properties, there are general `get_property()`
    and `set_property()` commands. In some projects, you’ll see these low-level commands
    used to do exactly what the `set_target_properties()` command does, just with
    a bit more work:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的概念并非目标独有；CMake 还支持设置其他作用域的属性：`GLOBAL`、`DIRECTORY`、`SOURCE`、`INSTALL`、`TEST`
    和 `CACHE`。要操作各种属性，可以使用通用的 `get_property()` 和 `set_property()` 命令。在某些项目中，你会看到这些低级命令用于执行
    `set_target_properties()` 命令所做的事情，只是工作量稍大一些：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Generally, it’s better to use as many high-level commands as you can. In some
    cases, CMake offers short-hand commands that come with additional mechanisms.
    For example, `add_dependencies(<target> <dep>)` is a shorthand for appending dependencies
    to the `MANUALLY_ADDED_DEPENDENCIES` target property. In this case, we can query
    it with `get_target_property()` exactly as with any other property. However, we
    can’t use `set_target_properties()` to change it (it’s read only), as CMake insists
    on using the `add_dependencies()` command to restrict operations to appending
    only.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，尽量使用尽可能多的高级命令。在某些情况下，CMake 提供了简写命令，并附带了额外的机制。例如，`add_dependencies(<target>
    <dep>)` 是一个简写，用于将依赖项添加到 `MANUALLY_ADDED_DEPENDENCIES` 目标属性中。在这种情况下，我们可以像查询任何其他属性一样使用
    `get_target_property()` 查询它。然而，我们不能使用 `set_target_properties()` 来修改它（它是只读的），因为
    CMake 坚持使用 `add_dependencies()` 命令来限制操作只能是附加依赖项。
- en: We’ll introduce more property-setting commands when we discuss compiling and
    linking in upcoming chapters. Meanwhile, let’s focus on how the properties of
    one target can be carried over to another.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在接下来的章节中讨论编译和链接时，我们会介绍更多的属性设置命令。与此同时，让我们专注于如何将一个目标的属性传递给另一个目标。
- en: What are Transitive Usage Requirements?
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是传递性使用要求？
- en: Let’s just agree that naming is hard, and sometimes one ends up with a label
    that’s difficult to understand. “Transitive Usage Requirements” is, unfortunately,
    one of those cryptic titles that you will encounter in the online CMake documentation.
    Let’s untangle this strange name and perhaps propose a term that is easier to
    understand.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们达成共识，命名确实很难，有时最终会得到一个难以理解的标签。“传递性使用要求”不幸地就是你在 CMake 在线文档中会遇到的那些难以理解的标题之一。让我们拆解一下这个奇怪的名字，并尝试提出一个更容易理解的术语。
- en: 'Starting from the middle term: **Usage**. As we previously discussed, one target
    may depend on another. CMake documentation sometimes refers to such dependency
    as **usage**, as in one target *uses* another.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从中间术语开始：**使用**。正如我们之前讨论的，一个目标可能依赖于另一个目标。CMake 文档有时将这种依赖关系称为 **使用**，就像一个目标*使用*另一个目标一样。
- en: 'There will be cases when such a *used target* sets specific *properties* or
    *dependencies* for itself, which, in turn, constitute **requirements** for *other
    targets* that use it: link some libraries, include a directory, or require specific
    compiler features.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 会有这样的情况：当某个*被使用的目标*为自己设置了特定的*属性*或*依赖*，这些属性或依赖反过来成为*使用该目标的其他目标*的**需求**：链接一些库，包含一个目录，或者需要特定的编译器特性。
- en: The last part of our puzzle, **transitive**, describes the behavior correctly
    (maybe could be a bit simpler). CMake appends some properties/requirements of
    *used targets* to properties of *using targets*. You can say that some properties
    can transition (or simply propagate) across targets implicitly, so it’s easier
    to express dependencies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们难题的最后一部分，**传递性**，正确描述了行为（可能可以简化一点）。CMake将*被使用目标*的一些属性/需求附加到*使用目标*的属性中。可以说，一些属性可以隐式地在目标之间传递（或者简单地传播），因此更容易表达依赖关系。
- en: Simplifying this whole concept, I see it as **propagated properties** between
    the **source target** (targets that get used) and **destination targets** (targets
    that use other targets).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 简化这个概念，我将其视为**传播的属性**，它们在**源目标**（被使用的目标）和**目标使用者**（使用其他目标的目标）之间传播。
- en: 'Let’s look at a concrete example to understand why it’s there and how it works:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来理解它为什么存在以及它是如何工作的：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This target command will populate the `COMPILE_DEFINITIONS` property of a `<source>`
    target. **Compile definitions** are simply `-Dname=definition` flags passed to
    the compiler that configure the C++ preprocessor definitions (we’ll get to that
    in *Chapter 7*, *Compiling C++ Sources with CMake*). The interesting part here
    is the second argument. We need to specify one of three values, `INTERFACE`, `PUBLIC`,
    or `PRIVATE`, to control which targets the property should be passed to. Now,
    don’t confuse these with C++ access specifiers – this is a separate concept in
    its own right.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目标命令将填充`COMPILE_DEFINITIONS`属性到一个`<source>`目标中。**编译定义**就是传递给编译器的`-Dname=definition`标志，用于配置C++预处理器定义（我们将在*第七章*，*使用CMake编译C++源代码*中详细讲解）。这里有趣的部分是第二个参数。我们需要指定三个值中的一个，`INTERFACE`、`PUBLIC`或`PRIVATE`，来控制该属性应该传递给哪些目标。现在，别把这些和C++的访问控制符混淆——这是一个独立的概念。
- en: 'Propagation keywords work like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 传播关键字是这样工作的：
- en: '`PRIVATE` sets the property of the source target.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE`设置源目标的属性。'
- en: '`INTERFACE` sets the property of the destination targets.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE`设置目标使用者的属性。'
- en: '`PUBLIC` sets the property of the source and destination targets.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC`设置源目标和目标使用者的属性。'
- en: When a property is not to be transitioned to any destination targets, set it
    to `PRIVATE`. When such a transition is needed, go with `PUBLIC`. If you’re in
    a situation where the source target doesn’t use the property in its implementation
    (`.cpp` files) and only in the headers, and these are passed to the consumer targets,
    `INTERFACE` is the keyword to use.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个属性不需要传递给任何目标时，设置为`PRIVATE`。当需要进行这样的传递时，使用`PUBLIC`。如果你处在一种情况，源目标在其实现（`.cpp`文件）中并不使用该属性，而只在头文件中使用，并且这些头文件被传递给消费者目标，那么应该使用`INTERFACE`关键字。
- en: How does this work under the hood? To manage those properties, CMake provides
    a few commands such as the aforementioned `target_compile_definitions()`. When
    you specify a `PRIVATE` or `PUBLIC` keyword, CMake will store provided values
    in the property of the target, in this case, `COMPILE_DEFINITIONS`. Additionally,
    if a keyword is `INTERFACE` or `PUBLIC`, it will store the value in a property
    with an `INTERFACE_` prefix – `INTERFACE_COMPILE_DEFINITIONS`. During the configuration
    stage, CMake will read the interface properties of source targets and append their
    contents to destination targets. There you have it – propagated properties, or
    Transitive Usage Requirements, as CMake calls them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这在背后是如何工作的呢？为了管理这些属性，CMake提供了一些命令，比如前面提到的`target_compile_definitions()`。当你指定`PRIVATE`或`PUBLIC`关键字时，CMake会将提供的值存储到目标的属性中，在这个例子中是`COMPILE_DEFINITIONS`。此外，如果关键字是`INTERFACE`或`PUBLIC`，CMake会将值存储到带有`INTERFACE_`前缀的属性中——`INTERFACE_COMPILE_DEFINITIONS`。在配置阶段，CMake会读取源目标的接口属性，并将它们的内容附加到目标使用者上。就是这样——传播的属性，或者CMake所称的传递性使用需求。
- en: 'Properties managed with the `set_target_properties()` command can be found
    at [https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html),
    in the *Properties on Targets* section (not all target properties are transitive).
    Here are the most important ones:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set_target_properties()`命令管理的属性可以在[https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html)中找到，位于*目标上的属性*部分（并非所有目标属性都是传递性的）。以下是最重要的属性：
- en: '`COMPILE_DEFINITIONS`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_DEFINITIONS`'
- en: '`COMPILE_FEATURES`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_FEATURES`'
- en: '`COMPILE_OPTIONS`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPILE_OPTIONS`'
- en: '`INCLUDE_DIRECTORIES`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCLUDE_DIRECTORIES`'
- en: '`LINK_DEPENDS`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_DEPENDS`'
- en: '`LINK_DIRECTORIES`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_DIRECTORIES`'
- en: '`LINK_LIBRARIES`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_LIBRARIES`'
- en: '`LINK_OPTIONS`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_OPTIONS`'
- en: '`POSITION_INDEPENDENT_CODE`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSITION_INDEPENDENT_CODE`'
- en: '`PRECOMPILE_HEADERS`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRECOMPILE_HEADERS`'
- en: '`SOURCES`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOURCES`'
- en: 'We’ll discuss most of these options in the following pages, but remember that
    all of these options are, of course, described in the CMake manual. Find them
    described in detail at the following link (replace `<PROPERTY>` with a property
    that interests you): `https://cmake.org/cmake/help/latest/prop_tgt/<PROPERTY>.html`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几页中讨论这些选项，但请记住，所有这些选项当然在 CMake 手册中有详细描述。你可以通过以下链接找到它们的详细描述（将`<PROPERTY>`替换为你感兴趣的属性）：`https://cmake.org/cmake/help/latest/prop_tgt/<PROPERTY>.html`
- en: The next question that comes to mind is how far this propagation goes. Are the
    properties set just on the first destination target, or are they sent to the very
    top of the dependency graph? You get to decide.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是，这种传播会传播多远？属性只会设置到第一个目标目标，还是会传播到依赖图的最顶端？你可以自行决定。
- en: 'To create a dependency between targets, we use the `target_link_libraries()`
    command. The full signature of this command requires a propagation keyword:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在目标之间创建依赖关系，我们使用`target_link_libraries()`命令。这个命令的完整签名需要一个传播关键字：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, this signature also specifies a propagation keyword, and it
    controls how properties from the *source target* get stored in the *destination
    target*. *Figure 5.3* shows what happens to a propagated property during the generation
    stage (after the configuration stage is completed):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个签名还指定了一个传播关键字，它控制属性如何从*源目标*存储到*目标目标*。*图 5.3* 展示了在生成阶段（配置阶段完成后）传播的属性会发生什么：
- en: '![](img/B19844_05_03.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_05_03.png)'
- en: 'Figure 5.3: How properties are propagated to destination targets'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：属性如何传播到目标目标
- en: 'Propagation keywords work like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 传播关键字的工作方式如下：
- en: '`PRIVATE` appends the source value to the **private** property of the *source
    target*.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE` 将源值追加到*源目标*的**私有**属性中。'
- en: '`INTERFACE` appends the source value to the **interface** property of the *source
    target*.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE` 将源值追加到*源目标*的**接口**属性中。'
- en: '`PUBLIC` appends to both properties of the *source target*.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC` 会将值追加到*源目标*的两个属性中。'
- en: As we discussed before, interface properties are only used to propagate the
    properties further down the chain (to the next *destination target*), and the
    *source target* won’t use them in its build process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，接口属性仅用于进一步传播属性到链条下游（到下一个*目标目标*），而*源目标*在其构建过程中不会使用这些属性。
- en: The basic `target_link_libraries(<target> <item>...)` command that we used before
    implicitly specifies the `PUBLIC` keyword.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的基本命令`target_link_libraries(<target> <item>...)`隐式指定了`PUBLIC`关键字。
- en: If you correctly set propagation keywords for your source targets, properties
    will be automatically placed on destination targets for you – unless there’s a
    conflict…
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确设置了源目标的传播关键字，属性将自动被放置到目标目标上，除非出现冲突……
- en: Dealing with conflicting propagated properties
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理冲突的传播属性
- en: 'When one target depends on multiple other targets, there may be a situation
    where propagated properties are in outright conflict with each other. Say that
    one used target specifies the `POSITION_INDEPENDENT_CODE` property as `true` and
    the other as `false`. CMake understands this as a conflict and will print an error
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个目标依赖于多个其他目标时，可能会出现传播的属性相互冲突的情况。比如一个使用的目标指定了`POSITION_INDEPENDENT_CODE`属性为`true`，而另一个则为`false`。CMake
    会理解为冲突，并打印出类似以下的错误信息：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is useful to receive such a message, as we explicitly know that we introduced
    this conflict, and we need to resolve it. CMake has its own properties that must
    “agree” between source and destination targets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到这样的消息是有用的，因为我们明确知道是我们引入了这个冲突，需要解决它。CMake 有自己的属性，这些属性必须在源目标和目标目标之间“一致”。
- en: On rare occasions, this may become important – for example, if you’re building
    software using the same library in multiple targets that are then linked to a
    single executable. If these source targets are using different versions of the
    same library, you may run into problems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，这可能变得很重要——例如，如果你在多个目标中使用同一个库，然后将它们链接到一个单一的可执行文件。如果这些源目标使用的是不同版本的同一个库，你可能会遇到问题。
- en: To make sure that we’re only using the same specific version, we can create
    a custom interface property, `INTERFACE_LIB_VERSION`, and store the version there.
    This is not enough to solve the problem, as CMake won’t propagate custom properties
    by default (this mechanism works only on built-in target properties). We must
    explicitly add a custom property to a list of “compatible” properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保我们只使用相同的特定版本，我们可以创建一个自定义接口属性`INTERFACE_LIB_VERSION`，并将版本存储在其中。但这还不足以解决问题，因为CMake默认不会传播自定义属性（该机制仅适用于内建目标属性）。我们必须显式地将自定义属性添加到“兼容”属性列表中。
- en: 'Each target has four such lists:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目标都有四个这样的列表：
- en: '`COMPATIBLE_INTERFACE_BOOL`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_BOOL`'
- en: '`COMPATIBLE_INTERFACE_STRING`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_STRING`'
- en: '`COMPATIBLE_INTERFACE_NUMBER_MAX`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_NUMBER_MAX`'
- en: '`COMPATIBLE_INTERFACE_NUMBER_MIN`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPATIBLE_INTERFACE_NUMBER_MIN`'
- en: Appending your property to one of them will trigger propagation and compatibility
    checks. The `BOOL` list will check whether all properties propagated to the destination
    target evaluate to the same Boolean value. Analogically, `STRING` will evaluate
    to a string. `NUMBER_MAX` and `NUMBER_MIN` are a bit different – propagated values
    don’t have to match, but the destination target will just receive the highest
    or the lowest value instead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的属性添加到其中之一会触发传播和兼容性检查。`BOOL`列表将检查所有传播到目标目标的属性是否评估为相同的布尔值。类似地，`STRING`将评估为字符串。`NUMBER_MAX`和`NUMBER_MIN`略有不同——传播的值不必完全匹配，但目标目标将接收最高或最低的值。
- en: 'This example will help us understand how to apply this in practice:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将帮助我们理解如何在实践中应用这一点：
- en: '**ch05/02-propagated/CMakeLists.txt**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch05/02-propagated/CMakeLists.txt**'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create three targets here; for simplicity, all are using the same empty source
    file. On both *source targets*, we specify our custom property with the `INTERFACE_`
    prefix, and we set them to the same matching library version. Both *source targets*
    are linked to the destination target. Finally, we specify a `STRING` compatibility
    requirement as a property for `source1` (we don’t add the `INTERFACE_` prefix
    here).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了三个目标；为了简化起见，所有目标都使用相同的空源文件。在两个*源目标*上，我们指定了带有`INTERFACE_`前缀的自定义属性，并将它们设置为相同的匹配库版本。这两个*源目标*都链接到目标目标。最后，我们为`source1`指定了一个`STRING`兼容性要求作为属性（这里没有加`INTERFACE_`前缀）。
- en: CMake will propagate this custom property to the *destination target* and check
    whether the version of all the source targets is an exact match (the compatibility
    property can be set on just one target).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会将这个自定义属性传播到*目标目标*，并检查所有源目标的版本是否完全匹配（兼容性属性可以只设置在一个目标上）。
- en: Now that we understand what regular targets are, let’s take a look at other
    things that look like targets, smell like targets, and sometimes act like targets
    but, as it turns out, aren’t the real deal.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了常规目标是什么，让我们来看一看那些看起来像目标、闻起来像目标、有时也像目标但实际上并不是目标的其他事物。
- en: Meet the pseudo targets
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识伪目标
- en: 'The concept of a target is so useful that it would be great if some of its
    behaviors could be borrowed for other things too; ones that do not represent outputs
    of the buildsystem but rather inputs – external dependencies, aliases, and so
    on. These are the pseudo targets, or targets that don’t make it to the generated
    buildsystem:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目标的概念非常有用，如果它的一些行为可以借用到其他地方，那就更好了；这些地方并不代表构建系统的输出，而是输入——外部依赖、别名等。这些就是伪目标，或者说是那些没有进入生成的构建系统的目标：
- en: Imported targets
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入目标
- en: Alias targets
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名目标
- en: Interface libraries
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口库
- en: Let’s take a look.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一下。
- en: Imported targets
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入目标
- en: If you skimmed the table of contents of this book, you know that we’ll be talking
    about how CMake manages external dependencies – other projects, libraries, and
    so on. `IMPORTED` targets are essentially products of this process. CMake can
    define them as a result of the `find_package()` command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览过本书的目录，你就会知道我们将讨论CMake如何管理外部依赖——其他项目、库等等。`IMPORTED`目标本质上是这个过程的产物。CMake可以通过`find_package()`命令定义它们。
- en: 'You can adjust the target properties of such a target: **compile definitions**,
    **compile** **options**, **include directories**, and so on – and they will even
    support Transitive Usage Requirements. However, you should treat them as immutable;
    don’t change their sources or dependencies.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整这种目标的目标属性：**编译定义**、**编译** **选项**、**包含目录**等——它们甚至支持传递性使用要求。然而，你应该将它们视为不可变的；不要更改它们的源代码或依赖关系。
- en: The scope of the definition of an `IMPORTED` target can be global or local to
    the directory where it was defined (visible in subdirectories but not in parent
    directories).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMPORTED`目标的定义范围可以是全局的，也可以是局部的，即只在定义该目标的目录中可见（在子目录中可见，但在父目录中不可见）。'
- en: Alias targets
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名目标
- en: 'Alias targets do exactly what you expect – they create another reference to
    a target under a different name. You can create alias targets for executables
    and libraries with the following commands:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 别名目标正如你所期待的那样——它们创建了一个不同名称的目标引用。你可以使用以下命令为可执行文件和库创建别名目标：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Properties of alias targets are read only, and you cannot install or export
    aliases (they aren’t visible in the generated buildsystem).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 别名目标的属性是只读的，不能安装或导出别名（它们在生成的构建系统中不可见）。
- en: So, what is the reason to have aliases at all? They come in handy in scenarios
    where some part of a project (such as a subdirectory) requires a target with a
    specific name, and the actual implementation may be available under different
    names depending on circumstances. For example, you may wish to build a library
    shipped with your solution or import it based on a user’s choice.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用别名呢？它们在项目的某些部分（例如子目录）需要一个特定名称的目标，而实际的实现可能会根据情况以不同的名称出现时非常有用。例如，你可能希望构建一个与你的解决方案一起提供的库，或者根据用户的选择导入它。
- en: Interface libraries
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口库
- en: This is an interesting construct – a library that doesn’t compile anything but
    instead serves as a utility target. Its whole concept is built around propagated
    properties (Transitive Usage Requirements).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的构造——一个不编译任何东西，而是作为一个工具目标的库。它的整个概念是围绕传播的属性（传递性使用要求）构建的。
- en: Interface libraries have two primary uses – to represent header-only libraries,
    and to bundle a bunch of propagated properties into a single logical unit.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接口库有两个主要用途——表示仅包含头文件的库，以及将一堆传播的属性捆绑成一个逻辑单元。
- en: 'Header-only libraries are fairly easy to create with `add_library(INTERFACE)`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_library(INTERFACE)`创建仅包含头文件的库非常简单：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To use such a library, we just must link it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这样的库，我们只需要链接它：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: No actual linking occurs here, but CMake will understand this command as a request
    to propagate all the `INTERFACE` properties to the `executable` target.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不会发生实际的链接，但CMake会将此命令理解为要求将所有`INTERFACE`属性传播到`executable`目标。
- en: 'The second use case leverages exactly the same mechanism but for a different
    purpose – it creates a logical target that can be a placeholder for propagated
    properties. We can then use this target as a dependency for other targets and
    set properties in a clean, convenient way. Here’s an example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种用法完全利用相同的机制，但目的是不同的——它创建一个逻辑目标，可以作为传播属性的占位符。然后，我们可以将这个目标作为其他目标的依赖，并以干净、方便的方式设置属性。这里是一个例子：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `add_library(INTERFACE)` command creates a logical `warning_properties`
    target that is used to set **compile options** specified in the second command
    on the `executable` target. I recommend using these `INTERFACE` targets, as they
    improve the readability and reusability of your code. Think of it as refactoring
    a bunch of magic values to a well-named variable. I also suggest explicitly adding
    a suffix like `_properties` to easily differentiate interface libraries from the
    regular ones.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_library(INTERFACE)`命令创建一个逻辑的`warning_properties`目标，用于设置第二个命令中指定的**编译选项**，应用于`executable`目标。我推荐使用这些`INTERFACE`目标，因为它们提高了代码的可读性和可重用性。可以将其视为将一堆魔法值重构为一个命名良好的变量。我还建议明确地添加一个后缀，如`_properties`，以便轻松区分接口库和常规库。'
- en: Object libraries
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标库
- en: '*Object libraries* are used to group multiple source files under a single logical
    target and are compile them into (`.o`) *object files* during a build. To create
    an *object library*, we follow the same method as with other libraries, but with
    the `OBJECT` keyword:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标库*用于将多个源文件归为一个逻辑目标，并在构建过程中将它们编译成（`.o`）*目标文件*。创建*目标库*的方法与其他库相同，只不过使用`OBJECT`关键字：'
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Object files* produced during the build can be incorporated as compiled elements
    to other targets with the `$<TARGET_OBJECTS:objlib>` generator expression:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中生成的*目标文件*可以通过`$<TARGET_OBJECTS:objlib>`生成表达式作为编译元素并入到其他目标中：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Alternatively, you can add them as dependencies with the `target_link_libraries()`
    command.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用`target_link_libraries()`命令将它们作为依赖项添加。
- en: In the context of our `Calc` library, *object libraries* will be useful to avoid
    redundant compilation of library sources for the static and shared versions of
    the library. It’s essential to explicitly compile the *object files* with `POSITION_INDEPENDENT_CODE`
    enabled, a prerequisite for shared libraries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`Calc`库的上下文中，*目标库*将有助于避免为静态和共享版本的库重复编译库源文件。显式编译*目标文件*并启用`POSITION_INDEPENDENT_CODE`是共享库的先决条件。
- en: 'Returning to the project’s targets: `calc_obj` will supply compiled *object
    files*, which then will be used for both the `calc_static` and `calc_shared` libraries.
    Let’s explore the practical distinctions between these two types of libraries
    and understand why one might opt to create both.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 回到项目的目标：`calc_obj`将提供编译好的*目标文件*，然后它们将用于`calc_static`和`calc_shared`库。让我们探讨这两种库类型之间的实际区别，并理解为什么有时需要同时创建这两种类型。
- en: Are pseudo targets exhausting the concept of the target? Of course not! That
    would simply be too easy. We still need to understand how these targets are then
    used to generate buildsystems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 伪目标是否已经穷尽了目标的概念？当然没有！那样就太简单了。我们仍然需要理解这些目标是如何用来生成构建系统的。
- en: Build targets
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建目标
- en: The term “target” can have different meanings depending on the context within
    a project and the generated buildsystems. In the context of generating a buildsystem,
    CMake “compiles” the listfiles written in the CMake language into the language
    of the selected build tool, such as creating a Makefile for GNU Make. These generated
    Makefiles have their own set of targets. Some of these targets are direct conversions
    of the targets defined in the listfiles, while others are created implicitly as
    part of the buildsystem generation process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: “目标”这个术语可以根据项目中的上下文和生成的构建系统的不同而有不同的含义。在生成构建系统的上下文中，CMake将用CMake语言编写的列表文件“编译”成所选构建工具的语言，例如为GNU
    Make创建一个Makefile。这些生成的Makefile有自己的目标集合。部分目标是从列表文件中定义的目标直接转换而来，而其他目标则是作为构建系统生成过程的一部分隐式创建的。
- en: One such buildsystem target is `ALL`, which CMake generates by default to contain
    all top-level listfile targets, such as executables and libraries (not necessarily
    custom targets). `ALL` is built when we run `cmake --build <build tree>` without
    choosing any specific target. As you might remember from the first chapter, you
    can choose one by adding the `--target <name>` parameter to the `cmake` build
    command.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的构建系统目标是`ALL`，这是CMake默认生成的，包含所有顶级列表文件目标，例如可执行文件和库（不一定是自定义目标）。当我们运行`cmake
    --build <build tree>`而不选择任何特定目标时，`ALL`会被构建。正如你在第一章中可能记得的，你可以通过在`cmake`构建命令中添加`--target
    <name>`参数来选择一个目标。
- en: 'Some executables or libraries might not be needed in every build, but we’d
    like to keep them as part of the project for those rare occasions when they come
    in useful. To optimize our default build, we can exclude them from the `ALL` target
    like so:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有些可执行文件或库在每次构建中可能都不需要，但我们希望它们作为项目的一部分保留，以备在少数需要时使用。为了优化我们的默认构建，我们可以像这样将它们从`ALL`目标中排除：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Custom targets work the other way around – by default, they’re excluded from
    the `ALL` target unless you explicitly add them with an `ALL` keyword, as we did
    in the BankApp example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义目标的工作方式正好相反——默认情况下，它们会被排除在`ALL`目标之外，除非你显式地使用`ALL`关键字将它们添加进去，就像我们在BankApp示例中所做的那样。
- en: Another implicitly defined build target is `clean`, which simply removes produced
    artifacts from the build tree. We use it to get rid of all old files and build
    everything from scratch. It’s important, though, to understand that it doesn’t
    just simply delete everything in the build directory. For `clean` to work correctly,
    you need to manually specify any files that your custom targets might create as
    `BYPRODUCTS` (see the BankApp example).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个隐式定义的构建目标是`clean`，它简单地从构建树中移除生成的产物。我们使用它来删除所有旧文件并从头开始构建。然而，重要的是要理解，它并不只是简单地删除构建目录中的所有内容。为了让`clean`正确工作，你需要手动指定你的自定义目标可能会创建的任何文件作为`BYPRODUCTS`（见BankApp示例）。
- en: 'This concludes our journey through targets and their different aspects: we
    know how to create them, configure their properties, use pseudo targets, and decide
    whether they should be built by default or not. There’s also an interesting non-target
    mechanism to create custom artifacts that can be used in all actual targets –
    **custom commands** (not to be confused with **custom targets**).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们探索目标及其不同方面的总结：我们知道如何创建目标，配置其属性，使用伪目标，并决定它们是否应该默认构建。此外，还有一种有趣的非目标机制，用于创建可以在所有实际目标中使用的自定义工件——**自定义命令**（不要与**自定义目标**混淆）。
- en: Writing custom commands
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义命令
- en: 'Using custom targets has one drawback – as soon as you add them to the `ALL`
    target or start depending on them for other targets, they will be built every
    single time. Sometimes, this is what you want, but there are cases when custom
    behavior is necessary to produce files that shouldn’t be recreated without reason:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义目标有一个缺点——一旦将它们添加到`ALL`目标中，或者让其他目标依赖它们，它们就会每次都被构建。有时，这是你想要的效果，但也有些情况下，出于某些原因，有必要生成不应被重新创建的文件，此时需要自定义行为：
- en: Generating a source code file that another target depends on
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成另一个目标依赖的源代码文件
- en: Translating another language into C++
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将另一种语言翻译成C++
- en: Executing a custom action immediately before or after another target was built
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个目标构建之前或之后立即执行自定义操作
- en: 'There are two signatures for a custom command. The first one is an extended
    version of `add_custom_target()`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义命令有两个签名，第一个是`add_custom_target()`的扩展版本：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you might have guessed, a custom command doesn’t create a logical target,
    but just like custom targets, it has to be added to a dependency graph. There
    are two ways of doing that – using its output artifact as a source for an executable
    (or library), or explicitly adding it to a `DEPENDS` list for a custom target.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，自定义命令并不会创建一个逻辑目标，但和自定义目标一样，它必须被添加到依赖图中。这样做有两种方式——将其输出的工件作为可执行文件（或库）的源，或者显式地将其添加到自定义目标的`DEPENDS`列表中。
- en: Using a custom command as a generator
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义命令作为生成器
- en: Admittedly, not every project needs to generate C++ code from other files. One
    such occasion might be a compilation of **Google’s Protocol Buffer’s** (**Protobuf’s**)
    `.proto` files. If you’re not familiar with this library, Protobuf is a platform-neutral
    binary serializer for structured data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，并不是每个项目都需要从其他文件生成C++代码。一个这样的情况可能是**Google的协议缓冲区**（**Protobuf**）的`.proto`文件编译。如果你不熟悉这个库，Protobuf是一个平台中立的二进制序列化工具，用于结构化数据。
- en: 'In other words: it can be used to encode objects to and from binary streams:
    files or network connections. To keep Protobuf cross-platform and fast at the
    same time, Google’s engineers invented their own Protobuf language that defines
    models in `.proto` files, such as this one:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：它可以用于在二进制流中编码对象：文件或网络连接。为了保持Protobuf的跨平台性和快速性，Google的工程师发明了他们自己的Protobuf语言，该语言在`.proto`文件中定义模型，如下所示：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Such a file can be then used to encode data in multiple languages – C++, Ruby,
    Go, Python, Java, and so on. Google provides a compiler, `protoc`, that reads
    `.proto` files and outputs structure and serialization source code valid for the
    chosen language (that later needs to be compiled or interpreted). Smart engineers
    don’t check those generated source files into a repository but will use the original
    Protobuf format and add a step to generate the source files to the build chain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的文件可以用于在多种语言中编码数据——C++、Ruby、Go、Python、Java等。Google提供了一个编译器`protoc`，它读取`.proto`文件，并输出针对所选语言的结构和序列化源代码（稍后需要编译或解释）。聪明的工程师不会将这些生成的源文件提交到版本库，而是会使用原始的Protobuf格式，并在构建链中添加一步生成源文件的操作。
- en: 'We don’t know yet how to detect whether (and where) a Protobuf compiler is
    available on the target host (we’ll learn this in *Chapter 9*, *Managing Dependencies
    in CMake*). So, for now, let’s just assume that the compiler’s `protoc` command
    is residing in a location known to the system. We have prepared a `person.proto`
    file and we know that the Protobuf compiler will output `person.pb.h` and `person.pb.cc`
    files. Here’s how we would define a custom command to compile them:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不知道如何检测目标主机上是否存在（以及在哪里存在）Protobuf编译器（我们将在*第9章*，*CMake中的依赖管理*中学习这一点）。所以，目前我们暂时假设编译器的`protoc`命令位于系统已知的位置。我们已经准备了一个`person.proto`文件，并且知道Protobuf编译器将输出`person.pb.h`和`person.pb.cc`文件。下面是我们如何定义一个自定义命令来编译它们：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, to allow serialization in our executable, we can just add output files
    to the sources:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了在我们的可执行文件中支持序列化，我们可以直接将输出文件添加到源代码中：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Assuming we dealt correctly with the inclusion of header files and linking the
    Protobuf library, everything will compile and update automatically when we introduce
    changes to the `.proto` file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正确处理了头文件的包含和 Protobuf 库的链接，当我们对 `.proto` 文件进行修改时，所有内容会自动编译并更新。
- en: 'A simplified (and much less practical) example would be to create the necessary
    header by copying it from another location:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简化的（但不太实用的）示例是通过从另一个位置复制必要的头文件来创建它：
- en: '**ch05/03-command/CMakeLists.txt**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch05/03-command/CMakeLists.txt**'
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our “compiler”, in this case, is the `cp` command. It fulfills a dependency
    of the `main` target by creating a `constants.h` file in the build tree root,
    simply by copying it from the source tree.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的“编译器”是 `cp` 命令。它通过简单地从源代码树复制 `constants.h` 文件到构建树根目录，满足 `main` 目标的依赖。
- en: Using a custom command as a target hook
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义命令作为目标钩子
- en: 'The second version of the `add_custom_command()` command introduces a mechanism
    to execute commands before or after building a target:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二版本的 `add_custom_command()` 命令引入了一个机制，用于在构建目标之前或之后执行命令：
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We specify what target we’d like to “enhance” with the new behavior in the
    first argument and under the following conditions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一个参数中指定希望“增强”的目标，并在以下条件下执行：
- en: '`PRE_BUILD` will run before any other rules for this target (Visual Studio
    generators only; for others, it behaves like `PRE_LINK`).'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_BUILD` 会在为此目标执行任何其他规则之前运行（仅适用于 Visual Studio 生成器；对于其他生成器，它的行为像 `PRE_LINK`）。'
- en: '`PRE_LINK` binds the command to be run just after all sources have been compiled
    but before the linking (or archiving) of the target. It doesn’t work for custom
    targets.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRE_LINK` 将命令绑定到所有源文件编译完成后、目标链接（或归档）之前运行。它不适用于自定义目标。'
- en: '`POST_BUILD` will run after all other rules have been executed for this target.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST_BUILD` 会在所有其他规则为此目标执行完成后运行。'
- en: 'Using this version of `add_custom_command()`, we can replicate the generation
    of the checksum from the previous BankApp example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本的 `add_custom_command()`，我们可以复制前面 BankApp 示例中的校验和生成：
- en: '**ch05/04-command/CMakeLists.txt**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch05/04-command/CMakeLists.txt**'
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the build of the `main` executable completes, CMake will execute `cksum`
    with the provided arguments. But what is happening in the first argument? It’s
    not a variable, as then it would be wrapped in curly braces (`${}`), not in angle
    brackets (`$<>`). It’s a **generator expression** evaluating to a full path to
    the target’s binary file. This mechanism is useful in the context of many target
    properties, which we’ll explain in the next chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 可执行文件的构建完成后，CMake 会执行 `cksum` 命令并传入提供的参数。但是，首个参数发生了什么？它不是一个变量，否则它应该用大括号（`${}`）括起来，而不是用尖括号（`$<>`）。它是一个
    **生成器表达式**，计算得到目标二进制文件的完整路径。这个机制在许多目标属性的上下文中非常有用，我们将在下一章中解释。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Understanding targets is critical to writing clean, modern CMake projects.
    In this chapter, we have not only discussed what constitutes a target and how
    to define three different types of targets: executables, libraries, and custom
    targets. We have also explained how targets depend on each other through a dependency
    graph and we learned how to visualize it using the Graphviz module. With this
    general understanding, we were able to learn about the key feature of targets
    – properties. We not only went through a few commands to set regular properties
    on targets but we also solved the mystery of Transitive Usage Requirements also
    known as propagated properties.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 理解目标是编写清晰、现代 CMake 项目的关键。在本章中，我们不仅讨论了目标的构成以及如何定义三种不同类型的目标：可执行文件、库和自定义目标，还解释了目标之间如何通过依赖图相互依赖，并学习了如何使用
    Graphviz 模块来可视化它。通过这些基本理解，我们得以学习目标的一个关键特性——属性。我们不仅介绍了几个命令来设置目标的常规属性，还解决了传递使用要求的谜团，也就是所谓的传播属性。
- en: This was a hard one to crack, as we had to not only understand how to control
    which properties are propagated but also how that propagation affects subsequent
    targets. Furthermore, we discovered how to guarantee the compatibility of properties
    consumed from multiple sources.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很难解决的问题，因为我们不仅需要理解如何控制哪些属性会被传播，还要理解这种传播如何影响后续目标。此外，我们还发现了如何确保来自多个源的属性兼容性。
- en: 'We then briefly discussed pseudo targets: imported targets, alias targets,
    and interface libraries. All of them will come in handy later in our projects,
    especially when we know how to connect them with propagated properties for our
    benefit. Then, we talked about generated build targets and how the configuration
    stage affects them. Afterward, we spent some time looking at a mechanism that
    is similar to targets, but not exactly it: the custom commands. We touched on
    how they can generate files consumed by other targets (compiled, translated, and
    so on) and their hooking function: executing additional steps when a target is
    built.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们简要讨论了伪目标：导入目标、别名目标和接口库。它们在后续的项目中将派上用场，特别是当我们知道如何将它们与传播属性结合起来，造福我们自己时。然后，我们讨论了生成的构建目标，以及配置阶段如何影响它们。之后，我们花了一些时间研究了一种类似于目标但并不完全相同的机制：自定义命令。我们简要提到它们如何生成供其他目标使用的文件（如编译、翻译等），以及它们的钩子功能：在目标构建时执行附加步骤。
- en: With such a solid foundation, we are ready for the next topic – compiling C++
    sources into executables and libraries.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有了如此坚实的基础，我们准备进入下一个主题——将 C++ 源代码编译成可执行文件和库。
- en: Further reading
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解本章涉及的更多内容，您可以参考以下资源：
- en: 'Graphviz module documentation: [https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz),
    [https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphviz 模块文档：[https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/Graphviz)，[https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)
- en: 'Graphviz software: [https://graphviz.org](https://graphviz.org)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphviz 软件：[https://graphviz.org](https://graphviz.org)
- en: 'CMake target properties: [https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 目标属性：[https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html#properties-on-targets)
- en: 'Transitive Usage Requirements: [https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements
    )'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可传递使用要求：[https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#transitive-usage-requirements
    )
- en: Join our community on Discord
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 频道，与作者和其他读者讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
