- en: '*Chapter 9*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*'
- en: Requirements Engineering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求工程
- en: There may have been roughly an equivalent amount of thought over the last few
    decades into how to know you're building the right software as there has been
    into how to build software better. The software engineering techniques of the
    period 1960s-1980s explained how to construct requirements specifications, how
    to verify that the software delivered satisfied the specifications, and how to
    allow discoveries made while building and testing the software to feed back into
    the specification.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年中，关于如何构建正确软件的思考可能与如何更好地构建软件的思考大致相当。20世纪60年代至80年代的软件工程技术解释了如何构建需求规格说明，如何验证交付的软件满足规格，以及如何让在构建和测试软件过程中做出的发现反馈到规格中。
- en: In the 1990s, methodologies arose that favored closer interaction between the
    users of the software and its builders. **Rapid Application Development** dropped
    "big upfront" planning in favor of quickly iterated prototypes that customers
    could explore and give feedback on. **Extreme Programming** took this idea further
    and involves the customer or a representative of the customer not only in appraising
    the product during development but in prioritizing and planning the project as
    it proceeds. (It's a bit of a simplification to call these 1990s ideas. Many of
    the concepts behind RAD and other methodologies had been around since at least
    the 1970s, and a systematic literature review could pin the ideas more precisely
    onto the calendar.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，出现了倾向于用户与软件构建者之间更紧密互动的方法。**快速应用开发**放弃了“前期大量”规划，转而采用快速迭代的原型，客户可以探索并给出反馈。**极限编程**将这一想法进一步发展，不仅让客户或客户的代表在开发过程中评估产品，而且在项目进行中还参与优先级排序和规划项目。（将这些20世纪90年代的想法称为简化。RAD和其他方法背后的许多概念至少从20世纪70年代以来就已经存在，系统性的文献综述可以将这些想法更精确地定位到日历上。
- en: Nonetheless, it was the 1990s in which the ideas were synthesized into proposed
    systems for building software, and it was also the 1990s in which development
    teams started to use the systems and vendors created products to exploit their
    needs.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将这些想法综合成构建软件的提议系统是在20世纪90年代，也是在20世纪90年代，开发团队开始使用这些系统，供应商创造了产品来满足他们的需求。
- en: In parallel with that story, the history of how software applications are presented
    to their users has also been evolving. The success of this presentation is evident
    in the way that successive generations of practitioners have distanced themselves
    from the terminology used by the previous generation. If attempts to make software
    usable had been seen to work, then people would be happy to associate themselves
    with the field. Instead, **Human-Computer Interaction** has fallen out of favor,
    as have **Human Interface Design**, **Computer-Supported Collaborative Working**,
    **Interaction Design**, **User Interface Design**, and so on. It'll soon be the
    turn of **User Experience** to become one of history's résumé keywords.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，软件应用向用户展示的历史也在不断发展。这种展示的成功体现在 successive generations of practitioners（
    successive generations of practitioners 指的是连续几代从业者）逐渐远离了前一代使用的术语。如果使软件易于使用的尝试被证明是有效的，那么人们会乐意将自己与该领域联系起来。相反，**人机交互**已经不再受欢迎，同样不再受欢迎的还有**人机界面设计**、**计算机支持的协作工作**、**交互设计**、**用户界面设计**等等。很快，**用户体验**将成为历史简历中的关键词之一。
- en: If the whole point of building software is to make it easier for people to do
    things, we should investigate what it is that people are trying to do and how
    to support that. Along the way, we can find out how to understand what *we* do,
    which can help us improve our own work (maybe even by writing software to do so).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建软件的全部目的是为了让人们更容易地做事，那么我们应该调查人们试图做什么以及如何支持他们。在这个过程中，我们可以了解我们自己的工作方式，这可以帮助我们改进自己的工作（也许甚至可以通过编写软件来实现）。
- en: Study People
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 研究人们
- en: Software applications do not exist in a vacuum. They are used by people; a system
    of people with existing goals, ideas, values, and interactions with each other
    (and yes, programmers, existing technology). The introduction of a new software
    product into this system will undoubtedly change the system. Will it support the
    existing goals and values or replace them with new ones? Will it simplify existing
    interactions, or introduce friction?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用并非存在于真空之中。它们是由人使用的；一个由具有现有目标、想法、价值观以及彼此之间互动（是的，程序员，现有技术）的人群系统。将新的软件产品引入这个系统无疑会改变这个系统。它是否会支持现有的目标和价值观，或者用新的来取代它们？它是否会简化现有的互动，或者引入摩擦？
- en: To answer these questions, we must have a way to measure that system of people.
    To do *that*, we must understand what questions we should ask about that system
    in order to support the things we want to learn and discover what it is we should
    measure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们必须有一种方法来衡量这个人群系统。为了做到这一点，我们必须了解我们应该就这个系统提出哪些问题，以便支持我们想要学习和发现我们应该衡量什么。
- en: Decide The Model
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定模型
- en: In *Chapter 6, Testing*, I had to start by deciding that the requirements of
    a software system did not arise as some fundamental truth about the universe but
    were based on the way the people who used the system worked with the world and
    with each other. Now imagine that you're trying to understand the requirements
    of an application such as Excel. Will you consider the needs of each of the millions
    of users individually? While this could lead to a higher-quality product (or products,
    if you resolve conflicting needs by producing different solutions), there are
    few, if any, companies that could afford to undertake the research involved, and
    even if they could, it would be difficult to profit from the resulting software.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章，测试*中，我必须首先决定软件系统的需求并非源于宇宙的基本真理，而是基于使用该系统的人与世界以及彼此互动的方式。现在想象一下，你正在尝试理解像Excel这样的应用程序的需求。你会考虑每个百万级用户的个别需求吗？虽然这可能导致产品质量更高（或者如果你通过提供不同的解决方案来解决冲突需求，则可能是多个产品），但很少有，如果有的话，公司能够承担起涉及的研究，即使他们能够承担，从结果软件中获得利润也可能很困难。
- en: It's much cheaper to pick a small number of representative users and design
    the software for them. Some teams pick actual customers, while others create "personas"
    based on hypothetical customers, or on market research. Whichever way it's done,
    the product will come to represent the real or imagined needs of those real or
    imagined people
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 选择少数具有代表性的用户来设计和开发软件要便宜得多。有些团队选择真实的客户，而有些团队则基于假设的客户或市场研究创建“用户画像”。无论采用哪种方式，产品都将代表那些真实或想象中的人的实际或想象需求。
- en: User personas give the impression of designing for users, when in fact the product
    team has merely externalized their impression of what they want the software to
    be. It's easy to go from "I want this feature" to "Bob would want this feature"
    when Bob is a stock photo pinned to a whiteboard; Bob won't join in with the discussion,
    so he won't tell you otherwise. The key thing is to get inside the fictitious
    Bob's head and ask "why" he'd want that feature. Sometimes, teams that I've been
    on where personas were used nominated someone to be their advocate during discussions.
    This gave that person license to challenge attempts to put words in the persona's
    mouth; not quite the same as having a real customer involved but still useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用户画像给人一种为用户设计的印象，但实际上产品团队只是将他们对软件应该是什么的印象外化了。当鲍勃只是一个贴在白板上的股票照片时，很容易从“我想这个功能”变成“鲍勃会想要这个功能”。鲍勃不会参与讨论，所以不会告诉你相反的情况。关键是要进入虚构的鲍勃的头脑，问他“为什么”他会想要这个功能。有时，我所在的团队在使用用户画像时，会指定某人在讨论中担任他们的倡导者。这给了那个人挑战试图将话语放入用户画像嘴里的权利；虽然这并不完全等同于有真实客户参与，但仍然很有用。
- en: At first glance, the situation seems much better for builders of in-house or
    "enterprise" software; find the people who are going to use the software and build
    it for them. There are still some important questions about this model of the
    software's environment. One clear problem is where you're going to stop. Does
    the team you're building for represent an isolated unit in the company with clear
    inputs and outputs, or do you treat the interactions between members of this and
    other teams as part of the system? How about the interactions with customers,
    partners, and other external parties? The article **Three Schools of Thought on
    Enterprise Architecture**—[http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219](http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219)
    explores the effects of these boundaries on considering the systems involved.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，内部或“企业”软件的构建者似乎情况要好得多；找到将要使用软件的人，为他们构建。关于这种软件环境模型，还有一些重要的问题。一个明显的问题是你要在哪里停止。你正在为的团队是否代表公司中的一个孤立单位，有明确的输入和输出，还是你将这个团队和其他团队之间的互动视为系统的一部分？那么与客户、合作伙伴和其他外部实体的互动呢？文章**关于企业架构的三种思想学派**——[http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219](http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=6109219)探讨了这些边界对考虑涉及的系统的影响。
- en: Having decided on the scope of the system, are you designing for the specific
    people who currently comprise it or for more abstract concepts such as the roles
    that are occupied by those people? In either case, be aware of political biases
    entering into your model. Software designed according to a collaborative model
    of the interaction between a manager and their reports will differ from that modelled
    on the struggle between the oppressed workers and the exploitative bourgeoisie.
    Because the software will end up changing the system it's deployed into, such
    decisions will affect the way people work with each other.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了系统的范围之后，你是为目前构成该系统的特定人员设计，还是为更抽象的概念，例如那些人员所担任的角色设计？在两种情况下，都要意识到政治偏见可能进入你的模型。根据经理与其下属之间互动的协作模型设计的软件将与基于受压迫工人与剥削资产阶级之间斗争的模型不同。因为软件最终会改变其部署的系统，这样的决策将影响人们相互工作的方式。
- en: You Shouldn't Necessarily Build What The Client Asks For
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你不一定需要构建客户要求的东西
- en: Discovering the requirements for any software application is hard, even if the
    people building it are going to be the people using it. In *Chapter 6, Testing*,
    I explored the notion that everybody has their own idea of what the software should
    do, and in *Chapter 7, Architecture*, the fact that some requirements are not
    made explicit. So, if you just asked everyone for a list of things the software
    should do and built that, it'd be rife with conflicts and probably wouldn't do
    everything that any one person wanted from it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 发现任何软件应用的需求都很困难，即使构建它的人将是使用它的人。在*第6章，测试*中，我探讨了每个人都有自己关于软件应该做什么的想法，而在*第7章，架构*中，有些需求并没有明确表达。所以，如果你只是要求每个人列出软件应该做的事情，并据此构建，那么它将充满冲突，可能不会满足任何一个人对它的所有期望。
- en: While it's an inaccurate way of finding out what software should do, asking
    people is one of the easiest and most accessible methods. You can interview people
    with either a directed questionnaire or an open-ended discussion, finding out
    what they think of the system of interest and hopefully teasing out some of those
    tacit requirements. You can also get a group of people together, as a round-table
    discussion or a focus group, to collectively discuss their needs and problems.
    Even when people are being helpful and answering your questions to the best of
    their abilities, there will be problems that come up with interpreting their answers.
    The thing they do is likely a specialist activity, and so is making software.
    Each of these disciplines will have its jargon and its accepted "common sense"
    knowledge; translating between those will be difficult. Everyone has their own
    version of what "everybody" who does their job knows and will probably not think
    to tell you about those things.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然询问人们是找出软件应该做什么的不准确方法，但询问人们是其中最容易和最可访问的方法之一。你可以通过定向问卷或开放式讨论来采访人们，了解他们对感兴趣系统的看法，并希望揭示一些那些隐含的需求。你还可以召集一群人，作为一个圆桌讨论或焦点小组，共同讨论他们的需求和问题。即使人们在尽力回答你的问题时很有帮助，也可能会出现解释他们答案的问题。他们所做的是一项专业活动，制作软件也是如此。每个学科都将有自己的术语和公认的“常识”知识；在这些术语之间进行翻译将是困难的。每个人都有自己版本的对“每个人”做他们工作所知道的事情，可能不会想到告诉你那些事情。
- en: So, there's an art (or maybe a science; I don't think the industry has made
    its mind up yet) to looking past the direct answers to your direct questions,
    to find out both what questions you *should* have asked and what answers you would
    *never* have been given. This is where bespoke software (particularly so called
    "enterprise" software) has a chance to provide a much better experience than off-the-shelf
    software; you have the opportunity to observe what your users *really* do and
    to provide software that supports that, rather than offering something that supports
    their stated needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有一种艺术（或者也许是一种科学；我认为该行业还没有下定决心）在于超越直接回答你的直接问题，找出你*应该*提出的问题以及你*永远不会*得到答案的问题。这就是定制软件（尤其是所谓的“企业”软件）有机会提供比现成软件更好的体验的地方；你有机会观察你的用户*真正*在做什么，并提供支持这些行为的软件，而不是提供支持他们声明的需求的东西。
- en: You need to remember too that *you* are the software expert, and your client
    is the expert at solving whatever problem it is that they solve. When they talk
    about the *problem* they are having, there is more information about how it should
    be solved than when they tell you about the *solution* they envisage. That's not
    to say that you shouldn't accept their suggestions; but you *should* remember
    that their expertise lies elsewhere and that your team probably has more experience
    of designing software. Obviously, if you're a start-up working on a developer
    tool, your team probably has *less* experience than your customers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要记住，*你*是软件专家，而你的客户是解决他们所解决问题的专家。当他们在谈论他们遇到的*问题*时，关于如何解决这个问题的信息比他们告诉你他们预想的*解决方案*时更多。这并不是说你不应该接受他们的建议；但你应该记住，他们的专业知识在其他地方，而你的团队可能在设计软件方面有更多的经验。显然，如果你是一个在开发工具上工作的初创公司，你的团队可能比你的客户有*更少*的经验。
- en: Avoid Asking What You Want To Hear
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免询问你想要听到的
- en: If you've got a pet feature, it's all too easy to drop it into a discussion
    of the proposed system when conducting interviews and focus groups with prospective
    users. The problem you then face is that it's easy for people to agree that said
    feature would be a good idea, even if it really wouldn't.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个宠爱的功能，在采访和焦点小组讨论中，很容易将其融入到对潜在用户的讨论中。你面临的问题是你很容易让人们同意这个功能是个好主意，即使它实际上并不是。
- en: Firstly, you have to separate things that people think they would use from things
    that people *do* use. Consider whatever word processing software you use and think
    about all the features it has that you've never touched. When you bought the software,
    were you swayed by any of the discussions of those features in the marketing material?
    (The idea that word processors have more features than people use has been investigated
    by human-computer interaction researchers—[https://www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf](https://www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf)
    and while they found that some features go unused by some users, the users still
    know that those features are there and have some familiarity with their function.
    So, saying that these extra features are entirely without value is clearly a stretch;
    nonetheless, the default choice on whether we "should" incorporate a feature into
    a product is usually "yes" due to the feature matrix marketing described here.)
    Do you think the majority of other users do make use of those features? Would
    the software be worth as much if it didn't have those features? Given the choice
    between an application that does a thing and one that doesn't, people will often
    choose the one that does it even if they don't see a need for that right now.
    Particularly as, when you're gathering requirements, there's no other information
    to go on; without being able to see the two (currently hypothetical) applications,
    prospective users can't compare their usability, speed, quality, or other features,
    so the options really do boil down to "with" or "without."
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须区分人们认为他们会使用的东西和人们*确实*使用的东西。考虑一下你使用的任何文字处理软件，想想它有多少你从未使用过的功能。当你购买该软件时，你是否被营销材料中对这些功能的讨论所影响？（关于文字处理器具有比人们使用更多的功能这一观点，已经被人机交互研究人员调查过——[https://www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf](https://www.cs.ubc.ca/~joanna/papers/GI2000_McGrenere_Bloat.pdf)，尽管他们发现一些功能被某些用户未使用，但用户仍然知道这些功能存在，并对它们的功能有所了解。因此，说这些额外功能完全没有价值显然是夸大其词；然而，由于这里描述的特征矩阵营销，我们通常将是否将功能纳入产品中的默认选择定为“是”。你认为大多数其他用户是否真的使用了这些功能？如果软件没有这些功能，它是否仍然具有同样的价值？在具有功能的应用程序和没有功能的应用程序之间进行选择时，人们通常会选择具有功能的应用程序，即使他们现在看不到需要它的理由。尤其是在收集需求时，没有其他信息可供参考；如果不能看到这两个（目前假设的）应用程序，潜在用户就无法比较它们的可用性、速度、质量或其他功能，所以选项实际上真的归结为“有”或“没有”。
- en: 'Bear in mind, too, the tendency for people without a strong view on a statement
    to agree with it. This is known in psychological circles as the *acquiescence
    response bias* and needs to be taken into account when evaluating the results
    of questionnaires. An example is in order. Imagine that you wanted to build a
    "clean coder" IDE, but you want to find out whether anyone would use it first.
    You create a questionnaire asking respondents to rate how strongly they agree
    or disagree with these statements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，那些对某个声明没有强烈观点的人倾向于同意它。这在心理学领域被称为*顺从反应偏差*，在评估问卷结果时需要考虑。以下是一个例子。想象一下，你想要构建一个“清洁编码者”IDE，但首先你想知道是否有人会使用它。你创建了一份问卷，要求受访者对这些陈述进行评分，以表示他们同意或不同意这些陈述的程度：
- en: A professional programmer writes unit tests.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业程序员编写单元测试。
- en: A good method has minimal loops and branches.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的方法应该尽量减少循环和分支。
- en: Long, descriptive variable names are better.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长且描述性的变量名更好。
- en: 'Someone else wants to write a "stripped-down" IDE, harking back to the times
    when "real programmers didn''t eat quiche" and just got their jobs done. (This
    is a tongue-in-cheek reference to the article **Real Programmers Don''t Use Pascal**—[http://www.ee.ryerson.ca/~elf/hack/realmen.html](http://www.ee.ryerson.ca/~elf/hack/realmen.html),
    which was itself a tongue-in-cheek reference to the book **Real Men Don''t Eat
    Quiche**—[https://bit.ly/2XjLjxw](https://bit.ly/2XjLjxw). That was itself satirical,
    but I''ve run out of cheeks into which I am willing to insert my tongue.) They
    create a questionnaire in which respondents rate their agreement with these statements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另有人想写一个“简化版”IDE，回顾那些“真正的程序员不吃千层面”的时代，他们只是完成工作。（这是一个对文章**真正的程序员不用Pascal**——[http://www.ee.ryerson.ca/~elf/hack/realmen.html](http://www.ee.ryerson.ca/~elf/hack/realmen.html)的戏谑引用，该文章本身是对书籍**真正的男人不吃千层面**——[https://bit.ly/2XjLjxw](https://bit.ly/2XjLjxw)的戏谑引用。那本书本身是讽刺的，但我已经没有地方可以插入我的舌头了。）他们创建了一份问卷，让受访者对这些陈述表示同意的程度：
- en: Time spent writing tests is time spent not adding value.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花在编写测试上的时间是用来不增加价值的时间。
- en: A good method has as many loops and branches as necessary to provide a simple
    interface onto complex work.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的方法需要有足够的循环和分支来提供一个简单的界面，进入复杂的工作。
- en: Typing is not the focus of programming; terseness is a virtue.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打字不是编程的重点；简洁是一种美德。
- en: These questionnaires will yield different results; not necessarily entirely
    in opposition to one another but certainly each revealing a bias in favor of the
    higher end of their respective scales. This is the acquiescence response bias;
    each has asked what they wanted to hear and the respondents in each case have
    tended to agree with it. The two researchers should have each chosen a mix of
    questions from both lists to get a more representative survey.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问卷将产生不同的结果；不一定完全相互对立，但确实每个都揭示了各自尺度高端的偏见。这是默认响应偏差；每个人都问了他们想听的问题，并且每个案例的受访者都倾向于同意它。两位研究人员应该各自从两个列表中选择问题组合，以获得更具代表性的调查。
- en: Finally, bear in mind that telling your client "I think we should do it like
    *this*" will predispose them to that approach, due to a cognitive bias called
    **anchoring**—[https://www.sciencedaily.com/terms/anchoring.htm](https://www.sciencedaily.com/terms/anchoring.htm)).
    Having *anchored* a particular feature or workflow in their mind, they'll prefer
    options that contain that feature or workflow even if it rationally appears worse
    than an unrelated alternative. You could end up privileging a suboptimal or costly
    design just because it was the first thing you thought of and blurted it out to
    your clients. It's best to leave options open early on so that you don't pit your
    own customers against better designs you create later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住告诉你的客户“我认为我们应该这样做”会由于一个称为**锚定**的认知偏差而使他们倾向于这种方法——[https://www.sciencedaily.com/terms/anchoring.htm](https://www.sciencedaily.com/terms/anchoring.htm))。一旦在他们的脑海中“锚定”了某个特定功能或工作流程，他们就会更喜欢包含该功能或工作流程的选项，即使从理性上看它比无关的替代方案更差。你可能会因为它是你首先想到并脱口而出的而偏袒一个次优或昂贵的方案。最好是尽早留出选项，这样你就不会让你的客户与你在后来创建的更好设计相对抗。
- en: Understand The Problem Domain
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解问题领域
- en: As mentioned earlier, you and your team are the experts in making software,
    and the customers are the experts in the thing that the software will do. I've
    cautioned against using that distinction to build the software you want rather
    than the software that the customers need; should this be taken to mean that the
    software people stick to software and the customers stick to their problem domain?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你和你的团队是软件制作的专家，而客户是软件将要完成的事情的专家。我曾警告过不要用这种区别来构建你想要的软件而不是客户需要的软件；这难道意味着软件人员坚持软件，而客户坚持他们的问题领域吗？
- en: No.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不。
- en: You need to know what you're building *for*, so you need to have some understanding
    of the problem domain. Yes, this is asymmetric. That's because the situation is
    asymmetric – you're building the software to solve a problem; the problem hasn't
    been created so that you can write some software. That's just the way it is, and
    compromises must come more from the software makers than from the people we're
    working for. The better you understand the problem you're trying to solve, the
    more you can synthesize ideas from that domain and the software domain to create
    interesting solutions. In other words, you can write better software if you understand
    what it is that software will do. That's hopefully not a controversial idea.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道你正在为谁构建，所以你需要对问题领域有一些了解。是的，这是不对称的。这是因为情况是不对称的——你正在构建软件来解决一个问题；问题并不是为了你可以编写一些软件而创造的。就是这样，并且妥协必须更多地来自软件制作人，而不是我们为之工作的人。你越了解你试图解决的问题，你就越能从该领域和软件领域综合想法来创造有趣的解决方案。换句话说，如果你了解软件将要做什么，你就能编写更好的软件。这希望不是一个有争议的想法。
- en: 'There are different levels on which this understanding can be implemented,
    relevant to different amounts of interaction with customers. *Chapter 5, Coding
    Practices*, described **Domain-Driven Design** and the ubiquitous language: the
    glossary of terms that defines concepts in the problem domain and should be used
    to name parts in the software domain, too. Needless to say, everyone working on
    the software should be familiar with the ubiquitous language and using it in the
    same way – it''s not ubiquitous otherwise! The point of the ubiquitous language
    is to ensure that everyone—customers and software makers—means the same thing
    when they use technical or jargon terms. Therefore, it prefers jargon to be from
    the problem domain, so that non-software people don''t have to learn software
    terminology, and it''s expected that the terms pervade the software design and
    implementation and are not just used in customer meetings.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解可以在不同的层面上实现，与与客户的不同程度的互动相关。*第五章，编码实践*描述了**领域驱动设计**和无处不在的语言：定义问题域概念的术语表，也应用于命名软件域中的部分。不用说，所有参与软件开发的人都应该熟悉无处不在的语言，并以相同的方式使用它——否则就不是无处不在了！无处不在的语言的目的是确保当人们使用技术术语或行话时，每个人——客户和软件制造商——都意味着相同的事情。因此，它更倾向于使用来自问题域的术语，这样非软件人员就不必学习软件术语，并且预期这些术语渗透到软件设计和实现中，而不仅仅是用于客户会议。
- en: The ubiquitous language should be considered a starting point. Some methodologies,
    including Extreme Programming, require that the development team have a customer
    representative on hand to ensure that the development work is always adding value.
    These discussions need to be had at the level of the business, that is, at the
    level of the problem domain. (This is one of the reasons that programmers often
    get frustrated that the business doesn't schedule time for refactoring, development
    infrastructure, or "paying off" technical debt. The problem is that bringing these
    things up in the context of a business discussion is a mistake; these are internal
    details of what we do and how we work with each other and have nothing to do with
    business value or how we work with customers. If some refactoring work is going
    to make it easier to work on the software, then just do it and let the business
    see the results in terms of reduced costs.) This in turn means that at least one
    person is going to need to be capable of having a peer discussion about the problem
    at hand with the customer representative.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将无处不在的语言视为一个起点。包括极限编程在内的一些方法要求开发团队有客户代表在场，以确保开发工作始终在增加价值。这些讨论需要在业务层面进行，也就是说，在问题域的层面。（这也是程序员经常感到沮丧的原因之一，因为业务没有安排时间进行重构、开发基础设施或“偿还”技术债务。问题在于，在业务讨论的背景下提出这些事情是一个错误；这些是我们所做事情和我们如何相互合作的内部细节，与我们如何与客户合作以及业务价值无关。如果某些重构工作可以使软件更容易工作，那么就去做，让业务看到成本降低的结果。）这反过来意味着至少需要一个人能够与客户代表就手头的问题进行同行讨论。
- en: Uncover Tacit Requirements
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示隐性需求
- en: This chapter has already covered the idea that you need to find out what customers
    need from their software that they're not talking about. But it's worth bringing
    up again, because the ubiquitous language may have ubiquitous holes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了这样一个观点：你需要找出客户从他们的软件中需要的东西，而这些东西他们并没有提到。但再次提出这一点是值得的，因为无处不在的语言可能存在无处不在的漏洞。
- en: Think of all the times you've been surprised at a question someone from outside
    the software field has asked about an application you're writing. Well, no, of
    *course* the app we made for the seven-inch tablet won't work on the three-inch
    phone. It's such a basic thing, it's not even worth mentioning, so why would someone
    ask it?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想想那些你对外部软件领域的人询问你正在编写的应用程序时感到惊讶的时刻。好吧，当然，我们为七英寸平板电脑制作的那个应用程序不会在三英寸的手机上工作。这是一件如此基本的事情，甚至不值得提，那么为什么有人会问这个问题呢？
- en: Now think about flipping that situation. What are the things that people in
    your problem domain think so basic that they'd never mention them? The things
    that a professor told them were "obvious" in a first-year lecture and they haven't
    questioned since? How are you going to get anyone to tell you about them?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下这种情况的反面。在你的问题域中，人们认为哪些事情是如此基本，以至于他们永远不会提到？那些教授在第一年讲座中告诉他们是“明显”的事情，他们从未质疑过？你将如何让任何人告诉你这些事情？
- en: As with pair coaching, this is a situation where acting like a petulant toddler
    can be to your advantage. Domain experts are likely to have particular ways of
    doing things; finding out *why* is what's going to uncover the stuff they didn't
    think to tell you. It'll be frustrating. Some things we don't have real reasons
    for doing; they're just "best" practice or the way it gets done. Probing those
    things will set up a cognitive dissonance, which can lead people to get defensive;
    it's important to let them know that you're asking because you're aware how much
    of an expert they are at this stuff and that you just need to understand the basics
    in order to do a good job by them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像配对辅导一样，这是一个表现得像任性的幼儿可能对你有利的情境。领域专家可能有自己的做事方式；找出*为什么*将会揭示他们没有想到要告诉你的东西。这会让人感到沮丧。有些事情我们没有真正的理由去做；它们只是“最佳实践”或完成工作的方式。对这些事情进行探究会引发认知失调，这可能导致人们变得防御性；重要的是让他们知道你之所以提问是因为你意识到他们在这些事情上多么专业，而你只是需要了解基础知识以便为他们做好工作。
- en: Why the cognitive dissonance? Well, sometimes we just do things because "that's
    how they're done," rather than because there's any known value to that technique.
    We can find examples of this in the field of making software. Many developers
    (though, far from all) use version control. What are the benefits of doing so?
    Surprisingly, *no study can be found*—[http://www.neverworkintheory.org/?p=451](http://www.neverworkintheory.org/?p=451)
    that investigates that. However, many developers, myself included, will tell you
    that version control is important, you should be doing it, and can come up with
    benefits. Tell us "but there's no evidence for those benefits, so why not just
    stop?" and we'll get confused and angry, trying more vociferously to defend our
    position despite the problems with the argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有认知失调？好吧，有时候我们只是因为“这就是他们做事的方式”而做事，而不是因为这种技术有任何已知的价值。我们可以在软件制作的领域中找到这样的例子。许多开发者（尽管并非所有）使用版本控制。这样做有什么好处？令人惊讶的是，*没有找到任何研究*——[http://www.neverworkintheory.org/?p=451](http://www.neverworkintheory.org/?p=451)——来调查这一点。然而，包括我在内的许多开发者会告诉你，版本控制很重要，你应该这样做，并且可以提出好处。如果你告诉我们“但是没有证据支持这些好处，为什么不停止呢？”我们可能会感到困惑和愤怒，更加激烈地试图捍卫我们的立场，尽管论点存在问题。
- en: You Shouldn't Build What Your Client Wants
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你不应该建造客户想要的东西
- en: 'At least, you probably shouldn''t, anyway. Most of the time, they won''t represent
    the majority of users, or even *any* of the users. This happens in pretty much
    every field of software:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你可能根本不应该这样做。大多数时候，他们不会代表大多数用户，甚至*任何*用户。这种情况几乎在软件的每个领域都会发生：
- en: In-house software is usually commissioned by the IT department, but will be
    used by sales, engineers, finance, and other departments.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部软件通常由IT部门委托，但会被销售、工程师、财务和其他部门使用。
- en: Commercial software is usually driven by a product manager but will be sold
    to thousands (or more) of people. Even where you have a dedicated customer representative,
    they represent only one of many users. And, as with in-house software, the "representative"
    may still not be the ultimate user of the application.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商业软件通常由产品经理推动，但会卖给成千上万（或更多）的人。即使你有专门的客户代表，他们也只代表众多用户中的一个。而且，就像内部软件一样，这个“代表”可能也不是应用程序的最终用户。
- en: Even in a case where you're building bespoke software for a small team of people
    who are involved in the decision-making, a disproportionate number of suggestions
    will come from the more senior or more vocal users; with the worst case being
    that specific requests get filtered through the understanding of a senior manager
    before being summarized and presented to the development team.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是为参与决策的小团队定制软件的情况，过多的建议也会来自资历较深或更健谈的用户；最糟糕的情况是，具体请求会在被总结并呈交给开发团队之前，先通过高级经理的理解进行筛选。
- en: What this means is that, in almost all situations, what your client wants is
    at best only a rough approximation to what would be in the best interests of the
    product (and therefore its user base, and presumably your bottom line). The trick
    to managing this is, of course, political rather than technical; you probably
    don't want to offend the people who *are* giving you input into the software requirements,
    especially if they're paying the bills. That means flipping the **Bozo Bit**—[http://c2.com/cgi/wiki?SetTheBozoBit](http://c2.com/cgi/wiki?SetTheBozoBit)
    is out of the question. But if something's a bad idea, you probably don't want
    it in your app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，在几乎所有情况下，客户想要的东西最多只是对产品最佳利益（因此是其用户群，以及可能还有你的底线）的一个粗略近似。管理这个问题的技巧当然是政治性的，而不是技术性的；你可能不想得罪那些正在向软件需求提供反馈的人，尤其是如果他们正在支付账单的话。这意味着要翻过**波佐比特**——[http://c2.com/cgi/wiki?SetTheBozoBit](http://c2.com/cgi/wiki?SetTheBozoBit)是不可能的。但如果某个想法是糟糕的，你可能不希望它在你的应用程序中出现。
- en: But what makes *you* sure it's a bad idea? Even if you are the user of the software
    you're writing, it's still one not-quite-representative user versus another. Yes,
    you may have more of an idea about platform norms and expected behavior, but that
    could also mean that you're conservative about brand new ideas because no other
    app works this way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是什么让你确信这是一个糟糕的想法？即使你是你正在编写的软件的用户，这也只是不太具有代表性的一个用户与另一个用户之间的比较。是的，你可能对平台规范和预期行为有更多的了解，但这也可能意味着你对全新的想法持保守态度，因为没有其他应用程序是这样工作的。
- en: 'Resolving this conflict can be achieved with data. I discussed A/B testing
    and user acceptance testing in *Chapter 6, Testing*; those tools can be put to
    use here in discovering whether any given suggestion improves the software. It
    doesn''t have to be expensive; in that, you don''t have to build the whole feature
    before you can find out whether anyone wants it. You could try out a prototype
    on a whiteboard to see how people get on with it or build a very basic version
    of the feature to see how popular it is. Be cautious about trying to poll users
    to find out how popular a feature would be though: answering "yes" or "no" takes
    the same effort, but in one case they get a higher chance of getting a new shiny
    thing, whether they''d use it or not. The risk/reward calculation in responding
    to a feature poll is biased toward affirming the request, and we''ve already seen
    acquiescence bias means people tend to agree with whatever statement is presented
    to them.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数据可以解决这个冲突。我在*第6章，测试*中讨论了A/B测试和用户验收测试；这些工具可以在这里用来发现任何给定的建议是否改善了软件。这不必很昂贵；在这方面，你不必在发现是否有人想要它之前构建整个功能。你可以在白板上尝试一个原型来查看人们如何使用它，或者构建该功能的非常基本的版本来查看它的受欢迎程度。尽管如此，在尝试通过调查用户来了解一个功能可能会多么受欢迎时要谨慎：回答“是”或“否”需要同样的努力，但在一种情况下，他们有更高的机会得到一个新玩意儿，无论他们是否会使用它。对特征调查的响应中的风险/回报计算倾向于肯定请求，而我们已经看到默认同意偏差意味着人们倾向于同意他们面前提出的任何陈述。
- en: When you've got the data, the conversation can start "that was a nice idea,
    but it looks like the customers aren't ready for it" rather than "I'm not building
    your bad feature." That's a much easier way to have an ongoing relationship with
    your clients. Unfortunately, it's not always an option; plenty of software is
    still built in secrecy, with no user engagement until 1.0 is nearly ready (or
    even later). In these cases, your imperfect customer proxies are all you've got
    and, like it or not, you have only their suggestions and your opinions to work
    with. You can still frame discussion around hypothetical other users (often called
    personae) to defuse any emotional feelings about challenging "personal" feature
    requests, but that's an imperfect rhetorical tool rather than an imperfect requirements
    tool. Application telemetry in the 1.0 release can tell you how people really
    use the features and help you prioritize future development, but that's too late
    for discussions about the initial release; and remember that it's the initial
    release that costs money while it's not paying for itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有数据时，对话可以开始“那是个不错的主意，但看起来客户还没有准备好接受它”，而不是“我不会构建你的糟糕功能。”这是一种与客户保持持续关系的更容易的方式。不幸的是，这并不总是可行的；许多软件仍然在秘密中构建，直到1.0版本几乎准备好（甚至更晚）才与用户互动。在这些情况下，你只有不完美的客户代理，而且不管你喜不喜欢，你只能根据他们的建议和你的意见来工作。你仍然可以围绕假设的其他用户（通常称为角色）来框架讨论，以减轻对具有挑战性的“个人”功能请求的情感反应，但这只是一种不完美的修辞工具，而不是不完美的需求工具。1.0版本中的应用遥测可以告诉你人们如何真正使用功能，并帮助你优先考虑未来的开发，但对于关于初始发布的讨论来说已经太晚了；记住，是初始发布在花钱，而它没有自我支付。
- en: Human Factors In Software Systems
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件系统的人类因素
- en: The thing about software requirements is that they don't exist. Or at least,
    they don't exist in isolation. The standard model of particle physics is based
    on the idea that there are fundamental particles called quarks, and that these
    combine into systems called *hadrons* (heavyweight particles including protons
    and neutrons) and *mesons* (middleweight particles important in high-energy interactions).
    Quarks are bound into these systems by *gluons*, the particles that carry the
    strong force. This model is generally accepted, even though no one has ever seen
    a quark or a gluon in isolation; they're always part of a hadron or meson.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件需求的问题在于，它们不存在。或者至少，它们不是孤立存在的。粒子物理学的标准模型基于这样的想法，即存在被称为夸克的基本粒子，它们结合成称为*强子*（包括质子和中子的重粒子）和*介子*（在高温相互作用中重要的中等质量粒子）的系统。夸克通过携带强力的胶子绑定到这些系统中。这个模型被普遍接受，尽管没有人曾单独看到过夸克或胶子；它们总是强子或介子的组成部分。
- en: Just as quarks and gluons have no existence on their own, so software on its
    own without users is meaningless, and software users without software have nothing
    to do. The whole represents a *socio-technical system* and it is *this* system
    that we are constructing and modifying with our software-building efforts. So,
    no view on software requirements is complete without a view of the effect the
    software will have on the politics, economics, social structure, and psychology
    of the people who will interact with it, and of how those people will affect the
    software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如夸克和胶子本身没有存在一样，没有用户的软件本身也是没有意义的，没有软件的用户也没有事情可做。整体代表一个*社会技术系统*，而我们正是通过我们的软件开发努力构建和修改这个系统。因此，没有对软件需求的观点是不完整的，没有对软件将对与之互动的人的政治、经济、社会结构和心理学产生的影响的看法，以及这些人将如何影响软件的看法。
- en: '*I''ve had a theoretical grasp on this point for years. It was finally emotionally
    reified for me by* **Robert Annett**—[https://twitter.com/robert_annett](https://twitter.com/robert_annett)
    *during a talk he gave on legacy software systems. The anecdote he told involved
    him walking through an office at the company he was deploying a new system at,
    talking with one of the people he''d be working with. As they left a room where
    around 20 data entry clerks were working, his new colleague said quietly "it''s
    a shame really – when your new system comes online, we''ll have to fire them."*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*我已经对这个观点有了理论上的理解好几年了。最终，在**罗伯特·安内特**（[https://twitter.com/robert_annett](https://twitter.com/robert_annett)）关于遗产软件系统的演讲中，这个观点对我产生了情感上的共鸣。他讲述的一个轶事是，他走过他在部署新系统的公司办公室，与将要一起工作的人交谈。当他们离开大约有20个数据录入员工作的房间时，他的新同事低声说，“这真的很遗憾——当你的新系统上线时，我们不得不解雇他们。”*'
- en: '*Sometimes, the pattern of sigils and words you feed to the compiler can have
    a real impact on real people, good or bad.*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时，你提供给编译器的符号和文字的模式会对真实的人产生真正的影响，无论是好是坏*。'
- en: Economics
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经济学
- en: 'The economic side of this interaction is covered well by Barry Boehm in his
    1981 book **Software Engineering Economics**—[http://books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y](http://books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y).
    His model for estimating the costs of software projects has not been generally
    adopted in the industry, but it does include what he calls "human relations factors,"
    which can affect the cost of a software system and the benefits derived. It includes
    the "modified golden rule" for working with other people:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这场互动的经济方面在Barry Boehm 1981年的著作《软件工程经济学》[http://books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y](http://books.google.co.uk/books/about/Software_engineering_economics.html?id=VphQAAAAMAAJ&redir_esc=y)中得到了很好的阐述。他对于估计软件项目成本的模型在业界并没有被普遍采用，但它确实包括了被他称为“人际关系因素”的内容，这些因素可以影响软件系统的成本和收益。它包括了与别人合作的“修改后的黄金法则”：
- en: '*Do unto others as you would have others do unto you – if you were like them*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*己所不欲，勿施于人——如果你和他们一样*。'
- en: The point of the conditional clause is to remind programmers that not everyone
    wants to be treated like they enjoy solving software problems and can understand
    computer science concepts. Boehm argues that the costs and benefits of usability,
    of satisfying human needs, and of allowing users to fulfil their potential need
    to be considered in economic terms for a software project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 条件句的目的在于提醒程序员，并不是每个人都希望被当作喜欢解决软件问题并能理解计算机科学概念的人来对待。Boehm认为，在软件项目中，可用性、满足人类需求以及允许用户实现其潜能的需求，在经济术语上需要被考虑。
- en: 'While surely better (or at least, more complete) than not reasoning at all
    about these factors, trying to find a dollar value for them is an early stage
    in their consideration. What I infer from it, and from similar arguments in information
    security and other fields (remember the discussion on the economic value of accessibility,
    in the *Chapter 6, Testing*) is that we either can''t *see* or can''t *justify*
    an intrinsic benefit of those properties, but would still like to include them
    in our decision-making. The fact that we''re not willing to ignore them leads
    me toward the second explanation: we know that these things are valuable but don''t
    have an argument to support that.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这肯定比完全不考虑这些因素要好（或者至少更完整），但试图为它们找到美元价值只是考虑它们的一个早期阶段。我从其中，以及从信息安全和其他领域的类似论点（记得在*第6章，测试*中关于无障碍经济价值的讨论）中推断出，我们要么看不到，要么无法证明这些属性固有的好处，但我们仍然希望将它们纳入我们的决策中。我们不愿意忽视它们的事实，使我倾向于第二个解释：我们知道这些事物是有价值的，但我们没有论据来支持这一点。
- en: 'That''s not to say that these defenses for human factors aren''t useful; just
    that they aren''t the apotheosis of debate. You can see how usability might be
    economically justified in terms of cost; more effort in designing usable software
    can pay off in making its users more efficient, and more satisfied. Satisfaction
    (linked to another of the factors – fulfilment of human potential) can lead to
    greater engagement with their work and higher levels of staff retention, reducing
    the HR costs of the organization. Satisfying human needs is what **Herzberg**—[http://www.businessballs.com/herzberg.htm](http://www.businessballs.com/herzberg.htm)
    deems a *hygiene factor*: people must have their basic needs met before they can
    be motivated to pursue other goals.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说这些关于人的因素的保护措施没有用；只是它们并不是辩论的顶峰。你可以看到，从成本的角度来看，可用性在经济上可能是合理的；在设计可用的软件上投入更多努力，可以使用户更有效率，更满意。满意（与另一个因素——实现人类潜能——相关）可以导致对工作的更大参与和更高的员工留存率，从而降低组织的HR成本。满足人类需求是**赫茨伯格**[http://www.businessballs.com/herzberg.htm](http://www.businessballs.com/herzberg.htm)认为的*卫生因素*：人们必须满足他们的基本需求，才能被激励去追求其他目标。
- en: 'Sometimes the trade-off in goals cannot reasonably be cast in economic terms.
    A good example is a game: if it had great usability, it''d be really simple so
    people would complete it quickly and then get back to work – an economic win.
    But people don''t play games that are straightforward; they play games that offer
    them a challenge, whether that challenge be mental, dexterous, or something else.
    Therefore, the player''s desire to be challenged, or to lose themselves in the
    game world, takes precedence, although it is difficult to see how to assign a
    monetary value to that desire.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在目标之间的权衡无法合理地用经济术语来表示。一个很好的例子是游戏：如果它有很好的可用性，那么它将非常简单，人们会快速完成它然后回到工作中去——这是一个经济上的胜利。但人们不会玩简单的游戏；他们玩那些给他们提供挑战的游戏，无论这个挑战是心理上的、灵巧上的还是其他什么。因此，玩家想要挑战或沉浸于游戏世界的愿望优先于其他，尽管很难为这种愿望赋予货币价值。
- en: Politics
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 政治
- en: 'The political side of software development can have an impact on how people
    think they are recognized, supported, empowered, and valued by the system in which
    the software is used and the wider system of interacting systems. Let''s start
    this section by looking at a case study: a shared calendar application used in
    a business. On one team, everyone can schedule events on their own calendar, and
    the manager can see everyone''s calendars. Additionally, the manager has a personal
    assistant who can schedule events for the manager in the manager''s calendar.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的政治面可能会影响人们认为自己在使用软件的系统以及更广泛的交互系统中所受到的认可、支持、赋权和价值。让我们从这个案例研究开始本节：一个在企业中使用的共享日历应用程序。在一个团队中，每个人都可以在自己的日历上安排事件，而经理可以看到所有人的日历。此外，经理还有一位个人助理，可以在经理的日历中为经理安排事件。
- en: The manager feels in a position of power, because they can see where everyone
    is and can strategically walk past their desks to see what they're up to at times
    when their reports should be there, because they don't have any meetings recorded.
    Additionally, the manager feels empowered because the mechanical work of updating
    the calendar software has been delegated to someone else, and delegation is a
    key activity for managers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 经理感到自己处于权力地位，因为他们可以看到每个人的位置，可以在报告应该在那里的时候，策略性地走过他们的办公桌，看看他们在忙什么，因为他们没有记录任何会议。此外，经理感到赋权，因为更新日历软件的机械工作已经委托给了别人，而委托是管理者的一项关键活动。
- en: On the other hand, the other members of the team feel empowered because they
    can control the manager through the calendar software. If they do not want to
    be disturbed, they can create themselves a "meeting" and find somewhere quiet
    to work. They can work with the personal assistant to arrange for the manager
    to be in a meeting at a time when they want to have a team discussion without
    the manager's involvement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，团队的其他成员感到赋权，因为他们可以通过日历软件控制经理。如果他们不想被打扰，他们可以为自己创建一个“会议”并找到一个安静的地方工作。他们可以与个人助理合作，安排经理在他们想要进行团队讨论而不希望经理参与的时间参加会议。
- en: 'This discussion about calendar software depends on an underlying model of the
    politics in the group using the calendar: I wrote it to rely on a *Marxist* model,
    exposing the struggle between the manager (playing the part of the capitalist)
    and the workers. Each group is represented by their own goals, which are, according
    to the model, inevitably in conflict. Stability is achieved by ensuring that conflicting
    goals do not come into direct opposition over a single issue.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日历软件的讨论依赖于使用日历的团队中的潜在政治模型：我写它是基于一个*马克思主义*模型，揭示了经理（扮演资本家角色）和工人之间的斗争。每个团队都代表着自己的目标，根据模型，这些目标不可避免地存在冲突。通过确保冲突的目标不会在单一问题上直接对立，从而实现稳定。
- en: Whether the people participating in this system are really engaged in the conflict
    presented in this model of the system – and whether individual participants would
    recognize that conflict or have a different perception of the system, is not captured
    within this model. It's an internally consistent story that has nothing to tell
    us about its own accuracy or applicability.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参与这个系统的人们是否真的参与了这个系统模型所呈现的冲突——以及个人参与者是否认识到这种冲突或对这个系统有不同的看法，这个模型并没有捕捉到。这是一个内部一致的叙述，它没有告诉我们关于其准确性或适用性的任何信息。
- en: In designing software to be used by multiple people, the real politics of the
    system of people and our model of those politics will both shape the interactions
    facilitated by the software. Will the software support an existing distribution
    of power or will it empower one group at the expense of others? Is the political
    structure modeled on a coarse level (as in the managers/workers case above) or
    are the different needs and expectations of every individual in the system captured?
    Will the software enable any new relationships or break some existing relationships?
    Will it even out inequalities, reinforce existing inequalities, or introduce new
    ones?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计供多个人使用的软件时，人和我们对其政治的模型的真实政治都会塑造软件促进的互动。软件会支持现有的权力分配，还是会以牺牲其他人为代价赋予某一群体权力？政治结构是在粗略的层面上建模的（如上例中的经理/工人案例）还是捕捉了系统中每个个体的不同需求和期望？软件会促进任何新的关系还是会破坏一些现有的关系？它会消除不平等，加强现有的不平等，还是会引入新的不平等？
- en: 'These are complex questions to address but it is necessary to answer them for
    the impact of collaborative software on its users to be fully understood. As the
    anecdote earlier in this section shows, software systems can have a real impact
    on real people: the management of a large business may be pleased to reduce their
    headcount after deploying new software, to recoup development costs, and see it
    as the responsibility of those who are made redundant to find alternative employment.
    A charity with a remit to support local people by providing work may prefer to
    retain the workers and reject the software. Only by understanding the political
    environment can you be sure that your software is a good social fit for its potential
    users and customers.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是复杂的，但为了全面理解协作软件对其用户的影响，回答这些问题是必要的。正如本节前面提到的轶事所示，软件系统可以对真实的人产生实际影响：一家大企业的管理层在部署新软件后可能会很高兴减少员工人数，以收回开发成本，并认为那些被裁员的员工有责任找到替代工作。一个有责任通过提供工作来支持当地人民的慈善机构可能更愿意保留工人并拒绝软件。只有通过理解政治环境，你才能确保你的软件对你的潜在用户和客户来说是良好的社会适应。
- en: Prioritizing Requirements
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先考虑需求
- en: 'This section really reiterates what came before: you should be building software
    that your users *need* in preference to what they *want*. That''s the ideology,
    anyway. Reality has this annoying habit of chipping in with a "well, *actually*"
    at this point.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节实际上重申了之前的内容：你应该优先构建用户*需要*的软件，而不是他们*想要*的软件。这是意识形态，无论如何。现实总是有这种讨厌的习惯，在这个时候插上一句“实际上”。
- en: 'It''s much easier to *sell* the thing the buyer wants than the thing they really
    need. Selling things is a good opportunity to take, as it allows you to fund other
    activities: perhaps including the development of the thing that the customers
    still needs. But, well, *actually*...'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 向买家推销他们真正需要的东西比推销他们想要的东西要容易得多。推销东西是一个很好的机会，因为它允许你资助其他活动：也许包括开发客户仍然需要的其他东西。但是，实际上...
- en: '...good marketing efforts can convince the customer that the thing they actually
    need is something they do in fact want. You can then shortcut all of the above
    discussion by making the thing people *should* be buying and convincing them to
    buy it. This is one of those high-risk, high-reward situations: yes, *selling
    people a faster horse*—[http://blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html](http://blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html)
    is easier but the margins will not be as high and the success not as long-lived
    as if you invent the motorcar industry. As they say, profit is a prize for taking
    a risk.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '...良好的营销努力可以说服客户，他们真正需要的东西是他们确实想要的。然后，你可以通过让人们*应该*购买的东西并说服他们购买它来跳过所有上述讨论。这是一种高风险、高回报的情况：是的，*向人们推销一匹更快的马*——[http://blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html](http://blogs.hbr.org/cs/2011/08/henry_ford_never_said_the_fast.html)更容易，但利润不会那么高，成功也不会那么持久，就像你发明汽车行业一样。正如他们所说，利润是承担风险的一种奖励。'
- en: 'So, how you prioritize building the software really depends on your comfortable
    risk level. You could get incremental low-margin gains by finding the things that
    people are definitely willing to buy and building those. This is the **Lean Start-up**
    approach, where you start with nothing and rapidly iterate towards what the data
    is telling you people want to buy. Or you could take the risk: build the thing
    you know people need, then convince them that it''s worth the money. This is the
    approach that bears most resemblance to Steve Jobs'' famous position: *It''s not
    up to customers to know what they want*.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何优先考虑构建软件，这实际上取决于你能够承受的风险水平。你可以通过找到人们肯定愿意购买的东西并构建它们来获得渐进的低利润收益。这是**精益创业**方法，你从无到有，快速迭代，直到数据告诉你人们想要购买什么。或者你可以承担风险：构建你知道人们需要的东西，然后说服他们这值得花钱。这种方法与史蒂夫·乔布斯著名的立场最为相似：*顾客不需要知道他们想要什么*。
- en: Is It Really "Engineering"?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这真的是“工程”吗？
- en: 'There''s an old quote that says anything where people feel the need to include
    the word "science" isn''t a science. And, yes, the original author was talking
    about computer science. But perhaps we should be wary of the attribution of "engineering"
    to requirements engineering. Engineering is, after all, the application of science
    to the manufacture of artifacts, while requirements engineering is the application
    of social science (the warning is firing again!) to the business of improving
    a social system. Really, it''s a transformation of some fields of social science
    (politics, economics, anthropology, ethnography, and geography) to other fields
    of social science (sociology and business studies) with some software created
    to effect the transformation. (Shortly after I finished writing this section,
    Paul Ralph submitted a paper to ArXiv describing **the rational and alternative
    paradigms**—[http://arxiv.org/abs/1303.5938v1](http://arxiv.org/abs/1303.5938v1)
    of software design. The rational paradigm is basically the intuition-based version
    of requirements engineering: the software requirements exist as a fundamental
    truth to the universe and can be derived from careful thought. The alternative
    paradigm is the empirical one: the requirements arise as a result of the interactions
    between people and can only be understood through observation. Ralph''s paper
    does a good job of explaining these two paradigms and putting them in context
    in the history of software design.)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有一句古老的格言说，任何需要包含“科学”这个词的东西都不是科学。是的，原文作者是在谈论计算机科学。但也许我们应该对将“工程”一词归因于需求工程持谨慎态度。毕竟，工程是将科学应用于制造实体的应用，而需求工程是将社会科学（社会学的警告又响了！）应用于改善社会系统的业务。实际上，它将某些社会科学领域（政治学、经济学、人类学、民族志和地理学）转变为其他社会科学领域（社会学和商业研究），并创建了一些软件来实现这种转变。（在我完成这一节不久之后，保罗·拉尔夫向ArXiv提交了一篇论文，描述了软件设计的**理性和替代范式**——[http://arxiv.org/abs/1303.5938v1](http://arxiv.org/abs/1303.5938v1)。理性范式基本上是基于直觉的需求工程版本：软件需求作为宇宙中的基本真理存在，可以通过仔细思考推导出来。替代范式是经验主义：需求是人们之间互动的结果，只能通过观察来理解。拉尔夫的论文很好地解释了这两种范式，并将它们置于软件设计历史背景中。）
- en: This isn't to say that the phrase "requirements engineering" needs to be retired,
    because people know what it means and use it as a placeholder for the real meaning
    of the discipline. But maybe we need to think of this as a generational thing;
    that while to *us* it's called "requirements engineering," we remember to give
    it a different term with the people we teach; something like "social software".
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说“需求工程”这个短语需要被淘汰，因为人们知道它的意思，并将其用作该学科真实含义的占位符。但也许我们需要将其视为一种代际现象；对我们来说，它被称为“需求工程”，我们记得在教别人的时候给它一个不同的术语；比如“社会软件”。
