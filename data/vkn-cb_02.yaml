- en: Image Presentation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像呈现
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating a Vulkan Instance with WSI extensions enabled
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建启用 WSI 扩展的 Vulkan 实例
- en: Creating a presentation surface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建呈现表面
- en: Selecting a queue family that supports presentation to a given surface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择支持向给定表面呈现的队列家族
- en: Creating a logical device with WSI extensions enabled
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建启用 WSI 扩展的逻辑设备
- en: Selecting a desired presentation mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所需的呈现模式
- en: Getting capabilities of a presentation surface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取呈现表面的功能
- en: Selecting a number of swapchain images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择交换链图像的数量
- en: Choosing a size of swapchain images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择交换链图像的大小
- en: Selecting desired usage scenarios of swapchain images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择交换链图像的期望使用场景
- en: Selecting a transformation of swapchain images
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择交换链图像的转换
- en: Selecting a format of swapchain images
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择交换链图像的格式
- en: Creating a swapchain
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建交换链
- en: Getting handles of swapchain images
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取交换链图像的句柄
- en: Creating a swapchain with R8G8B8A8 format and a mailbox present mode
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有 R8G8B8A8 格式和邮箱呈现模式的交换链
- en: Acquiring a swapchain image
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取交换链图像
- en: Presenting an image
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示图像
- en: Destroying a swapchain
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁交换链
- en: Destroying a presentation surface
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁呈现表面
- en: Introduction
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: APIs such as Vulkan can be used for many different purposes, such as mathematical
    and physical computations, image or video stream processing, and data visualizations.
    But the main purpose Vulkan was designed for and its most common usage is efficiently
    rendering 2D and 3D graphics. And when our application generates an image, we
    usually would like to display it on screen.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Vulkan 这样的 API 可以用于许多不同的目的，例如数学和物理计算、图像或视频流处理以及数据可视化。但 Vulkan 被设计的主要目的及其最常见的用途是高效渲染
    2D 和 3D 图形。当我们的应用程序生成图像时，我们通常希望将其显示在屏幕上。
- en: At first, it may seem surprising that the core of the Vulkan API doesn't allow
    for displaying generated images in the application's window. This is because Vulkan
    is a portable, cross-platform API but, unfortunately, there is no universal standard
    for presenting images on screen in different operating systems because they have
    drastically different architectures and standards.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能会觉得令人惊讶，Vulkan API 的核心不允许在应用程序窗口中显示生成的图像。这是因为 Vulkan 是一个可移植的、跨平台的 API，但不幸的是，由于不同的操作系统具有截然不同的架构和标准，因此在不同的操作系统上显示图像没有通用的标准。
- en: That's why a set of extensions was introduced for the Vulkan API which allow
    us to present generated images in an application's window. These extensions are
    commonly referred to as Windowing System Integration (WSI). Each operating system
    on which Vulkan is available has its own set of extensions that integrate Vulkan
    with the windowing system specific for a given OS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为 Vulkan API 引入了一组扩展，使我们能够在应用程序的窗口中呈现生成的图像。这些扩展通常被称为窗口系统集成（WSI）。Vulkan 可用的每个操作系统都有自己的扩展集，这些扩展将
    Vulkan 与特定操作系统的窗口系统集成在一起。
- en: The most important extension is the one which allows us to create a swapchain.
    A swapchain is an array of images that can be presented (displayed) to the user.
    In this chapter, we will be preparing for drawing images on screen--setting up
    image parameters such as format, size, and so on. We will also take a look at
    the various available **presentation** modes that determine the way images are
    displayed, that is, define whether vertical sync is enabled or disabled. And,
    finally, we will see how to present the images--display them in the application's
    window.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的扩展是允许我们创建交换链的那个。交换链是一组可以呈现给用户的图像。在本章中，我们将为在屏幕上绘制图像做准备——设置图像参数，如格式、大小等。我们还将查看各种可用的
    **呈现** 模式，这些模式决定了图像的显示方式，即定义是否启用垂直同步。最后，我们将了解如何展示图像——在应用程序窗口中显示它们。
- en: Creating a Vulkan Instance with WSI extensions enabled
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建启用 WSI 扩展的 Vulkan 实例
- en: To be able to properly display images on screen, we need to enable a set of
    WSI extensions. They are divided into instance- and device-levels, depending on
    the functionality they introduce. The first step is to create a Vulkan Instance
    with a set of enabled extensions that allow us to create a presentation surface--a
    Vulkan representation of an application's window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够正确地在屏幕上显示图像，我们需要启用一组 WSI 扩展。根据它们引入的功能，它们分为实例级和设备级。第一步是创建一个带有启用扩展的 Vulkan
    实例，这些扩展允许我们创建一个呈现表面——这是应用程序窗口的 Vulkan 表示。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the Windows operating systems family, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统家族中执行以下步骤：
- en: Prepare a variable of type `VkInstance` named `instance`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`instance`的类型为`VkInstance`的变量。
- en: Prepare a variable of type `std::vector<char const *>` named `desired_extensions`.
    Store the names of all extensions you want to enable in the `desired_extensions`
    variable.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`desired_extensions`的类型为`std::vector<char const *>`的变量。将您想要启用的所有扩展的名称存储在`desired_extensions`变量中。
- en: Add another element to the `desired_extensions` vector with the `VK_KHR_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Add yet another element to the `desired_extensions` vector with the `VK_KHR_WIN32_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_WIN32_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Create a Vulkan Instance object for which enable all of the extensions specified
    in the `desired_extensions` variable (refer to the *Creating a Vulkan Instance*
    recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instance
    and Devices*).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`desired_extensions`变量中指定的所有扩展创建一个Vulkan实例对象（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中的*创建Vulkan实例*配方，*实例和设备*）。
- en: 'On the Linux operating systems family with an **X11** windowing system through
    an **XLIB** interface, perform the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有**X11**窗口系统的Linux操作系统家族中通过**XLIB**接口执行以下步骤：
- en: Prepare a variable of type `VkInstance` named `instance`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`instance`的类型为`VkInstance`的变量。
- en: Prepare a variable of type `std::vector<char const *>` named `desired_extensions`.
    Store the names of all extensions you want to enable in the `desired_extensions`
    variable.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`desired_extensions`的类型为`std::vector<char const *>`的变量。将您想要启用的所有扩展的名称存储在`desired_extensions`变量中。
- en: Add another element to the `desired_extensions` vector with the `VK_KHR_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Add yet another element to the `desired_extensions` vector with the `VK_KHR_XLIB_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_XLIB_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Create a Vulkan Instance object for which enable all of the extensions specified
    in the `desired_extensions` variable (refer to the *Creating a Vulkan Instance*
    recipe from [Chapter 1](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&action=edit#post_42),
    *Instance and Devices*).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`desired_extensions`变量中指定的所有扩展创建一个Vulkan实例对象（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中的*创建Vulkan实例*配方，*实例和设备*）。
- en: 'On the Linux operating systems family with an X11 windowing system through
    an **XCB** interface, perform the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有X11窗口系统的Linux操作系统家族中通过**XCB**接口执行以下步骤：
- en: Prepare a variable of type `VkInstance` named `instance`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`instance`的类型为`VkInstance`的变量。
- en: Prepare a variable of type `std::vector<char const *>` named `desired_extensions`.
    Store the names of all extensions you want to enable in the `desired_extensions`
    variable.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`desired_extensions`的类型为`std::vector<char const *>`的变量。将您想要启用的所有扩展的名称存储在`desired_extensions`变量中。
- en: Add another element to the `desired_extensions` vector with the `VK_KHR_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Add yet another element to the `desired_extensions` vector with the `VK_KHR_XCB_SURFACE_EXTENSION_NAME`
    value.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`VK_KHR_XCB_SURFACE_EXTENSION_NAME`值添加到`desired_extensions`向量中另一个元素。
- en: Create a Vulkan Instance object for which enable all of the extensions specified
    in the `desired_extensions` variable (refer to the *Creating a Vulkan Instance*
    recipe from [Chapter 1](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&action=edit#post_42),
    *Instance and Devices*).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`desired_extensions`变量中指定的所有扩展创建一个Vulkan实例对象（参考[第1章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&action=edit#post_42)中的*创建Vulkan实例*配方，*实例和设备*）。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instance-level extensions are responsible for managing, creating, and destroying
    a presentation surface. It is a (cross-platform) representation of an application's
    window. Through it, we can check whether we are able to draw to the window (displaying
    an image, a presentation, is an additional property of a queue family), what its
    parameters are, or what presentation modes are supported (if we want the vertical
    sync to be enabled or disabled).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实例级别的扩展负责管理、创建和销毁一个呈现表面。它是应用程序窗口的（跨平台）表示。通过它，我们可以检查我们是否能够向窗口绘制（显示图像、呈现是队列家族的附加属性），它的参数是什么，或者支持哪些呈现模式（如果我们想启用或禁用垂直同步）。
- en: The presentation surface is directly connected to our application's window,
    so it can be created only in a way that is specific for a given operating system.
    That's why this functionality is introduced through extensions and each operating
    system has its own extension for creating a presentation surface. On the Windows
    operating systems family, this extension is called `VK_KHR_win32_surface`. On
    the Linux operating systems family with an X11 windowing system, this extension
    is called `VK_KHR_xlib_surface`. On the Linux operating systems family with an
    XCB windowing system, this extension is called `VK_KHR_xcb_surface`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显示表面直接连接到我们的应用程序窗口，因此只能以特定于给定操作系统的特定方式创建。这就是为什么这种功能是通过扩展引入的，每个操作系统都有自己的扩展来创建显示表面。在
    Windows 操作系统家族中，这个扩展称为 `VK_KHR_win32_surface`。在具有 X11 窗口系统的 Linux 操作系统家族中，这个扩展称为
    `VK_KHR_xlib_surface`。在具有 XCB 窗口系统的 Linux 操作系统家族中，这个扩展称为 `VK_KHR_xcb_surface`。
- en: The functionality of destroying a presentation surface is enabled via an additional
    extension called `VK_KHR_surface`. It is available on all operating systems. So
    in order to properly manage a presentation surface, check its parameters, and
    verify the ability to present to it, we need to enable two extensions during Vulkan
    Instance creation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁显示表面的功能是通过一个名为 `VK_KHR_surface` 的附加扩展启用的。它在所有操作系统上都是可用的。因此，为了正确管理显示表面、检查其参数并验证向其呈现的能力，我们需要在创建
    Vulkan 实例时启用两个扩展。
- en: '`VK_KHR_win32_surface` and `VK_KHR_surface` extensions introduce the ability
    to create and destroy a presentation surface on the Windows OS family.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_KHR_win32_surface` 和 `VK_KHR_surface` 扩展引入了在 Windows 操作系统家族中创建和销毁显示表面的能力。'
- en: '`VK_KHR_xlib_surface` and `VK_KHR_surface` extensions introduce the ability
    to create and destroy a presentation surface on the Linux OS family with an X11
    windowing system and an XLIB interface.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_KHR_xlib_surface` 和 `VK_KHR_surface` 扩展引入了在 Linux 操作系统家族中使用 X11 窗口系统和 XLIB
    接口创建和销毁显示表面的能力。'
- en: '`VK_KHR_xcb_surface` and `VK_KHR_surface` extensions introduce the ability
    to create and destroy a presentation surface on the Linux OS family with an X11
    windowing system and an XCB interface.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_KHR_xcb_surface` 和 `VK_KHR_surface` 扩展引入了在 Linux 操作系统家族中使用 X11 窗口系统和 XCB
    接口创建和销毁显示表面的能力。'
- en: 'In order to create a Vulkan Instance that supports the process of creating
    and destroying a presentation surface, we need to prepare the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个支持创建和销毁显示表面过程的 Vulkan 实例，我们需要准备以下代码：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we begin with a vector variable in which the names of
    all extensions we want to enable are stored. We then add the required WSI extensions
    to the vector. The names of these extensions are provided through convenient preprocessor
    definitions. They are defined in the `vulkan.h` file. With them, we don't need
    to remember the exact names of extensions and if we make a mistake, compiler will
    tell us about it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从一个向量变量开始，其中存储了我们想要启用的所有扩展的名称。然后我们将所需的 WSI 扩展添加到向量中。这些扩展的名称通过方便的预处理器定义提供。它们在
    `vulkan.h` 文件中定义。有了它们，我们不需要记住扩展的确切名称，如果出错，编译器会告诉我们。
- en: After we are done preparing the list of required extensions, we can create a
    Vulkan Instance object in the same way as described in the *Creating a Vulkan
    Instance* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备好所需扩展的列表后，我们可以像在 [第 1 章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml) 的
    *创建 Vulkan 实例* 配方中描述的那样创建 Vulkan 实例对象。
- en: See also
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instance and Devices*
    see the following recipes:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml) 的 *实例和设备* 部分中，查看以下配方：
- en: '*Checking available Instance extensions*'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的实例扩展*'
- en: '*Creating a Vulkan Instance*'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 Vulkan 实例*'
- en: 'The following recipe in this chapter:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a logical device with WSI extensions enabled*'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*启用 WSI 扩展创建逻辑设备*'
- en: Creating a presentation surface
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建显示表面
- en: A presentation surface represents an application's window. It allows us to acquire
    the window's parameters, such as dimensions, supported color formats, required
    number of images, or presentation modes. It also allows us to check whether a
    given physical device is able to display an image in a given window.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显示表面代表应用程序的窗口。它允许我们获取窗口的参数，例如尺寸、支持的颜色格式、所需图像数量或显示模式。它还允许我们检查给定的物理设备是否能够在给定的窗口中显示图像。
- en: That's why, in situations where we want to show an image on screen, we need
    to create a presentation surface first, as it will help us choose a physical device
    that suits our needs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们想在屏幕上显示图像的情况下，我们首先需要创建一个显示表面，因为它将帮助我们选择一个符合我们需求的物理设备。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create a presentation surface, we need to provide the parameters of an application''s
    window. In order to do that, the window must have been already created. In this
    recipe, we will provide its parameters through a structure of type `WindowParameters`.
    Its definition looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个显示表面，我们需要提供应用程序窗口的参数。为了做到这一点，窗口必须已经创建。在这个菜谱中，我们将通过一个类型为 `WindowParameters`
    的结构来提供其参数。其定义看起来像这样：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Windows, the structure contains the following parameters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，该结构包含以下参数：
- en: A variable of type `HINSTANCE` named `HInstance` in which we store the value
    acquired using the `GetModuleHandle()` function
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `HInstance` 的类型为 `HINSTANCE` 的变量，其中我们存储使用 `GetModuleHandle()` 函数获取的值
- en: A variable of type `HWND` named `HWnd` in which we store a value returned by
    the `CreateWindow()` function
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `HWnd` 的类型为 `HWND` 的变量，其中我们存储了 `CreateWindow()` 函数返回的值
- en: 'On Linux with an X11 windowing system and an XLIB interface, the structure
    contains the following members:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 的 X11 窗口系统和 XLIB 接口中，该结构包含以下成员：
- en: A variable of type `Display*` named `Dpy` in which the value of the `XOpenDisplay()`
    function call is stored
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Dpy` 的类型为 `Display*` 的变量，其中存储了 `XOpenDisplay()` 函数调用的值
- en: A variable of type `Window` named `Window` to which we assign a value returned
    by `XCreateWindow()` or `XCreateSimpleWindow()` functions
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Window` 的类型为 `Window` 的变量，我们将 `XCreateWindow()` 或 `XCreateSimpleWindow()`
    函数返回的值赋给它
- en: 'On Linux with an X11 windowing system and an XCB interface, the `WindowParameters`
    structure contains the following members:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 的 X11 窗口系统和 XCB 接口中，`WindowParameters` 结构包含以下成员：
- en: A variable of type `xcb_connection_t*` named `Connection` in which we store
    a value returned by the `xcb_connect()` function
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Connection` 的类型为 `xcb_connection_t*` 的变量，其中存储了 `xcb_connect()` 函数返回的值
- en: A variable of type `xcb_window_t` named `Window` in which a value returned by
    the `xcb_generate_id()` function is stored
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `Window` 的类型为 `xcb_window_t` 的变量，其中存储了 `xcb_generate_id()` 函数返回的值
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'On the Windows operating systems family, perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统家族中，执行以下步骤：
- en: Take the variable of type `VkInstance` named `instance` in which a handle of
    a created Vulkan Instance is stored.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个名为 `instance` 的类型为 `VkInstance` 的变量，其中存储了一个创建的 Vulkan 实例的句柄。
- en: 'Create a variable of type `WindowParameters` named `window_parameters`. Assign
    the following values for its members:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `window_parameters` 的类型为 `WindowParameters` 的变量。为其成员分配以下值：
- en: A value returned by the `CreateWindow()` function for `HWnd`
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateWindow()` 函数为 `HWnd` 返回的值'
- en: A value returned by the `GetModuleHandle(nullptr)` function for `HInstance`
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetModuleHandle(nullptr)` 函数返回的值用于 `HInstance`'
- en: 'Create a variable of type `VkWin32SurfaceCreateInfoKHR` named `surface_create_info`
    and initialize its members with the following values:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_create_info` 的类型为 `VkWin32SurfaceCreateInfoKHR` 的变量，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR` value for `sType`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR` 的值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullptr` 的值用于 `pNext`'
- en: '`0` value for `flags`'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 的值用于 `flags`'
- en: '`window_parameters.HInstance` member for `hinstance`'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window_parameters.HInstance` 成员用于 `hinstance`'
- en: '`window_parameters.HWnd` member for `hwnd`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window_parameters.HWnd` 成员用于 `hwnd`'
- en: Create a variable of type `VkSurfaceKHR` named `presentation_surface` and assign
    a `VK_NULL_HANDLE` value to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `presentation_surface` 的类型为 `VkSurfaceKHR` 的变量，并将其赋值为 `VK_NULL_HANDLE`。
- en: Call `vkCreateWin32SurfaceKHR(instance, &surface_create_info, nullptr, &presentation_surface)`.
    Provide a handle of a created Instance in the first parameter, a pointer to the
    `surface_create_info` variable in the second parameter, a `nullptr` value in the
    third parameter, and a pointer to the `presentation_surface` variable in the last
    parameter.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateWin32SurfaceKHR(instance, &surface_create_info, nullptr, &presentation_surface)`。在第一个参数中提供一个创建的实例的句柄，在第二个参数中提供一个指向
    `surface_create_info` 变量的指针，在第三个参数中使用 `nullptr` 值，在最后一个参数中提供一个指向 `presentation_surface`
    变量的指针。
- en: Make sure the `vkCreateWin32SurfaceKHR()` function call was successful by checking
    whether the value returned by it is equal to `VK_SUCCESS` and the value of the `presentation_surface`
    variable is not equal to a `VK_NULL_HANDLE`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用 `vkCreateWin32SurfaceKHR()` 函数成功，通过检查其返回值是否等于 `VK_SUCCESS` 以及 `presentation_surface`
    变量的值是否不等于 `VK_NULL_HANDLE`。
- en: 'On the Linux operating systems family with an X11 windowing system and an XLIB
    interface, perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有 X11 窗口系统和 XLIB 接口的 Linux 操作系统家族上，执行以下步骤：
- en: Take the variable of type `VkInstance` named `instance` in which a handle of
    a created Vulkan Instance is stored.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取名为 `instance` 的类型为 `VkInstance` 的变量，其中存储了一个创建的 Vulkan 实例的句柄。
- en: 'Create a variable of type `WindowParameters` named `window_parameters`. Assign
    the following values for its members:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `window_parameters` 的类型为 `WindowParameters` 的变量。为其成员分配以下值：
- en: A value returned by the `XOpenDisplay()` function for `Dpy`
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XOpenDisplay()` 函数为 `Dpy` 返回的值'
- en: A value returned by the `XCreateSimpleWindow()` or `XCreateWindow()` functions
    for `Window`
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCreateSimpleWindow()` 或 `XCreateWindow()` 函数为 `Window` 返回的值'
- en: 'Create a variable of type `VkXlibSurfaceCreateInfoKHR` named `surface_create_info`
    and initialize its members with the following values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_create_info` 的类型为 `VkXlibSurfaceCreateInfoKHR` 的变量，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR` value for `sType`'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR` 的值用于 `sType`'
- en: '`nullptr` value for `pNext`'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: '`0` value for `flags`'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的值为 `0`'
- en: '`window_parameters.Dpy` member for `dpy`'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpy` 的 `window_parameters.Dpy` 成员'
- en: '`window_parameters.Window` member for `window`'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window` 的 `window_parameters.Window` 成员'
- en: Create a variable of type `VkSurfaceKHR` named `presentation_surface` and assign
    a `VK_NULL_HANDLE` value to it.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `presentation_surface` 的类型为 `VkSurfaceKHR` 的变量，并将其值设置为 `VK_NULL_HANDLE`。
- en: Call `vkCreateXlibSurfaceKHR(instance, &surface_create_info, nullptr, &presentation_surface)`.
    Provide a handle of a created Instance in the first parameter, pointer to the
    `surface_create_info` variable in the second parameter, a `nullptr` value in the
    third parameter, and a pointer to the `presentation_surface` variable in the last
    parameter.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateXlibSurfaceKHR(instance, &surface_create_info, nullptr, &presentation_surface)`。在第一个参数中提供一个创建的实例的句柄，在第二个参数中提供一个指向
    `surface_create_info` 变量的指针，在第三个参数中使用 `nullptr` 值，在最后一个参数中提供一个指向 `presentation_surface`
    变量的指针。
- en: Make sure the `vkCreateXlibSurfaceKHR()` function call was successful by checking
    whether the value returned by it is equal to `VK_SUCCESS` and the value of the `presentation_surface`
    variable is not equal to `VK_NULL_HANDLE`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查 `vkCreateXlibSurfaceKHR()` 函数返回的值是否等于 `VK_SUCCESS` 以及 `presentation_surface`
    变量的值是否不等于 `VK_NULL_HANDLE`，确保 `vkCreateXlibSurfaceKHR()` 函数调用成功。
- en: 'On the Linux operating systems family with an X11 windowing system and an XCB
    interface, perform the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有 X11 窗口系统和 XCB 接口的 Linux 操作系统家族上，执行以下步骤：
- en: Take the variable of type `VkInstance` named `instance` in which a handle of
    a created Vulkan Instance is stored.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取名为 `instance` 的类型为 `VkInstance` 的变量，其中存储了一个创建的 Vulkan 实例的句柄。
- en: 'Create a variable of type `WindowParameters` named `window_parameters`. Assign
    the following values for its members:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `window_parameters` 的类型为 `WindowParameters` 的变量。为其成员分配以下值：
- en: A value returned by the `xcb_connect()` function for `Connection`
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xcb_connect()` 函数为 `Connection` 返回的值'
- en: A value returned by the `xcb_generate_id()` functions for `Window`
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xcb_generate_id()` 函数为 `Window` 返回的值'
- en: 'Create a variable of type `VkXcbSurfaceCreateInfoKHR` named `surface_create_info`
    and initialize it''s members with the following values:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_create_info` 的类型为 `VkXcbSurfaceCreateInfoKHR` 的变量，并使用以下值初始化其成员：
- en: '`VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR` value for `sType`'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sType` 的值为 `VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR`'
- en: '`nullptr` value for `pNext`'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的值为 `nullptr`'
- en: '`0` value for `flags`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 的值为 `0`'
- en: '`window_parameters.Connection` member for `connection`'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection` 的 `window_parameters.Connection` 成员'
- en: '`window_parameters.Window` member for `window`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window` 的 `window_parameters.Window` 成员'
- en: Create a variable of type `VkSurfaceKHR` named `presentation_surface` and assign
    a `VK_NULL_HANDLE` value to it.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `presentation_surface` 的类型为 `VkSurfaceKHR` 的变量，并将其值设置为 `VK_NULL_HANDLE`。
- en: Call `vkCreateXcbSurfaceKHR( instance, &surface_create_info, nullptr, &presentation_surface
    )`. Provide a handle of a created Instance in the first parameter, a pointer to
    the `surface_create_info` variable in the second parameter, a `nullptr` value
    in the third parameter, and a pointer to the `presentation_surface` variable in
    the last parameter.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkCreateXcbSurfaceKHR(instance, &surface_create_info, nullptr, &presentation_surface)`。在第一个参数中提供一个创建的实例的句柄，在第二个参数中提供一个指向
    `surface_create_info` 变量的指针，在第三个参数中使用 `nullptr` 值，在最后一个参数中提供一个指向 `presentation_surface`
    变量的指针。
- en: Make sure the `vkCreateXcbSurfaceKHR()` function call was successful by checking
    whether the value returned by it is equal to `VK_SUCCESS` and the value of the `presentation_surface`
    variable is not equal to `VK_NULL_HANDLE`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`vkCreateXcbSurfaceKHR()`函数返回的值是否等于`VK_SUCCESS`以及`presentation_surface`变量的值是否不等于`VK_NULL_HANDLE`，确保该函数调用成功。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Presentation surface creation depends heavily on parameters that are specific
    for a given operating system. On each OS, we need to create a variable of a different
    type and call a different function. Here is a code that creates a presentation
    surface on Windows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 展示表面的创建在很大程度上依赖于特定于给定操作系统的参数。在每种操作系统上，我们需要创建不同类型的变量并调用不同的函数。以下是在Windows上创建展示表面的代码：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is a part of the code that does the same on the Linux operating system,
    when we are using the X11 windowing system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Linux操作系统上使用X11窗口系统时执行相同操作的代码片段：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, here is the part for the XCB windowing system, also on Linux:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是Linux上的XCB窗口系统的部分，同样是在Linux上：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code samples are very similar. In each, we create a variable
    of a structure type whose members we initialize with parameters of a created window.
    Next we call a `vkCreate???SurfaceKHR()` function which creates a presentation
    surface and stores its handle in the `presentation_surface` variable. After that,
    we should check whether everything worked as expected:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例非常相似。在每个示例中，我们创建了一个结构类型变量，并用创建的窗口的参数初始化其成员。接下来，我们调用一个`vkCreate???SurfaceKHR()`函数来创建展示表面，并将其句柄存储在`presentation_surface`变量中。之后，我们应该检查一切是否按预期工作：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取展示表面的能力*'
- en: '*Creating a swapchain*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: '*Destroying a presentation surface*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*销毁展示表面*'
- en: Selecting a queue family that supports presentation to a given surface
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择支持向给定表面展示的队列家族
- en: Displaying an image on screen is performed by submitting a special command to
    the device's queue. We can't display images using any queues we want or, in other
    words, we can't submit this operation to any queue. This is because it may not
    be supported. Image presentation, along with the graphics, compute, transfer,
    and sparse operations, is another property of a queue family. And similar to all
    types of operations, not all queues may support it and, more importantly, not
    even all devices may support it. That's why we need to check what queue family
    from which physical device allows us to present an image on screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像是通过向设备的队列提交一个特殊命令来完成的。我们不能使用任何我们想要的队列来显示图像，换句话说，我们不能将此操作提交给任何队列。这是因为可能不支持。图像展示，连同图形、计算、传输和稀疏操作，是队列家族的另一个属性。并且与所有类型的操作类似，并非所有队列都支持它，更重要的是，甚至并非所有设备都支持它。这就是为什么我们需要检查哪个物理设备所属的队列家族允许我们在屏幕上展示图像。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a physical device returned by the `vkEnumeratePhysicalDevices()`
    function. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由`vkEnumeratePhysicalDevices()`函数返回的物理设备的句柄。将其存储在名为`physical_device`的`VkPhysicalDevice`类型变量中。
- en: Take the created presentation surface and store its handle in a variable of
    type `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的展示表面及其句柄存储在名为`presentation_surface`的`VkSurfaceKHR`类型变量中。
- en: Create a `std::vector` with elements of type `VkQueueFamilyProperties` and call
    it `queue_families`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`VkQueueFamilyProperties`类型元素的`std::vector`，并将其命名为`queue_families`。
- en: Enumerate all queue families that are available on a physical device represented
    by the `physical_device` variable (refer to the *Checking available queue families
    and their properties* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*). Store the results of this operation in the `queue_families`
    variable.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举由`physical_device`变量表示的物理设备上可用的所有队列家族（参考第1章中的*检查可用的队列家族及其属性*食谱）。将此操作的结果存储在`queue_families`变量中。
- en: Create a variable of type `uint32_t` named `queue_family_index`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`queue_family_index`的`uint32_t`类型变量。
- en: 'Create a variable of type `uint32_t` named `index`. Use it to loop over all
    elements of the `queue_families` vector. For each element of the `queue_families`
    variable, perform the following steps:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index`的`uint32_t`类型变量。使用它来遍历`queue_families`向量的所有元素。对于`queue_families`变量的每个元素，执行以下步骤：
- en: Create a variable of type `VkBool32` named `presentation_supported`. Assign
    a value of `VK_FALSE` to this variable.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`presentation_supported`的`VkBool32`类型的变量。将值`VK_FALSE`分配给这个变量。
- en: Call `vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, index, presentation_surface,
    &presentation_supported)`. Provide a handle of the physical device in the first
    argument, the number of the current loop iteration in the second argument, and
    a handle of the presentation surface in the third argument. Also, provide a pointer
    to the `presentation_supported` variable in the last argument.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, index, presentation_surface,
    &presentation_supported)`。在第一个参数中提供物理设备的句柄，在第二个参数中提供当前循环迭代的数字，在第三个参数中提供呈现表面的句柄。同时，在最后一个参数中提供`presentation_supported`变量的指针。
- en: Check whether the value returned by the `vkGetPhysicalDeviceSurfaceSupportKHR() `function
    is equal to `VK_SUCCESS` and whether the value of the `presentation_supported`
    variable is equal to `VK_TRUE`. If it is, store the value of a current loop iteration
    (`index` variable) in the `queue_family_index` variable and finish the loop.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`vkGetPhysicalDeviceSurfaceSupportKHR()`函数返回的值是否等于`VK_SUCCESS`，以及`presentation_supported`变量的值是否等于`VK_TRUE`。如果是，将当前循环迭代的值（`index`变量）存储在`queue_family_index`变量中，并结束循环。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First we need to check what queue families are exposed by a given physical
    device. This operation is performed the same way as described in the *Checking
    available queue families and their properties* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查给定物理设备暴露了哪些队列家族。这个操作与[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)的*实例和设备*部分中描述的*检查可用的队列家族及其属性*食谱中的方式相同：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next we can iterate over all available queue families and check whether a given
    family supports image presentation. This is performed by calling a `vkGetPhysicalDeviceSurfaceSupportKHR()`
    function which stores the information in a specified variable. If the image presentation
    is supported, we can remember an index of a given family. All queues from this
    family will support image presentation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以遍历所有可用的队列家族，并检查给定的家族是否支持图像呈现。这是通过调用`vkGetPhysicalDeviceSurfaceSupportKHR()`函数来完成的，该函数将信息存储在指定的变量中。如果支持图像呈现，我们可以记住给定家族的索引。从这个家族的所有队列都将支持图像呈现：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When there is no queue family exported by a given physical device that supports
    image presentation, we must check whether this operation is available on another
    physical device.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有队列家族由给定的物理设备导出以支持图像呈现时，我们必须检查此操作是否可在另一个物理设备上执行。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'In [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instance and Devices*
    see the following recipes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)的*实例和设备*部分，查看以下食谱：
- en: '*Checking available queue families and their properties*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的队列家族及其属性*'
- en: '*Selecting index of a queue family with desired capabilities*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择具有所需功能的队列家族的索引*'
- en: '*Creating a logical device*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: Creating a logical device with WSI extensions enabled
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建启用了WSI扩展的逻辑设备
- en: When we have created an Instance with WSI extensions enabled and have found
    a queue family that supports image presentation, it is time to create a logical
    device with another extension enabled. A device-level WSI extension allows us
    to create a swapchain. This is a collection of images which are managed by the
    presentation engine. In order to use any of these images and to render into them,
    we need to acquire them. After we are done, we give it back to the presentation
    engine. This operation is called a presentation and it informs the driver that
    we want to show an image to the user (present or display it on screen). The presentation
    engine displays it according to the parameters defined during swapchain creation.
    And we can create it only on logical devices with an enabled swapchain extension.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建了一个启用了WSI扩展的实例，并且找到了一个支持图像呈现的队列家族时，就是时候创建一个启用了另一个扩展的逻辑设备了。设备级别的WSI扩展允许我们创建一个swapchain。这是一个由呈现引擎管理的图像集合。为了使用这些图像并将它们渲染到其中，我们需要获取它们。完成之后，我们将它们归还给呈现引擎。这个操作被称为呈现，它通知驱动程序我们想要向用户展示一个图像（在屏幕上呈现或显示它）。呈现引擎根据在swapchain创建期间定义的参数来显示它。我们只能在启用了swapchain扩展的逻辑设备上创建它。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a physical device, for which there is a queue family that
    supports image presentation, and store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个物理设备的句柄，该设备有一个支持图像呈现的队列家族，并将其存储在一个名为 `VkPhysicalDevice` 的变量中。
- en: Prepare a list of queue families and a number of queues from each family. Assign
    a priority (a floating-point value between `0.0f` and `1.0f`) for each queue from
    each family. Store these parameters in a `std::vector` variable named `queue_infos`
    with elements of a custom type `QueueInfo` (refer to the *Creating a logical device*
    recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml), *Instance
    and Devices*). Remember to include at least one queue from a family that supports
    image presentation.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个队列家族列表和每个家族的队列数量。为每个家族中的每个队列分配一个优先级（一个介于 `0.0f` 和 `1.0f` 之间的浮点值）。将这些参数存储在一个名为
    `queue_infos` 的 `std::vector` 变量中，其元素为自定义类型 `QueueInfo`（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中的
    *创建逻辑设备* 菜单，*实例和设备*）。请记住，至少包含一个支持图像呈现的家族的队列。
- en: Prepare a list of extensions that should be enabled. Store it in a variable
    of type `std::vector<char const *>` named `desired_extensions`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个应启用扩展的列表。将其存储在一个名为 `desired_extensions` 的 `std::vector<char const *>` 类型的变量中。
- en: Add another element to the `desired_extensions` variable with value equal to
    `VK_KHR_SWAPCHAIN_EXTENSION_NAME`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个元素添加到 `desired_extensions` 变量中，其值等于 `VK_KHR_SWAPCHAIN_EXTENSION_NAME`。
- en: Create a logical device using the parameters prepared in the `physical_device`
    and `queue_infos` variable and with all extensions enabled from the `desired_extensions`
    vector (refer to the *Creating a logical device* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在 `physical_device` 和 `queue_infos` 变量中准备的参数，以及从 `desired_extensions` 向量中启用的所有扩展来创建一个逻辑设备（参考[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中的
    *创建逻辑设备* 菜单，*实例和设备*）。
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we want to display images on screen, there is only one device-level extension
    that needs to be enabled during logical device creation. This is called `VK_KHR_swapchain`
    and allows us to create a swapchain.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在屏幕上显示图像时，在创建逻辑设备期间需要启用一个设备级扩展。这被称为 `VK_KHR_swapchain`，它允许我们创建交换链。
- en: A swapchain defines parameters that are very similar to the parameters of a
    default drawing buffer in the OpenGL API. It specifies, among others, the format
    of an image we want to render to, the number of images (which can be thought of
    as double or triple buffering), or a presentation mode (v-sync enabled or disabled).
    Images created along the swapchain are owned and managed by the presentation engine.
    We are not allowed to create or destroy them by ourselves. We can't even use them
    until we ask to do this. When we want to display an image on screen, we need to
    ask for one of the swapchain images (acquire it), render into it, and then give
    the image back to the presentation engine (present it).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 交换链定义了与OpenGL API中默认绘制缓冲区参数非常相似的参数。它指定了我们要渲染到的图像的格式、图像的数量（可以认为是双缓冲或三缓冲），或呈现模式（启用或禁用v-sync）。在交换链中创建的图像由呈现引擎拥有和管理。我们不允许自己创建或销毁它们。我们甚至不能使用它们，直到我们请求这样做。当我们想在屏幕上显示图像时，我们需要请求交换链中的一个图像（获取它），将其渲染进去，然后将图像交还给呈现引擎（呈现它）。
- en: The ability to specify a set of presentable images, to acquire them, and to
    display them on screen is defined in a `VK_KHR_swapchain` extension.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一组可显示的图像、获取它们以及在屏幕上显示它们的功能由 `VK_KHR_swapchain` 扩展定义。
- en: 'The functionality described is defined in the `VK_KHR_swapchain` extension.
    To enable it during logical device creation, we need to prepare the following
    code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的功能由 `VK_KHR_swapchain` 扩展定义。要在创建逻辑设备时启用它，我们需要准备以下代码：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The logical device creation code is identical to the operation described in
    the *Creating a logical device* recipe from [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices*. Here, we just need to remember that we must check whether
    a given physical device supports a `VK_KHR_swapchain` extension, and after that,
    we need to include it in a list of extensions that should be enabled.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑设备创建的代码与[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中描述的 *创建逻辑设备* 菜单中的操作相同，*实例和设备*。在这里，我们只需要记住，我们必须检查给定的物理设备是否支持
    `VK_KHR_swapchain` 扩展，然后我们需要将其包含在应启用的扩展列表中。
- en: The name of the extension is specified through a `VK_KHR_SWAPCHAIN_EXTENSION_NAME`
    preprocessor definition. It is defined in the `vulkan.h` header file and it helps
    us avoid making typos in the name of the extension.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的名称通过`VK_KHR_SWAPCHAIN_EXTENSION_NAME`预处理器定义指定。它在`vulkan.h`头文件中定义，帮助我们避免在扩展名称中出错。
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The following recipes in [Chapter 1](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml),
    *Instance and Devices:*
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](d10e8284-6122-4d0a-8f86-ab0bc0bba47e.xhtml)中的以下配方，*实例和设备：*
- en: '*Checking available device extensions*'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查可用的设备扩展*'
- en: '*Creating a logical device*'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建逻辑设备*'
- en: The recipe *Creating a Vulkan Instance with WSI extensions* enabled in this
    chapter
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中启用WSI扩展的*创建Vulkan实例*配方
- en: Selecting a desired presentation mode
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择期望的显示模式
- en: The ability to display images on screen is one of the most important features
    of a Vulkan's swapchain--and, in fact, it's what a swapchain was designed for.
    In OpenGL, when we finished rendering to a back buffer, we just switched it with
    a front buffer and the rendered image was displayed on screen. We could only determine
    whether we wanted to display an image along with blanking intervals (if we wanted
    a v-sync to be enabled) or not.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示图像是Vulkan交换链最重要的功能之一——实际上，这也是交换链被设计的目的。在OpenGL中，当我们完成对后缓冲区的渲染后，我们只需将其与前缓冲区交换，渲染的图像就会显示在屏幕上。我们只能确定是否要显示图像以及是否要使用空白间隔（如果我们想启用v-sync）。
- en: In Vulkan, we are not limited to only one image (back buffer) to which we can
    render. And, instead of two (v-sync enabled or disabled), we can select one of
    more ways in which images are displayed on screen. This is called a presentation
    mode and we need to specify it during swapchain creation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vulkan中，我们不仅限于只能渲染一个图像（后缓冲区）。而且，我们可以在图像在屏幕上显示的方式中选择一种或多种方式，而不是两种（启用或禁用v-sync）。这被称为显示模式，我们需要在创建交换链时指定它。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Take the handle of a physical device enumerated with the `vkEnumeratePhysicalDevices()`
    function. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`vkEnumeratePhysicalDevices()`函数枚举物理设备。将其存储在名为`physical_device`的`VkPhysicalDevice`类型的变量中。
- en: Take the created presentation surface and store its handle in a variable of
    type `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的显示表面及其句柄存储在名为`presentation_surface`的`VkSurfaceKHR`类型的变量中。
- en: Create a variable of type `VkPresentModeKHR` named `desired_present_mode`. Store
    a desired presentation mode in this variable.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`desired_present_mode`的`VkPresentModeKHR`类型的变量。将期望的显示模式存储在这个变量中。
- en: Prepare a variable of type `uint32_t` named `present_modes_count`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为`present_modes_count`的`uint32_t`类型的变量。
- en: Call `vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, presentation_surface,
    &present_modes_count, nullptr)`. Provide a handle of a physical device and a handle
    of a presentation surface as the first two arguments. In the third parameter,
    provide a pointer to the `present_modes_count` variable.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, presentation_surface,
    &present_modes_count, nullptr)`。将物理设备的句柄和显示表面的句柄作为前两个参数提供。在第三个参数中，提供一个指向`present_modes_count`变量的指针。
- en: If a function call is successful, the `present_modes_count` variable will contain
    the number of supported presentation modes.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，则`present_modes_count`变量将包含支持的显示模式数量。
- en: Create a variable of type `std::vector<VkPresentModeKHR>` named `present_modes`.
    Resize the vector to be large enough to contain at least `present_modes_count`
    elements.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`present_modes`的`std::vector<VkPresentModeKHR>`类型的变量。将向量的大小调整为至少包含`present_modes_count`个元素。
- en: Once again, call `vkGetPhysicalDeviceSurfacePresentModesKHR( physical_device,
    presentation_surface, &present_modes_count, &present_modes[0])`, but this time,
    in the last parameter, provide a pointer to the first element of the `present_modes`
    vector.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, presentation_surface,
    &present_modes_count, &present_modes[0])`，但这次，在最后一个参数中，提供一个指向`present_modes`向量第一个元素的指针。
- en: If the function returns a `VK_SUCCESS` value, the `present_modes` variable will
    contain the present modes supported on a given platform.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数返回`VK_SUCCESS`值，则`present_modes`变量将包含在给定平台上支持的显示模式。
- en: Iterate over all elements of the `present_modes` vector. Check whether one of
    the elements is equal to the desired present mode stored in the `desired_present_mode`
    variable.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`present_modes`向量的所有元素。检查这些元素中是否有与存储在`desired_present_mode`变量中的期望显示模式相等的元素。
- en: If the desired present mode is not supported (none of the elements of the `present_modes`
    vector is equal to the `desired_present_mode` variable), select a FIFO present
    mode--a value of `VK_PRESENT_MODE_FIFO_KHR`--which always should be supported.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所需的展示模式不受支持（`present_modes`向量的任何元素都不等于`desired_present_mode`变量），则选择FIFO展示模式--`VK_PRESENT_MODE_FIFO_KHR`的值--这始终应该被支持。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The presentation mode defines the way in which images are displayed on screen.
    Currently, there are four modes defined in a Vulkan API.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 展示模式定义了图像在屏幕上显示的方式。目前，在 Vulkan API 中定义了四种模式。
- en: 'The simplest is an **IMMEDIATE** mode. Here, when an image is presented, it
    immediately replaces the image that is being displayed. There is no waiting involved,
    no queue, and no other parameters that should be considered from the application
    perspective. And because of that, screen tearing may (and probably will) be observed:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的是**立即**模式。在这里，当展示一个图像时，它立即替换正在显示的图像。没有等待，没有队列，也没有从应用程序角度应该考虑的其他参数。正因为如此，可能会观察到屏幕撕裂：
- en: '![](img/image_02_001.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: The presentation mode that is mandatory, that every Vulkan API implementation
    must support, is a **FIFO mode**. Here, when an image is presented, it is added
    to the First In First Out queue (the length of this queue is equal to the number
    of images in a swapchain minus one, *n - 1*). From this queue, images are displayed
    on screen in sync with blanking periods (v-sync), always in the same order they
    were added to the queue. There is no tearing in this mode, as v-sync is enabled.
    This mode is similar to OpenGL's buffer swapping with swap interval set to one.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 必须支持的展示模式，即每个Vulkan API实现都必须支持的，是**FIFO模式**。在这里，当展示一个图像时，它被添加到先进先出队列（这个队列的长度等于swapchain中的图像数量减一，*n
    - 1*）。从这个队列中，图像在同步消隐周期（v-sync）的情况下显示在屏幕上，始终按照它们被添加到队列中的相同顺序。在这个模式下没有撕裂，因为v-sync已启用。这种模式类似于OpenGL的缓冲区交换，其中交换间隔设置为1。
- en: The FIFO presentation mode must always be supported.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO展示模式必须始终支持。
- en: 'There is also a slight modification of a FIFO mode called **FIFO RELAXED**.
    The difference between these two is that in **RELAXED** mode, images are displayed
    on screen in sync with blanking periods only when they are presented quick enough,
    faster than the refresh rate. If an image is presented by the application and
    the time that has elapsed from the last presentation is greater than the refresh
    time between two blanking periods (the FIFO queue is empty), the image is presented
    immediately. So if we are quick enough, there is no screen tearing, but if we
    are drawing slower than the monitor''s refresh rate, screen tearing will be visible.
    This behavior is similar to that specified in OpenGL''s `EXT_swap_control_tear`
    extension:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种FIFO模式的轻微修改，称为**FIFO RELAXED**。这两种模式之间的区别在于，在**RELAXED**模式下，只有当图像展示得足够快，快于刷新率时，图像才会与消隐周期同步显示在屏幕上。如果一个图像被应用程序展示，并且从上次展示以来经过的时间大于两个消隐周期之间的刷新时间（FIFO队列是空的），则图像将立即展示。所以如果我们足够快，就没有屏幕撕裂，但如果我们绘制速度慢于显示器的刷新率，屏幕撕裂将可见。这种行为类似于OpenGL的`EXT_swap_control_tear`扩展中指定的：
- en: '![](img/image_02_002.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.png)'
- en: 'The last presentation mode is called **mailbox** mode. It can be perceived
    as a triple buffering. Here also, there is a queue involved, but it contains just
    one element. An image that is waiting in this queue is displayed in sync with
    the blanking periods (v-sync is enabled). But when the application presents an
    image, the new image replaces the one waiting in the queue. So the presentation
    engine always displays the latest, the most recent, image available. And there
    is no screen tearing:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种展示模式被称为**邮箱**模式。它可以被视为三缓冲。在这里，也涉及到一个队列，但它只包含一个元素。在这个队列中等待的图像将与消隐周期（v-sync已启用）同步显示。但是，当应用程序展示一个图像时，新的图像将替换队列中等待的图像。因此，展示引擎总是显示最新的、最新的可用图像。而且没有屏幕撕裂：
- en: '![](img/image_02_003.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_003.png)'
- en: 'To select the desired presentation mode, we need to check what modes are available
    on the current platform. First, we need to acquire the number of all supported
    presentation modes. This is done by calling a `vkGetPhysicalDeviceSurfacePresentModesKHR()`
    function with the last parameter set to `nullptr`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择所需的展示模式，我们需要检查当前平台上有哪些模式可用。首先，我们需要获取所有支持展示模式的总数。这是通过调用一个`vkGetPhysicalDeviceSurfacePresentModesKHR()`函数来完成的，其中最后一个参数设置为`nullptr`：
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next we can prepare storage for all supported modes and once again call the
    same function, but this time with the last parameter pointing to the allocated
    storage:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们可以为所有支持的模式准备存储，然后再次调用相同的函数，但这次将最后一个参数指向分配的存储：
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we know what presentation modes are available, we can check whether
    the selected mode is available. If it is not, we can choose another presentation
    mode from the acquired list or we just fall back to the default FIFO mode that
    is mandatory and should always be available:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了可用的展示模式，我们可以检查所选模式是否可用。如果不可用，我们可以从获取的列表中选择另一个展示模式，或者我们退回到强制性和始终可用的默认
    FIFO 模式：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Selecting a number of swapchain images*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的数量*'
- en: '*Creating a swapchain*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: '*Creating a swapchain with R8G8B8A8 format and a mailbox present mode*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 R8G8B8A8 格式和邮箱展示模式创建交换链*'
- en: '*Acquiring a swapchain image*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取交换链图像*'
- en: '*Presenting an image*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*展示图像*'
- en: Getting the capabilities of a presentation surface
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取展示表面的能力
- en: When we create a swapchain, we need to specify creation parameters. But we can't
    choose whatever values we want. We must provide values that fit into supported
    limits, which can be obtained from a presentation surface. So in order to properly
    create a swapchain, we need to acquire the surface's capabilities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建交换链时，我们需要指定创建参数。但我们不能选择我们想要的任何值。我们必须提供适合支持限制的值，这些值可以从展示表面获得。因此，为了正确创建交换链，我们需要获取表面的能力。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Take the handle of a selected physical device enumerated using the `vkEnumeratePhysicalDevices()`
    function and store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vkEnumeratePhysicalDevices()` 函数枚举的所选物理设备的句柄，并将其存储在名为 `physical_device`
    的类型为 `VkPhysicalDevice` 的变量中。
- en: Take the handle of a created presentation surface. Store it in a variable of
    type `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的展示表面的句柄。将其存储在名为 `presentation_surface` 的类型为 `VkSurfaceKHR` 的变量中。
- en: Create a variable of type `VkSurfaceCapabilitiesKHR` named `surface_capabilities`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_capabilities` 的类型为 `VkSurfaceCapabilitiesKHR` 的变量。
- en: Call `vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, presentation_surface,
    &surface_capabilities)` for which provide the handles of the physical device and
    a presentation surface, and a pointer to the `surface_capabilities` variable.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, presentation_surface,
    &surface_capabilities)`，其中提供物理设备的句柄和一个展示表面，以及指向 `surface_capabilities` 变量的指针。
- en: If the function call is successful, the `surface_capabilities` variable will
    contain the presentation surface's parameters, limits, and capabilities that can
    be used to create a swapchain.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`surface_capabilities` 变量将包含用于创建交换链的展示表面的参数、限制和能力。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Acquiring the supported capabilities and ranges of parameters that can be used
    during swapchain creation is very straightforward:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建交换链时获取支持的特性和参数范围非常直接：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We just call a `vkGetPhysicalDeviceSurfaceCapabilitiesKHR()` function, which
    stores the parameters in a variable of type `VkSurfaceCapabilitiesKHR`. It is
    a structure which contains members defining the following parameters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需调用一个 `vkGetPhysicalDeviceSurfaceCapabilitiesKHR()` 函数，它将参数存储在类型为 `VkSurfaceCapabilitiesKHR`
    的变量中。这是一个结构，其中包含定义以下参数的成员：
- en: Minimal and maximal allowed number of swapchain images
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的最小和最大交换链图像数量
- en: Minimal, maximal, and current extent of a presentation surface
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示表面的最小、最大和当前范围
- en: Supported image transformations (which can be applied before presentation) and
    the transformation currently in use
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的图像转换（可以在展示之前应用）和当前正在使用的转换
- en: Maximal number of supported image layers
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的最大图像层数量
- en: Supported usages
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的使用方式
- en: A list of the supported compositions of a surface's alpha value (how an image's
    alpha component should affect the application's window desktop composition)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的表面 alpha 值组合列表（图像的 alpha 成分应该如何影响应用程序的窗口桌面合成）
- en: See also
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a presentation surface*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建展示表面*'
- en: '*Selecting a number of swapchain images*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的数量*'
- en: '*Choosing a size of swapchain images*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的大小*'
- en: '*Selecting desired usage scenarios of swapchain images*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的期望使用场景*'
- en: '*Selecting a transformation of swapchain images*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的转换*'
- en: '*Selecting a format of swapchain images*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择swapchain图像的格式*'
- en: '*Creating a swapchain*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建swapchain*'
- en: Selecting a number of swapchain images
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择swapchain图像的数量
- en: When an application wants to render into a swapchain image, it must acquire
    it from the presentation engine. An application can acquire more images; we are
    not limited to just one image at a time. But the number of images that are available
    (unused by the presentation engine at a given time) depends on the specified presentation
    mode, the application's current situation (rendering/presenting history), and
    the number of images--when we create a swapchain, we must specify the (minimal)
    number of images that should be created.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序想要渲染到swapchain图像时，它必须从展示引擎中获取它。应用程序可以获取更多图像；我们不仅仅限制于一次获取一张图像。但是，可用图像的数量（在给定时间未被展示引擎使用）取决于指定的展示模式、应用程序当前的状态（渲染/展示历史）以及图像的数量——当我们创建swapchain时，我们必须指定应该创建的（最小）图像数量。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Acquire the capabilities of a presentation surface (refer to the *Getting capabilities
    of a presentation surface* recipe). Store them in a variable of type `VkSurfaceCapabilitiesKHR`
    named `surface_capabilities`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取展示表面的能力（参考 *获取展示表面能力* 脚本）。将它们存储在名为 `surface_capabilities` 的 `VkSurfaceCapabilitiesKHR`
    类型变量中。
- en: Create a variable of type `uint32_t` named `number_of_images`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `number_of_images` 的 `uint32_t` 类型变量。
- en: Assign a value of `surface_capabilities.minImageCount + 1` to the `number_of_images`
    variable.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `surface_capabilities.minImageCount + 1` 的值分配给 `number_of_images` 变量。
- en: Check whether the value of the `maxImageCount` member of the `surface_capabilities`
    variable is greater than zero. If it is, this means there is a limit to the maximal
    allowed number of created images. In this case, check whether the value of the
    `number_of_images` variable is greater than the value of `surface_capabilities.maxImageCount`.
    If it is, clamp the value of the `number_of_images` variable to the limit defined
    in the `maxImageCount` member of the `surface_capabilities` variable.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `surface_capabilities` 变量的 `maxImageCount` 成员是否大于零。如果是，这意味着创建图像的最大允许数量有限制。在这种情况下，检查
    `number_of_images` 变量的值是否大于 `surface_capabilities.maxImageCount` 的值。如果是，将 `number_of_images`
    变量的值限制在 `surface_capabilities` 变量的 `maxImageCount` 成员中定义的限制内。
- en: How it works...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Images created (automatically) along with a swapchain are mainly used for presentation
    purposes. But they also allow the presentation engine to work properly. One image
    is (always) displayed on screen. The application can't use it until it is replaced
    by another image. Images that are presented replace the displayed image immediately,
    or wait in a queue for the proper moment (v-sync) to replace it, depending on
    the selected mode. An image that was displayed and is now being replaced becomes
    unused and can be acquired by the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与swapchain一起创建（自动）的图像主要用于展示目的。但它们也允许展示引擎正常工作。屏幕上始终显示一张图像。应用程序必须用另一张图像替换它后才能使用它。展示的图像会立即替换显示的图像，或者根据所选模式等待队列中的适当时刻（v-sync）来替换它。被展示并正在被替换的图像变为未使用状态，可以被应用程序获取。
- en: An application can acquire only images that are currently in an unused state
    (refer to the *Selecting a desired presentation mode* recipe). We can acquire
    all of them. But as soon as all unused images are acquired, we need to present
    at least one of them in order to be able to acquire another one. If we don't do
    this, the acquiring operation may block indefinitely.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序只能获取当前处于未使用状态（参考 *选择所需展示模式* 脚本）的图像。我们可以获取所有这些图像。但是，一旦所有未使用的图像都被获取，我们就需要展示其中至少一张，以便能够获取另一张。如果我们不这样做，获取操作可能会无限期地阻塞。
- en: The number of unused images depends mainly on the presentation mode and the
    total number of images created with a swapchain. So the number of images that
    we want to create should be chosen based on the rendering scenarios we want to
    implement (how many images an application wants to possess at the same time) and
    the selected present mode.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用图像的数量主要取决于展示模式和与swapchain一起创建的总图像数量。因此，我们想要创建的图像数量应根据我们想要实现的渲染场景（应用程序希望同时拥有的图像数量）和所选的展示模式来选择。
- en: 'Choosing the minimal number of images may look like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最小数量的图像可能如下所示：
- en: '[PRE13]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Usually, in the most typical rendering scenarios, we will be rendering into
    a single image at a given time. So the minimal supported number of images may
    be enough. Creating more images allows us to acquire more of them at the same
    time, but, more importantly, it may also increase the performance of our application
    if a proper rendering algorithm is implemented. But we can't forget that images
    consume a considerable amount of memory. So the number of images we choose for
    the swapchain should be a compromise between our needs, memory usage, and the
    performance of our application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在最常见的渲染场景中，我们将在给定时间内渲染到单个图像。因此，最小支持的图像数量可能就足够了。创建更多图像允许我们同时获取更多图像，但更重要的是，如果实现了适当的渲染算法，这也可能提高我们应用程序的性能。但我们不能忘记图像会消耗相当大的内存。因此，我们为swapchain选择的图像数量应该在我们的需求、内存使用和应用程序性能之间取得平衡。
- en: In the preceding example, such a compromise is presented in which the application
    chooses one image more than the minimal value that allows the presentation engine
    to work properly. After that, we also need to check whether there is an upper
    limit and whether we exceed it. If we do, we need to clamp the selected value
    to the supported range.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，展示了这样一个折衷方案，即应用程序选择比允许呈现引擎正常工作的最小值多一个图像。之后，我们还需要检查是否存在上限，以及我们是否超过了它。如果我们超过了，我们需要将选定的值限制在支持的范围内。
- en: See also
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Selecting a desired presentation mode*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择所需的呈现模式*'
- en: '*Getting the capabilities of a presentation surface*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取呈现表面的能力*'
- en: '*Creating a swapchain*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建swapchain*'
- en: '*Acquiring a swapchain image*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取swapchain图像*'
- en: '*Presenting an image*'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*呈现图像*'
- en: Choosing a size of swapchain images
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择swapchain图像的大小
- en: Usually, images created for a swapchain should fit into an application's window.
    The supported dimensions are available in the presentation surface's capabilities.
    But on some operating systems, the size of the images defines the final size of
    the window. We also should keep that in mind and check what dimensions are proper
    for the swapchain images.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为swapchain创建的图像应该适合应用程序的窗口。支持的尺寸在呈现表面的能力中可用。但在某些操作系统上，图像的大小定义了窗口的最终大小。我们也应该记住这一点，并检查swapchain图像的适当尺寸。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Acquire the capabilities of a presentation surface (refer to the *Getting capabilities
    of a presentation surface* recipe). Store them in a variable of type `VkSurfaceCapabilitiesKHR`
    named `surface_capabilities`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取呈现表面的能力（参考*获取呈现表面能力*配方）。将它们存储在名为`surface_capabilities`的`VkSurfaceCapabilitiesKHR`类型的变量中。
- en: Create a variable of type `VkExtent2D` named `size_of_images` in which we will
    store the desired size of swapchain images.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`size_of_images`的`VkExtent2D`类型的变量，我们将存储所需的swapchain图像的大小。
- en: 'Check whether the `currentExtent.width` member of the `surface_capabilities`
    variable is equal to `0xFFFFFFFF` (`-1` converted to an unsigned value of `uint32_t`
    type). If it is, it means that the size of images determines the size of the window.
    In this situation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`surface_capabilities`变量的`currentExtent.width`成员是否等于`0xFFFFFFFF`（`-1`转换为`uint32_t`类型的无符号值）。如果是，这意味着图像的大小决定了窗口的大小。在这种情况下：
- en: Assign the desired values for `width` and `height` members of the `size_of_images`
    variable
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`size_of_images`变量的`width`和`height`成员分配所需的值
- en: Clamp the value of the `width` member of a `size_of_images` variable to the
    range defined by `surface_capabilities.minImageExtent.width` and `surface_capabilities.maxImageExtent.width`
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`size_of_images`变量的`width`成员的值限制在由`surface_capabilities.minImageExtent.width`和`surface_capabilities.maxImageExtent.width`定义的范围内
- en: Clamp the value of the `height` member of the `size_of_images` variable to the
    range defined by `surface_capabilities.minImageExtent.height` and `surface_capabilities.maxImageExtent.height`
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`size_of_images`变量的`height`成员的值限制在由`surface_capabilities.minImageExtent.height`和`surface_capabilities.maxImageExtent.height`定义的范围内
- en: If the value of the `currentExtent.width` member of the `surface_capabilities`
    variable is not equal to `0xFFFFFFFF`, in the `size_of_images` variable, store
    the value of `surface_capabilities.currentExtent`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`surface_capabilities`变量的`currentExtent.width`成员的值不等于`0xFFFFFFFF`，在`size_of_images`变量中存储`surface_capabilities.currentExtent`的值。
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The size of swapchain images must fit into supported limits. These are defined
    by the surface capabilities. In most typical scenarios, we want to render into
    an image that has the same dimensions as the application window's client area.
    This value is specified in the `currentExtent` member of surface's capabilities.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 交换链图像的大小必须符合支持的极限。这些极限由表面能力定义。在大多数典型场景中，我们希望渲染到与应用程序窗口客户端区域相同尺寸的图像。这个值在表面的能力成员`currentExtent`中指定。
- en: 'But there are operating systems on which the window''s size is determined by
    the size of swapchain images. This situation is signaled by the `0xFFFFFFFF` value
    of the `currentExtent.width` or `currentExtent.height` member of the surface''s
    capabilities. In this case, we can define the size of images, but it still must
    fall within a specified range:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一些操作系统，窗口的大小由交换链图像的大小决定。这种情况通过表面能力的`currentExtent.width`或`currentExtent.height`成员的`0xFFFFFFFF`值来表示。在这种情况下，我们可以定义图像的大小，但它仍然必须在一个指定的范围内：
- en: '[PRE14]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取呈现表面的能力*'
- en: '*Creating a swapchain*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: Selecting desired usage scenarios of swapchain images
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择交换链图像的期望使用场景
- en: Images created with a swapchain are usually used as color attachments. This
    means that we want to render into them (use them as render targets). But we are
    not limited only to this scenario. We can use swapchain images for other purposes--we
    can sample from them, use them as a source of data in copy operations, or copy
    data into them. These are all different image usages and we can specify them during
    swapchain creation. But, again, we need to check whether these usages are supported.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交换链创建的图像通常用作颜色附件。这意味着我们希望将渲染到它们中（将它们用作渲染目标）。但我们不仅限于这种场景。我们可以将交换链图像用于其他目的--我们可以从它们中采样，将它们用作复制操作中的数据源，或者将数据复制到它们中。这些都是不同的图像使用方式，我们可以在创建交换链期间指定它们。但是，再次强调，我们需要检查这些使用是否受支持。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Acquire the capabilities of a presentation surface (refer to the *Getting capabilities
    of a presentation surface* recipe). Store them in a variable of type `VkSurfaceCapabilitiesKHR`
    named `surface_capabilities`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取呈现表面的能力（参考*获取呈现表面的能力*食谱）。将它们存储在一个名为`surface_capabilities`的`VkSurfaceCapabilitiesKHR`类型变量中。
- en: Choose the desired image usages and store them in a variable of a bit field
    type `VkImageUsageFlags` named `desired_usages`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的图像使用方式，并将它们存储在一个名为`desired_usages`的位字段类型`VkImageUsageFlags`的变量中。
- en: Create a variable of type `VkImageUsageFlags` named `image_usage` in which a
    list of requested usages that are supported on a given platform will be stored.
    Assign a value of `0` to the `image_usage` variable.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`image_usage`的`VkImageUsageFlags`类型变量中创建一个变量，其中将存储在给定平台上受支持的请求使用列表。将`image_usage`变量的值设置为`0`。
- en: 'Iterate over all bits of the `desired_usages` bit field variable. For each
    bit in the variable:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`desired_usages`位字段变量的所有位。对于变量中的每个位：
- en: Check whether the bit is set (is equal to one)
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查位是否设置（等于一）
- en: Check whether the corresponding bit of the `supportedUsageFlags` member of the `surface_capabilities`
    variable is set
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`surface_capabilities`变量的`supportedUsageFlags`成员中的对应位是否设置
- en: If the preceding checks are true, set the same bit in the `image_usage` variable
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前面的检查是正确的，则在`image_usage`变量中设置相同的位。
- en: Make sure that all of the requested usages are supported on a given platform
    by checking if the values of the `desired_usages` and `image_usage` variables
    are equal.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查`desired_usages`和`image_usage`变量的值是否相等，确保在给定平台上所有请求的使用都是受支持的。
- en: How it works...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The list of usages that can be selected for swapchain images is available in
    a `supportedUsageFlags` member of a presentation surface's capabilities. This
    member is a bit field in which each bit corresponds to a specific usage. If a
    given bit is set, it means that a given usage is supported.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为交换链图像选择的用法列表在呈现表面能力的`supportedUsageFlags`成员中可用。该成员是一个位字段，其中每个位对应于特定的用法。如果给定位被设置，则表示给定的用法受支持。
- en: Color attachment usage (`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`) must always be
    supported.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色附件使用（`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`）必须始终受支持。
- en: '`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` usage is mandatory and all Vulkan implementations
    must support it. Other usages are optional. That''s why we shouldn''t rely on
    their availability. Also, we shouldn''t request usages that we don''t need as
    this may impact the performance of our application.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`用法是强制性的，所有Vulkan实现都必须支持它。其他用法是可选的。这就是为什么我们不应该依赖于它们的可用性。同样，我们也不应该请求我们不需要的用法，因为这可能会影响我们应用程序的性能。'
- en: 'Selecting a desired usage may look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所需的用法可能看起来像这样：
- en: '[PRE15]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We take only the common part of desired usages and the supported usages. We
    then check whether all requested usages are supported. We do this by comparing
    the values of the requested and the "final" usages. If their values differ, we
    know that not all of the desired usages are supported.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只取所需用法和支持用法的公共部分。然后检查是否所有请求的用法都受支持。我们通过比较请求的用法和“最终”用法的值来完成此操作。如果它们的值不同，我们知道并非所有所需的用法都受支持。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'The following recipes in this chapter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取呈现表面的能力*'
- en: '*Creating a swapchain*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建swapchain*'
- en: Selecting a transformation of swapchain images
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择swapchain图像的转换
- en: On some (especially mobile) devices, images can be viewed from different orientations.
    Sometimes we would like to be able to specify how an image should be oriented
    when it is displayed on screen. In Vulkan, we have such a possibility. When creating
    a swapchain, we need to specify the transformation which should be applied to
    an image before it is presented.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些（特别是移动）设备上，图像可以从不同的方向查看。有时我们可能希望能够指定图像在屏幕上显示时应如何定位。在Vulkan中，我们有这样的可能性。在创建swapchain时，我们需要指定在呈现之前应用于图像的转换。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Acquire the capabilities of a presentation surface (refer to the *Getting capabilities
    of a presentation surface* recipe). Store them in a variable of type `VkSurfaceCapabilitiesKHR`
    named `surface_capabilities`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取呈现表面的能力（参考*获取呈现表面的能力*食谱）。将它们存储在名为`surface_capabilities`的`VkSurfaceCapabilitiesKHR`类型的变量中。
- en: Store the desired transformations in a bit field variable of type `VkSurfaceTransformFlagBitsKHR`
    named `desired_transform`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的转换存储在名为`desired_transform`的`VkSurfaceTransformFlagBitsKHR`类型的位字段变量中。
- en: Create a variable of type `VkSurfaceTransformFlagBitsKHR` named `surface_transform`
    in which we will store the supported transformation.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`surface_transform`的`VkSurfaceTransformFlagBitsKHR`类型的变量，我们将存储受支持的转换。
- en: Check whether all bits set in the `desired_transform` variable are also set
    in the `supportedTransforms` member of the presentation surface's capabilities.
    If they are, assign the value of the `desired_transform` variable to the `surface_transform`
    variable.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查在`desired_transform`变量中设置的位是否也在呈现表面能力的`supportedTransforms`成员中设置。如果是，将`desired_transform`变量的值分配给`surface_transform`变量。
- en: If not all desired transformations are supported, fall back to the current transformation
    by assigning a value of `surface_capabilities.currentTransform` to the `surface_transform`
    variable.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是所有所需的转换都受支持，则通过将`surface_capabilities.currentTransform`的值分配给`surface_transform`变量来回退到当前转换。
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `supportedTransforms` member of a presentation surface's capabilities defines
    a list of all image transformations that are available on a given platform. Transformations
    define how an image should be rotated or mirrored before it is displayed on screen.
    During swapchain creation, we can specify the desired transformation and a presentation
    engine applies it to the image as part of the displaying process.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现表面能力的`supportedTransforms`成员定义了在给定平台上可用的所有图像转换列表。转换定义了在屏幕上显示之前图像应该如何旋转或镜像。在创建swapchain期间，我们可以指定所需的转换，并且呈现引擎将其应用于图像作为显示过程的一部分。
- en: 'We can choose any of the supported values. Here is a code sample that selects
    a desired transformation if it is available or otherwise just takes the currently
    used transformation:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择任何受支持的值。以下是一个代码示例，如果可用则选择所需的转换，否则仅使用当前使用的转换：
- en: '[PRE16]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: 'The following recipes in this chapter:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取呈现表面的能力*'
- en: '*Creating a swapchain*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建swapchain*'
- en: Selecting a format of swapchain images
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择swapchain图像的格式
- en: The format defines the number of color components, the number of bits for each
    component, and the used data type. During swapchain creation, we must specify
    whether we want to use red, green, and blue channels with or without an alpha
    component, whether the color values should be encoded using unsigned integer or
    floating-point data types, and what their precision is. We must also choose whether
    we are encoding color values using linear or nonlinear color space. But as with
    other swapchain parameters, we can use only values that are supported by the presentation
    surface.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 格式定义了颜色组件的数量、每个组件的位数以及使用的数据类型。在创建交换链时，我们必须指定是否要使用带有或不带有 alpha 组件的红、绿、蓝通道，颜色值是否应该使用无符号整数或浮点数据类型进行编码，以及它们的精度是多少。我们还必须选择是否使用线性或非线性颜色空间进行颜色值的编码。但与其他交换链参数一样，我们只能使用由显示表面支持的值。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we use several terms that may seem identical, but in fact they
    specify different parameters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了一些可能看起来相同的术语，但实际上它们指定了不同的参数：
- en: Image format is used to describe the number of components, precision, and data
    type of an image's pixels. It corresponds to variables of type `VkFormat`.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像格式用于描述图像像素的组件数量、精度和数据类型。它对应于 `VkFormat` 类型的变量。
- en: Color space determines the way the values of color components are interpreted
    by the hardware, whether they are encoded or decoded using a linear or nonlinear
    function. Color space corresponds to variables of type `VkColorSpaceKHR`.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色空间决定了硬件解释颜色组件值的方式，是使用线性或非线性函数进行编码或解码。颜色空间对应于 `VkColorSpaceKHR` 类型的变量。
- en: Surface format is a pair of image format and color space and is represented
    by variables of type `VkSurfaceFormatKHR`.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表面格式是图像格式和颜色空间的一对，由 `VkSurfaceFormatKHR` 类型的变量表示。
- en: How to do it...
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a physical device returned by the `vkEnumeratePhysicalDevices()`
    function. Store it in a variable of type `VkPhysicalDevice` named `physical_device`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取 `vkEnumeratePhysicalDevices()` 函数返回的物理设备的句柄。将其存储在名为 `physical_device` 的 `VkPhysicalDevice`
    类型变量中。
- en: Take the created presentation surface and store its handle in a variable of
    type `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的显示表面存储在其名为 `presentation_surface` 的 `VkSurfaceKHR` 类型变量中。
- en: Select the desired image format and color space and assign them to the members
    of a variable of type `VkSurfaceFormatKHR` named `desired_surface_format`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所需的图像格式和颜色空间，并将它们分配给名为 `desired_surface_format` 的 `VkSurfaceFormatKHR` 类型变量的成员。
- en: Create a variable of type `uint32_t` named `formats_count`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `formats_count` 的 `uint32_t` 类型变量。
- en: Call `vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface,
    &formats_count, nullptr )`, provide a handle of the physical device in the first
    parameter, a handle of the presentation surface in the second parameter, and a
    pointer to the `formats_count` variable in the third variable. Leave the value
    of the last parameter set to `nullptr`.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface,
    &formats_count, nullptr )`，在第一个参数中提供物理设备的句柄，在第二个参数中提供显示表面的句柄，在第三个参数中提供一个指向 `formats_count`
    变量的指针。将最后一个参数的值设置为 `nullptr`。
- en: If a function call is successful, the `formats_count` variable will contain
    the number of all supported format-color space pairs.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果函数调用成功，`formats_count` 变量将包含所有支持的格式-颜色空间对的数量。
- en: Create a variable of type `std::vector<VkSurfaceFormatKHR>` named `surface_formats`.
    Resize the vector so it is able to hold at least `formats_count` elements.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_formats` 的 `std::vector<VkSurfaceFormatKHR>` 类型的变量。调整向量大小，使其至少能容纳
    `formats_count` 个元素。
- en: Make the following call, `vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device,
    presentation_surface, &formats_count, &surface_formats[0] )`. Provide the same
    arguments for the first three parameters. In the last parameter, provide a pointer
    to the first element of the `surface_formats` vector.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下调用，`vkGetPhysicalDeviceSurfaceFormatsKHR( physical_device, presentation_surface,
    &formats_count, &surface_formats[0] )`。为前三个参数提供相同的参数。在最后一个参数中，提供一个指向 `surface_formats`
    向量第一个元素的指针。
- en: If the call is successful, all available image format-color space pairs will
    be stored in the `surface_formats` variable.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用成功，所有可用的图像格式-颜色空间对都将存储在 `surface_formats` 变量中。
- en: Create a variable of type `VkFormat` named `image_format` and a second variable
    of type `VkColorSpaceKHR` named `image_color_space` in which we will store selected
    values of format and color space used later during swapchain creation.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_format`的`VkFormat`类型变量和一个名为`image_color_space`的`VkColorSpaceKHR`类型变量，我们将存储在创建swapchain时使用的格式和颜色空间的选择值。
- en: Check the number of elements in the `surface_formats` vector. If it holds only
    one element with a value of `VK_FORMAT_UNDEFINED`, it means that we can choose
    whatever surface format we want. Assign the members of the `desired_surface_format`
    variable to the `image_format` and `image_color_space` variables.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`surface_formats`向量的元素数量。如果它只包含一个值为`VK_FORMAT_UNDEFINED`的元素，这意味着我们可以选择我们想要的任何表面格式。将`desired_surface_format`变量的成员分配给`image_format`和`image_color_space`变量。
- en: If the `surface_formats` vector contains more elements, iterate over each element
    of the vector and compare the `format` and `colorSpace` members with the same
    members of the `desired_surface_format` variable. If we find an element in which
    both members are identical, it means that the desired surface format is supported
    and we can use it for swapchain creation. Assign the members of the `desired_surface_format`
    variable to the `image_format` and `image_color_space` variables.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`surface_formats`向量包含更多元素，遍历向量的每个元素，并将`format`和`colorSpace`成员与`desired_surface_format`变量的相同成员进行比较。如果我们找到一个两个成员都相同的元素，这意味着所需的表面格式受支持，并且我们可以用它来创建swapchain。将`desired_surface_format`变量的成员分配给`image_format`和`image_color_space`变量。
- en: If we haven't found a match, iterate over all elements of the `surface_formats`
    vector. Check whether the `format` member of any of its elements is identical
    to the value of a chosen `surface_format.format`. If there is such an element,
    assign the `desired_surface_format.format` value to the `image_format` variable,
    but take the corresponding color space from the currently viewed element of the `surface_formats`
    vector and assign it to the `image_color_space` variable.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有找到匹配项，遍历`surface_formats`向量的所有元素。检查其任何元素的`format`成员是否与所选`surface_format.format`的值相同。如果存在这样的元素，将`desired_surface_format.format`的值分配给`image_format`变量，但将从当前查看的`surface_formats`向量的元素中获取相应的颜色空间并分配给`image_color_space`变量。
- en: If the `surface_formats` variable doesn't contain any element with the selected
    image format, take the first element of the vector and assign its `format` and
    `colorSpace` members to the `image_format` and `image_color_space` variables.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`surface_formats`变量不包含任何具有所选图像格式的元素，则取向量的第一个元素，并将它的`format`和`colorSpace`成员分配给`image_format`和`image_color_space`变量。
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To obtain a list of all supported surface formats, we need to make a double
    call of a `vkGetPhysicalDeviceSurfaceFormatsKHR()` function. First we acquire
    the number of all supported format-color space pairs:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有支持表面格式的列表，我们需要执行两次`vkGetPhysicalDeviceSurfaceFormatsKHR()`函数的调用。首先，我们获取所有支持格式-颜色空间对的数目：
- en: '[PRE17]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next we can prepare storage for the actual values and make the second call
    to acquire them:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为实际值准备存储空间，并执行第二次调用以获取它们：
- en: '[PRE18]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, we can choose one of the supported surface formats that is the
    best match for our needs. If only one surface format was returned and it has a
    value of `VK_FORMAT_UNDEFINED`, it means that there are no restrictions on the
    supported format-color space pairs. In such a situation, we can choose any surface
    format we want and use it during swapchain creation:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以选择一个最适合我们需求的受支持表面格式。如果只返回了一个表面格式并且它的值为`VK_FORMAT_UNDEFINED`，这意味着对支持的格式-颜色空间对没有限制。在这种情况下，我们可以选择我们想要的任何表面格式并在创建swapchain时使用它：
- en: '[PRE19]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If there are more elements returned by the `vkGetPhysicalDeviceSurfaceFormatsKHR()`
    function, we need to take one of them. First we check whether the chosen surface
    format is supported "entirely"--both selected image format and color space are
    available:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`vkGetPhysicalDeviceSurfaceFormatsKHR()`函数返回了更多元素，我们需要从中选择一个。首先，我们检查所选表面格式是否完全受支持--所选图像格式和颜色空间都是可用的：
- en: '[PRE20]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we can''t find a match, we look for a member that has an identical image
    format, but other color space. We can''t take any of the supported formats and
    any of the supported color spaces--we must take the same color space that corresponds
    to a given format:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到匹配项，我们寻找一个具有相同图像格式但其他颜色空间的成员。我们不能选择任何支持的格式和任何支持的颜色空间--我们必须选择与给定格式相对应的相同颜色空间：
- en: '[PRE21]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, if the format we wanted to use is not supported, we just take the
    first available image format-color space pair:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想使用的格式不受支持，我们只需取第一个可用的图像格式-颜色空间对：
- en: '[PRE22]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下食谱：
- en: '*Creating a swapchain*'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: '*Creating a swapchain with R8G8B8A8 format and a mailbox present mode*'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 R8G8B8A8 格式和邮箱展示模式创建交换链*'
- en: Creating a swapchain
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建交换链
- en: A swapchain is used to display images on screen. It is an array of images which
    can be acquired by the application and then presented in our application's window.
    Each image has the same defined set of properties. When we have prepared all of
    these parameters, meaning that we chose a number, a size, a format, and usage
    scenarios for swapchain images, and also acquired and selected one of the available
    presentation modes, we are ready to create a swapchain.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 交换链用于在屏幕上显示图像。它是一个图像数组，应用程序可以获取这些图像，然后在我们的应用程序窗口中展示。每个图像都有相同的定义属性集。当我们准备好了所有这些参数，意味着我们选择了一个数字、大小、格式和交换链图像的使用场景，并且获取并选择了一个可用的展示模式，我们就准备好创建一个交换链了。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Take the handle of a created logical device object. Store it in a variable of
    type `VkDevice` named `logical_device`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿到一个创建的逻辑设备对象的句柄。将其存储在一个名为 `logical_device` 的 `VkDevice` 类型变量中。
- en: Assign the handle of a created presentation surface to a variable of type `VkSurfaceKHR`
    named `presentation_surface`.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的展示表面句柄分配给名为 `VkSurfaceKHR` 类型的变量 `presentation_surface`。
- en: Take the desired number of swapchain images assigned to a variable of type `uint32_t`
    named `image_count`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分配给变量 `uint32_t` 类型的 `image_count` 的所需数量的交换链图像句柄。
- en: Store the values of the selected image format and color space in a variable
    of type `VkSurfaceFormatKHR` named `surface_format`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所选图像格式和颜色空间的值存储在名为 `VkSurfaceFormatKHR` 类型的变量 `surface_format` 中。
- en: Prepare the required image size and assign it to a variable of type `VkExtent2D`
    named `image_size`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备所需图像大小并将其分配给名为 `VkExtent2D` 类型的变量 `image_size`。
- en: Choose the desired usage scenarios for swapchain images. Store them in a bit
    field variable of type `VkImageUsageFlags` named `image_usage`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择交换链图像的所需使用场景，并将它们存储在名为 `VkImageUsageFlags` 类型的位字段变量 `image_usage` 中。
- en: Take the selected surface transformations stored in a variable of type `VkSurfaceTransformFlagBitsKHR`
    named `surface_transform`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储在名为 `VkSurfaceTransformFlagBitsKHR` 类型的变量 `surface_transform` 中的所选表面转换。
- en: Prepare a variable of type `VkPresentModeKHR` named `present_mode` and assign
    a desired presentation mode to it.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `present_mode` 的 `VkPresentModeKHR` 类型变量，并将其分配一个所需的展示模式。
- en: Create a variable of type `VkSwapchainKHR` named `old_swapchain`. If there was
    a swapchain created previously, store a handle of that swapchain in this variable.
    Otherwise, assign a `VK_NULL_HANDLE` value to this variable.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `old_swapchain` 的 `VkSwapchainKHR` 类型变量。如果有之前创建的交换链，将那个交换链的句柄存储在这个变量中。否则，将
    `VK_NULL_HANDLE` 值分配给此变量。
- en: 'Create a variable of type `VkSwapchainCreateInfoKHR` named `swapchain_create_info`.
    Assign the following values to the members of this variable:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapchain_create_info` 的 `VkSwapchainCreateInfoKHR` 类型变量。将以下值分配给此变量的成员：
- en: '`VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR` value for `sType`'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `sType` 的 `VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR` 值
- en: '`nullptr` value for `pNext`'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `pNext` 的 `nullptr` 值
- en: '`0` value for `flags`'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `flags` 的 `0` 值
- en: '`presentation_surface` variable for `surface`'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `surface` 的 `presentation_surface` 变量
- en: '`image_count` variable for `minImageCount`'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `minImageCount` 的 `image_count` 变量
- en: '`surface_format.format` member for `imageFormat`'
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageFormat` 的 `surface_format.format` 成员
- en: '`surface_format.colorSpace` member for `imageColorSpace`'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageColorSpace` 的 `surface_format.colorSpace` 成员
- en: '`image_size` variable for `imageExtent`'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageExtent` 的 `image_size` 变量
- en: '`1` value for `imageArrayLayers` (or more if we want to perform layered/stereoscopic
    rendering)'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageArrayLayers` 的 `1` 值（或更多，如果我们想进行分层/立体渲染）
- en: '`image_usage` variable for `imageUsage`'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageUsage` 的 `image_usage` 变量
- en: '`VK_SHARING_MODE_EXCLUSIVE` value for `imageSharingMode`'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `imageSharingMode` 的 `VK_SHARING_MODE_EXCLUSIVE` 值
- en: '`0` value for `queueFamilyIndexCount`'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `queueFamilyIndexCount` 的 `0` 值
- en: '`nullptr` value for `pQueueFamilyIndices`'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `pQueueFamilyIndices` 的 `nullptr` 值
- en: '`surface_transform` variable for `preTransform`'
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `preTransform` 的 `surface_transform` 变量
- en: '`VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR` value for `compositeAlpha`'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `compositeAlpha` 的 `VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR` 值
- en: '`present_mode` variable for `presentMode`'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `presentMode` 的 `present_mode` 变量
- en: '`VK_TRUE` for `clipped`'
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `clipped` 的 `VK_TRUE`
- en: '`old_swapchain` variable for `oldSwapchain`'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `oldSwapchain` 的 `old_swapchain` 变量
- en: Create a variable of type `VkSwapchainKHR` named `swapchain`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapchain` 的 `VkSwapchainKHR` 类型变量。
- en: Call `vkCreateSwapchainKHR( logical_device, &swapchain_create_info, nullptr,
    &swapchain )`. Use the handle of a created logical device, a pointer to the `swapchain_create_info`
    variable, a `nullptr` value, and a pointer to the `swapchain` variable as the
    function's arguments.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkCreateSwapchainKHR( logical_device, &swapchain_create_info, nullptr, &swapchain
    )`。使用已创建的逻辑设备句柄、`swapchain_create_info`变量的指针、`nullptr`值以及`swapchain`变量的指针作为函数的参数。
- en: Make sure the call was successful by comparing the returned value with a `VK_SUCCESS`
    value.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将返回值与`VK_SUCCESS`值进行比较，确保调用成功。
- en: Call `vkDestroySwapchainKHR( logical_device, old_swapchain, nullptr )` to destroy
    the old swapchain. Provide a handle to the created logical device, a handle of
    an old swapchain, and a `nullptr` value for the function call.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroySwapchainKHR( logical_device, old_swapchain, nullptr )`来销毁旧swapchain。提供一个已创建的逻辑设备句柄、旧swapchain的句柄，以及函数调用中的`nullptr`值。
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As was mentioned earlier, a swapchain is a collection of images. They are created
    automatically along with a swapchain. They are also destroyed when the swapchain
    is destroyed. Though an application can obtain handles of these images, it is
    not allowed to create or destroy them.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，swapchain是一组图像。它们会自动与swapchain一起创建。当swapchain被销毁时，它们也会被销毁。尽管应用程序可以获取这些图像的句柄，但不允许创建或销毁它们。
- en: 'The process of swapchain creation isn''t too complicated, but there is a considerable
    amount of data we need to prepare before we are able to create it:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 创建swapchain的过程并不太复杂，但在我们能够创建它之前，我们需要准备相当多的数据：
- en: '[PRE23]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Only one swapchain can be associated with a given application''s window. When
    we create a new swapchain, we need to destroy any swapchain that was previously
    created for the same window:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 只能有一个swapchain与一个特定应用程序的窗口相关联。当我们创建一个新的swapchain时，我们需要销毁之前为同一窗口创建的任何swapchain：
- en: '[PRE24]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the swapchain is ready, we can acquire its images and perform tasks that
    fit into specified usage scenarios. We are not limited to acquiring just a single
    image, like we were used to in an OpenGL API (single back buffer). The number
    of images depends on the minimal specified number of images that should be created
    along with a swapchain, the chosen presentation mode, and current rendering history
    (number of images currently acquired and recently presented).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当swapchain准备就绪时，我们可以获取其图像并执行适合指定使用场景的任务。我们不仅限于获取单个图像，就像我们习惯在OpenGL API（单个后缓冲区）中那样。图像的数量取决于应与swapchain一起创建的最小指定图像数量、选择的显示模式以及当前的渲染历史（当前获取和最近显示的图像数量）。
- en: After we have acquired an image, we can use it in our application. The most
    common usage is rendering into the image (using it as a color attachment), but
    we are not limited to just this usage and we can perform other tasks with swapchain
    images. But we must make sure respective usages are available on a given platform
    and that they were specified during swapchain creation. Not all platforms may
    support all usages. Only color attachment usage is mandatory.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取到一个图像后，我们可以在我们的应用程序中使用它。最常见的用法是将渲染到图像中（将其用作颜色附件），但我们不仅限于这种用法，我们还可以使用swapchain图像执行其他任务。但我们必须确保在给定的平台上可用的相应用法，并且在创建swapchain时已指定。并非所有平台都支持所有用法。仅颜色附件用法是强制性的。
- en: When we are done rendering into an image (or images) or performing other tasks,
    we can display an image by presenting it. This operation returns the image to
    the presentation engine which replaces the currently displayed image with the
    new one according to the specified presentation mode.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成对图像（或图像）的渲染或其他任务后，我们可以通过显示图像来显示它。此操作将图像返回到显示引擎，根据指定的显示模式用新图像替换当前显示的图像。
- en: See also
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a presentation surface*'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建显示表面*'
- en: '*Selecting a queue family that supports presentation to a given surface*'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择支持向给定表面进行显示的队列家族*'
- en: '*Creating a logical device with WSI extensions enabled*'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建启用WSI扩展的逻辑设备*'
- en: '*Selecting a desired presentation mode*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择所需的显示模式*'
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取显示表面的能力*'
- en: '*Selecting a number of swapchain images*'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择多个swapchain图像*'
- en: '*Choosing a size of swapchain images*'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择swapchain图像的大小*'
- en: '*Selecting desired usage scenarios of swapchain images*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择swapchain图像的期望使用场景*'
- en: '*Selecting a transformation of swapchain images*'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择swapchain图像的转换*'
- en: '*Selecting a format of swapchain images*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择swapchain图像的格式*'
- en: Getting handles of swapchain images
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取交换链图像的句柄
- en: When the swapchain object is created, it may be very useful to acquire the number
    and handles of all images that were created along with the swapchain.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当交换链对象被创建时，获取与交换链一起创建的所有图像的数量和句柄可能非常有用。
- en: How to do it...
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Take the handle of a created logical device object. Store it in a variable of
    type `VkDevice` named `logical_device`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备对象的句柄。将其存储在名为`logical_device`的`VkDevice`类型变量中。
- en: Assign the handle of a created swapchain to a variable of type `VkSwapchainKHR`
    named `swapchain`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的交换链的句柄分配给名为`swapchain`的`VkSwapchainKHR`类型变量。
- en: Create a variable of type `uint32_t` named `images_count`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`images_count`的`uint32_t`类型变量。
- en: Call `vkGetSwapchainImagesKHR(logical_device, swapchain, &images_count, nullptr)`
    for which provide the handle to the created logical device in the first parameter,
    the handle of the swapchain in the second, and a pointer to the `images_count`
    variable in the third parameter. Provide a `nullptr` value in the last parameter.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetSwapchainImagesKHR(logical_device, swapchain, &images_count, nullptr)`，其中在第一个参数中提供创建的逻辑设备句柄，在第二个参数中提供交换链的句柄，在第三个参数中提供指向`images_count`变量的指针。在最后一个参数中提供`nullptr`值。
- en: If the call is successful, meaning that the returned value is equal to `VK_SUCCESS`,
    the `images_count` variable will contain the total number of images created for
    a given swapchain object.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果调用成功，即返回值等于`VK_SUCCESS`，则`images_count`变量将包含为给定交换链对象创建的图像总数。
- en: Create a `std::vector` with elements of type `VkImage`. Name the vector `swapchain_images`
    and resize it so it is able to hold at least `images_count` number of elements.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元素类型为`VkImage`的`std::vector`。命名为`swapchain_images`，并调整大小以便能够容纳至少`images_count`个元素。
- en: Call `vkGetSwapchainImagesKHR(logical_device, swapchain, &images_count, &swapchain_images[0])`
    and provide the same arguments for the first three parameters as previously. In
    the last parameter, provide a pointer to the first element of the `swapchain_images`
    vector.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkGetSwapchainImagesKHR(logical_device, swapchain, &images_count, &swapchain_images[0])`，并为前三个参数提供与之前相同的参数。在最后一个参数中，提供指向`swapchain_images`向量第一个元素的指针。
- en: On success, the vector will contain the handles of all swapchain images.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功时，该向量将包含所有交换链图像的句柄。
- en: How it works...
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drivers may create more images than were requested in the swapchain's creation
    parameters. There, we just defined the minimum required number but Vulkan implementations
    are allowed to create more.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序可能创建比交换链创建参数中请求的更多图像。在那里，我们只定义了所需的最小数量，但Vulkan实现被允许创建更多。
- en: We need to know the total number of created images to be able to acquire their
    handles. In Vulkan, when we want to render into an image, we need to know its
    handle. It is required to create an image view that wraps the image and is used
    during framebuffer creation. A framebuffer, as in OpenGL, specifies a set of images
    that are used during the rendering process (mostly that we render into them).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道创建的图像总数，以便能够获取它们的句柄。在Vulkan中，当我们想要将渲染输出到图像时，我们需要知道它的句柄。需要创建一个图像视图来包装图像，并在创建帧缓冲区时使用。帧缓冲区，就像OpenGL一样，指定了在渲染过程中使用的图像集合（大多数情况下是我们将渲染到它们）。
- en: But this is not the only case in which we need to know what images were created
    along with a swapchain. It's been said that when an application wants to use a
    presentable image, it must acquire it from the presentation engine. The process
    of image acquisition returns a number, not the handle itself. The provided number
    represents an index of an image in the array of images acquired with the `vkGetSwapchainImagesKHR()`
    function (a `swapchain_images` variable). So the knowledge of the total number
    of images, their order, and their handles is necessary to properly use a swapchain
    and its images.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是唯一需要知道与交换链一起创建的图像的情况。据说当应用程序想要使用可呈现的图像时，它必须从显示引擎中获取它。图像获取的过程返回一个数字，而不是句柄本身。提供的数字代表使用`vkGetSwapchainImagesKHR()`函数（一个`swapchain_images`变量）获取的图像数组中的图像索引。因此，了解图像的总数、它们的顺序和它们的句柄对于正确使用交换链及其图像是必要的。
- en: 'To acquire the total number of images, we need to use the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取图像的总数，我们需要使用以下代码：
- en: '[PRE25]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we can prepare storage for all images and acquire their handles:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以为所有图像准备存储空间并获取它们的句柄：
- en: '[PRE26]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下内容：
- en: '*Selecting a number of swapchain images*'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的数量*'
- en: '*Creating a swapchain*'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: '*Acquiring a swapchain image*'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取swapchain图像*'
- en: '*Presenting an image*'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像*'
- en: Creating a swapchain with R8G8B8A8 format and a mailbox present mode
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个具有R8G8B8A8格式和存在邮箱显示模式的swapchain
- en: To create a swapchain, we need to acquire a lot of additional information and
    prepare a considerable number of parameters. To present the order of all the steps
    required for the preparation phases and how to use the acquired information, we
    will create a swapchain with arbitrarily chosen parameters. For it, we will set
    a mailbox presentation mode, the most commonly used R8G8B8A8 color format with
    unsigned normalized values (similar to OpenGL's RGBA8 format), no transformations,
    and a standard color attachment image usage.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建swapchain，我们需要获取大量的附加信息和准备相当数量的参数。为了展示准备阶段所需的所有步骤的顺序以及如何使用获取的信息，我们将使用任意选择的参数创建一个swapchain。为此，我们将设置邮箱显示模式，最常用的R8G8B8A8颜色格式，具有无符号归一化值（类似于OpenGL的RGBA8格式），无转换，以及标准颜色附加图像使用。
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Prepare a physical device handle. Store it in a variable of type `VkPhysicalDevice`
    named `physical_device`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个物理设备句柄。将其存储在名为`physical_device`的类型为`VkPhysicalDevice`的变量中。
- en: Take the handle of a created presentation surface and assign it to a variable
    of type `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的显示表面的句柄并将其分配给名为`presentation_surface`的类型为`VkSurfaceKHR`的变量。
- en: Take the logical device created from the handle represented by the `physical_device`
    variable. Store the handle of the logical device in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`physical_device`变量表示的句柄中获取逻辑设备。将逻辑设备的句柄存储在名为`logical_device`的类型为`VkDevice`的变量中。
- en: Create a variable of type `VkSwapchainKHR` named `old_swapchain`. If a swapchain
    was previously created, assign its handle to the `old_swapchain` variable. Otherwise,
    assign a `VK_NULL_HANDLE` to it.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`old_swapchain`的类型为`VkSwapchainKHR`的变量。如果之前创建了swapchain，则将其句柄分配给`old_swapchain`变量。否则，将其分配给`VK_NULL_HANDLE`。
- en: Create a variable of type `VkPresentModeKHR` named `desired_present_mode`.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`desired_present_mode`的类型为`VkPresentModeKHR`的变量。
- en: Check whether the `VK_PRESENT_MODE_MAILBOX_KHR` presentation mode is supported
    and assign it to the `desired_present_mode` variable. If this mode is not supported,
    use a `VK_PRESENT_MODE_FIFO_KHR` mode (refer to *Selecting a desired presentation
    mode* recipe).
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`VK_PRESENT_MODE_MAILBOX_KHR`显示模式是否受支持，并将其分配给`desired_present_mode`变量。如果不支持此模式，则使用`VK_PRESENT_MODE_FIFO_KHR`模式（参考*选择期望的显示模式*配方）。
- en: Create a variable of type `VkSurfaceCapabilitiesKHR` named `surface_capabilities`.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`surface_capabilities`的类型为`VkSurfaceCapabilitiesKHR`的变量。
- en: Get the capabilities of a presentation surface and store them in the `surface_capabilities`
    variable.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取显示表面的能力并将它们存储在`surface_capabilities`变量中。
- en: Create a variable of type `uint32_t` named `number_of_images`. Based on the
    acquired surface capabilities, assign a minimal required number of images to the
    `number_of_images` variable (refer to the *Selecting a number of swapchain images*
    recipe).
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`number_of_images`的类型为`uint32_t`的变量。根据获取的表面能力，将所需的最小图像数量分配给`number_of_images`变量（参考*选择swapchain图像数量*配方）。
- en: Create a variable of type `VkExtent2D` named `image_size`. Based on the acquired
    surface capabilities, assign a size of swapchain images to the `image_size` variable
    (refer to the *Choosing a size of swapchain images* recipe).
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_size`的类型为`VkExtent2D`的变量。根据获取的表面能力，将swapchain图像的大小分配给`image_size`变量（参考*选择swapchain图像大小*配方）。
- en: Make sure the `width` and `height` members of the `image_size` variable are
    greater than zero. If they are not, do not attempt to create a swapchain, but
    don't close the application--such a situation may occur when a window is minimized.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保变量`image_size`的`width`和`height`成员大于零。如果它们不是，不要尝试创建swapchain，但不要关闭应用程序——这种情况下可能发生在窗口最小化时。
- en: Create a variable of type `VkImageUsageFlags` named `image_usage`. Assign a
    `VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT` image usage to it (refer to the *Selecting
    desired usage scenarios of swapchain images* recipe).
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`image_usage`的类型为`VkImageUsageFlags`的变量。将`VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT`图像使用分配给它（参考*选择swapchain图像的期望使用场景*配方）。
- en: Create a variable of type `VkSurfaceTransformFlagBitsKHR` named `surface_transform`.
    Store an identity transform (a value of `VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR`)
    in the variable. Based on the acquired surface capabilities, check whether it
    is supported. If it is not, assign the `currentTransform` member of the acquired
    capabilities to the `surface_transform` variable (refer to the *Selecting a transformation
    of swapchain images* recipe).
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `surface_transform` 的 `VkSurfaceTransformFlagBitsKHR` 类型的变量。将一个单位变换（`VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR`
    的值）存储在该变量中。根据获取的表面能力，检查它是否受支持。如果不支持，将获取的能力中的 `currentTransform` 成员赋值给 `surface_transform`
    变量（参考 *选择交换链图像的变换* 章节中的配方）。
- en: Create a variable of type `VkFormat` named `image_format` and a variable of
    type `VkColorSpaceKHR` named `image_color_space`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image_format` 的 `VkFormat` 类型的变量和一个名为 `image_color_space` 的 `VkColorSpaceKHR`
    类型的变量。
- en: Using the acquired capabilities, try to use the `VK_FORMAT_R8G8B8A8_UNORM` image
    format with a `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR` color space. If format or color
    space, or both, are not supported, select other values from the surface capabilities
    (refer to the *Selecting a format of swapchain images* recipe).
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用获取的能力，尝试使用 `VK_FORMAT_R8G8B8A8_UNORM` 图像格式和 `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`
    色彩空间。如果格式或色彩空间，或两者都不受支持，则从表面能力中选择其他值（参考 *选择交换链图像的格式* 章节中的配方）。
- en: Create a variable of type `VkSwapchainKHR` named `swapchain`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapchain` 的 `VkSwapchainKHR` 类型的变量。
- en: Using the `logical_device`, `presentation_surface`, `number_of_images`, `image_format`,
    `image_color_space`, `size_of_images`, `image_usage`, `surface_transform`, `desired_present_mode`,
    and `old_swapchain` variables, create a swapchain and store its handle in the
    `swapchain` variable. Remember to check if the swapchain creation was successful. (refer
    to the *Creating a swapchain* recipe).
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `logical_device`、`presentation_surface`、`number_of_images`、`image_format`、`image_color_space`、`size_of_images`、`image_usage`、`surface_transform`、`desired_present_mode`
    和 `old_swapchain` 变量创建一个交换链，并将句柄存储在 `swapchain` 变量中。请记住检查交换链创建是否成功。（参考 *创建交换链*
    章节中的配方）。
- en: Create a variable of type `std::vector<VkImage>` named `swapchain_images` and
    store the handles of the created swapchain images in it (refer to the *Getting
    handles of swapchain images* recipe).
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapchain_images` 的 `std::vector<VkImage>` 类型的变量，并将创建的交换链图像的句柄存储在其中（参考
    *掌握交换链图像的句柄* 章节中的配方）。
- en: How it works...
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we want to create a swapchain, we first need to think what presentation
    mode we would like to use. As the mailbox mode allows us to present the most recent
    image without screen tearing (it is similar to a triple buffering), it looks like
    a good choice:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要创建一个交换链时，我们首先需要考虑我们想要使用哪种展示模式。由于邮箱模式允许我们在不出现屏幕撕裂的情况下展示最新的图像（它类似于三缓冲），这似乎是一个不错的选择：
- en: '[PRE27]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next we need to acquire the presentation surface capabilities and use them
    to set up the required number of images, their size (dimensions), usage scenarios,
    transformations applied during presentation, and their format and color space:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取展示表面的能力，并使用它们来设置所需图像的数量、大小（维度）、使用场景、展示期间应用的变换以及它们的格式和色彩空间：
- en: '[PRE28]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, with all these preparations, we can create a swapchain, destroy an
    old one (if we want to replace a previously created swapchain with the new one),
    and acquire the handles of images created along with it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在完成所有这些准备工作后，我们可以创建一个交换链，销毁旧的交换链（如果我们想用新的交换链替换之前创建的交换链），并获取与其一起创建的图像句柄：
- en: '[PRE29]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Creating a presentation surface*'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个展示表面*'
- en: '*Creating a logical device with WSI extensions enabled*'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建启用 WSI 扩展的逻辑设备*'
- en: '*Selecting a desired presentation mode*'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择期望的展示模式*'
- en: '*Getting capabilities of a presentation surface*'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取展示表面的能力*'
- en: '*Selecting a number of swapchain images*'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的数量*'
- en: '*Choosing a size of swapchain images*'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的大小*'
- en: '*Selecting desired usage scenarios of swapchain images*'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的期望使用场景*'
- en: '*Selecting a transformation of swapchain images*'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的变换*'
- en: '*Selecting a format of swapchain images*'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择交换链图像的格式*'
- en: '*Creating a swapchain*'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建交换链*'
- en: '*Getting handles of swapchain images*'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握交换链图像的句柄*'
- en: Acquiring a swapchain image
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取交换链图像
- en: Before we can use a swapchain image, we need to ask a presentation engine for
    it. This process is called **image acquisition**. It returns an image's index
    into the array of images returned by the `vkGetSwapchainImagesKHR()` function
    as described in the *Getting handles of swapchain images* recipe.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用交换链图像之前，我们需要向显示引擎请求它。这个过程被称为**图像获取**。它返回一个图像的索引，该索引是 `vkGetSwapchainImagesKHR()`
    函数返回的图像数组中的索引，如 *获取交换链图像句柄* 菜单中所述。
- en: Getting ready
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To acquire an image in Vulkan, we need to specify one of two types of objects
    that haven't been described yet. These are semaphores and fences.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Vulkan 中获取图像，我们需要指定两种尚未描述的对象之一。这些是信号量和栅栏。
- en: Semaphores are used to synchronize device's queues. It means that when we submit
    commands for processing, these commands may require another job to be finished.
    In such a situation, we can specify that these commands should wait for the other
    commands before they are executed. And this is what semaphores are for. They are
    for internal queue synchronization, but we can't use them to synchronize an application
    with the submitted commands (refer to the *Creating a semaphore* recipe from [Chapter
    3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers and Synchronization*).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量用于同步设备的队列。这意味着当我们提交命令进行处理时，这些命令可能需要另一个任务完成。在这种情况下，我们可以指定这些命令应该在执行之前等待其他命令。这正是信号量的作用。它们用于内部队列同步，但我们不能使用它们来同步应用程序与提交的命令（请参阅
    [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的 *创建信号量* 菜单）。
- en: To do so, we need to use fences. They are used to inform an application about
    some work being finished. An application can acquire the state of a fence and,
    based on the acquired information, check whether some commands are still being
    processed or whether they have finished the assigned tasks (refer to the *Creating
    a fence* recipe from [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml),
    *Command Buffers and Synchronization*).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们需要使用栅栏。它们用于通知应用程序某些工作已完成。应用程序可以获取栅栏的状态，并根据获取的信息检查某些命令是否仍在处理中，或者它们是否已经完成了分配的任务（请参阅
    [第 3 章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中的 *创建栅栏* 菜单）。
- en: How to do it...
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a created logical device and store it in a variable of type
    `VkDevice` named `logical_device`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的逻辑设备的句柄，并将其存储在类型为 `VkDevice` 的变量 `logical_device` 中。
- en: Prepare the handle of a swapchain object and assign it to a `VkSwapchainKHR`
    variable named `swapchain`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个交换链对象的句柄，并将其分配给名为 `swapchain` 的 `VkSwapchainKHR` 变量。
- en: Prepare a semaphore in the form of a variable of type `VkSemaphore` named `semaphore`
    or prepare a fence and assign its handle to the variable of type `VkFence` named
    `fence`. You can prepare both synchronization objects but at least one of them
    is required (no matter which one).
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个类型为 `VkSemaphore` 的变量 `semaphore` 的信号量，或者准备一个栅栏并将它的句柄分配给类型为 `VkFence` 的变量
    `fence`。您可以准备这两个同步对象，但至少需要其中一个（无论哪个）。
- en: Create a variable of type `uint32_t` named `image_index`.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image_index` 的 `uint32_t` 类型的变量。
- en: Call `vkAcquireNextImageKHR( logical_device, swapchain, <timeout>, semaphore,
    fence, &image_index )`. Provide a handle of the logical device in the first parameter
    and a handle of a swapchain object in the second. For the third parameter, named
    `<timeout>`, provide a value of time after which the function will return a timeout
    error. You also need to provide one or both synchronization primitives--a swapchain
    and/or a fence. For the last parameter, provide a pointer to the `image_index`
    variable.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `vkAcquireNextImageKHR( logical_device, swapchain, <timeout>, semaphore,
    fence, &image_index )`。在第一个参数中提供逻辑设备的句柄，在第二个参数中提供交换链对象的句柄。对于第三个参数，名为 `<timeout>`，提供函数返回超时错误的时间值。您还需要提供一个或两个同步原语——交换链和/或栅栏。对于最后一个参数，提供一个指向
    `image_index` 变量的指针。
- en: Check the value returned by the `vkAcquireNextImageKHR()` function. If the returned
    value was equal to `VK_SUCCESS` or `VK_SUBOPTIMAL_KHR`, the call was successful
    and an `image_index` variable will hold an index of swapchain images which points
    to the element of an array returned by the `vkGetSwapchainImagesKHR()` function
    (refer to the *Getting handles of swapchain images* recipe). But if the `VK_ERROR_OUT_OF_DATE_KHR`
    value was returned, you can't use any images from the swapchain. You must destroy
    the given swapchain and recreate it once again in order to acquire images.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`vkAcquireNextImageKHR()`函数返回的值。如果返回值等于`VK_SUCCESS`或`VK_SUBOPTIMAL_KHR`，则调用成功，`image_index`变量将包含一个指向由`vkGetSwapchainImagesKHR()`函数返回的交换链图像数组的索引（参考*获取交换链图像句柄*过程）。但如果返回了`VK_ERROR_OUT_OF_DATE_KHR`值，则无法使用交换链中的任何图像。你必须销毁给定的交换链，并重新创建它以获取图像。
- en: How it works...
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `vkAcquireNextImageKHR()`function returns an index into the array of swapchain
    images returned by the `vkGetSwapchainImagesKHR()` function. It does not return
    the handle of that image. The following code illustrates the recipe:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`vkAcquireNextImageKHR()`函数返回一个索引，该索引指向由`vkGetSwapchainImagesKHR()`函数返回的交换链图像数组。它不返回该图像的句柄。以下代码说明了这个过程：'
- en: '[PRE30]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the code sample, we call the `vkAcquireNextImageKHR()` function. Sometimes
    images may not be available immediately due to the internal mechanism of a presentation
    engine. It is even possible that we may wait indefinitely! It occurs in situations
    when we want to acquire more images than the presentation engine can provide.
    That's why in the third parameter of the preceding function, we provide a timeout
    value in nanoseconds. It tells the hardware how long we can wait for the image.
    After this time, the function will inform us that it took too long to acquire
    an image. In the preceding sample, we inform the driver that we don't want to
    wait more than 2 seconds for the image to be acquired.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们调用`vkAcquireNextImageKHR()`函数。有时由于演示引擎的内部机制，图像可能无法立即可用。甚至可能无限期地等待！这种情况发生在我们想要获取比演示引擎能提供的更多图像时。这就是为什么在前一个函数的第三个参数中，我们提供了一个以纳秒为单位的超时值。它告诉硬件我们可以等待图像多长时间。在此时间之后，函数将通知我们获取图像花费了太长时间。在前面的示例中，我们通知驱动程序我们不想等待超过2秒钟来获取图像。
- en: The other interesting parameters are a semaphore and a fence. When we acquire
    an image, we still may not use it immediately for our purposes. We need to wait
    for all previously submitted operations that referenced this image to finish.
    For this purpose, a fence can be used, using which an application can check when
    it is safe to modify an image. But we can also tell the driver that it should
    wait before it starts processing new commands that use a given image. For this
    purpose, a semaphore is used, which, in general, is a better option.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有趣的参数是一个信号量和一个栅栏。当我们获取一个图像时，我们仍然可能无法立即为我们自己的目的使用它。我们需要等待所有之前提交的引用此图像的操作完成。为此，可以使用栅栏，通过它应用程序可以检查何时修改图像是安全的。但我们也可以告诉驱动程序在开始处理使用给定图像的新命令之前应该等待。为此，使用信号量，这通常是一个更好的选择。
- en: Waiting on the application side hurts the performance much more than waiting
    solely on the GPU.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序端等待比仅在GPU端等待对性能的伤害更大。
- en: Return values are also very important during swapchain image acquisition. When
    the function returns a `VK_SUBOPTIMAL_KHR` value, it means we can still use an
    image but it may no longer be best suited for the presentation engine. We should
    recreate the swapchain from which an image was acquired. But we don't need to
    do it immediately. When the function returns a `VK_ERROR_OUT_OF_DATE_KHR` value,
    we can't use images from a given swapchain anymore and we need to recreate it
    as soon as possible.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换链图像获取过程中，返回值也非常重要。当函数返回`VK_SUBOPTIMAL_KHR`值时，这意味着我们仍然可以使用该图像，但它可能不再最适合演示引擎。我们应该从获取图像的交换链中重新创建交换链。但我们不需要立即这样做。当函数返回`VK_ERROR_OUT_OF_DATE_KHR`值时，我们不能再使用给定交换链中的图像，并且我们需要尽快重新创建它。
- en: And the last thing to note about swapchain image acquisition is that before
    we can use an image, we need to change (transition) its layout. The layout is
    the image's internal memory organization, which may be different depending on
    the current purpose for which image is used. And if we want to use the image in
    a different way, we need to change its layout.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 关于交换链图像获取的最后一点是，在我们能够使用图像之前，我们需要更改（转换）其布局。布局是图像的内部内存组织，这可能会根据图像当前使用的目的而有所不同。如果我们想以不同的方式使用图像，我们需要更改其布局。
- en: For example, images used by the presentation engine must have a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` layout.
    But if we want to render into an image, it must have a `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` layout.
    The operation of changing the layout is called a transition (refer to the *Setting
    an image memory barrier* recipe from [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml),
    *Resources and Memory*).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，展示引擎使用的图像必须具有 `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR` 布局。但如果我们想要将图像渲染到图像中，它必须具有
    `VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL` 布局。改变布局的操作称为转换（参考第 4 章 *设置图像内存屏障* 的配方，*资源和内存*）。
- en: See also
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Selecting a desired presentation mode*'
  id: totrans-507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择所需的展示模式*'
- en: '*Creating a swapchain*'
  id: totrans-508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个交换链*'
- en: '*Getting handles of swapchain images*'
  id: totrans-509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取交换链图像的句柄*'
- en: '*Presenting an image*'
  id: totrans-510
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*展示一个图像*'
- en: 'In [Chapter 4](f1332ca0-b5a2-49bd-ac41-e37068e31042.xhtml), *Resources and
    Memory* see the following recipe:'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 4 章 *资源和内存* 中，查看以下配方：
- en: '*Setting an image memory barrier*'
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization* see the following recipe:'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 3 章 *命令缓冲区和同步* 中，查看以下配方：
- en: '*Creating a semaphore*'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Creating a fence*'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个栅栏*'
- en: Presenting an image
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示一个图像
- en: After we are done rendering into a swapchain image or using it for any other
    purposes, we need to give the image back to the presentation engine. This operation
    is called a presentation and it displays an image on screen.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将图像渲染到交换链图像或用于其他任何目的之后，我们需要将图像归还给展示引擎。这个操作称为展示，它会在屏幕上显示图像。
- en: Getting ready
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will be using a custom structure defined as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用以下定义的自定义结构：
- en: '[PRE31]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is used to define a swapchain from which we want to present an image, and
    an image (its index) that we want to display. For each swapchain, we can present
    only one image at a time.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于定义我们想要展示图像的交换链，以及我们想要显示的图像（其索引）。对于每个交换链，我们一次只能展示一个图像。
- en: How to do it...
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进行...
- en: Prepare a handle of a queue that supports presenting. Store it in a variable
    of type `VkQueue` named `queue`.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个支持展示的队列的句柄。将其存储在名为 `queue` 的 `VkQueue` 类型的变量中。
- en: Prepare a variable of type `std::vector<VkSemaphore>` named `rendering_semaphores`.
    Into this vector, insert semaphores associated with rendering commands that reference
    images which we want to present.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个名为 `rendering_semaphores` 的 `std::vector<VkSemaphore>` 类型的变量。将与此相关的信号量插入到这个向量中，这些信号量与引用我们想要展示的图像的渲染命令相关联。
- en: Create a variable of type `std::vector<VkSwapchainKHR>` named `swapchains` in
    which store the handles of all swapchains from which we want to present images.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `swapchains` 的 `std::vector<VkSwapchainKHR>` 类型的变量，用于存储我们想要展示图像的所有交换链的句柄。
- en: Create a variable of type `std::vector<uint32_t>` named `image_indices`. Resize
    the vector to be the same size as the `swapchains` vector. For each element of
    the `image_indices` variable, assign an index of an image from the corresponding
    swapchain (at the same position in the `swapchains` vector).
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `image_indices` 的 `std::vector<uint32_t>` 类型的变量。将向量的大小调整为与 `swapchains`
    向量相同。对于 `image_indices` 变量的每个元素，分配来自相应交换链（在 `swapchains` 向量中的相同位置）的图像的索引。
- en: 'Create a variable of type `VkPresentInfoKHR` named `present_info`. Assign the
    following values for its members:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `present_info` 的 `VkPresentInfoKHR` 类型的变量。为其成员分配以下值：
- en: '`VK_STRUCTURE_TYPE_PRESENT_INFO_KHR` value for `sType`'
  id: totrans-528
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_STRUCTURE_TYPE_PRESENT_INFO_KHR` 对应的 `sType` 值'
- en: '`nullptr` value for `pNext`'
  id: totrans-529
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pNext` 的 `nullptr` 值'
- en: A number of elements of the `rendering_semaphores` vector for `waitSemaphoreCount`
  id: totrans-530
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rendering_semaphores` 向量中的元素数量用于 `waitSemaphoreCount`'
- en: A pointer to the first element of the `rendering_semaphores` vector for `pWaitSemaphores`
  id: totrans-531
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `rendering_semaphores` 向量第一个元素的指针用于 `pWaitSemaphores`
- en: The number of elements in the `swapchains` vector for `swapchainCount`
  id: totrans-532
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swapchainCount` 的 `swapchains` 向量中的元素数量'
- en: A pointer to the first element of the `swapchains` vector for `pSwapchains`
  id: totrans-533
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pSwapchains`的`swapchains`向量的第一个元素的指针'
- en: A pointer to the first element of the `image_indices` vector for `pImageIndices`
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pImageIndices`的`image_indices`向量的第一个元素的指针'
- en: '`nullptr` value for `pResults`'
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pResults`的`nullptr`值'
- en: Call `vkQueuePresentKHR( queue, &present_info )` and provide the handle of the
    queue to which we want to submit this operation, and a pointer to the `present_info`
    variable.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkQueuePresentKHR(queue, &present_info)`并提供我们想要提交此操作的队列的句柄，以及`present_info`变量的指针。
- en: Make sure the call was successful by comparing the returned value with a `VK_SUCCESS`.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将返回值与`VK_SUCCESS`进行比较，确保调用成功。
- en: How it works...
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A presentation operation gives an image back to the presentation engine, which
    displays an image according to the presentation mode. We can present multiple
    images at the same time, but only one image from a given swapchain. To present
    an image, we provide its index into the array returned by the `vkGetSwapchainImagesKHR()`
    function (refer to the *Getting handles of swapchain images* recipe):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 展示操作将图像返回给展示引擎，展示引擎根据展示模式显示图像。我们可以同时展示多个图像，但只能从给定的swapchain中选择一个图像。要展示一个图像，我们需要提供其索引，该索引由`vkGetSwapchainImagesKHR()`函数返回的数组中（参考*获取swapchain图像句柄*配方）：
- en: '[PRE32]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding sample, the handles of swapchains from which we want to present
    images and the indices of images are placed in the `swapchains` and `image_indices`
    vectors.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们想要展示图像的swapchain的句柄和图像的索引被放置在`swapchains`和`image_indices`向量中。
- en: Before we can submit an image, we need to change its layout to a `VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`
    or the presentation engine may be not able to correctly display such an image.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以提交一个图像之前，我们需要将其布局更改为`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`，否则展示引擎可能无法正确显示此类图像。
- en: Semaphores are used to inform the hardware when it can safely display an image.
    When we submit a rendering command, we can associate a semaphore with such a submission.
    This semaphore will then change its state to signaled when the commands are finished.
    We should create and associate a semaphore with commands that reference a presentable
    image. This way, when we present an image and provide such a semaphore, the hardware
    will know when an image is no longer in use and displaying it will not interrupt
    any previously issued operations.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量用于通知硬件何时可以安全地显示图像。当我们提交一个渲染命令时，我们可以将一个信号量与这样的提交关联。然后，当命令完成时，这个信号量将改变其状态为已触发。我们应该创建一个信号量并将其与引用可展示图像的命令关联。这样，当我们展示一个图像并提供这样的信号量时，硬件将知道何时图像不再使用，并且展示它不会中断任何先前发出的操作。
- en: See also
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The following recipes in this chapter:'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的以下配方：
- en: '*Selecting a desired presentation mode*'
  id: totrans-546
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择一个期望的展示模式*'
- en: '*Creating a swapchain*'
  id: totrans-547
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建swapchain*'
- en: '*Getting handles of swapchain images*'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取swapchain图像句柄*'
- en: '*Acquiring a swapchain image*'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取swapchain图像*'
- en: 'In [Chapter 3](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml), *Command Buffers
    and Synchronization* see the following recipe:'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](fc38e0ae-51aa-4f6f-8fb3-551861273018.xhtml)，*命令缓冲区和同步*中查看以下配方：
- en: '*Creating a semaphore*'
  id: totrans-551
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个信号量*'
- en: '*Creating a fence*'
  id: totrans-552
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个栅栏*'
- en: 'In [Chapter 4](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&action=edit#post_207), *Resources
    and Memory* see the following recipe:'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](https://cdp.packtpub.com/vulkancookbook/wp-admin/post.php?post=29&action=edit#post_207)，*资源和内存*中查看以下配方：
- en: '*Setting an image memory barrier*'
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置图像内存屏障*'
- en: Destroying a swapchain
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁swapchain
- en: When we are done using a swapchain, because we don't want to present images
    any more, or because we are just closing our application, we should destroy it.
    We need to destroy it before we destroy a presentation surface which was used
    during a given swapchain creation.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成使用swapchain时，因为我们不再想要展示图像，或者因为我们只是关闭我们的应用程序，我们应该销毁它。在销毁用于给定swapchain创建的展示表面之前，我们需要销毁它。
- en: How to do it...
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Take the handle of a logical device and store it in a variable of type `VkDevice`
    named `logical_device`.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取逻辑设备的句柄并将其存储在名为`logical_device`的`VkDevice`类型的变量中。
- en: Take the handle of a swapchain object that needs to be destroyed. Store it in
    a variable of type `VkSwapchainKHR` named `swapchain`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取需要销毁的swapchain对象的句柄。将其存储在名为`swapchain`的`VkSwapchainKHR`类型的变量中。
- en: Call `vkDestroySwapchainKHR( logical_device, swapchain, nullptr )` and provide
    the `logical_device` variable as the first argument and the swapchain handle as
    the second argument. Set the last parameter to `nullptr`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroySwapchainKHR(logical_device, swapchain, nullptr)`，并将`logical_device`变量作为第一个参数，swapchain句柄作为第二个参数。将最后一个参数设置为`nullptr`。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `swapchain` variable.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将`VK_NULL_HANDLE`值分配给`swapchain`变量。
- en: How it works...
  id: totrans-562
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To destroy a swapchain, we can prepare code that is similar to the following
    example:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁swapchain，我们可以准备类似于以下示例的代码：
- en: '[PRE33]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First we check whether a swapchain was really created (if its handle is not
    empty). Next we call the `vkDestroySwapchainKHR()` function and then we assign
    a `VK_NULL_HANDLE` value to the `swapchain` variable to be sure that we won't
    try to delete the same object twice.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否真的创建了一个swapchain（如果其句柄不为空）。接下来，我们调用`vkDestroySwapchainKHR()`函数，然后将`VK_NULL_HANDLE`值赋给`swapchain`变量以确保我们不会尝试删除同一个对象两次。
- en: See also
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a swapchain* recipe in this chapter'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建swapchain*配方
- en: Destroying a presentation surface
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁展示表面
- en: The presentation surface represents the window of our application. It is used,
    among other purposes, during swapchain creation. That's why we should destroy
    the presentation surface after the destruction of a swapchain that is based on
    a given surface is finished.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 展示表面代表我们应用程序的窗口。它在创建swapchain的过程中被使用，以及其他目的。这就是为什么在基于给定表面的swapchain被销毁完成后，我们应该销毁展示表面。
- en: How to do it...
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Prepare the handle of a Vulkan Instance and store it in a variable of type `VkInstance`
    named `instance`.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个Vulkan实例的句柄，并将其存储在名为`instance`的`VkInstance`类型变量中。
- en: Take the handle of a presentation surface and assign it to the variable of type
    `VkSurfaceKHR` named `presentation_surface`.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取展示表面的句柄，并将其分配给名为`presentation_surface`的`VkSurfaceKHR`类型变量。
- en: Call `vkDestroySurfaceKHR( instance, presentation_surface, nullptr )` and provide
    the `instance` and `presentation_surface` variables in the first two parameters
    and a `nullptr` value in the last parameter.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`vkDestroySurfaceKHR(instance, presentation_surface, nullptr)`，并将`instance`和`presentation_surface`变量作为前两个参数，最后一个参数设置为`nullptr`。
- en: For safety reasons, assign a `VK_NULL_HANDLE` value to the `presentation_surface`
    variable.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，将`VK_NULL_HANDLE`值分配给`presentation_surface`变量。
- en: How it works...
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The presentation surface''s destruction is very similar to the destruction
    of other Vulkan resources presented so far. We make sure we don''t provide a `VK_NULL_HANDLE`
    value and we call a `vkDestroySurfaceKHR()` function. After that, we assign a
    `VK_NULL_HANDLE` value to the `presentation_surface` variable:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 展示表面的销毁与其他到目前为止展示的Vulkan资源的销毁非常相似。我们确保不提供`VK_NULL_HANDLE`值，并调用`vkDestroySurfaceKHR()`函数。之后，我们将`VK_NULL_HANDLE`值分配给`presentation_surface`变量：
- en: '[PRE34]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See also
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a presentation surface* recipe in this chapter'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*创建展示表面*配方
