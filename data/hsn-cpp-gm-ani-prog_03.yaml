- en: '*Chapter 3*: Implementing Matrices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：实现矩阵'
- en: In the context of game animation, a matrix represents an affine transformation.
    It linearly maps points from one space to another. A mesh is represented by vertices,
    which are just points in space. These vertices are moved by multiplying them by
    a matrix.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏动画的背景下，矩阵代表一个仿射变换。它将点从一个空间线性映射到另一个空间。一个网格由顶点表示，这些顶点只是空间中的点。通过将它们乘以一个矩阵，这些顶点被移动。
- en: In this chapter, you will learn matrix math and how to implement matrices in
    code. By the end of this chapter, you will have built a robust matrix library
    that can be used in any project. Matrices are important; they play a big role
    in the graphics pipeline. It's hard to render anything without using matrices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习矩阵数学以及如何在代码中实现矩阵。到本章结束时，您将建立一个强大的矩阵库，可以在任何项目中使用。矩阵很重要；它们在图形管线中扮演着重要角色。没有使用矩阵，很难渲染任何东西。
- en: 'You will only need to implement a square, 4 x 4 matrix. By the end of this
    chapter, you should be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要实现一个4 x 4的方阵。到本章结束时，您应该能够做到以下几点：
- en: Understand what a matrix is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解矩阵是什么
- en: Understand column-major matrix storage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解列主要矩阵存储
- en: Multiply matrices together
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将矩阵相乘
- en: Invert a matrix
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转矩阵
- en: Transform points and vectors by using a matrix
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用矩阵来转换点和向量
- en: Understand how to create matrices to view a three-dimensional world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何创建矩阵以查看三维世界
- en: Important information
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: In this chapter, you will implement a 4 x 4 matrix. The matrix implementation
    will rely on code to demonstrate concepts, rather than through the format of math
    definitions. If you're interested in the formal math behind matrices, check out
    [https://gabormakesgames.com/matrices.html](https://gabormakesgames.com/matrices.html).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将实现一个4 x 4的矩阵。矩阵的实现将依赖于代码来演示概念，而不是通过数学定义的格式。如果您对矩阵背后的正式数学感兴趣，请查看[https://gabormakesgames.com/matrices.html](https://gabormakesgames.com/matrices.html)。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are two samples provided in the downloadable materials for the book for
    this chapter. `Sample00` shows the matrix code as it is written throughout the
    chapter. `Sample01` shows an alternative implementation that uses explicit lower-order
    matrices to implement the matrix inverse function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的可下载材料中提供了两个示例。`Sample00`显示了整个章节中编写的矩阵代码。`Sample01`显示了一个使用显式低阶矩阵来实现矩阵逆函数的替代实现。
- en: What is a matrix?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是矩阵？
- en: A matrix is a two-dimensional array of numbers. A square matrix is one whose
    width and height are the same. In this chapter, you will implement a 4 x 4 matrix;
    that is, a matrix with four rows and four columns. The elements of this matrix
    will be stored as a linear array.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个二维数组。一个方阵是宽度和高度相同的矩阵。在本章中，您将实现一个4 x 4的矩阵；也就是说，一个有四行四列的矩阵。这个矩阵的元素将被存储为一个线性数组。
- en: A 4 x 4 matrix can be thought of as four vectors that have four components each,
    or an array of `vec4s`. If the vectors represent the columns of the matrix, the
    matrix is column-major. If the vectors represent the rows of the matrix, it is
    row-major.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个4 x 4的矩阵可以被看作是有四个分量的四个向量，或者是一个`vec4s`数组。如果这些向量代表矩阵的列，那么矩阵是列主要的。如果这些向量代表矩阵的行，那么它是行主要的。
- en: 'Assuming a 4 x 4 matrix contains the letters *A, B, C, D … P* of the alphabet,
    it can be constructed as either a row- or column-major matrix. This is demonstrated
    in the following *Figure 3.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个4 x 4的矩阵包含字母* A，B，C，D … P *的字母表，它可以被构造为行主要或列主要矩阵。这在下面的*图3.1*中有所示：
- en: '![Figure 3.1: Comparing row- and column-major matrices'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1：比较行主要和列主要矩阵'
- en: '](img/Figure_3.1_B16191.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16191.jpg)'
- en: 'Figure 3.1: Comparing row- and column-major matrices'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：比较行主要和列主要矩阵
- en: 'Most math books and OpenGL use column-major matrices. In this chapter, you
    will be implementing column-major matrices as well. Understanding what is in a
    matrix is important. The diagonal of the matrix contains scaling information,
    and the final column contains translation:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数学书籍和OpenGL使用列主要矩阵。在本章中，您也将实现列主要矩阵。了解矩阵中包含的内容是很重要的。矩阵的对角线包含缩放信息，最后一列包含平移：
- en: '![Figure 3.2: What is stored in a matrix?'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2：矩阵中存储了什么？'
- en: '](img/Figure_3.2_B16191.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16191.jpg)'
- en: 'Figure 3.2: What is stored in a matrix?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：矩阵中存储了什么？
- en: The upper 3 x 3 submatrix contains three vectors; each of these is a basis vector
    for the matrix's rotation. The basis vectors are the up, right, and forward directions
    stored in the matrix. You might have noticed that the rotation and scale components
    occupy the same space in the matrix.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的3 x 3子矩阵包含三个向量；每个向量都是矩阵旋转的基向量。基向量是存储在矩阵中的上、右和前方向。您可能已经注意到旋转和比例组件在矩阵中占据了相同的空间。
- en: Matrix storage
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵存储
- en: Now that you know that the matrix layout is going to be column matrices, the
    next question is how to store the actual matrix. Matrix storage is a confusing
    topic.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道矩阵布局将是列矩阵，下一个问题是如何存储实际的矩阵。矩阵存储是一个令人困惑的话题。
- en: Since a matrix is stored in memory as a linear array, let's figure out what
    elements should be placed where. A row-major matrix is stored in memory one row
    at a time. A column-major matrix is stored one column at a time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于矩阵在内存中存储为线性数组，让我们弄清楚应该把元素放在哪里。行主要矩阵在内存中一次存储一行。列主要矩阵一次存储一列。
- en: 'Since both row- and column-major matrices contain the same vectors, the final
    linear mapping ends up being the same, regardless of the major of the matrix.
    The following *Figure 3.3* demonstrates this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行主要和列主要矩阵都包含相同的向量，最终的线性映射结果是相同的，无论矩阵的主要性如何。下面的*图3.3*演示了这一点：
- en: '![Figure 3.3: Matrix storage mapping to a linear array'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3：矩阵存储映射到线性数组'
- en: '](img/Figure_3.3_B16191.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B16191.jpg)'
- en: 'Figure 3.3: Matrix storage mapping to a linear array'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：矩阵存储映射到线性数组
- en: The matrix class you will be building is a column-major matrix with column storage;
    this means there will be a discrepancy between the physical memory layout of the
    matrix and the logical placement of its elements. It's easy to treat a matrix
    with a linear memory layout as a row matrix but remember that each of those rows
    is actually a column.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要构建的矩阵类是一个列主矩阵，使用列存储；这意味着矩阵的物理内存布局与其元素的逻辑放置之间会有差异。很容易将具有线性内存布局的矩阵视为行矩阵，但请记住，这些行中的每一行实际上都是一列。
- en: Important note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The typical mapping of a two-dimensional grid to linear storage is `"row * numberOfColumns
    + column"`. This mapping won't work for storing a column-major matrix. When looking
    at a matrix, the element in column 2, row 3 should have a linear index of 7, but
    the previous mapping yields 14\. Instead, to account for the column-major storage,
    the mapping formula is `"column * numberOfRows + row"`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将二维网格映射到线性存储的典型方法是`"行 * 列数 + 列"`。这种映射对于存储列主要矩阵是行不通的。当查看矩阵时，列2，行3的元素应该具有线性索引7，但是先前的映射得到的是14。为了适应列主存储，映射公式是`"列
    * 行数 + 行"`。
- en: Understanding how a matrix is stored in memory is important, it's going to affect
    how data is stored and how APIs can access that data. In the next section, you
    will start to implement a matrix structure.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 了解矩阵在内存中的存储方式很重要，它将影响数据的存储方式以及API如何访问这些数据。在下一节中，您将开始实现一个矩阵结构。
- en: Creating a matrix
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建矩阵
- en: 'In this section, you will create a new 4 x 4 matrix. This matrix will be stored
    as a 16-element array of floats. A union will be used to allow access to the data
    in the matrix in an easier-to-use fashion:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建一个新的4x4矩阵。这个矩阵将以一个包含16个浮点数的数组的形式存储。将使用一个联合来以更易于使用的方式访问矩阵中的数据：
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The identity matrix is a special matrix that multiplies anything by the identity
    matrix results in the original matrix. The identity matrix does no mapping. An
    identity matrix contains 0 in all elements except the main diagonal, which is
    made up entirely of 1.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵是一个特殊的矩阵，它将任何东西乘以单位矩阵的结果都是原始矩阵。单位矩阵不进行映射。单位矩阵中所有元素都包含0，除了主对角线，它完全由1组成。
- en: Create a new file, `mat4.h`. This file is needed to declare the `mat4` struct.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，`mat4.h`。这个文件需要声明`mat4`结构。
- en: 'Add the following structure declaration to `mat4.h`, which starts a union by
    declaring a flat array of 16 elements as the first member of the union:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下结构声明添加到`mat4.h`，它通过声明一个由16个元素组成的平面数组作为联合的第一个成员来开始一个联合：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next member of the union is a structure of `vec4` variables. Each of the
    `vec4` variables represents one column of the matrix; they are named after the
    basis vector stored in those columns:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联合的下一个成员是`vec4`变量的结构。每个`vec4`变量代表矩阵的一列；它们以存储在这些列中的基向量命名：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It might be useful to access members by element based on the basis vector.
    The following struct contains named pairs; the first letter represents the basis
    vector and the second letter represents the component of that vector:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据基向量的元素访问成员可能是有用的。以下结构包含了命名对；第一个字母代表基向量，第二个字母代表该向量的分量：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next struct will allow you to access the matrix using column-row notation:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个结构将允许您使用列-行表示法访问矩阵：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The final struct will allow you to access the matrix using row-column notation:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的结构将允许您使用行-列表示法访问矩阵：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add an `inline` constructor that will create the identity matrix:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`inline`构造函数，可以创建单位矩阵：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add an `inline` constructor that will create a matrix from a float array:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`inline`构造函数，可以从一个浮点数组创建矩阵：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add an `inline` constructor that will let you create a matrix by specifying
    each element inside the matrix:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`inline`构造函数，可以通过指定矩阵中的每个元素来创建矩阵：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The matrix struct you just declared is the final `mat4` struct; the anonymous
    union provides five different ways of accessing matrix data. Matrix data can be
    accessed as a flat array, as four columns each stored as `vec4`, or as one of
    three mnemonics. The three mnemonics name elements using their basis vectors,
    their row and then column, or their column and then row.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚声明的矩阵结构是最终的`mat4`结构；匿名联合提供了访问矩阵数据的五种不同方式。矩阵数据可以作为一个平面数组访问，作为四个列分别存储为`vec4`，或作为三个助记符之一访问。这三个助记符使用它们的基向量、它们的行然后列，或它们的列然后行来命名元素。
- en: Next, you will start working on functions that operate on the `mat4` structure.
    You will implement common matrix operations, such as adding, scaling, and multiplying
    matrices, and see how to use matrices to transform vectors and points.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将开始编写操作`mat4`结构的函数。您将实现常见的矩阵操作，如添加、缩放和相乘矩阵，并了解如何使用矩阵来转换向量和点。
- en: Common matrix operations
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的矩阵操作
- en: In this section, you will learn how to implement some common matrix operations.
    These operations will be used in later chapters of this book to display animated
    models. Specifically, this section will cover how to compare, add, scale, and
    multiply matrices as well as how to transform vectors and points using matrices.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何实现一些常见的矩阵操作。这些操作将在本书的后面章节中用于显示动画模型。具体来说，本节将涵盖如何比较、添加、缩放和相乘矩阵，以及如何使用矩阵来转换向量和点。
- en: Comparing matrices
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较矩阵
- en: Comparing matrices is a component-wise operation. Two matrices are the same
    only if all their components are the same. To compare two matrices, loop through
    and compare all of their components. Since you are comparing floating point numbers,
    an epsilon should be used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 比较矩阵是一个逐分量的操作。只有当两个矩阵的所有分量都相同时，它们才相同。要比较两个矩阵，循环遍历并比较它们的所有分量。由于比较的是浮点数，应该使用一个epsilon。
- en: 'Create a new file, `mat4.cpp`. Implement the matrix equality and inequality
    operators in this file. The equality operator should check whether two matrices
    are the same; the inequality operator returns the opposite of the equality operator.
    Don''t forget to add the function declarations to `mat4.h`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件 `mat4.cpp`。在这个文件中实现矩阵的相等和不相等运算符。相等运算符应该检查两个矩阵是否相同；不相等运算符返回相等运算符的相反值。不要忘记将函数声明添加到
    `mat4.h` 中：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `MAT4_EPSILON` constant should be defined in `mat4.h`. `0.000001f` is a
    good default value to use.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAT4_EPSILON` 常量应该在 `mat4.h` 中定义。`0.000001f` 是一个很好的默认值。'
- en: When comparing matrices by component, you are checking for literal equality.
    There are other ways to define matrix equality; for example, regardless of shape,
    the volume of two matrices can be compared using their determinants. Matrix determinants
    will be covered later in this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当按组件比较矩阵时，您正在检查字面上的相等。还有其他定义矩阵相等的方法；例如，可以使用它们的行列式来比较两个矩阵的体积，而不考虑形状。矩阵的行列式将在本章后面介绍。
- en: In the next section, you will learn how to add matrices together.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何将矩阵相加。
- en: Adding matrices
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵相加
- en: Two matrices can be added together by component. To add two matrices together,
    sum their respective components and store the result in a new matrix. Matrix addition
    can be used with scalar multiplication to interpolate or blend between multiple
    matrices. Later, you will learn how to use this property to implement animation
    skinning.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 两个矩阵可以按组件相加。要将两个矩阵相加，求出它们各自的分量之和，并将结果存储在一个新矩阵中。矩阵加法可以与标量乘法一起使用，以在多个矩阵之间进行插值或混合。稍后，您将学习如何使用这个属性来实现动画蒙皮。
- en: 'Implement the matrix addition function in `mat4.cpp`. Don''t forget to add
    the function declaration to `mat4.h`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mat4.cpp` 中实现矩阵加法函数。不要忘记将函数声明添加到 `mat4.h` 中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Matrix addition is simple but it will play a big role in displaying an animated
    mesh. In the next section, you will learn how to scale a matrix by a scalar value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵加法很简单，但在显示动画网格中起着重要作用。在下一节中，您将学习如何将矩阵按标量值进行缩放。
- en: Scaling a matrix
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵缩放
- en: Matrices can be scaled by floating point numbers; this kind of scaling is a
    component-wise operation. To scale a matrix, multiply every element by the provided
    floating point number.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵可以通过浮点数进行缩放；这种缩放是一种按组件的操作。要缩放一个矩阵，将每个元素乘以提供的浮点数。
- en: 'Implement matrix scaling in `mat4.cpp`. Don''t forget to add the function declaration
    to `mat4.h`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mat4.cpp` 中实现矩阵缩放。不要忘记将函数声明添加到 `mat4.h` 中：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Scaling matrices and then adding them allows you to "lerp" or "mix" between
    two matrices, so long as both matrices represent a linear transform. In the next
    section, you will learn how to multiply matrices together.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 先缩放矩阵，然后将它们相加，可以让您在多个矩阵之间进行"lerp"或"mix"，只要这些矩阵都表示线性变换。在下一节中，您将学习如何将矩阵相乘。
- en: Matrix multiplication
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩阵乘法
- en: 'Matrix multiplication combines the transformation of two matrices into one
    matrix. Two matrices can only be multiplied together if their inner dimensions
    are the same. The following are some examples:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法将两个矩阵的变换合并为一个矩阵。只有当两个矩阵的内部维度相同时，才能将两个矩阵相乘。以下是一些例子：
- en: A 4 x **4** and a **4** x 4 matrix could be multiplied together, since both
    inner dimensions are 4.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 4 x **4** 矩阵和一个 **4** x 4 矩阵可以相乘，因为内部维度都是 4。
- en: A 4 x **4** and a **4** x 1 matrix could be multiplied together, since both
    inner dimensions are 4.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 4 x **4** 矩阵和一个 **4** x 1 矩阵可以相乘，因为内部维度都是 4。
- en: A 4 x **4** and a **1** x 4 matrix could not be multiplied together, since the
    inner dimensions, 4 and 1, don't match.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 4 x **4** 矩阵和一个 **1** x 4 矩阵不能相乘，因为内部维度 4 和 1 不匹配。
- en: 'The resulting matrix from a matrix multiplication will have the outer dimensions
    of the matrices being multiplied together. The following is an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法的结果矩阵将具有相乘在一起的矩阵的外部维度。以下是一个例子：
- en: A **4** x 4 and a 4 x **4** matrix would yield a 4 x 4 matrix.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **4** x 4 矩阵和一个 4 x **4** 矩阵将产生一个 4 x 4 矩阵。
- en: A **4** x 4 and a 4 x **1** matrix would yield a 4 x 1 matrix.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **4** x 4 矩阵和一个 4 x **1** 矩阵将产生一个 4 x 1 矩阵。
- en: A **1** x 4 and a 4 x **2** matrix would yield a 1 x 2 matrix.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **1** x 4 矩阵和一个 4 x **2** 矩阵将产生一个 1 x 2 矩阵。
- en: Assume there are two matrices, *A* and *B*. Matrix *A* translates 10 units on
    the *X* axis. Matrix *B* rotates by 30 degrees around the *Y* axis. If the matrices
    where to be multiplied as *A * B*, the resulting matrix would rotate by 30 degrees
    around the *Y* axis then translate 10 units on the *X* axis.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个矩阵，*A* 和 *B*。矩阵 *A* 在 *X* 轴上平移 10 个单位。矩阵 *B* 绕 *Y* 轴旋转 30 度。如果这两个矩阵相乘为
    *A * B*，得到的矩阵将绕 *Y* 轴旋转 30 度，然后在 *X* 轴上平移 10 个单位。
- en: Matrix multiplication is not cumulative. Consider the last example but multiply
    *B * A*, instead. When multiplying *B * A*, the resulting matrix will translate
    10 units on the *X* axis and then rotate 30 degrees around the *Y* axis. Multiplication
    order matters; *A * B* is not the same as *B * A*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵乘法不是累积的。考虑上一个例子，但是将 *B * A* 相乘。当相乘 *B * A* 时，得到的矩阵将在 *X* 轴上平移 10 个单位，然后绕 *Y*
    轴旋转 30 度。乘法顺序很重要；*A * B* 不同于 *B * A*。
- en: This brings up a new question—what order should matrices be multiplied together
    in? If *M = A * B * C*, in what order do those matrices concatenate? *A*, *B*,
    and then *C* or *C*, *B*, and then *A*? If it's *A*, *B*, and then *C*, the matrix
    multiplication is defined as left to right. But if it's *C*, *B*, and then *A*,
    the matrix multiplication is right to left.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个新问题——矩阵应该以什么顺序相乘？如果 *M = A * B * C*，那么这些矩阵应该以什么顺序连接？*A*，*B*，然后 *C* 还是
    *C*，*B*，然后 *A*？如果是 *A*，*B*，然后 *C*，矩阵乘法被定义为从左到右。但如果是 *C*，*B*，然后 *A*，矩阵乘法是从右到左。
- en: To maintain consistency with OpenGL, in this chapter you will be implementing
    right-to-left multiplication. But how are two matrices multiplied together? Each
    element of a matrix has a row and a column. The resulting value for any element
    is the dot product of that row from the left matrix and that column forms the
    right matrix.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与OpenGL保持一致，在本章中，您将实现从右到左的矩阵乘法。但是两个矩阵如何相乘呢？矩阵的每个元素都有一行和一列。任何元素的结果值都是左矩阵的该行与右矩阵的该列的点积。
- en: 'For example, suppose you want to find the value of the element in row 2 column
    3 when multiplying two matrices. This means taking the dot product of row 2 from
    the left-hand side matrix and column 3 from the right-hand side matrix. *Figure
    3.4* demonstrates this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要找到两个矩阵相乘时第2行第3列的元素的值。这意味着取左侧矩阵的第2行和右侧矩阵的第3列进行点乘。*图3.4*演示了这一点：
- en: '![Figure 3.4: Multiplying matrices'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4：矩阵相乘'
- en: '](img/Figure_3.4_B16191.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B16191.jpg)'
- en: 'Figure 3.4: Multiplying matrices'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：矩阵相乘
- en: 'You might have noticed, in the previous figure, that even though the matrices
    are column-major, the subscript of the elements appears as row first, then column.
    The subscript references the physical topology of the matrix; it has nothing to
    do with what is stored in the matrix or how the matrix is laid out. Subscript
    indices remain the same, no matter what major the matrix is. Perform the following
    steps to implement matrix multiplication:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在前面的图中，即使矩阵是列主序的，元素的下标也是先行后列。下标引用了矩阵的物理拓扑结构；它与矩阵中存储的内容或矩阵的布局方式无关。无论矩阵的主序是什么，下标索引都保持不变。执行以下步骤来实现矩阵乘法：
- en: 'To keep the code for multiplying matrices short, you will need to create a
    helper macro. This macro will assume that there are two matrices, `a` and `b`.
    The macro will take two numbers, the row of `a` and the column of `b`, to dot
    together and the result will bet the dot product of the two. Define the `M4D`
    macro in `mat4.cpp`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使矩阵相乘的代码保持简洁，您需要创建一个辅助宏。该宏将假定有两个矩阵`a`和`b`。该宏将取两个数字，`a`的行和`b`的列，进行点乘，结果将是这两者的点积。在`mat4.cpp`中定义`M4D`宏：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the `M4D` macro in place, implement the matrix multiplication function
    in `mat4.cpp`. Don''t forget to add the function declaration to `mat4.h`. Remember
    that the `(2, 1)` element, for example, should take the dot product of row `2`
    from matrix `a` and column `1` of matrix `b`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中放置了`M4D`宏后，实现矩阵乘法函数。不要忘记将函数声明添加到`mat4.h`中。记住，例如`(2, 1)`元素应该取矩阵`a`的第2行和矩阵`b`的第1列进行点乘：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The most important property of matrix multiplication is that it combines the
    transformation encoded in both matrices into a single matrix. This is useful because
    you can pre-multiply certain matrices to perform fewer multiplications per frame.
    Next, you will learn about how matrices can apply their transformation data to
    vectors and points.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵相乘最重要的特性是将编码在两个矩阵中的变换合并为一个单独的矩阵。这很有用，因为您可以预先乘以某些矩阵，以执行更少的每帧乘法。接下来，您将了解矩阵如何将其变换数据应用于向量和点。
- en: Transforming vectors and points
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换向量和点
- en: Transforming points and vectors is done in the same way as multiplying matrices.
    In fact, the vector being transformed can be thought of as a matrix with 4 columns
    and 1 row. This means transforming vectors is a matter of multiplying a 4 x 4
    and a 4 x 1 matrix together.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点和向量的变换方式与矩阵相乘的方式相同。实际上，被变换的向量可以被视为具有4列1行的矩阵。这意味着变换向量就是将一个4 x 4矩阵和一个4 x 1矩阵相乘的问题。
- en: 'When a matrix transforms a vector, it affects both the orientation and scale
    of the vector. When a matrix transforms a point, it just translates the point
    in space. So, what''s the difference between vectors and points? The *w* component
    of a vector is *0* and the *W* component of a point is *1*. The following steps
    will guide you through implementing matrix-vector multiplication:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩阵变换向量时，它会影响向量的方向和大小。当矩阵变换点时，它只是在空间中平移点。那么，向量和点之间有什么区别呢？向量的*w*分量为*0*，点的*W*分量为*1*。以下步骤将指导您实现矩阵-向量乘法：
- en: 'To make the matrix-vector multiplication a little easier to read, you will
    need to once again create a macro. This macro will take the row of a matrix and
    perform a dot product of that row against the provided column vector. Implement
    the `M4VD` macro in `mat4.cpp`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使矩阵-向量乘法更易于阅读，您需要再次创建一个宏。该宏将取矩阵的行并对该行与提供的列向量进行点积。在`mat4.cpp`中实现`M4VD`宏：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `M4V4D` macro in place, implement the matrix-vector multiplication
    function in `mat4.cpp`. Don''t forget to add the function definition to `mat4.h`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中放置了`M4V4D`宏后，实现矩阵-向量乘法函数。不要忘记将函数定义添加到`mat4.h`中：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of the data in this book will be stored as three-component vectors, not
    four. There is no need to create a new four-component vector every time one needs
    to be transformed by a matrix; instead, you will create a specialized function
    for just this occasion.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书中的大部分数据将被存储为三分量向量，而不是四分量。每次需要通过矩阵进行变换时，都无需创建一个新的四分量向量；相反，您将为此创建一个专门的函数。
- en: 'Define a new function in `mat4.cpp`: `transformVector`. Don''t forget to add
    the function declaration to `mat4.h`. This function will take `vec3` and transform
    it using the provided matrix, assuming the vector represents the direction and
    magnitude:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中定义一个新函数：`transformVector`。不要忘记将函数声明添加到`mat4.h`中。该函数将使用提供的矩阵对`vec3`进行变换，假设该向量表示方向和大小：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, define the `transformPoint` function in `mat4.cpp`. It should multiply
    the vector and the matrix, assuming that the W component of the vector is 1:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`mat4.cpp`中定义`transformPoint`函数。它应该将向量和矩阵相乘，假设向量的W分量为1：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Define an overload for `transformPoint` that takes an additional *W* component.
    The *W* component is a reference—it is a read-write. After the function is executed,
    the *w* component holds the value for *W*, if the input vector had been `vec4`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`transformPoint`定义一个重载，它带有额外的*W*分量。*W*分量是一个引用——它是可读写的。函数执行后，*w*分量将保存*W*的值，如果输入向量是`vec4`的话：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Throughout the rest of this book, most data is stored in `vec3` structures.
    This means `transformVector` and `transformPoint` will be used, rather than the
    overloaded multiplication operator. This should help reduce ambiguity as to what
    the data being transformed is. Next, you will learn how to invert a matrix.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，大多数数据都存储在`vec3`结构中。这意味着将使用`transformVector`和`transformPoint`，而不是重载的乘法运算符。这应有助于减少对被转换数据的歧义。接下来，您将学习如何求矩阵的逆。
- en: Inverting a matrix
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 求逆矩阵
- en: Multiplying a matrix by its inverse will always result in the identity matrix.
    An inverted matrix has the opposite mapping of the non-inverted matrix. Not all
    matrices have an inverse. Only matrices with a non-zero determinant can be inverted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵乘以其逆矩阵总是会得到单位矩阵。逆矩阵具有非逆矩阵的相反映射。并非所有矩阵都有逆矩阵。只有行列式非零的矩阵才能被求逆。
- en: Inverting matrices is an important operation; the view matrix that is used to
    transform three-dimensional objects to be displayed on-screen is the inverse of
    the camera's position and rotation. Another place where inverted matrices become
    important is skinning, which will be covered in [*Chapter 10*](B16191_10_Final_JC_ePub.xhtml#_idTextAnchor167)*,
    Mesh Skinning*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 求逆矩阵是一个重要的操作；用于将三维对象转换为屏幕上显示的视图矩阵是相机位置和旋转的逆矩阵。另一个逆矩阵变得重要的地方是蒙皮，这将在[*第10章*](B16191_10_Final_JC_ePub.xhtml#_idTextAnchor167)*，网格蒙皮*中介绍。
- en: Finding the inverse of a matrix is rather complicated as it needs other support
    functions (such as transpose and adjugate). In this section, you will build these
    support functions first and then build the inverse function after they have all
    been built. So firstly, we need to transpose the matrix.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 找到矩阵的逆矩阵相当复杂，因为它需要其他支持函数（如转置和伴随矩阵）。在本节中，您将首先构建这些支持函数，然后在它们都构建完成后构建逆函数。因此，首先需要转置矩阵。
- en: Transpose
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转置
- en: 'To transpose a matrix, flip every element of the matrix across its main diagonal.
    For example, the *2, 1* element would become the *1, 2* element. Elements where
    both subscripts are the same, such as *1, 1*, will remain the same:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要转置矩阵，需要沿着其主对角线翻转矩阵的每个元素。例如，*2, 1*元素将变为*1, 2*元素。两个下标都相同的元素，如*1, 1*，将保持不变：
- en: 'Implement the `transpose` function in `mat4.cpp`. Don''t forget to add the
    function declaration to `mat4.h`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中实现`transpose`函数。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `transposed` function in `mat4.cpp`. The `transposed` function modifies
    a matrix that is passed into it. Don''t forget to add the function declaration
    to `mat4.h`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中创建一个`transposed`函数。`transposed`函数修改传入的矩阵。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Transposing a matrix is useful if you need to convert a matrix from row-major
    to column-major or the other way around. In the next section, you will learn how
    to calculate the determinant of a square matrix.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将矩阵从行优先顺序转换为列优先顺序，或者反之，则转置矩阵是有用的。在下一节中，您将学习如何计算方阵的行列式。
- en: Determinant and minors of lower-order matrices
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行列式和低阶矩阵的小数
- en: To find the determinant of a 4 x 4 matrix, it's important to first understand
    what the determinant and minor of lower-order matrices are. The determinant function
    is recursive; to find the determinant of a 4 x 4 matrix, we need to find the determinants
    of several 3 x 3 and 2 x 2 matrices as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到4 x 4矩阵的行列式，首先要了解低阶矩阵的行列式和小数是什么。行列式函数是递归的；要找到4 x 4矩阵的行列式，我们需要找到几个3 x 3和2
    x 2矩阵的行列式。
- en: The determinant of a matrix is always a scalar value; only square matrices have
    a determinant. The determinant of a matrix remains the same if the matrix is transposed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的行列式始终是一个标量值；只有方阵有行列式。如果矩阵被转置，其行列式保持不变。
- en: In the following sections, you will learn how to find the determinant of 2 x
    2 matrices, the matrix of minors for any sized matrices, and the cofactor of any
    sized matrices. These methods are the building blocks of Laplace expansion, which
    you will use to find the determinant of any sized matrices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您将学习如何找到2 x 2矩阵的行列式，任意大小矩阵的小数矩阵以及任意大小矩阵的余子式。这些方法是拉普拉斯展开的基本组成部分，您将用它们来找到任意大小矩阵的行列式。
- en: A 2 x 2 determinant
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2 x 2行列式
- en: 'To find the determinant of a 2 x 2 matrix, subtract the product of the diagonal
    elements. The following diagram demonstrates this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到2 x 2矩阵的行列式，需要减去对角线元素的乘积。以下图示了这一点：
- en: '![Figure 3.5: A 2 x 2 matrix and the formula for the determinant'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：2 x 2矩阵和行列式的公式'
- en: '](img/Figure_3.5_B16191.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B16191.jpg)'
- en: 'Figure 3.5: A 2 x 2 matrix and the formula for the determinant'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：2 x 2矩阵和行列式的公式
- en: Minor
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小数
- en: Every element in a matrix has a minor. The minor of an element is the determinant
    of a smaller matrix that eliminates the row and column of the element. For example,
    consider a 3 x 3 matrix—what is the minor of element *2, 1*?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵中的每个元素都有一个小数。元素的小数是消除该元素的行和列后得到的较小矩阵的行列式。例如，考虑一个3 x 3矩阵——元素*2, 1*的小数是什么？
- en: 'First, eliminate row 2 and column 1 from the matrix. This will result in a
    smaller 2 x 2 matrix. The determinant of this 2 x 2 matrix is the minor of element
    *2, 1*. The following diagram demonstrates this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从矩阵中消除第2行和第1列。这将导致一个较小的2 x 2矩阵。这个2 x 2矩阵的行列式就是元素*2, 1*的小数。以下图示了这一点：
- en: '![Figure 3.6: The minor of element 2, 1 in a 3 x 3 matrix'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6：3 x 3矩阵中元素2, 1的小数'
- en: '](img/Figure_3.6_B16191.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16191.jpg)'
- en: 'Figure 3.6: The minor of element 2, 1 in a 3 x 3 matrix'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：3 x 3矩阵中元素2, 1的小数
- en: This formula works for higher-dimension matrices as well. For example, the minor
    of an element in a 4 x 4 matrix is the determinant of some smaller, 3 x 3 matrix.
    A matrix of minors is a matrix where every element is the minor of the corresponding
    element from the input matrix.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式也适用于更高维度的矩阵。例如，4x4矩阵中一个元素的余子式是一些较小的3x3矩阵的行列式。余子式矩阵是一个矩阵，其中每个元素都是输入矩阵对应元素的余子式。
- en: Cofactor
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 余子式
- en: 'To find the cofactor of a matrix, first, calculate the matrix of minors. After
    the matrix of minors is known, multiply every element, *(i, j)*, in the matrix
    by *-1* to the *i + j* power. The value of Add -1(i+j)power forms a convenient
    checkerboard pattern with *+* always being at the top left:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到矩阵的余子式，首先计算余子式矩阵。得到余子式矩阵后，将矩阵中的每个元素*(i, j)*乘以*-1*的*i+j*次幂。加-1(i+j)power的值形成一个方便的棋盘格图案，其中*+*始终位于左上角：
- en: '![Figure 3.7: A checkerboard pattern of -1 to the i + j power'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7：-1到i+j次幂的棋盘格图案'
- en: '](img/Figure_3.7_B16191.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16191.jpg)'
- en: 'Figure 3.7: A checkerboard pattern of -1 to the i + j power'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：-1到i+j次幂的棋盘格图案
- en: The preceding diagram shows the checkerboard pattern that Add -1(i+j) creates.
    Notice how the pattern always starts with a positive element in the top left.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了Add -1(i+j)创建的棋盘格图案。请注意，图案始终从左上角的正元素开始。
- en: Laplace expansion
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉普拉斯展开
- en: 'The determinant (if one exists) of any square matrix can be found through Laplace
    expansion. To perform this, first find the cofactor matrix. Next, multiply every
    element in the first row of the original matrix by the corresponding element in
    the first row of the cofactor matrix. The determinant is the sum of these multiplications:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方阵的行列式（如果存在）都可以通过拉普拉斯展开来找到。要执行此操作，首先找到余子式矩阵。接下来，将原始矩阵的第一行中的每个元素乘以余子式矩阵中相应的第一行的元素。行列式是这些乘积的总和：
- en: '![](img/Formula_03_001.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_03_001.jpg)'
- en: Adjugate
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伴随矩阵
- en: The final operation before you can invert a matrix is to find the adjugate of
    a matrix. The adjugate of a matrix is the transpose of the cofactor matrix. Implementing
    the adjugate is simple since you already know how to find the cofactor of a matrix
    and how to transpose a matrix.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以反转矩阵之前的最后一个操作是找到矩阵的伴随矩阵。矩阵的伴随矩阵是余子式矩阵的转置。实现伴随矩阵很简单，因为您已经知道如何找到矩阵的余子式以及如何对矩阵进行转置。
- en: Inverse
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆
- en: To find the inverse of a matrix, divide the adjugate of the matrix by its determinant.
    Since the scalar matrix division is not defined, you will need to multiply the
    adjugate by the reciprocal of the determinant.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到矩阵的逆，需要将矩阵的伴随矩阵除以其行列式。由于标量矩阵除法未定义，因此需要将伴随矩阵乘以行列式的倒数。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In this chapter, you will build a matrix multiplication function that uses macros
    to avoid the need for lower-order matrices. The `Chapter03/Sample01` sample in
    the downloadable materials for this book provides an implementation that utilizes
    lower-order matrices and is easier to work through with a debugger.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将构建一个矩阵乘法函数，该函数使用宏来避免对低阶矩阵的需求。本书的可下载材料中的`Chapter03/Sample01`示例提供了一个实现，该实现利用了低阶矩阵，并且更容易通过调试器进行调试。
- en: 'To implement a matrix inverse function, you will first need to be able to find
    the determinant and adjugate of a 4 x 4 matrix. Both functions rely on being able
    to find the minor of an element in the matrix:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现矩阵的逆函数，首先需要能够找到4x4矩阵的行列式和伴随矩阵。这两个函数都依赖于能够找到矩阵中元素的余子式：
- en: 'Create a new macro in `mat4.cpp`. This macro will find the minor of one element
    in the matrix, given an array of floats, and three rows and three columns to cut
    from the matrix:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中创建一个新的宏。该宏将找到矩阵中一个元素的余子式，给定一个浮点数数组，以及从矩阵中切割的三行和三列：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the `M4_3X3MINOR` macro defined, implement the `determinant` function
    in `mat4.cpp`. Since the determinant will multiply each element by the cofactor,
    some of the values need to be negated. Don''t forget to add the function declaration
    to `mat4.h`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用定义的`M4_3X3MINOR`宏，在`mat4.cpp`中实现`determinant`函数。由于行列式将每个元素乘以余子式，因此需要对一些值进行取反。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, implement the `adjugate` function in `mat4.cpp`. Don''t forget to add
    the function declaration to `mat4.h`. Use the `M4_3X3MINOR` macro to find the
    matrix of minors, then negate the appropriate elements to create the cofactor
    matrix. Finally, return the transpose of the cofactor matrix:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`mat4.cpp`中实现`adjugate`函数。不要忘记将函数声明添加到`mat4.h`中。使用`M4_3X3MINOR`宏找到余子式矩阵，然后对适当的元素取反以创建余子式矩阵。最后，返回余子式矩阵的转置：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that the `determinant` and `adjugate` functions are finished, the implementation
    of the `inverse` function for a 4 x 4 matrix should be straightforward. Implement
    the `inverse` function in `mat4.cpp`. Don''t forget to add the function declaration
    to `mat4.h`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`determinant`和`adjugate`函数已经完成，实现4x4矩阵的`inverse`函数应该很简单。在`mat4.cpp`中实现`inverse`函数。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `inverse` function takes a constant matrix reference and returns a new
    matrix that is the inverse of the provided matrix. Implement an `invert` convenience
    function in `mat4.cpp`. This convenience function will invert the matrix inline,
    modifying the argument. Don''t forget to add the function declaration to `mat4.h`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`inverse`函数接受一个常量矩阵引用，并返回一个新的矩阵，该矩阵是提供矩阵的逆矩阵。在`mat4.cpp`中实现一个`invert`便利函数。这个便利函数将内联地反转矩阵，修改参数。不要忘记将函数声明添加到`mat4.h`中：'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inverting matrices is a relatively expensive function. Matrices that only encode
    the position and rotation can be inverted faster because the inverse of a 3 x
    3 rotation matrix is the same as its transpose.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的求逆是一个相对昂贵的函数。只编码位置和旋转的矩阵可以更快地求逆，因为3x3旋转矩阵的逆矩阵与其转置矩阵相同。
- en: You will learn how to implement this fast inverse in the next section when implementing
    the `lookAt` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`lookAt`函数时，您将学习如何实现这个快速的逆函数。
- en: Creating camera matrices
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建相机矩阵
- en: Matrices are also used for camera transformations, including perspective transforms.
    A perspective transform maps a frustum to NDC space. NDC space typically has a
    range of -1 to +1 on all axes. Unlike world/eye coordinates, NDC space is left-handed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵也用于相机变换，包括透视变换。透视变换将视锥体映射到NDC空间。NDC空间通常在所有轴上的范围为-1到+1。与世界/眼坐标不同，NDC空间是左手坐标系。
- en: In this section, you will learn how to create camera transformation matrices.
    The first camera matrix is a frustum, which looks like a pyramid with the tip
    cut off. A frustum represents everything that is visible to the camera. You will
    also learn how to create different projections and how to implement a "look at"
    function that lets you easily create a view matrix.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何创建相机变换矩阵。第一个相机矩阵是一个视锥体，看起来像一个顶部被切掉的金字塔。视锥体代表相机可见的一切。您还将学习如何创建不同的投影，并实现一个“look
    at”函数，让您轻松创建视图矩阵。
- en: Frustum
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视锥体
- en: 'Visually, a frustum looks like a pyramid with the tip cut off. A frustum has
    six sides; it represents the space that a camera can see. Create the `frustum`
    function in `mat4.cpp`. This function takes left, right, bottom, top, near, and
    far values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉上，视锥体看起来像一个顶部被切掉的金字塔。视锥体有六个面；它代表相机可以看到的空间。在`mat4.cpp`中创建`frustum`函数。该函数接受left、right、bottom、top、near和far值：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The details of deriving the frustum matrix are beyond the scope of this book.
    For more information on how to derive the function, check out [http://www.songho.ca/opengl/gl_projectionmatrix.html](http://www.songho.ca/opengl/gl_projectionmatrix.html).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 推导视锥体矩阵的细节超出了本书的范围。有关如何推导该函数的更多信息，请查看[http://www.songho.ca/opengl/gl_projectionmatrix.html](http://www.songho.ca/opengl/gl_projectionmatrix.html)。
- en: The `frustum` function can be used to construct a view frustum, but the function
    parameters are not intuitive. In the next section, you will learn how to create
    a view frustum from more intuitive arguments.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`frustum`函数可用于构建视锥体，但函数参数不直观。在下一节中，您将学习如何从更直观的参数创建视锥体。'
- en: Perspective
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透视
- en: A perspective matrix is built from a field of view (typically in degrees), an
    aspect ratio, and near and far distances. It serves as an easy way to create a
    view frustum.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 透视矩阵是由视野（通常以度为单位）、宽高比和近远距离构建的。它是创建视锥体的一种简单方式。
- en: 'Implement the `perspective` function in `mat4.cpp`. Don''t forget to add the
    function declaration to `mat4.h`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中实现`perspective`函数。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `perspective` function will be used in almost all visual graphics demonstrations
    throughout the rest of this book. It's a really convenient way of creating a view
    frustum.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`perspective`函数将在本书其余部分的几乎所有视觉图形演示中使用。这是创建视锥体的一种非常方便的方式。'
- en: Orthographic
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正交
- en: An orthographic projection has no perspective to it. An orthographic projection
    maps linearly to NDC space. Orthographic projections are often used for two-dimensional
    games. It's often used to achieve an isometric perspective.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正交投影没有透视效果。正交投影线性映射到NDC空间。正交投影通常用于二维游戏。它经常用于实现等距透视。
- en: 'Implement the `ortho` function in `mat4.cpp`. Don''t forget to add the function
    declaration to `mat4.h`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中实现`ortho`函数。不要忘记将函数声明添加到`mat4.h`中：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Orthographic view projections are generally useful for displaying UI or other
    two-dimensional elements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正交视图投影通常用于显示UI或其他二维元素。
- en: Look at
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察
- en: The view matrix is the inverse of the camera's transformation (the position,
    rotation, and scale of the camera). Instead of having to create the camera's transform
    matrix and then invert it, you will be implementing a `lookAt` function that generates
    this matrix directly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 视图矩阵是相机变换的逆矩阵（相机的位置、旋转和缩放）。您将实现一个`lookAt`函数，直接生成该矩阵，而不是创建相机的变换矩阵然后求逆。
- en: A `lookAt` function typically takes a `position`, the `target point` at which
    the camera is looking and a reference `up direction`. The rest of the work is
    finding the inverted basis vectors and figuring out where the position is.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookAt`函数通常接受一个`位置`、相机所看的`目标点`和一个参考`上方向`。其余的工作是找到倒置的基向量，并确定位置在哪里。'
- en: Since the basis vectors are orthonormal, their inverse is the same as their
    transpose. The position can be calculated by negating the dot product of the position
    column vector with the inverted basis vectors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基向量是正交的，它们的逆矩阵与它们的转置矩阵相同。位置可以通过将位置列向量与倒置的基向量的点积取反来计算。
- en: 'Implement the `lookAt` function in `mat4.cpp`. Don''t forget to add the function
    declaration to `mat4.h`. Remember, the view matrix maps the game world forward
    to the positive *Z* axis:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mat4.cpp`中实现`lookAt`函数。不要忘记将函数声明添加到`mat4.h`中。记住，视图矩阵将游戏世界映射到正*Z*轴：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `lookAt` function is the most convenient way of constructing a view matrix.
    All of the code samples throughout the rest of this book will use the `lookAt`
    function to set up a view matrix.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookAt`函数是构建视图矩阵最方便的方法。本书其余部分的所有代码示例都将使用`lookAt`函数来设置视图矩阵。'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the math required to work with four-dimensional
    square matrices and implemented a reusable matrix library. Matrices are commonly
    used to encode transformation information; they are used at almost every step
    of the graphics pipeline to display models on screen.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了处理四维方阵所需的数学知识，并实现了一个可重用的矩阵库。矩阵通常用于编码变换信息；它们几乎在图形管线的每一步都被用来在屏幕上显示模型。
- en: In the next chapter, you will learn about encoding rotation data using quaternions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用四元数编码旋转数据。
