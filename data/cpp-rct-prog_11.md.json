["```cpp\n//---------- DirReact.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \n#include <map> \n#include <algorithm> \n#include <string> \n#include <vector> \n#include <windows.h> // This is omitted in POSIX version \n#include <functional> \n#include <thread> \n#include <future> \nusing namespace std; \n//////////////////////////////////// \n//-------------- Forward Declarations \n//-------------- Model Folder/File \nclass FileNode; \nclass DirectoryNode; \n//////////////////////////////// \n//------------- The Visitor Interface \nclass IFileFolderVisitor; \n```", "```cpp\n///////////////////////////////// \n//------ a Type to store FileInformation \nstruct FileInformation{ \n   string name; \n   long size; \n   FileInformation( string pname,long psize ) \n   { name = pname;size = psize; } \n}; \n////////////////////////////// \n//-------------- Base class for File/Folder data structure \nclass EntryNode{ \n    protected: \n      string  name; \n      int isdir; \n      long size; \n    public: \n      virtual bool Isdir() = 0; \n      virtual long getSize() = 0; \n      virtual void Accept(IFileFolderVisitor& ivis)=0; \n      virtual ~EntryNode() {} \n};\n```", "```cpp\n//-------------The Visitor Interface \nclass IFileFolderVisitor{ \n   public: \n    virtual void Visit(FileNode& fn )=0; \n    virtual void Visit(DirectoryNode& dn )=0; \n}; \n```", "```cpp\n// The Node which represents Files \nclass FileNode : public EntryNode { \n   public:  \n   FileNode(string pname, long psize) {  isdir = 0; name = pname; size = psize;} \n   ~FileNode() {cout << \"....Destructor FileNode ....\" << name << endl; } \n   virtual bool  Isdir() { return isdir == 1; } \n   string getname() { return name; }\n   virtual long getSize() {return size; } \n   //------------- accept method \n   //------------- dispatches call to correct node in\n   //------------- the Composite\n   virtual void Accept( IFileFolderVisitor& ivis ){ivis.Visit(*this);} \n}; \n```", "```cpp\n// Node which represents Directory \nclass DirectoryNode : public EntryNode { \n  list<unique_ptr<EntryNode>> files;   \npublic: \n  DirectoryNode(string pname)  \n  { files.clear(); isdir = 1; name = pname;} \n  ~DirectoryNode() {files.clear();} \n  list<unique_ptr<EntryNode>>& GetAllFiles() {return files;} \n  bool AddFile( string pname , long size) { \n       files.push_back(unique_ptr<EntryNode> (new FileNode(pname,size))); \n       return true; \n  } \n  bool AddDirectory( DirectoryNode *dn ) { \n        files.push_back(unique_ptr<EntryNode>(dn)); \n        return true; \n  } \n  bool Isdir() { return isdir == 1; } \n  string  getname() { return name; } \n  void   setname(string pname) { name = pname; } \n  long getSize() {return size; } \n  //\n  //--------------------- accept method\n  void Accept( IFileFolderVisitor& ivis ){ivis.Visit(*this); } \n}; \n```", "```cpp\n//------Directory Helper Has to be written for Each OS \nclass DirHelper { \n public: \n    static  DirectoryNode  *SearchDirectory(\n            const std::string& refcstrRootDirectory){ \n           //--------------- Do some OS specific stuff to retrieve \n           //--------------- File/Folder hierarchy from the root folder \n           return DirNode; \n}}; \n```", "```cpp\n///////////////////////////////////// \n//----- A Visitor Interface that prints \n//----- The contents of a Folder \nclass PrintFolderVisitor : public IFileFolderVisitor \n{ \n  public: \n    void Visit(FileNode& fn ) {cout << fn.getname() << endl; } \n    void Visit(DirectoryNode& dn ) { \n      cout << \"In a directory \" << dn.getname() << endl; \n      list<unique_ptr<EntryNode>>& ls = dn.GetAllFiles(); \n      for ( auto& itr : ls ) { itr.get()->Accept(*this);} \n    } \n}; \n```", "```cpp\n//--------------- has used raw pointers \n//--------------- in a production implementation, use smart pointer\nvoid TestVisitor( string directory ){ \n  // Search files including subdirectories \n  DirectoryNode *dirs = DirHelper::SearchDirectory(directory); \n  if ( dirs == 0 ) {return;} \n  PrintFolderVisitor *fs = new PrintFolderVisitor (); \n  dirs->Accept(*fs); delete fs; delete dirs; \n} \n```", "```cpp\nint main(int argc, char *argv[]) {  TestVisitor(\"D:\\\\Java\"); }\n```", "```cpp\n// Flatten the File/Folders into a linear list \nclass FlattenVisitor : public IFileFolderVisitor{ \n    list <FileInformation> files; \n    string CurrDir; \n public: \n    FlattenVisitor() { CurrDir = \"\";} \n    ~FlattenVisitor() { files.clear();} \n    list<FileInformation> GetAllFiles() { return files; } \n    void Visit(FileNode& fn ) { \n       files.push_back( FileInformation{ \n                  CurrDir +\"\\\" + fn.getname(),fn.getSize())); \n    } \n    void Visit(DirectoryNode& dn ) { \n        CurrDir = dn.getname(); \n        files.push_back( FileInformation( CurrDir, 0 )); \n        list<unique_ptr<EntryNode>>& ls = dn.GetAllFiles(); \n        for ( auto& itr : ls ) { itr.get()->Accept(*this);} \n    } \n}; \n```", "```cpp\nlist<FileInformation> GetAllFiles(string dirname ){ \n   list<FileInformation> ret_val; \n   // Search files including subdirectories \n   DirectoryNode *dirs = DirHelper::SearchDirectory(dirname); \n   if ( dirs == 0 ) {return ret_val;} \n   //--  We have used Raw pointers here...\n   //--- In Modern C++, one can use smart pointer here\n   //  unique_ptr<FlattenVisitor> fs(new FlattenVisitor());\n   //  We can avoid delete fs\n   FlattenVisitor *fs = new FlattenVisitor(); \n   dirs->Accept(*fs); \n   ret_val = fs->GetAllFiles(); \n   //--------- use of Raw pointer \n   delete fs; delete dirs; \n   return ret_val; \n} \nint main(int argc, char *argv[]) { \n  list<FileInformation> rs = GetAllFiles(\"D:\\JAVA\"); \n  for( auto& as : rs ) \n    cout << as.name << endl; \n} \n```", "```cpp\n////////////////////////////// \n// A Toy implementation of Active  \n// Object Pattern... Will be explained as a separate pattern\ntemplate <class T> \nstruct ActiveObject { \n    rxcpp::subjects::subject<T> subj; \n    // fire-and-forget \n    void FireNForget(T & item){subj.get_subscriber().on_next(item);} \n    rxcpp::observable<T> GetObservable()  \n    { return subj.get_observable(); } \n    ActiveObject(){}  \n    ~ActiveObject() {} \n}; \n/////////////////////// \n// The class uses a FireNForget mechanism to  \n// push data to the Data/Event sink \n// \nclass DirectoryEmitter { \n      string rootdir; \n      //-------------- Active Object ( a Pattern in it's own right ) \n      ActiveObject<FileInformation> act; // more on this below  \n  public: \n      DirectoryEmitter(string s )   { \n         rootdir = s; \n         //----- Subscribe  \n         act.GetObservable().subscribe([] ( FileInformation item ) { \n            cout << item.name << \":\" << item.size << endl; \n         }); \n      } \n      bool Trigger() { \n           std::packaged_task<int()> task([&]() {  EmitDirEntry(); return 1; }); \n           std::future<int> result = task.get_future(); \n           task(); \n           //------------ Comment the below lineto return immediately \n           double dresult = result.get(); \n           return true; \n      } \n      //----- Iterate over the list of files  \n      //----- uses ActiveObject Pattern to do FirenForget \n      bool EmitDirEntry() { \n           list<FileInformation> rs = GetAllFiles(rootdir); \n           for( auto& a : rs ) { act.FireNForget(a); } \n           return false; \n      } \n}; \nint main(int argc, char *argv[]) { \n  DirectoryEmitter emitter(\"D:\\\\JAVA\"); \n  emitter.Trigger(); return 0; \n} \n```", "```cpp\n//------------------ CellPattern.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \n#include <map> \n#include <algorithm> \nusing namespace std; \nclass Cell \n{ \n  private: \n    std::string name; \n    std::map<std::string,Cell *> parents; \n    rxcpp::subjects::behavior<double> *behsubject;   \n  public: \n    string get_name() { return name;} \n    void SetValue(double v )  \n    { behsubject->get_subscriber().on_next(v);} \n    double GetValue()  \n    { return behsubject->get_value(); } \n    rxcpp::observable<double> GetObservable()  \n    { return behsubject->get_observable(); } \n    Cell(std::string pname) { \n       name = pname; \n       behsubject = new rxcpp::subjects::behavior<double>(0); \n    } \n    ~Cell() {delete behsubject; parents.clear();} \n    bool GetCellNames( string& a , string& b ) \n    { \n         if ( parents.size() !=2 ) { return false; } \n         int i = 0; \n         for(auto p  : parents ) { \n            ( i == 0 )? a = p.first : b = p.first; \n            i++;      \n         } \n         return true; \n    } \n    ///////////////////////////// \n    // We will just add two parent cells... \n    // in real life, we need to implement an  \n    // expression evaluator \n    bool Recalculate() { \n        string as , bs ; \n        if (!GetCellNames(as,bs) ) { return false; } \n        auto a = parents[as]; \n        auto b = parents[bs]; \n        SetValue( a->GetValue() + b->GetValue() ); \n        return true; \n    } \n    bool Attach( Cell& s ) { \n       if ( parents.size() >= 2 ) { return false; } \n       parents.insert(pair<std::string,Cell *>(s.get_name(),&s)); \n       s.GetObservable().subscribe( [=] (double a ) { Recalculate() ;}); \n       return true; \n    } \n    bool Detach( Cell& s ) { //--- Not Implemented  \n    } }; \n```", "```cpp\nint main(int argc, char *argv[]) {     \n    Cell a(\"a\");  \n    Cell b(\"b\"); \n    Cell c(\"c\"); \n    Cell d(\"d\"); \n    Cell e(\"e\"); \n    //-------- attach a to c \n    //-------- attach b to c \n    //-------- c is a + b  \n    c.Attach(a); \n    c.Attach(b); \n    //---------- attach c to e \n    //---------- attach d to e \n    //---------- e is c + d or e is a + b + d; \n    e.Attach(c); \n    e.Attach(d); \n    a.SetValue(100);  // should print 100 \n    cout << \"Value is \" << c.GetValue() << endl; \n    b.SetValue(200);  // should print 300 \n    cout << \"Value is \" << c.GetValue() << endl; \n    b.SetValue(300);  // should print 400 \n    cout << \"Value is \" << c.GetValue() << endl; \n    d.SetValue(-400); // should be Zero \n    cout << \"Value is \" << e.GetValue() << endl; \n} \n```", "```cpp\n#include <rxcpp/rx.hpp> \n#include <memory> \n#include <map> \n#include <algorithm> \n#include <string> \n#include <vector> \n#include <windows.h> \n#include <functional> \n#include <thread> \n#include <future> \nusing namespace std; \n//------- Active Object Pattern Implementation \ntemplate <class T> \nclass ActiveObject { \n    //----------- Dispatcher Object \n    rxcpp::subjects::subject<T> subj; \n    protected: \n    ActiveObject(){ \n       subj.get_observable().subscribe([=] (T s ) \n       { Execute(s); }); \n    }  \n    virtual void Execute(T s) {} \n    public: \n    // fire-and-forget \n    void FireNForget(T item){ subj.get_subscriber().on_next(item);} \n    rxcpp::observable<T> GetObservable() { return subj.get_observable(); } \n    virtual ~ActiveObject() {} \n}; \n```", "```cpp\nclass ConcreteObject : public ActiveObject<double> { \n    public: \n     ConcreteObject() {} \n     virtual void Execute(double a ) \n     { cout << \"Hello World.....\" << a << endl;} \n}; \nint main(int argc, char *argv[]) { \n  ConcreteObject temp; \n  for( int i=0; i<=10; ++i ) \n      temp.FireNForget(i*i); \n  return 0; \n}\n```", "```cpp\n//----------- ResourceLoan.cpp \n#include <rxcpp/rx.hpp> \nusing namespace std; \n////////////////////////// \n// implementation of Resource Loan  Pattern. The Implementation opens a file \n// and does not pass the file handle to user  defined Lambda. The Ownership remains with \n// the class  \nclass ResourceLoan { \n   FILE *file;  // This is the resource which is being loaned\n   string filename; \n  public: \n     ResourceLoan(string pfile) { \n        filename = pfile; \n        //---------- Create the resource\n        file = fopen(filename.c_str(),\"rb\"); \n     }   \n     //////////////////////////// \n     // Read upto 1024 bytes to a buffer  \n     // return the buffer contents and number of bytes \n     int ReadBuffer( std::function<int(char pbuffer[],int val )> func ) \n     { \n          if (file == nullptr ) { return -1; } \n          char buffer[1024]; \n          int result = fread (buffer,1,1024,file); \n          return func(buffer,result); \n     }  \n     //---------- close the resource \n     ~ResourceLoan() { fclose(file);} \n}; \n//////////////////////////////// \n// A Sample Program to invoke the preceding \n// class \n// \nint main(int argc, char *argv[]) { \n  ResourceLoan res(\"a.bin\"); \n  int nread ; \n  //------------- The conents of the buffer \n  //------------- and size of buffer is stored in val \n  auto rlambda =  [] (char buffer[] , int val ) { \n       cout <<  \"Size \" << val << endl; \n       return val; \n  }; \n  //------- The File Handle is not available to the  \n  //------- User defined Lambda It has been loaned to the \n  //-------- consumer of the class\n  while ((nread = res.ReadBuffer(rlambda)) > 0) {} \n  //---- When the ResourceLoan object goes out of scope \n  //---- File Handle is closed \n  return 0; \n} \n```", "```cpp\n//----------- EventBus.cpp \n#include <rxcpp/rx.hpp> \n#include <memory> \n#include <map> \n#include <algorithm> \nusing namespace std; \n//---------- Event Information \nstruct EVENT_INFO{ \n   int id; \n   int err_code; \n   string description; \n   EVENT_INFO() { id = err_code = 0 ; description =\"default\";} \n   EVENT_INFO(int pid,int perr_code,string pdescription ) \n   { id = pid; err_code = perr_code; description = pdescription; } \n   void Print() { \n      cout << \"id & Error Code\" << id << \":\" << err_code << \":\"; \n      cout << description << endl; \n   } \n}; \n```", "```cpp\n//----------- The following method \n//----------- will be invoked by  \n//----------- Consumers \ntemplate <class T> \nvoid DoSomeThingWithEvent( T ev ) \n{ev.Print();} \n\n//---------- Forward Declarations  \ntemplate <class T> \nclass EventBus; \n//------------- Event Producer \n//------------- Just Inserts event to a Bus \ntemplate <class T> \nclass Producer { \n  string name; \n public: \n   Producer(string pname ) { name = pname;} \n   bool Fire(T ev,EventBus<T> *bev ) { \n         bev->FireEvent(ev); \n         return false; \n   } \n}; \n```", "```cpp\n//------------ Event Consumer \n//------------ Subscribes to a Subject \n//------------ to Retrieve Events \ntemplate <class T> \nclass Consumer { \n  string name; \n  //--------- The subscription member helps us to \n  //--------- Unsubscribe to an Observable  \n  rxcpp::composite_subscription subscription; \npublic: \n  Consumer(string pname) { name = pname;} \n  //--------- Connect a Consumer to a Event Bus \n  bool Connect( EventBus<T> *bus ) { \n      //------ If already subscribed, Unsubscribe! \n      if ( subscription.is_subscribed() ) \n             subscription.unsubscribe(); \n      //------- Create a new Subscription \n      //------- We will call DoSomeThingWithEvent method \n      //------- from Lambda function \n      subscription = rxcpp::composite_subscription(); \n      auto subscriber = rxcpp::make_subscriber<T>( \n        subscription,[=](T value){ \n            DoSomeThingWithEvent<T>(value); \n        },[](){ printf(\"OnCompletedn\");}); \n      //----------- Subscribe! \n      bus->GetObservable().subscribe(subscriber); \n      return true; \n  } \n  //-------- DTOR ....Unsubscribe \n  ~Consumer() { Disconnect(); } \n  bool Disconnect() { \n       if (subscription.is_subscribed() ) \n        subscription.unsubscribe(); \n  } \n}; \n```", "```cpp\n//--- The implementation of the EventBus class \n//--- We have not taken care of Concurrency issues \n//--- as our purpose is to demonstrate the pattern \ntemplate <class T> \nclass EventBus \n{ \n  private: \n    std::string name; \n    //----- Reference to the Subject... \n    //----- Consumers get notification by  \n    //----- Subscribing to the Observable side of the subject \n    rxcpp::subjects::behavior<T> *replaysubject;  \n  public: \n    EventBus<T>() {replaysubject = new rxcpp::subjects::behavior<T>(T());} \n    ~EventBus() {delete replaysubject;} \n    //------ Add a Consumer to the Bus... \n    bool AddConsumer( Consumer<T>& b ) {b.Connect(this);} \n    //------ Fire the Event... \n    bool FireEvent ( T& event ) { \n       replaysubject->get_subscriber().on_next(event); \n       return true; \n    } \n    string get_name() { return name;} \n    rxcpp::observable<T> GetObservable()  \n    { return replaysubject->get_observable(); } \n}; \n```", "```cpp\n///////////////////// \n//The EntryPoint \n// \n// \nint main(int argc, char *argv[]) { \n    //---- Create an instance of the EventBus \n    EventBus<EVENT_INFO> program_bus; \n    //---- Create a Producer and Two Consumers \n    //---- Add Consumers to the EventBus \n    Producer<EVENT_INFO> producer_one(\"first\"); \n    Consumer<EVENT_INFO> consumer_one(\"one\"); \n    Consumer<EVENT_INFO> consumer_two(\"two\"); \n    program_bus.AddConsumer(consumer_one); \n    program_bus.AddConsumer(consumer_two); \n    //---- Fire an Event... \n    EVENT_INFO ev; \n    ev.id = 100; \n    ev.err_code = 0; \n    ev.description = \"Hello World..\"; \n    producer_one.Fire(ev,&program_bus); \n    //---- fire another by creating a second  \n    //---- Producer \n    ev.id = 100; \n    ev.err_code = 10; \n    ev.description = \"Error Happened..\"; \n    Producer<EVENT_INFO> producer_two(\"second\"); \n    producer_two.Fire(ev,&program_bus); \n} \n```"]