- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Data Structures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'In the last chapter, we discussed how to analyze time and memory complexity
    and how to measure performance. In this chapter, we are going to talk about how
    to choose and use data structures from the standard library. To understand why
    certain data structures work very well on the computers of today, we first need
    to cover some basics about computer memory. In this chapter, you will learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何分析时间和内存复杂性以及如何衡量性能。在本章中，我们将讨论如何从标准库中选择和使用数据结构。要理解为什么某些数据结构在今天的计算机上运行得非常好，我们首先需要了解一些关于计算机内存的基础知识。在本章中，您将了解以下内容：
- en: The properties of computer memory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机内存的属性
- en: 'The standard library containers: sequence containers and associative containers'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库容器：序列容器和关联容器
- en: The standard library container adaptors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库容器适配器
- en: Parallel arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行数组
- en: Before we start walking through the containers offered by the standard library
    and some other useful data structures, we will briefly discuss some properties
    of computer memory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始遍历标准库提供的容器和一些其他有用的数据结构之前，我们将简要讨论一些计算机内存的属性。
- en: The properties of computer memory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机内存的属性
- en: C++ treats memory as a sequence of cells. The size of each cell is 1 byte, and
    each cell has an address. Accessing a byte in memory by its address is a constant-time
    operation, *O(1)*, in other words, it's independent of the total number of memory
    cells. On a 32-bit machine, you can theoretically address 2^(32) bytes, that is,
    around 4 GB, which restricts the amount of memory a process is allowed to use
    at once. On a 64-bit machine, you can theoretically address 2^(64) bytes, which
    is so big that there is hardly any risk of running out of addresses.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: C++将内存视为一系列单元。每个单元的大小为1字节，并且每个单元都有一个地址。通过其地址访问内存中的一个字节是一个常量时间操作，*O(1)*，换句话说，它与内存单元的总数无关。在32位机器上，您可以理论上寻址2^(32)字节，即大约4GB，这限制了进程一次允许使用的内存量。在64位机器上，您可以理论上寻址2^(64)字节，这是如此之大，以至于几乎没有任何地址用完的风险。
- en: 'The following figure shows a sequence of memory cells laid out in memory. Each
    cell contains 8 bits. The hexadecimal numbers are the addresses of the memory
    cells:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了内存中排列的一系列内存单元。每个单元包含8位。十六进制数字是内存单元的地址：
- en: '![](img/B15619_04_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_01.png)'
- en: 'Figure 4.1: A sequence of memory cells'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：一系列内存单元
- en: 'Since accessing a byte by its address is an *O(1)* operation, from a programmer''s
    perspective, it''s tempting to believe that each memory cell is equally quick
    to access. This approach to memory is simple and useful in many cases, but when
    choosing data structures for efficient use, you need to take into account the
    memory hierarchy that exists in modern computers. The importance of the memory
    hierarchy has increased, since the time it takes to read and write from the main
    memory has become more expensive when compared to the speed of today''s processors.
    The following figure shows the architecture of a machine with one CPU and four
    cores:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过地址访问一个字节是一个*O(1)*操作，从程序员的角度来看，很容易相信每个内存单元都可以快速访问。这种对内存的处理方式在许多情况下都是简单且有用的，但是在选择数据结构以实现高效使用时，您需要考虑现代计算机中存在的内存层次结构。随着从主存储器读取和写入所需的时间与今天处理器的速度相比变得更加昂贵，内存层次结构的重要性已经增加。以下图显示了具有一个CPU和四个核心的机器的架构：
- en: '![](img/B15619_04_02.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_02.png)'
- en: 'Figure 4.2: An example of a processor with four cores; the boxes labeled L1i,
    L1d, L2, and L3 are memory caches'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：具有四个核心的处理器的示例；标有L1i、L1d、L2和L3的框是内存缓存
- en: 'I''m currently writing this chapter on a MacBook Pro from 2018, which is equipped
    with an Intel Quad-Core i7 CPU. On this processor, each core has its own L1 and
    L2 caches, whereas the L3 cache is shared among all four cores. Running the following
    command from a terminal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前正在使用2018年的MacBook Pro进行撰写本章，它配备了Intel Quad-Core i7 CPU。在这个处理器上，每个核心都有自己的L1和L2缓存，而L3缓存是所有四个核心共享的。从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'gives me, among other things, the following information:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 给我提供了以下信息，除其他外：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reported `hw.memsize` is the total amount of main memory, which is 16 GB
    in this case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的`hw.memsize`是主存储器的总量，本例中为16GB。
- en: The `hw.cachelinesize`, which is reported to be 64 bytes, is the size of the
    cache lines, also known as blocks. When accessing a byte in memory, the machine
    is not only fetching the byte that is asked for; instead, the machine always fetches
    a cache line, which, in this case, is 64 bytes. The various caches between the
    CPU and main memory keep track of 64-byte blocks, instead of individual bytes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`hw.cachelinesize`报告的是64字节，这是缓存行的大小，也称为块。当访问内存中的一个字节时，机器不仅会获取所请求的字节；相反，机器总是获取一个缓存行，在这种情况下是64字节。
    CPU和主存储器之间的各种高速缓存跟踪64字节的块，而不是单个字节。'
- en: The `hw.l1icachesize` is the size of the L1 instruction cache. This is a 32
    KB cache dedicated to storing instructions that have been recently used by the
    CPU. The `hw.l1dcachesize` is also 32 KB and is dedicated to data, as opposed
    to instructions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`hw.l1icachesize`是L1指令缓存的大小。这是一个32KB的缓存，专门用于存储CPU最近使用的指令。 `hw.l1dcachesize`也是32KB，专门用于数据，而不是指令。'
- en: Lastly, we can read the size of the L2 cache and the L3 cache, which is 256
    KB and 8 MB, respectively. An important observation is that the caches are tiny
    compared to the amount of main memory available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以读取L2缓存和L3缓存的大小，分别为256KB和8MB。一个重要的观察是，与可用的主存储器量相比，缓存非常小。
- en: 'Without presenting any detailed facts about the actual number of cycles required
    to access data from each layer in the cache hierarchy, a very rough guideline
    is that there are orders of magnitude differences of latency between two adjacent
    layers (for example, L1 and L2). The following table shows an extract from the
    latency numbers presented in an article by Peter Norvig called *Teach yourself
    programming in ten years, 2001* ([http://norvig.com/21-days.html](http://norvig.com/21-days.html)).
    The full table is usually referred to as *Latency numbers every programmer should
    know* and is credited to Jeff Dean:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供关于从缓存层中的每一层访问数据所需的实际周期数的详细事实，一个非常粗略的指导原则是，相邻层之间的延迟存在数量级的差异（例如，L1和L2）。下表显示了Peter
    Norvig在一篇名为《在十年内自学编程》（2001）的文章中提出的延迟数字的摘录（[http://norvig.com/21-days.html](http://norvig.com/21-days.html)）。完整的表通常被称为《每个程序员都应该知道的延迟数字》，并且由Jeff
    Dean创作：
- en: '| L1 cache reference | 0.5 ns |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| L1缓存引用 | 0.5 ns |'
- en: '| L2 cache reference | 7 ns |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| L2缓存引用 | 7 ns |'
- en: '| Main memory reference | 100 ns |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 主存储器引用 | 100 ns |'
- en: Structuring the data in such a way that the caches can be fully utilized can
    have a dramatic effect on performance. Accessing data that has recently been used
    and, therefore, potentially already resides in the cache will make your program
    faster. This is known as **temporal locality**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以这样的方式结构化数据，使得缓存可以被充分利用，对性能有着显著的影响。访问最近使用过的数据，因此可能已经存在于缓存中，将使你的程序更快。这被称为**时间局部性**。
- en: Also, accessing data located near some other data you are using will increase
    the likelihood that the data you need is already in a cache line that was fetched
    from the main memory earlier. This is known as **spatial locality**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，访问位于你正在使用的其他数据附近的数据，将增加你需要的数据已经在先前从主存储器中获取的缓存行中的可能性。这被称为**空间局部性**。
- en: 'Constantly wiping out the cache lines in inner loops might result in very bad
    performance. This is sometimes called **cache thrashing**. Let''s look at an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部循环中不断清除缓存行可能导致非常糟糕的性能。这有时被称为**缓存抖动**。让我们看一个例子：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This version takes about 40 ms to run on my computer. However, by only changing
    the line in the inner loop to the following, the time it takes to complete the
    function increases from 40 ms to over 800 ms:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本在我的电脑上运行大约需要40毫秒。然而，只需将内部循环中的一行更改为以下内容，完成函数所需的时间就会从40毫秒增加到800毫秒以上：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the first example, when using `matrix[i][j]`, most of the time we will access
    memory that is already in the L1 cache, whereas, in the modified version using
    `matrix[j][i]`, every access will generate an L1 cache miss. A few images might
    help you to understand what''s going on. Instead of drawing the full 32768 x 32768
    matrix, a tiny 3 x 3 matrix, as shown here, will serve as an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，使用`matrix[i][j]`时，大多数情况下我们将访问已经在L1缓存中的内存，而在使用`matrix[j][i]`的修改版本中，每次访问都会生成一个L1缓存未命中。一些图像可能会帮助你理解发生了什么。与其绘制完整的32768
    x 32768矩阵，不如用这里显示的一个小3 x 3矩阵作为例子：
- en: '![](img/B15619_04_03.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_03.png)'
- en: 'Figure 4.3: A 3x3 matrix'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：一个3x3矩阵
- en: 'Even if this might be our mental image of how a matrix resides in memory, there
    is no such thing as 2-dimensional memory. Instead, when this matrix is laid out
    in a 1-dimensional memory space, it looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这可能是我们对矩阵在内存中的想象，实际上并不存在二维内存。相反，当这个矩阵在一维内存空间中排列时，它看起来是这样的：
- en: '![](img/B15619_04_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_04.png)'
- en: 'Figure 4.4: A 2-dimensional matrix in a 1-dimensional memory space'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：一个二维矩阵在一维内存空间中
- en: 'That is, it''s a contiguous array of elements laid out row by row. In the fast
    version of our algorithm, the numbers are accessed sequentially in the same order
    in which they are contiguously laid out in memory, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它是一个按行排列的连续元素数组。在我们算法的快速版本中，数字按照它们在内存中连续排列的顺序顺序访问，就像这样：
- en: '![](img/B15619_04_05.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_05.png)'
- en: 'Figure 4.5: Fast sequential stride-1 accesses'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：快速顺序步幅-1访问
- en: 'Whereas in the slow version of the algorithm, the elements are accessed in
    a completely different pattern. Accessing the first four elements using the slow
    version would now look like this instead:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 而在算法的慢速版本中，元素以完全不同的模式访问。使用慢速版本访问前四个元素现在看起来是这样的：
- en: '![](img/B15619_04_06.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_06.png)'
- en: 'Figure 4.6: Slow access using a larger stride'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：使用较大步幅的慢速访问
- en: Accessing data in this way is substantially slower due to poor spatial locality.
    Modern processors are usually also equipped with a **prefetcher**, which can automatically
    recognize memory access patterns and try to prefetch data from memory into the
    caches that are likely to be accessed in the near future. Prefetchers tend to
    perform best for smaller strides. You can read a lot more about this in the excellent
    book, *Computer Systems, A Programmer's Perspective*, by Randal E. Bryant and
    David R. O'Hallaron.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式访问数据由于空间局部性差而明显较慢。现代处理器通常也配备有**预取器**，它可以自动识别内存访问模式，并尝试从内存中预取可能在不久的将来被访问的缓存。预取器对于较小的步幅表现最佳。你可以在Randal
    E. Bryant和David R. O'Hallaron的优秀著作《计算机系统，程序员的视角》中阅读更多相关内容。
- en: To summarize this section, even if memory accesses are constant-time operations,
    caching can have dramatic effects on the actual time it takes to access the memory.
    This is something to always bear in mind when using or implementing new data structures.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本节，即使内存访问是恒定时间操作，缓存对实际访问内存所需时间的影响可能会很大。在使用或实现新数据结构时，这是一件需要时刻牢记的事情。
- en: Next, I will introduce a set of data structures from the C++ standard library,
    called containers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍C++标准库中的一组数据结构，称为容器。
- en: The standard library containers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库容器
- en: The C++ standard library offers a set of very useful container types. A container
    is a data structure that contains a collection of elements. The container manages
    the memory of the elements it holds. This means that we don't have to explicitly
    create and delete the objects that we put in a container. We can pass objects
    created on the stack to a container and the container will copy and store them
    on the free store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了一组非常有用的容器类型。容器是包含一系列元素的数据结构。容器管理它所持有的元素的内存。这意味着我们不必显式地创建和删除放入容器中的对象。我们可以将在堆栈上创建的对象传递给容器，容器将会复制并存储它们在自由存储器上。
- en: Iterators are used to access elements in containers, and are, therefore, a fundamental
    concept for understanding algorithms and data structures from the standard library.
    The iterator concept is covered in *Chapter 5*, *Algorithms*. For this chapter,
    it's enough to know that an iterator can be thought of as a pointer to an element
    and that iterators have different operators defined depending on the container
    they belong to. For example, array-like data structures provide random access
    iterators to their elements. These iterators support arithmetic expressions using
    `+` and `-`, whereas an iterator to a linked list, for example, only supports
    `++` and `--` operators.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器用于访问容器中的元素，因此对于理解标准库中的算法和数据结构来说，它们是一个基本概念。迭代器概念在*第5章*，*算法*中有介绍。对于本章来说，知道迭代器可以被视为指向元素的指针，并且迭代器根据它们所属的容器定义了不同的操作符就足够了。例如，类似数组的数据结构提供对其元素的随机访问迭代器。这些迭代器支持使用`+`和`-`的算术表达式，而例如链表的迭代器只支持`++`和`--`操作符。
- en: 'The containers are divided into three categories: sequence containers, associative
    containers, and container adaptors. This section will contain a brief introduction
    to the containers in each of the three categories and also address the most important
    things to consider when performance is an issue.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 容器分为三类：序列容器、关联容器和容器适配器。本节将简要介绍这三类容器中的容器，并讨论在性能成为问题时需要考虑的最重要的事情。
- en: Sequence containers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列容器
- en: Sequence containers keep the elements in the order we specify when adding the
    elements to the container. The sequence containers from the standard library are
    `std::array`, `std::vector`, `std::deque`, `std::list`, and `std::forward_list`.
    I will also address `std::basic_string` in this section, although it's not formally
    a generic sequence container because it only handles elements of character types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 序列容器会按照我们添加元素到容器时指定的顺序来保留元素。标准库中的序列容器包括`std::array`、`std::vector`、`std::deque`、`std::list`和`std::forward_list`。我也会在本节中介绍`std::basic_string`，尽管它不是正式的通用序列容器，因为它只处理字符类型的元素。
- en: 'We should know the answers to the following questions before choosing a sequence
    container:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择序列容器之前，我们应该知道以下问题的答案：
- en: What is the number of elements (order of magnitude)?
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元素数量是多少（数量级）？
- en: What are the usage patterns? How often are you going to add data? Read/traverse
    data? Delete data? Rearrange data?
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模式是什么？您将多频繁地添加数据？读取/遍历数据？删除数据？重新排列数据？
- en: Where in the sequence are you going to add data most often? At the end, at the
    beginning, or in the middle of the sequence?
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您最常在序列中添加数据的位置是哪里？在末尾、开头还是中间？
- en: Do you need to sort the elements? Or do you even care about the order?
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要对元素进行排序吗？或者您是否甚至关心顺序？
- en: Depending on the answers to these questions, we can determine which sequence
    containers are more or less suitable for our needs. But, to do that, we need a
    basic understanding of the interfaces and performance characteristics of each
    type of sequence container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些问题的答案，我们可以确定哪种序列容器更适合我们的需求。但是，为了做到这一点，我们需要对每种类型的序列容器的接口和性能特征有基本的了解。
- en: The sections that follow will briefly present the different sequence containers,
    starting with one of the most widely used containers overall.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将简要介绍不同的序列容器，首先介绍最常用的容器之一。
- en: Vectors and arrays
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量和数组
- en: '`std::vector` is probably the most commonly used container type, and for good
    reason. A vector is an array that grows dynamically when needed. The elements
    added to a vector are guaranteed to be laid out contiguously in memory, which
    means that you can access any element in the array by its index in constant time.
    It also means that it provides excellent performance when traversing the elements
    in the order they are laid out, thanks to the spatial locality mentioned earlier.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`可能是最常用的容器类型，原因很充分。向量是一个在需要时动态增长的数组。添加到向量中的元素保证在内存中是连续排列的，这意味着您可以通过索引以常数时间访问数组中的任何元素。这也意味着在按照它们排列的顺序遍历元素时，由于前面提到的空间局部性，它提供了出色的性能。'
- en: 'A vector has a **size** and a **capacity**. The size is the number of elements
    that are currently held in the container, and the capacity is the number of elements
    that the vector can hold until it needs to allocate more space:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向量有一个**大小**和一个**容量**。大小是当前容器中保存的元素数量，容量是向量需要分配更多空间之前可以容纳的元素数量：
- en: '![](img/B15619_04_07.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_07.png)'
- en: 'Figure 4.7: Size and capacity of a std::vector'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：std::vector的大小和容量
- en: Adding elements to the end of a vector using the `push_back()` function is fast,
    as long as the size is less than the capacity. When adding an element and there
    is no room for more, the vector will allocate a new internal buffer and then move
    all of the elements to the new space. The capacity will grow in such a way that
    resizing the buffer rarely happens, thus making `push_back()` an amortized constant-time
    operation, as we discussed in *Chapter 3*, *Analyzing and Measuring Performance*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`push_back()`函数向向量末尾添加元素是快速的，只要大小小于容量。当添加一个元素并且没有更多空间时，向量将会分配一个新的内部缓冲区，然后将所有元素移动到新空间。容量会以一种很少发生调整缓冲区大小的方式增长，因此使`push_back()`成为摊销的常数时间操作，正如我们在*第3章*，*分析和测量性能*中讨论的那样。
- en: 'A vector template instance of type `std::vector<Person>` will store `Person`
    objects by value. When the vector needs to rearrange the `Person` objects (for
    example, as a result of an insert), the values will be copy constructed or moved.
    Objects will be moved if they have a `nothrow` move constructor. Otherwise, the
    objects will be copy constructed in order to guarantee strong exception safety:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为`std::vector<Person>`的向量模板实例将按值存储`Person`对象。当向量需要重新排列`Person`对象（例如，作为插入的结果），值将被复制构造或移动。如果对象具有`nothrow`移动构造函数，则对象将被移动。否则，为了保证强异常安全性，对象将被复制构造：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Internally, `std::vector` uses `std::move_if_noexcept` in order to determine
    whether the object should be copied or moved. The `<type_traits>` header can help
    you to verify at compile time that your classes are guaranteed to not throw an
    exception when moved:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`std::vector`使用`std::move_if_noexcept`来确定对象是应该被复制还是移动。`<type_traits>`头文件可以帮助您在编译时验证您的类在移动时是否保证不会抛出异常：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you are adding newly created objects to the vector, you can take advantage
    of the `emplace_back()` function, which will create the object in place for you,
    instead of creating an object and then copying/moving it to the vector using the
    `push_back()` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要将新创建的对象添加到向量中，您可以利用`emplace_back()`函数，它将为您创建对象，而不是使用`push_back()`函数创建对象，然后将其复制/移动到向量中：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The capacity of the vector can change in the following ways:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的容量可以通过以下方式改变：
- en: By adding an element to the vector when the `capacity == size`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在`capacity == size`时向向量添加元素
- en: By calling `reserve()`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`reserve()`
- en: By calling `shrink_to_fit()`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`shrink_to_fit()`
- en: Other than that, the vector will not change the capacity, and hence will not
    allocate or deallocate dynamic memory. For example, the member function `clear()`
    empties a vector, but it does not change its capacity. These memory guarantees
    make the vector usable even in real-time contexts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，向量不会改变容量，因此也不会分配或释放动态内存。例如，成员函数`clear()`会清空向量，但不会改变其容量。这些内存保证使得向量即使在实时环境中也可以使用。
- en: 'Since C++20, there are also two free functions that erase elements from a `std::vector`.
    Prior to C++20, we had to use the *erase-remove idiom*, which we will discuss
    in *Chapter 5*, *Algorithms*. However, now the recommended way to erase elements
    from a `std::vector` is by using `std::erase()` and `std::erase_if()`. Here is
    a short example of how to use these functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，还有两个免费函数可以从`std::vector`中删除元素。在C++20之前，我们必须使用*擦除-移除惯用法*，我们将在*第5章* *算法*中讨论。然而，现在从`std::vector`中删除元素的推荐方法是使用`std::erase()`和`std::erase_if()`。以下是如何使用这些函数的简短示例：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As an alternative to the dynamically sized vector, the standard library also
    provides a fixed size version named `std::array` that manages its elements by
    using the stack as opposed to the free store. The size of the array is a template
    argument specified at compile time, which means that the size and type elements
    become a part of the concrete type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为动态大小向量的替代，标准库还提供了一个名为`std::array`的固定大小版本，它通过使用堆栈而不是自由存储来管理其元素。数组的大小是在编译时指定的模板参数，这意味着大小和类型元素成为具体类型的一部分：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, `a` and `b` are not the same type, which means that you have
    to specify the size when using the type as a function parameter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a`和`b`不是相同的类型，这意味着在使用类型作为函数参数时，你必须指定大小：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This might seem a bit tedious at first, but this is, in fact, the big advantage
    over the built-in array type (the C arrays), which loses the size information
    when passed to a function, since it automatically converts a pointer into the
    first element of the array:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能看起来有点麻烦，但事实上，这是与内置数组类型（C数组）相比的一个很大的优势，因为当传递给函数时，它会自动将指针转换为数组的第一个元素，从而丢失大小信息：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An array losing its size information is usually referred to as **array decay**.
    You will see later on in this chapter how array decay can be avoided by using
    `std::span` when passing contiguous data to functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数组失去其大小信息通常被称为**数组衰变**。在本章后面，您将看到如何通过在将连续数据传递给函数时使用`std::span`来避免数组衰变。
- en: Deque
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双端队列
- en: Sometimes, you'll find yourself in a situation where you need to frequently
    add elements to both the beginning and end of a sequence. If you are using a `std::vector`
    and need to speed up the inserts at the front, you can instead use `std::deque`,
    which is short for **double-ended queue**. `std::deque` is usually implemented
    as a collection of fixed-size arrays, which makes it possible to access elements
    by their index in constant time. However, as you can see in the following figure,
    all of the elements are not stored contiguously in memory, which is the case with
    `std::vector` and `std::array`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会发现自己处于需要频繁向序列的开头和结尾添加元素的情况。如果您使用的是`std::vector`并且需要加快在前面插入的速度，您可以使用`std::deque`，它是**双端队列**的缩写。`std::deque`通常实现为一组固定大小的数组，这使得可以在常数时间内通过它们的索引访问元素。然而，正如您在下图中所看到的，所有元素并不是存储在内存中的连续位置，这与`std::vector`和`std::array`的情况不同。
- en: '![](img/B15619_04_08.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_08.png)'
- en: 'Figure 4.8: A possible layout of std::deque'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：std::deque的可能布局
- en: List and forward_list
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表和前向列表
- en: The `std::list` is a **doubly linked list**, meaning that each element has one
    link to the next element and one link to its previous element. This makes it possible
    to iterate over the list both backward and forward. There is also a **singly linked
    list** named `std::forward_list`. The reason you wouldn't always choose the doubly
    linked list over `std::forward_list` is because of the excessive memory that is
    occupied by the back pointers in the doubly linked list. So, if you don't need
    to traverse the list backward, use `std::forward_list`. Another interesting feature
    of the forward list is that it's optimized for very short lists. When the list
    is empty, it only occupies one word, which makes it a viable data structure for
    sparse data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::list`是一个**双向链表**，意味着每个元素都有一个指向下一个元素和一个指向前一个元素的链接。这使得可以向前和向后遍历列表。还有一个名为`std::forward_list`的**单向链表**。之所以不总是选择双向链表而不是`std::forward_list`，是因为双向链表中的后向指针占用了过多的内存。因此，如果不需要向后遍历列表，就使用`std::forward_list`。单向链表的另一个有趣特性是它针对非常短的列表进行了优化。当列表为空时，它只占用一个字，这使得它成为稀疏数据的一种可行数据结构。'
- en: Note that even if the elements are ordered in a sequence, they are *not* laid
    out contiguously in memory like the vector and array are, which means that iterating
    a linked list will most likely generate a lot more cache misses compared to the
    vector.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使元素在一个序列中是有序的，它们在内存中*并不*像向量和数组那样连续布局，这意味着迭代链表很可能会产生比向量更多的缓存未命中。
- en: 'To recap, the `std::list` is a doubly linked list with pointers to the next
    and previous elements:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`std::list`是一个具有指向下一个和上一个元素的双向链表：
- en: '![](img/B15619_04_09.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_09.png)'
- en: 'Figure 4.9: std::list is a doubly linked list'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：std::list是一个双向链表
- en: 'The `std::forward_list` is a singly linked list with pointers to the next element:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`是一个具有指向下一个元素的单向链表：'
- en: '![](img/B15619_04_10.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_10.png)'
- en: 'Figure 4.10: std::forward_list is a singly linked list'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：std::forward_list是一个单向链表
- en: The `std::forward_list` is more memory efficient since it only has one pointer
    to the next element.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward_list`更加内存高效，因为它只有一个指向下一个元素的指针。'
- en: Lists are also the only containers that support **splicing**, which is a way
    to transfer elements between lists without copying or moving the elements. This
    means, for example, that it is possible to concatenate two lists into one in constant
    time, *O(1)*. Other containers require at least linear time for such operations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也是唯一支持**splicing**的容器，这是一种在不复制或移动元素的情况下在列表之间传输元素的方法。这意味着，例如，可以在常数时间*O(1)*内将两个列表连接成一个。其他容器对于这样的操作至少需要线性时间。
- en: The basic_string
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本字符串
- en: 'The last template class that we will cover in this section is the `std::basic_string`.
    The `std::string` is a `typedef` for `std::basic_string<char>`. Historically,
    `std::basic_string` was not guaranteed to be laid out contiguously in memory.
    This changed with C++17, which makes it possible to pass the string to APIs that
    require an array of characters. For example, the following code reads an entire
    file into a string:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中介绍的最后一个模板类是`std::basic_string`。`std::string`是`std::basic_string<char>`的一个`typedef`。从历史上看，`std::basic_string`并不保证在内存中连续布局。这在C++17中发生了改变，这使得可以将字符串传递给需要字符数组的API。例如，以下代码将整个文件读入字符串中：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By opening the file using `std::ios::ate`, the position indicator is set to
    the end of the stream so that we can use `tellg()` to retrieve the size of the
    file. After that, we set the input position to the beginning of the stream and
    start reading.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`std::ios::ate`打开文件，位置指示器被设置到流的末尾，这样我们就可以使用`tellg()`来检索文件的大小。之后，我们将输入位置设置为流的开头并开始读取。
- en: Most implementations of `std::basic_string` utilize something called **small
    object optimization**, which means that they do not allocate any dynamic memory
    if the size of the string is small. We will discuss small object optimization
    later in the book. For now, let's move on to discuss associative containers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`std::basic_string`的实现都利用了称为**小对象优化**的东西，这意味着如果字符串的大小很小，它们不会分配任何动态内存。我们将在本书的后面讨论小对象优化。现在，让我们继续讨论关联容器。
- en: Associative containers
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联容器
- en: The associative containers place their elements based on the element itself.
    For example, it's not possible to add an element at the back or front in an associative
    container as we do with `std::vector::push_back()` or `std::list::push_front()`.
    Instead, the elements are added in a way that makes it possible to find the element
    without the need to scan the entire container. Therefore, the associative containers
    have some requirements for the objects we want to store in a container. We will
    look at these requirements later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器根据元素本身的特性放置它们的元素。例如，在关联容器中不可能像使用`std::vector::push_back()`或`std::list::push_front()`那样在后面或前面添加元素。相反，元素是以一种使得可以在不需要扫描整个容器的情况下找到元素的方式添加的。因此，关联容器对我们想要存储在容器中的对象有一些要求。我们将在后面讨论这些要求。
- en: 'There are two main categories of associative containers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关联容器有两个主要类别：
- en: '**Ordered associative containers**: These containers are based on trees; the
    containers use a tree for storing their elements. They require that the elements
    are ordered by the less than operator (`<`). The functions for adding, deleting,
    and finding elements are all O(log n) in the tree-based containers. The containers
    are named `std::set`, `std::map`, `std::multiset`, and `std::multimap`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序关联容器**：这些容器基于树；容器使用树来存储它们的元素。它们要求元素按照小于运算符(`<`)进行排序。基于树的容器中添加、删除和查找元素的函数都是O(log
    n)。这些容器被命名为`std::set`、`std::map`、`std::multiset`和`std::multimap`。'
- en: '**Unordered associative containers**: These containers are based on hash tables;
    the containers use a hash table for storing their elements. They require that
    the elements are compared with the equality operator (`==`) and that there is
    a way to compute a hash value based on an element. More on that later. The functions
    for adding, deleting, and finding elements are all *O(1)* in the hash table-based
    containers. The containers are named `std::unordered_set`, `std::unordered_map`,
    `std::unordered_multiset`, and `std::unordered_multimap`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无序关联容器**：这些容器基于哈希表；容器使用哈希表来存储它们的元素。它们要求元素使用相等运算符（`==`）进行比较，并且有一种方法可以根据元素计算哈希值。稍后会详细介绍。基于哈希表的容器中添加、删除和查找元素的函数都是*O(1)*。这些容器的名称是`std::unordered_set`、`std::unordered_map`、`std::unordered_multiset`和`std::unordered_multimap`。'
- en: Since C++20, all associative containers are equipped with a function named `contains()`,
    which should be used when you want to know whether a container contains some specific
    elements. In earlier versions of C++, it was necessary to use `count()` or `find()`
    to find out whether a container contained an element.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，所有关联容器都配备了一个名为`contains()`的函数，当您想知道容器是否包含某些特定元素时应该使用它。在较早版本的C++中，需要使用`count()`或`find()`来确定容器是否包含元素。
- en: Always use the specialized functions, such as `contains()` and `empty()`, instead
    of using `count() > 0` or `size() == 0`. The specialized functions are guaranteed
    to be the most efficient ones.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用专门的函数，如`contains()`和`empty()`，而不是使用`count() > 0`或`size() == 0`。专门的函数保证是最有效的。
- en: Ordered sets and maps
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序集合和映射
- en: 'The ordered associative containers guarantee that insert, delete, and search
    can be done in logarithmic time, *O(log n)*. How that is achieved is up to the
    implementation of the standard library. However, the implementations we know about
    do use some kind of self-balancing binary search tree. The fact that the tree
    stays approximately balanced is necessary for controlling the height of the tree,
    and, hence, also the worst-case running time when accessing elements. There is
    no need for the tree to pre-allocate memory, so, typically, a tree will allocate
    memory on the free store each time an element is inserted and also free up memory
    whenever elements are erased. Take a look at the following diagram, which shows
    that the height of a balanced tree is *O(log n)*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有序关联容器保证插入、删除和搜索可以在对数时间*O(log n)*内完成。如何实现这一点取决于标准库的实现。然而，我们所知道的实现确实使用了某种自平衡二叉搜索树。树保持大致平衡是控制树的高度以及访问元素的最坏情况运行时间的必要条件。树不需要预先分配内存，因此通常情况下，每次插入元素时树都会在自由存储器上分配内存，并在擦除元素时释放内存。请看下面的图表，显示平衡树的高度为*O(log
    n)*：
- en: '![](img/B15619_04_11.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_11.png)'
- en: 'Figure 4.11: The height of the tree is O(log n) if it''s balanced'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：如果树是平衡的，则树的高度为O(log n)
- en: Unordered sets and maps
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无序集合和映射
- en: The unordered versions of sets and maps offer a hash-based alternative to the
    tree-based versions. This data structure is, in general, referred to as hash tables.
    In theory, hash tables offer amortized constant-time insert, add, and delete operations,
    which can be compared to the tree-based versions that operate in *O(log n)*. However,
    in practice, the difference might not be so obvious, especially if you are not
    storing a very large number of elements in your container.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无序集合和映射的版本提供了基于哈希的替代方案，而不是基于树的版本。这种数据结构通常被称为哈希表。理论上，哈希表提供了摊销的常数时间插入、添加和删除操作，可以与操作在*O(log
    n)*的基于树的版本进行比较。然而，在实践中，差异可能并不那么明显，特别是如果您的容器中没有存储非常大数量的元素。
- en: Let's see how a hash table can offer *O(1)* operations. A hash table keeps its
    elements in some sort of array of buckets. When adding an element to the hash
    table, an integer is computed for the element using a hash function. The integer
    is usually called the **hash** of the element. The hash value is then limited
    to the size of the array (by using the modulo operation, for example) so that
    the new limited value can be used as an index in the array. Once the index is
    computed, the hash table can store the element in the array at that index. The
    lookup of an element works in a similar manner by first computing a hash value
    for the element we are looking for and then accessing the array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看哈希表如何提供*O(1)*的操作。哈希表将其元素保存在一些桶的数组中。当向哈希表添加元素时，使用哈希函数计算元素的整数。这个整数通常被称为元素的**哈希**。然后，哈希值被限制在数组的大小范围内（例如通过使用取模运算），以便新的限制值可以用作数组中的索引。一旦计算出索引，哈希表就可以将元素存储在数组的该索引处。查找元素的操作方式类似，首先计算要查找的元素的哈希值，然后访问数组。
- en: 'Apart from computing the hash value, this technique seems straightforward.
    This is just half of the story, though. What if two different elements generate
    the same index, either because they produced the same hash value, or because two
    different hash values are being limited to the same index? When two non-equal
    elements end up at the same index, we call that a **hash collision**. This is
    not just an edge case: this will happen a lot, even if we are using a good hash
    function, and especially if the array is small when compared to the number of
    elements we are adding. There are various ways of dealing with hash collisions.
    Here, we will focus on the one that is being used in the standard library, which
    is called **separate chaining**.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算哈希值，这种技术似乎很简单。然而，这只是故事的一半。如果两个不同的元素生成相同的索引，要么是因为它们产生了相同的哈希值，要么是因为两个不同的哈希值被限制到相同的索引，会发生什么？当两个不相等的元素最终位于同一个索引时，我们称之为**哈希冲突**。这不仅仅是一个边缘情况：即使我们使用一个很好的哈希函数，尤其是当数组的大小与我们添加的元素数量相比较小时，这种情况会经常发生。有各种方法来处理哈希冲突。在这里，我们将专注于标准库中使用的一种方法，称为**分离链接**。
- en: Separate chaining solves the problem of two unequal elements ending up at the
    same index. Instead of just storing the elements directly in the array, the array
    is a sequence of **buckets**. Each bucket can contain multiple elements, that
    is, all of the elements that are hashed to the same index. So, each bucket is
    also some sort of container. The exact data structure used for the buckets is
    not defined, and it can vary for different implementations. However, we can think
    of it as a linked list and assume that finding an element in a specific bucket
    is slow, since it needs to scan the elements in the buckets linearly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分离链接解决了两个不相等的元素最终在相同索引处的问题。数组不仅仅是直接存储元素，而是一个序列的**桶**。每个桶可以包含多个元素，也就是所有散列到相同索引的元素。因此，每个桶也是某种类型的容器。用于桶的确切数据结构未定义，对于不同的实现可能会有所不同。但是，我们可以将其视为链表，并假设在特定桶中查找元素是缓慢的，因为它需要线性扫描桶中的元素。
- en: 'The following figure shows a hash table with eight buckets. The elements have
    landed in three separate buckets. The bucket with index **2** contains four elements,
    the bucket with index **4** contains two elements, and the bucket with index **5**
    contains only one element. The other buckets are empty:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个具有八个桶的哈希表。元素分布在三个单独的桶中。索引为**2**的桶包含四个元素，索引为**4**的桶包含两个元素，索引为**5**的桶只包含一个元素。其他桶为空：
- en: '![](img/B15619_04_12.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_12.png)'
- en: 'Figure 4.12: Each bucket contains 0 or more elements'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：每个桶包含0个或多个元素
- en: Hash and equals
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希和相等
- en: The hash value, which can be computed in constant time with respect to the size
    of the container, determines which bucket an element will be placed in. Since
    it's possible that more than one object will generate the same hash value, and
    therefore end up in the same bucket, each key also needs to provide an equals
    function, which is used to compare the key we are looking for with all of the
    keys in the bucket.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值可以在与容器大小相关的常量时间内计算，它决定了元素将被放置在哪个桶中。由于可能会有多个对象生成相同的哈希值，因此最终进入同一个桶，每个键还需要提供一个相等函数，用于将要查找的键与桶中的所有键进行比较。
- en: If two keys are equal, they are required to generate the same hash value. However,
    it's perfectly legal for two objects to return the same hash value while not being
    equal to each other.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个键相等，则它们需要生成相同的哈希值。但是，两个对象返回相同的哈希值而彼此不相等是完全合法的。
- en: A good hash function is quick to compute and will also distribute the keys evenly
    among the buckets in order to minimize the number of elements in each bucket.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的哈希函数计算快速，并且还会在桶之间均匀分布键，以最小化每个桶中的元素数量。
- en: 'The following is an example of a *very bad*, but valid, hash function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个*非常糟糕*但有效的哈希函数的示例：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is valid because it will return the same hash value for two objects that
    are equal. The hash function is also very quick. However, since all elements will
    produce the same hash value, all keys will end up in the same bucket, which means
    finding an element will be *O(n)* instead of *O(1)*, which we are aiming for.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它是有效的，因为它将为两个相等的对象返回相同的哈希值。哈希函数也非常快。然而，由于所有元素将产生相同的哈希值，所有键最终将进入同一个桶，这意味着查找一个元素将是*O(n)*而不是我们所追求的*O(1)*。
- en: A good hash function, on the other hand, ensures that the elements are distributed
    evenly among the buckets to minimize hash collisions. The C++ standard actually
    has a note about this, which states that it should be very rare for a hash function
    to produce the same hash value for two different objects. Fortunately, the standard
    library already provides us with good hash functions for basic types. In many
    cases, we can reuse these functions when writing our own hash functions for user-defined
    types.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个好的哈希函数可以确保元素在桶之间均匀分布，以最小化哈希冲突。C++标准实际上对此有一个注释，指出哈希函数很少会为两个不同的对象产生相同的哈希值。幸运的是，标准库已经为基本类型提供了良好的哈希函数。在许多情况下，我们可以在为用户定义的类型编写自己的哈希函数时重用这些函数。
- en: 'Suppose we want to use a `Person` class as a key in an `unorordered_set`. The
    `Person` class has two data members: `age`, which is an `int`, and `name`, which
    is a `std::string`. We start by writing the equal predicate:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将`Person`类作为`unorordered_set`中的键。`Person`类有两个数据成员：`age`是一个`int`，`name`是一个`std::string`。我们首先编写相等谓词：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For two `Person` objects to be equal, they need to have the same name and the
    same age. We can now define the hash predicate by combining the hash values of
    all of the data members that are included in the equals predicate. Unfortunately,
    there is no function in the C++ standard yet to combine hash values, but there
    is a good one available in Boost, which we will use here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使两个`Person`对象相等，它们需要有相同的名称和相同的年龄。现在我们可以通过组合包含在相等谓词中的所有数据成员的哈希值来定义哈希谓词。不幸的是，C++标准中还没有函数来组合哈希值，但Boost中有一个很好的函数可用，我们将在这里使用：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If, for some reason, you cannot use Boost, `boost::hash_combine()` is really
    just a one-liner that can be copied from the documentation found at [https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine](https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您无法使用Boost，`boost::hash_combine()`实际上只是一个可以从[https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine](https://www.boost.org/doc/libs/1_55_0/doc/html/hash/reference.html#boost.hash_combine)的文档中复制的一行代码。
- en: 'With the equality and hash functions defined, we can finally create our `unordered_set`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了相等和哈希函数的定义，我们最终可以创建我们的`unordered_set`：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A good rule of thumb is to always use all of the data members that are being
    used in the equal function when producing the hash value. That way, we adhere
    to the contract between equals and hash, and, at the same time, this enables us
    to provide an effective hash value. For example, it would be correct but inefficient
    to only use the name when computing the hash value, since that would mean that
    all `Person` objects with the same name would end up in the same bucket. Even
    worse, though, would be to include data members in the hash function that are
    not being used in the equals function. This would most likely result in a disaster
    where you cannot find objects in your `unordered_set` that, in fact, compare equally.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是在生成哈希值时始终使用等函数中使用的所有数据成员。这样，我们遵守了等号和哈希之间的约定，同时这使我们能够提供一个有效的哈希值。例如，仅在计算哈希值时使用名称是正确但低效的，因为这意味着所有具有相同名称的`Person`对象最终都会进入同一个桶中。更糟糕的是，在哈希函数中包括未在等函数中使用的数据成员。这很可能会导致灾难，使您无法在`unordered_set`中找到相等的对象。
- en: Hash policy
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 哈希策略
- en: Apart from creating hash values that distribute the keys evenly among the buckets,
    we can reduce the number of collisions by having many buckets. The average number
    of elements per bucket is called the **load factor**. In the preceding example,
    we created an `unordered_set` with 100 buckets. If we add 50 `Person` objects
    to the set, `load_factor()` would return 0.5\. The `max_load_factor` is an upper
    limit of the load factor, and when that value is reached, the set will need to
    increase the number of buckets, and, as a consequence, also rehash all the elements
    that are currently in the set. It's also possible to trigger a rehash manually
    with the `rehash()` and `reserve()` member functions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建均匀分布在桶中的键的哈希值之外，我们还可以通过拥有许多桶来减少碰撞的数量。每个桶的平均元素数称为**负载因子**。在前面的示例中，我们创建了一个具有100个桶的`unordered_set`。如果我们向集合中添加50个`Person`对象，`load_factor()`将返回0.5。`max_load_factor`是负载因子的上限，当达到该值时，集合将需要增加桶的数量，并且因此还需要重新散列当前集合中的所有元素。还可以使用`rehash()`和`reserve()`成员函数手动触发重新散列。
- en: 'Let''s move on to look at the third category: container adaptors.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看第三类：容器适配器。
- en: Container adaptors
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器
- en: 'There are three container adaptors in the standard library: `std::stack`, `std::``queue`,
    and `std::``priority_queue`. Container adaptors are quite different from sequence
    containers and associative containers because they represent **abstract data types**
    that can be implemented by the underlying sequence container. For example, the
    stack, which is a **last in, first out** (**LIFO**) data structure supporting
    push and pop on the top of the stack, can be implemented by using a `vector`,
    `list`, `deque`, or any other custom sequence container that supports `back()`,
    `push_back()`, and `pop_back()`. The same goes for `queue`, which is a **first
    in, first out** (**FIFO**) data structure, and `priortiy_queue`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有三种容器适配器：`std::stack`、`std::queue`和`std::priority_queue`。容器适配器与序列容器和关联容器非常不同，因为它们代表可以由底层序列容器实现的**抽象数据类型**。例如，堆栈是一个**后进先出**（**LIFO**）数据结构，支持在堆栈顶部进行推送和弹出，可以使用`vector`、`list`、`deque`或任何其他支持`back()`、`push_back()`和`pop_back()`的自定义序列容器来实现。队列也是如此，它是一个**先进先出**（**FIFO**）数据结构，以及`priority_queue`。
- en: In this section, we will focus on `std::priority_queue`, which is a pretty useful
    data structure that is easy to forget.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注`std::priority_queue`，这是一个非常有用的数据结构，很容易被忘记。
- en: Priority queues
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优先队列
- en: A **priority queue** offers a constant-time lookup of the element with the highest
    priority. The priority is defined using the less than operator of the elements.
    Insert and delete both run in logarithmic time. A priority queue is a partially
    ordered data structure, and it might not be obvious when to use one instead of
    a completely sorted data structure, for example, a tree or a sorted vector. However,
    in some cases, a priority queue can offer you the functionality you need, and
    for a lower cost than a completely sorted container.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先队列**提供了具有最高优先级的元素的常数时间查找。使用元素的小于运算符定义优先级。插入和删除都在对数时间内运行。优先队列是一个部分有序的数据结构，可能不明显何时使用它而不是完全排序的数据结构，例如树或排序向量。但是，在某些情况下，优先队列可以为您提供所需的功能，并且成本比完全排序的容器低。'
- en: The standard library already provides a partial sort algorithm, so we don't
    need to write our own. But let's look at how we can implement a partial sort algorithm
    using a priority queue. Suppose that we are writing a program for searching documents
    given a query. The matching documents (search hits) should be ordered by rank,
    and we are only interested in finding the first 10 search hits with the highest
    rank.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库已经提供了一个部分排序算法，所以我们不需要自己写。但让我们看看如何使用优先队列来实现一个部分排序算法。假设我们正在编写一个程序，用于根据查询搜索文档。匹配的文档（搜索命中）应按排名排序，我们只对找到的前10个排名最高的搜索命中感兴趣。
- en: 'A document is represented by the following class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文档由以下类表示：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When searching, an algorithm selects the documents that match the query and
    computes a rank of the search hits. Each matching document is represented by a
    `Hit`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索时，算法选择与查询匹配的文档并计算搜索命中的排名。每个匹配的文档由`Hit`表示：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we need to sort the hits and return the top *m* documents. What are
    the options for sorting the hits? If the hits are contained in a container that
    provides random access iterators, we could use `std::sort()` and only return the
    *m* first elements. Or, if the total number of hits is much larger than the *m*
    documents we are to return, we could use `std::partial_sort()`, which would be
    more efficient than `std::sort()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对命中进行排序并返回前*m*个文档。对于排序命中有哪些选项？如果命中包含在提供随机访问迭代器的容器中，我们可以使用`std::sort()`并且只返回前*m*个元素。或者，如果命中的总数远远大于我们要返回的*m*个文档，我们可以使用`std::partial_sort()`，这比`std::sort()`更有效。
- en: 'But what if we don''t have random access iterators? Maybe the matching algorithm
    only provides forward iterators to the hits. In that case, we could use a priority
    queue and still come up with an efficient solution. Our sort interface would look
    like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们没有随机访问迭代器怎么办？也许匹配算法只提供了对命中的前向迭代器。在这种情况下，我们可以使用优先队列，仍然得到一个高效的解决方案。我们的排序接口将如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could call this function with any iterator that has the increment operator
    defined. Next, we create a `std::priority_queue` backed by a `std::vector`, using
    a custom compare function for keeping the *lowest* ranking hits at the top of
    the queue:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用定义了递增运算符的任何迭代器调用此函数。接下来，我们创建一个由`std::vector`支持的`std::priority_queue`，使用自定义比较函数来保持队列顶部的*最低*排名命中：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will only insert, at most, *m* elements in the priority queue. The priority
    queue will contain the highest-ranking hits seen so far. Among the elements that
    are currently in the priority queue, the hit with the lowest rank will be the
    topmost element:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在优先队列中最多插入m个元素。优先队列将包含到目前为止看到的排名最高的命中。在当前在优先队列中的元素中，排名最低的命中将成为最顶部的元素：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we have collected the highest-ranking hits in the priority queue, so the
    only thing left to do is to put them in a vector in reverse order and return the
    *m*-sorted hits:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在优先队列中收集了排名最高的命中，所以唯一剩下的事情就是将它们以相反的顺序放入向量中，并返回排序后的命中：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What is the complexity of this algorithm? If we denote the number of hits with
    n and the number of returned hits with *m*, we can see that the memory consumption
    is *O(m)*, whereas the time complexity is *O(n * log m)*, since we are iterating
    over *n* elements. Additionally, in each iteration, we might have to do a push
    and/or pop, which both run in *O(log m)* time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的复杂度是多少？如果我们用n表示命中次数，用m表示返回的命中次数，我们可以看到内存消耗是O(m)，而时间复杂度是O(n * log m)，因为我们正在迭代n个元素。此外，在每次迭代中，我们可能需要进行推送和/或弹出，这两者都在O(log
    m)时间内运行。
- en: We will now leave the standard library containers and focus on a couple of new
    useful class templates that are closely related to standard containers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将离开标准库容器，专注于一些与标准容器密切相关的新的有用的类模板。
- en: Using views
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图
- en: 'In this section, we will discuss some relatively new class templates in the
    C++ standard library: `std::string_view` from C++17 and `std::span`, which was
    introduced in C++20.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论C++标准库中一些相对较新的类模板：C++17中的`std::string_view`和C++20中引入的`std::span`。
- en: These class templates are not containers but lightweight views (or slices) of
    a sequence of contiguous elements. Views are small objects that are meant to be
    copied by value. They don't allocate memory, nor do they provide any guarantees
    regarding the lifetime of the memory they point to. In other words, they are non-owning
    reference types, which differ significantly from the containers described previously
    in this chapter. At the same time, they are closely related to `std::string`,
    `std::array`, and `std::vector`, which we will look at soon. I will start by describing
    `std::string_view`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类模板不是容器，而是一系列连续元素的轻量级视图（或切片）。视图是小对象，可以按值复制。它们不分配内存，也不提供有关它们指向的内存的生存期的任何保证。换句话说，它们是非拥有引用类型，与本章前面描述的容器有很大不同。与此同时，它们与`std::string`、`std::array`和`std::vector`密切相关，我们将很快看到。我将从描述`std::string_view`开始。
- en: Avoiding copies with string_view
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用string_view避免复制
- en: 'A `std::string_view` contains a pointer to the beginning of an immutable string
    buffer and a size. Since a string is a contiguous sequence of characters, the
    pointer and the size fully define a valid substring range. Typically, a `std::string_view`
    points to some memory that is owned by a `std::string`. But it could also point
    to a string literal with static storage duration or something like a memory-mapped
    file. The following diagram shows a `std::string_view` pointing at memory owned
    by a `std::string`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`包含一个指向不可变字符串缓冲区开头的指针和一个大小。由于字符串是一系列连续的字符，指针和大小完全定义了一个有效的子字符串范围。通常，`std::string_view`指向由`std::string`拥有的一些内存。但它也可以指向具有静态存储期的字符串字面量或类似内存映射文件的东西。以下图表显示了`std::string_view`指向由`std::string`拥有的内存：'
- en: '![](img/B15619_04_13.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_13.png)'
- en: 'Figure 4.13: A std::string_view object pointing at memory owned by an instance
    of std::string'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：一个指向由std::string实例拥有的内存的std::string_view对象。
- en: The character sequence defined by a `std::string_view` is not required to be
    terminated by a null character, but it is perfectly valid to have a sequence of
    characters that contains null characters. The `std::string`, on the other hand,
    needs to be able to return a null-terminated string from `c_str()`, which means
    that it always stores an extra null character at the end of the sequence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由`std::string_view`定义的字符序列不需要以空字符结尾，但包含空字符的字符序列是完全有效的。另一方面，`std::string`需要能够从`c_str()`返回以空字符结尾的字符串，这意味着它总是在序列的末尾存储额外的空字符。
- en: The fact that `string_view` does not need a null terminator means that it can
    handle substrings much more efficiently than a C-style string or a `std::string`
    because it does not have to create new strings just to add the null terminator.
    The complexity of `substr()` using a `std::string_view` is constant, which should
    be compared to the `substr()` version of `std::string`, which runs in linear time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view`不需要空终止符的事实意味着它可以比C风格字符串或`std::string`更有效地处理子字符串，因为它不必创建新的字符串来添加空终止符。使用`std::string_view`的`substr()`的复杂度是常数，这应该与`std::string`的`substr()`版本进行比较，后者的复杂度是线性时间。'
- en: 'There is also a performance win when passing strings to functions. Consider
    the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串传递给函数时也会有性能提升。考虑以下代码：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When passing a string literal to `some_func()`, the compiler needs to construct
    a new `std::string` object to match the type of the argument. However, if we let
    `some_func()` accept a `std::string_view`, there is no longer any need to construct
    a `std::string`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当将字符串字面量传递给`some_func()`时，编译器需要构造一个新的`std::string`对象以匹配参数的类型。然而，如果我们让`some_func()`接受一个`std::string_view`，就不再需要构造一个`std::string`了：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A `std::string_view` instance can be constructed efficiently both from a `std::string`
    and a string literal and is, therefore, a well-suited type for function parameters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`实例可以有效地从`std::string`和字符串字面量构造，并且因此是函数参数的合适类型。'
- en: Eliminating array decay with std::span
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用std::span消除数组衰减
- en: 'When discussing `std::vector` and `std::array` earlier in this chapter, I mentioned
    that array decay (losing the size information of an array) happens with built-in
    arrays when they are passed to a function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面讨论`std::vector`和`std::array`时，我提到了数组衰减（失去数组的大小信息）在将内置数组传递给函数时会发生：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We could get around this problem by adding a size parameter:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加大小参数来解决这个问题：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Although this technically works, passing the correct data to this function
    is both error-prone and tedious, and if `f2()` passes the buffer to other functions,
    it needs to remember to pass the correctly sized variable `n`. This is what the
    call site of `f2()` might look like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在技术上是有效的，但向该函数传递正确的数据既容易出错又繁琐，如果`f2()`将缓冲区传递给其他函数，它需要记住传递正确大小的变量`n`。这是`f2()`的调用点可能会看起来像的：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Array decay is the source of many bound-related bugs, and in situations where
    built-in arrays are used (for one reason or another), `std::span` offers a safer
    way to pass arrays to functions. Since the span holds both the pointer to the
    memory and the size together in one object, we can use it as the single type when
    passing sequences of elements to functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数组衰减是许多与边界相关的错误的根源，在使用内置数组的情况下（出于某种原因），`std::span`提供了一种更安全的方法将数组传递给函数。由于span在一个对象中同时保存了指向内存的指针和大小，因此我们可以将其用作将元素序列传递给函数时的单一类型：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A span is also more convenient to use over a built-in array since it acts more
    like a regular container with support for iterators.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置数组相比，span更方便使用，因为它更像一个具有迭代器支持的常规容器。
- en: 'There are many similarities between `std::string_view` and `std::span` when
    it comes to the data members (pointer and size) and the member functions. But
    there are also some notable differences: the memory pointed to by `std::span`
    is mutable, whereas the `std::string_view` always points to constant memory. `std::string_view`
    also contains string-specific functions such as `hash()` and `substr()`, which
    are naturally not part of `std::span`. Lastly, there is no `compare()` function
    in `std::span`, so it''s not possible to directly use the comparison operators
    on `std::span` objects.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据成员（指针和大小）和成员函数方面，`std::string_view`和`std::span`之间有许多相似之处。但也有一些显着的区别：`std::span`指向的内存是可变的，而`std::string_view`总是指向常量内存。`std::string_view`还包含特定于字符串的函数，如`hash()`和`substr()`，这自然不是`std::span`的一部分。最后，在`std::span`中没有`compare()`函数，因此不可能直接在`std::span`对象上使用比较运算符。
- en: It's now time to highlight a few general points related to performance when
    using data structures from the standard library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候强调一些与使用标准库数据结构相关的一般性能要点了。
- en: Some performance considerations
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些性能考虑
- en: 'We have now covered the three major container categories: sequence containers,
    associative containers, and container adaptors. This section will provide you
    with some general performance advice to consider when working with containers.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了三个主要的容器类别：序列容器、关联容器和容器适配器。本节将为您提供一些在使用容器时考虑的一般性能建议。
- en: Balancing between complexity guarantees and overhead
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在复杂性保证和开销之间取得平衡。
- en: Knowing the time and memory complexity of data structures is important when
    choosing between containers. But it's equally important to remember that each
    container is afflicted with an overhead cost, which has a bigger impact on the
    performance for smaller datasets. The complexity guarantees only become interesting
    for sufficiently large datasets. It's up to you, though, to decide what sufficiently
    large means in your use cases. Here, again, you need to measure your program while
    executing it to gain insights.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择容器时，了解数据结构的时间和内存复杂性是重要的。但同样重要的是要记住，每个容器都带有开销成本，这对于较小的数据集的性能影响更大。复杂性保证只有在足够大的数据集时才变得有趣。在您的用例中，您需要决定足够大的含义。在这里，您需要再次在执行程序时测量以获得见解。
- en: In addition, the fact that computers are equipped with memory caches makes the
    use of data structures that are friendly to the cache more likely to perform better.
    This usually speaks in favor of the `std::vector`, which has a low memory overhead
    and stores its elements contiguously in memory, making access and traversal faster.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，计算机配备了内存缓存的事实使得对缓存友好的数据结构更有可能表现更好。这通常有利于`std::vector`，它的内存开销低，并且将其元素连续存储在内存中，使得访问和遍历更快。
- en: 'The following diagram shows the actual running time of two algorithms. One
    runs in linear time, *O(n)*, and the other runs in logarithmic time, *O(log n)*,
    but with a larger overhead. The logarithmic algorithm is slower than the linear
    time algorithm when the input size is below the marked threshold:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两种算法的实际运行时间。一个以线性时间*O(n)*运行，另一个以对数时间*O(log n)*运行，但开销更大。当输入大小低于标记的阈值时，对数算法比线性时间算法慢：
- en: '![](img/B15619_04_14.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_14.png)'
- en: 'Figure 4.14: For small sizes of n, the linear algorithm, O(n), is faster than
    the algorithm running in O(log n)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：对于较小的n，线性算法O(n)比运行在O(log n)的算法更快
- en: Our next point to keep in mind is more concrete and highlights the importance
    of using the most suitable API functions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要记住的下一个要点更加具体，突出了使用最合适的API函数的重要性。
- en: Knowing and using the appropriate API functions
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解并使用适当的API函数
- en: In C++, there is usually more than one way to do something. The language and
    the library continue to evolve, but very few features are being deprecated. When
    new functions are added to the standard library, we should learn when to use them
    and reflect on what patterns we might have used to compensate for a previously
    missing function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，通常有多种方法可以做某事。语言和库继续发展，但很少有功能被弃用。当新函数添加到标准库中时，我们应该学会何时使用它们，并反思我们可能已经使用的模式，以弥补以前缺失的功能。
- en: 'Here, we will focus on two small, but important, functions that can be found
    in the standard library: `contains()` and `empty()`. Use `contains()` when checking
    whether an element exists in an associated container. Use `empty()` if you want
    to know whether a container has any elements or is empty. Apart from expressing
    the intent more clearly, it also has performance benefits. Checking the size of
    a linked list is an *O(n)* operation, whereas calling `empty()` on a list runs
    in constant time, *O(1)*.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将专注于标准库中的两个小但重要的函数：`contains()`和`empty()`。在检查关联容器中的元素是否存在时使用`contains()`。如果要知道容器是否有任何元素或为空，请使用`empty()`。除了更清晰地表达意图外，它还具有性能优势。检查链表的大小是一个*O(n)*操作，而在列表上调用`empty()`则在常数时间*O(1)*内运行。
- en: 'Before C++20 and the introduction of the `contains()` function, we had to take
    a detour every time we wanted to check for the existence of some value in an associative
    container. You have most likely stumbled upon code that uses various ways to look
    for the existence of an element. Suppose we have a bag-of-words implemented using
    a `std::multiset`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前和`contains()`函数的引入之前，每当我们想要检查关联容器中某个值的存在时，我们都不得不绕个弯。您很可能会遇到使用各种方法来查找元素存在性的代码。假设我们使用`std::multiset`实现了一个单词袋：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we want to know whether some specific word is in our bag-of-words, there
    are numerous ways to go forward. One alternative would be to use `count()`, like
    this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道我们的单词袋中是否有某个特定单词，有许多方法可以继续。一个选择是使用`count()`，就像这样：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It seems reasonable, but it may have a slight overhead since it counts *all*
    elements that match our word. Another alternative is to use `find()`, but it has
    the same overhead since it returns all the matching words, not just the first
    occurrence:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是合理的，但它可能有一些额外开销，因为它计算与我们的单词匹配的*所有*元素。另一种选择是使用`find()`，但它有相同的开销，因为它返回所有匹配的单词，而不仅仅是第一次出现的：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before C++20, the recommended way was to use `lower_bound()`, since it only
    returns the first matching element, like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前，推荐的方法是使用`lower_bound()`，因为它只返回第一个匹配的元素，就像这样：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, with C++20 and the introduction of `contains()`, we can express our intent
    more clearly and also be sure that the library will provide us with the most efficient
    implementation when we only want to check for existence of an element:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着C++20和`contains()`的引入，我们可以更清楚地表达我们的意图，并确保当我们只想检查元素是否存在时，库会为我们提供最有效的实现：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The general rule is that if there is a specific member function or a free function
    designed for a specific container, then use it if it matches your needs. It will
    be efficient, and it will express the intent more clearly. Don't use detours like
    the ones shown earlier just because you haven't learned the full API or because
    you have old habits of doing things in a certain way.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，如果有一个特定的成员函数或为特定容器设计的自由函数，那么如果符合您的需求，请使用它。它将是高效的，并且会更清晰地表达意图。不要像之前展示的那样绕道而行，只是因为您还没有学会完整的API，或者因为您有以某种方式做事的旧习惯。
- en: It should also be said that the zero-overhead principle applies particularly
    well to functions like these, so don't spend time trying to outsmart the library
    implementors by handcrafting your own functions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该说的是，零开销原则特别适用于这样的函数，因此不要浪费时间试图通过手工制作自己的函数来智胜库实现者。
- en: We will now go ahead and look at a lengthier example of how we can reorder data
    in different ways to optimize runtime performance for a specific use case.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续看一个更长的示例，展示我们如何以不同的方式重新排列数据，以优化特定用例的运行时性能。
- en: Parallel arrays
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行数组
- en: 'We will finish this chapter by talking about iterating over elements and exploring
    ways to improve performance when iterating over array-like data structures. I have
    already mentioned two important factors for performance when accessing data: spatial
    locality and temporal locality. When iterating over elements stored contiguously
    in memory, we will increase the probability that the data we need is already cached
    if we manage to keep our objects small, thanks to spatial locality. Obviously,
    this will have a great impact on performance.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过讨论迭代元素和探索在迭代类似数组的数据结构时改善性能的方法来结束本章。我已经提到了访问数据时性能的两个重要因素：空间局部性和时间局部性。当在内存中连续存储的元素上进行迭代时，如果我们设法保持对象小，那么我们将增加所需数据已经被缓存的概率，这要归功于空间局部性。显然，这将对性能产生巨大影响。
- en: Recall the cache-thrashing example, shown at the beginning of this chapter,
    where we iterated over a matrix. It demonstrated that we sometimes need to think
    about the way we access data, even if we have a fairly compact representation
    of the data.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在本章开头展示的缓存抖动示例，我们在矩阵上进行了迭代。它表明有时我们需要考虑访问数据的方式，即使我们对数据有一个相当紧凑的表示。
- en: 'Next, we will compare how long it takes to iterate over objects of different
    sizes. We will start by defining two structs, `SmallObject` and `BigObject`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将比较迭代不同大小对象需要多长时间。我们将首先定义两个结构体，`SmallObject`和`BigObject`：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`SmallObject` and `BigObject` are identical, except for the size of the initial
    data array. Both structs contain an `int` named `score_`, which we initialize
    to a random value just for testing purposes. We can let the compiler tell us the
    size of the objects by using the `sizeof` operator:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`SmallObject`和`BigObject`是相同的，只是初始数据数组的大小不同。这两个结构都包含一个名为`score_`的`int`，我们为测试目的初始化为一个随机值。我们可以使用`sizeof`运算符让编译器告诉我们对象的大小：'
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We need plenty of objects in order to evaluate the performance. Create one
    million objects of each kind:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要大量对象来评估性能。创建每种对象一百万个：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now for the iteration. Let''s say that we want to sum the scores of all the
    objects. Our preference would be to use `std::accumulate()`, which we will cover
    later in the book, but, for now, a simple `for`-loop will do. We write this function
    as a template so that we don''t have to manually write one version for each type
    of object. The function iterates over the objects and sums all the scores:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行迭代。假设我们想要对所有对象的分数进行求和。我们更倾向于使用`std::accumulate()`，这是我们稍后会在书中介绍的，但是，现在，一个简单的`for`循环就可以了。我们将这个函数写成一个模板，这样我们就不必为每种类型的对象手动编写一个版本。该函数迭代对象并对所有分数求和：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we are ready to see how long it takes to sum the scores in the small objects
    compared to the big objects:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备看看在小对象中求和分数需要多长时间，与大对象相比：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To achieve reliable results, we need to repeat the test a couple of times. On
    my computer, it takes about 1 ms to compute the sum of the small objects and 10
    ms to compute the sum of the big objects. This example is similar to the cache
    thrashing example at the beginning of the chapter, and one reason for the big
    difference is, again, because of the way the computer uses the cache hierarchy
    to fetch data from the main memory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得可靠的结果，我们需要多次重复测试。在我的电脑上，计算小对象的总和大约需要1毫秒，计算大对象的总和需要10毫秒。这个例子类似于本章开头的缓存抖动示例，而造成巨大差异的一个原因是，再次是因为计算机使用缓存层次结构从主内存中获取数据的方式。
- en: How can we utilize the fact that it's faster to iterate over collections of
    smaller objects than bigger objects when working with more realistic scenarios
    than the preceding example?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理比前面的例子更现实的场景时，我们如何利用迭代小对象集合比大对象集合更快的事实？
- en: Obviously, we can do our best to keep the size of our classes small, but it's
    often easier said than done. Also, if we are working with an old code base that
    has been growing for some time, the chances are high that we will stumble across
    some really large classes with too many data members and too many responsibilities.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以尽力保持类的大小较小，但这通常说起来容易做起来难。此外，如果我们正在处理一个已经增长了一段时间的旧代码库，很有可能会遇到一些非常大的类，其中包含太多的数据成员和太多的职责。
- en: 'We will now look at a class that represents a user in an online game system
    and see how we can split it into smaller parts. The class has the following data
    members:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一个代表在线游戏系统中用户的类，并看看我们如何将其分成更小的部分。该类具有以下数据成员：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A user has a name that is frequently used and some information for authentication
    that are rarely used. The class also keeps track of which level the player is
    currently playing at. Finally, the `User` struct also knows whether the user is
    currently playing by storing the `is_playing_` boolean.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 用户有一个经常使用的名称和一些很少使用的身份验证信息。该类还跟踪玩家当前所玩的级别。最后，`User`结构还通过存储`is_playing_`布尔值来知道用户当前是否在玩。
- en: 'The `sizeof` operator reports that the `User` class is 128 bytes when compiling
    for a 64-bit architecture. An approximate layout of the data members can be seen
    in the following figure:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof`运算符在64位架构编译时报告`User`类为128字节。数据成员的近似布局如下图所示：'
- en: '![](img/B15619_04_15.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_15.png)'
- en: 'Figure 4.15: Memory layout of the User class'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：User类的内存布局
- en: 'All users are kept in a `std::vector`, and there are two global functions that
    are called very often and need to run quickly: `num_users_at_level()` and `num_playing_users()`.
    Both functions iterate over all users, and therefore we need to make iterations
    over the user vector quick.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用户都保存在`std::vector`中，并且有两个经常调用并且需要快速运行的全局函数：`num_users_at_level()`和`num_playing_users()`。这两个函数都迭代所有用户，因此我们需要快速迭代用户向量。
- en: 'The first function returns the number of users who have reached a certain level:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数返回达到特定级别的用户数量：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second function computes how many users are currently playing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数计算当前有多少用户在玩：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we use the algorithm `std::count_if()` instead of a handwritten loop,
    as we did in `num_users_at_level()`. `std::count_if()` will call the predicate
    we provide for each user in the user vector and return the number of times the
    predicate returns `true`. This is basically what we are doing in the first function
    as well, so we could also have used `std::count_if()` in the first case. Both
    functions run in linear time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用算法`std::count_if()`而不是手写循环，就像我们在`num_users_at_level()`中所做的那样。`std::count_if()`将为用户向量中的每个用户调用我们提供的谓词，并返回谓词返回`true`的次数。这基本上也是我们在第一个函数中所做的，所以我们也可以在第一个情况下使用`std::count_if()`。这两个函数都在线性时间内运行。
- en: 'Calling the two functions with a vector of one million users results in the
    following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个包含一百万个用户的向量调用这两个函数会得到以下输出：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We hypothesize that by making the `User` class smaller, it would be faster
    to iterate over the vector. As mentioned, the password and security data fields
    are rarely used and could be grouped in a separate struct. That would give us
    the following classes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设通过使`User`类更小，迭代向量将更快。如前所述，密码和安全数据字段很少使用，可以分组在一个单独的结构中。这将给我们以下类：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This change decreases the size of the `User` class from 128 bytes to 40 bytes.
    Instead of storing four strings in the `User` class, we use a pointer to refer
    to the new `AuthInfo` object. The following figure shows you how we have split
    up the `User` class into two smaller classes:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变将`User`类的大小从128字节减小到40字节。在`User`类中不再存储四个字符串，而是使用指针来引用新的`AuthInfo`对象。下图显示了我们如何将`User`类分成两个较小的类：
- en: '![](img/B15619_04_16.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_16.png)'
- en: 'Figure 4.16: Memory layout when authentication information is kept in a separate
    class'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：当认证信息保存在单独的类中时的内存布局
- en: This change makes sense from a design perspective too. Keeping the authentication
    data in a separate class increases the cohesion of the `User` class. The `User`
    class contains a pointer to the authentication information. The total amount of
    memory that the user data occupies has not decreased, of course, but the important
    thing right now is to shrink the `User` class in order to speed up the functions
    that iterate over all users.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计的角度来看，这个改变也是有意义的。将认证数据保存在单独的类中增加了`User`类的内聚性。`User`类包含一个指向认证信息的指针。当然，用户数据占用的总内存量并没有减少，但现在重要的是缩小`User`类以加快迭代所有用户的函数。
- en: 'From an optimization point of view, we have to measure this again to verify
    that our hypothesis regarding smaller data is valid. It turns out that both functions
    run more than twice as fast with the smaller `User` class. The output when running
    the modified version is:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 从优化的角度来看，我们必须再次测量以验证我们关于较小数据的假设是否有效。结果表明，使用较小的`User`类时，两个函数的运行速度都提高了两倍以上。修改版本运行时的输出如下：
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we are going to try a more aggressive way of shrinking the amount of
    data we need to iterate through by using **parallel arrays**. First, a warning:
    this is an optimization that, in many cases, has too many drawbacks to be a viable
    alternative. Don''t take this as a general technique and apply it without thinking
    twice. We will come back to the pros and cons of parallel arrays after looking
    at a few examples.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试一种更激进的方式来缩小我们需要迭代的数据量，即使用**并行数组**。首先，警告：在许多情况下，这是一种优化，具有太多的缺点，无法成为可行的替代方案。不要将其视为一般技术，并且不加思考地应用它。在看完几个例子之后，我们将回顾并行数组的优缺点。
- en: By using parallel arrays, we simply split the large structures into smaller
    types, similar to what we did with the authentication information for our `User`
    class. But instead of using pointers to relate objects, we store the smaller structures
    in separate arrays of equal size. The smaller objects in the different arrays
    that share the same index form the complete original object.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并行数组，我们简单地将大型结构拆分为较小的类型，类似于我们为`User`类的认证信息所做的操作。但是，我们不是使用指针来关联对象，而是将较小的结构存储在相等大小的单独数组中。不同数组中的较小对象，它们共享相同的索引，形成完整的原始对象。
- en: 'An example will clarify this technique. The `User` class we have worked with
    consists of 40 bytes. It now only contains a username string, a pointer to the
    authentication information, an integer for the current level, and the `is_playing_`
    boolean. By making the user objects smaller, we saw that the performance improved
    when iterating over the objects. The memory layout of an array of user objects
    would look something like the one shown in the following figure. We will ignore
    memory alignment and padding for now, but will get back to these topics in *Chapter
    7*, *Memory Management*:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将阐明这种技术。我们所使用的`User`类由40个字节组成。现在它只包含一个用户名字符串，一个指向认证信息的指针，一个表示当前级别的整数，以及`is_playing_`布尔值。通过缩小用户对象，我们发现在迭代对象时性能有所提高。用户对象数组的内存布局看起来像下图所示。我们暂时忽略内存对齐和填充，但在*第7章*
    *内存管理*中会回到这些主题：
- en: '![](img/B15619_04_17.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_17.png)'
- en: 'Figure 4.17: User objects stored contiguously in a vector'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：用户对象在向量中连续存储
- en: 'Instead of having one vector with user objects, we can store all the `short`
    levels and `is_playing_` flags in separate vectors. The current level for the
    user at index 0 in the user array is also stored at index 0 in the level array.
    In that way, we can avoid having pointers to the levels, and instead just use
    the index for connecting the data fields. We could do the same thing with the
    boolean `is_playing_` field and end up with three parallel arrays instead of just
    one. The memory layout of the three vectors would look something like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有`short`级别和`is_playing_`标志存储在单独的向量中，而不是一个包含用户对象的向量。用户数组中索引为0的用户的当前级别也存储在级别数组的索引0处。这样，我们可以避免使用级别的指针，而是只使用索引来连接数据字段。我们也可以对布尔`is_playing_`字段做同样的操作，最终得到三个并行数组，而不是一个。这三个向量的内存布局看起来像这样：
- en: '![](img/B15619_04_18.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_04_18.png)'
- en: 'Figure 4.18: Memory layout when using three parallel arrays'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：使用三个并行数组时的内存布局
- en: 'We are using three parallel arrays to make iterations over one particular field
    quickly. The `num_users_at_level()` function can now compute the number of users
    at a specific level by only using the level array. The implementation is now simply
    a wrapper around `std::count()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个并行数组来快速迭代一个特定字段。`num_users_at_level()`函数现在可以通过仅使用级别数组来计算特定级别的用户数量。现在的实现只是`std::count()`的一个包装器：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Likewise, the `num_playing_users()` function only needs to iterate over the
    vector of booleans to determine the number of playing users. Again, we use `std::count()`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`num_playing_users()`函数只需要迭代布尔向量来确定正在玩游戏的用户数量。同样，我们使用`std::count()`：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With parallel arrays, we don''t have to use the user array at all. The amount
    of memory occupied by the extracted arrays is substantially smaller than the user
    array, so let''s check whether we have improved on performance when running the functions
    on one million users again:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行数组，我们根本不需要使用用户数组。提取数组所占用的内存量远远小于用户数组，因此让我们再次检查在一百万用户上运行这些函数时是否提高了性能：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Counting the number of users at a certain level only takes about 0.7 ms when
    using the array of integers. To recap, the initial version using the `User` class
    with a size of 128 bytes took around 11 ms. The smaller `User` class executed
    in 4 ms, and now, by only using the `levels` array, we are down to 0.7 ms. This
    is quite a dramatic change.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数数组计算特定级别的用户数量只需要大约0.7毫秒。回顾一下，初始版本使用128字节大小的`User`类大约需要11毫秒。较小的`User`类执行时间为4毫秒，现在，只使用`levels`数组，我们的执行时间降至0.7毫秒。这是一个相当大的变化。
- en: For the second function, `num_playing_users()`, the change is even bigger—it
    only takes around 0.03 ms to count how many users are currently playing. The reason
    why it can be so fast is thanks to a data structure called **bit arrays**. It
    turns out that `std::vector<bool>` is not at all a standard vector of C++ `bool`
    objects. Instead, internally, it's a bit array. Operations such as `count()` and
    `find()` can be optimized very efficiently in a bit array since it can process
    64 bits at a time (on a 64-bit machine), or possibly even more by using SIMD registers.
    The future of `std::vector<bool>` is unclear, and it might be deprecated soon
    in favor of the fixed-size `std::bitset` and a new dynamically sized bitset. There
    is already a version in Boost named `boost::dynamic_bitset`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个函数`num_playing_users()`来说，改变更大——只需要大约0.03毫秒就能计算出当前正在玩游戏的用户数量。之所以能够如此快速，是因为有一种叫做**位数组**的数据结构。原来`std::vector<bool>`并不是标准的C++
    `bool`对象的向量。在内部，它实际上是一个位数组。在位数组中，诸如`count()`和`find()`等操作可以被高效地优化，因为它可以一次处理64位（在64位机器上），甚至可能通过使用SIMD寄存器处理更多位。`std::vector<bool>`的未来尚不明朗，很可能会很快被固定大小的`std::bitset`和新的动态大小的bitset所取代。Boost中已经有了一个名为`boost::dynamic_bitset`的版本。
- en: This is all fantastic, but I warned you about some drawbacks. First of all,
    extracting the fields from the classes where they actually belong will have a
    big impact on the structure of the code. In some cases, it makes perfect sense
    to split large classes into smaller parts, but in other cases, it totally breaks
    encapsulation and exposes data that could have been hidden behind interfaces with
    higher abstraction.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很棒，但我警告过您会有一些缺点。首先，从类中提取字段实际上会对代码结构产生重大影响。在某些情况下，将大类拆分为较小的部分是完全合理的，但在其他情况下，它完全破坏了封装性，并暴露了本应该隐藏在更高抽象接口后面的数据。
- en: It's also cumbersome to ensure that the arrays are in sync, such that we always
    need to ensure that fields that comprise one object are stored at the same index
    in all arrays. Implicit relationships like this can be hard to maintain and are
    error-prone.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数组同步也很麻烦，因此我们总是需要确保组成一个对象的字段在所有数组中的相同索引处存储。这样的隐式关系很难维护，也容易出错。
- en: The last drawback is actually related to performance. In the preceding example,
    you saw that for algorithms that iterate over one field at a time, there was a
    big performance gain. However, if we have an algorithm that would need to access
    multiple fields that have been extracted into different arrays, it would be substantially
    slower than iterating over one array with bigger objects.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个缺点实际上与性能有关。在前面的例子中，您看到对于逐个字段迭代的算法，性能有了很大的提升。然而，如果我们有一个需要访问已提取到不同数组中的多个字段的算法，它将比在一个包含更大对象的数组上迭代要慢得多。
- en: So, as is always the case when working with performance, there is nothing that
    comes without a cost, and the cost for exposing data and splitting one simple
    array into multiple arrays may or may not be too high. It all depends on the scenario
    you are facing and what performance gain you encounter after measuring. Don't
    consider parallel arrays before you actually face a real performance issue. Always
    opt for sound design principles first, and favor explicit ways of expressing relationships
    between objects rather than implicit ones.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像在处理性能时一样，没有什么是不需要付出代价的，暴露数据并将一个简单的数组拆分为多个数组的代价可能太高，也可能不太高。这一切取决于您所面临的情况，以及在测量后您所遇到的性能收益。在真正面临性能问题之前，不要考虑并行数组。始终优先考虑良好的设计原则，并倾向于显式地表达对象之间的关系，而不是隐式的。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the container types from the standard library were introduced.
    You learned that the way we structure data has a big impact on how efficiently
    we can perform certain operations on a collection of objects. The asymptotic complexity
    specifications of the standard library containers are key factors to consider
    when choosing among the different data structures.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，介绍了标准库中的容器类型。您了解到我们如何组织数据对于我们能够高效执行集合对象上的某些操作有着重大影响。标准库容器的渐近复杂度规范是在选择不同数据结构时需要考虑的关键因素。
- en: In addition, you learned how the cache hierarchy in modern processors impacts
    the way we need to organize data for efficient access to memory. The importance
    of utilizing the cache levels efficiently cannot be stressed enough. This is one
    of the reasons why containers that keep their elements contiguously in memory
    have become the most used, such as `std::vector` and `std::string`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您了解到现代处理器中的缓存层次结构如何影响我们需要如何组织数据以实现对内存的高效访问。高效利用缓存层次结构的重要性不言而喻。这也是为什么保持元素在内存中连续的容器，如`std::vector`和`std::string`，已经成为最常用的容器之一的原因。
- en: In the next chapter, we will look at how we can use iterators and algorithms
    to operate on containers efficiently.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用迭代器和算法来高效地操作容器。
