- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Optimizing and Maintaining CMake Projects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化和维护CMake项目
- en: Software projects tend to live for a long time, and for some, it’s not unheard
    of for them to be under more or less active development for a decade or more.
    But even if projects do not live that long, they tend to grow over time and attract
    certain clutter and legacy artifacts. Often, maintaining a project does not just
    mean refactoring code or adding a feature once in a while but also keeping build
    information and dependencies up to date.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件项目通常会存在很长时间，对于某些项目来说，持续开发十年甚至更久并不罕见。但即使项目没有存在那么久，它们也会随着时间的推移而增长，并吸引某些杂乱和遗留的工件。通常，维护项目不仅仅是重构代码或偶尔添加功能，还包括保持构建信息和依赖项的最新状态。
- en: As projects grow in complexity, build times often increase dramatically to the
    point that development might get tedious because of the long wait times. Long
    build times are not just inconvenient; they might also encourage developers to
    take shortcuts because they make trying things out hard. It is hard to try out
    something new if each build takes hours to complete and if each push to the CI/CD
    pipeline takes hours to return, which does not help either.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目复杂度的增加，构建时间往往会大幅增加，甚至到达开发变得乏味的程度，因为需要等待很长时间。长时间的构建不仅不方便，还可能促使开发人员采取捷径，因为它使得尝试新事物变得困难。如果每次构建需要数小时才能完成，而且每次推送到CI/CD管道需要数小时才能返回，这种情况就更糟糕了。
- en: Apart from choosing a good, modular project structure to increase the effectiveness
    of incremental builds, CMake has a few features to help with profiling and optimizing
    build times. And if CMake alone is not enough, using technologies such as **compiler
    cache** (**ccache**) for caching build results or precompiled headers can further
    help speed up incremental builds.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择一个好的模块化项目结构来提高增量构建的有效性外，CMake还提供了一些功能来帮助分析性能和优化构建时间。如果仅使用CMake还不够，使用**编译器缓存**
    (**ccache**) 等技术来缓存构建结果或预编译头文件，进一步加速增量构建。
- en: Optimizing build times can yield good results, improve the daily life of developers
    considerably, and even be a cost-saving factor because a CI/CD pipeline might
    need fewer resources to build projects. However, there are pitfalls that heavily
    optimized systems may become brittle and break down more easily and that, at one
    point, optimizing for build time might be a trade-off with easy project maintenance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 优化构建时间可以带来良好的效果，显著改善开发人员的日常工作，甚至可能成为节省成本的因素，因为CI/CD管道可能需要更少的资源来构建项目。然而，也有一些陷阱，过度优化的系统可能会变得脆弱，更容易崩溃，并且在某些情况下，为了优化构建时间，可能会牺牲项目的易维护性。
- en: 'In this chapter, we will cover a few general tips for maintaining projects
    and structuring them to keep the maintenance effort in check. Then, we will dive
    into analyzing build performance and see how builds can be sped up. The following
    topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些关于如何维护项目并结构化它们以便保持维护工作量的通用建议。然后，我们将深入分析构建性能，并看看如何加速构建。本章将涵盖以下主题：
- en: Keeping a CMake project maintainable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持CMake项目的可维护性
- en: Profiling a CMake build
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake构建的性能分析
- en: Optimizing build performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化构建性能
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, all examples are tested with CMake 3.21 and
    run on either of the following compilers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，所有示例都使用CMake 3.21进行了测试，并运行在以下任一编译器上：
- en: '**GNU Compiler Collection** (**GCC**) 9 or newer'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU编译器集合** (**GCC**) 9或更新版本'
- en: Clang 12 or newer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12或更新版本
- en: '**Microsoft Visual C++** (**MSVC**) 19 or newer'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Visual C++** (**MSVC**) 19或更新版本'
- en: For viewing profiling data, a third-party viewer for Google trace format is
    needed; arguably, the most widely used is Google Chrome.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看性能数据，需要第三方查看器来查看Google跟踪格式的数据；可以说，最广泛使用的是Google Chrome。
- en: Examples using `ccache` are tested with Clang and GCC but not with MSVC. To
    obtain `ccache`, use either the package manager of your operating system or obtain
    it from [https://ccache.dev/](https://ccache.dev/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ccache`的示例已经在Clang和GCC上进行了测试，但没有在MSVC上测试过。要获得`ccache`，可以使用操作系统的包管理器，或从[https://ccache.dev/](https://ccache.dev/)获取。
- en: All examples are available at [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例可在[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/)查看。
- en: Keeping a CMake project maintainable
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持CMake项目的可维护性
- en: When maintaining a CMake project over a long time, there are often a few tasks
    that regularly come up. There are the usual things, such as new files being added
    to the project or versions of dependencies increasing, which are usually relatively
    trivial to handle with CMake. Then, there are things such as adding new toolchains
    or platforms for cross-compiling, and lastly, there are updates to CMake itself,
    when new features such as presets are available.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间维护 CMake 项目时，通常会出现一些经常性的任务。有一些常见的事情，比如新文件被添加到项目中，或者依赖版本的增加，这些通常通过 CMake
    处理起来比较琐碎。接着，有些事情如添加新的工具链或跨平台编译，最后是 CMake 本身的更新，当新功能（如预设）可用时。
- en: Regularly updating CMake and making use of new features can help keep projects
    maintainable. While it is often not practical to update every single new version,
    checking for new big features of CMake and using them when they are released may
    make projects easier to maintain. For example, the introduction of CMake presets
    in version 3.19 of CMake is such a feature that has the potential to make many
    complicated `CMakeLists.txt` files much simpler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新 CMake 并利用新功能有助于保持项目的可维护性。虽然通常不实际更新每一个新版本，但检查 CMake 的新功能并在其发布时使用它们，可能会使项目更易于维护。例如，CMake
    3.19 版本引入的 CMake 预设就是这样一个具有潜力的功能，它可以使许多复杂的`CMakeLists.txt`文件变得更加简单。
- en: Keeping dependencies up to date and under control is often a task that keeps
    maintainers busy. Here, using a consistent concept for handling dependencies will
    make maintaining a project easier. In that regard, we recommend using package
    managers, as described in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084), *Integrating
    Third-Party Libraries and Dependency Management*, for any but the smallest project.
    As package managers are designed to shift the complexity of managing dependencies
    to the package manager instead of exposing it to the maintainer, they often have
    great potential to make maintainers’ lives much easier.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 保持依赖关系的更新和控制通常是维护人员忙碌的任务。在这方面，使用一致的依赖处理概念将使得维护项目变得更加容易。在这方面，我们建议使用包管理器，正如在[*第5章*](B30947_05.xhtml#_idTextAnchor084)中所描述的，*集成第三方库与依赖管理*，对于任何项目（除非是非常小的项目）。由于包管理器旨在将管理依赖关系的复杂性转移到包管理器上，而不是暴露给维护人员，它们通常具有使维护人员的工作更轻松的巨大潜力。
- en: At the root of making a project maintainable is choosing an effective project
    structure so that things are found easily and can be improved independently from
    each other. The exact structure to choose depends heavily on the context and size
    of the project, so what works for one project might not work for another.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 保持项目可维护性的核心是选择有效的项目结构，使得各部分可以轻松找到，并且能够相互独立地改进。具体选择哪种结构，往往取决于项目的背景和规模，因此对一个项目有效的结构可能不适用于另一个项目。
- en: 'The biggest gain to keeping large projects maintainable is to use a project
    structure that fits the need. While the details of project organization depend
    on the actual situation a project is developed in, there are a few good practices
    that will help keep an overview of the project. Keeping a project maintainable
    starts with the `CMakeLists.txt` root of a project. For large projects, the `CMakeLists.txt`
    root should handle the following things:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保持大型项目可维护性的最大收益是使用适合需求的项目结构。虽然项目组织的细节取决于项目开发的实际情况，但有一些良好的实践可以帮助保持项目的概览。保持项目可维护性从项目的`CMakeLists.txt`根目录开始。对于大型项目，`CMakeLists.txt`根目录应处理以下内容：
- en: The basic setup of the whole project, such as handling the `project()` call,
    fetching toolchains, supporting programs, and helper repositories. This also includes
    setting language standards, search behavior, and project-wide setting of compiler
    flags and search paths.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个项目的基本设置，例如处理`project()`调用、获取工具链、支持程序和帮助库。这还包括设置语言标准、搜索行为以及项目范围的编译器标志和搜索路径。
- en: Handling cross-cutting dependencies, especially large frameworks such as Boost
    and Qt, should be included at the top level. Depending on the complexity of the
    dependencies, creating and including a subdirectory with its own `CMakeLists.txt`
    file to handle acquiring the dependencies might help keep the project maintainable.
    Using `add_subdirectory` is recommended over using `include` for including dependencies
    because, this way, any temporary variables used for searching dependencies are
    scoped to the subdirectory unless they are explicitly marked as cache variables.
    If there are more than just a few build targets, moving them to their own subdirectories
    and including them with `add_subdirectory()` will help to keep individual files
    small and self-contained. Aiming for a design principle of loose coupling and
    high internal cohesion will make libraries and executables easier to maintain
    independently. The file and project structure should reflect that, which might
    mean that each library and executable in a project gets its own `CMakeLists.txt`
    file.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理横向依赖，特别是像Boost和Qt这样的大型框架，应当放在项目的顶层。根据依赖关系的复杂性，创建并包含一个独立的`CMakeLists.txt`文件来处理获取这些依赖关系，可能有助于保持项目的可维护性。建议使用`add_subdirectory`来包含依赖项，而不是使用`include`，因为这样，任何用于查找依赖项的临时变量的作用域仅限于该子目录，除非它们显式标记为缓存变量。如果构建目标不止几个，将它们移到自己的子目录并使用`add_subdirectory()`来包含它们，将有助于保持单个文件小且自包含。追求松耦合和高内聚性的设计原则，将使得库和可执行文件更容易独立维护。文件和项目结构应反映这一点，这可能意味着项目中的每个库和可执行文件都需要拥有自己的`CMakeLists.txt`文件。
- en: Whether unit tests are kept close to the units that they test against or as
    a subfolder of a `tests` folder on the root level is a matter of personal preference.
    Keeping tests in their own subdirectory with their own `CMakeLists.txt` file makes
    it easier to handle test-specific dependencies and compiler settings.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试是保持在与其测试对象接近的位置，还是作为根目录下`tests`文件夹的子文件夹，这取决于个人偏好。将测试保持在独立的子目录中，并为其设置自己的`CMakeLists.txt`文件，可以更容易地处理与测试相关的依赖项和编译器设置。
- en: Packaging and installation instructions for the project should be centralized
    and included at the top level of the project. If the installation instructions
    and packaging instructions are too large, they can be put in their own `CMakeLists.txt`
    file and included from the `CMakeLists.txt` root.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目的打包和安装说明应集中在项目的顶层。如果安装说明和打包说明过于庞大，可以将它们放入单独的`CMakeLists.txt`文件中，并从根目录的`CMakeLists.txt`文件中引用。
- en: Structuring a project in this way will simplify the navigation inside the project
    and will help to avoid unnecessary code duplication in CMake files, especially
    when projects get larger over time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式组织项目结构，将简化项目内部的导航，并有助于避免在CMake文件中不必要的代码重复，特别是当项目随着时间推移变得更大时。
- en: A good project setup might make the difference between fighting daily with the
    build system and running smoothly. Using the techniques and practices from this
    book will help to make a CMake project maintainable. Having a clearly defined
    build environment by using CMake presets and build containers or sysroots, as
    described in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible
    Build* *Environments*, and [*Chapter 12*](B30947_12.xhtml#_idTextAnchor182), *Cross-Platform
    Compiling and Custom Toolchains*, will help to make the build more portable between
    developers and the CI system. Last but not least, organizing your custom CMake
    code into macros and functions, as described in [*Chapter 13*](B30947_13.xhtml#_idTextAnchor198),
    *Reusing* *CMake Code*, will help to avoid redundancy and duplication.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的项目设置可能决定了是否每天与构建系统作斗争，或者能够顺利运行。使用本书中的技术和实践将有助于使CMake项目具有可维护性。通过使用CMake预设和构建容器或系统根目录（sysroots），如在[*第9章*](B30947_09.xhtml#_idTextAnchor146)中所述，*创建可重现的构建*
    *环境*，以及[*第12章*](B30947_12.xhtml#_idTextAnchor182)中所述，*跨平台编译和自定义工具链*，将有助于使构建在开发者和CI系统之间更具可移植性。最后但同样重要的是，按照[*第13章*](B30947_13.xhtml#_idTextAnchor198)中所述，*重用*
    *CMake代码*，将自定义CMake代码组织成宏和函数，将有助于避免冗余和重复。
- en: Apart from the complexity of CMake files, longer configuration and build times
    are often another concern when projects grow bigger. To manage those growing build
    and configuration times, CMake offers a few features to optimize them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CMake文件的复杂性之外，随着项目规模的增长，较长的配置和构建时间往往是另一个问题。为了管理这些日益增长的构建和配置时间，CMake提供了一些功能来优化它们。
- en: Profiling a CMake build
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake构建的性能分析
- en: 'When CMake projects get big, configuring them might take quite a long time,
    especially if there is external content loaded or if there are lots of checks
    done for toolchain features. A first step to optimize this is to check what part
    of the configuration process takes up how much time. Since version 3.18, CMake
    has included command-line options to produce nice profiling graphs to investigate
    where time is spent during configuration. By adding the `--profiling-output` and
    `--profiling-format` profiling flags, CMake will create profiling output. At the
    time of writing this book, only the Google trace format for output format is supported.
    Despite this, the format and the file need to be specified to create profiling
    information. A call to CMake to create a profiling graph could look like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CMake 项目变得庞大时，配置它们可能需要相当长的时间，尤其是如果加载了外部内容或进行了大量的工具链特性检查。优化的第一步是检查配置过程中哪些部分花费了多少时间。从版本
    3.18 开始，CMake 包含了命令行选项来生成精美的分析图，以便调查配置过程中时间的分布。通过添加 `--profiling-output` 和 `--profiling-format`
    分析标志，CMake 将生成分析输出。写这本书时，仅支持 Google 跟踪格式作为输出格式。尽管如此，仍然需要指定格式和文件来生成分析信息。生成分析图的
    CMake 调用可以像这样：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will write the profiling output to the `profiling.json` file in the current
    directory. The output file can be viewed with Google Chrome by typing `about://tracing`
    into the address bar. A tracing output for a cached build of the GitHub project
    to this book could look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把分析输出写入当前目录中的 `profiling.json` 文件。可以通过在地址栏中输入 `about://tracing`，使用 Google
    Chrome 查看输出文件。针对本书中的 GitHub 项目的缓存构建，跟踪输出可能如下所示：
- en: '![Figure 14.1 – An example profiling graph for a CMake project displayed in
    Google Chrome](img/B30947_14_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 在 Google Chrome 中显示的 CMake 项目示例分析图](img/B30947_14_01.jpg)'
- en: Figure 14.1 – An example profiling graph for a CMake project displayed in Google
    Chrome
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 在 Google Chrome 中显示的 CMake 项目示例分析图
- en: In the preceding figure, it is pretty obvious that there is one call to `add_subdirectory`
    that takes up the majority of time when configuring the project. In this case,
    this is the `chapter5` subdirectory, taking a bit more than 3 seconds to complete.
    By drilling down a bit, it becomes apparent that these are examples that use the
    Conan package manager, namely the two calls to `conan_cmake_install` that make
    the configuration relatively expensive. In this case, centralizing the calls to
    Conan in a directory further up would cut the time CMake would take for a configuration
    run in half.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，很明显有一个 `add_subdirectory` 调用占用了大部分配置项目时的时间。在这种情况下，这是 `chapter5` 子目录，花费了超过
    3 秒的时间来完成。通过进一步深入分析，很明显这些是使用 Conan 包管理器的示例，特别是两个 `conan_cmake_install` 调用，使得配置过程相对较慢。在这种情况下，将对
    Conan 的调用集中在更上层的目录中，将使得 CMake 配置运行的时间缩短一半。
- en: In order to correctly interpret the profiling output, it helps to compare different
    runs of CMake with each other, especially comparing a CMake run on a clean cache
    with one that makes use of cached information. If only the CMake runs on a clean
    cache take their time, but the incremental runs are fast enough, this might still
    be acceptable for the developers. However, if the incremental CMake runs take
    their time as well, this might be more problematic. Profiling them may help find
    out if there are unnecessary steps done for each configuration run.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确解释分析输出，将不同的 CMake 运行进行比较是很有帮助的，特别是将清理缓存的 CMake 运行与利用缓存信息的运行进行比较。如果只有清理缓存的
    CMake 运行花费了较长时间，但增量运行足够快，对于开发人员来说这可能仍然是可以接受的。然而，如果增量的 CMake 运行也花费了较长时间，这可能会更成问题。对其进行分析可能有助于找出每次配置运行中是否有不必要的步骤。
- en: Fixing slow build steps will depend on the concrete situation, but common culprits
    for long configuration times are files that are downloaded each time because there
    is no check whether the file exists in the first place. Analyzing profiling calls
    might often show calls such as `execute_process` or `try_compile` consuming lots
    of execution time. The most obvious *fix* would be to try to get rid of these
    calls, but often these calls are there for a reason. More often, following up
    the call stack leading to the commands might reveal opportunities to reduce how
    often these functions will be called. Maybe the results can be cached, or maybe
    files created with `execute_process` do not need to be generated each time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 修复慢构建步骤将取决于具体情况，但长时间配置的常见原因是每次都会下载的文件，因为没有检查文件是否存在。分析分析调用通常会显示像`execute_process`或`try_compile`这样的调用占用了大量执行时间。最明显的*修复*方法是尝试去除这些调用，但通常这些调用是有原因的。更常见的是，跟踪导致这些命令的调用堆栈可能会揭示减少这些函数调用频率的机会。也许结果可以缓存，或者使用`execute_process`创建的文件不需要每次都生成。
- en: 'Especially when cross-compiling, `find_` commands might also take up a lot
    of time. Changing the search order by changing the various `CMAKE_FIND_ROOT_PATH_MODE_`
    variables, as described in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084), *Integrating
    Third-Party Libraries and Dependency Management*, might help a bit here. For a
    more thorough analysis of why `find_` calls take up too much time, CMake can be
    told to enable debug output for them by setting the `CMAKE_FIND_DEBUG_MODE` variable
    to `true`. As this will print out a lot of information, it is a good idea to enable
    this only for certain calls, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其在交叉编译时，`find_`命令可能也会占用大量时间。通过更改不同的`CMAKE_FIND_ROOT_PATH_MODE_`变量来改变搜索顺序，正如在[*第5章*](B30947_05.xhtml#_idTextAnchor084)《集成第三方库与依赖管理》中所述，可能在这里有一点帮助。为了更深入地分析为何`find_`调用占用过多时间，可以通过将`CMAKE_FIND_DEBUG_MODE`变量设置为`true`来启用调试输出。由于这会输出大量信息，因此最好只为特定的调用启用此功能，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The profiling options of CMake allow profiling the configuration stage of the
    build process; profiling the actual compilation and time have to be done by using
    the respective generator. Most generators either support some profiling option
    or log the needed information. For Visual Studio generators, the `vcperf` tool
    ([https://github.com/microsoft/vcperf](https://github.com/microsoft/vcperf)) will
    give a lot of insights. When using Ninja, the `.ninja_log` file can be converted
    to Google trace format using the `ninjatracing` tool ([https://github.com/nico/ninjatracing](https://github.com/nico/ninjatracing)).
    While CMake does not offer support to profile the actual compiling and linking
    of software, it does offer ways to improve build times, which we will see in the
    next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的分析选项允许对构建过程的配置阶段进行分析；实际的编译和时间分析必须使用相应的生成器来完成。大多数生成器都支持某些分析选项或记录所需的信息。对于Visual
    Studio生成器，`vcperf`工具（[https://github.com/microsoft/vcperf](https://github.com/microsoft/vcperf)）将提供大量见解。在使用Ninja时，可以使用`ninjatracing`工具（[https://github.com/nico/ninjatracing](https://github.com/nico/ninjatracing)）将`.ninja_log`文件转换为Google跟踪格式。虽然CMake不提供分析实际编译和链接的软件的支持，但它确实提供了改进构建时间的方法，这将在下一节中看到。
- en: Optimizing build performance
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化构建性能
- en: Apart from raw compilation time, the main driver for long build times in C++
    projects is often unnecessary dependencies between targets or files. If targets
    have unnecessary linking requirements between each other, the build system will
    be limited in executing build tasks in parallel, and some of the targets will
    be frequently relinked. Creating a dependency graph of the targets, as described
    in [*Chapter 6*](B30947_06.xhtml#_idTextAnchor101), *Automatically Generating
    Documentation*, will help identify dependencies. If the resulting graph looks
    more like a snarl of rope than a tree, optimizing and refactoring the project
    structure might bring a lot of performance gains. Tools such as *include what
    you use* and *link what you use*, as described in [*Chapter 7*](B30947_07.xhtml#_idTextAnchor113),
    *Seamlessly Integrating Code Quality Tools with CMake*, may further help identify
    unnecessary dependencies. Another common theme is C or C++ projects that expose
    too much private information in public headers, often causing frequent rebuilds
    and reducing the effectiveness of incremental builds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了纯编译时间外，C++项目中构建时间长的主要原因通常是目标或文件之间不必要的依赖。如果目标之间存在不必要的链接要求，构建系统在执行构建任务时将无法并行化，一些目标将被频繁地重新链接。如在[*第6章*](B30947_06.xhtml#_idTextAnchor101)《自动生成文档》中所述，创建目标的依赖图将有助于识别这些依赖关系。如果生成的图看起来更像是绳结而不是树形结构，那么优化和重构项目结构可能会带来大量性能提升。如在[*第7章*](B30947_07.xhtml#_idTextAnchor113)《无缝集成代码质量工具与CMake》中所述，使用*include
    what you use*和*link what you use*等工具，可能进一步帮助识别不必要的依赖关系。另一个常见的问题是C或C++项目在公共头文件中暴露过多的私有信息，这通常导致频繁重建，降低增量构建的效率。
- en: A relatively safe option to bring performance improvements is to set the `CMAKE_OPTIMIZE_DEPENDENCIES`
    cache variable to `true`. This will cause CMake to remove some dependencies for
    static or object libraries at generation time if they are not needed. If you work
    with a lot of static or object libraries and a deep dependency graph, this might
    already produce some gains regarding compile time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相对安全的选项来提升性能是将`CMAKE_OPTIMIZE_DEPENDENCIES`缓存变量设置为`true`。这将导致CMake在生成时移除一些静态或目标库的依赖，如果这些依赖不再需要。如果你处理大量静态或目标库，并且依赖关系图很深，这可能会在编译时间上带来一些收益。
- en: Generally speaking, optimizing the project structure and modularizing the code
    will often have a greater effect on build performance than optimization of the
    code. On average, compiling and linking a project that consists of many small
    files takes longer than projects consisting of a few large files. CMake can help
    improve build performance with so-called unity builds, which merge several files
    into a larger file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，优化项目结构并将代码模块化，往往比代码优化对构建性能的影响更大。平均而言，编译和链接由许多小文件组成的项目，比由少数大文件组成的项目所需时间更长。CMake可以通过所谓的统一构建来帮助提高构建性能，统一构建将多个文件合并成一个更大的文件。
- en: Using unity builds
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用统一构建
- en: Unity builds that CMake can support may help with build performance by concatenating
    multiple files into larger files, thus reducing the number of files to be compiled.
    This might bring a decrease in build time because `include` files are processed
    only once instead of for every smaller file. So, this will have the biggest effect
    if many of the files include the same header files and if the header files are
    heavy to digest by the compiler. Generally speaking, these are headers containing
    lots of macros or template metaprogramming. Creating a unity build may improve
    build time significantly, especially when using large header-only libraries, such
    as the Eigen math library. On the other hand, unity builds have the downside that
    incremental builds might take longer as, usually, larger chunks of the project
    have to be recompiled and linked when only a single file changes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CMake支持的统一构建可以通过将多个文件合并成较大的文件来帮助提高构建性能，从而减少需要编译的文件数量。这可能会减少构建时间，因为`include`文件只会处理一次，而不是每个小文件都处理一次。因此，如果许多文件包含相同的头文件，且这些头文件对编译器来说比较重（例如包含大量宏或模板元编程），这一做法会产生最大的效果。创建统一构建可能会显著提高构建时间，尤其是在使用大型头文件库（如Eigen数学库）时。另一方面，统一构建的缺点是增量构建可能会变得更慢，因为通常需要重新编译和链接更大的项目部分，即使只是单个文件发生了变化。
- en: By setting the `CMAKE_UNITY_BUILD` cache variable to `true`, CMake will concatenate
    the sources into one or more unity sources and build them instead of the original
    files. The generated files are along the `unity_<lang>_<Nr>.<lang>` pattern and
    are located in a folder called `Unity` in the build directory for the project.
    Unity files for C++ would be named `unity_0_cxx.cxx`, `unity_1_cxx.cxx`, and so
    on, where C files are named `unity_0_c.c` and so on. This variable is not intended
    to be set in the `CMakeLists.txt` file but rather to be passed over the command
    line or a preset, as it might depend on the context of whether a unity build is
    needed or not. CMake will decide on the language of the project if merging files
    is needed and possible. For instance, as header files are not compiled, they will
    not be added to unity sources. For C and C++, this works quite well; for other
    languages, this might not work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`CMAKE_UNITY_BUILD`缓存变量设置为`true`，CMake会将源文件合并成一个或多个unity源文件并进行构建，而不是使用原始文件。生成的文件遵循`unity_<lang>_<Nr>.<lang>`的命名模式，并位于构建目录中的`Unity`文件夹内。例如，C++的unity文件会命名为`unity_0_cxx.cxx`、`unity_1_cxx.cxx`等，C语言文件则命名为`unity_0_c.c`等。这个变量不应该在`CMakeLists.txt`文件中设置，而是通过命令行或预设传递，因为是否需要unity构建可能取决于上下文。CMake会根据需要和可能性决定项目的语言。如果需要合并文件，CMake会判断是否可以合并。比如，头文件不会被编译，因此不会被添加到unity源文件中。对于C和C++来说，这种方法效果良好，但对于其他语言，可能无法正常工作。
- en: 'Unity builds work best for projects that consist of many small files. If the
    source files are already large on their own, unity builds might run the risk of
    running out of memory when compiling. If only a few files are problematic in this
    regard, they can be excluded from the unity build by setting the `SKIP_UNITY_BUILD_INCLUSION`
    property on the source files, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unity构建最适用于由许多小文件组成的项目。如果源文件本身已经很大，unity构建可能会面临编译时内存不足的风险。如果只有少数文件在这方面有问题，可以通过在源文件上设置`SKIP_UNITY_BUILD_INCLUSION`属性来将它们从unity构建中排除，像这样：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the example, the `eratosthenes.cpp` file would be excluded from the unity
    build, while `main.cpp` and `fibonacci.cpp` would be included in a single compilation
    unit. If the preceding project is configured, the `unit_0_cxx.cxx` file would
    contain something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`eratosthenes.cpp`文件将被排除在unity构建之外，而`main.cpp`和`fibonacci.cpp`将包含在一个编译单元中。如果之前的项目已配置，`unit_0_cxx.cxx`文件将包含类似以下内容：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the original source files are only included in the unity file, not
    copied into the file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，原始源文件只会包含在unity文件中，而不会被复制到文件中。
- en: Since CMake 3.18, unity builds support two modes that are controlled with the
    `CMAKE_UNITY_BUILD_MODE` variable or the `UNITY_BUILD_MODE` target property. The
    mode can either be `BATCH` or `GROUP`, with `BATCH` being the default if not specified.
    In `BATCH` mode, CMake determines which files are grouped together by default,
    in the order in which they were added to the target. All files of a target will
    be assigned to batches unless they are explicitly excluded. In `GROUP` mode, each
    target has to specify explicitly how the files are grouped together. Files not
    assigned to a group will be compiled individually. While `GROUP` mode offers more
    precise control, using `BATCH` mode is often the preferred one, as it has significantly
    lower maintenance overhead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从CMake 3.18开始，unity构建支持两种模式，可以通过`CMAKE_UNITY_BUILD_MODE`变量或`UNITY_BUILD_MODE`目标属性来控制。模式可以是`BATCH`或`GROUP`，如果未指定，则默认使用`BATCH`模式。在`BATCH`模式下，CMake会默认按文件添加到目标的顺序来决定哪些文件组合在一起。除非显式排除，否则所有目标文件都会被分配到批处理中。在`GROUP`模式下，每个目标必须明确指定文件如何分组。未分配到任何组的文件将单独编译。虽然`GROUP`模式提供了更精确的控制，但通常推荐使用`BATCH`模式，因为它的维护开销要小得多。
- en: By default, CMake will collect the files in batches of eight files when the
    `UNITY_BUILD_MODE` property is set to `BATCH`. By setting the `UNITY_BUILD_BATCH_SIZE`
    property of a target, this can be changed. To set the batch size globally, the
    `CMAKE_UNITY_BUILD_BATCH_SIZE` cache variable is used. The batch size should be
    selected carefully as setting it too low will bring little gain in performance,
    while setting it too high might cause the compiler to use too much memory or the
    compilation unit to hit other size constraints. If the batch size is set to `0`,
    then all files of a target will be combined in a single batch, but this is discouraged
    because of the reasons mentioned earlier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当 `UNITY_BUILD_MODE` 属性设置为 `BATCH` 时，CMake 会将文件按每批八个文件进行收集。通过设置目标的 `UNITY_BUILD_BATCH_SIZE`
    属性，可以更改这一点。要全局设置批大小，可以使用 `CMAKE_UNITY_BUILD_BATCH_SIZE` 缓存变量。批大小应谨慎选择，因为设置得太小对性能提升有限，而设置得过大会导致编译器使用过多内存或编译单元达到其他大小限制。如果批大小设置为
    `0`，则所有目标文件将合并为一个批次，但由于之前提到的原因，不推荐这样做。
- en: 'In `GROUP` mode, no batch size is applied, but the files have to be assigned
    to groups by setting the `UNITY_GROUP` property of the source file, as illustrated
    in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GROUP` 模式下，不会应用批大小，但必须通过设置源文件的 `UNITY_GROUP` 属性将文件分配到组中，以下是一个示例：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the example, the `main.cpp` and `fibonacci.cpp` files would be grouped together,
    and `erathostenes.cpp` and `pythagoras.cpp` would be compiled in a different group.
    In `GROUP` mode, the generated files are named `unity_<groupName>_<lang>.<lang>`.
    So, in this example, the files would be named `unity_group1_cxx.cxx` and `unity_group2_cxx.cxx`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`main.cpp` 和 `fibonacci.cpp` 文件会被归为一组，而 `erathostenes.cpp` 和 `pythagoras.cpp`
    则会在另一个组中编译。在 `GROUP` 模式下，生成的文件会命名为 `unity_<groupName>_<lang>.<lang>`。因此，在这个示例中，文件将被命名为
    `unity_group1_cxx.cxx` 和 `unity_group2_cxx.cxx`。
- en: Depending on the anatomy of a project, using unity builds can have a significant
    effect on build performance. Another technique often used to improve build times
    is using precompiled headers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的结构，使用统一构建可能会显著提高构建性能。另一种常用于提高构建速度的技术是使用预编译头文件。
- en: Precompiled headers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预编译头文件
- en: Precompiled headers are often a significant boost for the compile time, especially
    in cases where processing the headers is a significant part of the compile time
    or when header files are included in many different compilation units. In a nutshell,
    precompiled headers work by compiling some headers into a binary format that is
    easier to process for the compilers. Since CMake 3.16, there is direct support
    for precompiled headers, and most of the major compilers support some form of
    precompiled headers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头文件通常对编译时间有显著提升，尤其是在处理头文件是编译时间的重要组成部分，或当头文件在多个编译单元中被包含时。简而言之，预编译头文件通过将一些头文件编译成二进制格式，从而使编译器更容易处理。自
    CMake 3.16 起，已经直接支持预编译头文件，大多数主要编译器也支持某种形式的预编译头文件。
- en: 'Precompiled headers are added to a target with the `target_precompile_headers`
    command, which has the following signature:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 预编译头文件通过 `target_precompile_headers` 命令添加到目标中，其语法如下：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `PRIVATE`, `PUBLIC`, and `INTERFACE` keywords have the usual meaning. In
    the majority of cases, `PRIVATE` should be used. The headers specified in the
    command will be collected in a `cmake_pch.h` or `cmake_pch.hxx` file in the build
    folder, which will be force-included in all source files by the respective compiler
    flag, so there is no need for the source files to have a `#include "``cmake_pch.h"`
    directive.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVATE`、`PUBLIC` 和 `INTERFACE` 关键字具有常见含义。在大多数情况下，应使用 `PRIVATE`。命令中指定的头文件将会被收集到
    `cmake_pch.h` 或 `cmake_pch.hxx` 文件中，该文件会通过相应的编译器标志强制包含到所有源文件中，因此源文件中无需添加 `#include
    "cmake_pch.h"` 指令。'
- en: 'The headers may be specified either as plain filenames, with angle brackets,
    or with double quotes, in which case they have to be escaped with double square
    brackets:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件可以指定为普通文件名，带尖括号，或带双引号，在这种情况下，它们必须使用双中括号进行转义：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, `myHeader.h` would be searched from the current source directory,
    while `external_header.h` and `unordered_map` are searched for in the `include`
    directories.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`myHeader.h` 会从当前的源代码目录中搜索，而 `external_header.h` 和 `unordered_map` 则会在
    `include` 目录中搜索。
- en: 'In large projects, precompiled headers that are used in multiple targets are
    relatively common. Instead of redefining them every time, the `REUSE_FROM` option
    of `target_precompile_headers` can be used:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，多个目标之间使用相同的预编译头文件是相对常见的。为了避免每次都重新定义它们，可以使用`target_precompile_headers`的`REUSE_FROM`选项：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reusing precompiled headers will introduce an automatic dependency from target
    to `other_target`. Both targets will have the same compiler options, flags, and
    definitions enabled. Some compilers will warn if this is not the case, but some
    might not.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重用预编译头文件会引入目标与`other_target`之间的自动依赖关系。两个目标将启用相同的编译器选项、标志和定义。一些编译器会在这种情况不符合时发出警告，但有些编译器则不会。
- en: Precompiled headers from another target may only be used if the current target
    does not define its own set of precompiled headers. If the target already has
    precompiled headers defined, CMake will halt with an error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个目标的预编译头文件只有在当前目标没有定义自己的预编译头文件集时才能使用。如果目标已经定义了预编译头文件，CMake将会报错并停止。
- en: Precompiled headers are most effective in improving build times when the headers
    included rarely change. Any headers provided by the compiler, system, or external
    dependencies are generally good candidates to include in precompiled headers.
    Which headers exactly bring the most benefit is something that needs to be tried
    out and measured.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当包含的头文件很少更改时，预编译头文件在提高构建时间方面最为有效。由编译器、系统或外部依赖项提供的任何头文件通常都是合适的预编译头文件候选。哪些头文件确实带来最多的好处，需要通过试验和测量来确定。
- en: Together with unity builds, precompiled headers can improve compile time significantly,
    especially for projects with frequent header reuse. A third way to optimize build
    time for incremental builds is the use of compiler caches, namely `ccache`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与统一构建一起，预编译头文件可以显著提高编译时间，尤其是对于频繁重用头文件的项目。优化增量构建编译时间的第三种方式是使用编译器缓存，即`ccache`。
- en: Using a compiler cache (ccache) to speed up rebuilds
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用编译器缓存（ccache）来加速重建
- en: Ccaches work by caching compilations and detecting when the same compilation
    is done again. At the time of writing this book, the most popular program for
    caching compile results is `ccache`, which is open source and distributed under
    the `ccache` program not only affects incremental builds but also fresh builds,
    as long as the cache is not deleted between the two runs. The cache created is
    portable between systems running the same compilers and can be stored in remote
    databases so that multiple developers may access the same cache. Officially, `ccache`
    supports GCC, Clang, and `ccache` with CMake, it works best with Makefile and
    Ninja generators. At the time of writing this book, Visual Studio was not supported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存通过缓存编译结果并检测相同编译是否再次进行来工作。在编写本书时，最受欢迎的编译缓存程序是`ccache`，它是开源的，并且在`ccache`程序下进行分发，`ccache`不仅影响增量构建，还会影响全新构建，只要缓存没有在两次运行之间被删除。创建的缓存可以在运行相同编译器的系统之间移植，并且可以存储在远程数据库中，以便多个开发人员可以访问相同的缓存。官方支持`ccache`与GCC、Clang以及`ccache`与CMake一起使用，最佳的配合方式是使用Makefile和Ninja生成器。写本书时，Visual
    Studio尚不支持。
- en: 'To use `ccache` with CMake, the `CMAKE_<LANG>_COMPILER_LAUNCHER` cache variable
    is used, where `<LANG>` is replaced with the respective programming language.
    The recommended way is to pass this in using a preset, but to enable `ccache`
    for C and C++ inside a `CMakeLists.txt` file, the following code can be used:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CMake中使用`ccache`，可以使用`CMAKE_<LANG>_COMPILER_LAUNCHER`缓存变量，其中`<LANG>`替换为相应的编程语言。推荐的做法是通过预设传递这个变量，但为了在`CMakeLists.txt`文件中启用C和C++的`ccache`，可以使用以下代码：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Passing the variable from a preset or from the command line or a preset is also
    a good alternative, especially because the configuration of `ccache` is done easiest
    by using environment variables.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从预设或命令行传递变量也是一个不错的替代方案，特别是因为`ccache`的配置最容易通过使用环境变量来完成。
- en: 'Using `ccache` with the default configuration might already bring a considerable
    improvement regarding build times, but if the build is a bit more complex, further
    configuration might be necessary. To configure `ccache`, certain environment variables
    starting with `CCACHE_` can be used; for full documentation of all configuration
    options, refer to the `ccache` documentation. Common scenarios that need special
    attention are combining `ccache` with precompiled headers, managing dependencies
    that are included using `FetchContent`, and combining `ccache` with other compiler
    wrappers, such as `distcc` or `icecc` for distributed builds. For these scenarios,
    the following environment variables are used:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置的`ccache`可能已经在构建时间上带来相当大的改进，但如果构建稍微复杂一些，可能需要进一步的配置。要配置`ccache`，可以使用一些以`CCACHE_`开头的环境变量；有关所有配置选项的完整文档，请参阅`ccache`文档。需要特别注意的常见场景包括将`ccache`与预编译头文件结合使用，管理通过`FetchContent`包含的依赖项，以及将`ccache`与其他编译器包装器结合使用，如`distcc`或`icecc`用于分布式构建。对于这些场景，将使用以下环境变量：
- en: To work efficiently with precompiled headers, set `CCACHE_SLOPPINESS` to `pch_defines,time_macros`.
    The reason for this is that `ccache` cannot detect changes in `#defines` in the
    precompiled header, and it cannot tell if `__TIME__`, `__DATE__`, or `__TIMESTAMP__`
    are used when creating precompiled headers. Optionally, setting `include_file_mtime`
    to `CCACHE_SLOPPINESS` might further increase the cache hit performance, but it
    carries a very small risk of a race condition.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了高效地使用预编译头文件，设置`CCACHE_SLOPPINESS`为`pch_defines,time_macros`。原因在于`ccache`无法检测到预编译头文件中`#defines`的变化，也无法判断在创建预编译头文件时是否使用了`__TIME__`、`__DATE__`或`__TIMESTAMP__`。可选地，将`include_file_mtime`设置为`CCACHE_SLOPPINESS`可能会进一步提高缓存命中性能，但它带有一个非常小的竞态条件风险。
- en: When including big dependencies that are built from source (for instance, by
    using `FetchContent`), setting `CCACHE_BASEDIR` to `CMAKE_BINARY_DIR` might increase
    the cache hit rate; this might bring a performance boost especially if there are
    many (sub)projects fetching the same dependency. On the other hand, if the sources
    in the project itself are the ones that take more time to compile, setting this
    to `CMAKE_SOURCE_DIR` might bring better results. It needs to be tried out to
    learn which one brings the better result.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当包含从源代码构建的大型依赖项时（例如，使用`FetchContent`），将`CCACHE_BASEDIR`设置为`CMAKE_BINARY_DIR`可能会提高缓存命中率；特别是当有多个（子）项目获取相同的依赖项时，这可能会带来性能提升。另一方面，如果项目本身的源代码需要更多时间编译，将其设置为`CMAKE_SOURCE_DIR`可能会带来更好的结果。需要通过试验来确定哪种设置能带来更好的效果。
- en: To work with other compiler wrappers, the `CCACHE_PREFIX` environment variable
    is used to add commands for these wrappers. It is recommended to use `ccache`
    first when chaining multiple wrappers so that the results of other wrappers may
    also be cached.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与其他编译器包装器一起使用，`CCACHE_PREFIX` 环境变量用于为这些包装器添加命令。建议在链式调用多个包装器时首先使用`ccache`，以便其他包装器的结果也可以被缓存。
- en: 'Passing environment variables to CMake using a configure preset, as described
    in [*Chapter 9*](B30947_09.xhtml#_idTextAnchor146), *Creating Reproducible Build*
    *Environments*, is the recommended way; this can either be combined with detecting
    `ccache` inside the `CMakeLists.txt` file or the `ccache` command may also be
    passed using the following preset:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用配置预设将环境变量传递给CMake，如在[*第9章*](B30947_09.xhtml#_idTextAnchor146)中所述，*创建可重现的构建环境*，是推荐的方法；这可以与在`CMakeLists.txt`文件中检测`ccache`相结合，或者也可以通过以下预设将`ccache`命令传递：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With these configurations, using `ccache` can yield very large benefits to the
    compile time, but caching compiler results is a complicated matter, so to get
    the full benefit, the `ccache` documentation should be consulted. In most cases,
    using `ccache` will probably bring the most performance benefit with a relatively
    trivial setup. Other tools, such as `distcc` for distributed builds, work very
    similarly from the CMake perspective, but require a bit more setup work.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些配置，使用`ccache`可以大大提高编译时间的效率，但缓存编译器结果是一个复杂的问题，因此为了获得最大的好处，应该查阅`ccache`文档。在大多数情况下，使用`ccache`可能通过相对简单的设置带来最大的性能提升。其他工具，如用于分布式构建的`distcc`，从CMake的角度看工作非常相似，但需要更多的配置工作。
- en: Distributed builds
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式构建
- en: 'Distributed builds work by shoveling off some part of the compilation to different
    machines on a network. This requires setting up the servers that can accept connections
    and then configuring the clients to be able to connect to these servers. Setting
    up a server for `distcc` happens with the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式构建通过将部分编译任务分配给网络上的不同机器来工作。这要求设置能够接受连接的服务器，并配置客户端以便能够连接这些服务器。为`distcc`设置服务器的命令如下：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `client1` and `client2` are the hostnames or IP addresses of the respective
    build servers. On the client side, configuring CMake to use `distcc` will work
    similarly to using `ccache` by setting `CMAKE_<LANG>_COMPILER_LAUNCHER` to the
    `distcc` command. The list of potential servers is either configured over a configuration
    file or by the `DISTCC_HOSTS` environment variable. Unlike the `ccache` configuration,
    this is very host-specific, so the configuration should be put into a user preset,
    not the project-specific preset. The respective preset might look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`client1`和`client2`是各自构建服务器的主机名或IP地址。在客户端，配置CMake使用`distcc`的方式类似于通过将`CMAKE_<LANG>_COMPILER_LAUNCHER`设置为`distcc`命令来使用`ccache`。潜在服务器的列表可以通过配置文件或`DISTCC_HOSTS`环境变量进行配置。与`ccache`配置不同，这种配置非常依赖主机，因此配置应放在用户预设中，而不是项目特定的预设中。相应的预设可能如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `cpp` postfix after the `buildsrvr1` host. This puts `distcc` into
    so-called *pump mode*, which further increases compilation speed by also distributing
    the preprocessing to the servers. The `lzo` postfix tells `distcc` to compress
    the communication.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`buildsrvr1`主机后的`cpp`后缀。这将`distcc`置于所谓的*泵模式*，通过将预处理也分发到服务器来进一步提高编译速度。`lzo`后缀告诉`distcc`压缩通信内容。
- en: The downside to distributed builds is that in order to gain a speed benefit,
    the network has to be fast enough or else the cost of transferring the information
    for compiling might be higher than the reduced build time. However, in most local
    networks, this is easily the case. Distributed builds work well if the machines
    are similar regarding processor architecture, compilers, and operating systems.
    While cross-compiling using `distcc` is possible, it can be quite a bit of work
    to set up. By combining good coding practices, precompiled headers and compiler
    caches working on large projects still work without waiting minutes for every
    single build.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式构建的缺点在于，为了获得速度提升，网络必须足够快速，否则传输编译信息的成本可能会高于减少的构建时间。然而，在大多数本地网络中，这通常是可以满足的。如果机器在处理器架构、编译器和操作系统方面相似，分布式构建效果很好。虽然使用`distcc`进行交叉编译是可能的，但设置起来可能需要相当多的工作。通过结合良好的编码实践、预编译头文件和编译器缓存，大型项目仍然能够正常工作，而无需等待每次构建花费几分钟时间。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed some general tips on structuring and maintaining
    CMake projects, especially larger projects. With increased project size, configuring
    and building times usually increase, which could be a hindrance in the developer
    workflow. We looked at how the CMake profiling feature may be a useful tool to
    find performance hogs in the configuration process, even though it cannot be used
    to profile the compilation itself.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一些关于构建和维护CMake项目的常见技巧，尤其是大型项目。随着项目规模的增大，配置和构建时间通常会增加，这可能会妨碍开发人员的工作流。我们探讨了CMake的性能分析功能，这可能是找出配置过程中的性能瓶颈的有用工具，尽管它不能用于分析编译本身的性能。
- en: To help with long compilation times, we showed how to use unity build and precompiled
    headers from CMake to improve compile times themselves. And if all this does not
    yet bring the desired effect, using a compiler cache such as `ccache`, or a distributed
    compiler such as `distcc`, may be used by prefixing the compiler command.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决较长的编译时间，我们展示了如何使用CMake中的统一构建和预编译头文件来改善编译时间。如果这些方法还不能达到预期效果，可以通过在编译器命令前加上编译器缓存（如`ccache`）或分布式编译器（如`distcc`）来使用这些工具。
- en: Optimizing build performance is a very satisfying affair, even if finding the
    right combination of tools and methods to get the most out of CMake might be a
    bit tedious. The downside of heavily optimized builds is, however, that the builds
    might be more prone to failure, and the added complexity in the build process
    might need a deeper understanding and more expert knowledge to maintain in the
    long run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 优化构建性能是一个非常令人满意的过程，即使找到合适的工具和方法组合以最大化CMake的效率可能有些繁琐。然而，经过高度优化的构建也有其缺点，那就是构建可能更容易失败，而且构建过程中增加的复杂性可能需要更深入的理解和更多的专业知识来长期维护。
- en: In the next chapter, we will outline some high-level strategies for migrating
    from any build system to a CMake project.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将概述从任何构建系统迁移到CMake项目的一些高层策略。
- en: Questions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command-line flags are used to generate profiling information from CMake?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些命令行标志用于从CMake生成性能分析信息？
- en: On a very high level, how do unity builds optimize compile time?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个非常高层次来看，统一构建如何优化编译时间？
- en: What is the difference between `BATCH` and `GROUP` modes for unity builds?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BATCH`模式和`GROUP`模式在统一构建中有什么区别？'
- en: How are precompiled headers added to a target?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将预编译头文件添加到目标中？
- en: How does CMake handle compiler caches?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake如何处理编译器缓存？
- en: Answers
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `--profiling-output <filename>` and `--profiling-format=google-trace` flags
    are used.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--profiling-output <filename>`和`--profiling-format=google-trace`标志。
- en: By grouping together various compilation units into a single one, the need for
    relinking happens less often.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将多个编译单元合并为一个，减少了重新链接的需求。
- en: In `BATCH` mode, CMake automatically groups sources together, but in `GROUP`
    mode, the grouping has to be specified by the user. By default, `BATCH` mode groups
    all sources for a unity build, while `GROUP` mode only adds explicitly marked
    files to the unity build.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BATCH`模式下，CMake会自动将源文件分组，而在`GROUP`模式下，分组需要由用户指定。默认情况下，`BATCH`模式会将所有源文件分组为统一构建，而`GROUP`模式只会将显式标记的文件添加到统一构建中。
- en: By using the `target_precompile_headers` function. Precompiled headers are automatically
    included, without the need for a `#include` directive in files.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`target_precompile_headers`函数，预编译头文件会自动包含，无需在文件中使用`#include`指令。
- en: By prefixing the compiler command with the command specified in `CMAKE_<LANG>_COMPILER_LAUNCHER`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在编译器命令前加上`CMAKE_<LANG>_COMPILER_LAUNCHER`中指定的命令。
