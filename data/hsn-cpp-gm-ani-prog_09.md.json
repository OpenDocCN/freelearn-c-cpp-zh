["```cpp\n    class Pose {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<Transform> mJoints;\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> mParents;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0Pose();\n    \u00a0\u00a0\u00a0\u00a0Pose(const Pose& p);\n    \u00a0\u00a0\u00a0\u00a0Pose& operator=(const Pose& p);\n    \u00a0\u00a0\u00a0\u00a0Pose(unsigned int numJoints);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int size);\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0int GetParent(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0void SetParent(unsigned int index, int parent);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Transform GetLocalTransform(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0void SetLocalTransform(unsigned int index, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const Transform& transform);\n    \u00a0\u00a0\u00a0\u00a0Transform GetGlobalTransform(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0Transform operator[](unsigned int index);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void GetMatrixPalette(std::vector<mat4>& out);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0bool operator==(const Pose& other);\n    \u00a0\u00a0\u00a0\u00a0bool operator!=(const Pose& other);\n    };\n    ```", "```cpp\n    Pose::Pose() { }\n    Pose::Pose(unsigned int numJoints) {\n    \u00a0\u00a0\u00a0\u00a0Resize(numJoints);\n    }\n    Pose::Pose(const Pose& p) {\n    \u00a0\u00a0\u00a0\u00a0*this = p;\n    }\n    ```", "```cpp\n    Pose& Pose::operator=(const Pose& p) {\n    \u00a0\u00a0\u00a0\u00a0if (&p == this) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mParents.size() != p.mParents.size()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mParents.resize(p.mParents.size());\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mJoints.size() != p.mJoints.size()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mJoints.resize(p.mJoints.size());\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mParents.size() != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memcpy(&mParents[0], &p.mParents[0], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sizeof(int) * mParents.size());\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mJoints.size() != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memcpy(&mJoints[0], &p.mJoints[0], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sizeof(Transform) * mJoints.size());\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    void Pose::Resize(unsigned int size) {\n    \u00a0\u00a0\u00a0\u00a0mParents.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mJoints.resize(size);\n    }\n    unsigned int Pose::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mJoints.size();\n    }\n    ```", "```cpp\n    Transform Pose::GetLocalTransform(unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mJoints[index];\n    }\n    void Pose::SetLocalTransform(unsigned int index, const Transform& transform) {\n    \u00a0\u00a0\u00a0\u00a0mJoints[index] = transform;\n    }\n    ```", "```cpp\n    Transform Pose::GetGlobalTransform(unsigned int i) {\n    \u00a0\u00a0\u00a0\u00a0Transform result = mJoints[i];\n    \u00a0\u00a0\u00a0\u00a0for (int p = mParents[i]; p >= 0; p = mParents[p]) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = combine(mJoints[p], result);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    Transform Pose::operator[](unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return GetGlobalTransform(index);\n    }\n    ```", "```cpp\n    void Pose::GetMatrixPalette(std::vector<mat4>& out) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = Size();\n    \u00a0\u00a0\u00a0\u00a0if (out.size() != size) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out.resize(size);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform t = GetGlobalTransform(i);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out[i] = transformToMat4(t);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    int Pose::GetParent(unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mParents[index];\n    }\n    void Pose::SetParent(unsigned int index, int parent) {\n    \u00a0\u00a0\u00a0\u00a0mParents[index] = parent;\n    }\n    ```", "```cpp\n    bool Pose::operator==(const Pose& other) {\n    \u00a0\u00a0\u00a0\u00a0if (mJoints.size() != other.mJoints.size()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (mParents.size() != other.mParents.size()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = (unsigned int)mJoints.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform thisLocal = mJoints[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform otherLocal = other.mJoints[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int thisParent = mParents[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int otherParent = other.mParents[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (thisParent != otherParent) { return false; }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (thisLocal.position != otherLocal.position) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false; }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (thisLocal.rotation != otherLocal.rotation {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false; }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (thisLocal.scale != otherLocal.scale { \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return false; } \n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return true;\n    }\n    bool Pose::operator!=(const Pose& other) {\n    \u00a0\u00a0\u00a0\u00a0return !(*this == other);\n    }\n    ```", "```cpp\n    class Clip {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<TransformTrack> mTracks;\n    \u00a0\u00a0\u00a0\u00a0std::string mName;\n    \u00a0\u00a0\u00a0\u00a0float mStartTime;\n    \u00a0\u00a0\u00a0\u00a0float mEndTime;\n    \u00a0\u00a0\u00a0\u00a0bool mLooping;\n    ```", "```cpp\n    protected:\n    \u00a0\u00a0\u00a0\u00a0float AdjustTimeToFitRange(float inTime);\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0Clip();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0unsigned int GetIdAtIndex(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0void SetIdAtIndex(unsigned int idx, unsigned int id);\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0float Sample(Pose& outPose, float inTime);\n    \u00a0\u00a0\u00a0\u00a0TransformTrack& operator[](unsigned int index);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void RecalculateDuration();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0std::string& GetName();\n    \u00a0\u00a0\u00a0\u00a0void SetName(const std::string& inNewName);\n    \u00a0\u00a0\u00a0\u00a0float GetDuration();\n    \u00a0\u00a0\u00a0\u00a0float GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0float GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0bool GetLooping();\n    \u00a0\u00a0\u00a0\u00a0void SetLooping(bool inLooping);\n    };\n    ```", "```cpp\n    Clip::Clip() {\n    \u00a0\u00a0\u00a0\u00a0mName = \"No name given\";\n    \u00a0\u00a0\u00a0\u00a0mStartTime = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0mEndTime = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0mLooping = true;\n    }\n    ```", "```cpp\n    float Clip::Sample(Pose& outPose, float time) {\n    \u00a0\u00a0\u00a0\u00a0if (GetDuration() == 0.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return 0.0f;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0time= AdjustTimeToFitRange(time);\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = mTracks.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int j = mTracks[i].GetId(); // Joint\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform local = outPose.GetLocalTransform(j);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform animated = mTracks[i].Sample(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 local, time, mLooping);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0outPose.SetLocalTransform(j, animated);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return time;\n    }\n    ```", "```cpp\n    float Clip::AdjustTimeToFitRange(float inTime) {\n    \u00a0\u00a0\u00a0\u00a0if (mLooping) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float duration = mEndTime - mStartTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (duration <= 0) { 0.0f; }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inTime = fmodf(inTime - mStartTime, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mEndTime - mStartTime);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (inTime < 0.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inTime += mEndTime - mStartTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inTime = inTime + mStartTime;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (inTime < mStartTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inTime = mStartTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (inTime > mEndTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inTime = mEndTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return inTime;\n    }\n    ```", "```cpp\n    void Clip::RecalculateDuration() {\n    \u00a0\u00a0\u00a0\u00a0mStartTime = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0mEndTime = 0.0f;\n    \u00a0\u00a0\u00a0\u00a0bool startSet = false;\n    \u00a0\u00a0\u00a0\u00a0bool endSet = false;\n    \u00a0\u00a0\u00a0\u00a0unsigned int tracksSize = mTracks.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < tracksSize; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mTracks[i].IsValid()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float startTime = mTracks[i].GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float endTime = mTracks[i].GetEndTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (startTime < mStartTime || !startSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mStartTime = startTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0startSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (endTime > mEndTime || !endSet) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mEndTime = endTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0endSet = true;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    TransformTrack& Clip::operator[](unsigned int joint) {\n    \u00a0\u00a0\u00a0\u00a0for (int i = 0, s = mTracks.size(); i < s; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mTracks[i].GetId() == joint) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return mTracks[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0mTracks.push_back(TransformTrack());\n    \u00a0\u00a0\u00a0\u00a0mTracks[mTracks.size() - 1].SetId(joint);\n    \u00a0\u00a0\u00a0\u00a0return mTracks[mTracks.size() - 1];\n    }\n    ```", "```cpp\n    std::string& Clip::GetName() {\n    \u00a0\u00a0\u00a0\u00a0return mName;\n    }\n    unsigned int Clip::GetIdAtIndex(unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return mTracks[index].GetId();\n    }\n    unsigned int Clip::Size() {\n    \u00a0\u00a0\u00a0\u00a0return (unsigned int)mTracks.size();\n    }\n    float Clip::GetDuration() {\n    \u00a0\u00a0\u00a0\u00a0return mEndTime - mStartTime;\n    }\n    float Clip::GetStartTime() {\n    \u00a0\u00a0\u00a0\u00a0return mStartTime;\n    }\n    float Clip::GetEndTime() {\n    \u00a0\u00a0\u00a0\u00a0return mEndTime;\n    }\n    bool Clip::GetLooping() {\n    \u00a0\u00a0\u00a0\u00a0return mLooping;\n    }\n    ```", "```cpp\n    void Clip::SetName(const std::string& inNewName) {\n    \u00a0\u00a0\u00a0\u00a0mName = inNewName;\n    }\n    void Clip::SetIdAtIndex(unsigned int index, unsigned int id) {\n    \u00a0\u00a0\u00a0\u00a0return mTracks[index].SetId(id);\n    }\n    void Clip::SetLooping(bool inLooping) {\n    \u00a0\u00a0\u00a0\u00a0mLooping = inLooping;\n    }\n    ```", "```cpp\n    // Inside the GLTFHelpers namespace\n    Transform GLTFHelpers::GetLocalTransform(cgltf_node& n){\n    \u00a0\u00a0\u00a0\u00a0Transform result;\n    \u00a0\u00a0\u00a0\u00a0if (n.has_matrix) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4 mat(&n.matrix[0]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = mat4ToTransform(mat);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (n.has_translation) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.position = vec3(n.translation[0], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 n.translation[1], n.translation[2]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (n.has_rotation) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.rotation = quat(n.rotation[0], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n.rotation[1], n.rotation[2], n.rotation[3]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (n.has_scale) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.scale = vec3(n.scale[0], n.scale[1], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n.scale[2]);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\n    // Inside the GLTFHelpers namespace\n    int GLTFHelpers::GetNodeIndex(cgltf_node* target, \n    \u00a0\u00a0\u00a0\u00a0cgltf_node* allNodes, unsigned int numNodes) {\n    \u00a0\u00a0\u00a0\u00a0if (target == 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < numNodes; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (target == &allNodes[i]) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return (int)i;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return -1;\n    }\n    ```", "```cpp\n    Pose LoadRestPose(cgltf_data* data) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int boneCount = data->nodes_count;\n    \u00a0\u00a0\u00a0\u00a0Pose result(boneCount);\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < boneCount; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_node* node = &(data->nodes[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Transform transform = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GLTFHelpers::GetLocalTransform(data->nodes[i]);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.SetLocalTransform(i, transform);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int parent = GLTFHelpers::GetNodeIndex(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 node->parent, data->nodes, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 boneCount);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.SetParent(i, parent);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return result;\n    }\n    ```", "```cpp\nstd::vector<std::string> LoadJointNames(cgltf_data* data) {\n\u00a0\u00a0\u00a0\u00a0unsigned int boneCount = (unsigned int)data->nodes_count;\n\u00a0\u00a0\u00a0\u00a0std::vector<std::string> result(boneCount, \"Not Set\");\n\u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < boneCount; ++i) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_node* node = &(data->nodes[i]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node->name == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i] = \"EMPTY NODE\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i] = node->name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return result;\n}\n```", "```cpp\n    // Inside the GLTFHelpers namespace\n    void GLTFHelpers::GetScalarValues( vector<float>& out, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int compCount, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const cgltf_accessor& inAccessor) {\n    \u00a0\u00a0\u00a0\u00a0out.resize(inAccessor.count * compCount);\n    \u00a0\u00a0\u00a0\u00a0for (cgltf_size i = 0; i < inAccessor.count; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_accessor_read_float(&inAccessor, i, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&out[i * compCount], \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compCount);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    // Inside the GLTFHelpers namespace\n    template<typename T, int N>\n    void GLTFHelpers::TrackFromChannel(Track<T, N>& result,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const cgltf_animation_channel& channel) {\n    \u00a0\u00a0\u00a0\u00a0cgltf_animation_sampler& sampler = *channel.sampler;\n    \u00a0\u00a0\u00a0\u00a0Interpolation interpolation = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Interpolation::Constant;\n    \u00a0\u00a0\u00a0\u00a0if (sampler.interpolation ==\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_interpolation_type_linear) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interpolation = Interpolation::Linear;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else if (sampler.interpolation ==\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cgltf_interpolation_type_cubic_spline) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0interpolation = Interpolation::Cubic;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0bool isSamplerCubic = interpolation == \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Interpolation::Cubic;\n    \u00a0\u00a0\u00a0\u00a0result.SetInterpolation(interpolation);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> time; // times\n    \u00a0\u00a0\u00a0\u00a0GetScalarValues(time, 1, *sampler.input);\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> val; // values\n    \u00a0\u00a0\u00a0\u00a0GetScalarValues(val, N, *sampler.output);\n    \u00a0\u00a0\u00a0\u00a0unsigned int numFrames = sampler.input->count; \n    \u00a0\u00a0\u00a0\u00a0unsigned int compCount = val.size() / time.size();\n    \u00a0\u00a0\u00a0\u00a0result.Resize(numFrames);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < numFrames; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int baseIndex = i * compCount;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Frame<N>& frame = result[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int offset = 0;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frame.mTime = time[i];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int comp = 0; comp < N; ++comp) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frame.mIn[comp] = isSamplerCubic ? \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val[baseIndex + offset++] : 0.0f;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int comp = 0; comp < N; ++comp) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frame.mValue[comp] = val[baseIndex + \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 offset++];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int comp = 0; comp < N; ++comp) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frame.mOut[comp] = isSamplerCubic ? \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val[baseIndex + offset++] : 0.0f;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0}\n    } // End of TrackFromChannel function\n    ```", "```cpp\n    std::vector<Clip> LoadAnimationClips(cgltf_data* data) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int numClips = data->animations_count;\n    \u00a0\u00a0\u00a0\u00a0unsigned int numNodes = data->nodes_count;\n    \u00a0\u00a0\u00a0\u00a0std::vector<Clip> result;\n    \u00a0\u00a0\u00a0\u00a0result.resize(numClips);\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < numClips; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i].SetName(data->animations[i].name);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int numChannels = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 data->animations[i].channels_count;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (unsigned int j = 0; j < numChannels; ++j){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_animation_channel& channel = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data->animations[i].channels[j];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cgltf_node* target = channel.target_node;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int nodeId = GLTFHelpers::GetNodeIndex(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 target, data->nodes, numNodes);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (channel.target_path == \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cgltf_animation_path_type_translation){\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 VectorTrack& track = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result[i][nodeId].GetPositionTrack();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 GLTFHelpers::TrackFromChannel<vec3, 3>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(track, channel);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (channel.target_path == \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cgltf_animation_path_type_scale) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0VectorTrack& track = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i][nodeId].GetScaleTrack();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GLTFHelpers::TrackFromChannel<vec3, 3>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(track, channel);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if (channel.target_path == \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cgltf_animation_path_type_rotation) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0QuaternionTrack& track = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 result[i][nodeId].GetRotationTrack();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GLTFHelpers::TrackFromChannel<quat, 4>\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (track, channel);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} // End num channels loop\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i].RecalculateDuration();\n    \u00a0\u00a0\u00a0\u00a0} // End num clips loop\n    \u00a0\u00a0\u00a0\u00a0return result;\n    } // End of LoadAnimationClips function\n    ```"]