- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Proxy Objects and Lazy Evaluation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理对象和延迟评估
- en: In this chapter, you will learn how to use proxy objects and lazy evaluation
    in order to postpone the execution of certain code until required. Using proxy
    objects enables optimizations to occur under the hood, thereby leaving the exposed
    interfaces intact.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用代理对象和延迟评估，以推迟执行某些代码直到需要。使用代理对象可以在后台进行优化，从而保持公开的接口不变。
- en: 'This chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了：
- en: Lazy and eager evaluation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰和急切评估
- en: Using proxy objects to avoid superfluous computations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代理对象避免多余的计算
- en: Overloading operators when working with proxy objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用代理对象时重载运算符
- en: Introducing lazy evaluation and proxy objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入延迟评估和代理对象
- en: First and foremost, the techniques used in this chapter are used to hide optimizations
    in a library from the user of that library. This is useful because exposing every
    single optimization technique as a separate function requires a lot of attention
    and education from the user of the library. It also bloats the code base with
    a multitude of specific functions, making it hard to read and understand. By using
    proxy objects, we can achieve optimizations under the hood; the resultant code
    is both optimized and readable.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，本章中使用的技术是用于隐藏库中的优化技术，不让库的用户看到。这很有用，因为将每个单独的优化技术公开为一个单独的函数需要用户的大量关注和教育。它还使代码库膨胀了大量特定的函数，使其难以阅读和理解。通过使用代理对象，我们可以在后台实现优化；结果代码既经过优化又易读。
- en: Lazy versus eager evaluation
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰与急切评估
- en: '**Lazy** **evaluation** is a technique used to postpone an operation until
    its result is really needed. The opposite, where operations are performed right
    away, is called **eager evaluation**. In some situations, eager evaluation is
    undesirable as we might end up constructing a value that is never used.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**懒惰** **评估**是一种技术，用于推迟操作，直到真正需要其结果。相反，立即执行操作的情况称为**急切评估**。在某些情况下，急切评估是不希望的，因为我们可能最终构造一个从未使用的值。'
- en: 'To demonstrate the difference between eager and lazy evaluation, let''s assume
    we are writing some sort of game with multiple levels. Whenever a level has been
    completed, we need to display the current score. Here we will focus on a few components
    of our game:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示急切和懒惰评估之间的差异，让我们假设我们正在编写某种具有多个级别的游戏。每当完成一个级别时，我们需要显示当前分数。在这里，我们将专注于游戏的一些组件：
- en: A `ScoreView` class responsible for displaying the user's score with an optional bonus
    image if a bonus was achieved
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ScoreView`类负责显示用户的分数，如果获得了奖励，则显示可选的奖励图像
- en: An `Image` class that represents an image loaded into memory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表加载到内存中的图像的`Image`类
- en: A `load()` function that loads images from disk
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘加载图像的`load()`函数
- en: 'The implementation of the classes and functions is not important in this example,
    but the declarations look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类和函数的实现并不重要，但声明看起来是这样的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Two versions of `display()` are provided: the first one requires a fully loaded
    bonus image, whereas the second one accepts a function that will be called only
    if a bonus image is needed. Using the first *eager* version would look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了两个`display()`版本：第一个需要完全加载的奖励图像，而第二个接受一个只在需要奖励图像时调用的函数。使用第一个*急切*版本会是这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the second *lazy* version would look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二个*懒惰*版本会是这样：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The eager version will always load the default image into memory even if it's
    never displayed. However, the lazy loading of the bonus image will guarantee that
    the image is only loaded if the `ScoreView` really needs to show the bonus image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 急切版本将始终将默认图像加载到内存中，即使它从未显示过。然而，奖励图像的延迟加载将确保只有在`ScoreView`真正需要显示奖励图像时才加载图像。
- en: This is a very simple example, but the idea is that your code gets expressed
    almost in the same way as if it were declared eagerly. A technique for hiding
    the fact that the code evaluates lazily is to use proxy objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但其思想是，您的代码几乎以与急切声明相同的方式表达。隐藏代码懒惰评估的技术是使用代理对象。
- en: Proxy objects
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理对象
- en: Proxy objects are internal library objects that aren't intended to be visible
    to the user of the library. Their task is to postpone operations until required
    and to collect the data of an expression until it can be evaluated and optimized.
    However, proxy objects act in the dark; the user of the library should be able
    to handle the expressions as if the proxy objects were not there. In other words,
    using proxy objects, you can encapsulate optimizations in your libraries while
    leaving the interfaces intact. You will now learn how to use proxy objects in
    order to evaluate more advanced expressions lazily.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代理对象是内部库对象，不打算对库的用户可见。它们的任务是推迟操作直到需要，并收集表达式的数据，直到可以评估和优化。然而，代理对象在黑暗中行事；库的用户应该能够处理表达式，就好像代理对象不存在一样。换句话说，使用代理对象，您可以在库中封装优化，同时保持接口不变。现在您将学习如何使用代理对象来懒惰地评估更高级的表达式。
- en: Avoiding constructing objects using proxy objects
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理对象避免构造对象
- en: Eager evaluation can have the undesirable effect that objects are unnecessarily
    constructed. Often this is not a problem, but if the objects are expensive to
    construct (because of heap allocations, for example), there might be legitimate
    reasons to optimize away the unnecessary construction of short-lived objects that
    serve no purpose.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 急切评估可能会导致不必要地构造对象。通常这不是问题，但如果对象昂贵（例如因为堆分配），可能有合理的理由优化掉无用的短暂对象的构造。
- en: Comparing concatenated strings using a proxy
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代理对象比较连接的字符串
- en: We will now walk through a minimal example of using proxy objects to give you
    an idea of what they are and can be used for. It's not meant to provide you with
    a general production-ready solution to optimizing string comparisons.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过一个使用代理对象的最小示例，让您了解它们是什么以及可以用于什么。它并不意味着为您提供一个通用的生产就绪的优化字符串比较解决方案。
- en: 'With that said, take a look at this code snippet that concatenates two strings
    and compares the result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，看看这段代码片段，它连接两个字符串并比较结果：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a visual representation of the preceding code snippet:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码片段的可视化表示：
- en: '![](img/B15619_10_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_10_01.png)'
- en: 'Figure 10.1: Concatenating two strings into a new string'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：将两个字符串连接成一个新字符串
- en: 'The problem here is that (`a + b`) constructs a new temporary string in order
    to compare it with `c`. Instead of constructing a new string, we can just compare
    the concatenation right away, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，(`a + b`)构造了一个新的临时字符串，以便将其与`c`进行比较。我们可以直接比较连接，而不是构造一个新的字符串，就像这样：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then use it like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用它：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Performance-wise, we've achieved a win, but syntactically, a code base littered
    with special-case convenience functions like this is hard to maintain. So, let's
    see how this optimization can be achieved with the original syntax still intact.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就性能而言，我们取得了胜利，但从语法上讲，一个代码库中充斥着这种特殊情况的便利函数很难维护。因此，让我们看看如何在保持原始语法不变的情况下实现这种优化。
- en: Implementing the proxy
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现代理
- en: 'First, we''ll create a proxy class representing the concatenation of two strings:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个代表两个字符串连接的代理类：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll construct our own `String` class that contains a `std::string`
    and an overloaded `operator+()` function. Note that this is an example of how
    to make and use proxy objects; creating your own `String` class is not something
    I recommend:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将构建自己的`String`类，其中包含一个`std::string`和一个重载的`operator+()`函数。请注意，这是如何创建和使用代理对象的示例；创建自己的`String`类不是我推荐的做法：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s a visual representation of the preceding code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面代码片段的可视化表示：
- en: '![](img/B15619_10_02.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_10_02.png)'
- en: 'Figure 10.2: A proxy object representing the concatenation of two strings'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：代表两个字符串连接的代理对象
- en: 'Lastly, we''ll create a global `operator==()` function, which in turn will
    use the optimized `is_concat_equal()` function, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个全局的`operator==()`函数，该函数将使用优化的`is_concat_equal()`函数，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have everything in place, we can get the best of both worlds:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备就绪，可以兼得两全：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In other words, we gained the performance of `is_concat_equal()` while preserving
    the expressive syntax of using `operator==()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在保留使用`operator==()`的表达语法的同时，获得了`is_concat_equal()`的性能。
- en: The rvalue modifier
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rvalue修饰符
- en: 'In the preceding code, the global `operator==()` function only accepts `ConcatProxy`
    rvalues:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，全局的`operator==()`函数只接受`ConcatProxy` rvalues：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we were to accept a `ConcatProxy` lvalue, we could end up accidentally misusing
    the proxy, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接受一个`ConcatProxy` lvalue，我们可能会意外地误用代理，就像这样：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The problem here is that both the temporary `String` objects holding `"Cole"`
    and `"Porter"` have been destructed by the time the comparison is executed, leading
    to a failure. (Remember that the `ConcatProxy` class only holds references to
    the strings.) But since we forced the `concat` object to be an rvalue, the preceding
    code will not compile and thereby saves us from a likely runtime crash. Of course,
    you could force it to compile by casting it to an rvalue using `std::move(concat)
    == String("ColePorter")`, but that wouldn't be a realistic case.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，持有`"Cole"`和`"Porter"`的临时`String`对象在比较执行时已被销毁，导致失败。（请记住，`ConcatProxy`类只持有对字符串的引用。）但由于我们强制`concat`对象为rvalue，前面的代码将无法编译，从而避免了可能的运行时崩溃。当然，你可以通过使用`std::move(concat)
    == String("ColePorter")`将其强制编译，但这不是一个现实的情况。
- en: Assigning a concatenated proxy
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配一个连接的代理
- en: 'Now, you might be thinking, what if we actually want to store the concatenated
    string as a new string rather than just compare it? What we do is simply overload
    an `operator String()` function, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想，如果我们实际上想将连接的字符串存储为一个新的字符串而不仅仅是比较它，该怎么办？我们所做的就是简单地重载一个`operator String()`函数，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The concatenation of two strings can now implicitly convert itself to a string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符串的连接现在可以隐式转换为一个字符串：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There is one little snag, though: we cannot initialize the new `String` object
    with the `auto` keyword, as this would result in `ConcatProxy`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个小问题：我们无法使用`auto`关键字初始化新的`String`对象，因为这将导致`ConcatProxy`：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Unfortunately, we have no way to get around this; the result must be explicitly
    cast to `String`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法绕过这一点；结果必须显式转换为`String`。
- en: It's time to see how much faster our optimized version is compared to the normal
    case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们优化版本与正常情况相比有多快了。
- en: Performance evaluation
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能评估
- en: 'To evaluate the performance benefits, we''ll use the following benchmark, which
    concatenates and compares `10''000` strings of size `50`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估性能优势，我们将使用以下基准测试，连接并比较大小为`50`的`10,000`个字符串：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I achieved a 40x speedup using gcc when executing on an Intel Core i7 CPU. The
    version using `std::string` directly completed in 1.6 ms, whereas the proxy version
    using `String` completed in only 0.04 ms. When running the same test using short
    strings of length 10, the speedup was around 20x. One reason for the big variation
    is that small strings will avoid heap allocations by utilizing the small string
    optimization discussed in *Chapter 7*, *Memory Management*. The benchmark shows
    us that the speedup with a proxy object is considerable when we get rid of the
    temporary string and the possible heap allocation that comes with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel Core i7 CPU上执行时，我使用gcc实现了40倍的加速。直接使用`std::string`的版本完成时间为1.6毫秒，而使用`String`的代理版本仅为0.04毫秒。当使用长度为10的短字符串进行相同的测试时，加速约为20倍。造成这种巨大变化的一个原因是，小字符串将通过利用*第7章*
    *内存管理*中讨论的小字符串优化来避免堆分配。基准测试告诉我们，当我们摆脱临时字符串和可能伴随其而来的堆分配时，使用代理对象的加速是相当可观的。
- en: The `ConcatProxy` class helped us to hide an optimization when comparing strings.
    Hopefully this simple example has inspired you to start thinking about ways to
    keep your API design clean while implementing performance optimizations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcatProxy` 类帮助我们隐藏了在比较字符串时的优化。希望这个简单的例子能激发您开始思考在实现性能优化的同时保持 API 设计清晰的方法。'
- en: Next, you will see another useful optimization that can be hidden behind a proxy class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到另一个有用的优化，可以隐藏在代理类后面。
- en: Postponing sqrt computations
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推迟 sqrt 计算
- en: This section will show you how to use a proxy object in order to postpone, or
    even avoid, using the computationally heavy `std::sqrt()` function when comparing
    the length of two-dimensional vectors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示如何使用代理对象来推迟或甚至避免在比较二维向量长度时使用计算量大的 `std::sqrt()` 函数。
- en: A simple two-dimensional vector class
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的二维向量类
- en: 'Let''s start with a simple two-dimensional vector class. It has *x* and *y*
    coordinates and a member function called `length()` that calculates the distance
    from the origin to the location *(x, y)*. We will call the class `Vec2D`. Here
    follows the definition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的二维向量类开始。它有 *x* 和 *y* 坐标，以及一个名为 `length()` 的成员函数，用于计算从原点到位置 *(x, y)*
    的距离。我们将这个类称为 `Vec2D`。以下是定义：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is an example of how clients can use `Vec2D`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端如何使用 `Vec2D` 的示例：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The example creates two vectors and compares their lengths. The length of the
    shortest vector is then printed to standard out. *Figure 10.3* illustrates the
    vector and the calculated length to the origin:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例创建了两个向量并比较它们的长度。然后将最短向量的长度打印到标准输出。*图 10.3* 说明了向量和到原点的计算长度：
- en: '![](img/B15619_10_03.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_10_03.png)'
- en: 'Figure 10.3: Two 2D vectors of different lengths. The length of vector a is
    5.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：两个长度不同的二维向量。向量 a 的长度为 5。
- en: The underlying mathematics
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 底层数学
- en: 'Looking into the mathematics of the calculation, you may notice something interesting.
    The formula used for length is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算的数学中，您可能会注意到一些有趣的事情。用于长度的公式如下：
- en: '![](img/B15619_10_001.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_10_001.png)'
- en: 'However, if we only need to compare the distance between two vectors, the squared
    length is all we need, as the following formula shows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们只需要比较两个向量之间的距离，平方长度就足够了，如下面的公式所示：
- en: '![](img/B15619_10_002.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_10_002.png)'
- en: The square root can be computed using the function `std::sqrt()`. But, as mentioned,
    as the square root operation is not required if we just want to compare lengths
    between two vectors, we can omit it. The nice thing is that `std::sqrt()` is a
    relatively slow operation, meaning that if we compare a lot of vectors by their
    length, we can gain some performance. The question is, how can we do this while
    preserving a clean syntax? Let's see how we can use a proxy object to make a simple
    library perform this optimization under the hood when comparing lengths.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 平方根可以使用函数 `std::sqrt()` 计算。但是，正如前面提到的，如果我们只想比较两个向量的长度，就不需要进行平方根运算。好处在于 `std::sqrt()`
    是一个相对缓慢的操作，这意味着如果我们通过长度比较许多向量，就可以获得一些性能。问题是，我们如何在保持清晰语法的同时实现这一点？让我们看看如何使用代理对象在比较长度时在后台执行这种优化。
- en: 'For clarity, we start with the original `Vec2D` class but we split the `length()`
    function into two parts – `length_squared()` and `length()`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们从原始的 `Vec2D` 类开始，但是我们将 `length()` 函数分成两部分 - `length_squared()` 和 `length()`，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now clients to our `Vec2D` class can use `length_squared()` if they want to
    gain some performance when only comparing the lengths of different vectors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们 `Vec2D` 类的客户端可以使用 `length_squared()` 来获得一些性能优势，当只比较不同向量的长度时。
- en: 'Let''s say that we want to implement a convenient utility function that returns
    the minimum length of a range of `Vec2D` objects. We now have two options: either
    use the `length()` function or the `length_squared()` function when doing the
    comparison. Their corresponding implementations are shown in the following examples:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要实现一个方便的实用函数，返回一系列 `Vec2D` 对象的最小长度。现在我们有两个选择：在进行比较时使用 `length()` 函数或 `length_squared()`
    函数。它们对应的实现如下示例所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second optimized version using `length_squared()` for comparison would
    look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `length_squared()` 进行比较的第二个优化版本将如下所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first version using `length()` inside `cmp` has the advantage of being more
    readable and easier to get right, whereas the second version has the advantage
    of being faster. To remind you, the speedup of the second version is because we
    can avoid the call to `std::sqrt()` inside the `cmp` lambda.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cmp` 内部的 `length()` 的第一个版本具有更可读和更容易正确的优势，而第二个版本具有更快的优势。提醒一下，第二个版本的加速是因为我们可以避免在
    `cmp` lambda 内部调用 `std::sqrt()`。
- en: The optimal solution would be to have the syntax of the first version using
    `length()` and the performance of the second version using `length_squared()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是具有使用 `length()` 语法的第一个版本和使用 `length_squared()` 性能的第二个版本。
- en: Depending on the context this class will be used in, there might be good reasons
    to expose a function such as `length_squared()`. But let's assume that other developers
    on our team don't understand the reason for having the `length_squared()` function
    and find the class confusing. So, we decide to come up with something better to
    avoid having two versions of a function that exposes a length property of the
    vector. As you might have guessed, it's time for a proxy class that hides this
    complexity.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个类将被使用的上下文，可能有很好的理由暴露 `length_squared()` 这样的函数。但是让我们假设我们团队中的其他开发人员不理解为什么有
    `length_squared()` 函数，并且觉得这个类很混乱。因此，我们决定想出更好的方法，避免有两个暴露向量长度属性的函数版本。正如您可能已经猜到的那样，是时候使用代理类来隐藏这种复杂性了。
- en: In order to achieve this, instead of returning a `float` value from the `length()`
    member function, we return an intermediate object hidden from the user. Depending
    on how the user uses the hidden proxy object, it should avoid the `std::sqrt()`
    operation until it is really required. In sections to come, we will implement
    a class called `LengthProxy`, which will be the type of proxy object we will return
    from `Vec2D::length()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们不是从`length()`成员函数中返回一个`float`值，而是返回一个对用户隐藏的中间对象。根据用户如何使用隐藏的代理对象，它应该避免`std::sqrt()`操作，直到真正需要。在接下来的部分中，我们将实现一个名为`LengthProxy`的类，它将是我们从`Vec2D::length()`返回的代理对象的类型。
- en: Implementing the LengthProxy object
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现LengthProxy对象
- en: 'It''s time to implement the `LengthProxy` class containing a `float` data member
    that represents the squared length. The actual squared length is never exposed
    in order to prevent users of the class from mixing the squared length with the
    regular length. Instead, `LengthProxy` has a hidden `friend` function that compares
    its squared length with a regular length, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现`LengthProxy`类了，其中包含一个代表平方长度的`float`数据成员。实际的平方长度永远不会暴露出来，以防止类的用户将平方长度与常规长度混淆。相反，`LengthProxy`有一个隐藏的`friend`函数，用于比较其平方长度和常规长度，如下所示：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have defined `operator float()` to allow implicit casts from `LengthProxy`
    to `float`. `LengthProxy` objects can also be compared with each other. By using
    the new C++20 comparisons, we simply `default` the equality operator and three-way
    comparison operator to have the compiler generate all the necessary comparison
    operators for us.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`operator float()`，以允许从`LengthProxy`到`float`的隐式转换。`LengthProxy`对象也可以相互比较。通过使用新的C++20比较，我们简单地将等号运算符和三路比较运算符设置为`default`，让编译器为我们生成所有必要的比较运算符。
- en: 'Next, we rewrite the `Vec2D` class to return objects of the class `LengthProxy`
    instead of the actual `float` length:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写`Vec2D`类，以返回`LengthProxy`类的对象，而不是实际的`float`长度：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With these additions in place, it's time to use our new proxy class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些补充，现在是时候使用我们的新代理类了。
- en: Comparing lengths with LengthProxy
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LengthProxy比较长度
- en: 'In this example, we''ll compare two vectors, `a` and `b`, and determine whether
    `a` is shorter than `b`. Note how the code syntactically looks exactly the same
    as if we had not utilized a proxy class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将比较两个向量`a`和`b`，并确定`a`是否比`b`短。请注意，代码在语法上看起来与我们没有使用代理类时完全相同：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Under the hood, the final statement is expanded to something similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，最终语句会扩展为类似于这样的内容：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Nice! The `std::sqrt()` operation is omitted while the interface of the `Vec2D`
    class is still intact. The simple version of `min_length()` we implemented earlier
    now performs its comparison more efficiently, as the `std::sqrt()` operation is
    omitted. What follows is the simple implementation, which now has become efficient
    as well:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！`std::sqrt()`操作被省略，而`Vec2D`类的接口仍然完整。我们之前实现的`min_length()`的简化版本现在执行比较更有效，因为省略了`std::sqrt()`操作。接下来是简化的实现，现在也变得高效了：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The optimized length comparisons between `Vec2D` objects now happen under the
    hood. The programmer implementing the `min_length()` function doesn't need to
    know about this optimization in order to benefit from it. Let's see what it looks
    like if we need the actual length.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec2D`对象之间的优化长度比较现在是在后台进行的。实现`min_length()`函数的程序员不需要知道这种优化，就能从中受益。让我们看看如果我们需要实际长度会是什么样子。'
- en: Calculating length with LengthProxy
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LengthProxy计算长度
- en: 'When requesting the actual length, the calling code changes a little bit. To
    trig the implicit cast to `float`, we have to commit to a `float` when declaring
    the `len` variable below; that is, we can''t just use `auto` as we usually do:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求实际长度时，调用代码会有一些变化。为了触发对`float`的隐式转换，我们必须在声明下面的`len`变量时承诺一个`float`；也就是说，我们不能像通常那样只使用`auto`：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we were to just write `auto`, the `len` object would be of type `LengthProxy`
    rather than `float`. We do not want the users of our code base to explicitly handle
    `LengthProxy` objects; proxy objects should operate in the dark and only their
    results should be utilized (in this case, the comparison result or the actual
    distance value is `float`). Even though we cannot hide proxy objects completely,
    let's see how we can tighten them to prevent misuse.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只写`auto`，`len`对象将是`LengthProxy`类型，而不是`float`。我们不希望我们的代码库的用户明确处理`LengthProxy`对象；代理对象应该在暗中运行，只有它们的结果应该被利用（在这种情况下，比较结果或实际距离值是`float`）。尽管我们无法完全隐藏代理对象，让我们看看如何收紧它们以防止误用。
- en: Preventing the misuse of LengthProxy
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止误用LengthProxy
- en: 'You may have noted that there can be a case where using the `LengthProxy` class
    might lead to worse performance. In the example that follows, the `std::sqrt()`
    function is invoked multiple times according to the programmer''s request for
    the length value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，使用`LengthProxy`类可能会导致性能变差的情况。在接下来的示例中，根据程序员对长度值的请求，多次调用`std::sqrt()`函数：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although this is an artificial example, there can be real-world cases where
    this might happen, and we want to force users of `Vec2d` to only invoke `operator
    float()` once per `LengthProxy` object. In order to prevent misuse we make the
    `operator float()` member function invocable only on rvalues; that is, the `LengthProxy`
    object can only be converted to a floating point if it is not tied to a variable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个人为的例子，但在现实世界中可能会出现这种情况，我们希望强制`Vec2d`的用户每个`LengthProxy`对象只调用一次`operator
    float()`。为了防止误用，我们使`operator float()`成员函数只能在rvalue上调用；也就是说，只有当`LengthProxy`对象没有绑定到变量时，才能将其转换为浮点数。
- en: We force this behavior by using `&&` as a modifier on the `operator float()`
    member function. The `&&` modifier works just like a `const` modifier, but where
    a `const` modifier forces the member function to not modify the object the `&&`
    modifier forces the function to operate on temporary objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`operator float()`成员函数上使用`&&`作为修饰符来强制执行此行为。`&&`修饰符的工作原理与`const`修饰符相同，但是`const`修饰符强制成员函数不修改对象，而`&&`修饰符强制函数在临时对象上操作。
- en: 'The modification looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 修改如下：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we were to invoke `operator float()` on a `LengthProxy` object tied to a
    variable, such as the `dist` object in the following example, the compiler would
    refuse to compile:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在绑定到变量的`LengthProxy`对象上调用`operator float()`，例如以下示例中的`dist`对象，编译器将拒绝编译：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, we can still invoke `operator float()` directly on the rvalue returned
    from `length()`, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们仍然可以直接在从`length()`返回的rvalue上调用`operator float()`，就像这样：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A temporary `LengthProxy` instance will still be created in the background,
    but since it is not tied to a variable, we are allowed to implicitly convert it
    to `float`. This will prevent misuse such as invoking `operator float()` several
    times on a `LengthProxy` object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 临时的`LengthProxy`实例仍将在后台创建，但由于它没有绑定到变量，因此我们可以将其隐式转换为`float`。这将防止滥用，例如在`LengthProxy`对象上多次调用`operator
    float()`。
- en: Performance evaluation
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能评估
- en: 'For the sake of it, let''s see how much performance we''ve actually gained.
    We will benchmark the following version of `min_element()`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看我们实际获得了多少性能，让我们来测试一下`min_element()`的以下版本：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to compare the proxy object optimization with something, we will define
    an alternative version, `Vec2DSlow`, which always computes the actual length using
    `std::sqrt()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将代理对象优化与其他内容进行比较，我们将定义一个另一版本`Vec2DSlow`，它总是使用`std::sqrt()`计算实际长度：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using Google Benchmark with a function template, we can see how much performance
    we gain when finding the minimum length of 1,000 vectors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Google Benchmark和函数模板，我们可以看到在查找1,000个向量的最小长度时获得了多少性能提升：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running this benchmark on an Intel i7 CPU generated the following results:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Intel i7 CPU上运行此基准测试生成了以下结果：
- en: Using unoptimized `Vec2DSlow` with `std::sqrt()` took 7,900 ns
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未优化的`Vec2DSlow`和`std::sqrt()`花费了7,900 ns
- en: Using `Vec2D` with `LengthProxy` took 1,800 ns
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LengthProxy`的`Vec2D`花费了1,800 ns
- en: This performance win corresponds to a speedup of more than 4x.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种性能提升相当于超过4倍的加速。
- en: This was one example of how we can avoid computations that are not necessary
    in some situations. But instead of making the interface of `Vec2D` more complicated,
    we managed to encapsulate the optimization inside the proxy object so that all
    clients could benefit from the optimization, without sacrificing clarity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，说明了我们如何在某些情况下避免不必要的计算。但是，我们成功地将优化封装在代理对象内部，而不是使`Vec2D`的接口更加复杂，以便所有客户端都能从优化中受益，而不会牺牲清晰度。
- en: A related technique for optimizing expressions in C++ is **expression templates**.
    This uses template metaprogramming to generate expression trees at compile time.
    The technique can be used for avoiding temporaries and to enable lazy evaluation.
    Expression templates is one of the techniques that makes linear algebra algorithms
    and matrix operations fast in Boost **Basic Linear Algebra Library** (**uBLAS**)
    and **Eigen**, [http://eigen.tuxfamily.org](http://eigen.tuxfamily.org). You can
    read more about how expression templates and fused operations can be used when
    designing a matrix class in *The C++ Programming Language*, *4th Edition*, by
    Bjarne Stroustrup.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: C++中用于优化表达式的相关技术是**表达式模板**。这利用模板元编程在编译时生成表达式树。该技术可用于避免临时变量并实现延迟评估。表达式模板是使Boost
    **基本线性代数库**（**uBLAS**）和**Eigen**中的线性代数算法和矩阵运算快速的技术之一，[http://eigen.tuxfamily.org](http://eigen.tuxfamily.org)。您可以在Bjarne
    Stroustrup的《C++程序设计语言》第四版中了解有关如何在设计矩阵类时使用表达式模板和融合操作的更多信息。
- en: We will end this chapter by looking at other ways to benefit from proxy objects
    when they are combined with overloaded operators.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看与重载运算符结合使用代理对象时的其他受益方式来结束本章。
- en: Creative operator overloading and proxy objects
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创造性的运算符重载和代理对象
- en: 'As you might already know, C++ has the ability to overload several operators,
    including the standard math operators such as plus and minus. Overloaded math
    operators can be utilized to create custom math classes that behave as numeric
    built-in types to make the code more readable. Another example is the stream operator,
    which in the standard library is overloaded in order to convert the objects to
    streams, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经知道的那样，C++具有重载多个运算符的能力，包括标准数学运算符，例如加号和减号。重载的数学运算符可用于创建自定义数学类，使其行为类似于内置数值类型，以使代码更易读。另一个例子是流运算符，在标准库中重载以将对象转换为流，如下所示：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Some libraries, however, use overloading in other contexts. The Ranges library,
    as discussed earlier, uses overloading to compose views like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些库在其他上下文中使用重载。如前所述，Ranges库使用重载来组合视图，如下所示：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we will explore how to use the pipe operator with proxy classes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何在代理类中使用管道运算符。
- en: The pipe operator as an extension method
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道运算符作为扩展方法
- en: Compared to other languages, for example, C#, Swift, and JavaScript, C++ does
    not support extension methods; that is, you cannot extend a class locally with
    a new member function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言相比，例如C＃，Swift和JavaScript，C++不支持扩展方法；也就是说，您不能在本地使用新的成员函数扩展类。
- en: 'For example, you cannot extend `std::vector` with a `contains(T val)` function
    to be used like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您不能使用如下所示的`std::vector`扩展`contains(T val)`函数：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, you can overload the pipe operator to achieve this, almost equivalent,
    syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以重载管道运算符以实现这种几乎等效的语法：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By using a proxy class, it's possible to accomplish this without much trouble.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用代理类，可以轻松实现这一点。
- en: The pipe operator
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道运算符
- en: 'Our goal here is to implement a simple pipe operator so that we can write the
    following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是实现一个简单的管道操作符，以便我们可以编写以下内容：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `contains()` function used with a pipeable syntax has two arguments: `numbers`
    and `seven`. Since the left argument, `numbers`, could be anything, we need the
    overload to contain something unique on the right-hand side. So, we create a `struct`
    template named `ContainsProxy`, which holds onto the argument on the right-hand
    side; this way, the overloaded pipe operator can recognize the overload:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可管道化语法的`contains()`函数有两个参数：`numbers`和`seven`。由于左参数`numbers`可以是任何东西，我们需要重载以在右侧包含一些唯一的东西。因此，我们创建了一个名为`ContainsProxy`的`struct`模板，它保存右侧的参数；这样，重载的管道操作符可以识别重载：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can use `ContainsProxy` like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像这样使用`ContainsProxy`：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The pipe operator works, although the syntax is still ugly as we need to specify
    the type. In order to make the syntax neater, we can simply make a convenience
    function that takes the value and creates a proxy containing the type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 管道操作符有效，尽管语法仍然很丑陋，因为我们需要指定类型。为了使语法更整洁，我们可以简单地创建一个方便的函数，它接受该值并创建一个包含类型的代理：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That''s all we need; we can now use it for any type or container:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的全部；现在我们可以将其用于任何类型或容器：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The example covered in this section show a rudimentary approach to implementing
    the pipe operator. Libraries such as the Ranges library and the Fit library by
    Paul Fultz, available at [https://github.com/pfultz2/Fit](https://github.com/pfultz2/Fit),
    implement adaptors that take a regular function and give it the ability to be
    invoked using the pipe syntax.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖的示例展示了实现管道操作符的一种基本方法。例如，Paul Fultz的Ranges库和Fit库（可在[https://github.com/pfultz2/Fit](https://github.com/pfultz2/Fit)找到）实现了适配器，它们接受常规函数并赋予其使用管道语法的能力。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the difference between lazy evaluation and eager
    evaluation. You also learned how to use hidden proxy objects to implement lazy
    evaluation behind the scenes, meaning that you now understand how to implement
    lazy evaluation optimizations while preserving the easy-to-use interface of your
    classes. Hiding complex optimizations inside library classes instead of having
    them exposed in the application code makes the application code more readable
    and less error-prone.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了惰性求值和急性求值之间的区别。您还学会了如何使用隐藏的代理对象在幕后实现惰性求值，这意味着您现在了解如何在保留类的易于使用的接口的同时实现惰性求值优化。将复杂的优化隐藏在库类中，而不是在应用程序代码中暴露它们，可以使应用程序代码更易读，更少出错。
- en: In the next chapter, we will shift focus and move on to concurrent and parallel
    programming using C++.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转移重点，转向使用C++进行并发和并行编程。
