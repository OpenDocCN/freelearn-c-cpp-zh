- en: Chapter 8. Building a Spreadsheet Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。构建电子表格应用程序
- en: In this chapter, we will start developing the last application of this book–a
    spreadsheet program capable of calculating numerical expressions as well as cutting
    and pasting cells with relative references. Similar to the word processor in the
    previous chapters, the spreadsheet program cuts and pastes ASCII and Unicode text
    as well as application-specific information. Moreover, it is possible to change
    the font and color of the cells and their horizontal and vertical alignment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始开发本书的最后一个应用程序——一个能够计算数值表达式以及使用相对引用剪切和粘贴单元格的电子表格程序。类似于前几章中的文本处理器，电子表格程序剪切和粘贴
    ASCII 和 Unicode 文本以及特定于应用程序的信息。此外，还可以更改单元格及其水平和垂直对齐方式的字体和颜色。
- en: 'In this chapter, we will look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Mouse and keyboard input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标和键盘输入
- en: Drawing a spreadsheet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制电子表格
- en: Saving and loading the spreadsheet
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载电子表格
- en: Cutting, copying, and pasting cell blocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪切、复制和粘贴单元格块
- en: Fonts, colors, and alignments of cell blocks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元格块的字体、颜色和对齐方式
- en: The MainWindow class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`MainWindow` 类'
- en: The `MainWindow` definition in this chapter looks very much like the previous
    definitions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中 `MainWindow` 的定义与之前的定义非常相似。
- en: '**MainWindow.cpp**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**MainWindow.cpp**'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The CalcDocument class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CalcDocument` 类'
- en: The `CalcDocument` class is the main class of the application. It catches mouse
    and keyboard events, handles scrolling and painting, and processes menu actions.
    However, the cell-level operations are handled by the `Cell` class, which we will
    cover in [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"), *Formula
    Interpretation*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`CalcDocument` 类是应用程序的主要类。它捕获鼠标和键盘事件，处理滚动和绘制，并处理菜单操作。然而，单元格级别的操作由 `Cell` 类处理，我们将在第
    9 章（[ch09.html](https://example.org/ch09.html "第 9 章。公式解释"）中介绍），*公式解释* 中进行介绍。'
- en: The user can mark one or several cells, in which case, the private field `calcMode`
    is set to `Mark`. The user can also edit the text in one cell, in which case the
    `calcMode` field is set to `Edit`. Similar to the word processor in the previous
    chapters, we refer to the current value of the `calcMode` field in expressions
    such as **in mark mode** and **in edit mode**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以标记一个或多个单元格，在这种情况下，私有字段 `calcMode` 被设置为 `Mark`。用户还可以编辑一个单元格中的文本，在这种情况下，`calcMode`
    字段被设置为 `Edit`。类似于前几章中的文本处理器，我们在 **标记模式** 和 **编辑模式** 等表达式中引用 `calcMode` 字段的当前值。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `OnMouseDown`, `OnMouseMove`, and `OnDoubleClick` methods catch the mouse
    actions in the same way as in the previous applications. Note that we do not override
    the `OnMouseUp` method. Contrary to the word processor of [Chapter 7](ch07.html
    "Chapter 7. Keyboard Input and Character Calculation"), *Keyboard Input and Character
    Calaculation*, this application remains in the `mark` mode until the user actually
    inputs a character, even if they mark only one cell. The user can also mark several
    cells by dragging the mouse.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMouseDown`、`OnMouseMove` 和 `OnDoubleClick` 方法以与先前应用程序相同的方式捕获鼠标动作。请注意，我们没有重写
    `OnMouseUp` 方法。与第 7 章（[ch07.html](https://example.org/ch07.html "第 7 章。键盘输入和字符计算"）中提到的“键盘输入和字符计算”的文本处理器相反，此应用程序在用户实际输入字符之前保持
    `mark` 模式，即使他们只标记了一个单元格。用户还可以通过拖动鼠标标记多个单元格。'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `OnHorizontalScroll` and `OnVerticalScroll` methods are called when the
    user changes the scroll bars. In the previous applications, we did not override
    these functions, but in this application, we want each scroll movement to result
    in a movement of an exact number of cells. Besides, in the `StandardDocument`
    constructor call, we use the `LogicalWithoutScroll` coordinate system in order
    to be able to handle the row and column headers of the spreadsheet, which are
    always located at the top and to the left of the client area regardless of the
    scroll bar settings. This implies that we have to handle scroll bar movements
    manually.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改滚动条时，会调用 `OnHorizontalScroll` 和 `OnVerticalScroll` 方法。在先前的应用程序中，我们没有重写这些函数，但在这个应用程序中，我们希望每次滚动都导致单元格移动一个精确的数量。此外，在
    `StandardDocument` 构造函数调用中，我们使用 `LogicalWithoutScroll` 坐标系统，以便能够处理电子表格的行和列标题，这些标题始终位于客户端区域的顶部和左侧，无论滚动条设置如何。这意味着我们必须手动处理滚动条移动。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The user can mark all cells by clicking on the **all** box in the top-left corner
    (`ClickAll`), all cells in a column by clicking on the column header (`ClickCol`),
    all cells in a row by clicking on the row header (`ClickRow`), or just one of
    the cells (`ClickCell`) by clicking on the cell.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过点击左上角的**all**框（`ClickAll`）标记所有单元格，通过点击列标题标记一列中的所有单元格（`ClickCol`），通过点击行标题标记一行中的所有单元格（`ClickRow`），或者通过点击单元格来标记单个单元格（`ClickCell`）。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `GetMouseLocation` method analyzes a mouse click and returns one of the
    `ClickArea` values. If the user clicks on the right of the spreadsheet, the rightmost
    cell on the row is selected, and if they click below the spreadsheet, the cell
    at the bottom of the column is selected. The `Reference` class is defined in [Chapter
    12](ch12.html "Chapter 12. The Auxiliary Classes"), *The Auxiliary Classes*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMouseLocation`方法分析鼠标点击并返回一个`ClickArea`值。如果用户点击在电子表格的右侧，则选择该行的最右单元格，如果他们点击在电子表格下方，则选择该列的最下单元格。`Reference`类在[第12章](ch12.html
    "第12章。辅助类") *辅助类*中定义。'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `MarkBlock` method marks the blocks in the click area depending on the marks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkBlock`方法根据标记标记点击区域内的块：'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OnDraw` method draws the row and column header as well as the cells themselves.
    In the `edit` mode, the `UpdateCaret` method sets the caret in the cell being
    edited.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDraw`方法绘制行和列标题以及单元格本身。在`edit`模式下，`UpdateCaret`方法设置正在编辑的单元格中的光标。'
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the user marks cells with the keyboard, the latest marked cell will always
    be visible. The `IsCellVisible` method returns `true` if it is visible, while
    the `MakeCellVisible` method makes sure it is visible by scrolling, if necessary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用键盘标记单元格时，最新标记的单元格始终可见。如果可见，`IsCellVisible`方法返回`true`，而`MakeCellVisible`方法通过滚动确保其可见性，如果需要的话。
- en: The `MakeCellVisible` method without parameters calls the `MakeCellVisible`
    method with the parameter with the edited cell, or the last marked cell, depending
    on whether the application holds the `edit` or `mark` mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无参数的`MakeCellVisible`方法调用带有编辑单元格的参数的`MakeCellVisible`方法，或者根据应用是否处于`edit`或`mark`模式，调用最后标记的单元格的`MakeCellVisible`方法。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the user finishes input text in a cell, the `ToMarkMode` method is called,
    which tries to change the application mode from `edit` to `mark`. It returns `false`
    if the input fails (if a formula with syntax error has been input):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在一个单元格中完成输入文本后，会调用`ToMarkMode`方法，尝试将应用模式从`edit`更改为`mark`。如果输入失败（如果输入了有语法错误的公式），则返回`false`：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Remark` method is called when the user has marked one or several cells.
    In order to avoid dazzle, it does not mark already marked cells:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户标记一个或多个单元格时，会调用`Remark`方法。为了避免混淆，它不会标记已经标记的单元格：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `OnChar` method is called when the user inputs a character in `mark` mode;
    the application is changed to `edit` mode:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在`mark`模式下输入字符时，会调用`OnChar`方法；应用模式将变为`edit`模式：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `OnKeyDown` method calls one of the specific key handling methods, which
    changes the caret position in the `edit` mode and changes the cell markings in
    the `mark` mode:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnKeyDown`方法调用一个特定的按键处理方法，在`edit`模式下改变光标位置，在`mark`模式下改变单元格标记：'
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `OnReturnKey` and `OnTabulatorKey` methods finish the input in the `edit`
    mode (unless a syntax error occurs) and moves the mark position one step down
    (*Return*), to the left (*Shift* + *Tab*) or to the right (*Tab*). However, in
    case of an error, an error message box is displayed and the `edit` mode remains.
    The only way for the user to finish the input of a formula with a syntax error
    is to press the *Esc* key, in which case the `OnEscapeKey` method is called and
    the cell''s value is reset to the value which it held at the beginning of the
    input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnReturnKey`和`OnTabulatorKey`方法在`edit`模式下完成输入（除非发生语法错误）并将标记位置向下移动一步（*Return*），向左（*Shift*
    + *Tab*）或向右（*Tab*）。然而，如果发生错误，将显示错误消息框，并且`edit`模式保持不变。用户完成有语法错误的公式的输入的唯一方法是按下*Esc*键，在这种情况下将调用`OnEscapeKey`方法，并将单元格的值重置为输入开始时的值：'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `OnDeleteKey` and `OnBackspaceKey` methods remove the current character
    from the `edit` mode and clear the marked cells in the `mark` mode:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDeleteKey`和`OnBackspaceKey`方法从`edit`模式中删除当前字符，并在`mark`模式下清除标记的单元格：'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similar to the previous applications, the `ClearDocument` method is called
    when the user selects the **New** menu item, the `ReadDocumentFromStream` method
    is called when they select the **Open** menu item, and the `WriteDocumentToStream`
    method is called when they select the **Save** or S**ave As** menu items:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的应用程序类似，当用户选择 **新建** 菜单项时调用 `ClearDocument` 方法，当用户选择 **打开** 菜单项时调用 `ReadDocumentFromStream`
    方法，当用户选择 **保存** 或 **另存为** 菜单项时调用 `WriteDocumentToStream` 方法：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A text that begins with an equal sign (**=**) followed by a numerical expression
    with cell references is regarded as a **formula**. Technically, an equal sign
    followed by something other than a numerical expression is also considered a formula.
    However, in that case, it is a formula with a syntax error. When the user inputs
    a formula, the cells referred to in the formula constitute the cell''s **source
    set**. The **target set** of a cell is made up by the cells that have it at a
    source (the sets are more exactly defined at the end of this chapter). The `WriteSetMapToStream`
    and `ReadSetMapFromStream` methods write and read the source and target set maps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以等号（**=**) 开头后跟带有单元格引用的数值表达式被视为 **公式**。技术上讲，等号后跟的不是数值表达式的内容也被视为公式。然而，在这种情况下，它是一个存在语法错误的公式。当用户输入公式时，公式中引用的单元格构成了单元格的
    **源集**。单元格的 **目标集** 由具有该单元格作为源（集合在本章末尾更精确地定义）的单元格组成。`WriteSetMapToStream` 和 `ReadSetMapFromStream`
    方法写入和读取源和目标集映射：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this application, we overwrite the methods `IsCopyAsciiReady`, `IsCopyUnicodeReady`,
    and `IsCopyGenericReady` from the `StandardDocument` class. They are called by
    the `OnCopy`  method in the `StandardDocument` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，我们重写了 `StandardDocument` 类中的 `IsCopyAsciiReady`、`IsCopyUnicodeReady`
    和 `IsCopyGenericReady` 方法。它们是由 `StandardDocument` 类中的 `OnCopy` 方法调用的：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It may seem strange that both the `CopyEnable` method and the three more specific
    enable methods are overridden. However, the `CopyEnable` method returns `true`
    if the application is ready for copying (which it is in the `mark` mode), while
    the other methods are called by the `OnCopy` method in the `StandardDocument`
    class to decide whether the application is ready to copy in the given format.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来很奇怪，`CopyEnable` 方法以及三个更具体的启用方法都被重写了。然而，`CopyEnable` 方法在应用程序准备好复制时返回 `true`（在
    `mark` 模式下是这样），而其他方法是由 `StandardDocument` 类中的 `OnCopy` 方法调用来决定应用程序是否准备好以给定格式复制。
- en: 'Their default implementation is to return `false`, but we need to override
    them, as it is always possible to copy the marked cells in `mark` mode:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的默认实现是返回 `false`，但我们需要重写它们，因为在 `mark` 模式下始终可以复制标记的单元格：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could override the `PasteEnable` method from the `StandardDocument` class
    in the same way we override the `CopyEnable` method. However, in this application,
    we need some finer testing. Therefore, we override the `IsPasteAsciiReady`, `IsPasteUnicodeReady`,
    and `IsPasteGenericReady` methods instead. In the word processor of the previous
    chapters, we could always paste text, irrespective of the number of characters
    or paragraphs. In this application, however, we need to check whether the block
    to be pasted fits in the spreadsheet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像重写 `CopyEnable` 方法一样重写 `StandardDocument` 类中的 `PasteEnable` 方法。然而，在此应用程序中，我们需要进行一些更精细的测试。因此，我们重写了
    `IsPasteAsciiReady`、`IsPasteUnicodeReady` 和 `IsPasteGenericReady` 方法。在前几章的文字处理器中，我们可以始终粘贴文本，无论字符数或段落数。然而，在此应用程序中，我们需要检查要粘贴的块是否适合电子表格：
- en: '[PRE19]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similar to the word processor, we override the `PasteAscii`, `PasteUnicode`,
    and `PasteGeneric` methods. Remember that these methods are called in the order
    in which the formats are given in the list in the `CalcDocument` constructor call.
    When the corresponding enable method `IsPasteAsciiReady`, `IsPasteUnicodeReady`,
    or `IsPasteGenericReady` returns `true`, the `PasteAscii`, `PasteUnicode`, or
    `PasteGeneric` method is called. Only the first paste method is called. If none
    of the enable methods returns `true`, none of the paste methods is called:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与文字处理器类似，我们重写了 `PasteAscii`、`PasteUnicode` 和 `PasteGeneric` 方法。记住，这些方法是在 `CalcDocument`
    构造函数调用中给出的格式列表的顺序中调用的。当相应的启用方法 `IsPasteAsciiReady`、`IsPasteUnicodeReady` 或 `IsPasteGenericReady`
    返回 `true` 时，将调用 `PasteAscii`、`PasteUnicode` 或 `PasteGeneric` 方法。只有第一个粘贴方法会被调用。如果没有任何启用方法返回
    `true`，则不会调用任何粘贴方法：
- en: '[PRE20]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `DeleteEnable` method always returns `true` in the `mark` mode, since there
    is always at least one cell marked and ready to be deleted. It returns `true`
    in the `edit` mode if the caret is not located at the end of the text of the edited
    cell.  The `OnDelete` method simply calls the `OnDeleteKey` method, because the
    **Delete** menu item has the same effect as that of a user pressing the *Delete*
    key:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteEnable` 方法在 `mark` 模式下始终返回 `true`，因为总是至少有一个单元格被标记并准备好删除。在 `edit` 模式下，如果光标不在编辑单元格文本的末尾，则返回
    `true`。`OnDelete` 方法简单地调用 `OnDeleteKey` 方法，因为**删除**菜单项与用户按下 *Delete* 键具有相同的效果：'
- en: '[PRE21]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `OnFont` and `OnBackgroundColor` methods are called when the user selects
    the **Font** or **Background Color** menu item. They display the standard **Font**
    or **Color** dialog:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**字体**或**背景颜色**菜单项时，会调用 `OnFont` 和 `OnBackgroundColor` 方法。它们显示标准的**字体**或**颜色**对话框：
- en: '[PRE22]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Horizontally, the text of a cell can be aligned to left, center, right, or
    justified. Vertically, it can be aligned to top, center, or bottom. All the radio
    methods call the `IsHorizontalAlignment` or `IsVerticalAlignment` methods, and
    all the selection methods call the `SetHorizontalAlignment` or `SetVerticalAlignment`
    methods:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 水平方向上，单元格的文本可以左对齐、居中对齐、右对齐或两端对齐。垂直方向上，它可以上对齐、居中对齐或底对齐。所有单选方法都调用 `IsHorizontalAlignment`
    或 `IsVerticalAlignment` 方法，所有选择方法都调用 `SetHorizontalAlignment` 或 `SetVerticalAlignment`
    方法：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `InterpretEditCell` method interprets the cell after the user has finished
    the input and creates a **syntax tree** (described in [Chapter 9](ch09.html "Chapter 9. Formula
    Interpretation"), *Formula Interpretation*) in the case of a formula (or throws
    an exception in the case of syntax error). The `IsCircular` method returns `true`
    if the cell is part of a circular reference (the cell formula refers to itself,
    directly or indirectly). The `RemoveTargetSetMap` method removes the targets of
    the cell, and the `AddTargetSetMap` method adds targets to the cell. The `EvaluateCell`
    method evaluates the value of one cell, while the `EvaluateRecursive` method recursively
    evaluates the values of all its target cells. Finally, the `InvalidateCell` method
    invalidates the cell so that it can be redrawn later:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterpretEditCell` 方法在用户完成输入后解释单元格，并在公式的情况下创建一个**语法树**（在第 9 章[公式解释](ch09.html
    "第 9 章。公式解释")中描述，*公式解释*）。如果出现语法错误，则抛出异常。`IsCircular` 方法如果单元格是循环引用的一部分（单元格公式直接或间接地引用自身），则返回
    `true`。`RemoveTargetSetMap` 方法删除单元格的目标，而 `AddTargetSetMap` 方法向单元格添加目标。`EvaluateCell`
    方法评估单个单元格的值，而 `EvaluateRecursive` 方法递归地评估所有目标单元格的值。最后，`InvalidateCell` 方法使单元格无效，以便稍后可以重新绘制：'
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As mentioned at the beginning of this section, the `calcMode` method is set
    to `Mark` or `Edit`, and we refer to its current value as **in mark mode** and
    **in edit mode**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，`calcMode` 方法设置为 `Mark` 或 `Edit`，我们将其当前值称为**标记模式**和**编辑模式**：
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `markOk` field is set by the `OnMouseDown` method to signal the `OnMouseMove`
    method that it is clear to mark cells:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`markOk` 字段由 `OnMouseDown` 方法设置，以通知 `OnMouseMove` 方法可以标记单元格：'
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `firstMarkRef` and `lastMarkRef` fields refer to the first and last marked
    cell in the spreadsheet in the `mark` mode. Note that they refer to their chronological
    order rather than their physical order, which means that the first marked reference
    can be larger than the last marked reference. When necessary, in some methods,
    the minimum and maximum references are calculated:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mark` 模式下，`firstMarkRef` 和 `lastMarkRef` 字段分别指向电子表格中第一个和最后一个标记的单元格。请注意，它们指的是它们的顺序而不是物理顺序，这意味着第一个标记引用可以大于最后一个标记引用。在必要时，在某些方法中，会计算最小和最大引用：
- en: '[PRE27]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `edit` mode, `editRef` refers to the cell currently edited and `editIndex`
    to the index of the next input position in the cell text (and the caret position):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `edit` 模式下，`editRef` 指的是当前编辑的单元格，而 `editIndex` 指的是单元格文本中的下一个输入位置索引（以及光标位置）：
- en: '[PRE28]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `cellMatrix` field holds the spreadsheet of the application. `Rows` and
    `Cols` are constant values and `Cell` is the class holding the information of
    each cell. `Matrix` is defined in [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"),
    *Formula Interpretation*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellMatrix` 字段持有应用程序的电子表格。`Rows` 和 `Cols` 是常量值，`Cell` 是包含每个单元格信息的类。`Matrix`
    在第 9 章[公式解释](ch09.html "第 9 章。公式解释")中定义。'
- en: '[PRE29]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the user inputs a formula in a cell, each reference in the formula becomes
    a source. In the same way, each of the source cells is given a cell as a target.
    The source and target sets of the cells are stored in the `sourceSetMap` and `targetSetMap`
    methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在单元格中输入一个公式时，公式中的每个引用都成为一个源。同样，每个源单元格被赋予一个目标单元格。单元格的源和目标集合存储在`sourceSetMap`和`targetSetMap`方法中：
- en: '[PRE30]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The value of the `CalcFormat` method used when identifying cut, copy, and paste
    format is arbitrarily chosen to be 1003:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别剪切、复制和粘贴格式时使用的`CalcFormat`方法的值被任意选择为1003：
- en: '[PRE31]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the user finishes the input of a cell with the *Esc* key, the previous
    content of the cell (what was stored in the cell before the input began) gets
    stored in the `prevCell` variable and is copied back to the cell:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用*Esc*键完成单元格的输入时，单元格的先前内容（输入开始之前存储在单元格中的内容）被存储在`prevCell`变量中，并复制回单元格：
- en: '[PRE32]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**CalcDocument.cpp**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**CalcDocument.cpp**'
- en: '[PRE33]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The constructor calls the `StandardDocument` constructor in the same way as
    in the word processor of the previous chapters. However, note that we choose the
    `LogicalWithoutScroll` coordinate system (in the word processor, we chose `LogicalWithScroll`).
    This implies that the coordinates of the client area are not updated when the
    user changes the scroll bar settings. Instead, we have to catch the scroll bar
    movements with the `OnHorizontalScroll` and `OnVerticalScroll` methods. This is
    because the row and column headers are always placed at the top and to the left
    of the client area, regardless of the current scroll bar settings. Besides, we
    also want the scrolling to result in exact row and column movements. We also give
    `false` as the seventh parameter, indicating that we omit the **Print** and **Print
    Preview** file items in the **File** menu in this application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数以与上一章中的文字处理器相同的方式调用`StandardDocument`构造函数。然而，请注意，我们选择了`LogicalWithoutScroll`坐标系（在文字处理器中，我们选择了`LogicalWithScroll`）。这意味着当用户更改滚动条设置时，客户端区域的坐标不会更新。相反，我们必须使用`OnHorizontalScroll`和`OnVerticalScroll`方法来捕获滚动条移动。这是因为行和列标题始终放置在客户端区域的顶部和左侧，无论当前的滚动条设置如何。此外，我们还想使滚动产生精确的行和列移动。我们还把第七个参数设置为`false`，表示在这个应用程序的**文件**菜单中省略**打印**和**打印预览**文件项：
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this application, we only add the **Format** menu besides the **File**, **Edit**,
    and **Help** standard menus to the standard menu bar. The **Format** menu holds
    the **Font** and **Background Color** items as well as the sub menus **Horizontal
    Alignment** and **Vertical Alignment**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们只将**格式**菜单添加到**文件**、**编辑**和**帮助**标准菜单之外的标准菜单栏中。**格式**菜单包含**字体**和**背景颜色**项目，以及子菜单**水平对齐**和**垂直对齐**。
- en: '[PRE35]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `GenerateCaretList` method is called for each cell in the spreadsheet,
    even though every cell is empty to start with. However, there is an extra caret
    rectangle generated for the position to the right of the text, which we need in
    case the user double-clicks on an empty cell. If they do, we use the caret list
    to find the index of the character clicked on (which naturally is zero for an
    empty cell):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作表中的每个单元格，都会调用`GenerateCaretList`方法，尽管每个单元格最初都是空的。然而，为了应对用户双击空单元格的情况，我们会在文本右侧的位置生成一个额外的光标矩形。如果用户这样做，我们使用光标列表来找到点击的字符索引（对于空单元格，这个索引自然为零）：
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Mouse input
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: 'The `OnMouseDown` and `OnMouseMove` methods look up the part of the spreadsheet
    with the mouse position and mark the appropriate set of cells. If the user inputs
    a formula with a syntax error, it is not possible to change the mode from `edit`
    to `mark`, so an error message is displayed in a message box, and the `edit` mode
    remains as it is. In that case, the `markOk` method is set to `false`, indicating
    that the `OnMouseMove` and `OnDoubleClick` methods will take no actions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMouseDown`和`OnMouseMove`方法查找鼠标位置所在的电子表格部分，并标记适当的单元格集合。如果用户输入了一个语法错误的公式，则无法从`edit`模式切换到`mark`模式，因此会在消息框中显示错误消息，并且`edit`模式保持不变。在这种情况下，`markOk`方法被设置为`false`，表示`OnMouseMove`和`OnDoubleClick`方法将不采取任何操作：'
- en: '[PRE37]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that the `OnMouseMove` method only takes action if the `markOk` method
    is set to `true` in the `OnMouseDown` method. Since the `OnMouseDown` method is
    always called before the `OnMouseMove` method, the `markOk` method is always properly
    set. One difference between the `OnMouseDown` and `OnMouseMove` methods is that
    the `OnMouseDown` method sets the first and last marked cell reference, while
    the `OnMouseMove` method only sets the last marked cell reference:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`OnMouseMove`方法仅在`OnMouseDown`方法中将`markOk`方法设置为`true`时才会采取行动。由于`OnMouseDown`方法总是在`OnMouseMove`方法之前被调用，因此`markOk`方法总是被正确设置。`OnMouseDown`和`OnMouseMove`方法之间有一个区别，即`OnMouseDown`方法设置第一个和最后一个标记的单元格引用，而`OnMouseMove`方法只设置最后一个标记的单元格引用：
- en: '[PRE38]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When the user double-clicks, the input position (and caret) is set to the character
    clicked on. We look up the clicked area in the same way as in the `OnMouseDown`
    and `OnMouseMove` methods. However, the double-click only takes effect if the
    user clicks on a cell, not the all-box or one of the row or column headers. We
    mark the clicked cell, set the application to the `edit` mode, and extract the
    edit index from the cell by calling the `MouseToIndex` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击时，输入位置（和光标）将被设置为点击的字符。我们以与`OnMouseDown`和`OnMouseMove`方法相同的方式查找点击区域。然而，只有当用户点击单元格而不是全选框或行或列标题时，双击才生效。我们标记点击的单元格，将应用程序设置为`edit`模式，并通过调用`MouseToIndex`方法从单元格中提取编辑索引：
- en: '[PRE39]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Scrolling and marking
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动和标记
- en: 'The `OnHorizontalScroll` and `OnVerticalScroll` methods are called when the
    user changes the scroll bar settings. We adjust the position to the nearest column
    or row and set the scroll position. These methods (together with `GetMouseLocation`)
    are the reason we chose the `LogicalWithoutScroll` coordinate system in the `CalcDocument`
    constructor call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改滚动条设置时，会调用`OnHorizontalScroll`和`OnVerticalScroll`方法。我们将位置调整到最近的列或行并设置滚动位置。这些方法（连同`GetMouseLocation`）是我们选择在`CalcDocument`构造函数调用中选择`LogicalWithoutScroll`坐标系的原因：
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `GetMouseLocation` method takes the position of a mouse click and returns
    one of the four areas of the client window: the all-box in the top-left corner
    (`ClickAll`), one of the column headers (`ClickCol`), one of the row headers (`ClickRow`),
    or one of the cells in the spreadsheet (`ClickCell`). In order for these methods
    to work properly, we have to choose the `LogicalWithoutScroll` coordinate system
    in the `CalcDocument` constructor call. We must be able to find the mouse position
    without any regard to the current scroll settings.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMouseLocation`方法获取鼠标点击的位置，并返回客户端窗口的四个区域之一：左上角的全选框（`ClickAll`）、列标题之一（`ClickCol`）、行标题之一（`ClickRow`）或电子表格中的单元格之一（`ClickCell`）。为了使这些方法正常工作，我们必须在`CalcDocument`构造函数调用中选择`LogicalWithoutScroll`坐标系。我们必须能够在不考虑当前滚动设置的情况下找到鼠标位置。'
- en: 'If the user clicks on the all-box (where both the horizontal and vertical positions
    are within the header dimension), we return the `ClickAll` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击全选框（其中水平和垂直位置都在标题维度内），我们返回`ClickAll`方法：
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the mouse click is not located within the all-box but within the header
    width, we return the `ClickRow` method and set the cell reference to the row clicked
    on. If the mouse click is below the bottom row, the bottom row is selected:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标点击不在全选框内但位于标题宽度内，我们返回`ClickRow`方法并将单元格引用设置为点击的行。如果鼠标点击在底部行下方，则选择底部行：
- en: '[PRE42]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If the mouse click is not located within the all-box or in a row header but
    within the header height, we return the `ClickCol` method and set the cell reference
    to the column clicked on. If the mouse click is to the right of the rightmost
    column, the rightmost column is selected:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标点击不在全选框或行标题内，但位于标题高度内，我们返回`ClickCol`方法并将单元格引用设置为点击的列。如果鼠标点击在最右侧列的右侧，则选择最右侧的列：
- en: '[PRE43]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the mouse click is not located within the all-box or at a row or column
    header, we return the `ClickCell` method and set the cell reference to the cell
    clicked on. If the mouse click is below the bottom row, the bottom row is selected,
    and if the mouse click is to the right of the rightmost column, the rightmost
    column selected:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标点击不在全选框内或在行或列标题上，我们返回`ClickCell`方法并将单元格引用设置为点击的单元格。如果鼠标点击在底部行下方，则选择底部行，并且如果鼠标点击在最右侧列的右侧，则选择最右侧的列：
- en: '[PRE44]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is an outline of the different parts of the spreadsheet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是电子表格不同部分的概述：
- en: '![Scrolling and marking](img/B05475_08_01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![滚动和标记](img/B05475_08_01.jpg)'
- en: 'The `MarkBlock` method marks a part of the spreadsheet due to the `clickArea`
    parameter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkBlock`方法根据`clickArea`参数标记工作表的一部分：'
- en: '[PRE45]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the user clicks on the all-box, all cells in the spreadsheet are marked:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击全选框，工作表中的所有单元格都会被标记：
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If they click on a row, all cells in that row are marked:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们点击一行，该行中的所有单元格都会被标记：
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If they click on a column, all cells in that column are marked:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们点击一个列，该列中的所有单元格都会被标记：
- en: '[PRE48]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If they click on a cell, only that cell gets marked:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们点击一个单元格，只有该单元格会被标记：
- en: '[PRE49]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Painting
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制
- en: 'The `OnDraw` method is called when the window client area needs to be repainted
    partly or completely. The client area can be divided into five parts as outlined
    earlier: the top-left corner, the row header, the column header, the cell space,
    and the area outside the spreadsheet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口客户端区域需要部分或完全重绘时，会调用`OnDraw`方法。客户端区域可以划分为五个部分，如前所述：左上角、行标题、列标题、单元格空间以及工作表外的区域：
- en: '[PRE50]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We use the scroll bar settings to find the top and leftmost row and column.
    We cannot simply draw all cells (unless the scroll bar settings are zero) since
    it would  overwrite the row or column headers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用滚动条设置来找到顶部和最左边的行和列。我们不能简单地绘制所有单元格（除非滚动条设置为零），因为这会覆盖行或列标题：
- en: '[PRE51]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The all-box is simply a rectangle:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 全选框只是一个矩形：
- en: '[PRE52]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When drawing the column headers, we calculate the horizontal position of the
    cell''s left border by multiplying the column index by the column width. We also
    need to subtract the current setting of the horizontal scroll bar and add the
    width of the header. The first column has index zero and will be named `A`, so
    we add the column index to the character `A` in order to find its name:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制列标题时，我们通过将列索引乘以列宽度来计算单元格左边的水平位置。我们还需要减去当前的水平滚动条设置并加上标题的宽度。第一列的索引为零，将被命名为`A`，因此我们将列索引加到字符`A`上以找到其名称：
- en: '[PRE53]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the same way, when drawing the row headers, we calculate the vertical position
    of the cell''s top border by multiplying the row index by the row height. We also
    need to subtract the current setting of the vertical scroll bar and add the height
    of the header:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当绘制行标题时，我们通过将行索引乘以行高度来计算单元格顶部的垂直位置。我们还需要减去当前的垂直滚动条设置并加上标题的高度：
- en: '[PRE54]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Since the marked cells will be inverted and the `firstMarkRef` and `lastMarkRef`
    methods refer to the chronological order of the marking, we calculate the minimal
    and maximal markings:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标记的单元格将被反转，并且`firstMarkRef`和`lastMarkRef`方法指的是标记的时间顺序，因此我们计算最小和最大的标记：
- en: '[PRE55]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we draw the cells. For the cells marked or being edited, the third
    `DrawCell` parameter is `true` and the cell is inversed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绘制单元格。对于标记或正在编辑的单元格，第三个`DrawCell`参数是`true`，单元格被反转：
- en: '[PRE56]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Visibility
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视性
- en: 'The `IsCellVisible` method returns `true` if the cell is visible in the window''s
    client area. The index of the first and last visible row and column is calculated
    from the current scroll bar settings. The given cell reference is then compared
    to the references of the visible cells:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsCellVisible`方法返回`true`，如果单元格在窗口的客户端区域内可见。第一行和最后一行以及第一列和最后一列的索引是从当前的滚动条设置中计算出来的。然后，给定的单元格引用与可见单元格的引用进行比较：'
- en: '[PRE57]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `MakeCellVisible` method makes the cell being edited visible in `edit`
    mode and the last marked cell visible in the `mark` mode:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeCellVisible`方法在`edit`模式下使正在编辑的单元格可见，在`mark`模式下使最后标记的单元格可见：'
- en: '[PRE58]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `MakeCellVisible` method makes the cell visible by comparing it to the
    current scroll bar settings. If necessary, it changes the scroll bar settings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeCellVisible`方法通过将其与当前的滚动条设置进行比较，使单元格可见。如果需要，它会更改滚动条设置：'
- en: '[PRE59]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we check whether the width of the spreadsheet is larger than the width
    of the client area, in which case it may be necessary to change the setting of
    the horizontal scroll bar:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查工作表的宽度是否大于客户端区域的宽度，如果是这样，可能需要更改水平滚动条的设置：
- en: '[PRE60]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If the cell''s left border is located to the left of the client area''s left
    border or if the cell''s right border is located to the right of the client area''s
    right border, we change the scroll bar setting, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格的左边界位于客户端区域左边界左侧或单元格的右边界位于客户端区域右边界右侧，我们将更改滚动条设置，如下所示：
- en: '[PRE61]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If the height of the spreadsheet is more than the height of the client area,
    it may be necessary to change the setting of the horizontal scroll bar:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工作表的高度超过客户端区域的高度，可能需要更改水平滚动条的设置：
- en: '[PRE62]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the cell''s top border is located above the client area''s top border or
    if the cell''s bottom border is located below the client area''s bottom border,
    we change the scroll bar settings:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格的顶部边框位于客户端区域顶部边框之上或单元格的底部边框位于客户端区域底部边框之下，我们更改滚动条设置：
- en: '[PRE63]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Marking and updating
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记和更新
- en: The `UpdateCaret` method sets the caret in `edit` mode if the edited cell is
    visible. Otherwise, it clears the caret. We have to check whether the cell is
    visible. Otherwise, the caret may be shown in one of the header areas. In the
    keyboard `insert` mode, the caret is a vertical bar, and in the `overwrite` mode,
    it is a rectangle the size of the current character.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCaret` 方法在编辑的单元格可见时将光标设置在 `edit` 模式下。否则，它清除光标。我们必须检查单元格是否可见。否则，光标可能会显示在某个标题区域中。在键盘
    `insert` 模式下，光标是一个垂直条，而在 `overwrite` 模式下，它是一个与当前字符大小相同的矩形。'
- en: '[PRE64]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `ToMarkMode` method is called when the user ends the input of the text
    in the cell by pressing the *Return* or *Tab* key or by clicking the mouse. Its
    first task is to check whether the input is valid by calling the `InterpretEditCell`
    method, which returns `false` if the text contains a formula with a syntax error.
    In that case, the `edit` mode remains unchanged and `false` is returned. However,
    if the cell interpretation goes well, the application is set to the `mark` mode
    and we get `true` in return:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过按下 *Return* 或 *Tab* 键或点击鼠标来结束单元格中的文本输入时，会调用 `ToMarkMode` 方法。它的第一个任务是调用
    `InterpretEditCell` 方法来检查输入是否有效，如果文本包含语法错误的公式，则返回 `false`。在这种情况下，`edit` 模式保持不变，并返回
    `false`。然而，如果单元格解释顺利，应用程序设置为 `mark` 模式，并返回 `true`：
- en: '[PRE65]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `Remark` method unmarks the marked cells and marks the new block given
    by the parameters without any unnecessary updating. That is, cells already marked
    shall not be invalidated. Note that the first and last marked cells refer to their
    chronological order rather than their locations on the spreadsheet. The last row
    or column may be less reflective than the first one. Therefore, we introduce the
    minimal and maximal variables to reflect their actual locations in the spreadsheet:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Remark` 方法取消标记已标记的单元格，并标记由参数给出的新块，而不进行任何不必要的更新。也就是说，已标记的单元格不应被无效化。请注意，第一个和最后一个标记单元格指的是它们的时序顺序，而不是它们在电子表格上的位置。最后一行或列可能不如第一行或列明显。因此，我们引入最小和最大变量来反映它们在电子表格中的实际位置：'
- en: '[PRE66]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the previous marked block, all cells that are not located in the new marked
    block are invalidated in order for them to be redrawn as unmarked cells. No old
    cells within the new marked blocks become invalidated:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个标记块中，所有不在新标记块中的单元格都被无效化，以便它们被重新绘制为未标记的单元格。新标记块内的任何旧单元格都不会被无效化：
- en: '[PRE67]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the new marked block, all cells that are not located in the old marked block
    are invalidated in order for them to be redrawn as unmarked cells. No already
    marked cells become invalidated:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在新标记块中，所有不在旧标记块中的单元格都被无效化，以便它们被重新绘制为未标记的单元格。任何已经标记的单元格都不会被无效化：
- en: '[PRE68]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The first and last marked reference is set and the invalidated cells are updated:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 设置第一个和最后一个标记引用，并更新无效化的单元格：
- en: '[PRE69]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Keyboard input
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键盘输入
- en: 'The `OnCharDown` method is called every time the user presses a graphical key
    on the keyboard. In the `mark` mode, the application is changed to the `edit`
    mode, where the edit reference is set to the first marked reference, the edit
    index is set to zero since the start of the input resets the cell, and the `prevCell`
    variable is set as backup in case the user finishes the input by pressing the
    *Esc* key:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户在键盘上按下图形键时都会调用 `OnCharDown` 方法。在 `mark` 模式下，应用程序更改为 `edit` 模式，其中编辑引用设置为第一个标记引用，编辑索引设置为输入开始以来的零，并将
    `prevCell` 变量设置为备份，以防用户通过按下 *Esc* 键完成输入：
- en: '[PRE70]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The cell to be edited is made visible, the character is added to the text,
    and the caret rectangle is regenerated. Finally, the caret and window are updated,
    since the cell has been altered and the edit index has been updated:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑的单元格被设置为可见，字符被添加到文本中，并且光标矩形被重新生成。最后，由于单元格已被更改并且编辑索引已更新，因此更新光标和窗口：
- en: '[PRE71]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `OnKeyDown` method is called every time the user presses a key. The appropriate
    method is called in the case of the arrow keys, *Page Up*, *Page Down*, *Home*,
    *End*, *Return*, *Tab*, *Insert*, *Delete*, or *Backspace*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户按下键时都会调用 `OnKeyDown` 方法。在箭头键、*Page Up*、*Page Down*、*Home*、*End*、*Return*、*Tab*、*Insert*、*Delete*
    或 *Backspace* 的情况下，会调用适当的方法：
- en: '[PRE72]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `OnLeftArrowKey` method is called when the user presses the left arrow
    key. We have three different cases to consider depending on the `edit` or `mark`
    mode and on whether the user presses the *Shift* key. In the `edit` mode, we make
    the edit cell visible, move the edit index one step to the left if it is not already
    at the leftmost position, and update the caret:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下左箭头键时，会调用`OnLeftArrowKey`方法。根据`edit`或`mark`模式以及用户是否按下*Shift*键，我们有三种不同的情况要考虑。在`edit`模式下，我们使编辑单元格可见，如果编辑索引不在最左侧位置，则将其向左移动一个步骤，并更新光标：
- en: '[PRE73]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the `mark` mode, we have to take into consideration whether the *Shift*
    key is pressed. If it is not, we place the marked block (both the first and last
    marked cells) one step to the left of the last marked cell unless it is already
    at the leftmost column:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mark`模式下，我们必须考虑是否按下了*Shift*键。如果没有按下，我们将标记的块（第一个和最后一个标记单元格）相对于最后一个标记单元格向左移动一个步骤，除非它已经在最左侧列：
- en: '[PRE74]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If the *Shift* key is pressed, we move the last marked cell one step to the
    left unless it is already at the leftmost position. The first marked cell is not
    affected:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了*Shift*键，如果标记单元格不在最左侧位置，我们将最后一个标记单元格向左移动一个步骤，除非它已经在最左侧位置。第一个标记单元格不受影响：
- en: '[PRE75]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `OnRightArrowKey` method is called when the user presses the right arrow
    key. It works similarly to the `OnLeftArrowKey` method. In the `edit` mode, we
    make the edit cell visible, move the edit index one step to the right if it is
    not already at the rightmost position, and update the caret:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下右箭头键时，会调用`OnRightArrowKey`方法。它的工作方式与`OnLeftArrowKey`方法类似。在`edit`模式下，我们使编辑单元格可见，如果编辑索引不在最右侧位置，则将其向右移动一个步骤，并更新光标：
- en: '[PRE76]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the `mark` mode, we have to take into consideration whether the *Shift*
    key is pressed. If it is not pressed, we place the marked block one step to the
    right of the first marked cell, unless it already is at the rightmost column:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mark`模式下，我们必须考虑是否按下了*Shift*键。如果没有按下，我们将标记的块相对于第一个标记单元格向右移动一个步骤，除非它已经在最右侧列：
- en: '[PRE77]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If the *Shift* key is pressed, we move the last marked cell one step to the
    right unless it is already at the rightmost position. The first marked cell is
    not affected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了*Shift*键，如果标记单元格不在最右侧位置，我们将最后一个标记单元格向右移动一个步骤，除非它已经在最右侧位置。第一个标记单元格不受影响：
- en: '[PRE78]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The `OnUpArrowKey` method is called when the user presses the up arrow key.
    In the `edit` mode, no action is taken:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下上箭头键时，会调用`OnUpArrowKey`方法。在`edit`模式下，不执行任何操作：
- en: '[PRE79]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If the *Shift* key is not pressed in the `mark` mode, we place the marked cell
    one step up relative to the first marked cell if it is not already in the top
    row. In that case, we place the marked block in the first marked cell:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`mark`模式下没有按下*Shift*键，如果标记单元格不在最上行，我们将标记单元格相对于第一个标记单元格向上移动一个步骤。在这种情况下，我们将标记块放在第一个标记单元格中：
- en: '[PRE80]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the *Shift* key is pressed, we move the last marked cell one step up unless
    it is already in the top row. The first marked cell is not affected:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了*Shift*键，如果标记单元格不在最上行，我们将最后一个标记单元格向上移动一个步骤，除非它已经在最上行。第一个标记单元格不受影响：
- en: '[PRE81]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `OnDownArrowKey` method is called when the user presses the down arrow
    key. It works in a way similar to the `OnUpArrowKey` method. In the `edit` mode,
    no action is taken:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下下箭头键时，会调用`OnDownArrowKey`方法。它的工作方式与`OnUpArrowKey`方法类似。在`edit`模式下，不执行任何操作：
- en: '[PRE82]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If the *Shift* key is not pressed in the `mark` mode, we place the marked block
    one step relatively under the first marked cell, unless it already is in the bottom
    row:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`mark`模式下没有按下*Shift*键，我们将标记的块相对于第一个标记单元格向下移动一个步骤，除非它已经在最后一行：
- en: '[PRE83]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If the *Shift* key is pressed, we move the last marked cell one step down unless
    it is already in the bottom row. The first marked cell is not affected:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了*Shift*键，我们将最后一个标记单元格向下移动一个步骤，除非它已经在最后一行。第一个标记单元格不受影响：
- en: '[PRE84]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `OnHomeKey` method is called when the user presses the *Home* key. In the
    `edit` mode, we make the edit cell visible, move the edit index to the leftmost
    index, and update the caret:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Home*键时，会调用`OnHomeKey`方法。在`edit`模式下，我们使编辑单元格可见，将编辑索引移动到最左侧索引，并更新光标：
- en: '[PRE85]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If neither the *Shift* or *Ctrl* keys is pressed in the `mark` mode, we move
    the marked block to the leftmost column of the first marked row. If the *Shift*
    key is pressed, we move the last marked cell to the leftmost column of the last
    marked row. The first marked cell is not affected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`mark`模式下没有按下*Shift*或*Ctrl*键，我们将标记块移动到第一个标记行的最左侧列。如果按下了*Shift*键，我们将最后一个标记单元格移动到最后一个标记行的最左侧列。第一个标记单元格不受影响：
- en: '[PRE86]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If the *Ctrl* key is pressed, but not the *Shift* key, we move the marked block
    to the top-left cell. If the *Ctrl* key is not pressed, we move the last marked
    cell to the leftmost position in the row:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下*Ctrl*键但没有按下*Shift*键，我们将标记的块移动到左上角单元格。如果没有按下*Ctrl*键，我们将最后一个标记的单元格移动到该行的最左侧位置：
- en: '[PRE87]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `OnEndKey` method is called when the user presses the *End* key, and it
    works in a way similar to the `OnHomeKey` method. In the `edit` mode, we make
    the edit cell visible, move the edit index to the rightmost index, and update
    the caret:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*End*键时，会调用`OnEndKey`方法，其工作方式与`OnHomeKey`方法类似。在`edit`模式下，我们使编辑单元格可见，将编辑索引移动到最右侧索引，并更新光标：
- en: '[PRE88]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If neither the *Shift* nor the *Ctrl* key is pressed in the `mark` mode, we
    move the marked block to the rightmost column of the first marked row. If the
    *Shift* key is pressed, we move the last marked cell to the rightmost column of
    the last marked row. The first marked cell is not affected:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mark`模式下，如果没有按下*Shift*键或*Ctrl*键，我们将标记的块移动到第一个标记行的最右侧列。如果按下*Shift*键，我们将最后一个标记的单元格移动到最后一个标记行的最右侧列。第一个标记的单元格不受影响：
- en: '[PRE89]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If the *Ctrl* key is pressed, but not the *Shift* key, we move the marked block
    to the bottom-right cell. If the *Ctrl* key is not pressed, we move the last marked
    cell to the rightmost position in the row:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下*Ctrl*键但没有按下*Shift*键，我们将标记的块移动到底部右边的单元格。如果没有按下*Ctrl*键，我们将最后一个标记的单元格移动到该行的最右侧位置：
- en: '[PRE90]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The *Return* key finishes the editing session unless the user has input a formula
    with a syntax error, in which case an error message box is displayed. The user
    can also finish by pressing the *Tab* key or by clicking the mouse; in either
    case, the `Remark` method takes care of finishing the editing process. When the
    editing is finished, we try to mark the cell:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*Return*键结束编辑会话，除非用户输入了有语法错误的公式，在这种情况下会显示错误信息框。用户也可以通过按下*Tab*键或单击鼠标来结束编辑；在任一情况下，`Remark`方法负责完成编辑过程。当编辑完成后，我们尝试标记单元格：'
- en: '[PRE91]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The *Tab* key does almost the same thing as the *Return* key. The only difference
    is that the next marked cell is, if possible, the cell to right or the cell to
    the left (if the user pressed the *Shift* key):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*Tab*键几乎与*Return*键做同样的事情。唯一的区别是，如果可能的话，下一个标记的单元格是向右或向左的单元格（如果用户按下了*Shift*键）：'
- en: '[PRE92]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `OnEscapeKey` method is called when the user presses the *Esc* key and
    resets the cell to the value of the `prevCell` variable:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Esc*键时，会调用`OnEscapeKey`方法，并将单元格重置为`prevCell`变量的值：
- en: '[PRE93]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `OnDeleteKey` method is called when the user presses the *Delete* key or
    selects the **Delete** menu item to delete a character in the `edit` mode or the
    contents of the marked block in the `mark` mode. In the `edit` mode, we delete
    the character of the edit index unless it is at the end of the text. In the `mark`
    mode, we just reset the marked cell. When the cells are reset, we need to re-evaluate
    their target cells recursively:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Delete*键或选择**删除**菜单项来删除`edit`模式下的字符或在`mark`模式下的标记块内容时，会调用`OnDeleteKey`方法。在`edit`模式下，我们删除编辑索引处的字符，除非它位于文本的末尾。在`mark`模式下，我们只需重置标记的单元格。当单元格被重置时，我们需要递归地重新评估它们的目标单元格：
- en: '[PRE94]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `OnBackspaceKey` method is called when the user presses the *Backspace*
    key to delete a character in a cell in the `edit` mode or the contents of the
    marked block in the `mark` mode. In the `edit` mode, we decrement the edit index
    and remove the character by calling the `OnDeleteKey` method at the new index,
    unless the edit position is already at the beginning of text. In the `mark` mode,
    we just call the `OnDeleteKey` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下*Backspace*键以在`edit`模式下的单元格中删除字符或在`mark`模式下的标记块内容中删除内容时，会调用`OnBackspaceKey`方法。在`edit`模式下，我们通过调用新索引处的`OnDeleteKey`方法来递减编辑索引并删除字符，除非编辑位置已经在文本的开头。在`mark`模式下，我们只需调用`OnDeleteKey`方法：
- en: '[PRE95]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: File management
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件管理
- en: Similar to the previous applications, the `ClearDocument` method is called by
    the `StandardDocument` class when the user selects the **New** menu item, the
    `WriteDocumentToStream` method is called when the user selects **Save** or **Save
    As**, and the `ReadDocumentFromStream` method is called when the user selects
    **Open** menu item.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的应用类似，当用户选择**新建**菜单项时，`StandardDocument`类会调用`ClearDocument`方法，当用户选择**保存**或**另存为**时，会调用`WriteDocumentToStream`方法，当用户选择**打开**菜单项时，会调用`ReadDocumentFromStream`方法。
- en: 'In the `ClearDocument` method, every cell is cleared along with their source
    and target sets. When a cell is reset, its text is cleared. When it is cleared,
    its font and color are also cleared. Finally, the application is set to the `mark`
    mode, where the top-left cell is marked:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ClearDocument`方法中，每个单元格及其源集和目标集都会被清除。当单元格被重置时，其文本会被清除。当它被清除时，其字体和颜色也会被清除。最后，应用程序设置为`mark`模式，其中左上角的单元格被标记：
- en: '[PRE96]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `WriteCellToStream` method is a callback function that, given a cell and
    an output stream, writes the cell to the stream. In the same way, the `ReadCellFromStream`
    method reads a cell from an input stream:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteCellToStream`方法是一个回调函数，它接受一个单元格和一个输出流，并将单元格写入流中。同样，`ReadCellFromStream`方法从输入流中读取单元格：'
- en: '[PRE97]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `WriteDocumentToStream` and `ReadDocumentFromStream` methods write and
    read the spreadsheet. More specifically, they read and write the `application`
    mode, the edit index and reference, the mark references, the source and target
    sets, and the cells in the cell matrix:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteDocumentToStream`和`ReadDocumentFromStream`方法写入和读取电子表格。更具体地说，它们读取和写入`application`模式、编辑索引和引用、标记引用、源集和目标集以及单元格矩阵中的单元格：'
- en: '[PRE98]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Note that we call the `MakeCellVisible` method at the end of the `ReadDocumentFromStream`
    method. The idea is that the user should be able to pick up the spreadsheet where
    they left it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`ReadDocumentFromStream`方法的末尾调用`MakeCellVisible`方法。其想法是用户应该能够从他们离开的地方继续使用电子表格：
- en: '[PRE99]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `WriteSetMapToStream` and `ReadSetMapFromStream` methods write and read
    the source and target sets. They are static, since they are called for both `sourceSetMap`
    and `targetSetMap`. For each cell in the spreadsheet, the size of the set as well
    as the references of the sets are written and read:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteSetMapToStream`和`ReadSetMapFromStream`方法写入和读取源集和目标集。它们是静态的，因为它们为`sourceSetMap`和`targetSetMap`都调用。对于电子表格中的每个单元格，都会写入和读取集合的大小以及集合的引用：'
- en: '[PRE100]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Cut, copy, and paste
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪切、复制和粘贴
- en: 'The **Copy** menu item is enabled in the `mark` mode. Note that we do not override
    the `PasteEnable` method, since the `StandardDocument` class enables the **Paste**
    menu item if there is a clipboard buffer with one of the application formats–the
    `AsciiFormat`, `UnicodeFormat`, or `CalcFormat` format:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**菜单项在`mark`模式下被启用。请注意，我们没有覆盖`PasteEnable`方法，因为`StandardDocument`类会在剪贴板缓冲区包含应用程序格式之一（即`AsciiFormat`、`UnicodeFormat`或`CalcFormat`格式）时启用**粘贴**菜单项：'
- en: '[PRE101]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The `CopyAscii` method simply calls `CopyUnicode`, which in turn fills the
    `textList` list with the copied text. Each text in the `textList` list holds one
    row, and the columns are divided by semicolons ('';''):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyAscii`方法简单地调用`CopyUnicode`，而`CopyUnicode`方法则将复制的文本填充到`textList`列表中。`textList`列表中的每个文本都代表一行，列之间由分号（`;`）分隔：'
- en: '[PRE102]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `CopyGeneric` method stores the top-left position and size of the marked
    block and calls the `WriteCellToClipboard` method for each marked cell:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyGeneric`方法存储标记块的左上角位置和大小，并为每个标记单元格调用`WriteCellToClipboard`方法：'
- en: '[PRE103]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `IsPasteAsciiReady` method simply calls the `IsPasteUnicodeReady` method,
    which returns `true` if there is only one cell currently marked and the block
    to be pasted fits in the spreadsheet, or if the currently marked block has the
    same size as the block to be pasted. Note that in the first case, if only one
    cell is marked, the block to be pasted does not have to have an equal number of
    columns for each row, as long as they fit in the spreadsheet:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPasteAsciiReady`方法简单地调用`IsPasteUnicodeReady`方法，如果当前只标记了一个单元格且要粘贴的块适合在电子表格中，或者当前标记的块与要粘贴的块具有相同大小，则返回`true`。请注意，在第一种情况下，如果只标记了一个单元格，要粘贴的块不需要每行有相同数量的列，只要它们适合在电子表格中即可：'
- en: '[PRE104]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Similar to the `IsPasteUnicodeReady` method, the `IsPasteGenericReady` method
    returns `true` if there is only cell marked at the moment and the block to be
    pasted fits in the spreadsheet or if the currently marked block and the block
    to be pasted have the same size. However, unlike the Unicode case we saw earlier,
    the rows of the generic block to be pasted all have the same size:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与`IsPasteUnicodeReady`方法类似，`IsPasteGenericReady`方法在当前只标记了一个单元格且要粘贴的块适合在电子表格中，或者当前标记的块和要粘贴的块具有相同大小时返回`true`。然而，与之前看到的Unicode情况不同，要粘贴的通用块的每一行都具有相同的大小：
- en: '[PRE105]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `PasteAscii` method simply calls the `PasteUnicode` method that first takes
    a backup of the cell matrix as well as the source and target set maps, since the
    cells to be pasted may contain a formula with syntax errors, in which case the
    pasting process will be aborted. Then, it iterates through the text to be pasted
    and splits each row in to columns. The text of each column is copied to the pasted
    cell:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasteAscii`方法简单地调用`PasteUnicode`方法，首先备份单元格矩阵以及源和目标集映射，因为要粘贴的单元格可能包含有语法错误的公式，在这种情况下，粘贴过程将被终止。然后，它遍历要粘贴的文本并将每一行分割成列。每一列的文本被复制到粘贴的单元格中：'
- en: '[PRE106]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The text of the column is interpreted, and if it holds a formula with a syntax
    error, an exception is thrown, stopping the iteration and restoring the backup
    matrix together with the source and target set maps. This is actually the reason
    why the `EvaluateRecursive` method fills the set of references to be invalidated
    instead of just invalidating them. If the pasting process fails due to a formula
    with a syntax error, we would not want any cells to become invalidated and updated:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列的文本被解释，如果它包含有语法错误的公式，将抛出异常，停止迭代并恢复备份矩阵以及源和目标集映射。这实际上就是为什么`EvaluateRecursive`方法填充要无效化的引用集而不是直接无效化的原因。如果粘贴过程由于语法错误的公式而失败，我们不希望任何单元格被无效化和更新：
- en: '[PRE107]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When the text has been interpreted, we need to update the references, in case
    it holds a formula, by comparing the location of the marked block with the original
    location (from where it was copied) of the pasted block in order for the reference
    to be relative:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本被解释后，我们需要更新引用，如果它包含公式，通过比较标记块的位置与粘贴块原始位置（它被复制的地方）来确定引用是否相对：
- en: '[PRE108]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Finally, we set the source and target sets of the cell, evaluate its value,
    and generate its caret rectangle list. The evaluation may result in an error (missing
    value, reference out of range, circular reference, or division by zero), in which
    case an error message is stored in the cell text:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置单元格的源和目标集，评估其值，并生成其光标矩形列表。评估可能会导致错误（缺失值、引用超出范围、循环引用或除以零），在这种情况下，错误消息将存储在单元格文本中：
- en: '[PRE109]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The pasted cells are not invalidated until we have iterated through them and
    none of them has been found to hold a formula with a syntax error. Note that there
    may be more than just the pasted cells to be invalidated, the other cells outside
    the pasted block that are targets of the pasted cells, and thereby evaluated,
    need to be invalidated:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴的单元格只有在遍历它们并且没有发现包含有语法错误的公式时才被无效化。请注意，可能还有其他需要无效化的单元格，即粘贴块外的其他单元格，它们是粘贴单元格的目标，并且因此需要被评估：
- en: '[PRE110]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If one of the pasted cells holds a formula with a syntax error, we simply restore
    the backup and display a message box:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果粘贴的单元格中包含有语法错误的公式，我们只需恢复备份并显示一个消息框：
- en: '[PRE111]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `PasteGeneric` method is simpler than the `PasteUnicode` method: since
    there is no need for cell interpretation (as the cell has been copied from the
    spreadsheet and thereby holds valid formulas), there in no need for backup and
    no exception is thrown:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasteGeneric`方法比`PasteUnicode`方法简单：由于不需要单元格解释（因为单元格是从电子表格中复制的，因此包含有效的公式），因此不需要备份，也不会抛出异常：'
- en: '[PRE112]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Each pasted cell is read from the buffer and then the source cell is assigned
    to it. The target set is removed and then added by the pasted cell:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个粘贴的单元格都是从缓冲区中读取的，然后将源单元格分配给它。目标集被移除，然后由粘贴的单元格添加：
- en: '[PRE113]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The **Delete** menu item is enabled in the `edit` mode unless the edit index
    is at the end of the cell''s text. The item is always enabled in the `mark` mode,
    since there is always at least one marked cell marked to be deleted:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`编辑`模式下，**删除**菜单项被启用，除非编辑索引位于单元格文本的末尾。在`标记`模式下，该选项始终启用，因为总是至少有一个标记的单元格被标记为删除：
- en: '[PRE114]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `OnDelete` method (the menu item) just calls `OnDeleteKey` (the key pressed),
    since they perform the same action:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDelete`方法（菜单项）只是调用`OnDeleteKey`（按下的键），因为它们执行相同的操作：'
- en: '[PRE115]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Font and color
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体和颜色
- en: 'The `OnFont` and `OnBackgroundColor` methods work in the same manner–they are
    called when the user selects the **Font** or **Background Color** items in the
    **Format** menu. They apply the change on the edited or marked cells, and the
    window and (in the edit case) the caret is updated. If at least one cell has been
    modified, the dirty flag is set:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnFont` 和 `OnBackgroundColor` 方法以相同的方式工作–当用户在 **格式** 菜单中选择 **字体** 或 **背景颜色**
    项时调用它们。它们应用于编辑或标记的单元格，并且更新窗口和（在编辑情况下）光标。如果至少有一个单元格已被修改，则设置脏标志：'
- en: '[PRE116]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In the `edit` mode, the font of the edited cell is changed if the `FontDialog`
    method returns `true` (the user has pressed the **Ok** button) and has chosen
    a different font. Note that the `FontDialog` method also sets the color of the
    font:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `edit` 模式下，如果 `FontDialog` 方法返回 `true`（用户已按下 **确定** 按钮）并且选择了不同的字体，则编辑单元格的字体会改变。请注意，`FontDialog`
    方法还设置字体的颜色：
- en: '[PRE117]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In the `mark` mode, the font of each marked cell is set to the new font if
    the `FontDialog` method returns `true`. If the font of at least one cell is set
    (which we do not know from the start), the dirty flag is set:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mark` 模式下，如果 `FontDialog` 方法返回 `true`（用户已按下 **确定** 按钮）并且选择了新的字体，则每个标记单元格的字体设置为新的字体。如果至少有一个单元格的字体被设置（我们一开始并不知道），则设置脏标志：
- en: '[PRE118]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `OnBackgroundColor` method is similar to the `OnFont` method. The only
    difference is that the `OnBackgroundColor` method calls the `ColorDialog` method
    instead of the `FontDialog` method, and that `BackgroundColor` is called for each
    cell instead of `Font`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnBackgroundColor` 方法与 `OnFont` 方法类似。唯一的区别是 `OnBackgroundColor` 方法调用 `ColorDialog`
    方法而不是 `FontDialog` 方法，并且对每个单元格调用 `BackgroundColor` 而不是 `Font`：'
- en: '[PRE119]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Alignment
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐
- en: The horizontal and vertical alignments follow the same pattern. The radio methods
    call the `IsHorizontalAlignment` or `IsVerticalAlignment` method, which return
    `true` if the edited cells or all the marked cells hold the alignment in question.
    The selection methods call the `SetHorizontalAlignment` or `SetVerticalAlignment`
    method, which set the alignment of the edited cell or every marked cell. If at
    least one cell has been modified, the dirty flag is set. Finally, the window and
    (in the edit case) caret are updated.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 水平和垂直对齐遵循相同的模式。单选方法调用 `IsHorizontalAlignment` 或 `IsVerticalAlignment` 方法，如果编辑的单元格或所有标记的单元格保持所询问的对齐方式，则返回
    `true`。选择方法调用 `SetHorizontalAlignment` 或 `SetVerticalAlignment` 方法，这些方法设置编辑单元格或每个标记单元格的对齐方式。如果至少有一个单元格已被修改，则设置脏标志。最后，更新窗口和（在编辑情况下）光标。
- en: 'The `HorizontalLeftRadio`, `HorizontalCenterRadio`, `HorizontalRightRadio`,
    and `HorizontalJustifiedRadio` methods call the `IsHorizontalAlignment` method,
    as you''ll see next:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalLeftRadio`、`HorizontalCenterRadio`、`HorizontalRightRadio` 和 `HorizontalJustifiedRadio`
    方法调用 `IsHorizontalAlignment` 方法，正如你接下来会看到的：'
- en: '[PRE120]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `IsHorizontalAlignment` method returns `true` if the alignment of the edited
    cell or at least one of the marked cells holds the alignment in question:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑单元格或至少一个标记单元格保持所询问的对齐方式，则 `IsHorizontalAlignment` 方法返回 `true`：
- en: '[PRE121]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `OnHorizontalLeft`,  `OnHorizontalCenter`,  `OnHorizontalRight`, and `OnHorizontalJustified`
    methods call the `SetHorizontalAlignment` method, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnHorizontalLeft`、`OnHorizontalCenter`、`OnHorizontalRight` 和 `OnHorizontalJustified`
    方法调用 `SetHorizontalAlignment` 方法，如下所示：'
- en: '[PRE122]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `SetHorizontalAlignment` method sets the alignment of the edited cell or
    all marked cells:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetHorizontalAlignment` 方法设置编辑单元格或所有标记单元格的对齐方式：'
- en: '[PRE123]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'For each cell whose alignment is changed, its caret rectangle list is regenerated
    and the cell becomes invalidated:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个对齐方式改变的单元格，其光标矩形列表被重新生成，并且单元格变得无效：
- en: '[PRE124]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The dirty flag is set, since at least one cell has been modified. Otherwise,
    the alignment menu item would not be enabled:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 脏标志被设置，因为至少有一个单元格已被修改。否则，对齐菜单项将不会被启用：
- en: '[PRE125]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The vertical alignment methods are similar to the horizontal alignment methods,
    as we can see here:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直对齐方法与水平对齐方法类似，正如我们在这里可以看到的：
- en: '[PRE126]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Source and target sets
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源和目标集
- en: Each cell in the spreadsheet holds a numerical value, a formula, or a (possibly
    empty) plain text. As mentioned at the beginning of the chapter, a formula is
    a text beginning with the equal sign (=) followed by a numerical expression with
    cell references. If the cell holds a value, it may affect the values in other
    cells (if it does not hold a value, it might cause evaluation errors in target
    cells). If the cell contains a formula, its value may depend on the values in
    other cells. This implies that each cell needs a set of cells that it depends
    on, that is, its source set, and a set of cells that depend on it, that is, its
    target set.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格中的每个单元格都包含一个数值、一个公式或一个（可能为空）纯文本。如本章开头所述，公式是以等号（=）开头的文本，后跟一个带有单元格引用的数值表达式。如果单元格包含一个值，它可能会影响其他单元格的值（如果它不包含值，它可能会在目标单元格中引起评估错误）。如果单元格包含一个公式，其值可能取决于其他单元格的值。这意味着每个单元格都需要一个它依赖的单元格集合，即其源集合，以及一个依赖它的单元格集合，即其目标集合。
- en: Only a formula has a non-empty source set, which is the set of all references
    of the formula. The target set, on the other hand, is more complicated–a cell
    does not decide its own target set; it is decided indirectly by the formulas that
    have it as its source cell.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 只有公式才有非空源集合，即该公式的所有引用集合。另一方面，目标集合更为复杂——一个单元格不决定自己的目标集合；它是由将其作为源单元格的公式间接决定的。
- en: In mathematical terms, the cells with its source and target sets constitute
    a **directed graph**. Technically, they constitute two different directed graphs,
    one each for the source and target sets. However, the graphs are just inverses
    of each other, so in all practical ways, they can be regarded as the same graph.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 用数学术语来说，具有其源和目标集合的单元格构成一个**有向图**。技术上，它们构成两个不同的有向图，一个对应源集合，一个对应目标集合。然而，这两个图互为逆图，所以在所有实际意义上，它们可以被视为同一个图。
- en: For instance, in the screenshot that follows the source set of `a3` holds `a1`
    and `c1` because its formula includes `a1` and `c1`. In the same way, the source
    set of `c3` holds `c1` because its formula includes `c1`. The source set of `a1`
    and `c1` are empty, because they do not hold formulas.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的截图之后，`a3`的源集合包含`a1`和`c1`，因为其公式包含`a1`和`c1`。同样，`c3`的源集合包含`c1`，因为其公式包含`c1`。`a1`和`c1`的源集合为空，因为它们不包含公式。
- en: As `c1` is included in both the formulas of `a3` and `c3`, the value of `c1`
    affects the values of `a3` and `c3`. This implies that the target set of `c1`
    holds `a3` and `c3`. In the same way, as `a1` is included in the formula of `a3`,
    the target set of `a1` holds `a3`. As the values of `a3` and `c3` do not affect
    the values of any other cells, their target sets are empty.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`c1`同时包含在`a3`和`c3`的公式中，`c1`的值会影响`a3`和`c3`的值。这意味着`c1`的目标集合包含`a3`和`c3`。同样，由于`a1`包含在`a3`的公式中，`a1`的目标集合包含`a3`。由于`a3`和`c3`的值不影响任何其他单元格的值，它们的目标集合为空。
- en: '![Source and target sets](img/B05475_08_02.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![源和目标集合](img/B05475_08_02.jpg)'
- en: 'The following is a screenshot of the same spreadsheet with the `c3` cell being
    edited instead of the `a3` cell:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个截图，显示了同一电子表格，正在编辑的是`c3`单元格而不是`a3`单元格：
- en: '![Source and target sets](img/B05475_08_03.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![源和目标集合](img/B05475_08_03.jpg)'
- en: The first of the following diagrams shows the acyclic graph of the source sets
    of the preceding spreadsheet, the second diagram shows the acyclic graph of the
    target sets. As mentioned previously (and shown by the graphs), the source and
    targets sets are the inverse of each other. Technically, we can manage with only
    one of the sets. However, as the sets are needed on different occasions, the code
    is clearer with both of them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的第一个图显示了前面电子表格的源集合的无环图，第二个图显示了目标集合的无环图。如前所述（并由图所示），源集合和目标集合互为逆。技术上，我们可以只用其中一个集合。然而，由于在不同的场合需要使用这两个集合，所以使用两个集合的代码更清晰。
- en: '![Source and target sets](img/B05475_07_04.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![源和目标集合](img/B05475_07_04.jpg)'
- en: When the value of a cell is changed, its target set is traversed and the values
    of those cells are updated. Then the target sets of these cells are traversed,
    and so on. The search terminates when there are no more cells to evaluate or when
    we detect a circular reference. The circular reference is detected by a deep-search
    algorithm, which is described in the next section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格的值发生变化时，会遍历其目标集合，并更新这些单元格的值。然后遍历这些单元格的目标集合，依此类推。当没有更多单元格需要评估或检测到循环引用时，搜索终止。循环引用是通过深度搜索算法检测的，该算法将在下一节中描述。
- en: Graph searching
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图搜索
- en: When the user changes the value of a cell, we need to find the cells that need
    to be re-evaluated. Again, note the difference between source and target sets.
    While only formula cells can have non-empty source sets, all kinds of cells (also
    empty cells) can have non-empty target sets. Another difference between the two
    sets is that the target sets are defined indirectly by formulas in other cells.
    If a formula of another cell holds a reference to a particular cell, the reference
    to the formula cell is added to the target set of the particular cell. In the
    same way, when a formula is altered or cleared, the reference to that cell is
    removed from the target sets of all its source cells. When a cell is updated,
    all its targets are evaluated recursively–the targets cells are re-evaluated,
    then their target cells are re-evaluated, and so on. The evaluation always terminates
    when there are no more targets left, or when a circular reference is encountered.
    We always run out of targets or encounter a circular reference, since there is
    a finite number of cells in the spreadsheet.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改单元格的值时，我们需要找到需要重新评估的单元格。再次注意源集和目标集之间的区别。虽然只有公式单元格可以有非空的源集，但所有类型的单元格（包括空单元格）都可以有非空的目标集。这两个集合之间的另一个区别是，目标集是通过其他单元格中的公式间接定义的。如果另一个单元格的公式包含对特定单元格的引用，则将该公式单元格的引用添加到特定单元格的目标集中。同样，当公式被更改或清除时，对该单元格的引用将从所有源单元格的目标集中删除。当单元格被更新时，所有其目标都会递归地被评估–目标单元格被重新评估，然后它们的目标单元格被重新评估，依此类推。评估总是在没有更多目标或遇到循环引用时终止。由于电子表格中的单元格数量是有限的，我们总会耗尽目标或遇到循环引用。
- en: 'The `InterpretEditCell` method is called when the user finishes the input of
    a cell. It interprets the cell by calling the `InterpretCell` method, which fills
    the `sourceSet` method but throws an exception in the case of a formula with a
    syntax error:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户完成单元格输入时，会调用`InterpretEditCell`方法。该方法通过调用`InterpretCell`方法来解释单元格，填充`sourceSet`方法，但在公式存在语法错误的情况下会抛出异常：
- en: '[PRE127]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'However, if the parsing goes well, the previous source set is removed and the
    new source set is added:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果解析顺利，则删除之前的源集并添加新的源集：
- en: '[PRE128]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then the cell is recursively evaluated and all its direct or indirect target
    cells are updated:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后递归评估该单元格，并更新其所有直接或间接的目标单元格：
- en: '[PRE129]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Finally, all evaluated cells are invalidated, the dirty flag is set, and `true`
    is returned:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有已评估的单元格都会被使无效，设置脏标志，并返回`true`：
- en: '[PRE130]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If a syntax error is detected and an exception is thrown, an error message
    is displayed and `false` is returned. In that case, the application remains in
    `edit` mode if the user has finished the input. If the `InterpretEditCell` method
    has been called due to pasting, the pasting process is aborted:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到语法错误并抛出异常，将显示错误消息并返回`false`。在这种情况下，如果用户已完成输入，则应用程序将保持`edit`模式。如果由于粘贴而调用`InterpretEditCell`方法，则终止粘贴过程：
- en: '[PRE131]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `InvalidateCell` method invalidates the area occupied by the cell with
    the given reference:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvalidateCell`方法会使给定引用的单元格占用的区域无效：'
- en: '[PRE132]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The sources and targets sets can be searched and evaluated in two ways: **depth-first**
    and **breadth-first**. As the names implies, depth-first tries to search as deep
    as possible. When it reaches a dead end, it backtracks and tries another way,
    if there is one. Breadth-first, on the other hand, evaluates all cells at the
    same distance from the start cell. Not until every cell at a distance has been
    evaluated, are the cells at the next distance examined.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 源集和目标集可以通过两种方式搜索和评估：**深度优先**和**广度优先**。正如其名称所暗示的，深度优先尝试尽可能深入地搜索。当它达到死胡同时，它会回溯并尝试另一种方法，如果有的话。另一方面，广度优先评估从起始单元格相同距离的所有单元格。只有当距离相同的所有单元格都被评估后，才会检查下一个距离的单元格。
- en: 'When the user adds or alters a formula, it is essential that we detect potential
    circular references in the graph. The `IsCircular` method decides whether the
    cell is part of a circular reference, that is, a direct reference to its own cell
    or a chain of references leading to its own cell. We perform a depth-first search,
    which is easier than the breadth-first search, since we can take advantage of
    recursive calls. The breadth-first method is, on the other hand, necessary in
    order to evaluate the targets of a modified cell in the `EvaluateRecursive` method,
    as shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户添加或修改公式时，我们检测图中潜在的循环引用是至关重要的。`IsCircular` 方法决定单元格是否是循环引用的一部分，即直接引用其自身单元格或导致其自身单元格的引用链。我们执行深度优先搜索，这比广度优先搜索更容易，因为我们可以利用递归调用。另一方面，广度优先方法在`EvaluateRecursive`方法中评估修改后的单元格的目标时是必要的，如下所示：
- en: '[PRE133]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: When the value of a cell is modified, it is essential that the formulas having
    references to the cell are notified and that their values are re-evaluated. The
    `EvaluateRecursive` method performs a breadth-first search by following the target
    sets forward.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格的值被修改时，必须通知引用该单元格的公式，并重新评估它们的值。`EvaluateRecursive`方法通过跟随目标集进行广度优先搜索。
- en: 'Unlike the check for circular references, which we saw earlier, we cannot perform
    a depth-first search, since it would introduce the risk of the cells being evaluated
    in the wrong order:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的循环引用检查不同，我们不能执行深度优先搜索，因为这会引入单元格评估顺序错误的危险：
- en: '[PRE134]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'When a cell is being evaluated, it needs the values of the cells in its source
    set; the `valueMap` parameter holds the values of the source cells that holds
    some value. Every source cell not holding a value is omitted from the map:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当单元格正在被评估时，它需要其源集中的单元格的值；`valueMap`参数持有具有某些值的源单元格的值。每个没有值的源单元格都从映射中省略：
- en: '[PRE135]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If this cell is not a part of a circular reference, we add the values of the
    referred cells with values to the `valueMap` parameter. Refereed cells without
    values are simply omitted from the `valueMap` parameter:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此单元格不是循环引用的一部分，我们将引用单元格的值与值添加到`valueMap`参数中。没有值的引用单元格简单地从`valueMap`参数中省略：
- en: '[PRE136]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Regardless of whether the cell was properly evaluated or was found to be part
    of a circular reference, we need to regenerate its caret rectangle list. It is
    either given a proper value or an error message, and in both cases, the text is
    changed:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 无论单元格是否被正确评估或被发现是循环引用的一部分，我们都需要重新生成其光标矩形列表。它要么得到一个适当的值或错误消息，在两种情况下，文本都会改变：
- en: '[PRE137]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `RemoveTargetSetMap` method traverses the source set of the cell in the
    cell matrix and, for each source cell, removes the cell as a target. In the same
    way, the `AddTargetSetMap` method traverses the source set of the cell in the
    cell matrix and, for each source cell, adds the cell as a target:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveTargetSetMap`方法遍历单元格矩阵中单元格的源集，并对每个源单元格，将其作为目标移除。同样，`AddTargetSetMap`方法遍历单元格矩阵中单元格的源集，并对每个源单元格，将其作为目标添加：'
- en: '[PRE138]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Error handling
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'The evaluation errors are as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 评估错误如下：
- en: '**Missing value**: This error occurs when the cell referred in a formula does
    not hold a value'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺失值**：当公式中引用的单元格没有值时，会发生此错误'
- en: '**Reference out of range**: This error occurs when a reference is outside the
    scope of the spreadsheet'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用超出范围**：当引用超出工作表的作用域时，会发生此错误'
- en: '**Circular reference**: This error occurs when a cell is referring to itself,
    directly or indirectly'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环引用**：当单元格直接或间接地引用自身时，会发生此错误'
- en: '**Division by zero**: This error occurs when the denominator in a division
    expression is zero'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除以零**：当除法表达式的分母为零时，会发生此错误'
- en: There is also the syntax error that occurs when the user inputs a syntactically
    incorrect formula.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入语法不正确的公式时，也会发生语法错误。
- en: '**Error.h**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**Error.h**'
- en: '[PRE139]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '**Error.cpp**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**Error.cpp**'
- en: '[PRE140]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we looked into how a spreadsheet program is implemented: the
    mouse and keyboard input; cut, copy, and paste; file management; and font, color,
    and alignment. [Chapter 9](ch09.html "Chapter 9. Formula Interpretation"), *Formula
    Interpretation*, will introduce cell handling and formula interpretation, including
    parsing, scanning, and caret rectangle list generation.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了电子表格程序是如何实现的：鼠标和键盘输入；剪切、复制和粘贴；文件管理；以及字体、颜色和对齐。[第9章](ch09.html "第9章。公式解释")，*公式解释*，将介绍单元格处理和公式解释，包括解析、扫描和光标矩形列表生成。
