- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Asynchronous Programming Using Boost.Asio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost.Asio 进行异步编程
- en: '**Boost.Asio** is a C++ library included in the well-known Boost libraries
    family that simplifies the development of solutions dealing with asynchronous
    **input/output** ( **I/O** ) tasks managed by the **operating system** ( **OS**
    ), making it easier to develop asynchronous software that deals with internal
    and external resources, such as network communications services or file operations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Asio** 是 Boost 库家族中包含的一个 C++ 库，它简化了处理由操作系统（**OS**）管理的异步 **输入/输出**（**I/O**）任务解决方案的开发，使得开发处理内部和外部资源（如网络通信服务或文件操作）的异步软件变得更加容易。'
- en: For that purpose, Boost.Asio defines OS services (services belonging to and
    managed by the OS), I/O objects (providing interfaces to OS services), and the
    I/O execution context object (an object that behaves as a services registry and
    proxy).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，Boost.Asio 定义了操作系统服务（属于并受操作系统管理的服务）、I/O 对象（提供对操作系统服务的接口）以及 I/O 执行上下文对象（一个充当服务注册表和代理的对象）。
- en: In the following pages, we will introduce Boost.Asio, describe its main building
    blocks, and explain some common patterns to develop asynchronous software with
    this library, which are widely used in the industry.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下页面中，我们将介绍 Boost.Asio，描述其主要构建块，并解释一些在工业界广泛使用的开发异步软件的常见模式。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What Boost.Asio is and how it simplifies asynchronous programming with external
    resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Asio 是什么，以及它是如何简化使用外部资源的异步编程的
- en: What I/O objects and I/O execution contexts are, and how they interact with
    OS services and between each other
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 对象和 I/O 执行上下文是什么，以及它们如何与操作系统服务以及彼此交互
- en: What the Proactor and Reactor design patterns are, and how they are related
    to Boost.Asio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Proactor 和 Reactor 设计模式是什么，以及它们与 Boost.Asio 的关系
- en: How to keep the program thread-safe and how to serialize tasks using strands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保持程序线程安全以及如何使用 strands 序列化任务
- en: How to efficiently pass data to asynchronous tasks using buffers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用缓冲区有效地将数据传递给异步任务
- en: How to cancel asynchronous operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何取消异步操作
- en: Examples of common practices with timers and networking applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计时器和网络应用程序的常见实践示例
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we will need to install the Boost C++ libraries. The most
    recent version when writing this book is Boost 1.85.0. Here are the release notes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们需要安装 Boost C++ 库。本书编写时的最新版本是 Boost 1.85.0。以下是发布说明：
- en: '[https://www.boost.org/users/history/version_1_85_0.html](https://www.boost.org/users/history/version_1_85_0.html)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/users/history/version_1_85_0.html](https://www.boost.org/users/history/version_1_85_0.html)'
- en: 'For installation instructions in Unix variants systems (Linux, macOS), check
    out the following link:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unix 变体系统（Linux、macOS）的安装说明，请查看以下链接：
- en: '[https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html](https://www.boost.org/doc/libs/1_85_0/more/getting_started/unix-variants.html)'
- en: 'For Windows systems, check out this link:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，请查看以下链接：
- en: '[https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html](https://www.boost.org/doc/libs/1_85_0/more/getting_started/windows.html)'
- en: 'Also, depending on the project we want to develop, we might need to configure
    **Boost.Asio** or install dependencies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据我们想要开发的项目，我们可能需要配置 **Boost.Asio** 或安装依赖项：
- en: '[https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/using.html)'
- en: All code shown during this chapter will be supported by the C++20 version. Please
    check the technical requirements section in [*Chapter 3*](B22219_03.xhtml#_idTextAnchor051)
    with some guidance on how to install GCC 13 and Clang 8 compilers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有代码都将由 C++20 版本支持。请查阅[*第 3 章*](B22219_03.xhtml#_idTextAnchor051)中的技术要求部分，其中包含有关如何安装
    GCC 13 和 Clang 8 编译器的指导。
- en: 'You can find the complete code in the following GitHub repository:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub 仓库中找到完整的代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: 'The examples for this chapter are located under the **Chapter_09** folder.
    All source code files can be compiled using CMake as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于**Chapter_09**文件夹下。所有源代码文件都可以使用CMake编译，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Executable binaries will be generated under the *bin* directory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行二进制文件将在*bin*目录下生成。
- en: What is Boost.Asio?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Boost.Asio？
- en: '**Boost.Asio** is a cross-platform C++ library created by Chris Kohlhoff that
    provides a portable network and low-level I/O programming, including sockets,
    timers, hostname resolution, socket iostreams, serial ports, file descriptors,
    and Windows HANDLEs, providing a consistent asynchronous model. It also provides
    coroutine support, but as we learned in the previous chapter, they are now available
    in C++20, so we will only introduce them briefly in this chapter.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Asio**是由Chris Kohlhoff创建的跨平台C++库，它提供了一个可移植的网络和低级I/O编程，包括套接字、定时器、主机名解析、套接字iostreams、串行端口、文件描述符和Windows
    HANDLEs，提供了一个一致的异步模型。它还提供了协程支持，但正如我们在上一章所学，它们现在在C++20中可用，所以我们将只在本章中简要介绍。'
- en: Boost.Asio allows the program to manage long-running operations without the
    explicit usage of threads and locks. Also, as it implements a layer on top of
    the OS services, it allows portability, efficiency, ease of use, and scalability,
    using the most appropriate underlying OS mechanisms to achieve these goals, for
    example, scatter-gather I/O operations or moving data across while minimizing
    costly copies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio允许程序在不显式使用线程和锁的情况下管理长时间运行的操作。此外，因为它在操作系统服务之上实现了一层，所以它允许可移植性、效率、易用性和可扩展性，使用最合适的底层操作系统机制来实现这些目标，例如，分散-聚集I/O操作或在移动数据的同时最小化昂贵的复制。
- en: Let’s start by learning about the basic Boost.Asio blocks, I/O objects, and
    I/O execution context objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习Boost.Asio的基本块、I/O对象和I/O执行上下文对象开始。
- en: I/O objects
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O对象
- en: Sometimes, an application needs to access OS services, run asynchronous tasks
    on them, and collect the results or errors. **Boost.Asio** provides a mechanism
    composed of I/O objects and I/O execution context objects to allow this functionality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序需要访问操作系统服务，在这些服务上运行异步任务，并收集结果或错误。**Boost.Asio**提供了一个由I/O对象和I/O执行上下文对象组成的机制，以允许这种功能。
- en: I/O objects are task-oriented objects representing the actual entities performing
    I/O operations. As we can see in *Figure 9* *.1* , Boost.Asio provides core classes
    to manage concurrency, streams, buffers, or other core functionality to the library
    and also includes portable networking classes for network communications via **Transmission
    Control Protocol/Internet Protocol** ( **TCP/IP** ), **User Datagram Protocol**
    ( **UDP** ), or **Internet Control Message Protocol** ( **ICMP** ), classes to
    define the security layer, the transmission protocol and serial port, among other
    tasks, and also platform-specific classes to deal with specific settings depending
    on the underlying OS.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: I/O对象是表示执行I/O操作的实体任务的面向任务的I/O对象。正如我们在*图9.1*中可以看到，Boost.Asio提供了核心类来管理并发、流、缓冲区或其他核心功能，并为库提供通过**传输控制协议/互联网协议**（**TCP/IP**）、**用户数据报协议**（**UDP**）或**互联网控制消息协议**（**ICMP**）进行网络通信的可移植网络类，还包括定义安全层、传输协议和串行端口等任务的类，以及针对特定平台设置的特定类，以处理底层操作系统。
- en: '![Figure 9.1 – I/O objects](img/B22219_09_1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – I/O对象](img/B22219_09_1.jpg)'
- en: Figure 9.1 – I/O objects
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – I/O对象
- en: 'The I/O objects do not directly execute their tasks in the OS. They need to
    communicate with the OS via an I/O execution context object. An instance of a
    context object is passed as the first argument in the I/O object constructors.
    Here, we are defining an I/O object (a timer with an expiration time of three
    seconds) and passing an I/O execution context object ( **io_context** ) via its
    constructor:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: I/O对象不会直接在操作系统中执行其任务。它们需要通过I/O执行上下文对象与操作系统进行通信。上下文对象的一个实例作为I/O对象构造函数的第一个参数传递。在这里，我们定义了一个I/O对象（一个三秒后到期的定时器）并通过其构造函数传递一个I/O执行上下文对象（**io_context**）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most I/O objects have methods whose name starts with **async_** . These methods
    trigger asynchronous operations, which will call a completion handler, a callable
    object passed as an argument to the method when the operation completes. These
    methods return immediately, not blocking the program flow. The current thread
    can continue performing other tasks while the task is not complete. Once completed,
    the completion handler will be called and executed, dealing with the result or
    error of the asynchronous task.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 I/O 对象都有以 **async_** 开头的方法名。这些方法触发异步操作，当操作完成时将调用完成处理程序，这是一个作为方法参数传递的可调用对象。这些方法立即返回，不会阻塞程序流程。当前线程可以在任务未完成时继续执行其他任务。一旦完成，完成处理程序将被调用并执行，处理异步任务的结果或错误。
- en: I/O objects also provide the blocking counterpart methods, which will block
    until completion. These methods do not need to receive a handler as a parameter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 对象还提供了阻塞的对应方法，这些方法将阻塞直到完成。这些方法不需要作为参数接收处理程序。
- en: As mentioned before, note that the I/O objects don’t interact directly with
    the OS; they need an I/O execution context object. Let’s learn about this class
    of objects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，请注意，I/O 对象不直接与操作系统交互；它们需要一个 I/O 执行上下文对象。让我们来了解这类对象。
- en: I/O execution context objects
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 执行上下文对象
- en: To access the I/O services, the program uses at least one I/O execution context
    object that represents the gateway to the OS I/O services. It’s implemented with
    the **boost::asio::io_context** class, providing the core I/O functionality of
    OS services to I/O objects. In Windows, **boost::asio::io_context** is based in
    **I/O completion ports** ( **IOCP** ), on Linux, it is based in **epoll** , and
    on FreeBSD/macOS, it is based in **kqueue** .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 I/O 服务，程序至少使用一个表示操作系统 I/O 服务的网关的 I/O 执行上下文对象。它使用 **boost::asio::io_context**
    类实现，为 I/O 对象提供操作系统服务的核心 I/O 功能。在 Windows 上，**boost::asio::io_context** 基于 **I/O
    completion ports** ( **IOCP** )，在 Linux 上，它基于 **epoll**，在 FreeBSD/macOS 上，它基于
    **kqueue**。
- en: '![Figure 9.2 – Boost.Asio architecture](img/B22219_09_2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – Boost.Asio 架构](img/B22219_09_2.jpg)'
- en: Figure 9.2 – Boost.Asio architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – Boost.Asio 架构
- en: '**boost::asio::io_context** is a subclass of **boost::asio::execution_context**
    , a base class for function object execution also inherited by other execution
    context objects, such as **boost::asio::thread_pool** or **boost::asio::system_context**
    . In this chapter, we will be using **boost::asio::io_context** as our execution
    context object.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**boost::asio::io_context** 是 **boost::asio::execution_context** 的子类，它是函数对象执行的基础类，也被其他执行上下文对象继承，例如
    **boost::asio::thread_pool** 或 **boost::asio::system_context**。在本章中，我们将使用 **boost::asio::io_context**
    作为我们的执行上下文对象。'
- en: The **boost::asio::io_context** class has been a replacement for the **boost::asio::io_service**
    class since version 1.66.0, embracing more modern features and practices from
    C++. **boost::asio::io_service** is still available for backward compatibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.66.0 版本以来，**boost::asio::io_context** 类已经取代了 **boost::asio::io_service**
    类，采用了更多来自 C++ 的现代特性和实践。**boost::asio::io_service** 仍然可用于向后兼容。
- en: As described earlier, Boost.Asio objects can schedule asynchronous operations
    using methods starting with **async_** . When all the asynchronous tasks are scheduled,
    the program needs to call the **boost::asio::io_context::run()** function to execute
    an event processing loop, allowing the OS to deal with the tasks and pass to the
    program the results and trigger the handlers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Boost.Asio 对象可以使用以 **async_** 开头的方法来调度异步操作。当所有异步任务都调度完毕后，程序需要调用 **boost::asio::io_context::run()**
    函数来执行事件处理循环，允许操作系统处理任务并将结果传递给程序，并触发处理程序。
- en: 'Coming back to our previous example, we will now set up the completion handler,
    **on_timeout()** , a callable object (in this case a function) that we pass as
    a parameter when calling the asynchronous **async_wait()** function. Here is the
    code example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，我们现在将设置完成处理程序，**on_timeout()**，这是一个可调用对象（在这种情况下是一个函数），我们在调用异步的 **async_wait()**
    函数时将其作为参数传递。以下是代码示例：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this code, we should see the message **Timer expired.** in the console
    after three seconds, or an error message if the asynchronous call fails for any
    reason.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们应该在三个秒后在控制台看到消息 **Timer expired.**，或者在异步调用因任何原因失败时显示错误消息。
- en: '**boost::io_context::run()** is a blocking call. This is intended to keep the
    event loop running, allow the asynchronous operations to run, and prevent the
    program from exiting. Obviously, this function can be called in a new thread and
    leave the main thread unblocked to carry on with other tasks, as we have seen
    in previous chapters.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**boost::io_context::run()**是一个阻塞调用。这是为了保持事件循环运行，允许异步操作运行，并防止程序退出。显然，这个函数可以在新线程中调用，并让主线程保持未阻塞以继续其他任务，正如我们在前面的章节中看到的。'
- en: When there are no pending asynchronous operations, **boost::io_context::run()**
    will return. There is a template class, **boost::asio::executor_work_guard** ,
    that can keep **io_context** busy and avoid it exiting if needed. Let’s see how
    it works with an example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有挂起的异步操作时，**boost::io_context::run()**将返回。有一个模板类，**boost::asio::executor_work_guard**，可以在需要时保持**io_context**忙碌并避免其退出。让我们通过一个示例看看它是如何工作的。
- en: 'Let’s start by defining a background task that will wait for two seconds before
    posting some work through **io_context** using the **boost::asio::io_context::post()**
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个后台任务，该任务将在等待两秒钟后通过**io_context**使用**boost::asio::io_context::post()**函数发布一些工作：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the **main()** function, the **io_context** object is created, and a **work_guard**
    object is constructed using that **io_context** object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在**main()**函数中，创建了**io_context**对象，并使用该**io_context**对象构造了一个**work_guard**对象。
- en: Then, two threads are created, **io_thread** , where **io_context** runs, and
    **worker** , where **background_task()** will run. We also pass **io_context**
    as a reference to the background task to post work, as explained earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建了两个线程，**io_thread**，其中**io_context**运行，和**worker**，其中**background_task()**将运行。我们还像之前解释的那样，将**io_context**作为引用传递给后台任务以发布工作。
- en: 'With that in place, the main thread does some work (waiting for five seconds)
    and then removes the work guard by calling its **reset()** function, letting **io_context**
    exit its **run()** function, and joins both threads before exiting, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，主线程进行了一些工作（等待五秒钟），然后通过调用其**reset()**函数移除工作保护，让**io_context**退出其**run()**函数，并在退出之前加入两个线程，如所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run the previous code, this is the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，这是输出：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see how the background thread posts a background task correctly, and
    this is completed before the work guard is removed and the I/O context object
    stops its execution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到后台线程如何正确地发布后台任务，并且这个任务在移除工作保护并停止I/O上下文对象的执行之前完成。
- en: 'Another way to keep the **io_context** object alive and servicing requests
    is to provide asynchronous tasks by continuously calling **async_** functions
    or posting work from the completion handlers. This is a common pattern when reading
    or writing to sockets or streams:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种保持**io_context**对象活跃并处理请求的方法是通过不断调用**async_**函数或从完成处理程序发布工作。这在读取或写入套接字或流时是一个常见的模式：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, **timer_handler** is the completion handler defined as a lambda
    function that captures the timer and itself. Every second, when the timer expires,
    it prints the **Handler: Timer expired.** message and restarts itself by enqueueing
    a new asynchronous task (using the **async_wait()** function) into the **io_context**
    object via the **timer** object.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**timer_handler**是一个作为lambda函数定义的完成处理程序，它捕获了计时器和自身。每秒钟，当计时器到期时，它打印**处理程序：计时器已过期**的消息，并通过将新的异步任务（使用**async_wait()**函数）入队到**io_context**对象中通过**计时器**对象来重启自己。
- en: As we have already seen, the **io_context** object can run from any thread.
    By default, this object is thread-safe, but in some scenarios where we want better
    performance, we might want to avoid this safety. This can be adjusted during its
    construction, as we will see in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**io_context**对象可以从任何线程运行。默认情况下，此对象是线程安全的，但在某些场景中，如果我们想要更好的性能，我们可能想要避免这种安全性。这可以在其构造过程中进行调整，正如我们将在下一节中看到的。
- en: Concurrency hints
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发提示
- en: The **io_context** constructor accepts as an argument a concurrency hint, suggesting
    to the implementation the number of active threads that should be used for running
    completion handlers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**io_context**构造函数接受一个并发提示作为参数，建议实现使用多少个活动线程来运行完成处理程序。'
- en: By default, this value is **BOOST_ASIO_CONCURRENCY_HINT_SAFE** (value *1* ),
    indicating that the **io_context** object will run from a single thread, enabling
    several optimizations due to this fact. That doesn’t mean that **io_context**
    can only be used from one thread; it still provides thread safety, and it can
    use I/O objects from many threads.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此值为**BOOST_ASIO_CONCURRENCY_HINT_SAFE**（值*1*），表示**io_context**对象将从一个线程运行，由于这个事实，可以启用一些优化。但这并不意味着**io_context**只能从单个线程使用；它仍然提供线程安全，并且可以使用来自多个线程的I/O对象。
- en: 'Other values that can be specified are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定的其他值如下：
- en: '**BOOST_ASIO_CONCURRENCY_HINT_UNSAFE** : Disables locking so all operations
    on **io_context** or I/O objects must occur in the same thread.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BOOST_ASIO_CONCURRENCY_HINT_UNSAFE**：禁用锁定，因此对**io_context**或I/O对象的操作必须在同一线程中发生。'
- en: '**BOOST_ASIO_CONCURRENCY_HINT_UNSAFE_IO** : Disables locking in the reactor
    but keeps it in the scheduler, so all operations in the **io_context** object
    can use different threads apart from the **run()** function and the other methods
    related to executing the event processing loop. We will learn about schedulers
    and reactors when explaining the design principles behind the library.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BOOST_ASIO_CONCURRENCY_HINT_UNSAFE_IO**：在反应器中禁用锁定，但在调度器中保持锁定，因此**io_context**对象中的所有操作都可以使用除**run()**函数和其他与执行事件处理循环相关的方法之外的不同线程。我们将在解释库背后的设计原则时了解调度器和反应器。'
- en: Let’s now learn about what the event processing loop is and how to manage it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解事件处理循环是什么以及如何管理它。
- en: The event processing loop
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理循环
- en: Using the **boost::asio::io_context::run()** method, **io_context** blocks and
    keeps processing I/O asynchronous tasks until all have been completed and the
    completion handlers have been notified. This I/O requests processing is done in
    an internal event processing loop.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**boost::asio::io_context::run()**方法，**io_context**会阻塞并持续处理I/O异步任务，直到所有任务都已完成并且通知了完成处理程序。这个I/O请求处理是在内部事件处理循环中完成的。
- en: 'There are other methods to control the event loop and avoid blocking until
    all asynchronous events are processed. These are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以控制事件循环并避免在所有异步事件处理完毕之前阻塞。这些方法如下：
- en: '**poll** : Run the event processing loop to execute ready handlers'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**poll**：运行事件处理循环以执行就绪处理程序'
- en: '**poll_one** : Run the event processing loop to execute one ready handler'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**poll_one**：运行事件处理循环以执行一个就绪处理程序'
- en: '**run_for** : Run the event processing loop for a specified duration'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run_for**：运行事件处理循环以指定的时间段'
- en: '**run_until** : Same as the previous one but only until a specified time'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run_until**：与上一个相同，但仅限于指定的时间'
- en: '**run_one** : Run the event processing loop to execute at most one handler'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run_one**：运行事件处理循环以执行最多一个处理程序'
- en: '**run_one_for** : Same as the previous one but only for a specified duration'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run_one_for**：与上一个相同，但仅限于指定的时间段'
- en: '**run_one_until** : Same as the previous one but only until a specified time'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**run_one_until**：与上一个相同，但仅限于指定的时间'
- en: The event loop can also be stopped by calling the **boost::asio::io_context::stop()**
    method or checking if its status is stopped by calling **boost:asio::io_context::stopped()**
    .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环也可以通过调用**boost::asio::io_context::stop()**方法或通过调用**boost:asio::io_context::stopped()**来检查其状态是否已停止来停止。
- en: When the event loop is not running, tasks already being scheduled will continue
    executing. Other tasks will remain pending. Pending tasks can be resumed and pending
    results collected by starting the event loop with one of the methods mentioned
    previously again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件循环没有运行时，已经安排的任务将继续执行。其他任务将保持挂起。可以通过再次使用前面提到的方法之一启动事件循环来恢复挂起的任务并收集挂起的结果。
- en: In previous examples, the application sent some work to **io_context** by calling
    asynchronous methods or by using the **post()** function. Let’s learn now about
    **dispatch()** and its differences with **post()** .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，应用程序通过调用异步方法或使用**post()**函数将一些工作发送到**io_context**。现在让我们了解**dispatch()**及其与**post()**的区别。
- en: Giving some work to the io_context
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向io_context分配一些工作
- en: Apart from sending work to **io_context** via the asynchronous methods from
    the different I/O objects or by using **executor_work_guard** (explained below),
    we can also use the **boost::asio::post()** and **boost::asio::dispatch()** template
    methods. Both functions are used to schedule some work into an **io_context**
    object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过来自不同I/O对象的异步方法或使用**executor_work_guard**（下面将解释）将工作发送到**io_context**之外，我们还可以使用**boost::asio::post()**和**boost::asio::dispatch()**模板方法。这两个函数都用于将一些工作调度到**io_context**对象中。
- en: 'The **post()** function guarantees that the task will be executed. It places
    its completion handler in the execution queue and eventually, it will be executed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**post()** 函数保证任务将被执行。它将完成处理程序放入执行队列，最终将被执行：'
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On the other hand, **dispatch()** may execute the task immediately if **io_context**
    or strand (more on strands later in this chapter) are in the same thread where
    the task is being dispatched, or otherwise placed in the queue for asynchronous
    execution:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果 **io_context** 或 strand（本章后面将详细介绍 strand）与任务被派发的同一线程相同，则 **dispatch()**
    可能会立即执行任务，否则将其放入队列以异步执行：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Therefore, using **dispatch()** , we can optimize performance by reducing context
    switching or queuing delays.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 **dispatch()**，我们可以通过减少上下文切换或队列延迟来优化性能。
- en: Dispatched events can execute directly from the current worker thread even if
    there are other pending events queued up. The posted events must always need to
    be managed by the I/O execution context, waiting until other handlers complete
    before being allowed to be executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 已派发的事件可以直接从当前工作线程执行，即使队列中还有其他挂起的事件。必须始终由 I/O 执行上下文管理已发布的事件，等待其他处理程序完成，然后才能执行。
- en: Now that we have already learned about some basic concepts, let’s learn how
    synchronous and asynchronous operations work under the hood.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了某些基本概念，让我们了解同步和异步操作在底层是如何工作的。
- en: Interacting with the OS
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与操作系统交互
- en: '**Boost.Asio** can interact with I/O services using synchronous and asynchronous
    operations. Let’s learn how they behave and what the main differences are.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Asio** 可以使用同步和异步操作与 I/O 服务交互。让我们了解它们的行为以及主要区别是什么。'
- en: Synchronous operations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步操作
- en: 'If the program wants to use an I/O service in a synchronous way, usually, it
    will create an I/O object and use its synchronous operation method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序想以同步方式使用 I/O 服务，通常，它将创建一个 I/O 对象并使用其同步操作方法：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When calling **timer.wait()** , the request is sent to the I/O execution context
    object ( **io_context** ), which calls the OS to perform the operation. Once the
    OS finishes with the task, it returns the result to **io_context** , which then
    translates the result, or an error if anything went wrong, back to the I/O object
    ( **timer** ). Errors are of type **boost::system::error_code** . If an error
    occurs, an exception is thrown.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 **timer.wait()** 时，请求被发送到 I/O 执行上下文对象（**io_context**），该对象调用操作系统执行操作。一旦操作系统完成任务，它将结果返回给
    **io_context**，然后 **io_context** 将结果或错误（如果有任何问题）转换回 I/O 对象（**定时器**）。错误类型为 **boost::system::error_code**。如果发生错误，将抛出异常。
- en: 'If we don’t want exceptions to be thrown, we can pass an error object by reference
    to the synchronous method to capture the status of the operation and check it
    afterward:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望抛出异常，我们可以通过引用将错误对象传递给同步方法以捕获操作状态并在之后进行检查：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Asynchronous operations
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步操作
- en: 'In the case of asynchronous operations, we need to also pass a completion handler
    to the asynchronous method. This completion handler is a callable object that
    will be invoked by the I/O context object when the asynchronous operation finishes,
    notifying the program about the result or operation error. Its signature is as
    follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步操作的情况下，我们还需要向异步方法传递一个完成处理程序。这个完成处理程序是一个可调用对象，当异步操作完成时，I/O 上下文对象将调用它，通知程序结果或操作错误。其签名如下：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Continuing with the timer example, now, we need to call the asynchronous operation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 继续以定时器为例，现在，我们需要调用异步操作：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, the I/O object ( **timer** ) forwards the request to the I/O execution
    context object ( **io_context** ). **io_context** requests to the OS to start
    the asynchronous operation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，I/O 对象（**定时器**）将请求转发到 I/O 执行上下文对象（**io_context**）。**io_context** 向操作系统请求启动异步操作。
- en: When the operation is finished, the OS places the result in a queue, where **io_context**
    is listening. Then, **io_context** dequeues the result, translates the error into
    an error code object, and triggers the completion handler to notify the program
    about the completion of the task and the result.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作完成时，操作系统将结果放入队列，其中 **io_context** 正在监听。然后，**io_context** 取出结果，将错误转换为错误代码对象，并触发完成处理程序以通知程序任务完成和结果。
- en: To allow **io_context** to follow these steps, the program must execute **boost::asio::io_context::run()**
    (or similar functions introduced earlier that manage the event processing loop)
    and block the current thread while processing any unfinished asynchronous operation.
    As already commented, if there are no pending asynchronous operations, **boost::asio::io_context::run()**
    exits.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许 **io_context** 跟进这些步骤，程序必须执行 **boost::asio::io_context::run()**（或之前介绍过的类似函数，这些函数管理事件处理循环）并阻塞当前线程，以处理任何未完成的异步操作。如前所述，如果没有挂起的异步操作，**boost::asio::io_context::run()**
    将退出。
- en: Completion handlers are required to be copy-constructible, meaning that a copy-constructor
    must be available. If a temporary resource is needed (such as memory, thread,
    or file descriptor), this resource is released before calling the completion handler.
    That allows us to call the same operation without overlapping resource usage,
    avoiding increasing the peak resource usage in the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 完成处理器（Completion handlers）需要是可复制的，这意味着必须有一个复制构造函数可用。如果需要临时资源（如内存、线程或文件描述符），则在调用完成处理器之前释放该资源。这允许我们在不重叠资源使用的情况下调用相同的操作，从而避免增加系统的峰值资源使用。
- en: Error handling
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'As mentioned previously, **Boost.Asio** allows users to handle errors in two
    different ways: by using error codes or throwing exceptions. If we pass a reference
    to a **boost::system::error_code** object when calling an I/O object method, the
    implementation will pass errors through that variable; otherwise, an exception
    will be thrown.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**Boost.Asio** 允许用户以两种不同的方式处理错误：使用错误代码或抛出异常。如果我们调用 I/O 对象方法时传递一个对 **boost::system::error_code**
    对象的引用，则实现将通过该变量传递错误；否则，将抛出异常。
- en: We already implemented some examples following the first approach by checking
    the error codes. Let’s now see how to catch exceptions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过检查错误代码实现了第一个方法的一些示例。现在让我们看看如何捕获异常。
- en: 'The following example creates a timer with an expiration period of three seconds.
    The **io_context** object is running from the background thread, **io_thread**
    . When the timer starts the asynchronous task by calling its **async_wait()**
    function, it passes the **boost::asio::use_future** argument so the function returns
    a future object, **fut** , that later is used inside a try-catch block to call
    its **get()** function and retrieve the stored result or exception, as we learned
    in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125) . After starting the asynchronous
    operation, the main thread waits for one second and the timer cancels the operation
    by calling its **cancel()** function. As this happens before its expiration time
    (three seconds), an exception is thrown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例创建了一个持续三秒钟的计时器。**io_context** 对象由后台线程 **io_thread** 运行。当计时器通过调用其 **async_wait()**
    函数启动异步任务时，它传递了 **boost::asio::use_future** 参数，因此函数返回一个未来对象 **fut**，稍后在该 try-catch
    块内部调用其 **get()** 函数以检索存储的结果或异常，正如我们在 [*第 6 章*](B22219_06.xhtml#_idTextAnchor125)
    中所学。在启动异步操作后，主线程等待一秒钟，然后计时器通过调用其 **cancel()** 函数取消操作。由于这发生在其到期时间（三秒钟）之前，因此会抛出异常：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The exception of type **boost::system::system_error** is caught, and its message
    is printed. If the timer cancels its operation after the asynchronous operation
    completes (in this example, by sleeping the main thread for more than three seconds),
    the timer expires successfully, and no exception is thrown.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 **boost::system::system_error** 的异常被捕获，并打印出其消息。如果在异步操作完成后（在这个例子中，通过让主线程休眠超过三秒钟），计时器取消其操作，计时器将成功到期，不会抛出异常。
- en: Now that we have seen the main building blocks of Boost.Asio and how they interact
    together, let’s recap and understand the design patterns behind its implementation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 Boost.Asio 的主要构建块以及它们是如何相互作用的，让我们回顾一下并理解其实现背后的设计模式。
- en: The Reactor and Proactor design patterns
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应器（Reactor）和执行者（Proactor）设计模式
- en: 'When using event handling applications, we can follow two approaches to designing
    the concurrent solution: the Reactor and Proactor design patterns.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用事件处理应用程序时，我们可以遵循两种方法来设计并发解决方案：反应器（Reactor）和执行者（Proactor）设计模式。
- en: These patterns describe the mechanisms followed to process events, indicating
    how these are initiated, received, demultiplexed, and dispatched. As the system
    collects and queues the I/O events coming from different resources, demultiplexing
    these events means separating them to be dispatched to their correct handlers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式描述了处理事件所遵循的机制，表明了这些事件是如何被发起、接收、解多路复用和分派的。当系统收集和排队来自不同资源的 I/O 事件时，解多路复用这些事件意味着将它们分离以分派到正确的处理程序。
- en: The **Reactor pattern** demultiplexes and dispatches synchronously and serially
    service requests. It usually follows a non-blocking synchronous I/O strategy,
    returning the result if the operation can be executed, or an error if the system
    has no resources to complete the operation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reactor 模式**同步和串行地解多路复用和调度服务请求。它通常遵循非阻塞同步 I/O 策略，如果操作可以执行，则返回结果；如果系统没有资源完成操作，则返回错误。'
- en: On the other hand, the **Proactor pattern** allows demultiplexing and dispatching
    service requests in an efficient asynchronous way by immediately returning the
    control to the caller, indicating that the operation has been initiated. Then,
    the called system will notify the caller when the operation is complete.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**Proactor 模式**允许通过立即将控制权返回给调用者，以高效异步的方式解多路复用和调度服务请求，表明操作已启动。然后，被调用的系统将在操作完成时通知调用者。
- en: 'Thus, the Proactor pattern distributes responsibilities among two tasks: the
    long-duration operations that are executed asynchronously and the completion handlers
    that process the results and usually invoke other asynchronous operations.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Proactor 模式在两个任务之间分配责任：执行异步的长时操作和完成处理程序，处理结果并通常调用其他异步操作。
- en: '**Boost.Asio** implements the Proactor design pattern by using the following
    elements:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boost.Asio** 通过以下元素实现 Proactor 设计模式：'
- en: '**Initiator** : An I/O object that initiates the asynchronous operation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发起者**：一个 I/O 对象，用于启动异步操作。'
- en: '**Asynchronous operation** : A task to run asynchronously by the OS.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步操作**：由操作系统异步运行的任务。'
- en: '**Asynchronous operation processor** : This executes the asynchronous operation
    and queues results in the completion event queue.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步操作处理器**：这执行异步操作，并将结果排队在完成事件队列中。'
- en: '**Completion event queue** : An event queue where the asynchronous operation
    processor pushes events, and the asynchronous event dequeues them.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成事件队列**：一个事件队列，异步操作处理器将事件推入其中，而异步事件从队列中取出。'
- en: '**Asynchronous event demultiplexer** : This blocks the I/O context, waiting
    for events, and returning completed events to the caller.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步事件解多路复用器**：这会阻塞 I/O 上下文，等待事件，并将完成的事件返回给调用者。'
- en: '**Completion handler** : A callable object that will process the results of
    the asynchronous operation.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成处理程序**：一个可调用的对象，将处理异步操作的结果。'
- en: '**Proactor** : This calls the asynchronous event demultiplexer to dequeue events
    and dispatch them to the completion handler. This is what the I/O execution context
    does.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Proactor**：这调用异步事件解多路复用器来出队事件并将它们分派给完成处理程序。这正是 I/O 执行上下文所做的事情。'
- en: '*Figure 9* *.3* clearly shows the relationship between all these elements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9* *.3* 清楚地显示了所有这些元素之间的关系：'
- en: '![Figure 9.3 – Proactor design pattern](img/B22219_09_3.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – Proactor 设计模式](img/B22219_09_3.jpg)'
- en: Figure 9.3 – Proactor design pattern
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – Proactor 设计模式
- en: The Proactor pattern increases the separation of concerns at the same time as
    encapsulating concurrency mechanisms, simplifying application synchronization,
    and increasing performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Proactor 模式在封装并发机制的同时，增加了关注点的分离，简化了应用程序的同步，并提高了性能。
- en: On the other hand, we have no control over how or when the asynchronous operations
    are scheduled or how efficiently the OS will perform these operations. Also, there
    is an increase in memory usage due to the completion event queue and increased
    complexity in debugging and testing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们无法控制异步操作是如何或何时被调度，以及操作系统将如何高效地执行这些操作。此外，由于完成事件队列和调试和测试的复杂性增加，内存使用量也有所增加。
- en: Another aspect of the design of Boost.Asio is the thread safety of the execution
    context objects. Let’s now dig into how threading works with Boost.Asio.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 设计的另一个方面是执行上下文对象的线程安全性。现在让我们深入了解 Boost.Asio 中的线程是如何工作的。
- en: Threading with Boost.Asio
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost.Asio 的多线程
- en: I/O execution context objects are thread-safe; their methods can be called from
    different threads safely. That means that we can use a separate thread to run
    the blocking **io_context.run()** method and leave the main thread unblocked to
    carry on with other unrelated tasks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 执行上下文对象是线程安全的；它们的方法可以从不同的线程安全调用。这意味着我们可以使用单独的线程来运行阻塞的 **io_context.run()**
    方法，并让主线程保持未阻塞状态，以便继续执行其他无关任务。
- en: Let’s now explain the different ways to configure the asynchronous application
    in terms of how to use threads.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释如何根据使用线程的方式配置异步应用程序的不同方法。
- en: Single-threaded approach
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单线程方法
- en: 'The starting point and preferred solution for any **Boost.Asio** application
    should follow a single-threaded approach where the I/O execution context object
    runs in the same thread where the completion handlers are being processed. These
    handlers must be short and non-blocking. Here is an example of a steady timer
    completion handler running in the same thread as the I/O context, the main thread:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 **Boost.Asio** 应用程序的起点和首选解决方案都应遵循单线程方法，其中 I/O 执行上下文对象在处理完成处理程序的同一线程中运行。这些处理程序必须是短小且非阻塞的。以下是一个在
    I/O 上下文和主线程中运行的稳定定时器完成处理程序的示例：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the **steady_timer** timer calls the asynchronous **async_wait()**
    function, setting up the **handle_timer_expiry()** completion handler, in the
    same thread that the **io_context.run()** function is being executed in. When
    the asynchronous function finishes, its completion handler will run in the same
    thread.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**steady_timer** 定时器在执行 **io_context.run()** 函数的同一线程中调用异步的 **async_wait()**
    函数，设置 **handle_timer_expiry()** 完成处理程序。当异步函数完成后，其完成处理程序将在同一线程中运行。
- en: As the completion handler is running in the main thread, its execution should
    be quick to avoid freezing the main thread and other relevant tasks that the program
    should perform. In the next section, we will learn how to deal with long-running
    tasks or completion handlers and keep the main thread responsive.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完成处理程序在主线程中运行，其执行应该快速，以避免冻结主线程和其他程序应执行的相关任务。在下一节中，我们将学习如何处理长时间运行的任务或完成处理程序，并保持主线程的响应性。
- en: Threaded long-running tasks
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程化长时间运行的任务
- en: 'For long-running tasks, we can keep the logic in the main thread but use other
    threads to pass work and get results back to the main thread:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间运行的任务，我们可以保留主线程中的逻辑，但使用其他线程传递工作和将结果返回到主线程：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, after **io_context** is created, a work guard is used to avoid
    the **io_context.run()** function to immediately return before any work is posted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在创建 **io_context** 之后，使用工作保护来避免在发布任何工作之前立即返回 **io_context.run()** 函数。
- en: The posted work consists of a **t** thread being created to run the **long_running_task()**
    function in the background. That **t** thread is detached before the lambda function
    exits; otherwise, the program would terminate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 发布的工作包括创建一个 **t** 线程以在后台运行 **long_running_task()** 函数。在 lambda 函数退出之前，该 **t**
    线程被分离；否则，程序将终止。
- en: In the background task function, the current thread sleeps for a given period
    and then posts another task into the **io_context** object to print a message
    and stop **io_context** itself. If we don’t call **io_context.stop()** , the event
    processing loop will continue running forever and the program will not finish,
    as **io_context.run()** will continue blocking due to the work guard.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台任务函数中，当前线程会暂停给定的时间，然后向 **io_context** 对象中发布另一个任务以打印消息并停止 **io_context** 本身。如果我们不调用
    **io_context.stop()**，事件处理循环将无限期地继续运行，程序将无法结束，因为 **io_context.run()** 将由于工作保护而继续阻塞。
- en: Multiple I/O execution context objects, one per thread
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个线程一个 I/O 执行上下文对象
- en: 'This approach is like the single-threaded one, where each thread has its own
    **io_context** object and processes short and non-blocking completion handlers:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于单线程方法，其中每个线程都有自己的 **io_context** 对象，并处理短小且非阻塞的完成处理程序：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, four threads are created, each one running the **background_task()**
    function where an **io_context** object is created, and a timer is set up to timeout
    after one second together with its completion handler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了四个线程，每个线程运行 **background_task()** 函数，其中创建了一个 **io_context** 对象，并设置了一个定时器，在经过一秒后超时，并与其完成处理程序一起停止。
- en: Multiple threads with a single I/O execution context object
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个 I/O 执行上下文对象的多线程
- en: 'Now, there is only one **io_context** object but it is starting the asynchronous
    tasks from different I/O objects from different threads. In this case, the completion
    handlers can be called from any of those threads. Here is an example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有一个**io_context**对象，但它从不同的线程启动不同的I/O对象异步任务。在这种情况下，完成处理程序可以从这些线程中的任何一个被调用。以下是一个例子：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, only one **io_context** object is created and run in a separate
    thread, **io_context_thread** . Then, an additional four background threads are
    created, where work is posted into the **io_context** object. Finally, the main
    thread waits for five seconds to let all threads finish their work and resets
    the work guard, letting the **io_context.run()** function return if there is no
    more pending work. When the program exits, all threads automatically join, as
    they are instances of **std::jthread** .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只创建并运行了一个**io_context**对象，并在一个单独的线程**io_context_thread**中执行。然后，创建了另外四个后台线程，工作被提交到**io_context**对象中。最后，主线程等待五秒钟，让所有线程完成它们的工作，并重置工作保护器，如果没有任何待处理的工作，则让**io_context.run()**函数返回。当程序退出时，所有线程自动合并，因为它们是**std::jthread**的实例。
- en: Parallelizing work done by one I/O execution context
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化一个I/O执行上下文所做的工作
- en: In the previous example, a unique I/O execution context object was used with
    its **run()** function being called from different threads. Then, each thread
    posted some work that completion handlers were executing in available threads
    at the time of completion.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，使用了一个独特的I/O执行上下文对象，其**run()**函数从不同的线程中被调用。然后，每个线程提交了一些工作，这些工作由完成处理程序在完成时在可用的线程中执行。
- en: This is a common way to parallelize work done by one I/O execution context,
    by calling its **run()** function from multiple threads, distributing the processing
    of asynchronous operations across those threads. This is possible because the
    **io_context** object provides a thread-safe event dispatching system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的并行化一个I/O执行上下文所做工作的方法，通过从多个线程调用其**run()**函数，将异步操作的处理分配给这些线程。这是可能的，因为**io_context**对象提供了一个线程安全的事件分发系统。
- en: 'Here is another example where a pool of threads is created, with each thread
    running **io_context.run()** , making these threads compete to pull tasks from
    the queue and execute them. In this case, only one asynchronous task is created
    using a timer that expires in two seconds. One of the threads will pick up the
    task and execute it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，其中创建了一个线程池，每个线程运行**io_context.run()**，使这些线程竞争从队列中拉取任务并执行它们。在这种情况下，仅使用一个在两秒后到期的计时器创建了一个异步任务。其中一个线程将拾取该任务并执行它：
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This technique improves scalability, as the application better utilizes multiple
    cores, and reduces latency by handling asynchronous tasks concurrently. Also,
    contention can be reduced and throughput increased by reducing bottlenecks generated
    when single-threaded code processes many simultaneous I/O operations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术提高了可伸缩性，因为应用程序更好地利用了多个核心，并通过并发处理异步任务来降低延迟。此外，通过减少单线程代码处理许多同时进行的I/O操作时产生的瓶颈，可以减少竞争并提高吞吐量。
- en: Note that the completion handlers also must use synchronization primitives and
    be thread-safe if they are shared across different threads or modify shared resources.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，完成处理程序也必须使用同步原语，并且如果它们在不同的线程之间共享或修改共享资源，则必须是线程安全的。
- en: Also, there is no guarantee in the order the completion handlers will be executed.
    As many threads can run simultaneously, any of them can complete earlier and call
    its associated completion handler.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，不能保证完成处理程序执行的顺序。由于可以同时运行许多线程，任何一个线程都可能先完成并调用其相关的完成处理程序。
- en: As threads are competing to pull tasks from the queue, there might be potential
    lock contention or context-switching overhead if the thread pool size is not optimal,
    ideally matching the number of hardware threads, as done in this example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于线程正在竞争从队列中拉取任务，如果线程池的大小不是最优的，可能会出现潜在的锁竞争或上下文切换开销，理想情况下应与硬件线程的数量相匹配，就像在这个例子中所做的那样。
- en: Now, it’s time to understand how the objects’ lifetime can affect the stability
    of our asynchronous programs developed with Boost.Asio.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候了解对象的生存期如何影响我们使用Boost.Asio开发的异步程序稳定性了。
- en: Managing objects’ lifetime
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象的生存期
- en: One of the main disastrous issues that can happen with asynchronous operations
    is that, when the operation takes place, some of the required objects have been
    destroyed. Therefore, managing objects’ lifetimes is crucial.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作可能引发的主要灾难性问题之一是，当操作进行时，一些必需的对象已经被销毁。因此，管理对象的生命周期至关重要。
- en: In C++, an object’s lifetime begins when the constructor ends and ends when
    the destructor begins.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个对象的生命周期从构造函数结束开始，到析构函数开始结束。
- en: A common pattern used to keep objects alive is to let the object create a shared
    pointer instance to itself, ensuring that the object remains valid as long as
    there are shared pointers pointing to it, meaning that there are ongoing asynchronous
    operations needing that object.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 保持对象存活的一个常用模式是让对象为自己创建一个指向自身的共享指针实例，确保只要存在指向该对象的共享指针，对象就保持有效，这意味着有持续进行的异步操作需要该对象。
- en: This technique is called **shared-from-this** and uses the **std::enable_shared_from_this**
    template base class, available since C++11, which provides the **shared_from_this()**
    method used by the object to obtain a shared pointer to itself.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为**shared-from-this**，它使用C++11以来可用的**std::enable_shared_from_this**模板基类，该基类提供了对象用来获取自身共享指针的**shared_from_this()**方法。
- en: Implementing an echo server – an example
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现回声服务器 – 示例
- en: Let’s see how it works by creating an echo server. At the same time, we will
    be discussing this technique, we will also be learning about how to use Boost.Asio
    for networking.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个回声服务器来看看它是如何工作的。同时，我们将讨论这项技术，我们还将学习如何使用Boost.Asio进行网络编程。
- en: Transmission of data over a network can take a long time to complete, and several
    errors can occur. That makes network I/O services a special good case to be dealt
    with by Boost.Asio. Network I/O services were the first services to be included
    in the library.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中传输数据可能需要很长时间才能完成，并且可能会发生几个错误。这使得网络I/O服务成为Boost.Asio处理的一个特殊良好案例。网络I/O服务是库中最早包含的服务之一。
- en: The main common usage of Boost.Asio in the industry is to develop networking
    applications due to its support for the internet protocols TCP, UDP, and ICMP.
    The library also provides a socket interface based on the **Berkeley Software
    Distribution** ( **BSD** ) socket API to allow the development of efficient and
    scalable applications using a low-level interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业界，Boost.Asio的主要常见用途是开发网络应用程序，因为它支持互联网协议TCP、UDP和ICMP。该库还提供了一个基于**伯克利软件发行版**（**BSD**）套接字API的套接字接口，以允许使用低级接口开发高效和可扩展的应用程序。
- en: However, as, in this book, we are interested in asynchronous programming, let’s
    focus on implementing an echo server using a high-level interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于在这本书中我们关注的是异步编程，让我们专注于使用高级接口实现回声服务器。
- en: An echo server is a program that listens to a specific address and port and
    writes back everything that it reads from that port. For that purpose, we will
    create a TCP server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回声服务器是一个监听特定地址和端口的程序，并将从该端口读取的所有内容写回。为此，我们将创建一个TCP服务器。
- en: 'The main program will simply create an **io_context** object, set up the **EchoServer**
    object by passing the **io_context** object and a port number to listen from,
    and call **io_context.run()** to start the event processing loop:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序将简单地创建一个**io_context**对象，通过传递**io_context**对象和一个要监听的端口号来设置**EchoServer**对象，并调用**io_context.run()**来启动事件处理循环：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When **EchoServer** initializes, it will start listening for incoming connections.
    It does that by using a **boost::asio::tcp::acceptor** object. This object accepts
    via its constructor an **io_context** object (as usual for I/O objects) and a
    **boost::asio::tcp::endpoint** object, which indicates the connection protocol
    and port number used for listening. As a **boost::asio::tcp::v4()** object is
    used to initialize the endpoint object, the protocol that the **EchoServer** will
    use is IPv4. The IP address is not specified to the endpoint constructor, therefore
    the endpoint IP address will be *any address* ( **INADDR_ANY** for IPv4 or **in6addr_any**
    for IPv6). Next, the code implementing the **EchoServer** constructor is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当**EchoServer**初始化时，它将开始监听传入的连接。它是通过使用一个**boost::asio::tcp::acceptor**对象来做到这一点的。这个对象通过其构造函数接受一个**io_context**对象（对于I/O对象来说通常是这样的）和一个**boost::asio::tcp::endpoint**对象，该对象指示用于监听的连接协议和端口号。由于使用了**boost::asio::tcp::v4()**对象来初始化端点对象，因此**EchoServer**将使用的协议是IPv4。没有指定给端点构造函数的IP地址，因此端点IP地址将是*任何地址*（IPv4的**INADDR_ANY**或IPv6的**in6addr_any**）。接下来，实现**EchoServer**构造函数的代码如下：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The **EchoServer** constructor calls the **do_accept()** function after setting
    up the acceptor object. The **do_accept()** function calls the **async_accept()**
    function waiting for incoming connections. When a client connects to the server,
    the OS returns the connection’s socket ( **boost::asio::tcp::socket** ) or an
    error via the **io_context** object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**EchoServer** 构造函数在设置好接受者对象后调用 **do_accept()** 函数。**do_accept()** 函数调用 **async_accept()**
    函数等待传入的连接。当客户端连接到服务器时，操作系统通过 **io_context** 对象返回连接的套接字（**boost::asio::tcp::socket**）或错误。'
- en: If there is no error and a connection is established, a shared pointer of a
    **Session** object is created, moving the socket into the **Session** object.
    Then, the **Session** object runs the **start()** function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误并且建立了连接，就创建一个 **Session** 对象的共享指针，将套接字移动到 **Session** 对象中。然后，**Session**
    对象运行 **start()** 函数。
- en: 'The **Session** object encapsulates the state of a particular connection, in
    this case, the **socket_** object and the **data_** buffer. It also manages asynchronous
    reads and writes into that buffer by using **do_read()** and **do_write()** ,
    which we will implement in a moment. But before this, comment that **Session**
    inherits from **std::enable_shared_from_this<Session>** , allowing **Session**
    objects to create shared pointers to themselves, ensuring that the session objects
    remain alive throughout the lifetime of asynchronous operations needing them,
    as long as there is at least one shared pointer pointing to a **Session** instance
    managing that connection. This shared pointer is the one created in the **do_accept()**
    function in the **EchoServer** object when the connection was established. Here
    is the implementation of the **Session** class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Session** 对象封装了特定连接的状态，在本例中是 **socket_** 对象和 **data_** 缓冲区。它还通过使用 **do_read()**
    和 **do_write()** 管理对该缓冲区的异步读取和写入，我们将在稍后实现它们。但在那之前，注释说明 **Session** 继承自 **std::enable_shared_from_this<Session>**，允许
    **Session** 对象创建指向自身的共享指针，确保会话对象在整个异步操作的生命周期中保持活跃，只要至少有一个共享指针指向管理该连接的 **Session**
    实例。这个共享指针是 **EchoServer** 对象中的 **do_accept()** 函数在建立连接时创建的。以下是 **Session** 类的实现：'
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using a **Session** class allows us to separate the logic that manages the connection
    from the one that manages the server. **EchoServer** just needs to accept connections
    and create a **Session** object per connection. That way, a server can manage
    multiple clients, keeping their connections independent and asynchronously managed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Session** 类允许我们将管理连接的逻辑与管理服务器的逻辑分开。**EchoServer** 只需要接受连接并为每个连接创建一个 **Session**
    对象。这样，服务器可以管理多个客户端，保持它们的连接独立并异步管理。
- en: '**Session** is the one that manages the behavior of that connection using the
    **do_read()** and **do_write()** functions. When **Session** starts, its **start()**
    function calls the **do_read()** function, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**Session** 是使用 **do_read()** 和 **do_write()** 函数管理该连接行为的对象。当 **Session** 开始时，它的
    **start()** 函数调用 **do_read()** 函数，如下所示：'
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The **do_read()** function creates a shared pointer to the current session object
    ( **self** ) and uses the socket’s **async_read_some()** asynchronous function
    to read some data into the **data_** buffer. If successful, this operation returns
    the data copied into the **data_** buffer and the number of read bytes in the
    **length** variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**do_read()** 函数创建当前会话对象（**self**）的共享指针，并使用套接字的 **async_read_some()** 异步函数将一些数据读取到
    **data_** 缓冲区。如果操作成功，此操作将返回复制到 **data_** 缓冲区的数据以及读取的字节数存储在 **length** 变量中。'
- en: 'Then, **do_write()** is called with that **length** variable, asynchronously
    writing the content of the **data_** buffer into the socket by using the **async_write()**
    function. When this asynchronous operation succeeds, it restarts the cycle by
    calling again the **do_read()** function, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用那个 **length** 变量调用 **do_write()**，通过使用 **async_write()** 函数异步地将 **data_**
    缓冲区的内容写入套接字。当这个异步操作成功时，它通过再次调用 **do_read()** 函数来重启循环，如下所示：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might wonder why it is that **self** is defined but is not being used. It
    looks like **self** is redundant, but as the lambda function is capturing it by
    value, a copy is being created, increasing the reference count of the shared pointer
    to the **this** object, ensuring that the session will not be destroyed if the
    lambda is active. The **this** object is captured to provide access to its members
    into the lambda function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么定义了**self**但没有使用它。它看起来**self**是多余的，但作为lambda函数按值捕获它，会创建一个副本，增加对**this**对象的共享指针的引用计数，确保如果lambda是活跃的，会话不会被销毁。**this**对象被捕获以在lambda函数中提供对其成员的访问。
- en: As an exercise, try to implement a **stop()** function that breaks the cycle
    between **do_read()** and **do_write()** . Once all asynchronous operations are
    complete and the lambda functions exit, the **self** objects will be destroyed
    and there will be no other shared pointers pointing to the **Session** object,
    thus the session will be destroyed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试实现一个**stop()**函数，以中断**do_read()**和**do_write()**之间的循环。一旦所有异步操作完成并且lambda函数退出，**self**对象将被销毁，并且没有其他共享指针指向**Session**对象，因此会话将被销毁。
- en: This pattern ensures robust and safe management of objects’ lifetimes during
    asynchronous operations, avoiding dangling pointers or early destruction, which
    would lead to undesired behavior or crashes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式确保在异步操作期间对对象生命周期的健壮和安全管理，避免了悬垂指针或过早销毁，这可能导致不期望的行为或崩溃。
- en: To test this server, just start the server, open a new terminal, and use the
    **telnet** command to connect to the server and send data to it. As arguments,
    we can pass the **localhost** address, indicating that we are connecting to a
    server running on the same machine (IP address of **127.0.0.1** ) and the port,
    in this case, **1234** .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试此服务器，只需启动服务器，打开一个新的终端，并使用**telnet**命令连接到服务器并向其发送数据。作为参数，我们可以传递**localhost**地址，表示我们正在连接到同一台机器上运行的服务器（IP地址为**127.0.0.1**）和端口号，在这种情况下，**1234**。
- en: The **telnet** command will start and show some information about the connection
    and indicate that we need to hit the *Ctrl* + *}* keys to close the connection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**telnet**命令将启动并显示一些关于连接的信息，并指示我们需要按下*Ctrl* + *}*键来关闭连接。'
- en: Typing anything and hitting the *Enter* key will send that entered line to the
    echo server, which will listen and send back the same content; in this example,
    it will be **Hello world!** .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输入任何内容并按*Enter*键将发送输入的行到回显服务器，服务器将监听并发送回相同的内容；在这个例子中，将是**Hello world!**。
- en: 'Just close the connection and exit **telnet** by using the **quit** command
    to exit back to the terminal:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 只需关闭连接并使用**quit**命令退出**telnet**回到终端：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we have already used a buffer. Let’s learn a bit more about
    them in the next section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经使用了一个缓冲区。让我们在下一节中了解更多关于它们的信息。
- en: Transferring data using buffers
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓冲区传输数据
- en: '**Buffers** are contiguous regions of memory used during I/O operations to
    transfer data.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲区**是在I/O操作期间用于传输数据的连续内存区域。'
- en: 'Boost.Asio defines two types of buffers: **mutable buffers** ( **boost::asio::mutable_buffer**
    ), where data can be written, and **constant buffers** ( **boost::asio::const_buffers**
    ), which are used to create read-only buffers. Mutable buffers can be converted
    into constant buffers, but not the opposite. Both types of buffers provide protection
    against overruns.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio定义了两种类型的缓冲区：**可变缓冲区**（**boost::asio::mutable_buffer**），其中可以写入数据，和**常量缓冲区**（**boost::asio::const_buffers**），用于创建只读缓冲区。可变缓冲区可以转换为常量缓冲区，但不能反向转换。这两种类型的缓冲区都提供了防止越界的保护。
- en: 'There is also the **boost::buffer** function to help with the creation of mutable
    or constant buffers from different data types (a pointer to raw memory and size,
    a string ( **std::string** ), or an array or vector of **plain old data** ( **POD**
    ) structures (meaning a type, a structure, or a class that has no user-defined
    copy assignment operator or destructor, and without private or protected non-static
    data members). For example, to create a buffer from an array of chars, we can
    use the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有**boost::buffer**函数，用于从不同数据类型（原始内存的指针和大小、字符串（**std::string**）、或**原始数据**（**POD**）结构（意味着一个没有用户定义的复制赋值运算符或析构函数的类型、结构或类，并且没有私有或受保护的非静态数据成员）的数组或向量）创建可变或常量缓冲区。例如，要从字符数组创建缓冲区，我们可以使用以下代码：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Also, note that the buffer’s ownership and lifetime are the responsibility of
    the program, not the Boost.Asio library.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，缓冲区的所有权和生命周期是程序的责任，而不是Boost.Asio库的责任。
- en: Scatter-gather operations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scatter-gather操作
- en: Buffers can be used efficiently by using scatter-gather operations where multiple
    buffers are used together to receive data (scatter-read) or to send data (gather-write).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用scatter-gather操作，可以有效地使用缓冲区，其中多个缓冲区一起用于接收数据（scatter-read）或发送数据（gather-write）。
- en: '**Scatter-read** is the process of reading data from a unique source into different
    non-contiguous memory buffers.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scatter-read**是从唯一源读取数据到不同的非连续内存缓冲区的过程。'
- en: '**Gather-write** is the opposite process; data is gathered from different non-contiguous
    memory buffers and written into a single destination.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gather-write**是相反的过程；数据从不同的非连续内存缓冲区中收集并写入单个目标。'
- en: These techniques increase efficiency and performance as they reduce the number
    of system calls or data copying. They are not only used for I/O operations but
    also in other use cases, such as data processing, machine learning, or parallel
    algorithms, such as sorting or matrix multiplication.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术通过减少系统调用或数据复制的次数来提高效率和性能。它们不仅用于I/O操作，还用于其他用例，例如数据处理、机器学习或并行算法，如排序或矩阵乘法。
- en: To allow scatter-gather operations, several buffers can be passed together to
    the asynchronous operation inside a container ( **std::vector** , **std::list**
    , **std::array** , or **boost::array** ).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许scatter-gather操作，可以将多个缓冲区一起传递到容器中的异步操作内部（**std::vector**、**std::list**、**std::array**或**boost::array**）。
- en: 'Here is an example of scatter-read where a socket reads some data asynchronously
    into both the **buf1** and **buf2** buffers:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个scatter-read的示例，其中套接字异步地将一些数据读取到**buf1**和**buf2**缓冲区中：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is how to achieve a gather-read:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何实现gather-read的：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, the socket does the opposite operation, writing some data from both buffers
    into the socket buffer for asynchronous sending.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，套接字执行相反的操作，将两个缓冲区中的数据写入套接字缓冲区以进行异步发送。
- en: Stream buffers
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流缓冲区
- en: We can also use stream buffers to manage data. **Stream buffers** are defined
    by the **boost::asio::basic_streambuf** class, based in the **std::basic_streambuf**
    C++ class and defined in the **<streambuf>** header file. It allows a dynamic
    buffer where its size can adapt to the amount of data being transferred.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用流缓冲区来管理数据。**Stream buffers**由**boost::asio::basic_streambuf**类定义，基于**std::basic_streambuf**
    C++类，并在**<streambuf>**头文件中定义。它允许一个动态缓冲区，其大小可以适应传输的数据量。
- en: Let’s see in the following example how stream buffers work together with scatter-gather
    operations. In this case, we are implementing a TCP server that listens and accepts
    clients’ connections from a given port, reads the messages sent by the clients
    into two stream buffers, and prints their content to the console. As we are interested
    in understanding stream buffers and scatter-gather operations, let’s simplify
    the example by using synchronous operations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例中流缓冲区如何与scatter-gather操作一起工作。在这种情况下，我们正在实现一个TCP服务器，该服务器监听并接受来自给定端口的客户端连接，将客户端发送的消息读取到两个流缓冲区中，并将它们的内容打印到控制台。由于我们感兴趣的是理解流缓冲区和scatter-gather操作，让我们通过使用同步操作来简化示例。
- en: 'As in the previous example, in the **main()** function, we use a **boost::asio::ip::tcp::acceptor**
    object to set up the protocol and port that the TCP server will use to accept
    connections. Then, in an infinite loop, the server uses that acceptor object to
    attach a TCP socket ( **boost::asio::ip::tcp::socket** ) and call the **handle_client()**
    function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个示例所示，在**main()**函数中，我们使用一个**boost::asio::ip::tcp::acceptor**对象来设置TCP服务器将用于接受连接的协议和端口。然后，在一个无限循环中，服务器使用该acceptor对象附加一个TCP套接字（**boost::asio::ip::tcp::socket**）并调用**handle_client()**函数：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The **handle_client()** function creates two stream buffers: **buf1** and **buf2**
    , and adds them to a container, in this case, **std::array** , to be used in scatter-gather
    operations.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**handle_client()**函数创建了两个流缓冲区：**buf1**和**buf2**，并将它们添加到一个容器中，在这种情况下是**std::array**，用于scatter-gather操作。'
- en: Then, the synchronous **read_some()** function from the socket is called. This
    function returns the number of bytes read from the socket and copies them into
    the buffers. If anything goes wrong with the socket connection, an error will
    be returned in the error code object, **ec** . In that case, the server will print
    the error message and exit.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，调用套接字的同步**read_some()**函数。此函数返回从套接字读取的字节数并将它们复制到缓冲区中。如果套接字连接出现任何问题，错误将返回到错误代码对象**ec**中。在这种情况下，服务器将打印错误消息并退出。
- en: 'Here is the implementation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现方式：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If there are no errors, the stream buffers’ **commit()** function is used to
    transfer five bytes to each of the stream buffers, **buf1** and **buf2** . The
    contents of these buffers are extracted by using **std::istream** objects and
    printed to the console.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，流缓冲区的 **commit()** 函数用于将五个字节传输到每个流缓冲区，即 **buf1** 和 **buf2**。这些缓冲区的内容通过使用
    **std::istream** 对象提取并打印到控制台。
- en: 'To execute this example, we need to open two terminals. In one terminal, we
    execute the server, and in the other, the **telnet** command, as shown earlier.
    In the **telnet** terminal, we can type a message (for example, *Hello World*
    ). This message is sent to the server. The server terminal will then show the
    following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，我们需要打开两个终端。在一个终端中，我们执行服务器，在另一个终端中执行 **telnet** 命令，如前所述。在 **telnet** 终端中，我们可以输入一条消息（例如，*Hello
    World*）。这条消息将被发送到服务器。然后服务器终端将显示以下内容：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, only 10 bytes are processed and distributed into the two buffers.
    The space character between the two words is processed but discarded when parsing
    the input by the **iostream** objects.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，只有 10 个字节被处理并分配到两个缓冲区中。两个单词之间的空格在通过 **iostream** 对象解析输入时被处理但被丢弃。
- en: Stream buffers are useful when the size of the incoming data is variable and
    unknown in advance. These types of buffers can be used together with fixed-sized
    buffers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到的数据大小可变且事先未知时，流缓冲区非常有用。这些类型的缓冲区可以与固定大小的缓冲区一起使用。
- en: Signal handling
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号处理
- en: '**Signal handling** allows us to catch signals sent by the OS and gracefully
    shut down the application before the OS decides to kill the application’s process.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号处理**允许我们捕获操作系统发送的信号，并在操作系统决定杀死应用程序进程之前优雅地关闭应用程序。'
- en: Boost.Asio provides the **boost::asio::signal_set** class for this purpose,
    which starts an asynchronous wait for one or more signals to occur.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Asio 提供了 **boost::asio::signal_set** 类来实现此目的，该类启动对一个或多个信号发生的异步等待。
- en: 'This is an example of how to handle the **SIGINT** and **SIGTERM** signals:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何处理 **SIGINT** 和 **SIGTERM** 信号的示例：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The **signals** object is **signal_set** , listing the signals that the program
    waits for, **SIGINT** and **SIGTERM** . This object has an **async_wait()** method
    that asynchronously waits for any of those signals to happen and triggers the
    completion handler, **handle_signal()** .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**signals** 对象是 **signal_set**，列出了程序等待的信号，**SIGINT** 和 **SIGTERM**。此对象有一个 **async_wait()**
    方法，它异步等待这些信号中的任何一个发生，并触发完成处理程序，**handle_signal()**。'
- en: As usual in completion handlers, **handle_signal()** checks the error code,
    **ec** , and if there is no error, some cleanup code might execute to cleanly
    and gracefully exit the program. In this example, we just stop the event processing
    loop by calling **io_context.stop()** .
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在完成处理程序中通常所做的那样，**handle_signal()** 检查错误代码，**ec**，如果没有错误，可能会执行一些清理代码以干净和优雅地退出程序。在这个例子中，我们只是通过调用
    **io_context.stop()** 来停止事件处理循环。
- en: We could also wait synchronously for signals by using the **signals.wait()**
    method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 **signals.wait()** 方法同步等待信号。
- en: If the application is multithreaded, the signals event handler must run in the
    same thread as the **io_context** object, typically being the main thread.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序是多线程的，信号事件处理程序必须在与 **io_context** 对象相同的线程中运行，通常是主线程。
- en: In the next section, we will learn how to cancel operations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何取消操作。
- en: Canceling operations
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消操作
- en: Some I/O objects, such as sockets or timers, have object-wide cancellation of
    outstanding asynchronous operations by calling their **close()** or **cancel()**
    methods. If an asynchronous operation is canceled, the completion handler will
    receive an error with the **boost::asio::error::operation_aborted** code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 I/O 对象，如套接字或定时器，可以通过调用它们的 **close()** 或 **cancel()** 方法来取消未完成的异步操作。如果异步操作被取消，完成处理程序将接收到一个带有
    **boost::asio::error::operation_aborted** 代码的错误。
- en: 'In the following example, a timer is created, and its timeout period is set
    to five seconds. But after sleeping the main thread for only two seconds, the
    timer is canceled by calling its **cancel()** method, making the completion handler
    be called with a **boost::asio::error::operation_aborted** error code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，创建了一个定时器，并将其超时时间设置为五秒。但是，在主线程仅休眠两秒后，通过调用其 **cancel()** 方法取消定时器，使得完成处理程序以
    **boost::asio::error::operation_aborted** 错误代码被调用：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But if we want a per-operation cancellation, we need to set up a cancellation
    slot that will be triggered when a cancellation signal is emitted. This cancellation
    signal/slot pair composes a lightweight channel to communicate cancellation operations,
    like the ones created between promises and futures explained in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125)
    . The cancellation framework has been available in Boost.Asio since version 1.75.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想实现按操作取消，我们需要设置一个在取消信号发出时被触发的取消槽。这个取消信号/槽对构成了一个轻量级通道，用于通信取消操作，就像在[*第6章*](B22219_06.xhtml#_idTextAnchor125)中解释的承诺和未来之间创建的那样。取消框架自Boost.Asio
    1.75版本以来就可用。
- en: This approach enables a more flexible cancellation mechanism where multiple
    operations can be canceled using the same signal, and it integrates seamlessly
    with Boost.Asio’s asynchronous operations. Synchronous operations can only be
    canceled by using the **cancel()** or **close()** methods described earlier; they
    are not supported by the cancellation slots mechanism.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法实现了一种更灵活的取消机制，其中可以使用相同的信号取消多个操作，并且它与Boost.Asio的异步操作无缝集成。同步操作只能通过使用前面描述的**cancel()**或**close()**方法来取消；它们不受取消槽机制的支持。
- en: Let’s modify the previous example and use a cancellation signal/slot to cancel
    the timer. We only need to modify the way the timer is canceled in the **main()**
    function. Now, when the asynchronous **async_wait()** operation is executed, a
    cancellation slot is created by binding a slot from the cancellation signal and
    the completion handler using the **boost::asio::bind_cancellation_slot()** function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的示例，并使用取消信号/槽来取消计时器。我们只需要修改**main()**函数中取消计时器的方式。现在，当执行异步**async_wait()**操作时，通过使用**boost::asio::bind_cancellation_slot()**函数将取消信号的槽绑定到完成处理程序，将创建一个取消槽。
- en: 'As before, the timer has an expiration period of five seconds, and again, the
    main thread only sleeps for two seconds. This time, a cancellation signal is emitted
    by calling the **cancel_signal.emit()** function. The signal will trigger the
    counterpart cancellation slot and execute the completion handler with a **boost::asio::error::operation_aborted**
    error code, printing in the console the **Timer canceled.** message; see the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，计时器的到期时间为五秒，再次强调，主线程只睡眠两秒。这次，通过调用**cancel_signal.emit()**函数发出取消信号。该信号将触发对应的取消槽，并使用**boost::asio::error::operation_aborted**错误代码执行完成处理程序，在控制台打印**Timer
    canceled.**消息；请参见以下内容：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the signal is emitted, a cancellation type must be specified, letting the
    target operation know what the application requires and the operation guarantees,
    thus controlling the scope and behavior of the cancellation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出信号时，必须指定取消类型，让目标操作知道应用程序的要求和操作保证，从而控制取消的范围和行为。
- en: 'The various categories of cancellation are as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 取消的各类别如下：
- en: '**None** : No cancellation is performed. It can be useful if we want to test
    if a cancellation should occur.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：不执行取消。如果我们想测试是否应该发生取消，这可能很有用。'
- en: '**Terminal** : The operation has unspecified side effects so the only safe
    way to cancel the operation is to close or destroy the I/O object, being its result
    final, for example, completing a task or transaction.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**：操作具有未指定的副作用，因此取消操作的唯一安全方法是关闭或销毁I/O对象，因为其结果是最终的，例如，完成任务或事务。'
- en: '**Partial** : The operation has well-defined side effects so the completion
    handler can take the required actions to resolve the issue, meaning that the operation
    is partially completed and can be resumed or retried.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分**：操作具有定义良好的副作用，因此完成处理程序可以采取必要的行动来解决该问题，这意味着操作已部分完成，可以恢复或重试。'
- en: '**Total** or **All** : The operation has no side effects. Cancels both terminal
    and partial operations, enabling a comprehensive cancellation by stopping all
    ongoing asynchronous operations.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全部**或**全部**：操作没有副作用。取消终止和部分操作，通过停止所有正在进行的异步操作实现全面取消。'
- en: If the cancellation type is not supported by the asynchronous operation, the
    cancellation request is discarded. For example, timer operations support all categories
    of cancellation, but sockets only support **Total** and **All** , meaning that
    if we try to cancel a socket asynchronous operation with a **Partial** cancellation,
    this cancellation will be ignored. This prevents undefined behavior if an I/O
    system tries to handle an unsupported cancellation request.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异步操作不支持取消类型，则取消请求将被丢弃。例如，计时器操作支持所有取消类别，但套接字只支持 **Total** 和 **All**，这意味着如果我们尝试使用
    **Partial** 取消来取消套接字异步操作，则此取消请求将被忽略。这防止了如果 I/O 系统尝试处理不受支持的取消请求时出现未定义的行为。
- en: Also, cancellation requests made after the operation is initiated but before
    it starts, or after its completion, have no effect.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在操作开始之前或完成之后提出的取消请求没有任何效果。
- en: Sometimes, we need to run some work sequentially. Next, we will introduce how
    we can achieve this by using strands.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要按顺序运行一些工作。接下来，我们将介绍如何通过使用线程来实现这一点。
- en: Serializing workload with strands
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程序列化工作负载
- en: A **strand** is a strict sequential and non-concurrent invocation of completion
    handlers. Using strands, asynchronous operations can be sequenced without explicit
    locking by using mutexes or other synchronization mechanisms seen earlier in this
    book. Strands can be implicit or explicit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是一种严格的顺序和非并发调用完成处理器的机制。使用线程，异步操作可以在不使用互斥锁或其他之前在本书中看到的同步机制的情况下进行排序。线程可以是隐式的或显式的。'
- en: As shown earlier in this chapter, if we execute **boost::asio::io_context::run()**
    from only one thread, all event handlers will execute in an implicit strand, as
    they will be sequentially queued one by one and triggered from the I/O execution
    context.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所示，如果我们只从一个线程执行 **boost::asio::io_context::run()**，所有的事件处理器都将在一个隐式线程中执行，因为它们将一个接一个地按顺序排队并从
    I/O 执行上下文中触发。
- en: Another implicit strand happens when there are chained asynchronous operations
    where one asynchronous operation schedules the next asynchronous operation, and
    so on. Some previous examples in this chapter already used this technique, but
    here there is another one.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在链式异步操作时，其中一个异步操作安排下一个异步操作，依此类推，会发生另一个隐式线程。本章中的一些先前示例已经使用了这种技术，但这里还有一个例子。
- en: 'In this case, if there are no errors, the timer keeps restarting itself in
    the **handle_timer_expiry()** event handler by recursively setting up the expiration
    time and calling the **async_wait()** method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有错误，计时器将通过在 **handle_timer_expiry()** 事件处理器中递归地设置过期时间并调用 **async_wait()**
    方法来不断重启自己：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running this example would print the **Timer expired. Count: <number>** line
    every second with the counter increasing on each line.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '运行此示例将每秒打印一次 **Timer expired. Count: <number>** 行，计数器在每一行上递增。'
- en: In case some work needs to be serialized but these approaches are not appropriate,
    we can use explicit strands by using **boost::asio::strand** or its specialization
    for I/O context execution objects, **boost::asio::io_context::strand** . Posted
    work using these strand objects will serialize their handler execution in the
    order they enter the I/O execution context queue.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些工作需要序列化，但这些方法不适用，我们可以通过使用 **boost::asio::strand** 或其针对 I/O 上下文执行对象的特化，**boost::asio::io_context::strand**
    来使用显式线程。使用这些线程对象发布的作业将按它们进入 I/O 执行上下文队列的顺序序列化其处理器的执行。
- en: In the following example, we will create a logger that serializes writing operations
    into a single log file from several threads. We will be logging messages from
    four threads, writing five messages from each. We expect the output to be correct,
    but this time without using any mutex or other synchronization mechanism.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将创建一个记录器，它将多个线程中的写入操作序列化到一个单个日志文件中。我们将从四个线程中记录消息，每个线程写入五条消息。我们期望输出是正确的，但这次不使用任何互斥锁或其他同步机制。
- en: 'Let’s start by defining the **Logger** class:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 **Logger** 类：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The **Logger** constructor accepts an I/O context object, used to create a strand
    object ( **boost::asio::io_context::strand** ), and **std::string** , specifying
    a log filename that is used to open the log file or create it if it does not exist.
    The log file is open for appending new content. If the file is not open before
    the constructor finishes, meaning that there was an issue when accessing or creating
    the file, the constructor throws an exception.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**Logger**构造函数接受一个I/O上下文对象，用于创建一个线程对象（**boost::asio::io_context::strand**），以及**std::string**，指定用于打开日志文件或创建它的日志文件名。日志文件用于追加新内容。如果构造函数完成前文件未打开，意味着在访问或创建文件时出现问题，构造函数将抛出异常。'
- en: The logger also provides the public **log()** function that accepts **std::string**
    , specifying a message as a parameter. This function uses the strand to post new
    work into the **io_context** object. It does that by using a lambda function,
    capturing by value the logger instance (the object **this** ) and the message,
    and calls the private **do_log()** function, where a **std::fstream** object is
    used to write the message into the output file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器还提供了一个公共的**log()**函数，该函数接受**std::string**，指定一个消息作为参数。此函数使用线程对象将新工作提交到**io_context**对象。它是通过使用lambda函数实现的，通过值捕获记录器实例（对象**this**）和消息，并调用私有的**do_log()**函数，在该函数中使用**std::fstream**对象将消息写入输出文件。
- en: There will be only one instance of the **Logger** class in the program, shared
    by all threads. That way, the threads will write to the same file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中只有一个**Logger**类的实例，由所有线程共享。这样，线程将写入同一个文件。
- en: 'Let’s define a **worker()** function that each thread will run to write **num_messages_per_thread**
    messages into the output file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个**worker()**函数，每个线程将运行此函数以将**num_messages_per_thread**条消息写入输出文件：
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function accepts a shared pointer to the **Logger** object and a thread
    identifier. It prints all the messages using the **Logger** ’s public **log()**
    function explained earlier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受对**Logger**对象的共享指针和一个线程标识符。它使用前面解释的**Logger**的公共**log()**函数打印所有消息。
- en: To interleave the threads executions and rigorously test how the strands work,
    each thread will sleep for 100 ms after writing each message.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了交错线程执行并严格测试线程的工作方式，每个线程在写入每条消息后都将睡眠100毫秒。
- en: Finally, in the **main()** function, we start an **io_context** object and a
    work guard to avoid an early exit from the **io_context** . Then, a shared pointer
    to a **Logger** instance is created, passing the necessary parameters explained
    earlier.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在**main()**函数中，我们启动一个**io_context**对象和一个工作保护器，以避免从**io_context**中提前退出。然后，创建一个指向**Logger**实例的共享指针，传递前面解释的必要参数。
- en: A thread pool (vector of **std::jthread** objects) is created by using the **worker()**
    function and passing the shared pointer to the logger and a unique identifier
    for each thread. Also, a thread running the **io_context.run()** function is added
    to the thread pool.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**worker()**函数并传递对记录器的共享指针以及每个线程的唯一标识符，创建了一个线程池（**std::jthread**对象向量）。此外，还添加了一个运行**io_context.run()**函数的线程到线程池中。
- en: In the following example, as we know that all messages will be printed out in
    less than two seconds, we make **io_context** run for only that period, using
    **io_context.run_for(2s)** .
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，由于我们知道所有消息将在两秒内打印出来，我们使**io_context**只运行那个时间段，使用**io_context.run_for(2s)**。
- en: 'When the **run_for()** function exits, the program prints **Done!** to the
    console and finishes:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当**run_for()**函数退出时，程序将打印**Done!**到控制台并结束：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Running this example will show the following output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将显示以下输出：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is the content of the generated **log.txt** log file. As the sleep time
    for each thread is the same, all threads and messages are sequentially ordered:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的**log.txt**日志文件的内容。由于每个线程的睡眠时间相同，所有线程和消息都是顺序排列的：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we remove the work guard, the log file only has the following content:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除工作保护器，日志文件只包含以下内容：
- en: '[PRE40]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This happens because the first batch of work is promptly posted and queued into
    **io_object** from each thread, but **io_object** exits after finishing dispatching
    the work guard and notifying the completion handlers before the second batch of
    messages is posted.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为第一个工作批次被及时提交并排队到每个线程的**io_object**中，但在第二个消息批次提交之前，**io_object**在完成工作保护器的调度和通知完成处理程序后退出。
- en: 'If we also remove the **sleep_for()** instruction in the worker thread, now,
    the log file content is as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们也在工作线程中移除**sleep_for()**指令，现在，日志文件的内容如下：
- en: '[PRE41]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Earlier, the content was sorted by message identifier, and now it’s by thread
    identifier. This is because now, when a thread starts and runs the **worker()**
    function, it posts all messages at once, without any delay. Therefore, the first
    thread (thread **0** ) enqueues all its work before the second thread has the
    chance to do that, and so on.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，内容是按消息标识符排序的，现在则是按线程标识符排序。这是因为现在，当一个线程开始运行 **worker()** 函数时，它会一次性发布所有消息，没有任何延迟。因此，第一个线程（线程
    **0**）在第二个线程有机会这样做之前，就将其所有工作入队，依此类推。
- en: 'Continuing with further experiments, when we posted content into the strand,
    we captured the logger instance and the message by value, by using the following
    instruction:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行进一步实验时，当我们向 strand 中发布内容时，我们通过以下指令捕获了日志记录器实例和消息的值：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Capturing by value allows the lambda function running **do_log()** to use a
    copy of the needed objects, keeping them alive, as commented earlier in this chapter
    when we discussed object lifetimes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值捕获允许 lambda 函数运行 **do_log()** 时使用所需对象的副本，保持它们存活，正如在本章前面讨论对象生命周期时注释的那样。
- en: 'Say, for some reason, we decided to capture by reference using the following
    instruction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，由于某种原因，我们决定使用以下指令通过引用捕获：
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Then, the resulting log file will have incomplete log messages and even incorrect
    characters because the logger is printing from memory areas that belonged to a
    message object that no longer exists when the **do_log()** function executes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生成的日志文件将包含不完整的日志消息，甚至可能包含错误的字符，因为日志记录器是从属于不再存在的消息对象的内存区域打印的，当 **do_log()**
    函数执行时。
- en: Therefore, always assume asynchronous changes; the OS might perform some changes
    out of our control, so always know what is under our control and, most importantly,
    what’s not.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，始终假设异步更改；操作系统可能会执行一些我们无法控制的变化，所以始终要知道我们控制的是什么，最重要的是，什么不是。
- en: 'Finally, instead of using a lambda expression and capturing the **this** and
    **message** objects by value, we could also use **std::bind** as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不仅可以使用 lambda 表达式并通过值捕获 **this** 和 **message** 对象，还可以像下面这样使用 **std::bind**：
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s learn now how we can simplify the echo server we implemented earlier by
    using coroutines and improving it by adding a command to exit the connection from
    the client’s side.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何通过使用协程简化我们之前实现的 echo 服务器，并通过添加一个命令从客户端退出连接来改进它。
- en: Coroutines
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Boost.Asio has also included support for coroutines since version 1.56.0 and
    supported native coroutines since version 1.75.0.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.56.0 版本以来，Boost.Asio 也包括了协程的支持，并从 1.75.0 版本开始支持原生协程。
- en: As we have learned in the previous chapter, using coroutines simplifies how
    the program is written as there is no need to add completion handlers and split
    the flow of the program into different asynchronous functions and callbacks. Instead,
    with coroutines, the program follows a sequential structure where an asynchronous
    operation call pauses the execution of the coroutine. When the asynchronous operation
    completes, the coroutine is resumed, letting the program continue its execution
    from where it was previously paused.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，使用协程简化了程序的编写方式，因为不需要添加完成处理程序并将程序的流程分割成不同的异步函数和回调。相反，使用协程，程序遵循顺序结构，异步操作调用会暂停协程的执行。当异步操作完成时，协程会恢复，让程序从之前暂停的地方继续执行。
- en: With newer versions (newer than 1.75.0), we can use native C++ coroutines via
    **co_await** , to wait for asynchronous operations within a coroutine, **boost::asio::co_spawn**
    to launch a coroutine, and **boost::asio::use_awaitable** to let Boost.Asio know
    that an asynchronous operation will use coroutines. With earlier versions (from
    1.56.0), coroutines were available using **boost::asio::spawn()** and **yield**
    contexts. As the newer approach is preferred, not only because it supports native
    C++20 coroutines, but the code is also more modern, clean, and readable, we will
    focus on this approach in this section.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在新版本（1.75.0之后的版本）中，我们可以通过 **co_await** 使用原生 C++ 协程，在协程中等待异步操作，使用 **boost::asio::co_spawn**
    来启动协程，以及使用 **boost::asio::use_awaitable** 来让 Boost.Asio 知道异步操作将使用协程。在早期版本（从 1.56.0
    开始），可以通过 **boost::asio::spawn()** 和 **yield** 上下文使用协程。由于新方法更受欢迎，不仅因为它支持原生 C++20
    协程，而且代码也更现代、简洁、易读，我们将在这个部分专注于这种方法。
- en: Let’s implement again the echo server, but this time using Boost.Asio’s awaitable
    interface and coroutines. We will also add some improvements, such as support
    to close the connection from the client’s side when sending the **QUIT** command,
    showing how to process data or commands on the server side, and stopping handling
    connections and exiting if any exception is thrown.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次实现 echo 服务器，但这次使用 Boost.Asio 的 awaitable 接口和协程。我们还将添加一些改进，例如支持在发送 **QUIT**
    命令时从客户端关闭连接，展示如何在服务器端处理数据或命令，以及在抛出任何异常时停止处理连接并退出。
- en: Let’s start by implementing the **main()** function. The program starts by using
    **boost::asio::co_spawn** to create a new coroutine-based thread. This function
    accepts as parameters an execution context ( **io_context** , but can also use
    a strand), a function with the **boost::asio::awaitable<R,E>** return type, which
    will be used as the coroutine’s entry point (the **listener()** function that
    we will implement and explain next), and a completion token that will be called
    when the thread has completed. If we want to run the coroutine without being notified
    of its completion, we can pass the **boost::asio::detached** token.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现 **main()** 函数。程序开始时使用 **boost::asio::co_spawn** 创建一个新的基于协程的线程。这个函数接受一个执行上下文（**io_context**，也可以使用
    strand），一个返回类型为 **boost::asio::awaitable<R,E>** 的函数，该函数将用作协程的入口点（我们将实现并解释的 **listener()**
    函数），以及一个完成令牌，当线程完成时将被调用。如果我们想在不通知其完成的情况下运行协程，我们可以传递 **boost::asio::detached**
    令牌。
- en: Finally, we start processing asynchronous events by calling **io_context.run()**
    .
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 **io_context.run()** 开始处理异步事件。
- en: 'In case there is any exception, it will be caught by the try-catch block, and
    the event processing loop will be stopped by calling **io_context.stop()** :'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何异常发生，它将被 try-catch 块捕获，并且通过调用 **io_context.stop()** 来停止事件处理循环：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The **listener()** function receives as parameters an **io_context** object
    and the port number that the listener will accept connections from, using an **acceptor**
    object as explained earlier. It also must have a return type of **boost::asio::awaitable<R,E>**
    , where **R** is the return type of the coroutine and **E** is the exception type
    that might be thrown. In this example, **E** is set as default, so not explicitly
    specified.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**listener()** 函数接收一个 **io_context** 对象和监听器将接受的端口号作为参数，使用前面解释的 **acceptor**
    对象。它还必须有一个返回类型为 **boost::asio::awaitable<R,E>** ，其中 **R** 是协程的返回类型，**E** 是可能抛出的异常类型。在这个例子中，**E**
    被设置为默认值，因此没有明确指定。'
- en: The connection is accepted by calling the **async_accept** acceptor function.
    As we are now using a coroutine, we need to specify **boost::asio::use_awaitable**
    to the asynchronous function and use **co_await** to stop the coroutine execution
    until is resumed when the asynchronous task completes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 **async_accept** 接受器函数来接受连接。由于我们现在使用协程，我们需要将 **boost::asio::use_awaitable**
    指定给异步函数，并使用 **co_await** 来停止协程执行，直到异步任务完成时恢复。
- en: 'When the listener coroutine task resumes, **acceptor.async_accept()** returns
    a socket object. The coroutine continues by spawning a new thread, using the **boost::asio::co_spawn**
    function, executing the **echo()** function, and passing the **socket** object
    to it:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当监听协程任务恢复时，**acceptor.async_accept()** 返回一个套接字对象。协程继续通过使用 **boost::asio::co_spawn**
    函数创建一个新的线程，执行 **echo()** 函数，并将 **socket** 对象传递给它：
- en: '[PRE46]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The **echo()** function is responsible for handling a single client connection.
    It must follow a similar signature as the **listener()** function; it needs a
    return type of **boost::asio::awaitable<R,E>** . As commented earlier, the **socket**
    object is moved into this function from the listener.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**echo()** 函数负责处理单个客户端连接。它必须遵循与 **listener()** 函数相似的签名；它需要一个返回类型为 **boost::asio::awaitable<R,E>**
    。如前所述，**socket** 对象是从监听器移动到这个函数中的。'
- en: The function asynchronously reads content from the socket and writes it back
    in an infinite loop that only finishes if it receives the **QUIT** command or
    an exception is thrown.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 函数异步地从套接字读取内容，并在一个无限循环中将其写回，只有当它接收到 **QUIT** 命令或抛出异常时循环才会结束。
- en: Asynchronous reads are done by using the **socket.async_read_some()** function,
    which reads data into the data buffer using **boost::asio::buffer** and returns
    the number of bytes read ( **bytes_read** ). As the asynchronous task is managed
    by a coroutine, **boost::asio::use_awaitable** is passed to the asynchronous operation.
    Then, **co_wait** just instructs the coroutine engine to pause the execution until
    the asynchronous operation finishes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 异步读取是通过使用**socket.async_read_some()**函数完成的，该函数使用**boost::asio::buffer**将数据读入数据缓冲区，并返回读取的字节数（**bytes_read**）。由于异步任务由协程管理，因此将**boost::asio::use_awaitable**传递给异步操作。然后，**co_wait**只是指示协程引擎暂停执行，直到异步操作完成。
- en: Once some data is received, the execution of the coroutine resumes, checking
    if there is really some data to process, otherwise, it finishes the connection
    by exiting the loop, thus the **echo()** function as well.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦接收到一些数据，协程的执行就会继续，检查是否真的有数据需要处理，如果没有，它将通过退出循环来结束连接，从而结束**echo()**函数。
- en: If data is read, it converts it into **std::string** for easy manipulation.
    It removes the **\r\n** ending, if present, and compares the string against **QUIT**
    .
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取到数据，它将其转换为**std::string**以便于操作。如果存在，它会移除**\r\n**结束符，并将字符串与**QUIT**进行比较。
- en: If **QUIT** is present, it performs an asynchronous write, sends the **Good
    bye!** message, and exits the loop. Otherwise, it sends the received data back
    to the client. In both cases, an asynchronous write operation is performed by
    using the **boost::asio::async_write()** function, passing the socket, **boost:asio::buffer**
    wrapping the data buffer to send, and **boost::asio::use_awaitable** as with the
    asynchronous read operation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在**QUIT**，它将执行异步写入，发送**Good bye!**消息，并退出循环。否则，它将发送接收到的数据回客户端。在这两种情况下，都使用**boost::asio::async_write()**函数执行异步写入操作，传递套接字、**boost:asio::buffer**包装要发送的数据缓冲区，以及与异步读取操作相同的**boost::asio::use_awaitable**。
- en: 'Then, **co_await** is used again to suspend the execution of the coroutine
    while the operation is performed. Once completed, the coroutine will resume and
    repeat these steps in a new loop iteration:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，再次使用**co_await**来挂起协程的执行，同时进行操作。一旦完成，协程将恢复，并在新的循环迭代中重复这些步骤：
- en: '[PRE47]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The coroutine loops until no data is read, happening when the client closes
    the connection, when the **QUIT** command is received, or when an exception occurs.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 协程循环直到没有读取到数据，这发生在客户端关闭连接、接收到**QUIT**命令或发生异常时。
- en: Asynchronous operations are used throughout to ensure the server remains responsive,
    even when handling multiple clients simultaneously.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作被广泛应用于确保服务器在同时处理多个客户端时仍保持响应。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Boost.Asio and how to use this library to
    manage asynchronous tasks that deal with external resources managed by the OS.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Boost.Asio以及如何使用这个库来管理由操作系统管理的资源的外部资源的异步任务。
- en: For that purpose, we introduced the I/O objects and I/O execution context objects,
    with an in-depth explanation of how they work and interact together, how they
    access and communicate with OS services, what the design principles are behind
    them, and how to use them properly in single-threaded and multi-threaded applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们介绍了I/O对象和I/O执行上下文对象，并深入解释了它们是如何工作以及如何相互交互的，它们如何访问和与操作系统服务进行通信，它们背后的设计原则是什么，以及如何在单线程和多线程应用程序中正确使用它们。
- en: We also showed different techniques available in Boost.Asio to serialize work
    using strands, to manage the objects’ lifetimes used by asynchronous operations,
    how to start, interrupt, or cancel tasks, how to manage the event processing loop
    that the library uses, and how to handle signals sent by the OS.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了Boost.Asio中可用于使用 strands 序列化工作、管理异步操作使用的对象的生命周期、如何启动、中断或取消任务、如何管理库使用的处理事件循环，以及如何处理操作系统发送的信号的不同技术。
- en: Other concepts related to networking and coroutines were also introduced, and
    we also implemented some useful examples using this powerful library.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还介绍了与网络和协程相关的其他概念，并使用这个强大的库实现了一些有用的示例。
- en: All these concepts and examples allow us to acquire a deeper knowledge of how
    to manage asynchronous tasks in C++ and how an extensively used library works
    under the hood to achieve this goal.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些概念和示例都使我们能够更深入地了解如何在C++中管理异步任务，以及一个广泛使用的库是如何在底层实现这一目标的。
- en: In the next chapter, we will learn about another Boost library, Boost.Cobalt,
    that provides a rich and high-level interface to develop asynchronous software
    based in coroutines.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个 Boost 库，Boost.Cobalt，它提供了一个丰富且高级的接口，用于基于协程开发异步软件。
- en: Further reading
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Boost.Asio official site: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boost.Asio 官方网站: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio.html)'
- en: 'Boost.Asio reference: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boost.Asio 参考: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/reference.html)'
- en: 'Boost.Asio revision history: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boost.Asio 版本历史: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/history.html)'
- en: 'Boost.Asio BSD socket API: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Boost.Asio BSD 套接字 API: [https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html](https://www.boost.org/doc/libs/1_85_0/doc/html/boost_asio/overview/networking/bsd_sockets.html)'
- en: 'BSD socket API: [https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html](https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'BSD 套接字 API: [https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html](https://web.mit.edu/macdev/Development/MITSupportLib/SocketsLib/Documentation/sockets.html)'
- en: '*The Boost C++ Libraries, Boris* *Schälig* : [https://theboostcpplibraries.com/boost.asio](https://theboostcpplibraries.com/boost.asio)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost C++ 库, Boris* *Schälig* : [https://theboostcpplibraries.com/boost.asio](https://theboostcpplibraries.com/boost.asio)'
- en: '*Thinking Asynchronously: Designing Applications with Boost.Asio, Christopher*
    *Kohlhoff* : [https://www.youtube.com/watch?v=D-lTwGJRx0o](https://www.youtube.com/watch?v=D-lTwGJRx0o)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异步思维：使用 Boost.Asio 设计应用程序, Christopher* *Kohlhoff* : [https://www.youtube.com/watch?v=D-lTwGJRx0o](https://www.youtube.com/watch?v=D-lTwGJRx0o)'
- en: '*CppCon 2016: Asynchronous IO with Boost.Asio, Michael* *Caisse* : [https://www.youtube.com/watch?v=rwOv_tw2eA4](https://www.youtube.com/watch?v=rwOv_tw2eA4)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CppCon 2016: 使用 Boost.Asio 进行异步 I/O, Michael* *Caisse* : [https://www.youtube.com/watch?v=rwOv_tw2eA4](https://www.youtube.com/watch?v=rwOv_tw2eA4)'
- en: '*Pattern-Oriented Software Architecture – Patterns for Concurrent and Networked
    Objects* , *Volume 2* , D. Schmidt et al, Wiley, 2000'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向模式的软件架构 – 并发和网络对象模式* , *第2卷* , D. Schmidt et al, Wiley, 2000'
- en: '*Boost.Asio C++ Network Programming Cookbook* , Dmytro Radchuk, Packt Publishing,
    2016'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boost.Asio C++ 网络编程食谱* , Dmytro Radchuk, Packt Publishing, 2016'
- en: '*Proactor: An Object Behavioral Pattern for Demultiplexing and Dispatching
    handlers for Asynchronous events* , Irfan Pyarali, Tim Harrison, Douglas C Schmidt,
    Thomas D Jordan. 1997'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Proactor: 异步事件处理器的解复用和分发行为对象模式* , Irfan Pyarali, Tim Harrison, Douglas C Schmidt,
    Thomas D Jordan. 1997'
- en: '*Reactor: An Object Behavioral Pattern for Demultiplexing and Dispatching Handlers
    for Synchronous events* , Douglas C Schmidt, 1995'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*反应器：同步事件处理器的解复用和分发行为对象模式* , Douglas C Schmidt, 1995'
- en: '*Input/Output Completion* *Port* : [https://en.wikipedia.org/wiki/Input/output_completion_port](https://en.wikipedia.org/wiki/Input/output_completion_port)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入/输出完成* *端口* : [https://en.wikipedia.org/wiki/Input/output_completion_port](https://en.wikipedia.org/wiki/Input/output_completion_port)'
- en: '*kqueue* : [https://en.wikipedia.org/wiki/Kqueue](https://en.wikipedia.org/wiki/Kqueue)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kqueue* : [https://en.wikipedia.org/wiki/Kqueue](https://en.wikipedia.org/wiki/Kqueue)'
- en: '*epoll* : [https://en.wikipedia.org/wiki/Epoll](https://en.wikipedia.org/wiki/Epoll)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*epoll* : [https://en.wikipedia.org/wiki/Epoll](https://en.wikipedia.org/wiki/Epoll)'
