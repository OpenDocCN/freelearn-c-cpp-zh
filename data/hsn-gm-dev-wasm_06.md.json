["```cpp\nwhile(loop_forever) {\n    get_user_input();\n    move_game_objects();\n    collision_detection();\n    render_game_objects();\n    play_audio();\n}\n```", "```cpp\nemscripten_set_main_loop(game_loop, 0, 0);\n```", "```cpp\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <emscripten.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define SPRITE_FILE \"sprites/Franchise.png\"\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define MAX_VELOCITY 2.0\n```", "```cpp\nUint32 last_time;\nUint32 last_frame_time;\nUint32 current_time;\n```", "```cpp\nSDL_Window *window;\nSDL_Renderer *renderer;\nSDL_Rect dest = {.x = 160, .y = 100, .w = 16, .h = 16 };\nSDL_Texture *sprite_texture;\nSDL_Event event;\n```", "```cpp\nbool left_key_down = false;\nbool right_key_down = false;\nbool up_key_down = false;\nbool down_key_down = false;\n```", "```cpp\nfloat player_x = 160.0;\nfloat player_y = 100.0;\nfloat player_rotation = PI;\nfloat player_dx = 0.0;\nfloat player_dy = 1.0;\nfloat player_vx = 0.0;\nfloat player_vy = 0.0;\nfloat delta_time = 0.0;\n```", "```cpp\n\nvoid rotate_left() {\n    player_rotation -= delta_time;\n    if( player_rotation < 0.0 ) {\n        player_rotation += TWO_PI;\n    }\n    player_dx = sin(player_rotation);\n    player_dy = -cos(player_rotation);\n}\n\nvoid rotate_right() {\n    player_rotation += delta_time;\n    if( player_rotation >= TWO_PI ) {\n        player_rotation -= TWO_PI;\n    }\n    player_dx = sin(player_rotation);\n    player_dy = -cos(player_rotation);\n}\n```", "```cpp\n\nvoid accelerate() {\n    player_vx += player_dx * delta_time;\n    player_vy += player_dy * delta_time;\n}\n\nvoid decelerate() {\n    player_vx -= (player_dx * delta_time) / 2.0;\n    player_vy -= (player_dy * delta_time) / 2.0;\n}\n\nvoid cap_velocity() {\n    float vel = sqrt( player_vx * player_vx + player_vy * player_vy );\n    if( vel > MAX_VELOCITY ) {\n        player_vx /= vel;\n        player_vy /= vel;\n        player_vx *= MAX_VELOCITY;\n        player_vy *= MAX_VELOCITY;\n    }\n}\n```", "```cpp\n\nvoid move() {\n    current_time = SDL_GetTicks();\n    delta_time = (float)(current_time - last_time) / 1000.0;\n    last_time = current_time;\n\n    if( left_key_down ) {\n        rotate_left();\n    }\n    if( right_key_down ) {\n        rotate_right();\n    }\n    if( up_key_down ) {\n        accelerate();\n    }\n    if( down_key_down ) {\n        decelerate();\n    }\n    cap_velocity();\n\n    player_x += player_vx;\n\n    if( player_x > 320 ) {\n        player_x = -16;\n    }\n    else if( player_x < -16 ) {\n        player_x = 320;\n    }\n\n    player_y += player_vy;\n\n    if( player_y > 200 ) {\n        player_y = -16;\n    }\n    else if( player_y < -16 ) {\n        player_y = 200;\n    }\n} \n```", "```cpp\n\nvoid input() {\n    if( SDL_PollEvent( &event ) ){\n        switch( event.type ){\n            case SDL_KEYDOWN:\n                switch( event.key.keysym.sym ){\n                    case SDLK_LEFT:\n                        left_key_down = true;\n                        break;\n                    case SDLK_RIGHT:\n                        right_key_down = true;\n                        break;\n                    case SDLK_UP:\n                        up_key_down = true;\n                        break;\n                    case SDLK_DOWN:\n                        down_key_down = true;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            case SDL_KEYUP:\n                switch( event.key.keysym.sym ){\n                    case SDLK_LEFT:\n                        left_key_down = false;\n                        break;\n                    case SDLK_RIGHT:\n                        right_key_down = false;\n                        break;\n                    case SDLK_UP:\n                        up_key_down = false;\n                        break;\n                    case SDLK_DOWN:\n                        down_key_down = false;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n\n            default:\n                break;\n        }\n    }\n}\n```", "```cpp\nvoid render() {\n    SDL_RenderClear( renderer );\n\n    dest.x = player_x;\n    dest.y = player_y;\n\n    float degrees = (player_rotation / PI) * 180.0;\n    SDL_RenderCopyEx( renderer, sprite_texture,\n                        NULL, &dest,\n    degrees, NULL, SDL_FLIP_NONE );\n\n    SDL_RenderPresent( renderer );\n }\n```", "```cpp\nvoid game_loop() {\n    input();\n    move();\n    render();\n}\n```", "```cpp\nint main() {\n    char explosion_file_string[40];\n    SDL_Init( SDL_INIT_VIDEO );\n    SDL_CreateWindowAndRenderer( 320, 200, 0, &window, &renderer );\n    SDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\n    SDL_RenderClear( renderer );\n    SDL_Surface *temp_surface = IMG_Load( SPRITE_FILE );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return 0;\n    }\n\n    sprite_texture = SDL_CreateTextureFromSurface( renderer, \n                                                  temp_surface );\n    SDL_FreeSurface( temp_surface );\n    last_frame_time = last_time = SDL_GetTicks();\n\n    emscripten_set_main_loop(game_loop, 0, 0);\n    return 1;\n}\n```", "```cpp\nfloat player_x = 160.0;\nfloat player_y = 100.0;\nfloat player_rotation = PI;\nfloat player_dx = 0.0;\nfloat player_dy = 1.0;\nfloat player_vx = 0.0;\nfloat player_vy = 0.0;\n```", "```cpp\nvoid rotate_left() {\n    player_rotation -= delta_time;\n    if( player_rotation < 0.0 ) {\n        player_rotation += TWO_PI;\n    }\n    player_dx = sin(player_rotation);\n    player_dy = -cos(player_rotation);\n}\n\nvoid rotate_right() {\n    player_rotation += delta_time;\n    if( player_rotation >= TWO_PI ) {\n         player_rotation -= TWO_PI;\n    }\n    player_dx = sin(player_rotation);\n    player_dy = -cos(player_rotation);\n}\n```", "```cpp\nvoid accelerate() {\n    player_vx += player_dx * delta_time;\n    player_vy += player_dy * delta_time;\n}\n\nvoid decelerate() {\n    player_vx -= (player_dx * delta_time) / 2.0;\n    player_vy -= (player_dy * delta_time) / 2.0;\n}\n```", "```cpp\nvoid cap_velocity() {\n    float vel = sqrt( player_vx * player_vx + player_vy * player_vy );\n\n    if( vel > MAX_VELOCITY ) {\n        player_vx /= vel;\n        player_vy /= vel;\n        player_vx *= MAX_VELOCITY;\n        player_vy *= MAX_VELOCITY;\n     }\n}\n```", "```cpp\nvoid move() {\n    current_time = SDL_GetTicks();\n    delta_time = (float)(current_time - last_time) / 1000.0;\n    last_time = current_time;\n\n    if( left_key_down ) {\n        rotate_left();\n    }\n\n    if( right_key_down ) {\n        rotate_right();\n    }\n\n    if( up_key_down ) {\n        accelerate();\n    }\n\n    if( down_key_down ) {\n        decelerate();\n    }\n\n    cap_velocity();\n    player_x += player_vx;\n\n    if( player_x > 320 ) {\n         player_x = -16;\n     }\n    else if( player_x < -16 ) {\n        player_x = 320;\n    }\n    player_y += player_vy;\n\n    if( player_y > 200 ) {\n        player_y = -16;\n    }\n    else if( player_y < -16 ) {\n        player_y = 200;\n    }\n}\n```", "```cpp\n\nvoid input() {\n    if( SDL_PollEvent( &event ) ){\n        switch( event.type ){\n            case SDL_KEYDOWN:\n                switch( event.key.keysym.sym ){\n                    case SDLK_LEFT:\n                        left_key_down = true;\n                        break;\n                    case SDLK_RIGHT:\n                        right_key_down = true;\n                        break;\n                    case SDLK_UP:\n                        up_key_down = true;\n                        break;\n                    case SDLK_DOWN:\n                        down_key_down = true;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            case SDL_KEYUP:\n                switch( event.key.keysym.sym ){\n                    case SDLK_LEFT:\n                        left_key_down = false;\n                        break;\n                    case SDLK_RIGHT:\n                        right_key_down = false;\n                        break;\n                    case SDLK_UP:\n                        up_key_down = false;\n                        break;\n                    case SDLK_DOWN:\n                        down_key_down = false;\n                        break;\n                    default:\n                        break;\n                }\n                break;\n            default:\n                break;\n        }\n    }\n}\n```", "```cpp\nvoid render() {\n    SDL_RenderClear( renderer );\n    dest.x = player_x;\n    dest.y = player_y;\n    float degrees = (player_rotation / PI) * 180.0;\n    SDL_RenderCopyEx( renderer, sprite_texture,\n                        NULL, &dest,\n                        degrees, NULL, SDL_FLIP_NONE );\n    SDL_RenderPresent( renderer );\n}\n```", "```cpp\nvoid game_loop() {\n    input();\n    move();\n    render();\n}\n```", "```cpp\nemcc game_loop.c -o gameloop.html  --preload-file sprites -s NO_EXIT_RUNTIME=1 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s EXTRA_EXPORTED_RUNTIME_METHODS=\"['cwrap', 'ccall']\" -s USE_SDL=2\n```", "```cpp\n#ifndef __GAME_H__\n#define __GAME_H__#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <emscripten.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string>\n#include <vector>\n\n#define SPRITE_FILE \"sprites/Franchise.png\"\n#define MAX_VELOCITY 2.0\n#define PI 3.14159\n#define TWO_PI 6.28318\n\nextern Uint32 last_time;\nextern Uint32 last_frame_time;\nextern Uint32 current_time;\nextern SDL_Window *window;\nextern SDL_Renderer *renderer;\nextern SDL_Rect dest;\nextern SDL_Texture *sprite_texture;\nextern SDL_Event event;\nextern bool left_key_down;\nextern bool right_key_down;\nextern bool up_key_down;\nextern bool down_key_down;\nextern bool space_key_down;\nextern float delta_time;\nextern int diff_time;\n\nclass PlayerShip {\n    public:\n        float m_X;\n        float m_Y;\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        PlayerShip();\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n        void Move();\n        void Render();\n};\n\nextern PlayerShip player;\n#endif\n```", "```cpp\nextern Uint32 last_time;\nextern Uint32 last_frame_time;\nextern Uint32 current_time;\nextern SDL_Window *window;\nextern SDL_Renderer *renderer;\nextern SDL_Rect dest;\nextern SDL_Texture *sprite_texture;\nextern SDL_Event event;\nextern bool left_key_down;\nextern bool right_key_down;\nextern bool up_key_down;\nextern bool down_key_down;\nextern float delta_time;\n```", "```cpp\nclass PlayerShip {\n    public:\n        float m_X;\n        float m_Y;\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        PlayerShip();\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n        void Move();\n        void Render();\n };\n\nextern PlayerShip player;\n```", "```cpp\nclass Projectile {\n    public:\n        const char* c_SpriteFile = \"sprites/Projectile.png\";\n        const int c_Width = 8;\n        const int c_Height = 8;\n        SDL_Texture *m_SpriteTexture;\n        bool m_Active;\n        const float c_Velocity = 6.0;\n        const float c_AliveTime = 2000;\n        float m_TTL;\n        float m_X;\n        float m_Y;\n        float m_VX;\n        float m_VY;\n\n        Projectile();\n        void Move();\n        void Render();\n        void Launch(float x, float y, float dx, float dy);\n};\n\nclass ProjectilePool {\n    public:\n        std::vector<Projectile*> m_ProjectileList;\n        ProjectilePool();\n        ~ProjectilePool();\n        void MoveProjectiles();\n        void RenderProjectiles();\n        Projectile* GetFreeProjectile();\n};\n\nextern ProjectilePool* projectile_pool; \n```", "```cpp\npublic:\n    const char* c_SpriteFile = \"sprites/Franchise.png\";\n    const Uint32 c_MinLaunchTime = 300;\n    const int c_Width = 16;\n    const int c_Height = 16;\n    Uint32 m_LastLaunchTime;\n    SDL_Texture *m_SpriteTexture;\n```", "```cpp\nclass Projectile {\n    public:\n        const char* c_SpriteFile = \"sprites/Projectile.png\";\n        const int c_Width = 8;\n        const int c_Height = 8;\n        const float c_Velocity = 6.0;\n        const float c_AliveTime = 2000;\n\n        SDL_Texture *m_SpriteTexture;\n        bool m_Active;\n        float m_TTL;\n        float m_X;\n        float m_Y;\n        float m_VX;\n        float m_VY;\n\n        Projectile();\n        void Move();\n        void Render();\n        void Launch(float x, float y, float dx, float dy);\n};\n```", "```cpp\nclass Projectile {\n    public:\n        const char* c_SpriteFile = \"sprites/Projectile.png\";\n        const int c_Width = 8;\n        const int c_Height = 8;\n```", "```cpp\nProjectile();\nvoid Move();\nvoid Render();\nvoid Launch(float x, float y, float dx, float dy);\n```", "```cpp\nclass ProjectilePool {\n    public:\n        std::vector<Projectile*> m_ProjectileList;\n        ProjectilePool();\n        ~ProjectilePool();\n        void MoveProjectiles();\n        void RenderProjectiles();\n        Projectile* GetFreeProjectile();\n};\n```", "```cpp\n#include \"game.hpp\"\n\nProjectile::Projectile() {\n    m_Active = false;\n    m_X = 0.0;\n    m_Y = 0.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    SDL_FreeSurface( temp_surface );\n}\n\nvoid Projectile::Move() {\n    m_X += m_VX;\n    m_Y += m_VY;\n    m_TTL -= diff_time;\n\n    if( m_TTL <= 0 ) {\n        m_Active = false;\n        m_TTL = 0;\n    }\n}\n\nvoid Projectile::Render() {\n    dest.x = m_X;\n    dest.y = m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    int return_val = SDL_RenderCopy( renderer, m_SpriteTexture,\n                                     NULL, &dest );\n    if( return_val != 0 ) {\n        printf(\"SDL_Init failed: %s\\n\", SDL_GetError());\n    }\n}\n\nvoid Projectile::Launch(float x, float y, float dx, float dy) {\n    m_X = x;\n    m_Y = y;\n    m_VX = c_Velocity * dx;\n    m_VY = c_Velocity * dy;\n    m_TTL = c_AliveTime;\n    m_Active = true;\n}\n```", "```cpp\nProjectile::Projectile() {\n    m_Active = false;\n    m_X = 0.0;\n    m_Y = 0.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nvoid Projectile::Move() {\n    m_X += m_VX;\n    m_Y += m_VY;\n    m_TTL -= diff_time;\n    if( m_TTL <= 0 ) {\n        m_Active = false;\n        m_TTL = 0;\n    }\n}\n```", "```cpp\nvoid Projectile::Render() {\n    dest.x = m_X;\n    dest.y = m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    int return_val = SDL_RenderCopy( renderer, m_SpriteTexture,\n                                    NULL, &dest );\n\n    if( return_val != 0 ) {\n        printf(\"SDL_Init failed: %s\\n\", SDL_GetError());\n    }\n}\n```", "```cpp\nvoid Projectile::Launch(float x, float y, float dx, float dy) {\n    m_X = x;\n    m_Y = y;\n    m_VX = c_Velocity * dx;\n    m_VY = c_Velocity * dy;\n    m_TTL = c_AliveTime;\n    m_Active = true;\n}\n```", "```cpp\n#include \"game.hpp\"\n\nProjectilePool::ProjectilePool() {\n    for( int i = 0; i < 10; i++ ) {\n        m_ProjectileList.push_back( new Projectile() );\n    }\n}\n\nProjectilePool::~ProjectilePool() {\n    m_ProjectileList.clear();\n}\n\nvoid ProjectilePool::MoveProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Move();\n        }\n    }\n}\n\nvoid ProjectilePool::RenderProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Render();\n         }\n    }\n}\n\nProjectile* ProjectilePool::GetFreeProjectile() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n        if( projectile->m_Active == false ) {\n            return projectile;\n        }\n    }\n    return NULL;\n}\n```", "```cpp\nenum FSM_STUB {\n    SHOOT = 0,\n    TURN_LEFT = 1,\n    TURN_RIGHT = 2,\n    ACCELERATE = 3,\n    DECELERATE = 4\n};\n\nclass EnemyShip {\n    public:\n        const char* c_SpriteFile = \"sprites/BirdOfAnger.png\";\n        const Uint32 c_MinLaunchTime = 300;\n        const int c_Width = 16;\n        const int c_Height = 16;\n        const int c_AIStateTime = 2000;\n\n        Uint32 m_LastLaunchTime;\n        SDL_Texture *m_SpriteTexture;\n\n        FSM_STUB m_AIState;\n        int m_AIStateTTL;\n\n        float m_X;\n        float m_Y;\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        EnemyShip();\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n        void Move();\n        void Render();\n        void AIStub();\n};\n```", "```cpp\n#include \"game.hpp\"\nEnemyShip::EnemyShip() {\n m_X = 60.0;\n    m_Y = 50.0;\n    m_Rotation = PI;\n    m_DX = 0.0;\n    m_DY = 1.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n    m_LastLaunchTime = current_time;\n\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship surface\\n\");\n    }\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship texture\\n\");\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nvoid EnemyShip::RotateLeft() {\n    m_Rotation -= delta_time;\n\n    if( m_Rotation < 0.0 ) {\n        m_Rotation += TWO_PI;\n    }\n    m_DX = sin(m_Rotation);\n    m_DY = -cos(m_Rotation);\n}\nvoid EnemyShip::RotateRight() {\n    m_Rotation += delta_time;\n\n    if( m_Rotation >= TWO_PI ) {\n        m_Rotation -= TWO_PI;\n    }\n    m_DX = sin(m_Rotation);\n    m_DY = -cos(m_Rotation);\n}\n```", "```cpp\nvoid EnemyShip::Accelerate() {\n    m_VX += m_DX * delta_time;\n    m_VY += m_DY * delta_time;\n}\n\nvoid EnemyShip::Decelerate() {\n    m_VX -= (m_DX * delta_time) / 2.0;\n    m_VY -= (m_DY * delta_time) / 2.0;\n}\n\nvoid EnemyShip::CapVelocity() {\n    float vel = sqrt( m_VX * m_VX + m_VY * m_VY );\n\n    if( vel > MAX_VELOCITY ) {\n        m_VX /= vel;\n        m_VY /= vel;\n\n        m_VX *= MAX_VELOCITY;\n        m_VY *= MAX_VELOCITY;\n    }\n}\n```", "```cpp\nvoid EnemyShip::Render() {\n    dest.x = (int)m_X;\n    dest.y = (int)m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    float degrees = (m_Rotation / PI) * 180.0;\n\n    int return_code = SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                                        NULL, &dest,\n                                        degrees, NULL, SDL_FLIP_NONE );\n\n if( return_code != 0 ) {\n printf(\"failed to render image: %s\\n\", IMG_GetError() );\n }\n}\n\n```", "```cpp\nvoid EnemyShip::Move() {\n     AIStub();\n\n if( m_AIState == TURN_LEFT ) {\n     RotateLeft();\n }\n\n if( m_AIState == TURN_RIGHT ) {\n     RotateRight();\n }\n\n if( m_AIState == ACCELERATE ) {\n     Accelerate();\n }\n\n if( m_AIState == DECELERATE ) {\n     Decelerate();\n }\n\n CapVelocity();\n m_X += m_VX;\n\n if( m_X > 320 ) {\n     m_X = -16;\n }\n else if( m_X < -16 ) {\n     m_X = 320;\n }\n\n m_Y += m_VY;\n\n if( m_Y > 200 ) {\n     m_Y = -16;\n }\n else if( m_Y < -16 ) {\n     m_Y = 200;\n }\n\n if( m_AIState == SHOOT ) {\n     Projectile* projectile;\n     if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n         m_LastLaunchTime = current_time;\n         projectile = projectile_pool->GetFreeProjectile();\n\n         if( projectile != NULL ) {\n             projectile->Launch( m_X, m_Y, m_DX, m_DY );\n             }\n         }\n     }\n}\n\nvoid EnemyShip::AIStub() {\n     m_AIStateTTL -= diff_time;\n     if( m_AIStateTTL <= 0 ) {\n         // for now get a random AI state.\n         m_AIState = (FSM_STUB)(rand() % 5);\n         m_AIStateTTL = c_AIStateTime;\n     }\n}\n```", "```cpp\nvoid EnemyShip::AIStub() {\n    m_AIStateTTL -= diff_time;\n\n    if( m_AIStateTTL <= 0 ) {\n        // for now get a random AI state.\n        m_AIState = (FSM_STUB)(rand() % 5);\n        m_AIStateTTL = c_AIStateTime;\n    }\n}\n```", "```cpp\nvoid EnemyShip::Move() {\n    AIStub();\n\n    if( m_AIState == TURN_LEFT ) {\n        RotateLeft();\n    }\n    if( m_AIState == TURN_RIGHT ) {\n        RotateRight();\n    }\n    if( m_AIState == ACCELERATE ) {\n        Accelerate();\n    }\n    if( m_AIState == DECELERATE ) {\n        Decelerate();\n    }\n    CapVelocity();\n     m_X += m_VX;\n\n    if( m_X > 320 ) {\n        m_X = -16;\n    }\n    else if( m_X < -16 ) {\n        m_X = 320;\n    }\n    m_Y += m_VY;\n\n    if( m_Y > 200 ) {\n        m_Y = -16;\n    }\n    else if( m_Y < -16 ) {\n        m_Y = 200;\n    }\n\n    if( m_AIState == SHOOT ) {\n        Projectile* projectile;\n        if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n            m_LastLaunchTime = current_time;\n            projectile = projectile_pool->GetFreeProjectile();\n\n            if( projectile != NULL ) {\n                projectile->Launch( m_X, m_Y, m_DX, m_DY );\n            }\n        }\n    }\n}\n```", "```cpp\nem++ main.cpp enemy_ship.cpp player_ship.cpp projectile.cpp projectile_pool.cpp -std=c++17 --preload-file sprites -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -o game_objects.html\n```"]